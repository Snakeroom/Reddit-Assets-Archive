// https://www.redditstatic.com/desktop2x/Governance~Reddit.386de343eff29d320f5e.js
// Retrieved at 5/26/2020, 4:30:05 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~Reddit"], {
		"./assets/fonts/NotoMono/font.less": function(e, t, n) {},
		"./src/graphql/operations/AllUserMultireddits.json": function(e) {
			e.exports = JSON.parse('{"id":"0a5fcd52ba67"}')
		},
		"./src/graphql/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/graphql/operations/CommunityAwardsBlacklistStatus.json": function(e) {
			e.exports = JSON.parse('{"id":"7af03aa4c24e"}')
		},
		"./src/graphql/operations/CreateCommunityAward.json": function(e) {
			e.exports = JSON.parse('{"id":"38852e4f82b0"}')
		},
		"./src/graphql/operations/CreateGlobalAward.json": function(e) {
			e.exports = JSON.parse('{"id":"c11324579f8c"}')
		},
		"./src/graphql/operations/CreateModAward.json": function(e) {
			e.exports = JSON.parse('{"id":"a04c85b4e964"}')
		},
		"./src/graphql/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/graphql/operations/DeleteAward.json": function(e) {
			e.exports = JSON.parse('{"id":"4d31f6356d57"}')
		},
		"./src/graphql/operations/DisableAward.json": function(e) {
			e.exports = JSON.parse('{"id":"5e453976052b"}')
		},
		"./src/graphql/operations/ExperimentVariants.json": function(e) {
			e.exports = JSON.parse('{"id":"34910619f1e9"}')
		},
		"./src/graphql/operations/FetchBlockedRedditorsInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"1e9183c00f76"}')
		},
		"./src/graphql/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/graphql/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"c03afa35c319"}')
		},
		"./src/graphql/operations/Frontpage.json": function(e) {
			e.exports = JSON.parse('{"id":"946f7377e05e"}')
		},
		"./src/graphql/operations/GetPostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"4231b7734ef9"}')
		},
		"./src/graphql/operations/GildComment.json": function(e) {
			e.exports = JSON.parse('{"id":"c25f21e6351f"}')
		},
		"./src/graphql/operations/GildPost.json": function(e) {
			e.exports = JSON.parse('{"id":"496275fd4bb6"}')
		},
		"./src/graphql/operations/GlobalAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"1eed20c0ac09"}')
		},
		"./src/graphql/operations/ManageableAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"74d6c7e7c9cb"}')
		},
		"./src/graphql/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(e) {
			e.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/graphql/operations/ModeratedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"3c148c0b5100"}')
		},
		"./src/graphql/operations/MultiredditListing.json": function(e) {
			e.exports = JSON.parse('{"id":"8e1d1ebfc136"}')
		},
		"./src/graphql/operations/OtherDiscussions.json": function(e) {
			e.exports = JSON.parse('{"id":"717c239ddb6a"}')
		},
		"./src/graphql/operations/PostFeedAndOtherDiscussions.json": function(e) {
			e.exports = JSON.parse('{"id":"64131f4665de"}')
		},
		"./src/graphql/operations/ProfileTrophies.json": function(e) {
			e.exports = JSON.parse('{"id":"3c59e5ed6f14"}')
		},
		"./src/graphql/operations/RedditorKarma.json": function(e) {
			e.exports = JSON.parse('{"id":"db6eb1356b13"}')
		},
		"./src/graphql/operations/RedditorMultireddits.json": function(e) {
			e.exports = JSON.parse('{"id":"3d04e2bb92b5"}')
		},
		"./src/graphql/operations/RichTextPostContent.json": function(e) {
			e.exports = JSON.parse('{"id":"fc24b7b690ad"}')
		},
		"./src/graphql/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"7d0ee544a263"}')
		},
		"./src/graphql/operations/SubredditGeoRecommendationViaFocusVertical.json": function(e) {
			e.exports = JSON.parse('{"id":"9aa1f8d54079"}')
		},
		"./src/graphql/operations/SubredditLinks.json": function(e) {
			e.exports = JSON.parse('{"id":"e74dba05ccd0"}')
		},
		"./src/graphql/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"917d29682a4d"}')
		},
		"./src/graphql/operations/SubredditPostFlairStyleTemplates.json": function(e) {
			e.exports = JSON.parse('{"id":"9a87d9b91dc4"}')
		},
		"./src/graphql/operations/SubredditPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"e647e1d0187f"}')
		},
		"./src/graphql/operations/SubredditRecommendations.json": function(e) {
			e.exports = JSON.parse('{"id":"43275c35dbb6"}')
		},
		"./src/graphql/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"0df127946e72"}')
		},
		"./src/graphql/operations/SubredditStyles.json": function(e) {
			e.exports = JSON.parse('{"id":"8d0e34deaa32"}')
		},
		"./src/graphql/operations/SubredditTopContent.json": function(e) {
			e.exports = JSON.parse('{"id":"feadbc62961a"}')
		},
		"./src/graphql/operations/SubredditTypeaheadSearch.json": function(e) {
			e.exports = JSON.parse('{"id":"20edc5ee12df"}')
		},
		"./src/graphql/operations/SubredditsPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"3b630128c0db"}')
		},
		"./src/graphql/operations/TopicBySlug.json": function(e) {
			e.exports = JSON.parse('{"id":"3127660a5599"}')
		},
		"./src/graphql/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/graphql/operations/UpdateSubredditPrimaryTag.json": function(e) {
			e.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/graphql/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/graphql/operations/UsableAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"6c18d5bc8a2d"}')
		},
		"./src/graphql/operations/UsableAwardsForProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"cde891369be8"}')
		},
		"./src/graphql/operations/UserDataExportEligibility.json": function(e) {
			e.exports = JSON.parse('{"id":"3817c69d7a39"}')
		},
		"./src/lib/addAllowQuarantinedParam/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				allow_quarantined: !0
			})
		},
		"./src/lib/assertNever.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				throw new Error("Unexpected object: ".concat(e))
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "custom"
		},
		"./src/lib/filterQueryParams/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				a = n.n(o);
			t.a = (e, t) => {
				const n = a.a.parse(e, !0);
				return n.search = void 0, n.query = Object.assign({}, r()(n.query, t)), a.a.format(n)
			}
		},
		"./src/lib/forceHttps/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = function(e) {
				return e.startsWith("http") ? e.replace(/^http:\/\//i, "https://") : "https://".concat(e)
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/app/strings/index.ts"),
				r = n("./src/app/strings/sources/error.js");

			function o(e, t, n) {
				return t ? t.fields && t.fields.length ? t.fields.map(e => e.msg).join(", ") : t.type && r.a[t.type] ? Object(s.a)(e, "error.".concat(t.type)) : 401 === n ? Object(s.a)(e, "error.authentication") : Object(s.a)(e, "error.generic") : ""
			}
		},
		"./src/lib/isEqualWithoutKey/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			t.a = (e, t) => {
				const {
					key: n
				} = e, s = o(e, ["key"]), {
					key: a
				} = t, c = o(t, ["key"]);
				return r()(s, c)
			}
		},
		"./src/lib/makeCollectionCommentsPageKey/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			t.a = function(e, t, n) {
				let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
					r = "collectionCommentsPage--[collection:'".concat(e, "']");
				return t && (r += "--[post:'".concat(t, "']")), n && (r += "--[rootComment:'".concat(n, "']")), s && (s.sort && s.hasSortParam && (r += "--[sort:'".concat(s.sort, "']")), s.context && (r += "--[context:".concat(s.context, "]")), s.depth && (r += "--[depth:".concat(s.depth, "]"))), r
			}
		},
		"./src/lib/makeDraftKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/PostDraft/index.ts");

			function r(e, t) {
				return "".concat(s.c[e], "_").concat(t)
			}
		},
		"./src/lib/makeGqlRequest/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./src/lib/addQueryParams/index.ts")),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/constants/headers.ts"),
				i = n("./src/lib/env/index.ts"),
				d = n("./src/lib/logs/errors.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/makeRequest/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/customMiddleware/gqlContext.ts"),
				f = n("./src/reddit/singleton/tracing/index.ts");
			const m = (e, t) => {
					const n = Object.assign({}, t, {
							headers: Object.assign({}, t.headers || {}, e.headers)
						}),
						s = Object(i.b)() ? [b.a] : [b.a, c.c];
					n.headers = r()(n.headers, s);
					const a = f.b.getTracingHeaders();
					return n.headers = Object.assign({}, n.headers, a), n.endpoint = (e => Object(o.a)(e, {
						request_timestamp: Date.now().toString()
					}))(n.endpoint), n
				},
				O = (e, t, n) => {
					const {
						errors: s
					} = n.body;
					s && s.length && Object(d.a)({
						context: e,
						endpoint: t.endpoint,
						error: s.map(e => e.message).join("\n"),
						type: a.p.GQL
					})
				};

			function g(e, t, n) {
				const s = n && n.traceRequestName ? n.traceRequestName : "gql_api_call";
				return f.b.recordRpcSpanAsync(s, async () => {
					const s = Object(p.b)(e),
						r = Object.assign({}, n ? Object.assign({}, n) : {}, {
							data: t,
							method: a.ab.POST,
							endpoint: s.apiUrl,
							type: "json"
						}),
						o = m(s, r);
					return s.onBeforeRequest(o), Object(l.b)(o).then(e => (s.onResponse(e, {
						allowSetEmptyLoid: t.allowSetEmptyLoid
					}), !e.ok && (Object(u.d)(s, r, e), e.status >= 400) ? Object.assign({}, e, {
						error: {
							type: Object(u.e)(e.status)
						}
					}) : e.body.errors ? (O(s, Object.assign({}, r, {
						operation: t.id || t.query
					}), e), Object.assign({}, e, {
						ok: !1,
						error: {
							type: a.C.BAD_REQUEST,
							fields: e.body.errors.map(e => ({
								msg: e.message || ""
							}))
						}
					})) : (e.ok && e.body, Object.assign({}, e, {
						error: null
					}))))
				})
			}
		},
		"./src/lib/makeOverviewConversationsItemKey/index.ts": function(e, t, n) {
			"use strict";
			t.a = (e, t) => {
				return "overviewConversations--[profile:'".concat(t, "']--[post:'").concat(e, "']")
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += "--[draftId:".concat(e.draftId, "]")), t
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/makeSearchKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s, r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/parameters.ts");
			! function(e) {
				e.Trending = "trending", e.PromotedTrend = "promoted_trend"
			}(s || (s = {}));
			const a = e => {
					return c(e).join(",")
				},
				c = e => {
					let t;
					return "string" == typeof e ? t = decodeURIComponent(e).split(",").filter(r.Zb).sort() : Array.isArray(e) && (t = e.filter(r.Zb).sort()), t && 0 !== t.length || (t = [r.Kb.Posts, r.Kb.Subreddits, r.Kb.Users]), t
				},
				i = new Set(["f", "n", "0"]),
				d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
					const t = e.toLowerCase();
					return !(0 === t.length || "off" === t || i.has(t[0]))
				},
				u = e => e ? "1" : "",
				l = e => {
					const t = e.sort && Object(r.Yb)(e.sort) ? e.sort : r.Ab,
						n = e.t && r.Ub.has(e.t) ? e.t : r.Bb,
						s = c(e.type),
						a = {
							ad: e.ad,
							q: e.q,
							sort: t,
							t: n,
							type: s
						};
					return void 0 !== e.include_over_18 && (a.include_over_18 = u(d(e.include_over_18))), void 0 !== e.restrict_sr && (a.restrict_sr = u(d(e.restrict_sr))), e.is_multi && (a.is_multi = u(d(e.is_multi))), e.category && (a.category = e.category), e[o.b] && (a.category_name = e.category_name), e[o.s] && (a.source = e.source), a
				};
			t.b = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
					s = e || "!";
				return t && (s = "".concat(s, "--[user:").concat(t, "]")), void 0 !== n.include_over_18 && (s = "".concat(s, "--[include_over_18:").concat(n.include_over_18, "]")), n.q && (s = "".concat(s, "--[q:").concat(n.q, "]")), n.restrict_sr && (s = "".concat(s, "--[restrict_sr:").concat(n.restrict_sr, "]")), n.sort && (s = "".concat(s, "--[sort:").concat(n.sort, "]")), n.t && (s = "".concat(s, "--[t:").concat(n.t, "]")), n.category && (s = "".concat(s, "--[c:").concat(n.category, "]")), n.type && (s = "".concat(s, "--[type:").concat(a(n.type), "]")), s.toLowerCase()
			}
		},
		"./src/lib/omitKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var r = 0;
					for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
				}
				return n
			};

			function r(e, t) {
				if (t in e) {
					const n = t;
					e[n];
					return s(e, ["symbol" == typeof n ? n : n + ""])
				}
				return e
			}
		},
		"./src/lib/timezone/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.split.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/PostCreationForm/index.ts");
			const o = "America/Los_Angeles",
				a = () => {
					let e;
					try {
						e = Intl.DateTimeFormat().resolvedOptions().timeZone
					} catch (t) {}
					return "Asia/Calcutta" === e && (e = "Asia/Kolkata"), e || void 0
				},
				c = e => {
					const t = Math.abs(e),
						n = t % 60,
						s = e > 0 ? "-" : "+",
						r = ("0" + Math.floor(t / 60)).slice(-2),
						o = ("0" + n).slice(-2);
					return "".concat(s).concat(r, ":").concat(o)
				},
				i = (e, t) => {
					const n = t || Date.now(),
						r = {
							year: "numeric",
							month: "numeric",
							day: "numeric",
							hour: "numeric",
							minute: "numeric",
							second: "numeric",
							timeZoneName: "short",
							hour12: !1,
							timeZone: e
						};
					let o = "";
					try {
						o = new Intl.DateTimeFormat("en-US", r).format(new Date(n))
					} catch (g) {
						return
					}
					const [a, c, i] = o.replace(", ", " ").split(" "), [d, u, l] = a.trim().split("/").map(Number), [b, p, f] = c.trim().split(":").map(Number), m = Date.UTC(l, d - 1, u, b, p, f), O = new Date(n).setMilliseconds(0) - m;
					return {
						abbreviation: i,
						offset: Math.round(O / s.bb)
					}
				},
				d = e => {
					const t = e.slice(0, 19),
						[n, s] = t.split("T"),
						[r, o, a] = n.split("-").map(Number),
						[c, i, d = 0] = s.split(":").map(Number);
					return new Date(r, o - 1, a, c, i, d)
				},
				u = e => {
					const t = new Date(e);
					return t.setMinutes(t.getMinutes() - t.getTimezoneOffset()), t.toISOString().slice(0, 16)
				},
				l = e => {
					if (e && e.eventInfo) {
						const {
							eventStart: t,
							eventEnd: n
						} = e.eventInfo;
						return {
							startDate: u(new Date(t * s.Cb)),
							endDate: u(new Date(n * s.Cb)),
							submitTime: r.i.Now,
							timezoneName: a() || o
						}
					}
				}
		},
		"./src/lib/uploadToS3/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/lib/makeRequest/index.ts");
			const a = (e, t) => {
				const n = new FormData;
				return t.fields.forEach(e => {
					e.value && n.append(e.name, e.value)
				}), n.append("file", e), n
			};
			t.a = async (e, t, c) => {
				const i = (() => Object(r.a)(() => n.e("vendors~xml2js").then(n.t.bind(null, "./node_modules/xml2js/lib/xml2js.js", 7))).then(e => e.default))(),
					d = await Object(o.b)({
						data: a(e, t),
						endpoint: t.action,
						method: s.ab.POST,
						type: null,
						setup: c
					});
				if ("string" != typeof d.body) return d;
				try {
					(await i).parseString(d.body, (e, t) => {
						d.body = t
					})
				} catch (u) {
					d.body = u
				}
				return d
			}
		},
		"./src/reddit/actions/ads/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			}));
			const s = "AD_BRAND_SAFETY_STATUS_RECEIVED",
				r = "FETCH_COMMENTS_PAGE_ADS_COMPLETED",
				o = "FETCH_COMMENTS_PAGE_ADS_FAILED",
				a = "FETCH_SIDEBAR_PROMOTED_POSTS_COMPLETED",
				c = "FETCH_SIDEBAR_PROMOTED_POSTS_FAILED",
				i = "REFRESH_SIDEBAR_PROMOTED_POST_COMPLETED",
				d = "REFRESH_SIDEBAR_PROMOTED_POST_FAILED",
				u = "RESET_SIDEBAR_PROMOTED_POSTS"
		},
		"./src/reddit/actions/ads/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return m
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "a", (function() {
				return I
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/config.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts");
			const c = async (e, t, n) => {
				const s = {
					count: t
				};
				return n && (s.subreddit = n), Object(a.b)(e, {
					type: "json",
					endpoint: "".concat(r.a.gatewayUrl, "/desktopapi/v1/sidebar_ads"),
					method: o.ab.POST,
					data: s
				})
			};
			var i = n("./src/reddit/helpers/adCount/index.ts"),
				d = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				u = n("./src/reddit/selectors/brandSafety.ts"),
				l = n("./src/reddit/selectors/platform.ts"),
				b = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/actions/ads/constants.ts");
			const f = Object(s.a)(p.a),
				m = e => async (t, n) => {
					const s = n();
					Object(u.c)(s) && Object(u.d)(s) === e.isViewSafe || t(f(e))
				}, O = Object(s.a)(p.d), g = Object(s.a)(p.e), _ = Object(s.a)(p.f), y = Object(s.a)(p.g), j = (Object(s.a)(p.h), Object(s.a)(p.b)), h = (Object(s.a)(p.c), e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = Object(i.b)(o, e),
						u = a.length;
					if (0 === u) return;
					switch (e) {
						case d.a.COMMENTS:
						case d.a.COMMENTS_OVERLAY:
							if (!Object(l.m)(o, {
									page: o.platform.currentPage
								})) return;
							break;
						case d.a.FRONTPAGE:
						case d.a.MULTIREDDIT:
						case d.a.SEARCH_RESULTS:
						case d.a.SUBREDDIT: {
							const e = o.listings.activeKey,
								t = Object(b.U)(o, {
									listingKey: e
								});
							if (!t || !t.length) return;
							break
						}
						default:
							return void 0
					}
					const p = Object(l.e)(o);
					let f;
					if ((f = p ? await c(r(), u, p) : await c(r(), u)).body && f.body.length) {
						const e = f.body,
							n = {};
						for (let t = 0; t < e.length; t++) n[a[t]] = e[t];
						t(O(n))
					} else t(g(f.error))
				}), E = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = await c(r(), 1);
					o.body && o.body.length ? t(_({
						[e]: o.body[0]
					})) : t(y(o.error))
				}, I = e => async (t, n, s) => {
					let {
						apiContext: c
					} = s;
					const i = Object(l.e)(n()),
						d = await (async (e, t, n, s) => {
							const c = {
								count: t,
								subreddit: s,
								post_id: n
							};
							return Object(a.b)(e, {
								type: "json",
								endpoint: "".concat(r.a.gatewayUrl, "/desktopapi/v1/comments_page_ads"),
								method: o.ab.POST,
								data: c
							})
						})(c(), 1, e, i);
					if (d.body && d.body.length) return t(j(d.body)), d.body[0].id;
					t(g(d.error))
				}
		},
		"./src/reddit/actions/apiRequestHeaders.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "API_REQUEST_HEADERS__set";
			Object(s.a)(r)
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				a = "API_REQUEST_STATE__COMPLETED",
				c = "API_REQUEST_STATE__FAILED",
				i = "API_REQUEST_STATE__RELEASED";

			function d(e) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: e
					}
				}
			}

			function u(e) {
				return {
					type: a,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: e
					}
				}
			}

			function l(e, t) {
				return {
					type: c,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const b = Object(s.a)(i)
		},
		"./src/reddit/actions/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "IN_CONTEXT_AUTHOR_FLAIR_UPDATED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/badge.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "m", (function() {
				return T
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/governance/errorToast.ts"),
				o = n("./src/reddit/endpoints/governance/badges.ts");
			const a = "BADGE__BADGE_MODAL_OPENED",
				c = "BADGE__BADGE_APPLICATION_SUCCESS",
				i = "BADGE__BADGE_APPLICATION_FAILURE",
				d = "BADGE__SUBREDDIT_BADGES_FETCH_SUCCESS",
				u = "BADGE__SUBREDDIT_BADGES_FETCH_FAILURE",
				l = "BADGE__SUBREDDIT_BADGES_FETCH_PENDING",
				b = "BADGE__USER_BADGES_FETCH_SUCCESS",
				p = "BADGE__USER_BADGES_FETCH_FAILURE",
				f = "BADGE__USER_BADGES_FETCH_PENDING",
				m = Object(s.a)(a),
				O = Object(s.a)(c),
				g = Object(s.a)(i),
				_ = (Object(s.a)("BADGE__BADGE_APPLICATION_PENDING"), Object(s.a)(d)),
				y = Object(s.a)(u),
				j = Object(s.a)(l),
				h = Object(s.a)(b),
				E = Object(s.a)(p),
				I = Object(s.a)(f),
				v = e => {
					let {
						badgeIds: t,
						subredditId: n
					} = e;
					return async (e, s, a) => {
						let {
							apiContext: c
						} = a;
						const i = s(),
							d = i.user.account;
						if (d) {
							const s = (i.users.appliedBadges[d.id] || {})[n] || [],
								a = t.length ? t[0] : s[0],
								u = !!t.length;
							e(O({
								badgeIds: t,
								subredditId: n,
								userId: d.id
							}));
							const l = await Object(o.a)(c(), n, a, u);
							l.ok || (e(g({
								badgeIds: t,
								subredditId: n,
								error: l.error,
								previousBadgeIds: s,
								userId: d.id
							})), Object(r.a)(e, l.error))
						}
					}
				},
				S = e => {
					let {
						subredditId: t,
						userIds: n
					} = e;
					return async (e, s, r) => {
						let {
							apiContext: a
						} = r;
						e(j({
							subredditId: t
						}));
						const c = await Object(o.b)(a(), t, n);
						c.ok ? e(_(Object.assign({}, c.body, {
							subredditId: t
						}))) : e(y({
							subredditId: t,
							error: c.error
						}))
					}
				},
				T = e => {
					let {
						subredditId: t
					} = e;
					return async (e, n, s) => {
						let {
							apiContext: r
						} = s;
						const a = n().user.account;
						if (a) {
							e(I({
								subredditId: t
							}));
							const n = await Object(o.c)(r(), t, a.id);
							n.ok ? e(h(Object.assign({}, n.body, {
								subredditId: t
							}))) : e(E({
								subredditId: t,
								error: n.error
							}))
						}
					}
				}
		},
		"./src/reddit/actions/blockedRedditors.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "g", (function() {
				return _
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/graphql/operations/FetchBlockedRedditorsInfo.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			const a = (e, t) => Object(o.a)(e, Object.assign({}, r, {
				variables: t
			}), {
				traceRequestName: "get_blocked_redditors_info"
			});
			var c = n("./src/reddit/selectors/blockedRedditors.ts");
			const i = "BLOCKED_REDDITORS_LIST__ADD",
				d = "BLOCKED_REDDITORS_LIST__REMOVE",
				u = "BLOCKED_REDDITORS_LIST__FAILED",
				l = "BLOCKED_REDDITORS_LIST__LOADED",
				b = "BLOCKED_REDDITORS_LIST__PENDING",
				p = Object(s.a)(i),
				f = Object(s.a)(d),
				m = Object(s.a)(u),
				O = Object(s.a)(l),
				g = Object(s.a)(b),
				_ = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t(),
						o = Object(c.a)(r);
					if (Object(c.b)(r) || o.timestamp && Date.now() - o.timestamp < 36e6) return;
					let i = !1,
						d = "";
					do {
						e(g());
						const t = {
								after: d,
								pageSize: 100
							},
							n = await a(s(), t);
						if (n && n.ok) {
							const {
								data: {
									identity: t
								}
							} = n.body;
							if (t && t.blockedRedditorsInfo) {
								const {
									pageInfo: n,
									edges: s
								} = t.blockedRedditorsInfo;
								if (e(O(s.map(e => e.node.id))), n) {
									const {
										hasNextPage: e,
										endCursor: t
									} = n;
									i = e, d = t || ""
								}
							} else i = !1
						} else {
							i = !1;
							const t = n.error ? n.error.type : "unknown error";
							e(m({
								message: t
							}))
						}
					} while (i)
				}
		},
		"./src/reddit/actions/bulkActions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "BULKACTION_PENDING",
				r = "BULKACTION_LOADED",
				o = "BULKACTION_FAILED"
		},
		"./src/reddit/actions/category.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "i", (function() {
				return S
			})), n.d(t, "d", (function() {
				return T
			})), n.d(t, "j", (function() {
				return C
			}));
			n("./node_modules/lodash/isEmpty.js"), n("./node_modules/react-router-redux/es/index.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/constants/categories.tsx"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			var d = n("./src/reddit/endpoints/category/subreddits.ts"),
				u = n("./src/reddit/helpers/localStorage/index.ts"),
				l = n("./src/reddit/selectors/category.ts");
			const b = "CATEGORY__LIST_PENDING",
				p = "CATEGORY__LIST_LOADED",
				f = "CATEGORY__LIST_FAILED",
				m = Object(s.a)(b),
				O = Object(s.a)(p),
				g = Object(s.a)(f),
				_ = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const d = t(),
						u = Object(l.h)(d),
						b = Object(l.g)(d);
					if (u || b) return;
					e(m());
					const p = await (e => Object(a.b)(Object(c.a)(e, [i.a]), {
						endpoint: "".concat(e.apiUrl, "/api/available_subreddit_categories.json?use_extended_categories=true"),
						method: o.ab.GET
					}))(s());
					if (p.ok) {
						const {
							categories: t,
							categoryIds: n
						} = (e => {
							const t = {},
								n = [];
							return e.forEach((e, s) => {
								const o = {
									attr: e.category_attr,
									color: e.category_color || r.a[s % r.a.length],
									icon: e.category_icon,
									id: e.category_id,
									name: e.category_name
								};
								n.push(o.id), t[o.id] = o
							}), {
								categories: t,
								categoryIds: n
							}
						})(p.body);
						e(O({
							categories: t,
							categoryIds: n
						}))
					} else e(g(p.error))
				}, y = "CATEGORY__SUBREDDITS_PENDING", j = "CATEGORY__SUBREDDITS_LOADED", h = "CATEGORY__SUBREDDITS_FAILED", E = Object(s.a)(y), I = Object(s.a)(j), v = Object(s.a)(h), S = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(l.l)(a, {
							id: e
						}),
						i = Object(l.k)(a, {
							id: e
						});
					if (c || i) return;
					n(E({
						categoryId: e
					}));
					const u = await Object(d.a)(o(), e, t);
					if (u.ok) {
						const t = Object(d.b)(u.body);
						n(I(Object.assign({
							categoryId: e
						}, t)))
					} else n(v({
						categoryId: e,
						error: u.error
					}))
				}, T = "CATEGORY__RANK_SET", D = Object(s.a)(T), C = e => async (t, n) => {
					const s = Object(l.i)(n(), {
						id: e
					});
					t(D({
						categoryId: e,
						rank: s + 1
					})), Object(u.F)(Object(l.e)(n()))
				}
		},
		"./src/reddit/actions/changeUsername.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "e", (function() {
				return m
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/interceptedAction.ts"),
				o = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/components/Settings/modalIds.ts"),
				c = n("./src/reddit/constants/actions.ts"),
				i = n("./src/reddit/selectors/interceptedAction.ts");
			const d = "CHANGE_USERNAME_TOOLTIP_CLOSED",
				u = "CHANGE_USERNAME_TOOLTIP_OPENED",
				l = "SAVE_USERNAME_SUCCESS",
				b = Object(s.a)(d),
				p = (Object(s.a)(u), Object(s.a)(l)),
				f = e => async (t, n) => {
					e && t(Object(r.c)(e)), t(Object(o.h)(a.e))
				}, m = (e, t) => async (n, s) => {
					const o = Object(i.a)(s());
					if (n(p({
							username: e
						})), o) {
						n(((e, t, n) => {
							switch (e.type) {
								case c.a: {
									const {
										payload: {
											args: s
										}
									} = e;
									s && s[0] && "string" == typeof s[0] && (s[0] = s[0].split(n).join(t));
									break
								}
							}
							return e
						})(o, e, t)), n(Object(r.d)())
					}
				}
		},
		"./src/reddit/actions/chat/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.anybody = "Everyone", e.account_age_30_days = "Accounts older than 30 days", e.nobody = "Nobody"
				}(s || (s = {}))
		},
		"./src/reddit/actions/chat/init.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/chat/customMiddleware/containerSize.ts"),
				r = n("./src/chat/reducers/subscribe.ts"),
				o = n("./src/lib/loadWithRetries/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts");
			let c;
			let i;
			const d = "CHAT__INITED",
				u = Object(a.a)(d),
				l = async (e, t, a) => i ? {
					chatStore: i,
					firstInit: !1
				} : (i = await (async (e, t, s) => {
					const r = Date.now(),
						a = await Object(o.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/initializer.ts"))).then(e => e.default);
					return (await a(t(), r, s)).store
				})(0, t, a), Object(s.b)(i), await (async (e, t, s) => {
					if (!c) {
						const a = (await Object(o.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/reddit/actions/chat/proxy.ts"))).then(e => e.default))(t, s),
							i = Object(r.b)(e, a);
						c = e.subscribe(i)
					}
				})(i, e, t), e(u()), {
					chatStore: i,
					firstInit: !0
				})
		},
		"./src/reddit/actions/chat/subredditChannel.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "b", (function() {
				return D
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/chat/index.ts"),
				o = n("./src/reddit/models/SubredditChannel/index.ts"),
				a = n("./src/reddit/selectors/chat.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const i = "SUBREDDIT_CHANNELS__REQUESTED",
				d = "SUBREDDIT_CHANNELS__ADDED",
				u = "SUBREDDIT_CHANNELS__FAILED",
				l = "SUBREDDIT_CHANNEL__ADDED",
				b = "SUBREDDIT_CHANNEL__SELECTED",
				p = "SUBREDDIT_CHANNEL__EDITED",
				f = "SUBREDDIT_CHANNEL__REMOVED",
				m = Object(s.a)(b),
				O = Object(s.a)(i),
				g = Object(s.a)(u),
				_ = Object(s.a)(d),
				y = Object(s.a)(l),
				j = Object(s.a)("SUBREDDIT_CHANNEL__FAILED"),
				h = e => async (t, n, s) => {
					let {
						apiContext: c
					} = s;
					const {
						user: {
							account: i,
							session: d
						}
					} = n();
					if (!i || !d) return;
					t(O({
						subredditId: e
					}));
					const u = Object(a.e)(n(), {
							subredditId: e
						}),
						l = await Object(r.i)(c(), e, u);
					if (l.ok) {
						const {
							rooms: n,
							subreddit_chat_enabled: s,
							user_subreddit_chat_enabled: r
						} = l.body, a = Object(o.d)(n);
						t(_({
							collection: a,
							subredditId: e,
							isSubredditWhitelisted: !!s,
							isUserSubredditChatEnabled: !!r
						}))
					} else if (l.error) {
						const {
							error: n
						} = l;
						t(g({
							error: n,
							subredditId: e
						}))
					}
				}, E = (e, t) => async (n, s, a) => {
					let {
						apiContext: c
					} = a;
					const {
						user: {
							account: i,
							session: d
						}
					} = s();
					if (!i || !d) return;
					const u = await Object(r.d)(c(), d, t);
					if (u.ok) {
						const s = Object(o.e)(Object.assign({}, u.body, t));
						return await n(y({
							channel: s,
							subredditId: e
						})), s
					}
					n(j(u.error))
				}, I = (e, t) => async (n, s, o) => {
					let {
						apiContext: a
					} = o;
					const {
						channelSendbirdUrl: c
					} = e, {
						user: {
							session: i
						}
					} = s();
					if (!i) return;
					const d = await Object(r.f)(a(), c, i, t);
					d.ok ? n(v({
						channel: e,
						editedSubredditChannelData: t
					})) : n(j(d.error))
				}, v = Object(s.a)(p), S = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const {
						channelId: a,
						channelSendbirdUrl: i
					} = e, d = n();
					if (!Object(c.H)(d)) return;
					const u = await Object(r.e)(o(), i);
					u.ok ? t(T(a)) : t(j(u.error))
				}, T = Object(s.a)(f), D = "SUBREDDIT_CHANNELS__ENABLED";
			Object(s.a)(D)
		},
		"./src/reddit/actions/chat/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/chat/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const a = "CHAT_SUBREDDIT_SETTINGS__SET",
				c = Object(s.a)(a),
				i = Object(s.a)("CHAT_SUBREDDIT_SETTINGS__SET_FAILED"),
				d = async (e, t, n) => {
					try {
						if (n) return await e(c(Object.assign({
							subredditId: t
						}, n))), n
					} catch (s) {
						i(s)
					}
				}, u = e => async (t, n, s) => {
					let {
						apiContext: a
					} = s;
					try {
						const s = n();
						if (!Object(o.H)(s)) return;
						const c = await Object(r.g)(a(), e);
						return d(t, e, c)
					} catch (c) {
						i(c)
					}
				}, l = (e, t) => async (n, s, a) => {
					let {
						apiContext: c
					} = a;
					try {
						const a = s();
						if (!Object(o.H)(a)) return;
						const i = await Object(r.j)(c(), e, t);
						i.ok && d(n, e, i.body)
					} catch (u) {
						i(u)
					}
				}
		},
		"./src/reddit/actions/chat/toggle.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/chat/constants/container.ts"),
				a = n("./src/chat/customMiddleware/containerSize.ts"),
				c = n("./src/reddit/actions/chat/init.ts"),
				i = n("./src/reddit/helpers/trackers/authorHovercard.ts");
			const d = () => Object(r.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/actions/meta.ts"))).then(e => e.setExternalData),
				u = () => Object(r.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/actions/container.ts"))).then(e => e.sizeChanged);
			async function l(e, t, n, r) {
				const [{
					chatStore: a,
					firstInit: l
				}, b] = await Promise.all([Object(c.c)(e, t, n), u()]), p = t(), f = await d(), m = Object(i.h)(p, r);
				a.dispatch(f(m)), a.getState().container.size !== o.a.EMBED && a.dispatch(b(o.a.EMBED)), !l && a.dispatch(Object(s.c)(n))
			}
			const b = () => async (e, t) => Promise.all([Object(c.c)(e, t), u()]).then(e => {
				let [{
					chatStore: t,
					firstInit: n
				}, s] = e;
				t.getState().container.size !== o.a.EMBED || n ? t.dispatch(s(o.a.EMBED)) : t.dispatch(s(o.a.HIDDEN))
			}), p = (e, t) => async (s, o) => {
				const a = (await (() => Object(r.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/helpers/urls/index.ts"))).then(e => e.channelUserIdUrl))())(e);
				await l(s, o, a, t)
			}, f = e => {
				let {
					channelId: t,
					subredditName: s,
					channelUrl: o
				} = e;
				return async (e, a) => {
					if (!o && t) {
						const e = await (() => Object(r.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/helpers/urls/index.ts"))).then(e => e.channelUrl))();
						o = e(t, s)
					}
					if (!o) throw new Error("Please specify channelUrl or channelId (subredditName is optional)");
					await l(e, a, o)
				}
			}, m = e => async (t, s) => {
				if (!c.b) return;
				const o = await (() => Object(r.a)(() => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/actions/theme.ts"))).then(e => e.switchTheme))();
				c.b.dispatch(o(e))
			}, O = () => async (e, t) => {
				const n = t(),
					s = n.user.account && n.user.account.id || "unknown";
				Object(a.c)(s) && Object(c.c)(e, t)
			}
		},
		"./src/reddit/actions/chat/unreadCount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "d", (function() {
				return y
			}));
			var s, r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/chat/endpoints/sendbird/index.ts"),
				c = n("./src/reddit/selectors/chat.ts"),
				i = n("./src/reddit/selectors/user.ts");
			! function(e) {
				e.SYNC = "UNREAD_COUNT__SYNC", e.REQUEST_FAILED = "UNREAD_COUNT__REQUEST_FAILED", e.REQUEST_PENDING = "UNREAD_COUNT__REQUEST_PENDING", e.REQUEST_SUCCESS = "UNREAD_COUNT__REQUEST_SUCCESS"
			}(s || (s = {}));
			const {
				SYNC: d,
				REQUEST_FAILED: u,
				REQUEST_PENDING: l,
				REQUEST_SUCCESS: b
			} = s, p = Object(o.a)(d), f = Object(o.a)(u), m = Object(o.a)(l), O = Object(o.a)(b);
			let g;
			const _ = 5 * r.bb,
				y = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					if (!Object(i.H)(r) || !Object(c.f)(r)) return clearTimeout(g);
					g || e((() => async (e, t, n) => {
						let {
							apiContext: s
						} = n;
						const r = t(),
							{
								session: o
							} = r.user;
						if (o && Object(i.H)(r) && Object(c.f)(r)) {
							e(m());
							const t = await Object(a.i)(s(), o);
							t && t.ok ? e(O({
								basicChannelCount: t.body.unread_count || 0,
								subredditChannelCount: t.body.subreddit_unread_count || 0
							})) : e(f({
								error: t.error
							}))
						}
					})()), g = setTimeout(() => {
						e(y())
					}, _)
				}
		},
		"./src/reddit/actions/chat/userSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "c", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/config.ts"),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			var l = n("./src/reddit/helpers/trackers/chat.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/telemetry/index.ts"),
				f = n("./src/reddit/actions/chat/constants.ts");
			const m = Object(r.a)("USER_SETTINGS__FETCH_PENDING"),
				O = Object(r.a)("USER_SETTINGS__FETCH_FAILURE"),
				g = "USER_SETTINGS__UPDATE_SUCCESS",
				_ = Object(r.a)(g),
				y = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					e(m());
					const r = await (e => Object(i.b)(Object(d.a)(e, [u.a]), {
						endpoint: "".concat(a.a.sendbirdServiceUrl, "/").concat("api/v1", "/chat/me/settings"),
						method: c.ab.GET
					}))(s());
					if (r.ok) {
						const t = Object.assign({}, r.body);
						e(_({
							invitePolicy: f.a[t.invite_policy]
						}))
					} else e(O(r.error))
				}, j = Object(r.a)("USER_SETTINGS__SAVE_PENDING"), h = Object(r.a)("USER_SETTINGS__SAVE_FAILURE"), E = e => async (t, n, r) => {
					let {
						apiContext: m
					} = r;
					const O = n(),
						{
							invitePolicy: g
						} = e,
						y = Object.keys(f.a).find(e => f.a[e] === g);
					if (y) {
						t(j());
						const e = await (async (e, t) => Object(i.b)(Object(d.a)(t, [u.a]), {
							endpoint: "".concat(a.a.sendbirdServiceUrl, "/").concat("api/v1", "/chat/me/settings"),
							method: c.ab.PUT,
							data: JSON.stringify({
								invite_policy: e
							})
						}))(y, m());
						if (Object(p.a)(Object(l.f)(y)(O)), e.ok) {
							const e = f.a[y];
							t(_({
								invitePolicy: e
							})), t(Object(o.e)({
								kind: b.b.SuccessCommunity,
								text: s.fbt._("Changes saved", null, {
									hk: "4eTtdy"
								})
							}))
						} else t(h(e.error))
					}
				}
		},
		"./src/reddit/actions/claimgold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "h", (function() {
				return T
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/models/Toast/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				l = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			var b = async (e, t) => {
				const {
					code: n
				} = t, s = {
					api_type: "json",
					code: n,
					raw_json: 1
				};
				return Object(i.b)(Object(d.a)(e, [u.a]), {
					method: c.ab.POST,
					endpoint: "".concat(e.apiUrl, "/api/claimgold"),
					data: s
				}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
					error: Object(l.a)(e)
				}))
			}, p = n("./src/reddit/helpers/genericServerError/index.ts"), f = n("./src/reddit/selectors/claimgold.ts");
			const m = "CLAIMGOLD__OPEN_CLAIMGOLD_MODAL",
				O = "CLAIMGOLD__CLOSE_CLAIMGOLD_MODAL",
				g = Object(r.a)(m),
				_ = Object(r.a)(O),
				y = () => async (e, t) => {
					const n = t();
					Object(f.b)(n) ? e(_()) : e(g())
				}, j = "CLAIMGOLD_UPDATE_CODE", h = Object(r.a)(j), E = "CLAIM_GOLD__TRIGGER_LOADER", I = "CLAIM_GOLD__CLAIM_GOLD_PENDING", v = "CLAIM_GOLD__CLAIM_GOLD_SUCCESSFUL", S = "CLAIM_GOLD__CLAIM_GOLD_FAILED", T = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = {
						code: t().claimGold.code
					};
					e(w());
					try {
						const t = await b(s(), r);
						t.error ? e(R(t)) : e(k())
					} catch (o) {
						e(R(o))
					}
				}, D = Object(r.a)(E), C = Object(r.a)(I), w = () => async (e, t) => {
					e(C()), window.setTimeout(() => {
						t().claimGold.api.pending && e(D())
					}, 2e3)
				}, A = Object(r.a)(S), R = e => async (t, n) => {
					await t(A(Object.assign({}, e, {
						error: e.error || Object(p.a)()
					})));
					const s = n().claimGold.api.error;
					s && t(Object(o.e)({
						kind: a.b.Error,
						duration: o.a,
						text: s
					}))
				}, P = Object(r.a)(v), k = () => async (e, t) => {
					e(P()), e(Object(o.e)({
						kind: a.b.SuccessCommunity,
						text: s.fbt._("You have redeemed your gift code successfully", null, {
							hk: "18mkH2"
						})
					}))
				}
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "C", (function() {
				return ue
			})), n.d(t, "ib", (function() {
				return be
			})), n.d(t, "n", (function() {
				return pe
			})), n.d(t, "R", (function() {
				return fe
			})), n.d(t, "gb", (function() {
				return me
			})), n.d(t, "L", (function() {
				return _e
			})), n.d(t, "Q", (function() {
				return ye
			})), n.d(t, "X", (function() {
				return je
			})), n.d(t, "v", (function() {
				return he
			})), n.d(t, "u", (function() {
				return Ee
			})), n.d(t, "t", (function() {
				return Ie
			})), n.d(t, "Z", (function() {
				return De
			})), n.d(t, "rb", (function() {
				return Ce
			})), n.d(t, "T", (function() {
				return we
			})), n.d(t, "i", (function() {
				return Ae
			})), n.d(t, "h", (function() {
				return Re
			})), n.d(t, "d", (function() {
				return Pe
			})), n.d(t, "e", (function() {
				return ke
			})), n.d(t, "c", (function() {
				return xe
			})), n.d(t, "b", (function() {
				return Ne
			})), n.d(t, "j", (function() {
				return Le
			})), n.d(t, "m", (function() {
				return Ue
			})), n.d(t, "N", (function() {
				return Me
			})), n.d(t, "M", (function() {
				return Fe
			})), n.d(t, "W", (function() {
				return Ke
			})), n.d(t, "nb", (function() {
				return He
			})), n.d(t, "K", (function() {
				return Ye
			})), n.d(t, "H", (function() {
				return Qe
			})), n.d(t, "cb", (function() {
				return ze
			})), n.d(t, "pb", (function() {
				return Je
			})), n.d(t, "S", (function() {
				return Xe
			})), n.d(t, "E", (function() {
				return Ze
			})), n.d(t, "G", (function() {
				return $e
			})), n.d(t, "F", (function() {
				return et
			})), n.d(t, "D", (function() {
				return tt
			})), n.d(t, "mb", (function() {
				return st
			})), n.d(t, "kb", (function() {
				return rt
			})), n.d(t, "qb", (function() {
				return ct
			})), n.d(t, "tb", (function() {
				return it
			})), n.d(t, "lb", (function() {
				return ut
			})), n.d(t, "sb", (function() {
				return lt
			})), n.d(t, "jb", (function() {
				return bt
			})), n.d(t, "Y", (function() {
				return pt
			})), n.d(t, "p", (function() {
				return ft
			})), n.d(t, "o", (function() {
				return mt
			})), n.d(t, "k", (function() {
				return Ot
			})), n.d(t, "f", (function() {
				return gt
			})), n.d(t, "l", (function() {
				return _t
			})), n.d(t, "O", (function() {
				return jt
			})), n.d(t, "s", (function() {
				return It
			})), n.d(t, "P", (function() {
				return vt
			})), n.d(t, "ob", (function() {
				return St
			})), n.d(t, "ab", (function() {
				return Tt
			})), n.d(t, "bb", (function() {
				return Dt
			})), n.d(t, "fb", (function() {
				return Ct
			})), n.d(t, "q", (function() {
				return wt
			})), n.d(t, "I", (function() {
				return Rt
			})), n.d(t, "r", (function() {
				return Pt
			})), n.d(t, "A", (function() {
				return kt
			})), n.d(t, "z", (function() {
				return xt
			})), n.d(t, "B", (function() {
				return Nt
			})), n.d(t, "g", (function() {
				return Lt
			})), n.d(t, "V", (function() {
				return Mt
			})), n.d(t, "U", (function() {
				return qt
			})), n.d(t, "eb", (function() {
				return Vt
			})), n.d(t, "x", (function() {
				return Kt
			})), n.d(t, "w", (function() {
				return Ht
			})), n.d(t, "y", (function() {
				return Wt
			})), n.d(t, "db", (function() {
				return Jt
			})), n.d(t, "hb", (function() {
				return Xt
			})), n.d(t, "a", (function() {
				return Zt
			})), n.d(t, "J", (function() {
				return $t
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/telemetry/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeCommentsPageKey/index.ts"),
				d = n("./src/lib/makeDraftKey/index.ts"),
				u = n("./src/reddit/actions/changeUsername.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				b = n("./src/reddit/actions/login.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				f = n("./src/reddit/actions/post.ts"),
				m = n("./src/reddit/actions/postCreation/editorContent.ts"),
				O = n("./src/reddit/actions/shortcuts/utils.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/actions/vote.ts"),
				y = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				j = n("./src/reddit/constants/adEvents.ts"),
				h = n("./src/reddit/constants/modals.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				I = n("./src/lib/omitHeaders/index.ts"),
				v = n("./src/reddit/constants/headers.ts"),
				S = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				T = n("./src/reddit/models/Comment/addProfileImgParam.ts"),
				D = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				C = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const w = (e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
					endpoint: Object(S.a)("".concat(e.apiUrl, "/api/save")),
					method: a.ab.POST,
					data: {
						id: t
					}
				}),
				A = (e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
					endpoint: Object(S.a)("".concat(e.apiUrl, "/api/unsave")),
					method: a.ab.POST,
					data: {
						id: t
					}
				}),
				R = (e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
					endpoint: Object(S.a)("".concat(e.apiUrl, "/api/lock")),
					method: a.ab.POST,
					data: {
						id: t
					}
				}),
				P = (e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
					endpoint: Object(S.a)("".concat(e.apiUrl, "/api/unlock")),
					method: a.ab.POST,
					data: {
						id: t
					}
				}),
				k = (e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
					endpoint: "".concat(e.apiUrl, "/api/ignore_reports"),
					method: a.ab.POST,
					data: {
						id: t
					}
				}),
				x = (e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
					endpoint: "".concat(e.apiUrl, "/api/unignore_reports"),
					method: a.ab.POST,
					data: {
						id: t
					}
				});
			var N = n("./src/graphql/operations/CommentToxicity.json"),
				L = n("./src/lib/makeGqlRequest/index.ts"),
				U = n("./src/reddit/helpers/genericServerError/index.ts"),
				M = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				F = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				G = n("./src/reddit/models/PostCreationForm/index.ts");
			const B = (e, t, n, s) => {
					let r, o;
					if (s === G.h.MARKDOWN) r = n.text, o = null;
					else {
						r = null;
						let e = null;
						n.rteState && (e = y.a.toRichTextJSON(n.rteState).document), o = JSON.stringify({
							document: e
						})
					}
					return Object(L.a)(e, Object.assign({}, N, {
						variables: {
							subredditName: t,
							markdown: r,
							richText: o
						}
					})).then(e => !e.ok || e.body.data.isValidComment)
				},
				q = async (e, t, n, s, r) => {
					const o = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: t
					};
					if (r === G.h.MARKDOWN) o.text = n.text;
					else {
						o.text = null;
						let e = null;
						n.rteState && (e = y.a.toRichTextJSON(n.rteState).document), o.richtext_json = JSON.stringify({
							document: e
						})
					}
					return Object(E.b)(Object(I.a)(e, [v.a]), {
						method: a.ab.POST,
						endpoint: Object(S.a)(Object(D.a)(Object(C.a)("".concat(e.apiUrl, "/api/comment.json")))),
						data: o
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? Object.assign({}, e, {
						ok: !1,
						error: Object(F.a)(e)
					}) : Object.assign({}, e, {
						body: {
							comment: Object(M.a)(e.body.json.data.things[0].data, s)
						}
					}) : Object.assign({}, e, {
						body: {
							comment: Object(M.a)(e.body, s)
						}
					}) : Object.assign({}, e, {
						error: e.error || Object(U.a)()
					}))
				};
			var V = n("./src/reddit/endpoints/post/index.tsx"),
				K = n("./src/reddit/endpoints/post/convert.ts"),
				H = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				W = n("./src/reddit/featureFlags/index.ts"),
				Y = n("./src/reddit/helpers/commentList/index.ts"),
				Q = n("./src/reddit/helpers/dom/index.ts"),
				z = n("./src/reddit/selectors/telemetry.ts");
			var J = n("./src/reddit/helpers/trackers/commentsPage.ts"),
				X = n("./src/reddit/models/Comment/index.ts"),
				Z = n("./src/reddit/models/Post/index.ts"),
				$ = n("./src/reddit/models/PostDraft/index.ts"),
				ee = n("./src/reddit/models/RichTextJson/index.ts"),
				te = n("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				ne = n("./src/reddit/models/Toast/index.ts"),
				se = n("./src/reddit/models/Vote/index.ts"),
				re = n("./src/reddit/selectors/comments.ts"),
				oe = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				ae = n("./src/reddit/selectors/moderatingComments.ts"),
				ce = n("./src/reddit/selectors/platform.ts"),
				ie = n("./src/reddit/selectors/posts.ts"),
				de = n("./src/reddit/selectors/user.ts");
			const ue = "COMMENT__STICKIED_COMMENT_SUCCESS",
				le = {},
				be = Object(c.a)(ue),
				pe = "COMMENT__MUTATED",
				fe = Object(c.a)(pe),
				me = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (!Object(de.H)(n())) return t(Object(b.h)()), void t(Object(p.k)({
						actionSource: p.a.Save,
						redirectUrl: Object(re.m)(n(), {
							commentId: e
						})
					}));
					const a = n().comments.models[e];
					if (!a) return;
					const c = a.isSaved ? A : w;
					if (t(fe({
							[e]: {
								isSaved: !a.isSaved
							}
						})), (await c(o(), e)).ok) {
						const n = a.isSaved ? r.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : r.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							s = r.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						t(Object(g.e)({
							text: n,
							kind: ne.b.Undo,
							buttonText: s,
							buttonAction: me(e)
						}))
					} else t(fe({
						[e]: {
							isSaved: a.isSaved
						}
					}))
				}, Oe = e => "viewing-comment-".concat(e), ge = s.a.telemetry.commentConsumedThreshold, _e = e => async (t, n) => {
					const r = n();
					if (!Object(re.n)(r, {
							commentId: e
						}) || Math.random() > s.a.telemetry.commentSampleRate) return;
					(e => {
						let {
							state: t,
							commentId: n
						} = e;
						Object(o.a)(Object.assign({
							source: "comment",
							action: "view",
							noun: "comment"
						}, z.defaults(t), {
							profile: z.profile(t),
							post: z.post(t, n),
							media: z.media(t, n),
							subreddit: z.subreddit(t),
							comment: z.comment(t, n)
						}))
					})({
						state: r,
						commentId: e
					}), o.c.start(Oe(e));
					const a = setTimeout(() => (e => {
						let {
							state: t,
							commentId: n
						} = e;
						return Object(o.a)(Object.assign({
							source: "comment",
							action: "consume",
							noun: "comment"
						}, z.defaults(t), {
							profile: z.profile(t),
							post: z.post(t, n),
							media: z.media(t, n),
							subreddit: z.subreddit(t),
							comment: z.comment(t, n)
						}))
					})({
						state: r,
						commentId: e
					}), ge);
					le[e] = a
				}, ye = (e, t) => async (n, s) => {
					const r = s(),
						a = Oe(e);
					if (Object(re.n)(r, {
							commentId: e
						}) && o.c.has(a)) {
						const n = o.c.end(a);
						!t && n < ge && (clearTimeout(le[e]), delete le[e])
					}
				}, je = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					if (!Object(de.H)(n())) return void t(Object(p.i)(h.a.LOGIN_MODAL_ID));
					const o = n().comments.models[e];
					if (!o) return;
					const a = o.isLocked ? P : R;
					t(fe({
						[e]: {
							isLocked: !o.isLocked
						}
					})), (await a(r(), e)).ok || t(fe({
						[e]: {
							isLocked: o.isLocked
						}
					}))
				}, he = "COMMENT__MORECOMMENTS_PENDING", Ee = "COMMENT__MORECOMMENTS_LOADED", Ie = "COMMENT__MORECOMMENTS_FAILED", ve = Object(c.a)(he), Se = Object(c.a)(Ee), Te = Object(c.a)(Ie), De = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const i = r(),
						d = i.moreComments.models[t],
						u = i.platform.currentPage,
						b = u && u.routeMatch,
						p = b && b.match,
						{
							partialPostId: f
						} = p ? p.params : null;
					if (!f) return;
					const m = Object(Z.m)(f);
					n(ve({
						moreCommentsId: d.id
					}));
					const O = await ((e, t, n, r) => {
						let o = Object(C.a)(Object(D.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/morecomments/").concat(t)));
						return r && (o = Object(T.a)(o)), Object(E.b)(e, {
							data: n,
							endpoint: o,
							method: a.ab.POST,
							type: "json",
							traceRequestName: "more_comments"
						})
					})(c(), m, {
						token: d.token
					}, Object(oe.a)(i));
					if (O.ok) {
						const t = O.body,
							s = Object(Y.a)(t, m, i);
						n(Se(Object.assign({
							key: e,
							moreCommentsItem: d,
							shouldCollapse: s
						}, t)));
						const r = i.posts.models[m];
						r && "subreddit" === r.belongsTo.type && t.comments && await n(Object(l.a)({
							commentIds: Object.keys(O.body.comments),
							postIds: [r.id],
							skip: ["communityDetails", "subscription"],
							subredditId: r.belongsTo.id
						}))
					} else n(Te(Object.assign({
						moreCommentsItem: d
					}, O.error)))
				}, Ce = Object(_.b)(Y.b, se.a.upvoted), we = Object(_.b)(Y.b, se.a.downvoted), Ae = "COMMENT__FOCUSED_TOGGLED", Re = "COMMENT__FOCUSED_SET", Pe = "COMMENT__COLLAPSED_TOGGLED", ke = "COMMENT__COLLAPSED_UNSET", xe = "COMMENTS__HIDDEN_TOGGLED", Ne = "COMMENTS__HIDDEN_SET", Le = "COMMENT_FORM_FOCUS_CHANGED", Ue = "COMMENT_MARKED_UNCOLLAPSED", Me = Object(c.a)(Ae), Fe = Object(c.a)(Re), Ge = Object(c.a)(Pe), Be = Object(c.a)(ke), qe = (Object(c.a)(Ne), Object(c.a)(xe), Object(c.a)(Le)), Ve = Object(c.a)(Ue), Ke = e => {
					let {
						hasFocus: t,
						draftKey: n
					} = e;
					return async (e, s) => {
						const r = s();
						if (!!r.comments.drafts[n])
							if (Object(de.J)(r) && t) {
								const s = qe({
									hasFocus: t,
									draftKey: n
								});
								e(Object(u.f)(s))
							} else e(qe({
								hasFocus: t,
								draftKey: n
							}))
					}
				}, He = e => {
					let {
						commentId: t,
						commentsPageKey: n,
						scrollToAndRemeasure: s
					} = e;
					return async (e, r) => {
						const o = r(),
							a = Object(X.f)(t),
							c = Object(re.o)(o, {
								commentLink: a,
								commentsPageKey: n
							}),
							i = Object(ae.b)(o, {
								commentId: t,
								commentsPageKey: n
							}),
							d = c.depth;
						e(Ge({
							commentId: t,
							commentsPageKey: n,
							isCollapsed: i
						})), i || 0 !== d || s(t, !0), Object(O.d)()
					}
				}, We = e => {
					let {
						commentId: t,
						commentsPageKey: n
					} = e;
					return async (e, s) => {
						e(Be({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, Ye = e => {
					let {
						commentLink: t,
						commentsPageKey: n,
						lineDepth: s,
						scrollToAndRemeasure: r
					} = e;
					return async (e, o) => {
						const a = o(),
							c = Object(Y.e)(n, t, s, a),
							i = Object(ae.b)(a, {
								commentId: t.id,
								commentsPageKey: n
							});
						e(Ge({
							commentId: c,
							commentsPageKey: n,
							isCollapsed: i
						})), 0 === s && r(c, !0), Object(O.d)()
					}
				}, Qe = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						c = o.comments.models[e],
						i = o.user.account ? o.user.account.displayText : null;
					c && i && (t(fe({
						[e]: {
							isApproved: !0,
							approvedBy: i,
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (await ((e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
						endpoint: Object(S.a)("".concat(e.apiUrl, "/api/approve")),
						method: a.ab.POST,
						data: {
							id: t
						}
					}))(r(), e)).ok || t(fe({
						[e]: {
							isApproved: c.isApproved,
							approvedBy: null,
							bannedBy: c.bannedBy,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam,
							modNote: c.modNote,
							modReasonBy: c.modReasonBy,
							modRemovalReason: c.modRemovalReason,
							numReports: c.numReports || null
						}
					})), Object(O.d)())
				}, ze = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const c = s(),
						i = c.comments.models[e],
						d = c.user.account ? c.user.account.displayText : null;
					i && d && (n(fe({
						[e]: {
							approvedBy: null,
							bannedBy: d,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (await ((e, t, n) => Object(E.b)(Object(I.a)(e, [v.a]), {
						endpoint: Object(S.a)("".concat(e.apiUrl, "/api/remove")),
						method: a.ab.POST,
						data: {
							id: t,
							spam: n
						}
					}))(o(), e, t)).ok || n(fe({
						[e]: {
							approvedBy: i.approvedBy,
							bannedBy: i.bannedBy,
							isApproved: i.isApproved,
							isRemoved: i.isRemoved,
							isSpam: i.isSpam
						}
					})), Object(O.d)())
				}, Je = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().comments.models[e];
					if (!o) return;
					const a = o.ignoreReports ? x : k;
					t(fe({
						[e]: {
							ignoreReports: !o.ignoreReports
						}
					})), (await a(r(), e)).ok || t(fe({
						[e]: {
							ignoreReports: o.ignoreReports
						}
					}))
				}, Xe = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: c
					} = o;
					const d = r(),
						u = d.comments.models[e];
					if (!u) return;
					const l = u.postId,
						b = d.postStickiedComments.data[l],
						p = a.g[t];
					s(fe({
						[e]: {
							distinguishType: t,
							isAdmin: t === a.A.ADMIN,
							isMod: t === a.A.MODERATOR,
							isStickied: !!n
						}
					})), n && b && b !== e && s(fe({
						[b]: {
							isStickied: !1
						}
					})), (await ((e, t, n, s) => Object(E.b)(Object(I.a)(e, [v.a]), {
						endpoint: Object(S.a)("".concat(e.apiUrl, "/api/distinguish/").concat(n)),
						method: a.ab.POST,
						data: {
							id: t,
							sticky: s
						}
					}))(c(), e, p, n || null)).ok ? n && s(be({
						id: e,
						postId: l,
						commentsPageKey: Object(i.a)(l, null, Object.assign({
							sort: a.q.CONFIDENCE
						}, d.platform.currentPage.queryParams))
					})) : (s(fe({
						[e]: {
							distinguishType: u.distinguishType,
							isAdmin: u.isAdmin,
							isMod: u.isMod,
							isStickied: u.isStickied
						}
					})), s(fe({
						[b]: {
							isStickied: d.comments.models[b].isStickied
						}
					})))
				}, Ze = "COMMENT__SUBMIT_COMMENT_PENDING", $e = "COMMENT__SUBMIT_REPLY_TO_POST_SUCCESS", et = "COMMENT__SUBMIT_REPLY_TO_COMMENT_SUCCESS", tt = "COMMENT__SUBMIT_COMMENT_FAILURE", nt = Object(c.a)(Ze), st = Object(c.a)($e), rt = Object(c.a)(et), ot = Object(c.a)(tt), at = (e, t, n, s) => {
					const r = s.ok && s.body,
						o = r && r.comment && r.comment.id;
					J.f(e, n, t, o)
				}, ct = "Toxicity_Warning__Modal", it = (e, t, n, s, r, o) => async (a, c, i) => {
					let {
						gqlContext: d
					} = i;
					const u = c(),
						l = Object(ce.f)(u);
					let b = "";
					if (l && (b = l.name), W.d.enableToxicityWarning(u)) {
						if (!(await B(d(), b, s, r))) return void a(Object(p.i)(ct))
					}
					a(ut(e, t, n, s, r, o))
				}, dt = e => e.rteState ? y.a.toRichTextJSON(e.rteState) : e.rtJson || e.text, ut = (e, t, n, s, o, c, i) => async (d, u, l) => {
					let {
						apiContext: b
					} = l;
					d(Object(p.g)(ct));
					const m = u(),
						_ = m.comments.submit.pending[n];
					if (!m.user.account || _) return;
					d(nt({
						draftKey: n,
						draft: s
					}));
					const y = m.user.account.displayText,
						h = s.commentMode;
					let E;
					if ((E = i ? await Object(H.i)(b(), e, s, y) : await q(b(), e, s, y, h)).ok) {
						d(st(Object.assign({}, E.body, {
							headCommentId: Object(re.x)(m, {
								commentsPageKey: t
							}),
							commentsPageKey: t,
							draftKey: n
						})));
						const s = Object(ie.O)(u(), {
							postId: e
						});
						d(Object(f.B)(s, j.a.CommentSubmitted))
					} else {
						E.error && E.error.type === a.wb && J.g(m, dt(s), e);
						const t = E.error && E.error.fields && E.error.fields[0] ? E.error.fields[0].msg : r.fbt._("Something went wrong", null, {
							hk: "LWFS0"
						});
						d(ot({
							draftKey: n,
							error: E.error
						})), d(Object(g.e)({
							duration: g.a,
							kind: ne.b.Error,
							text: t
						}))
					}
					at(u(), t, o, E), c || Object(O.d)()
				}, lt = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const {
						parentCommentId: o,
						commentsPageKey: a,
						parentCommentDepth: c,
						draftKey: i,
						formData: d,
						editorMode: u
					} = e, l = n(), b = Object(ce.f)(l);
					let f = "";
					if (b && (f = b.name), W.d.enableToxicityWarning(l)) {
						if (!(await B(r(), f, d, u))) return void t(Object(p.i)(ct))
					}
					t(bt({
						commentsPageKey: a,
						draftKey: i,
						parentCommentDepth: c,
						parentCommentId: o,
						formData: d,
						editorMode: u
					}))
				}, bt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const {
						parentCommentId: o,
						commentsPageKey: c,
						parentCommentDepth: i,
						draftKey: d,
						formData: u,
						editorMode: l
					} = e;
					t(Object(p.g)(ct));
					const b = n(),
						f = b.comments.submit.pending[d];
					if (!b.user.account || f) return;
					t(nt({
						draftKey: d,
						draft: u
					}));
					const m = b.user.account.displayText,
						g = u.commentMode,
						_ = await q(r(), o, u, m, g);
					if (_.ok) t(rt(Object.assign({}, _.body, {
						parentCommentId: o,
						commentsPageKey: c,
						draftKey: d,
						depth: i + 1
					})));
					else {
						if (_.error && _.error.type === a.wb) {
							const e = Object(re.n)(b, {
								commentId: o
							});
							if (!e) return;
							J.g(b, dt(u), e.postId, o)
						}
						t(ot({
							draftKey: d,
							error: _.error
						}))
					}
					at(n(), c, l, _), Object(O.d)()
				}, pt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().comments.models[e] && (await ((e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
						endpoint: "".concat(e.apiUrl, "/api/show_comment"),
						method: a.ab.POST,
						data: {
							id: t
						}
					}))(r(), e)).ok && t((e => async (t, n, s) => {
						let {
							apiContext: r
						} = s;
						t(Ve({
							commentId: e
						}))
					})(e))
				}, ft = "COMMENT__COMMENT_REPLY_FORM_OPENED", mt = "COMMENT__COMMENT_REPLY_FORM_CANCELLED", Ot = "COMMENT__COMMENT_FORM_MUTATED", gt = "COMMENT__COMMENT_DRAFT_CLEARED", _t = "COMMENT__COMMENT_FORM_SWITCHED_MODE", yt = Object(c.a)(ft), jt = Object(c.a)(mt), ht = Object(c.a)(Ot), Et = (Object(c.a)(gt), Object(c.a)(_t)), It = "INITIALIZE_COMMENT_EDITOR_MODE", vt = (Object(c.a)(It), (e, t, n) => async (s, o, a) => {
					let {
						apiContext: c
					} = a;
					const i = e === G.h.RICH_TEXT;
					if (!t || "object" == typeof t && Object(ee.F)(t)) s(Et({
						editorMode: e,
						draftKey: n,
						content: i ? ee.i : ""
					})), s(Object(m.c)(e));
					else {
						s(Object(m.b)(n));
						const o = await Object(K.a)(c(), e, i ? t : JSON.stringify(t));
						if (o.ok) {
							const t = o.body.output;
							s(Object(m.a)(n)), s(Et({
								editorMode: e,
								draftKey: n,
								content: t
							})), s(Object(m.c)(e))
						} else s(Object(m.a)(n)), s(Object(g.e)({
							duration: g.a,
							kind: ne.b.Error,
							text: r.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), St = e => {
					let {
						commentsPageKey: t,
						parentCommentId: n,
						singleOpen: s
					} = e;
					return async (e, r) => {
						const o = r(),
							a = Object(d.a)($.c.replyToComment, n);
						if (!Object(de.H)(r())) return e(Object(b.h)()), void e(Object(p.k)({
							actionSource: p.a.Reply,
							redirectUrl: Object(re.m)(r(), {
								commentId: n
							})
						}));
						const c = o.comments.replyFormOpen[t],
							i = c && c[n];
						if ((i || c && s) && (Object.keys(c).forEach(n => c[n] && e(jt({
								parentCommentId: n,
								commentsPageKey: t
							}))), i)) return;
						let l = "",
							f = null;
						const m = o.user.prefs.commentMode,
							O = Object(Q.d)();
						if (O) {
							const e = O.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (m === G.h.MARKDOWN) l = e.map(e => "> ".concat(e, "\n")).join("");
							else {
								const t = e.map(e => te.s(e, null)).map(e => te.l([e])),
									n = te.s("", null),
									s = te.l([n]);
								f = {
									document: [te.c(t), s]
								}
							}
						}
						const g = o.comments.drafts[a];
						let _;
						if (_ = O ? {
								commentMode: m,
								draftType: $.c.replyToComment,
								rtJson: f,
								text: "".concat(l, "\n")
							} : g || {
								commentMode: m,
								draftType: $.c.replyToComment,
								rtJson: f,
								text: ""
							}, Object(de.J)(o)) {
							const s = yt({
								parentCommentId: n,
								commentsPageKey: t,
								draftKey: a,
								formData: _
							});
							e(Object(u.f)(s))
						} else e(yt({
							parentCommentId: n,
							commentsPageKey: t,
							draftKey: a,
							formData: _
						}))
					}
				}, Tt = e => async (t, n) => {
					t(We(e)), t(Mt(e))
				}, Dt = e => {
					let {
						parentCommentId: t,
						commentsPageKey: n
					} = e;
					return async (e, s) => {
						e(jt({
							parentCommentId: t,
							commentsPageKey: n
						})), e(St({
							parentCommentId: t,
							commentsPageKey: n
						})), e(We({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, Ct = (e, t) => n => n(ht({
					draftKey: e,
					formData: t
				})), wt = "COMMENT__DISABLE_AUTOFOCUS", At = Object(c.a)(wt), Rt = e => t => t(At({
					draftKey: e
				})), Pt = "COMMENT__EDIT_COMMENT_ENABLED", kt = "COMMENT__REQUEST_EDIT_PENDING", xt = "COMMENT__REQUEST_EDIT_FAILURE", Nt = "COMMENT__REQUEST_EDIT_SUCCESS", Lt = "COMMENT__COMMENT_EDIT_FORM_CANCELLED", Ut = Object(c.a)(Pt), Mt = e => {
					let {
						commentId: t,
						commentMode: n,
						commentsPageKey: s,
						draftKey: r,
						text: o
					} = e;
					return async (e, a) => {
						const c = a();
						c.user.account && (J.c(c), e(Ut({
							commentId: t,
							commentsPageKey: s,
							draftKey: r,
							formData: {
								text: o,
								commentMode: n,
								rteState: null,
								draftType: $.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Ft = Object(c.a)(kt), Gt = Object(c.a)(xt), Bt = Object(c.a)(Nt), qt = Object(c.a)(Lt), Vt = e => {
					let {
						id: t,
						commentsPageKey: n,
						depth: s,
						draftKey: r,
						formData: o
					} = e;
					return async (e, s, c) => {
						let {
							apiContext: i
						} = c;
						const d = s();
						if (!d.user.account) return;
						e(Ft({
							draftKey: r
						})), J.d(d);
						const u = d.user.account.displayText || "",
							l = o.commentMode,
							b = await (async (e, t, n, s, r, o) => {
								const c = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: t
								};
								if (o === G.h.MARKDOWN) c.text = s.text;
								else {
									c.text = null;
									let e = null;
									s.rteState && (e = y.a.toRichTextJSON(s.rteState).document), c.richtext_json = JSON.stringify({
										document: e
									})
								}
								return Object(E.b)(Object(I.a)(e, [v.a]), {
									endpoint: Object(S.a)(Object(C.a)(Object(D.a)("".concat(e.apiUrl, "/api/editusertext")))),
									method: a.ab.POST,
									data: c
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? Object.assign({}, e, {
									ok: !1,
									error: Object(F.a)(e)
								}) : Object.assign({}, e, {
									body: {
										comment: Object(M.a)(e.body.json.data.things[0].data, r)
									}
								}) : Object.assign({}, e, {
									body: {
										comment: Object(M.a)(e.body, r)
									}
								}) : Object.assign({}, e, {
									error: e.error || Object(U.a)()
								}))
							})(i(), t, 0, o, u, l);
						if (b.ok) {
							const s = b.body;
							e(Bt({
								commentId: t,
								commentsPageKey: n,
								draftKey: r
							})), e(fe({
								[t]: Object.assign({}, s.comment)
							}))
						} else e(Gt({
							draftKey: r,
							error: b.error
						}))
					}
				}, Kt = "COMMENT__REQUEST_DELETE_PENDING", Ht = "COMMENT__REQUEST_DELETE_FAILURE", Wt = "COMMENT__REQUEST_DELETE_SUCCESS", Yt = Object(c.a)(Kt), Qt = Object(c.a)(Ht), zt = Object(c.a)(Wt), Jt = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const c = s();
					n(Yt({
						id: e
					})), J.a(e, c);
					const i = await ((e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
						endpoint: Object(S.a)("".concat(e.apiUrl, "/api/del")),
						method: a.ab.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? Object.assign({}, e, {
						ok: !1,
						error: Object(F.a)(e)
					}) : Object.assign({}, e, {
						body: {}
					}) : Object.assign({}, e, {
						error: e.error || Object(U.a)()
					})))(o(), e);
					i.ok ? n(zt({
						id: e,
						postId: t
					})) : n(Qt({
						id: e,
						error: i.error
					}))
				}, Xt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = !n().comments.models[e].sendReplies;
					t(fe({
						[e]: {
							sendReplies: o
						}
					})), (await Object(V.p)(r(), e, o)).ok || t(fe({
						[e]: {
							sendReplies: !o
						}
					}))
				}, Zt = "COMMENT__CHANGE_HIGHLIGHT_FILTER", $t = Object(c.a)(Zt)
		},
		"./src/reddit/actions/comment/list.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/helpers/trackers/commentList.ts");
			const o = "COMMENTLIST__MARKED_END",
				a = "COMMENTLIST__UNMARKED_END",
				c = Object(s.a)(o),
				i = Object(s.a)(a),
				d = (e, t) => async (n, s) => {
					const o = s();
					e in o.profileCommentsPage.fetchedTokens ? e in o.profileCommentsPage.commentIds ? n(i({
						listingKey: e
					})) : Object(r.a)(o, e) : n(c({
						listingKey: e,
						listingName: t
					}))
				}
		},
		"./src/reddit/actions/comment/websocket/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "COMMENT__LIVECOMMENTS__NEWCOMMENT",
				r = "COMMENT__LIVECOMMENTS__UPDATECOMMENT",
				o = "COMMENT__LIVECOMMENTS_DELETECOMMENT"
		},
		"./src/reddit/actions/commentsListTruncated/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "COMMENTS_LIST__EXPANDED",
				r = "COMMENTS_LIST__TRUNCATED"
		},
		"./src/reddit/actions/communityFlairs/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			const s = "TOP_COMMUNITY_FLAIR__FETCH_FAILURE",
				r = "TOP_COMMUNITY_FLAIR__FETCH_PENDING",
				o = "TOP_COMMUNITY_FLAIR__FETCH_SUCCESS",
				a = "COMMUNITY_FLAIR__ADD_FLAIRS"
		},
		"./src/reddit/actions/communityFlairs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "c", (function() {
				return I
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "d", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/camelCase.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/isEmpty.js"),
				a = n.n(o),
				c = n("./node_modules/lodash/omit.js"),
				i = n.n(c),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/endpoints/flair/index.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				b = n("./src/reddit/models/Flair/index.ts"),
				p = n("./src/reddit/selectors/communityFlairs.ts"),
				f = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/actions/communityFlairs/constants.ts");
			const O = Object(d.a)(m.c),
				g = Object(d.a)(m.d),
				_ = Object(d.a)(m.b),
				y = Object(d.a)(m.a),
				j = e => {
					const t = {};
					for (const n in e) {
						t[r()(n)] = e[n]
					}
					return t
				},
				h = (e, t) => async (n, s) => {
					const o = s(),
						c = Object(p.b)(o, t),
						d = Object(p.c)(o, t) || [],
						u = (e => {
							const t = {};
							return e.map(e => {
								const n = Object(l.g)(e),
									s = r()(n),
									o = s && t.hasOwnProperty(s);
								e.type !== b.f.Spoiler && e.type !== b.f.Nsfw && (o || (t[s] = Object.assign({}, e, {
									id: s
								})))
							}), t
						})(e),
						f = i()(u, d);
					if (a()(f)) return;
					const m = Object.keys(f),
						O = d ? d.concat(m) : m,
						g = c ? Object.assign({}, c, f) : f;
					n(y({
						models: g,
						sortedKeys: O,
						subredditId: t
					}))
				}, E = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = Object(f.E)(n(), e);
					t(O());
					const a = await Object(u.c)(r(), e);
					if (a.ok) {
						const e = a.body.map(j).map(e => Object(l.c)(e));
						t(h(e, o)), t(g())
					} else t(_())
				}, I = (e, t) => {
					const n = [];
					for (const s in e) {
						const r = e[s],
							o = r.belongsTo && r.belongsTo.id === t;
						r.flair && r.flair.length && o && n.push(...r.flair)
					}
					return n
				}, v = e => {
					const t = e && e.data && e.data.content && e.data.content.widgets;
					if (t) {
						const e = t.items;
						for (const t in e) {
							const n = e[t];
							if ("post-flair" === n.kind) return n
						}
					}
				}, S = e => {
					const t = [],
						{
							templates: n
						} = e;
					for (const s in n) {
						const e = n[s];
						e && t.push(e)
					}
					return t
				}
		},
		"./src/reddit/actions/contentGate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "o", (function() {
				return I
			})), n.d(t, "q", (function() {
				return v
			})), n.d(t, "r", (function() {
				return S
			})), n.d(t, "t", (function() {
				return T
			})), n.d(t, "p", (function() {
				return D
			})), n.d(t, "u", (function() {
				return C
			})), n.d(t, "s", (function() {
				return w
			})), n.d(t, "k", (function() {
				return A
			})), n.d(t, "l", (function() {
				return R
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/js-cookie/src/js.cookie.js"),
				o = n.n(r),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/constants/cookie.ts"),
				i = n("./src/reddit/endpoints/user/preferences.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = "CONTENTGATE__VISITED_GOLD_SUBREDDIT",
				l = "CONTENTGATE__VISITED_PRIVATE_SUBREDDIT",
				b = "CONTENTGATE__VISITED_QUARANTINED_SUBREDDIT",
				p = "CONTENTGATE__SET_OVER_18_PREF",
				f = "CONTENTGATE__VISITED_BANNED_SUBREDDIT",
				m = "CONTENTGATE__VISITED_SUBREDDIT_BLOCKED_FOR_LEGAL_REASON",
				O = "CONTENTGATE__VISITED_NONEXISTENT_SUBREDDIT",
				g = "CONTENTGATE__VISITED_DELETED_PROFILE",
				_ = "CONTENTGATE__VISITED_SUSPENDED_PROFILE",
				y = "CONTENTGATE__VISITED_PROFILE_BLOCKED_FOR_LEGAL_REASON",
				j = Object(a.a)(p),
				h = Object(a.a)(f),
				E = Object(a.a)(m),
				I = Object(a.a)(O),
				v = Object(a.a)(u),
				S = Object(a.a)(l),
				T = Object(a.a)(b),
				D = Object(a.a)(g),
				C = Object(a.a)(_),
				w = Object(a.a)(y),
				A = () => {
					const e = new Date;
					e.setFullYear(e.getFullYear() + 2), o.a.set(c.f, "1", {
						expires: e,
						domain: s.a.cookieDomain
					})
				},
				R = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					Object(d.H)(r) && r.platform.currentPage && await Object(i.f)(s()), e(j({
						over18: !0
					}))
				}
		},
		"./src/reddit/actions/dashboard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "DASHBOARD__COMPONENT_SELECTED",
				o = "DASHBOARD__SUBREDDIT_SELECTED",
				a = "DASHBOARD__SUBREDDIT_LOADED",
				c = Object(s.a)(r),
				i = Object(s.a)(o),
				d = Object(s.a)(a)
		},
		"./src/reddit/actions/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "h", (function() {
				return T
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeListingKey/index.ts"),
				a = (n("./src/lib/addQueryParams/index.ts"), n("./src/lib/makeApiRequest/index.ts")),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = (n("./src/lib/stringInterpolate/index.ts"), n("./src/reddit/constants/headers.ts")),
				d = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				u = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var l = n("./src/reddit/selectors/discoveryUnit.ts"),
				b = n("./src/reddit/selectors/listings.ts");
			const p = "DISCOVERY_UNIT__LIST_PENDING",
				f = "DISCOVERY_UNIT__LIST_LOADED",
				m = "DISCOVERY_UNIT__LIST_FAILED",
				O = Object(r.a)(p),
				g = Object(r.a)(f),
				_ = Object(r.a)(m),
				y = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t(),
						o = Object(l.e)(r),
						a = Object(l.d)(r);
					if (o || a) return;
					e(O());
					const c = await (e => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_88",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Similar communities to %{subredditName}",
										unit_name: "chaining_similar_subreddits_posts",
										unit_type: "listing"
									}, {
										id: "xd_89",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Mildy similar posts",
										unit_name: "chaining_similar_posts",
										unit_type: "listing"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(s());
					if (c.ok) {
						const {
							discoveryUnits: t
						} = (e => {
							return {
								discoveryUnits: e.global.discovery_config_v1.discovery_units.reduce((e, t) => {
									const n = {
										enabled: t.enabled,
										experiment: t.experiment,
										id: t.id,
										index: t.index,
										layout: t.layout,
										options: t.options,
										parameters: t.parameters,
										subtitle: t.subtitle,
										subtitleIcon: t.subtitle_icon,
										surface: t.surface,
										title: t.title,
										unitName: t.unit_name,
										unitType: t.unit_type,
										url: t.url
									};
									return e[n.id] = n, e
								}, {})
							}
						})(c.body);
						e(g({
							discoveryUnits: t
						}))
					} else e(_({
						error: c.error
					}))
				}, j = "DISCOVERY_UNIT__UNIT_DATA_PENDING", h = "DISCOVERY_UNIT__UNIT_DATA_LOADED", E = "DISCOVERY_UNIT__UNIT_DATA_FAILED", I = Object(r.a)(j), v = Object(r.a)(h), S = Object(r.a)(E), T = (e, t) => async (n, r, l) => {
					let {
						apiContext: p
					} = l;
					const f = r(),
						m = Object(o.a)(e, s.M.HOT, {
							category: t
						}),
						O = Object(b.h)(f, {
							listingKey: m
						}),
						g = !!f.listings.listingOrder.fetchedTokens[m];
					if (O || g) return;
					n(I({
						key: m
					}));
					const _ = await ((e, t) => Object(a.b)(Object(c.a)(e, [i.a]), {
						endpoint: Object(u.a)("".concat(e.apiUrl, "/api/posts_in_category.json?category=").concat(t)),
						method: s.ab.GET
					}))(p(), t);
					if (_.ok) {
						const {
							postIds: e,
							posts: t
						} = (e => {
							const t = [],
								n = {};
							return e.data.children.forEach(e => {
								const s = Object(d.a)(e.data);
								t.push(s.id), n[s.id] = s
							}), {
								postIds: t,
								posts: n
							}
						})(_.body), s = e.length > 0 ? e.length - 1 : 0;
						n(v({
							key: m,
							meta: f.meta,
							postIds: e,
							posts: t,
							token: e[s]
						}))
					} else n(S({
						key: m,
						error: _.error
					}))
				}
		},
		"./src/reddit/actions/dismissedTruncationList/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "DISMISSED_TRUNCATION_LIST__ADD_SUBREDDIT_ID"
		},
		"./src/reddit/actions/downToChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "i", (function() {
				return L
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/chat/toggle.ts"),
				o = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/constants/modals.ts"),
				i = n("./src/config.ts"),
				d = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			const p = "".concat("api/v1", "/sendbird");
			var f = n("./src/reddit/helpers/parseUrl.ts"),
				m = n("./src/reddit/selectors/telemetry.ts"),
				O = n("./src/telemetry/models/Event.ts");
			var g = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/downToChat.ts"),
				y = n("./src/telemetry/index.ts");
			const {
				fbt: j
			} = n("./node_modules/fbt/lib/FbtPublic.js"), h = "FETCH_DOWN_TO_CHAT_AVAILABILITY__PENDING", E = "FETCH_DOWN_TO_CHAT_AVAILABILITY__SUCCESS", I = "FETCH_DOWN_TO_CHAT_AVAILABILITY__FAILED", v = "DISMISS_DOWN_TO_CHAT_BANNER__PENDING", S = "DISMISS_DOWN_TO_CHAT_BANNER__SUCCESS", T = "DISMISS_DOWN_TO_CHAT_BANNER__FAILED", D = "DISMISS_EACH_SUBREDDIT_BANNER", C = Object(s.a)(h), w = Object(s.a)(E), A = Object(s.a)(I), R = Object(s.a)(v), P = Object(s.a)(S), k = (Object(s.a)(T), Object(s.a)(D)), x = e => async (t, n, s) => {
				let {
					apiContext: r
				} = s;
				const o = n();
				if (Object(_.a)(o, e)) return;
				t(C({
					subredditId: e
				}));
				const a = await (async (e, t) => Object(u.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(i.a.sendbirdServiceUrl, "/").concat(p, "/down_to_chat/availability"),
					method: d.ab.GET,
					type: "json",
					data: {
						subreddit_id: t
					}
				}))(r(), e);
				if (a.ok && a.body) {
					if (t(w({
							subredditId: e,
							bannerEnabled: !!a.body.feature_enabled,
							buttonEnabled: !!a.body.experiment_enabled
						})), a.body.feature_enabled) {
						const e = (e => Object.assign({
							source: O.b.Chat,
							action: O.a.View,
							noun: "down_to_chat_subreddit_entry",
							subreddit: Object(m.subreddit)(e)
						}, Object(m.defaults)(e)))(o);
						Object(y.a)(e)
					}
				} else t(A({
					subredditId: e,
					error: "Failed to fetch subreddit's down to chat availability data"
				}))
			}, N = e => async (t, n, s) => {
				let {
					apiContext: r
				} = s;
				t(R({
					subredditId: e
				}));
				const o = await (async (e, t) => Object(u.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(i.a.sendbirdServiceUrl, "/").concat(p, "/down_to_chat/availability"),
					method: d.ab.DELETE,
					data: {
						subreddit_id: t
					}
				}))(r(), e);
				o.ok && o.body && (t(P({
					subredditId: e,
					bannerEnabled: !!o.body.feature_enabled,
					buttonEnabled: !!o.body.experiment_enabled
				})), o.body.feature_enabled || t(k()));
				const a = (e => Object.assign({
					source: O.b.Chat,
					action: O.a.Dismiss,
					noun: "down_to_chat_subreddit_entry",
					subreddit: Object(m.subreddit)(e)
				}, Object(m.defaults)(e)))(n());
				Object(y.a)(a)
			}, L = e => async (t, n, s) => {
				let {
					apiContext: _
				} = s;
				const h = await (async (e, t) => Object(u.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(i.a.sendbirdServiceUrl, "/").concat(p, "/down_to_chat/join"),
					method: d.ab.POST,
					type: "json",
					data: {
						subreddit_id: t
					}
				}))(_(), e);
				if (h.ok && h.body && h.body.deeplink_url) {
					t(Object(o.i)(c.a.DOWN_TO_CHAT_PENDING_MODAL));
					const e = Object(f.a)(h.body.deeplink_url);
					e && e.pathname && t(Object(r.b)({
						channelUrl: e.pathname
					}))
				} else t(Object(a.e)({
					kind: g.b.Error,
					text: j._("Failed to join a subreddit channel", null, {
						hk: "mZam3"
					})
				}));
				setTimeout(() => t(Object(o.f)()), 1e3);
				const E = (e => Object.assign({
					source: O.b.Chat,
					action: O.a.Click,
					noun: "down_to_chat_subreddit_entry",
					subreddit: Object(m.subreddit)(e)
				}, Object(m.defaults)(e)))(n());
				Object(y.a)(E)
			}
		},
		"./src/reddit/actions/economics/banners/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			const s = "ECONOMICS__BANNERS__DISMISSED_BANNERS_PENDING",
				r = "ECONOMICS__BANNERS__DISMISSED_BANNERS_UPDATED",
				o = "ECONOMICS__BANNERS__BANNER_DISMISSED",
				a = "ECONOMICS__BANNERS__BANNER_UNDISMISSED"
		},
		"./src/reddit/actions/economics/ftue/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "ECONOMICS__FTUE__TIPPING_HIGHLIGHT_VIEWED",
				r = "ECONOMICS__FTUE__TOP_TIPPERS_VIEWED"
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => async t => {
				const s = await (() => Promise.all([n.e("vendors~EconHelperActions~SubredditPremiumBadgeManagement"), n.e("EconHelperActions")]).then(n.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(s(e))
			}
		},
		"./src/reddit/actions/economics/me/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "ECONOMICS__ME__ME_DATA_SUCCESS",
				r = "ECONOMICS__ME__POINTS_COPY_REQUESTED",
				o = "ECONOMICS__ME__POINTS_COPY_SUCCESS"
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			const s = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				r = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				a = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				c = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			}));
			const s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				r = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__PURCHASE_MODAL_OPENED",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS",
				b = "ECONOMICS__SUBREDDIT_PREMIUM__UPLOAD_MODAL_OPENED"
		},
		"./src/reddit/actions/economics/support/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "ECONOMICS__SUPPORT__SUPPORT_MODAL_OPENED",
				r = "ECONOMICS__SUPPORT__TOTAL_SUPPORT_INCREASED"
		},
		"./src/reddit/actions/economics/tips/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "ECONOMICS__TIPS__TIP_DETAILS_SUCCESS"
		},
		"./src/reddit/actions/emailVerificationTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "EMAIL_VERIFICATION_TOOLTIP_TOGGLED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/embedAndImage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "EMBEDS__UNLOADABLE",
				o = "EMBEDS__LOADABLE",
				a = Object(s.a)(r),
				c = Object(s.a)(o)
		},
		"./src/reddit/actions/emoji.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return I
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "h", (function() {
				return w
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "f", (function() {
				return R
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "q", (function() {
				return M
			})), n.d(t, "p", (function() {
				return G
			})), n.d(t, "l", (function() {
				return B
			})), n.d(t, "m", (function() {
				return q
			})), n.d(t, "j", (function() {
				return V
			})), n.d(t, "k", (function() {
				return K
			})), n.d(t, "b", (function() {
				return H
			})), n.d(t, "n", (function() {
				return Y
			})), n.d(t, "e", (function() {
				return Q
			})), n.d(t, "o", (function() {
				return J
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/forEach.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/lib/uploadToS3/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			const l = async (e, t) => Object(c.b)(Object(i.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emojis/all"),
				method: a.ab.GET,
				type: "json"
			}).then(e => (e.ok && (e.body = (e => {
				let t;
				const n = o()(e, (e, n) => ("snoomojis" !== n && (t = n), o()(e, (t, n) => {
					e[n] = {
						name: n,
						userFlairAllowed: t.user_flair_allowed,
						postFlairAllowed: t.post_flair_allowed,
						modFlairOnly: t.mod_flair_only,
						url: t.url
					}
				})));
				return {
					[t]: {
						emojis: n[t],
						snoomojis: n.snoomojis
					}
				}
			})(e.body)), e));
			var b = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/reddit/actions/imageUploads.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				m = n("./src/reddit/helpers/getGenericUploadError.ts"),
				O = n("./src/reddit/helpers/getS3KeyFromUrl/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				_ = n("./src/reddit/models/Emoji/index.ts"),
				y = n("./src/reddit/models/Image/index.tsx"),
				j = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/selectors/emojis.ts"),
				E = n("./src/reddit/selectors/subreddit.ts");
			const I = "STRUCTURED_STYLES__NEW_EMOJI_ADDED",
				v = Object(b.a)(I),
				S = "STRUCTURED_STYLES__EMOJI_DELETE_LOADED",
				T = "STRUCTURED_STYLES__EMOJI_DELETE_FAILED",
				D = Object(b.a)(S),
				C = Object(b.a)(T),
				w = "GET_ALL_EMOJIS_PENDING",
				A = "GET_ALL_EMOJIS_LOADED",
				R = "GET_ALL_EMOJIS_FAILED",
				P = Object(b.a)(w),
				k = Object(b.a)(A),
				x = Object(b.a)(R),
				N = "STRUCTURED_STYLES__EMOJIS_ENABLED_SETTING_LOADED",
				L = Object(b.a)(N),
				U = e => ({
					text: s.fbt._("Failed to save emoji", null, {
						hk: "3i6FC2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "1XMjgA"
					}),
					buttonAction: G(e)
				}),
				M = e => {
					let {
						imageData: t,
						subredditId: n
					} = e;
					return async (e, s, r) => {
						const o = s(),
							l = Object(E.Q)(o, {
								subredditId: n
							}).name;
						e(Object(p.k)(t));
						const b = t.file,
							f = await Object(g.g)(b),
							m = await (async (e, t, n, s) => Object(c.b)(Object(i.a)(e, [u.a]), {
								endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji_asset_upload_s3.json"),
								method: a.ab.POST,
								data: {
									filepath: n,
									mimetype: s
								}
							}))(r.apiContext(), l, b.name, f);
						let O = !1;
						if (m.ok) {
							const n = await (async (e, t, n) => Object(d.a)(n, t))(r.apiContext(), m.body.s3UploadLease, b);
							if (n.ok) {
								if (!s().imageUploads[t.id]) return Object(y.d)(t), !1;
								const r = decodeURIComponent(n.body.PostResponse.Location),
									o = m.body.websocketUrl,
									a = Object(y.n)(t, r, o);
								e(Object(p.j)(a)), O = !0
							} else {
								const s = Object(y.k)(t, n.error);
								e(Object(p.i)(s))
							}
						} else {
							const n = Object(y.k)(t, m.error);
							e(Object(p.i)(n))
						}
						return O
					}
				},
				F = (e, t) => async (n, s, r) => {
					const {
						imageData: o,
						subredditId: d,
						emojiName: l,
						settings: b
					} = e, m = Object(O.a)(o.url), g = s(), _ = Object(E.Q)(g, {
						subredditId: d
					}).name, j = await (async (e, t, n, s, r) => Object(c.b)(Object(i.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji.json"),
						method: a.ab.POST,
						data: {
							s3_key: n,
							name: s,
							mod_flair_only: r.modFlairOnly,
							post_flair_allowed: r.postFlairAllowed,
							user_flair_allowed: r.userFlairAllowed
						}
					}))(r.apiContext(), _, m, l, b);
					if (!j.ok) {
						const s = Object(y.k)(o, j.error);
						n(Object(p.i)(s)), n(Object(f.e)(U(e))), t && t.close()
					}
					return j.ok
				}, G = e => async (t, n, s) => {
					const {
						imageData: r,
						subredditId: o,
						emojiName: a,
						settings: c
					} = e;
					if (t(Object(p.k)(r)), !r.websocketUrl) return t(Object(f.e)({
						text: "Could not upload emoji"
					}));
					let i;
					const d = new WebSocket(r.websocketUrl);
					return d.onopen = async () => {
						i = await F(e, d)(t, n, s)
					}, d.onmessage = n => {
						const s = JSON.parse(n.data);
						if ("success" === s.type) {
							i = !0;
							const e = s.payload.emoji_url,
								n = Object(y.o)(r, e);
							t(Object(p.l)(n));
							const d = Object(_.e)(a, n.url, o, c);
							t(v(d)), t(B(o))
						} else {
							const n = Object(m.a)(a),
								s = Object(y.k)(r, n);
							t(Object(p.i)(s)), t(Object(f.e)(U(e)))
						}
						d.close()
					}, d.onerror = n => {
						i = !1;
						const s = Object(m.a)(a),
							o = Object(y.k)(r, s);
						t(Object(p.i)(o)), t(Object(f.e)(U(e))), d.close()
					}, i
				}, B = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n();
					if (Object(h.a)(o, e)) return;
					const a = Object(E.Q)(o, {
						subredditId: e
					}).name;
					t(P(e));
					const c = await l(r(), a);
					if (c.ok) {
						const n = c.body;
						t(k({
							subredditId: e,
							data: n
						}))
					} else t(x({
						subredditId: e,
						error: c.error
					}))
				}, q = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().emojis[e] || await t(B(e))
				}, V = (e, t) => async (n, r, o) => {
					let {
						apiContext: d
					} = o;
					const l = r(),
						b = Object(E.Q)(l, {
							subredditId: t
						}).name,
						p = await (async (e, t, n) => Object(c.b)(Object(i.a)(e, [u.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(n, "/emoji/").concat(t),
							method: a.ab.DELETE,
							type: "json"
						}))(d(), e, b);
					if (p.ok) {
						n(D({
							emojiName: e,
							subredditId: t
						})), n(f.e({
							kind: j.b.SuccessCommunityGreen,
							text: s.fbt._("Emoji successfully deleted", null, {
								hk: "1zMXEe"
							})
						}))
					} else n(C(p.error)), n(f.e({
						kind: j.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, K = (e, t) => async (n, r, o) => {
					let {
						apiContext: d
					} = o;
					const l = r(),
						b = Object(E.Q)(l, {
							subredditId: e
						}).name;
					if ((await (async (e, t, n) => Object(c.b)(Object(i.a)(e, [u.a]), {
							endpoint: "".concat(e.apiUrl, "/api/enable_emojis_in_sr.json"),
							method: a.ab.POST,
							data: {
								subreddit: t,
								enable: n
							}
						}))(d(), b, t)).ok) {
						n(L({
							subredditId: e,
							emojisEnabled: t
						}))
					} else n(f.e({
						kind: j.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, H = "EMOJI_CUSTOM_SIZE_UPDATED", W = Object(b.a)(H), Y = (e, t) => async (n, r, o) => {
					let {
						apiContext: d
					} = o;
					const l = r(),
						b = Object(E.Q)(l, {
							subredditId: e
						}).name;
					(await (async (e, t, n) => Object(c.b)(Object(i.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji_custom_size"),
						method: a.ab.POST,
						data: n
					}))(d(), b, t)).ok ? n(W({
						subredditId: e,
						emojiCustomSize: t
					})) : n(f.e({
						kind: j.b.Error,
						text: s.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}, Q = "EMOJI_PERMISSIONS_UPDATED", z = Object(b.a)(Q), J = (e, t, n, r) => async (o, d, l) => {
					let {
						apiContext: b
					} = l;
					const p = d(),
						m = Object(E.Q)(p, {
							subredditId: r
						}).name;
					(await (async (e, t, n, s) => Object(c.b)(Object(i.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(n, "/emoji_permissions.json"),
						method: a.ab.POST,
						data: {
							name: t,
							post_flair_allowed: s.postFlairAllowed,
							user_flair_allowed: s.userFlairAllowed,
							mod_flair_only: s.modFlairOnly
						}
					}))(b(), e, m, n)).ok ? (o(z({
						emojiName: e,
						isSnoomoji: t,
						settings: n,
						subredditId: r
					})), o(f.e({
						kind: j.b.SuccessCommunityGreen,
						text: s.fbt._("Emoji permissions updated", null, {
							hk: "4b2RIU"
						})
					}))) : o(f.e({
						kind: j.b.Error,
						text: s.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}
		},
		"./src/reddit/actions/eventPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			}));
			const s = "MOD_PAGE_EVENT_POSTS_LOADED",
				r = "MOD_PAGE_EVENT_POSTS_FAILED",
				o = "MOD_PAGE_EVENT_POSTS_PENDING",
				a = "MOD_PAGE_EVENT_POSTS_MORE_LOADED",
				c = "START_EVENT_NOW_SUCCESS",
				i = "EDIT_EVENT_TIME_SUCCESS"
		},
		"./src/reddit/actions/experiments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./src/lib/makeActionCreator/index.ts");
			n("./src/reddit/endpoints/user/index.ts"), n("./src/reddit/models/Post/index.ts"), n("./src/reddit/selectors/telemetry.ts");
			const r = "EXPERIMENTS__REQUEST_LOADED",
				o = (Object(s.a)("EXPERIMENTS__REQUEST_PENDING"), Object(s.a)("EXPERIMENTS__REQUEST_FAILED"), Object(s.a)(r), "EXPERIMENTS__SET_EXPERIMENT_OVERRIDE"),
				a = Object(s.a)(o)
		},
		"./src/reddit/actions/exportImportStyles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "e", (function() {
				return h
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/structuredStyles/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/models/StructuredStyles/index.ts"),
				d = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const l = "STRUCTURED_STYLES__EXPORT_THEME_PENDING",
				b = "STRUCTURED_STYLES__EXPORT_THEME_LOADED",
				p = "STRUCTURED_STYLES__EXPORT_THEME_FAILED",
				f = Object(o.a)(l),
				m = Object(o.a)(b),
				O = Object(o.a)(p),
				g = Object(o.a)("STRUCTURED_STYLES__IMPORT_THEME_PENDING"),
				_ = Object(o.a)("STRUCTURED_STYLES__IMPORT_THEME_LOADED"),
				y = Object(o.a)("STRUCTURED_STYLES__IMPORT_THEME_FAILED"),
				j = e => async (t, o) => {
					t(f());
					const a = o(),
						i = Object(u.Q)(a, {
							subredditId: e
						}).name,
						l = a.structuredStyles.models[e],
						b = await Object(r.a)(() => Promise.all([n.e("vendors~ExportTheme~ImportTheme"), n.e("ExportTheme")]).then(n.bind(null, "./src/reddit/helpers/exportTheme/index.ts"))).then(e => e.default),
						p = await b(l, i);
					p.ok ? (t(m()), t(Object(c.e)({
						kind: d.b.SuccessMod,
						text: s.fbt._("Theme successfully exported", null, {
							hk: "24KHqI"
						})
					}))) : (t(O(p.error)), t(Object(c.e)({
						kind: d.b.Error,
						text: s.fbt._("Sorry, theme failed to export", null, {
							hk: "2MC4jC"
						})
					})))
				}, h = e => async (t, o) => {
					t(g());
					const u = await Object(r.a)(() => Promise.all([n.e("vendors~ExportTheme~ImportTheme"), n.e("ImportTheme")]).then(n.bind(null, "./src/reddit/helpers/importTheme/index.ts"))).then(e => e.default),
						l = await u(e);
					l.ok ? (t(_()), t(Object(c.e)({
						kind: d.b.SuccessMod,
						text: s.fbt._("Theme successfully imported", null, {
							hk: "42FErS"
						})
					})), 0 !== Object.keys(l.attributes).length && t(Object(a.d)(Object(i.j)(l.attributes)))) : (t(y(l.error)), t(Object(c.e)({
						kind: d.b.Error,
						text: s.fbt._("Sorry, theme failed to import", null, {
							hk: "4BqW32"
						})
					})))
				}
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return j
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "i", (function() {
				return I
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "o", (function() {
				return P
			})), n.d(t, "p", (function() {
				return k
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "n", (function() {
				return G
			})), n.d(t, "e", (function() {
				return B
			})), n.d(t, "f", (function() {
				return q
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "m", (function() {
				return Y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/constants/parameters.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var f = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/models/User/index.ts"),
				O = n("./src/reddit/selectors/externalAccount.ts"),
				g = n("./src/reddit/selectors/platform.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/selectors/user.ts");
			const j = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				h = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				I = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				v = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				S = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				T = Object(r.a)(j),
				D = Object(r.a)(h),
				C = Object(r.a)(E),
				w = Object(r.a)(I),
				A = Object(r.a)(v),
				R = Object(r.a)(S),
				P = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = Object(y.i)(o),
						c = e || a && Object(m.e)(a);
					if (!c) return;
					if (Object(O.d)(o, {
							username: c
						})) return;
					t(T(c));
					const f = await ((e, t) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/user/").concat(t, ".json")),
						method: i.ab.GET
					}))(r(), c);
					if (f.ok) {
						const e = p(f.body);
						t(D({
							username: c,
							accountsData: e
						}))
					} else t(C(f.error))
				}, k = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t(),
						o = Object(g.e)(r);
					if (!o) return;
					const a = r.externalAccount.api.subreddit.fetched[o],
						c = r.externalAccount.api.subreddit.pending[o];
					if (a || c) return;
					const f = Object(_.w)(r, {
						subredditName: o
					});
					if (!(f && f.hasExternalAccount)) return;
					e(w(o));
					const m = await ((e, t) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/subreddit/").concat(t, ".json")),
						method: i.ab.GET
					}))(s(), o);
					if (m.ok) {
						const t = p(m.body);
						e(A({
							subredditName: o,
							accountsData: t
						}))
					} else e(R(m.error))
				}, x = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", N = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", L = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", U = Object(r.a)(x), M = Object(r.a)(N), F = Object(r.a)(L), G = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(U({
						provider: e
					}));
					const o = Object(y.i)(n()),
						a = Object(m.e)(o),
						c = await ((e, t) => Object(d.b)(Object(u.a)(e, [l.a]), {
							endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/").concat(t, "/disconnect.json")),
							method: i.ab.POST
						}))(r(), e);
					c.ok ? t(M({
						provider: e,
						username: a
					})) : t(F({
						provider: e,
						error: c.error
					}))
				}, B = "OAUTH_FLOW_URL_PENDING", q = "OAUTH_FLOW_URL_SUCCESS", V = "OAUTH_FLOW_URL_FAILED", K = Object(r.a)(B), H = Object(r.a)(q), W = Object(r.a)(V), Y = e => async (t, n, r) => {
					let {
						apiContext: p
					} = r;
					t(K({
						provider: e
					}));
					const m = Object(o.a)(window.location.href, {
							[c.c]: e
						}),
						O = await ((e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
							endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/").concat(t, "/connect.json")),
							method: i.ab.POST,
							data: {
								redirect_url: n
							}
						}))(p(), e, m);
					if (O.ok) {
						const {
							redirect_url: n
						} = O.body;
						t(H({
							provider: e
						})), window.location.href = n
					} else t(W({
						provider: e,
						error: O.error
					})), t(Object(a.e)({
						kind: f.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/flairManagement/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "FLAIR_PREVIEW_EXAMPLE_POST_CREATED",
				r = "FLAIR_PREVIEW_EXAMPLE_POST_DELETED"
		},
		"./src/reddit/actions/focusedVerticals/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "b", (function() {
				return I
			}));
			var s, r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/focusedVerticals/constants.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/graphql/operations/SubredditGeoRecommendationViaFocusVertical.json");
			! function(e) {
				e.LoggedInGeo = "2.1", e.LoggedOutGeo = "2.1"
			}(s || (s = {}));
			var i, d = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			! function(e) {
				e.DEFAULT = "DEFAULT", e.GEO = "GEO"
			}(i || (i = {}));
			var l = n("./src/reddit/selectors/focusedVerticalSuggestion.ts");
			const b = Object(r.a)(o.g),
				p = Object(r.a)(o.e),
				f = Object(r.a)(o.h),
				m = Object(r.a)(o.c),
				O = Object(r.a)(o.f),
				g = Object(r.a)(o.j),
				_ = Object(r.a)(o.i),
				y = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const o = t(),
						i = Object(l.e)(o),
						O = Object(l.d)(o),
						g = o.user.temporaryGQL.isLoggedIn;
					if (i || !O) return;
					e(f());
					let _ = !1;
					try {
						const t = g ? s.LoggedInGeo : s.LoggedOutGeo,
							n = await ((e, t, n) => Object(a.a)(e, Object.assign({}, c, {
								variables: {
									version: t,
									isNsfwIncluded: !1
								}
							})))(r(), t);
						if (n.ok && n.body) {
							const {
								data: t
							} = n.body;
							if (j(t)) {
								if (h(t)) {
									e(m({
										recommendedSubredditIds: [],
										interactedSubredditIds: [],
										category: "",
										lastLoadedEnv: "client"
									})), _ = !0
								} else if (E(t)) {
									const n = t.focusVerticalSubredditRecommendations,
										{
											recommendedSubreddit: s,
											interactedSubreddit: r,
											category: o
										} = n.focusRecommendations[0],
										a = [s, r],
										c = Object(u.d)(a),
										i = Object(d.b)(a),
										l = Object(u.c)(s),
										p = {
											recommendedSubredditIds: [s.id],
											interactedSubredditIds: [r.id],
											subreddits: c,
											subredditsAboutInfo: i,
											subredditTopContent: l,
											category: o,
											lastLoadedEnv: "client"
										};
									e(b(p)), _ = !0
								}
							} else _ = !1
						}
					} catch (y) {
						_ = !1
					}
					_ || e(p({
						error: {
							type: "Focused vertical experiment GQL API failed or caught by try and catch"
						}
					}))
				}, j = e => {
					const t = e.focusVerticalSubredditRecommendations;
					return !(!t || !t.focusRecommendations)
				}, h = e => {
					const t = e.focusVerticalSubredditRecommendations,
						n = t && t.focusRecommendations;
					return !(!n || 0 !== n.length)
				}, E = e => {
					const t = e.focusVerticalSubredditRecommendations,
						n = t && t.focusRecommendations,
						s = t && t.type;
					return !!(n && !h(e) && s === i.GEO && n[0] && n[0].recommendedSubreddit && n[0].interactedSubreddit)
				}, I = () => async (e, t, n) => {
					const s = t(),
						r = Object(l.g)(s);
					return Object(l.f)(s) || null === r || "client" === r ? e(y()) : "server" === r ? e(O({
						lastLoadedEnv: "client"
					})) : void 0
				}
		},
		"./src/reddit/actions/frontpage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "e", (function() {
				return T
			}));
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/getParsedUserAgent/index.ts"),
				a = n("./src/reddit/actions/page.ts"),
				c = n("./src/reddit/constants/parameters.ts"),
				i = n("./src/reddit/endpoints/page/frontpage.ts"),
				d = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				u = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/lib/makeListingKey/index.ts"),
				b = n("./src/lib/constants/index.ts"),
				p = n("./src/reddit/constants/page.ts"),
				f = n("./src/reddit/constants/postLayout.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				O = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				g = n("./src/reddit/selectors/frontpage.ts"),
				_ = n("./src/reddit/selectors/user.ts");
			const y = "FRONTPAGE__MORE_POSTS_PENDING",
				j = "FRONTPAGE__MORE_POSTS_LOADED",
				h = "FRONTPAGE__MORE_POSTS_FAILED",
				E = Object(u.a)(y),
				I = Object(u.a)(j),
				v = Object(u.a)(h),
				S = e => async (t, n, s) => {
					let {
						apiContext: a,
						gqlContext: u
					} = s;
					const y = n(),
						j = Object(g.a)(y),
						{
							sort: h = j
						} = e,
						S = y.platform.currentPage ? y.platform.currentPage.queryParams : {},
						T = Object(l.a)(p.a, h, S),
						D = y.listings.postOrder.loadMore[T],
						C = S[c.t] ? S[c.t].toUpperCase() : "",
						w = C in b.Pb && b.Pb[C];
					if (D) {
						const e = y.listings.postOrder.api.pending[T],
							n = y.listings.postOrder.fetchedTokens,
							s = !(!n[T] || !n[T][D.token]);
						if (!e && !s) {
							t(E({
								key: T,
								fetchedToken: D.token
							}));
							const e = !!y.platform.currentPage && !!y.platform.currentPage.queryParams.useMockData,
								n = Object.assign({
									after: D.token,
									dist: D.dist
								}, r()(S, c.k), {
									isMobile: Object(o.e)(y.meta.userAgent),
									sort: h,
									t: Object(d.a)(h, w),
									layout: f.e[Object(m.N)(y, {})],
									useMockData: e
								}); {
								const e = y.platform.lastPage,
									t = e && e.url;
								t && (n.clickUrl = t)
							}
							const s = () => Object(i.a)(u(), Object(i.b)(y, Object.assign({}, n, {
									limit: f.a
								})), Object(_.O)(y)),
								a = await s(),
								l = Object.assign({}, a.body, Object(O.a)(y, T, a.body));
							a.ok ? t(I(Object.assign({
								key: T,
								fetchedToken: D.token,
								meta: y.meta
							}, l))) : t(v(Object.assign({
								key: T,
								error: a.error,
								fetchedToken: D.token
							}, l)))
						}
					}
				}, T = e => async (t, n) => {
					const s = n(),
						r = Object(g.a)(s),
						{
							sort: o = r
						} = e,
						i = s.platform.currentPage ? s.platform.currentPage.queryParams : {},
						u = Object(l.a)(p.a, o, i),
						f = i[c.t] ? i[c.t].toUpperCase() : "",
						m = f in b.Pb && b.Pb[f];
					await t(Object(a.w)(u, {
						sort: o,
						t: Object(d.a)(o, m)
					}))
				}
		},
		"./src/reddit/actions/global.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/userSettings.ts");
			const a = "LOCAL_STORAGE_LOADED",
				c = Object(s.a)(a),
				i = e => async (t, n) => {
					t(Object(o.a)());
					const s = n();
					s.user.loid.loid || s.meta.isBot || r.c.withScope(e => {
						Object(r.a)(e, {
							serverLogging: !1
						}), r.c.captureMessage("User has no LOID set")
					});
					const {
						localStorageData: a
					} = e;
					a && t(c(a))
				}
		},
		"./src/reddit/actions/gold/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "b", (function() {
				return D
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "f", (function() {
				return U
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/models/Gold/Award.ts"),
				d = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/activeModalId.ts"),
				l = n("./src/reddit/selectors/communityAwards.ts"),
				b = n("./src/reddit/selectors/experiments/goldPremiumAwards.ts"),
				p = n("./src/reddit/selectors/profile.ts"),
				f = n("./src/reddit/endpoints/gold/communityAwards.ts"),
				m = n("./src/reddit/constants/gold.ts"),
				O = n("./src/reddit/actions/gold/constants.ts");
			const g = () => s.fbt._("There was an error creating the award. Please try again.", null, {
					hk: "3UtrTD"
				}),
				_ = () => s.fbt._("There was an error loading awards list. Please try again.", null, {
					hk: "3fs6Y8"
				}),
				y = () => s.fbt._("There was an error disabling the award. Please try again.", null, {
					hk: "Mp45j"
				}),
				j = (e, t, n, s, r, o, a, c) => async (i, d, u) => {
					let {
						gqlContext: l
					} = u;
					i(I());
					try {
						if ((await Object(f.a)(l(), e, t, n, s, r, o, a, c)).error) {
							const e = g();
							await i(S(e))
						}
					} catch (b) {
						const e = g();
						await i(S(e))
					}
				}, h = (e, t, n, s, r, o, a, c) => async (i, d, u) => {
					let {
						gqlContext: l
					} = u;
					i(I());
					try {
						if ((await Object(f.c)(l(), e, t, n, s, r, o, a, c)).error) {
							const e = g();
							await i(S(e))
						}
					} catch (b) {
						const e = g();
						await i(S(e))
					}
				}, E = e => {
					let {
						awardSubType: t,
						coinPrice: n,
						coinReward: s,
						daysOfDripExtension: r,
						daysOfPremium: o,
						description: a,
						endsAt: c,
						giverCoinReward: i,
						iconFormat: d,
						iconHeight: u,
						iconUrl: l,
						iconWidth: b,
						isNew: p,
						name: m,
						pennyPrice: O,
						pennyDonate: _,
						startsAt: y,
						subredditCoinReward: j
					} = e;
					return async (e, h, E) => {
						let {
							gqlContext: v
						} = E;
						e(I());
						try {
							if ((await Object(f.b)({
									awardSubType: t,
									coinPrice: n,
									coinReward: s,
									context: v(),
									daysOfDripExtension: r,
									daysOfPremium: o,
									description: a,
									endsAt: c,
									giverCoinReward: i,
									iconFormat: d,
									iconHeight: u,
									iconUrl: l,
									iconWidth: b,
									isNew: p,
									name: m,
									pennyPrice: O,
									pennyDonate: _,
									startsAt: y,
									subredditCoinReward: j
								})).error) {
								const t = g();
								await e(S(t))
							}
						} catch (T) {
							const t = g();
							await e(S(t))
						}
					}
				}, I = Object(r.a)(O.f), v = Object(r.a)(O.e), S = e => async (t, n) => {
					await t(v(e)), t(Object(c.e)({
						kind: d.b.Error,
						duration: c.a,
						text: e
					}))
				}, T = Object(r.a)(O.g), D = e => {
					let {
						award: t,
						subredditId: n
					} = e;
					return async (e, r) => {
						const o = r();
						e(T({
							award: t,
							subredditId: n
						})), Object(u.a)(o) === m.a && e(Object(a.i)(m.a));
						const i = s.fbt._("Community award successfully created!", null, {
							hk: "3UvmDa"
						});
						e(Object(c.e)({
							kind: d.b.SuccessCommunity,
							text: i
						}))
					}
				}, C = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const a = n(),
						c = !!a.awards.manageable.order[e];
					if (Object(l.b)(a, {
							subredditId: e
						}) || c) return;
					t(w({
						subredditId: e
					}));
					const i = Object(o.a)(e),
						d = i ? Object(f.i)(r()) : Object(f.j)(r(), e);
					try {
						const [n, s] = await Promise.all([d, Object(f.f)(r(), e)]);
						if (!n.ok) {
							const e = _();
							return void(await t(P(e)))
						}
						if (s.ok && !s.body.data.subreddit.isAwardCreationAllowed) return void(await t(k({
							subredditId: e,
							disabled: !0
						})));
						const o = i ? n.body.data.globalAwards : n.body.data.subreddit.manageableAwards;
						await t(A({
							awards: o,
							subredditId: e
						}))
					} catch (u) {
						const e = _();
						t(P(e))
					}
				}, w = Object(r.a)(O.G), A = Object(r.a)(O.F), R = Object(r.a)(O.E), P = e => async (t, n) => {
					await t(R(e)), t(Object(c.e)({
						kind: d.b.Error,
						duration: c.a,
						text: e
					}))
				}, k = Object(r.a)(O.b), x = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (!!!o.awards.usable.order[e]) {
						t(N({
							subredditOrProfileId: e
						}));
						try {
							const n = Object(p.p)(o, {
									profileId: e
								}),
								s = Object(b.a)(o);
							if (n) {
								const o = await Object(f.l)(r(), n.name, s);
								if (o.ok) {
									const n = o.body;
									return void(await t(L({
										awards: n.data.profile.usableAwards,
										subredditOrProfileId: e
									})))
								}
							} else {
								const n = await Object(f.k)(r(), e, s);
								if (n.ok) {
									const s = n.body;
									return void(await t(L({
										awards: s.data.subreddit.usableAwards,
										subredditOrProfileId: e
									})))
								}
							}
						} catch (a) {}
						await t(L({
							awards: i.l,
							subredditOrProfileId: e
						}))
					}
				}, N = Object(r.a)(O.O), L = Object(r.a)(O.N), U = (Object(r.a)(O.M), Object(r.a)(O.i), Object(r.a)(O.j), Object(r.a)(O.h), (e, t) => async (n, r, o) => {
					let {
						gqlContext: a
					} = o;
					n(M());
					try {
						if ((await Object(f.h)(a(), t)).error) {
							const e = y();
							await n(B(e))
						} else {
							await n(F({
								awardId: t,
								subredditId: e
							}));
							const o = Object(l.a)(r(), t);
							if (!o) return;
							const a = s.fbt._("{award name} Award successfully deleted!", [s.fbt._param("award name", o.name)], {
								hk: "3ZQs5u"
							});
							n(Object(c.e)({
								kind: d.b.SuccessCommunity,
								duration: c.a,
								text: a
							}))
						}
					} catch (i) {
						const e = y();
						await n(B(e))
					}
				}), M = Object(r.a)(O.l), F = Object(r.a)(O.m), G = Object(r.a)(O.k), B = e => async (t, n) => {
					await t(G(e)), t(Object(c.e)({
						kind: d.b.Error,
						duration: c.a,
						text: e
					}))
				}
		},
		"./src/reddit/actions/gold/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "J", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "I", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "H", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "G", (function() {
				return g
			})), n.d(t, "F", (function() {
				return _
			})), n.d(t, "E", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "O", (function() {
				return h
			})), n.d(t, "N", (function() {
				return E
			})), n.d(t, "M", (function() {
				return I
			})), n.d(t, "x", (function() {
				return v
			})), n.d(t, "B", (function() {
				return S
			})), n.d(t, "w", (function() {
				return T
			})), n.d(t, "y", (function() {
				return D
			})), n.d(t, "A", (function() {
				return C
			})), n.d(t, "z", (function() {
				return w
			})), n.d(t, "C", (function() {
				return A
			})), n.d(t, "q", (function() {
				return R
			})), n.d(t, "p", (function() {
				return P
			})), n.d(t, "t", (function() {
				return k
			})), n.d(t, "s", (function() {
				return x
			})), n.d(t, "o", (function() {
				return N
			})), n.d(t, "r", (function() {
				return L
			})), n.d(t, "n", (function() {
				return U
			})), n.d(t, "L", (function() {
				return M
			})), n.d(t, "K", (function() {
				return F
			})), n.d(t, "u", (function() {
				return G
			})), n.d(t, "v", (function() {
				return B
			})), n.d(t, "D", (function() {
				return q
			})), n.d(t, "a", (function() {
				return V
			}));
			const s = "GIVE_PREMIUM__OPEN_GIVE_PREMIUM_MODAL",
				r = "GIVE_PREMIUM__CLOSE_GIVE_PREMIUM_MODAL",
				o = "GILD__OPEN_GILD_MODAL",
				a = "GILD__CLOSE_GILD_MODAL",
				c = "GILD__OPEN_FRAMED_GILD",
				i = "COMMUNITY_AWARDS__CREATE_AWARD_PENDING",
				d = "COMMUNITY_AWARDS__CREATE_AWARD_SUCCESSFUL",
				u = "COMMUNITY_AWARDS__CREATE_AWARD_FAILED",
				l = "COMMUNITY_AWARDS__DELETE_AWARD_PENDING",
				b = "COMMUNITY_AWARDS__DELETE_AWARD_SUCCESSFUL",
				p = "COMMUNITY_AWARDS__DELETE_AWARD_FAILED",
				f = "COMMUNITY_AWARDS__DISABLE_AWARD_PENDING",
				m = "COMMUNITY_AWARDS__DISABLE_AWARD_SUCCESSFUL",
				O = "COMMUNITY_AWARDS__DISABLE_AWARD_FAILED",
				g = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_PENDING",
				_ = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_LOADED",
				y = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_FAILED",
				j = "COMUNITY_AWARDS__BLACKLIST_STATUS_LOADED",
				h = "COMMUNITY_AWARDS__USABLE_AWARDS_PENDING",
				E = "COMMUNITY_AWARDS__USABLE_AWARDS_LOADED",
				I = "COMMUNITY_AWARDS__USABLE_AWARDS_FAILED",
				v = "GIVE_PREMIUM__GIVE_PREMIUM_PENDING",
				S = "GIVE_PREMIUM__GIVE_PREMIUM_SUCCESSFUL",
				T = "GIVE_PREMIUM__GIVE_PREMIUM_FAILED",
				D = "GIVE_PREMIUM__SELECT_PACKAGE",
				C = "GIVE_PREMIUM__SET_IS_ANONYMOUS",
				w = "GIVE_PREMIUM__SET_INCLUDE_MESSAGE",
				A = "GIVE_PREMIUM__UPDATE_MESSAGE",
				R = "GILD__SET_IS_ANONYMOUS",
				P = "GILD__SET_INCLUDE_MESSAGE",
				k = "GILD__UPDATE_MESSAGE",
				x = "GILD__TRIGGER_LOADER",
				N = "GILD__GILD_PENDING",
				L = "GILD__GILD_SUCCESSFUL",
				U = "GILD__GILD_FAILED",
				M = "GIVE_AWARD__SELECT_AWARD",
				F = "AWARDS__REPORT_AWARD",
				G = "AWARDS__GIVE_AWARD_TOOLTIP_CLOSED",
				B = "AWARDS__GIVE_AWARD_TOOLTIP_OPENED",
				q = "AWARDS__HIDE_AWARD",
				V = "GILD__AWARD_KARMA_UPDATED"
		},
		"./src/reddit/actions/gold/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "setIsAnonymous", (function() {
				return G
			})), n.d(t, "setIncludeMessage", (function() {
				return B
			})), n.d(t, "updateMessage", (function() {
				return q
			})), n.d(t, "gildGqlRequested", (function() {
				return V
			})), n.d(t, "triggerLoader", (function() {
				return K
			})), n.d(t, "gildPending", (function() {
				return W
			})), n.d(t, "gildFailed", (function() {
				return Q
			})), n.d(t, "gildSuccessful", (function() {
				return X
			})), n.d(t, "awardKarmaUpdated", (function() {
				return Z
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/messageIframeParent/index.ts"),
				a = n("./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts"),
				c = n("./src/reddit/actions/goldPurchaseModals/purchaseCatalog.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./node_modules/react/index.js"),
				u = n.n(d),
				l = n("./src/reddit/models/Gold/Award.ts"),
				b = n("./src/reddit/components/Gold/AwardKarmaToastMessage/index.m.less"),
				p = n.n(b);
			const {
				fbt: f
			} = n("./node_modules/fbt/lib/FbtPublic.js"), m = e => f._("Sent! You earned {=awarder karma}", [f._param("=awarder karma", u.a.createElement("a", {
				className: p.a.karmaLink,
				href: l.a,
				target: "_blank",
				rel: "noopener noreferrer"
			}, f._({
				"*": "{awarder karma} awarder karma",
				_1: "1 awarder karma"
			}, [f._plural(e.awarderKarmaReceived, "awarder karma")], {
				hk: "2Llmz0"
			})))], {
				hk: "3ItXUT"
			});
			var O = n("./src/reddit/models/Gold/Coins/index.ts"),
				g = n("./src/reddit/models/Post/index.ts"),
				_ = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/selectors/comments.ts"),
				j = n("./src/reddit/selectors/communityAwards.ts"),
				h = n("./src/reddit/selectors/experiments/econAwardKarma.ts"),
				E = n("./src/reddit/selectors/gild.ts"),
				I = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				v = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/reddit/selectors/user.ts"),
				D = n("./src/graphql/operations/GildComment.json"),
				C = n("./src/graphql/operations/GildPost.json"),
				w = n("./src/lib/makeGqlRequest/index.ts"),
				A = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const R = (e, t, n) => Object(w.a)(e, Object.assign({}, C, {
					variables: t
				}), {
					query: n ? {} : Object(A.b)()
				}),
				P = (e, t, n) => Object(w.a)(e, Object.assign({}, D, {
					variables: t
				}), {
					query: n ? {} : Object(A.b)()
				});
			var k = n("./src/reddit/helpers/awards/getAwardItemId.ts"),
				x = n("./src/reddit/helpers/awards/message.ts"),
				N = n("./src/reddit/helpers/correlationIdTracker.ts"),
				L = n("./src/reddit/helpers/isPost.ts"),
				U = n("./src/reddit/helpers/trackers/gild.ts"),
				M = n("./src/telemetry/index.ts"),
				F = n("./src/reddit/actions/gold/constants.ts");
			const G = Object(r.a)(F.q),
				B = Object(r.a)(F.p),
				q = Object(r.a)(F.t),
				V = (e, t) => async (n, r, o) => {
					let {
						gqlContext: a
					} = o;
					const c = r().gild,
						{
							isOldReddit: i,
							isLivestream: d
						} = t;
					n(W());
					try {
						const t = {
								gildingTypeId: c.selectedAward.id,
								isAnonymous: c.isAnonymous,
								isGildFunded: !1,
								message: Object(x.d)(c.message, c.selectedAward, d),
								nodeId: e
							},
							r = Object(L.a)(e) ? R : P,
							o = await r(a(), {
								input: t
							}, i);
						let u = !1,
							l = null,
							b = null;
						if (o.ok) {
							const e = o.body;
							u = e.data.gild.ok, l = e.data.gild.fieldErrors, b = e.data.gild.errors
						}
						if (u) {
							const t = o.body,
								{
									gild: s
								} = t.data,
								r = Object(L.a)(e) ? o.body.data.gild.postInfo : o.body.data.gild.comment,
								{
									awardings: a,
									treatmentTags: i
								} = r;
							await n(X({
								awardId: c.selectedAward.id,
								awardings: a,
								awardKarmaReceived: s.awardKarmaReceived,
								coins: s.coins,
								id: e,
								subredditCoins: s.subredditCoins,
								treatmentTags: i
							}))
						} else {
							const e = l && l[0] && l[0].message,
								t = b && b[0] && b[0].message,
								r = e || t || s.fbt._("An unknown error occurred", null, {
									hk: "2oAbwZ"
								});
							await n(Q(r))
						}
					} catch (u) {
						const e = u,
							t = e && e.message || s.fbt._("An unknown error occurred", null, {
								hk: "2oAbwZ"
							});
						await n(Q(t))
					} finally {
						Object(N.b)(N.a.GildingFlow)
					}
				}, K = Object(r.a)(F.s), H = Object(r.a)(F.o), W = () => async (e, t) => {
					e(H()), window.setTimeout(() => {
						t().gild.api.pending && e(K())
					}, 2e3)
				}, Y = Object(r.a)(F.n), Q = e => async (t, n) => {
					await t(Y(e)), t(Object(i.e)({
						kind: _.b.Error,
						duration: i.a,
						text: e
					}))
				}, z = Object(r.a)(F.r), J = (e, t) => {
					const {
						id: n
					} = t, s = Object(L.a)(n) ? Object(v.O)(e, {
						postId: n
					}) : Object(y.n)(e, {
						commentId: n
					}), r = Object(T.i)(e), o = e.gild, {
						isAnonymous: a
					} = o, c = !a && r && (r.username || r.displayText) ? r.username || r.displayText : void 0, i = s ? s.author : void 0, d = Object(S.I)(e, {
						thingId: n
					});
					return z(Object.assign({}, t, {
						gilder: c,
						gildee: i,
						subredditId: d && d.id
					}))
				}, X = e => async (t, n) => {
					const r = n(),
						{
							awardId: d,
							id: u
						} = e,
						b = Object(j.a)(r, d),
						p = Object(h.a)(r),
						f = e.awardKarmaReceived,
						y = Object(T.i)(r);
					if (Object(E.h)(r)) {
						const e = "success.gild",
							t = {},
							n = b.icon32 ? b.icon32.url : b.icon.url;
						t.awardId = d, t.awardIcon = n, Object(o.a)({
							type: e,
							data: t
						})
					}
					if (b.awardType === l.f.Moderator && void 0 === e.subredditCoins) {
						const t = Object(S.I)(r, {
								thingId: u
							}),
							n = t && Object(S.B)(r, {
								subredditName: t.name
							});
						n && (e.subredditCoins = n - b.coinPrice)
					}
					if (t(J(r, e)), y && y.displayName && p) {
						const e = y.awarderKarma + f;
						t(Z({
							userName: y.displayName,
							awarderKarma: e
						}))
					}(r.posts.instances[u] || []).forEach(n => {
						t(J(r, Object.assign({}, e, {
							id: n
						})))
					});
					const D = Object(L.a)(u) ? s.fbt._("Success! You have given this post the {awardName} Award", [s.fbt._param("awardName", b.name)], {
							hk: "1Ndi4Z"
						}) : s.fbt._("Success! You have given this comment the {awardName} Award", [s.fbt._param("awardName", b.name)], {
							hk: "2sIK9Y"
						}),
						C = b.coinPrice;
					p ? Object(M.a)(Object(U.viewKarmaSuccessEvent)({
						award: b,
						awarderKarmaEarned: f,
						awardeeKarmaEarned: 0,
						numberCoins: C,
						thingId: u
					})(r)) : Object(M.a)(Object(U.viewSuccessAwardEvent)(u, C, b)(r));
					const w = b.icon64 ? b.icon64.url : b.icon.url;
					t(Object(i.e)({
						customIconAsset: w,
						kind: _.b.SuccessAward,
						text: p && f > 0 ? m({
							awarderKarmaReceived: f
						}) : D
					})), setTimeout(() => {
						const e = Object(k.a)(d, u),
							t = document.getElementById(e);
						t && t.dispatchEvent(new Event("awardAdded"))
					}, 10);
					const A = Object(L.a)(u) && Object(g.i)(Object(v.O)(r, {
						postId: u
					}));
					await t(Object(c.a)());
					const R = Object(I.d)(n()).filter(e => O.a.has(e.dealInfo.type));
					R.length && setTimeout(() => t(Object(a.h)({
						packageId: R[0].mobileId
					})), A ? 600 : 10)
				}, Z = Object(r.a)(F.a)
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "f", (function() {
				return I
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/messageIframeParent/index.ts"),
				o = n("./src/reddit/helpers/isPost.ts"),
				a = n("./src/reddit/selectors/gild.ts"),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/actions/gold/communityAwards.ts"),
				d = n("./src/reddit/components/GildModal/getGildModalId.ts"),
				u = n("./src/reddit/selectors/communityAwards.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/telemetry/index.ts"),
				f = n("./src/reddit/actions/gold/constants.ts");
			const m = Object(s.a)(f.J),
				O = Object(s.a)(f.d),
				g = () => async (e, t) => {
					const s = t();
					e(O()), Object(c.b)(c.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: r
					} = await n.e("givePremiumTrackers").then(n.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(p.a)(r()(s))
				}, _ = Object(s.a)(f.I), y = e => {
					let {
						awardId: t,
						isOverlay: n,
						thingId: s
					} = e;
					return async (e, r) => {
						const a = r(),
							c = Object(d.a)(s, n),
							p = t ? Object(u.a)(a, t) : void 0;
						e(_({
							award: p,
							thingId: s,
							gildModalId: c
						}));
						const f = Object(b.I)(a, {
							thingId: s
						});
						if (f) Object(i.h)(f.id);
						else if (Object(o.a)(s)) {
							const e = Object(l.O)(a, {
								postId: s
							});
							if (!e) return;
							Object(i.h)(e.belongsTo.id)
						} else;
					}
				}, j = Object(s.a)(f.c), h = Object(s.a)(f.H), E = () => async (e, t) => {
					const s = t(),
						o = Object(a.d)(s);
					if (Object(a.h)(s)) {
						const e = "close.gild";
						Object(r.a)({
							type: e
						})
					}
					e(j());
					const {
						clickCloseGildModalEvent: i
					} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(p.a)(i(o)(s)), Object(c.b)(c.a.GildingFlow)
				}, I = () => async () => {
					Object(r.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return I
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "h", (function() {
				return w
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "g", (function() {
				return P
			})), n.d(t, "m", (function() {
				return k
			})), n.d(t, "l", (function() {
				return x
			})), n.d(t, "i", (function() {
				return N
			})), n.d(t, "j", (function() {
				return L
			})), n.d(t, "k", (function() {
				return U
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/sentry/index.ts"),
				c = n("./src/reddit/constants/modals.ts"),
				i = n("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				b = n("./src/reddit/endpoints/gold/purchase.ts"),
				p = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				m = n("./src/reddit/models/Gold/Award.ts"),
				O = n("./src/reddit/models/Gold/Coins/index.ts"),
				g = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/constants/experiments.ts"),
				y = n("./src/reddit/helpers/chooseVariant/index.ts");
			var j = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				h = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				E = n("./src/reddit/selectors/user.ts");
			const I = "COIN_PURCHASE_MODAL__OPEN_COIN_PURCHASE_MODAL",
				v = "COIN_PURCHASE_MODAL__OPEN_TARGETED_OFFER_MODAL",
				S = "COIN_PURCHASE_MODAL__CLOSE_COIN_PURCHASE_MODAL",
				T = Object(o.a)(I),
				D = Object(o.a)(S),
				C = Object(o.a)(v),
				w = e => {
					let {
						packageId: t
					} = e;
					return async (e, n) => {
						const s = n(),
							r = Object(j.c)(s, t);
						r ? ("new_purchaser" !== r.dealInfo.type || (e => {
							const t = Object(y.c)(e, {
								experimentEligibilitySelector: y.a,
								experimentName: _.Y
							});
							return !(!t || Object(_.rc)(t))
						})(s)) && ("repeat_purchaser" !== r.dealInfo.type || (e => {
							const t = Object(y.c)(e, {
								experimentEligibilitySelector: y.a,
								experimentName: _.X
							});
							return !(!t || Object(_.rc)(t))
						})(s)) && (e(C({
							packageId: t
						})), e(Object(d.i)(c.a.GOLD_TARGETED_OFFER_MODAL))) : a.c.captureMessage("Tried to show targeted offer, but could not find package id: ".concat(t))
					}
				},
				A = "COIN_PURCHASE_MODAL__OPEN_COIN_PURCHASE_MODAL_TO_GILD",
				R = Object(o.a)(A),
				P = (e, t, n) => async (r, o) => {
					const a = o(),
						c = [...Object(j.b)(a), ...Object(j.d)(a)],
						i = t - e,
						d = Object(O.d)(i, c, !0);
					if (d) r(R({
						thingId: n
					})), r(T({
						packageId: d.mobileId
					}));
					else {
						const e = s.fbt._("Unable to create purchase request.", null, {
							hk: "lgfDj"
						});
						r(Object(u.e)({
							kind: g.b.Error,
							duration: u.a,
							text: e
						}))
					}
				}, k = (e, t) => async (n, o, a) => {
					let {
						apiContext: c
					} = a;
					const d = o(),
						{
							coins: u,
							pennies: l
						} = t,
						f = Object(p.c)(p.a.GoldPayment),
						m = Object(E.Q)(d);
					let O, g;
					n(Object(i.stripeTokenPending)());
					const _ = Object(h.v)(d);
					if (_ || (O = await n(Object(i.validateAndCreateStripeToken)(e)), g = Object(h.s)(d), O)) try {
						const e = await Object(b.e)({
							coins: u,
							context: c(),
							correlationId: f,
							language: m,
							pennies: l,
							rememberCard: g,
							savedCardId: _ || void 0,
							token: O
						});
						if (e.error) {
							const t = Object(r.a)(m, e.error, e.status);
							return void n(Object(i.stripeApiError)(t))
						}
						return void n(Object(i.paymentCompleted)({
							coins: e.body.coins ? e.body.coins : 0,
							confirmed: !1
						}))
					} catch (y) {
						const e = Object(r.a)(m, y);
						n(Object(i.stripeApiError)(e))
					} else {
						const e = s.fbt._("Looks like something went wrong validating your credit card.", null, {
							hk: "2OvpVH"
						});
						n(Object(i.stripeApiError)(e))
					}
				}, x = (e, t, o) => async (a, c, d) => {
					let {
						apiContext: u
					} = d;
					const l = c(),
						{
							coins: O,
							pennies: g
						} = t,
						_ = Object(p.c)(p.a.GoldPayment),
						y = Object(E.Q)(l);
					let j, I;
					a(Object(i.stripeTokenPending)());
					const v = Object(h.v)(l);
					if (v || (j = await a(Object(i.validateAndCreateStripeToken)(e)), I = Object(h.s)(l), j)) try {
						const {
							gildModalThingId: e,
							isAnonymous: t,
							includeMessage: c,
							message: d,
							selectedAward: p
						} = l.gild;
						if (!e || !p.id) {
							const e = s.fbt._("Gilding unknown thing", null, {
								hk: "2Jiujp"
							});
							return void a(Object(i.stripeApiError)(e))
						}
						const h = p.id,
							E = {
								gildType: h,
								includeMessage: c,
								isAnonymous: t,
								message: d
							},
							S = await Object(b.d)({
								coins: O,
								context: u(),
								correlationId: _,
								gildParams: E,
								isOldReddit: o,
								language: y,
								pennies: g,
								rememberCard: I,
								savedCardId: v || void 0,
								thingId: e,
								token: j
							});
						if (S.error) {
							const e = Object(r.a)(y, S.error, S.status);
							return void a(Object(i.stripeApiError)(e))
						} {
							const {
								gildSuccessful: t
							} = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/gold/gild.ts"));
							a(D()), a(Object(i.paymentCompleted)({
								confirmed: !1
							}));
							const {
								awarder_karma_received: s,
								all_awardings: r,
								coins: o,
								treatment_tags: c
							} = S.body;
							return void a(t({
								awardKarmaReceived: s || 0,
								awardId: h,
								awardings: r && r.length ? Object(f.a)(r).map(e => ({
									award: Object(m.h)(e),
									total: e.count
								})) : [],
								coins: o,
								id: e,
								treatmentTags: c
							}))
						}
					} catch (S) {
						const e = Object(r.a)(y, S);
						a(Object(i.stripeApiError)(e))
					} else {
						const e = s.fbt._("Looks like something went wrong validating your credit card.", null, {
							hk: "2OvpVH"
						});
						a(Object(i.stripeApiError)(e))
					}
				}, N = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const c = n(),
						d = Object(p.c)(p.a.GoldPayment),
						u = Object(E.Q)(c),
						{
							coins: b,
							pennies: f
						} = e;
					try {
						const e = await Object(l.a)({
							context: o(),
							coins: b,
							pennies: f,
							correlationId: d
						});
						if (e.error) {
							const n = Object(r.a)(u, e.error);
							return void t(Object(i.paypalApiError)(n))
						} {
							const {
								order_id: t
							} = e.body;
							return t
						}
					} catch (m) {
						a.c.captureException(m);
						const e = Object(r.a)(u, m);
						t(Object(i.paypalApiError)(e))
					}
				}, L = (e, t) => async (n, s, o) => {
					let {
						apiContext: c
					} = o;
					const d = s(),
						u = Object(p.c)(p.a.GoldPayment),
						b = Object(E.Q)(d),
						{
							coins: f,
							pennies: m
						} = t;
					try {
						const t = await Object(l.c)({
							context: c(),
							orderId: e,
							coins: f,
							pennies: m,
							correlationId: u
						});
						if (t.error) {
							const e = Object(r.a)(b, t.error);
							return void n(Object(i.paypalApiError)(e))
						} {
							const {
								coins: e
							} = t.body;
							n(Object(i.paymentCompleted)({
								coins: e,
								confirmed: !0
							}))
						}
					} catch (O) {
						a.c.captureException(O);
						const e = Object(r.a)(b, O);
						n(Object(i.paypalApiError)(e))
					}
				}, U = (e, t) => async (o, c, d) => {
					let {
						apiContext: u
					} = d;
					const b = c(),
						O = Object(p.c)(p.a.GoldPayment),
						g = Object(E.Q)(b),
						{
							coins: _,
							pennies: y
						} = t;
					try {
						const {
							gildModalThingId: t,
							includeMessage: a,
							isAnonymous: c,
							message: d,
							selectedAward: p
						} = b.gild;
						if (!t || !p) return void o(Object(i.paypalApiError)(s.fbt._("Gilding unknown post or comment", null, {
							hk: "4DkIS3"
						})));
						const j = p.id,
							h = await Object(l.d)({
								context: u(),
								orderId: e,
								coins: _,
								pennies: y,
								thingId: t,
								awardId: j,
								message: a ? d : "",
								isAnonymous: c,
								correlationId: O
							});
						if (h.error) {
							const e = Object(r.a)(g, h.error);
							o(Object(i.paypalApiError)(e))
						} else {
							o(D());
							const {
								all_awardings: e,
								awarder_karma_received: s,
								coins: r,
								subreddit_coins: a,
								treatment_tags: c
							} = h.body;
							o(Object(i.paymentCompleted)({
								coins: r,
								confirmed: !0
							}));
							const {
								gildSuccessful: d
							} = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/gold/gild.ts"));
							o(d({
								awardId: j,
								awardKarmaReceived: s || 0,
								awardings: Object(f.a)(e).map(e => ({
									award: Object(m.h)(e),
									total: e.count
								})),
								coins: r,
								id: t,
								subredditCoins: a,
								treatmentTags: c
							}))
						}
					} catch (j) {
						a.c.captureException(j);
						const e = Object(r.a)(g, j);
						o(Object(i.paypalApiError)(e))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "k", (function() {
				return d
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "s", (function() {
				return _
			})), n.d(t, "t", (function() {
				return y
			})), n.d(t, "u", (function() {
				return j
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return I
			}));
			const s = "GOLD_PAYMENT__CARD_NAME_EMPTY",
				r = "GOLD_PAYMENT__CARD_NAME_INPUT",
				o = "GOLD_PAYMENT__DELETE_SAVED_CARD",
				a = "GOLD_PAYMENT__FETCHED_STRIPE_INFO",
				c = "GOLD_PAYMENT__PAYMENT_COMPLETED",
				i = "GOLD_PAYMENT__PAYPAL_API_ERROR",
				d = "GOLD_PAYMENT__SAVED_CARDS_PENDING",
				u = "GOLD_PAYMENT__SELECT_PAYMENT_METHOD",
				l = "GOLD_PAYMENT__SELECT_SAVED_CARD",
				b = "GOLD_PAYMENT__STRIPE_API_ERROR",
				p = "GOLD_PAYMENT__STRIPE_ELEMENT_CHANGE",
				f = "GOLD_PAYMENT__CARD_ERROR",
				m = "GOLD_PAYMENT__STRIPE_TOKEN_PENDING",
				O = "GOLD_PAYMENT__TOGGLE_REMEMBER_CARD",
				g = "UPDATE_CARD_MODAL__CLOSE_UPDATE_CARD_MODAL",
				_ = "UPDATE_CARD_MODAL__UPDATE_CARD_FAILED",
				y = "UPDATE_CARD_MODAL__UPDATE_CARD_PENDING",
				j = "UPDATE_CARD_MODAL__UPDATE_CARD_SUCCESSFUL",
				h = "GOLD_PURCHASE__FETCH_PURCHASE_CATALOG_ERROR",
				E = "GOLD_PURCHASE__FETCH_PURCHASE_CATALOG_REQUESTED",
				I = "GOLD_PURCHASE__FETCH_PURCHASE_CATALOG_SUCCESS"
		},
		"./src/reddit/actions/goldPurchaseModals/payment.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "selectPaymentMethod", (function() {
				return d
			})), n.d(t, "paymentCompleted", (function() {
				return u
			})), n.d(t, "cardNameInput", (function() {
				return l
			})), n.d(t, "cardNameEmpty", (function() {
				return b
			})), n.d(t, "cardElementChange", (function() {
				return p
			})), n.d(t, "stripeTokenPending", (function() {
				return f
			})), n.d(t, "stripeTokenError", (function() {
				return m
			})), n.d(t, "stripeApiError", (function() {
				return O
			})), n.d(t, "validateAndCreateStripeToken", (function() {
				return g
			})), n.d(t, "paypalApiError", (function() {
				return _
			})), n.d(t, "toggleRememberCard", (function() {
				return y
			})), n.d(t, "selectSavedCard", (function() {
				return j
			})), n.d(t, "_deleteSavedCard", (function() {
				return h
			})), n.d(t, "deleteSavedCard", (function() {
				return E
			})), n.d(t, "loadSavedCards", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/endpoints/gold/purchase.ts"),
				c = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				i = n("./src/reddit/selectors/goldPurchaseModals.ts");
			const d = Object(o.a)(c.l),
				u = Object(o.a)(c.i),
				l = Object(o.a)(c.b),
				b = Object(o.a)(c.a),
				p = Object(o.a)(c.o),
				f = Object(o.a)(c.q),
				m = Object(o.a)(c.p),
				O = Object(o.a)(c.n),
				g = e => async (t, n) => {
					const r = n(),
						o = Object(i.g)(r),
						{
							token: a,
							error: c
						} = await e.createToken({
							name: o
						});
					if (o.trim()) {
						if (!c && a) return a;
						t(m(c || void 0))
					} else {
						const e = s.fbt._("Your card’s name field is incomplete", null, {
							hk: "VBdRU"
						});
						t(b({
							message: e
						}))
					}
				}, _ = Object(o.a)(c.j), y = Object(o.a)(c.r), j = Object(o.a)(c.m), h = Object(o.a)(c.d), E = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					t(h(e));
					try {
						const t = await Object(a.a)(o(), e);
						if (t.error) throw new Error(t.error.type)
					} catch (c) {
						r.c.captureException(c)
					}
				}, I = Object(o.a)(c.k), v = Object(o.a)(c.e), S = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					e(I());
					try {
						const t = await Object(a.b)(s());
						if (t.error) throw new Error(t.error.type);
						const n = t.body.map(e => ({
							brand: e.brand,
							cardId: e.card_id,
							expirationMonth: e.exp_month,
							expirationYear: e.exp_year,
							last4: e.last4
						}));
						e(v(n)), n[0] && e(j(n[0].cardId))
					} catch (o) {
						r.c.captureException(o), e(v([]))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/pennyPurchaseModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "f", (function() {
				return v
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/sentry/index.ts"),
				c = n("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				i = n("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				d = n("./src/reddit/endpoints/gold/purchase.ts"),
				u = n("./src/reddit/helpers/correlationIdTracker.ts"),
				l = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				b = n("./src/reddit/models/Gold/Award.ts"),
				p = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				f = n("./src/reddit/selectors/user.ts");
			const m = "PENNY_PURCHASE_MODAL__OPEN_PENNY_PURCHASE_MODAL",
				O = "PENNY_PURCHASE_MODAL__CLOSE_PENNY_PURCHASE_MODAL",
				g = Object(o.a)(m),
				_ = Object(o.a)(O),
				y = "PENNY_PURCHASE_MODAL__OPEN_PENNY_PURCHASE_MODAL_TO_GILD",
				j = Object(o.a)(y),
				h = (e, t) => async e => {
					e(j({
						thingId: t
					})), e(g())
				}, E = (e, t) => async (o, a, i) => {
					let {
						apiContext: m
					} = i;
					const O = a(),
						g = Object(u.c)(u.a.GoldPayment),
						y = Object(f.Q)(O);
					let j, h;
					o(Object(c.stripeTokenPending)());
					const E = Object(p.v)(O);
					if (E || (j = await o(Object(c.validateAndCreateStripeToken)(e)), h = Object(p.s)(O), j)) try {
						const {
							gildModalThingId: e,
							isAnonymous: a,
							message: i,
							selectedAward: u
						} = O.gild;
						if (!e || !u.id) return void o(Object(c.stripeApiError)(s.fbt._("Gilding unknown thing", null, {
							hk: "Qd6mo"
						})));
						const p = u.id,
							f = u.pennyPrice;
						if (!f) return void o(Object(c.stripeApiError)(s.fbt._("Trying to purchase award with zero price", null, {
							hk: "3FhAjz"
						})));
						const I = {
								gildType: p,
								includeMessage: !!i,
								isAnonymous: a,
								message: i
							},
							v = await Object(d.f)({
								context: m(),
								correlationId: g,
								gildParams: I,
								isOldReddit: t,
								pennies: f,
								rememberCard: h,
								savedCardId: E || void 0,
								thingId: e,
								token: j
							});
						if (v.error) {
							const e = Object(r.a)(y, v.error, v.status);
							return void o(Object(c.stripeApiError)(e))
						} {
							const {
								gildSuccessful: t
							} = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/gold/gild.ts"));
							o(_()), o(Object(c.paymentCompleted)({
								confirmed: !1
							}));
							const {
								all_awardings: s,
								awarder_karma_received: r,
								coins: a,
								treatment_tags: i
							} = v.body;
							return void o(t({
								awardKarmaReceived: r || 0,
								awardId: p,
								awardings: s && s.length ? Object(l.a)(s).map(e => ({
									award: Object(b.h)(e),
									total: e.count
								})) : [],
								coins: a,
								id: e,
								treatmentTags: i
							}))
						}
					} catch (I) {
						const e = Object(r.a)(y, I);
						o(Object(c.stripeApiError)(e))
					} else o(Object(c.stripeApiError)(s.fbt._("Looks like something went wrong validating your credit card.", null, {
						hk: "20FruV"
					})))
				}, I = (e, t, n) => async (s, o, d) => {
					let {
						apiContext: l
					} = d;
					const b = o(),
						p = Object(u.c)(u.a.GoldPayment),
						m = Object(f.Q)(b);
					try {
						const o = await Object(i.b)({
							context: l(),
							awardId: e,
							pennies: t,
							thingId: n,
							correlationId: p
						});
						if (o.error) {
							const e = Object(r.a)(m, o.error);
							return void s(Object(c.paypalApiError)(e))
						} {
							const {
								order_id: e
							} = o.body;
							return e
						}
					} catch (O) {
						a.c.captureException(O);
						const e = Object(r.a)(m, O);
						s(Object(c.paypalApiError)(e))
					}
				}, v = e => async (t, o, d) => {
					let {
						apiContext: p
					} = d;
					const m = o(),
						O = Object(u.c)(u.a.GoldPayment),
						g = Object(f.Q)(m);
					try {
						const {
							gildModalThingId: o,
							isAnonymous: a,
							message: d,
							selectedAward: u
						} = m.gild;
						if (!o || !u) return void t(Object(c.paypalApiError)(s.fbt._("Gilding unknown post or comment", null, {
							hk: "4DkIS3"
						})));
						const f = u.id,
							y = await Object(i.e)({
								awardId: f,
								context: p(),
								orderId: e,
								thingId: o,
								message: d || "",
								isAnonymous: a,
								correlationId: O
							});
						if (y.error) {
							const e = Object(r.a)(g, y.error);
							t(Object(c.paypalApiError)(e))
						} else {
							t(_());
							const {
								all_awardings: e,
								awarder_karma_received: s,
								coins: r,
								subreddit_coins: a,
								treatment_tags: i
							} = y.body;
							t(Object(c.paymentCompleted)({
								coins: r,
								confirmed: !0
							}));
							const {
								gildSuccessful: d
							} = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/gold/gild.ts"));
							t(d({
								awardKarmaReceived: s || 0,
								awardId: f,
								awardings: Object(l.a)(e).map(e => ({
									award: Object(b.h)(e),
									total: e.count
								})),
								coins: r,
								id: o,
								subredditCoins: a,
								treatmentTags: i
							}))
						}
					} catch (y) {
						a.c.captureException(y);
						const e = Object(r.a)(g, y);
						t(Object(c.paypalApiError)(e))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "f", (function() {
				return j
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/formatApiError/index.ts"),
				i = n("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				d = n("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				u = n("./src/reddit/endpoints/gold/purchase.ts"),
				l = n("./src/reddit/helpers/correlationIdTracker.ts"),
				b = n("./src/reddit/selectors/user.ts");
			const p = "PREMIUM_PURCHASE_MODAL__OPEN_PREMIUM_PURCHASE_MODAL",
				f = "PREMIUM_PURCHASE_MODAL__CLOSE_PREMIUM_PURCHASE_MODAL",
				m = Object(o.a)(p),
				O = Object(o.a)(f),
				g = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const d = n(),
						p = a.lb,
						f = Object(l.c)(l.a.GoldPayment),
						m = Object(b.Q)(d);
					t(Object(i.stripeTokenPending)());
					const O = await t(Object(i.validateAndCreateStripeToken)(e));
					if (O) try {
						const e = await Object(u.g)({
							context: o(),
							correlationId: f,
							pennies: p,
							token: O
						});
						if (e.error) {
							const n = Object(c.a)(m, e.error);
							t(Object(i.stripeApiError)(n))
						} else t(Object(i.paymentCompleted)({
							confirmed: !1
						}))
					} catch (g) {
						const e = Object(c.a)(m, g);
						t(Object(i.stripeApiError)(e))
					} else {
						const e = r.fbt._("Looks like something went wrong validating your credit card.", null, {
							hk: "4eGqpL"
						});
						t(Object(i.stripeApiError)(e))
					}
				}, _ = "PREMIUM_PURCHASE_MODAL__PAYMENT_BLOB_CREATED", y = Object(o.a)(_), j = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					t(m());
					const a = n(),
						u = Object(b.Q)(a),
						l = s.a.paypal.buttons.premium;
					try {
						const n = await Object(d.f)({
							buttonId: l,
							context: o(),
							correlationId: e
						});
						if (n.error) {
							const e = Object(c.a)(u, n.error);
							t(Object(i.paypalApiError)(e))
						} else t(y(n))
					} catch (p) {
						const e = Object(c.a)(u, p);
						t(Object(i.paypalApiError)(e))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/purchaseCatalog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				l = n("./src/reddit/endpoints/gold/purchase.ts");
			const b = e => ({
					baselineCoins: e.baseline_coins || e.coins,
					baselinePennies: e.baseline_pennies || e.pennies,
					bonusPct: e.bonus_pct,
					coins: e.coins,
					description: e.description,
					featured: e.featured,
					featuredLabel: e.featured_label,
					images: {
						marketing: e.images.marketing,
						purchaseSuccess: e.images.purchase_success
					},
					mobileId: e.mobile_id,
					pennies: e.pennies
				}),
				p = e => e.map(b),
				f = e => e.map(e => {
					const t = b(e);
					return Object.assign({}, t, {
						dealInfo: {
							type: e.deal_info.type,
							title: e.deal_info.title,
							subtitle: e.deal_info.subtitle,
							displayDelay: e.deal_info.display_delay
						}
					})
				}),
				m = e => e.map(e => ({
					description: e.description,
					frequency: e.frequency,
					frequencyDays: e.frequency_days,
					images: {
						marketing: e.images.marketing,
						purchaseSuccess: e.images.purchase_success
					},
					mobileId: e.mobile_id,
					mobilePennies: e.mobile_pennies,
					pennies: e.pennies,
					periodicalCoins: e.periodical_coins,
					signupBonusCoins: e.signup_bonus_coins
				})),
				O = e => e ? {
					ctaText: e.cta_text,
					dropdownHeaderText: e.dropdown_banner_text,
					dropdownHeaderBackgroundAsset: e.dropdown_banner_image_url,
					endsAt: e.ends_at,
					heroImageUrl: e.hero_image_url,
					heroSubtext: e.hero_subtext,
					heroText: e.hero_text
				} : null;

			function g(e) {
				if (!e.ok) return e;
				const {
					active_sale: t,
					coin_packages: n,
					deals: s,
					premium_packages: r
				} = e.body, o = {
					activeSaleConfig: O(t),
					coinPackages: p(n),
					dealCoinPackages: f(s),
					premiumPackages: m(r)
				};
				return Object.assign({}, e, {
					body: o
				})
			}
			var _ = n("./src/reddit/selectors/user.ts"),
				y = n("./src/reddit/actions/goldPurchaseModals/constants.ts");
			const j = Object(r.a)(y.g),
				h = Object(r.a)(y.h),
				E = Object(r.a)(y.f),
				I = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					e(j());
					const b = t(),
						p = Object(_.H)(b);
					try {
						const t = !p,
							n = await (async (e, t) => {
								const n = "/api/v2/gold/purchase_package_details",
									s = t && "undefined" != typeof window ? "".concat(window.location.origin).concat(n) : "".concat(e.apiUrl).concat(n),
									r = Object(u.a)(s);
								return Object(c.b)(Object(i.a)(e, [d.a]), {
									method: a.ab.GET,
									endpoint: r
								}).then(l.c).then(g)
							})(r(), t);
						if (!n.ok) throw new Error(n.error && n.error.type || "Unknown error");
						const s = n.body;
						e(h(s))
					} catch (f) {
						o.c.captureException(f);
						const t = s.fbt._("There was an error fetching available products", null, {
							hk: "1Uvx37"
						});
						e(E(t))
					}
				}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "p", (function() {
				return _
			})), n.d(t, "q", (function() {
				return y
			})), n.d(t, "r", (function() {
				return j
			})), n.d(t, "s", (function() {
				return h
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "u", (function() {
				return I
			})), n.d(t, "v", (function() {
				return v
			})), n.d(t, "w", (function() {
				return S
			})), n.d(t, "x", (function() {
				return T
			})), n.d(t, "y", (function() {
				return D
			}));
			const s = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				r = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				o = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				a = "GOVERNANCE__OPT_OUT_IN_PENDING",
				c = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				i = "POLL_VOTE_SUCCESS",
				d = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				u = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				l = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				b = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				f = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				m = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				O = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				g = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				_ = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				y = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				j = "GOVERNANCE__TRANSFER_FAILURE",
				h = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				E = "GOVERNANCE__TRANSFER_PENDING",
				I = "GOVERNANCE__TRANSFER_SUCCESS",
				v = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				S = "GOVERNANCE__WALLETS_FETCH_PENDING",
				T = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				D = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/actions/toaster.ts"),
				r = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				o = n("./src/reddit/models/Toast/index.ts");

			function a(e, t) {
				e(Object(s.e)({
					duration: 5e3,
					kind: o.b.Error,
					text: Object(r.a)(t)
				}))
			}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "l", (function() {
				return a
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			}));
			const s = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				a = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				c = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				i = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				d = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				f = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/harbergerTax/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			}));
			const s = "HARBERGER_TAX__BANNER_MANAGE_MODAL_OPENED",
				r = "HARBERGER_TAX__BANNER_PURCHASE_MODAL_OPENED",
				o = "HARBERGER_TAX__BANNER_CRYPTO_MANAGE_MODAL_OPENED",
				a = "HARBERGER_TAX__BANNER_CRYPTO_PURCHASE_MODAL_OPENED",
				c = "HARBERGER_TAX__BANNER_PURCHASE_FAILURE",
				i = "HARBERGER_TAX__BANNER_PURCHASE_PENDING",
				d = "HARBERGER_TAX__BANNER_PURCHASE_SUCCESS",
				u = "HARBERGER_TAX__BANNER_UPDATE_FAILURE",
				l = "HARBERGER_TAX__BANNER_UPDATE_PENDING",
				b = "HARBERGER_TAX__BANNER_UPDATE_SUCCESS"
		},
		"./src/reddit/actions/header.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "j", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "HEADER__SUBSCRIPTIONS_PINNED",
				o = "HEADER__SUBSCRIPTIONS_UNPINNED",
				a = Object(s.a)(r),
				c = Object(s.a)(o),
				i = "HEADER__DROPDOWN_CLOSED",
				d = "HEADER__DROPDOWN_OPENED",
				u = "HEADER__DROPDOWN_TOGGLED",
				l = Object(s.a)(i),
				b = Object(s.a)(d),
				p = Object(s.a)(u)
		},
		"./src/reddit/actions/imageUploads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "m", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/lib/uploadToS3/index.ts"),
				a = n("./src/reddit/helpers/getGenericUploadError.ts"),
				c = n("./src/reddit/models/Image/index.tsx"),
				i = n("./src/reddit/selectors/imageUploads.ts");
			const d = "IMAGE_UPLOADS__IMAGE_UPLOAD_PENDING",
				u = "IMAGE_UPLOADS__IMAGE_UPLOAD_LOADED",
				l = "IMAGE_UPLOADS__IMAGE_UPLOAD_SAVED",
				b = "IMAGE_UPLOADS__IMAGE_UPLOAD_FAILED",
				p = "IMAGE_UPLOADS__IMAGE_UPLOAD_CANCELED",
				f = Object(s.a)(d),
				m = Object(s.a)(u),
				O = Object(s.a)(l),
				g = Object(s.a)(b),
				_ = Object(s.a)(p),
				y = async (e, t, n, s) => {
					if (!t.ok) throw Object(c.k)(n, t.error);
					let r, a = t.body;
					"s3UploadLease" in a && (a = a.s3UploadLease, r = t.body.websocketUrl);
					const i = await Object(o.a)(n.file, a);
					if (i.ok) {
						if (!e.imageUploads[n.id]) return void Object(c.d)(n);
						const t = decodeURIComponent(i.body.PostResponse.Location);
						return Object(c.n)(n, t, r, s)
					}
					throw Object(c.k)(n, i.error)
				};

			function j(e) {
				return e.split("/").pop()
			}
			const h = (e, t) => new Promise((n, s) => {
					const o = Object(i.c)(e, t);
					if (!o.length) return n(null);
					const a = o[0].websocketUrl;
					if (!a) return s(new Error("ImageUploads: No websocket URL found"));
					const c = {};
					for (let e = 0; e < o.length; e++) {
						const t = o[e],
							n = j(t.url);
						c[n] = t
					}
					const d = o.length,
						u = new WebSocket(a);
					u.onopen = e => {
						u.onerror = null, n({
							websocket: u,
							imagesByKey: c,
							imageCount: d
						})
					}, u.onerror = e => {
						u.close();
						const t = new Error("ImageUploads: Failed to connect to websocket");
						r.c.captureException(t), s()
					}
				}),
				E = e => (t, n, s) => {
					let {
						apiContext: o
					} = s;
					return new Promise((n, s) => {
						const {
							websocket: o
						} = e;
						let {
							imageCount: i,
							imagesByKey: d
						} = e;

						function u() {
							for (const e in d) {
								const n = d[e],
									s = Object(c.o)(n, n.url);
								t(O(s))
							}
							n(), o.close()
						}
						d = Object.assign({}, d);
						let l = setTimeout(u, 6e4);
						o.onmessage = e => {
							clearTimeout(l);
							const s = JSON.parse(e.data);
							if (s && "success" === s.type) {
								const e = s.payload.url,
									n = j(e),
									r = d[n];
								if (!r) return;
								i -= 1, delete r[n];
								const o = Object(c.o)(r, e);
								t(O(o))
							} else {
								const e = j(s.payload.image_key),
									n = d[e];
								if (!n) return;
								i -= 1, delete n[e];
								const r = Object(a.a)(s.payload.image_key),
									o = Object(c.k)(n, r);
								t(g(o))
							}
							i ? l = setTimeout(u, 6e4) : (o.close(), n())
						}, o.onerror = e => {
							clearTimeout(l);
							const n = Object(a.a)("websocket");
							for (const s in d) {
								const e = d[s],
									r = Object(c.k)(e, n);
								t(g(r))
							}
							o.close();
							const i = new Error("ImageUploads: WebSocket connection failed before all messages received");
							r.c.captureException(i), s()
						}
					})
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "INCONTEXT__BANNED",
				o = "INCONTEXT__MUTED",
				a = Object(s.a)(r),
				c = Object(s.a)(o)
		},
		"./src/reddit/actions/inFeedChaining.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return j
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "e", (function() {
				return D
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/telemetry/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				i = n("./src/reddit/actions/discoveryUnit.ts"),
				d = n("./src/reddit/actions/subreddit/similarSubreddit.ts"),
				u = n("./src/reddit/actions/subreddit/subredditPosts.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				b = n("./src/reddit/constants/inFeedChaining.ts"),
				p = n("./src/reddit/constants/page.ts"),
				f = n("./src/reddit/helpers/localStorage/index.ts"),
				m = n("./src/reddit/helpers/trackers/discoveryUnit.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/inFeedChaining.ts"),
				_ = n("./src/reddit/selectors/posts.ts"),
				y = n("./src/reddit/selectors/subreddit.ts");
			const j = "FEED_CHAINING__CHAIN_LOADED",
				h = Object(a.a)(j),
				E = e => {
					const t = Date.now() - e,
						n = Object(f.r)();
					return Object.keys(n).filter(e => n[e].when >= t).map(e => n[e])
				},
				I = e => {
					let {
						listingName: t,
						listingKey: n,
						postId: s
					} = e;
					return async (e, a) => {
						if (!s) return;
						if (!(t === p.f || t === p.b)) return;
						0 === E(o.cb).length && Object(f.S)(!1);
						let l = a();
						if (Object(g.d)(l, {
								listingKey: n,
								postId: s
							}) || Object(g.a)(l).length >= b.a || Object(f.y)() || E(o.v).length >= b.a) return;
						const O = Object(_.C)(l, {
							listingKey: n,
							postId: s
						});
						if (O && O.isSponsored) return;
						await e(Object(i.g)()), l = a();
						const j = Object(g.b)(l, {
							listingName: t
						});
						if (!j) return;
						const I = Object(_.bb)(l, {
							postId: s
						});
						if (!I || Object(g.e)(l, {
								subredditId: I.id
							}) || (e => {
								return E(o.v).some(t => t.subredditId === e)
							})(I.id)) return;
						const v = {
							subredditIds: [I.id],
							count: b.b
						};
						await e(Object(d.b)(v));
						const S = Object(d.a)(v);
						l = a();
						const T = Object(y.u)(l, {
							key: S
						});
						0 !== T.length ? (await e((e => async (t, n) => {
							const s = o.Pb.DAY.toUpperCase(),
								r = e.filter(e => {
									const t = Object(c.a)(e, o.M.TOP, {
										t: s
									});
									return 0 === Object(_.H)(n(), {
										listingKey: t
									}).length
								});
							await t(Object(u.b)({
								first: 1,
								range: s,
								sort: o.G.TOP,
								subredditNames: r
							}))
						})(T.map(e => e.name))), l = a(), Object(g.f)(l, {
							postId: s
						}).length < b.c ? Object(r.a)(Object(m.b)(j, "other", I)(l)) : (Object(f.a)(s, I.id), Object(r.a)(Object(m.c)(j, I)(l)), e(h({
							listingKey: n,
							postId: s
						})))) : Object(r.a)(Object(m.b)(j, "no_chaining", I)(l))
					}
				},
				v = "FEED_CHAINING__CHAIN_TOGGLED",
				S = (Object(a.a)(v), "FEED_CHAINING__CHAINING_TOGGLED"),
				T = Object(a.a)(S),
				D = () => async e => {
					Object(f.S)(!0), e(T({
						isDismissed: !0
					})), e(Object(l.e)(Object(l.d)(s.fbt._("You'll see this less often.", null, {
						hk: "38LGcQ"
					}), O.b.Undo, s.fbt._("Undo", null, {
						hk: "4zFGDk"
					}), async () => {
						Object(f.S)(!1), e(T({
							isDismissed: !1
						}))
					})))
				}
		},
		"./src/reddit/actions/inbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "INBOX__COUNT_UPDATE",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/interceptedAction.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "INTERCEPTED_ACTION_SET",
				o = "INTERCEPTED_ACTION_UNSET",
				a = Object(s.a)(r),
				c = Object(s.a)(o)
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "JSAPI__CONSUMER_SUBSCRIBED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/leaderboard/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = "LEADERBOARD__DATE_RANGE_CHANGED",
				r = "LEADERBOARD__DATE_RANGE_FETCH_FAILURE",
				o = "LEADERBOARD__DATE_RANGE_FETCH_PENDING",
				a = "LEADERBOARD__DATE_RANGE_FETCH_SUCCESS"
		},
		"./src/reddit/actions/login.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "j", (function() {
				return g
			}));
			var s = n("./src/reddit/actions/modal.ts"),
				r = n("./src/reddit/actions/preferences.ts"),
				o = n("./src/reddit/constants/modals.ts"),
				a = n("./src/reddit/constants/postLayout.ts");
			const c = e => async (t, n) => {
				t(Object(s.i)(e)), !n().user.prefs.layout && t(Object(r.w)(a.d.Card))
			}, i = () => async (e, t) => {
				e(c(o.a.LOGIN_MODAL_ID))
			}, d = () => async e => {
				e(c(o.a.REGISTER_MODAL_ID))
			}, u = () => async e => {
				e(c(o.a.CHANGE_PASSWORD_MODAL_ID))
			}, l = () => async e => {
				e(c(o.a.ENABLE_TWO_FACTOR))
			}, b = () => async e => {
				e(c(o.a.DISABLE_TWO_FACTOR))
			}, p = () => async e => {
				e(c(o.a.TWO_FACTOR_BACKUP_CODES))
			}, f = () => async e => {
				e(c(o.a.LINK_APPLE_SSO))
			}, m = () => async e => {
				e(c(o.a.UNLINK_APPLE_SSO))
			}, O = () => async e => {
				e(c(o.a.LINK_GOOGLE_SSO))
			}, g = () => async e => {
				e(c(o.a.UNLINK_GOOGLE_SSO))
			}
		},
		"./src/reddit/actions/media.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "f", (function() {
				return _
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				i = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/models/Media/index.ts"),
				u = n("./src/reddit/actions/video.ts");
			const l = "MEDIA__SET_MUTE",
				b = Object(s.a)(l),
				p = "MEDIA__SET_VOLUME",
				f = Object(s.a)(p),
				m = (e, t) => async (n, s) => {
					n(b(e)), !e && t && n(Object(u.J)(t))
				}, O = "MEDIA__EMBED_HEIGHT_MEASURED", g = Object(s.a)(O), _ = e => {
					let {
						height: t,
						isDeleted: n,
						postId: s
					} = e;
					return async (e, u, l) => {
						let {
							apiContext: b
						} = l;
						const p = u(),
							{
								media: f
							} = p.posts.models[s];
						e(g({
							height: t,
							isDeleted: n,
							postId: s
						})), null !== f && f.type === d.n.EMBED && f.provider === d.t.Twitter && f.height !== t && await ((e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
							endpoint: Object(i.a)("".concat(e.apiUrl, "/api/set_twitter")),
							method: r.ab.POST,
							data: {
								height: n,
								link: t
							}
						}))(b(), s.substr(3), t)
					}
				}
		},
		"./src/reddit/actions/meta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "META__GEO_CHANGED",
				o = Object(s.a)(r),
				a = "META__META_RECEIVED";
			Object(s.a)(a)
		},
		"./src/reddit/actions/modMode.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./node_modules/js-cookie/src/js.cookie.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/constants/cookie.ts");
			const i = "MOD_MODE_TOGGLED",
				d = Object(a.a)(i),
				u = e => async (t, n, s) => {
					let a, {
						apiContext: i
					} = s;
					if (void 0 !== e) a = e;
					else {
						a = "false" === r.a.get(c.c)
					}
					r.a.set(c.c, a, {
						domain: o.a.cookieDomain
					});
					(document.cookie.match(/mod_mode_enabled=/g) || []).length > 1 && r.a.set(c.c, "", {
						expires: 0,
						path: "/"
					});
					t(d({
						enabled: a
					}))
				}
		},
		"./src/reddit/actions/modQueue/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return s
			})), n.d(t, "i", (function() {
				return r
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "n", (function() {
				return d
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "w", (function() {
				return m
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "u", (function() {
				return g
			})), n.d(t, "t", (function() {
				return _
			})), n.d(t, "s", (function() {
				return y
			})), n.d(t, "r", (function() {
				return j
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return S
			}));
			const s = "MODQUEUE_PENDING",
				r = "MODQUEUE_LOADED",
				o = "MODQUEUE_FAILED",
				a = "EDITED_PENDING",
				c = "EDITED_LOADED",
				i = "EDITED_FAILED",
				d = "REPORTS_PENDING",
				u = "REPORTS_LOADED",
				l = "REPORTS_FAILED",
				b = "SPAM_PENDING",
				p = "SPAM_LOADED",
				f = "SPAM_FAILED",
				m = "UNMODERATED_PENDING",
				O = "UNMODERATED_LOADED",
				g = "UNMODERATED_FAILED",
				_ = "UNDOACTION_PENDING",
				y = "UNDOACTION_LOADED",
				j = "UNDOACTION_FAILED",
				h = "MORE_MODERATED_SUBREDDITS_LOADED",
				E = "ALL_MODERATED_COMMUNITIES_LOADED",
				I = "ADD_SELECTED_ITEMS",
				v = "BULK_SELECT_ITEMS",
				S = "BULK_UNSELECT_ITEMS"
		},
		"./src/reddit/actions/modal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "j", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "k", (function() {
				return E
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/changeUsername.ts"),
				o = n("./src/reddit/actions/header.ts"),
				a = (n("./src/reddit/actions/media.ts"), n("./src/reddit/constants/modals.ts")),
				c = n("./src/reddit/endpoints/user/index.ts"),
				i = n("./src/reddit/helpers/localStorage/index.ts"),
				d = n("./src/reddit/selectors/activeModalId.ts"),
				u = n("./src/reddit/selectors/header.ts"),
				l = n("./src/reddit/selectors/user.ts");
			const b = "MODAL_TOGGLED",
				p = Object(s.a)(b),
				f = "CLOSE_ALL_MODALS",
				m = Object(s.a)(f),
				O = "REDESIGN_MODAL_CLOSED",
				g = (Object(s.a)(O), e => async (t, n, s) => {
					Object(d.b)(e)(n()) && t(p(e))
				}),
				_ = e => async (t, n, s) => {
					const c = n();
					if (!Object(d.b)(e)(c)) {
						if ((e === a.a.MULTIREDDIT_CREATE || e === a.a.MULTIREDDIT_ADD_SUBREDDIT) && Object(l.J)(c)) {
							Object(u.a)(c) && t(Object(o.f)());
							const n = p(e);
							return void t(Object(r.f)(n))
						}
						t(p(e))
					}
				}, y = () => async (e, t, n) => {
					Object(i.R)(a.a.REDESIGN_MODAL, !0), Object(l.H)(t()) && Object(c.e)(n.apiContext())
				}, j = "SET_ACCOUNT_MANAGER_MODAL_DATA";
			var h;
			! function(e) {
				e.HeaderLogin = "header_login", e.HeaderSignup = "header_signup", e.Hide = "hide", e.IdCard = "id_card", e.Post = "post", e.PromoBanner = "promo", e.Reply = "reply", e.Report = "report", e.SubredditLeaderboard = "subreddit_leaderboard", e.Save = "save", e.Subscribe = "subscribe", e.Vote = "vote"
			}(h || (h = {}));
			const E = Object(s.a)(j)
		},
		"./src/reddit/actions/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/profile/index.ts"),
				o = (n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"), n("./src/reddit/models/User/index.ts")),
				a = n("./src/reddit/selectors/user.ts");
			const c = "MOD_PERMS__REQUEST_LOADED",
				i = (Object(s.a)("MOD_PERMS__REQUEST_PENDING"), Object(s.a)(c), Object(s.a)("MOD_PERMS__REQUEST_FAILED"), () => async (e, t) => {
					const n = Object(a.i)(t());
					if (n) {
						const t = Object(o.e)(n);
						await e(Object(r.b)(t))
					}
				})
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "SUBREDDIT__MODERATION_LOG_LOADED",
				r = "SUBREDDIT__ALL_MODERATORS_LOADED"
		},
		"./src/reddit/actions/multireddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "q", (function() {
				return s
			})), n.d(t, "r", (function() {
				return r
			})), n.d(t, "s", (function() {
				return o
			})), n.d(t, "t", (function() {
				return a
			})), n.d(t, "u", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "o", (function() {
				return _
			})), n.d(t, "p", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "A", (function() {
				return I
			})), n.d(t, "B", (function() {
				return v
			})), n.d(t, "z", (function() {
				return S
			})), n.d(t, "y", (function() {
				return T
			})), n.d(t, "v", (function() {
				return D
			})), n.d(t, "w", (function() {
				return C
			})), n.d(t, "x", (function() {
				return w
			})), n.d(t, "d", (function() {
				return A
			}));
			const s = "MULTIREDDIT__MORE_POSTS_FAILED",
				r = "MULTIREDDIT__MORE_POSTS_LOADED",
				o = "MULTIREDDIT__MORE_POSTS_PENDING",
				a = "MULTIREDDIT__MY_MULTIREDDITS_PENDING",
				c = "MULTIREDDIT__MY_MULTIREDDITS_RECEIVED",
				i = "MULTIREDDIT__CREATE_FAILURE",
				d = "MULTIREDDIT__CREATE_PENDING",
				u = "MULTIREDDIT__CREATE_SUCCESS",
				l = "MULTIREDDIT__DELETE_PENDING",
				b = "MULTIREDDIT__DELETE_SUCCESS",
				p = "MULTIREDDIT__DELETE_FAILURE",
				f = "MULTIREDDIT__DUPLICATE_PENDING",
				m = "MULTIREDDIT__DUPLICATE_SUCCESS",
				O = "MULTIREDDIT__DUPLICATE_FAILURE",
				g = "MULTIREDDIT__EDIT_FAILURE",
				_ = "MULTIREDDIT__EDIT_PENDING",
				y = "MULTIREDDIT__EDIT_SUCCESS",
				j = "MULTIREDDIT__ADD_SUBREDDIT_FAILURE",
				h = "MULTIREDDIT__ADD_SUBREDDIT_PENDING",
				E = "MULTIREDDIT__ADD_SUBREDDIT_SUCCESS",
				I = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_PENDING",
				v = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_SUCCESS",
				S = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_FAILURE",
				T = 10,
				D = "MULTIREDDIT__REMOVE_SUBREDDIT_FAILURE",
				C = "MULTIREDDIT__REMOVE_SUBREDDIT_PENDING",
				w = "MULTIREDDIT__REMOVE_SUBREDDIT_SUCCESS";
			var A;
			! function(e) {
				e.InvalidSrQuarantine = "INVALID_SR_QUARANTINE", e.TooManySubreddits = "MULTI_TOO_MANY_SUBREDDITS"
			}(A || (A = {}))
		},
		"./src/reddit/actions/multireddit/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return G
			})), n.d(t, "g", (function() {
				return V
			})), n.d(t, "b", (function() {
				return Y
			})), n.d(t, "d", (function() {
				return Z
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "i", (function() {
				return ae
			})), n.d(t, "c", (function() {
				return ue
			})), n.d(t, "e", (function() {
				return fe
			})), n.d(t, "h", (function() {
				return _e
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./node_modules/react-router-redux/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/linkMatchers/customLinks.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/actions/page.ts"),
				p = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/constants/parameters.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				O = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				_ = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				y = n("./src/graphql/operations/AllUserMultireddits.json"),
				j = n("./src/lib/makeGqlRequest/index.ts"),
				h = (e, t) => Object(j.a)(e, Object.assign({}, y, {
					variables: t
				})),
				E = n("./src/reddit/endpoints/page/multiredditListing.ts"),
				I = n("./src/graphql/operations/SubredditRecommendations.json"),
				v = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				S = n("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				T = n("./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts"),
				D = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				C = (n("./node_modules/core-js/modules/es6.regexp.split.js"), e => {
					let t = e.over_18 || !1;
					if (!t)
						for (const a of e.subreddits)
							if (a.data.over_18) {
								t = !0;
								break
							} let n = e.quarantine || !1;
					if (!n)
						for (const a of e.subreddits) {
							const e = (a.data.audience_target || "").split(",");
							if (a.data.quarantine || e.indexOf("unsafe") > -1) {
								n = !0;
								break
							}
						}
					const s = e.subreddits.map(e => {
							const t = e.data,
								{
									name: n,
									display_name: s
								} = t;
							return {
								id: n,
								displayName: s.toLowerCase()
							}
						}).sort((e, t) => e.displayName.localeCompare(t.displayName)),
						r = s.filter(e => !e.displayName.startsWith(c.Rb)).map(e => e.id),
						o = s.filter(e => e.displayName.startsWith(c.Rb)).map(e => e.id);
					return {
						created: e.created_utc,
						description: e.description_md,
						descriptionHtml: e.description_html,
						descriptionRtJson: null,
						displayText: e.display_name,
						followerCount: e.num_subscribers,
						icon: e.icon_url,
						isFavorited: !!e.is_favorited,
						isFollowed: !1,
						isNSFW: t,
						isQuarantined: n,
						name: e.name,
						ownerId: e.owner_id,
						profileIds: o,
						subredditCount: e.subreddits.length,
						subredditIds: r,
						url: e.path.toLowerCase(),
						visibility: e.visibility
					}
				}),
				w = n("./src/reddit/models/Multireddit/index.ts"),
				A = n("./src/reddit/models/Toast/index.ts"),
				R = n("./src/reddit/selectors/multireddit.ts"),
				P = n("./src/reddit/selectors/platform.ts"),
				k = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/reddit/selectors/user.ts"),
				N = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				L = n("./src/reddit/actions/multireddit/constants.ts");
			const U = Object(d.a)(L.q),
				M = Object(d.a)(L.r),
				F = Object(d.a)(L.s),
				G = e => async (t, n, s) => {
					const {
						gqlContext: r
					} = s, {
						sort: o = c.M.HOT,
						multiredditName: a,
						username: i
					} = e, d = n(), l = d.platform.currentPage, b = l ? l.queryParams : {}, p = Object(R.d)(d, {
						multiredditName: a,
						username: i
					}), f = Object(u.a)(p.url, o, b), m = d.listings.postOrder.loadMore[f];
					if (!m) return;
					const O = d.listings.postOrder.api.pending[f],
						g = d.listings.postOrder.fetchedTokens,
						_ = g[f] && g[f][m.token] || !1;
					if (O || _) return;
					t(F({
						key: f,
						fetchedToken: m.token
					}));
					const y = p.url.replace(/\/$/, ""),
						j = b.t ? b.t.toUpperCase() : void 0,
						h = {
							after: m.token,
							includeIdentity: !1,
							includeSources: !1,
							path: y,
							range: j,
							sort: o.toUpperCase()
						},
						I = await Object(E.a)(r(), h),
						{
							data: S
						} = I.body,
						D = Object(T.a)(S);
					I.ok && S && S.multireddit ? t(M(Object.assign({
						fetchedToken: m.token,
						key: f,
						meta: d.meta
					}, D, Object(v.a)(d, f, D), {
						multiredditsModelsState: d.multireddits.models
					}))) : t(U(Object.assign({
						error: {
							type: c.C.NOT_FOUND_ERROR
						},
						fetchedToken: m.token,
						key: f
					}, I.body, Object(v.a)(d, f, D))))
				}, B = Object(d.a)(L.t), q = Object(d.a)(L.u), V = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s, r) => {
						let {
							apiContext: o,
							gqlContext: a
						} = r;
						const c = s();
						if (!Object(x.i)(c)) return;
						if (!e && Object(R.h)(c) || Object(R.i)(c)) return;
						n(B());
						const i = await h(a(), {
							includeSources: t
						});
						if (i.ok) {
							const e = i.body.data.identity.allMultireddits.edges.map(e => e.node),
								t = Object(S.b)(e);
							n(q(Object.assign({}, t, {
								multiredditsModelsState: c.multireddits.models
							})))
						}
					}
				}, K = Object(d.a)(L.e), H = Object(d.a)(L.f), W = Object(d.a)(L.g), Y = e => {
					let {
						description: t,
						displayName: n,
						shouldNavigate: r
					} = e;
					return async (e, o, i) => {
						let {
							apiContext: d
						} = i;
						const u = o(),
							b = Object(x.i)(u);
						if (!b) return;
						e(H());
						const f = await ((e, t, n) => Object(m.b)(Object(O.a)(e, [g.a]), {
							endpoint: Object(_.a)("".concat(e.apiUrl, "/api/multi")),
							data: {
								model: JSON.stringify({
									description_md: n,
									display_name: t,
									visibility: "private",
									subreddits: []
								})
							},
							method: c.ab.POST
						}))(d(), n, t);
						if (f.ok) {
							const {
								id: t
							} = b;
							if (await e(W({
									multireddit: C(f.body.data),
									multiredditsModelsState: u.multireddits.models,
									userId: t
								})), r) {
								e(Object(l.f)());
								const t = f.body.data.path.toLowerCase();
								await e(Object(a.b)(t))
							}
							e(Object(p.e)({
								text: s.fbt._("Custom feed created!", null, {
									hk: "258cY9"
								})
							}))
						} else e(K(f.error))
					}
				}, Q = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t(),
						a = Object(x.i)(r),
						i = Object(P.h)(r) ? Object(P.l)(r) : Object(P.b)(r),
						d = i && i.routeMatch && i.routeMatch.match;
					if (!d) return;
					const l = d.params,
						p = l.sort || c.M.HOT,
						{
							multiredditName: m,
							username: O
						} = l;
					if (!m) return;
					const g = Object(w.h)((O || a && a.displayText || "").toLowerCase(), m.toLowerCase()),
						{
							queryParams: _
						} = d,
						y = Object(u.a)(g, p, _),
						j = f.t in _ && _[f.t].toUpperCase() || "",
						h = c.Pb[j] || !1,
						E = Object(x.i)(r);
					(O || E && E.displayText) && await e(Object(b.B)(y, (O || E.displayText).toLowerCase(), m.toLowerCase(), Object.assign({}, o()(_, f.k), o()(_, f.j), {
						sort: p,
						t: Object(N.a)(p, h)
					})))
				}, z = Object(d.a)(L.k), J = Object(d.a)(L.l), X = Object(d.a)(L.m), Z = e => {
					let {
						description: t,
						displayName: n,
						fromName: r,
						fromUsername: o
					} = e;
					return async (e, i, d) => {
						let {
							apiContext: u
						} = d;
						const b = i(),
							f = Object(x.i)(b);
						if (!f || !f.displayText) return;
						const y = Object(w.h)((o || f.displayText).toLowerCase(), r.toLowerCase());
						e(J());
						const j = await ((e, t) => Object(m.b)(Object(O.a)(e, [g.a]), {
							endpoint: Object(_.a)("".concat(e.apiUrl, "/api/multi/copy")),
							data: {
								description_md: t.description,
								display_name: t.displayName,
								expand_srs: !0,
								from: t.from
							},
							method: c.ab.POST
						}))(u(), {
							from: y,
							displayName: n,
							description: t
						});
						if (j.ok) {
							const t = C(j.body.data);
							e(Object(l.f)()), e(X({
								multireddit: t,
								multiredditsModelsState: b.multireddits.models,
								userId: f.id
							})), e(Object(p.e)({
								text: s.fbt._("Custom feed duplicated!", null, {
									hk: "2u48X"
								}),
								buttonText: s.fbt._("Go there", null, {
									hk: "4sXZMm"
								}),
								buttonAction: Object(a.b)(t.url)
							}))
						} else e(z(j.error)), e(Object(p.e)({
							text: s.fbt._("Something went wrong duplicating {multiName}", [s.fbt._param("multiName", r)], {
								hk: "4bzN2D"
							})
						}))
					}
				}, $ = Object(d.a)(L.b), ee = Object(d.a)(L.c), te = Object(d.a)(L.a), ne = e => {
					let {
						communityInfo: t,
						identifier: n,
						multiredditNames: r
					} = e;
					return async (e, o, a) => {
						let {
							apiContext: d
						} = a;
						const u = o(),
							b = Object(x.i)(u);
						if (!b || u.multireddits.api.addSubreddit.pending) return;
						e($({
							name: n.name
						}));
						const {
							displayText: f
						} = b;
						if (!f) return;
						const y = r.map(e => "/user/".concat(f.toLowerCase(), "/m/").concat(e.toLowerCase())).join(","),
							j = "".concat("profile" === n.type ? c.Rb : "").concat(n.name),
							h = await ((e, t, n) => Object(m.b)(Object(O.a)(e, [g.a]), {
								endpoint: Object(_.a)("".concat(e.apiUrl, "/api/multi/bulk_add/r/").concat(t)),
								data: {
									paths: n
								},
								method: c.ab.PUT
							}))(d(), j, y);
						if (h.ok) {
							const o = Object(k.J)(u, {
									identifier: n
								}) || t && t.id || "",
								a = r.map(e => Object(w.h)(f, e));
							e(Object(l.f)()), e(Object(p.e)({
								text: s.fbt._({
									"*": "Successfully added {communityName} to {number} custom feeds!",
									_1: "Successfully added {communityName} to 1 custom feed!"
								}, [s.fbt._param("communityName", "".concat("subreddit" === n.type ? i.d.subreddit : i.d.profile).concat(n.name)), s.fbt._plural(r.length, "number")], {
									hk: "9EXsM"
								})
							})), await e(ee({
								communityInfo: t,
								id: o,
								multipaths: a,
								type: n.type
							})), 1 === r.length && await e(Q())
						} else {
							e(te(h.error));
							let t = s.fbt._("Sorry, something went wrong adding {subredditName}.", [s.fbt._param("subredditName", n.name)], {
								hk: "ERdWO"
							});
							h.body && (h.body.reason === L.d.TooManySubreddits ? t = s.fbt._("Maximum communities reached", null, {
								hk: "2eguyW"
							}) : h.body.reason === L.d.InvalidSrQuarantine && (t = s.fbt._("{communityname} is invalid because it is quarantined", [s.fbt._param("communityname", "".concat("subreddit" === n.type ? i.d.subreddit : i.d.profile).concat(n.name))], {
								hk: "407xmS"
							}))), e(Object(p.e)({
								text: t,
								kind: A.b.Error
							}))
						}
					}
				}, se = Object(d.a)(L.w), re = Object(d.a)(L.x), oe = Object(d.a)(L.v), ae = e => {
					let {
						id: t,
						multiredditName: n,
						name: r,
						type: o
					} = e;
					return async (e, a, i) => {
						let {
							apiContext: d
						} = i;
						const u = a(),
							b = Object(x.i)(u);
						if (!b || !b.displayText || u.multireddits.api.removeSubreddit.pending) return;
						e(se({
							id: t
						}));
						const {
							displayText: f
						} = b, y = Object(w.h)(f, n), j = "".concat("profile" === o ? c.Rb : "").concat(r), h = await ((e, t, n) => Object(m.b)(Object(O.a)(e, [g.a]), {
							endpoint: Object(_.a)("".concat(e.apiUrl, "/api/multi").concat(n, "r/").concat(t)),
							method: c.ab.DELETE
						}))(d(), j, y);
						h.ok ? (e(Object(l.f)()), e(re({
							id: t,
							multipath: y,
							type: o
						})), e(Object(p.e)({
							text: s.fbt._("{subredditname} removed from your custom feed!", [s.fbt._param("subredditname", r)], {
								hk: "uaWNe"
							}),
							buttonText: s.fbt._("undo", null, {
								hk: "3HH7IT"
							}),
							buttonAction: ne({
								identifier: {
									name: r,
									type: o
								},
								multiredditNames: [n]
							})
						})), e(Q())) : (e(oe(h.error)), e(Object(p.e)({
							text: s.fbt._("Sorry, something went wrong removing {subredditName}.", [s.fbt._param("subredditName", r)], {
								hk: "1E1rKm"
							})
						})))
					}
				}, ce = Object(d.a)(L.h), ie = Object(d.a)(L.i), de = Object(d.a)(L.j), ue = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = n();
					if (!Object(x.i)(i)) return;
					t(ie());
					const d = await ((e, t) => Object(m.b)(Object(O.a)(e, [g.a]), {
						endpoint: Object(_.a)("".concat(e.apiUrl, "/api/multi").concat(t)),
						method: c.ab.DELETE
					}))(o(), e);
					d.ok ? (await t(de(e)), t(Object(l.f)()), await t(Object(a.b)("/")), t(Object(p.e)({
						text: s.fbt._("Custom feed deleted!", null, {
							hk: "aWGMo"
						})
					}))) : t(ce(d.error))
				}, le = Object(d.a)(L.n), be = Object(d.a)(L.o), pe = Object(d.a)(L.p), fe = e => {
					let {
						description: t,
						displayText: n,
						multipath: r,
						visibility: o
					} = e;
					return async (e, a, i) => {
						let {
							apiContext: d
						} = i;
						const u = a();
						if (!Object(x.H)(u)) return;
						e(be());
						const b = await (e => {
							let {
								context: t,
								description: n,
								displayText: s,
								multipath: r,
								visibility: o
							} = e;
							return Object(m.b)(Object(O.a)(t, [g.a]), {
								endpoint: Object(_.a)("".concat(t.apiUrl, "/api/multi").concat(r)),
								data: {
									model: JSON.stringify({
										description_md: n,
										display_name: s,
										visibility: o
									}),
									expand_srs: !0
								},
								method: c.ab.PUT
							})
						})({
							context: d(),
							description: t,
							displayText: n,
							multipath: r,
							visibility: o
						});
						b.ok ? (await e(pe(C(b.body.data))), e(Object(l.f)()), e(Object(p.e)({
							text: s.fbt._("Custom feed updated!", null, {
								hk: "39R30f"
							})
						}))) : (e(le(b.error)), e(Object(p.e)({
							kind: A.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1Y6lli"
							})
						})))
					}
				}, me = Object(d.a)(L.z), Oe = Object(d.a)(L.A), ge = Object(d.a)(L.B), _e = e => {
					let {
						multiredditName: t,
						username: n,
						toExcludeNames: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: a
						} = o;
						const c = r(),
							i = Object(x.i)(c);
						if (!(n || i && i.displayText)) return;
						const d = Object(w.h)(n || i.displayText, t),
							u = c.multireddits.models[d];
						if (!u || !u.subredditIds) return;
						e(Oe());
						const l = s && s.reduce((e, t) => {
								const n = Object(k.E)(c, t) || Object(k.F)(c, t);
								return n ? [...e, n] : e
							}, []),
							b = await ((e, t) => Object(j.a)(e, Object.assign({}, I, {
								variables: t
							})))(a(), {
								count: L.y,
								subredditIds: u.subredditIds,
								toExclude: l
							});
						if (b.ok) {
							const {
								data: t
							} = b.body;
							e(ge({
								multipath: d,
								subreddits: Object(D.b)(t)
							}))
						} else e(me(b.error))
					}
				}
		},
		"./src/reddit/actions/notificationBanner.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "NOTIFICATION_BANNER_SET",
				o = "NOTIFICATION_BANNER_DISMISSED",
				a = Object(s.a)(r),
				c = Object(s.a)(o)
		},
		"./src/reddit/actions/notifications/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "p", (function() {
				return a
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "o", (function() {
				return d
			})), n.d(t, "n", (function() {
				return u
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "i", (function() {
				return y
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "NOTIFICATIONS__SHOW_NOTIFICATION_PROMPT",
				o = "NOTIFICATIONS__HIDE_NOTIFICATION_PROMPT",
				a = Object(s.a)(r),
				c = (Object(s.a)(o), "NOTIFICATIONS__PERMISSION_GRANTED"),
				i = "NOTIFICATIONS__PERMISSION_DENIED",
				d = Object(s.a)("NOTIFICATIONS__PERMISSION_PENDING"),
				u = Object(s.a)(c),
				l = Object(s.a)(i);
			var b, p;
			! function(e) {
				e[e.NotificationsSupported = 0] = "NotificationsSupported", e[e.BrowserUnsupported = 1] = "BrowserUnsupported", e[e.LocalStorageUnavailable = 2] = "LocalStorageUnavailable", e[e.NotAllRequiredAPIsSupported = 3] = "NotAllRequiredAPIsSupported"
			}(b || (b = {})),
			function(e) {
				e.Granted = "granted", e.Denied = "denied", e.Closed = "closed", e.Default = "default"
			}(p || (p = {}));
			const f = "PUSH__GET_PREFERENCES_PENDING",
				m = "PUSH__GET_PREFERENCES_LOADED",
				O = "PUSH__GET_PREFERENCES_FAILED",
				g = "PUSH__SET_PREFERENCES_PENDING",
				_ = "PUSH__SET_PREFERENCES_LOADED",
				y = "PUSH__SET_PREFERENCES_FAILED"
		},
		"./src/reddit/actions/nps.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "d", (function() {
				return j
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/config.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			var d = n("./node_modules/@r/frames/compiled.js"),
				u = n("./node_modules/lodash/debounce.js"),
				l = n.n(u),
				b = function(e) {
					document.body.appendChild(function(e) {
						let t;
						const n = l()((function() {
							t && t.contentWindow && d.postMessage(t.contentWindow, "resize.asknicely")
						}), 500);
						return function() {
							return t = function() {
								const t = document.createElement("iframe");
								return t.src = e, t.setAttribute("allowTransparency", "true"), t.style.display = "block", t.style.width = "100%", t.style.height = "1px", t.style.background = "transparent", t.style.border = "none", t
							}(), d.listen("embedjail"), d.receiveMessage(t.contentWindow, "open.embedjail", (function(e) {
								var s;
								s = e.detail, t.style.width = s.dimensions.width, t.style.height = s.dimensions.height, t.style.display = "block", t.style.position = "fixed", t.style.bottom = 0, t.style.zIndex = 2147483647, window.addEventListener("resize", n)
							})), d.receiveMessage(t.contentWindow, "close.embedjail", (function(e) {
								t.parentElement.removeChild(t), d.stopListening("asknicely"), window.removeEventListener("resize", n), t = void 0
							})), window.addEventListener("message", (function(e) {
								"https://live.asknice.ly" !== e.origin && "https://reddit.asknice.ly" !== e.origin || e.data && t && t.contentWindow && d.postMessage(t.contentWindow, e.data + ".asknicely")
							})), t
						}
					}(e)())
				};
			const p = "NPS__URL_PENDING",
				f = "NPS__URL_LOADED",
				m = "NPS__URL_FAILED",
				O = Object(s.a)(p),
				g = Object(s.a)(f),
				_ = Object(s.a)(m);
			let y = !1;
			const j = () => async (e, t, n) => {
				const s = t();
				if (s.nps.pending) return;
				if (y) return;
				e(O());
				const d = s.platform.currentPage && s.platform.currentPage.queryParams.feature || "",
					u = !!s.user.account,
					l = await ((e, t, n) => Object(a.b)(Object(c.a)(e, [i.a]), {
						data: {
							feature: t,
							app_name: "web2x"
						},
						endpoint: "".concat(n ? r.a.oauthUrl : r.a.apiUrl, "/api/jail/asknicely").concat(n ? "" : ".json"),
						method: o.ab.GET,
						traceRequestName: "get_nps_survey"
					}))(n.apiContext(), d, u);
				if (l.ok) {
					const t = l.body;
					t.dest ? (e(g(t)), b(t.dest), y = !0) : e(_())
				} else e(_())
			}
		},
		"./src/reddit/actions/oldSiteRules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			const i = "OLD_SITE_RULES_LOADED",
				d = Object(s.a)(i),
				u = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const i = await (e => Object(o.b)(Object(a.a)(e, [c.a]), {
						endpoint: "".concat(e.apiUrl, "/api/site_rules.json"),
						method: r.ab.GET
					}))(s());
					if (i.ok) {
						const {
							site_rules: t
						} = i.body;
						e(d({
							oldSiteRules: t
						}))
					}
				}
		},
		"./src/reddit/actions/page.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return We
			})), n.d(t, "i", (function() {
				return Ye
			})), n.d(t, "G", (function() {
				return Qe
			})), n.d(t, "h", (function() {
				return ze
			})), n.d(t, "g", (function() {
				return Je
			})), n.d(t, "f", (function() {
				return Xe
			})), n.d(t, "w", (function() {
				return tt
			})), n.d(t, "y", (function() {
				return rt
			})), n.d(t, "d", (function() {
				return ot
			})), n.d(t, "b", (function() {
				return at
			})), n.d(t, "a", (function() {
				return ct
			})), n.d(t, "s", (function() {
				return dt
			})), n.d(t, "r", (function() {
				return ut
			})), n.d(t, "t", (function() {
				return bt
			})), n.d(t, "q", (function() {
				return pt
			})), n.d(t, "c", (function() {
				return ft
			})), n.d(t, "z", (function() {
				return Ot
			})), n.d(t, "A", (function() {
				return gt
			})), n.d(t, "n", (function() {
				return _t
			})), n.d(t, "F", (function() {
				return yt
			})), n.d(t, "x", (function() {
				return ht
			})), n.d(t, "l", (function() {
				return Et
			})), n.d(t, "k", (function() {
				return It
			})), n.d(t, "j", (function() {
				return vt
			})), n.d(t, "B", (function() {
				return Ct
			})), n.d(t, "C", (function() {
				return wt
			})), n.d(t, "e", (function() {
				return At
			})), n.d(t, "p", (function() {
				return Rt
			})), n.d(t, "o", (function() {
				return Pt
			})), n.d(t, "D", (function() {
				return kt
			})), n.d(t, "E", (function() {
				return xt
			})), n.d(t, "u", (function() {
				return Nt
			})), n.d(t, "v", (function() {
				return Lt
			})), n.d(t, "H", (function() {
				return Ut
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./node_modules/react-router-redux/es/index.js"),
				c = n("./src/lib/addQueryParams/index.ts"),
				i = n("./src/lib/getParsedUserAgent/index.ts"),
				d = n("./src/lib/truncateText/index.ts"),
				u = n("./src/reddit/actions/category.ts"),
				l = n("./src/reddit/actions/discoveryUnit.ts"),
				b = n("./src/reddit/actions/focusedVerticals/index.ts"),
				p = n("./src/reddit/actions/multireddit/index.ts"),
				f = n("./src/reddit/actions/pages/subreddit.ts"),
				m = n("./src/reddit/actions/pages/userDataRequest/index.ts"),
				O = n("./src/reddit/actions/shortcuts/active.ts"),
				g = n("./src/reddit/actions/subredditSettings.ts"),
				_ = n("./src/reddit/components/GildModal/getGildModalId.ts"),
				y = n("./src/reddit/endpoints/governance/posts.ts"),
				j = n("./src/reddit/endpoints/page/commentsPage.ts"),
				h = n("./src/reddit/endpoints/page/frontpage.ts"),
				E = n("./src/reddit/endpoints/page/multiredditListing.ts"),
				I = n("./src/reddit/endpoints/page/subredditPage.ts"),
				v = n("./src/reddit/endpoints/profile/info.ts"),
				S = n("./src/reddit/models/Post/index.ts"),
				T = n("./src/lib/constants/index.ts"),
				D = (n("./src/lib/makeDraftKey/index.ts"), n("./src/lib/opener/index.ts")),
				C = n("./src/lib/pageTitle.ts"),
				w = (n("./src/reddit/models/PostDraft/index.ts"), n("./src/reddit/actions/dashboard.ts"), n("./src/reddit/actions/economics/helpers/async.ts")),
				A = n("./src/reddit/actions/externalAccount.ts"),
				R = n("./src/reddit/actions/gold/modals.ts"),
				P = n("./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts"),
				k = n("./src/reddit/actions/login.ts"),
				x = n("./src/reddit/actions/otherDiscussions/constants.ts"),
				N = n("./src/lib/makeActionCreator/index.ts"),
				L = n("./src/reddit/actions/platform.ts"),
				U = n("./src/reddit/endpoints/me/index.ts"),
				M = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				F = n("./src/reddit/actions/pages/appeal/constants.ts");
			const G = Object(N.a)(F.b),
				B = Object(N.a)(F.a);
			var q = n("./src/reddit/actions/post.ts"),
				V = n("./src/reddit/actions/profile/index.ts"),
				K = n("./src/reddit/actions/redditEmbed.ts"),
				H = n("./src/reddit/actions/subreddit.ts"),
				W = n("./src/reddit/actions/toaster.ts"),
				Y = n("./src/reddit/actions/users.ts"),
				Q = n("./src/reddit/constants/adEvents.ts"),
				z = n("./src/reddit/constants/experiments.ts"),
				J = n("./src/reddit/constants/graphql.ts"),
				X = n("./src/reddit/constants/page.ts"),
				Z = n("./src/reddit/constants/parameters.ts"),
				$ = n("./src/reddit/constants/postLayout.ts"),
				ee = n("./src/reddit/constants/posts.ts"),
				te = n("./src/reddit/contexts/PageLayer/index.tsx"),
				ne = n("./src/reddit/helpers/commentList/index.ts"),
				se = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				re = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				oe = n("./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts"),
				ae = n("./src/reddit/models/Comment/index.ts"),
				ce = n("./src/reddit/models/Media/index.ts"),
				ie = n("./src/reddit/models/Multireddit/index.ts"),
				de = n("./src/reddit/models/Subreddit/index.ts"),
				ue = n("./src/reddit/models/Toast/index.ts"),
				le = n("./src/reddit/models/User/index.ts"),
				be = n("./src/reddit/selectors/category.ts"),
				pe = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				fe = n("./src/reddit/selectors/experiments/frontpageSignup.ts"),
				me = n("./src/reddit/selectors/experiments/postSeo.ts"),
				Oe = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				ge = n("./node_modules/reselect/es/index.js"),
				_e = n("./src/reddit/helpers/chooseVariant/index.ts"),
				ye = n("./src/reddit/selectors/experiments/utils.ts"),
				je = n("./src/reddit/selectors/platform.ts");
			var he = n("./src/reddit/selectors/subreddit.ts"),
				Ee = n("./src/reddit/selectors/user.ts");
			const Ie = Object(ge.a)(Ee.G, he.K, je.h, me.f, e => {
					const t = (e => e.seo.crawler)(e);
					return t && t.name || null
				}, (e, t, n, s, r) => !!r && !e && !n && s && !Object(de.e)(t)),
				ve = Object(ge.a)((e, t) => Object(_e.c)(e, {
					experimentEligibilitySelector: e => Ie(e, t),
					experimentName: z.Qb
				}), ye.a);
			var Se, Te = n("./src/reddit/selectors/frontpage.ts"),
				De = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				Ce = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				we = n("./src/reddit/selectors/multireddit.ts"),
				Ae = n("./src/reddit/selectors/posts.ts"),
				Re = (n("./src/reddit/selectors/PublicAccessNetwork/api.ts"), n("./src/reddit/selectors/runTimeEnvVars.ts")),
				Pe = n("./src/lib/makeCommentsPageKey/index.ts"),
				ke = n("./src/lib/makeListingKey/index.ts"),
				xe = n("./src/lib/matchRoute/index.ts"),
				Ne = n("./src/reddit/actions/ads/index.ts"),
				Le = n("./src/reddit/helpers/canonicalUrls.ts"),
				Ue = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				Me = n("./src/lib/isUrl/index.ts");
			! function(e) {
				e.Image = "image", e.Link = "link", e.Video = "video"
			}(Se || (Se = {}));
			var Fe = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				Ge = n("./src/reddit/actions/seo/linksModule.ts"),
				Be = n("./src/reddit/actions/subreddit/subredditPosts.ts"),
				qe = n("./src/reddit/selectors/experiments/chatPost.ts"),
				Ve = n("./src/reddit/selectors/seo/linksModule.ts"),
				Ke = n("./src/reddit/actions/publicAccessNetwork/api.ts"),
				He = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			n("./src/reddit/actions/publicAccessNetwork/streams.ts");
			const We = 25,
				Ye = 100,
				Qe = function(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					return async (n, s, r) => {
						let {
							routes: o
						} = r;
						const c = s();
						Object(xe.a)(e, o, c) ? n(Object(a.b)(e)) : t ? Object(D.d)(e, "_blank") : window.location.assign(e)
					}
				},
				ze = "PAGE__FRONTPAGE_PENDING",
				Je = "PAGE__FRONTPAGE_LOADED",
				Xe = "PAGE__FRONTPAGE_FAILED",
				Ze = Object(N.a)(ze),
				$e = Object(N.a)(Je),
				et = Object(N.a)(Xe),
				tt = (e, t) => async (n, r, o) => {
					const a = r();
					if (a.listings.postOrder.api.pending[e]) return;
					const c = $.e[Object(te.N)(a, {})];
					t.isMobile = Object(i.e)(a.meta.userAgent), t.recentPostIds = a.posts.recent, t.layout = c, t.useMockData = !!a.platform.currentPage && (!!a.platform.currentPage.queryParams.useMockData && Object(Re.b)(a)), n(Ze({
						key: e
					})); {
						const e = a.platform.currentPage,
							n = e && e.url;
						n && (t.clickUrl = n)
					}
					const d = await Object(Ue.a)("index", () => Object(h.a)(o.gqlContext(), Object(h.b)(a, t), Object(Ee.O)(a)));
					n(Object(L.m)(d.status));
					const u = "error-".concat(e);
					if (d.ok) {
						const t = d.body;
						n($e(Object.assign({
							key: e,
							meta: a.meta
						}, t))), n(W.f(u)), n(Object(Ne.b)(Fe.a.FRONTPAGE))
					} else n(et(Object.assign({
						error: d.error,
						key: e
					}, d.body))), n(W.e({
						id: u,
						kind: ue.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "36ypKx"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: tt(e, t)
					}))
				}, nt = (e, t) => async (n, s) => {
					const r = s(),
						a = Object(Te.a)(r),
						{
							sort: c = a
						} = e.params,
						i = Object(ke.a)(X.a, c, e.queryParams),
						d = r.listings.postOrder.ids[i],
						u = r.listings.postOrder.api.error[i],
						l = r.listings.postOrder.api.pending[i],
						b = Z.t in e.queryParams && e.queryParams[Z.t].toUpperCase() || "",
						p = b in T.Pb && T.Pb[b];
					if (l || d && !u && !t) return void(d && (n(L.l({
						title: C.c()
					})), r.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						n(Object(Ne.b)(Fe.a.FRONTPAGE))
					})));
					await n(tt(i, Object.assign({}, o()(e.queryParams, Z.k), o()(e.queryParams, Z.j), {
						sort: c,
						t: Object(re.a)(c, p)
					}))), n(L.l({
						title: C.c()
					})), Object(_e.c)(r, {
						experimentEligibilitySelector: _e.a,
						experimentName: "redesign_aa"
					});
					const f = Object(fe.a)(r, {});
					Object(fe.e)(f) && n(Object(k.h)())
				}, st = () => async (e, t) => {
					const n = t();
					if (!Object(Ve.a)(n)) return e(Object(Ge.c)())
				}, rt = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					await Promise.all([n(Object(b.b)()), n(nt(e, t)), n(st()), n(Object(Ke.c)(He.P))])
				}, ot = "PAGE__COMMENTSPAGE_PENDING", at = "PAGE__COMMENTSPAGE_LOADED", ct = "PAGE__COMMENTSPAGE_FAILED", it = Object(N.a)(ot), dt = Object(N.a)(at), ut = Object(N.a)(ct), lt = (e, t) => {
					const n = Object(Ae.bb)(e, {
							postId: t
						}),
						r = Object(Ae.O)(e, {
							postId: t
						});
					if (!n || !r) return "";
					const o = e.posts.models[t].title,
						a = function(e) {
							return Object(d.a)(e, z.cc, z.ec)
						};
					let c;
					switch (o.length >= z.bc ? c = Object(me.h)(e) : o.length <= z.dc && (c = Object(me.m)(e)), c) {
						case z.ob.TruncTitleSubBrand:
							return "".concat(a(o), " - ").concat(n.name, " - Reddit");
						case z.ob.TruncTitleReddit:
							return "".concat(a(o), " - Reddit");
						case z.ob.TruncTitleSub:
							return "".concat(a(o), " - ").concat(n.name);
						case z.sb.TitleSubPtypeBrand:
							const e = (e => {
								if (!e.media && e.source && Object(Me.a)(e.source.url)) return Se.Link;
								if (e.media) switch (e.media.type) {
									case ce.n.IMAGE:
										return Se.Image;
									case ce.n.VIDEO:
										return Se.Video;
									default:
										return
								}
							})(r);
							return e ? "".concat(o, " - ").concat(e, " - ").concat(n.name, " - Reddit") : "".concat(o, " - ").concat(n.name, " - Reddit");
						case z.sb.TitleSubPtypeCom:
							return s.fbt._("{post title} - posted in the {subreddit name} community", [s.fbt._param("post title", o), s.fbt._param("subreddit name", n.name)], {
								hk: "2IcMsc"
							});
						default:
							return "".concat(o, " : ").concat(n.name)
					}
				}, bt = e => async (t, n) => {
					const {
						partialPostId: s,
						partialCommentId: r
					} = e.params, {
						subredditName: o
					} = e.params || "", c = s ? Object(S.m)(s) : "", i = r && Object(ae.e)(r), {
						path: d,
						queryParams: l
					} = e, b = Object(x.d)(d), p = n(), {
						instanceId: f
					} = l, {
						hasSortParam: m,
						sortToUse: g
					} = Object(se.a)(p, c), _ = ["context", "depth", "limit", Z.e].reduce((e, t) => {
						const n = parseInt(l[t]);
						return isNaN(n) || (e[t] = n), e
					}, {
						subredditName: o,
						hasSortParam: m,
						instanceId: f,
						include_categories: !0
					});
					m && (_.sort = g), _.onOtherDiscussions = b, t(q.t(c)), await t(pt(c, i, _, g));
					const y = n().posts.models[c];
					if (y) {
						const s = lt(n(), c),
							r = Object(he.K)(n(), {
								identifier: y.belongsTo
							});
						if ((y.media && y.media.type) === ce.n.LIVEVIDEO) {
							const e = Object(Oe.b)(p),
								n = y.belongsTo.type === ee.a.SUBREDDIT,
								s = e && n ? r.url : "/",
								o = Object(S.n)(y.id),
								c = "/rpan".concat(s).concat(o);
							return void t(Object(a.c)(c))
						}
						if (y.belongsTo.type !== ee.a.SUBREDDIT || y.isSponsored) y.belongsTo.type === ee.a.PROFILE && await t(V.d(r.name));
						else {
							!!Object(he.P)(p, {
								subredditId: y.belongsTo.id
							}) || await t(H.o(r.name))
						}
						const o = !!ve(p, {
								identifier: y.belongsTo
							}),
							i = b,
							d = !Object(de.e)(r) && !Object(qe.d)(p, {
								postId: c
							}) && !!r || !Object(je.h)(p) && Object(me.f)(p);
						if (i || d) {
							const e = {
									adContext: {
										layout: J.a.Card,
										reddaid: p.user.reddaid,
										sourcePostId: c
									},
									range: T.Pb.WEEK.toUpperCase(),
									sort: T.G.TOP,
									subredditName: r.name
								},
								n = {
									postId: c
								},
								s = t(Object(Be.a)(Object.assign({}, n, e, {
									includeOtherDiscussions: i,
									includePostFeed: d
								})));
							d && o && await s
						}
						t(Object(A.p)()), t(L.l({
							title: s
						}));
						const l = n().posts.instances[c] ? e.queryParams.instanceId : y.postId;
						t(Object(O.b)(l)); {
							const e = Object(be.d)(n(), {
								subredditName: r.name
							});
							await Promise.all(e.map(e => t(u.j(e))))
						}
					} else t(L.l({
						title: C.c()
					}));
					const {
						routePrefix: j
					} = e.params;
					ee.b[j] === ee.a.PROFILE ? Object(Le.d)(n(), t, e) : Object(Le.b)(n(), t, e)
				}, pt = (e, t, n, s) => async (r, o, a) => {
					const c = o(),
						i = Object(Pe.a)(e, t, n),
						{
							subredditName: d
						} = n,
						u = c.commentsPage.keyToHeadCommentId.hasOwnProperty(i),
						b = c.commentsPage.api.fullyLoaded[i],
						p = c.commentsPage.api.error[i],
						m = c.commentsPage.api.pending[i],
						O = !c.user.temporaryGQL.isLoggedIn,
						g = Object(Ee.i)(c),
						_ = s === T.q.CHAT,
						h = !!c.platform.lastPage;
					if ((m || u && !p) && !(_ && h)) {
						if (u && !c.sidebarPromotedPosts.firstFetch) {
							const t = Object(je.h)(c) ? Fe.a.COMMENTS_OVERLAY : Fe.a.COMMENTS;
							window.addEventListener("load", () => {
								r(Object(Ne.b)(t)), Math.random() <= .01 && r(Object(Ne.a)(e))
							})
						}
						return void(b || r(Ot(e, t, n)))
					}
					r(l.g());
					const E = c.user.prefs.commentMode;
					r(it({
						key: i,
						postId: e,
						commentMode: E
					}));
					const S = Object.assign({}, n, _ ? {
						sort: T.q.LIVE
					} : O ? {
						sort: n.sort,
						depth: 2
					} : {
						sort: n.sort
					}); {
						const t = Object(Ae.O)(o(), {
							postId: e
						});
						t && t.numComments && t.numComments > Ye && (S.truncate = We)
					}
					const D = Object(Ue.a)("comments", () => Object(j.a)(a.apiContext(), e, t, S, Object(pe.a)(o()))),
						C = !O && g && Object(v.b)(a.gqlContext(), Object(le.e)(g)) || null,
						[A, R] = await Promise.all([D, C]);
					let P;
					if (r(Object(L.m)(A.status)), A.ok) {
						const t = Object.keys(A.body.posts).filter(e => !!A.body.posts[e].isMeta),
							n = A.body.posts[e];
						if (t.length) {
							const e = await Object(y.a)(a.apiContext(), n.belongsTo.id, t);
							e.ok && (P = e.body)
						}
						if (R && R.ok) {
							const e = R.body.data.redditorInfoByName.karma,
								t = {
									awardeeKarma: e.fromAwardsReceived,
									awarderKarma: e.fromAwardsGiven,
									commentKarma: e.fromComments,
									postKarma: e.fromPosts,
									totalKarma: e.total
								};
							A.body && A.body.account && Object.assign(A.body.account, t)
						}
						const s = Object(ne.a)(A.body, e, c);
						r(dt(Object.assign({
							key: i,
							postId: e,
							meta: c.meta,
							governance: P,
							shouldCollapse: s
						}, A.body)))
					} {
						const s = Object(Ae.O)(o(), {
							postId: e
						});
						s && A.body.comments && Object.keys(A.body.comments).length < s.numComments ? r(Ot(e, t, n)) : A.ok && r(mt({
							key: i
						}));
						const a = Object(je.h)(c) ? Fe.a.COMMENTS_OVERLAY : Fe.a.COMMENTS;
						r(Object(Ne.b)(a)), Math.random() <= .01 && r(Object(Ne.a)(e))
					}
					if (A.ok) {
						r(W.f(i));
						const t = Object(Ae.O)(o(), {
							postId: e
						});
						r(q.B(t, Q.a.CommentsView)), t && "subreddit" === t.belongsTo.type && A.body.comments && await r(Object(w.a)({
							commentIds: Object.keys(A.body.comments),
							postIds: [t.id],
							subredditId: t.belongsTo.id
						}))
					} else {
						let e;
						d && (r(Object(f.k)({
							key: i
						})), e = await Object(Ue.a)("subreddit", () => Object(I.a)(a.apiContext(), d, {})), r(Object(L.m)(e.status)), r(Object(f.f)(e, d))), r(ut(Object.assign({
							error: A.error,
							key: i
						}, e ? e.body : A.body)))
					}
				}, ft = "PAGE__COMMENTSPAGE_LOADED_FULL", mt = Object(N.a)(ft), Ot = (e, t, n) => async (s, r, o) => {
					const a = Object(Pe.a)(e, t, n),
						c = r(),
						i = Object(Ee.H)(c),
						d = Object(Ee.i)(c),
						u = Object(j.a)(o.apiContext(), e, t, n, Object(pe.a)(c)),
						l = i && d && Object(v.b)(o.gqlContext(), Object(le.e)(d)) || null,
						[b, p] = await Promise.all([u, l]);
					if (s(Object(L.m)(b.status)), b.ok) {
						if (p && p.ok) {
							const e = p.body.data.redditorInfoByName.karma,
								t = {
									awardeeKarma: e.fromAwardsReceived,
									awarderKarma: e.fromAwardsGiven,
									commentKarma: e.fromComments,
									postKarma: e.fromPosts,
									totalKarma: e.total
								};
							b.body && b.body.account && Object.assign(b.body.account, t)
						}
						const t = Object(ne.a)(b.body, e, c);
						s(dt(Object.assign({
							key: a,
							postId: e,
							meta: c.meta,
							shouldCollapse: t
						}, b.body))), s(mt({
							key: a
						}));
						const n = r().posts.models[e],
							o = n && Object(Ae.bb)(r(), {
								postId: n.id
							});
						n && "subreddit" === n.belongsTo.type && o && Object(Ce.a)(c, {
							subredditId: o.id
						}) && s(Object(g.f)(o.name, o.id)), n && "subreddit" === n.belongsTo.type && b.body.comments && await s(Object(w.a)({
							commentIds: Object.keys(b.body.comments),
							postIds: [n.id],
							subredditId: n.belongsTo.id
						}))
					} else s(ut(Object.assign({
						error: b.error,
						key: a
					}, b.body)))
				}, gt = e => async (t, n, s) => {
					await t(Object(K.c)(e, !0))
				}, _t = () => async (e, t, n) => {
					await e((() => async (e, t, n) => {
						let {
							apiContext: s
						} = n;
						const r = t(),
							o = await Object(U.a)(s());
						if (o.ok && o.body)
							if (o.body.account)
								if (r.user.account && r.user.account.isFPR) {
									const e = "https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/my-account-was-suspended-or-locked";
									window.location.href = e
								} else e(G(o.body));
						else Object(M.a)(e, r);
						else e(B(o.error))
					})())
				}, yt = (e, t, n) => async (s, r, o) => {
					let {
						routes: c
					} = o;
					const i = r(),
						d = (t || i.platform.currentPage).routeMatch.match,
						u = Object(xe.a)(d.url, c);
					if (!u) return;
					const l = e.metaKey || e.ctrlKey || 1 === e.button;
					if (u.route && u.route.meta && (u.route.meta.name === T.yb.INDEX || u.route.meta.name === T.yb.MULTIREDDIT || u.route.meta.name === T.yb.SUBREDDIT)) l ? window.open(d.url) : n ? s(Object(a.b)(d.url)) : await s(u.route.action(d, !0));
					else if (u.match && u.match.params && u.match.params.subredditName) {
						const {
							subredditName: e
						} = u.match.params, t = "/r/".concat(e, "/");
						if (l) window.open(t);
						else if (n) s(Object(a.b)(t));
						else {
							const n = Object(ke.a)(e, T.M.HOT);
							await s(Object(a.b)(t)), s(Object(f.i)(n, e, {}))
						}
					}
				}, jt = Object(N.a)("PAGE__FRONTPAGE_RELOADED"), ht = e => async (t, n, s) => {
					const r = n(),
						o = r.platform.currentPage.routeMatch.match;
					Object(De.n)(r) || Object(De.r)(r) || (e || t(jt()), await t(rt(o, !0)))
				}, Et = "PAGE__MULTIREDDIT_FEED_PENDING", It = "PAGE__MULTIREDDIT_FEED_LOADED", vt = "PAGE__MULTIREDDIT_FEED_FAILED", St = Object(N.a)(Et), Tt = Object(N.a)(It), Dt = Object(N.a)(vt), Ct = (e, t, n, r, o) => async (a, c, i) => {
					const {
						gqlContext: d
					} = i, u = c();
					if (u.listings.postOrder.api.pending[e]) return;
					a(St({
						key: e
					})), r.layout = $.e[Object(te.N)(u, {})];
					const l = {
							path: Object(ie.h)(t, n).replace(/\/$/, ""),
							includeIdentity: !0,
							includeSources: !0,
							sort: r.sort ? r.sort.toUpperCase() : void 0,
							range: r.t ? r.t.toUpperCase() : void 0
						},
						b = await Object(Ue.a)("multireddit", () => Object(E.a)(d(), l)),
						{
							data: f
						} = b.body,
						m = "error-".concat(e);
					if (b.ok && f) {
						const s = Object(oe.a)(f);
						if (!f.multireddit) return o && a(W.f(m)), void a(Dt(Object.assign({}, s, {
							error: {
								type: T.C.NOT_FOUND_ERROR
							},
							key: e
						})));
						a(Tt(Object.assign({
							key: e,
							meta: u.meta
						}, s, {
							account: s.account || Object(Ee.i)(u),
							multiredditsModelsState: u.multireddits.models
						}))), o && a(W.f(m)), a(Object(p.h)({
							multiredditName: n,
							username: t
						})), window.addEventListener("load", () => {
							a(Object(Ne.b)(Fe.a.MULTIREDDIT))
						})
					} else o && a(W.e({
						id: m,
						kind: ue.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "36ypKx"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: Ct(e, t, n, r, o)
					}))
				}, wt = (e, t) => async (n, s) => {
					const {
						multiredditName: r
					} = e.params;
					let {
						username: i
					} = e.params;
					if (!i) {
						let t = s();
						if (t.user.session && t.user.session.unsafeLoggedOut) return void n(Object(a.c)("/"));
						!t.user.account && t.user.session && await n(Y.r()), t = s();
						const {
							account: o
						} = t.user;
						if (!o) return void n(Object(a.c)("/"));
						i = Object(le.e)(o);
						let d = "/user/".concat(i, "/m/").concat(r);
						const {
							sort: u
						} = e.params;
						return d += u ? "/".concat(u) : "", void n(Object(a.c)(Object(c.a)(d, e.queryParams)))
					}
					const {
						sort: d = T.M.HOT
					} = e.params, u = {
						multiredditName: r,
						username: i
					}, l = s();
					i || (i = l.user.account ? Object(le.e)(l.user.account) : "");
					const b = Object(ie.h)(i, r),
						p = Object(ke.a)(b, d, e.queryParams),
						f = l.listings.postOrder.ids[p],
						m = l.listings.postOrder.api.error[p],
						O = l.listings.postOrder.api.pending[p],
						g = Z.t in e.queryParams && e.queryParams[Z.t].toUpperCase() || "",
						_ = g in T.Pb && T.Pb[g];
					if (O || f && !m && !t) return void(f && (n(L.l({
						title: Object(we.f)(s(), u)
					})), l.sidebarPromotedPosts.firstFetch || n(Object(Ne.b)(Fe.a.MULTIREDDIT))));
					await n(Ct(p, i, r, Object.assign({}, o()(e.queryParams, Z.k), o()(e.queryParams, Z.j), {
						sort: d,
						t: Object(re.a)(d, _)
					}), !0));
					const y = s();
					Object(we.d)(y, u) && n(L.l({
						title: Object(we.f)(s(), u)
					})), Object(Le.c)(y, n, e)
				}, At = "PAGE__DASHBOARD_PENDING", Rt = (Object(N.a)(At), e => async (e, t) => {
					const n = t();
					e(L.l({
						title: C.a()
					})), Object(Ee.H)(n) || await e(Y.r())
				}), Pt = e => async (e, t) => e(L.l({
					title: C.a()
				})), kt = e => async (t, s) => {
					const r = s();
					if (t(L.l({
							title: C.e()
						})), e.queryParams.thanks) {
						const e = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/goldPurchaseModals/payment.ts")).then(e => e.paymentCompleted);
						setTimeout(() => {
							t(P.e()), t(e({
								confirmed: !1
							}))
						}, 1e3)
					}
					Object(Ee.H)(r) || await t(Y.r())
				}, xt = e => async (e, t) => {
					const n = t();
					e(L.l({
						title: C.f()
					})), Object(Ee.H)(n) || await e(Y.r())
				}, Nt = e => async (t, n) => {
					const s = n(),
						r = e.params.thingId;
					t(Object(R.c)({
						thingId: r,
						gildModalId: Object(_.a)(r)
					})), Object(Ee.H)(s) || await t(Y.r());
					const o = n();
					if (!Object(Ee.H)(o)) return t(Object(R.f)())
				}, Lt = e => async (e, t) => {
					const n = t();
					Object(Ee.H)(n) || await e(Y.r());
					const s = t();
					if (!Object(Ee.H)(s)) throw new Error("Failed to login")
				}, Ut = () => async (e, t, n) => await e(m.d())
		},
		"./src/reddit/actions/pages/appeal/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "APPEAL_PAGE_LOADED",
				r = "APPEAL_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/collectionCommentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return G
			})), n.d(t, "b", (function() {
				return B
			})), n.d(t, "a", (function() {
				return q
			})), n.d(t, "e", (function() {
				return W
			})), n.d(t, "c", (function() {
				return Y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makeCollectionCommentsPageKey/index.ts"),
				o = n("./src/lib/pageTitle.ts"),
				a = n("./src/lib/truncateText/index.ts"),
				c = n("./src/reddit/actions/ads/index.ts"),
				i = n("./src/reddit/actions/economics/helpers/async.ts"),
				d = n("./src/reddit/actions/page.ts"),
				u = n("./src/reddit/actions/pages/subreddit.ts"),
				l = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/post.ts"),
				p = n("./src/reddit/actions/profile/index.ts"),
				f = n("./src/reddit/actions/shortcuts/active.ts"),
				m = n("./src/reddit/actions/subreddit.ts"),
				O = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/constants/adEvents.ts"),
				_ = n("./src/reddit/constants/parameters.ts"),
				y = n("./src/reddit/constants/postCollection.ts"),
				j = n("./src/reddit/constants/posts.ts"),
				h = n("./src/reddit/endpoints/governance/posts.ts"),
				E = n("./src/config.ts"),
				I = n("./src/lib/constants/index.ts"),
				v = n("./src/lib/makeApiRequest/index.ts"),
				S = n("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function T(e, t, n) {
				const s = "".concat(E.a.gatewayUrl, "/desktopapi/v1/collection_postcomments");
				return n ? Object(S.a)("".concat(s, "/").concat(e, "/").concat(t, "/").concat(n)) : t ? Object(S.a)("".concat(s, "/").concat(e, "/").concat(t)) : Object(S.a)("".concat(s, "/").concat(e))
			}
			var D = (e, t, n, s, r) => Object(v.b)(e, {
					data: r,
					endpoint: T(t, n, s),
					method: I.ab.GET
				}),
				C = n("./src/reddit/endpoints/page/subredditPage.ts"),
				w = n("./src/reddit/helpers/canonicalUrls.ts"),
				A = n("./src/reddit/helpers/commentList/index.ts"),
				R = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				P = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				k = n("./src/reddit/models/Comment/index.ts"),
				x = n("./src/reddit/models/Post/index.ts"),
				N = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				L = n("./src/reddit/selectors/platform.ts"),
				U = n("./src/reddit/selectors/postCollection.ts"),
				M = n("./src/reddit/selectors/posts.ts"),
				F = n("./src/reddit/selectors/subreddit.ts");
			const G = "PAGE__COLLECTIONCOMMENTSPAGE_PENDING",
				B = "PAGE__COLLECTIONCOMMENTSPAGE_LOADED",
				q = "PAGE__COLLECTIONCOMMENTSPAGE_FAILED",
				V = Object(s.a)(G),
				K = Object(s.a)(B),
				H = Object(s.a)(q),
				W = e => async (t, n) => {
					const {
						collectionId: s,
						partialPostId: r,
						partialCommentId: c,
						subredditName: i = "",
						routePrefix: d
					} = e.params, u = r ? Object(x.m)(r) : "", O = c && Object(k.e)(c), {
						queryParams: g
					} = e, h = n(), {
						instanceId: E
					} = g, I = {
						id: s,
						type: j.b[d]
					}, v = j.b[d] === j.a.PROFILE, {
						hasSortParam: S,
						sortToUse: T
					} = Object(R.a)(h, u), D = ["context", "depth", "limit", _.e].reduce((e, t) => {
						const n = parseInt(g[t]);
						return isNaN(n) || (e[t] = n), e
					}, {
						subredditName: i,
						hasSortParam: S,
						instanceId: E
					});
					S && (D.sort = T), t(b.t(u)), await Promise.all([v ? t(p.d(i)) : Promise.resolve(), t(J(s, u, O, D))]);
					const C = ((e, t) => {
						const n = Object(U.r)(e, {
							collectionId: t.id
						});
						if (!n) return "";
						const s = Object(F.K)(e, {
								identifier: t
							}),
							r = Object(o.b)(n.title, s.name).toString();
						return Object(a.a)(r, y.c, " …")
					})(n(), I) || Object(o.c)();
					t(l.l({
						title: C
					}));
					const A = n().posts.models[u];
					if (A) {
						const s = Object(F.K)(n(), {
							identifier: A.belongsTo
						});
						if (!A.isSponsored)
							if (A.belongsTo.type === j.a.SUBREDDIT) {
								!!Object(F.P)(h, {
									subredditId: A.belongsTo.id
								}) || await t(m.o(s.name))
							} else await t(p.d(s.name));
						const r = n().posts.instances[u] ? e.queryParams.instanceId : A.postId;
						t(Object(f.b)(r))
					}
					v ? Object(w.d)(n(), t, e) : Object(w.e)(n(), t, e)
				}, Y = "PAGE__COLLECTIONCOMMENTSPAGE_LOADED_FULL", Q = Object(s.a)(Y), z = (e, t, n, s) => async (o, a, c) => {
					const i = Object(r.a)(e, t, n, s),
						d = a();
					t = t || Object(U.q)(d, {
						collectionId: e
					});
					const u = await D(c.apiContext(), e, t, n, s);
					if (o(Object(l.m)(u.status)), u.ok) {
						if (!(t = t || u.body.collections[e].primaryPostId)) return;
						const n = Object(A.a)(u.body, t, d);
						o(K(Object.assign({
							key: i,
							collectionId: e,
							meta: d.meta,
							postId: t,
							shouldCollapse: n
						}, u.body)));
						const s = d.user.prefs.commentMode;
						o(Q({
							commentMode: s,
							key: i,
							postId: t
						}))
					} else o(H(Object.assign({
						error: u.error,
						key: i
					}, u.body)))
				}, J = (e, t, n, s, o) => async (a, p, f) => {
					const m = Object(r.a)(e, t, n, s),
						_ = p();
					t = t || Object(U.q)(_, {
						collectionId: e
					});
					const {
						subredditName: y
					} = s, j = _.commentsPage.keyToHeadCommentId.hasOwnProperty(m), E = _.commentsPage.api.fullyLoaded[m], I = _.commentsPage.api.error[m];
					if (_.commentsPage.api.pending[m] || j && !I) {
						if (j && !_.sidebarPromotedPosts.firstFetch) {
							const e = Object(L.h)(_) ? N.a.COMMENTS_OVERLAY : N.a.COMMENTS;
							window.addEventListener("load", () => {
								a(Object(c.b)(e))
							})
						}
						return void(E || o || a(z(e, t, n, s)))
					}
					const v = _.user.prefs.commentMode;
					a(V({
						key: m,
						collectionId: e,
						commentMode: v,
						postId: t
					}));
					const S = Object.assign({}, s); {
						const e = t && Object(M.O)(p(), {
							postId: t
						});
						e && e.numComments && e.numComments > d.i && (S.truncate = d.m)
					}
					let T, w = await Object(P.a)("comments", () => D(f.apiContext(), e, t, n, S));
					if (a(Object(l.m)(w.status)), w.ok && (t = t || w.body.collections[e].primaryPostId)) {
						const e = Object.keys(w.body.posts).filter(e => !!w.body.posts[e].isMeta),
							n = Object(M.O)(p(), {
								postId: t
							});
						if (e.length) {
							const t = await Object(h.a)(f.apiContext(), n.belongsTo.id, e);
							t.ok && (T = t.body)
						}
					}
					if (!o) {
						const r = t ? Object(M.O)(p(), {
							postId: t
						}) : null;
						r && w.body.comments && Object.keys(w.body.comments).length < r.numComments ? a(z(e, t, n, s)) : w.ok && a(Q({
							commentMode: v,
							key: m,
							postId: t
						}));
						const o = Object(L.h)(_) ? N.a.COMMENTS_OVERLAY : N.a.COMMENTS;
						a(Object(c.b)(o))
					}
					if (w.ok) {
						if (!t) return;
						const e = Object(A.a)(w.body, t, _);
						a(Object(d.s)(Object.assign({
							commentMode: v,
							key: m,
							postId: t,
							meta: _.meta,
							governance: T,
							shouldCollapse: e
						}, w.body))), a(O.f(m));
						const n = Object(M.O)(_, {
							postId: t
						});
						a(b.B(n, g.a.CommentsView)), !o && n && "subreddit" === n.belongsTo.type && w.body.comments && await a(Object(i.a)({
							commentIds: Object.keys(w.body.comments),
							postIds: [n.id],
							subredditId: n.belongsTo.id
						}))
					} else y && (a(Object(u.k)({
						key: m
					})), w = await Object(P.a)("subreddit", () => Object(C.a)(f.apiContext(), y, {})), a(Object(l.m)(w.status))), a(Object(u.f)(w, y)), a(H(Object.assign({
						error: w.error,
						key: m
					}, w.body)))
				}
		},
		"./src/reddit/actions/pages/modListing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return f
			}));
			const s = "PAGE__MOD_LISTING_PAGE_PENDING",
				r = "PAGE__MOD_LISTING_PAGE_LOADED",
				o = "PAGE__MOD_LISTING_PAGE_FAILED",
				a = "MOD_LISTING_MORE_POSTS_PENDING",
				c = "MOD_LISTING_MORE_POSTS_LOADED",
				i = "MOD_LISTING_MORE_POSTS_FAILED",
				d = "MOD_LISTING_HIDE_SUBREDDIT_SUCCESS",
				u = "MOD_LISTING_HIDE_SUBREDDIT_PENDING",
				l = "MOD_LISTING_HIDE_SUBREDDIT_FAILED",
				b = "MOD_LISTING_UNHIDE_SUBREDDIT_SUCCESS",
				p = "MOD_LISTING_UNHIDE_SUBREDDIT_PENDING",
				f = "MOD_LISTING_UNHIDE_SUBREDDIT_FAILED"
		},
		"./src/reddit/actions/pages/modListing/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return N
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "a", (function() {
				return Q
			})), n.d(t, "d", (function() {
				return z
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/platform.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/page.ts"),
				b = n("./src/reddit/constants/parameters.ts"),
				p = n("./src/config.ts"),
				f = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				O = n("./src/reddit/constants/headers.ts"),
				g = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				_ = n("./src/reddit/helpers/name/index.ts"),
				y = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				j = (e, t) => Object(f.b)(e, {
					data: t,
					endpoint: Object(g.a)(Object(y.a)("".concat(p.a.gatewayUrl, "/desktopapi/v1/mod"))),
					method: a.ab.GET
				});
			const h = (e, t, n, s) => Object(f.b)(Object(m.a)(e, [O.a]), {
					endpoint: "".concat(e.apiUrl, "/api/filter/user/").concat(t, "/f/mod/").concat(Object(_.b)(n)),
					method: s ? a.ab.PUT : a.ab.DELETE,
					data: {
						model: JSON.stringify({
							name: Object(_.g)(n)
						})
					}
				}),
				E = (e, t, n) => h(e, t, n, !0),
				I = (e, t, n) => h(e, t, n, !1);
			var v = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				S = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				T = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				D = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/routes/modListing/index.ts"),
				w = n("./src/reddit/selectors/user.ts"),
				A = n("./src/reddit/actions/pages/modListing/constants.ts");
			const R = Object(c.a)(A.f),
				P = Object(c.a)(A.e),
				k = Object(c.a)(A.d),
				x = (e, t) => async (n, r, o) => {
					const a = r();
					if (a.listings.postOrder.api.pending[e]) return;
					n(R({
						key: e
					}));
					const c = await Object(T.a)("modListing", () => j(o.apiContext(), t)),
						i = "error-".concat(e);
					c.ok ? (n(P(Object.assign({
						key: e,
						meta: a.meta
					}, c.body))), n(u.f(i))) : (n(k(Object.assign({
						error: c.error,
						key: e
					}, c.body))), 401 === c.status ? Object(S.a)(n, a) : n(u.e({
						id: i,
						kind: D.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: x(e, t)
					})))
				}, N = (e, t) => async (n, r) => {
					const {
						sort: c = a.N
					} = e.params, u = Object(C.d)(e.path), p = u ? l.e : l.d, f = Object(i.a)(p, c, e.queryParams), m = r(), O = m.listings.postOrder.ids[f], g = m.listings.postOrder.api.error[f];
					if (m.listings.postOrder.api.pending[f] || O && !g && !t) return void(O && n(d.l({
						title: s.fbt._("Subreddits you moderate", null, {
							hk: "3RYtBz"
						})
					})));
					const _ = G(e.queryParams);
					await n(x(f, Object.assign({}, o()(e.queryParams, b.k), o()(e.queryParams, b.j), {
						filtered: !!u || void 0,
						moderated_srs: !0,
						sort: c,
						t: Object(v.a)(c, _)
					}))), n(d.l({
						title: s.fbt._("Subreddits you moderate", null, {
							hk: "3RYtBz"
						})
					}))
				}, L = Object(c.a)(A.i), U = Object(c.a)(A.h), M = Object(c.a)(A.g), F = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const c = n(),
						d = c.platform.currentPage;
					if (!d) return;
					const {
						sort: u = a.N
					} = e, p = d.queryParams, f = Object(C.d)(d.url), m = f ? l.e : l.d, O = Object(i.a)(m, u, p), g = c.listings.postOrder.loadMore[O];
					if (!g) return;
					const _ = c.listings.postOrder.api.pending[O],
						y = c.listings.postOrder.fetchedTokens,
						h = !(!y[O] || !y[O][g.token]);
					if (_ || h) return;
					const E = G(p);
					t(L({
						key: O,
						fetchedToken: g.token
					}));
					const I = await j(r(), Object.assign({
							after: g.token,
							dist: g.dist,
							filtered: !!f || void 0,
							sort: u,
							t: Object(v.a)(u, E)
						}, o()(p, b.k))),
						S = c.listings.postOrder.ids[O],
						T = Object.assign({}, I.body, {
							postIds: (I.body.postIds || []).filter(e => !S || !S.includes(e))
						});
					I.ok ? t(U(Object.assign({
						key: O,
						fetchedToken: g.token,
						meta: c.meta
					}, T))) : t(M(Object.assign({
						key: O,
						error: I.error,
						fetchedToken: g.token
					}, T)))
				};

			function G(e) {
				const t = b.t in e && e[b.t].toUpperCase() || "";
				return t in a.Pb && a.Pb[t]
			}
			const B = Object(c.a)(A.c),
				q = Object(c.a)(A.b),
				V = Object(c.a)(A.a),
				K = Object(c.a)(A.l),
				H = Object(c.a)(A.k),
				W = Object(c.a)(A.j),
				Y = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(w.i)(a),
						[i, d, u, l] = t ? [q, B, V, E] : [H, K, W, I];
					if (!c || !c.displayText) return;
					const {
						currentPage: b
					} = a.platform;
					if (!b || !b.routeMatch) return;
					n(i(e));
					const p = await l(o(), c.displayText, e);
					p.ok ? (await n(N(b.routeMatch.match, !0)), n(d(e))) : n(u(p.body))
				}, Q = e => Y(e, !0), z = e => Y(e, !1)
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return x
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "d", (function() {
				return B
			})), n.d(t, "e", (function() {
				return q
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/filterQueryParams/index.ts"),
				a = n("./src/lib/isFakeSubreddit/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makePostCreationPageKey/index.ts"),
				d = n("./src/lib/pageTitle.ts"),
				u = n("./src/reddit/actions/economics/helpers/async.ts"),
				l = n("./src/reddit/actions/externalAccount.ts"),
				b = n("./src/reddit/actions/platform.ts"),
				p = n("./src/reddit/actions/post.ts"),
				f = n("./src/reddit/actions/postCreation/general.ts"),
				m = n("./src/reddit/actions/postRequirements/index.ts"),
				O = n("./src/reddit/actions/profile/index.ts"),
				g = n("./src/reddit/actions/subreddit.ts"),
				_ = n("./src/reddit/actions/subredditDuplicates.ts"),
				y = n("./src/config.ts"),
				j = n("./src/lib/makeApiRequest/index.ts"),
				h = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				E = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				I = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				v = n("./src/reddit/helpers/trackers/postComposer.ts"),
				S = n("./src/reddit/models/User/index.ts"),
				T = n("./src/reddit/selectors/postCollection.ts"),
				D = n("./src/reddit/selectors/postCreations.ts"),
				C = n("./src/reddit/selectors/postRequirements.ts"),
				w = n("./src/reddit/selectors/posts.ts"),
				A = n("./src/reddit/selectors/profile.ts"),
				R = n("./src/reddit/selectors/subreddit.ts"),
				P = n("./src/reddit/selectors/user.ts");
			const k = e => {
					const t = e.platform.currentPage;
					let n = "Reddit";
					if (t && t.urlParams.subredditName) {
						const {
							subredditName: s
						} = t.urlParams, r = Object(R.z)(e, {
							subredditName: s
						});
						r && (n = r.name)
					}
					return Object(d.h)(n)
				},
				x = "POST_CREATION__PAGE_PENDING",
				N = "POST_CREATION__PAGE_LOADED",
				L = "POST_CREATION__PAGE_FAILED",
				U = Object(c.a)(x),
				M = Object(c.a)(N),
				F = Object(c.a)(L),
				G = () => async (e, t) => {
					const n = t(),
						s = Object(D.a)(n);
					s !== Object(D.ab)(n) && e(Object(f.h)({
						submissionType: s
					}))
				}, B = e => async (t, n, s) => {
					const {
						collectionId: o,
						profileName: c,
						subredditName: d
					} = e, u = Object(i.a)(e), b = n(), p = b.creations.api.page.pending[u], f = b.creations.api.page.fetched[u], _ = b.creations.api.page.error[u];
					if (p) return;
					if (f && !_) return void t(G());
					const E = [];
					t(U({
						key: u
					}));
					let v = d;
					!d && c && (v = "u_".concat(c)), E.push(((e, t) => Object(j.b)(e, {
						method: r.ab.GET,
						endpoint: Object(h.a)("".concat(y.a.gatewayUrl, "/desktopapi/v1/submitpage")),
						data: {
							subreddit: t.subredditName,
							collection_id: t.collectionId
						}
					}))(s.apiContext(), {
						subredditName: v,
						collectionId: o
					})), c && (E.push(t(O.d(c))), E.push(t(O.b(c))));
					const [T] = await Object(I.a)("postCreation", () => Promise.all(E));
					if (T.ok) {
						const e = T.body,
							{
								posts: s = {}
							} = e;
						if (t(M(Object.assign({
								key: u,
								meta: b.meta
							}, e, {
								posts: s
							}))), !Object(P.H)(n())) return;
						t(G());
						const r = [];
						r.push(t(l.o()));
						const o = Object(P.i)(n());
						if (o && o.hasUserProfile && r.push(t(O.d(Object(S.e)(o)))), d && !Object(a.a)(d)) {
							r.push(t(g.o(d))), !!Object(C.b)(n(), {
								subredditName: d
							}) || r.push(t(Object(m.a)(d)))
						}
						await Promise.all(r)
					} else t(F({
						error: T.error,
						key: u
					}))
				}, q = e => async (t, n) => {
					const {
						subredditName: a,
						profileName: c
					} = e.params, i = e.queryParams, d = i.collection;
					if (await t(B({
							collectionId: d,
							profileName: c,
							subredditName: a
						})), !Object(P.H)(n())) return void Object(E.a)(t, n());
					let l;
					if (a ? (l = Object(R.z)(n(), {
							subredditName: a
						}), await t(Object(u.a)({
							subredditName: a
						}))) : c && (l = Object(A.j)(n(), {
							profileName: c
						})), i.source_id) await t(((e, t) => async (n, s) => {
						const {
							subredditName: r,
							profileName: o
						} = e, a = [];
						let c;
						r ? c = Object(R.E)(s(), r) : o && (c = Object(P.X)(s(), {
							userName: o
						})), c && a.push(n(Object(_.b)(c, t))), a.push(n(Object(p.S)(t))), await Promise.all(a);
						const i = Object(w.f)(s(), {
							postId: t
						});
						n(Object(f.l)({
							postId: t,
							postTitle: i ? i.title : ""
						}))
					})(e.params, i.source_id));
					else if (d) {
						const r = Object(T.r)(n(), {
							collectionId: d
						});
						l && r && r.subredditId === l.id || t(Object(s.c)(Object(o.a)(e.url, ["collection"])))
					}((e, t) => {
						const n = e.platform.lastPage;
						t && n && n.meta && n.meta.name === r.yb.POST_CREATION && v.u(e)
					})(n(), a), t(b.l({
						title: k(n())
					}))
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return g
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makePostDraftPageKey/index.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				a = n("./src/config.ts"),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				u = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				l = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				b = n("./src/reddit/helpers/timeApiRoute/index.ts");
			const p = "POST_DRAFT__PAGE_LOADED",
				f = (Object(s.a)("POST_DRAFT__PAGE_PENDING"), Object(s.a)(p)),
				m = Object(s.a)("POST_DRAFT__PAGE_FAILED"),
				O = e => async (t, n, s) => {
					const {
						draftId: p,
						profileName: O
					} = e, g = Object(r.a)(e), _ = n(), y = _.creations.api.page.pending[g], j = _.creations.api.page.fetched[g], h = _.creations.api.page.error[g];
					if (y || j && !h || !p) return;
					t(o.d(O));
					const E = await Object(b.a)("postDraft", () => ((e, t, n) => Object(i.b)(e, {
						endpoint: Object(d.a)(Object(u.a)("".concat(a.a.gatewayUrl, "/desktopapi/v1/draftpreviewpage/").concat(n, "/").concat(t))),
						method: c.ab.GET
					}))(s.apiContext(), p, O));
					if (E.ok) {
						const e = E.body;
						e.drafts[p].kind = Object(l.b)(e.drafts[p].kind), t(f(Object.assign({}, e, {
							key: g
						})))
					} else t(m({
						error: E.error,
						key: g
					}))
				}, g = e => async (t, n, s) => {
					await t(O(e.params))
				}
		},
		"./src/reddit/actions/pages/profileComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return R
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "h", (function() {
				return U
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "b", (function() {
				return F
			})), n.d(t, "a", (function() {
				return G
			})), n.d(t, "g", (function() {
				return K
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/lodash/difference.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				a = n.n(o),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/contentGate.ts"),
				u = n("./src/reddit/actions/externalAccount.ts"),
				l = n("./src/reddit/actions/moderatingSubreddits.ts"),
				b = n("./src/reddit/actions/pages/profileShared.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				f = n("./src/reddit/actions/profile/index.ts"),
				m = n("./src/reddit/actions/subreddit.ts"),
				O = n("./src/reddit/constants/errors.ts"),
				g = n("./src/reddit/constants/parameters.ts"),
				_ = n("./src/reddit/contexts/PageLayer/index.tsx"),
				y = n("./src/config.ts"),
				j = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				h = n("./src/lib/constants/index.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				I = n("./src/reddit/models/Comment/addProfileImgParam.ts"),
				v = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const S = (e, t, n, s) => {
				let r = Object(j.a)(Object(v.a)("".concat(y.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/comments")));
				return s && (r = Object(I.a)(r)), Object(E.b)(e, {
					data: n,
					endpoint: r,
					method: h.ab.GET
				})
			};
			var T = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				D = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				C = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				w = n("./src/reddit/selectors/profile.ts"),
				A = n("./src/reddit/selectors/profileComments.ts");
			const R = "PAGE__PROFILE_COMMENTS_PENDING",
				P = "PAGE__PROFILE_COMMENTS_LOADED",
				k = "PAGE__PROFILE_COMMENTS_FAILED",
				x = Object(c.a)(R),
				N = Object(c.a)(P),
				L = Object(c.a)(k),
				U = e => async (t, n, s) => {
					const {
						queryParams: r,
						params: o
					} = e, {
						sort: c,
						t: _
					} = Object(b.b)(r), {
						profileName: y
					} = o, j = Object(i.a)("u_".concat(y), c, e.queryParams), {
						profileCommentsPage: h
					} = n(), E = h.commentIds[j], I = h.api.error[j], v = h.api.pending[j];
					if (await t(f.d(y)), v || E && !I) {
						if (E) {
							const e = Object(w.q)(n(), {
								profileName: y
							});
							t(p.l({
								title: e
							}))
						}
						return
					}
					const A = Object.assign({}, a()(e.queryParams, [...g.k, g.g]), {
						sort: c,
						t: Object(T.a)(c, _)
					});
					t(x({
						key: j
					}));
					const R = await Object(D.a)("profileComments", () => S(s.apiContext(), y, A, Object(C.a)(n())));
					if (!R.ok) return t(L({
						account: R.body.data ? R.body.data.account : null,
						error: R.body.reason ? {
							type: R.body.reason
						} : R.error,
						key: j
					})), R.body.reason === O.a.DeletedProfile && t(Object(d.p)({
						profileName: y
					})), void t(p.m(R.status));
					const P = R.body;
					t(N(Object.assign({
						key: j,
						meta: n().meta
					}, P))), await Promise.all([t(Object(b.c)(y)), t(Object(m.q)()), t(Object(l.b)()), t(u.o(y))])
				}, M = "PROFILE_COMMENTS__MORE_ITEMS_PENDING", F = "PROFILE_COMMENTS__MORE_ITEMS_LOADED", G = "PROFILE_COMMENTS__MORE_ITEMS_FAILED", B = Object(c.a)(M), q = Object(c.a)(F), V = Object(c.a)(G), K = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						{
							currentPage: c
						} = o.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: d,
						params: u
					} = c.routeMatch.match, {
						sort: l,
						t: p
					} = Object(b.b)(d), {
						profileName: f
					} = u, m = Object(i.a)("u_".concat(f), l, d), O = Object(A.d)(o, {
						listingKey: m
					});
					if (!O) return;
					const y = Object(A.b)(o, {
							listingKey: m
						}),
						j = Object(A.c)(o, {
							listingKey: m
						}),
						h = j && j[O.token];
					if (y || h) return;
					e(B({
						key: m,
						fetchedToken: O.token
					}));
					const E = await S(s(), f, Object.assign({
						after: O.token,
						dist: O.dist,
						sort: l,
						t: p
					}, a()(d, g.k), {
						layout: Object(_.N)(o, {}).toLowerCase()
					}), Object(C.a)(o));
					if (E.ok) {
						const t = Object(A.f)(o, {
								listingKey: m
							}),
							n = Object.assign({}, E.body, {
								commentIds: r()(E.body.commentIds, t)
							});
						e(q(Object.assign({
							fetchedToken: O.token,
							key: m,
							meta: o.meta
						}, n)))
					} else e(V({
						account: E.body.data ? E.body.data.account : null,
						error: E.error,
						fetchedToken: O.token,
						key: m
					}))
				}
		},
		"./src/reddit/actions/pages/profileModSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/preferences.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				a = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				c = n("./src/reddit/models/User/index.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const d = "PAGE__PROFILE_MOD_SETTINGS_LOADED",
				u = Object(s.a)(d),
				l = e => async (t, n) => {
					const s = [t(r.z()), t(Object(o.d)(e.params.profileName))];
					await Promise.all(s);
					const d = Object(i.i)(n());
					d ? (await t(Object(o.b)(Object(c.e)(d))), t(u())) : Object(a.a)(t, n())
				}
		},
		"./src/reddit/actions/pages/profileOverview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "c", (function() {
				return w
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "g", (function() {
				return M
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/reddit/actions/moderatingSubreddits.ts"),
				a = n("./src/reddit/actions/pages/profileShared.ts"),
				c = n("./src/reddit/actions/subreddit.ts"),
				i = n("./src/reddit/endpoints/page/profileOverviewPage.ts"),
				d = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/constants/postLayout.ts"),
				l = n("./src/reddit/constants/parameters.ts"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/selectors/listings.ts"),
				f = n("./src/reddit/selectors/profile.ts"),
				m = n("./src/reddit/selectors/profileOverviewChronoItems.ts"),
				O = n("./src/lib/makeActionCreator/index.ts"),
				g = n("./src/reddit/actions/contentGate.ts"),
				_ = n("./src/reddit/actions/externalAccount.ts"),
				y = n("./src/reddit/actions/pinnedPost.ts"),
				j = n("./src/reddit/actions/platform.ts"),
				h = n("./src/reddit/actions/profile/index.ts"),
				E = n("./src/reddit/actions/trophyCase.ts"),
				I = n("./src/reddit/constants/errors.ts"),
				v = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				S = n("./src/reddit/helpers/timeApiRoute/index.ts");
			const T = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_PENDING",
				D = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_LOADED",
				C = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_FAILED",
				w = "PAGE__PROFILE_OVERVIEW_CHRONO_PENDING",
				A = "PAGE__PROFILE_OVERVIEW_CHRONO_LOADED",
				R = "PAGE__PROFILE_OVERVIEW_CHRONO_FAILED",
				P = Object(O.a)(T),
				k = Object(O.a)(D),
				x = Object(O.a)(C),
				N = Object(O.a)(w),
				L = Object(O.a)(A),
				U = Object(O.a)(R),
				M = e => async (t, n, s) => {
					const {
						queryParams: O,
						params: T
					} = e, {
						sort: D,
						t: C
					} = Object(a.a)(n(), O), {
						profileName: w
					} = T, A = u.e[Object(b.N)(n(), {})], R = w.toLowerCase(), M = Object.assign({}, r()(e.queryParams, l.k), {
						sort: D,
						layout: A,
						t: C
					});
					if (await t(h.d(R)), A === u.e[u.g.Compact]) {
						const s = Object(v.a)(R, d.hb, D, e.queryParams);
						if (n().profileOverviewPage.chrono.ids[s]) return;
						await t(((e, t, n, s) => async (s, r, o) => {
							const a = r(),
								c = !!Object(m.f)(a, {
									listingKey: e
								}).length,
								d = !!Object(m.a)(a, {
									listingKey: e
								});
							if (!!Object(m.b)(a, {
									listingKey: e
								}) || c && !d) return;
							s(N({
								key: e
							}));
							const u = await Object(S.a)("profile", () => Object(i.a)(o.apiContext(), t, n)),
								l = u.body,
								{
									pinned: b
								} = l;
							if (u.ok) {
								s(L(Object.assign({
									key: e,
									meta: a.meta
								}, l)));
								const n = Object(f.m)(a, t);
								s(Object(y.h)({
									profileId: n,
									pinned: b
								}))
							} else s(U({
								account: u.body.data ? u.body.data.account : null,
								error: u.body.reason ? {
									type: u.body.reason
								} : u.error,
								key: e
							})), u.body.reason === I.a.DeletedProfile && s(Object(g.p)({
								profileName: t
							})), s(Object(j.m)(u.status))
						})(s, R, M))
					} else {
						const s = Object(v.a)(R, d.ib, D, e.queryParams);
						if (n().listings.postOrder.ids[s] && !n().listings.postOrder.api.error[s]) return;
						await t(((e, t, n, s) => async (s, r, o) => {
							const a = r(),
								c = !!a.listings.postOrder.ids[e],
								d = !!Object(p.c)(a, {
									listingKey: e
								});
							if (!!Object(p.d)(a, {
									listingKey: e
								}) || c && !d) return;
							s(P({
								key: e
							}));
							const u = await Object(S.a)("profile", () => Object(i.b)(o.apiContext(), t, n)),
								l = u.body,
								{
									pinned: b,
									postIds: m
								} = l;
							if (u.ok) {
								s(k(Object.assign({
									key: e,
									meta: a.meta,
									profileName: t
								}, l, {
									postIds: m
								})));
								const n = Object(f.m)(a, t);
								s(Object(y.h)({
									profileId: n,
									pinned: b
								}))
							} else s(x({
								account: u.body.data ? u.body.data.account : null,
								error: u.body.reason ? {
									type: u.body.reason
								} : u.error,
								key: e
							})), u.body.reason === I.a.DeletedProfile && s(Object(g.p)({
								profileName: t
							})), s(Object(j.m)(u.status))
						})(s, R, M))
					}
					await t(Object(c.q)()), await t(Object(o.b)());
					const G = n();
					if (!G.platform.currentPage) return;
					if (200 !== G.platform.currentPage.status) return;
					const B = Object(f.m)(n(), R);
					await t(E.b(R, B)), t(j.l({
						title: F(n(), w)
					}));
					const q = [t(h.b(R)), t(_.o(w)), t(h.f(w))];
					await Promise.all(q)
				}, F = (e, t) => Object(f.q)(e, {
					profileName: t
				})
		},
		"./src/reddit/actions/pages/profilePosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return C
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "d", (function() {
				return A
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "b", (function() {
				return L
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "g", (function() {
				return B
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				c = n("./src/reddit/actions/contentGate.ts"),
				i = n("./src/reddit/actions/externalAccount.ts"),
				d = n("./src/reddit/actions/moderatingSubreddits.ts"),
				u = n("./src/reddit/actions/pages/profileShared.ts"),
				l = n("./src/reddit/actions/pinnedPost.ts"),
				b = n("./src/reddit/actions/platform.ts"),
				p = n("./src/reddit/actions/profile/index.ts"),
				f = n("./src/reddit/actions/subreddit.ts"),
				m = n("./src/reddit/constants/errors.ts"),
				O = n("./src/reddit/constants/parameters.ts"),
				g = n("./src/reddit/contexts/PageLayer/index.tsx"),
				_ = n("./src/config.ts"),
				y = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				j = n("./src/lib/constants/index.ts"),
				h = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const I = (e, t, n) => Object(h.b)(e, {
				data: n,
				endpoint: Object(y.a)(Object(E.a)("".concat(_.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/posts"))),
				method: j.ab.GET
			}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? Object.assign({}, e, {
				body: Object.assign({}, e.body, {
					pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
				})
			}) : e);
			var v = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				S = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				T = n("./src/reddit/selectors/listings.ts"),
				D = n("./src/reddit/selectors/profile.ts");
			const C = "PAGE__PROFILE_POSTS_PENDING",
				w = "PAGE__PROFILE_POSTS_LOADED",
				A = "PAGE__PROFILE_POSTS_FAILED",
				R = Object(o.a)(C),
				P = Object(o.a)(w),
				k = Object(o.a)(A),
				x = e => async (t, n, s) => {
					const {
						queryParams: o,
						params: _
					} = e, {
						sort: y,
						t: j
					} = Object(u.b)(o), {
						profileName: h
					} = _, E = Object(a.a)("u_".concat(h), y, o), C = n(), w = C.listings.postOrder.ids[E], A = Object(T.c)(C, {
						listingKey: E
					}), x = Object(T.d)(C, {
						listingKey: E
					});
					if (await t(p.d(h)), x || w && !A) {
						if (w) {
							const e = Object(D.q)(n(), {
								profileName: h
							});
							t(b.l({
								title: e
							}))
						}
						return
					}
					const N = Object.assign({}, r()(e.queryParams, [...O.k, ...O.j, O.g]), {
						layout: Object(g.N)(C, {}).toLowerCase(),
						sort: y,
						t: Object(v.a)(y, j)
					});
					t(R({
						key: E
					}));
					const L = await Object(S.a)("profilePosts", () => I(s.apiContext(), h, N));
					if (!L.ok) return t(k({
						account: L.body.data ? L.body.data.account : null,
						error: L.body.reason ? {
							type: L.body.reason
						} : L.error,
						key: E
					})), L.body.reason === m.a.DeletedProfile && t(Object(c.p)({
						profileName: h
					})), void t(b.m(L.status));
					const U = L.body;
					t(P(Object.assign({
						key: E,
						meta: n().meta
					}, U)));
					const M = Object(D.m)(n(), h),
						{
							pinned: F
						} = U;
					t(Object(l.h)({
						profileId: M,
						pinned: F
					})), await Promise.all([t(Object(u.c)(h)), t(Object(f.q)()), t(Object(d.b)()), t(i.o(h))])
				}, N = "PROFILE_POSTS__MORE_POSTS_PENDING", L = "PROFILE_POSTS__MORE_POSTS_LOADED", U = "PROFILE_POSTS__MORE_POSTS_FAILED", M = Object(o.a)(N), F = Object(o.a)(L), G = Object(o.a)(U), B = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						{
							currentPage: c
						} = o.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: i,
						params: d
					} = c.routeMatch.match, {
						sort: l,
						t: b
					} = Object(u.b)(i), {
						profileName: p
					} = d, f = Object(a.a)("u_".concat(p), l, i), m = Object(T.g)(o, {
						listingKey: f
					});
					if (!m) return;
					const _ = Object(T.d)(o, {
							listingKey: f
						}),
						y = Object(T.e)(o, {
							listingKey: f,
							token: m.token
						});
					if (_ || y) return;
					e(M({
						key: f,
						fetchedToken: m.token
					}));
					const j = Object.assign({
							after: m.token,
							dist: m.dist,
							sort: l,
							t: b
						}, r()(i, O.k), {
							layout: Object(g.N)(o, {}).toLowerCase()
						}),
						h = await I(s(), p, j),
						E = o.listings.postOrder.ids[f],
						v = h.body.postIds || [],
						S = Object.assign({}, h.body, {
							postIds: v.filter(e => !E || !E.includes(e))
						});
					h.ok ? (e(F(Object.assign({
						fetchedToken: m.token,
						key: f,
						meta: o.meta
					}, S))), await e(Object(u.c)(p))) : e(G({
						account: h.body.data ? h.body.data.account : null,
						error: h.error,
						fetchedToken: m.token,
						key: f
					}))
				}
		},
		"./src/reddit/actions/pages/profilePrivate/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			}));
			const s = 25,
				r = "PAGE__PROFILE_PRIVATE_PENDING",
				o = "PAGE__PROFILE_PRIVATE_MIXED_LOADED",
				a = "PAGE__PROFILE_PRIVATE_POSTS_LOADED",
				c = "PAGE__PROFILE_PRIVATE_FAILED",
				i = "MORE__PROFILE_PRIVATE_PENDING",
				d = "MORE__PROFILE_PRIVATE_MIXED_LOADED",
				u = "MORE__PROFILE_PRIVATE_POSTS_LOADED",
				l = "MORE__PROFILE_PRIVATE_FAILED"
		},
		"./src/reddit/actions/pages/profileShared.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/defaults.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				a = n.n(o),
				c = n("./src/reddit/actions/platform.ts"),
				i = n("./src/reddit/actions/profile/index.ts"),
				d = n("./src/reddit/actions/trophyCase.ts"),
				u = n("./src/reddit/selectors/profile.ts"),
				l = n("./src/lib/constants/index.ts");
			const b = {
				sort: l.rb,
				t: l.sb
			};

			function p(e) {
				return r()(a()(e, ["t", "sort"]), b)
			}

			function f(e, t) {
				return p(t)
			}
			const m = e => async (t, n, s) => {
				const r = [t(O(e)), t(g(e)), t(Object(i.f)(e))];
				await Promise.all(r)
			}, O = e => async (t, n, s) => {
				const r = Object(u.m)(n(), e);
				await t(d.b(e, r))
			}, g = e => async (t, n, s) => {
				const r = Object(u.q)(n(), {
					profileName: e
				});
				t(c.l({
					title: r
				})), await t(i.b(e))
			}
		},
		"./src/reddit/actions/pages/report/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			const s = "REPORT_PAGE__FAILED",
				r = "REPORT_PAGE__PENDING",
				o = "REPORT_PAGE__LOADED",
				a = "REPORT_PAGE_INITIAL_REASON__SET"
		},
		"./src/reddit/actions/pages/search.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "e", (function() {
				return P
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeSearchKey/index.ts"),
				d = n("./src/lib/pageTitle.ts"),
				u = n("./src/reddit/actions/ads/index.ts"),
				l = n("./src/reddit/actions/category.ts"),
				b = n("./src/reddit/actions/communityFlairs/index.ts"),
				p = n("./src/reddit/actions/discoveryUnit.ts"),
				f = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/actions/search.ts"),
				O = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/constants/parameters.ts"),
				_ = n("./src/reddit/endpoints/page/search.ts"),
				y = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				j = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				I = n("./src/reddit/selectors/subreddit.ts");
			const v = "SEARCH__SEARCH_PENDING",
				S = "SEARCH__SEARCH_RESULTS_RECEIVED",
				T = "SEARCH__SEARCH_FAILED",
				D = Object(c.a)(v),
				C = Object(c.a)(S),
				w = Object(c.a)(T),
				A = e => s.fbt._("reddit.com: search results - {query}", [s.fbt._param("query", e || "None")], {
					hk: "1XOKAg"
				}),
				R = (e, t, n, r) => async (o, c, i) => {
					let {
						apiContext: d
					} = i;
					const f = c(),
						v = t[g.b],
						S = t.category;
					(v || S) && (await Promise.all([o(p.g()), o(l.h())]), S && await Promise.all([o(l.i(S, 10)), o(p.h(j.g, S))]));
					const {
						q: T
					} = t, A = !!T && a.zb.some(e => T.includes("".concat(e, ":")));
					let P = t.type.indexOf(a.Kb.Posts) > -1 || !(!n || !t.restrict_sr) || A;
					if (P) {
						const t = f.listings.postOrder.ids[e],
							n = f.listings.postOrder.api.error[e];
						P = !(f.listings.postOrder.api.pending[e] || t && !n)
					}
					let k = t.type.indexOf(a.Kb.Subreddits) > -1 || t.type.indexOf(a.Kb.Users) > -1;
					if (k) {
						const t = f.listings.listingOrder.identifiers[e],
							n = f.listings.listingOrder.api.error[e];
						k = !(f.listings.listingOrder.api.pending[e] || t && !n)
					}
					if (!P && !k) return void(f.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						o(Object(u.b)(E.a.SEARCH_RESULTS))
					}));
					t.q && o(Object(m.h)(t.q));
					const x = "error-".concat(e),
						{
							type: N
						} = t;
					o(D({
						key: e,
						type: N
					}));
					const L = await Object(y.a)("searchResults", () => Object(_.a)(d(), n, r, Object.assign({}, t, {
						type: (t.type || []).join(","),
						b: !A
					})));
					if (L.ok) {
						const s = {
								key: e,
								type: N,
								meta: f.meta,
								searchQuery: t.q,
								subredditName: n,
								username: r
							},
							a = L.body;
						if (o(C(Object.assign({
								categoryName: v
							}, s, a))), o(O.f(x)), o(Object(u.b)(E.a.SEARCH_RESULTS)), n) {
							const e = Object(I.E)(c(), n),
								t = Object(b.c)(a.posts, e),
								s = Object(b.b)(a.structuredStyles || {}),
								r = (s ? Object(b.d)(s) : []).concat(t);
							o(Object(b.a)(r, e))
						}
					} else o(w(Object.assign({
						key: e,
						error: L.error,
						type: N
					}, L.body))), o(O.e({
						id: x,
						kind: h.b.Error,
						text: s.fbt._("Sorry, we couldn't load search results.", null, {
							hk: "QgweL"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "jld4g"
						}),
						buttonAction: R(e, t, n, r)
					}))
				}, P = e => async (t, n, s) => {
					const r = Object(i.c)(o()(e.queryParams, g.q)),
						c = e.params.subredditName || e.params.multiredditName,
						{
							username: u
						} = e.params,
						l = Object(i.b)(c, u, r);
					await t(R(l, r, c, u));
					const b = n();
					let p = !1;
					const {
						type: m = []
					} = r, O = m.indexOf(a.Kb.Posts) > -1, _ = m.indexOf(a.Kb.Subreddits) > -1 || m.indexOf(a.Kb.Users) > -1;
					O && b.listings.postOrder.api.error[l] && (p = !0), _ && b.listings.listingOrder.api.error[l] && (p = !0), t(p ? f.l({
						title: Object(d.c)()
					}) : f.l({
						title: A(r.q)
					}))
				}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return de
			})), n.d(t, "d", (function() {
				return ue
			})), n.d(t, "c", (function() {
				return le
			})), n.d(t, "a", (function() {
				return be
			})), n.d(t, "k", (function() {
				return pe
			})), n.d(t, "i", (function() {
				return Oe
			})), n.d(t, "e", (function() {
				return _e
			})), n.d(t, "g", (function() {
				return ye
			})), n.d(t, "h", (function() {
				return je
			})), n.d(t, "l", (function() {
				return he
			})), n.d(t, "b", (function() {
				return Ee
			})), n.d(t, "j", (function() {
				return Ie
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/some.js"),
				c = n.n(a),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/isAdHocMultireddit/index.ts"),
				u = n("./src/lib/isFakeSubreddit/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/makeListingKey/index.ts"),
				f = n("./src/lib/makeSearchKey/index.ts"),
				m = n("./src/reddit/actions/ads/index.ts"),
				O = n("./src/reddit/actions/communityFlairs/index.ts"),
				g = n("./src/reddit/actions/contentGate.ts"),
				_ = n("./src/reddit/actions/discoveryUnit.ts"),
				y = n("./src/reddit/actions/economics/helpers/async.ts"),
				j = n("./src/reddit/actions/externalAccount.ts"),
				h = n("./src/reddit/actions/pages/search.ts"),
				E = n("./src/reddit/actions/platform.ts"),
				I = n("./src/reddit/actions/seo/linksModule.ts"),
				v = n("./src/reddit/actions/structuredStyles/index.ts"),
				S = n("./src/reddit/actions/subreddit.ts"),
				T = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/react-router-redux/es/index.js")),
				D = n("./src/reddit/actions/toaster.ts"),
				C = n("./src/reddit/helpers/localStorage/index.ts"),
				w = n("./src/reddit/models/Subreddit/index.ts"),
				A = n("./src/reddit/models/Toast/index.ts"),
				R = n("./src/reddit/routes/postCreation/constants.ts"),
				P = n("./src/reddit/selectors/moderatorPermissions.ts"),
				k = n("./src/reddit/selectors/platform.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				N = n("./src/reddit/selectors/user.ts"),
				L = n("./src/reddit/selectors/widgets.ts");
			const U = () => async (e, t, n) => {
				const s = t(),
					r = Object(k.f)(s);
				if (!r || r.type !== w.c.Public) return;
				const o = r.name,
					a = Object(k.l)(s),
					c = Object(x.w)(s, {
						subredditName: o
					});
				if (!c) return;
				const {
					activity7Day: i
				} = c, d = !!i && i >= 51 && i <= 100, l = !o || Object(u.a)(o), b = a && a.urlParams.subredditName === o, p = Object(N.H)(s), f = Object(P.g)(s, {
					subredditId: Object(x.E)(s, o)
				});
				if (l || b || Object(C.o)() || !d || !p || f) return;
				const m = Object(L.d)(t(), {
					subredditName: o
				});
				if (!m || !m.currentlyViewingCount) return;
				const O = (24 * m.currentlyViewingCount * 7).toString(),
					g = O[0].padEnd(O.length, "0");
				e(Object(D.e)({
					buttonAction: async () => e(Object(T.b)("/r/".concat(o).concat(R.b))),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: A.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(C.P)(),
					secondButtonText: "Dismiss",
					text: "There have been over ".concat(g, " visits to r/").concat(o, " in the past week. Create a new post and start the next conversation.")
				}))
			};
			var M = n("./src/reddit/actions/subredditSettings.ts"),
				F = n("./src/reddit/actions/tags/index.ts"),
				G = n("./src/reddit/constants/page.ts"),
				B = n("./src/reddit/constants/parameters.ts"),
				q = n("./src/reddit/constants/postLayout.ts"),
				V = n("./src/reddit/contexts/PageLayer/index.tsx"),
				K = n("./src/reddit/endpoints/governance/posts.ts"),
				H = n("./src/reddit/endpoints/page/subredditPage.ts"),
				W = n("./src/reddit/endpoints/profile/info.ts"),
				Y = n("./src/reddit/helpers/canonicalUrls.ts"),
				Q = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				z = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				J = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				X = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				Z = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				$ = n("./src/reddit/models/RichTextJson/index.ts"),
				ee = n("./src/reddit/models/User/index.ts"),
				te = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				ne = n("./src/reddit/selectors/communityFlairs.ts"),
				se = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				re = n("./src/reddit/selectors/experiments/subredditSeo.ts"),
				oe = n("./src/reddit/selectors/experiments/topPosts.ts"),
				ae = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				ce = n("./src/reddit/selectors/multireddit.ts"),
				ie = (n("./src/reddit/selectors/posts.ts"), n("./src/reddit/actions/publicAccessNetwork/api.ts"));
			const de = (e, t) => async n => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: s,
							reason: r
						}
					} = e, o = s ? s.account : void 0, a = s && s.features || void 0, c = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (r === b.a.NotFoundSubreddit) n(g.o({
							account: o,
							features: a,
							subredditName: c
						}));
						else if (r === b.a.BannedSubreddit) {
						const e = s ? s.banMessage || s.ban_message : void 0;
						n(g.m({
							banMessage: e,
							account: o,
							features: a,
							subredditName: c
						}))
					}
					if (451 === e.status && n(g.n({
							account: o,
							features: a,
							subredditName: c
						})), 403 === e.status)
						if (r === b.a.GoldSubreddit) n(g.q({
							account: o,
							features: a,
							subredditName: c
						}));
						else if (r === b.a.PrivateSubreddit) n(g.r({
						account: o,
						features: a,
						subredditDescription: s.description || "",
						subredditName: c
					}));
					else if (r === b.a.QuarantinedSubreddit) {
						const e = !s || void 0 === s.quarantineRequiresEmailOptin || s.quarantineRequiresEmailOptin;
						n(g.t({
							account: o,
							features: a,
							subredditName: c,
							quarantineRequiresEmail: e,
							quarantineMessage: s.quarantineMessage,
							quarantineMessageHtml: s.quarantineMessageHtml || "",
							quarantineMessageRTJson: s.quarantineMessageRTJson || $.i
						}))
					}
				}
			}, ue = "PAGE__SUBREDDIT_PENDING", le = "PAGE__SUBREDDIT_LOADED", be = "PAGE__SUBREDDIT_FAILED", pe = Object(l.a)(ue), fe = Object(l.a)(le), me = Object(l.a)(be), Oe = (e, t, n, r) => async (o, a, d) => {
				const l = a(),
					b = Object(N.H)(l),
					p = l.listings.postOrder.api.pending[e],
					f = Object(N.i)(l);
				if (p) return;
				const g = t !== G.c.All && t !== G.c.Popular || !l.posts.recent.length ? n : Object.assign({}, n, {
					recentPostIds: l.posts.recent
				});
				g.layout = q.e[Object(V.N)(l, {})], o(pe({
					key: e
				}));
				const _ = Object(se.b)(l) ? () => Object(H.b)(d.gqlContext(), Object(H.c)(l, t, g), b) : () => Object(H.a)(d.apiContext(), t, g),
					h = b && f && !Object(se.b)(l) ? Object(W.b)(d.gqlContext(), Object(ee.e)(f)) : null,
					[v, T] = await Promise.all([Object(J.a)("subreddit", _), h]),
					C = v.body;
				o(E.m(v.status));
				const w = "error-".concat(e),
					R = Object(u.a)(t) || c()(C.subreddits, e => e.name.toLowerCase() === t.toLowerCase());
				if (v.ok && R) {
					let n;
					const s = C.postIds.filter(e => !!C.posts[e].isMeta);
					if (s.length) {
						const e = Object.keys(C.subreddits).reduce((e, n) => {
							const s = C.subreddits[n];
							return s.name.toLowerCase() === t.toLowerCase() ? s.id : e
						}, null);
						if (e) {
							const t = await Object(K.a)(d.apiContext(), e, s);
							t.ok && (n = t.body)
						}
					}
					if (T && T.ok) {
						const e = T.body.data.redditorInfoByName.karma,
							t = {
								awardeeKarma: e.fromAwardsReceived,
								awarderKarma: e.fromAwardsGiven,
								commentKarma: e.fromComments,
								postKarma: e.fromPosts,
								totalKarma: e.total
							};
						C.account && Object.assign(C.account, t)
					}
					if (o(fe(Object.assign({
							key: e,
							meta: l.meta,
							governance: n
						}, C, {
							postIds: C.postIds
						}))), !Object(u.a)(t)) {
						const e = Object(x.E)(a(), t);
						!!Object(x.P)(l, {
							subredditId: e
						}) || await S.o(t)(o, a, d);
						const n = Object(O.c)(C.posts, e),
							s = Object(O.b)(C.structuredStyles),
							r = (s ? Object(O.d)(s) : []).concat(n);
						o(Object(O.a)(r, e))
					}
					r && o(D.f(w)), o(Object(m.b)(te.a.SUBREDDIT)), o(Object(j.p)());
					const c = Object(x.E)(a(), t);
					if (c) {
						const e = [o(Object(y.a)({
							subredditId: c,
							postIds: C.postIds,
							skip: ["subscription"]
						}))];
						Object(re.b)(a(), {
							subredditId: c
						}) && e.push(o(Object(I.d)(c))), Object(ae.a)(a(), {
							subredditId: c
						}) && e.push(o(Object(M.f)(t, c)), o(Object(F.k)(c, X.a.idCard))), await Promise.all(e)
					}
				} else {
					if (403 === v.status || 404 === v.status || 451 === v.status) return void o(de(v, t));
					o(me(Object.assign({
						error: !v.ok && v.error || {
							type: i.C.NOT_FOUND_ERROR
						},
						key: e
					}, C))), r && o(D.e({
						id: w,
						kind: A.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: Oe(e, t, n, r)
					}))
				}
			}, ge = (e, t) => {
				if (Object(u.a)(t)) {
					if (Object(d.a)(t)) {
						return Object(ce.a)(e, {
							listingName: t
						}).displayText
					}
					switch (t.toLowerCase()) {
						case G.c.Popular:
							return "r/popular";
						case G.c.All:
							return "r/all"
					}
				}
				return Object(x.T)(e, {
					subredditName: t
				})
			}, _e = (e, t) => {
				const n = e.f;
				if (n) return {
					[B.o]: n,
					[B.p]: "1",
					[B.h]: t ? "1" : "",
					sort: i.Ib.New
				}
			}, ye = (e, t) => {
				const n = _e(e, t);
				return n && Object(f.c)(n)
			}, je = (e, t, n, s) => s ? Object(f.b)(e, void 0, s) : Object(p.a)(e, t, n), he = (e, t) => async (n, s, r) => {
				const {
					subredditName: a
				} = e.params, {
					styling: c
				} = e.queryParams, d = s(), l = Object(Q.a)(e.params, d), b = ye(e.queryParams, Object(N.V)(d)), f = je(a, l, e.queryParams, b), g = l, y = d.listings.postOrder.api.error[f], I = d.listings.postOrder.api.pending[f];
				let S = !!d.listings.postOrder.ids[f];
				const T = d.listings.postOrder.listingSort[f];
				T && T.hasChanged && (S = !1);
				let D = Object(x.E)(d, a);
				const C = (e, t) => "true" === c && ((e, t) => Object(P.a)(Z.c.config)(e, {
						subredditId: t
					}) || Object(P.a)(Z.c.flair)(e, {
						subredditId: t
					}))(e, t),
					w = B.t in e.queryParams && e.queryParams[B.t].toUpperCase() || "",
					A = w in i.Pb && i.Pb[w];
				if (I || S && !y && !t) {
					if (C(d, D) && n(v.i(D)), S) {
						const t = ge(s(), a);
						n(E.l({
							title: t
						})), Object(Y.e)(s(), n, e), window.addEventListener("load", () => {
							n(Object(j.p)())
						}), d.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							n(Object(m.b)(te.a.SUBREDDIT))
						}), n(U())
					}
					return
				}
				n(_.g());
				const R = n(Object(ie.c)("r/".concat(a)));
				if (b) await n(Object(h.d)(f, b, a));
				else {
					const t = Object.assign({}, o()(e.queryParams, [...B.k, ...B.j, B.g]), {
							sort: g,
							t: Object(z.a)(g, A)
						}),
						s = d.user.prefs.geopopular || d.meta.country;
					!t[B.g] && s && (t[B.g] = s), await n(Oe(f, a, t, !0))
				}
				const k = d.platform.currentPage,
					L = Object(oe.d)(d, {
						pageLayer: k
					});
				if (Object(oe.a)(L) || Object(oe.b)(L) || Object(oe.c)(L)) {
					const e = Object(p.a)(a, i.M.TOP, {
							t: i.Pb.WEEK
						}),
						t = {
							sort: i.M.TOP,
							t: i.Pb.WEEK
						};
					await n(Oe(e, a, t, !1))
				}
				D = D || Object(x.E)(s(), a), Object(ne.a)(d, D) || Object(u.a)(a) || await n(Object(O.e)(a)), C(s(), D) && n(v.i(D)), Object(Y.e)(s(), n, e);
				const M = ge(s(), a);
				n(E.l({
					title: M
				})), n(U()), await R
			}, Ee = "PAGE__SUBREDDIT_INVALIDATE_LISTING", Ie = Object(l.a)(Ee)
		},
		"./src/reddit/actions/pages/subredditWiki/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_PENDING",
				r = "PAGE__SUBREDDIT_WIKI_PAGE_LOADED",
				o = "PAGE__SUBREDDIT_WIKI_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/topic.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "j", (function() {
				return I
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "g", (function() {
				return R
			})), n.d(t, "k", (function() {
				return P
			})), n.d(t, "h", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makeListingKey/index.ts"),
				o = n("./src/reddit/actions/platform.ts"),
				a = n("./src/reddit/constants/listings.ts"),
				c = n("./src/graphql/operations/TopicBySlug.json"),
				i = n("./src/lib/makeGqlRequest/index.ts");
			var d = n("./src/reddit/helpers/canonicalUrls.ts"),
				u = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				m = n("./src/reddit/models/Post/index.ts"),
				O = n("./src/reddit/selectors/listings.ts"),
				g = n("./src/reddit/selectors/topic.ts"),
				_ = n("./src/reddit/selectors/user.ts");
			const y = "TOPIC_PAGE__DATA_PENDING",
				j = "TOPIC_PAGE__DATA_LOADED",
				h = "TOPIC_PAGE__DATA_FAILED",
				E = Object(s.a)(y),
				I = Object(s.a)(j),
				v = Object(s.a)(h),
				S = "TOPIC_PAGE__MORE_POSTS_PENDING",
				T = "TOPIC_PAGE__MORE_POSTS_LOADED",
				D = "TOPIC_PAGE__MORE_POSTS_FAILED",
				C = Object(s.a)(S),
				w = Object(s.a)(T),
				A = Object(s.a)(D),
				R = async (e, t, n) => {
					const s = await ((e, t) => Object(i.a)(e, Object.assign({}, c, {
						variables: t
					})))(e, Object.assign({
						firstPosts: 20,
						firstSubreddits: 30,
						includeIdentity: !1,
						includePosts: !0,
						includeSubreddits: !0,
						includeTopic: !0,
						topicSlug: t
					}, n));
					if (!s.ok) throw s;
					return (e => {
						const t = {},
							n = [],
							s = {},
							r = {};
						if (!e.topicBySlug) return;
						const o = e.topicBySlug.posts && e.topicBySlug.posts.edges || [];
						for (const l of o) {
							const e = l && l.node;
							if (e && (n.push(e.id), t[e.id] = Object(u.d)(e), e.__typename === m.f.SubredditPost && e.subreddit && e.subreddit.id)) {
								const {
									subreddit: t
								} = e;
								s[t.id] = Object(p.a)(t)
							}
						}
						const a = [],
							c = e.topicBySlug.subreddits && e.topicBySlug.subreddits.edges || [];
						for (const u of c) {
							const e = u && u.node;
							if (e && e.id) {
								s[e.id] = Object(p.a)(e);
								const t = Object(b.a)(e)[e.id];
								t && (r[e.id] = t, a.push(e.id))
							}
						}
						const i = {
								hasPosts: !!Object.keys(t).length,
								hasSubreddits: !!a.length,
								id: e.topicBySlug.id,
								name: e.topicBySlug.name,
								namePlural: e.topicBySlug.namePlural,
								slug: e.topicBySlug.slug,
								subredditIds: a
							},
							d = i.id ? {
								[i.id]: i
							} : void 0,
							O = e.topicBySlug.posts && e.topicBySlug.posts.pageInfo,
							g = O && O.hasNextPage ? O.endCursor : void 0;
						let _, y;
						return e.identity && (_ = Object(f.a)(e.identity), y = Object(l.a)(e.identity.preferences, e.identity.interactions)), {
							account: _,
							preferences: y,
							postIds: n,
							posts: t,
							subredditAboutInfo: r,
							subreddits: s,
							token: g,
							topics: d
						}
					})(s.body.data)
				}, P = (e, t) => async (n, s, c) => {
					let {
						gqlContext: i
					} = c;
					const u = s();
					if (Object(d.f)(u, n, e)) return;
					const l = e.params.topicSlug,
						b = Object(r.a)(a.b.Topic, null, Object.assign({}, e.params, {
							topicSlug: l
						})),
						p = Object(O.c)(u, {
							listingKey: b
						}),
						f = Object(O.d)(u, {
							listingKey: b
						}),
						m = !!u.listings.postOrder.ids[b];
					if (f || m && !p && !t) {
						if (m) {
							const e = Object(g.d)(s(), {
								topicSlug: l
							});
							e && n(o.l({
								title: e
							}))
						}
						return
					}
					let y;
					n(E({
						key: b
					}));
					try {
						y = await R(i(), l, {
							includeIdentity: Object(_.O)(u) && !u.user.account
						})
					} catch (h) {
						const e = h.error;
						if (!(e.fields && e.fields.some(e => "Topic not found" === e.msg))) throw n(v({
							key: b,
							error: e
						})), n(o.m(h.status || 500)), new Error("Topic page fetching failed: upstream service error")
					}
					if (!y || !(e => !!(e && e.topics && Object.keys(e.topics).length > 0 && (Object.keys(e.posts).length > 0 || Object.keys(e.subreddits).length > 0)))(y)) return void n(o.m(404));
					n(I(Object.assign({}, y, {
						key: b,
						meta: u.meta
					})));
					const j = Object(g.d)(s(), {
						topicSlug: l
					});
					j && n(o.l({
						title: j
					}))
				}, k = e => async (t, n, s) => {
					let {
						gqlContext: o
					} = s;
					const c = n(),
						i = e.topicSlug,
						d = Object(r.a)(a.b.Topic, null, e),
						u = Object(O.g)(c, {
							listingKey: d
						});
					if (!u) return;
					const l = Object(O.d)(c, {
							listingKey: d
						}),
						b = Object(O.e)(c, {
							listingKey: d,
							token: u.token
						});
					if (l || b) return;
					let p;
					t(C({
						key: d
					}));
					try {
						p = await R(o(), i, {
							afterPosts: u.token,
							includeSubreddits: !1,
							includeTopic: !1
						})
					} catch (f) {
						return void t(A({
							key: d,
							error: f
						}))
					}
					p && t(w(Object.assign({}, p, {
						key: d,
						fetchedToken: u.token,
						meta: c.meta
					})))
				}
		},
		"./src/reddit/actions/pages/userDataRequest/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return O
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/me/index.ts"),
				o = n("./src/graphql/operations/UserDataExportEligibility.json"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				i = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/selectors/userDataRequest.ts");
			const u = "USER_DATA_REQUEST_PAGE_LOADING",
				l = "USER_DATA_REQUEST_PAGE_LOADED",
				b = "USER_DATA_REQUEST_PAGE_FAILED",
				p = Object(s.a)(u),
				f = Object(s.a)(l),
				m = Object(s.a)(b),
				O = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: u
					} = n;
					const l = t(),
						b = Object(i.i)(l),
						O = Object(d.b)(l);
					if (b && O.success) return;
					e(p());
					const g = await Object(r.a)(s());
					if (!g.ok || !g.body) return void e(m(g.error));
					if (!g.body.account) return void Object(c.a)(e, l);
					const _ = await (e => Object(a.a)(e, Object.assign({}, o)))(u());
					if (!_.ok) return void e(m());
					const y = g.body,
						j = _.body;
					e(f({
						account: y.account,
						userDataExportEligibility: j.data.identity.userDataExportEligibility.isUserEligibleForDataExport
					}))
				}
		},
		"./src/reddit/actions/pinnedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "i", (function() {
				return P
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/constants/modals.ts"),
				d = n("./src/reddit/endpoints/post/index.tsx"),
				u = n("./src/reddit/models/Toast/index.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/profile.ts");
			const p = "PINNEDPOST__PINNED_POSTS_LOADED",
				f = Object(o.a)(p),
				m = "PINNEDPOST__PIN_POST_SUCCESS",
				O = "PINNEDPOST__UNPIN_POST_SUCCESS",
				g = Object(o.a)(m),
				_ = Object(o.a)(O),
				y = "PINNEDPOST__PIN_POST_PENDING",
				j = "PINNEDPOST__UNPIN_POST_PENDING",
				h = Object(o.a)(y),
				E = Object(o.a)(j),
				I = "PINNEDPOST__PIN_POST_FAILURE",
				v = "PINNEDPOST__UNPIN_POST_FAILURE",
				S = Object(o.a)(I),
				T = Object(o.a)(v),
				D = e => Object(c.e)({
					buttonAction: P(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "1O9LWh"
					}),
					kind: u.b.SuccessMod,
					text: s.fbt._("Post pinned to profile!", null, {
						hk: "1hbHLt"
					})
				}),
				C = (e, t) => Object(c.e)({
					buttonAction: P(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "3YtcK2"
					}),
					kind: u.b.SuccessMod,
					text: t ? s.fbt._("Post unpinned, reload to see changes", null, {
						hk: "5FF1g"
					}) : s.fbt._("Post unpinned.", null, {
						hk: "2BgT0h"
					})
				}),
				w = () => Object(c.e)({
					kind: u.b.Error,
					text: s.fbt._("Could not pin post", null, {
						hk: "3uNHEh"
					})
				}),
				A = () => Object(c.e)({
					kind: u.b.Error,
					text: s.fbt._("You can't pin a removed post", null, {
						hk: "3bdn2y"
					})
				}),
				R = () => Object(c.e)({
					kind: u.b.Error,
					text: s.fbt._("Could not unpin post", null, {
						hk: "o8HG0"
					})
				}),
				P = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s, o) => {
						let {
							apiContext: c
						} = o;
						const u = s(),
							p = u.posts.models[e];
						if (!p) return;
						const f = !Object(l.w)(u, {
							postId: e
						});
						if (f && p.isRemoved) return n(A());
						const m = p.author,
							O = Object(b.m)(u, m),
							[y, j, I, v, P] = f ? [h, g, S, D, w] : [E, _, T, C, R];
						if (f) {
							if (Object(l.W)(u, {
									profileName: m
								}).length >= r.T) return void n(Object(a.i)(i.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const k = Object(l.q)(u, e, m),
							x = !f && k;
						n(y({
							postId: e,
							profileId: O
						})), (await Object(d.s)(c(), e, f, !0)).ok ? (n(j({
							postId: e,
							profileId: O
						})), t || n(v(e, x))) : (n(I({
							postId: e,
							profileId: O
						})), n(P()))
					}
				}
		},
		"./src/reddit/actions/platform.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "i", (function() {
				return I
			})), n.d(t, "m", (function() {
				return T
			})), n.d(t, "l", (function() {
				return D
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "j", (function() {
				return w
			})), n.d(t, "g", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.search.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./src/lib/areUrlsEqual/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/logs/errors.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/matchRoute/index.ts"),
				i = (n("./src/lib/addQueryParams/index.ts"), n("./src/lib/isEqualWithoutKey/index.ts")),
				d = n("./src/reddit/actions/tracing.ts"),
				u = n("./src/reddit/constants/experiments.ts"),
				l = n("./src/reddit/constants/listings.ts"),
				b = n("./src/reddit/helpers/routeKey/index.ts"),
				p = n("./src/reddit/selectors/experiments/postSeo.ts");
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/helpers/chooseVariant/index.ts");
			new Set([r.yb.COMMENTS, r.yb.INDEX, r.yb.LISTING, r.yb.PROFILE_COMMENTS, r.yb.PROFILE_OVERVIEW, r.yb.PROFILE_POSTS, r.yb.SUBREDDIT]);
			var f = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/singleton/tracing/index.ts");
			const O = "PLATFORM__HISTORY_LOCATION_SET",
				g = "PLATFORM__INITIAL_REFERRER_SET",
				_ = "PLATFORM__NAVIGATION_CONFIRMATION_REQUESTED",
				y = "PLATFORM__NAVIGATION_CONFIRMATION_DISCARDED",
				j = "PLATFORM__PAGE_META_SET",
				h = "PLATFORM__PAGE_STATUS_SET",
				E = e => async (t, n, s) => {
					const {
						currentPage: r
					} = n().platform;
					if (!r) return;
					const o = Object(c.a)(r.url, e);
					o && o.route.action(o.match)(t, n, s)
				}, I = (e, t, n) => async (o, a, c) => {
					const O = a().platform.currentPage;
					(!n || n.route.chunk === r.o.SUBREDDIT && l.a.has(n.match.params.subredditName.toLowerCase())) && window.location.replace("https://www.reddit.com".concat(e.pathname).concat(e.search));
					const g = n ? Object(b.c)(n, a()).listingKey : null,
						{
							user: _
						} = a(),
						y = n && n.match && n.match.queryParams,
						j = y && y["experiment_".concat(u.Ab)];
					Object(p.j)(a()), e.pathname.split("/").some(e => "comments" === e), Object(f.h)(a());
					if (o(v({
							action: t,
							listingKey: g,
							location: e,
							routeMatch: n,
							user: _
						})), O && Object(s.a)(O.url, e)) return;
					m.b.isEnabled;
					let h = !1;
					if (m.b.isEnabled) {
						if (O && O.locationState && Object(i.a)(O.locationState.closeLocation, e)) {
							const e = m.b.createRootSpanId();
							m.b.setParent(e), o(Object(d.b)(e.spanId))
						} else h = !0
					}
					if (n) {
						const {
							match: e
						} = n;
						if (h) {
							const t = m.b.createRootSpanId();
							m.b.setParent(t), o(Object(d.b)(t.spanId));
							const s = n && n.route.action.name,
								r = n && n.route ? "".concat(s, "_").concat(n.route.meta.name) : "",
								i = {
									[m.a.HttpUrl]: e.url
								};
							await m.b.recordRequest(r, i, async () => {
								await n.route.action(e)(o, a, c)
							})
						} else await n.route.action(e)(o, a, c)
					}
				}, v = Object(a.a)(O), S = (Object(a.a)(g), Object(a.a)(j)), T = Object(a.a)(h), D = e => async (t, n, s) => {
					const r = n(),
						{
							currentPage: o
						} = r.platform;
					if (!o) return;
					const {
						key: a
					} = o;
					await t(S({
						key: a,
						meta: e
					}))
				}, C = Object(a.a)(_), w = Object(a.a)(y), A = () => async (e, t, n) => {
					if (window !== window.parent) {
						Object(o.b)(n.apiContext(), {
							extra: {
								errorType: r.p.NOT_ALLOWED_ACCESS,
								value: "Page was unexpectedly loaded inside iframe"
							}
						});
						try {
							window.top.location.href = window.location.href
						} catch (s) {}
					}
				}
		},
		"./src/reddit/actions/polls.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "POLLS__POLL_CREATION_UPDATED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/post.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return ee
			})), n.d(t, "e", (function() {
				return te
			})), n.d(t, "k", (function() {
				return ne
			})), n.d(t, "j", (function() {
				return se
			})), n.d(t, "z", (function() {
				return re
			})), n.d(t, "p", (function() {
				return ae
			})), n.d(t, "T", (function() {
				return ie
			})), n.d(t, "h", (function() {
				return de
			})), n.d(t, "g", (function() {
				return ue
			})), n.d(t, "J", (function() {
				return le
			})), n.d(t, "I", (function() {
				return be
			})), n.d(t, "Z", (function() {
				return pe
			})), n.d(t, "V", (function() {
				return fe
			})), n.d(t, "cb", (function() {
				return Oe
			})), n.d(t, "y", (function() {
				return ge
			})), n.d(t, "P", (function() {
				return ye
			})), n.d(t, "Q", (function() {
				return je
			})), n.d(t, "a", (function() {
				return he
			})), n.d(t, "b", (function() {
				return Ee
			})), n.d(t, "q", (function() {
				return Ie
			})), n.d(t, "s", (function() {
				return ve
			})), n.d(t, "r", (function() {
				return Se
			})), n.d(t, "f", (function() {
				return Te
			})), n.d(t, "l", (function() {
				return De
			})), n.d(t, "m", (function() {
				return Ce
			})), n.d(t, "C", (function() {
				return Le
			})), n.d(t, "D", (function() {
				return Ue
			})), n.d(t, "B", (function() {
				return Me
			})), n.d(t, "R", (function() {
				return Fe
			})), n.d(t, "u", (function() {
				return Ge
			})), n.d(t, "U", (function() {
				return Be
			})), n.d(t, "O", (function() {
				return qe
			})), n.d(t, "G", (function() {
				return Ve
			})), n.d(t, "Y", (function() {
				return Ke
			})), n.d(t, "L", (function() {
				return He
			})), n.d(t, "K", (function() {
				return We
			})), n.d(t, "x", (function() {
				return Ye
			})), n.d(t, "ab", (function() {
				return Qe
			})), n.d(t, "bb", (function() {
				return ze
			})), n.d(t, "F", (function() {
				return Xe
			})), n.d(t, "n", (function() {
				return Ze
			})), n.d(t, "v", (function() {
				return et
			})), n.d(t, "t", (function() {
				return tt
			})), n.d(t, "W", (function() {
				return nt
			})), n.d(t, "N", (function() {
				return st
			})), n.d(t, "S", (function() {
				return rt
			})), n.d(t, "E", (function() {
				return ot
			})), n.d(t, "M", (function() {
				return at
			})), n.d(t, "o", (function() {
				return ct
			})), n.d(t, "A", (function() {
				return dt
			})), n.d(t, "X", (function() {
				return ut
			})), n.d(t, "i", (function() {
				return lt
			})), n.d(t, "H", (function() {
				return bt
			})), n.d(t, "c", (function() {
				return pt
			})), n.d(t, "w", (function() {
				return ft
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/js-cookie/src/js.cookie.js"),
				a = n.n(o),
				c = n("./src/lib/addQueryParams/index.ts"),
				i = n("./src/lib/copyToClipboard/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/login.ts"),
				l = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/constants/adEvents.ts"),
				p = n("./src/lib/LRUCache/index.ts"),
				f = n("./node_modules/query-string/index.js"),
				m = n.n(f),
				O = n("./src/lib/sentry/index.ts"),
				g = n("./src/reddit/helpers/getVendorMetadata.ts");
			const _ = new p.a(1e3),
				y = (e, t, n) => {
					const s = e.events,
						r = Object(g.b)(e.id, n);
					return s.filter(e => e.type === t).every(e => ((e, t) => {
						let {
							url: n,
							type: s
						} = e;
						if (!n) return O.c.captureMessage("Pixel of type ".concat(s, " has no url")), !1;
						if (!_.get(n)) {
							const e = /^(http|https):\/\/([a-z]+\.)?reddit.com/.test(n);
							let s;
							if (t && e) {
								const {
									url: e,
									query: r
								} = m.a.parseUrl(n);
								s = m.a.stringifyUrl({
									url: e,
									query: Object.assign({}, r, t)
								})
							}
							const r = new Image;
							return _.set(n, !0), s && (n = s), r.src = n, !0
						}
						return !1
					})(e, r))
				};
			var j = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/actions/unload/constants.ts");
			let E = !1;
			const I = Object(d.a)(h.b),
				v = (e, t, n) => {
					if (window && !E && (window.addEventListener("beforeunload", () => (e => {
							h.a.forEach(t => {
								let {
									post: n
								} = t;
								const s = Object(j.N)(e(), n.id);
								y(n, b.a.Unload, s)
							})
						})(n)), E = !0), h.c.has(e.id)) return;
					h.c.add(e.id);
					const s = {
						post: e,
						unloadTimer: window.setTimeout(() => {
							t(Me(e, b.a.Unload))
						}, h.d)
					};
					if (h.a.push(s), h.a.length > 10) {
						const n = h.a.shift();
						t(I(e.id)), t(Me(n.post, b.a.Unload)), clearTimeout(n.unloadTimer)
					}
				};
			var S = n("./src/reddit/actions/video.ts"),
				T = n("./src/reddit/actions/vote.ts"),
				D = n("./src/reddit/constants/cookie.ts"),
				C = n("./src/reddit/constants/history.ts"),
				w = n("./src/reddit/constants/posts.ts"),
				A = n("./src/reddit/helpers/isPost.ts"),
				R = n("./src/reddit/helpers/overlay/index.ts"),
				P = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				k = n("./src/reddit/models/Media/index.ts"),
				x = n("./src/reddit/endpoints/post/index.tsx"),
				N = n("./src/lib/makeGqlRequest/index.ts"),
				L = n("./src/graphql/operations/RichTextPostContent.json");
			var U = n("./src/lib/constants/index.ts"),
				M = n("./src/lib/makeListingKey/index.ts"),
				F = n("./node_modules/react-router-redux/es/index.js"),
				G = n("./src/reddit/actions/modal.ts"),
				B = n("./src/reddit/actions/toaster.ts"),
				q = n("./src/reddit/constants/modals.ts"),
				V = n("./src/reddit/endpoints/page/commentsPage.ts"),
				K = n("./src/reddit/helpers/trackers/post.ts"),
				H = n("./src/reddit/models/Flair/index.ts"),
				W = n("./src/reddit/models/Toast/index.ts"),
				Y = n("./src/reddit/models/User/index.ts"),
				Q = n("./src/reddit/models/Vote/index.ts"),
				z = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				J = n("./src/reddit/selectors/platform.ts"),
				X = n("./src/reddit/selectors/user.ts"),
				Z = n("./src/reddit/constants/viewabilityEvents.ts"),
				$ = n("./src/telemetry/index.ts");
			const ee = "POST__EXPANDED_TOGGLED",
				te = "POST__FOCUS_CHANGED",
				ne = "POSTS__MUTATED",
				se = "POSTS_LOADED",
				re = Object(d.a)(ee),
				oe = (Object(d.a)(te), Object(d.a)(se)),
				ae = "POST__STICKY_POST_SUCCESS",
				ce = Object(d.a)(ae),
				ie = Object(d.a)(ne),
				de = "POST__MODERATION_PROMPT_OPENED",
				ue = "POST__MODERATION_PROMPT_CLOSED",
				le = Object(d.a)(de),
				be = Object(d.a)(ue),
				pe = (e, t, n, s) => async (o, a, c) => {
					let {
						apiContext: i
					} = c;
					const d = a().posts.models[e];
					if (!d) return;
					if (!Object(X.H)(a())) return o(Object(G.k)({
						actionSource: G.a.Hide,
						redirectUrl: d.permalink
					})), void o(Object(u.h)());
					let l;
					if (o(ie({
							[e]: {
								hidden: t
							}
						})), (l = t ? await Object(x.g)(i(), e) : await Object(x.t)(i(), e)).ok) {
						if (s) {
							const s = t ? r.fbt._("Post hidden successfully.", null, {
									hk: "a4K6a"
								}) : r.fbt._("Post unhidden successfully.", null, {
									hk: "xJgPP"
								}),
								a = Object(B.d)(s, W.b.Undo, r.fbt._("Undo", null, {
									hk: "46OwLP"
								}), pe(e, !t, n, !1));
							o(Object(B.e)(a))
						}
					} else if (o(ie({
							[e]: {
								hidden: !t
							}
						})), s) {
						const e = Object(B.d)(r.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						}), W.b.Error);
						o(Object(B.e)(e))
					}
				}, fe = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = n().posts.models[e];
					if (!a) return;
					if (!Object(X.H)(n())) return t(Object(u.h)()), void t(Object(G.k)({
						actionSource: G.a.Save,
						redirectUrl: a.permalink
					}));
					const c = a.saved ? x.x : x.o;
					if (t(ie({
							[e]: {
								saved: !a.saved
							}
						})), (await c(o(), e)).ok) {
						const n = a.saved ? r.fbt._("Post unsaved successfully", null, {
								hk: "rrnyE"
							}) : r.fbt._("Post saved successfully", null, {
								hk: "3fAuAl"
							}),
							s = Object(B.d)(n, W.b.Undo, r.fbt._("Undo", null, {
								hk: "46OwLP"
							}), fe(e));
						t(Object(B.e)(s))
					} else t(ie({
						[e]: {
							saved: a.saved
						}
					}))
				}, me = (e, t) => t().posts.models[e], Oe = Object(T.b)(me, Q.a.upvoted), ge = Object(T.b)(me, Q.a.downvoted), _e = e => "viewing-".concat(e), ye = (e, t) => async (n, s) => {
					const r = s();
					K.i(r, e, t), $.c.start(_e(e))
				}, je = (e, t, n) => async (r, o) => {
					const a = o(),
						c = _e(e);
					if ($.c.has(c)) {
						const r = $.c.end("viewing-".concat(e));
						!t && r > s.a.telemetry.postConsumedThreshold && K.a(a, e, r, n)
					}
				}, he = "AD__IMPRESSION", Ee = "AD__VIEWABLE_IMPRESSION", Ie = "VENDOR_FULLY_IN_VIEW", ve = "VENDOR_FULLY_IN_VIEW_5_SECS", Se = "VENDOR_FULLY_IN_VIEW_15_SECS", Te = "GROUPM_VIEWABLE", De = "POST_ENTERED_THRESHOLDS", Ce = "POST_EXITED_THRESHOLDS", we = {
					[Z.a.VendorFullyViewable]: Ie,
					[Z.a.VendorFullyViewableSeconds5]: ve,
					[Z.a.VendorFullyViewableSeconds15]: Se
				}, Ae = Object(d.a)(Te), Re = Object(d.a)(he), Pe = Object(d.a)(Ee), ke = Object(d.a)(De), xe = Object(d.a)(Ce), Ne = Object(d.b)(we), Le = (e, t) => async (n, s) => {
					const r = Object(g.a)(t);
					e.isSponsored && n(ke({
						postId: e.id,
						thresholds: r
					}))
				}, Ue = (e, t) => async n => {
					const s = Object(g.a)(t);
					e.isSponsored && n(xe({
						postId: e.id,
						thresholds: s
					}))
				}, Me = (e, t) => async (n, s) => {
					const r = Object(j.N)(s(), e.id);
					y(e, t, r)
				}, Fe = (e, t) => async (n, s) => {
					const r = e.media && "video" === e.media.type,
						o = [Z.a.VendorFullyViewable, Z.a.VendorFullyViewableSeconds5, Z.a.VendorFullyViewableSeconds15];
					if (r && t === Z.a.VideoViewable) n(Object(S.F)(e.id));
					else if (r && t === Z.a.VideoFullyViewable) n(Object(S.C)(e.id));
					else if (r && t === Z.a.MRCVideoViewableImpression) n(Object(S.B)(e.id));
					else if (r && t === Z.a.VideoGroupMViewable) n(Object(S.D)(e.id));
					else if (r && t === Z.a.VideoVendorFullyViewable50) n(Object(S.E)(e.id));
					else if (e.isSponsored)
						if (o.includes(t)) n(((e, t) => async n => {
							n(Me(e, t)), n(Ne(t, {
								postId: e.id
							}))
						})(e, t));
						else {
							if (t !== Z.a.GroupMViewable) return t === Z.a.Impression ? (n((e => async (t, n) => {
								e.isSponsored && (t(Re({
									postId: e.id
								})), t(Me(e, b.a.Impression)), v(e, t, n))
							})(e)), void(e.isBlank || K.h(s(), e.postId))) : void n((e => async t => {
								e.isSponsored && (t(Me(e, b.a.ViewableImpression)), t(Pe({
									postId: e.id
								})))
							})(e));
							n(((e, t) => async n => {
								n(Me(e, t)), n(Ae({
									postId: e.id
								}))
							})(e, t))
						}
				}, Ge = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = o.posts.models[e],
						c = o.user.account ? o.user.account.displayText : null;
					a && (t(ie({
						[e]: {
							approvedBy: c,
							bannedBy: null,
							isApproved: !0,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							numReports: 0,
							modRemovalReason: null,
							modReasonBy: null
						}
					})), (await Object(x.b)(r(), e)).ok || t(ie({
						[e]: {
							approvedBy: null,
							bannedBy: a.bannedBy,
							isApproved: a.isApproved,
							isRemoved: a.isRemoved,
							isSpam: a.isSpam,
							modNote: a.modNote,
							numReports: a.numReports || null,
							modRemovalReason: a.modRemovalReason,
							modReasonBy: a.modReasonBy
						}
					})))
				}, Be = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = a.posts.models[e],
						i = a.user.account ? a.user.account.displayText : null;
					c && i && (n(ie({
						[e]: {
							approvedBy: null,
							bannedBy: i,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (await Object(x.l)(o(), e, t)).ok || n(ie({
						[e]: {
							approvedBy: c.approvedBy,
							bannedBy: c.bannedBy,
							isApproved: c.isApproved,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam
						}
					})))
				}, qe = (e, t, n) => async (s, o, a) => {
					let {
						apiContext: c
					} = a;
					const i = o();
					if (i.posts.models[e])
						if (s(ie({
								[e]: {
									hidden: !0
								}
							})), (await Object(x.c)(c(), e)).ok) {
							const e = Object(B.d)(r.fbt._("Post deleted successfully.", null, {
								hk: "1sQ4Xf"
							}), W.b.SuccessMod);
							if (n) s(Object(F.b)(t.state[C.a.CloseLocation]));
							else {
								const e = Object(J.f)(i);
								e && s(Object(F.b)(e.url))
							}
							s(Object(B.e)(e))
						} else {
							s(ie({
								[e]: {
									hidden: !1
								}
							}));
							const t = Object(B.d)(r.fbt._("Something went wrong", null, {
								hk: "22u7ha"
							}), W.b.Error);
							s(Object(B.e)(t))
						}
				}, Ve = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().posts.models[e];
					if (!o) return;
					const a = o.isLocked ? x.v : x.i;
					t(ie({
						[e]: {
							isLocked: !o.isLocked
						}
					})), (await a(r(), e)).ok || t(ie({
						[e]: {
							isLocked: o.isLocked
						}
					}))
				}, Ke = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().posts.models[e];
					if (!o) return;
					const a = o.isSpoiler ? x.y : x.r,
						c = o.isSpoiler ? o.flair.filter(e => e.type !== H.f.Spoiler) : [...o.flair, {
							text: "spoiler",
							type: H.f.Spoiler
						}];
					t(ie({
						[e]: {
							isSpoiler: !o.isSpoiler,
							flair: c
						}
					})), (await a(r(), e)).ok || t(ie({
						[e]: {
							isSpoiler: o.isSpoiler,
							flair: o.flair
						}
					}))
				}, He = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = Object(j.O)(n(), {
						postId: e
					});
					o && (t(ie({
						[e]: {
							isOriginalContent: !o.isOriginalContent
						}
					})), (await Object(x.k)(r(), e, !o.isOriginalContent)).ok || t(ie({
						[e]: {
							isOriginalContent: o.isOriginalContent
						}
					})))
				}, We = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().posts.models[e];
					if (!o) return;
					const a = o.isNSFW ? x.w : x.j,
						c = o.isNSFW ? o.flair.filter(e => e.type !== H.f.Nsfw) : [...o.flair, {
							text: "nsfw",
							type: H.f.Nsfw
						}];
					t(ie({
						[e]: {
							isNSFW: !o.isNSFW,
							flair: c
						}
					})), (await a(r(), e)).ok ? await t(st(e)) : t(ie({
						[e]: {
							isNSFW: o.isNSFW,
							flair: o.flair
						}
					}))
				}, Ye = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().posts.models[e];
					if (!a) return;
					const c = U.g[t];
					n(ie({
						[e]: {
							distinguishType: t
						}
					})), (await Object(x.d)(o(), e, c)).ok || n(ie({
						[e]: {
							distinguishType: a.distinguishType
						}
					}))
				}, Qe = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().posts.models[e];
					if (!o) return;
					const a = o.ignoreReports ? x.u : x.h;
					t(ie({
						[e]: {
							ignoreReports: !o.ignoreReports
						}
					})), (await a(r(), e)).ok || t(ie({
						[e]: {
							ignoreReports: o.ignoreReports
						}
					}))
				}, ze = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = o.posts.models[e];
					if (!a) return;
					const c = !a.isStickied;
					t(ie({
						[e]: {
							isStickied: c
						}
					}));
					const i = o.subredditStickyPosts.data[a.belongsTo.id];
					let d;
					if (c && i && i.length >= 2 && (d = i[1], t(ie({
							[d]: {
								isStickied: !1
							}
						}))), (await Object(x.s)(r(), e, c, !1)).ok) {
						const n = a.belongsTo.id,
							s = Je(e, c, o.subredditStickyPosts.data[a.belongsTo.id]),
							r = o.subreddits.models[n].name,
							i = Object(M.a)(r, U.N, {});
						t(ce({
							newStickiedPostList: s,
							subredditId: n,
							listingKey: i
						}))
					} else t(ie({
						[e]: {
							isStickied: a.isStickied
						}
					})), d && t(ie({
						[d]: {
							isStickied: !0
						}
					}))
				}, Je = (e, t, n) => {
					const s = n ? [...n] : [];
					return t ? (s.length >= 2 && s.splice(1, 1, e), s) : s.filter((function(t) {
						return t !== e
					}))
				}, Xe = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (Object(i.a)(e)) {
						const e = Object(B.d)(r.fbt._("Copied link!", null, {
							hk: "4a4E1x"
						}), W.b.SuccessCommunity);
						t(Object(B.e)(e))
					} else {
						const e = Object(B.d)(r.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						}), W.b.Error);
						t(Object(B.e)(e))
					}
				}, Ze = "PREFERENCES__RECENT_POSTS_UPDATED", $e = Object(d.a)(Ze), et = () => async (e, t) => {
					const n = t();
					if (!n.user.account) return;
					const r = Object(Y.e)(n.user.account);
					a.a.remove("".concat(r).concat(D.g), {
						domain: s.a.cookieDomain
					}), e($e({
						postIds: []
					}))
				}, tt = e => async (t, n) => {
					const r = n();
					if (!r.user.account || !r.user.account.showRecentPosts || r.posts.recent.indexOf(e) > -1) return;
					const o = Object(Y.e)(r.user.account),
						c = r.posts.recent ? r.posts.recent.slice(0) : [];
					c.push(e), c.length > w.c && c.shift(), a.a.set("".concat(o).concat(D.g), "".concat(c.join(",")), {
						domain: s.a.cookieDomain
					}), t($e({
						postIds: c
					}))
				}, nt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = !n().posts.models[e].sendReplies;
					t(ie({
						[e]: {
							sendReplies: o
						}
					})), (await Object(x.p)(r(), e, o)).ok || t(ie({
						[e]: {
							sendReplies: !o
						}
					}))
				}, st = e => async (t, n, s) => {
					if (Object(j.O)(n(), {
							postId: e
						})) return;
					const r = await Object(V.a)(s.apiContext(), e, void 0, {
						limit: 1,
						truncate: 0
					}, Object(z.a)(n()));
					if (t(Object(l.m)(r.status)), r.ok) {
						const e = r.body;
						t(oe(e.posts))
					}
				}, rt = e => async (t, n) => {
					await t(st(e));
					const s = Object(j.O)(n(), {
						postId: e
					});
					s && s.crosspostRootId && await t(st(s.crosspostRootId))
				}, ot = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = n();
					if (!Object(X.H)(a)) return void t(Object(G.i)(q.a.LOGIN_MODAL_ID));
					const c = Object(j.O)(a, {
						postId: e
					});
					if (!c) return;
					const i = c.isFollowed,
						d = a.posts.instances[e] || [],
						u = [e, ...d];
					t(ie(u.reduce((e, t) => Object.assign({}, e, {
						[t]: {
							isFollowed: !i
						}
					}), {}))), (await Object(x.f)(o(), e, !c.isFollowed)).ok ? t(Object(B.e)({
						kind: W.b.SuccessMod,
						text: i ? r.fbt._("Event unfollowed", null, {
							hk: "3tkWMt"
						}) : r.fbt._("Success! You followed this event, that means we’ll remind you when it starts!", null, {
							hk: "4A9cwh"
						})
					})) : (t(ie(u.reduce((e, t) => Object.assign({}, e, {
						[t]: {
							isFollowed: i
						}
					}), {}))), t(Object(B.e)({
						kind: W.b.Error,
						text: r.fbt._("Oops, something went wrong. Try again.", null, {
							hk: "2VQ3RW"
						})
					})))
				}, at = e => {
					let {
						postOrComment: t,
						queryParams: n,
						clickInfo: s
					} = e;
					return async (e, r) => {
						const o = r(),
							a = s && s.hasNewTabModifier;
						let i = t.permalink;
						if (Object(A.b)(t) && t.media && Object(k.B)(t.media)) {
							const {
								id: e,
								type: n
							} = t.belongsTo, s = "subreddit" === n ? o.subreddits.models[e] : null;
							i = s ? Object(P.b)(t.id, s.name) : Object(P.b)(t.id)
						}
						n && (i = Object(c.a)(i, n)), o.user.prefs.openPostInNewTab || a ? window.open(i) : e(Object(R.a)(i))
					}
				}, ct = "RICH_TEXT_POST_CONTENT_LOADED", it = Object(d.a)(ct), dt = e => async (t, n, s) => {
					const o = n(),
						a = Object(j.O)(o, {
							postId: e
						});
					if (!(a && a.media && Object(k.C)(a.media) && a.media.isRichtextPreview)) return;
					const c = await ((e, t) => Object(N.a)(e, Object.assign({}, L, {
						variables: t
					})))(s.gqlContext(), {
						postId: e
					});
					if (c.ok) {
						const {
							data: n
						} = c.body, s = n.post && n.post.content && n.post.content.richtext;
						s && t(it({
							postId: e,
							richtextContent: JSON.parse(s)
						}))
					} else t(Object(B.e)({
						kind: W.b.Error,
						text: r.fbt._("Something went wrong loading this page. Try again?", null, {
							hk: "1GbrKz"
						})
					}))
				}, ut = (e, t) => async (n, s, o) => {
					let {
						apiContext: a
					} = o;
					(await Object(x.q)(a(), e, t)).ok ? n(ie({
						[t]: {
							contestMode: e
						}
					})) : n(Object(B.e)({
						kind: W.b.Error,
						text: r.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, lt = "MOD_TO_MEMBER_SHARE_OPENED", bt = Object(d.a)(lt), pt = "CROWD_CONTROL_OPENED", ft = Object(d.a)(pt)
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "t", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "r", (function() {
				return l
			})), n.d(t, "s", (function() {
				return b
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "q", (function() {
				return h
			})), n.d(t, "o", (function() {
				return E
			}));
			const s = "CREATE_COLLECTION_PENDING",
				r = "CREATE_COLLECTION_SUCCESS",
				o = "CREATE_COLLECTION_FAILED",
				a = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				c = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				i = "ADD_POST_TO_COLLECTION_SUCCESS",
				d = "UPDATE_POST_WITH_COLLECTION_ID",
				u = "DELETE_COLLECTION_SUCCESS",
				l = "UPDATE_COLLECTION_PENDING",
				b = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				f = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				m = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				O = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				g = "REORDER_COLLECTION_PENDING",
				_ = "REORDER_COLLECTION_SUCCESS",
				y = "REORDER_COLLECTION_FAILED",
				j = "UPDATE_COLLECTION_LAYOUT_PENDING",
				h = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				E = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "I", (function() {
				return s
			})), n.d(t, "J", (function() {
				return r
			})), n.d(t, "m", (function() {
				return o
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "z", (function() {
				return c
			})), n.d(t, "F", (function() {
				return i
			})), n.d(t, "G", (function() {
				return d
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "E", (function() {
				return l
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "O", (function() {
				return p
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "B", (function() {
				return m
			})), n.d(t, "t", (function() {
				return O
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "k", (function() {
				return T
			})), n.d(t, "r", (function() {
				return D
			})), n.d(t, "Q", (function() {
				return C
			})), n.d(t, "P", (function() {
				return w
			})), n.d(t, "R", (function() {
				return A
			})), n.d(t, "S", (function() {
				return R
			})), n.d(t, "T", (function() {
				return P
			})), n.d(t, "U", (function() {
				return k
			})), n.d(t, "V", (function() {
				return x
			})), n.d(t, "W", (function() {
				return N
			})), n.d(t, "X", (function() {
				return L
			})), n.d(t, "s", (function() {
				return U
			})), n.d(t, "C", (function() {
				return M
			})), n.d(t, "x", (function() {
				return F
			})), n.d(t, "v", (function() {
				return G
			})), n.d(t, "w", (function() {
				return B
			})), n.d(t, "u", (function() {
				return q
			})), n.d(t, "y", (function() {
				return V
			})), n.d(t, "N", (function() {
				return K
			})), n.d(t, "p", (function() {
				return H
			})), n.d(t, "A", (function() {
				return W
			})), n.d(t, "Y", (function() {
				return Y
			})), n.d(t, "H", (function() {
				return Q
			})), n.d(t, "a", (function() {
				return z
			})), n.d(t, "D", (function() {
				return J
			})), n.d(t, "L", (function() {
				return X
			})), n.d(t, "M", (function() {
				return Z
			})), n.d(t, "K", (function() {
				return $
			}));
			const s = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				r = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				o = "POST_CREATION_EDIT_COMPLETE",
				a = "POST_CREATION_EDIT_FAILED",
				c = "POST_CREATION_PENDING_EDIT",
				i = "POST_CREATION_START_EDITING_POST",
				d = "POST_CREATION_STOP_EDITING_POST",
				u = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				l = "STARTED_CONVERTING_EDITOR_CONTENT",
				b = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				f = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				m = "POST_TITLE_FETCHED",
				O = "INITIALIZE_EDITOR_MODE",
				g = "POST_CREATION__CHANGE_FLAIR",
				_ = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				y = "POST_CREATION__CHANGE_LINK_BODY",
				j = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				h = "POST_CREATION__CHANGE_MEDIA_BODY",
				E = "POST_CREATION__CHANGE_POST_SCHEDULE",
				I = "POST_CREATION__CHANGE_RECAPTCHA",
				v = "POST_CREATION__CHANGE_RTE_STATE",
				S = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				T = "POST_CREATION__CHANGE_TITLE",
				D = "POST_CREATION__GOV_TYPE_CHANGED",
				C = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				w = "POST_CREATION__TOGGLE_IS_CHANGED",
				A = "POST_CREATION__TOGGLE_IS_GOV",
				R = "POST_CREATION__TOGGLE_IS_NSFW",
				P = "POST_CREATION__TOGGLE_IS_OC",
				k = "POST_CREATION__TOGGLE_IS_POLL",
				x = "POST_CREATION__TOGGLE_IS_SPOILER",
				N = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				L = "POST_CREATION__TOGGLE_SEND_REPLIES",
				U = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				M = "POST_CREATION__RESET_FORM",
				F = "POST_CREATION__MODAL_TOGGLED",
				G = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				B = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				q = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				V = "POST_CREATION__PENDING",
				K = "POST_CREATION__SUCCEEDED",
				H = "POST_CREATION__FAILED",
				W = "POST_CREATION__POLL_FAILED",
				Y = "POST_CREATION__VALIDATION_FAILED",
				Q = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				z = "POST_CREATION__CAPTCHA_REQUIRED",
				J = "POST_CREATION__SET_SUBMIT_MODE",
				X = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				Z = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				$ = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED"
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "c", (function() {
				return g
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/post/convert.ts"),
				c = n("./src/reddit/helpers/localStorage/index.ts"),
				i = n("./src/reddit/helpers/trackers/postComposer.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				u = n("./src/reddit/models/RichTextJson/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(r.a)(b.E),
				f = Object(r.a)(b.q),
				m = Object(r.a)(b.O),
				O = (e, t, n) => async (r, c, O) => {
					let {
						apiContext: _
					} = O;
					i.i(c(), t);
					const y = t === d.h.MARKDOWN,
						j = t === d.h.RICH_TEXT,
						h = b.l;
					if (y && Object(u.F)(n)) return r(m({
						editorKey: e,
						editorMode: d.h.MARKDOWN,
						content: ""
					})), void r(g(t));
					if (j && !n) return r(m({
						editorKey: e,
						editorMode: d.h.RICH_TEXT,
						content: u.i
					})), void r(g(t));
					r(p(h));
					const E = await Object(a.a)(_(), t, y ? JSON.stringify(n) : n);
					E.ok ? (r(f(h)), r(m({
						editorKey: e,
						editorMode: t,
						content: E.body.output
					})), r(g(t))) : (r(f(h)), r(Object(o.e)({
						duration: o.a,
						kind: l.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, g = e => async (t, n) => {
					const r = Object(c.h)();
					if (r >= 3) return;
					const a = n().user.prefs.useMarkdown ? d.h.MARKDOWN : d.h.RICH_TEXT;
					if (e === a) return;
					const i = e === d.h.MARKDOWN ? s.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : s.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					t(Object(o.e)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: s.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: l.b.SuccessCommunity,
						text: i
					})), Object(c.J)(r + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return f
			})), n.d(t, "o", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "k", (function() {
				return D
			})), n.d(t, "t", (function() {
				return C
			})), n.d(t, "s", (function() {
				return w
			})), n.d(t, "u", (function() {
				return A
			})), n.d(t, "v", (function() {
				return R
			})), n.d(t, "w", (function() {
				return P
			})), n.d(t, "x", (function() {
				return k
			})), n.d(t, "z", (function() {
				return x
			})), n.d(t, "A", (function() {
				return N
			})), n.d(t, "l", (function() {
				return L
			})), n.d(t, "r", (function() {
				return U
			})), n.d(t, "q", (function() {
				return F
			})), n.d(t, "m", (function() {
				return G
			})), n.d(t, "y", (function() {
				return B
			})), n.d(t, "p", (function() {
				return q
			})), n.d(t, "n", (function() {
				return V
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/isUrl/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				i = n("./src/reddit/endpoints/post/index.tsx"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				u = n("./src/reddit/routes/postCreation/constants.ts"),
				l = n("./src/reddit/selectors/postCollection.ts"),
				b = n("./src/reddit/selectors/postCreations.ts"),
				p = n("./src/reddit/actions/postCreation/constants.ts");
			const f = Object(o.a)(p.o),
				m = Object(o.a)(p.B),
				O = (Object(o.a)(p.t), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				g = Object(o.a)(p.b),
				_ = Object(o.a)(p.c),
				y = Object(o.a)(p.d),
				j = Object(o.a)(p.e),
				h = Object(o.a)(p.f),
				E = Object(o.a)(p.g),
				I = Object(o.a)(p.h),
				v = Object(o.a)(p.i),
				S = Object(o.a)(p.j),
				T = Object(o.a)(p.k),
				D = Object(o.a)(p.r),
				C = Object(o.a)(p.Q),
				w = Object(o.a)(p.P),
				A = (Object(o.a)(p.R), Object(o.a)(p.S)),
				R = Object(o.a)(p.T),
				P = Object(o.a)(p.U),
				k = Object(o.a)(p.V),
				x = Object(o.a)(p.W),
				N = Object(o.a)(p.X),
				L = Object(o.a)(p.s),
				U = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					t(y(e)), Object(r.a)(e) && t((e => async (t, n, s) => {
						let {
							apiContext: r
						} = s;
						const o = await Object(i.e)(r(), e);
						o.ok && o.body && o.body.json && o.body.json.data && t(m(o.body.json.data))
					})(e))
				}, M = Object(o.a)(p.C), F = (e, t) => async (n, r) => {
					n(M()), n(e ? Object(s.b)(u.b) : Object(s.b)(Object(b.R)(r(), {
						pageLayer: t
					})))
				}, G = Object(o.a)(a.c), B = e => async t => {
					e ? e === d.d ? t(G(e)) : t(a.i(e)) : (t(G(e)), t(a.i(e)))
				}, q = e => async (t, n) => {
					const s = n(),
						r = Object(c.D)(e),
						o = Object(b.z)(s);
					if (r && o) {
						Object(b.M)(s) !== d.c && t(B(d.c))
					} else t(F(!1, e))
				}, V = e => async (t, n) => {
					const s = n();
					Object(l.n)(s, {
						subredditId: e
					}) ? t(a.i(d.a)) : t(a.i(d.b))
				}
		},
		"./src/reddit/actions/postCreation/subredditChange.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return E
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/filterQueryParams/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/pages/postCreation.ts"),
				u = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = n("./src/reddit/helpers/name/index.ts"),
				b = n("./src/reddit/models/PostCreationForm/index.ts"),
				p = n("./src/reddit/routes/postCreation/index.ts"),
				f = n("./src/reddit/routes/postCreation/constants.ts"),
				m = n("./src/reddit/selectors/platform.ts"),
				O = n("./src/reddit/selectors/postCreations.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/actions/postCreation/constants.ts"),
				y = n("./src/reddit/actions/postCreation/general.ts");
			const j = Object(c.a)(_.L),
				h = Object(c.a)(_.M),
				E = Object(c.a)(_.K),
				I = (e, t) => async (n, s, r) => {
					let {
						apiContext: a
					} = r, c = s();
					const {
						name: p,
						isProfile: f
					} = e, _ = Object(m.f)(c), y = _ && !f && Object(l.a)(_.name, p), h = c.creations.api.subreddit.change.pending;
					if (y || h) return;
					const E = Object(u.t)(t);
					if (!p) return void n(v(e, E));
					n(j(e));
					const I = f ? {
						profileName: p
					} : {
						subredditName: p
					};
					if (await n(Object(d.d)(I)), f || !Object(O.v)(c)) return n(v(e, E));
					const S = e.allowedPostTypes || Object(g.y)(s(), {
						subredditName: p
					});
					if (!S) return void n(v(e, E));
					let T;
					c = s();
					const D = Object(O.ab)(c),
						C = Object(O.v)(c);
					if (D === o.Gb.MEDIA && C) {
						const {
							mediaType: e,
							video: t
						} = Object(O.K)(c);
						if ("image" !== e || S.images) {
							if ("video" === e && !S.videos) {
								const e = t && t.duration || 0;
								S.images ? e > o.X && (T = b.q.VideoWillBeRemovedTooLongForGif) : T = b.q.VideoWillBeRemovedMediaNotAllowed
							}
						} else T = b.q.ImageWillBeRemoved
					}
					n(T ? Object(i.i)(T) : v(Object.assign({}, e, {
						allowedPostTypes: S
					}), E))
				}, v = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (o, a) => {
						const {
							name: c,
							isProfile: i
						} = e, d = a().platform.currentPage, u = d.queryParams, l = i ? p.b : p.c;
						let b = "";
						b = c ? l(c) : f.b, b = Object(r.a)(b, Object.assign({}, u, {
							draft: t || u.draft
						})), (t || d.url.toLowerCase() !== b.toLowerCase()) && (o(h(e)), n && o(Object(y.s)(!0)), o(Object(y.j)()), o(Object(s.c)(b)))
					}
				}, S = e => async (t, n) => {
					const o = n().platform.currentPage,
						a = o.queryParams,
						c = Object(r.a)(o.url, Object.assign({}, a, {
							collection: e
						}));
					t(Object(s.c)(c))
				}, T = () => async (e, t) => {
					const n = t().platform.currentPage,
						r = Object(a.a)(n.url, ["collection"]);
					e(Object(s.c)(r))
				}
		},
		"./src/reddit/actions/postDraft.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return A
			})), n.d(t, "e", (function() {
				return R
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "p", (function() {
				return L
			})), n.d(t, "j", (function() {
				return U
			})), n.d(t, "l", (function() {
				return M
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "m", (function() {
				return G
			})), n.d(t, "k", (function() {
				return B
			})), n.d(t, "h", (function() {
				return q
			})), n.d(t, "n", (function() {
				return V
			})), n.d(t, "s", (function() {
				return J
			})), n.d(t, "r", (function() {
				return X
			})), n.d(t, "g", (function() {
				return Z
			})), n.d(t, "q", (function() {
				return ee
			})), n.d(t, "c", (function() {
				return te
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "o", (function() {
				return ce
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/postCreation/general.ts"),
				c = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/models/StructuredStyles/index.ts");
			var p = n("./src/reddit/constants/headers.ts"),
				f = n("./src/reddit/helpers/name/index.ts"),
				m = n("./src/reddit/models/PostDraft/index.ts"),
				O = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts"),
				g = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				_ = n("./src/reddit/models/Subreddit/index.ts");
			const y = e => {
				let t = e.drafts.reduce((e, t) => {
					const n = (e => {
						let t;
						return t = "link" === e.kind ? {
							kind: m.b.Link,
							body: e.body || void 0
						} : "markdown" === e.kind ? {
							kind: m.b.Markdown,
							body: e.body || void 0
						} : {
							kind: m.b.RichText,
							body: e.body || void 0
						}, Object.assign({
							subredditId: e.subreddit || void 0,
							contentCategory: e.content_category || void 0,
							created: e.created,
							flair: e.flair,
							id: e.id,
							isChatPost: !!e.discussion_type,
							isNSFW: !!e.nsfw,
							isOriginalContent: !!e.original_content,
							isSpoiler: !!e.spoiler,
							modified: e.modified || void 0,
							sendReplies: !!e.send_replies,
							isPublicLink: !!e.is_public_link,
							title: e.title || ""
						}, t)
					})(t);
					return e.postDraftIds.push(n.id), e.postDrafts[n.id] = n, e
				}, {
					postDraftIds: [],
					postDrafts: {},
					profiles: {},
					subreddits: {}
				});
				return t = e.subreddits.reduce((e, t) => {
					if (t.subreddit_type === _.c.User) {
						const n = Object(O.a)(t, Object(f.f)(t.display_name_prefixed));
						e.profiles[n.id] = n
					} else {
						const n = Object(g.a)(t);
						e.subreddits[n.id] = n
					}
					return e
				}, t)
			};
			var j = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				h = n("./src/reddit/models/PostCreationForm/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				I = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/reddit/models/User/index.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				T = n("./src/reddit/selectors/postDraft.ts"),
				D = n("./src/reddit/selectors/profile.ts"),
				C = n("./src/reddit/selectors/subreddit.ts"),
				w = n("./src/reddit/selectors/user.ts");
			const A = "POST_DRAFT__LIST_PENDING",
				R = "POST_DRAFT__LIST_LOADED",
				P = "POST_DRAFT__LIST_FAILED",
				k = Object(o.a)(A),
				x = Object(o.a)(R),
				N = Object(o.a)(P),
				L = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t();
					if (!Object(w.i)(o) || Object(T.b)(o)) return;
					e(k());
					const a = await (e => Object(u.b)(Object(l.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/drafts.json"),
						method: s.ab.GET
					}))(r());
					a.ok ? e(x(y(a.body))) : e(N(a.error))
				}, U = "POST_DRAFT__SAVE_DRAFT_PENDING", M = "POST_DRAFT__SAVE_DRAFT_SUCCEEDED", F = "POST_DRAFT__SAVE_DRAFT_FAILED", G = "POST_DRAFT__SAVE_DRAFT_VALIDATION_FAILED", B = "POST_DRAFT__SAVE_DRAFT_SUBMIT_VALIDATION_FAILED", q = "POST_DRAFT__SAVE_DRAFT_CAPTCHA_REQUIRED", V = "POST_CREATION__TOGGLE_DRAFT_IS_PUBLIC", K = Object(o.a)(U), H = Object(o.a)(M), W = Object(o.a)(F), Y = Object(o.a)(G), Q = Object(o.a)(B), z = Object(o.a)(q), J = Object(o.a)(V), X = e => async (t, n, o) => {
					let {
						apiContext: a
					} = o;
					const d = n(),
						b = Object(T.g)(d),
						f = Object(S.Q)(d);
					if (b || f) return;
					const m = Object(T.h)(d, e);
					if (!m) return;
					t(K(m)), E.e(d, m);
					const O = await ((e, t, n) => Object(u.b)(Object(l.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/draft"),
						method: n ? s.ab.PUT : s.ab.POST,
						data: Object(j.a)(t)
					}).then(e => e.body.fields && Object(h.v)(e.body.fields[0]) ? Object.assign({}, e, {
						body: {},
						error: {
							type: s.C.SUBMIT_VALIDATION_ERROR,
							fields: [{
								field: e.body.fields[0],
								msg: e.body.explanation
							}]
						}
					}) : e))(a(), m, e);
					if (O.ok) {
						const {
							id: n,
							draftsCount: s
						} = Object(j.c)(O.body);
						t(H({
							draftId: n,
							draftsCount: s
						})), e || t(Object(c.a)(m.destSubreddit, n, !1))
					} else {
						const e = O.error;
						e.type === s.C.BAD_CAPTCHA_ERROR ? t(z()) : e.type === s.C.VALIDATION_ERROR ? t(Y(e)) : e.type === s.C.SUBMIT_VALIDATION_ERROR ? t(Q(e)) : t(W(e));
						const n = Object(w.Q)(d);
						t(Object(i.e)({
							duration: i.a,
							kind: I.b.Error,
							text: Object(r.a)(n, e)
						}))
					}
				}, Z = "POST_DRAFT__LOAD_DRAFT", $ = Object(o.a)(Z), ee = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t($(e));
					let o = h.e;
					const a = n();
					if (e.subredditId) {
						const t = Object(C.Q)(a, {
								subredditId: e.subredditId
							}),
							n = Object(D.p)(a, {
								profileId: e.subredditId
							}),
							s = Object(w.i)(a);
						t ? o = {
							isProfile: !1,
							name: t.name
						} : n && s && (o = {
							isProfile: !0,
							name: Object(v.e)(s)
						})
					}
					await t(Object(c.a)(o, e.id, !1));
					const i = Object(T.h)(n(), e.id);
					i && E.h(n(), i)
				}, te = "POST_DELETE_DRAFT_SUCCEEDED", ne = "POST_DELETE_DRAFT_FAILED", se = "POST_DELETE_DRAFT_PENDING", re = Object(o.a)(te), oe = Object(o.a)(ne), ae = Object(o.a)(se), ce = (e, t) => async (n, o, c) => {
					let {
						apiContext: p
					} = c;
					const f = o();
					if (Object(T.a)(f, e)) return;
					const m = Object(T.d)(f, {
						draftId: e
					});
					m && E.f(f, m), n(ae({
						draftId: e
					}));
					const O = await (async (e, t) => Object(u.b)(Object(l.a)(e, [b.g]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/draft?draft_id=").concat(t),
						method: s.ab.DELETE
					}))(p(), e);
					if (O.ok) {
						const {
							draftsCount: s
						} = Object(j.c)(O.body);
						n(re({
							draftId: e,
							draftsCount: s
						}));
						const r = Object(d.t)(t);
						e === r && n(Object(a.q)(!0, t))
					} else {
						const t = O.error,
							s = Object(w.Q)(o());
						n(oe({
							draftId: e,
							apiError: t
						})), n(Object(i.e)({
							duration: i.a,
							kind: I.b.Error,
							text: Object(r.a)(s, t)
						}))
					}
				}
		},
		"./src/reddit/actions/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "e", (function() {
				return A
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "l", (function() {
				return N
			})), n.d(t, "k", (function() {
				return L
			})), n.d(t, "j", (function() {
				return U
			})), n.d(t, "g", (function() {
				return M
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "h", (function() {
				return G
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				a = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/flair/index.ts"),
				d = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/selectors/postFlair.ts"),
				p = n("./src/reddit/selectors/subreddit.ts");
			const f = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				m = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				O = Object(r.a)(f),
				g = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				_ = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				y = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				j = Object(r.a)(_),
				h = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				E = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				I = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				v = Object(r.a)(E),
				S = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				T = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				D = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				C = Object(r.a)(T),
				w = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				A = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				R = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				P = Object(r.a)(A),
				k = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				x = Object(r.a)(R),
				N = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(p.Q)(a, {
							subredditId: e
						}).name;
					n(m());
					const d = await Object(i.k)(o(), c, t);
					if (d.ok) {
						n(O({
							subredditId: e,
							isEnabled: t
						}))
					} else n(g());
					return d.ok
				}, L = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(p.Q)(a, {
							subredditId: e
						}).name;
					n(y());
					const d = await Object(i.j)(o(), t, u.d.LinkFlair, c);
					if (d.ok) {
						n(j({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(h());
					return d.ok
				}, U = (e, t) => async (n, r, o) => {
					let {
						apiContext: d
					} = o;
					const b = r(),
						f = Object(p.Q)(b, {
							subredditId: t
						}).name;
					n(I());
					const m = await Object(i.f)(d(), e, f, u.d.LinkFlair);
					let O = m.ok && !(m.body && !1 === m.body.success);
					if (O) {
						const s = m.body;
						if (n(v({
								subredditId: t,
								template: s
							})), s.id) {
							const r = e.styleTemplate,
								o = b.structuredStyles.flairTemplate.models[s.id];
							r ? O = await n(Object(a.d)(t, s.id, r)) : o && (O = await n(Object(a.c)(t, s.id)))
						}
					}
					if (O) {
						const e = Object(c.d)(s.fbt._("Flair saved!", null, {
							hk: "3MQuUt"
						}), l.b.SuccessMod);
						n(Object(c.e)(e))
					} else {
						n(S());
						const r = Object(c.d)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "1yf1Ne"
						}), l.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), U(e, t));
						n(Object(c.e)(r))
					}
					return O
				}, M = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const d = r(),
						u = Object(p.Q)(d, {
							subredditId: t
						}).name;
					if (n(D()), (await Object(i.b)(a(), e, u)).ok) {
						n(C({
							subredditId: t,
							templateId: e
						}));
						const r = Object(c.d)(s.fbt._("Flair deleted!", null, {
							hk: "44T1il"
						}), l.b.SuccessMod);
						n(Object(c.e)(r))
					} else {
						n(w());
						const r = Object(c.d)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "1nwT0G"
						}), l.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), M(e, t));
						n(Object(c.e)(r))
					}
				}, F = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const d = r(),
						f = Object(b.d)(d, {
							subredditId: t
						}).templateIds,
						m = Object(p.Q)(d, {
							subredditId: t
						}).name;
					if (n(P({
							subredditId: t,
							templateIds: e
						})), (await Object(i.e)(a(), m, u.d.LinkFlair, e)).ok) {
						n(k());
						const e = Object(c.d)(s.fbt._("Flair reorder saved.", null, {
							hk: "1Xbuan"
						}), l.b.SuccessMod);
						n(Object(c.e)(e))
					} else {
						n(x({
							subredditId: t,
							templateIds: f
						}));
						const r = Object(c.d)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "4ohwNd"
						}), l.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), F(e, t));
						n(Object(c.e)(r))
					}
				}, G = e => {
					let {
						post: t,
						previewFlair: n,
						selectedTemplateId: s
					} = e;
					return async (e, r, a) => {
						let {
							apiContext: c
						} = a;
						const u = t.flair.filter(e => !Object(d.p)(e.type));
						if (n && u.unshift(n), e(Object(o.T)({
								[t.id]: {
									flair: u
								}
							})), n) {
							const e = Object(d.g)(n);
							Object(i.h)(c(), t.id, s, e)
						} else Object(i.h)(c(), t.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return E
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "c", (function() {
				return D
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/lodash/forEach.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/isEqual.js"),
				a = n.n(o),
				c = n("./node_modules/lodash/values.js"),
				i = n.n(c),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/imageUploads.ts"),
				l = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			var O = n("./src/reddit/helpers/trackers/blade.ts"),
				g = n("./src/reddit/models/Image/index.tsx"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/telemetry/index.ts"),
				j = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const h = e => {
					let {
						subredditId: t,
						flairId: n,
						imageKey: s,
						imageData: r
					} = e;
					return async (e, o, a) => {
						const c = o(),
							i = Object(_.Q)(c, {
								subredditId: t
							});
						if (!i) return !1;
						e(Object(u.k)(r));
						const d = await (async (e, t, n, s, r, o) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_style_asset_upload_s3/").concat(n),
							method: b.ab.POST,
							data: {
								filepath: s,
								imagetype: r,
								mimetype: o
							}
						}))(a.apiContext(), i.name, n, r.file.name, s, await Object(l.g)(r.file));
						let O = !1;
						try {
							const t = await Object(u.g)(o(), d, r, g.a.FlairTemplates);
							t && e(Object(u.j)(t)), O = !0
						} catch (y) {
							if (y instanceof Error) throw y;
							e(Object(u.i)(y))
						}
						return O
					}
				},
				E = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				I = Object(d.a)(E),
				v = (e, t, n) => async (s, o, c) => {
					const {
						apiContext: d
					} = c;
					let l = o();
					const {
						pendingImages: E
					} = n;
					let v = j(n, ["pendingImages"]);
					const S = Object(_.Q)(l, {
						subredditId: e
					});
					if (!S) return !1;
					const T = l.structuredStyles.flairTemplate.models[t];
					if (T && a()(T, v)) return !0;
					if (E) {
						const n = [];
						if (r()(E, (r, o) => {
								r && n.push(s(h({
									flairId: t,
									imageData: Object(g.m)(r),
									imageKey: o,
									subredditId: e
								})))
							}), !(await Promise.all(n)).every(e => e)) return !1;
						v = ((e, t, n) => {
							const s = Object.assign({}, e);
							return r()(t, (e, t) => {
								const r = e && n.imageUploads[e.id];
								r && r.kind === g.b.TempUploaded && (s[t] = r.url)
							}), s
						})(v, E, o())
					}
					l = o();
					let D = null,
						C = null;
					const w = [];
					try {
						(D = await Object(u.f)(l, g.a.FlairTemplates)) && (C = Object(u.m)(D)(s, o, c), w.push(...i()(D.imagesByKey)))
					} catch (k) {
						return !1
					}
					const A = await (async (e, t, n, s) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_styles/").concat(n),
							method: b.ab.PUT,
							data: s
						}))(d(), S.name, t, v),
						R = T ? "edit_post_flair_template" : "save_post_flair_template",
						P = Object(O.e)(l, R);
					if (A.ok) {
						let e;
						if (C) try {
							await C, e = ((e, t, n) => {
								const s = Object.assign({}, e);
								return t.forEach(e => {
									const t = n.imageUploads[e.id];
									t && t.kind === g.b.Uploaded && (e.url === s.postBackgroundImage ? s.postBackgroundImage = t.url : e.url === s.postPlaceholderImage && (s.postPlaceholderImage = t.url))
								}), s
							})(v, w, o())
						} catch (k) {
							e = null
						} else e = v;
						s(I({
							flairId: t,
							template: e || v
						}))
					} else D && D.websocket.close();
					return Object(y.a)(Object.assign({}, P, {
						actionInfo: Object.assign({}, P.actionInfo, {
							success: A.ok
						})
					})), A.ok
				}, S = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", T = Object(d.a)(S), D = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(_.Q)(a, {
							subredditId: e
						});
					if (!c) return !1;
					const i = await (async (e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_styles/").concat(n),
							method: b.ab.DELETE
						}))(o(), c.name, t),
						d = Object(O.e)(a, "delete_flair_template");
					return i.ok && n(T({
						flairId: t
					})), Object(y.a)(Object.assign({}, d, {
						actionInfo: Object.assign({}, d.actionInfo, {
							success: i.ok
						})
					})), i.ok
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/postList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = (n("./src/reddit/actions/embedAndImage.ts"), n("./src/reddit/actions/video.ts"), n("./src/reddit/helpers/trackers/postList.ts"));
			n("./src/reddit/constants/postLayout.ts"), n("./src/reddit/selectors/platform.ts"), n("./src/reddit/selectors/posts.ts");
			n("./src/reddit/selectors/video.ts");
			const o = "POSTLIST__MARKED_END",
				a = "POSTLIST__UNMARKED_END",
				c = Object(s.a)(o),
				i = Object(s.a)(a),
				d = (e, t) => async (n, s) => {
					const o = s();
					e in o.listings.postOrder.fetchedTokens ? e in o.listings.postOrder.ids ? n(i({
						listingKey: e
					})) : r.j(o, e) : n(c({
						listingKey: e,
						listingName: t
					}))
				}
		},
		"./src/reddit/actions/postRequirements/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = "POST_REQUIREMENTS_FAILED",
				r = "POST_REQUIREMENTS_LOADED",
				o = "POST_REQUIREMENTS_PENDING",
				a = "POST_REQUIREMENTS_UPDATED"
		},
		"./src/reddit/actions/postRequirements/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return I
			}));
			var s = n("./node_modules/lodash/camelCase.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/graphql/operations/GetPostRequirements.json"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/graphql/operations/UpdatePostRequirements.json"),
				b = n("./src/reddit/endpoints/subreddit/about.ts"),
				p = n("./src/reddit/i18n/utils.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/postRequirements.ts"),
				O = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/actions/postRequirements/constants.ts");
			const _ = Object(a.a)(g.b),
				y = Object(a.a)(g.c),
				j = Object(a.a)(g.a),
				h = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const a = {
						subredditName: e.toLowerCase()
					};
					if (Object(m.a)(n(), a)) return;
					t(y(a));
					let i = Object(O.E)(n(), e);
					if (!i) {
						const n = await Object(b.a)(r(), e, !1);
						if (n.ok) {
							i = n.body.data.subreddit.id
						}
						if (!i) {
							const e = n.error || {
								type: o.C.NOT_FOUND_ERROR
							};
							return void t(j(Object.assign({}, a, {
								error: e
							})))
						}
					}
					let l = null;
					const p = await ((e, t) => Object(u.a)(e, Object.assign({}, d, {
						variables: t
					})))(r(), {
						subredditId: i
					});
					if (p.ok) {
						const e = p.body;
						l = e.data.subreddit && e.data.subreddit.postRequirements
					}
					if (l) t(_(Object.assign({}, a, {
						requirements: l
					})));
					else {
						const n = p.error || {
							type: o.C.UNKNOWN_ERROR
						};
						t(j(Object.assign({}, a, {
							error: n
						}))), c.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: p.body,
								responseOk: p.ok
							}), c.c.captureMessage("Missing post requirements data!")
						})
					}
				}, E = Object(a.a)(g.d), I = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = e.toLowerCase(),
						c = Object(O.E)(s(), e);
					if (!c) return {
						success: !1
					};
					const d = Object.assign({
							subredditId: c
						}, t),
						b = await ((e, t) => Object(u.a)(e, Object.assign({}, l, {
							variables: t
						})))(o(), {
							input: d
						});
					let m = !1,
						g = null;
					if (b.ok) {
						const e = b.body;
						m = e.data.updatePostRequirements.ok, g = v(e.data.updatePostRequirements.fieldErrors)
					}
					return m ? (n(E({
						subredditName: a,
						partialRequirements: t
					})), {
						success: !0
					}) : (n(Object(i.e)({
						duration: i.a,
						id: "REQUIREMENTS_SAVE_ERROR",
						kind: f.b.Error,
						text: g && g.length ? g[0].message : Object(p.b)("Something went wrong")
					})), {
						success: !1,
						errors: g || void 0
					})
				}, v = e => e && e.map(e => Object.assign({}, e, {
					field: r()(e.field)
				}))
		},
		"./src/reddit/actions/preferences.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return G
			})), n.d(t, "i", (function() {
				return B
			})), n.d(t, "g", (function() {
				return q
			})), n.d(t, "h", (function() {
				return V
			})), n.d(t, "p", (function() {
				return K
			})), n.d(t, "e", (function() {
				return H
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "m", (function() {
				return Y
			})), n.d(t, "f", (function() {
				return Q
			})), n.d(t, "o", (function() {
				return z
			})), n.d(t, "r", (function() {
				return J
			})), n.d(t, "t", (function() {
				return te
			})), n.d(t, "c", (function() {
				return ae
			})), n.d(t, "v", (function() {
				return ce
			})), n.d(t, "w", (function() {
				return ie
			})), n.d(t, "x", (function() {
				return de
			})), n.d(t, "u", (function() {
				return ue
			})), n.d(t, "y", (function() {
				return le
			})), n.d(t, "F", (function() {
				return be
			})), n.d(t, "D", (function() {
				return pe
			})), n.d(t, "a", (function() {
				return fe
			})), n.d(t, "q", (function() {
				return me
			})), n.d(t, "E", (function() {
				return ye
			})), n.d(t, "H", (function() {
				return je
			})), n.d(t, "j", (function() {
				return he
			})), n.d(t, "l", (function() {
				return Se
			})), n.d(t, "k", (function() {
				return De
			})), n.d(t, "z", (function() {
				return we
			})), n.d(t, "C", (function() {
				return Ae
			})), n.d(t, "s", (function() {
				return Re
			})), n.d(t, "B", (function() {
				return Pe
			})), n.d(t, "A", (function() {
				return Ne
			})), n.d(t, "n", (function() {
				return Le
			})), n.d(t, "G", (function() {
				return Fe
			})), n.d(t, "J", (function() {
				return Ge
			})), n.d(t, "I", (function() {
				return Be
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var s = n("./node_modules/Base64/base64.js"),
				r = n("./src/config.ts"),
				o = n("./node_modules/fbt/lib/FbtPublic.js"),
				a = n("./node_modules/js-cookie/src/js.cookie.js"),
				c = n.n(a),
				i = n("./node_modules/lodash/isEmpty.js"),
				d = n.n(i),
				u = n("./node_modules/lodash/omit.js"),
				l = n.n(u),
				b = n("./node_modules/lodash/pick.js"),
				p = n.n(b),
				f = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/makeActionCreator/index.ts"),
				O = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/actions/chat/toggle.ts"),
				_ = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				y = n("./src/reddit/actions/users.ts"),
				j = n("./src/reddit/constants/cookie.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				E = n("./src/reddit/endpoints/user/preferences.ts"),
				I = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				v = n("./src/lib/makeApiRequest/index.ts"),
				S = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				T = n("./src/reddit/actions/imageUploads.ts"),
				D = n("./src/reddit/actions/toaster.ts"),
				C = n("./src/reddit/constants/preferences.ts"),
				w = n("./src/reddit/endpoints/subreddit/settings.ts"),
				A = n("./src/reddit/helpers/media/index.ts"),
				R = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				P = n("./src/reddit/models/Image/index.tsx"),
				k = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/models/User/index.ts"),
				N = n("./src/reddit/selectors/experiments/editProfileImagesInline.ts"),
				L = n("./src/reddit/selectors/imageUploads.ts"),
				U = n("./src/reddit/selectors/structuredStyles.ts"),
				M = n("./src/reddit/selectors/subreddit.ts"),
				F = n("./src/reddit/selectors/user.ts");
			const G = "PREFERENCES__AUTOPLAY_TOGGLED",
				B = "PREFERENCES__NIGHTMODE_TOGGLED",
				q = "PREFERENCES__LANGUAGE_CHANGED",
				V = "PREFERENCES__LAYOUT_CHANGED",
				K = "PREFERENCES__SUBREDDIT_LAYOUT_CHANGED",
				H = "PREFERENCES__CUSTOMIZE_FLYOUT_SHOWN",
				W = "PREFERENCES__CUSTOMIZE_FLYOUT_DISMISSED",
				Y = "PREFERENCES__PROFILE_LAYOUT_CHANGED",
				Q = "PREFERENCES__HAMBURGER_TRAY_TOGGLED",
				z = "PREFERENCES__RPAN_DU_DISMISSED",
				J = "PREFERENCES__TOP_CONTENT_DISMISSAL_PREF_SET",
				X = Object(m.a)(q),
				Z = Object(m.a)(V),
				$ = Object(m.a)(K),
				ee = Object(m.a)(H),
				te = Object(m.a)(W),
				ne = Object(m.a)(z),
				se = Object(m.a)(J),
				re = (Object(m.a)(Y), Object(m.a)(G)),
				oe = Object(m.a)(B),
				ae = (Object(m.a)(Q), "PREFERENCES__COLLAPSED_TRAY_TOGGLED"),
				ce = (Object(m.a)(ae), e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = r(),
						a = await Object(v.b)(Object(O.a)(o, [h.a]), {
							data: {
								lang: e.replace("-", "_")
							},
							endpoint: "".concat(o.apiUrl, "/api/v1/me/prefs"),
							method: f.ab.PATCH,
							type: "json"
						});
					if (a.ok) {
						const e = a.body.lang;
						t(X(e))
					}
				}),
				ie = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(Z({
						layout: e
					})), t(Object(y.o)())
				}, de = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(F.Y)(a),
						{
							hasSeenCustomizeFlyout: i
						} = a.user.prefs;
					i || n(ee()), t && c ? (n($({
						subredditId: t,
						layout: e
					})), n(Ge(t, {
						layout: e
					}, !1)), i || n(je({
						hasSeenCustomizeFlyout: !0
					}, !1))) : (n(ie(e)), n(je(i ? {
						layout: e
					} : {
						layout: e,
						hasSeenCustomizeFlyout: !0
					}, !1)))
				}, ue = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().user.account && await Object(E.d)(e, r())
				}, le = e => async (t, n, a) => {
					let {
						apiContext: i
					} = a;
					const d = n();
					if (Object(U.j)(d)) t(Object(D.e)({
						kind: k.b.Error,
						text: o.fbt._("In order to continue styling your community, Night Mode must be turned off.", null, {
							hk: "1yZidT"
						})
					}));
					else {
						if (d.user.account) await Object(E.e)(e, i());
						else {
							const t = c.a.get(j.j);
							if (t) {
								const n = JSON.parse(Object(s.atob)(t));
								n.prefs.nightmode = e, c.a.set(j.j, btoa(JSON.stringify(n)), {
									domain: r.a.cookieDomain
								})
							}
						}
						t(oe({
							nightmode: e
						})), t(Object(g.e)(e)), c.a.remove(j.d, {
							domain: r.a.cookieDomain
						})
					}
				}, be = () => async (e, t, n) => {
					let {
						apiContext: a
					} = n;
					const i = t(),
						d = i.user.prefs.topContentTimesDismissed + 1,
						u = Date.now();
					if (i.user.account) e(je({
						topContentDismissalTime: u,
						topContentTimesDismissed: d
					}, !1));
					else {
						const e = c.a.get(j.j);
						if (e) {
							const t = JSON.parse(Object(s.atob)(e));
							t.prefs[C.d] = u, t.prefs[C.e] = d, c.a.set(j.j, btoa(JSON.stringify(t)), {
								domain: r.a.cookieDomain
							})
						}
					}
					e(se({
						topContentDismissalTime: u,
						topContentTimesDismissed: d
					})), e(Object(D.e)({
						kind: k.b.SuccessCommunity,
						text: o.fbt._("Got it! We will show you less of this", null, {
							hk: "4op5Wa"
						})
					}))
				}, pe = e => async (t, n, a) => {
					let {
						apiContext: i
					} = a;
					const d = -1 === [_.P, "r/popular"].indexOf(e),
						u = Date.now(),
						l = n(),
						b = o.fbt._("Got it! We will show you less of this", null, {
							hk: "4op5Wa"
						});
					if (l.user.account)
						if (d) {
							const n = e.replace(/^r\//, ""),
								s = Object(M.E)(l, n);
							t(Ge(s, {
								rpanDuDismissalTime: u
							}, !1))
						} else t(je({
							rpanDuDismissalTime: u
						}, !1));
					else {
						const e = c.a.get(j.j);
						if (e) {
							const t = JSON.parse(Object(s.atob)(e));
							t.prefs[C.b] = u, c.a.set(j.j, btoa(JSON.stringify(t)), {
								domain: r.a.cookieDomain
							})
						}
					}
					t(Object(D.e)({
						kind: k.b.SuccessCommunity,
						text: b
					})), t(ne(u))
				}, fe = "SETTINGS__ACCOUNT_PREFS_UPDATE_SUCCESS", me = "SETTINGS__SUBREDDIT_PREFS_UPDATED", Oe = Object(m.a)("SETTINGS__UPDATE_PENDING"), ge = Object(m.a)("SETTINGS__UPDATE_FAILURE"), _e = Object(m.a)(fe), ye = Object(m.a)(me), je = function(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
					return async (s, r, a) => {
						let {
							apiContext: c
						} = a;
						s(Oe());
						const i = l()(e, C.a),
							u = p()(e, C.a),
							b = [];
						d()(i) || b.push(Object(E.g)(i, c())), d()(u) || b.push(Object(E.b)(u, c())), (await Promise.all(b)).every(e => e.ok) ? (s(_e({
							preferences: e
						})), t && s(Object(D.e)({
							kind: k.b.SuccessCommunity,
							text: n || o.fbt._("Changes saved", null, {
								hk: "2isjrZ"
							})
						}))) : (s(ge()), t && s(Object(D.e)({
							kind: k.b.Error,
							text: o.fbt._("Changes failed to save", null, {
								hk: "XrtIq"
							})
						})))
					}
				}, he = "SETTINGS__SUCCESS", Ee = Object(m.a)("SETTINGS__PENDING"), Ie = Object(m.a)("SETTINGS__FAILURE"), ve = Object(m.a)(he), Se = "SETTINGS__PROFILE_IMAGE_UPDATE_SUCCESS", Te = Object(m.a)(Se), De = "SETTINGS__PROFILE_IMAGE_DELETE_SUCCESS", Ce = Object(m.a)(De), we = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					t(Ee());
					const a = await ((e, t) => Object(v.b)(e, {
						endpoint: Object(S.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/prefs")),
						method: f.ab.GET,
						data: {
							timestamp: t ? Date.now() : void 0
						}
					}))(o(), e);
					a.ok ? t(ve(a.body)) : t(Ie())
				}, Ae = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					if (n().user.account) await Object(E.a)(e, r());
					else {
						const e = c.a.get(j.e);
						if (e) {
							const t = JSON.parse(decodeURIComponent(e));
							t.pref_quarantine_optin = !0, c.a.set(j.e, JSON.stringify(encodeURIComponent(t)), f.w)
						} else {
							const e = JSON.stringify({
								pref_quarantine_optin: !0
							});
							c.a.set(j.e, e, f.w)
						}
					}
				}, Re = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().user.account && await Object(E.c)(e, r()), t(re({
						autoplayVideo: e
					}))
				}, Pe = (e, t) => async (n, s, r) => {
					const o = Object(N.a)(s()) ? ke : xe;
					await o(e, t)(n, s, r)
				}, ke = (e, t) => async (n, s, r) => {
					const {
						apiContext: a
					} = r, c = Object(F.i)(s());
					if (!c || !c.profileId) return;
					n(Object(T.k)(e));
					const i = Object(x.e)(c),
						d = f.Rb + i,
						u = await Object(I.d)(a(), d, e.file.name, t, await Object(A.g)(e.file));
					if (u.ok) {
						let p;
						try {
							if (!(p = await Object(T.g)(s(), u, e, P.a.Profiles))) return void n(Object(D.e)({
								kind: k.b.Error,
								text: o.fbt._("Changes failed to save", null, {
									hk: "3QlXrl"
								})
							}));
							n(Object(T.j)(p))
						} catch (l) {
							return void n(Object(T.i)(l))
						}
						let f = null,
							m = null;
						try {
							(f = await Object(T.f)(s(), P.a.Profiles)) && (m = Object(T.m)(f)(n, s, r))
						} catch (b) {
							return void n(Object(D.e)({
								kind: k.b.Error,
								text: o.fbt._("Changes failed to save", null, {
									hk: "3QlXrl"
								})
							}))
						}
						const O = decodeURIComponent(p.url);
						if (n(Te({
								imageUrl: O,
								key: t,
								subredditId: c.profileId,
								username: i
							})), (await Object(I.e)(a(), d, {
								[t]: O
							})).ok) {
							if (m) try {
								await m
							} catch (b) {}
							n(Object(D.e)({
								kind: k.b.SuccessCommunity,
								text: o.fbt._("Changes saved", null, {
									hk: "xEVHp"
								})
							})), Object(R.g)(s(), t);
							const r = Object(L.a)(s(), e);
							n(Te({
								imageUrl: r ? r.url : p.url,
								key: t,
								subredditId: c.profileId,
								username: i
							}))
						} else n(Object(D.e)({
							kind: k.b.Error,
							text: o.fbt._("Changes failed to save", null, {
								hk: "1y1wAY"
							})
						}))
					} else {
						const e = "profileBanner" === t ? "1280x384" : "256x256";
						n(Object(D.e)({
							kind: k.b.Error,
							text: o.fbt._("There was an error uploading your image. Please verify that the size of your image is {maxImageSize} and less than 500KB.", [o.fbt._param("maxImageSize", e)], {
								hk: "I6lfz"
							})
						}))
					}
				}, xe = (e, t) => async (n, s, r) => {
					let {
						apiContext: a
					} = r;
					const c = Object(F.i)(s());
					if (!c || !c.profileId) return;
					const i = Object(x.e)(c),
						d = f.Rb + i,
						u = await Object(I.g)(a(), d, t, e.file);
					if (u.ok) {
						const e = decodeURIComponent(u.body.PostResponse.Location);
						n(Te({
							imageUrl: e,
							key: t,
							subredditId: c.profileId,
							username: i
						})), (await Object(I.e)(a(), d, {
							[t]: e
						})).ok ? (n(Object(D.e)({
							kind: k.b.SuccessCommunity,
							text: o.fbt._("Changes saved", null, {
								hk: "xEVHp"
							})
						})), Object(R.g)(s(), t)) : n(Object(D.e)({
							kind: k.b.Error,
							text: o.fbt._("Changes failed to save", null, {
								hk: "1y1wAY"
							})
						}))
					} else {
						const e = "profileBanner" === t ? "1280x384" : "256x256";
						n(Object(D.e)({
							kind: k.b.Error,
							text: o.fbt._("There was an error uploading your image. Please verify that the size of your image is {maxImageSize} and less than 500KB.", [o.fbt._param("maxImageSize", e)], {
								hk: "I6lfz"
							})
						}))
					}
				}, Ne = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const a = Object(F.i)(n());
					if (!a || !a.profileId) return;
					const c = Object(x.e)(a),
						i = f.Rb + c,
						d = {
							profileIcon: "icon",
							profileBanner: "banner"
						} [e],
						u = await Object(w.b)(r(), i, d);
					if (u.ok) {
						const s = u.body[d + "_img"];
						t(Ce({
							imageUrl: s,
							key: e,
							subredditId: a.profileId,
							username: c
						})), t(Object(D.e)({
							kind: k.b.SuccessCommunity,
							text: o.fbt._("Changes saved", null, {
								hk: "xEVHp"
							})
						})), Object(R.f)(n(), e)
					} else t(Object(D.e)({
						kind: k.b.Error,
						text: o.fbt._("Changes failed to save", null, {
							hk: "1y1wAY"
						})
					}))
				}, Le = "SETTINGS__PROFILE_SETTINGS_UPDATE_SUCCESS", Ue = Object(m.a)(Le), Me = Object(m.a)("SETTINGS__PROFILE_SETTINGS_UPDATE_FAILED"), Fe = (e, t) => async (n, s, r) => {
					let {
						apiContext: a
					} = r;
					const c = Object(F.i)(s());
					if (!c || !c.profileId) return !1;
					const i = [],
						d = s().subreddits.settings[c.profileId],
						u = Object.assign({}, d, e);
					i.push(Object(w.f)(a(), c.profileId, u));
					const {
						showActiveCommunities: l,
						prevShowActiveCommunities: b
					} = t;
					return l !== b && i.push(Object(E.g)({
						showActiveCommunities: l
					}, a())), (await Promise.all(i)).every(e => e.ok) ? (n(Ue({
						settings: e,
						additional: t,
						subredditId: c.profileId
					})), Object(R.i)(s()), n(Object(D.e)({
						kind: k.b.SuccessCommunity,
						text: o.fbt._("Changes saved", null, {
							hk: "xEVHp"
						})
					})), !0) : (n(Me()), n(Object(D.e)({
						kind: k.b.Error,
						text: o.fbt._("Changes failed to save", null, {
							hk: "1y1wAY"
						})
					})), !1)
				}, Ge = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (s, r, a) => {
						let {
							apiContext: c
						} = a;
						const i = r().user.prefs.subreddit[e];
						s(ye({
							subredditId: e,
							prefs: t
						})), (await Object(E.h)(e, t, c())).ok ? n && s(Object(D.e)({
							kind: k.b.SuccessCommunity,
							text: o.fbt._("Changes saved", null, {
								hk: "xEVHp"
							})
						})) : (i && s(ye({
							subredditId: e,
							prefs: i
						})), n && s(Object(D.e)({
							kind: k.b.Error,
							text: o.fbt._("Changes failed to save", null, {
								hk: "1y1wAY"
							})
						})))
					}
				}, Be = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s();
					Object(M.Q)(a, {
						subredditId: e
					}) && a.user.prefs.rememberCommunitySort && n(Ge(e, {
						sort: t
					}, !1))
				}
		},
		"./src/reddit/actions/product.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return h
			})), n.d(t, "j", (function() {
				return E
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/governance/errorToast.ts"),
				o = n("./src/reddit/endpoints/governance/badges.ts"),
				a = n("./src/reddit/endpoints/governance/products/badges.ts");
			const c = "PRODUCT__BADGE_PURCHASE_OPENED",
				i = "PRODUCT__BADGE_PURCHASE_SUCCESS",
				d = "PRODUCT__BADGE_PURCHASE_FAILURE",
				u = "PRODUCT__BADGE_PURCHASE_PENDING",
				l = "PRODUCT__FETCH_SUCCESS",
				b = "PRODUCT__FETCH_FAILURE",
				p = "PRODUCT__FETCH_PENDING",
				f = Object(s.a)(c),
				m = Object(s.a)(i),
				O = Object(s.a)(d),
				g = Object(s.a)(u),
				_ = Object(s.a)(l),
				y = Object(s.a)(b),
				j = Object(s.a)(p),
				h = e => {
					let {
						productId: t
					} = e;
					return async (e, n, s) => {
						let {
							apiContext: c
						} = s;
						const i = n(),
							d = i.products.models[t],
							u = i.user.account,
							l = !!i.products.api.purchase.pending[t];
						if (d && d.price && !l) {
							e(g({
								productId: t
							}));
							const n = await Object(a.c)(c(), {
								price: d.price,
								products: [{
									productId: t,
									quantity: "1"
								}],
								subredditId: d.subredditId
							});
							let s;
							if (n.ok && u && (s = await Object(o.c)(c(), d.subredditId, u.id)), n.ok) {
								if (s && s.ok) {
									const {
										badges: t,
										userOwnedBadges: r
									} = s.body;
									e(m({
										product: d,
										badges: t,
										userOwnedBadges: r,
										wallet: n.body.wallet
									}))
								}
							} else e(O({
								productId: t,
								error: n.error
							})), Object(r.a)(e, n.error)
						}
					}
				},
				E = e => {
					let {
						subredditId: t
					} = e;
					return async (e, n, s) => {
						let {
							apiContext: r
						} = s;
						e(j({
							subredditId: t
						}));
						const o = await Object(a.a)(r(), t);
						o.ok ? e(_({
							subredditId: t,
							products: o.body
						})) : e(y({
							subredditId: t,
							error: o.error
						}))
					}
				}
		},
		"./src/reddit/actions/profile/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return s
			})), n.d(t, "j", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "g", (function() {
				return m
			}));
			const s = "PROFILE__PROFILE_INFO_LOADED",
				r = "PROFILE__PROFILE_INFO_FAILED",
				o = "PROFILE__MODERATED_SUBREDDITS_PENDING",
				a = "PROFILE__MODERATED_SUBREDDITS_LOADED",
				c = "PROFILE__MODERATED_SUBREDDITS_FAILED",
				i = "PROFILE__RECEIVED_MODERATED_SUBREDDITS_MODELS",
				d = "PROFILE__RECEIVED_MODERATED_SUBREDDITS_SUBSCRIPTIONS",
				u = "MORE__PROFILE_GQL_MODERATED_PENDING",
				l = "MORE__PROFILE_GQL_MODERATED_LOADED",
				b = "MORE__PROFILE_GQL_MODERATED_FAILED",
				p = "PROFILE__MULTIREDDITS_PENDING",
				f = "PROFILE__MULTIREDDITS_LOADED",
				m = "PROFILE__MULTIREDDITS_FAILED"
		},
		"./src/reddit/actions/profile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return k
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "f", (function() {
				return V
			})), n.d(t, "e", (function() {
				return K
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/actions/contentGate.ts"),
				a = n("./src/reddit/actions/gold/gild.ts"),
				c = n("./src/reddit/actions/pages/profilePrivate/constants.ts"),
				i = n("./src/reddit/endpoints/profile/info.ts"),
				d = n("./src/graphql/operations/ModeratedSubreddits.json"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				p = n("./src/reddit/constants/headers.ts");
			var f = n("./src/graphql/operations/RedditorMultireddits.json");
			var m = n("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts");
			var g = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				_ = e => {
					const t = e.awardee_karma || 0,
						n = e.awarder_karma || 0,
						s = e.comment_karma,
						o = e.link_karma,
						a = t + n + s + o;
					return Object.assign({
						accountIcon: e.icon_img,
						awardedLastMonth: e.awarded_last_month ? Object(g.c)(e.awarded_last_month) : null,
						awardeeKarma: t,
						awarderKarma: n,
						commentKarma: s,
						created: e.created,
						displayName: e.name,
						displayNamePrefixed: e.subreddit && e.subreddit.display_name_prefixed,
						displayText: e.name,
						hasUserProfile: !!e.subreddit,
						hideFromRobots: !!e.hide_from_robots,
						id: "".concat(r.vb.Account, "_").concat(e.id),
						isEmployee: e.is_employee,
						isFollowing: e.has_subscribed,
						isGold: e.is_gold,
						isAdmin: e.is_admin,
						isMod: e.is_mod,
						isNSFW: !(!e.subreddit || !e.subreddit.over_18),
						prefShowSnoovatar: e.pref_show_snoovatar,
						prefShowTwitter: e.pref_show_twitter,
						postKarma: o,
						totalKarma: a,
						url: "/user/".concat(e.name, "/"),
						username: e.name
					}, e.subreddit ? {
						profileId: e.subreddit.name
					} : null)
				},
				y = e => {
					const t = e.awardee_karma || 0,
						n = e.awarder_karma || 0,
						s = e.comment_karma,
						r = e.link_karma,
						o = t + n + s + r;
					return {
						awardeeKarma: t,
						awarderKarma: n,
						commentKarma: s,
						hasExternalAccount: e.has_external_account,
						postKarma: r,
						prefShowTwitter: e.pref_show_twitter,
						publicDescription: e.subreddit ? e.subreddit.public_description : "",
						totalKarma: o,
						userIsSubscriber: e.subreddit && e.subreddit.user_is_subscriber || !1
					}
				},
				j = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts");
			var h = n("./src/reddit/models/User/index.ts"),
				E = n("./src/reddit/selectors/profile.ts"),
				I = n("./src/reddit/selectors/subscriptions.ts"),
				v = n("./src/reddit/selectors/user.ts"),
				S = n("./src/reddit/actions/profile/constants.ts");
			const T = Object(s.a)(S.k),
				D = Object(s.a)(S.j),
				C = Object(s.a)(S.c),
				w = Object(s.a)(S.b),
				A = Object(s.a)(S.a),
				R = Object(s.a)(S.l),
				P = Object(s.a)(S.m),
				k = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = Object(v.i)(t());
					r && r.profileId && await e(x(Object(h.e)(r)))
				}, x = (e, t) => async (n, s, a) => {
					let {
						apiContext: c,
						gqlContext: d
					} = a;
					const u = s();
					if (!!(Object(E.j)(u, {
							profileName: e
						}) && Object(E.h)(u, {
							profileName: e
						}) && Object(v.eb)(u, {
							userName: e
						})) && !t) return;
					const [l, b] = await Promise.all([Object(i.a)(c(), e), Object(i.b)(d(), e)]);
					if (l.ok) {
						l.body && l.body.data && l.body.data.is_suspended && n(Object(o.u)({
							profileName: e
						}));
						const t = function(e) {
							const {
								data: t
							} = e;
							return Object.assign({
								about: y(t),
								banner: t.subreddit && t.subreddit.banner_img && {
									height: t.subreddit.banner_size && t.subreddit.banner_size[1],
									url: t.subreddit.banner_img,
									width: t.subreddit.banner_size && t.subreddit.banner_size[0]
								},
								user: _(t),
								features: t.features
							}, t.subreddit ? {
								profile: Object(j.a)(t.subreddit, t.name)
							} : null)
						}(l.body);
						if (b.ok && b.body.data.redditorInfoByName.karma) {
							const e = b.body.data.redditorInfoByName.karma,
								n = {
									awardeeKarma: e.fromAwardsReceived,
									awarderKarma: e.fromAwardsGiven,
									commentKarma: e.fromComments,
									postKarma: e.fromPosts,
									totalKarma: e.total
								};
							Object.assign(t.about, n), Object.assign(t.user, n)
						}
						n(T(t))
					} else l.error && l.error.type === r.l && n(Object(o.s)({
						profileName: e
					})), n(D(l.body))
				}, N = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = {
						profileName: e
					};
					if (Object(E.a)(n(), a)) return;
					if (Object(E.k)(n(), a)) return;
					t(C(a));
					const c = await ((e, t) => Object(u.b)(Object(b.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/moderated_subreddits.json"),
						method: r.ab.GET,
						data: {
							raw_json: 1
						}
					}))(o(), e);
					if (c.ok) {
						const s = function(e) {
							return e ? e.map(e => ({
								communityIcon: e.community_icon,
								displayText: e.sr_display_name_prefixed,
								icon: {
									height: e.icon_size ? e.icon_size[1] : 0,
									url: e.icon_img ? e.icon_img : "",
									width: e.icon_size ? e.icon_size[0] : 0
								},
								id: e.name,
								isNSFW: e.over_18,
								isQuarantined: !!e.quarantine,
								name: "user" === e.subreddit_type ? e.sr.slice(r.Rb.length) : e.sr,
								primaryColor: e.primary_color,
								subscribers: e.subscribers,
								title: e.title,
								type: e.subreddit_type,
								url: e.url,
								wls: e.wls
							})) : []
						}(c.body.data);
						t(w({
							profileName: e,
							data: s
						}));
						const o = {},
							a = {};
						if (s.forEach(e => {
								("user" === e.type ? a : o)[e.id] = e
							}), t(R({
								subreddits: o,
								profiles: a
							})), !Object(I.e)(n())) {
							const e = (e => {
								const t = e.filter(e => e.user_is_subscriber);
								return {
									subredditOrder: t.filter(e => "user" !== e.subreddit_type).map(e => e.name),
									profileOrder: t.filter(e => "user" === e.subreddit_type).map(e => e.name)
								}
							})(c.body.data || []);
							t(P(e))
						}
					} else t(A(c.body))
				}, L = Object(s.a)(S.f), U = Object(s.a)(S.e), M = Object(s.a)(S.d), F = e => async (t, n, s) => {
					const r = n(),
						o = e.toLowerCase(),
						{
							pageInfo: a
						} = r.profiles.moderated;
					if (!a[o] || !a[o].hasNextPage || !a[o].endCursor) return;
					t(L({
						profileName: o
					}));
					const i = await ((e, t) => Object(l.a)(e, Object.assign({}, d, {
							variables: t
						})))(s.gqlContext(), {
							name: o,
							after: a[o].endCursor,
							first: c.h
						}),
						u = i.body.data;
					if (i.ok) {
						const e = Object(O.b)(u.redditor.moderatedSubreddits);
						t(U(Object.assign({
							profileName: o
						}, e)))
					} else t(M(i.error))
				}, G = Object(s.a)(S.i), B = Object(s.a)(S.h), q = Object(s.a)(S.g), V = (e, t) => async (n, s, o) => {
					const a = s(),
						i = e.toLowerCase(),
						d = {
							profileName: i
						};
					if (Object(E.b)(a, d)) return;
					if (!t && Object(E.l)(a, d)) return;
					const {
						pageInfo: u
					} = a.profiles.multireddits;
					if (t && (!u[i] || !u[i].hasNextPage || !u[i].endCursor)) return;
					n(G(d));
					const b = await ((e, t) => Object(l.a)(e, Object.assign({}, f, {
							variables: t
						})))(o.gqlContext(), {
							name: i,
							first: t ? c.h : r.Db,
							after: t ? u[i].endCursor : void 0
						}),
						p = b.body.data;
					if (b.ok && p.redditorInfoByName) {
						const e = p.redditorInfoByName.multireddits.edges.map(e => e.node),
							t = Object(m.b)(e);
						n(B(Object.assign({}, d, t, {
							pageInfo: p.redditorInfoByName.multireddits.pageInfo,
							multiredditsModelsState: a.multireddits.models
						})))
					} else n(q(Object.assign({}, d, {
						error: b.error
					})))
				}, K = e => async (t, n, s) => {
					const r = e.toLowerCase(),
						o = await Object(i.b)(s.gqlContext(), r);
					if (o.ok && o.body) {
						const e = o.body.data.redditorInfoByName.karma;
						t(Object(a.awardKarmaUpdated)({
							awardeeKarma: e.fromAwardsReceived,
							awarderKarma: e.fromAwardsGiven,
							userName: r
						}))
					}
				}
		},
		"./src/reddit/actions/profileConversations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return _
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "h", (function() {
				return A
			})), n.d(t, "g", (function() {
				return R
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./node_modules/lodash/difference.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				a = n.n(o),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/pages/profileShared.ts"),
				u = n("./src/reddit/constants/parameters.ts"),
				l = n("./src/reddit/constants/things.ts"),
				b = n("./src/config.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				m = n("./src/reddit/models/Comment/addProfileImgParam.ts");
			var O = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				g = n("./src/reddit/selectors/experiments/avatarsInComments.ts");
			const _ = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_PENDING",
				y = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_LOADED",
				j = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_FAILED",
				h = "PROFILE__EXTRACOMMENTS_PENDING",
				E = "PROFILE__EXTRACOMMENTS_LOADED",
				I = "PROFILE__EXTRACOMMENTS_FAILED",
				v = Object(i.a)(_),
				S = Object(i.a)(y),
				T = Object(i.a)(j),
				D = Object(i.a)(E),
				C = Object(i.a)(h),
				w = Object(i.a)(I),
				A = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						{
							currentPage: i
						} = o.platform;
					if (!i || !i.routeMatch) return;
					const {
						queryParams: l,
						params: m
					} = i.routeMatch.match, {
						sort: g,
						t: _
					} = Object(d.a)(o, l), {
						profileName: y
					} = m, j = y.toLowerCase(), h = Object(O.a)(j, c.ib, g, l), E = o.listings.postOrder.loadMore[h];
					if (!E) return;
					const I = o.listings.postOrder.api.pending[h],
						{
							fetchedTokens: D
						} = o.listings.postOrder,
						C = !(!D[h] || !D[h][E.token]);
					if (I || C) return;
					e(v({
						key: h,
						fetchedToken: E.token
					}));
					const w = await ((e, t, n) => Object(p.b)(e, {
						data: n,
						endpoint: Object(f.a)("".concat(b.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/conversations")),
						method: c.ab.GET
					}))(s(), y, Object.assign({
						after: E.token,
						dist: E.dist,
						sort: g,
						t: _
					}, a()(l, u.k)));
					if (w.ok) {
						const t = o.listings.postOrder.ids[h],
							n = Object.assign({}, w.body, {
								postIds: r()(w.body.postIds, t)
							});
						e(S(Object.assign({
							fetchedToken: E.token,
							key: h,
							meta: o.meta,
							profileName: y
						}, n)))
					} else e(T({
						error: w.error,
						fetchedToken: E.token,
						key: h,
						account: w.body.data ? w.body.data.account : null
					}))
				}, R = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r();
					if (i.profileOverviewPage.conversations.extraComments.api.pending[n]) return;
					s(C({
						extraCommentsId: n
					}));
					let d = t;
					t.startsWith(l.b) && (d = t.slice(l.b.length));
					const u = n.split("-")[1],
						O = await ((e, t, n, s, r) => {
							let o = Object(f.a)("".concat(b.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/morecomments/").concat(n));
							return r && (o = Object(m.a)(o)), Object(p.b)(e, {
								endpoint: o,
								method: c.ab.GET,
								type: "json",
								data: {
									after: s,
									limit: 14
								}
							})
						})(a(), e, d, u, Object(g.a)(i));
					O.ok ? s(D(Object.assign({
						profileName: e,
						extraCommentsId: n
					}, O.body))) : s(w(O.body))
				}
		},
		"./src/reddit/actions/profileOverviewChrono.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "d", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./node_modules/lodash/difference.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				a = n.n(o),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				d = n("./src/reddit/selectors/profileOverviewChronoItems.ts"),
				u = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/constants/parameters.ts"),
				b = n("./src/reddit/actions/pages/profileShared.ts"),
				p = n("./src/reddit/endpoints/page/profileOverviewPage.ts");
			const f = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_PENDING",
				m = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_LOADED",
				O = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_FAILED",
				g = Object(c.a)(f),
				_ = Object(c.a)(m),
				y = Object(c.a)(O),
				j = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						{
							currentPage: c
						} = o.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: f,
						params: m
					} = c.routeMatch.match, {
						sort: O,
						t: j
					} = Object(b.a)(o, f), {
						profileName: h
					} = m, E = Object(i.a)(h, u.hb, O, f), I = Object(d.d)(o, {
						listingKey: E
					});
					if (!I) return;
					const v = Object(d.b)(o, {
							listingKey: E
						}),
						S = Object(d.c)(o, {
							listingKey: E
						}),
						T = S && S[I.token];
					if (v || T) return;
					e(g({
						key: E,
						fetchedToken: I.token
					}));
					const D = await Object(p.a)(s(), h, Object.assign({
						after: I.token,
						dist: I.dist,
						sort: O,
						t: j
					}, a()(f, l.k)));
					if (D.ok) {
						const t = Object(d.f)(o, {
								listingKey: E
							}),
							n = Object.assign({}, D.body, {
								overviewIds: r()(D.body.overviewIds, t)
							});
						e(_(Object.assign({
							fetchedToken: I.token,
							key: E,
							meta: o.meta
						}, n)))
					} else e(y({
						error: D.error,
						fetchedToken: I.token,
						key: E,
						account: D.body.data ? D.body.data.account : null
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return h
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/post.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				a = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				c = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				i = n("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const d = Object(s.a)(o.v),
				u = Object(s.a)(o.w),
				l = Object(s.a)(o.E),
				b = (Object(s.a)(o.F), Object(s.a)(o.G)),
				p = Object(s.a)(o.R),
				f = e => async (t, n) => {
					if (Object(c.a)(n())) return Object(c.b)(n()) ? t(m(e)) : t((() => async (e, t, n) => {
						let {
							gqlContext: s
						} = n;
						const r = Object(i.l)(t()),
							o = r.global.lastUpdated || 0,
							c = 1e3 * r.global.rpan_config_refresh_rate;
						if (r.isPending || Date.now() < o + c) return;
						e(l());
						const u = await Object(a.a)(s());
						u.ok && u.body ? e(d(Object.assign({}, u.body, {
							lastUpdated: Date.now()
						}))) : e(b())
					})())
				}, m = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = Object(i.l)(n()),
						c = Object(i.n)(n(), {
							subreddit: e
						}),
						p = c && c.lastUpdated || 0,
						f = 1e3 * o.global.rpan_config_refresh_rate;
					if (o.isPending || o.isPermanentlyCanceled || Date.now() < p + f) return;
					t(l());
					const m = await Object(a.b)(r(), e);
					if (!m.ok) return void t(b());
					const O = m.body;
					t(d(Object.assign({}, O.global, {
						lastUpdated: Date.now()
					}))), t(u({
						name: e,
						config: Object.assign({}, O.listing_info, {
							lastUpdated: Date.now()
						})
					}))
				}, O = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					t(p()), await Object(a.h)(r(), e)
				}, g = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					n().posts.models[e] || await t(Object(r.N)(e))
				}, _ = Object(s.a)(o.u), y = Object(s.a)(o.H), j = Object(s.a)(o.I), h = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (!Object(c.b)(r) || Object(i.i)(r)) return;
					e(y());
					const o = await Object(a.c)(s());
					o.ok && o.body && o.body.data ? e(_({
						subreddits: o.body.data
					})) : e(j({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/streams.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "e", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/es6.regexp.search.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/query-string/index.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				c = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				i = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				d = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				u = n("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const l = new Set(["home", "r/popular"]),
				b = e => {
					const t = location && location.search || "",
						n = r.a.parse(t);
					l.has(e) && (n.related = e);
					const s = r.a.stringify(n);
					return s ? "?".concat(s) : ""
				},
				p = Object(o.a)(a.L),
				f = Object(o.a)(a.x),
				m = Object(o.a)(a.M),
				O = Object(o.a)(a.y),
				g = Object(o.a)(a.K),
				_ = Object(o.a)(a.J),
				y = Object(o.a)(a.s),
				j = Object(o.a)(a.t),
				h = e => t => t.post.subreddit.name !== e ? t : Object.assign({}, t, {
					post: Object.assign({}, t.post, {
						subreddit: Object.assign({}, t.post.subreddit, {
							name: "pan"
						})
					})
				}),
				E = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = Object(i.g)(e),
						a = n();
					if (Object(u.e)(a, o)) return;
					t(p(o));
					const d = await Object(c.d)(r(), o),
						l = Date.now();
					if (d.ok && d.body && d.body.data) {
						let e = d.body.data;
						const s = Object(u.b)(n());
						s && "pan" !== s && (e = h(s)(e)), t(f({
							model: e,
							utcTimeStamp: l
						}))
					} else t(T({
						streamId: o,
						error: d.error,
						utcTimeStamp: l
					}))
				}, I = e => async (t, n) => Object(d.b)(n()) ? t(S(e)) : t(v()), v = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (Object(u.g)(r)) return;
					e(m());
					const o = await Object(c.f)(s()),
						a = Date.now();
					if (o.ok && o.body && o.body.data) {
						const t = o.body.data;
						e(O({
							models: t,
							utcTimeStamp: a
						}))
					} else e(D({
						error: o.error,
						utcTimeStamp: a
					}))
				}, S = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (Object(u.g)(o)) return;
					t(m());
					const a = await Object(c.e)(r(), e),
						i = Date.now();
					if (a.ok && a.body && a.body.data) {
						let s = a.body.data;
						const r = Object(u.b)(n());
						r && "pan" !== r && (s = s.map(h(r))), t(O({
							listingName: e,
							models: s,
							utcTimeStamp: i
						}))
					} else t(D({
						error: a.error,
						utcTimeStamp: i
					}))
				}, T = e => async t => {
					t(g(e))
				}, D = e => async t => {
					t(_(e))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/userSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = n("./src/reddit/constants/localStorage.ts"),
				a = n("./src/reddit/helpers/localStorage/index.ts");
			const c = Object(s.a)(r.B),
				i = e => async t => {
					await t(c(e)), t(l())
				}, d = () => async e => {
					const t = u();
					t && e(c(t))
				}, u = () => {
					return Object(a.m)(o.x) || void 0
				}, l = () => async (e, t) => {
					const n = t().publicAccessNetwork.userSettings;
					Object(a.O)(o.x, n)
				}
		},
		"./src/reddit/actions/redditEmbed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/me/index.ts"),
				o = n("./src/reddit/helpers/pageActionLoginRedirect.ts");
			const a = "REDDIT_EMBED_LOADED",
				c = "REDDIT_EMBED_FAILED",
				i = Object(s.a)("REDDIT_EMBED_PENDING"),
				d = Object(s.a)(a),
				u = Object(s.a)(c),
				l = (e, t) => async (e, n, s) => {
					let {
						apiContext: a
					} = s;
					const c = n();
					e(i());
					const l = await Object(r.a)(a());
					l.ok && l.body ? !t || l.body.account ? e(d(l.body)) : Object(o.a)(e, c) : e(u(l.error))
				}
		},
		"./src/reddit/actions/removalReasons/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return s
			})), n.d(t, "l", (function() {
				return r
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "r", (function() {
				return m
			})), n.d(t, "s", (function() {
				return O
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "o", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "t", (function() {
				return E
			}));
			const s = "REMOVALREASONS__LOAD_PENDING",
				r = "REMOVALREASONS__LOAD_SUCCESS",
				o = "REMOVALREASONS__LOAD_FAILED",
				a = "REMOVALREASONS__ADD_PENDING",
				c = "REMOVALREASONS__ADD_SUCCESS",
				i = "REMOVALREASONS__ADD_FAILED",
				d = "REMOVALREASONS__EDIT_PENDING",
				u = "REMOVALREASONS__EDIT_SUCCESS",
				l = "REMOVALREASONS__EDIT_FAILED",
				b = "REMOVALREASONS__DELETE_PENDING",
				p = "REMOVALREASONS__DELETE_SUCCESS",
				f = "REMOVALREASONS__DELETE_FAILED",
				m = "REMOVALREASONS__SUBMIT_PENDING",
				O = "REMOVALREASONS__SUBMIT_SUCCESS",
				g = "REMOVALREASONS__SUBMIT_FAILED",
				_ = "REMOVALREASONS__MESSAGE_PENDING",
				y = "REMOVALREASONS__MESSAGE_PRIVATE_SUCCESS",
				j = "REMOVALREASONS__MESSAGE_PUBLIC_SUCCESS",
				h = "REMOVALREASONS__MESSAGE_FAILED",
				E = "REMOVALREASONS__REMOVEDITEMS_SELECTED"
		},
		"./src/reddit/actions/reportFlow.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "j", (function() {
				return P
			})), n.d(t, "g", (function() {
				return k
			})), n.d(t, "i", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/login.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/reportRules.ts"),
				i = n("./src/reddit/actions/subreddit.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/actions/users.ts"),
				l = n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"),
				b = n("./src/reddit/endpoints/post/index.tsx"),
				p = n("./src/reddit/helpers/isComment.ts"),
				f = n("./src/reddit/helpers/isPost.ts"),
				m = n("./src/reddit/models/Post/index.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/posts.ts"),
				_ = n("./src/reddit/selectors/user.ts");
			const y = "REPORT__PENDING",
				j = "REPORT__LOADED",
				h = "REPORT__FAILED",
				E = Object(r.a)(y),
				I = Object(r.a)(j),
				v = Object(r.a)(h),
				S = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const c = e.id,
						i = r(),
						u = i.reportFlow.api.pending[c],
						l = i.reportFlow.userIsMod;
					if (u) return;
					n(E({
						id: c
					}));
					const p = await Object(b.m)(a(), e),
						f = "error-report-".concat(c);
					if (p.ok) n(I({
						id: c
					})), n(d.f(f)), !t.isAbuseOfReportButton && l && n(L());
					else {
						n(v({
							id: c
						}));
						const r = p.error && p.error.fields && p.error.fields.length ? p.error.fields[0].msg : "";
						n(d.e({
							id: f,
							kind: O.b.Error,
							text: r || s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: S(e, t)
						}))
					}
				}, T = "REPORT_FLOW__TARGET_SET", D = "REPORT_FLOW__OPENED_FROM_MODAL_PAGE", C = "REPORT_FLOW__OPEN_CATEGORY", w = Object(r.a)(T), A = Object(r.a)(D), R = Object(r.a)(C), P = (e, t, n, s) => async (r, d, l) => {
					let {
						apiContext: b
					} = l;
					const O = d(),
						y = Object(p.a)(e),
						j = Object(f.a)(e);
					if (!j && !y) return;
					const h = y ? O.comments.models[e] : O.posts.models[e];
					if (!h) return;
					if (!Object(_.H)(d())) return r(Object(o.h)()), void r(Object(a.k)({
						actionSource: a.a.Report,
						redirectUrl: h.permalink
					}));
					r(Object(u.y)(h.author));
					const E = Object(g.bb)(O, {
							postId: y ? O.comments.models[e].postId : O.posts.models[e].id
						}),
						I = n || j && Object(m.i)(h) || y && U(h, O);
					I || O.reportRules.sitewideRules && O.reportRules.sitewideRules.length || r(Object(c.d)()), !I || O.reportRules.liveStreamingRules && O.reportRules.liveStreamingRules.length || r(Object(c.c)()), E && r(Object(i.o)(E.name, E.type)), r(w(e)), r(A(!!t)), s && r(R(s)), E && r(N(E.name))
				}, k = "REPORT_FLOW__USER_IS_MOD_SET", x = Object(r.a)(k), N = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = await Object(l.a)(r());
					t(x(o.ok && !!o.body[e]))
				}, L = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					e(w(null))
				}, U = (e, t) => {
					const n = e.postId,
						s = n && t.posts.models[n];
					return !!s && Object(m.i)(s)
				}
		},
		"./src/reddit/actions/reportPageRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "REPORT_PAGE_RULES__LOADED"
		},
		"./src/reddit/actions/reportRules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "c", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			const d = "SITEWIDE_RULES_LOADED",
				u = "LIVESTREAMING_RULES_LOADED",
				l = Object(r.a)(d),
				b = Object(r.a)(u),
				p = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					if (!t().user) return;
					const r = await (e => Object(a.b)(Object(c.a)(e, [i.a]), {
						endpoint: "".concat(e.apiUrl, "/api/sitewide_rules.json"),
						method: o.ab.GET
					}))(s());
					if (r.ok) {
						const t = r.body,
							n = m(t.sitewide_rules);
						e(l(n))
					}
				}, f = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					if (!t().user) return;
					const r = await (e => Object(a.b)(Object(c.a)(e, [i.a]), {
						endpoint: "".concat(e.apiUrl, "/api/livestream_rules.json"),
						method: o.ab.GET
					}))(s());
					if (r.ok) {
						const t = r.body,
							n = m(t.livestream_rules);
						e(b(n))
					}
				}, m = e => {
					let t = [];
					if (e && e.length > 2) {
						const n = {
							reasonTextToShow: s.fbt._("It's spam or abuse", null, {
								hk: "21rHqk"
							}),
							nextStepReasons: [e[0], e[1], e[2]]
						};
						t.push(n), t = t.concat(e.slice(3))
					}
					return t
				}
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "m", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "r", (function() {
				return y
			})), n.d(t, "u", (function() {
				return j
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "v", (function() {
				return I
			})), n.d(t, "s", (function() {
				return v
			})), n.d(t, "x", (function() {
				return S
			})), n.d(t, "w", (function() {
				return T
			})), n.d(t, "t", (function() {
				return D
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = "SCHEDULED_POSTS_REQUESTED",
				o = "SCHEDULED_POSTS_LOADED",
				a = "STANDALONE_SCHEDULED_POSTS_LOADED",
				c = "RECURRING_SCHEDULED_POSTS_LOADED",
				i = "SCHEDULED_POSTS_FAILED",
				d = "SCHEDULED_POST_CREATION_SUCCEEDED",
				u = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				l = "SCHEDULED_POST_MUTATE_REQUESTED",
				b = "SCHEDULED_POST_MUTATE_FAILED",
				p = "STANDALONE_POST_MUTATE_SUCCESS",
				f = "RECURRING_POST_MUTATE_SUCCESS",
				m = "RECURRING_POST__EDIT_MODAL_LOAD",
				O = "RECURRING_POST__EDIT_LOAD",
				g = "STANDALONE_POST__EDIT_LOAD",
				_ = "SCHEDULED_POST__DELETE_SUCCESS",
				y = () => s.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				j = () => s.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				h = () => s.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				E = () => s.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				I = () => s.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				v = () => s.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				S = () => s.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				}),
				T = () => s.fbt._("Successfully edited scheduled post!", null, {
					hk: "HfGcT"
				}),
				D = () => s.fbt._("Failed to update scheduled post", null, {
					hk: "2zBuRu"
				})
		},
		"./src/reddit/actions/search.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return j
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "h", (function() {
				return A
			})), n.d(t, "g", (function() {
				return R
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "i", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeSearchKey/index.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/parameters.ts"),
				l = n("./src/reddit/actions/pages/subreddit.ts"),
				b = n("./src/reddit/endpoints/page/search.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			var O = async (e, t) => Object(p.b)(Object(f.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/related_queries_v1.json?query=").concat(t),
				method: a.ab.GET
			}), g = n("./src/reddit/models/Toast/index.ts"), _ = n("./src/reddit/selectors/searchResults.ts"), y = n("./src/reddit/selectors/user.ts");
			const j = "SEARCH__MORE_RESULTS_PENDING",
				h = "SEARCH__MORE_RESULTS_RECEIVED",
				E = "SEARCH__MORE_RESULTS_FAILED",
				I = "SEARCH__RELATED_QUERIES_RECEIVED",
				v = "SEARCH__UPDATE_SEARCH_QUERY",
				S = Object(c.a)(v),
				T = Object(c.a)(j),
				D = Object(c.a)(h),
				C = Object(c.a)(E),
				w = Object(c.a)(I),
				A = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = Object(_.g)(o, e);
					if (a && a.length > 0) return;
					const c = await O(r(), e);
					if (c.ok) {
						const n = (e => ({
							relatedQueries: e.body.related_queries
						}))(c);
						t(w({
							query: e,
							relatedQueries: n.relatedQueries
						}))
					}
				}, R = e => async (t, n, r) => {
					let {
						apiContext: c
					} = r;
					const p = n(),
						{
							queryParams: f
						} = p.platform.currentPage,
						m = Object(l.e)(f, Object(y.V)(p)),
						O = p.platform.currentPage.urlParams.subredditName || p.platform.currentPage.urlParams.multiredditName,
						{
							username: _
						} = p.platform.currentPage.urlParams,
						j = m || o()(f, u.q),
						h = Object(i.c)(j),
						E = Object.assign({}, h, {
							sort: h.category ? a.Ib.Relevance : h.sort,
							t: h.category ? a.Pb.DAY : h.t
						}),
						I = Object(i.b)(O, _, E);
					let v;
					if (e.indexOf(a.Kb.Posts) > -1) {
						const e = p.listings.postOrder.loadMore[I];
						if (!e) return;
						const t = p.listings.postOrder.api.pending[I],
							n = p.listings.postOrder.fetchedTokens,
							s = n[I] && n[I][e.token];
						if (t || s) return;
						v = e.token
					} else {
						if (!(e.indexOf(a.Kb.Subreddits) > -1 || e.indexOf(a.Kb.Users) > -1)) throw new Error("Should not attempt to fetch more results without a search type"); {
							const e = p.listings.listingOrder.loadMore[I];
							if (!e) return;
							const t = p.listings.listingOrder.api.pending[I],
								n = p.listings.listingOrder.fetchedTokens,
								s = n[I] && n[I][e.token];
							if (t || s) return;
							v = e.token
						}
					}
					const S = "error-".concat(I);
					t(T({
						fetchedToken: v,
						key: I,
						type: e
					}));
					const w = await Object(b.a)(c(), O, _, Object.assign({}, E, {
						after: v,
						type: (h.type || []).join(","),
						b: !0
					}));
					w.ok ? (t(D(Object.assign({
						key: I,
						fetchedToken: v,
						meta: p.meta,
						subredditOrMultiName: O,
						type: e
					}, w.body))), t(d.f(S))) : (t(C(Object.assign({
						key: I,
						error: w.error,
						fetchedToken: v,
						meta: p.meta,
						type: e
					}, w.body))), t(d.e({
						id: S,
						kind: g.b.Error,
						text: s.fbt._("Sorry, we couldn't load more search results.", null, {
							hk: "3IDePs"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: R(e)
					})))
				}, P = "SEARCH__TYPEAHEAD_SUCCESS", k = Object(c.a)(P)
		},
		"./src/reddit/actions/search/trending.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return O
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./node_modules/uuid/v4.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				c = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/extractQueryParams/index.ts"));
			var i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				l = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				b = n("./src/reddit/models/Search/index.ts");
			var p = e => {
				const t = {
					withAds: 1,
					ad: Object(c.a)(window.location.href).get("ad")
				};
				return Object(i.b)(Object(d.a)(e, [u.a]), {
					endpoint: "".concat(e.apiUrl, "/api/trending_searches_v1.json"),
					method: a.ab.GET,
					data: t
				})
			};
			const f = "PAGE__TRENDING_SEARCHES_LOADED",
				m = Object(s.a)(f),
				O = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = await p(s());
					if (r.ok) {
						const t = (e => {
							const t = [];
							if (e.body && e.body.trending_searches) {
								const n = e.body.trending_searches.length;
								for (let s = 0; s < n; s++) {
									const n = e.body.trending_searches[s],
										r = n.results.data.children.length > 0 ? n.results.data.children[0].data : null,
										a = {
											id: o()(),
											post: r ? Object(l.a)(r) : null,
											rawQuery: n.query_string,
											searchQuery: n.display_string,
											section: b.c.trending,
											isWhitelisted: n.is_subreddit_whitelisted,
											subredditInfo: r ? {
												icon: r.sr_detail.community_icon || r.sr_detail.icon_img,
												displayText: r.sr_detail.display_name_prefixed
											} : null,
											subredditOccurrences: n.subreddit_occurences - 1,
											type: b.b.text
										};
									t.push(a)
								}
							}
							return t
						})(r);
						return e(m({
							items: t
						})), t
					}
					return null
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "d", (function() {
				return g
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/loadWithRetries/index.ts");
			var o = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/graphql/operations/SubredditLinks.json");
			const c = e => ({
				communityIcon: e.styles && e.styles.icon || void 0,
				iconUrl: e.styles && e.styles.legacyIcon && e.styles.legacyIcon.url || void 0,
				id: e.id,
				isNSFW: e.isNSFW || !1,
				isSubscribed: e.isSubscribed,
				name: e.name,
				primaryColor: e.styles && e.styles.primaryColor || void 0,
				subscribers: e.subscribers,
				type: "subreddit"
			});
			var i = e => ({
					subreddits: e.data.subredditInfoById.linkedSubreddits ? e.data.subredditInfoById.linkedSubreddits.map(c) : []
				}),
				d = n("./src/reddit/selectors/seo/linksModule.ts");
			const u = "FRONTPAGE_LINKS__REQUEST_LOADED",
				l = "SUBREDDIT_LINKS_LOADED",
				b = Object(s.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				p = Object(s.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				f = Object(s.a)(u),
				m = Object(s.a)(l),
				O = () => async e => {
					e(b());
					const t = await (async () => (await Object(r.a)(() => n.e("FrontpageLinks").then(n.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default)();
					e(t ? f(t) : p())
				}, g = (e, t) => async (n, s, r) => {
					let {
						gqlContext: c
					} = r;
					if (e) {
						if (Object(d.c)(s(), {
								subredditId: e
							})) return;
						const r = await ((e, t) => Object(o.a)(e, Object.assign({}, a, {
							variables: t
						})))(c(), {
							subredditId: e,
							includeSubreddits: !0,
							subredditsLimit: t || 5
						});
						if (r.ok) {
							const t = i(r.body);
							t && n(m({
								id: e,
								data: t
							}))
						}
					}
				}
		},
		"./src/reddit/actions/shortcuts/active.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/shortcuts/constants.ts");
			const o = Object(s.a)(r.a),
				a = Object(s.a)(r.b)
		},
		"./src/reddit/actions/shortcuts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "SHORTCUTS__ACTIVE_COMMENT_SET",
				r = "SHORTCUTS__ACTIVE_POST_SET"
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./src/reddit/constants/shortcuts.ts"),
				r = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = n("./src/reddit/helpers/routeKey/index.ts");
			const a = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const n = t.routeMatch,
						s = Object(r.a)(e);
					return Object(o.b)(n, e, s)
				},
				c = e => {
					const t = document.getElementById(e);
					t && t.focus()
				},
				i = e => {
					const t = document.getElementById(e),
						n = window.scrollX,
						s = window.scrollY;
					t && (t.focus(), window.scrollTo(n, s))
				},
				d = () => {
					i(s.b)
				}
		},
		"./src/reddit/actions/sso/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "LINKED_IDENTITY__ADD",
				r = "LINKED_IDENTITY__REMOVE"
		},
		"./src/reddit/actions/streaming/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "SUBREDDIT__STREAMING_MOD_SETTINGS_LOADED"
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return s
			})), n.d(t, "k", (function() {
				return r
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "m", (function() {
				return O
			}));
			const s = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				a = "SUBREDDIT__STYLES_PENDING",
				c = "SUBREDDIT__STYLES_LOADED",
				i = "SUBREDDIT__STYLES_FAILED",
				d = "STRUCTURED_STYLES__DRAFT_REPLACED",
				u = "STRUCTURED_STYLES__DRAFT_UPDATED",
				l = "STRUCTURED_STYLES__EDITING_STOPPED",
				b = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				f = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				m = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				O = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return N
			})), n.d(t, "k", (function() {
				return M
			})), n.d(t, "j", (function() {
				return q
			})), n.d(t, "e", (function() {
				return K
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "g", (function() {
				return Q
			})), n.d(t, "c", (function() {
				return J
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "b", (function() {
				return $
			})), n.d(t, "m", (function() {
				return ee
			})), n.d(t, "a", (function() {
				return te
			})), n.d(t, "h", (function() {
				return ne
			})), n.d(t, "i", (function() {
				return se
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				a = n.n(o),
				c = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/lib/filterQueryParams/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/apiRequestState.ts"),
				l = n("./src/reddit/actions/imageUploads.ts"),
				b = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				f = e => Object.assign({}, e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				}, e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				}, e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				}, e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}),
				m = n("./src/reddit/selectors/postFlair.ts"),
				O = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const _ = Object(d.a)(g.c),
				y = Object(d.a)(g.b),
				j = Object(d.a)(g.a);
			var h = n("./src/reddit/actions/widgets/index.ts"),
				E = n("./src/reddit/constants/modals.ts"),
				I = n("./src/reddit/helpers/getGenericUploadError.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				S = n("./src/reddit/helpers/media/index.ts"),
				T = n("./src/reddit/models/Image/index.tsx"),
				D = n("./src/reddit/models/StructuredStyles/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				w = n("./src/reddit/selectors/platform.ts"),
				A = n("./src/reddit/selectors/structuredStyles.ts"),
				R = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/helpers/trackers/blade.ts"),
				k = n("./src/telemetry/index.ts"),
				x = n("./src/reddit/actions/structuredStyles/constants.ts");
			const N = Object(d.a)(x.m),
				L = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				U = e => {
					const t = Object.assign({}, e);
					return Object.keys(e).forEach(n => {
						L[n] && !e[n] && L[n].forEach(e => t[e] = null)
					}), t
				},
				M = (e, t, n, s) => async (r, o, a) => {
					const {
						apiContext: c
					} = a, i = o(), d = U(t), b = i.structuredStyles.models[e];
					let f;
					for (const e in d)
						if (d[e] !== b[e]) {
							f = !0;
							break
						} if (!f) return;
					r(Object(u.h)(s));
					const m = Object(P.i)(n)(i);
					let g = null,
						_ = null;
					try {
						(g = await Object(l.f)(o(), T.a.StructuredStyles)) && (_ = Object(l.m)(g)(r, o, a))
					} catch (E) {
						const e = Object(I.a)("webSocket");
						return void r(Object(u.f)(s, e))
					}
					const y = Object(O.Q)(i, {
							subredditId: e
						}).name,
						j = await p.e(c(), y, d),
						h = {};
					if (j.ok) {
						if (_) try {
							await _
						} catch (E) {}
						const n = Object(A.g)(o(), {
							apiRequestId: s
						});
						for (const e in n)
							if (e in t) {
								const t = Object(A.h)(o(), {
									name: e
								});
								t && Object(T.j)(t) && (h[e] = n[e])
							} Object.keys(h).length && r(H(h)), r(Object(u.e)(s)), r(N({
							subredditId: e,
							styles: Object.assign({}, d, h)
						}))
					} else g && g.websocket.close(), r(Object(u.f)(s, j.error));
					Object(k.a)(Object.assign({}, m, {
						actionInfo: Object.assign({}, m.actionInfo, {
							success: j.ok
						})
					}))
				}, F = Object(d.a)(x.l), G = Object(d.a)(x.k), B = Object(d.a)(x.j), q = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(F({
						subredditId: e
					}));
					const o = Object(O.Q)(n(), {
							subredditId: e
						}).name,
						a = await p.f(r(), o);
					if (a.ok) {
						const s = n().structuredStyles.models[e],
							r = s ? s.mobileKeyColor : null;
						t(G({
							subredditId: e,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else t(B(Object.assign({
						subredditId: e
					}, a.error)))
				}, V = Object(d.a)(x.d), K = e => async (t, n, s) => {
					const r = n(),
						o = r.structuredStyles.models[e] || {},
						a = Object(R.S)(r);
					t(V({
						isNightmodeOn: a,
						styles: o,
						subredditId: e
					})), ce(e, !1)(t, n, s), (e => async (t, n, s) => {
						let {
							gqlContext: r
						} = s;
						const o = n(),
							a = Object(O.Q)(o, {
								subredditId: e
							});
						if (!a) return;
						const c = Object(m.d)(o, {
								subredditId: e
							}),
							i = c && c.templateIds;
						if (!i || !i.length) return;
						t(_({
							subredditId: e
						}));
						const d = await Object(p.a)(r(), a.name, i);
						if (d.ok) {
							const n = {};
							if (d.body) {
								const {
									data: e
								} = d.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) n[t.id] = f(t)
							}
							t(y({
								subredditId: e,
								templates: n
							}))
						} else t(j({
							subredditId: e,
							error: d.error
						}))
					})(e)(t, n, s), Object(h.g)(e, !1)(t, n, s)
				}, H = Object(d.a)(x.c), W = e => async (t, n, s) => {
					const r = U(e),
						o = n();
					for (const e in r)
						if (Object(D.l)(e))
							if (r[e]) {
								if ("string" != typeof r[e]) {
									const o = r[e],
										a = await Object(T.e)(o);
									Q(e, a)(t, n, s), r[e] = ""
								}
							} else {
								const n = Object(A.h)(o, {
									name: e
								});
								n && t(Object(l.h)(n))
							} t(H(r))
				}, Y = Object(d.a)(x.f), Q = (e, t, n) => async (s, r, o) => {
					const a = r(),
						c = n || a.structuredStyles.isEditing,
						i = Object(O.Q)(a, {
							subredditId: c
						}).name;
					s(Y({
						imageKey: e,
						uploadId: t.id
					})), s(Object(l.k)(t));
					const d = await p.d(o.apiContext(), i, t.file.name, e, await Object(S.g)(t.file));
					try {
						const n = await Object(l.g)(r(), d, t, T.a.StructuredStyles);
						if (n) {
							const t = n.url;
							s(Object(l.j)(n)), s(H({
								[e]: t
							}))
						}
					} catch (u) {
						if (u instanceof Error) throw u;
						s(Object(l.i)(u))
					}
				}, z = Object(d.a)(x.b), J = (e, t, n) => async (s, o, c) => {
					const i = o(),
						d = i.structuredStyles.models[e] || {},
						u = i.structuredStyles.draft,
						l = Object(P.h)(t)(i);
					if (n) {
						const t = a()(d, n),
							o = r()(u, n),
							c = Object.assign({}, o, t);
						s(z({
							subredditId: e,
							styles: c
						}))
					} else {
						s(z({
							subredditId: e,
							styles: d
						}))
					}
					Object(k.a)(l)
				}, X = Object(d.a)(x.e), Z = () => async (e, t, n) => {
					const s = t(),
						r = Object(R.T)(s),
						o = !!Object(w.a)(s);
					if (e(X({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: a
					} = s.platform.currentPage;
					a && e(Object(c.c)(Object(i.a)(a, ["styling", "route"])))
				}, $ = Object(d.a)(x.a), ee = Object(d.a)(x.n), te = () => async e => e(Z()), ne = e => async (t, n) => {
					const s = n(),
						r = Object(A.j)(s);
					!Object(C.b)(E.a.BLADE_UNSAVED_CHANGES)(s) && r && (Object(A.a)(s, {
						subredditId: e
					}) ? t(Object(b.i)(E.a.BLADE_UNSAVED_CHANGES)) : t(te()))
				}, se = e => async (t, n) => {
					const s = n();
					Object(A.j)(s) || t(Object(R.S)(s) ? Object(b.i)(E.a.BLADE_NIGHTMODE) : K(e))
				}, re = Object(d.a)(x.i), oe = Object(d.a)(x.h), ae = Object(d.a)(x.g), ce = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o,
						apiContext: a
					} = r;
					n(re({
						subredditId: e
					}));
					const c = Object(O.Q)(s(), {
						subredditId: e
					});
					if (!c) return;
					if (!t) {
						const s = await p.c(a(), c.name, t);
						if (s.ok) {
							const t = s.body,
								r = t.data ? t.data.style : {};
							n(oe({
								subredditId: e,
								styles: r
							}))
						} else n(ae(Object.assign({
							subredditId: e
						}, s.error)));
						return
					}
					const i = await p.b(o(), c.name);
					if (i.ok) {
						let t = {};
						if (i.body) {
							const {
								data: e
							} = i.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(v.a)(e.subreddit.styles))
						}
						n(oe({
							subredditId: e,
							styles: t
						}))
					} else n(ae(Object.assign({
						subredditId: e
					}, i.error)))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return K
			})), n.d(t, "l", (function() {
				return H
			})), n.d(t, "k", (function() {
				return W
			})), n.d(t, "j", (function() {
				return Y
			})), n.d(t, "i", (function() {
				return Q
			})), n.d(t, "h", (function() {
				return z
			})), n.d(t, "d", (function() {
				return J
			})), n.d(t, "p", (function() {
				return ee
			})), n.d(t, "o", (function() {
				return re
			})), n.d(t, "r", (function() {
				return ce
			})), n.d(t, "g", (function() {
				return ie
			})), n.d(t, "f", (function() {
				return de
			})), n.d(t, "e", (function() {
				return ue
			})), n.d(t, "q", (function() {
				return fe
			})), n.d(t, "b", (function() {
				return me
			})), n.d(t, "c", (function() {
				return Oe
			})), n.d(t, "a", (function() {
				return ge
			})), n.d(t, "t", (function() {
				return he
			})), n.d(t, "n", (function() {
				return Ee
			})), n.d(t, "s", (function() {
				return Ie
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/listingSort/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/makeListingKey/index.ts"),
				u = n("./src/reddit/actions/economics/helpers/async.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/actions/oldSiteRules.ts"),
				p = n("./src/reddit/actions/pages/subreddit.ts"),
				f = n("./src/reddit/actions/preferences.ts"),
				m = n("./src/reddit/actions/subredditRules/constants.ts"),
				O = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/constants/modals.ts"),
				_ = n("./src/reddit/constants/parameters.ts"),
				y = n("./src/reddit/constants/postLayout.ts"),
				j = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/endpoints/governance/posts.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				I = n("./src/lib/omitHeaders/index.ts"),
				v = n("./src/reddit/constants/headers.ts"),
				S = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var T = n("./src/reddit/endpoints/modQueue/index.ts"),
				D = n("./src/reddit/endpoints/page/subredditPage.ts"),
				C = n("./src/reddit/endpoints/subreddit/about.ts"),
				w = n("./src/reddit/endpoints/subreddit/rules.ts"),
				A = n("./src/reddit/endpoints/user/preferences.ts"),
				R = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				P = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				N = n("./src/reddit/models/Subreddit/index.ts"),
				L = n("./src/reddit/models/Toast/index.ts"),
				U = n("./src/reddit/models/User/index.ts"),
				M = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				F = n("./src/reddit/selectors/oldSiteRules.ts"),
				G = n("./src/reddit/selectors/profile.ts"),
				B = n("./src/reddit/selectors/subreddit.ts"),
				q = n("./src/reddit/selectors/user.ts");
			const V = {},
				K = "SUBREDDIT__MODEL_SUCCEEDED",
				H = "SUBREDDIT__MODEL_PENDING",
				W = "SUBREDDIT__MODEL_FAILED",
				Y = "SUBREDDIT__MORE_POSTS_PENDING",
				Q = "SUBREDDIT__MORE_POSTS_LOADED",
				z = "SUBREDDIT__MORE_POSTS_FAILED",
				J = "SUBREDDIT__META_FILTER_TOGGLED",
				X = Object(i.a)(Y),
				Z = Object(i.a)(Q),
				$ = Object(i.a)(z),
				ee = Object(i.a)(J),
				te = Object(i.a)(m.b),
				ne = Object(i.a)(m.c),
				se = Object(i.a)(m.a),
				re = (e, t) => async (n, s) => {
					await (t === N.c.User ? n(oe(e)) : n(ae(e))), 0 === Object(F.a)(s()).length && n(Object(b.b)())
				}, oe = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = Object(G.m)(n(), e),
						a = await Object(w.c)(r(), e);
					if (a.ok) {
						const e = a.body;
						t(te({
							rules: e,
							subredditId: o
						}))
					}
				}, ae = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const a = Object(B.E)(n(), e);
					t(ne());
					const c = await Object(w.b)(o(), e);
					if (c.ok) {
						const e = c.body;
						t(te({
							rules: e,
							subredditId: a
						}))
					} else {
						t(se());
						const n = "error-block-".concat(e);
						t(O.e({
							id: n,
							kind: L.b.Error,
							text: s.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, ce = e => async (t, n, s) => {
					let {
						apiContext: r,
						gqlContext: a
					} = s;
					const {
						subredditName: i
					} = e;
					let l = e.t;
					const b = n(),
						p = Object(P.a)(e, b),
						f = b.platform.currentPage ? b.platform.currentPage.queryParams : {},
						m = Object(d.a)(i, p, Object.assign({
							t: l
						}, f)),
						O = b.listings.postOrder.loadMore[m],
						g = b.listings.postOrder.listingSort[m];
					let E = p;
					if (g && !E) {
						const e = Object(c.d)(g.sort);
						E = e.sort, l = e.timeSort
					}
					const I = b.listings.postOrder.api.pending[m],
						{
							fetchedTokens: v
						} = b.listings.postOrder,
						S = !(!v[m] || !v[m][O.token]);
					if (I || S) return;
					t(X({
						key: m,
						fetchedToken: O.token
					}));
					const T = Object.assign({
						after: O.token,
						dist: O.dist,
						layout: y.e[Object(j.N)(b, {})],
						sort: E,
						t: l
					}, o()(f, [..._.k, _.g]));
					T[_.g] || (T[_.g] = b.user.prefs.geopopular || b.meta.country);
					const C = Object(M.a)(b) ? () => Object(D.b)(a(), Object(D.c)(b, i, Object.assign({}, T, {
							limit: y.a
						})), Object(q.O)(b)) : () => Object(D.a)(r(), i, T),
						w = await C(),
						A = Object.assign({}, w.body, Object(R.a)(b, m, w.body));
					if (w.ok) {
						let e;
						const s = A.postIds.filter(e => !!A.posts[e].isMeta),
							o = Object(B.E)(n(), i);
						if (s.length) {
							const t = await Object(h.a)(r(), o, s);
							t.ok && (e = t.body)
						}
						t(Z(Object.assign({
							fetchedToken: O.token,
							key: m,
							meta: b.meta,
							governance: e
						}, A))), await t(Object(u.a)({
							subredditId: o,
							postIds: A.postIds,
							skip: ["communityDetails", "subscription"]
						}))
					} else t($(Object.assign({
						error: w.error,
						fetchedToken: O.token,
						key: m
					}, A)))
				}, ie = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", de = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", ue = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", le = Object(i.a)(ie), be = Object(i.a)(de), pe = Object(i.a)(ue), fe = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subreddits.moderated.api.fetched) return;
					e(le());
					const o = await Object(T.b)(s(), a.eb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					o.ok ? e(be(o.body)) : e(pe({
						error: o.error
					}))
				}, me = "SUBREDDIT__ABOUT_PENDING", Oe = "SUBREDDIT__ABOUT_SUCCEEDED", ge = "SUBREDDIT__ABOUT_FAILED", _e = Object(i.a)(me), ye = Object(i.a)(Oe), je = Object(i.a)(ge), he = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (Object(B.w)(o, {
							subredditName: e
						}) || o.subreddits.api.about.error[e.toLowerCase()] || o.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(_e({
						subredditName: e
					}));
					const a = !Object(B.E)(o, e),
						c = await Object(C.a)(r(), e, a);
					if (c.ok) {
						const n = c.body.data.subreddit,
							s = Object(k.a)(n),
							r = a ? Object(x.a)(n) : void 0;
						t(ye({
							subredditName: e,
							subreddits: r ? {
								[r.id]: r
							} : void 0,
							data: s
						}))
					} else t(je({
						subredditName: e,
						error: c.error
					}))
				}, Ee = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: c
					} = o;
					const i = Object(B.E)(r(), e.substring(2)),
						d = Object(q.i)(r());
					if (d) {
						const r = Object(U.e)(d),
							o = t + "\n\n   *To approve this user*, visit [the approved users page for " + e + "](https://www.reddit.com/" + e + "/about/contributors?user=" + r + ') and click "ADD USER".\n    Approving this user gives them permission to ' + n + ". You can change these community restrictions from the [community settings](/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + r + "](/u/" + r + ") or reply to this message to start a conversation.",
							u = {
								to: "/".concat(e),
								subject: "I would like to join ".concat(e),
								text: o
							};
						if ((await ((e, t) => Object(E.b)(Object(I.a)(e, [v.a]), {
								endpoint: Object(S.a)("".concat(e.apiUrl, "/api/compose")),
								method: a.ab.POST,
								data: t
							}))(c(), u)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							s(Object(f.E)({
								subredditId: i,
								prefs: t
							})), Object(A.h)(i, t, c()), s(Object(l.i)(g.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, Ie = e => async (t, n) => {
					const s = n(),
						{
							subredditName: r
						} = e,
						o = e.t,
						a = Object(P.a)(e, s),
						c = s.platform.currentPage ? s.platform.currentPage.queryParams : V,
						i = Object(d.a)(r, a, Object.assign({
							t: o
						}, c)),
						u = Object.assign({
							t: o,
							sort: a
						}, c);
					await t(Object(p.i)(i, r, u, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "p", (function() {
				return i
			})), n.d(t, "o", (function() {
				return d
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "r", (function() {
				return y
			})), n.d(t, "q", (function() {
				return j
			})), n.d(t, "s", (function() {
				return h
			}));
			const s = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				a = "SUBREDDIT__POSTS_LOADED",
				c = "SUBREDDIT__POSTS_SET_FAILED",
				i = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				d = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				u = "SUBREDDIT__RANKINGS_PENDING",
				l = "SUBREDDIT__RANKINGS_LOADED",
				b = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				f = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				m = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				O = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				g = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				_ = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				y = "SUBREDDIT__EDIT_REQUESTED",
				j = "SUBREDDIT__EDIT_FAILED",
				h = "SUBREDDIT__EDIT_SUCCESS"
		},
		"./src/reddit/actions/subreddit/similarSubreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return O
			}));
			var s, r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/subreddit/constants.ts"),
				a = n("./src/reddit/endpoints/category/subreddits.ts"),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			! function(e) {
				e.Factorization = "factorization", e.CustomModRelevant = "custom_mod_relevant"
			}(s || (s = {}));
			var l = n("./src/reddit/selectors/subreddit.ts");
			const b = e => {
					let t = e.subredditIds.join(",");
					return e.count && (t += "--[count:'".concat(e.count, "']")), e.variant && (t += "--[variant:'".concat(e.variant, "']")), t.toLowerCase()
				},
				p = Object(r.a)(o.n),
				f = Object(r.a)(o.m),
				m = Object(r.a)(o.l),
				O = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						O = b(e),
						g = Object(l.t)(o, {
							key: O
						}),
						_ = Object(l.s)(o, {
							key: O
						});
					if (g || _.length > 0) return;
					t(p({
						key: O
					}));
					const y = await ((e, t) => Object(i.b)(Object(d.a)(e, [u.a]), {
						data: {
							sr_fullnames: t.subredditIds.join(","),
							limit: t.count,
							variant: t.variant
						},
						endpoint: "".concat(e.apiUrl, "/api/similar_subreddits.json"),
						method: c.ab.GET
					}))(r(), e);
					if (y.ok) {
						const e = Object(a.b)(y.body);
						t(f(Object.assign({
							key: O
						}, e)))
					} else {
						const e = y.error;
						t(m({
							key: O,
							error: e
						}))
					}
				}
		},
		"./src/reddit/actions/subreddit/subredditPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return C
			})), n.d(t, "a", (function() {
				return w
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeListingKey/index.ts"),
				a = n("./src/reddit/actions/otherDiscussions/constants.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				i = (n("./src/graphql/operations/OtherDiscussions.json"), n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts")),
				d = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				b = n("./src/reddit/models/Post/index.ts");
			var p = e => {
				let {
					getState: t,
					onFailure: n,
					onSuccess: s,
					postId: r,
					response: a
				} = e;
				if (!a.ok) return void n(a.error);
				const c = a.body,
					{
						post: p
					} = c && c.data,
					f = t(),
					m = Object(o.a)(r, null, {
						isOtherDiscussions: !0
					});
				let O;
				if (p) {
					const {
						otherDiscussions: e,
						otherDiscussionsCount: t
					} = p, {
						postFlair: n,
						postIds: s,
						posts: o,
						profiles: a,
						subreddits: c
					} = (e => {
						const t = {
								postFlair: {},
								postIds: [],
								posts: {},
								profiles: {},
								subreddits: {}
							},
							n = e => {
								const n = Object(d.d)(e);
								t.posts[n.id] = n;
								const {
									crosspostRoot: s
								} = e;
								if (s && s.type === b.a.Post && s.postInfo) {
									const e = Object(d.d)(s.postInfo);
									t.posts[e.id] = e
								}
								switch (e.__typename) {
									case b.f.ProfilePost:
										t.profiles[e.profile.id] || (t.profiles[e.profile.id] = Object(u.a)(e.profile));
										break;
									case b.f.SubredditPost:
										t.subreddits[e.subreddit.id] || (t.subreddits[e.subreddit.id] = Object(l.a)(e.subreddit)), t.postFlair[e.subreddit.id] || (t.postFlair[e.subreddit.id] = Object(i.a)(e.subreddit))
								}
								return n.id
							};
						if (e && e.edges)
							for (const {
									node: s
								} of e.edges) {
								const e = n(s);
								e && t.postIds.push(e)
							}
						return t
					})(e);
					O = {
						count: t,
						key: m,
						meta: f.meta,
						postFlair: n,
						postId: r,
						postIds: s,
						posts: o,
						profiles: a,
						subreddits: c
					}
				} else O = {
					count: 0,
					key: m,
					meta: f.meta,
					postFlair: {},
					postId: r,
					postIds: [],
					posts: {},
					profiles: {},
					subreddits: {}
				};
				s(O)
			};
			const f = Object(r.a)(a.a),
				m = Object(r.a)(a.b),
				O = Object(r.a)(a.c);
			var g = n("./src/reddit/actions/subreddit/constants.ts"),
				_ = n("./src/graphql/operations/PostFeedAndOtherDiscussions.json"),
				y = (n("./src/graphql/operations/SubredditPosts.json"), n("./src/graphql/operations/SubredditsPosts.json"));
			var j = n("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts");
			var h = e => {
					let {
						getState: t,
						onSuccess: n,
						onFailure: r,
						options: a,
						subreddit: c
					} = e;
					try {
						if (!c) return;
						const {
							posts: e
						} = c, r = t(), i = ((e, t) => {
							const {
								edges: n
							} = e, s = n.filter(e => (e => !e.node.crosspostRoot)(e) && ((e, t) => !t.hasOwnProperty(e.node.id))(e, t));
							return Object.assign({}, e, {
								edges: s
							})
						})(e, r.posts && r.posts.models);
						if (!i.edges.length) return;
						const d = Object(j.a)(i),
							{
								range: u,
								sort: l,
								subredditName: b
							} = a,
							p = Object(o.a)(b, s.M[l], {
								t: u
							}),
							f = (e => e.reduce((e, t) => (e[t.id] = t, e), {}))(d),
							m = d.map(e => e.id);
						n({
							dist: e.dist,
							key: p,
							meta: r.meta,
							postIds: m,
							posts: f
						})
					} catch (i) {
						r(i)
					}
				},
				E = n("./src/reddit/selectors/posts.ts"),
				I = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const v = Object(r.a)(g.h),
				S = Object(r.a)(g.g),
				T = Object(r.a)(g.p),
				D = Object(r.a)(g.o),
				C = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = (await ((e, t) => Object(c.a)(e, Object.assign({}, y, {
							variables: t
						})))(r(), e)).body,
						{
							subredditNames: a
						} = e,
						i = I(e, ["subredditNames"]),
						d = [];
					try {
						for (const e of o.data.subredditsInfoByNames) {
							const t = e.posts.edges[0];
							t && t.node.__typename === b.f.SubredditPost && h({
								getState: n,
								onFailure: e => {
									throw e
								},
								onSuccess: e => d.push(e),
								options: Object.assign({}, i, {
									subredditName: t.node.subreddit.name
								}),
								subreddit: e
							})
						}
						t(T(d))
					} catch (u) {
						t(D(u))
					}
				}, w = e => async (t, n, r) => {
					let {
						gqlContext: a
					} = r;
					const {
						includeOtherDiscussions: i,
						includePostFeed: d,
						postId: u,
						range: l,
						sort: b,
						subredditName: g
					} = e, y = Object(o.a)(u, null, {
						isOtherDiscussions: !0
					}), j = Object(E.H)(n(), {
						listingKey: y
					}), I = i && (!j || 0 === j.length), T = Object(o.a)(g, s.M[b], {
						t: l
					}), D = Object(E.H)(n(), {
						listingKey: T
					}), C = d && (!D || 0 === D.length);
					if (!I && !C) return;
					I && t(O({
						key: y
					}));
					const w = await ((e, t) => Object(c.a)(e, Object.assign({}, _, {
							variables: t
						})))(a(), e),
						A = w.body;
					I && p({
						getState: n,
						onFailure: e => t(f(e)),
						onSuccess: e => t(m(e)),
						postId: u,
						response: w
					}), C && h({
						getState: n,
						onFailure: e => t(S(e)),
						onSuccess: e => t(v(e)),
						options: e,
						subreddit: A.data.subreddit
					})
				}
		},
		"./src/reddit/actions/subredditAutocomplete.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return g
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/graphql/operations/SubredditTypeaheadSearch.json"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				a = (e, t) => Object(o.a)(e, Object.assign({}, r, {
					variables: t
				})),
				c = n("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts"),
				i = e => {
					let {
						allowedPostTypes: t,
						id: n,
						isCrosspostDestination: s,
						isNsfw: r,
						name: o,
						styles: a,
						subscribersCount: i
					} = e;
					return {
						allowedPostTypes: Object(c.a)(t),
						communityIcon: a && a.icon || "",
						icon: a && a.legacyIcon && a.legacyIcon.url || "",
						id: n,
						isCrosspostDestination: s,
						isNsfw: r,
						name: o,
						primaryColor: a && a.primaryColor || "",
						subscribers: i
					}
				},
				d = n("./src/reddit/helpers/name/index.ts"),
				u = n("./src/reddit/selectors/subredditAutocomplete.ts");
			const l = "SUBREDDIT_AUTOCOMPLETE__PENDING",
				b = "SUBREDDIT_AUTOCOMPLETE__LOADED",
				p = "SUBREDDIT_AUTOCOMPLETE__FAILED",
				f = Object(s.a)(l),
				m = Object(s.a)(b),
				O = Object(s.a)(p),
				g = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s, r) => {
						let {
							gqlContext: o
						} = r;
						const c = Object(d.f)(e);
						if (!c) return;
						const l = s(),
							b = l.subredditAutocomplete;
						if (b.api.pending[c] || b.models[c]) return;
						if (Object(u.b)(l, {
								substring: c
							})) return;
						n(f({
							key: c
						}));
						const p = await a(o(), {
							query: c,
							includeNsfw: t
						});
						if (p.ok) {
							const e = p.body.data.subredditTypeahead.subreddits.edges.map(e => i(e.node));
							n(m(Object.assign({
								key: c
							}, {
								key: c,
								subreddits: e
							})))
						} else n(O({
							key: c,
							error: p.error
						}))
					}
				}
		},
		"./src/reddit/actions/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "f", (function() {
				return E
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const u = e => ({
				public_description: e.publicDescription,
				name: e.name,
				type: e.type,
				over_18: e.over18,
				restrict_commenting: e.restrictCommenting,
				restrict_posting: e.restrictPosting,
				existing_tags: e.existingTags.join(","),
				new_tags: e.newTags.join(","),
				primary_tag: e.primaryTagId
			});
			var l = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/telemetry/index.ts");
			const f = "SUBREDDIT__CREATE_PENDING",
				m = "SUBREDDIT__CREATE_SUCCEEDED",
				O = "SUBREDDIT__CREATE_FAILED",
				g = "SUBREDDIT__CREATE_CLEARED",
				_ = Object(r.a)(f),
				y = Object(r.a)(m),
				j = Object(r.a)(O),
				h = Object(r.a)(g),
				E = e => async (t, n, r) => {
					let {
						apiContext: f
					} = r;
					const m = n(),
						{
							name: O,
							type: g
						} = e;
					if (Object(b.l)(m)) return;
					t(_({
						subredditName: O
					}));
					const h = await ((e, t) => Object(a.b)(Object(c.a)(e, [i.a]), {
						endpoint: Object(d.a)("".concat(e.apiUrl, "/api/v1/subreddit/create_subreddit")),
						method: o.ab.POST,
						data: u(t)
					}))(f(), e);
					if (h.ok) {
						const n = h.body,
							r = n.fullname;
						Object(p.a)(Object(l.c)(g, e, r)(m)), t(y({
							subredditName: O
						})), window.location.href = "".concat(s.a.redditUrl).concat(n.path, "new")
					} else h.error && Object(p.a)(Object(l.d)(h.error.type)(m)), t(j({
						subredditName: O,
						error: h.error
					}))
				}
		},
		"./src/reddit/actions/subredditCrosspostable.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return m
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/subscription/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const u = "SUBREDDIT_CROSSPOSTABLE__PENDING",
				l = "SUBREDDIT_CROSSPOSTABLE__LOADED",
				b = "SUBREDDIT_CROSSPOSTABLE__FAILED",
				p = (Object(s.a)(u), Object(s.a)(l)),
				f = Object(s.a)(b),
				m = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					await e(r.e());
					const {
						api: u,
						ids: l
					} = t().subreddits.crosspostable;
					if (u.pending || Object.keys(l).length) return;
					const b = await ((e, t) => Object(a.b)(Object(c.a)(e, [i.a]), {
						data: t,
						endpoint: "".concat(e.apiUrl, "/api/crosspostable_subreddits.json"),
						method: o.ab.GET
					}))(s(), {
						sr_detail: !1
					});
					if (b.ok) {
						const n = t(),
							s = b.body && b.body.length ? b.body.map(e => Object(d.E)(n, e)).filter(e => !!e).reduce((e, t) => (e[t] = !0, e), {}) : {};
						e(p({
							subredditIds: s
						}))
					} else e(f({
						error: b.error
					}))
				}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/config.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/models/Post/index.ts");
			var i = n("./src/reddit/models/Duplicates/index.ts"),
				d = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/selectors/profile.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			const b = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(s.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(s.a)(b)),
				f = (e, t) => async (n, s, b) => {
					let {
						apiContext: f
					} = b;
					const m = Object(l.Q)(s(), {
						subredditId: e
					}) || Object(u.p)(s(), {
						profileId: e
					});
					if (!m) return;
					const O = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(d.e)(m) ? r.Rb + m.name : m.name
						},
						g = await ((e, t, n) => Object(a.b)(e, {
							data: n,
							endpoint: "".concat(o.a.gatewayUrl, "/desktopapi/v1/duplicates/").concat(Object(c.n)(t)),
							method: r.ab.GET
						}))(f(), t, O);
					if (g.ok) {
						const s = g.body;
						n(p({
							distinguishKey: Object(i.a)(t, O),
							postIds: s.postIds,
							posts: s.posts,
							profiles: s.profiles,
							subreddits: s.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditMention/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			const s = "SUBREDDIT_MENTION_LOADED",
				r = "SUBREDDIT__MODEL_SUCCEEDED",
				o = "SUBREDDIT__MODEL_PENDING",
				a = "SUBREDDIT__MODEL_FAILED"
		},
		"./src/reddit/actions/subredditModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "J", (function() {
				return R
			})), n.d(t, "H", (function() {
				return P
			})), n.d(t, "G", (function() {
				return k
			})), n.d(t, "ib", (function() {
				return U
			})), n.d(t, "M", (function() {
				return M
			})), n.d(t, "L", (function() {
				return F
			})), n.d(t, "K", (function() {
				return G
			})), n.d(t, "jb", (function() {
				return K
			})), n.d(t, "I", (function() {
				return H
			})), n.d(t, "N", (function() {
				return W
			})), n.d(t, "ob", (function() {
				return z
			})), n.d(t, "hb", (function() {
				return J
			})), n.d(t, "e", (function() {
				return X
			})), n.d(t, "d", (function() {
				return Z
			})), n.d(t, "c", (function() {
				return $
			})), n.d(t, "V", (function() {
				return se
			})), n.d(t, "h", (function() {
				return re
			})), n.d(t, "g", (function() {
				return oe
			})), n.d(t, "f", (function() {
				return ae
			})), n.d(t, "W", (function() {
				return ue
			})), n.d(t, "b", (function() {
				return le
			})), n.d(t, "i", (function() {
				return be
			})), n.d(t, "U", (function() {
				return me
			})), n.d(t, "mb", (function() {
				return Oe
			})), n.d(t, "m", (function() {
				return ge
			})), n.d(t, "l", (function() {
				return _e
			})), n.d(t, "k", (function() {
				return ye
			})), n.d(t, "Z", (function() {
				return Ie
			})), n.d(t, "p", (function() {
				return ve
			})), n.d(t, "o", (function() {
				return Se
			})), n.d(t, "n", (function() {
				return Te
			})), n.d(t, "ab", (function() {
				return Ae
			})), n.d(t, "j", (function() {
				return Re
			})), n.d(t, "q", (function() {
				return Pe
			})), n.d(t, "Y", (function() {
				return Ne
			})), n.d(t, "nb", (function() {
				return Le
			})), n.d(t, "C", (function() {
				return Ue
			})), n.d(t, "B", (function() {
				return Me
			})), n.d(t, "A", (function() {
				return Fe
			})), n.d(t, "t", (function() {
				return Ve
			})), n.d(t, "s", (function() {
				return Ke
			})), n.d(t, "r", (function() {
				return He
			})), n.d(t, "fb", (function() {
				return ze
			})), n.d(t, "db", (function() {
				return Je
			})), n.d(t, "x", (function() {
				return Xe
			})), n.d(t, "w", (function() {
				return Ze
			})), n.d(t, "v", (function() {
				return $e
			})), n.d(t, "eb", (function() {
				return st
			})), n.d(t, "a", (function() {
				return rt
			})), n.d(t, "T", (function() {
				return it
			})), n.d(t, "Q", (function() {
				return dt
			})), n.d(t, "R", (function() {
				return pt
			})), n.d(t, "lb", (function() {
				return mt
			})), n.d(t, "u", (function() {
				return Ot
			})), n.d(t, "cb", (function() {
				return jt
			})), n.d(t, "F", (function() {
				return ht
			})), n.d(t, "E", (function() {
				return Et
			})), n.d(t, "D", (function() {
				return It
			})), n.d(t, "gb", (function() {
				return Dt
			})), n.d(t, "y", (function() {
				return Ct
			})), n.d(t, "O", (function() {
				return At
			})), n.d(t, "S", (function() {
				return Pt
			})), n.d(t, "z", (function() {
				return kt
			})), n.d(t, "bb", (function() {
				return Nt
			})), n.d(t, "P", (function() {
				return Lt
			})), n.d(t, "kb", (function() {
				return Gt
			})), n.d(t, "X", (function() {
				return Bt
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/apiRequestState.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/subreddit.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/modals.ts"),
				b = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			const O = (e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/contributors"),
				method: b.ab.GET,
				data: n
			});
			var g = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const _ = (e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
					endpoint: Object(g.a)("".concat(e.apiUrl, "/api/v1/").concat(t, "/banned")),
					method: b.ab.GET,
					data: n
				}),
				y = (e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators"),
					method: b.ab.GET,
					data: Object.assign({}, n, {
						count: 10
					})
				}),
				j = (e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators_invited"),
					method: b.ab.GET,
					data: Object.assign({}, n, {
						count: 50
					})
				}),
				h = (e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/muted"),
					method: b.ab.GET,
					data: n
				});
			var E = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				I = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				v = n("./src/reddit/models/SubredditModeration/index.ts"),
				S = n("./src/reddit/models/Toast/index.ts"),
				T = n("./src/reddit/models/User/index.ts"),
				D = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/subreddit.ts"),
				w = n("./src/reddit/selectors/subredditModeration.ts"),
				A = n("./src/reddit/selectors/user.ts");
			const R = "SUBREDDIT__MUTEDUSERS_PENDING",
				P = "SUBREDDIT__MUTEDUSERS_LOADED",
				k = "SUBREDDIT__MUTEDUSERS_FAILED",
				x = Object(a.a)(R),
				N = Object(a.a)(P),
				L = Object(a.a)(k),
				U = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const a = s(),
							c = t.after || "",
							i = Object(v.d)(e, c),
							d = a.muted.fetchedTokens[i];
						if (a.muted.api.pending[i] || d) return;
						n(x({
							subredditId: e,
							fetchedToken: c
						}));
						const u = a.subreddits.models[e].name,
							l = await h(o(), u, t);
						l.ok ? n(N(Object.assign({}, l.body, {
							fetchedToken: c
						}))) : n(L({
							subredditId: e,
							fetchedToken: c
						}))
					}
				},
				M = "SUBREDDIT_MUTEDUSERS_SEARCH_PENDING",
				F = "SUBREDDIT_MUTEDUSERS_SEARCH_LOADED",
				G = "SUBREDDIT_MUTEDUSERS_SEARCH_FAILED",
				B = Object(a.a)(M),
				q = Object(a.a)(F),
				V = Object(a.a)(G),
				K = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						c = {
							username: Object(E.a)(t)
						};
					n(B());
					const i = await h(o(), a, c);
					i.ok ? n(q(i.body)) : n(V(i.error))
				}, H = "SUBREDDIT_MUTEDUSERS_MUTED_SUCCESS", W = "SUBREDDIT_MUTEDUSERS_UNMUTED_SUCCESS", Y = Object(a.a)(H), Q = Object(a.a)(W), z = (e, t) => async (n, r, a) => {
					let {
						apiContext: c
					} = a;
					const i = r().subreddits.models[e].url,
						d = await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: b.ab.POST,
							data: {
								api_type: "json",
								id: n,
								type: "muted"
							}
						}))(c(), i, t);
					if (d.ok) n(Q({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(d, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, J = (e, t, n) => async (r, a, c) => {
					let {
						apiContext: i
					} = c;
					const d = a(),
						l = d.subreddits.models[e].url,
						O = d.subreddits.models[e].name;
					t = Object(E.a)(t);
					const g = await ((e, t, n, s) => Object(p.b)(Object(f.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: b.ab.POST,
						data: {
							api_type: "json",
							name: n,
							note: s,
							type: "muted"
						}
					}))(i(), l, t, n);
					if (g.ok) {
						const e = {
							username: t
						};
						r(Object(u.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Successfully muted a user", null, {
								hk: "2ypyuL"
							})
						}));
						const n = await h(i(), O, e);
						n.ok && r(Y(n.body))
					} else {
						const e = o()(g, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, X = "SUBREDDIT__APPROVEDSUBMITTERS_PENDING", Z = "SUBREDDIT__APPROVEDSUBMITTERS_LOADED", $ = "SUBREDDIT__APPROVEDSUBMITTERS_FAILED", ee = Object(a.a)(X), te = Object(a.a)(Z), ne = Object(a.a)($), se = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const a = s(),
							c = t.after || "",
							i = Object(v.d)(e, c),
							d = a.approvedSubmitters.fetchedTokens[i];
						if (a.approvedSubmitters.api.pending[i] || d) return;
						n(ee({
							subredditId: e,
							fetchedToken: c
						}));
						const u = a.subreddits.models[e].name,
							l = await O(o(), u, t);
						l.ok ? n(te(Object.assign({}, l.body, {
							fetchedToken: c
						}))) : n(ne({
							subredditId: e,
							fetchedToken: c
						}))
					}
				}, re = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_PENDING", oe = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_LOADED", ae = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_FAILED", ce = Object(a.a)(re), ie = Object(a.a)(oe), de = Object(a.a)(ae), ue = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						c = {
							username: Object(E.a)(t)
						};
					n(ce());
					const i = await O(o(), a, c);
					i.ok ? n(ie(i.body)) : n(de(i.error))
				}, le = "SUBREDDIT_APPROVEDSUBMITTERS_APPROVED_SUCCESS", be = "SUBREDDIT_APPROVEDSUBMITTERS_UNAPPROVED_SUCCESS", pe = Object(a.a)(le), fe = Object(a.a)(be), me = (e, t) => async (n, r, a) => {
					let {
						apiContext: c
					} = a;
					const i = r(),
						d = i.subreddits.models[e].url,
						l = i.subreddits.models[e].name;
					t = Object(E.a)(t);
					const g = await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: b.ab.POST,
						data: {
							api_type: "json",
							name: n,
							type: "contributor"
						}
					}))(c(), d, t);
					if (g.ok) {
						const e = {
							username: t
						};
						n(Object(u.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Successfully added an approved submitter", null, {
								hk: "4gruK7"
							})
						}));
						const r = await O(c(), l, e);
						r.ok && n(pe(r.body))
					} else {
						const e = o()(g, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Oe = (e, t) => async (n, r, a) => {
					let {
						apiContext: c
					} = a;
					const i = r().subreddits.models[e].url,
						d = await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: b.ab.POST,
							data: {
								api_type: "json",
								id: n,
								type: "contributor"
							}
						}))(c(), i, t);
					if (d.ok) n(fe({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(d, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, ge = "SUBREDDIT__BANNEDUSERS_PENDING", _e = "SUBREDDIT__BANNEDUSERS_LOADED", ye = "SUBREDDIT__BANNEDUSERS_FAILED", je = Object(a.a)(ge), he = Object(a.a)(_e), Ee = Object(a.a)(ye), Ie = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const a = s(),
							c = t.after || "",
							i = Object(v.d)(e, c),
							d = a.banned.fetchedTokens[i];
						if (a.banned.api.pending[i] || d) return;
						n(je({
							subredditId: e,
							fetchedToken: c
						}));
						const u = a.subreddits.models[e].name,
							l = await _(o(), u, t);
						l.ok ? n(he(Object.assign({}, l.body, {
							fetchedToken: c
						}))) : n(Ee({
							subredditId: e,
							fetchedToken: c
						}))
					}
				}, ve = "SUBREDDIT_BANNEDUSERS_SEARCH_PENDING", Se = "SUBREDDIT_BANNEDUSERS_SEARCH_LOADED", Te = "SUBREDDIT_BANNEDUSERS_SEARCH_FAILED", De = Object(a.a)(ve), Ce = Object(a.a)(Se), we = Object(a.a)(Te), Ae = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						c = {
							username: Object(E.a)(t)
						};
					n(De());
					const i = await _(o(), a, c);
					i.ok ? n(Ce(i.body)) : n(we(i.error))
				}, Re = "SUBREDDIT_BANNEDUSERS_BAN_SUCCESS", Pe = "SUBREDDIT_BANNEDUSERS_UNBAN_SUCCESS", ke = Object(a.a)(Re), xe = Object(a.a)(Pe), Ne = (e, t, n) => async (r, a, i) => {
					let {
						apiContext: d
					} = i;
					const l = a(),
						O = l.subreddits.models[e].url,
						g = l.subreddits.models[e].name;
					t.username = Object(E.a)(t.username), r(Object(c.h)(n));
					const y = await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: b.ab.POST,
						data: {
							api_type: "json",
							ban_reason: n.reason,
							ban_message: n.banMessage,
							duration: n.duration,
							name: n.username,
							note: n.modNote,
							ban_context: n.contextId,
							type: "banned"
						}
					}))(d(), O, t);
					if (y.ok) {
						r(Object(c.e)(n));
						const e = {
							username: t.username
						};
						r(Object(u.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Successfully banned a user", null, {
								hk: "1kORpS"
							})
						}));
						const o = await _(d(), g, e);
						o.ok && r(ke(o.body))
					} else {
						r(Object(c.f)(n, y.error));
						const e = o()(y, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Le = (e, t) => async (n, r, a) => {
					let {
						apiContext: c
					} = a;
					const i = r().subreddits.models[e].url,
						d = await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: b.ab.POST,
							data: {
								api_type: "json",
								id: n,
								type: "banned"
							}
						}))(c(), i, t);
					if (d.ok) n(xe({
						subredditId: e,
						userId: t
					})), n(Object(u.e)({
						kind: S.b.SuccessMod,
						text: s.fbt._("Successfully unbanned a user", null, {
							hk: "OgqK6"
						})
					}));
					else {
						const e = o()(d, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Ue = "SUBREDDIT__MODERATORS_PENDING", Me = "SUBREDDIT__MODERATORS_LOADED", Fe = "SUBREDDIT__MODERATORS_FAILED", Ge = Object(a.a)(Ue), Be = Object(a.a)(Me), qe = Object(a.a)(Fe), Ve = "SUBREDDIT__EDITABLEMODERATORS_PENDING", Ke = "SUBREDDIT__EDITABLEMODERATORS_LOADED", He = "SUBREDDIT__EDITABLEMODERATORS_FAILED", We = Object(a.a)(Ve), Ye = Object(a.a)(Ke), Qe = Object(a.a)(He), ze = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(C.Q)(a, {
							subredditId: e
						}).name,
						i = t && t.after ? t.after : "",
						d = t && t.before ? t.before : "",
						u = Object(v.d)(e, i, d),
						l = a.moderators.userOrder.data[u],
						b = a.moderators.userOrder.api.error[u];
					if (a.moderators.userOrder.api.pending[u] || l && !b) return;
					n(Ge({
						subredditId: e,
						key: u
					}));
					const p = await y(o(), c, t);
					if (p.ok) {
						const t = {
							key: u,
							response: p.body,
							subredditId: e
						};
						n(Be(t))
					} else {
						const t = {
							error: p.error,
							subredditId: e,
							key: u
						};
						n(qe(t))
					}
				}, Je = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(C.Q)(a, {
							subredditId: e
						}).name,
						i = t && t.afterEditable ? t.afterEditable : "",
						d = t && t.beforeEditable ? t.beforeEditable : "",
						u = Object(v.d)(e, i, d),
						l = a.moderators.editableUserOrder.data[u],
						O = a.moderators.editableUserOrder.api.error[u];
					if (a.moderators.editableUserOrder.api.pending[u] || l && !O) return;
					n(We({
						subredditId: e,
						key: u
					}));
					const g = Object.assign({}, t, {
							after: i,
							before: d
						}),
						_ = await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators_editable"),
							method: b.ab.GET,
							data: Object.assign({}, n, {
								count: 10
							})
						}))(o(), c, g);
					if (_.ok) {
						const t = {
							key: u,
							response: _.body,
							subredditId: e
						};
						n(Ye(t))
					} else {
						const t = {
							key: u,
							error: _.error,
							subredditId: e
						};
						n(Qe(t))
					}
				}, Xe = "SUBREDDIT__INVITEDMODERATORS_PENDING", Ze = "SUBREDDIT__INVITEDMODERATORS_LOADED", $e = "SUBREDDIT__INVITEDMODERATORS_FAILED", et = Object(a.a)(Xe), tt = Object(a.a)(Ze), nt = Object(a.a)($e), st = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = Object(C.Q)(o, {
							subredditId: e
						}).name;
					if (o.moderators.invitedModerators.api.pending) return;
					t(et());
					const c = await j(r(), a);
					if (c.ok) {
						const e = c.body;
						t(tt(e))
					} else t(nt(c.error))
				}, rt = "SUBREDDIT__ADDMODERATOR__SUCCESS", ot = Object(a.a)("SUBREDDIT__ADDMODERATOR_PENDING"), at = Object(a.a)(rt), ct = Object(a.a)("SUBREDDIT__ADDMODERATOR__FAILED"), it = (e, t, n) => async (r, o, a) => {
					let {
						apiContext: c
					} = a;
					const i = o(),
						d = Object(C.Q)(i, {
							subredditId: e
						}),
						l = d.name,
						O = d.url;
					t = Object(E.a)(t), r(ot());
					const g = Object(I.d)(n),
						_ = await ((e, t, n, s) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
							method: b.ab.POST,
							data: {
								name: n,
								type: "moderator_invite",
								permissions: s,
								api_type: "json"
							}
						}))(c(), O, t, g);
					if (_.ok) {
						const n = await j(c(), l, {
							username: t
						});
						if (_.ok) {
							const t = n.body,
								o = t.moderatorIds[0];
							i.moderators.invitedModerators.models[e][o] ? r(Object(u.e)({
								kind: S.b.SuccessCommunity,
								text: s.fbt._("That user is already invited", null, {
									hk: "R8YPV"
								})
							})) : (r(Object(u.e)({
								kind: S.b.SuccessMod,
								text: s.fbt._("Successfully added a moderator", null, {
									hk: "2ZdoIZ"
								})
							})), r(at(t)))
						}
					} else {
						const e = _.body.json && _.body.json.errors;
						e && e[0] && e[0][1] && r(Object(u.e)({
							kind: S.b.Error,
							text: e[0][1],
							duration: 3e3
						})), r(ct())
					}
				}, dt = "SUBREDDIT__REMOVEMODERATOR__SUCCESS", ut = Object(a.a)("SUBREDDIT__REMOVEMODERATOR_PENDING"), lt = Object(a.a)(dt), bt = Object(a.a)("SUBREDDIT__REMOVEMODERATOR__FAILED"), pt = "SUBREDDIT__RESIGNMODERATOR__SUCCESS", ft = Object(a.a)(pt), mt = (e, t, n, s) => async (r, o, a) => {
					let {
						apiContext: c
					} = a;
					const i = o(),
						d = i.subreddits.models[e].name,
						u = Object(v.d)(e, n, s);
					if (r(ut()), (await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl, "/api/unfriend"),
							method: b.ab.POST,
							data: {
								id: n,
								type: "moderator",
								r: t,
								api_type: "json"
							}
						}))(c(), d, t)).ok) {
						r(lt({
							subredditId: e,
							userId: t,
							key: u
						}));
						const n = Object(A.i)(i);
						n && n.id === t && r(ft({
							subredditId: e,
							userId: t
						}))
					} else r(bt())
				}, Ot = "SUBREDDIT__EDITMODERATOR__SUCCESS", gt = Object(a.a)("SUBREDDIT__EDITMODERATOR_PENDING"), _t = Object(a.a)(Ot), yt = Object(a.a)("SUBREDDIT__EDITMODERATOR__FAILED"), jt = (e, t, n, s) => async (r, o, a) => {
					let {
						apiContext: c
					} = a;
					const i = o().subreddits.models[e].url;
					r(gt());
					const d = Object(I.d)(n);
					if ((await ((e, t, n, s) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/setpermissions"),
							method: b.ab.POST,
							data: {
								name: n,
								type: "moderator",
								permissions: s,
								api_type: "json"
							}
						}))(c(), i, t, d)).ok) {
						r(_t({
							permissions: n,
							subredditId: e,
							userId: s
						}))
					} else r(yt())
				}, ht = "SUBREDDIT_MODERATORS_SEARCH_PENDING", Et = "SUBREDDIT_MODERATORS_SEARCH_LOADED", It = "SUBREDDIT_MODERATORS_SEARCH_FAILED", vt = Object(a.a)(ht), St = Object(a.a)(Et), Tt = Object(a.a)(It), Dt = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						c = {
							username: Object(E.a)(t)
						};
					n(vt());
					const i = await y(o(), a, c);
					i.ok ? n(St(i.body)) : n(Tt(i.error))
				}, Ct = "SUBREDDIT_MODERATORS_ACCEPT_INVITE_SUCCESS", wt = Object(a.a)(Ct), At = "SUBREDDIT_NEWMODERATORPERMISSIONS_LOADED", Rt = Object(a.a)(At), Pt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = o.user.account;
					if (!a) return;
					const c = o.subreddits.models[e],
						i = c.url,
						d = c.name;
					if ((await ((e, t) => Object(p.b)(Object(f.a)(e, [m.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/accept_moderator_invite"),
							method: b.ab.POST,
							data: {
								api_type: "json"
							}
						}))(r(), i)).ok) {
						t(wt({
							subredditId: e
						})), t(Je(e)), t(st(e)), t(ze(e));
						const n = {
								username: Object(T.e)(a)
							},
							s = await y(r(), d, n);
						if (s.ok) {
							const n = s.body.moderators[a.id];
							n && t(Rt({
								[e]: n.modPermissions
							}))
						}
					}
				}, kt = "SUBREDDIT_MODERATORS_DECLINE_INVITE_SUCCESS", xt = Object(a.a)(kt), Nt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().subreddits.models[e].name;
					(await ((e, t) => Object(p.b)(Object(f.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/decline_mod_invite"),
						method: b.ab.POST,
						data: {
							api_type: "json"
						}
					}))(r(), o)).ok && t(xt({
						subredditId: e
					}))
				}, Lt = "SUBREDDIT__REMOVEINVITEDMODERATOR__SUCCESS", Ut = Object(a.a)("SUBREDDIT__REMOVEINVITEDMODERATOR_PENDING"), Mt = Object(a.a)(Lt), Ft = Object(a.a)("SUBREDDIT__REMOVEINVITEDMODERATOR__FAILED"), Gt = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(C.Q)(a, {
							subredditId: e
						}).name;
					n(Ut()), (await ((e, t, n) => Object(p.b)(Object(f.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl, "/api/unfriend"),
						method: b.ab.POST,
						data: {
							id: n,
							type: "moderator_invite",
							r: t,
							api_type: "json"
						}
					}))(o(), c, t)).ok ? n(Mt({
						subredditId: e,
						userId: t
					})) : n(Ft())
				}, Bt = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s();
					await Promise.all([(async () => {
						if (!Object(D.b)(l.a.BAN_USER)(a) && !Object(C.N)(a, {
								subredditId: e
							})) {
							const t = Object(C.Q)(a, {
								subredditId: e
							});
							await n(Object(d.o)(t.name))
						}
					})(), (async () => {
						const s = Object(A.eb)(a, {
							userName: t
						});
						if (!s) return;
						const r = Object(w.m)(a, {
							subredditId: e
						});
						r && r[s.id] || await n(Ie(e, {
							username: t
						}))
					})()]), n(Object(i.i)(l.a.BAN_USER))
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			}));
			const s = "SUBREDDIT__RULES_LOADED",
				r = "SUBREDDIT__RULES_PENDING",
				o = "SUBREDDIT__RULES_FAILED",
				a = "SUBREDDIT__RULE_ADDED",
				c = "SUBREDDIT__RULE_EDITED",
				i = "SUBREDDIT__RULE_REMOVED",
				d = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "d", (function() {
				return T
			})), n.d(t, "b", (function() {
				return D
			})), n.d(t, "h", (function() {
				return R
			})), n.d(t, "g", (function() {
				return P
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/invert.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/pick.js"),
				c = n.n(a),
				i = n("./node_modules/lodash/xor.js"),
				d = n.n(i),
				u = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				b = n("./src/reddit/endpoints/subreddit/settings.ts"),
				p = n("./src/telemetry/index.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				m = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/models/User/index.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/selectors/user.ts"),
				j = n("./src/reddit/selectors/widgets.ts");
			const h = "SUBREDDIT_SETTINGS_LOADED",
				E = Object(l.a)(h),
				I = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					if (!t || !Object(_.S)(s(), t)) {
						const t = await Object(b.c)(o(), e);
						t && t.ok && n(E(t.body))
					}
				}, v = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = Object(y.i)(t());
					r && await e(I(u.Rb + Object(g.e)(r)))
				}, S = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", T = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", D = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", C = Object(l.a)(S), w = Object(l.a)(T), A = Object(l.a)(D), R = function e(t, n) {
					let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (a, i, u) => {
						let {
							apiContext: l
						} = u;
						a(C());
						const g = i(),
							y = c()(Object(_.S)(g, t), ...Object.keys(n)),
							h = await Object(b.g)(l(), t, n);
						if (h.ok) {
							const c = Object(b.d)(h.body, o()(b.a));
							a(w({
								settings: Object.assign({}, c, {
									subredditId: t
								}),
								idCardWidgetId: Object(j.c)(g, {
									subredditId: t
								})
							}));
							const i = {};
							r && 0 === d()(Object.keys(n), Object.keys(y)).length && (i.buttonText = s.fbt._("Undo", null, {
								hk: "1Gskii"
							}), i.buttonAction = e(t, y, r)), a(Object(f.e)(Object.assign({
								kind: O.b.SuccessCommunity,
								text: s.fbt._("Subreddit settings updated successfully", null, {
									hk: "2fmdlZ"
								})
							}, i)))
						} else a(A()), a(Object(f.e)({
							kind: O.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: e(t, n)
						})), r && Object(p.a)(Object(m.c)(g, "BE returned an error:"))
					}
				}, P = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					(await Object(b.e)(a(), e, t)).ok ? n(Object(f.e)({
						kind: O.b.SuccessCommunity,
						text: s.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : n(Object(f.e)({
						kind: O.b.Error,
						text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/subredditTopContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "d", (function() {
				return f
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/preferences.ts"),
				o = n("./src/graphql/operations/SubredditTopContent.json"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			const i = "SUBREDDIT_TOP_CONTENT__PENDING",
				d = "SUBREDDIT_TOP_CONTENT__LOADED",
				u = "SUBREDDIT_TOP_CONTENT__FAILED",
				l = Object(s.a)(i),
				b = Object(s.a)(d),
				p = Object(s.a)(u),
				f = e => async (t, n, s) => {
					const i = e.toLowerCase(),
						d = n(),
						{
							api: u,
							topContent: f
						} = d.subreddits;
					if (u.topContent.pending[i] || f[i]) return;
					t(l({
						subredditName: i
					})), t(Object(r.z)());
					const m = await ((e, t) => Object(a.a)(e, Object.assign({}, o, {
						variables: t
					})))(s.gqlContext(), {
						subredditName: i
					});
					if (m.ok) {
						const e = m.body.data.subreddit;
						if (e) {
							const n = Object(c.c)(e);
							n && t(b(Object.assign({
								subredditName: i
							}, n)))
						}
					} else t(p({
						subredditName: i,
						error: m.error
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			}));
			const s = "SUBSCRIPTION__FETCH_DATA_PENDING",
				r = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				o = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				a = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				c = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				i = "SUBSCRIPTION__ORDER_LOADED",
				d = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return D
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "b", (function() {
				return x
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/linkMatchers/customLinks.ts"),
				c = n("./src/reddit/actions/login.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/subscription/constants.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/posts.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts");
			var m = n("./src/config.ts"),
				O = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var g = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/profile.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				j = n("./src/reddit/selectors/subscriptions.ts"),
				h = n("./src/reddit/selectors/user.ts");
			const E = () => s.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				I = Object(o.a)(d.c),
				v = Object(o.a)(d.b),
				S = Object(o.a)(d.a),
				T = Object(o.a)(d.h),
				D = (Object(o.a)(d.i), Object(o.a)(d.g), () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t();
					if (!o.user.account || o.subscriptions.api.fetched) return;
					e(v());
					const a = await (e => Object(b.b)(e, {
						endpoint: "".concat(m.a.gatewayUrl, "/desktopapi/v1/subscriptions"),
						method: r.ab.GET
					}))(s());
					a.ok ? e(I(a.body)) : e(S({
						error: a.error
					}))
				}),
				C = (e, t, n) => async (o, d, m) => {
					let {
						apiContext: E
					} = m;
					const I = e.map(e => e.type === l.a.SUBREDDIT ? {
						id: Object(y.E)(d(), e.name),
						name: e.name,
						type: e.type
					} : {
						id: Object(_.m)(d(), e.name),
						name: "".concat(r.Rb).concat(e.name),
						type: e.type
					});
					if (!Object(h.H)(d())) return o(Object(i.k)({
						actionSource: i.a.Subscribe
					})), void o(Object(c.h)());
					if (o(T({
							identifiers: I,
							nameIdentifiers: e,
							profileModels: d().profiles.models,
							subredditModels: d().subreddits.models,
							subscriptionsCount: Object(j.b)(d()),
							userIsSubscriber: t,
							widgetId: n
						})), (await ((e, t) => {
							let {
								subredditIds: n,
								subredditNames: s,
								subscribe: o
							} = t;
							return Object(b.b)(Object(p.a)(e, [f.a]), {
								method: r.ab.POST,
								endpoint: Object(O.a)("".concat(e.apiUrl, "/api/subscribe")),
								data: {
									action: o ? "sub" : "unsub",
									sr: n && n.join(",") || void 0,
									sr_name: s && s.join(",") || void 0,
									api_type: "json"
								}
							})
						})(E(), {
							subredditNames: I.map(e => {
								let {
									name: t
								} = e;
								return t
							}),
							subscribe: t
						})).ok) {
						const n = 1 === e.length ? "".concat("subreddit" === e[0].type ? a.d.subreddit : a.d.profile).concat(e[0].name) : "".concat(s.fbt.plural("community", e.length, {
							many: "communities",
							name: "communities",
							showCount: "yes"
						}));
						o(Object(u.e)({
							text: 1 === e.length && "profile" === e[0].type ? s.fbt._("Sucсessfully {verb} {communityname}", [s.fbt._param("verb", t ? "followed" : "unfollowed"), s.fbt._param("communityname", n)], {
								hk: "1hY5KX"
							}) : s.fbt._("Sucсessfully {verb} {communityname}", [s.fbt._param("verb", t ? "joined" : "left"), s.fbt._param("communityname", n)], {
								hk: "1hY5KX"
							})
						}))
					} else {
						o(T({
							identifiers: I,
							nameIdentifiers: e,
							profileModels: d().profiles.models,
							subredditModels: d().subreddits.models,
							subscriptionsCount: Object(j.b)(d()),
							userIsSubscriber: !t,
							widgetId: n
						}));
						const r = s.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						o(Object(u.e)(Object(u.d)(r, g.b.Error)))
					}
				}, w = Object(o.a)(d.f), A = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = n(),
						c = Object(y.K)(a, {
							identifier: e
						});
					if (!c) throw new Error("actions.subscription -- No subreddit or profile found with id ".concat(e.id));
					const i = e.type === l.a.SUBREDDIT ? c.name : "u_".concat(c.name),
						d = a.subscriptions.favoriteSubredditOrder || [],
						m = a.subscriptions.favoriteProfileOrder || [],
						O = d.indexOf(e.id),
						_ = m.indexOf(e.id),
						j = -1 === O && -1 === _,
						h = a.subreddits.models,
						I = a.profiles.models;
					t(w({
						makeFavorite: j,
						identifier: e,
						subredditModels: h,
						profileModels: I
					}));
					const v = {
							type: e.type,
							name: c.name
						},
						S = () => Object(y.bb)(n(), {
							identifier: v
						});
					(S() || (await t(C([v], !0)), S())) && ((await ((e, t, n) => Object(b.b)(Object(p.a)(e, [f.a]), {
						method: r.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/favorite"),
						data: {
							make_favorite: n ? "true" : "false",
							sr_name: t,
							api_type: "json"
						}
					}))(o(), i, j)).ok || (t(w({
						makeFavorite: !j,
						identifier: e,
						subredditModels: h,
						profileModels: I
					})), t(Object(u.e)({
						text: E(),
						kind: g.b.Error
					}))))
				}, R = Object(o.a)(d.d), P = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = n().multireddits.models,
						c = () => {
							t(Object(u.e)({
								text: E(),
								kind: g.b.Error
							}))
						},
						i = a[e];
					if (!i) return void c();
					const d = !i.isFavorited;
					t(R({
						makeFavorite: d,
						multiredditPath: e,
						multiredditsModelsState: a
					})), (await ((e, t, n) => Object(b.b)(Object(p.a)(e, [f.a]), {
						method: r.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/multi/favorite"),
						data: {
							make_favorite: n ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(o(), e, d)).ok || (t(R({
						makeFavorite: !d,
						multiredditPath: e,
						multiredditsModelsState: a
					})), c())
				}, k = Object(o.a)(d.e), x = e => async (t, n, o) => {
					let {
						apiContext: a
					} = o;
					const c = n(),
						i = c.multireddits.models;
					if (!Object(h.H)(c)) return;
					const d = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(u.e)({
								text: s.fbt._("Sorry, failed to {followAction}", [s.fbt._param("followAction", e ? s.fbt._("follow", null, {
									hk: "2I4uia"
								}) : s.fbt._("unfollow", null, {
									hk: "1ZDqgR"
								}))], {
									hk: "1ufRSl"
								}),
								kind: g.b.Error
							}))
						},
						l = i[e];
					if (!l) return void d();
					const m = !l.isFollowed;
					t(k({
						follow: m,
						multiredditPath: e,
						multiredditsModelsState: i
					})), (await ((e, t, n) => Object(b.b)(Object(p.a)(e, [f.a]), {
						method: r.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/multi/subscribe"),
						data: {
							action: n ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(a(), e, m)).ok || (t(k({
						follow: !m,
						multiredditPath: e,
						multiredditsModelsState: i
					})), d(m))
				}
		},
		"./src/reddit/actions/tabBadging.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/chat/unreadCount.ts"),
				o = n("./src/reddit/actions/inbox.ts"),
				a = n("./src/reddit/selectors/chat.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const i = "TAB__UPDATE_HAS_UNREAD_MESSAGES_BADGE",
				d = Object(s.a)(i),
				u = e => async (t, n) => {
					const s = n(),
						i = Object(a.a)(s),
						d = Object(a.d)(s),
						u = Object(c.C)(s),
						{
							basicChannelCount: l,
							inboxCount: b
						} = e;
					i !== l && t(Object(r.b)(Object.assign({}, d, {
						basicChannelCount: l
					}))), b && u !== b && t(Object(o.b)({
						inboxCount: b
					}))
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "t", (function() {
				return s
			})), n.d(t, "j", (function() {
				return r
			})), n.d(t, "r", (function() {
				return o
			})), n.d(t, "q", (function() {
				return a
			})), n.d(t, "s", (function() {
				return c
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "o", (function() {
				return l
			})), n.d(t, "p", (function() {
				return b
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "v", (function() {
				return f
			})), n.d(t, "w", (function() {
				return m
			})), n.d(t, "u", (function() {
				return O
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "A", (function() {
				return j
			})), n.d(t, "z", (function() {
				return h
			})), n.d(t, "D", (function() {
				return E
			})), n.d(t, "y", (function() {
				return I
			})), n.d(t, "C", (function() {
				return v
			})), n.d(t, "x", (function() {
				return S
			})), n.d(t, "B", (function() {
				return T
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "i", (function() {
				return P
			}));
			const s = "TAGS__REQUESTED",
				r = "TAGS__AVAILABLE_LOADED",
				o = "TAGS__LOADED",
				a = "TAGS__FAILURE",
				c = "TAGS__RELEVANCE_LOADED",
				i = "TAGS__CREATE_REQUESTED",
				d = "TAGS__CREATE_SUCCESS",
				u = "TAGS__CREATE_FAILURE",
				l = "TAGS__DELETE_REQUESTED",
				b = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				f = "TAGS__UPDATE_STATE_REQUESTED",
				m = "TAGS__UPDATE_STATE_SUCCESS",
				O = "TAGS__UPDATE_STATE_FAILURE",
				g = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				_ = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				y = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				j = "TAGS__OPTIONS_CANCELLED",
				h = "TAGS__OPTION_SELECTED",
				E = "TAGS__SUGGESTED_OPTION_SELECTED",
				I = "TAGS__OPTION_DESELECTED",
				v = "TAGS__SUGGESTED_OPTION_DESELECTED",
				S = "TAGS__INPUT_CHANGED",
				T = "TAGS__SUGGESTED_INPUT_CHANGED",
				D = "GLOBAL__TAGS__LOADED",
				C = "CREATION__TAGS_INPUT_CHANGED",
				w = "CREATION__TAGS_OPTION_SELECTED",
				A = "CREATION__TAGS_OPTION_DESELECTED",
				R = "CREATION__PRIMARY_TAG_SELECTED",
				P = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "n", (function() {
				return F
			})), n.d(t, "q", (function() {
				return G
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "p", (function() {
				return q
			})), n.d(t, "l", (function() {
				return V
			})), n.d(t, "o", (function() {
				return K
			})), n.d(t, "c", (function() {
				return H
			})), n.d(t, "b", (function() {
				return W
			})), n.d(t, "a", (function() {
				return Y
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "j", (function() {
				return Z
			})), n.d(t, "k", (function() {
				return ee
			})), n.d(t, "f", (function() {
				return ne
			})), n.d(t, "i", (function() {
				return oe
			})), n.d(t, "h", (function() {
				return ae
			})), n.d(t, "e", (function() {
				return ce
			})), n.d(t, "r", (function() {
				return ie
			})), n.d(t, "g", (function() {
				return de
			})), n.d(t, "s", (function() {
				return ue
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tags/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts");
			const c = e => {
				const {
					subredditInfoById: t
				} = e, n = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, t) => {
					let {
						node: n
					} = t;
					return e[n.subreddit && n.subreddit.id || "global"][n.id] = n, e
				}, n);
				const s = {
					[t.id]: {}
				};
				t.secondaryTags && t.secondaryTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, s);
				const r = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, r), {
					primaryTag: t.primaryTag,
					globalSubredditTags: n.global,
					subredditScopedTags: {
						[t.id]: n[t.id]
					},
					subredditId: t.id,
					itemTags: s,
					suggestedItemTags: r
				}
			};
			var i = n("./src/graphql/operations/CreateSubredditTags.json"),
				d = n("./src/lib/makeGqlRequest/index.ts");
			var u = n("./src/graphql/operations/FetchGlobalTags.json"),
				l = n("./src/graphql/operations/FetchSubredditTags.json");
			const b = 1050,
				p = (e, t) => {
					let {
						subredditId: n,
						pageSize: s = b,
						after: r,
						includeAvailableTags: o
					} = t;
					return Object(d.a)(e, Object.assign({}, l, {
						variables: {
							subredditId: n,
							pageSize: s,
							after: r,
							includeAvailableTags: o
						}
					}))
				};
			var f = n("./src/graphql/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			const m = (e, t) => Object(d.a)(e, Object.assign({}, f, {
				variables: Object.assign({}, t, {
					deleteTags: 0 !== t.deleteTagsInput.length,
					pageSize: b
				})
			}));
			var O = n("./src/graphql/operations/UpdateSubredditTagStatesRelevance.json");
			const g = (e, t) => Object(d.a)(e, Object.assign({}, O, {
				variables: t
			}));
			var _ = n("./src/graphql/operations/UpdateSubredditPrimaryTag.json");
			const y = e => {
					const {
						secondaryTags: t,
						id: n,
						primaryTag: s
					} = e.updateSubredditTagStates.subreddit, r = t && t.edges || [];
					return {
						subredditId: n,
						primaryTagId: s && s.tag.id || null,
						secondaryTags: r.reduce((e, t) => {
							let {
								node: n
							} = t;
							return e[n.tag.id] = n, e
						}, {})
					}
				},
				j = (e, t) => Object(d.a)(e, Object.assign({}, _, {
					variables: t
				}));
			var h = n("./src/reddit/featureFlags/communityTopics.ts"),
				E = n("./src/reddit/helpers/tags/index.ts"),
				I = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				v = n("./src/reddit/models/Tags/index.ts"),
				S = n("./src/reddit/models/Toast/index.ts"),
				T = n("./src/reddit/reducers/tags/selected/index.ts"),
				D = n("./src/reddit/selectors/tags.ts");
			const C = Object(r.a)(o.e),
				w = Object(r.a)(o.t),
				A = Object(r.a)(o.r),
				R = Object(r.a)(o.s),
				P = Object(r.a)(o.q),
				k = Object(r.a)(o.l),
				x = Object(r.a)(o.m),
				N = Object(r.a)(o.k),
				L = Object(r.a)(o.v),
				U = Object(r.a)(o.w),
				M = Object(r.a)(o.u),
				F = Object(r.a)(o.z),
				G = Object(r.a)(o.D),
				B = Object(r.a)(o.y),
				q = Object(r.a)(o.C),
				V = Object(r.a)(o.x),
				K = Object(r.a)(o.B),
				H = Object(r.a)(o.d),
				W = Object(r.a)(o.c),
				Y = Object(r.a)(o.b),
				Q = Object(r.a)(o.g),
				z = Object(r.a)(o.h),
				J = Object(r.a)(o.f),
				X = Object(r.a)(o.a),
				Z = Object(r.a)(o.i),
				$ = Object(r.a)(o.A),
				ee = function e(t, n) {
					let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (o, i, d) => {
						let {
							gqlContext: u
						} = d;
						const l = i();
						if (!Object(h.b)()) return;
						o(w());
						const b = await p(u(), {
								subredditId: t
							}),
							f = b.body;
						if (b.ok && f.data.subredditInfoById.secondaryTags && f.data.subredditInfoById.availableTags && f.data.subredditInfoById.suggestedTags) o(A(c(f.data))), r && I.h(i(), t, {
							context: n
						});
						else {
							o(P());
							const c = r ? "topics_save" : "topics_load";
							I.g(l, t, c, {
								context: n
							}), o(Object(a.e)(Object(a.d)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
								hk: "2DUkWX"
							}), S.b.Error, s.fbt._("Retry", null, {
								hk: "1c2xrJ"
							}), e(t, n, r))))
						}
					}
				},
				te = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					if (!Object(h.b)()) return;
					t(w());
					const i = await p(o(), {
						subredditId: e
					});
					if (i.ok) {
						const e = i.body;
						t(R(c(e.data)))
					} else t(P()), t(Object(a.e)(Object(a.d)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), S.b.Error, s.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), R(e))))
				}, ne = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (Object(D.r)(r)) return;
					e(w());
					const o = await ((e, t) => {
						let {
							pageSize: n = b,
							after: s
						} = t;
						return Object(d.a)(e, Object.assign({}, u, {
							variables: {
								pageSize: n,
								after: s
							}
						}))
					})(s(), {});
					if (o.ok) {
						const t = o.body;
						e(C((e => {
							return {
								globalSubredditTags: e.globalTags.edges.reduce((e, t) => (e[t.node.id] = t.node, e), {})
							}
						})(t.data)))
					}
				}, se = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!t.length) return null;
					n(k());
					const a = t.map(t => Object.assign({
							subredditId: e
						}, t)),
						c = await ((e, t) => Object(d.a)(e, Object.assign({}, i, {
							variables: t
						})))(o(), {
							input: a
						}),
						u = c.body && c.body.data || null;
					return c.ok && u && u.createSubredditTags && u.createSubredditTags.ok ? (n(x()), u.createSubredditTags.createdTags || []) : (n(N()), null)
				}, re = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (s, r, o) => {
						let {
							gqlContext: a
						} = o;
						if (!t.length && !n.length) return;
						s(L());
						const i = r(),
							d = Object(D.d)(i, {
								subredditId: e
							}),
							u = Object(D.s)(i, {
								itemId: e
							}),
							l = Object(D.C)(i, {
								itemId: e
							}),
							b = new Set;
						for (const e of t)
							if (e.state === v.d.NONE && d[e.tagId] && !l[e.tagId]) {
								!!n.find(t => t.state === v.d.TAGGED && t.tagId === e.tagId) || b.add(e.tagId)
							} for (const e of n)
							if (e.state === v.d.NONE && d[e.tagId] && !u[e.tagId]) {
								!!t.find(t => t.state === v.d.TAGGED && t.tagId === e.tagId) || b.add(e.tagId)
							} const p = await m(a(), {
								deleteTagsInput: [...b].map(e => ({
									tagId: e
								})),
								updateTagStatesInput: {
									subredditId: e,
									suggestedTagStates: n,
									tagStates: t
								}
							}),
							f = p.body && p.body.data || null;
						p.ok && f && f.updateSubredditTagStates && f.updateSubredditTagStates.ok && f.updateSubredditTagStates.subreddit ? s(U(c({
							subredditInfoById: f.updateSubredditTagStates.subreddit
						}))) : s(M())
					}
				}, oe = function e(t, n) {
					let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (o, c, i) => {
						const d = c(),
							u = Object(D.u)(d, {
								subredditId: t
							}),
							l = Object(D.F)(d, {
								subredditId: t
							});
						let b = u.filter(e => !!e.id && !!e.action).map(e => ({
							tagId: e.id,
							state: e.action === T.a.ADD ? v.d.TAGGED : v.d.NONE
						}));
						if (l.length > 0) {
							const e = await se(t, l)(o, c, i);
							b = b.concat((e || []).map(e => ({
								tagId: e.id,
								state: v.d.TAGGED
							})))
						}
						await re(t, b)(o, c, i), Object(D.D)(c()) ? o(Object(a.e)(Object(a.d)(s.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
							hk: "2Jbh5V"
						}), S.b.Error, s.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), e(t, n, r)))) : r && o(Object(a.e)(Object(a.d)(s.fbt._("Community topics saved!", null, {
							hk: "3wtajT"
						}), S.b.SuccessCommunity)))
					}
				}, ae = (e, t, n) => async (n, r, o) => {
					const c = {
						state: v.d.TAGGED
					};
					if (Object(E.b)(t)) {
						const s = await se(e, [{
							text: t.displayText,
							type: v.c.CLASSIFICATION
						}])(n, r, o);
						s && 1 === s.length && (c.tagId = s[0].id)
					} else {
						if (!t.id) return void n(Object(a.e)(Object(a.d)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), S.b.Error)));
						c.tagId = t.id
					}(e => !!e.tagId && !!e.state)(c) ? await re(e, [], [c])(n, r, o): n(Object(a.e)(Object(a.d)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), S.b.Error)))
				}, ce = (e, t, n) => async (s, r, o) => {
					t.id ? await re(e, [], [{
						state: v.d.NONE,
						tagId: t.id
					}])(s, r, o) : s(ee(e, n, !1))
				}, ie = function e(t, n, r, o) {
					let c = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (i, d, u) => {
						let {
							gqlContext: l
						} = u;
						if (!(await g(l(), {
								input: {
									tagStatesRelevance: n,
									suggestedTagStatesRelevance: r
								}
							})).ok) return i(Object(a.e)(Object(a.d)(s.fbt._("Whoops! Unable to update topics relevance status", null, {
							hk: "17akdT"
						}), S.b.Error, s.fbt._("Retry", null, {
							hk: "1wqK2v"
						}), e(t, n, r, o, c)))), void i(te(t));
						if (c)
							for (const e of r) I.f(d(), e, {
								context: o
							});
						i(Object(a.e)(Object(a.d)(s.fbt._("Successfully updated topics relevance!", null, {
							hk: "3KIYlz"
						}), S.b.SuccessCommunity, s.fbt._("Undo", null, {
							hk: "34apPL"
						}), e(t, n.map(e => Object.assign({}, e, {
							isRelevant: !e.isRelevant
						})), r.map(e => Object.assign({}, e, {
							isRelevant: !e.isRelevant
						})), o, c)))), i(te(t))
					}
				}, de = e => async (t, n) => {
					t($({
						itemTagsState: {
							[e]: Object(D.s)(n(), {
								itemId: e
							})
						}
					}))
				}, ue = function e(t, n) {
					let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (o, c, i) => {
						let {
							gqlContext: d
						} = i;
						o(Q());
						const u = await j(d(), {
								input: {
									subredditId: t,
									primaryTagState: n
								}
							}),
							l = u.body && u.body.data || null;
						u.ok && l && l.updateSubredditTagStates && l.updateSubredditTagStates.ok ? (o(z(y(l))), r && o(Object(a.e)(Object(a.d)(s.fbt._("Successfully updated primary topic!", null, {
							hk: "1NL90v"
						}), S.b.SuccessCommunity)))) : (o(J()), o(Object(a.e)(Object(a.d)(s.fbt._("Whoops! Unable to update primary topic", null, {
							hk: "3ilZqp"
						}), S.b.Error, s.fbt._("Retry", null, {
							hk: "1dRYXW"
						}), e(t, n)))))
					}
				}
		},
		"./src/reddit/actions/theme.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "THEME_CHANGED",
				o = (Object(s.a)(r), "BOOTUP_THEME"),
				a = Object(s.a)(o)
		},
		"./src/reddit/actions/toaster.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/models/Toast/index.ts");
			const o = 5e3,
				a = r.b.SuccessCommunity,
				c = "TOAST__DISPLAYED",
				i = "TOAST__DISMISSED",
				d = Object(s.a)(c),
				u = Object(s.a)(i),
				l = e => async (t, n) => {
					const s = b(e);
					t(d(s)), s.duration > 0 && window.setTimeout(() => t(u(s.id)), s.duration)
				}, b = e => Object.assign({}, e, {
					duration: e.duration || p(e.kind),
					id: e.id || Date.now().toString(),
					kind: e.kind || a
				}), p = e => {
					switch (e) {
						case r.b.Error:
							return -1;
						case r.b.Undo:
							return 1e4;
						case r.b.SuccessCommunity:
						case r.b.SuccessMod:
						default:
							return o
					}
				}, f = (e, t, n, s, r, o) => ({
					text: e,
					kind: t,
					buttonText: n,
					buttonAction: s,
					secondButtonText: r,
					secondButtonAction: o
				})
		},
		"./src/reddit/actions/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "j", (function() {
				return p
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "TOOLTIP__DROPDOWN_TOGGLED",
				o = "TOOLTIP__DROPDOWN_SET",
				a = "TOOLTIP__DROPDOWN_UNSET",
				c = "TOOLTIP__DROPDOWN_SET_IF_NONE",
				i = "TOOLTIP__DROPDOWN_UNSET_IF_ACTIVE",
				d = Object(s.a)(o),
				u = Object(s.a)(r),
				l = Object(s.a)(a),
				b = Object(s.a)(c),
				p = Object(s.a)(i)
		},
		"./src/reddit/actions/tracing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "PARENT_SPAN_RECEIVED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/tracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "TRACKING__VIEWPORT_DATA_LOADED",
				o = "TRACKING__VIEWPORT_DATA_UNLOADED",
				a = Object(s.a)(r);
			Object(s.a)(o)
		},
		"./src/reddit/actions/trafficStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__TRAFFIC_STATS_LOADED",
				r = "SUBREDDIT__TRAFFIC_STATS_PENDING",
				o = "SUBREDDIT__TRAFFIC_STATS_FAILED"
		},
		"./src/reddit/actions/trophyCase.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/graphql/operations/ProfileTrophies.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			n("./node_modules/core-js/modules/es6.symbol.js");
			var a = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var r = 0;
					for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
				}
				return n
			};
			const c = "TROPHYCASE__FETCH_SUCCESS",
				i = Object(s.a)(c),
				d = Object(s.a)("TROPHYCASE__FETCH_FAILED"),
				u = (e, t) => async (n, s, c) => {
					let {
						gqlContext: u
					} = c;
					const l = await ((e, t) => Object(o.a)(e, Object.assign({}, r, {
							variables: t
						})))(u(), {
							profileName: e
						}),
						b = l.body.data;
					if (l.ok && b) {
						const s = {},
							r = [];
						b.redditor && b.redditor.trophies && b.redditor.trophies.map(e => {
							const t = (e => {
									var {
										icon40Url: t,
										trophyId: n
									} = e, s = a(e, ["icon40Url", "trophyId"]);
									return Object.assign({
										icon: t,
										id: n
									}, s)
								})(e),
								{
									id: n
								} = t;
							s[n] = t, r.push(n)
						}), n(i({
							profileId: t,
							profileName: e,
							trophies: s,
							trophyIds: r
						}))
					} else n(d({
						profileId: t,
						error: l.error
					}))
				}
		},
		"./src/reddit/actions/unload/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set,
				r = [],
				o = "AD_UNLOAD",
				a = 18e5
		},
		"./src/reddit/actions/upload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "j", (function() {
				return D
			})), n.d(t, "k", (function() {
				return w
			})), n.d(t, "i", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/get.js"),
				r = n.n(s),
				o = n("./node_modules/uuid/v4.js"),
				a = n.n(o),
				c = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/uploadToS3/index.ts"),
				d = n("./src/reddit/models/Upload/index.ts");
			const u = "UPLOAD_PENDING",
				l = "UPLOAD_UPLOADING",
				b = "UPLOAD_METADATA_CHANGED",
				p = "UPLOAD_PROGRESS",
				f = "UPLOAD_SUCCESS",
				m = "UPLOAD_FAILED",
				O = "UPLOAD_CANCELED",
				g = "UPLOAD_REMOVED",
				_ = Object(c.a)(u),
				y = Object(c.a)(l),
				j = Object(c.a)(b),
				h = Object(c.a)(p),
				E = Object(c.a)(f),
				I = Object(c.a)(m),
				v = Object(c.a)(O),
				S = Object(c.a)(g),
				T = new Map,
				D = (e, t) => {
					const n = T.get(e) || [];
					n.push(t), T.set(e, n)
				},
				C = (e, t) => {
					const n = T.get(e);
					n && n.forEach(n => n(e, t)), T.delete(e)
				},
				w = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (o, c, u) => {
						let {
							apiContext: l
						} = u;
						const b = t;
						if (c().uploads[b] && Object(d.d)(c().uploads[b])) return;
						const p = a()(),
							f = () => {
								const e = c().uploads[b];
								return !e || e.id !== p || e.status === d.a.CANCELED
							};
						o(_({
							key: b,
							id: p,
							file: e
						}));
						const {
							uploadLease: m,
							error: O
						} = await n(c().uploads[b]);
						if (f()) return;
						if (O || !m) return void o(I({
							key: b,
							error: O
						}));
						let g;
						D(p, () => {
							g && g.abort()
						}), o(y({
							key: b
						}));
						const j = await Object(i.a)(e, m, e => (g = e, s && e.on("progress", e => {
							if (!f() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								o(h({
									key: b,
									progress: t
								}))
							}
						}), e));
						if (g = null, !f())
							if (j.ok) {
								const e = decodeURIComponent(j.body.PostResponse.Location);
								o(E({
									key: b,
									url: e
								}))
							} else {
								const e = r()(j, "body.Error.Message.0"),
									t = Object.assign({
										type: "ERROR"
									}, e ? {
										fields: [{
											field: "0",
											msg: e
										}]
									} : {});
								o(I({
									key: b,
									error: t
								}))
							}
					}
				},
				A = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						const r = s().uploads[e];
						r && (C(r.id, t), n(t ? S({
							key: e
						}) : v({
							key: e
						})))
					}
				}
		},
		"./src/reddit/actions/userBlocks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "g", (function() {
				return I
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/blockedRedditors.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/accounts/index.ts"),
				i = n("./src/reddit/models/Toast/index.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = "USER_BLOCK__PENDING",
				l = "USER_BLOCK__LOADED",
				b = "USER_BLOCK__FAILED",
				p = Object(r.a)(u),
				f = Object(r.a)(l),
				m = Object(r.a)(b),
				O = e => async (t, n, r) => {
					let {
						apiContext: d
					} = r;
					if (n().blockUser.api.pending[e]) return;
					t(p({
						username: e
					}));
					const u = await Object(c.a)(d(), e),
						l = "error-block-".concat(e);
					if (u.ok) u.body.name && t(f(u.body)), u.body.id && t(Object(o.f)(u.body.id)), t(a.f(l)), t(a.e({
						kind: i.b.SuccessCommunity,
						text: s.fbt._("Changes saved", null, {
							hk: "196AY7"
						})
					}));
					else {
						const n = {
							type: u.error ? u.error.type : "Unknown error",
							username: e
						};
						t(m(n)), t(a.e({
							id: l,
							kind: i.b.Error,
							text: s.fbt._("An error has occured. Please try again later", null, {
								hk: "2FpsLy"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "36rgQw"
							}),
							buttonAction: O(e)
						}))
					}
				}, g = "USER_UNBLOCK__PENDING", _ = "USER_UNBLOCK__SUCCESS", y = "USER_UNBLOCK__FAILED", j = Object(r.a)(g), h = Object(r.a)(_), E = Object(r.a)(y), I = e => async (t, n, r) => {
					let {
						apiContext: u
					} = r;
					const l = n(),
						b = Object(d.i)(l),
						p = b ? b.id : void 0,
						f = l.user.blocked.data.filter(t => t.name === e)[0];
					p && (t(j({
						name: e
					})), (await Object(c.c)(u(), p, e)).ok ? (t(h({
						name: e
					})), f && f.id && t(Object(o.h)(f.id)), t(a.e({
						kind: i.b.SuccessCommunity,
						text: s.fbt._("Changes saved", null, {
							hk: "4kz5FX"
						})
					}))) : (t(a.e({
						kind: i.b.Error,
						text: s.fbt._("An error has occured. Please try again later", null, {
							hk: "2FpsLy"
						})
					})), t(E({
						name: e
					}))))
				}
		},
		"./src/reddit/actions/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "g", (function() {
				return x
			})), n.d(t, "f", (function() {
				return N
			})), n.d(t, "e", (function() {
				return F
			})), n.d(t, "o", (function() {
				return V
			})), n.d(t, "n", (function() {
				return K
			})), n.d(t, "m", (function() {
				return H
			})), n.d(t, "l", (function() {
				return W
			})), n.d(t, "j", (function() {
				return Y
			})), n.d(t, "k", (function() {
				return Q
			})), n.d(t, "p", (function() {
				return z
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/isEmpty.js"),
				a = n.n(o),
				c = n("./src/reddit/actions/authorFlair.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/flair/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/models/Flair/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/models/User/index.ts"),
				f = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/selectors/userFlair.ts");
			const O = "USER_FLAIR_DATA__MUTATED",
				g = "AUTHOR_FLAIR_DATA__MUTATED",
				_ = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				y = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING"),
				j = Object(r.a)(_),
				h = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED"),
				E = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				I = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				v = Object(r.a)(E),
				S = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				T = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				D = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING"),
				C = Object(r.a)(T),
				w = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED"),
				A = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				R = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING"),
				P = Object(r.a)(A),
				k = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED"),
				x = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				N = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				L = Object(r.a)(x),
				U = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS"),
				M = Object(r.a)(N),
				F = "USERFLAIR_FETCH_SUCCESS",
				G = Object(r.a)(F),
				B = Object(r.a)(O),
				q = Object(r.a)(g),
				V = (e, t, n, s, r) => async (o, a, c) => {
					let {
						apiContext: i
					} = c;
					const l = a(),
						b = l.user.account,
						O = b ? Object(p.e)(b) : void 0,
						g = Object(m.c)(l, {
							subredditId: r
						}),
						_ = Object.assign({}, g.displaySettings, {
							isUserEnabled: n
						}),
						y = {
							userName: s,
							subredditId: r,
							applied: e,
							displaySettings: _
						};
					o(s === O ? B(y) : q(y));
					const j = Object(f.Q)(l, {
							subredditId: r
						}),
						h = t && e ? Object(u.g)(e) : void 0;
					Object(d.g)(i(), s, j.name, t, h), Object(d.i)(i(), n, j.name)
				}, K = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(f.Q)(a, {
							subredditId: e
						}).name;
					n(y());
					const i = await Object(d.l)(o(), c, t);
					if (i.ok) {
						n(j({
							subredditId: e,
							isEnabled: t
						}))
					} else n(h());
					return i.ok
				}, H = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = Object(f.Q)(a, {
							subredditId: e
						}).name;
					n(I());
					const i = await Object(d.j)(o(), t, l.d.UserFlair, c);
					if (i.ok) {
						n(v({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(S());
					return i.ok
				}, W = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const c = r(),
						u = Object(f.Q)(c, {
							subredditId: t
						}).name;
					n(D());
					const p = await Object(d.f)(a(), e, u, l.d.UserFlair),
						m = p.ok && !(p.body && !1 === p.body.success);
					if (m) {
						const e = {
							subredditId: t,
							template: p.body
						};
						n(C(e));
						const r = Object(i.d)(s.fbt._("Flair saved!", null, {
							hk: "354KI0"
						}), b.b.SuccessMod);
						n(Object(i.e)(r))
					} else {
						n(w());
						const r = Object(i.d)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4tkRNl"
						}), b.b.Error, s.fbt._("Retry", null, {
							hk: "4zNHTm"
						}), W(e, t));
						n(Object(i.e)(r))
					}
					return m
				}, Y = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const c = r(),
						u = Object(f.Q)(c, {
							subredditId: t
						}).name;
					if (n(R()), (await Object(d.b)(a(), e, u)).ok) {
						n(P({
							subredditId: t,
							templateId: e
						}));
						const r = Object(i.d)(s.fbt._("Flair deleted!", null, {
							hk: "1mNdn0"
						}), b.b.SuccessMod);
						n(Object(i.e)(r))
					} else {
						n(k());
						const r = Object(i.d)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "2QrdJr"
						}), b.b.Error, s.fbt._("Retry", null, {
							hk: "1buF3Y"
						}), Y(e, t));
						n(Object(i.e)(r))
					}
				}, Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const c = r(),
						u = Object(f.Q)(c, {
							subredditId: t
						}).name,
						p = Object(m.c)(c, {
							subredditId: t
						}).templateIds;
					if (n(L({
							subredditId: t,
							templateIds: e
						})), (await Object(d.e)(a(), u, l.d.UserFlair, e)).ok) {
						n(U());
						const e = Object(i.d)(s.fbt._("Flair reorder saved.", null, {
							hk: "1zrDON"
						}), b.b.SuccessMod);
						n(Object(i.e)(e))
					} else {
						n(M({
							subredditId: t,
							templateIds: p
						}));
						const r = Object(i.d)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "3gAbwk"
						}), b.b.Error, s.fbt._("Retry", null, {
							hk: "2nPnNw"
						}), Q(e, t));
						n(Object(i.e)(r))
					}
				}, z = (e, t) => async (n, r, o) => {
					let {
						apiContext: u
					} = o;
					const l = r(),
						p = l.userFlair;
					if (p && p[e] && p[e].displaySettings.isEnabled && a()(p[e].templateIds)) {
						const r = Object(f.Q)(l, {
								subredditId: e
							}).name,
							o = await Object(d.d)(u(), r);
						if (o.ok) n(G(o.body)), n(Object(c.b)({
							username: t,
							subredditId: e
						}));
						else {
							const e = Object(i.d)(s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							}), b.b.Error);
							n(Object(i.e)(e))
						}
					} else n(Object(c.b)({
						username: t,
						subredditId: e
					}))
				}
		},
		"./src/reddit/actions/userWhitelist.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "h", (function() {
				return h
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/accounts/index.ts"),
				c = n("./src/reddit/models/Toast/index.ts");
			const i = "USER_WHITELIST__PENDING",
				d = "USER_WHITELIST__SUCCESS",
				u = "USER_WHITELIST__FAILED",
				l = Object(r.a)(i),
				b = Object(r.a)(d),
				p = Object(r.a)(u),
				f = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					t(l());
					const d = await Object(a.e)(i(), e);
					d.ok ? d.body.name && (t(b(d.body)), t(o.e({
						kind: c.b.SuccessCommunity,
						text: s.fbt._("Changes saved", null, {
							hk: "3cOmlv"
						})
					}))) : (t(p()), t(o.e({
						kind: c.b.Error,
						text: s.fbt._("An error has occured. Please try again later", null, {
							hk: "3Dszn7"
						})
					})))
				}, m = "USER_UNWHITELIST__PENDING", O = "USER_UNWHITELIST__SUCCESS", g = "USER_UNWHITELIST__FAILED", _ = Object(r.a)(m), y = Object(r.a)(O), j = Object(r.a)(g), h = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					t(_({
						name: e
					})), (await Object(a.d)(i(), e)).ok ? (t(y({
						name: e
					})), t(o.e({
						kind: c.b.SuccessCommunity,
						text: s.fbt._("Changes saved", null, {
							hk: "2o6UcC"
						})
					}))) : (t(j({
						name: e
					})), t(o.e({
						kind: c.b.Error,
						text: s.fbt._("An error has occured. Please try again later", null, {
							hk: "3Dszn7"
						})
					})))
				}
		},
		"./src/reddit/actions/usernameAvailable.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "f", (function() {
				return f
			}));
			var s, r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/endpoints/usernameAvailable/index.ts");
			! function(e) {
				e[e.Available = 0] = "Available", e[e.Error = 1] = "Error", e[e.Pending = 2] = "Pending", e[e.Unavailable = 3] = "Unavailable"
			}(s || (s = {}));
			const a = "USERNAME_AVAILABLE__AVAILABLE",
				c = "USERNAME_AVAILABLE__FAILURE",
				i = "USERNAME_AVAILABLE__PENDING",
				d = "USERNAME_AVAILABLE__UNAVAILABLE",
				u = Object(r.a)(a),
				l = Object(r.a)(c),
				b = Object(r.a)(i),
				p = Object(r.a)(d),
				f = e => {
					let {
						username: t
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: a
						} = r;
						const c = n().users.nameAvailable;
						if (!c[t] || c[t] === s.Error) {
							e(b({
								username: t
							}));
							const n = await Object(o.a)(a(), {
								username: t
							});
							n.ok ? n.body ? e(u({
								username: t
							})) : e(p({
								username: t
							})) : e(l({
								username: t
							}))
						}
					}
				}
		},
		"./src/reddit/actions/users.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return q
			})), n.d(t, "q", (function() {
				return V
			})), n.d(t, "g", (function() {
				return K
			})), n.d(t, "f", (function() {
				return H
			})), n.d(t, "e", (function() {
				return W
			})), n.d(t, "k", (function() {
				return Y
			})), n.d(t, "d", (function() {
				return Q
			})), n.d(t, "y", (function() {
				return Z
			})), n.d(t, "c", (function() {
				return $
			})), n.d(t, "r", (function() {
				return te
			})), n.d(t, "p", (function() {
				return ne
			})), n.d(t, "x", (function() {
				return se
			})), n.d(t, "s", (function() {
				return re
			})), n.d(t, "a", (function() {
				return oe
			})), n.d(t, "o", (function() {
				return ce
			})), n.d(t, "u", (function() {
				return ie
			})), n.d(t, "m", (function() {
				return de
			})), n.d(t, "n", (function() {
				return ue
			})), n.d(t, "l", (function() {
				return le
			})), n.d(t, "t", (function() {
				return Oe
			})), n.d(t, "v", (function() {
				return ge
			})), n.d(t, "i", (function() {
				return _e
			})), n.d(t, "j", (function() {
				return ye
			})), n.d(t, "h", (function() {
				return je
			})), n.d(t, "w", (function() {
				return ve
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/emailVerificationTooltip.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				i = n("./src/reddit/actions/notificationBanner.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/components/NotificationBanners/bannerIds.ts"),
				l = n("./src/reddit/components/Settings/modalIds.ts"),
				b = n("./src/reddit/endpoints/user/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts"),
				O = n("./src/config.ts"),
				g = n("./src/reddit/helpers/getErrorMsgFromR2JQueryResponse.ts"),
				_ = (n("./node_modules/core-js/modules/es7.promise.finally.js"), n("./node_modules/promise-retry/index.js")),
				y = n.n(_),
				j = n("./src/lib/makeRequest/index.ts");
			var h = n("./src/reddit/constants/history.ts"),
				E = n("./src/reddit/endpoints/session/index.ts"),
				I = n("./node_modules/js-cookie/src/js.cookie.js"),
				v = n.n(I),
				S = n("./src/lib/constants/cookie.ts");
			const T = e => {
				v.a.remove(e, {
					domain: O.a.cookieDomain
				})
			};
			var D = n("./src/reddit/helpers/history/index.ts");
			const C = 2 * r.bb;
			var w = e => Date.now() + C < new Date(e.expires).getTime(),
				A = n("./src/reddit/helpers/localStorage/index.ts"),
				R = async (e, t) => {
					let n = t.accessToken;
					await y()(async (s, o) => {
						if (!w(t) || !n) {
							const r = await Object(E.b)(e, t);
							if (r.ok) {
								const e = r.body;
								n = e.accessToken
							} else if (1 === o) return s()
						}
						const a = await Object(p.b)(e, {
							endpoint: "/logoutproxy",
							method: r.ab.POST,
							data: {
								access_token: n
							}
						});
						if (await async function(e, t) {
								return await Object(j.b)({
									method: r.ab.POST,
									endpoint: "/timings/logoutrequest",
									data: {
										appName: e.statsAppName,
										successful: t
									},
									type: "json"
								})
							}(e, a && a.ok), !a.ok) return s()
					}, {
						retries: 1
					}).catch(() => {}).finally(() => {
						[S.c, S.d, S.h, S.i].forEach(T), Object(A.A)(null), Object(D.a)(h.a.JustLoggedOut, !0), window.location.reload()
					})
				}, P = n("./src/reddit/helpers/redesignOptoutCookie/index.ts"), k = n("./src/reddit/helpers/trackers/emailCollection.ts"), x = n("./src/reddit/helpers/trackers/emailVerification.ts"), N = n("./src/reddit/models/Toast/index.ts"), L = n("./src/reddit/selectors/activeModalId.ts"), U = n("./src/reddit/selectors/emailCollection.ts"), M = n("./src/reddit/selectors/notificationBanner.ts"), F = n("./src/reddit/selectors/user.ts"), G = n("./src/telemetry/index.ts"), B = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const q = "USER__LOID_RECEIVED",
				V = Object(o.a)(q),
				K = "USER__REQUEST_PENDING",
				H = "USER__REQUEST_LOADED",
				W = "USER__REQUEST_FAILED",
				Y = "USER__SESSION_TRACKER_RECEIVED",
				Q = "USER__REDDAID_RECEIVED",
				z = Object(o.a)(K),
				J = Object(o.a)(H),
				X = Object(o.a)(W),
				Z = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (n().users.models[e.toLowerCase()] || e === r.y) return;
					t(z({
						username: e
					}));
					const a = await Object(b.b)(o(), e);
					if (a.ok) {
						const n = {
							data: a.body
						};
						n.username = e, t(J(n))
					} else {
						const n = a.error;
						n.username = e, t(X(n))
					}
				}, $ = "USER__MYSELF_LOADED", ee = Object(o.a)($), te = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t();
					if (o.user.account || !o.user.session || o.user.session.unsafeLoggedOut) return;
					const a = await (e => Object(p.b)(e, {
						endpoint: "".concat(O.a.gatewayUrl, "/desktopapi/v1/me"),
						method: r.ab.GET,
						data: {
							api_type: "json",
							gilding_detail: 1,
							awarded_detail: 1
						}
					}))(s());
					a.ok && e(ee(a.body))
				}, ne = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t().user.session;
					Object(P.a)(), r && R(s(), r)
				}, se = Object(o.a)(Y), re = Object(o.a)(Q), oe = "USER__LAYOUT_SWITCH_VIEWED", ae = Object(o.a)(oe), ce = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					r.user.account && !r.user.account.seenLayoutSwitch && (e(ae()), Object(b.d)(s()))
				}, ie = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = await ((e, t) => Object(p.b)(Object(f.a)(e, [m.a]), {
							method: r.ab.POST,
							endpoint: "".concat(e.apiUrl, "/api/deactivate_user"),
							data: {
								user: t.username,
								passwd: t.password,
								confirm: t.checkbox,
								deactivate_message: t.feedback
							}
						}))(o(), e),
						c = n().user.session;
					a.ok && a.body && a.body.success ? c && R(o(), c) : t(Object(d.e)({
						kind: N.b.Error,
						text: "Something went wrong deactivating your account. Try again later."
					}))
				}, de = "USER__UPDATE_EMAIL_PENDING", ue = "USER__UPDATE_EMAIL_SUCCESS", le = "USER__UPDATE_EMAIL_FAILURE", be = Object(o.a)(de), pe = Object(o.a)(ue), fe = Object(o.a)(le), me = (e, t) => {
					t.isEmailVerificationTooltipShowing && e(Object(a.b)())
				}, Oe = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = B(e, []);
					if (Object(F.D)(n(), "changeEmail")) return;
					t(be());
					const c = await ((e, t) => {
							let {
								newEmail: n,
								password: s
							} = t;
							return Object(p.b)(Object(f.a)(e, [m.a]), {
								method: r.ab.POST,
								endpoint: "".concat(e.apiUrl, "/api/update_email"),
								data: Object.assign({}, s && {
									curpass: s
								}, {
									email: n
								})
							})
						})(o(), a),
						d = n();
					if (c.ok && c.body && c.body.success) {
						Object(M.a)(u.a.EmailCollectionBannerId)(d) && t(Object(i.c)(u.a.EmailCollectionBannerId)), Object(U.a)(d) && Object(G.a)(Object(k.c)(d));
						const e = Object(F.F)(d);
						e || await t(ge()), t(pe(a.newEmail)), e && t(Ee()), me(t, d)
					} else {
						const e = Object(g.b)(c, "Something went wrong updating your email. Try again later.");
						t(fe(e))
					}
				}, ge = e => async (t, n, o) => {
					let {
						apiContext: a
					} = o;
					const i = await ((e, t) => Object(p.b)(Object(f.a)(e, [m.a]), Object.assign({
							method: r.ab.GET,
							endpoint: "".concat(e.apiUrl, "/api/send_verification_email")
						}, t.source && {
							data: t
						})))(a(), {
							source: e
						}),
						u = n();
					if (i.ok && i.body && i.body.success) {
						e && (Object(G.a)(Object(x.f)(e)(u)), me(t, u));
						const n = Object(L.a)(u),
							s = n === l.g || n === l.n ? l.n : l.c;
						t(Object(c.i)(s))
					} else t(Object(d.e)({
						duration: d.a,
						kind: N.b.Error,
						text: s.fbt._("Something went wrong sending verification email. Try again later.", null, {
							hk: "2yTdAw"
						})
					}))
				}, _e = "USER__SEND_RESET_EMAIL_PENDING", ye = "USER__SEND_RESET_EMAIL_SUCCESS", je = "USER__SEND_RESET_EMAIL_FAILURE", he = Object(o.a)(_e), Ee = Object(o.a)(ye), Ie = Object(o.a)(je), ve = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (Object(F.D)(n(), "sendResetEmail")) return;
					t(he());
					const a = await ((e, t) => Object(p.b)(Object(f.a)(e, [m.a]), {
						method: r.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/password"),
						data: {
							email: t.curEmail,
							name: t.name
						}
					}))(o(), e);
					if (!a.ok || !a.body || !a.body.success) {
						const e = Object(g.b)(a, "Something went wrong sending the reset email. Please try again.");
						return t(Ie()), void t(Object(d.e)({
							duration: d.a,
							kind: N.b.Error,
							text: e
						}))
					}
					t(Ee())
				}
		},
		"./src/reddit/actions/video.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return f
			})), n.d(t, "r", (function() {
				return m
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "m", (function() {
				return _
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "q", (function() {
				return h
			})), n.d(t, "s", (function() {
				return E
			})), n.d(t, "u", (function() {
				return I
			})), n.d(t, "v", (function() {
				return v
			})), n.d(t, "t", (function() {
				return S
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "p", (function() {
				return D
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "e", (function() {
				return A
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "c", (function() {
				return k
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "g", (function() {
				return N
			})), n.d(t, "z", (function() {
				return U
			})), n.d(t, "F", (function() {
				return Q
			})), n.d(t, "B", (function() {
				return z
			})), n.d(t, "D", (function() {
				return J
			})), n.d(t, "E", (function() {
				return X
			})), n.d(t, "C", (function() {
				return Z
			})), n.d(t, "R", (function() {
				return $
			})), n.d(t, "J", (function() {
				return ee
			})), n.d(t, "S", (function() {
				return te
			})), n.d(t, "T", (function() {
				return ne
			})), n.d(t, "G", (function() {
				return re
			})), n.d(t, "H", (function() {
				return ae
			})), n.d(t, "L", (function() {
				return de
			})), n.d(t, "P", (function() {
				return ue
			})), n.d(t, "A", (function() {
				return le
			})), n.d(t, "Q", (function() {
				return pe
			})), n.d(t, "O", (function() {
				return Oe
			})), n.d(t, "N", (function() {
				return ge
			})), n.d(t, "x", (function() {
				return _e
			})), n.d(t, "M", (function() {
				return ye
			})), n.d(t, "w", (function() {
				return je
			})), n.d(t, "I", (function() {
				return he
			})), n.d(t, "K", (function() {
				return Ee
			})), n.d(t, "y", (function() {
				return Ie
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/constants/adEvents.ts"),
				o = n("./src/reddit/constants/video.ts"),
				a = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/actions/post.ts"),
				i = n("./src/reddit/helpers/trackers/media.ts"),
				d = n("./src/reddit/helpers/trackers/postList.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/telemetry.ts"),
				p = (n("./src/reddit/selectors/video.ts"), n("./src/telemetry/index.ts"));
			const f = "VIDEO__CONSUMED",
				m = "VIDEO__SET_FULLSCREEN",
				O = "VIDEO__EXIT_FULLSCREEN",
				g = "VIDEO__LOADABLE",
				_ = "VIDEO__LOADING",
				y = "VIDEO__PAUSED",
				j = "VIDEO__PLAYABLE",
				h = "VIDEO__METADATA_RECEIVED",
				E = "VIDEO__STARTED",
				I = "VIDEO__UNLOADABLE",
				v = "VIDEO__UNPAUSED",
				S = "VIDEO__TIME_UPDATED",
				T = "VIDEO__BUFFERING",
				D = "VIDEO__PLAYING",
				C = "VIDEO__CONTINUOUS_VIEW_STARTED_AT",
				w = "AD__MRC_VIDEO_VIEWABLE",
				A = "AD__VIDEO_VIEWABLE",
				R = "AD__VIDEO_FULLY_VIEWABLE",
				P = "AD__VIDEO_STARTED",
				k = "AD__VIDEO_PLAYED_WITH_SOUND",
				x = "AD__VIDEO_WATCHED_PERCENT",
				N = "AD__VIDEO_WATCHED_SECONDS",
				L = (() => {
					let e = "";
					return (t, n, s, r) => async (o, c) => {
						if (null != t) {
							e !== t && (e = t, Object(a.d)(a.a.VideoView));
							const o = c(),
								d = r ? i.b(t, n, s) : i.a(t, n, s);
							Object(p.a)(Object.assign({}, b.defaults(o), d(o)))
						}
					}
				})(),
				U = Object(s.a)(C),
				M = Object(s.a)(A),
				F = Object(s.a)(R),
				G = Object(s.a)(w),
				B = Object(s.a)("AD__VIDEO_GROUP_M_VIEWABLE"),
				q = Object(s.a)("AD__VIDEO_FULLY_VIEWABLE_50"),
				V = Object(s.a)(P),
				K = Object(s.a)(k),
				H = Object(s.a)("AD__VIDEO_PLAYED_EXPANDED"),
				W = Object(s.a)(x),
				Y = Object(s.a)(N),
				Q = e => async (t, n) => {
					const s = n(),
						o = Object(l.O)(s, {
							postId: e
						});
					t(L(e, "is_viewable", "video", !1)), o.isSponsored && (t(Object(c.B)(o, r.a.VideoViewableImpression)), t(M({
						postId: e
					})))
				}, z = e => async (t, n) => {
					const s = n(),
						o = Object(l.O)(s, {
							postId: e
						});
					o.isSponsored && (t(Object(c.B)(o, r.a.MRCVideoViewableImpression)), t(G({
						postId: e
					})))
				}, J = e => async (t, n) => {
					const s = n(),
						o = Object(l.O)(s, {
							postId: e
						});
					o.isSponsored && (t(Object(c.B)(o, r.a.VideoGroupMViewable)), t(B({
						postId: e
					})))
				}, X = e => async (t, n) => {
					const s = n(),
						o = Object(l.O)(s, {
							postId: e
						});
					o.isSponsored && (t(Object(c.B)(o, r.a.VideoVendorFullyViewable50)), t(q({
						postId: e
					})))
				}, Z = e => async (t, n) => {
					const s = n(),
						o = Object(l.O)(s, {
							postId: e
						});
					t(L(e, "is_fully_viewable", "video", !1)), o.isSponsored && (t(Object(c.B)(o, r.a.VideoFullyViewableImpression)), t(F({
						postId: e
					})))
				}, $ = e => async (t, n) => {
					const s = Object(l.O)(n(), {
						postId: e
					});
					t(L(e, "start", "video", !1)), s.isSponsored && (t(Object(c.B)(s, r.a.VideoStarted)), t(V({
						postId: e
					})))
				}, ee = e => async (t, n) => {
					const s = Object(l.O)(n(), {
						postId: e
					});
					t(L(e, "play_with_sound", "video", !1)), t(L(e, "is_viewable", "video", !1)), t(L(e, "is_fully_viewable", "video", !1)), s.isSponsored && (t(Object(c.B)(s, r.a.VideoPlayedWithSound)), t(Object(c.B)(s, r.a.VideoViewableImpression)), t(Object(c.B)(s, r.a.VideoFullyViewableImpression)), t(Object(c.B)(s, r.a.MRCVideoViewableImpression)), t(K({
						postId: e
					})), t(M({
						postId: e
					})), t(F({
						postId: e
					})), t(G({
						postId: e
					})))
				}, te = (e, t) => async (n, s) => {
					const a = Object(l.O)(s(), {
						postId: t
					});
					let i, d;
					switch (e) {
						case o.b:
							i = "watch_25_percent", d = r.a.VideoWatched25;
							break;
						case o.c:
							i = "watch_50_percent", d = r.a.VideoWatched50;
							break;
						case o.d:
							i = "watch_75_percent", d = r.a.VideoWatched75;
							break;
						case o.e:
							i = "watch_95_percent", d = r.a.VideoWatched95;
							break;
						default:
							i = "watch_100_percent", d = r.a.VideoWatched100
					}
					n(L(t, i, "video", !1)), a.isSponsored && (n(Object(c.B)(a, d)), n(W({
						postId: t,
						percentage: e
					})))
				}, ne = (e, t) => async (n, s) => {
					const a = Object(l.O)(s(), {
						postId: t
					});
					let i, d;
					switch (e) {
						case o.g:
							i = "watch_3_seconds", d = r.a.VideoWatchedSeconds3;
							break;
						case o.h:
							i = "watch_5_seconds", d = r.a.VideoWatchedSeconds5;
							break;
						default:
							i = "watch_10_seconds", d = r.a.VideoWatchedSeconds10
					}
					n(L(t, i, "video", !1)), a.isSponsored && (n(Object(c.B)(a, d)), n(Y({
						postId: t,
						seconds: e
					})))
				}, se = Object(s.a)(f), re = Object(s.a)(g), oe = Object(s.a)(_), ae = Object(s.a)(y), ce = Object(s.a)(j), ie = Object(s.a)(m), de = Object(s.a)(h), ue = Object(s.a)(S), le = Object(s.a)(O), be = Object(s.a)(E), pe = Object(s.a)(I), fe = Object(s.a)(v), me = Object(s.a)(T), Oe = Object(s.a)(D), ge = e => async (t, n) => {
					const s = Object(l.O)(n(), {
						postId: e
					});
					t(ie({
						postId: e
					})), ((e, t, n) => {
						n(L(t, "play_expanded", "video", !1)), n(L(t, "is_viewable", "video", !1)), n(L(t, "is_fully_viewable", "video", !1)), e.isSponsored && (n(Object(c.B)(e, r.a.VideoPlayedExpanded)), n(Object(c.B)(e, r.a.VideoViewableImpression)), n(Object(c.B)(e, r.a.VideoFullyViewableImpression)), n(Object(c.B)(e, r.a.MRCVideoViewableImpression)), n(H({
							postId: t
						})), n(M({
							postId: t
						})), n(F({
							postId: t
						})), n(G({
							postId: t
						})))
					})(s, e, t)
				}, _e = (e, t) => async (n, s) => {
					const r = s();
					r.posts.video.autoPlayed[e] && Object(u.j)(r) && (d.d(r, e), void 0 !== t && n(me({
						postId: e,
						isBuffering: t
					})))
				}, ye = e => async (t, n) => {
					const s = n();
					s.posts.video.autoPlayed[e] && Object(u.j)(s) && d.h(s, e)
				}, je = (e, t) => async (n, s) => {
					n(oe({
						postId: e,
						time: t
					}));
					const r = s();
					Object(u.j)(r) && d.f(r, e)
				}, he = (e, t) => async (n, s) => {
					n(ce({
						postId: e,
						time: t
					}));
					const r = s();
					Object(u.j)(r) && d.a(r, e)
				}, Ee = e => async (t, n) => {
					const s = n(),
						r = s.posts.video.autoPlayed[e],
						o = s.posts.video.started[e];
					t(be({
						postId: e
					})), t(fe({
						postId: e
					})), !o && r && Object(u.j)(s) && d.c(s, e)
				}, Ie = e => async (t, n) => {
					const s = n(),
						r = s.posts.video.autoPlayed[e],
						o = s.posts.video.consumed[e];
					t(se({
						postId: e
					})), r && Object(u.j)(s) && !o && d.b(s, e)
				}
		},
		"./src/reddit/actions/vote.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return U
			})), n.d(t, "b", (function() {
				return F
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/actions/tooltip.ts"),
				a = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				c = n("./src/reddit/endpoints/user/index.ts"),
				i = n("./src/reddit/actions/gold/constants.ts");
			const d = Object(s.a)(i.u),
				u = Object(s.a)(i.v);
			var l = n("./src/reddit/actions/login.ts"),
				b = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/post.ts"),
				f = n("./src/reddit/components/ModerationPrompts/useActivePromptId.ts"),
				m = n("./src/reddit/constants/adEvents.ts"),
				O = n("./src/reddit/constants/experiments.ts"),
				g = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				_ = n("./src/lib/constants/index.ts"),
				y = n("./src/lib/makeApiRequest/index.ts"),
				j = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				E = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var I = n("./src/reddit/featureFlags/index.ts"),
				v = n("./src/reddit/helpers/favoriteCreators/index.ts"),
				S = n("./src/reddit/helpers/isComment.ts"),
				T = n("./src/reddit/helpers/isPost.ts"),
				D = n("./src/reddit/helpers/trackers/gild.ts"),
				C = n("./src/reddit/models/Vote/index.ts"),
				w = n("./src/reddit/selectors/comments.ts"),
				A = n("./src/reddit/helpers/chooseVariant/index.ts"),
				R = n("./src/reddit/selectors/user.ts");
			var P = n("./src/reddit/selectors/gild.ts"),
				k = n("./src/reddit/selectors/moderatorPermissions.ts"),
				x = n("./src/reddit/selectors/modQueue.ts"),
				N = n("./src/reddit/selectors/platform.ts"),
				L = n("./src/reddit/selectors/posts.ts");
			const U = "VOTE__VOTE_CAST",
				M = Object(s.a)(U),
				F = (e, t) => n => async (s, i, U) => {
					let {
						apiContext: F
					} = U;
					if (!Object(R.H)(i())) return s(Object(b.k)({
						actionSource: b.a.Vote
					})), void s(Object(l.h)());
					const G = e(n, i),
						B = C.b(G, t),
						q = Object(T.a)(n) ? G.postId : n;
					if (s(M({
							id: q,
							isInstance: !1,
							vote: t
						})), (i().posts.instances[q] || []).forEach(e => {
							s(M({
								id: e,
								isInstance: !0,
								vote: t
							}))
						}), B)
						if (Object(T.a)(n)) {
							const e = Object(L.O)(i(), {
									postId: n
								}),
								r = t > 0 ? m.a.Upvote : m.a.Downvote;
							s(Object(p.B)(e, r))
						} else if (Object(S.a)(n)) {
						const e = Object(w.n)(i(), {
							commentId: n
						});
						if (e) {
							const n = Object(L.O)(i(), {
									postId: e.postId
								}),
								r = t > 0 ? m.a.CommentUpvote : m.a.CommentDownvote;
							s(Object(p.B)(n, r))
						}
					}
					const V = i(),
						K = Object(N.h)(V),
						H = !!Object(P.f)(V),
						W = Object(R.Z)(V);
					if (H ? s((() => async (e, t, n) => {
							let {
								apiContext: s
							} = n;
							e(d()), e(Object(o.i)())
						})()) : Object(T.a)(q) && B === C.a.upvoted && !W && (e => {
							const t = Object(A.c)(e, {
								experimentEligibilitySelector: e => Object(R.H)(e),
								experimentName: O.db
							});
							return Object(O.rc)(t) ? void 0 : t
						})(V) && (s(((e, t) => async (n, s, r) => {
							let {
								apiContext: i
							} = r;
							n(u(e)), n(Object(o.h)({
								tooltipId: Object(a.a)("View--GiveAward", e, t ? "lightbox" : void 0)
							})), Object(c.c)(i())
						})(q, K)), Object(r.a)(Object(D.viewGiveAwardTooltipEvent)(q)(V))), Object(T.a)(n) && B === C.a.upvoted && I.d.spFavoriteCreators(V)) {
						const e = Object(L.O)(V, {
							postId: n
						});
						Object(v.a)(e.belongsTo.id, e.authorId)
					}
					if (Object(R.H)(V)) {
						const e = await ((e, t, n) => Object(y.b)(Object(j.a)(e, [h.a]), {
							endpoint: Object(E.a)("".concat(e.apiUrl, "/api/vote")),
							method: _.ab.POST,
							data: {
								id: t,
								dir: n,
								api_type: "json"
							}
						}))(F(), q, B);
						e.ok || s(M({
								id: q,
								isInstance: !1,
								vote: t
							})),
							function(e) {
								const {
									moderationPrompt: t
								} = e.body;
								if (!t) return;
								if (!Object(T.a)(n)) return;
								const r = Object(L.O)(V, {
									postId: n
								});
								if (Object(k.g)(V, {
										subredditId: r.belongsTo.id
									})) return;
								if (Object(x.b)(V)) return;
								if (Object(g.E)(V.platform && V.platform.currentPage)) return;
								if (r.isSponsored) return;
								if ("profile" === r.belongsTo.type) return;
								const o = V.experimentOverrides[O.P],
									a = Object(N.h)(V);
								("none" !== t || o && B === C.a.downvoted) && (s(Object(p.T)({
									[n]: {
										moderationPrompt: o || t
									}
								})), s(Object(p.J)(Object(f.b)(n, a))))
							}(e)
					}
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return s
			})), n.d(t, "i", (function() {
				return r
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			}));
			const s = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				a = "WIDGETS_SORTED",
				c = "WIDGETS__STARTED_EDITING_WIDGET",
				i = "WIDGETS__LOADED",
				d = "SUBREDDIT__WIDGETS_PENDING",
				u = "SUBREDDIT__WIDGETS_LOADED",
				l = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "d", (function() {
				return T
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "f", (function() {
				return P
			})), n.d(t, "g", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/apiRequestState.ts"),
				a = n("./src/reddit/actions/imageUploads.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			const b = async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widgets"),
				method: i.ab.GET,
				type: "json",
				data: {
					progressive_images: n
				}
			});
			var p = n("./src/reddit/helpers/getGenericUploadError.ts"),
				f = n("./src/reddit/helpers/media/index.ts"),
				m = n("./src/lib/assertNever.ts"),
				O = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/models/Image/index.tsx"),
				_ = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/models/Widgets/index.ts"),
				j = n("./src/reddit/actions/widgets/constants.ts");
			const h = Object(r.a)(j.g),
				E = (e, t, n) => async (r, b, f) => {
					const {
						apiContext: m
					} = f;
					r(Object(o.h)(n));
					const j = b(),
						E = Object(O.Q)(j, {
							subredditId: e
						}).name,
						I = Object(y.k)(t);
					let v = null,
						S = null;
					try {
						(v = await Object(a.f)(j, g.a.Widgets)) && (S = Object(a.m)(v)(r, b, f))
					} catch (D) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					const T = await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget"),
						method: i.ab.POST,
						type: "json",
						data: n
					}))(m(), E, I);
					if (T.ok) {
						let a = T.body;
						const i = a.id;
						if ("calendar" === t.kind && r(Object(c.e)({
								kind: _.b.SuccessMod,
								text: s.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), v) {
							try {
								await S
							} catch (D) {}
							a = await r(U(e, i)) || a
						}
						r(h({
							subredditId: e,
							widget: a,
							widgetId: i
						})), r(Object(o.e)(n))
					} else v && v.websocket.close(), r(Object(o.f)(n, T.error))
				}, I = Object(r.a)(j.i), v = (e, t, n) => async (r, b, f) => {
					const {
						apiContext: j
					} = f;
					r(Object(o.h)(n));
					const h = t.id,
						E = b(),
						v = Object(O.Q)(E, {
							subredditId: e
						}).name,
						S = Object(y.k)(t);
					let T = null,
						D = null;
					try {
						(T = await Object(a.f)(E, g.a.Widgets)) && (D = Object(a.m)(T)(r, b, f))
					} catch (w) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					const C = await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget/").concat(n.id),
						method: i.ab.PUT,
						type: "json",
						data: n
					}))(j(), v, S);
					if (C.ok) {
						let a = function(e, t, n) {
							switch (e.kind) {
								case "calendar":
								case "id-card":
								case "subreddit-rules":
									return Object.assign({}, e, t);
								case "community-list": {
									const s = {};
									for (const t of e.data) s[t.name] = t;
									return Object.assign({}, t, {
										data: t.data.map(e => {
											if (!("subscribers" in s[e])) {
												const t = {
														subredditName: e
													},
													s = Object(O.z)(n, t),
													r = Object(O.w)(n, t);
												return {
													name: s.name,
													subscribers: s ? s.subscribers : void 0,
													iconUrl: s ? s.communityIcon : void 0,
													isNSFW: s ? s.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return s[e]
										})
									})
								}
								case "button":
								case "custom":
								case "image":
								case "menu":
								case "moderators":
								case "textarea":
								case "post-flair":
									return t;
								default:
									return Object(m.a)(e)
							}
						}(t, C.body, E);
						if (D) {
							try {
								await D
							} catch (w) {}
							a = await r(U(e, h)) || a
						}
						r(I({
							subredditId: e,
							widgetId: h,
							widget: a
						})), "calendar" === t.kind && r(Object(c.e)({
							kind: _.b.SuccessMod,
							text: s.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(n))
					} else T && T.websocket.close(), r(Object(o.f)(n, C.error))
				}, S = Object(r.a)(j.h), T = (e, t, n) => async (s, r, a) => {
					let {
						apiContext: c
					} = a;
					s(Object(o.h)(n));
					const b = t.id,
						p = Object(O.Q)(r(), {
							subredditId: e
						}).name,
						f = await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
							endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget/").concat(n.id),
							method: i.ab.DELETE,
							type: "json"
						}))(c(), p, t);
					f.ok ? (s(Object(o.e)(n)), s(S({
						subredditId: e,
						widgetId: b
					}))) : s(Object(o.f)(n, f.error))
				}, D = Object(r.a)(j.f), C = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = Object(O.Q)(s(), {
						subredditId: e
					}).name;
					(await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget_order/sidebar"),
						method: i.ab.PATCH,
						type: "json",
						data: n
					}))(o(), a, t)).ok && n(D({
						subredditId: e,
						widgetIds: t
					}))
				}, w = e => {
					let {
						imageData: t
					} = e;
					return async (e, n, s) => {
						const r = n(),
							o = r.structuredStyles.isEditing,
							c = Object(O.Q)(r, {
								subredditId: o
							}).name;
						e(Object(a.k)(t));
						const b = await (async (e, t, n, s) => Object(d.b)(Object(u.a)(e, [l.a]), {
							endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget_image_upload_s3"),
							method: i.ab.POST,
							data: {
								filepath: n,
								mimetype: s
							}
						}))(s.apiContext(), c, t.file.name, await Object(f.g)(t.file));
						let p = !1;
						try {
							const s = await Object(a.g)(n(), b, t, g.a.Widgets);
							s && (e(Object(a.j)(s)), p = !0)
						} catch (m) {
							if (m instanceof Error) throw m;
							e(Object(a.i)(m))
						}
						return p
					}
				}, A = Object(r.a)(j.d), R = Object(r.a)(j.e), P = (e, t) => async (n, s, r) => {
					let {
						apiContext: a
					} = r;
					n(Object(o.h)(t));
					const c = Object(O.Q)(s(), {
							subredditId: e
						}).name,
						i = await b(a(), c);
					if (i.ok) {
						const s = i.body;
						n(R({
							subredditId: e,
							widgets: s
						})), n(Object(o.e)(t))
					} else n(Object(o.f)(t, i.error))
				}, k = Object(r.a)(j.c), x = Object(r.a)(j.b), N = Object(r.a)(j.a), L = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(k({
						subredditId: e
					}));
					const a = Object(O.Q)(s(), {
							subredditId: e
						}).name,
						c = await b(o(), a, t);
					if (c.ok) {
						const t = c.body;
						n(x({
							subredditId: e,
							widgets: t
						}))
					} else n(N({
						subredditId: e,
						error: c.error
					}))
				}, U = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = Object(O.Q)(s(), {
							subredditId: e
						}).name,
						c = await b(o(), a, !0);
					if (c.ok) return c.body.items[t]
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			}));
			const s = "WIKI_BANNED_CONTRIBUTORS_PENDING",
				r = "WIKI_BANNED_CONTRIBUTORS_LOADED",
				o = "WIKI_BANNED_CONTRIBUTORS_FAILED",
				a = "MORE_WIKI_BANNED_CONTRIBUTORS_LOADED",
				c = "WIKI_BANNED_CONTRIBUTOR_ADDED",
				i = "WIKI_BANNED_CONTRIBUTOR_REMOVED",
				d = "WIKI_BANNED_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			}));
			const s = "WIKI_CONTRIBUTORS_PENDING",
				r = "WIKI_CONTRIBUTORS_LOADED",
				o = "WIKI_CONTRIBUTORS_FAILED",
				a = "MORE_WIKI_CONTRIBUTORS_LOADED",
				c = "WIKI_CONTRIBUTOR_ADDED",
				i = "WIKI_CONTRIBUTOR_REMOVED",
				d = "WIKI_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiDiff/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "WIKI_DIFF_PENDING",
				r = "WIKI_DIFF_LOADED",
				o = "WIKI_DIFF_FAILED"
		},
		"./src/reddit/actions/wiki/wikiEditing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "WIKI_PAGE_SAVE_SUCCESS"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_SETTINGS_LOADED",
				r = "SUBREDDIT_WIKI_PAGE_SETTINGS_UPDATED",
				o = "SUBREDDIT_WIKI_PAGE_CONTRIBUTOR_REOVED",
				a = "SUBREDDIT_WIKI_PAGE_MORE_CONTRIBUTORS_LOADED"
		},
		"./src/reddit/actions/wiki/wikiRevisions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			}));
			const s = "WIKI_REVISIONS_PENDING",
				r = "WIKI_REVISIONS_LOADED",
				o = "WIKI_REVISIONS_FAILED",
				a = "WIKI_PAGE_REVERT_SUCCESS",
				c = "WIKI_REVISION_TOGGLE_VISIBILITY"
		},
		"./src/reddit/components/Flatlist/getFlatlistTooltipId.ts": function(e, t, n) {
			"use strict";
			t.a = (e, t, n) => {
				const s = "".concat(e, "--").concat(t);
				return n ? "".concat(s, "--").concat(n) : s
			}
		},
		"./src/reddit/components/GildModal/getGildModalId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			}));
			const s = (e, t) => {
				const n = "".concat("GILD_MODAL_ID", "-[thingId: ").concat(e, "]");
				return void 0 !== t ? n + "-isOverlay[".concat(t, "]") : n
			};
			t.a = s
		},
		"./src/reddit/components/Gold/AwardKarmaToastMessage/index.m.less": function(e, t, n) {
			e.exports = {
				karmaLink: "_33-F8KNeBDS4RS9mUMQdxH"
			}
		},
		"./src/reddit/components/ModerationPrompts/useActivePromptId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./node_modules/react-redux/es/index.js");
			const r = e => e.moderationPromptId;

			function o(e, t) {
				return Object(s.d)(r) === a(e.id, t)
			}

			function a(e, t) {
				return "prompt-".concat(e).concat(t ? "-overlay" : "")
			}
		},
		"./src/reddit/components/NotificationBanners/bannerIds.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.EmailCollectionBannerId = "email-collection-banner-id"
				}(s || (s = {}))
		},
		"./src/reddit/components/Settings/modalIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "f", (function() {
				return O
			}));
			const s = "change_email_modal_id",
				r = "check_email_modal_id",
				o = "set_email_modal_id",
				a = "verify_email_modal_id",
				c = "reset_pw_sso_email_modal_id",
				i = "reset_pw_sso_google_link_modal_id",
				d = "reset_pw_sso_google_unlink_modal_id",
				u = "reset_pw_sso_apple_link_modal_id",
				l = "reset_pw_sso_apple_unlink_modal_id",
				b = "reset_pw_sso_deactivate_account_modal_id",
				p = "change_username_modal_id",
				f = "confirm_save_username_modal_id",
				m = "intercept_action_modal_id",
				O = "second_confirm_keep_username_modal_id"
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/index.ts");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const d = r.a.createContext(() => {});

			function u(e) {
				let {
					children: t
				} = e;
				const n = Object(o.e)(),
					i = Object(s.useCallback)(e => {
						{
							const t = n.getState(),
								s = e(t);
							Object(c.a)(Object.assign({}, a.defaults(t), s))
						}
					}, [n]);
				return r.a.createElement(d.Provider, {
					value: i
				}, t ? r.a.Children.only(t) : null)
			}

			function l() {
				return Object(s.useContext)(d)
			}

			function b(e) {
				return function(t) {
					const n = l();
					return r.a.createElement(e, i({}, t, {
						sendEvent: n
					}))
				}
			}
		},
		"./src/reddit/constants/actions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "@@router/CALL_HISTORY_METHOD"
		},
		"./src/reddit/constants/adViewability.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "j", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			}));
			const s = .01,
				r = .5,
				o = 1,
				a = [r, o, s],
				c = 1e3,
				i = 100,
				d = 5e3,
				u = 15e3,
				l = 0,
				b = 2e3,
				p = 3e3
		},
		"./src/reddit/constants/cookie.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			}));
			const s = "USER",
				r = "alphaModal",
				o = "over18",
				a = "mod_mode_enabled",
				c = "recent_srs",
				i = "_recentclicks2",
				d = "eu_cookie_v2",
				u = "uapp_cookie",
				l = "nightmode",
				b = "_options"
		},
		"./src/reddit/constants/errors.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.BannedProfile = "BANNED", e.DeletedProfile = "DELETED", e.NotFoundProfile = "NOT_FOUND", e.ForbiddenProfile = "FORBIDDEN"
				}(s || (s = {})),
				function(e) {
					e.Unknown = "Unknown"
				}(r || (r = {}))
		},
		"./src/reddit/constants/gold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			}));
			const s = "ModerationPage--Modal--AddAward",
				r = "ModerationPage--Modal--DeleteAwardConfirmation",
				o = 20,
				a = 4,
				c = 1e4,
				i = .2,
				d = .1,
				u = .1,
				l = 500
		},
		"./src/reddit/constants/graphql.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(s || (s = {}))
		},
		"./src/reddit/constants/inFeedChaining.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = 3,
				r = 5,
				o = 10
		},
		"./src/reddit/constants/modals.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.ADD_REMOVAL_REASON = "add_removal_reason", e.ALPHA_CONSUMER = "alpha_consumer", e.BADGE_PICKER = "badge_picker", e.BADGE_PURCHASE = "badge_purchase", e.BAN_USER = "ban_user", e.BLADE_NIGHTMODE = "blade_nightmode", e.BLADE_UNSAVED_CHANGES = "blade_unsaved_changes", e.CHANGE_PASSWORD_MODAL_ID = "account_manager_change_password", e.CONFIRM_CLOSE_COIN_MODAL_ID = "confirm_close_coin_modal_id", e.CONFIRM_CLOSE_PREMIUM_MODAL_ID = "confirm_close_premium_modal_id", e.CONTRIBUTOR_REQUEST = "contributor_request", e.CONTRIBUTOR_REQUEST_PENDING = "contributor_request_pending", e.CREATE_SUBREDDIT_CHAT = "create_subreddit_chat", e.DELETE_SUBREDDIT_CHAT = "delete_subreddit_chat", e.DISABLE_TWO_FACTOR = "disable_2fa_modal", e.DOWN_TO_CHAT_PENDING_MODAL = "down_to_chat_pending_modal", e.ECONOMY_SUPPORT_MODAL = "economy_support_modal", e.EDIT_SUBREDDIT_CHAT = "edit_subreddit_chat", e.ENABLE_TWO_FACTOR = "enable_2fa_modal", e.GOLD_GILD_ANIMATION_OVERLAY = "gold_gild_animation_overlay", e.GOLD_TARGETED_OFFER_MODAL = "gold_targeted_offer", e.GOVERNANCE_OPT_OUT = "governance_opt_out", e.GOVERNANCE_RELEASE_NOTES = "governance_release_notes", e.HARBERGER_TAX_CRYPTO_BANNER_MANAGE = "harberger_tax_crypto_banner_manage", e.HARBERGER_TAX_CRYPTO_BANNER_PURCHASE = "hargerger_tax_crypto_banner_purchase", e.HARBERGER_TAX_BANNER_MANAGE = "harberger_tax_banner_manage", e.HARBERGER_TAX_BANNER_PURCHASE = "harberger_tax_banner_purchase", e.KEYBOARD_SHORTCUTS = "keyboard_shortcuts", e.LINK_APPLE_SSO = "link_apple_sso", e.LINK_GOOGLE_SSO = "link_google_sso", e.LOGIN_MODAL_ID = "account_manager_login", e.MANAGE_SUBREDDIT_CHAT = "manage_subreddit_chat", e.MOD_TO_MEMBER_SHARE = "mod_to_member_share", e.CROWD_CONTROL = "crowd_control", e.MULTIREDDIT_ADD_SUBREDDIT = "multireddit_add_subreddit", e.MULTIREDDIT_CREATE = "multireddit_create", e.MULTIREDDIT_DUPLICATE = "multireddit_duplicate", e.MULTIREDDIT_EDIT = "multireddit_edit", e.MUTE_USER = "mute_user", e.PINNED_POSTS_LIMIT_REACHED = "pinned_posts_limit_reached", e.REDESIGN_MODAL = "redesign_modal", e.REGISTER_MODAL_ID = "account_manager_register", e.SPEZ_MODAL = "spez_modal", e.SUBREDDIT_CHAT_SETTINGS = "subreddit_chat_settings", e.SUBREDDIT_PREMIUM_BADGE_MANAGEMENT = "subreddit_premium_badge_management", e.SUBREDDIT_PREMIUM_GIFT_MODAL = "subreddit_premium_gift", e.SUBREDDIT_PREMIUM_PURCHASE_MODAL = "subreddit_premium_purchase", e.SUBREDDIT_PREMIUM_UPLOAD_MODAL = "subreddit_premium_upload", e.TRANSFER_POINTS = "community_points_transfer", e.TWO_FACTOR_BACKUP_CODES = "two_factor_backup_codes", e.UNLINK_APPLE_SSO = "unlink_apple_sso", e.UNLINK_GOOGLE_SSO = "unlink_google_sso", e.USER_FLAIR_MODAL_ID = "user_flair_modal", e.WALLET_REGISTRATION_MODAL = "wallet_registration_modal"
				}(s || (s = {}))
		},
		"./src/reddit/constants/preferences.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			}));
			const s = "rpanDuDismissalTime",
				r = "showRpanDu",
				o = "topContentDismissalTime",
				a = "topContentTimesDismissed",
				c = [...["openPostInNewTab", "rememberCommunitySort", "sort", "stylesEnabled", "useMarkdown", "layout", "rememberCommunityLayout", "hasSeenCustomizeFlyout", s, r, o, a], "activityRelevantAds", "thirdPartyDataPersonalizedAds", "thirdPartySiteDataPersonalizedAds", "thirdPartySiteDataPersonalizedContent", "showLocationBasedRecommendations"]
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "d", (function() {
					return s
				})), n.d(t, "c", (function() {
					return r
				})), n.d(t, "b", (function() {
					return o
				})), n.d(t, "a", (function() {
					return a
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue"
				}(s || (s = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				a = [9, 13, 32]
		},
		"./src/reddit/constants/thumbnails.ts": function(e, t, n) {
			"use strict";
			var s;
			! function(e) {
				e.NSFW = "nsfw", e.SELF = "self", e.IMAGE = "image", e.DEFAULT = "default", e.SPOILER = "spoiler"
			}(s || (s = {})), t.a = s
		},
		"./src/reddit/constants/tracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = {
					CLICK: "click",
					CLOSE: "close",
					COMPLETE: "complete",
					DISABLE: "disable",
					DRAG: "drag",
					ENABLE: "enable",
					REJECT: "reject",
					SELECT: "select",
					START: "start",
					STOP: "stop",
					VIEW: "view"
				},
				r = {
					POST: "post",
					SCREEN: "screen"
				},
				o = "media-element"
		},
		"./src/reddit/constants/video.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return s
			})), n.d(t, "l", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "j", (function() {
				return f
			}));
			const s = 250,
				r = 500,
				o = 25,
				a = 50,
				c = 75,
				i = 95,
				d = 100,
				u = [o, a, c, i, d],
				l = 3,
				b = 5,
				p = 10,
				f = [l, b, p]
		},
		"./src/reddit/constants/viewabilityEvents.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e[e.Viewable = 1] = "Viewable", e[e.VideoViewable = 2] = "VideoViewable", e[e.VideoFullyViewable = 3] = "VideoFullyViewable", e[e.Impression = 4] = "Impression", e[e.VendorFullyViewable = 10] = "VendorFullyViewable", e[e.VendorFullyViewableSeconds5 = 11] = "VendorFullyViewableSeconds5", e[e.VendorFullyViewableSeconds15 = 12] = "VendorFullyViewableSeconds15", e[e.GroupMViewable = 13] = "GroupMViewable", e[e.VideoGroupMViewable = 113] = "VideoGroupMViewable", e[e.VideoVendorFullyViewable50 = 114] = "VideoVendorFullyViewable50", e[e.MRCVideoViewableImpression = 115] = "MRCVideoViewableImpression"
				}(s || (s = {}))
		},
		"./src/reddit/customMiddleware/gqlContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			}));
			var s = n("./src/config.ts");
			const r = e => {
					let {
						apiUrl: t,
						onBeforeRequest: n,
						onResponse: s,
						statsAppName: r,
						headers: o
					} = e;
					return {
						apiUrl: t,
						onBeforeRequest: n,
						onResponse: s,
						statsAppName: r,
						headers: o()
					}
				},
				o = {
					unsafeLoggedOut: !1,
					accessToken: ""
				};
			t.a = e => {
				let t = () => o;
				return {
					gqlContext: () => {
						const {
							headers: n,
							onBeforeRequest: r,
							onResponse: o,
							statsAppName: a
						} = e();
						return {
							apiUrl: s.a.gqlUrl,
							onBeforeRequest: r,
							onResponse: o,
							statsAppName: a,
							headers: () => (e => {
								const {
									unsafeLoggedOut: n,
									accessToken: s
								} = t();
								return n ? Object.assign({}, e, {
									Authorization: "Bearer ".concat(s)
								}) : Object.assign({}, e)
							})(n)
						}
					},
					middleware: e => (t = () => (e => {
						if (!e.user.session) return o;
						const {
							unsafeLoggedOut: t,
							accessToken: n
						} = e.user.session;
						return {
							unsafeLoggedOut: !!t,
							accessToken: n
						}
					})(e.getState()), e => t => e(t))
				}
			}
		},
		"./src/reddit/endpoints/accounts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			const i = async (e, t) => Object(o.b)(Object(a.a)(e, [c.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/block_user"),
				method: r.ab.POST
			}), d = async (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
				data: {
					name: n,
					container: t,
					type: "enemy"
				},
				endpoint: "".concat(e.apiUrl, "/api/unfriend"),
				method: r.ab.POST
			}), u = async (e, t) => Object(o.b)(Object(a.a)(e, [c.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/add_whitelisted?include_model"),
				method: r.ab.POST
			}), l = async (e, t) => Object(o.b)(Object(a.a)(e, [c.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/remove_whitelisted"),
				method: r.ab.POST
			}), b = async (e, t) => Object(o.b)(Object(a.a)(e, [c.a]), {
				endpoint: "".concat(s.a.oauthUrl, "/user/").concat(t, "/about"),
				method: r.ab.GET,
				data: {
					raw_json: 1
				}
			})
		},
		"./src/reddit/endpoints/category/subreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				i = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = e => {
				const t = [],
					n = [],
					s = {},
					r = {};
				return e.data.children.forEach(e => {
					let {
						data: o
					} = e;
					const a = Object(c.a)(o);
					t.push(a.id), n.push(a.name), s[a.id] = a, r[a.id] = {
						accountsActive: o.accounts_active,
						allOriginalContent: o.all_original_content,
						bannerBackgroundColor: o.banner_background_color,
						bannerBackgroundImage: o.banner_background_image,
						contentCategory: o.content_category,
						allowChatPostCreation: o.allow_chat_post_creation,
						keyColor: o.key_color,
						originalContentTagEnabled: o.original_content_tag_enabled,
						publicDescription: o.public_description,
						subscribers: o.subscribers,
						userIsSubscriber: o.user_is_subscriber
					}
				}), {
					subredditIds: t,
					subredditNames: n,
					subreddits: s,
					subredditsAboutInfo: r
				}
			};
			t.a = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
				return Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(i.a)("".concat(e.apiUrl, "/api/subreddits_in_category.json?category_id=").concat(t, "&limit=").concat(n)),
					method: s.ab.GET
				})
			}
		},
		"./src/reddit/endpoints/chat/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "j", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			const i = "api/v1",
				d = "".concat(i, "/sendbird");
			var u;
			! function(e) {
				e.PUBLIC = "all"
			}(u || (u = {}));
			const l = 10,
				b = 10;
			class p extends Error {
				constructor(e, t) {
					super(e), this.response = t
				}
			}
			const f = async (e, t, n) => {
				const d = {};
				return n && (d.public_mode = u.PUBLIC), Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(i, "/subreddit/").concat(t, "/channels"),
					method: r.ab.GET,
					data: d
				})
			}, m = async (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
				endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(i, "/subreddit/channels/create"),
				method: r.ab.POST,
				data: JSON.stringify({
					room: n.room,
					room_type: n.roomType,
					description: n.description,
					subreddit: n.subreddit,
					automute_account_age_threshold: n.minimumAcctAge,
					automute_on_join_duration: n.newMemberAge
				})
			}), O = async (e, t, n, d) => Object(o.b)(Object(a.a)(e, [c.a]), {
				endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(i, "/subreddit/channels/").concat(t),
				method: r.ab.PUT,
				data: JSON.stringify({
					room: d.room,
					description: d.description,
					automute_account_age_threshold: d.minimumAcctAge,
					automute_on_join_duration: d.newMemberAge
				})
			}), g = async (e, t) => Object(o.b)(Object(a.a)(e, [c.a]), {
				endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(i, "/subreddit/channels/").concat(t),
				method: r.ab.DELETE
			}), _ = async e => Object(o.b)(Object(a.a)(e, [c.a]), {
				endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(d, "/config"),
				method: r.ab.GET
			});
			var y, j;

			function h(e) {
				const t = {
					bannedWords: e.profanity_filter && e.profanity_filter.keywords,
					regexes: e.profanity_filter && e.profanity_filter.regex_filters,
					rateLimit: e.user_messages_per_channel,
					domains: e.domain_filter && e.domain_filter.domains && e.domain_filter.domains.join(", "),
					useDefaultProfanityFilter: e.profanity_filter && e.profanity_filter.should_check_global,
					domainFilterOption: void 0
				};
				if (!1 === e.allow_links) t.domainFilterOption = j.BLOCK_ALL_DOMAINS;
				else {
					const {
						domain_filter: {
							type: n
						} = {
							type: void 0
						}
					} = e;
					n === y.BLOCK_MODE ? t.domainFilterOption = j.BLOCK_BANNED_DOMAINS : n === y.ALLOW_MODE ? t.domainFilterOption = j.ALLOW_APPROVED_DOMAINS : t.domainFilterOption = j.ALLOW_ALL_DOMAINS
				}
				return t
			}

			function E(e) {
				const t = {};
				return e.rateLimit && e.rateLimit > 0 && (t.user_messages_per_channel = e.rateLimit, t.user_messages_per_channel_duration = b), void 0 === e.bannedWords && void 0 === e.regexes && void 0 === e.useDefaultProfanityFilter || (t.profanity_filter = {
					keywords: e.bannedWords,
					regex_filters: e.regexes,
					should_check_global: e.useDefaultProfanityFilter
				}), e.domainFilterOption === j.BLOCK_ALL_DOMAINS ? (t.allow_links = !1, t.domain_filter = {
					type: y.DISABLE
				}) : e.domainFilterOption === j.ALLOW_ALL_DOMAINS ? (t.allow_links = !0, t.domain_filter = {
					type: y.DISABLE
				}) : e.domainFilterOption === j.ALLOW_APPROVED_DOMAINS && e.domains ? (t.allow_links = !0, t.domain_filter = {
					type: y.ALLOW_MODE,
					domains: e.domains.split(",")
				}) : e.domainFilterOption === j.BLOCK_BANNED_DOMAINS && e.domains && (t.allow_links = !0, t.domain_filter = {
					type: y.BLOCK_MODE,
					domains: e.domains.split(",")
				}), t
			}
			async function I(e, t) {
				const n = await Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(i, "/chat/subreddit/").concat(t, "/settings"),
					method: r.ab.GET
				});
				if (n.ok && n.body) return h(n.body)
			}
			async function v(e, t, n) {
					const d = await Object(o.b)(Object(a.a)(e, [c.a]), {
						endpoint: "".concat(s.a.sendbirdServiceUrl, "/").concat(i, "/chat/subreddit/").concat(t, "/settings"),
						method: r.ab.PUT,
						data: JSON.stringify(E(n))
					});
					if (d.ok && d.body) return Object.assign({}, d, {
						body: h(d.body)
					});
					throw new p("Failed to update subreddit chat settings", d)
				}! function(e) {
					e[e.BLOCK_MODE = 2] = "BLOCK_MODE", e[e.ALLOW_MODE = 1] = "ALLOW_MODE", e[e.DISABLE = 0] = "DISABLE"
				}(y || (y = {})),
				function(e) {
					e.ALLOW_ALL_DOMAINS = "Allow all domains", e.ALLOW_APPROVED_DOMAINS = "Allow links to approved domains", e.BLOCK_BANNED_DOMAINS = "Block links to banned domains", e.BLOCK_ALL_DOMAINS = "Block all domains"
				}(j || (j = {}))
		},
		"./src/reddit/endpoints/economics/tips.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");

			function o(e, t) {
				return Object(r.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: "".concat(s.a.metaUrl, "/tips-details/").concat(t.subredditId),
					method: "post",
					data: {
						contentIds: t.contentIds
					}
				})
			}
		},
		"./src/reddit/endpoints/flair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				i = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t, n, s, i, d) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(n, "/api/selectflair"),
					method: r.ab.POST,
					data: {
						api_type: "json",
						flair_template_id: s,
						name: t,
						text: i,
						css_class: d
					}
				}),
				u = (e, t, n, s) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/selectflair"),
					method: r.ab.POST,
					data: {
						api_type: "json",
						flair_template_id: n,
						link: t,
						text: s
					}
				}),
				l = (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(n, "/api/setflairenabled"),
					method: r.ab.POST,
					data: {
						api_type: "json",
						flair_enabled: t
					}
				}),
				b = async (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_user_flair.json"),
					method: r.ab.POST,
					data: {
						subreddit: t,
						enabled: n
					}
				}), p = async (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_link_flair.json"),
					method: r.ab.POST,
					data: {
						subreddit: t,
						enabled: n
					}
				}), f = async (e, t, n, s) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_user_flair_self_assign.json"),
					method: r.ab.POST,
					data: {
						subreddit: s,
						flair_type: n,
						enabled: t
					}
				}), m = async (e, t, n, s) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/flairtemplate_v2"),
					method: r.ab.POST,
					data: {
						allowable_content: t.allowableContent,
						css_class: t.cssClass,
						flair_template_id: t.id,
						text: t.text,
						text_editable: t.textEditable,
						flair_type: s,
						text_color: t.textColor,
						background_color: t.backgroundColor,
						max_emojis: t.maxEmojis,
						mod_only: t.modOnly,
						r: n
					}
				}), O = async (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/deleteflairtemplate"),
					method: r.ab.POST,
					data: {
						flair_template_id: t,
						r: n
					}
				}), g = async (e, t, n, s) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_template_order/").concat(n),
					method: r.ab.PATCH,
					type: "json",
					data: s
				}), _ = async (e, t) => Object(o.b)(e, {
					endpoint: "".concat(s.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t, "/userFlair"),
					method: r.ab.GET,
					headers: {
						[c.a]: c.a
					}
				}), y = async (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(n, "/api/deleteflair"),
					method: r.ab.POST,
					data: {
						api_type: "json",
						name: t
					}
				}), j = async (e, t) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: Object(i.a)("".concat(e.apiUrl, "/api/top_flair_in_subreddit.json?subreddit=").concat(t)),
					method: r.ab.GET
				})
		},
		"./src/reddit/endpoints/gold/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return j
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "c", (function() {
				return I
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "f", (function() {
				return S
			})), n.d(t, "j", (function() {
				return T
			})), n.d(t, "i", (function() {
				return D
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "l", (function() {
				return w
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "h", (function() {
				return R
			})), n.d(t, "e", (function() {
				return P
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/graphql/operations/DeleteAward.json"),
				c = n("./src/graphql/operations/DisableAward.json"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/lib/uploadToS3/index.ts"),
				u = n("./src/graphql/operations/CommunityAwardsBlacklistStatus.json"),
				l = n("./src/graphql/operations/CreateCommunityAward.json"),
				b = n("./src/graphql/operations/CreateGlobalAward.json"),
				p = n("./src/graphql/operations/CreateModAward.json"),
				f = n("./src/graphql/operations/GlobalAwards.json"),
				m = n("./src/graphql/operations/ManageableAwards.json"),
				O = n("./src/graphql/operations/UsableAwards.json"),
				g = n("./src/graphql/operations/UsableAwardsForProfile.json"),
				_ = n("./src/reddit/constants/headers.ts"),
				y = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const j = (e, t, n, o) => {
					const a = {
						subreddit: t,
						filepath: n,
						mimetype: o
					};
					return Object(r.b)(Object(i.a)(e, [_.a]), {
						method: s.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/v1/community_awards/award_asset_upload_s3"),
						data: a
					})
				},
				h = async (e, t) => Object(d.a)(t, e), E = (e, t, n, s, r, a, c, i, d) => Object(o.a)(e, Object.assign({}, l, {
					variables: {
						coinPrice: c,
						iconHeight: a,
						iconWidth: r,
						iconUrl: s,
						name: n,
						subredditId: t,
						startsAt: i,
						endsAt: d
					}
				})), I = (e, t, n, s, r, a, c, i, d) => Object(o.a)(e, Object.assign({}, p, {
					variables: {
						iconHeight: a,
						iconWidth: r,
						iconUrl: s,
						monthsOfPremium: c,
						name: n,
						subredditId: t,
						startsAt: i,
						endsAt: d
					}
				})), v = e => {
					let {
						awardSubType: t,
						coinPrice: n,
						coinReward: s,
						context: r,
						daysOfDripExtension: a,
						daysOfPremium: c,
						description: i,
						endsAt: d,
						giverCoinReward: u,
						iconFormat: l,
						iconHeight: p,
						iconUrl: f,
						iconWidth: m,
						isNew: O,
						name: g,
						pennyPrice: _,
						pennyDonate: y,
						startsAt: j,
						subredditCoinReward: h
					} = e;
					return Object(o.a)(r, Object.assign({}, b, {
						variables: {
							awardSubType: t,
							iconFormat: l,
							iconHeight: p,
							iconWidth: m,
							iconUrl: f,
							isNew: O,
							daysOfPremium: c,
							daysOfDripExtension: a,
							description: i,
							coinPrice: n,
							coinReward: s,
							name: g,
							pennyPrice: _,
							pennyDonate: y,
							giverCoinReward: u,
							startsAt: j,
							endsAt: d,
							subredditCoinReward: h
						}
					}))
				}, S = (e, t) => Object(o.a)(e, Object.assign({}, u, {
					variables: {
						subredditId: t
					}
				})), T = (e, t) => Object(o.a)(e, Object.assign({}, m, {
					variables: {
						subredditId: t
					}
				})), D = e => Object(o.a)(e, Object.assign({}, f)), C = (e, t, n) => Object(o.a)(e, Object.assign({}, O, {
					variables: {
						subredditId: t,
						includeAppreciation: !0,
						includePremium: n
					}
				})), w = (e, t, n) => Object(o.a)(e, Object.assign({}, g, {
					variables: {
						profileName: t,
						includeAppreciation: !0,
						includePremium: n
					}
				})), A = (e, t) => Object(o.a)(e, Object.assign({}, a, {
					variables: {
						awardId: t
					}
				})), R = (e, t) => Object(o.a)(e, Object.assign({}, c, {
					variables: {
						awardId: t
					}
				})), P = async (e, t, n) => {
					const o = {
						api_type: "json",
						award_id: t,
						raw_json: 1
					};
					return Object(r.b)(Object(i.a)(e, [_.a]), {
						method: s.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/report_award"),
						data: o
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
						error: Object(y.a)(e)
					}))
				}
		},
		"./src/reddit/endpoints/gold/paypalPurchases.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				i = n("./src/reddit/endpoints/gold/purchase.ts");
			const d = async e => {
				let {
					buttonId: t,
					context: n,
					correlationId: d
				} = e;
				const u = {
						button_id: t,
						correlation_id: d
					},
					l = "".concat(n.apiUrl, "/api/v2/gold/paypal/initiate_premium_payment"),
					b = Object(c.a)(l);
				return Object(r.b)(Object(o.a)(n, [a.a]), {
					method: s.ab.POST,
					endpoint: b,
					data: u
				}).then(i.c)
			}, u = async e => {
				let {
					context: t,
					coins: n,
					pennies: c,
					correlationId: d
				} = e;
				const u = {
					coins: n,
					pennies: c,
					correlation_id: d
				};
				return Object(r.b)(Object(o.a)(t, [a.a]), {
					method: s.ab.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/create_coin_purchase_order"),
					data: u
				}).then(i.c)
			}, l = async e => {
				let {
					context: t,
					awardId: n,
					pennies: c,
					thingId: d,
					correlationId: u
				} = e;
				const l = {
					award_id: n,
					correlation_id: u,
					pennies: c,
					thing_id: d
				};
				return Object(r.b)(Object(o.a)(t, [a.a]), {
					method: s.ab.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/create_award_purchase_order"),
					data: l
				}).then(i.c)
			}, b = async e => {
				let {
					context: t,
					orderId: n,
					coins: c,
					pennies: d,
					correlationId: u
				} = e;
				const l = {
					order_id: n,
					coins: c,
					pennies: d,
					correlation_id: u
				};
				return Object(r.b)(Object(o.a)(t, [a.a]), {
					method: s.ab.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/execute_coin_order"),
					data: l
				}).then(i.c)
			}, p = async e => {
				let {
					awardId: t,
					context: n,
					coins: c,
					correlationId: d,
					isAnonymous: u,
					message: l,
					orderId: b,
					pennies: p,
					thingId: f
				} = e;
				const m = {
					award_id: t,
					coins: c,
					correlation_id: d,
					is_anonymous: u,
					message: l,
					order_id: b,
					pennies: p,
					thing_id: f
				};
				return Object(r.b)(Object(o.a)(n, [a.a]), {
					method: s.ab.POST,
					endpoint: "".concat(n.apiUrl, "/api/v2/gold/paypal/execute_coin_with_gild_order"),
					data: m
				}).then(i.c)
			}, f = async e => {
				let {
					awardId: t,
					context: n,
					correlationId: c,
					isAnonymous: d,
					message: u,
					orderId: l,
					thingId: b
				} = e;
				const p = {
					award_id: t,
					correlation_id: c,
					is_anonymous: d,
					message: u,
					order_id: l,
					thing_id: b
				};
				return Object(r.b)(Object(o.a)(n, [a.a]), {
					method: s.ab.POST,
					endpoint: "".concat(n.apiUrl, "/api/v2/gold/paypal/execute_award_purchase_order"),
					data: p
				}).then(i.c)
			}
		},
		"./src/reddit/endpoints/gold/purchase.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return g
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				i = n("./src/reddit/helpers/genericServerError/index.ts"),
				d = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const u = e => e.ok ? e.body.json && e.body.json.errors.length ? Object.assign({}, e, {
					ok: !1,
					error: Object(d.a)(e)
				}) : Object.assign({}, e) : Object.assign({}, e, {
					error: e.error || Object(i.a)()
				}),
				l = async e => {
					let {
						coins: t,
						context: n,
						correlationId: i,
						language: d,
						pennies: l,
						rememberCard: b,
						token: p,
						savedCardId: f
					} = e;
					const m = {
							token: p ? p.id : void 0,
							coins: t,
							pennies: l,
							remember_card: b,
							card_id: f,
							correlation_id: i
						},
						O = "".concat(n.apiUrl, "/api/v2/gold/stripe/buy_coins"),
						g = Object(c.a)(O);
					return Object(r.b)(Object(o.a)(n, [a.a]), {
						method: s.ab.POST,
						endpoint: g,
						data: m
					}).then(u)
				}, b = async e => {
					let {
						coins: t,
						context: n,
						correlationId: i,
						gildParams: d,
						isOldReddit: l,
						language: b,
						pennies: p,
						rememberCard: f,
						thingId: m,
						token: O,
						savedCardId: g
					} = e;
					const {
						gildType: _,
						includeMessage: y,
						isAnonymous: j,
						message: h
					} = d, E = {
						token: O ? O.id : void 0,
						coins: t,
						pennies: p,
						thing_id: m,
						gild_type: _,
						message: y ? h : "",
						is_anonymous: j,
						remember_card: f,
						card_id: g,
						correlation_id: i
					}, I = "".concat(n.apiUrl, "/api/v2/gold/stripe/buy_coins_and_gild"), v = l ? I : Object(c.a)(I);
					return Object(r.b)(Object(o.a)(n, [a.a]), {
						method: s.ab.POST,
						endpoint: v,
						data: E
					}).then(u)
				}, p = async e => {
					let {
						context: t,
						correlationId: n,
						gildParams: i,
						isOldReddit: d,
						pennies: l,
						rememberCard: b,
						thingId: p,
						token: f,
						savedCardId: m
					} = e;
					const {
						gildType: O,
						includeMessage: g,
						isAnonymous: _,
						message: y
					} = i, j = {
						token: f ? f.id : void 0,
						thing_id: p,
						award_id: O,
						message: g ? y : "",
						is_anonymous: _,
						pennies: l,
						remember_card: b,
						card_id: m,
						correlation_id: n
					}, h = "".concat(t.apiUrl, "/api/v2/gold/stripe/buy_award"), E = d ? h : Object(c.a)(h);
					return Object(r.b)(Object(o.a)(t, [a.a]), {
						method: s.ab.POST,
						endpoint: E,
						data: j
					}).then(u)
				}, f = async e => {
					let {
						context: t,
						correlationId: n,
						pennies: i,
						token: d
					} = e;
					const l = {
							token: d.id,
							pennies: i,
							correlation_id: n
						},
						b = "".concat(t.apiUrl, "/api/v2/gold/stripe/buy_premium_subscription"),
						p = Object(c.a)(b);
					return Object(r.b)(Object(o.a)(t, [a.a]), {
						method: s.ab.POST,
						endpoint: p,
						data: l
					}).then(u)
				}, m = async (e, t) => {
					const n = {
						token: t.id
					};
					return Object(r.b)(Object(o.a)(e, [a.a]), {
						method: s.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/update_creditcard"),
						data: n
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
						error: Object(d.a)(e)
					}))
				}, O = async (e, t) => {
					const n = {
						card_id: t
					};
					return Object(r.b)(Object(o.a)(e, [a.a]), {
						method: s.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/delete_creditcard"),
						data: n
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
						error: Object(d.a)(e)
					}))
				}, g = async e => Object(r.b)(Object(o.a)(e, [a.a]), {
					method: s.ab.GET,
					endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/creditcards")
				}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
					error: Object(d.a)(e)
				}))
		},
		"./src/reddit/endpoints/governance/badges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");
			async function o(e, t, n) {
				const o = Object(r.a)(e, {
						headers: {
							"X-HTTP-Method-Override": "GET"
						},
						method: "post",
						endpoint: "".concat(s.a.metaUrl, "/badges/").concat(t),
						data: {
							selected: !0,
							users: n
						}
					}),
					a = await o;
				if (a.ok) {
					const e = {},
						t = {},
						n = a.body;
					return Object.keys(n).forEach(s => {
						const r = n[s];
						t[s] = r, e[r.userId] || (e[r.userId] = []), e[r.userId].push(r.id)
					}), Object.assign({}, a, {
						body: {
							badges: t,
							usersAppliedBadges: e
						}
					})
				}
				return a
			}
			async function a(e, t, n) {
				const o = await Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(s.a.metaUrl, "/badges/").concat(t, "?users=").concat(n)
				});
				if (o.ok) {
					const e = {},
						t = [],
						n = o.body;
					return Object.keys(n).forEach(s => {
						const r = n[s];
						e[s] = r, t.push(r.id)
					}), Object.assign({}, o, {
						body: {
							badges: e,
							userOwnedBadges: t
						}
					})
				}
				return o
			}

			function c(e, t, n) {
				let o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
				return Object(r.a)(e, {
					method: "patch",
					endpoint: "".concat(s.a.metaUrl, "/badges/").concat(t, "/").concat(n),
					data: {
						selected: o
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/community.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function a(e, t) {
				return Object(o.a)(e, {
					endpoint: "".concat(s.a.metaUrl, "/communities/").concat(t.subredditId, "/me"),
					method: r.ab.GET
				})
			}
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/reddit/models/Poll/index.ts"), n("./src/reddit/endpoints/governance/requester.ts"));

			function o(e, t, n) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(s.a.metaUrl, "/polls/").concat(t, "?postIds=").concat(n.join(","))
				})
			}
		},
		"./src/reddit/endpoints/governance/products/badges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			}));
			var s = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");

			function o(e, t) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(s.a.metaUrl, "/products/").concat(t, "?types=badge")
				})
			}

			function a(e, t) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(s.a.metaUrl, "/products/").concat(t, "?types=badge,membership")
				})
			}

			function c(e, t) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: "".concat(s.a.metaUrl, "/orders"),
					data: t
				})
			}

			function i(e, t) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: "".concat(s.a.metaUrl, "/orders"),
					data: {
						currency: "usd",
						price: t.price,
						products: t.products,
						providerArgs: {
							paymentNonce: t.nonce
						},
						providerName: "braintree",
						subredditId: t.subredditId
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/makeApiRequest/index.ts");

			function r(e, t) {
				return Object(s.b)(e, Object.assign({
					type: "json"
				}, t)).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : Object.assign({}, e.body, {
							code: e.status
						}),
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/me/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts");
			const a = e => Object(o.b)(e, {
				endpoint: "".concat(s.a.gatewayUrl, "/desktopapi/v1/me"),
				method: r.ab.GET
			})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				i = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t, n) => Object(o.b)(e, {
					endpoint: Object(i.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/").concat(t)),
					method: r.ab.GET,
					data: Object.assign({
						moderated_limit: 25
					}, n)
				}),
				u = (e, t, n) => Object(o.b)(Object(a.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/modactions/").concat(t),
					method: r.ab.POST,
					type: "json",
					data: n
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts");
			t.a = async e => Object(r.b)(Object(o.a)(e, [a.a]), {
				endpoint: "".concat(e.apiUrl, "/subreddit_permissions"),
				method: s.ab.GET,
				traceRequestName: "get_subreddit_permissions"
			})
		},
		"./src/reddit/endpoints/moderator/structuredStyles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "a", (function() {
				return _
			}));
			var s = n("./src/graphql/operations/SubredditPostFlairStyleTemplates.json"),
				r = n("./src/graphql/operations/SubredditStyles.json"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/lib/uploadToS3/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				l = n("./src/reddit/helpers/media/index.ts");
			const b = async (e, t, n) => Object(a.b)(Object(i.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: o.ab.GET,
				data: {
					progressive_images: n
				}
			}), p = async (e, t, n) => Object(a.b)(Object(i.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: o.ab.PATCH,
				data: n
			}), f = async (e, t) => Object(a.b)(Object(i.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: o.ab.DELETE
			}), m = async (e, t, n, s, r) => Object(a.b)(Object(i.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/style_asset_upload_s3/").concat(t),
				method: o.ab.POST,
				data: {
					filepath: n,
					imagetype: s,
					mimetype: r
				}
			}), O = async (e, t, n, s) => {
				const r = await Object(l.g)(s),
					o = await m(e, t, s.name, n, r);
				if (!o.ok) return o;
				let a = o.body;
				return "s3UploadLease" in a && (a = a.s3UploadLease), Object(d.a)(s, a)
			}, g = (e, t) => Object(c.a)(e, Object.assign({}, r, {
				variables: {
					subredditName: t
				}
			})), _ = (e, t, n) => Object(c.a)(e, Object.assign({}, s, {
				variables: {
					subredditName: t,
					templateIds: n
				}
			}))
		},
		"./src/reddit/endpoints/page/commentsPage.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/reddit/models/Comment/addProfileImgParam.ts"),
				c = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				i = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			t.a = (e, t, n, d, u) => {
				let l = n ? "".concat(s.a.gatewayUrl, "/desktopapi/v1/postcomments/").concat(t, "/").concat(n) : "".concat(s.a.gatewayUrl, "/desktopapi/v1/postcomments/").concat(t);
				return l = Object(c.a)(Object(i.a)(l)), u && (l = Object(a.a)(l)), Object(o.b)(e, {
					data: d,
					endpoint: l,
					method: r.ab.GET,
					traceRequestName: "get_comments_page"
				})
			}
		},
		"./src/reddit/endpoints/page/frontpage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./src/graphql/operations/Frontpage.json");
			window.atob;
			const r = window.btoa;
			var o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/performanceTimings/index.tsx"),
				i = n("./src/reddit/constants/graphql.ts"),
				d = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				u = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/models/Live/index.ts"),
				b = (e, t) => t ? {
					announcementUrl: t.url,
					buttonCta: t.callToAction,
					description: t.description || "",
					icon: l.a[t.icon] && t.icon.toLowerCase(),
					id: t.id,
					isAnnouncement: !0,
					numTimesDismissable: t.maxDismissCount,
					title: t.title,
					viewerCount: 0
				} : e ? {
					announcementUrl: "",
					buttonCta: "",
					description: e.description || "",
					icon: "",
					id: e.id,
					isAnnouncement: !1,
					numTimesDismissable: 0,
					title: e.title,
					viewerCount: e.viewerCount
				} : null,
				p = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				m = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				g = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				y = n("./src/reddit/selectors/platform.ts"),
				j = n("./src/reddit/selectors/user.ts");
			const h = (e, t) => {
					const {
						after: n,
						dist: s,
						isMobile: o,
						layout: a,
						limit: c,
						sort: u,
						t: l
					} = t, b = Object(j.O)(e), p = Object(y.p)(e), f = {
						recentPostIds: e.posts.recent,
						includeIdentity: b && !e.user.account,
						includeFeatured: !0,
						adContext: {
							layout: a ? a.toUpperCase() : i.a.Card,
							reddaid: e.user.reddaid,
							distance: s
						}
					};
					return u && (f.sort = u.toUpperCase()), l && (f.range = l.toUpperCase()), o ? f.pageSize = Object(d.a)(a) : c && (f.pageSize = c), p && p.ad && (f.forceAds = {
						ad: p.ad
					}), n && (f.after = r(n)), f
				},
				E = async (e, t, n) => {
					const r = Date.now(),
						i = await ((e, t) => Object(a.a)(e, Object.assign({}, s, {
							variables: t
						}), {
							traceRequestName: "get_frontpage"
						}))(e, t),
						d = Date.now();
					let l;
					try {
						const e = Date.now();
						l = (e => {
							let {
								trendingSubreddits: t = [],
								identity: n,
								home: s,
								featuredAnnouncement: r,
								featuredLiveEvent: o,
								recentPosts: a = []
							} = e;
							const c = [],
								i = [],
								d = {
									postIds: [],
									postInstances: {},
									posts: {},
									postFlair: {},
									profiles: {},
									subreddits: {}
								},
								l = e => {
									if (d.posts[e.id]) return e.id;
									const t = Object(f.d)(e);
									d.posts[t.id] = t;
									const {
										crosspostRoot: n
									} = e;
									n && n.type === u.a.Post && n.postInfo && l(n.postInfo);
									let s = t.id;
									switch (e.__typename) {
										case u.f.ProfilePost:
											d.profiles[e.profile.id] || (d.profiles[e.profile.id] = Object(O.a)(e.profile));
											break;
										case u.f.SubredditPost:
											d.subreddits[e.subreddit.id] || (d.subreddits[e.subreddit.id] = Object(g.a)(e.subreddit)), d.postFlair[e.subreddit.id] || (d.postFlair[e.subreddit.id] = Object(p.a)(e.subreddit));
											break;
										case u.f.AdPost:
											const n = Object(f.b)(e);
											if (!n) {
												s = null;
												break
											}
											s = n, d.posts[n] = Object.assign({}, t, {
												id: n,
												permalink: "".concat(t.permalink, "?instanceId=").concat(encodeURIComponent(n))
											}), d.posts[t.id] || (d.posts[t.id] = Object.assign({}, t, {
												events: []
											})), d.postInstances[e.id] || (d.postInstances[e.id] = []), d.postInstances[e.id].push(n)
									}
									return s
								};
							for (const u of t) {
								const e = Object(g.a)(u);
								d.subreddits[e.id] = e, c.push(e.id)
							}
							for (const {
									node: u
								} of s.posts.edges) {
								const e = l(u);
								e && d.postIds.push(e)
							}
							for (const u of a) {
								if (!u) continue;
								const e = l(u);
								e && i.push(e)
							}
							const y = d.postIds.length - 1,
								j = y >= 0 ? d.postIds[y] : "",
								h = s.posts.dist;
							return Object.assign({}, d, {
								account: n && Object(_.a)(n) || null,
								featuredLiveThread: b(o, r) || {},
								preferences: n && n.preferences && Object(m.a)(n.preferences, n.interactions) || null
							}, 0 !== c.length && {
								trendingSubredditIds: c
							}, 0 !== i.length && {
								recentPostIds: i
							}, {
								token: j
							}, null !== h && {
								dist: h
							})
						})(i.body.data);
						const t = Date.now(),
							s = [{
								duration: d - r,
								logKeyType: c.a.gqlFetchTiming
							}, {
								duration: t - e,
								logKeyType: c.a.gqlNormalizationTiming
							}];
						Object(c.h)(o.o.FRONTPAGE, n, s)
					} catch (y) {}
					return Object.assign({}, i, {
						body: l
					})
				}
		},
		"./src/reddit/endpoints/page/multiredditListing.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/graphql/operations/MultiredditListing.json"),
				r = n("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t) => Object(r.a)(e, Object.assign({}, s, {
				variables: t
			}))
		},
		"./src/reddit/endpoints/page/profileOverviewPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const i = (e, t, n) => Object(a.b)(e, {
					data: n,
					endpoint: Object(r.a)(Object(c.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/conversations"))),
					method: o.ab.GET
				}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? Object.assign({}, e, {
					body: Object.assign({}, e.body, {
						pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
					})
				}) : e),
				d = (e, t, n) => Object(a.b)(e, {
					data: n,
					endpoint: Object(r.a)(Object(c.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/overview"))),
					method: o.ab.GET
				}).then(e => "pinned" in e.body ? e : "overviewIds" in e.body ? Object.assign({}, e, {
					body: Object.assign({}, e.body, {
						pinned: e.body.overviewIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
					})
				}) : e)
		},
		"./src/reddit/endpoints/page/search.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/search/index.ts"),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t) => {
				let n = t ? Object.assign({}, e, {
					type: e.restrict_sr ? "link" : e.type
				}) : e;
				(n = n.type ? n : Object.assign({}, n, {
					type: "link,sr,user"
				})).q = Object(a.a)(e.q);
				const s = Object(c.c)(c.a.SearchResults);
				return s && (n.search_correlation_id = s), n
			};
			t.a = (e, t, n, a) => Object(o.b)(e, {
				data: d(a || {}, t),
				endpoint: Object(i.a)(n ? "".concat(s.a.gatewayUrl, "/desktopapi/v1/multireddits/").concat(n, "/").concat(t, "/search") : t ? "".concat(s.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t, "/search") : "".concat(s.a.gatewayUrl, "/desktopapi/v1/search")),
				method: r.ab.GET
			})
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return x
			})), n.d(t, "b", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/config.ts"),
				r = n("./src/graphql/operations/SubredditPage.json"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/isAdHocMultireddit/index.ts"),
				c = n("./src/lib/isFakeSubreddit/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/lib/performanceTimings/index.tsx"),
				l = n("./src/reddit/constants/graphql.ts"),
				b = n("./src/reddit/constants/page.ts"),
				p = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				f = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				m = n("./src/reddit/models/Post/index.ts"),
				O = n("./src/reddit/models/RichTextJson/index.ts"),
				g = n("./src/reddit/models/Subreddit/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				S = e => {
					let {
						isAccessEnabled: t,
						isAllAllowed: n,
						isChatConfigEditingAllowed: s,
						isChatOperator: r,
						isConfigEditingAllowed: o,
						isFlairEditingAllowed: a,
						isMailEditingAllowed: c,
						isPostEditingAllowed: i,
						isWikiEditingAllowed: d
					} = e;
					return {
						access: t,
						all: n,
						chatConfig: s,
						chatOperator: r,
						config: o,
						flair: a,
						mail: c,
						posts: i,
						wiki: d
					}
				},
				T = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				D = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/helpers.ts");
			const w = e => {
				switch (e) {
					case g.b.Banned:
						return i.a.BannedSubreddit;
					case g.b.GoldOnly:
						return i.a.GoldSubreddit;
					case g.b.Private:
						return i.a.PrivateSubreddit;
					case g.b.Quarantined:
						return i.a.QuarantinedSubreddit;
					case g.b.Unknown:
						return i.a.ForbiddenSubreddit
				}
			};
			var A = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				R = n("./src/reddit/selectors/platform.ts"),
				P = n("./src/reddit/selectors/user.ts"),
				k = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const x = (e, t, n) => {
					const {
						after: s,
						geo_filter: r,
						isMobile: o,
						layout: i,
						limit: d,
						recentPostIds: u,
						sort: p,
						t: m
					} = n, O = Object(P.O)(e), g = Object(R.p)(e), _ = Object(a.a)(t), y = Object(c.a)(t), j = {
						name: t,
						includeIdentity: O && !e.user.account,
						adContext: {
							layout: i ? i.toUpperCase() : l.a.Card,
							reddaid: e.user.reddaid
						},
						isFake: y,
						includeRecents: y && u && u.length > 0 || !1,
						includeTrending: y,
						isAdHocMulti: _,
						isAll: t === b.c.All,
						isPopular: t === b.c.Popular,
						recentPostIds: u || [],
						subredditNames: _ ? t.split("+") : []
					};
					return p && (j.sort = p.toUpperCase()), m && (j.range = m.toUpperCase()), o ? j.pageSize = Object(f.a)(i) : d && (j.pageSize = d), g && g.ad && (j.forceAds = {
						ad: g.ad
					}), (g && g.geo_filter || r) && (j.region = g && g.geo_filter || r), s && (j.after = btoa(s)), j
				},
				N = async (e, t, n) => {
					const s = Date.now(),
						a = await ((e, t) => Object(d.a)(e, Object.assign({}, r, {
							variables: t
						})))(e, t),
						c = Date.now();
					if (!a.ok || !a.body) return a;
					const l = a.body,
						b = Date.now(),
						p = (e => {
							let {
								adhocMultiredditByNames: t,
								all: n,
								identity: s,
								popular: r,
								recentPosts: o,
								subredditInfoByName: a,
								trendingSubreddits: c
							} = e;
							const d = {
								authorFlair: {},
								postIds: [],
								postInstances: {},
								posts: {},
								postFlair: {},
								profiles: {},
								recentPostIds: [],
								structuredStyles: {},
								subredditAboutInfo: {},
								subredditPermissions: {},
								subreddits: {},
								trendingSubredditIds: []
							};
							if (!a) return {
								reason: i.a.NotFoundSubreddit,
								data: {
									account: s && Object(D.a)(s) || null
								}
							};
							if (Object(g.f)(a)) {
								const {
									banMessage: e,
									publicDescriptionText: t,
									quarantineMessage: n,
									isEmailRequiredForQuarantineOptin: r
								} = a;
								return {
									reason: w(a.forbiddenReason),
									data: Object.assign({
										account: s && Object(D.a)(s) || null,
										banMessage: e || void 0,
										description: t,
										quarantineRequiresEmailOptin: r
									}, n ? {
										quarantineMessage: n.markdown,
										quarantineMessageRTJson: Object(C.e)(n.richtext, O.i)
									} : {})
								}
							}
							const u = e => {
									if (e.__typename === m.f.DeletedProfilePost || e.__typename === m.f.DeletedSubredditPost) return null;
									if (d.posts[e.id]) return e.id;
									const t = Object(j.d)(e);
									d.posts[t.id] = t;
									const {
										crosspostRoot: n
									} = e;
									n && n.type === m.a.Post && n.postInfo && u(n.postInfo);
									let s = t.id;
									switch (e.authorFlair && (d.authorFlair[t.belongsTo.id] || (d.authorFlair[t.belongsTo.id] = {}), d.authorFlair[t.belongsTo.id][t.author] = Object(_.a)(e.authorFlair)[0]), e.__typename) {
										case m.f.ProfilePost:
											d.profiles[e.profile.id] || (d.profiles[e.profile.id] = Object(E.a)(e.profile));
											break;
										case m.f.SubredditPost:
											d.subreddits[e.subreddit.id] || (d.subreddits[e.subreddit.id] = Object(v.a)(e.subreddit)), d.postFlair[e.subreddit.id] || (d.postFlair[e.subreddit.id] = Object(y.a)(e.subreddit));
											break;
										case m.f.AdPost:
											const n = Object(j.b)(e);
											if (!n) {
												s = null;
												break
											}
											s = n, d.posts[n] = Object.assign({}, t, {
												id: n,
												permalink: "".concat(t.permalink, "?instanceId=").concat(encodeURIComponent(n))
											}), d.posts[t.id] || (d.posts[t.id] = Object.assign({}, t, {
												events: []
											})), d.postInstances[e.id] || (d.postInstances[e.id] = []), d.postInstances[e.id].push(n)
									}
									return s
								},
								l = a || r || n || t;
							for (const {
									node: i
								} of l.posts.edges) {
								const e = u(i);
								e && d.postIds.push(e)
							}
							a && a.styles && (d.structuredStyles = {
								data: {
									style: Object(T.a)(a.styles)
								}
							});
							const b = d.postIds.length - 1,
								p = b >= 0 ? d.postIds[b] : "",
								f = l.posts.dist;
							if (c) {
								d.trendingSubredditIds = c.map(e => e.id);
								for (const e of c) d.subreddits[e.id] = Object(v.a)(e)
							}
							if (o)
								for (const i of o) {
									const e = u(i);
									e && d.recentPostIds.push(e)
								}
							return Object.assign({}, d, {
								account: s && Object(D.a)(s) || null,
								preferences: s && s.preferences && Object(h.a)(s.preferences, s.interactions) || null,
								subredditAboutInfo: a && Object(I.a)(a),
								subredditPermissions: a && a.modPermissions && S(a.modPermissions),
								token: p
							}, null !== f && {
								dist: f
							})
						})(l.data),
						f = Date.now(),
						A = [{
							duration: c - s,
							logKeyType: u.a.gqlFetchTiming
						}, {
							duration: f - b,
							logKeyType: u.a.gqlNormalizationTiming
						}];
					return Object(u.h)(o.o.SUBREDDIT, n, A), Object.assign({}, a, {
						ok: !!l.data.subredditInfoByName && !Object(g.f)(l.data.subredditInfoByName),
						status: L(l.data),
						body: p
					})
				}, L = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(g.f)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === g.b.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === g.b.GoldOnly || e.subredditInfoByName.forbiddenReason === g.b.Private || e.subredditInfoByName.forbiddenReason === g.b.Quarantined) return 403
					}
					return 200
				}, U = e => {
					var {
						recentPostIds: t
					} = e, n = k(e, ["recentPostIds"]);
					return t && t.length ? Object.assign({}, n, {
						recentPostIds: t.join(",")
					}) : n
				};
			t.a = (e, t, n) => Object(i.b)(e, {
				endpoint: Object(p.a)(Object(A.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t))),
				method: o.ab.GET,
				data: n && U(n) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts");
			t.a = (e, t, n) => {
				const d = {
					output_mode: "markdown" === t ? t : "rtjson"
				};
				return t === i.h.MARKDOWN ? d.richtext_json = n : d.markdown_text = n, Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/convert_rte_body_format")),
					method: s.ab.POST,
					data: d
				})
			}
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/PostDraft/index.ts");
			const o = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				a = e => {
					switch (e.kind) {
						case r.b.Link:
							return "link";
						case r.b.Markdown:
							return "markdown";
						case r.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				c = e => {
					switch (e) {
						case "link":
							return r.b.Link;
						case "markdown":
							return r.b.Markdown;
						case "richtext":
							return r.b.RichText;
						default:
							return "self"
					}
				},
				i = e => e.title.substring(0, 300),
				d = e => {
					switch (e.kind) {
						case r.b.Link:
						case r.b.Markdown:
							return e.body;
						case r.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				u = e => Object.assign({
					id: e.draftId || void 0
				}, (e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {})(e), {
					kind: a(e),
					title: i(e),
					body: d(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC
				}, (e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(s.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				})(e.flair), {
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/post/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "t", (function() {
				return f
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "w", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "o", (function() {
				return I
			})), n.d(t, "x", (function() {
				return v
			})), n.d(t, "r", (function() {
				return S
			})), n.d(t, "y", (function() {
				return T
			})), n.d(t, "h", (function() {
				return D
			})), n.d(t, "u", (function() {
				return C
			})), n.d(t, "s", (function() {
				return w
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "m", (function() {
				return R
			})), n.d(t, "n", (function() {
				return k
			})), n.d(t, "q", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var i = n("./src/reddit/helpers/reportPage/index.ts");
			const d = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/approve")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				u = (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/distinguish/").concat(n)),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				l = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/fetch_title")),
					method: s.ab.POST,
					data: {
						url: t,
						api_type: "json"
					}
				}),
				b = (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/follow_post")),
					method: s.ab.POST,
					data: {
						follow: n,
						fullname: t
					}
				}),
				p = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/hide")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				f = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unhide")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				m = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/lock")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				O = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unlock")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				g = (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/set_original_content")),
					method: s.ab.POST,
					data: {
						fullname: t,
						should_set_oc: n
					}
				}),
				_ = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/marknsfw")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unmarknsfw")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				j = (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: "".concat(e.apiUrl, "/api/sendreplies"),
					method: s.ab.POST,
					data: {
						id: t,
						state: n
					}
				}),
				h = (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/remove")),
					method: s.ab.POST,
					data: {
						id: t,
						spam: n
					}
				}),
				E = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/del")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				I = (e, t) => ((e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/save")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}))(e, t),
				v = (e, t) => ((e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unsave")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}))(e, t),
				S = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/spoiler")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				T = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unspoiler")),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				D = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: "".concat(e.apiUrl, "/api/ignore_reports"),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				C = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: "".concat(e.apiUrl, "/api/unignore_reports"),
					method: s.ab.POST,
					data: {
						id: t
					}
				}),
				w = (e, t, n, c) => Object(r.b)(Object(o.a)(e, [a.a]), {
					endpoint: "".concat(e.apiUrl, "/api/set_subreddit_sticky"),
					method: s.ab.POST,
					data: {
						id: t,
						state: n,
						to_profile: c
					}
				});
			var A;
			! function(e) {
				e.Rule = "rule", e.SiteRule = "siteRule", e.Other = "other", e.FileComplaint = "fileComplaint", e.CrisisTextLine = "crisisTextLine"
			}(A || (A = {}));
			const R = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
					method: s.ab.POST,
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/report")),
					data: P(t)
				}),
				P = e => {
					const t = Object.assign({
							thing_id: e.id,
							api_type: "json"
						}, e.timestamp && {
							live_stream_relative_report_time_sec: e.timestamp.toString()
						}),
						{
							reportFlowPayload: n
						} = e;
					switch (n.customText && (t.custom_text = n.customText), n.kind) {
						case A.Other:
							return Object.assign({}, t, {
								reason: "other",
								other_reason: n.rule
							});
						case A.Rule:
							return Object.assign({}, t, {
								reason: n.rule,
								rule_reason: n.rule
							});
						case A.SiteRule:
						case A.CrisisTextLine:
						default:
							return Object.assign({}, t, {
								reason: "site_reason_selected",
								site_reason: n.rule
							})
					}
				},
				k = (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					method: s.ab.POST,
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/report")),
					data: x(t, n)
				}),
				x = (e, t) => {
					const n = Object(i.b)(e),
						s = Object.assign({}, n, {
							api_type: "json"
						});
					return t && (s.from_help_desk = !0), s
				},
				N = async (e, t, n) => Object(r.b)(Object(o.a)(e, [a.a]), {
					method: s.ab.POST,
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/set_contest_mode/")),
					data: {
						api_type: "json",
						id: n,
						state: t
					}
				})
		},
		"./src/reddit/endpoints/profile/info.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/graphql/operations/RedditorKarma.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			const d = (e, t) => Object(o.b)(Object(c.a)(e, [i.a]), {
					endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/about.json"),
					method: r.ab.GET,
					data: {
						gilding_detail: 1,
						awarded_detail: 1,
						raw_json: 1
					}
				}),
				u = (e, t) => Object(a.a)(e, Object.assign({}, s, {
					variables: {
						name: t
					}
				}))
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "i", (function() {
				return I
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/omit.js"),
				o = n.n(r),
				a = n("./src/config.ts"),
				c = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/constants/headers.ts"),
				d = n("./src/lib/makeRequest/index.ts"),
				u = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				l = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				b = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				p = n("./src/reddit/models/PostCreationForm/index.ts"),
				f = n("./src/reddit/models/Vote/index.ts");
			const m = async e => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/rpan_config_v1"),
				method: c.ab.GET,
				headers: o()(e.headers(), [i.c, i.b]),
				timeoutMs: void 0
			}).then(T), O = async (e, t) => {
				let n;
				return n = t === u.P ? "/config" : "/".concat(t, "/config"), Object(d.b)({
					endpoint: "".concat(a.a.streamingApiUrl).concat(n),
					method: c.ab.GET,
					headers: o()(e.headers(), [i.c, i.b]),
					timeoutMs: void 0
				}).then(T)
			}, g = async (e, t) => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/videos/").concat(t),
				method: c.ab.GET,
				headers: o()(e.headers(), [i.c, i.b])
			}).then(T), _ = async e => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/videos"),
				method: c.ab.GET,
				headers: o()(e.headers(), [i.c, i.b])
			}).then(T), y = async (e, t) => {
				let n;
				return n = t === u.P ? "/broadcasts" : "/".concat(t, "/broadcasts"), Object(d.b)({
					endpoint: "".concat(a.a.streamingApiUrl).concat(n),
					method: c.ab.GET,
					headers: o()(e.headers(), [i.c, i.b])
				}).then(T)
			}, j = async e => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/recommended_viewer_subreddits"),
				method: c.ab.GET,
				headers: o()(e.headers(), [i.c, i.b])
			}).then(T), h = async (e, t, n) => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/videos/").concat(t, "/vote/").concat(D(n)),
				method: c.ab.POST,
				headers: o()(e.headers, [i.c, i.b])
			}).then(T), E = async (e, t) => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/videos/").concat(t, "/heartbeat"),
				method: c.ab.POST,
				headers: o()(e.headers(), [i.c, i.b])
			}).then(T), I = async (e, t, n, s) => {
				const r = n.rteState;
				if (!r) return Promise.reject(new Error("Editor state is undefined"));
				const o = l.a.getRawText(r);
				return o ? v(e, t, o).then(e => e.ok && e.body && e.body.data ? Object.assign({}, e, {
					body: {
						parentId: t,
						comment: Object.assign({}, Object(b.a)(e.body.data, s), {
							media: S(r)
						})
					},
					error: void 0
				}) : e) : Promise.reject(new Error("Cannot send empty message"))
			}, v = async (e, t, n) => Object(d.b)({
				endpoint: "".concat(a.a.streamingApiUrl, "/videos/").concat(t, "/comment"),
				method: c.ab.POST,
				headers: o()(e.headers, [i.c, i.b]),
				data: {
					text: n
				},
				type: "json"
			}).then(T), S = e => ({
				type: "rtjson",
				richtextContent: {
					document: l.a.toRichTextJSON(e).document
				},
				rteMode: p.h.RICH_TEXT
			}), T = e => {
				if (e.ok) return Object.assign({}, e, {
					error: void 0
				}); {
					const t = {
						type: 404 === e.status ? c.C.NOT_FOUND_ERROR : c.C.SERVER_ERROR
					};
					return 429 === e.status && (t.fields = [{
						field: "",
						msg: s.fbt._("Try again later", null, {
							hk: "3BBLIU"
						})
					}]), Object.assign({}, e, {
						error: t
					})
				}
			}, D = e => e === f.a.upvoted ? "up" : e === f.a.downvoted ? "down" : "unset"
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/graphql/operations/SubredditAbout.json"),
				r = n("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t, n) => Object(r.a)(e, Object.assign({}, s, {
				variables: {
					subredditName: t,
					includeSubreddit: n
				}
			}))
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "e", (function() {
				return I
			}));
			var s = n("./node_modules/lodash/camelCase.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/mapKeys.js"),
				a = n.n(o),
				c = n("./src/graphql/operations/SubredditRules.json"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/graphql/helpers.ts"),
				f = n("./src/reddit/models/Rule/index.ts");
			const m = e => {
					let {
						rules: t
					} = e;
					return {
						rules: t.map(e => Object.assign({}, a()(e, (e, t) => r()(t)), {
							kind: "link" === e.kind ? "post" : e.kind
						}))
					}
				},
				O = (e, t) => Object(u.a)(e, Object.assign({}, c, {
					variables: {
						subredditName: t
					}
				})).then(e => (e.ok && e.body && (e.body = (e => {
					return {
						rules: (e.data.subreddit && e.data.subreddit.rules || []).map(e => ({
							kind: f.c[e.kind],
							description: e.content.markdown,
							descriptionRichText: e.content.richtext,
							shortName: e.name,
							violationReason: e.violationReason || "",
							createdUtc: Object(p.d)(e.createdAt, p.a.Millis),
							priority: e.priority
						}))
					}
				})(e.body)), e)),
				g = (e, t) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/about/rules.json"),
					method: i.ab.GET
				}).then(e => (e.ok && e.body.rules && (e.body = m(e.body)), e)),
				_ = e => e.ok ? (e.body = Object(f.h)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				y = async (e, t, n) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/add_subreddit_rule"),
					method: i.ab.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === f.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e)), j = async (e, t, n, s) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/update_subreddit_rule"),
					method: i.ab.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === f.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						old_short_name: s,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e)), h = async (e, t, n) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/remove_subreddit_rule"),
					method: i.ab.POST,
					data: {
						r: t,
						short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e)), E = e => e.map(e => encodeURIComponent(e)).join(), I = async (e, t, n) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/reorder_subreddit_rules"),
					method: i.ab.POST,
					data: {
						r: t,
						new_rule_order: E(n),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e))
		},
		"./src/reddit/endpoints/subreddit/settings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return O
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			const i = (e, t, n) => Object(r.b)(Object(o.a)(e, [c.a]), {
					method: s.ab.POST,
					endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/delete_sr_").concat(n),
					data: {
						raw_json: 1
					}
				}),
				d = (e, t) => Object(r.b)(Object(o.a)(e, [c.a]), {
					method: s.ab.GET,
					endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/about/edit.json"),
					data: {
						raw_json: 1
					}
				}).then(e => e.ok ? Object.assign({}, e, {
					body: Object.assign({}, b(e.body.data))
				}) : e),
				u = (e, t, n) => Object(r.b)(Object(o.a)(e, [c.a]), {
					method: s.ab.PATCH,
					endpoint: Object(a.a)("".concat(e.apiUrl, "/api/v1/subreddit/update_settings")),
					type: "json",
					data: Object.assign({}, p(n, m), {
						sr: t
					})
				}),
				l = (e, t, n) => {
					const a = Object.assign({}, f(n), {
						sr: t
					});
					return Object(r.b)(Object(o.a)(e, [c.a]), {
						method: s.ab.POST,
						endpoint: "".concat(e.apiUrl, "/api/site_admin"),
						data: a
					})
				},
				b = e => ({
					allowChatPostCreation: e.allow_chat_post_creation,
					allowDiscovery: e.allow_discovery,
					allowImages: e.allow_images,
					allowPolls: e.allow_polls,
					allowPostCrossposts: e.allow_post_crossposts,
					collapseDeletedComments: e.collapse_deleted_comments,
					commentScoreHideMins: e.comment_score_hide_mins,
					contentOptions: e.content_options,
					contentVisible: e.default_set,
					crowdControlMode: e.crowd_control_mode,
					crowdControlChatLevel: e.crowd_control_chat_level,
					crowdControlLevel: e.crowd_control_level,
					description: e.description,
					disableContributorRequests: e.disable_contributor_requests,
					domain: e.domain,
					excludeBannedModqueue: e.exclude_banned_modqueue,
					headerHoverText: e.header_hover_text,
					hideAds: e.hide_ads,
					isChatPostFeatureEnabled: e.is_chat_post_feature_enabled,
					keyColor: e.key_color,
					language: e.language,
					over18: e.over_18,
					publicDescription: e.public_description,
					publicTraffic: e.public_traffic,
					restrictCommenting: e.restrict_commenting,
					restrictPosting: e.restrict_posting,
					showMedia: e.show_media,
					showMediaPreview: e.show_media_preview,
					spamComments: e.spam_comments,
					spamLinks: e.spam_links,
					spamSelfposts: e.spam_selfposts,
					spoilersEnabled: e.spoilers_enabled,
					submitLinkLabel: e.submit_link_label,
					submitText: e.submit_text,
					submitTextLabel: e.submit_text_label,
					subredditId: e.subreddit_id,
					subredditType: e.subreddit_type,
					suggestedCommentSort: e.suggested_comment_sort,
					title: e.title,
					toxicityThresholdChatLevel: e.toxicity_threshold_chat_level,
					welcomeMessageEnabled: e.welcome_message_enabled,
					welcomeMessageText: e.welcome_message_text,
					wikiEditAge: e.wiki_edit_age,
					wikiEditKarma: e.wiki_edit_karma,
					wikimode: e.wikimode
				}),
				p = (e, t) => {
					const n = {};
					for (const s in e) n[t[s]] = e[s];
					return n
				},
				f = e => ({
					allow_polls: e.allowPolls,
					allow_post_crossposts: e.allowPostCrossposts,
					allow_chat_post_creation: e.allowChatPostCreation,
					allow_images: e.allowImages,
					allow_discovery: e.allowDiscovery,
					allow_top: e.contentVisible,
					api_type: "json",
					collapse_deleted_comments: e.collapseDeletedComments,
					comment_score_hide_mins: e.commentScoreHideMins,
					crowd_control_mode: e.crowdControlMode,
					crowd_control_level: e.crowdControlLevel,
					crowd_control_chat_level: e.crowdControlChatLevel,
					disable_contributor_requests: e.disableContributorRequests,
					description: e.description,
					domain: e.domain,
					exclude_banned_modqueue: e.excludeBannedModqueue,
					"header-title": e.headerHoverText,
					hide_ads: e.hideAds,
					is_chat_post_feature_enabled: e.isChatPostFeatureEnabled,
					key_color: e.keyColor,
					lang: e.language,
					link_type: e.contentOptions,
					over_18: e.over18,
					public_description: e.publicDescription,
					public_traffic: e.publicTraffic,
					restrict_commenting: e.restrictCommenting,
					restrict_posting: e.restrictPosting,
					show_media: e.showMedia,
					show_media_preview: e.showMediaPreview,
					spam_comments: e.spamComments,
					spam_links: e.spamLinks,
					spam_selfposts: e.spamSelfposts,
					spoilers_enabled: e.spoilersEnabled,
					sr: e.subredditId,
					submit_link_label: e.submitLinkLabel,
					submit_text: e.submitText,
					submit_text_label: e.submitTextLabel,
					suggested_comment_sort: e.suggestedCommentSort,
					title: e.title,
					toxicity_threshold_chat_level: e.toxicityThresholdChatLevel,
					type: e.subredditType,
					welcome_message_enabled: e.welcomeMessageEnabled,
					welcome_message_text: e.welcomeMessageText,
					wiki_edit_age: e.wikiEditAge,
					wiki_edit_karma: e.wikiEditKarma,
					wikimode: e.wikimode
				}),
				m = {
					allowPostCrossposts: "allow_post_crossposts",
					allowImages: "allow_images",
					allowChatPostCreation: "allow_chat_post_creation",
					allowDiscovery: "allow_discovery",
					allowPolls: "allow_polls",
					contentVisible: "allow_top",
					collapseDeletedComments: "collapse_deleted_comments",
					commentScoreHideMins: "comment_score_hide_mins",
					crowdControlMode: "crowd_control_mode",
					crowdControlLevel: "crowd_control_level",
					crowdControlChatLevel: "crowd_control_chat_level",
					description: "description",
					disableContributorRequests: "disable_contributor_requests",
					domain: "domain",
					excludeBannedModqueue: "exclude_banned_modqueue",
					headerHoverText: "header-title",
					hideAds: "hide_ads",
					isChatPostFeatureEnabled: "is_chat_post_feature_enabled",
					keyColor: "key_color",
					language: "lang",
					contentOptions: "link_type",
					over18: "over_18",
					publicDescription: "public_description",
					publicTraffic: "public_traffic",
					restrictCommenting: "restrict_commenting",
					restrictPosting: "restrict_posting",
					showMedia: "show_media",
					showMediaPreview: "show_media_preview",
					spamComments: "spam_comments",
					spamLinks: "spam_links",
					spamSelfposts: "spam_selfposts",
					spoilersEnabled: "spoilers_enabled",
					submitLinkLabel: "submit_link_label",
					submitText: "submit_text",
					submitTextLabel: "submit_text_label",
					suggestedCommentSort: "suggested_comment_sort",
					title: "title",
					toxicityThresholdChatLevel: "toxicity_threshold_chat_level",
					subredditType: "type",
					welcomeMessageEnabled: "welcome_message_enabled",
					welcomeMessageText: "welcome_message_text",
					wikiEditAge: "wiki_edit_age",
					wikiEditKarma: "wiki_edit_karma",
					wikimode: "wikimode"
				},
				O = (e, t, n) => Object(r.b)(Object(o.a)(e, [c.a]), {
					method: s.ab.POST,
					endpoint: Object(a.a)("".concat(e.apiUrl, "/api/v1/subreddit/test_welcome_message")),
					data: {
						sr: t,
						test_message_text: n
					}
				})
		},
		"./src/reddit/endpoints/user/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/config.ts"),
				r = n("./src/graphql/operations/ExperimentVariants.json"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const l = (e, t) => Object(a.b)(e, {
					endpoint: Object(u.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/about")),
					method: o.ab.GET,
					data: {
						api_type: "json",
						gilding_detail: 1,
						awarded_detail: 1
					}
				}),
				b = e => Object(a.b)(Object(i.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_layout_switch"),
					method: o.ab.POST
				}),
				p = e => Object(a.b)(Object(i.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_give_award_tooltip"),
					method: o.ab.POST
				}),
				f = e => Object(a.b)(Object(i.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_modal"),
					method: o.ab.POST
				}),
				m = (e, t) => Object(c.a)(e, Object.assign({}, r, {
					variables: t
				}), {
					traceRequestName: "get_experiments"
				})
		},
		"./src/reddit/endpoints/user/preferences.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "h", (function() {
				return y
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts");
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const c = {
				activityRelevantAds: "activity_relevant_ads",
				acceptPrivateMessages: "accept_pms",
				allowClickTracking: "allow_clicktracking",
				collapseReadMessages: "collapse_read_messages",
				defaultCommentSort: "default_comment_sort",
				emailDigests: "email_digests",
				emailUnreadMessages: "email_messages",
				emailUnsubscribe: "email_unsubscribe_all",
				geopopular: "geopopular",
				hasSeenCustomizeFlyout: "has_seen_customize_flyout",
				hideAds: "hide_ads",
				hideFromRobots: "hide_from_robots",
				hideNSFW: "no_profanity",
				highlightComments: "highlight_new_comments",
				ignoreSuggestedSort: "ignore_suggested_sort",
				inBeta: "beta",
				labelNSFW: "label_nsfw",
				markMessagesRead: "mark_messages_read",
				nightmode: "nightmode",
				over18: "over_18",
				sendWelcomeMessages: "send_welcome_messages",
				showMessagesInInbox: "threaded_messages",
				showNotifications: "live_orangereds",
				showUsernameMentionNotifications: "monitor_mentions",
				privateFeeds: "private_feeds",
				autoplayVideo: "video_autoplay",
				rpanDuDismissalTime: "rpan_du_dismissal_time",
				showActiveCommunities: "top_karma_subreddits",
				showRpanDu: n("./src/reddit/constants/preferences.ts").c,
				showTwitter: "show_twitter",
				stylesEnabled: "styles_enabled",
				openPostInNewTab: "open_post_in_new_tab",
				rememberCommunitySort: "remember_community_sort",
				useMarkdown: "use_markdown",
				sort: "sort",
				layout: "layout",
				rememberCommunityLayout: "remember_community_layout",
				topContentDismissalTime: "top_content_dismissal_time",
				topContentTimesDismissed: "top_content_times_dismissed",
				thirdPartyDataPersonalizedAds: "third_party_data_personalized_ads",
				thirdPartySiteDataPersonalizedAds: "third_party_site_data_personalized_ads",
				thirdPartySiteDataPersonalizedContent: "third_party_site_data_personalized_content",
				showLocationBasedRecommendations: "show_location_based_recommendations"
			};
			var i = e => {
				const t = {};
				return Object.keys(e).map(n => {
					c.hasOwnProperty(n) && (t[c[n]] = e[n])
				}), t
			};
			const d = {
				rpanDuDismissalTime: "rpan_du_dismissal_time",
				isContributorRequestTimestamp: "is_contributor_request_timestamp",
				sort: "sort",
				stylesEnabled: "styles_enabled",
				layout: "layout"
			};
			var u = e => {
					const t = {};
					return Object.keys(e).map(n => {
						t[d[n]] = e[n]
					}), t
				},
				l = n("./src/reddit/constants/headers.ts");
			const b = e => Object(o.b)(Object(a.a)(e, [l.a]), {
					method: r.ab.PATCH,
					endpoint: "".concat(e.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						over_18: "true"
					}
				}),
				p = (e, t) => Object(o.b)(Object(a.a)(t, [l.a]), {
					method: r.ab.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						video_autoplay: e
					}
				}),
				f = (e, t) => Object(o.b)(Object(a.a)(t, [l.a]), {
					method: r.ab.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						nightmode: e
					}
				}),
				m = (e, t) => Object(o.b)(Object(a.a)(t, [l.a]), {
					method: r.ab.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						geopopular: e
					}
				}),
				O = (e, t) => Object(o.b)(Object(a.a)(t, [l.a]), {
					method: r.ab.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: i(e)
				}),
				g = (e, t) => Object(o.b)(Object(a.a)(t, [l.a]), {
					method: r.ab.POST,
					endpoint: "".concat(t.apiUrl, "/api/quarantine_optin"),
					data: {
						sr_name: e,
						api_type: "json",
						accept: !0
					}
				}),
				_ = (e, t) => Object(o.b)(t, {
					method: r.ab.POST,
					endpoint: "".concat(s.a.gatewayUrl, "/desktopapi/v1/set_preferences"),
					type: "json",
					data: {
						type: "account",
						preferences: i(e)
					}
				}),
				y = (e, t, n) => Object(o.b)(n, {
					method: r.ab.POST,
					endpoint: "".concat(s.a.gatewayUrl, "/desktopapi/v1/set_preferences"),
					type: "json",
					data: {
						type: "subreddit",
						subreddit_id: e,
						preferences: u(t)
					}
				})
		},
		"./src/reddit/endpoints/usernameAvailable/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts");
			const c = (e, t) => Object(r.b)(Object(o.a)(e, [a.a]), {
				method: s.ab.GET,
				endpoint: "".concat(e.apiUrl, "/api/username_available.json?user=").concat(t.username),
				type: "json"
			})
		},
		"./src/reddit/helpers/adCount/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				o = n("./src/reddit/selectors/platform.ts");
			const a = (e, t, n) => [e, t, n].join("/"),
				c = (e, t) => {
					switch (t) {
						case r.a.SUBREDDIT:
						case r.a.COMMENTS_OVERLAY:
						case r.a.COMMENTS: {
							const t = Object(o.h)(e);
							return [a(s.c.ABOVE_THE_FOLD, t, 0), a(s.c.BELOW_THE_FOLD, t, 1)]
						}
						case r.a.FRONTPAGE:
							return [a(s.c.ABOVE_THE_FOLD, !1, 0), a(s.c.BELOW_THE_FOLD, !1, 1)];
						case r.a.MULTIREDDIT:
						case r.a.SEARCH_RESULTS:
							return [a(s.c.BELOW_THE_FOLD, !1, 0)];
						default:
							return [a(s.c.ABOVE_THE_FOLD, !1, 0), a(s.c.BELOW_THE_FOLD, !1, 1)]
					}
				}
		},
		"./src/reddit/helpers/addRedesignIdentifier/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				o = n.n(r),
				a = n("./src/lib/addQueryParams/index.ts");

			function c(e) {
				const {
					protocol: t,
					host: n
				} = o.a.parse(e), r = "".concat(t, "//").concat(n) === s.a.oauthUrl ? s.a.telemetry.appName.redesignR2 : s.a.telemetry.appName.redesign, c = {
					redditWebClient: r,
					app: "".concat(r, "-").concat("client", "-").concat("production")
				};
				return Object(a.a)(e, c)
			}
			const i = () => {
				const e = s.a.telemetry.appName.redesignR2;
				return {
					redditWebClient: e,
					app: "".concat(e, "-").concat("client", "-").concat("production")
				}
			}
		},
		"./src/reddit/helpers/awards/getAwardItemId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t) => "awardItem__".concat(t, "-").concat(e)
		},
		"./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_22cerq"]),
				r = e => s.has(e);
			t.a = r
		},
		"./src/reddit/helpers/awards/message.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = 500,
				r = 1800,
				o = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return t ? e.coinPrice < s ? 0 : e.coinPrice < r ? 50 : 100 : 2048
				},
				a = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const s = o(t, n);
					return e.slice(0, s)
				}
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/constants/comments.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts");
			const c = (e, t) => t().comments.models[e],
				i = e => {
					switch (e.commentLink.type) {
						case s.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case s.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case s.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				d = (e, t) => e.type === s.a.MoreComments ? t[e.id].numComments : 1,
				u = (e, t, n, s) => {
					let o = Object(r.o)(s, {
							commentLink: t,
							commentsPageKey: e
						}),
						a = t;
					for (; o && o.depth > n && o.prev && (a = o.prev, (o = Object(r.o)(s, {
							commentLink: a,
							commentsPageKey: e
						})) && !(o.depth <= n)););
					return a.id
				},
				l = (e, t, n) => {
					const {
						commentLists: s,
						comments: r
					} = e, {
						head: c
					} = s[t];
					if (c) return Object.keys(r).filter(e => {
						const t = r[e];
						return !(!t.isStickied || !((e, t) => {
							const n = Object(a.c)(e, {
								experimentEligibilitySelector: a.a,
								experimentName: o.q,
								expEventOverride: t
							});
							return !!(Object(o.rc)(n) ? void 0 : n)
						})(n)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");

			function s(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let n = 0;
				return e.placement && t.placement && (n = e.placement.localeCompare(t.placement)), 0 === n && e.position && t.position && (n = e.position - t.position), 0 === n && (n = e.title.localeCompare(t.title)), n
			}

			function r(e) {
				return [...e].sort(s)
			}
		},
		"./src/reddit/helpers/favoriteCreators/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./src/lib/constants/index.ts"), n("./src/config.ts"), n("./src/reddit/endpoints/governance/requester.ts");
			n("./src/reddit/endpoints/economics/tips.ts");
			const s = {
					creators: {},
					lastFetch: 0,
					posts: [],
					tippablePosts: {}
				},
				r = e => "favorite-creators-".concat(e),
				o = e => {
					try {
						const t = localStorage.getItem(r(e));
						if (t) return Object.assign({}, s, JSON.parse(t))
					} catch (t) {}
					return s
				},
				a = (e, t) => {
					try {
						return localStorage.setItem(r(e), JSON.stringify(t)), !0
					} catch (n) {}
					return !1
				},
				c = e => {
					const t = o(e).creators;
					return Object.keys(t).sort((e, n) => t[e] - t[n]).slice(0, 100)
				},
				i = (e, t) => {
					const n = o(e);
					if (Object.keys(n.creators).length >= 200 && !n.creators[t]) {
						const t = c(e),
							s = t[t.length - 1];
						delete n.creators[s]
					}
					return n.creators[t] = (n.creators[t] || 0) + 1, a(e, n)
				},
				d = (e, t) => {
					const n = o(e);
					return delete n.creators[t], a(e, n)
				}
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/lodash/findLastIndex.js"),
				r = n.n(s),
				o = n("./src/reddit/models/WhitelistStatus/index.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/index.ts"),
				i = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const d = (e, t) => {
				let {
					subreddits: n,
					profiles: s
				} = t;
				const r = n[e.belongsTo.id] || s[e.belongsTo.id];
				return !e.isNSFW && r && r.wls === o.a.ALL_ADS
			};
			t.a = (e, t, n) => {
				var {
					postIds: s,
					posts: o,
					subreddits: u,
					profiles: l
				} = n, b = i(n, ["postIds", "posts", "subreddits", "profiles"]);
				const p = e.listings.postOrder.ids[t],
					f = (s || []).filter(e => !p || !p.includes(e)),
					m = p.map(t => e.posts.models[t]),
					O = m.length - (r()(m, e => e.isSponsored) + 1),
					g = f.map(e => o[e]);
				let _;
				const y = [],
					j = {
						subreddits: u,
						profiles: l
					};
				for (let r = 0; r < g.length; r++) {
					const n = g[r];
					let s = !1;
					if (n.isSponsored) {
						const e = r > 0 && g[r - 1],
							t = r < g.length - 1 && g[r + 1];
						e && d(e, j) && t && d(t, j) && (s = !0)
					}
					n.isSponsored && s && (null == _ && O + r >= 3 || r - _ >= 3) ? (_ = r, y.push(n.id)) : n.isSponsored ? n.isSponsored && Object(c.a)(Object.assign({
						source: "feed",
						action: "remove",
						noun: "ad"
					}, a.defaults(e), {
						listing: a.listing(e, t)
					})) : y.push(n.id)
				}
				return Object.assign({}, b, {
					subreddits: u,
					profiles: l,
					posts: o,
					postIds: y
				})
			}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			t.a = () => ({
				type: r.C.SERVER_ERROR,
				fields: [{
					field: "",
					msg: s.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getErrorMsgFromR2JQueryResponse.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = {
					INVALID_EMAIL: "You entered an invalid email. Please try again.",
					RATELIMITED: "You are doing that too much. Please try later.",
					WRONG_PASSWORD: "You entered an incorrect password. Please try again."
				},
				r = (e, t) => -1 !== e.indexOf(t);

			function o(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Something went wrong. Please try again.";
				const n = e && e.body && e.body.jquery && e.body.jquery[14] && e.body.jquery[14][3] && e.body.jquery[14][3][0];
				return "string" != typeof n ? t : r(n, "the following emails are invalid") ? s.INVALID_EMAIL : r(n, "wrong password") ? s.WRONG_PASSWORD : r(n, "you are doing that too much") ? s.RATELIMITED : t
			}
		},
		"./src/reddit/helpers/getGenericUploadError.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/constants/index.ts");

			function r(e) {
				return {
					type: s.C.UNKNOWN_ERROR,
					fields: [{
						field: e,
						msg: "Image failed to upload"
					}]
				}
			}
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/constants/postLayout.ts");

			function r(e) {
				return e ? s.c[e] : s.f
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(r.a)(e) ? t || s.Qb : void 0
			}
		},
		"./src/reddit/helpers/getVendorMetadata.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/adViewability.ts");
			const r = e => e.map(e => Math.floor(100 * e)),
				o = (e, t) => {
					let n = null,
						r = null;
					if ("undefined" == typeof document || "undefined" == typeof window) return null;
					const o = t[1].totalTime || 0,
						a = t[50].totalTime || 0,
						c = t[100].totalTime || 0,
						i = t[1].maxContinuousTime || 0,
						d = t[50].maxContinuousTime || 0,
						u = t[100].maxContinuousTime || 0,
						l = d > s.k,
						b = document.getElementById(e);
					if (!b) return null;
					const p = b.getBoundingClientRect();
					n = p.width, r = p.height;
					const f = t.isGroupMViewable,
						m = t[100].maxContinuousTime > 1e3,
						O = {
							w: n,
							h: r,
							sw: window.screen.width,
							sh: window.screen.height,
							t: Date.now(),
							a: o,
							b: a,
							c,
							d: i,
							e: d,
							f: u
						};
					return t.timeImpressionViewed > 0 && (O.i = Date.now() - t.timeImpressionViewed), l && (O.o = 1), f && (O.g = 1), m && (O.q = 1), t.eventGlobalCount && (O.r = t.eventGlobalCount), O
				}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function o(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : s.fbt._("Something went wrong. Please try again later.", null, {
					hk: "16ibYk"
				})
			}
		},
		"./src/reddit/helpers/graphql/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var s = n("./src/reddit/models/Gold/Award.ts");
			const r = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					try {
						return JSON.parse(e)
					} catch (n) {
						return t
					}
				},
				o = e => {
					switch (e) {
						case "UP":
							return 1;
						case "DOWN":
							return -1;
						default:
							return 0
					}
				},
				a = e => e.reduce((e, t) => {
					let {
						award: n,
						total: r
					} = t;
					if (void 0 !== n.icon) {
						const t = Object(s.i)(n, r);
						e.push(t)
					}
					return e
				}, []);
			var c;
			! function(e) {
				e[e.Seconds = 3] = "Seconds", e[e.Millis = 0] = "Millis"
			}(c || (c = {}));
			const i = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.Seconds;
				if (!e) return 0;
				let n = Date.parse(e);
				return Number.isNaN(n) && (n = Date.parse(e.replace("+0000", "Z"))), Number.isNaN(n) || n <= 0 ? 0 : n - n % Math.pow(10, t)
			};
			window.URL
		},
		"./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/Subreddit/index.ts");
			const r = {
				[s.a.Image]: "images",
				[s.a.Link]: "links",
				[s.a.Spoiler]: "spoilers",
				[s.a.Text]: "text",
				[s.a.Video]: "videos",
				[s.a.Poll]: "polls"
			};
			t.a = e => {
				return Object.assign({}, {
					images: !1,
					links: !1,
					spoilers: !1,
					text: !1,
					videos: !1,
					polls: !1
				}, e.reduce((e, t) => (e[r[t]] = !0, e), {}))
			}
		},
		"./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/models/Flair/index.ts"),
				r = n("./src/reddit/helpers/graphql/helpers.ts");
			const o = e => {
					switch (e) {
						case s.h.Dark:
							return s.e.Dark;
						case s.h.Light:
							return s.e.Light
					}
				},
				a = (e, t, n, o, a) => {
					const c = [];
					return a === s.f.Richtext ? (c.push(Object.assign({
						type: a,
						richtext: Object(r.e)(o, []) || []
					}, e)), t && c.push(Object.assign({
						type: s.f.Text,
						text: t
					}, e))) : c.push(Object.assign({
						type: a,
						text: n
					}, e)), c
				},
				c = e => {
					const {
						text: t,
						richtext: n
					} = e, {
						id: s,
						textColor: r,
						type: c,
						text: i,
						backgroundColor: d,
						cssClass: u
					} = e.template, l = Object.assign({
						backgroundColor: d || "",
						cssClass: u
					}, s && {
						templateId: s
					}, r && {
						textColor: o(r)
					});
					return a(l, i || "", t, n, c)
				},
				i = e => {
					const {
						text: t,
						richtext: n,
						cssClass: s
					} = e, {
						id: r,
						textColor: c,
						type: i,
						text: d,
						backgroundColor: u,
						cssClass: l,
						richtext: b
					} = e.template, p = Object.assign({
						backgroundColor: u || "",
						cssClass: s || l
					}, r && {
						templateId: r
					}, c && {
						textColor: o(c)
					});
					return a(p, d || "", t || "", n || b, i)
				}
		},
		"./src/reddit/helpers/graphql/normalizeModeratorPartFromGql/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/graphql/helpers.ts");
			const r = (e, t) => !!e && (e.verdict === "MOD_".concat(t.toUpperCase()) || e.verdict === "ADMIN_".concat(t.toUpperCase())),
				o = e => e && e.length ? e.map(e => [e.reason || "", e.author && e.author.name || ""]) : null,
				a = e => e && e.length ? e.map(e => [e.reason || "", e.count || 0]) : null;
			t.a = e => {
				let {
					moderationInfo: t
				} = e;
				if (!t) return;
				const n = (e => e && e.verdictBy && e.verdictBy.name || null)(t),
					c = (e => e && Object(s.d)(e.verdictAt) || null)(t),
					i = r(t, "spammed"),
					d = r(t, "approved"),
					u = r(t, "removed"),
					{
						approvedBy: l = null,
						approvedAtUTC: b = null,
						bannedBy: p = null,
						bannedAtUTC: f = null
					} = d ? {
						approvedBy: n,
						approvedAtUTC: c
					} : {
						bannedBy: n,
						bannedAtUTC: c
					};
				return Object.assign({
					isSpam: i,
					isApproved: d,
					isRemoved: u,
					ignoreReports: t.isReportingIgnored,
					numReports: t.reportCount || null,
					modNote: t.modNote,
					approvedBy: l,
					approvedAtUTC: b,
					bannedBy: p,
					bannedAtUTC: f
				}, u && {
					modReasonBy: n
				}, {
					modReports: o(t.modReports) || [],
					userReports: a(t.userReports) || [],
					modReportsDismissed: o(t.dismissedModReports) || [],
					userReportsDismissed: a(t.dismissedUserReports) || []
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/lodash/forEach.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/merge.js"),
				a = n.n(o),
				c = n("./src/lib/env/index.ts"),
				i = n("./src/lib/sentry/index.ts"),
				d = n("./src/reddit/helpers/graphql/helpers.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				b = n("./src/reddit/models/GqlTopLevelField.ts"),
				p = n("./src/reddit/models/Multireddit/index.ts");

			function f(e) {
				const t = {
					multireddits: {},
					multiredditsByUser: {},
					subreddits: {},
					profiles: {}
				};
				if (!e) return t;
				const {
					path: n
				} = e, s = n.toLowerCase(), r = s.endsWith("/") ? s : s + "/", o = {
					created: 0,
					description: e.descriptionContent ? e.descriptionContent.markdown : "",
					descriptionHtml: null,
					descriptionRtJson: e.descriptionContent ? JSON.parse(e.descriptionContent.richtext) : null,
					displayText: e.displayName,
					followerCount: e.followerCount,
					name: e.name,
					icon: e.icon,
					isFavorited: e.isFavorited,
					isFollowed: e.isFollowed,
					isNSFW: e.isNsfw || !1,
					isQuarantined: e.isQuarantined || !1,
					subredditCount: e.subredditCount,
					ownerId: e.ownerInfo.id,
					url: r,
					visibility: e.visibility && e.visibility.toLowerCase() || p.e.Private
				};
				if (o.created = Object(d.d)(e.createdAt) / 1e3, e.sources) {
					o.subredditIds = [], o.profileIds = [];
					for (const {
							node: n
						} of e.sources.edges) {
						if (n.__typename === b.a.Subreddit) o.subredditIds.push(n.id), t.subreddits[n.id] = t.subreddits[n.id] || Object(l.a)(n);
						else if (n.__typename === b.a.Profile) o.profileIds.push(n.id), t.profiles[n.id] = t.profiles[n.id] || Object(u.a)(n);
						else {
							const e = 'Unexpected Multireddit.sources node with type "'.concat(n.__typename, '"');
							Object(c.b)() ? i.c.captureMessage(e) : console.error(e)
						}
						n.isNSFW && (o.isNSFW = !0), n.isQuarantined && (o.isQuarantined = !0)
					}
				}
				return t.multireddits[r] = o, t.multiredditsByUser[e.ownerInfo.id] = [r], t
			}

			function m(e) {
				const t = {},
					n = {},
					s = {},
					o = {},
					c = e.map(f);
				for (const i of c) r()(i.multiredditsByUser, (e, t) => {
					n[t] = [...n[t] || [], ...e]
				}), a()(t, i.multireddits), a()(s, i.profiles), a()(o, i.subreddits);
				return {
					multireddits: t,
					multiredditsByUser: n,
					profiles: s,
					subreddits: o
				}
			}
			t.a = f
		},
		"./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = n("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				o = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				i = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				u = n("./src/reddit/models/Post/index.ts");
			t.a = e => {
				const t = {
					account: null,
					dist: 0,
					features: null,
					multireddits: {},
					multiredditsByUser: {},
					pageInfo: null,
					postFlair: {},
					postIds: [],
					postInstances: {},
					posts: {},
					preferences: null,
					profiles: {},
					subreddits: {},
					token: void 0
				};
				if (!e) return t;
				const {
					identity: n,
					multireddit: l
				} = e;
				if (n && (t.account = Object(d.a)(n) || null, t.preferences = Object(c.a)(n.preferences, n.interactions) || null), !l) return t;
				const {
					posts: b
				} = l;
				if (b) {
					t.pageInfo = b.pageInfo;
					for (const {
							node: e
						} of b.edges) {
						const n = e;
						t.postIds.push(n.id);
						const {
							post: r,
							crosspost: c
						} = n && Object(a.a)(n);
						t.posts[r.id] = r, c && (t.posts[c.id] = c), n.__typename !== u.f.DeletedProfilePost && n.__typename !== u.f.DeletedSubredditPost && (n.authorFlair && (t.postFlair[r.belongsTo.id] || (t.postFlair[r.belongsTo.id] = {}), t.postFlair[r.belongsTo.id][r.author] = Object(s.a)(n.authorFlair)[0]), n.__typename === u.f.SubredditPost && (t.subreddits[n.subreddit.id] || (t.subreddits[n.subreddit.id] = Object(i.a)(n.subreddit)), t.postFlair[n.subreddit.id] || (t.postFlair[n.subreddit.id] = Object(o.a)(n.subreddit))))
					}
				} else t.pageInfo = {
					endCursor: null,
					hasNextPage: !1,
					hasPreviousPage: !1,
					startCursor: null
				};
				t.postIds.length && (t.dist = t.postIds.length), t.pageInfo.hasNextPage && (t.token = t.pageInfo.endCursor || "");
				const {
					multireddits: p,
					multiredditsByUser: f,
					profiles: m,
					subreddits: O
				} = Object(r.a)(l);
				return Object.assign({}, t, {
					multireddits: p,
					multiredditsByUser: f,
					profiles: Object.assign({}, t.profiles, m),
					subreddits: Object.assign({}, t.subreddits, O)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/Flair/index.ts");

			function r(e) {
				switch (e) {
					case s.g.LEFT:
						return s.b.Left;
					case s.g.RIGHT:
						return s.b.Right;
					default:
						return null
				}
			}

			function o(e) {
				let {
					isEnabled: t = !1,
					position: n
				} = e;
				return {
					isEnabled: t,
					position: r(n)
				}
			}
			t.a = e => {
				let {
					postFlairSettings: t
				} = e;
				return Object.assign({}, t && {
					displaySettings: t && o(t)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "d", (function() {
				return B
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/constants/adEvents.ts"),
				a = n("./src/reddit/constants/thumbnails.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				i = n("./src/reddit/helpers/graphql/normalizeModeratorPartFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/helpers.ts"),
				u = e => {
					let {
						options: t,
						selectedOptionId: n,
						totalVoteCount: s,
						votingEndsAt: r
					} = e;
					return {
						options: t,
						totalVoteCount: s,
						userSelection: n,
						votingEndTimestamp: Object(d.d)(r)
					}
				};
			const l = /i\.redd\.it|v\.redd\.it|i\.reddituploads\.com/;
			var b = n("./src/reddit/models/Flair/index.ts"),
				p = n("./src/reddit/models/Media/index.ts");
			const f = e => {
				switch (e) {
					case "IMPRESSION":
						return o.a.Impression;
					case "CLICK":
						return o.a.Click;
					case "COMMENTS_VIEW":
						return o.a.CommentsView;
					case "UPVOTE":
						return o.a.Upvote;
					case "DOWNVOTE":
						return o.a.Downvote;
					case "COMMENT_SUBMITTED":
						return o.a.CommentSubmitted;
					case "VIEWABLE_IMPRESSION":
						return o.a.ViewableImpression;
					case "COMMENT_UPVOTE":
						return o.a.CommentUpvote;
					case "COMMENT_DOWNVOTE":
						return o.a.CommentDownvote;
					case "VIDEO_VIEWABLE_IMPRESSION":
						return o.a.VideoViewableImpression;
					case "VIDEO_FULLY_VIEWABLE_IMPRESSION":
						return o.a.VideoFullyViewableImpression;
					case "VIDEO_PLAYED_WITH_SOUND":
						return o.a.VideoPlayedWithSound;
					case "VIDEO_PLAYED_EXPANDED":
						return o.a.VideoPlayedExpanded;
					case "VIDEO_WATCHED_25":
						return o.a.VideoWatched25;
					case "VIDEO_WATCHED_50":
						return o.a.VideoWatched50;
					case "VIDEO_WATCHED_75":
						return o.a.VideoWatched75;
					case "VIDEO_WATCHED_95":
						return o.a.VideoWatched95;
					case "VIDEO_WATCHED_100":
						return o.a.VideoWatched100;
					case "VIDEO_STARTED":
						return o.a.VideoStarted;
					case "VIDEO_WATCHED_3_SECS":
						return o.a.VideoWatchedSeconds3;
					case "VIDEO_WATCHED_5_SECS":
						return o.a.VideoWatchedSeconds5;
					case "VIDEO_WATCHED_10_SECS":
						return o.a.VideoWatchedSeconds10;
					case "VENDOR_FULLY_IN_VIEW":
						return o.a.VendorFullyInView;
					case "VENDOR_FULLY_IN_VIEW_5_SECS":
						return o.a.VendorFullyInViewSeconds5;
					case "VENDOR_FULLY_IN_VIEW_15_SECS":
						return o.a.VendorFullyInViewSeconds15;
					case "UNLOAD":
						return o.a.Unload;
					case "GROUP_M_VIEWABLE":
						return o.a.GroupMViewable;
					case "MRC_VIDEO_VIEWABLE_IMPRESSION":
						return o.a.MRCVideoViewableImpression;
					case "VIDEO_VENDOR_FULLY_VIEWABLE_50":
						return o.a.VideoVendorFullyViewable50;
					case "VIDEO_GROUP_M_VIEWABLE":
						return o.a.VideoGroupMViewable
				}
			};
			var m = n("./src/reddit/models/Post/index.ts"),
				O = n("./src/reddit/models/PostCreationForm/index.ts"),
				g = n("./src/reddit/models/RichTextJson/index.ts"),
				_ = n("./src/reddit/models/User/index.ts"),
				y = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const j = e => e.__typename === m.f.DeletedProfilePost || e.__typename === m.f.DeletedSubredditPost,
				h = [m.e.Embed, m.e.Image, m.e.Video, m.e.Gifvideo],
				E = e => {
					const t = e.thumbnail ? Object.assign({
						url: e.thumbnail.url
					}, e.thumbnail.dimensions) : {
						url: a.a.DEFAULT,
						width: null,
						height: null
					};
					return e.__typename === m.f.AdPost && e.authorOnlyInfo && t.url ? t : e.__typename !== m.f.SubredditPost || e.subreddit.isThumbnailsEnabled ? t : e.isSelfPost ? Object.assign({}, t, {
						url: a.a.SELF
					}) : e.media && e.media.typeHint && h.includes(e.media.typeHint) ? Object.assign({}, t, {
						url: a.a.IMAGE
					}) : Object.assign({}, t, {
						url: a.a.DEFAULT
					})
				},
				I = e => {
					switch (e.__typename) {
						case m.f.SubredditPost:
							return {
								id: e.subreddit.id, type: "subreddit"
							};
						default:
							return {
								id: e.profile.id, type: "profile"
							}
					}
				},
				v = e => {
					var {
						flair: t,
						isNsfw: n,
						isSpoiler: s
					} = e, r = y(e, ["flair", "isNsfw", "isSpoiler"]);
					const o = [];
					t && o.push(...Object(c.b)(t)), s && o.push({
						text: "spoiler",
						type: b.f.Spoiler
					}), n && o.push({
						text: "nsfw",
						type: b.f.Nsfw
					});
					let a = !1;
					return r.__typename === m.f.ProfilePost ? a = r.profile.isQuarantined : r.__typename === m.f.SubredditPost && (a = r.subreddit.isQuarantined), a && o.push({
						text: "quarantined",
						type: b.f.Quarantined
					}), o
				},
				S = e => e.map(e => {
					let {
						type: t,
						url: n
					} = e;
					return {
						url: n || "",
						type: f(t)
					}
				}),
				T = e => {
					var {
						domain: t,
						url: n
					} = e, s = y(e, ["domain", "url"]);
					if (s.__typename === m.f.AdPost || !s.isSelfPost && !(e => l.test(e))(t || "")) {
						const e = s.outboundLink && s.outboundLink.expiresAt && Object(d.d)(s.outboundLink.expiresAt);
						return Object.assign({
							displayText: t || "",
							url: n || ""
						}, s.outboundLink && {
							outboundUrl: s.outboundLink.url || void 0,
							outboundUrlCreated: e && e - 36e5 || void 0,
							outboundUrlExpiration: e || void 0
						})
					}
					return null
				},
				D = {
					small: 108,
					medium: 216,
					large: 320,
					xlarge: 640,
					xxlarge: 960,
					xxxlarge: 1080
				},
				C = (e, t) => {
					const n = e && (t ? e.animated : e.still);
					if (!n) return [];
					const s = e && e.still && e.still.source ? e.still.source.dimensions.width : 0;
					return Object.keys(D).reduce((e, r) => {
						const o = n[t ? "".concat(t, "_").concat(r) : r];
						if (!o || D[r] > s) return e;
						const a = Object.assign({
							url: o.url
						}, o.dimensions);
						return a ? [...e, a] : e
					}, [])
				},
				w = e => {
					const {
						media: t,
						isSelfPost: n
					} = e;
					if (n) return e.content && e.content.richtext ? p.n.RTJSON : p.n.TEXT;
					switch (t && t.typeHint) {
						case m.e.Image:
							return p.n.IMAGE;
						case m.e.Gifvideo:
							return p.n.GIFVIDEO;
						case m.e.Video:
							return p.n.VIDEO;
						case m.e.Embed:
							return p.n.EMBED;
						case m.e.RPAN:
							return p.n.LIVEVIDEO;
						default:
							return null
					}
				},
				A = e => e.authorOnlyInfo && e.authorOnlyInfo.contentMode === m.d.Markdown ? O.h.MARKDOWN : O.h.RICH_TEXT,
				R = e => Math.min(e.height, e.width),
				P = (e, t) => {
					const {
						media: n,
						content: s
					} = e, r = (e => e.isSpoiler || e.isNsfw)(e) ? n && n.obfuscatedStill && n.obfuscatedStill.source && n.obfuscatedStill.source.url : null;
					switch (t) {
						case p.n.VIDEO: {
							const e = 400,
								s = C(n),
								o = n && n.still && n.still.source && Object.assign({
									url: n.still.source.url
								}, n.still.source.dimensions);
							let a;
							if (s.length) {
								a = s.reduce((e, t) => e.width > t.width ? e : t);
								const t = s.reduce((t, n) => R(n) > e && o && R(n) < R(o) ? [...t, n] : t, []);
								t.length && (a = t.reduce((e, t) => R(e) < R(t) ? e : t))
							} else a = o;
							return {
								type: t,
								obfuscated: r,
								hlsUrl: n && n.streaming && n.streaming.hlsUrl || "",
								dashUrl: n && n.streaming && n.streaming.dashUrl || "",
								isGif: !!n && !!n.streaming && n.streaming.isGif,
								scrubberThumbSource: n && n.streaming && n.streaming.scrubberMediaUrl || "",
								width: n && n.streaming ? n.streaming.dimensions.width : 0,
								height: n && n.streaming ? n.streaming.dimensions.height : 0,
								posterUrl: a && a.url || void 0
							}
						}
						case p.n.LIVEVIDEO:
							return {
								type: t, obfuscated: null, hlsUrl: n && n.RPAN && n.RPAN.hlsUrl || "", scrubberThumbSource: n && n.RPAN && n.RPAN.scrubberMediaUrl || ""
							};
						case p.n.TEXT:
							return {
								type: t, obfuscated: null, markdownContent: e.content ? e.content.markdown : "", content: "", rteMode: A(e)
							};
						case p.n.RTJSON:
							return {
								type: t, obfuscated: null, markdownContent: e.content ? e.content.markdown : "", richtextContent: Object(d.e)(s.richtext, g.i), content: "", rteMode: A(e), mediaMetadata: G(e)
							};
						case p.n.IMAGE: {
							const s = n && n.animated && n.animated.gif_source ? "gif" : null;
							let o = "";
							return "i.redd.it" === e.domain && e.url ? o = e.url : n && n.still && n.still.source && (o = n.still.source.url), {
								type: t,
								obfuscated: r,
								resolutions: C(n, s),
								width: n && n.still && n.still.source ? n.still.source.dimensions.width : 0,
								height: n && n.still && n.still.source ? n.still.source.dimensions.height : 0,
								content: o
							}
						}
						case p.n.EMBED:
							return {
								type: t, obfuscated: r, width: n && n.video && n.video.dimensions && n.video.dimensions.width || 0, height: n && n.video && n.video.dimensions && n.video.dimensions.height || 0, provider: n && n.video && n.video.attribution && n.video.attribution.providerName || "", content: n && n.video && n.video.embedUrl ? n.video.embedUrl : ""
							};
						case p.n.GIFVIDEO:
							return {
								type: t, obfuscated: r, resolutions: C(n, "mp4"), width: n && n.still && n.still.source ? n.still.source.dimensions.width : 0, height: n && n.still && n.still.source ? n.still.source.dimensions.height : 0, gifBackgroundImage: n && n.still && n.still.source ? n.still.source.url : "", content: n && n.animated && n.animated.mp4_source ? n.animated.mp4_source.url : ""
							};
						default:
							return null
					}
				},
				k = {
					events: [],
					isBlank: !1,
					isSponsored: !1
				},
				x = /\.gif\?(.*$)/,
				N = e => {
					const t = e.adEvents.find(e => f(e.type) === o.a.Impression),
						n = t && t.url && t.url.match(x);
					return n && n[1] ? "t3_".concat(n[1]) : null
				},
				L = e => e ? e.toLowerCase() : null,
				U = e => {
					let {
						isLive: t,
						startsAt: n,
						endsAt: s
					} = e;
					return {
						eventIsLive: t,
						eventStart: Math.round(Date.parse(n) / 1e3),
						eventEnd: Math.round(Date.parse(s) / 1e3)
					}
				};
			t.a = e => {
				const t = {
						post: B(e)
					},
					{
						crosspostRoot: n
					} = e;
				return n && n.type === m.a.Post && n.postInfo && (t.crosspost = B(n.postInfo)), t
			};
			const M = e => e && e.__typename !== _.c.DeletedRedditor ? "name" in e && e.name || "" : s.y,
				F = e => !(!e || e.__typename !== _.c.AvailableRedditor) && !!e.isPremiumMember,
				G = e => e.content && e.content.richtextMedia && e.content.richtextMedia.length ? e.content.richtextMedia.reduce((e, t) => {
					switch (t.__typename) {
						case m.c.ImageAsset:
							"image/gif" === t.mimetype ? e[t.id] = {
								e: g.r,
								id: t.id,
								s: {
									gif: t.url,
									x: t.height,
									y: t.width
								}
							} : e[t.id] = {
								e: g.s,
								id: t.id,
								s: {
									u: t.url,
									x: t.height,
									y: t.width
								}
							};
							break;
						case m.c.VideoAsset:
							e[t.id] = {
								dashUrl: t.dashUrl,
								e: g.t,
								hlsUrl: t.hlsUrl,
								id: t.id,
								x: t.height,
								y: t.width
							}
					}
					return e
				}, {}) : null,
				B = e => {
					const {
						awardings: t,
						commentCount: n,
						createdAt: o,
						crosspostCount: a,
						crosspostRoot: c,
						discussionType: l,
						domain: b,
						id: p,
						isArchived: f,
						isContestMode: O,
						isFollowed: g,
						isGildable: _,
						isHidden: y,
						isLocked: j,
						isNsfw: h,
						isOriginalContent: D,
						isSaved: C,
						isSpoiler: A,
						isStickied: R,
						liveCommentsWebsocket: x,
						permalink: N,
						removedBy: G,
						removedByCategory: B,
						poll: q,
						score: V,
						suggestedCommentSort: K,
						title: H,
						upvoteRatio: W,
						viewCount: Y,
						voteState: Q
					} = e, z = B && "NONE" !== B ? B.toLowerCase() : null, J = c && (c.type === m.a.Post ? c.postInfo && c.postInfo.id : c.comment && c.comment.id);
					c && !J && r.c.withScope(e => {
						e.setExtra("postId", p), Object(r.a)(e, {
							serverLogging: !1
						}), r.c.captureMessage("Lack of post or comment in crosspostRoot")
					});
					const X = t ? Object(d.b)(t) : void 0,
						Z = Object.assign({
							allAwardings: X,
							author: s.y,
							authorId: "",
							approvedAtUTC: null,
							approvedBy: null,
							bannedAtUTC: null,
							bannedBy: null,
							belongsTo: {
								id: "",
								type: "subreddit"
							},
							contestMode: O,
							created: Object(d.d)(o),
							crosspostParentId: J,
							crosspostRootId: J,
							discussionType: l,
							distinguishType: null,
							domain: b || "",
							events: [],
							flair: v(e),
							hidden: y,
							id: p,
							ignoreReports: !1,
							isApproved: !1,
							isArchived: f,
							isAuthorPremium: !1,
							isBlank: !1,
							isCrosspostable: !1,
							isFollowed: g,
							isGildable: _,
							isLocked: j,
							isMediaOnly: !1,
							isMeta: !1,
							isNSFW: h,
							isOriginalContent: D,
							isPinned: !1,
							isRemoved: !1,
							isScoreHidden: null === V,
							isSpam: !1,
							isSpoiler: A,
							isSponsored: !1,
							isStickied: R,
							liveCommentsWebsocket: x,
							media: null,
							modReports: [],
							numComments: n || 0,
							numCrossposts: a || 0,
							numReports: null,
							permalink: "https://www.reddit.com".concat(N),
							pollData: q && u(q) || void 0,
							postCategories: null,
							postId: p,
							previewComments: [],
							removedBy: G && G.name ? G.name : null,
							removedByCategory: z,
							saved: C,
							score: null !== V && V > 0 ? V : 0,
							sendReplies: !1,
							source: T(e),
							suggestedSort: K && s.q[K] || null,
							thumbnail: {
								height: null,
								url: "",
								width: null
							},
							title: H || "",
							upvoteRatio: W,
							userReports: [],
							viewCount: Y || 0,
							voteState: Q ? Object(d.c)(Q) : 0
						}, e.__typename === m.f.AdPost ? (e => {
							const {
								adEvents: t,
								callToAction: n,
								domain: s,
								isBlank: r
							} = e;
							return {
								callToAction: n,
								domainOverride: s,
								events: S(t),
								isBlank: r,
								isSponsored: !0
							}
						})(e) : k, Object(i.a)(e));
					if (e.__typename === m.f.DeletedProfilePost || e.__typename === m.f.DeletedSubredditPost) return Z;
					const {
						authorInfo: $,
						authorOnlyInfo: ee,
						distinguishedAs: te,
						isCrosspostable: ne,
						isMediaOnly: se,
						isPollIncluded: re,
						media: oe,
						postEventInfo: ae
					} = e, ce = (e => e && e.still && e.still.source ? Object.assign({
						url: e.still.source.url
					}, e.still.source.dimensions) : void 0)(oe);
					return Object.assign({}, Z, {
						author: $ && M($) || s.y,
						authorId: $ && $.id || "",
						belongsTo: I(e),
						distinguishType: L(te),
						isCrosspostable: ne,
						isMediaOnly: se,
						isMeta: re,
						isAuthorPremium: F($),
						media: P(e, w(e)),
						thumbnail: E(e)
					}, ce && {
						preview: ce
					}, ee && {
						sendReplies: ee.isReceivingPostReplies
					}, ae && {
						eventInfo: U(ae)
					})
				}
		},
		"./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const r = e => {
				let {
					edges: t
				} = e;
				const n = [];
				for (const {
						node: r
					} of t) n.push(Object(s.d)(r));
				return n
			}
		},
		"./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/User/index.ts");
			t.a = (e, t) => ({
				allowClickTracking: e.isClickTrackingEnabled,
				autoplayVideo: !e.isVideoAutoplayDisabled,
				defaultCommentSort: e.defaultCommentSort && r.b[e.defaultCommentSort] ? s.q[e.defaultCommentSort] : s.q.CONFIDENCE,
				geopopular: e.geopopular,
				hideNSFW: e.isNsfwMediaBlocked,
				ignoreSuggestedSort: e.isSuggestedSortIgnored,
				labelNSFW: e.isNsfwLabelShown,
				markMessagesRead: e.isMessageAutoReadEnabled,
				nightmode: e.isNightModeEnabled,
				over18: e.isNsfwContentShown,
				account: {
					openPostInNewTab: e.isNewTabOpenedForPostView,
					rpanDuDismissalTime: e.rpanDuDismissedAt,
					sort: e.globalCommunityPostFeedSort.range ? "".concat(e.globalCommunityPostFeedSort.sort.toLowerCase(), "_").concat(e.globalCommunityPostFeedSort.range.toLowerCase()) : e.globalCommunityPostFeedSort.sort.toLowerCase(),
					showRpanDu: e.isRpanDuShown,
					stylesEnabled: e.isCommunityStylingEnabled,
					rememberCommunitySort: e.isCommunityPostFeedSortingPreserved,
					useMarkdown: e.isMarkdownDefaultEditorMode,
					rememberCommunityLayout: e.isCommunityLayoutPreserved,
					layout: e.postFeedLayout.toLowerCase(),
					hasSeenCustomizeFlyout: t && t.isDefaultPostLayoutAware
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				r = n("./src/reddit/models/Subreddit/index.ts"),
				o = n("./src/reddit/models/User/index.ts"),
				a = n("./src/reddit/models/WhitelistStatus/index.ts");
			const c = e => {
				let {
					pageInfo: t,
					edges: n
				} = e;
				const r = {
					moderatedSubredditIds: [],
					pageInfo: t,
					subreddits: {}
				};
				for (const {
						node: o
					} of n) {
					const e = Object(s.a)(o);
					r.subreddits[e.id] = e, r.moderatedSubredditIds.push(e.id)
				}
				return r
			};
			t.a = e => {
				let {
					name: t,
					path: n,
					redditorInfo: s,
					styles: c,
					wls: i,
					id: d,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				} = e;
				const {
					height: f,
					icon: m,
					width: O
				} = c && c.legacyIcon && {
					height: c.legacyIcon.dimensions.height,
					icon: c.legacyIcon.url,
					width: c.legacyIcon.dimensions.width
				} || {
					height: null,
					icon: c && c.icon || "",
					width: null
				}, g = c && c.legacyPrimaryColor, _ = s && s.__typename === o.c.AvailableRedditor && s.prefixedName || "";
				return Object.assign({
					url: n,
					displayText: _,
					icon: {
						url: m,
						width: O,
						height: f
					},
					communityIcon: m,
					type: r.c.User,
					name: t.substr(2)
				}, g && {
					primaryColor: g
				}, i && {
					whitelistStatus: i.toLowerCase(),
					wls: a.a[i]
				}, {
					id: d,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/reddit/helpers/graphql/helpers.ts"),
				r = n("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts");
			const o = e => {
					const t = Object(r.a)(e.allowedPostTypes),
						n = e.moderation ? e.moderation.coins : void 0;
					return {
						[e.id]: {
							accountsActive: e.activeCount,
							activity7Day: e.activity7Day,
							allOriginalContent: !1,
							allowedPostTypes: t,
							allowChatPostCreation: e.isChatPostCreationAllowed,
							coins: n,
							created: Object(s.d)(e.createdAt),
							disableContributorRequests: !1,
							emojisEnabled: !0,
							isChatPostFeatureEnabled: e.isChatPostFeatureEnabled,
							isCrosspostableSubreddit: e.isCrosspostDestination,
							originalContentTagEnabled: !0,
							publicDescription: e.publicDescription.markdown,
							restrictCommenting: !1,
							restrictPosting: !0,
							showMedia: !0,
							subscribers: e.subscribersCount,
							userIsBanned: e.isUserBanned,
							userIsContributor: e.isContributor,
							userIsSubscriber: e.isSubscribed,
							usingNewModmail: !0
						}
					}
				},
				a = e => e.reduce((e, t) => Object.assign({}, e, o(t)), {});
			t.a = o
		},
		"./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			}));
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				c = n("./src/reddit/models/GqlTopLevelField.ts"),
				i = n("./src/reddit/models/WhitelistStatus/index.ts");
			const d = e => e.subredditRecommendations.recommendations.map(l).reduce((e, t) => (e[t.id] = t, e), {}),
				u = e => {
					const t = {
							posts: {},
							subredditTopContent: {}
						},
						n = [],
						{
							__typename: s
						} = e;
					if (s !== c.a.Subreddit) return null;
					const {
						id: r,
						isSubscribed: i,
						name: d,
						topContent: u
					} = e, {
						posts: l,
						range: b
					} = u;
					return l.forEach(e => {
						const {
							post: s,
							crosspost: r
						} = Object(a.a)(e), o = s.id;
						if (t.posts[o] = s, n.push(o), r) {
							const e = r.id;
							t.posts[e] = r
						}
					}), t.subredditTopContent[d.toLowerCase()] = {
						id: r,
						isSubscribed: i,
						name: d,
						postIds: n,
						range: o.Pb[b]
					}, t
				},
				l = e => {
					const {
						path: t,
						prefixedName: n,
						type: s,
						styles: r,
						wls: o,
						id: a,
						isQuarantined: c,
						isNSFW: d,
						name: u,
						subscribers: l,
						title: b,
						isFreeFormReportingAllowed: p
					} = e, {
						height: f,
						icon: m,
						width: O
					} = r && r.legacyIcon && {
						height: r.legacyIcon.dimensions.height,
						icon: r.legacyIcon.url,
						width: r.legacyIcon.dimensions.width
					} || {
						height: null,
						icon: r && r.icon || "",
						width: null
					}, g = r && r.primaryColor, _ = r && r.icon;
					return Object.assign({
						url: t,
						displayText: n,
						icon: {
							url: m,
							width: O,
							height: f
						}
					}, _ && {
						communityIcon: _
					}, {
						type: s.toLowerCase(),
						primaryColor: g || ""
					}, o && {
						whitelistStatus: o.toLowerCase(),
						wls: i.a[o]
					}, {
						freeFormReports: p,
						id: a,
						isQuarantined: c,
						isNSFW: d,
						name: u,
						subscribers: l,
						title: b
					})
				},
				b = (e, t) => ({
					isMod: r()(e),
					modAccess: e.isAccessEnabled,
					modConfig: e.isConfigEditingAllowed,
					modFlair: e.isFlairEditingAllowed,
					modFull: e.isAllAllowed,
					modMail: e.isMailEditingAllowed,
					modNone: !r()(e),
					modPost: e.isPostEditingAllowed,
					modWiki: e.isWikiEditingAllowed,
					isSubscriber: t
				}),
				p = e => e.reduce((e, t) => {
					const n = l(t);
					return e[n.id] = n, e
				}, {}),
				f = e => e;
			t.a = l
		},
		"./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			t.a = e => {
				const t = {
					menuPosition: e.menuPosition ? e.menuPosition.toLowerCase() : void 0,
					bannerCommunityNameFormat: e.bannerCommunityNameFormat ? e.bannerCommunityNameFormat.toLowerCase() : void 0,
					bannerShowCommunityIcon: e.bannerShowCommunityIcon ? e.bannerShowCommunityIcon.toLowerCase() : void 0,
					bannerHeight: e.bannerHeight ? e.bannerHeight.toLowerCase() : void 0,
					postVoteIcons: e.postVoteIcons ? e.postVoteIcons.toLowerCase() : void 0,
					submenuBackgroundStyle: e.submenuBackgroundStyle ? e.submenuBackgroundStyle.toLowerCase() : void 0,
					backgroundImagePosition: e.backgroundImagePosition ? e.backgroundImagePosition.toLowerCase() : void 0,
					bannerBackgroundImagePosition: e.bannerBackgroundImagePosition ? e.bannerBackgroundImagePosition.toLowerCase() : void 0,
					bannerPositionedImagePosition: e.bannerPositionedImagePosition ? e.bannerPositionedImagePosition.toLowerCase() : void 0,
					postBackgroundImagePosition: e.postBackgroundImagePosition ? e.postBackgroundImagePosition.toLowerCase() : void 0,
					postPlaceholderImagePosition: e.postPlaceholderImagePosition ? e.postPlaceholderImagePosition.toLowerCase() : void 0,
					menuBackgroundOpacity: e.menuBackgroundOpacity || void 0,
					backgroundImage: e.backgroundImage || void 0,
					bannerBackgroundImage: e.bannerBackgroundImage || void 0,
					bannerPositionedImage: e.bannerPositionedImage || void 0,
					communityIcon: e.icon || void 0,
					menuBackgroundImage: e.menuBackgroundImage || void 0,
					postBackgroundImage: e.postBackgroundImage || void 0,
					postDownvoteIconActive: e.postDownvoteIconActive || void 0,
					postDownvoteIconInactive: e.postDownvoteIconInactive || void 0,
					postPlaceholderImage: e.postPlaceholderImage || void 0,
					postUpvoteIconActive: e.postUpvoteIconActive || void 0,
					postUpvoteIconInactive: e.postUpvoteIconInactive || void 0,
					bannerBackgroundColor: e.bannerBackgroundColor || void 0,
					bannerOverlayColor: e.bannerOverlayColor || void 0,
					menuBackgroundColor: e.menuBackgroundColor || void 0,
					menuLinkColorActive: e.menuLinkColorActive || void 0,
					menuLinkColorInactive: e.menuLinkColorInactive || void 0,
					menuLinkColorHover: e.menuLinkColorHover || void 0,
					submenuBackgroundColor: e.submenuBackgroundColor || void 0,
					primaryColor: e.primaryColor || void 0,
					highlightColor: e.highlightColor || void 0,
					postTitleColor: e.postTitleColor || void 0,
					backgroundColor: e.backgroundColor || void 0,
					postBackgroundColor: e.postBackgroundColor || void 0,
					postDownvoteCountColor: e.postDownvoteCountColor || void 0,
					postUpvoteCountColor: e.postUpvoteCountColor || void 0,
					mobileKeyColor: e.mobileKeyColor || void 0,
					mobileBannerImage: e.mobileBannerImage || void 0,
					sidebarWidgetHeaderColor: e.sidebarWidgetHeaderColor || void 0,
					sidebarWidgetBackgroundColor: e.sidebarWidgetBackgroundColor || void 0,
					secondaryBannerPositionedImage: e.secondaryBannerPositionedImage || void 0
				};
				return Object.keys(t).forEach(e => {
					void 0 === t[e] && delete t[e]
				}), t
			}
		},
		"./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/reddit/models/User/index.ts"),
				r = n("./src/reddit/helpers/graphql/helpers.ts"),
				o = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const a = e => e && e.expiresAt && Object(r.d)(e.expiresAt, r.a.Seconds) / 1e3 || null,
				c = e => e && e.unreadCount ? e.unreadCount : 0,
				i = /^u\//,
				d = e => e.replace(i, "/user/"),
				u = e => e.__typename === s.c.DeletedRedditor ? null : "name" in e && e.name || null;
			t.a = e => {
				var {
					redditor: t,
					inbox: n,
					premium: i,
					preferences: u,
					coins: l
				} = e, b = o(e, ["redditor", "inbox", "premium", "preferences", "coins"]);
				let p = {
					awardeeKarma: 0,
					awarderKarma: 0,
					commentKarma: 0,
					hasUserProfile: !1,
					id: t.id,
					isGold: !1,
					postKarma: 0,
					totalKarma: 0,
					url: ""
				};
				if (t.__typename === s.c.AvailableRedditor) {
					const {
						karma: e,
						profile: n
					} = t, s = n && n.styles && n.styles.legacyIcon && n.styles.legacyIcon.url;
					p = Object.assign({}, p, s && {
						accountIcon: s
					}, {
						awardeeKarma: e ? e.fromAwardsReceived : 0,
						awarderKarma: e ? e.fromAwardsGiven : 0,
						commentKarma: e ? e.fromComments : 0,
						displayText: t.name,
						hasExternalAccount: t.isLinkedToExternalAccount,
						hasUserProfile: !!n,
						isGold: !!t.isGilded,
						postKarma: e ? e.fromPosts : 0,
						totalKarma: e ? e.total : 0,
						profileId: n && n.id || void 0,
						url: t.prefixedName && d(t.prefixedName) || void 0
					})
				}
				const {
					interactions: f,
					modMail: m
				} = b;
				return Object.assign({}, p, {
					coins: l,
					created: Object(r.d)(b.createdAt, r.a.Seconds) / 1e3,
					goldExpiration: a(i),
					hasUnreadMail: c(n) > 0,
					hasUnreadModmail: !!m && m.isUnread,
					hasUnreadOldModmail: !!m && m.isUnread,
					hasVerifiedEmail: !!b.isEmailVerified,
					inboxCount: c(n),
					inRedesignBeta: u.isInRedesignBeta,
					isEmployee: !!b.isEmployee,
					isFPR: !!b.isForcePasswordReset,
					isNameEditable: !!b.isNameEditable,
					isMod: !!b.isModerator,
					isPasswordSet: !!b.isPasswordSet,
					isSuspended: b.isSuspended,
					nightmode: u.isNightModeEnabled,
					seenLayoutSwitch: !!f && f.isLayoutSwitchAware,
					seenRedesignModal: !!f && f.isRedesignModalAware,
					seenSubredditChatFtux: !!f && f.isSubredditChatAware,
					showRecentPosts: u.isRecentPostsShown,
					showTrending: u.isTrendingSubredditsShown
				}, i && i.subscription && {
					hasAndroidSubscription: i.subscription.isAndroidAvailable,
					hasGoldSubscription: i.subscription.isGoldAvailable,
					hasIOSSubscription: i.subscription.isIOSAvailable,
					hasPaypalSubscription: i.subscription.isPaypalAvailable,
					hasStripeSubscription: i.subscription.isStripeAvailable
				})
			}
		},
		"./src/reddit/helpers/history/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s);
			const o = (e, t) => {
					const n = history.state ? history.state.state : {},
						s = Object.assign({}, history.state, {
							state: Object.assign({}, n, {
								[e]: t
							})
						});
					history.replaceState(s, window.document.title)
				},
				a = e => {
					const t = Object.assign({}, history.state, {
						state: Object.assign({}, r()(history.state.state, e))
					});
					history.replaceState(t, window.document.title)
				},
				c = e => history && history.state && history.state.state && history.state.state[e]
		},
		"./src/reddit/helpers/isArrayEqual.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/xorWith.js"),
				a = n.n(o);
			t.a = (e, t) => {
				const n = a()(e, t, r.a);
				return !(!n || 0 !== n.length)
			}
		},
		"./src/reddit/helpers/makeModQueueListingKey/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const {
					profile: t,
					subreddit: n
				} = e;
				let s = n && "r/".concat(n) || t && "u/".concat(t) || "all";
				return "comments" !== e.onlyOfType && "links" !== e.onlyOfType || (s += "--[".concat(e.onlyOfType, "]")), s
			}
		},
		"./src/reddit/helpers/makeProfileListingKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeListingKey/index.ts");
			const o = (e, t) => "".concat(s.Rb).concat(e.toLowerCase(), "--private--").concat(t);
			t.a = function(e, t, n) {
				let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
				const a = "".concat(s.Rb).concat(e, "--").concat(t);
				return Object(r.a)(a, n, o)
			}
		},
		"./src/reddit/helpers/normalizeUsername/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = e => {
				const t = /^((\/u\/)|(u\/))/;
				return /^((\/u\/)|(u\/))(.+)/.test(e) ? e.replace(t, "") : e
			}
		},
		"./src/reddit/helpers/onBeforeRequestFactory/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				a = n("./src/lib/addQueryParams/index.ts"),
				c = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.constructor.js"), n("./src/reddit/selectors/subreddit.ts"));
			const i = new RegExp("^/desktopapi/v1/(duplicates/[^/]+|frontpage|news|search|subreddits/(all|popular))(/|$)"),
				d = new RegExp("^/desktopapi/v1/(search|subreddits|postcomments|collection_postcomments|submitpage)(/|$)"),
				u = new RegExp("^/desktopapi/v1/(subreddits|postcomments|collection_postcomments)/?$"),
				l = (new RegExp("^/desktopapi/v1/(postcomments)(/+|$)"), new RegExp("^/desktopapi/v1/frontpage/?$")),
				b = new RegExp("^/desktopapi/v1/submitpage(/|$)");
			var p = (e, t, n) => {
					const s = new Set;
					e.user.session && !e.user.session.unsafeLoggedOut && (e.user.account || (s.add("identity"), s.add("prefs"), s.add("prefsAccount")), (e => !i.test(e.pathname || ""))(t) && s.add("identity")), !e.live.isFrontpageLoaded && (e => l.test(e.pathname || ""))(t) && s.add("featuredLiveThread");
					const r = t.pathname || "";
					if (d.test(r) || u.test(r)) {
						const r = ((e, t) => {
								if (b.test(e.pathname || "")) {
									const {
										subreddit: e
									} = t.data;
									return e
								}
							})(t, n),
							o = e.platform.currentPage,
							a = o && o.urlParams.subredditName,
							i = r || a || "",
							d = Object(c.E)(e, i);
						d && e.structuredStyles.models[d] || s.add("structuredStyles"), e.user.prefs.subreddit[d] || s.add("prefsSubreddit")
					}
					return [...s].join(",")
				},
				f = n("./src/reddit/selectors/user.ts");
			t.a = e => t => {
				const n = r.a.parse(t.endpoint, !0),
					{
						host: s,
						protocol: c
					} = n;
				if ("".concat(c, "//").concat(s) === o.a.gatewayUrl) {
					const s = {},
						r = Object(f.V)(e.getState()) ? "1" : "";
					s.allow_over18 = r, s.include = p(e.getState(), n, t), t.endpoint = Object(a.a)(t.endpoint, s)
				}
			}
		},
		"./src/reddit/helpers/ordinal/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				const t = ["th", "st", "nd", "rd"],
					n = e % 100;
				return e + (t[(n - 20) % 10] || t[n] || t[0])
			}
		},
		"./src/reddit/helpers/overlay/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/history/esm/history.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/reddit/helpers/path/index.ts");
			const a = e => {
					if ("string" == typeof e) return Object(s.c)(Object(o.b)(e), {
						isOverlay: !0
					}); {
						const t = Object(s.c)(e);
						return t.state = Object.assign({}, t.state || {}, {
							isOverlay: !0
						}), t
					}
				},
				c = e => Object(r.b)(a(e))
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/history/esm/history.js"), n("./src/reddit/actions/platform.ts");
			var s = n("./src/config.ts");
			t.a = (e, t) => {
				const n = t.platform.currentPage && t.platform.currentPage.url;
				let r = "".concat(s.a.accountManagerOrigin, "/login/");
				const o = window.location.origin;
				n && (r += "?dest=".concat(encodeURIComponent("".concat(o).concat(n)))), window.location.href = r
			}
		},
		"./src/reddit/helpers/parseUrl.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				a = n.n(o);
			const c = /\b(https?|chrome):\/\/[^\s$.?#].[^\s]*\b/;
			t.a = e => {
				if (!e) return null;
				const t = a.a.parse(e);
				return r()(t, ["protocol", "hostname", "port", "pathname", "search", "hash", "host"])
			}
		},
		"./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			var s = n("./src/reddit/models/Gold/Award.ts");
			t.a = e => e.map(e => ({
				awardType: e.award_type,
				awardSubType: e.award_sub_type ? e.award_sub_type : s.b.Global,
				coinPrice: e.coin_price,
				coinReward: e.coin_reward,
				count: e.count,
				daysOfDripExtension: e.days_of_drip_extension,
				daysOfPremium: e.days_of_premium,
				description: e.description,
				iconUrl: e.icon_url,
				resizedIcons: e.resized_icons,
				id: e.id,
				isEnabled: e.is_enabled,
				isNew: !!e.is_new,
				name: e.name,
				subredditCoinReward: e.subreddit_coin_reward,
				tags: e.tags
			}));
			const r = e => {
					const {
						icon_url: t,
						resized_icons: n
					} = e;
					let r, o, a;
					for (const {
							url: s,
							width: c
						} of n || []) 32 === c && (r = {
						url: s
					}), 64 === c && (o = {
						url: s
					}), 128 === c && (a = {
						url: s
					});
					return {
						awardType: e.award_type.toUpperCase(),
						awardSubType: e.award_sub_type ? e.award_sub_type.toUpperCase() : s.d.Global,
						coinPrice: e.coin_price,
						coinReward: e.coin_reward,
						daysOfDripExtension: e.days_of_drip_extension,
						daysOfPremium: e.days_of_premium,
						description: e.description,
						id: e.id,
						isEnabled: e.is_enabled,
						isNew: !!e.is_new,
						name: e.name,
						icon: {
							url: t
						},
						icon32: r,
						icon64: o,
						icon128: a,
						subredditCoinReward: e.subreddit_coin_reward,
						tags: e.tags
					}
				},
				o = e => {
					const {
						top_award: t,
						total_count: n
					} = e;
					return {
						topAward: t && r(t),
						totalCount: n
					}
				}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/isComment.ts"),
				o = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				a = n("./src/reddit/models/Vote/index.ts"),
				c = e => !0 === e ? a.a.upvoted : !1 === e ? a.a.downvoted : a.a.notVoted,
				i = n("./src/reddit/models/Comment/index.ts");
			t.a = (e, t) => {
				const n = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					created: e.created_utc,
					deletedBy: u(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === s.y,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: d(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(r.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: c(e.likes)
				};
				return e.all_awardings && (n.allAwardings = Object(o.a)(e.all_awardings)), e.awarders && (n.awarders = e.awarders), e.associated_award && (n.associatedAwardId = e.associated_award.id, n.associatedAward = Object(o.b)(e.associated_award)), n
			};
			const d = e => "string" == typeof e ? JSON.parse(e) : e,
				u = e => e.author !== s.y ? null : e.body === s.z ? i.a.User : e.body === s.xb ? i.a.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/Media/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/models/Vote/index.ts");
			const i = e => {
					const t = [];
					return e.link_flair_richtext && e.link_flair_richtext.length && t.push({
						richtext: e.link_flair_richtext,
						type: r.f.Richtext,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.link_flair_text && t.push({
						text: e.link_flair_text,
						type: r.f.Text,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.spoiler && t.push({
						text: "spoiler",
						type: r.f.Spoiler
					}), e.over_18 && t.push({
						text: "nsfw",
						type: r.f.Nsfw
					}), t
				},
				d = e => e ? e.map(e => ({
					categoryId: e.category_id,
					categoryName: e.category_name
				})) : [],
				u = e => {
					const t = e.preview && e.preview.enabled;
					let n = !1,
						s = null,
						r = {},
						c = {};
					const i = e.over_18 || e.spoiler;
					if (e.preview && (n = !!(c = e.preview.images[0].variants).mp4, r = e.preview.images[0].source, i && (s = c.obfuscated.source.url)), e.is_self) return Object.assign({
						content: e.selftext_html,
						type: o.n.TEXT,
						markdownContent: e.selftext,
						obfuscated: s,
						rteMode: e.rte_mode || a.h.RICH_TEXT
					}, e.rtjson && {
						richtextContent: e.rtjson,
						type: o.n.RTJSON,
						mediaMetadata: e.media_metadata
					});
					if (e.media && e.media.reddit_video) {
						const t = e.media.reddit_video;
						return {
							hlsUrl: t.hls_url,
							dashUrl: t.dash_url,
							isGif: t.is_gif,
							scrubberThumbSource: t.scrubber_media_url,
							obfuscated: s,
							posterUrl: t.url,
							width: t.width,
							height: t.height,
							type: o.n.VIDEO
						}
					}
					if (e.media && e.media.rpan_video) {
						const t = e.media.rpan_video;
						return {
							hlsUrl: t.hls_url,
							scrubberThumbSource: t.scrubber_media_url,
							type: o.n.LIVEVIDEO
						}
					}
					if (e.secure_media && e.secure_media.oembed) {
						return {
							content: e.secure_media_embed.media_domain_url,
							type: o.n.EMBED,
							width: e.secure_media.oembed.width,
							height: e.secure_media.oembed.height,
							obfuscated: s,
							provider: e.secure_media.oembed.provider_name
						}
					}
					if (t && n) return {
						content: c.mp4.source.url,
						type: o.n.GIFVIDEO,
						width: c.mp4.source.width,
						height: c.mp4.source.height,
						gifBackgroundImage: r.url,
						gifBackgroundResolutions: e.preview.images[0].resolutions,
						obfuscated: s,
						resolutions: c.mp4.resolutions
					};
					if (t) {
						const t = c.gif ? c.gif.resolutions : e.preview.images[0].resolutions;
						return {
							content: r.url,
							type: o.n.IMAGE,
							width: r.width,
							height: r.height,
							obfuscated: s,
							resolutions: t
						}
					}
					return null
				},
				l = e => {
					const t = {};
					if (e.promoted && e.outbound_link || !e.is_self && !e.is_reddit_media_domain) {
						if (t.displayText = e.domain, t.url = e.url, e.outbound_link) {
							const n = e.outbound_link;
							t.outboundUrl = n.url, t.outboundUrlExpiration = n.expiration, t.outboundUrlCreated = n.created
						}
						return t
					}
					return null
				};
			t.a = e => {
				return {
					allAwardings: e.all_awardings ? Object(s.a)(e.all_awardings) : [],
					awarders: e.awarders,
					author: e.author,
					authorId: e.author_fullname,
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					belongsTo: {
						type: "user" === e.subreddit_type ? "profile" : "subreddit",
						id: e.subreddit_id || ""
					},
					callToAction: e.call_to_action || null,
					contestMode: e.contest_mode,
					created: 1e3 * e.created,
					crosspostParentId: e.cross_post_parent_id || null,
					crosspostRootId: e.cross_post_root_id || null,
					discussionType: e.discussion_type || null,
					distinguishType: e.distinguish_type || null,
					domain: e.domain,
					domainOverride: e.domain_override || null,
					events: e.events || [],
					flair: i(e),
					hidden: e.hidden,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isApproved: e.approved,
					isArchived: e.archived,
					isAuthorPremium: e.author_premium,
					isBlank: e.is_blank,
					isCrosspostable: e.is_crosspostable,
					isFollowed: e.is_followed || !1,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMediaOnly: e.media_only,
					isMeta: e.is_meta,
					isNSFW: e.over_18,
					isOriginalContent: e.is_original_content,
					isPinned: e.pinned,
					isRemoved: e.removed,
					isSpam: e.spam,
					isSpoiler: e.spoiler,
					isSponsored: e.promoted,
					isStickied: e.stickied,
					liveCommentsWebsocket: e.liveCommentsWebsocket || e.websocket_url,
					media: u(e),
					modNote: e.mod_note || null,
					modReports: e.mod_reports,
					numComments: e.num_comments,
					numCrossposts: e.num_crossposts || 0,
					numDuplicates: e.num_duplicates,
					numReports: e.num_reports || 0,
					permalink: "https://www.reddit.com".concat(e.permalink),
					postCategories: d(e.post_categories),
					preview: e.preview && e.preview.images && e.preview.images[0] && e.preview.images[0].source ? {
						url: e.preview.images[0].source.url,
						width: e.preview.images[0].source.width,
						height: e.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: e.previous_visits,
					postId: e.name,
					modRemovalReason: e.mod_reason_title,
					modReasonBy: e.mod_reason_by,
					removedBy: e.removed_by,
					removedByCategory: e.removed_by_category,
					saved: e.saved,
					score: e.score,
					treatmentTags: e.treatment_tags,
					isScoreHidden: !!e.hide_score,
					sendReplies: e.send_replies,
					source: l(e),
					suggestedSort: e.suggested_sort,
					thumbnail: {
						url: e.thumbnail,
						width: e.thumbnail_width,
						height: e.thumbnail_height
					},
					title: e.title,
					userReports: e.user_reports,
					upvoteRatio: e.upvote_ratio,
					viewCount: e.view_count || 0,
					voteState: Object(c.d)(e.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				r = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			t.a = (e, t) => {
				const n = Object(s.a)(e),
					{
						wls: o
					} = n,
					a = r(n, ["wls"]);
				return Object.assign({}, a, {
					name: t
				})
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case s.C.NO_STRIPE_SUBSCRIPTION:
							case s.C.USER_DOESNT_EXIST:
							case s.C.USER_REQUIRED_ERROR:
							case s.C.VALIDATION_ERROR:
								return e;
							case s.C.NO_USER:
							case s.C.NO_TEXT:
							case s.C.NO_URL:
								return s.C.VALIDATION_ERROR;
							case s.C.CREDIT_CARD_FAILURE:
							case s.C.CREDIT_CARD_FAILURE_GENERIC:
								return s.C.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return s.C.SUBMIT_VALIDATION_ERROR
						}
					}
					return s.C.VALIDATION_ERROR
				},
				o = e => {
					const t = e.body;
					return {
						type: r(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				a = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? Object.assign({}, e, {
						error: o(e)
					}) : e
				};
			t.a = o
		},
		"./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => ({
				allowContractors: e.allow_contractors,
				communityIcon: e.community_icon,
				displayText: e.display_name_prefixed,
				icon: {
					height: e.icon_size ? e.icon_size[1] : 0,
					url: e.community_icon || e.icon_img || "",
					width: e.icon_size ? e.icon_size[0] : 0
				},
				id: e.name,
				isNSFW: e.over_18 || e.over18,
				isQuarantined: !!e.quarantine,
				name: e.display_name,
				primaryColor: e.primary_color,
				subscribers: e.subscribers,
				title: e.title,
				type: e.subreddit_type,
				url: e.url,
				wls: e.wls
			})
		},
		"./src/reddit/helpers/redesignOptoutCookie/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/js-cookie/src/js.cookie.js"),
				o = n.n(r);
			const a = "redesign_optout";

			function c() {
				const e = new Date;
				return e.setFullYear(e.getFullYear() + 3), e
			}

			function i() {
				o.a.get(a) || o.a.set(a, "true", {
					domain: s.a.cookieDomain,
					expires: c()
				})
			}

			function d() {
				o.a.get(a) && o.a.remove(a, {
					domain: s.a.cookieDomain
				})
			}
		},
		"./src/reddit/helpers/reportPage/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var s = n("./src/reddit/models/RulesSequence/index.ts");
			const r = "(?:old\\.reddit\\.".concat("(?:com|local)", "|new\\.reddit\\.").concat("(?:com|local)", "|reddit\\.").concat("(?:com|local)", "|www\\.reddit\\.").concat("(?:com|local)", ")"),
				o = "(?:".concat("(?:r)", "|").concat("(?:user|u)", ")"),
				a = "(?:https?://)",
				c = "^".concat(a).concat(r, "/").concat(o, "/").concat("(?:[^/]+)", "/comments/").concat("(?:\\w+)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "(?:/.*)?"),
				i = "^".concat(a).concat(r, "/").concat(o, "/").concat("(?:[^/]+)", "/comments/").concat("(\\w+)", "(?:/.*)?"),
				d = "^".concat(a).concat(r, "/message/messages/").concat("(\\w+)", "(?:/.*)?"),
				u = "^".concat(a, "?").concat("(?:mod.reddit.com/mail)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "(?:/)?$"),
				l = "^".concat(a, "?").concat("(?:mod.reddit.com/mail)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "/").concat("(\\w+)", "(?:/)?$"),
				b = "(?:".concat(i, "|").concat(c, "|").concat(d, "|").concat(u, "|").concat(l, ")"),
				p = "(?:(?:".concat(a, "?").concat(r, "/)?").concat("(?:user|u)", "/)?").concat("([\\w-]+)", "(?:/)?"),
				f = "(?:(?:".concat(a, "?").concat(r, "/)?").concat("(?:r)", "/)?").concat("([\\w-]+)", "(?:/)?"),
				m = e => {
					const t = new RegExp(c),
						n = new RegExp(i),
						s = new RegExp(d),
						r = new RegExp(u),
						o = new RegExp(l);
					let a, b, m;
					if (e.thingUrl) {
						const c = e.thingUrl.trim();
						if (t.test(c)) {
							const e = t.exec(c);
							e && e.length > 1 && (a = "t1_" + e[1])
						} else if (n.test(c)) {
							const e = n.exec(c);
							e && e.length > 1 && (a = "t3_" + e[1])
						} else if (s.test(c)) {
							const e = s.exec(c);
							e && e.length > 1 && (a = "t4_" + e[1])
						} else if (o.test(c)) {
							const e = o.exec(c);
							e && e.length > 2 && (b = e[1], m = e[2])
						} else if (r.test(c)) {
							const e = r.exec(c);
							e && e.length > 1 && (b = e[1])
						}
					}
					const O = new RegExp(p),
						g = new RegExp(f),
						_ = [];
					let y;
					if (e.subredditName) {
						const t = e.subredditName.trim();
						if (g.test(t)) {
							const e = g.exec(t);
							e && e.length > 1 && (y = e[1])
						}
					}
					if (e.usernames && e.usernames.length)
						for (let c = 0; c < e.usernames.length; c++) {
							const t = e.usernames[c].trim();
							if (O.test(t)) {
								const e = O.exec(t);
								e && e.length > 1 && _.push(e[1])
							}
						}
					const {
						reason: j
					} = e;
					return {
						reason: "site_reason_selected",
						site_reason: j.reasonText,
						additional_info: e.additionalInfo ? e.additionalInfo.join(",") : void 0,
						custom_text: e.customText,
						modmail_conv_id: b,
						modmail_msg_id: m,
						sr_name: y,
						thing_id: a,
						usernames: _.length ? _.join(",") : void 0
					}
				},
				O = (e, t) => {
					const n = new s.a;
					return g(n, e, t, 0), n
				},
				g = (e, t, n, s) => {
					for (let r = 0; r < t.length; r++) {
						const o = t[r];
						e.update(r, s);
						const a = e.getSequence().length;
						if (o.reasonAsParam === n) return;
						if (o.nextStepReasons && o.nextStepReasons.length && (g(e, o.nextStepReasons, n, s + 1), e.getSequence().length > a)) return;
						e.cut(s - 1)
					}
				}
		},
		"./src/reddit/helpers/routeKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "a", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeCommentsPageKey/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				i = n("./src/lib/makePostCreationPageKey/index.ts"),
				d = n("./src/lib/makeSearchKey/index.ts"),
				u = n("./src/reddit/constants/postLayout.ts"),
				l = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				b = n("./src/reddit/constants/listings.ts"),
				p = n("./src/reddit/constants/page.ts"),
				f = n("./src/reddit/constants/parameters.ts"),
				m = n("./src/reddit/constants/wiki.ts"),
				O = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				g = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				_ = n("./src/reddit/models/Comment/index.ts"),
				y = n("./src/reddit/models/Multireddit/index.ts"),
				j = n("./src/reddit/models/Post/index.ts"),
				h = n("./src/reddit/models/User/index.ts"),
				E = n("./src/reddit/routes/modListing/index.ts"),
				I = n("./src/reddit/selectors/frontpage.ts");
			const v = (e, t, n) => {
					const {
						route: s
					} = e, {
						name: r
					} = s.meta;
					if (!r || !o.L.has(r) && r !== o.yb.COINS && r !== o.yb.COMMENTS && r !== o.yb.POST_CREATION && r !== o.yb.PREMIUM && r !== o.yb.PUBLIC_ACCESS_NETWORK && r !== o.yb.SEARCH_RESULTS && r !== o.yb.EXPLORE && r !== o.yb.SETTINGS && r !== o.yb.SUBREDDIT_WIKI || !n && (r === o.yb.COMMENTS || r === o.yb.DUPLICATES)) return null;
					switch (r) {
						case o.yb.POST_CREATION:
							return Object(i.a)(e.match.params);
						case o.yb.INDEX:
						case o.yb.LISTING:
						case o.yb.SUBREDDIT:
						case o.yb.TOPIC:
							return T(e, t).listingKey;
						case o.yb.PROFILE_COMMENTS:
						case o.yb.PROFILE_POSTS:
						case o.yb.PROFILE_OVERVIEW:
						case o.yb.PROFILE_PRIVATE:
							return D(e, t);
						case o.yb.MULTIREDDIT:
							return C(e, t);
						case o.yb.COMMENTS:
							return A(e, t, n);
						case o.yb.SEARCH_RESULTS:
							return w(e);
						case o.yb.SUBREDDIT_WIKI:
							return P(e);
						case o.yb.COINS:
						case o.yb.PREMIUM:
						case o.yb.PUBLIC_ACCESS_NETWORK:
							return r;
						case o.yb.SETTINGS:
							return R(e);
						default:
							return null
					}
				},
				S = {
					listingKey: null
				},
				T = (e, t) => {
					const {
						route: n,
						match: s
					} = e, {
						name: r
					} = n.meta;
					if (!o.L.has(r) && r !== o.yb.POST_CREATION && r !== o.yb.SUBREDDIT_WIKI) return S;
					const {
						queryParams: a
					} = s;
					switch (r) {
						case o.yb.INDEX:
						case o.yb.LISTING: {
							const e = Object(I.a)(t),
								n = s.params,
								r = n.sort ? n.sort : e;
							return {
								listingKey: Object(c.a)(p.a, r, a),
								sort: r
							}
						}
						case o.yb.PROFILE_COMMENTS:
						case o.yb.PROFILE_POSTS: {
							const {
								profileName: e
							} = s.params, {
								sort: t
							} = a;
							return {
								listingKey: Object(c.a)("u_".concat(e), t, a),
								sort: t
							}
						}
						case o.yb.POST_CREATION:
						case o.yb.SUBREDDIT: {
							const e = s.params,
								{
									subredditName: n
								} = e,
								r = a.f,
								o = Object(g.a)(e, t);
							if (r) {
								const e = {
										[f.o]: r,
										[f.p]: "1"
									},
									t = Object(d.c)(e);
								return {
									listingKey: Object(d.b)(n, void 0, t),
									sort: o
								}
							}
							return {
								listingKey: Object(c.a)(n, o, a),
								sort: o
							}
						}
						case o.yb.TOPIC: {
							const e = s.params,
								t = e.sort || o.N,
								n = e.topicSlug;
							return {
								listingKey: Object(c.a)(b.b.Topic, t, Object.assign({}, e, {
									topicSlug: n
								})),
								sort: t
							}
						}
						case o.yb.MOD_LISTING: {
							const e = s.params,
								{
									sort: t = o.N
								} = e,
								n = Object(E.d)(s.path) ? p.e : p.d;
							return {
								listingKey: Object(c.a)(n, t, a),
								sort: t
							}
						}
						case o.yb.MULTIREDDIT:
							return {
								listingKey: C(e, t)
							};
						case o.yb.SEARCH_RESULTS:
							return {
								listingKey: v(e, t, null)
							};
						default:
							return S
					}
				},
				D = (e, t) => {
					const {
						route: n,
						match: s
					} = e, {
						name: r
					} = n.meta;
					if (!o.L.has(r) && r !== o.yb.POST_CREATION) return null;
					const {
						params: a,
						queryParams: i
					} = s, {
						profileName: d
					} = a, {
						sort: b = o.rb
					} = i;
					switch (r) {
						case o.yb.PROFILE_OVERVIEW:
							const e = (t.user.prefs && t.user.prefs.profileLayout ? t.user.prefs.profileLayout : u.g.Large) === u.g.Compact ? o.hb : o.ib;
							return Object(l.a)((d || "").toLowerCase(), e, b, i);
						case o.yb.PROFILE_COMMENTS:
						case o.yb.PROFILE_POSTS:
							return Object(c.a)("u_".concat(d), b, i);
						case o.yb.PROFILE_PRIVATE:
							const {
								listingType: n
							} = a;
							return Object(l.b)(d.toLowerCase(), n);
						default:
							return null
					}
				},
				C = (e, t) => {
					const {
						route: n,
						match: s
					} = e, {
						name: r
					} = n.meta;
					if (r !== o.yb.MULTIREDDIT) return null;
					const {
						params: a,
						queryParams: i
					} = s, {
						multiredditName: d,
						sort: u = o.M.HOT
					} = a;
					let {
						username: l
					} = a;
					l || (l = t.user.account ? Object(h.e)(t.user.account) : "me");
					const b = Object(y.h)(l, d);
					return Object(c.a)(b, u, i)
				},
				w = e => {
					const {
						route: t,
						match: n
					} = e, {
						name: s
					} = t.meta;
					if (s !== o.yb.SEARCH_RESULTS) return null;
					const {
						subredditName: a
					} = n.params, {
						username: c
					} = n.params, i = Object(d.c)(r()(n.queryParams, f.q));
					return Object(d.b)(a, c, i)
				},
				A = (e, t, n) => {
					const {
						route: s,
						match: r
					} = e, {
						name: c
					} = s.meta;
					if (!c || c !== o.yb.COMMENTS) return null;
					const {
						partialCommentId: i,
						partialPostId: d
					} = r.params, u = Object(j.m)(d), l = i && Object(_.e)(i), {
						hasSortParam: b,
						sortToUse: p
					} = Object(O.a)(t, u);
					return Object(a.a)(u, l, {
						sort: p,
						hasSortParam: b
					})
				},
				R = e => "SettingsPage-" + e.match.params.page,
				P = e => {
					const {
						route: t,
						match: n
					} = e;
					if (t.meta.name !== o.yb.SUBREDDIT_WIKI) return;
					const {
						subredditName: s = m.e,
						wikiPageName: r,
						wikiSubRoute: a
					} = n.params;
					return ["Wiki", s, a, r].join("--")
				}
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "g", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			n("./node_modules/react/index.js");
			const r = function(e) {
				if (void 0 === e) throw new Error("invariant(...): Second argument must be a string.")
			};

			function o(e, t) {
				for (var n = arguments.length, s = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++) s[o - 2] = arguments[o];
				if (r(t), !e) {
					let e;
					if (void 0 === t) e = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
					else {
						let n = 0;
						(e = new Error(t.replace(/%s/g, () => String(s[n++])))).name = "Invariant Violation"
					}
					throw e.framesToPop = 1, e
				}
			}
			const a = {
					AND: "AND",
					NONE: "NONE",
					OR: "OR"
				},
				c = {
					COMMA: "COMMA",
					SEMICOLON: "SEMICOLON"
				};
			var i = function(e, t, n) {
					const r = e.length;
					if (0 === r) return "";
					if (1 === r) return e[0];
					const i = e[r - 1];
					let d = e[0];
					for (let o = 1; o < r - 1; ++o) switch (n) {
						case c.SEMICOLON:
							d = s.fbt._("{previous items}; {following items}", [s.fbt._param("previous items", d), s.fbt._param("following items", e[o])], {
								hk: "4hs4xq"
							});
							break;
						default:
							d = s.fbt._("{previous items}, {following items}", [s.fbt._param("previous items", d), s.fbt._param("following items", e[o])], {
								hk: "2z8RMb"
							})
					}
					return function(e, t, n, r) {
						switch (n) {
							case a.AND:
								return s.fbt._("{list of items} and {last item }", [s.fbt._param("list of items", e), s.fbt._param("last item ", t)], {
									hk: "1ylan1"
								});
							case a.OR:
								return s.fbt._("{list of items} or {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
									hk: "3q8AmB"
								});
							case a.NONE:
								switch (r) {
									case c.SEMICOLON:
										return s.fbt._("{previous item}; {last item}", [s.fbt._param("previous item", e), s.fbt._param("last item", t)], {
											hk: "1h77rJ"
										});
									default:
										return s.fbt._("{list of items}, {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
											hk: "3Q0iaX"
										})
								}
								default:
									o(!1, "Invalid conjunction %s provided to intlList", n)
						}
					}(d, i, t || a.AND, n || c.COMMA)
				},
				d = n("./src/lib/timezone/index.ts"),
				u = n("./src/reddit/helpers/isArrayEqual.ts"),
				l = n("./src/reddit/helpers/ordinal/index.ts"),
				b = n("./src/reddit/models/ScheduledPost/index.ts");
			const p = (e, t) => {
					const n = e.toLocaleDateString(t, {
							month: "numeric",
							day: "numeric"
						}),
						s = e.toLocaleTimeString(t, {
							hour: "numeric",
							minute: "numeric"
						});
					return "".concat(n, " @ ").concat(s.replace(" ", "").toLowerCase())
				},
				f = (e, t, n) => {
					if (e && t) {
						const r = Object(d.f)(O(e, t)),
							o = p(r, n);
						return s.fbt._("Submit post at {time}", [s.fbt._param("time", o)], {
							hk: "IZ3L"
						})
					}
					return s.fbt._("Submit post at scheduled event time", null, {
						hk: "lYsoU"
					})
				},
				m = e => e.slice(0, 5),
				O = (e, t) => "".concat(e, "T").concat(m(t), ":00"),
				g = e => {
					const [t, n] = e.split("T");
					return [t, m(n)]
				},
				_ = (e, t) => {
					const [n, s] = g(e);
					if (n && s) {
						const e = Object(d.f)(O(n, s));
						return p(e, t)
					}
					return ""
				},
				y = e => {
					const t = Object(d.d)(e);
					let n, s = e;
					if (t) {
						n = t.offset;
						const r = Object(d.e)(t.offset),
							o = e.replace("/", " - ").replace(/_/g, " ");
						s = "(GMT".concat(r, ") ").concat(o)
					}
					return {
						name: e,
						displayText: s,
						offset: n
					}
				},
				j = e => "string" == typeof e,
				h = e => {
					const t = new Date,
						n = e - t.getDay();
					return t.setDate(t.getDate() + n), t.toLocaleDateString(void 0, {
						weekday: "long"
					})
				},
				E = e => {
					const t = (e => {
						const [t, n] = g(e);
						if (t && n) {
							return Object(d.f)(O(t, n)).toLocaleTimeString(void 0, {
								hour: "numeric",
								minute: "numeric"
							})
						}
						return ""
					})(e.publishAt);
					if (e.frequency === b.d.Hourly) return 2 === e.interval ? s.fbt._("Every other hour", null, {
						hk: "64vzK"
					}) : e.interval > 1 ? s.fbt._("Every {hour interval} hours", [s.fbt._param("hour interval", e.interval.toString())], {
						hk: "3x8zaD"
					}) : s.fbt._("Every hour", null, {
						hk: "1VzCs"
					});
					if (e.frequency === b.d.Daily) return 2 === e.interval ? s.fbt._("Every other day at {start time}", [s.fbt._param("start time", t)], {
						hk: "yTynp"
					}) : e.interval > 1 ? s.fbt._("Every {day interval} days at {start time}", [s.fbt._param("day interval", e.interval.toString()), s.fbt._param("start time", t)], {
						hk: "2OoGlG"
					}) : s.fbt._("Every day at {start time}", [s.fbt._param("start time", t)], {
						hk: "1cvwm2"
					});
					if (e.frequency === b.d.Weekly) {
						const n = (e => i(e.map(b.j).sort((e, t) => e - t).map(h), a.AND, c.COMMA))(e.byWeekDays);
						return 2 === e.interval ? s.fbt._("Every other week on {days of week } at {start time}", [s.fbt._param("days of week ", n), s.fbt._param("start time", t)], {
							hk: "43xwaa"
						}) : e.interval > 1 ? s.fbt._("Every {interval} weeks on {days of week} at {start time}", [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2IVbH"
						}) : s.fbt._("Every week on {days of week} at {start time}", [s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2Zl0L"
						})
					}
					const n = (e => i(e.sort((e, t) => e - t).map(l.a), a.AND, c.COMMA))(e.byMonthDays);
					return 2 === e.interval ? s.fbt._({
						"*": "Every other month on the {days of month} days at {start time}",
						_1: "Every other month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "okH9o"
					}) : e.interval > 1 ? s.fbt._({
						"*": "Every {interval} months on the {days of month} days at {start time}",
						_1: "Every {interval} months on the {days of month} day at {start time}"
					}, [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "KqN3x"
					}) : s.fbt._({
						"*": "Every month on the {days of month} days at {start time}",
						_1: "Every month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "1jBuYc"
					})
				},
				I = e => {
					let t = null;
					e.frequency && (t = e.frequency), (e.byWeekDays.length > 1 || e.byMonthDays.length > 1 || e.interval > 1) && (t = b.b);
					const n = Object(d.f)(e.publishAt),
						s = Object(b.o)(n.getDay()),
						r = n.getDate();
					return 1 === e.byWeekDays.length && e.byWeekDays[0] !== s && (t = b.b), 1 === e.byMonthDays.length && e.byMonthDays[0] !== r && (t = b.b), {
						recurrenceInfo: e.frequency ? {
							frequency: e.frequency,
							byMonthDays: e.byMonthDays,
							byWeekDays: e.byWeekDays,
							interval: e.interval
						} : null,
						frequencyOption: t,
						submitDate: e.publishAt,
						timezoneName: e.clientTimezone
					}
				},
				v = (e, t) => {
					if (!e && t || e && !t) return !1;
					if (!e && !t) return !0;
					for (const n in e) {
						if (!t) return !1;
						if (e.hasOwnProperty(n)) {
							if (Array.isArray(e[n]) && (!Array.isArray(t[n]) || !Object(u.a)(e[n], t[n]))) return !1;
							if (e[n] !== t[n]) return !1
						}
					}
					return !0
				}
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s);
			const o = e => r()(e).sort((t, n) => {
					const s = e[t.tag.id].tag.text.toLowerCase(),
						r = e[n.tag.id].tag.text.toLowerCase();
					return s < r ? -1 : s > r ? 1 : 0
				}),
				a = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/timeApiRoute/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/telemetry/index.ts");
			async function o(e, t) {
				const n = r.c.start();
				try {
					const o = await t();
					return Object(r.b)(s.k.Redesign, {
						page: e,
						type: "route",
						duration: r.c.end(n)
					}), o
				} finally {
					r.c.cancel(n)
				}
			}
		},
		"./src/reddit/helpers/trackers/authorHovercard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return o
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/reddit/helpers/isComment.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => ({
					comment: t && Object(s.a)(t) ? r.comment(e, t) : null,
					post: t ? r.post(e, t) : null,
					profile: r.profile(e),
					screen: r.screen(e)
				}),
				a = (e, t) => n => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: e
				}, o(n, t)),
				c = e => t => Object.assign({
					source: "user_hovercard",
					action: "view",
					noun: "hover_user_hovercard"
				}, o(t, e)),
				i = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "mute_dialog_in_context"
				}, o(t, e)),
				d = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "ban_dialog_in_context"
				}, o(t, e)),
				u = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "unban_user_in_context"
				}, o(t, e)),
				l = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "change_user_flair_in_context",
					userSubreddit: r.userSubreddit(t)
				}, o(t, e)),
				b = e => t => Object.assign({
					source: r.profile(t) ? "user_profile" : "user_hovercard",
					action: "click",
					noun: "create_chat"
				}, e && o(t, e))
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "k", (function() {
				return g
			}));
			var s = n("./src/reddit/constants/blade.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => n => Object.assign({}, r.defaults(n), {
					source: s.d.Appearance,
					action: "click",
					noun: e,
					actionInfo: r.actionInfo(n, {
						paneName: t
					}),
					subreddit: r.subreddit(n)
				}),
				a = e => o("save_style", e),
				c = e => o("cancel_style", e),
				i = e => t => ({
					source: s.d.Structure,
					action: "click",
					noun: e,
					screen: r.screen(t),
					subreddit: r.subreddit(t)
				}),
				d = e => t => ({
					source: s.d.Appearance,
					action: "click",
					noun: e,
					screen: r.screen(t),
					subreddit: r.subreddit(t)
				}),
				u = (e, t) => n => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: r.actionInfo(n, {
						paneName: s.g[t]
					}),
					screen: r.screen(n),
					subreddit: r.subreddit(n)
				}),
				l = e => t => ({
					source: s.h[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.actionInfo(t, {
						paneName: s.g[e]
					}),
					screen: r.screen(t),
					subreddit: r.subreddit(t)
				}),
				b = e => ({
					screen: r.screen(e),
					subreddit: r.subreddit(e)
				}),
				p = () => e => Object.assign({
					source: s.d.Appearance,
					action: "view",
					noun: "blade"
				}, b(e)),
				f = e => t => Object.assign({
					source: s.a[e],
					action: "click",
					noun: s.b[e]
				}, b(t)),
				m = () => e => Object.assign({
					source: s.d.Appearance,
					action: "click",
					noun: "back"
				}, b(e)),
				O = (e, t) => Object.assign({}, r.defaults(e), (e => t => Object.assign({
					source: s.d.PostFlairManagement,
					action: "click",
					noun: e
				}, b(t)))(t)(e)),
				g = e => t => ({
					source: s.d.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: r.screen(t),
					subreddit: r.subreddit(t),
					userSubreddit: r.userSubreddit(t)
				})
		},
		"./src/reddit/helpers/trackers/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "f", (function() {
				return y
			}));
			var s = n("./src/reddit/constants/chat.ts"),
				r = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/telemetry/models/Event.ts");
			const a = e => ({
					screen: Object(r.screen)(e),
					subreddit: Object(r.subreddit)(e)
				}),
				c = () => e => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "view",
					noun: "chat_rooms",
					chat: Object(r.numberChannels)(e)
				}, a(e)),
				i = e => t => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "click",
					noun: "view_room",
					chat: Object(r.channel)(t, e)
				}, a(t)),
				d = e => t => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "click",
					noun: "join_room",
					chat: Object(r.channel)(t, e)
				}, a(t)),
				u = () => e => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "click",
					noun: "view_all_rooms",
					chat: Object(r.numberChannels)(e)
				}, a(e)),
				l = e => t => Object.assign({
					source: o.b.ChatSidebarModal,
					action: "click",
					noun: "view_room",
					chat: Object(r.channel)(t, e)
				}, a(t)),
				b = e => t => Object.assign({
					source: o.b.ChatSidebarModal,
					action: "click",
					noun: "join_room",
					chat: Object(r.channel)(t, e)
				}, a(t)),
				p = () => e => Object.assign({
					source: o.b.ChatSetup,
					action: "view",
					noun: "create_chat_room"
				}, a(e)),
				f = e => t => {
					const {
						channelSendbirdUrl: n,
						type: r
					} = e;
					return Object.assign({
						source: o.b.ChatSetup,
						action: "submit",
						noun: "create_chat_room",
						chat: {
							id: n,
							type: s.e[r]
						}
					}, a(t))
				},
				m = () => e => Object.assign({
					source: o.b.ChatSetup,
					action: "view",
					noun: "edit_chat_room"
				}, a(e)),
				O = e => t => {
					const {
						channelSendbirdUrl: n,
						type: r
					} = e;
					return Object.assign({
						source: o.b.ChatSetup,
						action: "submit",
						noun: "edit_chat_room",
						chat: {
							id: n,
							type: s.e[r]
						}
					}, a(t))
				},
				g = e => t => {
					const {
						channelSendbirdUrl: n,
						type: r
					} = e;
					return Object.assign({
						source: o.b.ChatSetup,
						action: "submit",
						noun: "delete_chat_room",
						chat: {
							id: n,
							type: s.e[r]
						}
					}, a(t))
				},
				_ = () => e => Object.assign({
					source: o.b.Nav,
					action: "view",
					noun: "orangered_06"
				}, a(e)),
				y = e => t => Object.assign({
					source: "settings_privacy",
					action: "save",
					noun: "receive_chat_invites",
					setting: {
						value: e,
						oldValue: e
					},
					actionInfo: Object(r.actionInfo)(t, {
						settingValue: e
					})
				}, Object(r.defaults)(t))
		},
		"./src/reddit/helpers/trackers/commentList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/telemetry/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => {
				Object(s.a)(Object.assign({
					action: "view",
					source: "commentlist",
					noun: "bottom"
				}, r.defaults(e), {
					listing: r.listing(e, t),
					subreddit: r.subreddit(e)
				}))
			}
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return O
			}));
			var s = n("./src/telemetry/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/models/PostDraft/index.ts"),
				a = n("./src/reddit/selectors/comments.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const d = e => {
					const t = Object(c.n)(e);
					return Object.assign({
						source: "comment_composer",
						action: r.c.CLICK
					}, Object(i.defaults)(e), {
						screen: Object(i.screen)(e),
						subreddit: Object(i.subreddit)(e),
						post: t ? Object(i.post)(e, t) : null,
						profile: Object(i.profile)(e)
					})
				},
				u = (e, t, n, r) => {
					const o = {
							commentId: r,
							commentsPageKey: n
						},
						c = r && Object(a.j)(e, o) || 0;
					return Object(s.a)(Object.assign({
						noun: "comment"
					}, d(e), {
						comment: r ? Object(i.comment)(e, r) : null,
						listing: Object(i.listing)(e, void 0, {
							depth: c
						}),
						commentComposer: {
							editorMode: t
						}
					}))
				},
				l = (e, t, n, r) => {
					const o = d(e);
					return Object(s.a)(Object.assign({}, o, {
						actionInfo: Object.assign({}, o.actionInfo, {
							reason: "karma_rate_limit"
						}),
						source: "backend",
						action: "error",
						noun: "comment",
						comment: {
							bodyText: t,
							parentId: r,
							postId: n
						}
					}))
				},
				b = e => Object(s.a)(Object.assign({
					noun: "cancel"
				}, d(e))),
				p = (e, t) => {
					t === o.c.replyToPost && Object(s.a)(Object.assign({
						noun: "input"
					}, d(e)))
				},
				f = (e, t) => Object(s.a)(Object.assign({
					source: "comment",
					noun: "delete",
					action: "click"
				}, Object(i.defaults)(t), {
					screen: Object(i.screen)(t),
					subreddit: Object(i.subreddit)(t),
					post: Object(i.post)(t, e)
				})),
				m = e => Object(s.a)(Object.assign({
					noun: "edit"
				}, d(e))),
				O = e => Object(s.a)(Object.assign({
					noun: "save_edit"
				}, d(e)))
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return _
			}));
			var s, r = n("./src/reddit/selectors/tags.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(s || (s = {}));
			const c = (e, t, n) => {
					const s = Object(r.A)(e, {
						subredditId: t
					});
					return !!s && s.id === n
				},
				i = (e, t) => Object(r.x)(e, {
					itemId: t
				}).reduce((e, t) => {
					let {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					} = e;
					return n.push(t.tag.id), s.push(t.tag.text), r.push(t.tag.type), {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				d = (e, t, n) => {
					if (!n.id) return {
						content: n.displayText
					};
					const s = Object(r.b)(e)[n.id] || Object(r.d)(e, {
						subredditId: t
					})[n.id];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: c(e, t, s.id)
					} : null
				},
				u = (e, t, n) => {
					if (!n) return null;
					const s = Object(r.b)(e)[n] || Object(r.d)(e, {
						subredditId: t
					})[n];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: c(e, t, s.id)
					} : null
				},
				l = (e, t, n) => Object.assign({}, o.defaults(e), {
					subreddit: Object.assign({}, o.subreddit(e) || {}, {
						id: t
					}, i(e, t)),
					source: n.context,
					action: "click"
				}),
				b = (e, t, n) => {
					Object(a.a)(((e, t, n) => Object.assign({}, l(e, t.subredditId, n), {
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: u(e, t.subredditId, t.tagId)
					}))(e, t, n))
				},
				p = (e, t, n, s) => {
					Object(a.a)(Object.assign({}, l(e, t, s), {
						topicTag: d(e, t, n),
						noun: "add_related_topic"
					}))
				},
				f = (e, t, n, s) => {
					return !Object(r.l)(e, {
						subredditId: t
					}) && n.id ? Object(a.a)(((e, t, n, s) => Object.assign({}, l(e, t, s), {
						topicTag: d(e, t, n),
						noun: "topic_auto_suggest"
					}))(e, t, n, s)) : n.id ? Object(a.a)(((e, t, n, s) => Object.assign({}, l(e, t, s), {
						topicTag: d(e, t, n),
						noun: "topic_auto_complete"
					}))(e, t, n, s)) : Object(a.a)(((e, t, n, s) => Object.assign({}, l(e, t, s), {
						topicTag: d(e, t, n),
						noun: "topic_add_new"
					}))(e, t, n, s))
				},
				m = (e, t, n, s) => Object(a.a)(Object.assign({}, l(e, t, s), {
					topicTag: d(e, t, n),
					noun: "topic_remove"
				})),
				O = (e, t, n) => Object(a.a)(Object.assign({}, l(e, t, n), {
					noun: "topic_tag_field"
				})),
				g = (e, t, n) => Object(a.a)(Object.assign({}, l(e, t, n), {
					noun: n.context === s.communitySettings ? "save" : "save_community_topics"
				})),
				_ = (e, t, n, s) => {
					const r = l(e, t, s);
					Object(a.a)(Object.assign({}, r, {
						action: "view",
						noun: "error",
						actionInfo: Object.assign({}, r.actionInfo, {
							reason: n
						})
					}))
				}
		},
		"./src/reddit/helpers/trackers/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return _
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "G", (function() {
				return I
			})), n.d(t, "H", (function() {
				return v
			})), n.d(t, "A", (function() {
				return S
			})), n.d(t, "B", (function() {
				return T
			})), n.d(t, "C", (function() {
				return D
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "v", (function() {
				return w
			})), n.d(t, "w", (function() {
				return A
			})), n.d(t, "F", (function() {
				return R
			})), n.d(t, "u", (function() {
				return P
			})), n.d(t, "x", (function() {
				return k
			})), n.d(t, "y", (function() {
				return x
			})), n.d(t, "z", (function() {
				return N
			})), n.d(t, "I", (function() {
				return L
			})), n.d(t, "s", (function() {
				return U
			})), n.d(t, "E", (function() {
				return M
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "b", (function() {
				return G
			})), n.d(t, "a", (function() {
				return B
			})), n.d(t, "e", (function() {
				return q
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "r", (function() {
				return W
			})), n.d(t, "l", (function() {
				return Y
			})), n.d(t, "q", (function() {
				return Q
			})), n.d(t, "j", (function() {
				return z
			})), n.d(t, "k", (function() {
				return J
			})), n.d(t, "m", (function() {
				return X
			})), n.d(t, "o", (function() {
				return Z
			})), n.d(t, "p", (function() {
				return $
			})), n.d(t, "n", (function() {
				return ee
			})), n.d(t, "i", (function() {
				return te
			})), n.d(t, "t", (function() {
				return ne
			})), n.d(t, "D", (function() {
				return se
			}));
			var s, r = n("./src/lib/stringInterpolate/index.ts"),
				o = n("./src/reddit/actions/focusedVerticals/constants.ts"),
				a = (n("./src/reddit/constants/categories.tsx"), n("./src/reddit/constants/tracking.ts")),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				d = n("./src/reddit/models/Widgets/index.ts"),
				u = n("./src/reddit/selectors/posts.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				b = n("./src/reddit/selectors/widgets.ts"),
				p = n("./src/telemetry/index.ts");
			! function(e) {
				e.HEADER_SUBREDDIT = "header_subreddit", e.ITEM_POST = "item_post", e.ITEM_POST_SUBREDDIT = "item_post_subreddit", e.ITEM_SUBREDDIT = "item_subreddit", e.ITEM_SUBREDDIT_HIDE = "item_subreddit_hide", e.ITEM_SUBREDDIT_SUBSCRIBE = "item_subreddit_subscribe", e.ITEM_SUBREDDIT_UNSUBSCRIBE = "item_subreddit_unsubscribe"
			}(s || (s = {}));
			const f = "discovery_unit",
				m = (e, t, n) => Object.assign({}, l.defaults(e), {
					source: f,
					screen: l.screen(e),
					discoveryUnit: {
						id: t.id,
						type: t.unitType,
						title: t.title && n ? Object(r.a)(t.title, {
							subredditName: n.name
						}) : t.title,
						name: t.unitName
					}
				}),
				O = (e, t, n) => Object.assign({}, m(e, t, n), {
					source: "global",
					action: "view",
					noun: "discovery_unit"
				}),
				g = (e, t) => Object.assign({}, l.defaults(e), {
					correlationId: Object(c.c)(c.a.SearchResults),
					screen: l.screen(e),
					noun: "search_result_discovery_unit",
					post: t ? l.post(e, t) : null,
					discoveryUnit: {
						name: i.l,
						id: "xd_72",
						type: "listing"
					}
				}),
				_ = (e, t) => {
					Object(p.a)(y(t)(e))
				},
				y = (e, t) => n => O(n, e, t),
				j = (e, t, n, s) => "unitName" in t ? m(e, t, s) : ((e, t, n) => Object.assign({}, l.defaults(e), {
					source: "search",
					screen: l.screen(e),
					search: n ? Object.assign({}, l.search(e, n), {
						structureType: l.StructureType.Trending
					}) : null,
					discoveryUnit: {
						id: t.name,
						type: "listing",
						title: t.layout.title,
						name: t.name
					}
				}))(e, t, n),
				h = (e, t, n, r, o) => Object.assign({}, j(e, t, r, o), {
					action: "view",
					noun: s.ITEM_POST,
					post: l.post(e, n)
				}),
				E = e => {
					let {
						post: t,
						rawQuery: n,
						searchQuery: s
					} = e;
					return {
						displayQuery: decodeURIComponent(s),
						rawQuery: n ? decodeURIComponent(n) : void 0,
						structureType: t && t.isSponsored ? l.StructureType.PromotedTrend : l.StructureType.Trending
					}
				},
				I = (e, t) => {
					const n = t.post ? t.post.id : void 0;
					Object(p.a)(Object.assign({}, g(e, n), {
						metaSearch: E(t),
						source: "search",
						action: "click"
					}))
				},
				v = (e, t) => {
					const n = t.post ? t.post.id : void 0;
					Object(p.a)(Object.assign({}, g(e, n), {
						metaSearch: E(t),
						source: "search",
						action: "view"
					}))
				},
				S = (e, t, n, s) => {
					Object(p.a)(h(e, t, n, s))
				},
				T = (e, t, n, s) => r => h(r, e, t, n, s),
				D = (e, t, n, r) => {
					const o = j(e, t, r);
					Object(p.a)(Object.assign({}, o, Object(b.b)(e, n), {
						action: "view",
						noun: s.ITEM_SUBREDDIT
					}))
				},
				C = (e, t) => {
					Object(p.a)(Object.assign({}, m(e, t), {
						source: f,
						action: a.c.CLICK,
						noun: "show_less_often"
					}))
				},
				w = (e, t, n, s) => {
					Object(p.a)(A(t, n, s)(e))
				},
				A = (e, t, n, r) => o => {
					const c = j(o, e, n, r);
					return Object.assign({}, c, {
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_POST,
						post: l.post(o, t)
					})
				},
				R = () => e => t => ({
					source: "search",
					action: a.c.CLICK,
					noun: s.ITEM_POST,
					post: l.post(t, e),
					search: {
						structureType: l.StructureType.Trending
					}
				}),
				P = (e, t) => n => r => Object.assign({}, e ? m(r, e, t) : {}, {
					source: f,
					action: a.c.CLICK,
					noun: s.ITEM_POST,
					post: l.post(r, n)
				}),
				k = (e, t, n, s) => {
					Object(p.a)(x(t, n, s)(e))
				},
				x = (e, t, n, s) => r => {
					const o = Object(u.c)(r, {
							postId: t
						}),
						c = o ? Object(b.b)(r, o) : void 0,
						i = j(r, e, n, s);
					return Object.assign({}, i, c, {
						source: f,
						action: a.c.CLICK,
						noun: "item_post_subreddit",
						post: l.post(r, t)
					})
				},
				N = (e, t, n) => s => r => {
					const o = Object(u.c)(r, {
							postId: t
						}),
						c = o ? Object(b.b)(r, o) : void 0,
						i = j(r, e, void 0, n);
					return Object.assign({}, i, c, {
						source: f,
						action: a.c.CLICK,
						noun: s ? "item_post_subreddit_unsubscribe" : "item_post_subreddit_subscribe",
						post: l.post(r, t)
					})
				},
				L = (e, t, n) => {
					const s = j(e, t);
					Object(p.a)(Object.assign({}, s, Object(b.b)(e, n), {
						source: "search",
						action: a.c.CLICK,
						noun: "search_result_discovery_unit_subreddit"
					}))
				},
				U = (e, t, n) => {
					const s = j(e, t);
					Object(p.a)(Object.assign({}, s, Object(b.b)(e, n), {
						source: f,
						action: a.c.CLICK,
						noun: "footer_subreddit"
					}))
				},
				M = (e, t) => n => {
					const s = Object(d.j)(t);
					return Object.assign({}, m(n, e, t), Object(b.b)(n, s), {
						source: f,
						action: a.c.CLICK,
						noun: "title_subreddit"
					})
				},
				F = (e, t) => n => Object.assign({}, m(n, e, t), {
					action: "status",
					actionInfo: l.actionInfo(n, {
						success: !0
					}),
					noun: "loading"
				}),
				G = (e, t, n) => s => Object.assign({}, m(s, e, n), {
					action: "status",
					actionInfo: l.actionInfo(s, {
						reason: t,
						success: !1
					}),
					noun: "loading"
				}),
				B = (e, t) => n => Object.assign({}, m(n, e, t), {
					action: "click",
					noun: "close"
				}),
				q = (e, t, n) => s => Object.assign({}, j(s, e, t, n), {
					action: "click",
					noun: "scroll"
				}),
				V = (e, t) => n => Object.assign({}, m(n, e, t), {
					action: "click",
					noun: "overflow_menu"
				}),
				K = () => ({
					id: "xd_focus_verticals",
					unitType: i.f.Listing,
					experiment: "",
					title: o.a,
					unitName: "focused_vertical_suggestion",
					enabled: !1,
					layout: i.d.Large,
					surface: i.e.Frontpage,
					url: "gql.reddit.com"
				}),
				H = (e, t, n) => l.actionInfo(e, {
					position: n
				}),
				W = (e, t, n) => {
					const s = K();
					return e => Object.assign({}, O(e, s), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t)
					})
				},
				Y = (e, t, n) => {
					const s = K();
					return e => Object.assign({}, h(e, s, t), {
						actionInfo: H(e, 0, n)
					})
				},
				Q = (e, t, n) => {
					const r = K();
					return e => Object.assign({}, m(e, r), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t) || null,
						source: f,
						action: a.c.VIEW,
						noun: s.ITEM_SUBREDDIT
					})
				},
				z = (e, t, n) => {
					const r = K();
					return e => Object.assign({}, m(e, r), {
						actionInfo: H(e, 0, n),
						post: l.post(e, t) || null,
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_POST
					})
				},
				J = (e, t, n, r) => {
					const o = K();
					return e => Object.assign({}, m(e, o), {
						actionInfo: H(e, 0, r),
						subreddit: l.subredditById(e, n) || null,
						post: l.post(e, t) || null,
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_POST_SUBREDDIT
					})
				},
				X = (e, t, n) => {
					const r = K();
					return e => Object.assign({}, m(e, r), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t) || null,
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_SUBREDDIT
					})
				},
				Z = (e, t, n, r) => {
					const o = K();
					return e => Object.assign({}, m(e, o), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t) || null,
						post: r ? l.post(e, r) : null,
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_SUBREDDIT_SUBSCRIBE
					})
				},
				$ = (e, t, n, r) => {
					const o = K();
					return e => Object.assign({}, m(e, o), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t) || null,
						post: r ? l.post(e, r) : null,
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_SUBREDDIT_UNSUBSCRIBE
					})
				},
				ee = (e, t, n) => {
					const r = K();
					return e => Object.assign({}, m(e, r), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t) || null,
						source: f,
						action: a.c.CLICK,
						noun: s.ITEM_SUBREDDIT_HIDE
					})
				},
				te = (e, t, n) => {
					const r = K();
					return e => Object.assign({}, m(e, r), {
						actionInfo: H(e, 0, n),
						subreddit: l.subredditById(e, t) || null,
						source: f,
						action: a.c.CLICK,
						noun: s.HEADER_SUBREDDIT
					})
				},
				ne = (e, t) => n => Object.assign({}, m(n, e), t && Object(b.b)(n, t), {
					source: f,
					action: a.c.CLICK,
					noun: "item"
				}),
				se = e => t => Object.assign({}, m(t, e), {
					source: f,
					action: a.c.CLICK,
					noun: "see_all"
				})
		},
		"./src/reddit/helpers/trackers/emailCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					action: s.c.VIEW,
					actionInfo: r.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "email_collection"
				}),
				a = e => t => ({
					source: e,
					action: s.c.CLICK,
					actionInfo: r.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "add_email_collection"
				}),
				c = e => t => ({
					source: e,
					action: "close",
					actionInfo: r.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "email_collection"
				}),
				i = e => Object.assign({}, r.defaults(e), {
					source: "popup",
					action: s.c.CLICK,
					actionInfo: r.actionInfo(e, {
						settingValue: "footer_2"
					}),
					noun: "save_email_collection"
				}),
				d = e => t => Object.assign({}, r.defaults(t), {
					source: "popup",
					action: s.c.CLICK,
					actionInfo: r.actionInfo(t, {
						reason: e ? "1" : "0",
						settingValue: "footer_2"
					}),
					noun: "email_digest_check"
				}),
				u = e => Object.assign({}, r.defaults(e), {
					source: "popup",
					action: s.c.CLICK,
					actionInfo: r.actionInfo(e, {
						settingValue: "footer_2"
					}),
					noun: "email_settings_link"
				})
		},
		"./src/reddit/helpers/trackers/emailVerification.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = "tooltip",
				o = e => t => Object.assign({}, Object(s.defaults)(t), {
					action: "view",
					noun: "verification",
					source: e
				}),
				a = e => t => Object.assign({}, Object(s.defaults)(t), {
					action: "close",
					noun: "verification",
					source: e
				}),
				c = (e, t) => n => Object.assign({}, Object(s.defaults)(n), {
					action: "click",
					noun: "verification_".concat(t),
					source: e
				}),
				i = e => t => Object.assign({}, Object(s.defaults)(t), {
					action: "send",
					noun: "verification_email_".concat(e),
					source: "email"
				}),
				d = e => t => Object.assign({}, Object(s.defaults)(t), {
					action: "click",
					noun: "verification_email_".concat(e),
					source: "email"
				}),
				u = () => e => Object.assign({}, Object(s.defaults)(e), {
					action: "confirm",
					noun: "verification_email",
					source: "email"
				})
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getAwardTypeFromAward", (function() {
				return c
			})), n.d(t, "clickGildEvent", (function() {
				return u
			})), n.d(t, "clickRpanGiveAward", (function() {
				return l
			})), n.d(t, "clickAddAward", (function() {
				return b
			})), n.d(t, "clickHideAward", (function() {
				return p
			})), n.d(t, "clickConfirmHideAward", (function() {
				return f
			})), n.d(t, "clickCancelHideAward", (function() {
				return m
			})), n.d(t, "viewGildModalEvent", (function() {
				return O
			})), n.d(t, "clickSelectAwardEvent", (function() {
				return g
			})), n.d(t, "viewGiveAwardTooltipEvent", (function() {
				return _
			})), n.d(t, "triggerAnonymousEvent", (function() {
				return y
			})), n.d(t, "clickMessageInputEvent", (function() {
				return j
			})), n.d(t, "typeMessageInputEvent", (function() {
				return h
			})), n.d(t, "clickLearnMoreLinkEvent", (function() {
				return E
			})), n.d(t, "clickQuestionMarkEvent", (function() {
				return I
			})), n.d(t, "clickConfirmAwardEvent", (function() {
				return v
			})), n.d(t, "clickGetPremiumEvent", (function() {
				return S
			})), n.d(t, "clickNextButtonEvent", (function() {
				return T
			})), n.d(t, "clickCloseGildModalEvent", (function() {
				return D
			})), n.d(t, "viewSuccessAwardEvent", (function() {
				return C
			})), n.d(t, "viewKarmaSuccessEvent", (function() {
				return w
			}));
			var s = n("./src/reddit/models/Gold/Award.ts"),
				r = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				a = n("./src/reddit/helpers/isComment.ts");
			const c = e => e.awardType === s.f.Global && e.awardSubType === s.d.Appreciation ? "gid_appreciation" : e.awardType === s.f.Global && e.awardSubType === s.d.Premium ? "gid_premium" : e.awardType === s.f.Community ? "gid_community" : e.awardType === s.f.Moderator ? "gid_mod" : e.id,
				i = e => ({
					awardId: e.id,
					awardName: e.name,
					numberCoinsToRecipient: e.coinReward,
					type: c(e)
				}),
				d = (e, t) => Object.assign({}, r.defaults(e), {
					comment: r.comment(e, t),
					correlationId: Object(o.c)(o.a.GildingFlow),
					post: r.post(e, t),
					screen: r.screen(e),
					subreddit: r.subreddit(e),
					userSubreddit: r.userSubreddit(e)
				}),
				u = e => t => Object.assign({}, d(t, e), {
					source: Object(a.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold"
				}),
				l = e => t => Object.assign({}, d(t, e), {
					source: "stream_player",
					action: "click",
					noun: "give_gold"
				}),
				b = e => t => Object.assign({}, d(t, e), {
					source: Object(a.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award"
				}),
				p = (e, t) => n => Object.assign({}, d(n, t), {
					source: Object(a.a)(t) ? "comment" : "post",
					action: "click",
					noun: "hide_award",
					goldPurchase: i(e)
				}),
				f = (e, t) => n => Object.assign({}, d(n, t), {
					source: Object(a.a)(t) ? "comment" : "post",
					action: "click",
					noun: "confirm_hide_award",
					goldPurchase: i(e)
				}),
				m = (e, t) => n => Object.assign({}, d(n, t), {
					source: Object(a.a)(t) ? "comment" : "post",
					action: "click",
					noun: "cancel_hide_award",
					goldPurchase: i(e)
				}),
				O = (e, t, n) => s => Object.assign({}, d(s, n), {
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				g = (e, t) => n => Object.assign({}, d(n, t), {
					source: "give_gold",
					action: "click",
					noun: c(e),
					goldPurchase: i(e)
				}),
				_ = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "view",
					noun: "tooltip"
				}),
				y = (e, t) => n => Object.assign({}, d(n, t), {
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				j = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				h = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				E = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				I = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				v = (e, t) => n => Object.assign({}, d(n, e), {
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: Object.assign({
						contentType: Object(a.a)(e) ? "comment" : "post"
					}, i(t))
				}),
				S = (e, t) => n => Object.assign({}, d(n, e), {
					source: "give_gold",
					action: "click",
					noun: "get_premium",
					goldPurchase: Object.assign({
						contentType: Object(a.a)(e) ? "comment" : "post"
					}, i(t))
				}),
				T = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				D = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				C = (e, t, n) => s => Object.assign({}, d(s, e), {
					source: "give_gold",
					action: "view",
					noun: "success",
					goldPurchase: Object.assign({
						contentType: Object(a.a)(e) ? "comment" : "post",
						numberCoins: t
					}, i(n))
				}),
				w = e => {
					let {
						award: t,
						awardeeKarmaEarned: n,
						awarderKarmaEarned: s,
						numberCoins: r,
						thingId: o
					} = e;
					return e => Object.assign({}, d(e, o), {
						source: "give_gold",
						action: "view",
						noun: "karma_success",
						goldPurchase: Object.assign({
							contentType: Object(a.a)(o) ? "comment" : "post",
							awardeeKarmaEarned: n,
							awarderKarmaEarned: s,
							numberCoins: r
						}, i(t))
					})
				}
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			var s, r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(s || (s = {}));
			const a = e => ({
					subreddit: o.subreddit(e),
					userSubreddit: o.userSubreddit(e)
				}),
				c = e => Object.assign({
					source: "subreddit_tooltip",
					noun: s.SubredditInlineTooltip,
					action: r.c.VIEW
				}, a(e)),
				i = e => Object.assign({
					source: "id_card",
					noun: s.EditSubredditIcon,
					action: r.c.CLICK
				}, a(e)),
				d = e => Object.assign({
					source: "id_card",
					noun: s.EditSubredditDescription,
					action: r.c.CLICK
				}, a(e)),
				u = (e, t) => n => Object.assign({
					source: "id_card",
					noun: s.SaveDescription,
					action: r.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					}
				}, a(n)),
				l = (e, t) => Object.assign({
					source: "id_card",
					noun: s.Error,
					action: r.c.VIEW
				}, a(e), o.defaults(e), {
					actionInfo: o.actionInfo(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/media.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t, n) => o => ({
					source: "videoplayer",
					action: t,
					noun: n,
					experiment: r.experiment(o, s.mc),
					post: r.post(o, e),
					media: r.media(o, e),
					profile: r.profile(o),
					subreddit: r.subreddit(o),
					actionInfo: r.mediaActionInfo(o, e),
					correlationId: r.videoCorrelationId()
				}),
				a = e => t => ({
					source: "videoplayer",
					action: "underrun",
					noun: "playback",
					experiment: r.experiment(t, s.mc),
					post: r.post(t, e),
					profile: r.profile(t),
					subreddit: r.subreddit(t),
					actionInfo: r.mediaActionInfo(t, e),
					media: r.media(t, e)
				}),
				c = (e, t, n) => s => Object.assign({}, o(e, t, n)(s), {
					timer: r.videoPlayerFirstFrameTimer(s, e),
					media: Object.assign({}, r.media(s, e), r.videoPlayerMaxTimeServed(s, e))
				})
		},
		"./src/reddit/helpers/trackers/post.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "d", (function() {
				return y
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Post/index.ts"),
				o = n("./src/telemetry/index.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const c = e => e && e.meta && e.meta.name && e.meta.name === s.yb.DUPLICATES,
				i = (e, t, n) => {
					const {
						currentPage: s
					} = e.platform, r = c(s) ? "other_discussions" : "post";
					return Object(o.a)(Object.assign({
						source: r,
						action: "view",
						noun: "post"
					}, a.defaults(e), {
						actionInfo: a.actionInfo(e, {
							position: n
						}),
						post: a.post(e, t),
						profile: a.profile(e),
						media: a.media(e, t),
						screen: a.screen(e),
						subreddit: a.subreddit(e)
					}))
				},
				d = (e, t) => Object(o.a)(Object.assign({
					source: "post",
					action: "view",
					noun: "ad"
				}, a.defaults(e), {
					post: a.post(e, t),
					media: a.media(e, t),
					screen: a.screen(e),
					subreddit: a.subreddit(e)
				})),
				u = (e, t, n, s) => Object(o.a)(Object.assign({
					source: "post",
					action: "consume",
					noun: "post"
				}, a.defaults(e), {
					actionInfo: a.actionInfo(e, {
						position: s
					}),
					post: a.post(e, t, n),
					media: a.media(e, t),
					screen: a.screen(e),
					subreddit: a.subreddit(e)
				})),
				l = (e, t, n, s) => ({
					noun: s,
					post: a.post(e, t),
					source: n
				}),
				b = (e, t, n, s) => {
					const {
						currentPage: o
					} = e.platform;
					if (c(o)) {
						const n = Object(r.m)(o && o.urlParams.partialPostId || "");
						return {
							noun: "post",
							post: a.post(e, n),
							source: "other_discussions",
							targetPost: a.post(e, t)
						}
					}
					return l(e, t, n, s)
				},
				p = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "post";
					return s => {
						const {
							currentPage: r
						} = s.platform, o = c(r) ? b(s, e, n, t) : l(s, e, n, t);
						return Object.assign({}, o, a.defaults(s), {
							action: "click",
							media: a.media(s, e),
							subreddit: a.subreddit(s) || a.subredditByPostOrCommentId(s, e)
						})
					}
				},
				f = (e, t) => n => Object(o.a)(Object.assign({
					source: "post",
					action: "click",
					noun: t
				}, a.defaults(n), {
					post: a.post(n, e),
					media: a.media(n, e),
					screen: a.screen(n),
					session: a.session(n),
					subreddit: a.subreddit(n)
				})),
				m = (e, t) => ({
					post: a.post(e, t),
					profile: a.profile(e)
				}),
				O = e => t => Object.assign({
					action: "pin",
					noun: "post",
					source: "profile"
				}, m(t, e), a.defaults(t)),
				g = e => t => Object.assign({
					action: "unpin",
					noun: "post",
					source: "profile"
				}, m(t, e), a.defaults(t)),
				_ = (e, t, n) => s => Object.assign({
					action: "click",
					noun: "vote",
					source: "poll"
				}, a.defaults(s), {
					poll: a.poll(s, e, !0, n),
					post: a.post(s, t),
					subreddit: a.subreddit(s),
					userSubreddit: a.userSubreddit(s)
				}),
				y = (e, t) => n => Object.assign({
					action: "view",
					noun: "results",
					source: "poll"
				}, a.defaults(n), {
					poll: a.poll(n, e, !1),
					post: a.post(n, t),
					subreddit: a.subreddit(n),
					userSubreddit: a.userSubreddit(n)
				})
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "u", (function() {
				return y
			})), n.d(t, "t", (function() {
				return j
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "m", (function() {
				return E
			})), n.d(t, "n", (function() {
				return I
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "o", (function() {
				return S
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "r", (function() {
				return D
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "l", (function() {
				return w
			})), n.d(t, "k", (function() {
				return A
			})), n.d(t, "v", (function() {
				return R
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "f", (function() {
				return U
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "s", (function() {
				return F
			})), n.d(t, "g", (function() {
				return G
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/helpers/media/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/models/PostDraft/index.ts"),
				i = n("./src/reddit/selectors/postDraft.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				u = n("./src/reddit/selectors/user.ts"),
				l = n("./src/telemetry/index.ts"),
				b = n("./src/telemetry/models/PostComposer.ts"),
				p = n("./src/telemetry/models/PostDraft.ts");
			const f = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					crosspost: "crosspost"
				},
				m = e => Object.assign({
					source: "post_composer",
					action: s.c.CLICK
				}, d.defaults(e), {
					screen: d.screen(e),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				O = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === a.h.MARKDOWN ? "markdown" : "rte"
				},
				g = e => {
					Object(l.a)(Object.assign({
						noun: "cancel"
					}, m(e)))
				},
				_ = e => {
					Object(l.a)(Object.assign({
						noun: "discard"
					}, m(e)))
				},
				y = e => {
					Object(l.a)(Object.assign({
						noun: "subreddit_choice",
						subreddit: d.subreddit(e)
					}, m(e), {
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				j = e => {
					Object(l.a)(Object.assign({
						noun: "subreddit_selector"
					}, m(e)))
				},
				h = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "post_type_selector",
						postComposer: {
							type: f[t]
						}
					}, m(e)))
				},
				E = () => e => Object.assign({
					noun: "add_option"
				}, m(e)),
				I = () => e => Object.assign({
					noun: "voting_length"
				}, m(e)),
				v = (e, t, n) => {
					"image_upload" === t || "video_upload" === t ? Object(l.a)(Object.assign({
						noun: t
					}, m(e))) : Object(l.a)(Object.assign({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: n ? "on" : "off"
						}
					}, m(e)))
				},
				S = (e, t, n) => {
					Object(l.a)(Object.assign({
						noun: "post",
						subreddit: d.subreddit(e),
						postComposer: Object.assign({
							type: t
						}, O(e, t)),
						post: n ? d.post(e, n) : null
					}, m(e)))
				},
				T = (e, t) => {
					const n = t === a.h.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(l.a)(Object.assign({
						noun: n
					}, m(e)))
				},
				D = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "save",
						subreddit: d.subreddit(e),
						postComposer: Object.assign({
							type: t
						}, O(e, t))
					}, m(e)))
				},
				C = (e, t) => {
					const n = e.uploads[t];
					n.error && Object(l.a)(Object.assign({}, m(e), {
						noun: "media",
						action: s.c.REJECT,
						actionInfo: Object.assign({}, d.actionInfo(e), {
							reason: JSON.stringify(n.error)
						})
					}))
				},
				w = (e, t) => {
					t.forEach(t => {
						const n = Object(o.f)(t.type);
						n && Object(l.a)(Object.assign({}, m(e), {
							action: s.c.DRAG,
							noun: n
						}))
					})
				},
				A = (e, t, n) => {
					Object(l.a)(Object.assign({}, m(e), {
						noun: "input",
						postComposer: {
							inputType: n
						},
						action: t,
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				R = (e, t, n) => {
					Object(l.a)(Object.assign({}, m(e), {
						noun: n,
						action: Object(b.getToggleAction)(t),
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				P = e => {
					Object(l.a)(Object.assign({}, m(e), {
						noun: "hide_oc_description",
						action: s.c.CLICK
					}))
				},
				k = (e, t) => {
					if (t) {
						const n = d.subredditById(e, t);
						if (n) return {
							subreddit: n
						};
						const s = d.profileById(e, t);
						if (s) return {
							profile: s
						}
					}
				},
				x = (e, t) => {
					const {
						draftId: n,
						destSubreddit: s
					} = t, r = Object(u.i)(e), o = Object(i.d)(e, {
						draftId: n
					}), a = {
						authorId: r ? r.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: n || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case c.b.Link:
							a.type = p.DraftType.Link, a.urlLength = t.body.length;
							break;
						case c.b.Markdown:
							a.type = p.DraftType.Self, a.bodyTextLength = t.body.length;
							break;
						case c.b.RichText:
							a.type = p.DraftType.RichText, t.documentStats && (a.bodyTextLength = t.documentStats.textLength, a.numberRteImages = t.documentStats.rteImagesCount, a.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case c.b.Image:
							a.type = p.DraftType.Image;
							break;
						case c.b.Video:
							a.type = p.DraftType.Video
					}
					return Object.assign({
						postDraft: a
					}, k(e, s.id))
				},
				N = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "draft_load"
					}, m(e), x(e, t)))
				},
				L = (e, t) => {
					Object(l.a)(Object.assign({
						noun: t.draftId ? "draft_update" : "draft_create"
					}, m(e), x(e, t)))
				},
				U = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "draft_delete"
					}, m(e), ((e, t) => {
						const n = Object(u.i)(e),
							s = {
								authorId: n ? n.id : void 0,
								createdTimestamp: t.created,
								id: t.id,
								nsfw: t.isNSFW,
								originalContent: t.isOriginalContent,
								spoiler: t.isSpoiler,
								titleLength: t.title.length
							};
						switch (t.kind) {
							case c.b.Link:
								s.type = p.DraftType.Link, s.urlLength = (t.body || "").length;
								break;
							case c.b.Markdown:
								s.type = p.DraftType.Self, s.bodyTextLength = (t.body || "").length;
								break;
							case c.b.RichText:
								s.type = p.DraftType.RichText
						}
						return Object.assign({
							postDraft: s
						}, k(e, t.subredditId))
					})(e, t)))
				},
				M = e => {
					Object(l.a)(Object.assign({}, m(e), {
						noun: "social_connect_link",
						action: s.c.CLICK
					}))
				},
				F = (e, t) => {
					Object(l.a)(Object.assign({}, m(e), {
						noun: "twitter_share_checkbox",
						action: Object(b.getToggleAction)(t)
					}))
				},
				G = (e, t, n) => {
					Object(l.a)(Object.assign({}, m(e), x(e, t), {
						noun: "draft_share",
						action: n ? s.c.ENABLE : s.c.DISABLE
					}))
				}
		},
		"./src/reddit/helpers/trackers/postList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "j", (function() {
				return m
			}));
			var s = n("./src/telemetry/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => Object.assign({}, r.defaults(e), {
					media: r.media(e, t),
					post: r.post(e, t),
					profile: r.profile(e),
					subreddit: r.subreddit(e)
				}),
				a = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "stop",
						noun: "autoplay_initial_load"
					}))
				},
				c = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "complete",
						noun: "autoplay_initial_load"
					}))
				},
				i = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay_initial_load"
					}))
				},
				d = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay_network_load"
					}))
				},
				u = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "consume",
						noun: "autoplay"
					}))
				},
				l = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay"
					}))
				},
				b = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay_buffering"
					}))
				},
				p = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "stop",
						noun: "autoplay"
					}))
				},
				f = (e, t) => {
					Object(s.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "stop",
						noun: "autoplay_buffering"
					}))
				},
				m = (e, t) => {
					Object(s.a)(Object.assign({
						action: "view",
						source: "postlist",
						noun: "bottom"
					}, r.defaults(e), {
						listing: r.listing(e, t),
						subreddit: r.subreddit(e)
					}))
				}
		},
		"./src/reddit/helpers/trackers/profileSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "a", (function() {
				return E
			}));
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/tracking.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/index.ts"),
				i = n("./src/telemetry/models/PostComposer.ts");
			const d = e => Object.assign({
					source: "profile_settings"
				}, Object(a.defaults)(e)),
				u = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
					const n = Object(a.currentProfileModelSelector)(e);
					if (n) return r()(n, ["id", "name", "type", ...t])
				},
				l = e => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "twitter_connect_link",
						action: o.c.CLICK
					}))
				},
				b = e => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "twitter_disconnect_link",
						action: o.c.CLICK
					}))
				},
				p = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "display_twitter_checkbox",
						action: Object(i.getToggleAction)(t)
					}))
				},
				f = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "twitter_account",
						action: o.c.CLICK,
						profile: {
							id: t.id,
							name: t.username
						}
					}))
				},
				m = e => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, ["display_name", "about", "avatar_url", "cover_url", "nsfw", "content_visible", "communities_visible"]),
						action: o.c.VIEW,
						noun: "settings_page"
					}))
				},
				O = {
					profileIcon: "avatar",
					profileBanner: "cover"
				},
				g = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, ["avatar_url", "cover_url"]),
						action: "upload",
						noun: O[t]
					}))
				},
				_ = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, []),
						action: "remove",
						noun: O[t]
					}))
				},
				y = e => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, ["display_name", "about", "nsfw", "content_visible", "communities_visible"]),
						action: "click",
						noun: "save_settings"
					}))
				},
				j = e => t => Object.assign({}, d(t), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "content_visible"
				}),
				h = e => t => Object.assign({}, d(t), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "nsfw"
				}),
				E = e => t => Object.assign({}, d(t), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "active_in_communities"
				})
		},
		"./src/reddit/helpers/trackers/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => t => Object.assign({
					source: e,
					noun: "create_community_button",
					action: "click"
				}, s.defaults(t), {
					actionInfo: s.actionInfo(t, {
						settingValue: t.user.account && t.user.account.isMod ? "existing_mod" : "new_mod"
					})
				}),
				o = (e, t, n) => r => Object.assign({
					source: "community_form",
					noun: "save_community_button",
					action: "click"
				}, s.defaults(r), {
					actionInfo: s.actionInfo(r, {
						settingValue: e
					}),
					subreddit: {
						id: n,
						name: t.name,
						publicDescription: t.publicDescription,
						nsfw: t.over18,
						accessType: t.type,
						topicTagContents: t.allTags,
						topicTagPrimaryId: t.primaryTagId
					}
				}),
				a = () => e => Object.assign({
					source: "community_form",
					noun: "cancel",
					action: "click"
				}, s.defaults(e), {
					actionInfo: s.actionInfo(e)
				}),
				c = e => t => Object.assign({
					source: "community_form",
					noun: "error_message",
					action: "view"
				}, s.defaults(t), {
					actionInfo: s.actionInfo(t, {
						reason: e
					})
				})
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return a
			}));
			var s, r = n("./node_modules/uuid/v4.js"),
				o = n.n(r);
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(s || (s = {}));
			const a = () => o()()
		},
		"./src/reddit/models/Badge/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./src/config.ts");

			function o(e) {
				return "userId" in e
			}

			function a(e) {
				return !(!e.extra || !e.extra.membership) && !!e.extra.membership.included
			}

			function c(e, t, n) {
				const s = n.media[0],
					r = Object.keys(s);
				if (s["0x0"]) return s["0x0"];
				let o = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (r.forEach(n => {
						const r = s[n],
							[a, c] = n.split("x").map(e => parseInt(e));
						(a < o.width && a >= e || c < o.height && c >= t) && (o = {
							height: c,
							width: a,
							url: r
						})
					}), !o.url && r.length) {
					const e = Object.keys(s)[0],
						t = s[e],
						[n, r] = e.split("x").map(e => parseInt(e));
					o = {
						height: r,
						width: n,
						url: t
					}
				}
				return o.url
			}

			function i(e) {
				return e.startsWith("https") ? e : "".concat(r.a.assetPath, "/").concat(e)
			}

			function d(e, t, n) {
				const s = c(e, t, n),
					r = c(2 * e, 2 * t, n);
				return {
					url: i(s),
					url2x: i(r)
				}
			}! function(e) {
				e.First = "p1", e.Second = "p2"
			}(s || (s = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			}));
			var s, r, o = n("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(s || (s = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(r || (r = {}));
			const a = {
					[s.Loyalty]: o.a.First,
					[s.Achievement]: o.a.Second,
					[s.Cosmetic]: void 0
				},
				c = e => e === o.a.First ? s.Loyalty : e === o.a.Second ? s.Achievement : s.Cosmetic
		},
		"./src/reddit/models/Comment/addProfileImgParam.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				profile_img: !0
			})
		},
		"./src/reddit/models/DiscoveryUnit/index.ts": function(e, t, n) {
			"use strict";
			var s, r, o, a;
			n.d(t, "f", (function() {
					return s
				})), n.d(t, "e", (function() {
					return r
				})), n.d(t, "d", (function() {
					return o
				})), n.d(t, "c", (function() {
					return c
				})), n.d(t, "g", (function() {
					return i
				})), n.d(t, "h", (function() {
					return d
				})), n.d(t, "l", (function() {
					return u
				})), n.d(t, "a", (function() {
					return l
				})), n.d(t, "b", (function() {
					return b
				})), n.d(t, "j", (function() {
					return p
				})), n.d(t, "k", (function() {
					return f
				})), n.d(t, "i", (function() {
					return m
				})),
				function(e) {
					e.Community = "community", e.CommunityCategory = "community_category", e.FavoriteSubreddits = "favorite_subreddits", e.Listing = "listing", e.RecentlyVisitedSubreddits = "recently_visited_subreddits", e.SubredditListing = "subreddit_listing"
				}(s || (s = {})),
				function(e) {
					e.Comments = "comments", e.Communities = "communities", e.Explore = "explore", e.Frontpage = "front_page", e.Popular = "popular", e.SubredditListing = "subreddit_listing", e.Topic = "topic"
				}(r || (r = {})),
				function(e) {
					e.Large = "large", e.Small = "small"
				}(o || (o = {})),
				function(e) {
					e.Wide = "wide", e.Description = "description", e.ActionButton = "action_button", e.SeeMore = "see_more", e.HideItems = "hide_items", e.HideUnit = "hide_unit", e.ShowLess = "show_less", e.PostShowSubredditHeader = "post_show_subreddit_header", e.UnitShowSubredditHeader = "unit_show_subreddit_header", e.PreviewMode = "preview_mode"
				}(a || (a = {}));
			const c = "community_banner_posts",
				i = "search_posts",
				d = "search_subreddits",
				u = "trending_on_popular",
				l = "best_of_community",
				b = "chaining_similar_subreddits_posts",
				p = "top_week_posts",
				f = "top_week_posts_large",
				m = "top_topic_communities_rails"
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");

			function s(e, t) {
				return "".concat(e, "-sort[").concat(t.sort, "]-crossposts_only[").concat(t.crossposts_only, "]")
			}
		},
		"./src/reddit/models/Emoji/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			}));
			const s = 24,
				r = 64e3,
				o = 128,
				a = 128,
				c = (e, t, n, s) => Object.assign({
					name: e,
					url: t,
					subredditId: n
				}, s)
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Twitter = "twitter"
				}(s || (s = {}))
		},
		"./src/reddit/models/Gold/Award.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/config.ts"),
				r = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const o = "https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/what-karma";
			var a, c, i;
			! function(e) {
				e.Global = "GLOBAL", e.Moderator = "MODERATOR", e.Community = "COMMUNITY"
			}(a || (a = {})),
			function(e) {
				e.Global = "GLOBAL", e.Moderator = "MODERATOR", e.Community = "COMMUNITY", e.Appreciation = "APPRECIATION", e.Premium = "PREMIUM"
			}(c || (c = {})),
			function(e) {
				e.png = "PNG", e.apng = "APNG", e.jpg = "JPG", e.gif = "GIF"
			}(i || (i = {}));
			const d = "award_deleted",
				u = {
					awardType: a.Global,
					awardSubType: c.Global,
					coinPrice: 100,
					coinReward: 0,
					description: "",
					daysOfDripExtension: 0,
					icon: {
						url: "".concat(s.a.assetPath, "/img/gold/badges/award-silver-medium.png?v=2")
					},
					id: "gid_1",
					isEnabled: !0,
					isNew: !1,
					name: "Silver",
					daysOfPremium: 0
				},
				l = {
					awardType: a.Global,
					awardSubType: c.Global,
					coinPrice: 500,
					coinReward: 100,
					description: "",
					daysOfDripExtension: 0,
					icon: {
						url: "".concat(s.a.assetPath, "/img/gold/badges/award-gold-medium.png?v=2")
					},
					id: "gid_2",
					isEnabled: !0,
					isNew: !1,
					name: "Gold",
					daysOfPremium: 7
				},
				b = {
					awardType: a.Global,
					awardSubType: c.Global,
					coinPrice: 1800,
					coinReward: 0,
					description: "",
					daysOfDripExtension: 31,
					icon: {
						url: "".concat(s.a.assetPath, "/img/gold/badges/award-platinum-medium.png?v=2")
					},
					id: "gid_3",
					isEnabled: !0,
					isNew: !1,
					name: "Platinum",
					daysOfPremium: 31
				};
			var p;
			! function(e) {
				e.Silver = "silver", e.Gold = "gold", e.Platinum = "platinum"
			}(p || (p = {}));
			const f = [u, l, b];
			f.reduce((e, t) => (e[t.id] = t, e), {});
			var m, O;
			! function(e) {
				e.Global = "global", e.Community = "community", e.Moderator = "moderator"
			}(m || (m = {})),
			function(e) {
				e.Global = "global", e.Community = "community", e.Moderator = "moderator", e.Appreciation = "appreciation", e.Premium = "premium"
			}(O || (O = {}));
			const g = {
					500: 8,
					1e3: 4,
					2e3: 1,
					5e3: 1,
					1e4: 1,
					4e4: 1
				},
				_ = e => {
					const t = e.reduce((e, t) => t.awardType !== a.Community ? e : (e[t.coinPrice] = (e[t.coinPrice] || 0) + 1, e), {}),
						n = e.map(e => ({
							price: e.coinPrice,
							filled: !0,
							award: e
						}));
					return Object.keys(g).forEach(e => {
						const s = t[e] || 0,
							r = Math.max(g[e] - s, 0);
						r > 0 && n.push({
							filled: !1,
							price: parseInt(e),
							quantity: r
						})
					}), n
				},
				y = e => {
					const t = e.reduce((e, t) => t.awardType !== a.Community ? e : (e[t.coinPrice] = (e[t.coinPrice] || 0) + 1, e), {});
					return Object.keys(g).reduce((e, n) => {
						const s = t[n] || 0;
						return g[n] - s > 0 ? [...e, parseInt(n)] : e
					}, [])
				};

			function j(e) {
				return e.sort((e, t) => e.awardType === a.Moderator && t.awardType !== a.Moderator ? -1 : t.awardType === a.Moderator && e.awardType !== a.Moderator ? 1 : t.coinPrice - e.coinPrice)
			}

			function h(e) {
				const {
					count: t,
					iconUrl: n,
					resizedIcons: s
				} = e, o = r(e, ["count", "iconUrl", "resizedIcons"]);
				let a, c, i;
				for (const {
						url: r,
						width: d
					} of s || []) 32 === d && (a = {
					url: r
				}), 64 === d && (c = {
					url: r
				}), 128 === d && (i = {
					url: r
				});
				return Object.assign({}, o, {
					icon: {
						url: n
					},
					icon32: a,
					icon64: c,
					icon128: i,
					awardType: o.awardType.toUpperCase(),
					awardSubType: o.awardSubType.toUpperCase()
				})
			}

			function E(e, t) {
				const {
					awardType: n,
					awardSubType: s,
					icon: o,
					icon32: a,
					icon64: c,
					icon128: i
				} = e, d = r(e, ["awardType", "awardSubType", "icon", "icon32", "icon64", "icon128"]), u = [];
				return a && u.push({
					height: 32,
					url: a.url,
					width: 32
				}), c && u.push({
					height: 64,
					url: c.url,
					width: 64
				}), i && u.push({
					height: 128,
					url: i.url,
					width: 128
				}), Object.assign({
					awardType: n.toLowerCase(),
					awardSubType: s ? s.toLowerCase() : O.Global,
					count: t,
					iconUrl: o.url,
					resizedIcons: u
				}, d)
			}
		},
		"./src/reddit/models/Gold/Coins/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = (e, t, n) => {
					let s = null;
					for (const r of t) {
						const t = s ? s.coins : 1 / 0,
							o = r.coins;
						if (o >= e && o < t) {
							if (n && r.coins < 1200) continue;
							s = r
						}
					}
					return s
				},
				o = new Set(["low_coin_upsell"]),
				a = new Set(["new_purchaser", "repeat_purchaser"]),
				c = [{
					prompt: () => s.fbt._("What are Coins?", null, {
						hk: "1wU35D"
					}),
					answer: () => s.fbt._("Coins are our virtual good, and you can use them to award exceptional posts or comments, giving them Silver, Gold, or Platinum. We'll be adding cool new ways to spend your Coins in the future.", null, {
						hk: "4Wf9n"
					})
				}, {
					prompt: () => s.fbt._('What is "Give Award"?', null, {
						hk: "Q08fJ"
					}),
					answer: () => s.fbt._('Giving an Award, or "gilding", is a way to show appreciation for an exceptional contribution to Reddit. You can award someone by clicking on "Give Award" below their post or comment. This distinguishes it with an Award for all to see, and some even grant the honoree special bonus benefits.', null, {
						hk: "4fZWQ3"
					})
				}, {
					prompt: () => s.fbt._("What are these new Award types?", null, {
						hk: "2ysK1l"
					}),
					answer: () => s.fbt._("There are now several ways to Give Awards. A Silver Award requires 100 Coins, which simply marks a post or comment with a Silver Award icon. A classic Gold Award requires 500 Coins and gives the recipient a week of Reddit Premium membership and 100 Coins. Finally, the ultra rare Platinum Award costs 1800 Coins, and gives the recipient with one month of Reddit Premium membership, which includes 700 Coins for that month.", null, {
						hk: "sPegC"
					})
				}, {
					prompt: () => s.fbt._("I bought Coins, how can I tell how many I have?", null, {
						hk: "VVChk"
					}),
					answer: () => s.fbt._("If you buy Coins you will always have a balance associated with your Reddit account. You can view your balance on the top navigation bar by your username.", null, {
						hk: "1ZHMGy"
					})
				}, {
					prompt: () => s.fbt._("Can I transfer Coins between Reddit accounts?", null, {
						hk: "1VS4Gc"
					}),
					answer: () => s.fbt._("You cannot transfer your Reddit Coin balance across usernames, sorry. You can offer a Gold Award to other users which will grant them 100 Coins.", null, {
						hk: "46q9mb"
					})
				}, {
					prompt: () => s.fbt._("Can I get Coins for free?", null, {
						hk: "2Qzs1G"
					}),
					answer: () => s.fbt._("We may give away Coins on special occasions. Stay tuned!", null, {
						hk: "30yIpE"
					})
				}, {
					prompt: () => s.fbt._("What happened to Creddits? Do those still exist?", null, {
						hk: "qTu5W"
					}),
					answer: () => s.fbt._("Yes, Creddits are simply called \"Coins\" now, and we've converted any existing balance at a generous exchange rate of one Creddit to 2000 Coins. That's double their original monetary value as a thank you for supporting us early. Use them to award exceptional posts and comments you come across. Thanks again for your contribution to the Reddit community.", null, {
						hk: "3ZI3ct"
					})
				}, {
					prompt: () => s.fbt._("I thought Gold was the name of Reddit's subscription membership?", null, {
						hk: "26YDse"
					}),
					answer: () => s.fbt._('You\'re correct, it used to also be the name of the subscription membership. However, many people confused the subscription "Reddit Gold" membership with a virtual good or coin. To make things easier to understand, we\'ve renamed the membership to "Reddit Premium", while our virtual good is called "Coins".', null, {
						hk: "FjaSU"
					})
				}]
		},
		"./src/reddit/models/ModQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/isPost.ts"),
				r = n("./src/reddit/models/Flair/index.ts");
			const o = 1;
			var a;
			! function(e) {
				e.Approve = "approve", e.Flair = "flair", e.IgnoreReports = "ignore_reports", e.Lock = "lock", e.MarkNSFW = "mark_nsfw", e.RemovalReason = "removal_reason", e.Remove = "remove", e.Spam = "spam", e.Spoiler = "spoiler", e.UnignoreReports = "unignore_reports", e.Unlock = "unlock", e.UnmarkNSFW = "unmark_nsfw", e.Unspoiler = "unspoiler"
			}(a || (a = {}));
			const c = {},
				i = {
					ignore_reports: a.UnignoreReports,
					lock: a.Unlock,
					mark_nsfw: a.UnmarkNSFW,
					remove: a.Approve,
					spam: a.Approve,
					spoiler: a.Unspoiler,
					unignore_reports: a.IgnoreReports,
					unlock: a.Lock,
					unmark_nsfw: a.MarkNSFW,
					unspoiler: a.Spoiler
				},
				d = (e, t, n, o, i) => {
					switch (t) {
						case "approve": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									approvedBy: o,
									isApproved: !0,
									isRemoved: !1,
									isSpam: !1,
									bannedBy: null,
									modNote: null,
									modReasonBy: null,
									modRemovalReason: null,
									numReports: 0
								}
							}), e
						}
						case "flair": {
							const t = {};
							return n.forEach(n => {
								if (Object(s.a)(n)) {
									const s = e[n].flair.filter(e => e.type === r.f.Nsfw || e.type === r.f.Spoiler);
									i && i.flair && s.push(i.flair), t[n] = {
										flair: s
									}
								}
							}), t
						}
						case "ignore_reports": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									ignoreReports: !0
								}
							}), e
						}
						case "lock": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									isLocked: !0
								}
							}), e
						}
						case "mark_nsfw": {
							const t = {},
								o = {
									text: "nsfw",
									type: r.f.Nsfw
								};
							return n.forEach(n => {
								if (Object(s.a)(n)) {
									const s = e[n],
										r = s.isNSFW ? s.flair : s.flair ? [...s.flair, o] : {
											[n]: o
										};
									t[n] = {
										isNSFW: !0,
										flair: r
									}
								}
							}), t
						}
						case "remove": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									approvedBy: null,
									isApproved: !1,
									isRemoved: !0,
									isSpam: !1,
									bannedBy: o
								}
							}), e
						}
						case "spam": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									approvedBy: null,
									isApproved: !1,
									isRemoved: !1,
									isSpam: !0,
									bannedBy: o
								}
							}), e
						}
						case "spoiler": {
							const t = {},
								o = {
									text: "spoiler",
									type: r.f.Spoiler
								};
							return n.forEach(n => {
								if (Object(s.a)(n)) {
									const s = e[n],
										r = s.isSpoiler ? s.flair : s.flair ? [...s.flair, o] : {
											[n]: o
										};
									t[n] = {
										isSpoiler: !0,
										flair: r
									}
								}
							}), t
						}
						case "unignore_reports": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									ignoreReports: !1
								}
							}), e
						}
						case "unlock": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									isLocked: !1
								}
							}), e
						}
						case "unmark_nsfw": {
							const t = {};
							return n.forEach(n => {
								if (Object(s.a)(n)) {
									const s = e[n],
										o = s.flair ? s.flair.filter(e => e.type !== r.f.Nsfw) : null;
									t[n] = {
										isNSFW: !1,
										flair: o
									}
								}
							}), t
						}
						case "unspoiler": {
							const t = {};
							return n.forEach(n => {
								if (Object(s.a)(n)) {
									const s = e[n],
										o = s.flair ? s.flair.filter(e => e.type !== r.f.Spoiler) : null;
									t[n] = {
										isSpoiler: !1,
										flair: o
									}
								}
							}), t
						}
						case a.RemovalReason: {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									modNote: i && i.modNote,
									modReasonBy: o,
									modRemovalReason: i && i.removalReason
								}
							}), e
						}
						default:
							return c
					}
				}
		},
		"./src/reddit/models/Option/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const s = e => !e.id,
				r = e => !!e.id,
				o = (e, t) => s(e) && s(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!r(e) || !r(t)) && e.id === t.id
		},
		"./src/reddit/models/Poll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var s, r, o = n("./node_modules/bignumber.js/bignumber.js");
			! function(e) {
				e.GovGeneric = "governance:generic", e.ReplaceTopMod = "governance:replace-top-mod", e.Spinoff = "governance:spin-off", e.GA = "ga"
			}(s || (s = {})),
			function(e) {
				e.ByVoters = "byVoters", e.ByVotingPower = "byVotingPower"
			}(r || (r = {}));
			const a = {
				[s.ReplaceTopMod]: () => [{
					text: "Yes"
				}, {
					text: "No"
				}],
				[s.Spinoff]: e => [{
					text: e ? "Yes, I'd like to join r/".concat(e) : "Yes, I'd like to join the new community"
				}, {
					text: "No"
				}]
			};

			function c(e, t) {
				return !!e.options.filter(e => t.options[e.id].userSelected).length
			}

			function i(e, t) {
				return new Date(e.endsAt).getTime() < Date.now() || c(e, t)
			}

			function d(e, t) {
				let n = e.options[0],
					s = new o.BigNumber(t.options[n.id].votes);
				for (const r of e.options) {
					const e = new o.BigNumber(t.options[r.id].votes);
					e.isGreaterThan(s) && (n = r, s = e)
				}
				return n
			}

			function u(e) {
				switch (e.type) {
					case s.GovGeneric:
					case s.ReplaceTopMod:
					case s.Spinoff:
						return !0;
					default:
						return !1
				}
			}
		},
		"./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				emotes_as_images: !0
			})
		},
		"./src/reddit/models/RichTextJson/addRTJParam.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				rtj: "only"
			})
		},
		"./src/reddit/models/Rule/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "h", (function() {
				return l
			}));
			const s = {
					all: "all",
					post: "post",
					comment: "comment"
				},
				r = {
					all: "all",
					link: "post",
					comment: "comment"
				},
				o = {
					LINK_AND_COMMENT: "all",
					LINK: "post",
					COMMENT: "comment"
				},
				a = 15,
				c = 100,
				i = 100,
				d = 500,
				u = 2e3,
				l = e => ({
					rules: e.map(e => ({
						kind: r[e.kind],
						description: e.description,
						descriptionHtml: e.description_html,
						shortName: e.short_name,
						violationReason: e.violation_reason,
						createdUtc: e.created_utc,
						priority: e.priority
					}))
				})
		},
		"./src/reddit/models/RulesSequence/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			class s {
				constructor() {
					this.sequence = []
				}
				getSequence() {
					return this.sequence
				}
				update(e, t) {
					const n = this.sequence.slice(0, t);
					n.push(e), this.sequence = n
				}
				cut(e) {
					const t = this.sequence.slice(0, e + 1);
					this.sequence = t
				}
			}
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "p", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "o", (function() {
				return O
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "n", (function() {
				return v
			}));
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/reddit/models/GqlTopLevelField.ts"),
				o = n("./src/reddit/models/User/index.ts");
			const a = "scheduledposts";
			var c, i, d;
			! function(e) {
				e.LINK = "LINK", e.SELF = "SELF"
			}(c || (c = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(i || (i = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(d || (d = {}));
			const u = e => e.__typename === o.c.AvailableRedditor,
				l = e => e.__typename === r.a.Subreddit;
			var b, p, f, m;
			! function(e) {
				e.standalonePosts = "standalonePosts", e.recurringPosts = "recurringPosts"
			}(b || (b = {})),
			function(e) {
				e.MONDAY = "MONDAY", e.TUESDAY = "TUESDAY", e.WEDNESDAY = "WEDNESDAY", e.THURSDAY = "THURSDAY", e.FRIDAY = "FRIDAY", e.SATURDAY = "SATURDAY", e.SUNDAY = "SUNDAY"
			}(p || (p = {})),
			function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(f || (f = {})),
			function(e) {
				e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY"
			}(m || (m = {}));
			const O = e => p[m[e]],
				g = e => m[p[e]],
				_ = e => f[p[e]],
				y = e => p[f[e]],
				j = e => m[f[e]];
			var h;
			! function(e) {
				e.Hourly = "HOURLY", e.Daily = "DAILY", e.Weekly = "WEEKLY", e.Monthly = "MONTHLY"
			}(h || (h = {}));
			const E = "custom",
				I = e => {
					switch (e) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						default:
							return Object(s.a)(e)
					}
				},
				v = e => "frequency" in e && !!e.frequency
		},
		"./src/reddit/models/SearchDiscoveryUnit/index.ts": function(e, t, n) {
			"use strict";
			var s, r, o;
			n.d(t, "c", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})), n.d(t, "b", (function() {
					return o
				})),
				function(e) {
					e.Default = "DEFAULT", e.Trending = "TRENDING"
				}(s || (s = {})),
				function(e) {
					e.Communities = "COMMUNITIES", e.Posts = "POSTS", e.Queries = "QUERIES"
				}(r || (r = {})),
				function(e) {
					e.Carousel = "CAROUSEL", e.Hero = "HERO", e.Row = "ROW", e.Widget = "WIDGET", e.PromotedTrendHero = "PROMOTED_TREND_HERO"
				}(o || (o = {}))
		},
		"./src/reddit/models/SubredditChannel/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			}));
			var s, r, o = n("./src/chat/models/Channel/utils/removeSendbirdPrefix.ts");
			! function(e) {
				e.Public = "public", e.Private = "private"
			}(s || (s = {})),
			function(e) {
				e.Joined = "joined", e.Invited = "invited", e.Unsorted = "none"
			}(r || (r = {}));
			const a = {
					channelId: "",
					channelSendbirdUrl: "",
					subredditId: "",
					name: "",
					description: "",
					membersCount: 0,
					type: s.Public,
					channelState: r.Unsorted,
					minimumAcctAge: 0,
					newMemberAge: 0,
					isModQueue: !1
				},
				c = e => {
					const t = {};
					return e.length && e.forEach(e => {
						const n = (e => ({
							channelId: Object(o.a)(e.url),
							channelSendbirdUrl: e.url,
							channelState: e.member_state,
							subredditId: e.subreddit.id,
							isModQueue: e.is_modqueue,
							name: e.name,
							type: e.type,
							description: e.description,
							membersCount: e.member_count,
							minimumAcctAge: e.automute_account_age_threshold || 0,
							newMemberAge: e.automute_on_join_duration || 0
						}))(e);
						t[n.channelId] = n
					}), t
				},
				i = e => ({
					channelId: Object(o.a)(e.channel_url),
					channelSendbirdUrl: e.channel_url,
					channelState: r.Joined,
					subredditId: e.subreddit_id,
					isModQueue: !1,
					name: e.room,
					type: e.roomType,
					description: e.description,
					membersCount: 1,
					minimumAcctAge: e.automute_account_age_threshold,
					newMemberAge: e.automute_on_join_duration
				})
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			}));
			const s = 25,
				r = 64;
			var o;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(o || (o = {}));
			const a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: e.id,
						displayText: e.text,
						selected: t
					}
				},
				c = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return a(e.tag, t)
				};
			var i;
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(i || (i = {}))
		},
		"./src/reddit/models/Toast/index.ts": function(e, t, n) {
			"use strict";
			var s, r, o;
			n.d(t, "b", (function() {
					return r
				})), n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.AuthError = "auth-error"
				}(s || (s = {})),
				function(e) {
					e[e.SuccessAward = 0] = "SuccessAward", e[e.SuccessCommunity = 1] = "SuccessCommunity", e[e.SuccessCommunityGreen = 2] = "SuccessCommunityGreen", e[e.SuccessMod = 3] = "SuccessMod", e[e.Error = 4] = "Error", e[e.Undo = 5] = "Undo", e[e.EuCookiePolicy = 6] = "EuCookiePolicy", e[e.UappBanner = 7] = "UappBanner", e[e.AuthError = 8] = "AuthError", e[e.Custom = 9] = "Custom", e[e.Modal = 10] = "Modal"
				}(r || (r = {})),
				function(e) {
					e[e.subscribeMilestone = 0] = "subscribeMilestone", e[e.subscribeCap = 1] = "subscribeCap", e[e.voteMilestone = 2] = "voteMilestone"
				}(o || (o = {}))
		},
		"./src/reddit/models/Vote/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})), n.d(t, "d", (function() {
					return o
				})), n.d(t, "c", (function() {
					return a
				})), n.d(t, "e", (function() {
					return c
				})),
				function(e) {
					e[e.downvoted = -1] = "downvoted", e[e.notVoted = 0] = "notVoted", e[e.upvoted = 1] = "upvoted"
				}(s || (s = {}));
			const r = (e, t) => e.voteState === t ? s.notVoted : t,
				o = e => {
					switch (e) {
						case !0:
							return s.upvoted;
						case !1:
							return s.downvoted;
						default:
							return s.notVoted
					}
				},
				a = (e, t) => {
					const n = e.voteState === t,
						s = n ? 0 : t,
						r = n ? e.score - t : e.score - e.voteState + t;
					return Object.assign({}, e, {
						voteState: s,
						score: r
					})
				},
				c = e => "UP" === e ? s.upvoted : "DOWN" === e ? s.downvoted : s.notVoted
		},
		"./src/reddit/models/WhitelistAndBlocked.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.pending = "pending", e.error = "error", e.waitingForRequest = "waitingForRequest"
				}(s || (s = {}))
		},
		"./src/reddit/reducers/comments/visitHighlightingFilter/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s, r = n("./src/reddit/actions/comment/index.ts"),
				o = n("./src/reddit/actions/platform.ts");
			! function(e) {
				e.First = "First", e.Last = "Last", e.None = "None"
			}(s || (s = {}));
			const a = s.Last;
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.a:
						return a;
					case r.a:
						return t.payload.sort;
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s, r = n("./src/reddit/actions/economics/paymentSystems/constants.ts"),
				o = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(s || (s = {}));
			const a = {
				status: s.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						if (e.status === s.Fetched && e.data.stripe && e.data.stripe.sources) {
							const n = t.payload.cardId,
								s = e.data.stripe.sources,
								r = n,
								a = (s[r], o(s, ["symbol" == typeof r ? r : r + ""]));
							return Object.assign({}, e, {
								data: Object.assign({}, e.data, {
									stripe: Object.assign({}, e.data.stripe, {
										sources: a
									})
								})
							})
						}
						return e;
					case r.e:
						if (e.status === s.Fetched && e.data.braintree && e.data.braintree.sources) {
							const n = t.payload.sourceId,
								s = e.data.braintree.sources,
								r = n,
								a = (s[r], o(s, ["symbol" == typeof r ? r : r + ""]));
							return Object.assign({}, e, {
								data: Object.assign({}, e.data, {
									braintree: Object.assign({}, e.data.braintree, {
										sources: a
									})
								})
							})
						}
						return e;
					case r.b:
						return {
							error: t.payload.error, status: s.Failure
						};
					case r.c:
						return {
							data: t.payload, status: s.Fetched
						};
					case r.d:
						return {
							status: s.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./src/lib/constants/specialMembership.ts"),
				o = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				a = n("./src/reddit/helpers/economics/sortBadges.ts"),
				c = n("./src/reddit/models/Badge/index.ts"),
				i = n("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(s || (s = {}));
			const d = {};

			function u(e) {
				return "userId" in e
			}

			function l(e, t, n, s) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(r => {
						let o;
						(o = e.placement ? e.placement === c.a.First ? s[i.a.Loyalty][r] : s[i.a.Achievement][r] : u(e) ? s[i.a.Cosmetic][i.c.MyBadges][r] : s[i.a.Cosmetic][i.c.Gallery][r]) && (u(e) ? n.has(e.id) && o.unlocked.push(e) : t.has(e.id) || o.locked.push(e))
					})
				})
			}

			function b(e) {
				const t = (e, t) => {
					const n = parseInt(e.price || "0"),
						s = parseInt(t.price || "0");
					return n === s ? Object(a.b)(e, t) : n - s
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === r.a).map(b).sort((e, n) => {
					const s = t[e.id],
						r = t[n.id];
					return Object(a.b)(s, r)
				})
			}

			function f(e) {
				const t = {
					[i.a.Loyalty]: {},
					[i.a.Achievement]: {},
					[i.a.Cosmetic]: {
						[i.c.Gallery]: {},
						[i.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(n => {
					const s = e.collections[n],
						r = {
							description: s.description,
							highlight: s.extra && s.extra.style && s.extra.style.color,
							id: s.id,
							locked: [],
							title: s.title,
							unlocked: []
						};
					t[i.a.Loyalty][n] = Object.assign({}, r, {
						locked: [],
						unlocked: []
					}), t[i.a.Achievement][n] = Object.assign({}, r, {
						locked: [],
						unlocked: []
					}), t[i.a.Cosmetic][i.c.Gallery][n] = Object.assign({}, r, {
						locked: [],
						unlocked: []
					}), t[i.a.Cosmetic][i.c.MyBadges][n] = Object.assign({}, r, {
						locked: [],
						unlocked: []
					})
				});
				const n = new Set;
				e.userOwnedBadges.forEach(t => {
					const s = e.badges[t];
					s && n.add(s.type)
				});
				const s = new Set(e.userOwnedBadges);
				return l(Object.keys(e.badges).map(t => e.badges[t]), n, s, t), l(Object.keys(e.products).map(t => e.products[t]), n, s, t), {
					collections: {
						[i.a.Loyalty]: p(t[i.a.Loyalty], e.collections),
						[i.a.Achievement]: p(t[i.a.Achievement], e.collections),
						[i.a.Cosmetic]: {
							[i.c.Gallery]: p(t[i.a.Cosmetic][i.c.Gallery], e.collections),
							[i.c.MyBadges]: p(t[i.a.Cosmetic][i.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.a: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								data: Object.assign({}, r.data),
								raw: Object.assign({}, r.raw)
							})
						}) : e
					}
					case o.h: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								data: Object.assign({}, r.data, {
									subscription: Object.assign({}, r.data.subscription || {}, {
										settings: {
											renew: !1
										}
									})
								}),
								raw: Object.assign({}, r.raw, {
									subscription: Object.assign({}, r.raw.subscription || {}, {
										settings: {
											renew: !1
										}
									})
								})
							})
						}) : e
					}
					case o.i: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.subredditId]: {
								raw: n,
								data: f(n),
								status: s.Fetched
							}
						})
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/modal.ts");
			const o = {};
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.e:
							if (!t.payload.actionSource && !t.payload.redirectUrl) return o;
							return Object.assign({}, e, t.payload);
						default:
							return e
					}
				},
				c = n("./src/reddit/actions/authorFlair.ts"),
				i = n("./src/reddit/actions/badge.ts"),
				d = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				u = n("./src/reddit/actions/economics/support/constants.ts"),
				l = n("./src/reddit/actions/governance/constants.ts"),
				b = n("./src/reddit/actions/harbergerTax/constants.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				f = n("./src/reddit/actions/postCreation/constants.ts"),
				m = n("./src/reddit/actions/product.ts"),
				O = n("./src/reddit/actions/reportFlow.ts"),
				g = n("./src/reddit/actions/structuredStyles/constants.ts"),
				_ = n("./src/reddit/constants/modals.ts");
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.c: {
							const n = t.payload;
							return e === n ? null : n
						}
						case r.b:
						case f.x:
						case r.d:
						case p.a:
						case O.f:
							return null;
						case g.e:
							return e === _.a.BLADE_UNSAVED_CHANGES ? null : e;
						case g.d:
							return e === _.a.BLADE_NIGHTMODE ? null : e;
						case c.a:
							return e === _.a.USER_FLAIR_MODAL_ID ? null : _.a.USER_FLAIR_MODAL_ID;
						case i.c:
							return _.a.BADGE_PICKER;
						case m.b:
							return _.a.BADGE_PURCHASE;
						case l.e:
							return _.a.GOVERNANCE_OPT_OUT;
						case l.s:
							return _.a.TRANSFER_POINTS;
						case l.p:
							return _.a.GOVERNANCE_RELEASE_NOTES;
						case b.e:
							return _.a.HARBERGER_TAX_BANNER_PURCHASE;
						case b.c:
							return _.a.HARBERGER_TAX_BANNER_MANAGE;
						case b.b:
							return _.a.HARBERGER_TAX_CRYPTO_BANNER_PURCHASE;
						case b.a:
							return _.a.HARBERGER_TAX_CRYPTO_BANNER_MANAGE;
						case u.a:
							return _.a.ECONOMY_SUPPORT_MODAL;
						case l.y:
							return _.a.WALLET_REGISTRATION_MODAL;
						case d.f:
							return _.a.SUBREDDIT_PREMIUM_PURCHASE_MODAL;
						case d.c:
							return _.a.SUBREDDIT_PREMIUM_BADGE_MANAGEMENT;
						case d.j:
							return _.a.SUBREDDIT_PREMIUM_UPLOAD_MODAL;
						default:
							return e
					}
				},
				j = n("./src/reddit/actions/post.ts"),
				h = n("./src/reddit/actions/unload/constants.ts"),
				E = n("./src/reddit/actions/video.ts");
			const I = {};

			function v(e, t, n) {
				const s = e[t] || {};
				return Object.assign({}, e, {
					[t]: Object.assign({}, s, {
						[n]: Date.now()
					})
				})
			}
			var S = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : I,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case j.a:
							return v(e, t.payload.postId, "adImpression");
						case j.b:
							return v(e, t.payload.postId, "adViewableImpression");
						case E.e:
							return v(e, t.payload.postId, "adVideoViewable");
						case E.a:
							return v(e, t.payload.postId, "adMRCVideoViewable");
						case E.b:
							return v(e, t.payload.postId, "adVideoFullyViewable");
						case E.d:
							return v(e, t.payload.postId, "adVideoStarted");
						case E.c:
							return v(e, t.payload.postId, "adVideoPlayedWithSound");
						case E.r:
							return v(e, t.payload.postId, "adVideoPlayedExpanded");
						case E.f: {
							const {
								postId: n,
								percentage: s
							} = t.payload;
							return v(e, n, "adVideoWatchedPercent".concat(s))
						}
						case E.g: {
							const {
								postId: n,
								seconds: s
							} = t.payload;
							return v(e, n, "adVideoWatchedSeconds".concat(s))
						}
						case j.q:
							return v(e, t.payload.postId, "vendorFullyViewable");
						case j.s:
							return v(e, t.payload.postId, "vendorFullyViewableSeconds5");
						case j.r:
							return v(e, t.payload.postId, "vendorFullyViewableSeconds15");
						case h.b:
							return v(e, t.payload.postId, "adUnloaded");
						case j.f:
							return v(e, t.payload.postId, "groupMViewable");
						default:
							return e
					}
				},
				T = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/apiRequestState.ts"));
			const D = {};
			var C = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : D,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case T.d:
						case T.a:
						case T.b: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.apiRequestId]: n
							})
						}
						case T.c: {
							const n = t.payload;
							if (!(n in e)) return e;
							if (1 === Object.keys(e).length) return D;
							const s = Object.assign({}, e);
							return delete s[n], s
						}
						default:
							return e
					}
				},
				w = n("./src/reddit/actions/subredditModeration.ts");
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.e:
						case w.d:
							return null;
						case w.c:
							return t.payload;
						default:
							return e
					}
				},
				R = n("./src/reddit/models/SubredditModeration/index.ts");
			const P = {};
			var k = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.e: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(R.d)(n, s);
							return Object.assign({}, e, {
								[r]: !0
							})
						}
						case w.d:
						case w.c: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(R.d)(n, s);
							return Object.assign({}, e, {
								[r]: !1
							})
						}
						default:
							return e
					}
				},
				x = Object(s.c)({
					error: A,
					pending: k
				});
			const N = {};
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.d: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(R.d)(s, n);
						return Object.assign({}, e, {
							[r]: !0
						})
					}
					default:
						return e
				}
			};
			const U = {};
			var M = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : U,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.d: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				F = n("./node_modules/icepick/icepick.js");
			const G = {};
			var B = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.b:
					case w.d: {
						const {
							subredditId: n,
							approvedSubmitters: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(F.merge)(e, r)
					}
					case w.i: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(F.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var q = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.h:
					case w.g:
						return null;
					case w.f:
						return t.payload;
					default:
						return e
				}
			};
			var V = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.h:
							return !0;
						case w.g:
						case w.f:
							return !1;
						default:
							return e
					}
				},
				K = Object(s.c)({
					error: q,
					pending: V
				});
			var H = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.h:
							return null;
						case w.g: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				W = Object(s.c)({
					api: K,
					result: H
				});
			const Y = {};
			var Q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.d: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: [...e[n], ...s]
							}) : Object.assign({}, e, {
								[n]: s
							})
						}
						case w.i: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case w.b: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				z = Object(s.c)({
					api: x,
					fetchedTokens: L,
					loadMore: M,
					models: B,
					search: W,
					userOrder: Q
				});
			var J = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.a:
							return t.payload;
						default:
							return e
					}
				},
				X = n("./node_modules/lodash/mergeWith.js"),
				Z = n.n(X),
				$ = n("./src/reddit/actions/comment/index.ts"),
				ee = n("./src/reddit/actions/comment/websocket/constants.ts"),
				te = n("./src/reddit/actions/grantUserFlair/constants.ts"),
				ne = n("./src/reddit/actions/modQueue/constants.ts"),
				se = n("./src/reddit/actions/page.ts"),
				re = n("./src/reddit/actions/pages/profileComments.ts"),
				oe = n("./src/reddit/actions/pages/profilePosts.ts"),
				ae = n("./src/reddit/actions/pages/profilePrivate/constants.ts"),
				ce = n("./src/reddit/actions/pages/search.ts"),
				ie = n("./src/reddit/actions/pages/subreddit.ts"),
				de = n("./src/reddit/actions/profileConversations.ts"),
				ue = n("./src/reddit/actions/subreddit.ts"),
				le = n("./src/reddit/actions/userFlair.ts"),
				be = n("./src/reddit/models/User/index.ts");
			const pe = {};
			var fe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.b:
					case ee.c: {
						const n = t.payload,
							{
								authorFlair: s
							} = n;
						if (s) {
							return Z()(Object.assign({}, e), s, (e, t, n) => {
								if ("richtext" === n) return t
							})
						}
						return e
					}
					case ae.c:
					case ae.i:
					case ae.e:
					case ae.g:
					case ce.c: {
						const {
							authorFlair: n
						} = t.payload;
						if (n) {
							return Object(F.merge)(e, n)
						}
						return e
					}
					case $.u:
					case ie.c:
					case se.b:
					case re.b:
					case re.e:
					case oe.e:
					case oe.b:
					case de.e:
					case ue.i:
						return me(e, t.payload);
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
						return me(e, t.payload.response);
					case le.i: {
						const {
							subredditId: n,
							userName: s,
							applied: r,
							displaySettings: {
								isUserEnabled: o
							}
						} = t.payload;
						return Object(F.setIn)(e, [n, s], o ? r : null)
					}
					case te.h:
					case te.b: {
						const {
							subredditId: n,
							userName: s,
							applied: r
						} = t.payload;
						return e[n] && e[n][s] ? Object(F.setIn)(e, [n, s], r) : e
					}
					case le.a: {
						const {
							subredditId: n,
							userName: s,
							applied: r,
							displaySettings: {
								isEnabled: o
							}
						} = t.payload;
						return Object(F.setIn)(e, [n, s], o ? r : null)
					}
					default:
						return e
				}
			};
			const me = (e, t) => {
				let {
					account: n,
					authorFlair: s,
					userFlair: r
				} = t;
				const o = Object(F.merge)(e, s);
				if (!r || !n) return o;
				const a = Object.keys(r)[0];
				if (!a) return o;
				const c = r[a],
					i = Object(be.e)(n),
					d = c.applied,
					u = c.displaySettings && c.displaySettings.isUserEnabled;
				return i && d && u ? Object(F.merge)(o, {
					[a]: {
						[i]: d
					}
				}) : o
			};
			var Oe = Object(s.c)({
					inContext: J,
					models: fe
				}),
				ge = n("./src/reddit/actions/gold/constants.ts");
			const _e = {};
			var ye = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _e,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.b: {
						const {
							disabled: n,
							subredditId: s
						} = t.payload;
						return n ? Object.assign({}, e, {
							[s]: n
						}) : e
					}
					default:
						return e
				}
			};
			var je = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.f:
					case ge.g:
						return null;
					case ge.e:
						return t.payload;
					default:
						return e
				}
			};
			var he = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.a:
						case ge.g:
						case ge.e:
							return !1;
						case ge.f:
							return !0;
						default:
							return e
					}
				},
				Ee = Object(s.c)({
					error: je,
					pending: he
				}),
				Ie = Object(s.c)({
					api: Ee
				});
			var ve = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.G:
					case ge.F:
						return null;
					case ge.E:
						return t.payload;
					default:
						return e
				}
			};
			const Se = {};
			var Te = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Se,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.G: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case ge.F:
						case ge.E: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				De = Object(s.c)({
					error: ve,
					pending: Te
				});
			const Ce = {};
			var we = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ce,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.F: {
							const {
								awards: n,
								subredditId: s
							} = t.payload, r = n.map(e => e.id);
							return Object.assign({}, e, {
								[s]: r
							})
						}
						case ge.g: {
							const {
								award: n,
								subredditId: s
							} = t.payload;
							if (n && n.id) {
								if (!e[s]) return Object.assign({}, e, {
									[s]: [n.id]
								});
								if (-1 === e[s].indexOf(n.id)) return Object.assign({}, e, {
									[s]: [n.id, ...e[s]]
								})
							}
							return e
						}
						case ge.j: {
							const {
								awardId: n,
								subredditId: s
							} = t.payload, r = Object.assign({}, e);
							if (r[s]) {
								const e = r[s].indexOf(n);
								if (-1 !== e) {
									const t = [...r[s]];
									return t.splice(e, 1), r[s] = t, r
								}
							}
							return e
						}
						default:
							return e
					}
				},
				Ae = Object(s.c)({
					api: De,
					order: we
				}),
				Re = n("./node_modules/lodash/merge.js"),
				Pe = n.n(Re);
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			const ke = e => {
				const t = e.split("+");
				if (1 === t.length) return e;
				const n = "".concat(t[1].substring(0, 2), ":").concat(t[1].substring(2));
				return "".concat(t[0], "+").concat(n)
			};
			var xe = e => (e.startsAt && (e.startsAt = "number" == typeof e.startsAt ? new Date(e.startsAt).toISOString() : ke(e.startsAt)), e.endsAt && (e.endsAt = "number" == typeof e.endsAt ? new Date(e.endsAt).toISOString() : ke(e.endsAt)), e),
				Ne = n("./src/reddit/models/Gold/Award.ts"),
				Le = n("./src/reddit/actions/discoveryUnit.ts"),
				Ue = n("./src/reddit/actions/frontpage.ts"),
				Me = n("./src/reddit/actions/multireddit/constants.ts"),
				Fe = n("./src/reddit/actions/pages/collectionCommentsPage.ts"),
				Ge = n("./src/reddit/actions/pages/modListing/constants.ts"),
				Be = n("./src/reddit/actions/pages/postCreation.ts"),
				qe = n("./src/reddit/actions/pages/profileOverview.ts"),
				Ve = n("./src/reddit/actions/profileOverviewChrono.ts"),
				Ke = (n("./node_modules/core-js/modules/es6.symbol.js"), n("./src/lib/makeActionCreator/index.ts")),
				He = (n("./src/config.ts"), n("./src/lib/constants/index.ts"));
			n("./src/lib/makeApiRequest/index.ts"), n("./src/reddit/helpers/addRedesignIdentifier/index.ts"), n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			Object(Ke.a)("RECOMMENDED_POSTS_LOADED"), Object(Ke.a)("RECOMMENDED_POSTS_FAILED");
			var We = n("./src/reddit/actions/search.ts");
			const Ye = {},
				Qe = (e => t => {
					for (let n = 0; n < e.length; n++) t = e[n](t);
					return t
				})([xe]);
			var ze = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ye,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.F:
					case ge.N: {
						const {
							awards: n
						} = t.payload, s = n.reduce((e, t) => (e[t.id] = Qe(t), e), {});
						return Pe()(Object.assign({}, e), s)
					}
					case ge.g: {
						const {
							award: n
						} = t.payload;
						return n && n.id ? e[n.id] ? Pe()(Object.assign({}, e), {
							[n.id]: Qe(n)
						}) : Object.assign({}, e, {
							[n.id]: Qe(n)
						}) : e
					}
					case ge.m: {
						const {
							awardId: n
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								isEnabled: !1
							})
						}) : e
					}
					case Fe.b:
					case $.u:
					case ee.b:
					case Be.b:
					case Le.e:
					case Ue.b:
					case Ge.e:
					case Ge.h:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case Me.r:
					case se.b:
					case se.g:
					case se.k:
					case ce.c:
					case re.b:
					case re.e:
					case de.b:
					case de.e:
					case qe.b:
					case qe.e:
					case Ve.b:
					case oe.b:
					case oe.e:
					case ae.c:
					case ae.e:
					case ae.i:
					case ae.g:
					case "RECOMMENDED_POSTS_LOADED":
					case We.c:
					case ue.i:
					case ie.c: {
						const n = {},
							s = t.payload.posts || [],
							r = t.payload.comments || [];
						for (const e in s) {
							const t = s[e].allAwardings || [];
							for (const e of t) n[e.id] = Qe(Object(Ne.h)(e))
						}
						for (const e in r) {
							const t = r[e],
								{
									associatedAward: s,
									allAwardings: o = []
								} = t;
							for (const e of o) n[e.id] = Qe(Object(Ne.h)(e));
							s && (n[s.id] = Qe(s))
						}
						return Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			var Je = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.O:
					case ge.N:
						return null;
					case ge.M:
						return t.payload;
					default:
						return e
				}
			};
			const Xe = {};
			var Ze = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.O: {
							const {
								subredditOrProfileId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case ge.N:
						case ge.M: {
							const {
								subredditOrProfileId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				$e = Object(s.c)({
					error: Je,
					pending: Ze
				});
			const et = {};
			var tt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : et,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.N: {
							const {
								awards: n,
								subredditOrProfileId: s
							} = t.payload, r = n.map(e => e.id);
							return Object.assign({}, e, {
								[s]: r
							})
						}
						default:
							return e
					}
				},
				nt = Object(s.c)({
					api: $e,
					order: tt
				}),
				st = Object(s.c)({
					blacklist: ye,
					create: Ie,
					manageable: Ae,
					models: ze,
					usable: nt
				});
			const rt = {};
			var ot = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.e:
					case i.f: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case i.d: {
						const {
							subredditId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const at = {};
			var ct = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : at,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case i.e: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case i.f:
						case i.d: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				it = Object(s.c)({
					error: ot,
					pending: ct
				});
			const dt = {};
			var ut = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.h:
					case i.i: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case i.g: {
						const {
							subredditId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const lt = {};
			var bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case i.h: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case i.i:
						case i.g: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				pt = Object(s.c)({
					error: ut,
					pending: bt
				}),
				ft = Object(s.c)({
					subreddit: it,
					user: pt
				});
			const mt = {};
			var Ot = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.i:
						case i.f:
						case i.i:
						case m.d: {
							const {
								badges: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				gt = Object(s.c)({
					api: ft,
					models: Ot
				});
			var _t = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.m:
					case w.l:
						return null;
					case w.k:
						return t.payload;
					default:
						return e
				}
			};
			const yt = {};
			var jt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.m: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(R.d)(n, s);
							return Object.assign({}, e, {
								[r]: !0
							})
						}
						case w.l:
						case w.k: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(R.d)(n, s);
							return Object.assign({}, e, {
								[r]: !1
							})
						}
						default:
							return e
					}
				},
				ht = Object(s.c)({
					error: _t,
					pending: jt
				});
			const Et = {};
			var It = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Et,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.l: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(R.d)(s, n);
							return Object.assign({}, e, {
								[r]: !0
							})
						}
						default:
							return e
					}
				},
				vt = n("./src/reddit/actions/inContextModeration.ts");
			var St = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vt.a:
						return t.payload;
					default:
						return e
				}
			};
			const Tt = {};
			var Dt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.l: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const Ct = {};
			var wt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ct,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.j:
					case w.l: {
						const {
							subredditId: n,
							bannedUsers: s
						} = t.payload;
						return Object(F.merge)(e, {
							[n]: s
						})
					}
					case w.q: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(F.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var At = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.p:
					case w.o:
						return null;
					case w.n:
						return t.payload;
					default:
						return e
				}
			};
			var Rt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.p:
							return !0;
						case w.o:
						case w.n:
							return !1;
						default:
							return e
					}
				},
				Pt = Object(s.c)({
					error: At,
					pending: Rt
				});
			var kt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.p:
						case w.n:
							return null;
						case w.o: {
							const e = t.payload.bannedUserIds[0];
							return e ? t.payload.bannedUsers[e] : null
						}
						default:
							return e
					}
				},
				xt = Object(s.c)({
					api: Pt,
					result: kt
				});
			const Nt = {};
			var Lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.l: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: [...e[n], ...s]
							}) : Object.assign({}, e, {
								[n]: s
							})
						}
						case w.q: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case w.j: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Ut = Object(s.c)({
					api: ht,
					fetchedTokens: It,
					inContext: St,
					loadMore: Dt,
					models: wt,
					search: xt,
					userOrder: Lt
				}),
				Mt = n("./src/reddit/actions/blockedRedditors.ts");
			const Ft = {
				message: ""
			};
			var Gt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ft,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Mt.c:
					case Mt.d:
						return e;
					case Mt.b:
						return t.payload;
					default:
						return e
				}
			};
			var Bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Mt.d:
							return !0;
						case Mt.c:
						case Mt.b:
							return !1;
						default:
							return e
					}
				},
				qt = Object(s.c)({
					error: Gt,
					pending: Bt
				});
			const Vt = {
				ids: []
			};
			var Kt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Mt.a:
							return {
								ids: [...e.ids, t.payload], timestamp: e.timestamp
							};
						case Mt.e:
							const n = e.ids.slice();
							return n.splice(e.ids.indexOf(t.payload), 1), Object.assign({}, e, {
								ids: n
							});
						case Mt.c:
							return {
								ids: [...e.ids, ...t.payload], timestamp: Date.now()
							};
						default:
							return e
					}
				},
				Ht = Object(s.c)({
					api: qt,
					list: Kt
				}),
				Wt = n("./src/reddit/actions/userBlocks.ts");
			const Yt = {};
			var Qt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Wt.f:
					case Wt.e: {
						const {
							userId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Wt.d: {
						const {
							userId: n,
							type: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const zt = {};
			var Jt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Wt.f: {
							const {
								userId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Wt.e:
						case Wt.d: {
							const {
								userId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Xt = Object(s.c)({
					error: Qt,
					pending: Jt
				}),
				Zt = Object(s.c)({
					api: Xt
				}),
				$t = n("./src/reddit/actions/ads/constants.ts");
			const en = {
				isViewSafe: !0,
				hasBrandSafetyBeenAssessed: !1
			};
			var tn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : en,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $t.a:
							return e.isViewSafe === t.payload.isViewSafe && e.hasBrandSafetyBeenAssessed ? e : Object.assign({}, e, {
								isViewSafe: t.payload.isViewSafe,
								hasBrandSafetyBeenAssessed: !0
							});
						case ie.d:
						case se.l:
						case se.h:
							return e.hasBrandSafetyBeenAssessed ? Object.assign({}, e, {
								hasBrandSafetyBeenAssessed: !1
							}) : e;
						default:
							return e
					}
				},
				nn = n("./src/reddit/actions/category.ts");
			var sn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nn.b:
					case nn.c:
						return null;
					case nn.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			var rn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nn.c:
						return !1;
					case nn.b:
						return !0;
					default:
						return e
				}
			};
			var on = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nn.c:
							return !0;
						case nn.b:
						case nn.a:
							return !1;
						default:
							return e
					}
				},
				an = Object(s.c)({
					error: sn,
					loaded: rn,
					pending: on
				});
			const cn = {};
			var dn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nn.g:
					case nn.f: {
						const {
							categoryId: n
						} = t.payload, s = Object.assign({}, e);
						return delete s[n], s
					}
					case nn.e: {
						const {
							categoryId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const un = {};
			var ln = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : un,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nn.g: {
						const {
							categoryId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case nn.f: {
						const {
							categoryId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const bn = {};
			var pn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nn.g: {
							const {
								categoryId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case nn.f:
						case nn.e: {
							const {
								categoryId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				fn = Object(s.c)({
					error: dn,
					loaded: ln,
					pending: pn
				}),
				mn = Object(s.c)({
					list: an,
					subreddits: fn
				}),
				On = n("./node_modules/lodash/isEmpty.js"),
				gn = n.n(On);
			const _n = [];
			var yn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _n,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nn.b: {
						const {
							categoryIds: n
						} = t.payload;
						return gn()(n) ? e : n
					}
					default:
						return e
				}
			};
			const jn = {};
			var hn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nn.b: {
							const {
								categories: n
							} = t.payload;
							return gn()(n) ? e : Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				En = n("./node_modules/lodash/forOwn.js"),
				In = n.n(En),
				vn = n("./src/reddit/helpers/name/index.ts");
			const Sn = {};
			var Tn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nn.b: {
							const {
								categories: n
							} = t.payload;
							if (gn()(n)) return e;
							const s = {};
							return In()(n, e => {
								s[Object(vn.f)(e.name)] = e.id
							}), Object.assign({}, e, s)
						}
						default:
							return e
					}
				},
				Dn = n("./src/reddit/actions/global.ts"),
				Cn = n("./src/reddit/constants/localStorage.ts");
			const wn = {};
			var An = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Dn.a:
							return t.payload[Cn.d] || e;
						case nn.d: {
							const {
								categoryId: n,
								rank: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				Rn = Object(s.c)({
					api: mn,
					ids: yn,
					models: hn,
					nameToId: Tn,
					ranking: An
				}),
				Pn = n("./src/reddit/actions/chat/init.ts");
			var kn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pn.a:
						return !0;
					default:
						return e
				}
			};
			n("./src/reddit/endpoints/chat/index.ts");
			Object(Ke.a)("SENDBIRD_PROXY__SET_CONFIG");
			var xn = n("./src/reddit/actions/chat/subredditChannel.ts");
			var Nn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xn.b:
						case xn.a:
							return !!t.payload.isUserSubredditChatEnabled;
						case "SENDBIRD_PROXY__SET_CONFIG":
							const {
								user_subreddit_chat_enabled: n
							} = t.payload;
							return n;
						default:
							return e
					}
				},
				Ln = n("./src/chat/actions/promo/constants.ts");
			const Un = {
				displaySubredditChatFtux: !1
			};
			var Mn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Un,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ln.a: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ln.b: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Fn = n("./src/reddit/actions/chat/subredditSettings.ts");
			const Gn = {
				subredditId: null,
				bannedWords: "",
				domains: "",
				rateLimit: -1,
				regexes: []
			};
			var Bn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fn.a:
							return Object.assign({}, t.payload);
						default:
							return e
					}
				},
				qn = n("./src/reddit/actions/chat/unreadCount.ts");
			const Vn = {
				apiError: null
			};
			var Kn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qn.a.REQUEST_FAILED: {
						const e = t.payload;
						return Object.assign({}, Vn, {
							apiError: e
						})
					}
					case qn.a.REQUEST_SUCCESS:
					case qn.a.REQUEST_PENDING:
						return Vn;
					default:
						return e
				}
			};
			var Hn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qn.a.REQUEST_PENDING:
							return !0;
						case qn.a.REQUEST_FAILED:
						case qn.a.REQUEST_SUCCESS:
							return !1;
						default:
							return e
					}
				},
				Wn = Object(s.c)({
					error: Kn,
					pending: Hn
				});
			const Yn = {
				basicChannelCount: 0,
				subredditChannelCount: 0
			};
			var Qn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qn.a.SYNC:
						case qn.a.REQUEST_SUCCESS: {
							const e = t.payload;
							return Object.assign({}, e)
						}
						default:
							return e
					}
				},
				zn = Object(s.c)({
					api: Wn,
					count: Qn
				}),
				Jn = Object(s.c)({
					isInited: kn,
					isUserSubredditChatEnabled: Nn,
					subredditSettings: Bn,
					promos: Mn,
					unread: zn
				}),
				Xn = n("./src/reddit/actions/claimgold.ts");
			var Zn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xn.a:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg;
					case Xn.d:
					case Xn.e:
					case Xn.c:
						return null;
					default:
						return e
				}
			};
			var $n = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xn.d:
					case Xn.c:
					case Xn.a:
						return !1;
					case Xn.b:
						return !0;
					default:
						return e
				}
			};
			var es = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xn.b:
						case Xn.d:
						case Xn.c:
						case Xn.a:
							return !1;
						case Xn.f:
							return !0;
						default:
							return e
					}
				},
				ts = Object(s.c)({
					error: Zn,
					pending: $n,
					showLoader: es
				});
			var ns = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xn.g:
						return t.payload;
					case Xn.e:
						return "";
					default:
						return e
				}
			};
			var ss = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xn.e:
							return !0;
						case Xn.c:
						case Xn.d:
							return !1;
						default:
							return e
					}
				},
				rs = Object(s.c)({
					api: ts,
					code: ns,
					showModal: ss
				}),
				os = n("./node_modules/lodash/get.js"),
				as = n.n(os);
			const cs = {};
			var is = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cs,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.d: {
							const {
								commentsPageKey: n,
								commentId: s,
								isCollapsed: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									[s]: !as()(e, [n, s], r)
								})
							})
						}
						case $.e: {
							const {
								commentsPageKey: n,
								commentId: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									[s]: !1
								})
							})
						}
						case $.u:
						case Fe.b:
						case se.b: {
							const {
								key: n,
								shouldCollapse: s
							} = t.payload;
							if (!s) return e;
							const r = s.reduce((e, t) => Object.assign({}, e, {
								[t]: !0
							}), {});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], r)
							})
						}
						default:
							return e
					}
				},
				ds = n("./src/lib/makeDraftKey/index.ts"),
				us = n("./src/reddit/models/PostCreationForm/index.ts"),
				ls = n("./src/reddit/models/PostDraft/index.ts");
			const bs = {};
			var ps = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bs,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.q: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								autofocusDisabled: !0
							})
						})
					}
					case $.j: {
						const {
							draftKey: n,
							hasFocus: s
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								hasFocus: s
							})
						}) : e
					}
					case se.e: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {
								rteState: null,
								draftType: ls.c.replyToPost
							}
						})
					}
					case Fe.b:
					case Fe.c:
					case se.d: {
						const {
							postId: n,
							commentMode: s
						} = t.payload, r = Object(ds.a)(ls.c.replyToPost, n);
						return Object.assign({}, e, {
							[r]: {
								commentMode: s,
								draftType: ls.c.replyToPost,
								hasFocus: !1,
								rteState: null,
								text: ""
							}
						})
					}
					case se.b: {
						const {
							postId: n,
							preferences: s
						} = t.payload;
						if (!s || void 0 === s.useMarkdown) return e;
						const r = Object(ds.a)(ls.c.replyToPost, n),
							o = s.useMarkdown ? us.h.MARKDOWN : us.h.RICH_TEXT;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								commentMode: o
							})
						})
					}
					case $.l:
						const {
							draftKey: n, content: s, editorMode: r
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								commentMode: r,
								rteState: null,
								text: r === us.h.MARKDOWN ? s : "",
								rtJson: r === us.h.RICH_TEXT ? s : null
							})
						}) : e;
					case $.r:
					case $.p: {
						const {
							draftKey: n,
							formData: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								hasFocus: !0
							})
						})
					}
					case $.k: {
						const {
							draftKey: n,
							formData: s
						} = t.payload;
						return null === e[n] ? e : Object.assign({}, e, {
							[n]: Object.assign({}, e[n], s)
						})
					}
					case $.f: {
						const {
							draftKey: n
						} = t.payload, s = e[n];
						return s && s.draftType === ls.c.replyToPost ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								rteState: null,
								text: ""
							})
						}) : Object.assign({}, e, {
							[n]: null
						})
					}
					case $.G: {
						const {
							draftKey: n
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								rteState: null,
								text: ""
							})
						})
					}
					case $.F:
					case $.B: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case $.E: {
						const {
							draftKey: n,
							draft: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const fs = {};
			var ms = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fs,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.h: {
						const {
							commentListNodeId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case $.i: {
						const {
							commentListNodeId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !e[n]
						})
					}
					default:
						return e
				}
			};
			const Os = {};
			var gs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Os,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.c: {
						const {
							commentListNodeIds: n,
							commentsPageKey: s
						} = t.payload, r = n.reduce((t, n) => (t[n] = !as()(e, [s, n], !1), t), {});
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], r)
						})
					}
					case $.b: {
						const {
							commentListNodeIds: n,
							commentsPageKey: s
						} = t.payload, r = n.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], r)
						})
					}
					case $.u:
					case Fe.b:
					case se.b: {
						const {
							key: n,
							shouldHide: s
						} = t.payload;
						if (!s) return e;
						const r = s.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], r)
						})
					}
					default:
						return e
				}
			};
			const _s = {};
			var ys = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _s,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.r: {
							const {
								commentId: n,
								commentsPageKey: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], {
									[n]: !0
								})
							})
						}
						case $.g:
						case $.z:
						case $.B: {
							const {
								commentId: n,
								commentsPageKey: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], {
									[n]: !1
								})
							})
						}
						default:
							return e
					}
				},
				js = n("./node_modules/lodash/isEqual.js"),
				hs = n.n(js),
				Es = n("./node_modules/lodash/mapValues.js"),
				Is = n.n(Es),
				vs = n("./node_modules/lodash/omit.js"),
				Ss = n.n(vs),
				Ts = n("./src/reddit/actions/bulkActions/constants.ts"),
				Ds = n("./src/reddit/actions/modMode.ts"),
				Cs = n("./src/reddit/actions/vote.ts"),
				ws = n("./src/reddit/helpers/isComment.ts"),
				As = n("./src/reddit/models/Comment/index.ts");
			const Rs = (e, t, n) => {
					const s = {};
					for (const o of t) s[o.award.id] = o.total;
					const r = n ? e.awarders && e.awarders.length ? e.awarders.includes(n) ? e.awarders : [n, ...e.awarders] : [n] : e.awarders;
					return Object.assign({}, e, {
						awarders: r,
						awardCountsById: s
					})
				},
				Ps = (e, t) => Object.assign({}, e, {
					awardCountsById: Object.assign({}, e.awardCountsById, {
						[t]: 0
					})
				});
			var ks = n("./src/reddit/models/ModQueue/index.ts"),
				xs = n("./src/reddit/models/Vote/index.ts"),
				Ns = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Ls = {},
				Us = e => t => {
					for (let n = 0; n < e.length; n++) t = e[n](t);
					return t
				},
				Ms = ["next", "prev", "depth"],
				Fs = e => Ss()(e, Ms),
				Gs = e => {
					const {
						allAwardings: t,
						associatedAward: n
					} = e, s = Ns(e, ["allAwardings", "associatedAward"]), r = Object.assign({}, s);
					if (t) {
						const e = {};
						for (const n of t) e[n.id] = n.count;
						r.awardCountsById = e
					}
					return n && (r.associatedAwardId = n.id), r
				};
			var Bs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ls,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.b:
					case ee.c:
					case $.F:
					case $.G: {
						const {
							comment: n
						} = t.payload, s = Us([Gs]);
						return Object.assign({}, e, {
							[n.id]: s(n)
						})
					}
					case $.u:
					case Fe.b:
					case se.b:
					case re.b:
					case re.e:
					case qe.b:
					case qe.e:
					case de.b:
					case de.e:
					case Ve.b:
					case ae.i:
					case ae.g:
					case ae.c:
					case ae.e: {
						const n = Object.assign({}, e),
							s = Us([Fs, Gs]);
						for (const r in t.payload.comments) {
							const o = e[r],
								a = t.payload.comments[r];
							o ? hs()(o, a) || (a.postAuthor || (a.postAuthor = o.postAuthor), a.postTitle || (a.postTitle = o.postTitle), n[r] = s(a)) : n[r] = s(a)
						}
						return n
					}
					case ee.a:
					case $.y: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								isDeleted: !0,
								deletedBy: As.a.User
							})
						})
					}
					case $.n: {
						const n = t.payload;
						return Z()(Object.assign({}, e), n, (e, t) => Object.assign({}, e, t))
					}
					case Cs.a: {
						const {
							id: n,
							vote: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object(xs.c)(r, s)
						}) : e
					}
					case ge.r: {
						const {
							awardings: n,
							id: s,
							gilder: r,
							treatmentTags: o
						} = t.payload, a = e[s];
						return a ? Object.assign({}, e, {
							[s]: Object.assign({}, Rs(a, n, r), {
								treatmentTags: o
							})
						}) : e
					}
					case ge.D: {
						const {
							awardId: n,
							thingId: s
						} = t.payload, r = e[s];
						return r ? Object.assign({}, e, {
							[s]: Ps(r, n)
						}) : e
					}
					case w.l: {
						const {
							comments: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							comments: s
						} = n, r = Us([Gs]);
						return Object.assign({}, e, Is()(s, r))
					}
					case Ts.b:
					case ne.s: {
						const {
							operation: n,
							ids: s,
							username: r,
							options: o
						} = t.payload, a = s.filter(e => Object(ws.a)(e)), c = Object(ks.d)(e, n, a, r, o);
						return Z()(Object.assign({}, e), c, (e, t) => Object.assign({}, e, t))
					}
					case ce.c: {
						const {
							comments: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case Ds.a: {
						const n = Object.assign({}, e);
						for (const s in e)
							if (e.hasOwnProperty(s)) {
								const r = e[s];
								n[s].computedCollapsed = r.collapsedBecauseCrowdControl ? !t.payload.enabled : r.collapsed
							} return n
					}
					case $.m: {
						const {
							commentId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								collapsedBecauseCrowdControl: !1
							})
						})
					}
					default:
						return e
				}
			};
			const qs = {};
			var Vs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qs,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.p: {
						const {
							parentCommentId: n,
							commentsPageKey: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								[n]: !0
							})
						})
					}
					case $.o:
					case $.F: {
						const {
							parentCommentId: n,
							commentsPageKey: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								[n]: !1
							})
						})
					}
					default:
						return e
				}
			};
			const Ks = {};
			var Hs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ks,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.o:
					case $.E:
					case $.A:
					case $.G:
					case $.F:
					case $.B: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case $.D:
					case $.z: {
						const {
							draftKey: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case $.w: {
						const {
							id: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case $.x:
					case $.y: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					default:
						return e
				}
			};
			const Ws = {};
			var Ys = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ws,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.E:
						case $.A: {
							const {
								draftKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case $.F:
						case $.G:
						case $.B:
						case $.D:
						case $.z: {
							const {
								draftKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case $.x: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case $.y:
						case $.w: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Qs = Object(s.c)({
					error: Hs,
					pending: Ys
				}),
				zs = n("./src/reddit/reducers/comments/visitHighlightingFilter/index.ts"),
				Js = Object(s.c)({
					collapsed: is,
					drafts: ps,
					focused: ms,
					hidden: gs,
					isEditing: ys,
					models: Bs,
					replyFormOpen: Vs,
					submit: Qs,
					visitHighlightFilter: zs.b
				}),
				Xs = n("./src/reddit/actions/commentsListTruncated/constants.ts");
			var Zs = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xs.a:
						return !1;
					case Xs.b:
						return !0;
					default:
						return e
				}
			};
			const $s = [];
			var er = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $s,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $t.b:
						return t.payload;
					case $t.c:
					default:
						return e
				}
			};
			const tr = {};
			var nr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fe.d:
					case Fe.b:
					case se.d:
					case se.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Fe.a:
					case se.a: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s || {}
						})
					}
					default:
						return e
				}
			};
			const sr = {};
			var rr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fe.c:
					case se.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const or = {};
			var ar = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : or,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.d:
						case se.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Fe.b:
						case Fe.a:
						case se.b:
						case se.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				cr = Object(s.c)({
					error: nr,
					fullyLoaded: rr,
					pending: ar
				}),
				ir = (n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/lodash/uniqBy.js")),
				dr = n.n(ir),
				ur = n("./node_modules/lodash/values.js"),
				lr = n.n(ur);
			const br = {};

			function pr(e, t) {
				return lr()(e).map(e => {
					const n = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
					return {
						id: e.id,
						created: n,
						stickied: e.isStickied,
						authorId: e.authorId
					}
				})
			}

			function fr(e) {
				return dr()(e, "id").sort((e, t) => e.created - t.created)
			}
			var mr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : br,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.b:
						case $.u:
						case Fe.b: {
							const {
								comments: n,
								key: s
							} = t.payload, r = e[s] ? e[s] : [], o = pr(n, r.find(e => e.stickied)), a = fr([...r, ...o]);
							return Object.assign({}, e, {
								[s]: [...a]
							})
						}
						case ee.b:
						case ee.c:
						case $.G:
						case $.F: {
							const {
								comment: {
									id: n,
									created: s,
									isStickied: r,
									authorId: o
								},
								commentsPageKey: a
							} = t.payload;
							return Object.assign({}, e, {
								[a]: [...fr([...e[a] ? e[a] : [], {
									id: n,
									created: s,
									stickied: r,
									authorId: o
								}])]
							})
						}
						default:
							return e
					}
				},
				Or = n("./src/reddit/helpers/commentList/index.ts");
			const gr = {};

			function _r(e) {
				const t = e;
				return Is()(t, e => {
					let {
						depth: t,
						next: n,
						prev: s
					} = e;
					return {
						depth: t,
						next: n,
						prev: s
					}
				})
			}
			var yr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.u: {
						const {
							comments: n,
							commentLists: s,
							continueThreads: r,
							key: o,
							moreCommentsItem: a,
							moreComments: c
						} = t.payload, i = s[a.postId], d = e[o], u = {}, l = d[a.id];
						if (l && l.prev) {
							const {
								id: e
							} = l.prev;
							u[e] = Object.assign({}, d[e], {
								next: i.head || l.next
							})
						}
						if (l && l.next) {
							const {
								id: e
							} = l.next;
							u[e] = Object.assign({}, d[e], {
								prev: i.tail || l.prev
							})
						}
						if (i.head && i.tail) {
							const e = Object(Or.c)({
									commentLink: i.head,
									commentsDict: n,
									moreCommentsDict: c,
									continueThreadDict: r
								}),
								t = Object(Or.c)({
									commentLink: i.tail,
									commentsDict: n,
									moreCommentsDict: c,
									continueThreadDict: r
								});
							l && (e.prev = l.prev, t.next = l.next)
						}
						return Object.assign({}, e, {
							[o]: Object.assign({}, e[o], _r(n), _r(r), _r(c), u)
						})
					}
					case Fe.b:
					case se.b: {
						const {
							comments: n,
							continueThreads: s,
							key: r,
							moreComments: o
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], _r(n), _r(s), _r(o))
						})
					}
					case ee.b:
					case $.G: {
						const {
							comment: n,
							commentsPageKey: s,
							headCommentId: r
						} = t.payload, o = e[s], a = {};
						let c = null;
						return r && (a[r] = Object.assign({}, o[r], {
							prev: Object(As.f)(n.id)
						}), c = Object(As.f)(r)), Object.assign({}, e, {
							[s]: Object.assign({}, e[s], a, {
								[n.id]: {
									depth: 0,
									next: c,
									prev: null
								}
							})
						})
					}
					case $.F: {
						const {
							comment: n,
							commentsPageKey: s,
							parentCommentId: r,
							depth: o
						} = t.payload, a = e[s], c = {};
						let i = null;
						if (!a[r]) return e;
						const d = a[r].next;
						return d && (c[d.id] = Object.assign({}, a[d.id], {
							prev: Object(As.f)(n.id)
						}), i = d), c[r] = Object.assign({}, a[r], {
							next: Object(As.f)(n.id)
						}), Object.assign({}, e, {
							[s]: Object.assign({}, e[s], c, {
								[n.id]: {
									depth: o,
									next: i,
									prev: Object(As.f)(r)
								}
							})
						})
					}
					default:
						return e
				}
			};
			const jr = {};
			var hr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.b:
					case ee.c:
					case $.G: {
						const {
							comment: n,
							commentsPageKey: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n.id
						})
					}
					case Fe.b:
					case se.b: {
						const {
							commentLists: n,
							key: s,
							postId: r
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n[r] && n[r].head ? n[r].head.id : null
						})
					}
					default:
						return e
				}
			};
			const Er = {};
			var Ir = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Er,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.d:
						case Fe.b:
						case Fe.c:
						case se.d: {
							const {
								key: n,
								postId: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case $.G: {
							const {
								parentId: n,
								commentsPageKey: s
							} = t.payload;
							return e[s] ? e : Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				vr = Object(s.c)({
					api: cr,
					keyToChatCommentLinks: mr,
					keyToCommentThreadLinkSets: yr,
					keyToHeadCommentId: hr,
					keyToPostId: Ir,
					ads: er
				}),
				Sr = n("./src/reddit/actions/communityFlairs/constants.ts");
			const Tr = {};
			var Dr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sr.a: {
							const {
								models: n,
								sortedKeys: s,
								subredditId: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: {
									sortedKeys: s,
									models: n
								}
							})
						}
						default:
							return e
					}
				},
				Cr = n("./src/reddit/actions/contentGate.ts");
			const wr = {};
			var Ar = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cr.a: {
						const {
							subredditName: n
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										goldSubreddit: !0
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									goldSubreddit: !0
								}
							})
						}
						return e
					}
					case Cr.b: {
						const {
							subredditDescription: n,
							subredditName: s
						} = t.payload;
						if (s) {
							if (e[s]) {
								const t = {
									[s]: {
										privateSubreddit: !0,
										subredditDescription: n
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[s]: {
									privateSubreddit: !0,
									subredditDescription: n
								}
							})
						}
						return e
					}
					case Cr.f: {
						const {
							subredditName: n,
							quarantineRequiresEmail: s,
							quarantineMessage: r,
							quarantineMessageHtml: o,
							quarantineMessageRTJson: a
						} = t.payload;
						return n ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								quarantinedSubreddit: !0,
								quarantineRequiresEmail: s,
								quarantineMessage: r,
								quarantineMessageHtml: o,
								quarantineMessageRTJson: a
							})
						}) : e
					}
					case Cr.h: {
						const {
							subredditName: n,
							banMessage: s
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										subredditBanned: !0,
										subredditBanMessage: s
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									subredditBanned: !0,
									subredditBanMessage: s
								}
							})
						}
						return e
					}
					case Cr.i: {
						const {
							subredditName: n
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										subredditBlockedForLegalReason: !0
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									subredditBlockedForLegalReason: !0
								}
							})
						}
						return e
					}
					case Cr.j: {
						const {
							subredditName: n
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										subredditDoesNotExist: !0
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									subredditDoesNotExist: !0
								}
							})
						}
						return e
					}
					case Cr.c:
					case Cr.d:
					case Cr.e: {
						const {
							profileName: n
						} = t.payload, s = He.Rb + n.toLocaleLowerCase(), r = e[s] || {}, o = {
							profileDeleted: t.type === Cr.d,
							profileSuspended: t.type === Cr.e,
							profileBlockedForLegalReason: t.type === Cr.c
						};
						return Object.assign({}, e, {
							[s]: Object.assign({}, r, o)
						})
					}
					default:
						return e
				}
			};
			const Rr = {};
			var Pr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.u:
						case Fe.b:
						case se.b:
							return Object.assign({}, e, t.payload.continueThreads);
						default:
							return e
					}
				},
				kr = Object(s.c)({
					models: Pr
				}),
				xr = n("./src/reddit/actions/postCollection/constants.ts");
			var Nr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.c:
					case xr.d:
					case xr.c:
					case xr.s:
					case xr.r:
						return null;
					case xr.b:
					case xr.n:
						return t.payload;
					default:
						return e
				}
			};
			var Lr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xr.c:
						case xr.r:
							return !0;
						case xr.d:
						case xr.b:
						case xr.s:
						case xr.n:
							return !1;
						default:
							return e
					}
				},
				Ur = Object(s.c)({
					error: Nr,
					pending: Lr
				}),
				Mr = Object(s.c)({
					createOrUpdate: Ur
				}),
				Fr = n("./src/reddit/actions/postDraft.ts");
			const Gr = {};
			var Br = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fr.c:
					case Fr.b: {
						const {
							draftId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Fr.a: {
						const {
							apiError: n,
							draftId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const qr = {};
			var Vr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fr.b: {
							const {
								draftId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Fr.c:
						case Fr.a: {
							const {
								draftId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Kr = Object(s.c)({
					error: Br,
					pending: Vr
				});
			var Hr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fr.d:
						return t.payload;
					case Fr.f:
					case Fr.e:
						return null;
					default:
						return e
				}
			};
			var Wr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fr.f:
							return !0;
						case Fr.e:
						case Fr.d:
							return !1;
						default:
							return e
					}
				},
				Yr = Object(s.c)({
					error: Hr,
					pending: Wr
				});
			const Qr = {
				apiError: null,
				needsCaptcha: !1,
				validationError: null,
				submitValidationError: null
			};
			var zr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fr.l:
					case Fr.j:
						return Qr;
					case Fr.i: {
						const e = t.payload;
						return Object.assign({}, Qr, {
							apiError: e
						})
					}
					case Fr.m: {
						const e = t.payload;
						return Object.assign({}, Qr, {
							validationError: e
						})
					}
					case Fr.k: {
						const e = t.payload;
						return Object.assign({}, Qr, {
							submitValidationError: e
						})
					}
					case Fr.h:
						return Object.assign({}, Qr, {
							needsCaptcha: !0
						});
					default:
						return e
				}
			};
			var Jr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fr.j:
							return !0;
						case Fr.l:
						case Fr.i:
						case Fr.m:
						case Fr.k:
						case Fr.h:
							return !1;
						default:
							return e
					}
				},
				Xr = Object(s.c)({
					error: zr,
					pending: Jr
				}),
				Zr = Object(s.c)({
					deleteDraft: Kr,
					listing: Yr,
					save: Xr
				});
			const $r = {};
			var eo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $r,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.E: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case f.q: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				to = Object(s.c)({
					pending: eo
				});
			var no = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.v:
					case f.w:
					case f.d:
					case f.e:
					case f.f:
					case f.j:
					case f.k:
					case f.o:
					case f.M:
						return null;
					case f.u:
						return t.payload;
					default:
						return e
				}
			};
			var so = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.v:
							return !0;
						case f.w:
						case f.u:
							return !1;
						default:
							return e
					}
				},
				ro = Object(s.c)({
					error: no,
					pending: so
				}),
				oo = Object(s.c)({
					converting: to,
					mediaUpload: ro
				});
			const ao = {};
			var co = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ao,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b:
					case Be.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Be.a: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const io = {};
			var uo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : io,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case Be.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const lo = {};
			var bo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Be.b:
						case Be.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				po = Object(s.c)({
					error: co,
					fetched: uo,
					pending: bo
				}),
				fo = n("./src/reddit/actions/scheduledPosts/constants.ts");
			const mo = {
				apiError: null,
				needsCaptcha: !1,
				pollError: void 0,
				validationError: null,
				submitValidationError: null
			};
			var Oo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.N:
					case fo.h:
					case f.y:
					case f.c:
					case f.d:
					case f.e:
					case f.f:
					case f.j:
					case f.k:
					case f.o:
					case f.M:
					case f.C:
						return mo;
					case f.i: {
						const {
							isContentChanged: n
						} = t.payload;
						return n ? mo : e
					}
					case f.p: {
						const e = t.payload;
						return Object.assign({}, mo, {
							apiError: e
						})
					}
					case f.Y: {
						const e = t.payload;
						return Object.assign({}, mo, {
							validationError: e
						})
					}
					case f.I:
					case f.H: {
						const e = t.payload;
						return Object.assign({}, mo, {
							submitValidationError: e
						})
					}
					case f.a:
						return Object.assign({}, mo, {
							needsCaptcha: !0
						});
					case f.A:
						return Object.assign({}, mo, {
							pollError: t.payload
						});
					default:
						return e
				}
			};
			var go = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.y:
							return !0;
						case f.N:
						case fo.h:
						case f.p:
						case f.Y:
						case f.H:
						case f.I:
						case f.A:
						case f.a:
							return !1;
						default:
							return e
					}
				},
				_o = Object(s.c)({
					error: Oo,
					pending: go
				});
			var yo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.z:
					case f.F:
						return null;
					case f.n:
						return t.payload;
					default:
						return e
				}
			};
			var jo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.z:
							return !0;
						case f.n:
						case f.m:
							return !1;
						default:
							return e
					}
				},
				ho = Object(s.c)({
					error: yo,
					pending: jo
				}),
				Eo = Object(s.c)({
					submit: _o,
					update: ho
				});
			var Io = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.M:
					case f.K:
					case f.L:
						return null;
					default:
						return e
				}
			};
			var vo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.L:
							return !0;
						case f.K:
						case f.M:
							return !1;
						default:
							return e
					}
				},
				So = Object(s.c)({
					error: Io,
					pending: vo
				}),
				To = Object(s.c)({
					change: So
				}),
				Do = Object(s.c)({
					collection: Mr,
					draft: Zr,
					editor: oo,
					page: po,
					post: Eo,
					subreddit: To
				}),
				Co = n("./src/reddit/actions/pages/postDraft.ts");
			const wo = {};
			var Ao = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fr.e: {
						const {
							postDrafts: e
						} = t.payload;
						return e || wo
					}
					case Fr.c: {
						const n = e,
							{
								draftId: s
							} = t.payload;
						return Ss()(n, s)
					}
					case f.N: {
						const {
							draftId: n
						} = t.payload;
						return n ? Ss()(e, n) : e
					}
					case Co.a: {
						const {
							drafts: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			const Ro = e => {
					if (e.payload && e.payload.routeMatch) return e.payload.routeMatch.route.meta.name
				},
				Po = e => {
					if (e.payload && e.payload.routeMatch && e.payload.routeMatch.match) return e.payload.routeMatch.match.queryParams
				},
				ko = e => {
					if (e.payload && e.payload.routeMatch && e.payload.routeMatch.match) return e.payload.routeMatch.match.params
				};
			var xo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.d:
							return t.payload || "";
						case f.C:
							return "";
						case p.a: {
							if (Ro(t) !== He.yb.POST_CREATION) return "";
							const n = Po(t);
							return n && n.url ? n.url || "" : e
						}
						case Fr.g: {
							const e = t.payload;
							return e.kind === ls.b.Link && e.body || ""
						}
						case fo.b:
						case fo.n:
							return t.payload.url || "";
						default:
							return e
					}
				},
				No = (n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./src/reddit/models/ScheduledPost/index.ts"));
			const Lo = e => e ? e.replace(/\+/g, " ") : "";
			var Uo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.e:
							return t.payload || "";
						case f.C:
						case f.G:
							return "";
						case f.O:
							return t.payload.editorMode === us.h.MARKDOWN ? t.payload.content || "" : e;
						case p.a: {
							if (Ro(t) !== He.yb.POST_CREATION) return "";
							const n = Po(t);
							return n && n.text ? Lo(n.text) : e
						}
						case Fr.g: {
							const e = t.payload;
							return e.kind === ls.b.Markdown && e.body || ""
						}
						case fo.b:
						case fo.n: {
							const e = t.payload;
							return e.contentType === No.a.TEXT ? e.body : ""
						}
						default:
							return e
					}
				},
				Mo = n("./src/reddit/actions/upload.ts");
			var Fo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.f:
							return t.payload || null;
						case f.C:
							return null;
						case p.a:
							return Ro(t) !== He.yb.POST_CREATION ? null : e;
						case Fr.g:
							return null;
						case Mo.a:
						case Mo.f: {
							const {
								key: n
							} = t.payload;
							return n === us.m ? null : e
						}
						case fo.b:
						case fo.n:
							return null;
						default:
							return e
					}
				},
				Go = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				Bo = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts");
			const qo = Go.a.createInitial;
			var Vo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qo(),
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.i: {
							const {
								rteState: e
							} = t.payload;
							return e
						}
						case f.C:
							return Go.a.createInitial();
						case f.O: {
							const n = t.payload;
							return n.editorMode === us.h.RICH_TEXT && n.editorKey === us.g.POST_CREATION ? Go.a.createInitial(n.content) : e
						}
						case p.a:
							return Ro(t) !== He.yb.POST_CREATION ? Go.a.createInitial() : e;
						case Fr.g: {
							const e = t.payload;
							return e.kind === ls.b.RichText ? Go.a.createInitial(e.body) : Go.a.createInitial()
						}
						case fo.b:
						case fo.n: {
							const e = t.payload;
							return Go.a.createInitial(e.contentType === No.a.RTJSON ? Object(Bo.b)(e.body) : void 0)
						}
						default:
							return e
					}
				},
				Ko = Object(s.c)({
					link: xo,
					markdown: Uo,
					media: Fo,
					rte: Vo
				});
			var Ho = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b:
							return t.payload || null;
						case f.C:
						case Fr.g:
						case fo.b:
						case fo.n:
						case f.M:
							return null;
						case p.a:
							return Ro(t) === He.yb.POST_CREATION ? e : null;
						default:
							return e
					}
				},
				Wo = n("./src/reddit/selectors/scheduledPosts/index.ts");
			var Yo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.c:
						return t.payload || null;
					case fo.b:
					case fo.n: {
						const e = t.payload;
						return Object(Wo.m)({
							scheduledPost: e
						}) || null
					}
					case f.C:
						return null;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION ? e : null;
					case Fr.g:
						return t.payload.flair || null;
					default:
						return e
				}
			};
			var Qo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.r:
						return t.payload.type || null;
					case fo.b:
					case fo.n:
					case f.j:
					case f.C:
					case p.a:
						return null;
					default:
						return e
				}
			};
			var zo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.Q:
						return t.payload || !1;
					case fo.b:
					case fo.n:
					case f.C:
						return !1;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case Fr.g:
						return t.payload.isChatPost || !1;
					default:
						return e
				}
			};
			var Jo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.S:
						return t.payload || !1;
					case f.C:
						return !1;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case Fr.g:
						return t.payload.isNSFW || !1;
					case fo.b:
					case fo.n:
						return t.payload.isNsfw;
					default:
						return e
				}
			};
			var Xo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.T:
						return t.payload || !1;
					case f.C:
						return !1;
					case f.M: {
						const {
							name: n
						} = t.payload;
						return !!n && e
					}
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case Fr.g:
						return t.payload.isOriginalContent || !1;
					case fo.b:
					case fo.n:
						return t.payload.isOriginalContent;
					default:
						return e
				}
			};
			var Zo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.U:
						return t.payload || !1;
					case fo.b:
					case fo.n:
					case f.C:
						return !1;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					default:
						return e
				}
			};
			var $o = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fo.b:
					case fo.n:
					case f.C:
						return !1;
					case Fr.n:
						return t.payload;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case Fr.g:
						return t.payload.isPublicLink;
					default:
						return e
				}
			};
			var ea = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.V:
						return t.payload || !1;
					case f.C:
						return !1;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case Fr.g:
						return t.payload.isSpoiler || !1;
					case fo.b:
					case fo.n:
						return t.payload.isSpoiler;
					default:
						return e
				}
			};
			var ta = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.b: {
						const {
							subredditName: e
						} = t.payload;
						return e
					}
					case p.a:
					case f.j:
					case f.r:
					case f.C:
					case l.i:
						return "";
					default:
						return e
				}
			};
			var na = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.c: {
						const {
							username: e
						} = t.payload;
						return e
					}
					case p.a:
					case f.j:
					case f.r:
					case f.C:
					case l.i:
						return "";
					default:
						return e
				}
			};
			var sa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.L:
						case f.M:
							return t.payload;
						case f.K:
						case p.a:
							return null;
						default:
							return e
					}
				},
				ra = n("./src/reddit/actions/polls.ts");
			var oa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ra.a:
							return Object.assign({}, t.payload);
						case fo.b:
						case fo.n:
						case l.i:
						case f.C:
							return null;
						case p.a:
							return Ro(t) !== He.yb.POST_CREATION ? null : e;
						default:
							return e
					}
				},
				aa = n("./src/reddit/helpers/scheduledPosts/index.ts");
			var ca = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.g:
						return t.payload || null;
					case f.C:
					case Fr.g:
					case f.M:
						return null;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION ? e : null;
					case fo.n: {
						const e = t.payload;
						return {
							submitDate: e.publishAt,
							timezoneName: e.clientTimezone,
							frequencyOption: null,
							recurrenceInfo: null
						}
					}
					case fo.b: {
						const e = t.payload;
						return Object.assign({}, Object(aa.h)(e))
					}
					default:
						return e
				}
			};
			var ia = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				const {
					type: n,
					payload: s
				} = t;
				switch (n) {
					case f.W:
						return s || !1;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case fo.b:
					case fo.n:
					case Fr.g:
						return !1;
					default:
						return e
				}
			};
			var da = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.h:
						return t.payload || "";
					case p.a:
						return Ro(t) !== He.yb.POST_CREATION ? "" : e;
					default:
						return e
				}
			};
			var ua = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.a:
						return Ro(t) !== He.yb.POST_CREATION ? null : e;
					case f.C:
						return null;
					case fo.b:
					case fo.n:
						return t.payload.id;
					default:
						return e
				}
			};
			var la = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.C:
						return !0;
					case f.X:
						return t.payload;
					case p.a:
						return Ro(t) !== He.yb.POST_CREATION || e;
					case Fr.g:
						return t.payload.sendReplies;
					case fo.b:
					case fo.n:
						return t.payload.isSendReplies;
					default:
						return e
				}
			};
			const ba = He.Gb.POST;
			var pa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ba,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.C:
							return ba;
						case f.s:
							return He.Gb.CROSSPOST;
						case f.j:
							return t.payload.submissionType || ba;
						case p.a: {
							if (Ro(t) !== He.yb.POST_CREATION) return ba;
							const n = Po(t);
							if (!n) return e;
							const {
								title: s = "",
								url: r,
								text: o = "",
								media: a = !1,
								selftext: c = !1
							} = n, i = s && !o && !c;
							return a ? He.Gb.MEDIA : void 0 !== r || i ? He.Gb.LINK_ONLY : o || c ? He.Gb.POST : e
						}
						case Fr.g: {
							const e = t.payload;
							return ls.a[e.kind]
						}
						case fo.b:
						case fo.n:
							return t.payload.url ? He.Gb.LINK_ONLY : He.Gb.POST;
						default:
							return e
					}
				},
				fa = n("./src/reddit/models/Poll/index.ts");
			const ma = e => e ? e.replace(/\+/g, " ") : "",
				Oa = e => "Should ".concat(e || "username", " become the top moderator?"),
				ga = e => e ? "Should we spin-off to r/".concat(e, "?") : "Should we spin-off to a new community?";
			var _a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.s:
							return t.payload.postTitle || "";
						case f.k:
							return t.payload || "";
						case f.B: {
							const {
								title: n
							} = t.payload;
							return e || (n || "")
						}
						case f.C:
							return "";
						case p.a: {
							if (Ro(t) !== He.yb.POST_CREATION) return "";
							const n = Po(t);
							return n && n.title ? ma(n.title) : e
						}
						case Fr.g:
							return t.payload.title;
						case f.r: {
							const {
								oldType: n,
								type: s
							} = t.payload;
							return s === fa.a.ReplaceTopMod ? Oa("") : s === fa.a.Spinoff ? ga("") : n === fa.a.ReplaceTopMod || n === fa.a.Spinoff ? "" : e
						}
						case l.c: {
							const {
								username: e
							} = t.payload;
							return Oa(e)
						}
						case l.b: {
							const {
								subredditName: e
							} = t.payload;
							return ga(e)
						}
						case f.j: {
							const {
								extra: n
							} = t.payload;
							return !n || n.govType !== fa.a.ReplaceTopMod && n.govType !== fa.a.Spinoff ? e : ""
						}
						case fo.b:
						case fo.n:
							return t.payload.title;
						default:
							return e
					}
				},
				ya = Object(s.c)({
					body: Ko,
					eventSchedule: Ho,
					flair: Yo,
					govType: Qo,
					isChatPost: zo,
					isNSFW: Jo,
					isOC: Xo,
					isPoll: Zo,
					isPublicLink: $o,
					isSpoiler: ea,
					newSubreddit: ta,
					newTopMod: na,
					nextSubreddit: sa,
					polls: oa,
					postSchedule: ca,
					postToTwitter: ia,
					recaptcha: da,
					scheduledPostId: ua,
					sendReplies: la,
					submissionType: pa,
					title: _a
				});
			var ja = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.a:
						return Ro(t) === He.yb.POST_CREATION ? e : null;
					case f.F: {
						const {
							editorMode: e
						} = t.payload;
						return e
					}
					case f.G:
						return null;
					case f.O: {
						const {
							editorMode: e
						} = t.payload;
						return e
					}
					case fo.b:
					case fo.n:
						return t.payload.contentType === No.a.RTJSON ? us.h.RICH_TEXT : us.h.MARKDOWN;
					default:
						return e
				}
			};
			const ha = {
					title: [],
					body: [],
					link: [],
					flair: []
				},
				Ea = (e, t) => {
					const n = (t.fields || []).filter(e => {
						let {
							field: t
						} = e;
						return Object(us.v)(t)
					});
					if (!n.length) return e;
					const s = n.reduce((e, t) => (e[t.field] || (e[t.field] = []), e[t.field].push(t.msg), e), {});
					return Object.assign({}, e, s)
				};
			var Ia = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ha,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.c:
					case f.d:
					case f.e:
						return e[He.kb.BODY] ? Object.assign({}, e, {
							[He.kb.BODY]: []
						}) : e;
					case f.i: {
						const {
							isContentChanged: n
						} = t.payload;
						return e[He.kb.BODY] && n ? Object.assign({}, e, {
							[He.kb.BODY]: []
						}) : e
					}
					case f.k:
						return e[He.kb.TITLE] ? Object.assign({}, e, {
							[He.kb.TITLE]: []
						}) : e;
					case f.J: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n]: []
						})
					}
					case f.o: {
						const n = t.payload;
						return n ? Object.assign({}, e, {
							[n]: []
						}) : ha
					}
					case f.I:
					case f.H: {
						const n = t.payload;
						return Ea(e, n)
					}
					case p.a:
						return Ro(t) !== He.yb.POST_CREATION ? ha : e;
					default:
						return e
				}
			};
			var va = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.b:
					case f.c:
					case f.d:
					case f.e:
					case f.f:
					case f.g:
					case f.k:
					case f.j:
					case f.S:
					case f.T:
					case f.V:
					case Fr.n:
					case f.X:
						return !0;
					case f.i: {
						const {
							isContentChanged: n
						} = t.payload;
						return !!n || e
					}
					case f.N:
					case fo.h:
						return !1;
					case f.P:
						return t.payload;
					case p.a:
						return Ro(t) === He.yb.POST_CREATION && e;
					case f.C:
					case Fr.l:
					case Fr.g:
						return !1;
					default:
						return e
				}
			};
			var Sa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.x:
						return e === t.payload ? null : t.payload || null;
					case r.c:
						return t.payload ? null : e;
					case p.a:
						return Ro(t) !== He.yb.POST_CREATION ? null : e;
					default:
						return e
				}
			};
			const Ta = us.r.Post;
			var Da = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ta,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.y:
							return us.r.Post;
						case f.D:
							return t.payload;
						case Fr.j:
							return us.r.Draft;
						case p.a:
							return Ro(t) !== He.yb.POST_CREATION ? Ta : e;
						default:
							return e
					}
				},
				Ca = Object(s.c)({
					editorMode: ja,
					fieldValidation: Ia,
					isChanged: va,
					modalId: Sa,
					submitMode: Da
				});
			var wa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.F:
						return t.payload.editorMode === us.h.MARKDOWN ? t.payload.postContent || "" : e;
					case f.G:
						return "";
					case f.O:
						return t.payload.editorMode === us.h.MARKDOWN ? t.payload.content || "" : e;
					default:
						return e
				}
			};
			const Aa = Go.a.createInitial;
			var Ra = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Aa(),
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.G:
							return Go.a.createInitial();
						case f.F: {
							const n = t.payload;
							return n.editorMode === us.h.RICH_TEXT && "object" == typeof n.postContent ? Go.a.createInitial(n.postContent, n.mediaMetadata) : e
						}
						case f.O: {
							const n = t.payload;
							return n.editorMode === us.h.RICH_TEXT && n.editorKey === us.g.POST_EDITING ? Go.a.createInitial(n.content) : e
						}
						default:
							return e
					}
				},
				Pa = Object(s.c)({
					markdown: wa,
					rte: Ra
				});
			var ka = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.F: {
							const {
								postId: e
							} = t.payload;
							return e
						}
						case f.G:
							return null;
						default:
							return e
					}
				},
				xa = Object(s.c)({
					draft: Pa,
					postId: ka
				}),
				Na = Object(s.c)({
					api: Do,
					drafts: Ao,
					formData: ya,
					formState: Ca,
					postEditing: xa
				}),
				La = n("./src/reddit/actions/dashboard.ts");
			const Ua = {
				selectedComponent: null,
				subredditPending: !1,
				subredditLoaded: {}
			};
			var Ma = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ua,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case La.a:
						return Object.assign({}, e, {
							selectedComponent: t.payload
						});
					case La.c: {
						const n = t.payload,
							s = e.subredditLoaded[n];
						return Object.assign({}, e, {
							subredditPending: !s,
							subredditLoaded: Object.assign({}, e.subredditLoaded, {
								[n]: s || !1
							})
						})
					}
					case La.b: {
						const n = t.payload;
						return Object.assign({}, e, {
							subredditPending: !1,
							subredditLoaded: Object.assign({}, e.subredditLoaded, {
								[n]: !0
							})
						})
					}
					default:
						return e
				}
			};
			var Fa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.b:
					case Le.c:
						return null;
					case Le.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			var Ga = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.c:
						return !1;
					case Le.b:
						return !0;
					default:
						return e
				}
			};
			var Ba = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.c:
							return !0;
						case Le.b:
						case Le.a:
							return !1;
						default:
							return e
					}
				},
				qa = Object(s.c)({
					error: Fa,
					loaded: Ga,
					pending: Ba
				}),
				Va = Object(s.c)({
					list: qa
				});
			const Ka = {};
			var Ha = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ka,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.b: {
						const {
							discoveryUnits: n
						} = t.payload;
						return gn()(n) ? e : Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			const Wa = {};
			var Ya = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wa,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.b: {
							const {
								discoveryUnits: n
							} = t.payload;
							if (gn()(n)) return e;
							const s = {};
							return In()(n, e => {
								s[Object(vn.f)(e.unitName)] = e.id
							}), Object.assign({}, e, s)
						}
						default:
							return e
					}
				},
				Qa = Object(s.c)({
					api: Va,
					models: Ha,
					nameToId: Ya
				}),
				za = n("./src/reddit/actions/dismissedTruncationList/constants.ts");
			const Ja = [];
			var Xa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ja,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case za.a: {
							const {
								subredditId: n
							} = t.payload;
							return [...e, n]
						}
						default:
							return e
					}
				},
				Za = n("./src/reddit/actions/downToChat.ts");
			var $a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Za.f:
					case Za.g:
						return null;
					case Za.e: {
						const {
							error: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var ec = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Za.b:
						case Za.f:
							return !0;
						case Za.a:
						case Za.c:
						case Za.e:
						case Za.g:
							return !1;
						default:
							return e
					}
				},
				tc = Object(s.c)({
					error: $a,
					pending: ec
				});
			const nc = {};
			var sc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Za.f:
						case Za.e:
						case Za.g: {
							const {
								subredditId: n,
								bannerEnabled: s,
								buttonEnabled: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: {
									bannerEnabled: s,
									buttonEnabled: r
								}
							})
						}
						case Za.c: {
							const {
								subredditId: n,
								bannerEnabled: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									bannerEnabled: s
								})
							})
						}
						case Za.d:
							return Object.assign({}, Is()(e, e => ({
								bannerEnabled: !1,
								buttonEnabled: e.buttonEnabled
							})));
						case Za.a:
						case Za.b:
						default:
							return e
					}
				},
				rc = Object(s.c)({
					api: tc,
					subreddits: sc
				}),
				oc = n("./src/reddit/actions/economics/banners/constants.ts");
			const ac = {
				dismissedBanners: {}
			};
			var cc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ac,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case oc.c: {
							const n = t.payload;
							return Object.assign({}, e, {
								dismissedBanners: Object.assign({}, e.dismissedBanners, {
									[n]: Object.assign({}, e.dismissedBanners[n], {
										pending: !0
									})
								})
							})
						}
						case oc.d: {
							const {
								subredditId: n,
								data: s
							} = t.payload;
							return Object.assign({}, e, {
								dismissedBanners: Object.assign({}, e.dismissedBanners, {
									[n]: Object.assign({}, e.dismissedBanners[n], {
										pending: !1,
										data: s
									})
								})
							})
						}
						case oc.a:
						case oc.b: {
							const {
								subredditId: n,
								bannerType: s
							} = t.payload, r = e.dismissedBanners[n] || {}, o = t.type === oc.a;
							return Object.assign({}, e, {
								dismissedBanners: Object.assign({}, e.dismissedBanners, {
									[n]: Object.assign({}, r, {
										data: Object.assign({}, r.data, {
											[s]: o
										})
									})
								})
							})
						}
						default:
							return e
					}
				},
				ic = n("./src/reddit/models/Badge/managementPage.ts");
			const dc = {
				badgeType: ic.a.Cosmetic,
				view: ic.c.Gallery
			};
			var uc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.c: {
						const {
							badge: n,
							initialView: s
						} = t.payload;
						return n || s ? Object.assign({}, e, {
							badgeType: n ? Object(ic.d)(n.placement) : e.badgeType,
							view: s
						}) : e
					}
					case d.b: {
						const n = t.payload;
						return Object.assign({}, e, {
							badgeType: n
						})
					}
					case d.d: {
						const n = t.payload;
						return Object.assign({}, e, {
							view: n
						})
					}
					case r.b:
						return dc;
					default:
						return e
				}
			};
			var lc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.c:
						return {
							badge: t.payload.badge
						};
					case r.b:
						return null;
					case d.f:
						return t.payload;
					case d.j:
						return t.payload || null;
					default:
						return e
				}
			};
			var bc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case u.a:
						return t.payload;
					case r.b:
						return null;
					default:
						return e
				}
			};
			const pc = {};
			var fc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.e: {
							const {
								emotes: n,
								emoteCollections: s
							} = t.payload.products, r = {};
							return n.forEach(e => {
								const t = e.extra && e.extra.assets,
									n = Object.keys(e.collections || {})[0] || e.title,
									o = s[n];
								r[n] || (r[n] = {
									emotes: {},
									position: o ? o.position : 0,
									title: o ? o.title : e.title
								}), t && Object.keys(t).forEach(s => {
									const o = t[s];
									r[n].emotes[s] = {
										id: s,
										emoji: o.emoji,
										extra: {
											rtDescription: e.extra && e.extra.rtDescription
										},
										fullId: "emote|".concat(e.id, "|").concat(s),
										imageType: o.emoji.type,
										sticker: o.sticker
									}
								})
							}), Object.assign({}, e, {
								[t.payload.subredditId]: Object.keys(r).map(e => r[e]).sort((e, t) => e.position - t.position)
							})
						}
						default:
							return e
					}
				},
				mc = n("./src/reddit/actions/economics/ftue/constants.ts");
			const Oc = {
				tippingHighlightViewed: null,
				topTippersViewed: null
			};
			var gc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Oc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mc.a:
						return Object.assign({}, e, {
							tippingHighlightViewed: !0
						});
					case mc.b:
						return Object.assign({}, e, {
							tippingHighlightViewed: !0,
							topTippersViewed: !0
						});
					default:
						return e
				}
			};
			const _c = {};
			var yc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _c,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.e: {
							const n = t.payload.products.giphy.length > 0;
							return Object.assign({}, e, {
								[t.payload.subredditId]: {
									hasGifProduct: n
								}
							})
						}
						default:
							return e
					}
				},
				jc = n("./src/reddit/actions/economics/me/constants.ts");
			const hc = {
				fetched: !1,
				data: {}
			};
			var Ec = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jc.a: {
							const n = t.payload;
							return {
								fetched: !0,
								data: Object.assign({}, e.data, n)
							}
						}
						case d.h: {
							const {
								subredditId: n
							} = t.payload;
							return e.data.specialMemberships && e.data.specialMemberships[n] ? Object.assign({}, e, {
								data: Object.assign({}, e.data, {
									specialMemberships: Object.assign({}, e.data.specialMemberships, {
										[n]: Object.assign({}, e.data[n], {
											settings: {
												renew: !1
											}
										})
									})
								})
							}) : e
						}
						default:
							return e
					}
				},
				Ic = n("./src/reddit/reducers/economics/paymentSystems/index.ts");
			const vc = {
				fetched: !1,
				data: null
			};
			var Sc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jc.b:
							return {
								fetched: !0, data: e.data
							};
						case jc.c:
							return {
								fetched: !0, data: t.payload
							};
						default:
							return e
					}
				},
				Tc = n("./src/reddit/reducers/economics/subredditPremium/index.ts"),
				Dc = n("./src/reddit/actions/economics/tips/constants.ts"),
				Cc = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const wc = {};
			var Ac = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Dc.a: {
							const {
								subredditId: n,
								tipData: s
							} = t.payload, r = e[n] || {};
							return Object.assign({}, e, {
								[n]: Object.assign({}, r, s)
							})
						}
						case u.b: {
							const {
								accountId: n,
								accountUsername: s,
								anonymous: r,
								amount: o,
								contentId: a,
								subredditId: c
							} = t.payload, i = e[c] || {}, d = i[a] || {}, u = d.amounts || {
								usdr: {
									amount: "0",
									users: {}
								}
							}, l = u.usdr, b = l.amount || "0", p = String(parseInt(b) + parseInt(o)), f = u.usdr.users || {}, {
								anonymous: m = {
									amount: "0",
									includesUser: !1,
									numUsers: 0
								}
							} = f, O = Cc(f, ["anonymous"]), g = r ? Object.assign({}, O, {
								anonymous: {
									amount: String(parseInt(m.amount) + parseInt(o)),
									includesUser: !0,
									numUsers: m.includesUser ? m.numUsers : m.numUsers + 1
								}
							}) : Object.assign({}, f, {
								[n]: Object.assign({}, f[n] || {}, {
									amount: f[n] ? String(parseInt(f[n].amount || "0") + parseInt(o)) : o,
									username: s
								})
							});
							return Object.assign({}, e, {
								[c]: Object.assign({}, i, {
									[a]: Object.assign({}, d, {
										amounts: Object.assign({}, u, {
											usdr: Object.assign({}, l, {
												amount: p,
												users: g
											})
										})
									})
								})
							})
						}
						default:
							return e
					}
				},
				Rc = Object(s.c)({
					banners: cc,
					currentBadgeManagementScreen: uc,
					currentModalArgs: lc,
					currentPaymentTarget: bc,
					emotes: fc,
					ftue: gc,
					gifs: yc,
					me: Ec,
					paymentSystems: Ic.b,
					pointsCopy: Sc,
					subredditPremium: Tc.b,
					tipDetails: Ac
				}),
				Pc = n("./src/reddit/actions/emoji.ts"),
				kc = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const xc = {};
			var Nc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Pc.h: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Pc.g: {
							const {
								subredditId: n
							} = t.payload, s = n;
							e[s];
							return kc(e, ["symbol" == typeof s ? s : s + ""])
						}
						case Pc.f: {
							const {
								subredditId: n
							} = t.payload, s = n;
							e[s];
							return kc(e, ["symbol" == typeof s ? s : s + ""])
						}
						default:
							return e
					}
				},
				Lc = Object(s.c)({
					pending: Nc
				}),
				Uc = Object(s.c)({
					list: Lc
				}),
				Mc = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Fc = {};
			var Gc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Pc.f:
						case Pc.c:
							return e;
						case Pc.g: {
							const {
								data: e
							} = t.payload;
							return e
						}
						case Pc.d: {
							const {
								emojiName: n,
								subredditId: s
							} = t.payload, r = e[s].emojis, o = n, a = (r[o], Mc(r, ["symbol" == typeof o ? o : o + ""]));
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], {
									emojis: a
								})
							})
						}
						case Pc.i: {
							const n = t.payload,
								s = e[n.subredditId].emojis,
								r = {
									url: n.url,
									name: n.name,
									userFlairAllowed: n.userFlairAllowed,
									postFlairAllowed: n.postFlairAllowed,
									modFlairOnly: n.modFlairOnly
								},
								o = Object.assign({}, s, {
									[n.name]: r
								});
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, e[n.subredditId], {
									emojis: o
								})
							})
						}
						case Pc.e: {
							const {
								emojiName: n,
								isSnoomoji: s,
								settings: r,
								subredditId: o
							} = t.payload, a = s ? "snoomojis" : "emojis", c = e[o][a], i = Object.assign({}, c, {
								[n]: Object.assign({}, c[n], r)
							});
							return Object.assign({}, e, {
								[o]: Object.assign({}, e[o], {
									[a]: i
								})
							})
						}
						default:
							return e
					}
				},
				Bc = Object(s.c)({
					api: Uc,
					models: Gc
				}),
				qc = n("./src/reddit/actions/experiments.ts");
			const Vc = /^experiment_(.*)$/i,
				Kc = e => {
					const t = e.match(Vc);
					if (null !== t) return t[1]
				},
				Hc = {};
			var Wc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.a: {
							const n = Po(t);
							if (!n) return e;
							const s = {};
							for (const e in n) {
								const t = Kc(e);
								t && (s[t.toLowerCase()] = n[e] || "")
							}
							return gn()(s) ? e : Object.assign({}, e, s)
						}
						case qc.b: {
							const {
								experimentName: n,
								override: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[n]: s || ""
							}) : e
						}
						default:
							return e
					}
				},
				Yc = n("./src/reddit/actions/externalAccount.ts");
			const Qc = {};
			var zc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yc.e:
					case Yc.f: {
						const {
							provider: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Yc.d: {
						const {
							provider: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Jc = {};
			var Xc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yc.e: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Yc.f:
						case Yc.d: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Zc = Object(s.c)({
					error: zc,
					pending: Xc
				});
			const $c = {};
			var ei = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yc.l:
					case Yc.k: {
						const {
							provider: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Yc.j: {
						const {
							provider: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const ti = {};
			var ni = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ti,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yc.b: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Yc.c:
						case Yc.a: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				si = Object(s.c)({
					error: ei,
					pending: ni
				});
			const ri = {};
			var oi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ri,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yc.i:
					case Yc.h: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Yc.g: {
						const {
							subredditName: n,
							apiError: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const ai = {};
			var ci = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ai,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yc.h: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const ii = {};
			var di = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ii,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yc.i: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Yc.h:
						case Yc.g: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				ui = Object(s.c)({
					error: oi,
					fetched: ci,
					pending: di
				});
			const li = {};
			var bi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : li,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yc.l:
					case Yc.k: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Yc.j: {
						const {
							username: n,
							apiError: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const pi = {};
			var fi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pi,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yc.l: {
							const {
								username: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Yc.k:
						case Yc.j: {
							const {
								username: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				mi = Object(s.c)({
					error: bi,
					pending: fi
				}),
				Oi = Object(s.c)({
					connect: Zc,
					disconnect: si,
					user: mi,
					subreddit: ui
				});
			const gi = {};
			var _i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yc.h: {
						const {
							subredditName: n,
							accountsData: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const yi = {};
			var ji = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yi,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yc.k: {
							const {
								username: n,
								accountsData: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case Yc.c: {
							const {
								username: n,
								provider: s
							} = t.payload, r = e[n];
							return r && r[s] ? Object.assign({}, e, {
								[n]: Ss()(r, s)
							}) : e
						}
						default:
							return e
					}
				},
				hi = Object(s.c)({
					api: Oi,
					user: ji,
					subreddit: _i
				}),
				Ei = n("./src/reddit/featureFlags/index.ts");
			const Ii = new Set(["0", "disabled", "false", "off", ""]);
			var vi = e => !Ii.has(e.toLowerCase());
			const Si = Ei.a.reduce((e, t) => (e[t.toLowerCase()] = t, e), {}),
				Ti = Ei.a.reduce((e, t) => (e[t] = null, e), {});
			var Di = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ti,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.a: {
							const n = Po(t);
							if (void 0 !== n) {
								const t = {};
								for (const e in n) {
									const s = Object(Ei.g)(e);
									if (s) {
										const r = Si[s.toLowerCase()];
										if (r) {
											const s = n[e],
												o = "string" != typeof s || vi(s);
											t[r] = o
										}
									}
								}
								if (Object.keys(t).length > 0) return Object.assign({}, e, t)
							}
							return e
						}
						case Ei.b: {
							const {
								featureName: n,
								currentValue: s
							} = t.payload;
							return s === e[n] ? e : Object.assign({}, e, {
								[n]: s
							})
						}
						case Ei.c: {
							const {
								featureName: n,
								currentValue: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !s
							})
						}
						default:
							return e
					}
				},
				Ci = Object(s.c)({
					overrides: Di
				});
			var wi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g:
					case te.i:
						return null;
					case te.f:
						return t.payload;
					default:
						return e
				}
			};
			var Ai = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.i:
							return !0;
						case te.g:
						case te.f:
							return !1;
						default:
							return e
					}
				},
				Ri = Object(s.c)({
					error: wi,
					pending: Ai
				});
			const Pi = {};
			var ki = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g:
					case te.k: {
						const {
							subredditId: n,
							flairedUsers: s
						} = t.payload;
						return Pe()(Object.assign({}, e), {
							[n]: s
						})
					}
					case te.c: {
						const {
							subredditId: n,
							userName: s
						} = t.payload, r = Ss()(e[n], s);
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case te.a:
					case te.b:
					case te.h:
						const {
							subredditId: n, userName: s, applied: r
						} = t.payload;
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								[s]: r
							})
						}) : e;
					default:
						return e
				}
			};
			const xi = {};
			var Ni = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g: {
						const {
							key: n,
							pageInfo: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			var Li = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.l:
					case te.k:
						return null;
					case te.j:
						return t.payload;
					default:
						return e
				}
			};
			var Ui = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.l:
							return !0;
						case te.k:
						case te.j:
							return !1;
						default:
							return e
					}
				},
				Mi = Object(s.c)({
					error: Li,
					pending: Ui
				});
			var Fi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case te.c: {
							const {
								userName: n
							} = t.payload;
							return e === n ? null : e
						}
						default:
							return e
					}
				},
				Gi = Object(s.c)({
					api: Mi,
					result: Fi
				});
			const Bi = {};
			var qi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bi,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.g: {
							const {
								key: n,
								userOrder: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case te.a: {
							const {
								key: n,
								userName: s
							} = t.payload;
							if (!n) return e;
							if (!e[n].includes(s)) {
								const t = [...e[n], s];
								return Object.assign({}, e, {
									[n]: t
								})
							}
							return e
						}
						case te.c: {
							const {
								userName: n
							} = t.payload, s = {};
							for (const t in e) s[t] = e[t].filter(e => e !== n);
							return s
						}
						default:
							return e
					}
				},
				Vi = Object(s.c)({
					api: Ri,
					models: ki,
					pageInfo: Ni,
					search: Gi,
					userOrder: qi
				}),
				Ki = n("./src/reddit/actions/focusedVerticals/constants.ts");
			const Hi = {
				focusedVerticalGqlError: null
			};
			var Wi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ki.h:
					case Ki.g:
					case Ki.c:
						return Object.assign({}, e, {
							focusedVerticalGqlError: null
						});
					case Ki.e:
						return Object.assign({}, e, {
							focusedVerticalGqlError: t.payload
						});
					default:
						return e
				}
			};
			const Yi = {
				focusedVerticalGqlPending: !1
			};
			var Qi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yi,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ki.h:
							return Object.assign({}, e, {
								focusedVerticalGqlPending: !0
							});
						case Ki.e:
						case Ki.g:
						case Ki.c:
							return Object.assign({}, e, {
								focusedVerticalGqlPending: !1
							});
						default:
							return e
					}
				},
				zi = Object(s.c)({
					error: Wi,
					pending: Qi
				});
			var Ji = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ki.g:
					case Ki.c:
						return t.payload.category || "";
					default:
						return e
				}
			};
			const Xi = {
				dismissed: !0
			};
			var Zi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ki.j:
						return {
							dismissed: !1
						};
					case Ki.i:
						return {
							dismissed: !0
						};
					default:
						return e
				}
			};
			var $i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ki.g:
					case Ki.c:
						return t.payload.interactedSubredditIds || null;
					default:
						return e
				}
			};
			var ed = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ki.g:
					case Ki.c:
					case Ki.f:
						return t.payload.lastLoadedEnv || null;
					default:
						return e
				}
			};
			var td = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ki.g:
						case Ki.c:
							return t.payload.recommendedSubredditIds || null;
						default:
							return e
					}
				},
				nd = Object(s.c)({
					api: zi,
					components: Zi,
					interactedSubredditIds: $i,
					recommendedSubredditIds: td,
					category: Ji,
					lastLoadedEnv: ed
				});
			Object(Ke.a)("FONTS_FONT_FILES_PARSED");
			const sd = [];
			var rd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "FONTS_FONT_FILES_PARSED":
						return t.payload.fonts;
					default:
						return e
				}
			};
			var od = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.n:
						return t.payload;
					case ge.c:
					case p.a:
					case ge.I:
					case ge.r:
						return null;
					default:
						return e
				}
			};
			var ad = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.c:
					case p.a:
					case ge.r:
					case ge.n:
						return !1;
					case ge.o:
						return !0;
					default:
						return e
				}
			};
			var cd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.o:
						case ge.c:
						case p.a:
						case ge.r:
						case ge.n:
							return !1;
						case ge.s:
							return !0;
						default:
							return e
					}
				},
				id = Object(s.c)({
					error: od,
					pending: ad,
					showLoader: cd
				});
			var dd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				const n = t.payload;
				switch (t.type) {
					case ge.H:
					case ge.I:
						return n.gildModalId;
					case ge.r:
					case p.a:
					case ge.c:
						return null;
					default:
						return e
				}
			};
			var ud = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				const n = t.payload;
				switch (t.type) {
					case ge.H:
					case ge.I:
						return n.thingId;
					case ge.r:
					case p.a:
					case ge.c:
						return null;
					default:
						return e
				}
			};
			var ld = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.v:
						return t.payload;
					case ge.u:
					case ge.I:
						return null;
					default:
						return e
				}
			};
			var bd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.p:
						return t.payload;
					case ge.I:
						return !1;
					default:
						return e
				}
			};
			var pd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.q:
						return t.payload;
					case ge.I:
						return !1;
					default:
						return e
				}
			};
			var fd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.H:
						return !0;
					default:
						return e
				}
			};
			var md = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.t:
						return t.payload;
					case ge.I:
						return "";
					default:
						return e
				}
			};
			const Od = Ne.m;
			var gd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Od,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.L:
							return t.payload;
						case ge.I: {
							const {
								award: e
							} = t.payload;
							return e || Od
						}
						default:
							return e
					}
				},
				_d = Object(s.c)({
					api: id,
					gildModalId: dd,
					gildModalThingId: ud,
					includeMessage: bd,
					isAnonymous: pd,
					isIframed: fd,
					message: md,
					giveAwardTooltipThingId: ld,
					selectedAward: gd
				});
			var yd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.w:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg || "An unknown error occurred";
					case ge.d:
					case p.a:
					case ge.J:
					case ge.B:
						return null;
					default:
						return e
				}
			};
			var jd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.d:
						case p.a:
						case ge.B:
						case ge.w:
							return !1;
						case ge.x:
							return !0;
						default:
							return e
					}
				},
				hd = Object(s.c)({
					error: yd,
					pending: jd
				});
			var Ed = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.J:
							return t.payload;
						case p.a:
						case ge.d:
						case ge.B:
							return "";
						default:
							return e
					}
				},
				Id = Object(s.c)({
					api: hd,
					givePremiumModalAccountName: Ed
				}),
				vd = n("./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts"),
				Sd = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				Td = n("./src/reddit/actions/goldPurchaseModals/pennyPurchaseModal.ts"),
				Dd = n("./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts");
			var Cd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.b: {
						const {
							cardName: e
						} = t.payload;
						return e
					}
					case Sd.l:
						return t.payload !== He.tb ? "" : e;
					case vd.a:
					case Td.a:
					case Dd.a:
					case Sd.c:
					case p.a:
						return "";
					default:
						return e
				}
			};
			var wd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.o: {
						const {
							error: n,
							elementType: s
						} = t.payload;
						return "cardCvc" === s ? n && n.message || "" : e
					}
					case Sd.l:
						return t.payload !== He.tb ? "" : e;
					case vd.a:
					case Td.a:
					case Dd.a:
					case Sd.c:
					case p.a:
						return "";
					default:
						return e
				}
			};
			var Ad = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.o: {
						const {
							error: n,
							elementType: s
						} = t.payload;
						return "cardExpiry" === s ? n && n.message || "" : e
					}
					case Sd.l:
						return t.payload !== He.tb ? "" : e;
					case vd.a:
					case Td.a:
					case Dd.a:
					case Sd.c:
					case p.a:
						return "";
					default:
						return e
				}
			};
			var Rd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.o: {
						const {
							error: n,
							elementType: s
						} = t.payload;
						return "cardNumber" === s ? n && n.message || "" : e
					}
					case Sd.l:
						return t.payload !== He.tb ? "" : e;
					case vd.a:
					case Td.a:
					case Dd.a:
					case Sd.c:
					case p.a:
						return "";
					default:
						return e
				}
			};
			var Pd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.a:
						return t.payload.message || e;
					case Sd.b:
						return "";
					case Sd.l:
						return t.payload !== He.tb ? "" : e;
					case vd.a:
					case Td.a:
					case Dd.a:
					case Sd.c:
					case p.a:
						return "";
					default:
						return e
				}
			};
			var kd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sd.o: {
							const {
								error: n,
								elementType: s
							} = t.payload;
							return "postalCode" === s ? n && n.message || "" : e
						}
						case Sd.l:
							return t.payload !== He.tb ? "" : e;
						case vd.a:
						case Td.a:
						case Dd.a:
						case Sd.c:
						case p.a:
							return "";
						default:
							return e
					}
				},
				xd = Object(s.c)({
					cardCvc: wd,
					cardExpiry: Ad,
					cardNumber: Rd,
					nameOnCard: Pd,
					postalCode: kd
				});
			const Nd = He.ub;
			var Ld = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vd.b:
					case Td.b:
					case Dd.b:
						return Nd;
					case Sd.l:
						return t.payload;
					default:
						return e
				}
			};
			var Ud = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.j:
						return t.payload || e;
					case Sd.l: {
						const {
							method: n
						} = t.payload;
						return n === He.ub ? null : e
					}
					case vd.b:
					case Td.b:
					case Dd.b:
					case ge.I:
						return null;
					default:
						return e
				}
			};
			var Md = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Dd.b:
							return "";
						case Dd.c: {
							const e = t.payload;
							return e.body && e.body.passthrough ? e.body.passthrough : ""
						}
						default:
							return e
					}
				},
				Fd = Object(s.c)({
					errorMessage: Ud,
					passthrough: Md
				});
			var Gd = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.r:
						return !e;
					case Sd.l:
						return t.payload !== He.tb || e;
					case vd.a:
					case Td.a:
					case Dd.a:
					case p.a:
						return !0;
					default:
						return e
				}
			};
			const Bd = [];
			var qd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.e:
						return t.payload;
					case Sd.d: {
						const n = t.payload;
						return e.filter(e => e.cardId !== n)
					}
					default:
						return e
				}
			};
			var Vd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.k:
						return !0;
					case Sd.e:
						return !1;
					default:
						return e
				}
			};
			var Kd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.a:
					case Sd.p:
						return t.payload.message || e;
					case Sd.n:
						return t.payload;
					case Sd.o:
					case Sd.b:
					case Sd.q:
						return null;
					case Sd.l:
						return t.payload === He.tb ? null : e;
					default:
						return e
				}
			};
			var Hd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sd.a:
						case Sd.n:
						case Sd.p:
							return !1;
						case Sd.l:
							return t.payload !== He.tb && e;
						case Sd.q:
							return !0;
						default:
							return e
					}
				},
				Wd = Object(s.c)({
					errorMessage: Kd,
					pending: Hd
				});
			var Yd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sd.m:
							return t.payload;
						case Sd.d:
							return t.payload === e ? null : e;
						default:
							return e
					}
				},
				Qd = Object(s.c)({
					cardName: Cd,
					cardValidation: xd,
					paymentMethod: Ld,
					paypal: Fd,
					rememberCard: Gd,
					savedCards: qd,
					savedCardsPending: Vd,
					stripeToken: Wd,
					useSavedCard: Yd
				});
			var zd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "selectPayment",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Dd.b:
						return "selectPayment";
					case Sd.i:
						return "paymentCompleted";
					default:
						return e
				}
			};
			var Jd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Dd.b:
							return !0;
						case p.a:
						case Dd.a:
							return !1;
						default:
							return e
					}
				},
				Xd = Object(s.c)({
					activePage: zd,
					showModal: Jd
				});
			var Zd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.h:
						return t.payload.activeSaleConfig;
					default:
						return e
				}
			};
			const $d = [];
			var eu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.h:
						return t.payload.coinPackages;
					default:
						return e
				}
			};
			const tu = [];
			var nu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.h:
						return t.payload.dealCoinPackages;
					default:
						return e
				}
			};
			var su = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.h:
					case Sd.g:
						return null;
					case Sd.f:
						return t.payload;
					default:
						return e
				}
			};
			var ru = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sd.f:
					case Sd.h:
						return !1;
					case Sd.g:
						return !0;
					default:
						return e
				}
			};
			const ou = [];
			var au = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ou,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sd.h:
							return t.payload.premiumPackages;
						default:
							return e
					}
				},
				cu = Object(s.c)({
					activeSaleConfig: Zd,
					coinPackages: eu,
					dealCoinPackages: nu,
					errorMessage: su,
					pending: ru,
					premiumPackages: au
				});
			var iu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "selectPayment",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vd.b:
					case Td.b:
						return "selectPayment";
					case Sd.i:
						return "paymentCompleted";
					default:
						return e
				}
			};
			var du = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vd.a:
					case Td.a:
					case ge.c:
					case ge.r:
						return null;
					case vd.c:
					case Td.c:
						return t.payload && t.payload.thingId ? t.payload.thingId : e;
					default:
						return e
				}
			};
			var uu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vd.b: {
						const {
							packageId: e
						} = t.payload;
						return e
					}
					case Sd.i:
					case vd.a:
						return null;
					default:
						return e
				}
			};
			var lu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vd.b:
						case Td.b:
							return !0;
						case ge.I:
						case p.a:
						case vd.a:
						case Td.a:
							return !1;
						default:
							return e
					}
				},
				bu = Object(s.c)({
					activePage: iu,
					gildThingId: du,
					packageId: uu,
					showModal: lu
				});
			var pu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vd.d: {
							const {
								packageId: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				fu = Object(s.c)({
					packageId: pu
				});
			var mu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sd.s:
						case Sd.u:
							return !1;
						case Sd.t:
							return !0;
						default:
							return e
					}
				},
				Ou = Object(s.c)({
					pending: mu
				}),
				gu = Object(s.c)({
					payment: Qd,
					premiumPurchaseModal: Xd,
					purchaseCatalog: cu,
					purchaseModal: bu,
					targetedOffer: fu,
					updateCardModal: Ou
				}),
				_u = n("./src/reddit/actions/header.ts"),
				yu = n("./src/reddit/actions/overlayEvents.ts");
			var ju = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _u.a:
							return !1;
						case _u.b:
							return !0;
						case _u.c:
							return !e;
						case yu.b:
							return !1;
						default:
							return e
					}
				},
				hu = Object(s.c)({
					isSubscriptionsDropdownOpen: ju
				}),
				Eu = n("./src/reddit/actions/imageUploads.ts");
			const Iu = {};
			var vu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Iu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Eu.d: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.id]: n
							})
						}
						case Eu.c:
						case Eu.e:
						case Eu.b: {
							const n = t.payload;
							return e[n.id] ? Object.assign({}, e, {
								[n.id]: n
							}) : e
						}
						case Eu.a: {
							const n = t.payload;
							if (!e[n.id]) return e;
							const s = Object.assign({}, e);
							return delete s[n.id], s
						}
						default:
							return e
					}
				},
				Su = n("./src/reddit/actions/interceptedAction.ts");
			var Tu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Su.a:
							return t.payload;
						case Su.b:
							return null;
						default:
							return e
					}
				},
				Du = n("./src/reddit/actions/changeUsername.ts");
			var Cu = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Du.a:
							return !1;
						case Du.b:
							return !0;
						default:
							return e
					}
				},
				wu = n("./src/reddit/actions/emailVerificationTooltip.ts");
			var Au = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wu.a:
							return !e;
						default:
							return e
					}
				},
				Ru = n("./src/reddit/actions/moderatingSubreddits.ts");
			var Pu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ru.a: {
							if (e) return e;
							const n = t.payload;
							return Object.keys(n).some(e => !0 === n[e].posts)
						}
						case ie.c:
						case Fe.b:
						case se.b:
						case Be.b: {
							if (e) return e;
							const {
								payload: n
							} = t;
							return n.subredditPermissions && n.subreddits ? n.subredditPermissions.posts : e
						}
						case ne.i:
						case ne.f:
						case ne.m:
						case ne.p:
						case ne.v: {
							if (e) return e;
							const {
								response: n
							} = t.payload, {
								moderatingSubreddits: s,
								moderatingProfiles: r
							} = n;
							let o = Object.keys(s).some(e => !0 === s[e].posts);
							if (!o) {
								o = Object.keys(r).some(e => !0 === s[e].posts)
							}
							return o
						}
						default:
							return e
					}
				},
				ku = n("./src/reddit/actions/jsApi.ts");
			const xu = [];
			var Nu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ku.a: {
							const n = t.payload;
							return -1 === e.indexOf(n) && (e = [...e, n]).sort(), e
						}
						default:
							return e
					}
				},
				Lu = n("./src/reddit/actions/leaderboard/constants.ts"),
				Uu = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Mu = {};
			var Fu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Lu.b: {
							const {
								key: n,
								data: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case Lu.c:
						case Lu.d: {
							const {
								key: n
							} = t.payload, s = n;
							e[s];
							return Uu(e, ["symbol" == typeof s ? s : s + ""])
						}
						default:
							return e
					}
				},
				Gu = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Bu = {};
			var qu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Lu.b:
						case Lu.d: {
							const {
								key: n
							} = t.payload, s = n;
							e[s];
							return Gu(e, ["symbol" == typeof s ? s : s + ""])
						}
						case Lu.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						default:
							return e
					}
				},
				Vu = Object(s.c)({
					error: Fu,
					pending: qu
				});
			const Ku = {};
			var Hu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ku,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Lu.a: {
						const {
							dateRange: n,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Wu = {};
			var Yu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Lu.d: {
							const {
								key: n,
								data: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				Qu = Object(s.c)({
					api: Vu,
					dateRangeSelection: Hu,
					models: Yu
				});
			var zu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.a: {
						const {
							listingKey: n
						} = t.payload;
						return n || e
					}
					default:
						return e
				}
			};
			const Ju = {};
			var Xu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ju,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case We.b:
					case We.c:
					case ce.b:
					case ce.c: {
						const {
							key: n,
							type: s
						} = t.payload;
						return -1 === s.indexOf(He.Kb.Subreddits) && -1 === s.indexOf(He.Kb.Users) ? e : Object.assign({}, e, {
							[n]: null
						})
					}
					case We.a:
					case ce.a: {
						const {
							key: n,
							error: s,
							type: r
						} = t.payload;
						return -1 === r.indexOf(He.Kb.Subreddits) && -1 === r.indexOf(He.Kb.Users) ? e : Object.assign({}, e, {
							[n]: s
						})
					}
					case Le.f:
					case Le.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Le.d: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Zu = {};
			var $u = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.b:
						case ce.b: {
							const {
								key: n,
								type: s
							} = t.payload;
							return -1 === s.indexOf(He.Kb.Subreddits) && -1 === s.indexOf(He.Kb.Users) ? e : Object.assign({}, e, {
								[n]: !0
							})
						}
						case We.c:
						case We.a:
						case ce.c:
						case ce.a: {
							const {
								key: n,
								type: s
							} = t.payload;
							return -1 === s.indexOf(He.Kb.Subreddits) && -1 === s.indexOf(He.Kb.Users) ? e : Object.assign({}, e, {
								[n]: !1
							})
						}
						case Le.f: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Le.e:
						case Le.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				el = Object(s.c)({
					error: Xu,
					pending: $u
				});
			const tl = {};
			var nl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case We.c: {
						const {
							fetchedToken: n,
							key: s,
							type: r
						} = t.payload;
						if (-1 === r.indexOf(He.Kb.Subreddits) && -1 === r.indexOf(He.Kb.Users)) return e;
						const o = e[s];
						return Object.assign({}, e, {
							[s]: Object.assign({}, o, {
								[n]: !0
							})
						})
					}
					case Le.e: {
						const {
							fetchedToken: n,
							key: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								[n]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const sl = {};
			var rl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.c: {
							const {
								key: n,
								listingOrder: s,
								type: r
							} = t.payload;
							return -1 === r.indexOf(He.Kb.Subreddits) && -1 === r.indexOf(He.Kb.Users) ? e : Object.assign({}, e, {
								[n]: e[n].concat(s)
							})
						}
						case ce.c: {
							const {
								key: n,
								listingOrder: s,
								type: r
							} = t.payload;
							return -1 === r.indexOf(He.Kb.Subreddits) && -1 === r.indexOf(He.Kb.Users) ? e : Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				ol = n("./src/lib/omitKey/index.ts");
			const al = {};
			var cl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : al,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.c:
						case ce.c: {
							const {
								key: n,
								tokens: s,
								type: r
							} = t.payload;
							return -1 === r.indexOf(He.Kb.Subreddits) && -1 === r.indexOf(He.Kb.Users) ? e : s.listings ? Object.assign({}, e, {
								[n]: {
									token: s.listings
								}
							}) : Object(ol.a)(e, n)
						}
						case Le.e: {
							const {
								key: n,
								token: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: {
									token: s
								}
							})
						}
						default:
							return e
					}
				},
				il = Object(s.c)({
					api: el,
					identifiers: rl,
					fetchedTokens: nl,
					loadMore: cl
				}),
				dl = n("./src/reddit/actions/eventPosts/constants.ts"),
				ul = n("./src/reddit/actions/otherDiscussions/constants.ts"),
				ll = n("./src/reddit/actions/pages/topic.ts");
			const bl = {};
			var pl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.h:
						case se.g:
						case se.l:
						case se.k:
						case ie.d:
						case ie.c:
						case Ue.c:
						case Ue.b:
						case Ge.e:
						case Ge.f:
						case Ge.i:
						case Ge.h:
						case Me.s:
						case Me.r:
						case ul.b:
						case ul.c:
						case oe.f:
						case oe.e:
						case oe.c:
						case oe.b:
						case de.f:
						case de.e:
						case qe.f:
						case qe.e:
						case ue.j:
						case ll.f:
						case ll.e:
						case ll.c:
						case ll.b:
						case ue.i:
						case dl.e:
						case dl.c:
						case dl.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: null
							})
						}
						case ce.b:
						case ce.c:
						case We.b:
						case We.c: {
							const {
								key: n,
								type: s
							} = t.payload;
							return -1 === s.indexOf(He.Kb.Posts) ? e : Object.assign({}, e, {
								[n]: null
							})
						}
						case se.f:
						case se.j:
						case ie.a:
						case Ue.a:
						case Ge.g:
						case Me.q:
						case ul.a:
						case ue.h:
						case de.d:
						case qe.d:
						case oe.d:
						case oe.a:
						case ll.d:
						case ll.a:
						case dl.b: {
							const {
								key: n,
								error: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case ce.a:
						case We.a: {
							const {
								error: n,
								key: s,
								type: r
							} = t.payload;
							return -1 === r.indexOf(He.Kb.Posts) ? e : Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				fl = n("./src/reddit/actions/subreddit/constants.ts");
			const ml = {};
			var Ol = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ml,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.h:
						case se.l:
						case oe.f:
						case qe.f:
						case ie.d:
						case Ue.c:
						case Ge.f:
						case Ge.i:
						case Me.s:
						case ul.c:
						case de.f:
						case oe.c:
						case ue.j:
						case ll.c:
						case dl.e: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case ce.b:
						case We.b: {
							const {
								key: n,
								type: s
							} = t.payload;
							return -1 === s.indexOf(He.Kb.Posts) ? e : Object.assign({}, e, {
								[n]: !0
							})
						}
						case se.g:
						case se.f:
						case se.j:
						case se.k:
						case qe.d:
						case qe.e:
						case oe.d:
						case oe.e:
						case ie.c:
						case ie.a:
						case Ue.b:
						case Ue.a:
						case Ge.e:
						case Ge.d:
						case Ge.h:
						case Ge.g:
						case Me.r:
						case Me.q:
						case de.d:
						case de.e:
						case oe.a:
						case oe.b:
						case fl.h:
						case ul.b:
						case ul.a:
						case ue.i:
						case ue.h:
						case ll.b:
						case ll.a:
						case dl.c:
						case dl.b:
						case dl.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case fl.p: {
							if (!t.payload || !t.payload.length) return e;
							const n = {};
							for (const e of t.payload) {
								n[e.key] = !1
							}
							return Object.assign({}, e, n)
						}
						case ce.c:
						case ce.a:
						case We.c:
						case We.a: {
							const {
								key: n,
								type: s
							} = t.payload;
							return -1 === s.indexOf(He.Kb.Posts) ? e : Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				gl = Object(s.c)({
					error: pl,
					pending: Ol
				}),
				_l = n("./src/reddit/actions/postList.ts"),
				yl = n("./node_modules/lodash/omitBy.js"),
				jl = n.n(yl);

			function hl(e, t) {
				return t = t.toLowerCase(), jl()(e, (e, n) => n === t || n.startsWith("".concat(t, "--[")))
			}
			const El = {};
			var Il = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : El,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _l.a: {
						const {
							listingKey: n,
							listingName: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case _l.b: {
						const {
							listingKey: n
						} = t.payload;
						return n in e ? Ss()(e, [n]) : e
					}
					case ie.b:
						return hl(e, t.payload);
					default:
						return e
				}
			};
			const vl = {};
			var Sl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.e:
					case se.g:
					case se.k:
					case ie.c:
					case oe.e:
					case ll.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {}
						})
					}
					case Ue.b:
					case Ge.h:
					case Me.r:
					case de.e:
					case oe.b:
					case ue.i:
					case ll.b: {
						const {
							key: n,
							fetchedToken: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								[s]: !0
							})
						})
					}
					case We.c: {
						const {
							fetchedToken: n,
							key: s,
							type: r
						} = t.payload;
						if (r.indexOf(He.Kb.Posts) > -1) {
							const t = e[s];
							return Object.assign({}, e, {
								[s]: Object.assign({}, t, {
									[n]: !0
								})
							})
						}
						return e
					}
					case ie.b:
						return hl(e, t.payload);
					default:
						return e
				}
			};
			const Tl = {};
			var Dl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.h:
						case Ge.f:
						case se.l:
						case oe.f:
						case ie.d:
						case qe.f:
						case oe.f:
						case ll.f: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: []
							})
						}
						case Le.e:
						case Ge.e:
						case se.g:
						case se.k:
						case ie.c:
						case fl.h:
						case ul.b:
						case qe.e:
						case oe.e:
						case "RECOMMENDED_POSTS_LOADED":
						case ll.e:
						case dl.c: {
							const {
								key: n,
								postIds: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case fl.p: {
							if (!t.payload || !t.payload.length) return e;
							const n = {};
							for (const e of t.payload) {
								const t = e;
								n[t.key] = t.postIds
							}
							return Object.assign({}, e, n)
						}
						case Ue.b:
						case Ge.h:
						case Me.r:
						case oe.b:
						case de.e:
						case ue.i:
						case ll.b:
						case dl.d: {
							const {
								key: n,
								postIds: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: e[n].concat(s)
							})
						}
						case ce.c: {
							const {
								key: n,
								postOrder: s,
								type: r
							} = t.payload;
							return -1 === r.indexOf(He.Kb.Posts) ? e : Object.assign({}, e, {
								[n]: s
							})
						}
						case We.c: {
							const {
								key: n,
								postOrder: s,
								type: r
							} = t.payload;
							return -1 === r.indexOf(He.Kb.Posts) ? e : Object.assign({}, e, {
								[n]: e[n].concat(s)
							})
						}
						case j.p: {
							const {
								newStickiedPostList: n,
								listingKey: s
							} = t.payload;
							if (!e[s]) return e;
							const r = [...e[s]].filter(e => !n.includes(e));
							return r.unshift(...n), Object.assign({}, e, {
								[s]: r
							})
						}
						case ie.b:
							return hl(e, t.payload);
						default:
							return e
					}
				},
				Cl = n("./src/lib/makeListingKey/index.ts"),
				wl = n("./src/reddit/actions/preferences.ts");
			const Al = {};
			var Rl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Al,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c: {
						const {
							key: n,
							listingSort: s
						} = t.payload;
						return s && !Object(Cl.b)(n) ? Object.assign({}, e, {
							[n]: {
								sort: s,
								hasChanged: !1
							}
						}) : e
					}
					case wl.a:
					case wl.q: {
						const t = {};
						return Object.keys(e).forEach(n => {
							t[n] = Object.assign({}, e[n], {
								hasChanged: !0
							})
						}), t
					}
					default:
						return e
				}
			};
			const Pl = {};
			var kl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.g:
					case se.k:
					case ie.c:
					case qe.e:
					case oe.e:
					case Ue.b:
					case Ge.e:
					case Ge.h:
					case Me.r:
					case de.e:
					case oe.b:
					case ue.i:
					case ll.e:
					case ll.b: {
						const {
							key: n,
							token: s,
							dist: r
						} = t.payload;
						return s ? Object.assign({}, e, {
							[n]: {
								token: s,
								dist: r
							}
						}) : Object(ol.a)(e, n)
					}
					case We.c:
					case ce.c: {
						const {
							key: n,
							tokens: s,
							type: r
						} = t.payload;
						return -1 === r.indexOf(He.Kb.Posts) ? e : s.posts ? Object.assign({}, e, {
							[n]: {
								token: s.posts
							}
						}) : Object(ol.a)(e, n)
					}
					case ie.b:
						return hl(e, t.payload);
					default:
						return e
				}
			};
			const xl = {};
			var Nl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dl.c:
						case dl.d: {
							const {
								pageInfo: n,
								key: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				Ll = Object(s.c)({
					api: gl,
					endMarkers: Il,
					fetchedTokens: Sl,
					ids: Dl,
					listingSort: Rl,
					loadMore: kl,
					pageInfo: Nl
				}),
				Ul = Object(s.c)({
					activeKey: zu,
					listingOrder: il,
					postOrder: Ll
				});
			var Ml = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.g:
						return gn()(t.payload.featuredLiveThread) ? e : t.payload.featuredLiveThread;
					default:
						return e
				}
			};
			var Fl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.g:
							return !0;
						default:
							return e
					}
				},
				Gl = Object(s.c)({
					featured: Ml,
					isFrontpageLoaded: Fl
				}),
				Bl = n("./src/reddit/actions/media.ts");
			var ql = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Bl.b:
						return t.payload;
					default:
						return e
				}
			};
			var Vl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bl.c:
							return t.payload;
						default:
							return e
					}
				},
				Kl = Object(s.c)({
					isMuted: ql,
					volume: Vl
				}),
				Hl = n("./src/reddit/actions/meta.ts");
			const Wl = {
				city: "",
				country: "",
				crawler: void 0,
				domain: "",
				isBot: !1,
				isSessionSeo: !1,
				method: "",
				protocol: "",
				region: "",
				sessionReferrerDomain: "",
				userAgent: "",
				pageloadServerTime: 0
			};
			var Yl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Hl.b:
						return t.payload;
					case Hl.a:
						return Object.assign({}, e, t.payload);
					default:
						return e
				}
			};
			const Ql = {};
			var zl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ql,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Fe.b:
						case se.b:
						case Be.b: {
							const {
								payload: n
							} = t;
							if (!n.subredditPermissions || !n.subreddits) return e;
							const s = Object.keys(n.subredditAboutInfo || {});
							if (1 !== s.length) return e;
							const r = s[0];
							return Object.assign({}, e, {
								[r]: n.subredditPermissions
							})
						}
						case ne.i:
						case ne.f:
						case ne.m:
						case ne.p:
						case ne.v: {
							const {
								response: n
							} = t.payload, {
								moderatingSubreddits: s,
								moderatingProfiles: r
							} = n;
							return Object.assign({}, e, s, r)
						}
						case ue.f:
						case Ge.e:
						case ne.k: {
							const n = t.payload,
								{
									moderatingSubreddits: s,
									moderatingProfiles: r
								} = n;
							return Object.assign({}, e, s, r)
						}
						case w.R: {
							const {
								subredditId: n
							} = t.payload;
							return Object(ol.a)(e, n)
						}
						case w.O: {
							const n = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				Jl = n("./src/reddit/actions/moderationLog/constants.ts");
			const Xl = {};
			var Zl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Jl.b: {
						const {
							actionIds: n,
							key: s,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r] || {}, {
								[s]: n
							})
						})
					}
					default:
						return e
				}
			};
			const $l = {};
			var eb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $l,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Jl.b: {
							const {
								normalizedModerationLog: n,
								subredditId: s
							} = t.payload, r = {};
							n.forEach(e => {
								r[e.id] = e
							});
							const o = {
								[s]: r
							};
							return Pe()(Object.assign({}, e), o)
						}
						default:
							return e
					}
				},
				tb = Object(s.c)({
					itemOrder: Zl,
					models: eb
				});
			var nb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Jl.b: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const sb = {};
			var rb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Jl.b: {
						const {
							hasNextPage: n,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const ob = {};
			var ab = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ob,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Jl.b: {
						const {
							hasPreviousPage: n,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const cb = [];
			var ib = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Jl.a: {
						const {
							normalizedModerators: n,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			var db = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Jl.b: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				ub = Object(s.c)({
					actions: tb,
					endCursor: nb,
					hasNextPage: rb,
					hasPreviousPage: ab,
					moderators: ib,
					startCursor: db
				});
			var lb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case j.h:
						return t.payload;
					case j.g:
						return null
				}
				return e
			};
			const bb = {};
			var pb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.E:
					case w.s: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload.response || t.payload, r = {
							[n]: s
						};
						return Object(F.merge)(e, r)
					}
					case w.u: {
						const {
							subredditId: n,
							userId: s,
							permissions: r
						} = t.payload;
						return Object(F.setIn)(e, [n, s, "modPermissions"], r)
					}
					case w.Q: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(F.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			const fb = {};
			var mb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.t:
					case w.s: {
						const {
							key: n,
							subredditId: s
						} = t.payload;
						return s ? Object.assign({}, e, {
							[n]: null
						}) : e
					}
					case w.r: {
						const {
							error: n,
							key: s,
							subredditId: r
						} = t.payload;
						return r ? Object.assign({}, e, {
							[s]: n
						}) : e
					}
					default:
						return e
				}
			};
			const Ob = {};
			var gb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ob,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.r:
						case w.s: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[s]: !1
							}) : e
						}
						case w.t: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[s]: !0
							}) : e
						}
						default:
							return e
					}
				},
				_b = Object(s.c)({
					error: mb,
					pending: gb
				});
			const yb = {};
			var jb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.s: {
							const {
								subredditId: n,
								response: s,
								key: r
							} = t.payload;
							return Object(F.setIn)(e, [n, r], s.moderatorIds)
						}
						case w.Q: {
							const {
								subredditId: n,
								userId: s,
								key: r
							} = t.payload, o = e[n][r].filter(e => e !== s);
							return Object(F.setIn)(e, [n, r], o)
						}
						default:
							return e
					}
				},
				hb = Object(s.c)({
					data: jb,
					api: _b
				});
			var Eb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.x:
					case w.w:
						return null;
					case w.v:
						return t.payload;
					default:
						return e
				}
			};
			var Ib = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.w:
						case w.v:
							return !1;
						case w.x:
							return !0;
						default:
							return e
					}
				},
				vb = Object(s.c)({
					error: Eb,
					pending: Ib
				});
			const Sb = {};
			var Tb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.w: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload;
						return Object(F.set)(e, n, s)
					}
					case w.P: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(F.unsetIn)(e, [n, s])
					}
					case w.a: {
						const n = t.payload,
							{
								subredditId: s,
								moderators: r
							} = n,
							o = {
								[s]: r
							};
						return Object(F.merge)(e, o)
					}
					default:
						return e
				}
			};
			const Db = {};
			var Cb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Db,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.w: {
							const {
								subredditId: n,
								moderatorIds: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case w.P: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = e[n].filter(e => e !== s);
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case w.a: {
							const n = t.payload,
								{
									subredditId: s,
									moderatorIds: r
								} = n,
								o = [...e[s] || [], ...r];
							return Object.assign({}, e, {
								[s]: o
							})
						}
						default:
							return e
					}
				},
				wb = Object(s.c)({
					api: vb,
					models: Tb,
					userOrder: Cb
				});
			const Ab = {};
			var Rb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ab,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							invitePending: r
						} = s, o = {
							[n]: r
						};
						return Object(F.merge)(e, o)
					}
					case w.y:
					case w.z: {
						const {
							subredditId: n
						} = t.payload;
						return Object(F.unset)(e, n)
					}
					default:
						return e
				}
			};
			const Pb = {};
			var kb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.s: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const xb = {};
			var Nb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Lb = {};
			var Ub = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							response: n
						} = t.payload, s = {
							[n.subredditId]: n.moderators
						};
						return Object(F.merge)(Object.assign({}, e), s)
					}
					case w.u: {
						const n = t.payload,
							{
								subredditId: s,
								userId: r,
								permissions: o
							} = n;
						return e[s] && e[s][r] ? Object(F.setIn)(e, [s, r, "modPermissions"], o) : e
					}
					default:
						return e
				}
			};
			var Mb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.F:
					case w.E:
						return null;
					case w.D:
						return t.payload;
					default:
						return e
				}
			};
			var Fb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.F:
							return !0;
						case w.E:
						case w.D:
							return !1;
						default:
							return e
					}
				},
				Gb = Object(s.c)({
					error: Mb,
					pending: Fb
				});
			var Bb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.F:
						case w.D:
						case w.Q:
							return null;
						case w.E: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case w.u: {
							const {
								userId: n,
								permissions: s
							} = t.payload;
							return e && e.id === n && !hs()(e.modPermissions, s) ? Object.assign({}, e, {
								modPermissions: s
							}) : e
						}
						default:
							return e
					}
				},
				qb = Object(s.c)({
					api: Gb,
					result: Bb
				});
			const Vb = {};
			var Kb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.C:
					case w.B: {
						const {
							subredditId: n,
							key: s
						} = t.payload;
						return n ? Object.assign({}, e, {
							[s]: null
						}) : e
					}
					case w.A: {
						const {
							error: n,
							subredditId: s,
							key: r
						} = t.payload;
						return s ? Object.assign({}, e, {
							[r]: n
						}) : e
					}
					default:
						return e
				}
			};
			const Hb = {};
			var Wb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.A:
						case w.B: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[s]: !1
							}) : e
						}
						case w.C: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[s]: !0
							}) : e
						}
						default:
							return e
					}
				},
				Yb = Object(s.c)({
					error: Kb,
					pending: Wb
				});
			const Qb = {};
			var zb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.B: {
							const {
								response: n,
								subredditId: s,
								key: r
							} = t.payload, {
								moderatorIds: o
							} = n;
							return Object(F.merge)(e, {
								[s]: {
									[r]: o
								}
							})
						}
						case w.Q: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = Object.assign({}, e[n]);
							return Object.keys(e[n]).forEach(t => {
								const o = e[n][t].filter(e => e !== s);
								r[t] = o
							}), Object(F.set)(e, n, r)
						}
						default:
							return e
					}
				},
				Jb = Object(s.c)({
					data: zb,
					api: Yb
				}),
				Xb = Object(s.c)({
					editableModerators: pb,
					editableUserOrder: hb,
					invitedModerators: wb,
					invitePending: Rb,
					loadMoreModerators: Nb,
					loadMoreEditableModerators: kb,
					models: Ub,
					search: qb,
					userOrder: Jb
				});
			var Zb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.b:
					case Ge.k:
						return null;
					case Ge.a:
					case Ge.j:
						return t.payload;
					default:
						return e
				}
			};
			var $b = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.b:
						case Ge.k:
							return !0;
						case Ge.c:
						case Ge.a:
						case Ge.l:
						case Ge.j:
							return !1;
						default:
							return e
					}
				},
				ep = Object(s.c)({
					error: Zb,
					pending: $b
				});
			const tp = [];
			var np = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.e: {
							const n = t.payload,
								{
									filteredSubreddits: s
								} = n;
							return s || e
						}
						case Ge.j: {
							const n = t.payload;
							return [...e, n]
						}
						case Ge.k:
						case Ge.a: {
							const n = t.payload;
							return e.filter(e => e !== n)
						}
						default:
							return e
					}
				},
				sp = Object(s.c)({
					api: ep,
					names: np
				}),
				rp = Object(s.c)({
					filteredSubreddits: sp
				});
			var op = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ds.a:
						return t.payload.enabled;
					default:
						return e
				}
			};
			var ap = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ts.c:
					case Ts.b:
						return null;
					case Ts.a:
						return t.payload;
					default:
						return e
				}
			};
			var cp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ts.c:
							return !0;
						case Ts.b:
						case Ts.a:
						case ne.s:
						case ne.r:
							return !1;
						default:
							return e
					}
				},
				ip = Object(s.c)({
					error: ap,
					pending: cp
				});
			const dp = {};
			var up = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.a: {
						const {
							ids: n
						} = t.payload, s = {};
						return n.forEach(e => s[e] = !0), Object.assign({}, e, s)
					}
					case ne.d: {
						const {
							ids: n
						} = t.payload;
						return Ss()(e, n)
					}
					case ne.c: {
						const {
							ids: e
						} = t.payload, n = {};
						return e.forEach(e => n[e] = !0), n
					}
					default:
						return e
				}
			};
			const lp = {};
			var bp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ts.b: {
							const {
								operation: e,
								ids: n
							} = t.payload;
							return "approve" === e ? lp : {
								[ks.c[e]]: n
							}
						}
						default:
							return e
					}
				},
				pp = Object(s.c)({
					api: ip,
					selectedItems: up,
					undoLastAction: bp
				});
			var fp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.g:
					case ne.f:
						return null;
					case ne.e:
						return t.payload;
					default:
						return e
				}
			};
			var mp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.g:
							return !0;
						case ne.f:
						case ne.e:
							return !1;
						default:
							return e
					}
				},
				Op = Object(s.c)({
					error: fp,
					pending: mp
				});
			const gp = {};
			var _p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.f: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[s]: o
							})
						})
					}
					default:
						return e
				}
			};
			const yp = {};
			var jp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.f: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				hp = Object(s.c)({
					api: Op,
					itemOrder: _p,
					loadMore: jp
				});
			var Ep = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.e: {
						const n = t.payload,
							{
								moderatingSubreddits: s
							} = n;
						return s ? null : e
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: n
						} = e;
						return n
					}
					case ne.k: {
						const e = t.payload,
							{
								moderatedAfter: n
							} = e;
						return n
					}
					default:
						return e
				}
			};
			const Ip = [];
			var vp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ip,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: e
						} = t.payload, {
							listingOrder: n
						} = e;
						return n
					}
					case ne.k: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return [...e, ...s]
					}
					case Ge.e: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return s || e
					}
					default:
						return e
				}
			};
			var Sp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b:
						return !0;
					default:
						return e
				}
			};
			var Tp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.k:
							return !0;
						case ne.b:
							return !1;
						default:
							return e
					}
				},
				Dp = Object(s.c)({
					after: Ep,
					data: vp,
					loaded: Sp,
					pending: Tp
				});
			var Cp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.j:
					case ne.i:
						return null;
					case ne.h:
						return t.payload;
					default:
						return e
				}
			};
			var wp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.j:
							return !0;
						case ne.i:
						case ne.h:
							return !1;
						default:
							return e
					}
				},
				Ap = Object(s.c)({
					error: Cp,
					pending: wp
				});
			const Rp = {};
			var Pp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.i: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[s]: o
							})
						})
					}
					default:
						return e
				}
			};
			const kp = {};
			var xp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.i: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				Np = Object(s.c)({
					api: Ap,
					itemOrder: Pp,
					loadMore: xp
				});
			var Lp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.n:
					case ne.m:
						return null;
					case ne.l:
						return t.payload;
					default:
						return e
				}
			};
			var Up = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.n:
							return !0;
						case ne.m:
						case ne.l:
							return !1;
						default:
							return e
					}
				},
				Mp = Object(s.c)({
					error: Lp,
					pending: Up
				});
			const Fp = {};
			var Gp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.m: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[s]: o
							})
						})
					}
					default:
						return e
				}
			};
			const Bp = {};
			var qp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.m: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				Vp = Object(s.c)({
					api: Mp,
					itemOrder: Gp,
					loadMore: qp
				});
			var Kp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.q:
					case ne.p:
						return null;
					case ne.o:
						return t.payload;
					default:
						return e
				}
			};
			var Hp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.q:
							return !0;
						case ne.p:
						case ne.o:
							return !1;
						default:
							return e
					}
				},
				Wp = Object(s.c)({
					error: Kp,
					pending: Hp
				});
			const Yp = {};
			var Qp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.p: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[s]: o
							})
						})
					}
					default:
						return e
				}
			};
			const zp = {};
			var Jp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.p: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				Xp = Object(s.c)({
					api: Wp,
					itemOrder: Qp,
					loadMore: Jp
				});
			var Zp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.w:
					case ne.v:
						return null;
					case ne.u:
						return t.payload;
					default:
						return e
				}
			};
			var $p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.w:
							return !0;
						case ne.v:
						case ne.u:
							return !1;
						default:
							return e
					}
				},
				ef = Object(s.c)({
					error: Zp,
					pending: $p
				});
			const tf = {};
			var nf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.v: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[s]: o
							})
						})
					}
					default:
						return e
				}
			};
			const sf = {};
			var rf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.v: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				of = Object(s.c)({
					api: ef,
					itemOrder: nf,
					loadMore: rf
				}),
				af = Object(s.c)({
					bulkAction: pp,
					edited: hp,
					moderatedCommunitiesOrder: Dp,
					modqueue: Np,
					reports: Vp,
					spam: Xp,
					unmoderated: of
				}),
				cf = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const df = {};
			var uf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : df,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.v: {
						const {
							moreCommentsId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case $.u: {
						const {
							moreCommentsItem: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: null
						})
					}
					case $.t: {
						const n = t.payload,
							{
								moreCommentsItem: s
							} = n,
							r = cf(n, ["moreCommentsItem"]);
						return Object.assign({}, e, {
							[s.id]: r || {}
						})
					}
					default:
						return e
				}
			};
			const lf = {};
			var bf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.v: {
							const {
								moreCommentsId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case $.t:
						case $.u: {
							const {
								moreCommentsItem: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.id]: !1
							})
						}
						default:
							return e
					}
				},
				pf = Object(s.c)({
					error: uf,
					pending: bf
				});
			const ff = {};
			var mf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ff,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.u:
						case Fe.b:
						case se.b:
							return Object.assign({}, e, t.payload.moreComments);
						default:
							return e
					}
				},
				Of = Object(s.c)({
					api: pf,
					models: mf
				});
			var gf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.b:
					case Me.c:
						return null;
					case Me.a:
						return t.payload;
					default:
						return e
				}
			};
			var _f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.a:
					case Me.c:
						return !0;
					case Me.b:
						return !1;
					default:
						return e
				}
			};
			var yf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.k:
						case Me.a:
						case Me.c:
							return null;
						case Me.b: {
							const {
								name: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				jf = Object(s.c)({
					error: gf,
					fetched: _f,
					pending: yf
				});
			var hf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.f:
					case Me.g:
						return null;
					case Me.e:
						return t.payload;
					default:
						return e
				}
			};
			var Ef = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.e:
					case Me.g:
						return !0;
					case Me.f:
						return !1;
					default:
						return e
				}
			};
			var If = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.e:
						case Me.g:
							return !1;
						case Me.f:
							return !0;
						default:
							return e
					}
				},
				vf = Object(s.c)({
					error: hf,
					fetched: Ef,
					pending: If
				});
			var Sf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.i:
					case Me.j:
						return null;
					case Me.h:
						return t.payload;
					default:
						return e
				}
			};
			var Tf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.h:
					case Me.j:
						return !0;
					case Me.i:
						return !1;
					default:
						return e
				}
			};
			var Df = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.h:
						case Me.j:
							return !1;
						case Me.i:
							return !0;
						default:
							return e
					}
				},
				Cf = Object(s.c)({
					error: Sf,
					fetched: Tf,
					pending: Df
				});
			var wf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.l:
					case Me.m:
						return null;
					case Me.k:
						return t.payload;
					default:
						return e
				}
			};
			var Af = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.k:
					case Me.m:
						return !0;
					case Me.l:
						return !1;
					default:
						return e
				}
			};
			var Rf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.k:
						case Me.m:
							return !1;
						case Me.l:
							return !0;
						default:
							return e
					}
				},
				Pf = Object(s.c)({
					error: wf,
					fetched: Af,
					pending: Rf
				});
			var kf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.o:
					case Me.p:
						return null;
					case Me.n:
						return t.payload;
					default:
						return e
				}
			};
			var xf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.n:
					case Me.p:
						return !0;
					case Me.o:
						return !1;
					default:
						return e
				}
			};
			var Nf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.n:
						case Me.p:
							return !1;
						case Me.o:
							return !0;
						default:
							return e
					}
				},
				Lf = Object(s.c)({
					error: kf,
					fetched: xf,
					pending: Nf
				});
			var Uf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.t:
						return !1;
					case Me.u:
						return !0;
					default:
						return e
				}
			};
			var Mf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.t:
							return !0;
						case Me.u:
							return !1;
						default:
							return e
					}
				},
				Ff = Object(s.c)({
					fetched: Uf,
					pending: Mf
				});
			var Gf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.A:
					case Me.B:
						return null;
					case Me.z:
						return t.payload;
					default:
						return e
				}
			};
			var Bf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.A:
					case Me.z:
						return !1;
					case Me.B:
						return !0;
					default:
						return e
				}
			};
			var qf = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.A:
							return !0;
						case Me.B:
						case Me.z:
							return !1;
						default:
							return e
					}
				},
				Vf = Object(s.c)({
					error: Gf,
					fetched: Bf,
					pending: qf
				});
			var Kf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.w:
					case Me.x:
						return null;
					case Me.v:
						return t.payload;
					default:
						return e
				}
			};
			var Hf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.v:
					case Me.x:
						return !0;
					case Me.w:
						return !1;
					default:
						return e
				}
			};
			var Wf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.v:
						case Me.x:
							return null;
						case Me.w:
							const {
								id: n
							} = t.payload;
							return n;
						default:
							return e
					}
				},
				Yf = Object(s.c)({
					error: Kf,
					fetched: Hf,
					pending: Wf
				}),
				Qf = Object(s.c)({
					addSubreddit: jf,
					create: vf,
					deleteMulti: Cf,
					duplicate: Pf,
					edit: Lf,
					forUser: Ff,
					recommendations: Vf,
					removeSubreddit: Yf
				}),
				zf = n("./node_modules/lodash/union.js"),
				Jf = n.n(zf);

			function Xf(e, t, n) {
				let s, r, o = e.length - 1,
					a = 0;
				for (; a <= o;) {
					const c = n(s = e[r = (a + o) / 2 | 0], t);
					if (c < 0) {
						if ((a = r + 1) > o) return a
					} else {
						if (!(c > 0)) return r;
						if ((o = r - 1) < a) return o + 1
					}
				}
				return (a + o) / 2 | 0
			}
			var Zf = n("./src/reddit/actions/profile/constants.ts");
			const $f = {};
			var em = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $f,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.k:
						case Me.r:
						case Me.u:
						case Zf.h: {
							const {
								multireddits: n,
								multiredditsByUser: s,
								multiredditsModelsState: r
							} = t.payload, o = Object.assign({}, e), a = Object.assign({}, n, r);
							for (const t in s) {
								const n = s[t],
									r = e[t];
								o[t] = Jf()(r, n).sort((e, t) => a[e].displayText.toLowerCase() > a[t].displayText.toLowerCase() ? 1 : -1)
							}
							return hs()(e, o) ? e : o
						}
						case Me.g:
						case Me.m: {
							const {
								userId: n,
								multireddit: s
							} = t.payload, r = e[n] ? e[n].slice() : [], o = Xf(r, s.url, (e, t) => e > t ? 1 : -1);
							return r.splice(o, 0, s.url), Object.assign({}, e, {
								[n]: r
							})
						}
						case Me.j: {
							const n = t.payload;
							for (const t in e) {
								const s = e[t];
								if (s.indexOf(n) > -1) return Object.assign({}, e, {
									[t]: s.filter(e => e !== n)
								})
							}
							return e
						}
						default:
							return e
					}
				},
				tm = n("./src/reddit/actions/subscription/constants.ts"),
				nm = n("./src/reddit/models/Multireddit/index.ts");
			const sm = {};
			var rm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.k:
					case Me.r:
					case Me.u:
					case Zf.h: {
						let n = {};
						for (const s in t.payload.multireddits) {
							const r = Object.assign({}, t.payload.multireddits[s]),
								o = e[s];
							o && !Object(nm.g)(r) && (r.subredditIds = o.subredditIds, r.profileIds = o.profileIds), s in e && hs()(e[r.url], r) || (n = Object.assign({}, n, {
								[s]: r
							}))
						}
						return gn()(n) ? e : Object.assign({}, e, n)
					}
					case Me.g:
					case Me.m: {
						const {
							multireddit: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.url]: n
						})
					}
					case Me.j: {
						const n = t.payload,
							s = Object.assign({}, e);
						return delete s[n], s
					}
					case Me.p: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.url]: n
						})
					}
					case Me.x: {
						const {
							id: n,
							multipath: s,
							type: r
						} = t.payload, o = e[s], a = "subreddit" === r ? (o.subredditIds || []).filter(e => e !== n) : o.subredditIds, c = "profile" === r ? (o.profileIds || []).filter(e => e !== n) : o.profileIds;
						return Object.assign({}, e, {
							[s]: Object.assign({}, o, {
								profileIds: c,
								subredditIds: a
							})
						})
					}
					case tm.d: {
						const {
							makeFavorite: n,
							multiredditPath: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								isFavorited: n
							})
						})
					}
					case tm.e: {
						const {
							follow: n,
							multiredditPath: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								isFollowed: n,
								isFavorited: !1
							})
						})
					}
					case Me.c: {
						const {
							id: n,
							multipaths: s,
							type: r
						} = t.payload, o = s.reduce((t, s) => {
							const o = e[s],
								a = "subreddit" === r ? [...o.subredditIds || [], n] : o.subredditIds,
								c = "profile" === r ? [...o.profileIds || [], n] : o.profileIds;
							return Object.assign({}, t, {
								[s]: Object.assign({}, o, {
									subredditIds: a,
									profileIds: c
								})
							})
						}, {});
						return Object.assign({}, e, o)
					}
					default:
						return e
				}
			};
			const om = {};
			var am = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : om,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.B: {
							const {
								multipath: n,
								subreddits: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.keys(s)
							})
						}
						default:
							return e
					}
				},
				cm = Object(s.c)({
					api: Qf,
					byUserId: em,
					models: rm,
					recommendations: am
				});
			var im = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.J:
					case w.H:
						return null;
					case w.G:
						return t.payload;
					default:
						return e
				}
			};
			const dm = {};
			var um = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.J: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(R.d)(n, s);
							return Object.assign({}, e, {
								[r]: !0
							})
						}
						case w.H:
						case w.G: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(R.d)(n, s);
							return Object.assign({}, e, {
								[r]: !1
							})
						}
						default:
							return e
					}
				},
				lm = Object(s.c)({
					error: im,
					pending: um
				});
			const bm = {};
			var pm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.H: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(R.d)(s, n);
						return Object.assign({}, e, {
							[r]: !0
						})
					}
					default:
						return e
				}
			};
			var fm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vt.b:
						return t.payload;
					default:
						return e
				}
			};
			const mm = {};
			var Om = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.H: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const gm = {};
			var _m = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.I:
					case w.H: {
						const {
							subredditId: n,
							mutedUsers: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(F.merge)(e, r)
					}
					case w.N: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(F.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var ym = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.M:
					case w.L:
						return null;
					case w.K:
						return t.payload;
					default:
						return e
				}
			};
			var jm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.M:
							return !0;
						case w.L:
						case w.K:
							return !1;
						default:
							return e
					}
				},
				hm = Object(s.c)({
					error: ym,
					pending: jm
				});
			var Em = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.M:
						case w.K:
							return null;
						case w.L: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				Im = Object(s.c)({
					api: hm,
					result: Em
				});
			const vm = {};
			var Sm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.H: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: [...e[n], ...s]
							}) : Object.assign({}, e, {
								[n]: s
							})
						}
						case w.N: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case w.I: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Tm = Object(s.c)({
					api: lm,
					fetchedTokens: pm,
					inContext: fm,
					loadMore: Om,
					models: _m,
					search: Im,
					userOrder: Sm
				}),
				Dm = n("./src/reddit/actions/notificationBanner.ts");
			var Cm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Dm.b:
							return t.payload.notificationBannerId;
						case Dm.a:
							return null;
						default:
							return e
					}
				},
				wm = n("./src/reddit/actions/nps.ts");
			const Am = {
				pending: !1,
				success: !1,
				dest: void 0
			};
			var Rm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Am,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wm.c:
							return Object.assign({}, Am, {
								pending: !0
							});
						case wm.a:
							return Am;
						case wm.b: {
							const {
								dest: e
							} = t.payload;
							return Object.assign({}, Am, {
								success: !0,
								dest: e
							})
						}
						default:
							return e
					}
				},
				Pm = n("./src/reddit/actions/oldSiteRules.ts");
			const km = [];
			var xm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : km,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pm.a:
						return t.payload.oldSiteRules;
					default:
						return e
				}
			};
			const Nm = [];
			var Lm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qc.a: {
						const {
							pageExperimentVariants: e
						} = t.payload;
						return (e ? e.experiments : []).map(e => {
							let {
								id: t,
								experimentName: n,
								name: s,
								version: r
							} = e;
							return {
								id: parseInt(t),
								name: n,
								variant: s || void 0,
								version: r
							}
						})
					}
					default:
						return e
				}
			};
			var Um = Object(s.c)({
					models: Lm,
					canonicalUrl: function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 ? arguments[1] : void 0;
						switch (t.type) {
							case qc.a: {
								const {
									pageExperimentVariants: e
								} = t.payload;
								return e && e.canonicalUrl ? e.canonicalUrl : null
							}
							default:
								return e
						}
					}
				}),
				Mm = Object(s.c)({
					experiments: Um
				}),
				Fm = n("./node_modules/history/esm/history.js"),
				Gm = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Bm = {
					allowNavigationCallback: null,
					currentPage: null,
					lastPage: null,
					referrers: {},
					sessionReferrer: null,
					metas: {}
				},
				qm = (e, t) => ({
					key: e,
					locationState: {},
					meta: null,
					queryParams: {},
					routeMatch: null,
					status: 404,
					url: t,
					urlParams: {}
				}),
				Vm = (e, t, n, s) => {
					const r = n.route,
						{
							action: o
						} = r,
						a = Gm(r, ["action"]);
					return {
						key: e,
						locationState: s.state,
						meta: n.route.meta,
						queryParams: n.match.queryParams,
						routeMatch: Object.assign({}, n, {
							route: a
						}),
						status: 200,
						url: t,
						urlParams: n.match.params
					}
				};
			var Km = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.a: {
							const n = e.currentPage,
								s = t.payload,
								{
									routeMatch: r,
									location: o
								} = s,
								{
									key: a
								} = o;
							if (void 0 === a) return e;
							const c = Object(Fm.e)(o),
								i = r ? Vm(a, c, r, o) : qm(a, c);
							let {
								referrers: d
							} = e;
							if ("PUSH" === s.action) {
								const e = n && n.url || "";
								d = Object.assign({}, d, {
									[a]: e
								})
							} else if ("REPLACE" === s.action && n && d[n.key]) {
								const e = n.key,
									t = d[e],
									s = Gm(d, ["symbol" == typeof e ? e : e + ""]);
								d = Object.assign({}, s, {
									[a]: t
								})
							}
							return Object.assign({}, e, {
								referrers: d,
								currentPage: i,
								lastPage: n
							})
						}
						case p.e: {
							const n = t.payload,
								{
									key: s,
									meta: r
								} = n;
							return Object.assign({}, e, {
								metas: Object.assign({}, e.metas, {
									[s]: r
								})
							})
						}
						case p.f: {
							if (!e.currentPage) return e;
							const n = t.payload,
								s = Object.assign({}, e.currentPage, {
									status: n
								});
							return Object.assign({}, e, {
								currentPage: s
							})
						}
						case Fe.b:
						case se.b:
							return !e.currentPage || t.payload.postMeta, e;
						case p.b:
							return e;
						case p.d: {
							const {
								allowNavigationCallback: n
							} = t.payload;
							return Object.assign({}, e, {
								allowNavigationCallback: n
							})
						}
						case p.c:
							return Object.assign({}, e, {
								allowNavigationCallback: null
							});
						default:
							return e
					}
				},
				Hm = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Wm = {};
			var Ym = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.l: {
						const {
							pollId: n
						} = t.payload.pollResults, s = n;
						e[s];
						return Hm(e, ["symbol" == typeof s ? s : s + ""])
					}
					case l.k: {
						const {
							pollId: n
						} = t.payload, s = n;
						e[s];
						return Hm(e, ["symbol" == typeof s ? s : s + ""])
					}
					case l.j: {
						const {
							pollId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Qm = {};
			var zm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.l: {
							const {
								pollId: n
							} = t.payload.pollResults;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case l.j: {
							const {
								pollId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case l.k: {
							const {
								pollId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						default:
							return e
					}
				},
				Jm = Object(s.c)({
					error: Ym,
					pending: zm
				}),
				Xm = Object(s.c)({
					voting: Jm
				});
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			const Zm = e => {
				const {
					options: t,
					totalVoteCount: n,
					userSelection: s
				} = e;
				return {
					options: t.reduce((e, t) => {
						let {
							id: n,
							voteCount: r
						} = t;
						return Object.assign({}, e, {
							[n.toString()]: {
								id: n,
								votes: (r || 0).toString(),
								userSelected: n === s
							}
						})
					}, {}),
					totalVotes: n.toString()
				}
			};
			var $m = e => {
				if (!e.pollData) return null;
				const {
					id: t,
					created: n,
					authorId: s,
					belongsTo: r
				} = e, {
					options: o,
					votingEndTimestamp: a
				} = e.pollData;
				let c = 0;
				const i = [];
				return o.forEach(e => {
					c += e.voteCount, i.push({
						id: e.id.toString(),
						text: e.text
					})
				}), {
					id: t,
					createdAt: n,
					creatorId: s,
					subredditId: r.id,
					endsAt: a,
					postId: t,
					options: i,
					totalVoters: c,
					type: fa.a.GA
				}
			};
			const eO = {};
			var tO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.i: {
						const {
							poll: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case se.g:
					case ie.c:
					case ue.i:
					case Ue.b:
					case Fe.b:
					case se.b: {
						const {
							governance: n,
							posts: s
						} = t.payload;
						if (n) {
							const t = Object.keys(n).reduce((e, t) => {
								const s = n[t].poll;
								return e[s.id] = s, e
							}, {});
							return Object.assign({}, e, t)
						}
						const r = {};
						return Object.keys(s).forEach(e => {
							s[e].pollData && (r[e] = $m(s[e]))
						}), Object.assign({}, e, r)
					}
					default:
						return e
				}
			};
			const nO = {};
			var sO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.l: {
						const {
							[fa.b.ByVoters]: n, pollId: s
						} = t.payload.pollResults;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					case l.f: {
						const {
							pollId: n,
							optionId: s,
							options: r
						} = t.payload;
						let o = 0;
						const a = {};
						for (const e of r) o += e.voteCount, a[e.id] = {
							id: parseInt(e.id),
							userSelected: e.id === s,
							votes: e.voteCount.toString()
						};
						return Object.assign({}, e, {
							[n]: {
								options: a,
								totalVotes: o.toString()
							}
						})
					}
					case se.g:
					case ie.c:
					case ue.i:
					case Ue.b:
					case Fe.b:
					case se.b: {
						const {
							governance: n,
							posts: s
						} = t.payload;
						if (n) {
							const t = Object.keys(n).reduce((e, t) => {
								const s = n[t],
									{
										[fa.b.ByVoters]: r,
										pollId: o
									} = s.pollResults;
								return e[o] = r, e
							}, {});
							return Object.assign({}, e, t)
						}
						const r = Object.keys(s).reduce((e, t) => {
							if (!s[t].pollData) return e;
							const n = Zm(s[t].pollData);
							return n ? (e[t] = n, e) : e
						}, {});
						return Object.keys(r).length ? Object.assign({}, e, r) : e
					}
					default:
						return e
				}
			};
			const rO = {};
			var oO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.l: {
							const {
								[fa.b.ByVotingPower]: n, pollId: s
							} = t.payload.pollResults;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						case se.g:
						case ie.c:
						case ue.i:
						case Ue.b:
						case Fe.b:
						case se.b: {
							const {
								governance: n
							} = t.payload;
							if (n) {
								const t = Object.keys(n).reduce((e, t) => {
									const s = n[t],
										{
											[fa.b.ByVotingPower]: r,
											pollId: o
										} = s.pollResults;
									return e[o] = r, e
								}, {});
								return Object.assign({}, e, t)
							}
							return e
						}
						default:
							return e
					}
				},
				aO = Object(s.c)({
					byVoters: sO,
					byVotingPower: oO
				});
			const cO = {};
			var iO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.l: {
							const {
								pollId: n,
								rewardPoints: s
							} = t.payload.pollResults;
							return s ? Object.assign({}, e, {
								[n]: s
							}) : e
						}
						default:
							return e
					}
				},
				dO = Object(s.c)({
					api: Xm,
					models: tO,
					results: aO,
					rewards: iO
				});
			const uO = {
				reorderError: null,
				updateDescriptionError: null,
				updateLayoutError: null
			};
			var lO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xr.i:
					case xr.j:
						return Object.assign({}, e, {
							reorderError: null
						});
					case xr.h:
						return Object.assign({}, e, {
							reorderError: t.payload
						});
					case xr.l:
					case xr.m:
						return Object.assign({}, e, {
							updateDescriptionError: null
						});
					case xr.k:
						return Object.assign({}, e, {
							updateDescriptionError: t.payload
						});
					case xr.p:
					case xr.q:
						return Object.assign({}, e, {
							updateLayoutError: null
						});
					case xr.o:
						return Object.assign({}, e, {
							updateLayoutError: t.payload
						});
					default:
						return e
				}
			};
			const bO = {
				reorderPending: !1,
				updateDescriptionPending: !1,
				updateLayoutPending: !1
			};
			var pO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xr.i:
							return Object.assign({}, e, {
								reorderPending: !0
							});
						case xr.h:
						case xr.j:
							return Object.assign({}, e, {
								reorderPending: !1
							});
						case xr.l:
							return Object.assign({}, e, {
								updateDescriptionPending: !0
							});
						case xr.k:
						case xr.m:
							return Object.assign({}, e, {
								updateDescriptionPending: !1
							});
						case xr.p:
							return Object.assign({}, e, {
								updateLayoutPending: !0
							});
						case xr.o:
						case xr.q:
							return Object.assign({}, e, {
								updateLayoutPending: !1
							});
						default:
							return e
					}
				},
				fO = Object(s.c)({
					error: lO,
					pending: pO
				}),
				mO = n("./src/reddit/helpers/path/index.ts");
			const OO = {},
				gO = e => {
					const {
						protocol: t,
						domain: n
					} = e;
					return e => {
						const s = Object(mO.b)(e.permalink);
						return Object.assign({}, e, {
							permalink: "".concat(t, "://").concat(n).concat(s)
						})
					}
				};
			var _O = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b:
					case Ge.e:
					case Ge.h:
					case re.b:
					case re.e:
					case qe.e:
					case qe.b:
					case oe.e:
					case oe.b:
					case ie.c:
					case se.g:
					case se.k:
					case ie.c:
					case Fe.b:
					case se.b:
					case j.j:
					case Me.r:
					case Ue.b:
					case de.e:
					case "RECOMMENDED_POSTS_LOADED":
					case ue.i:
					case We.c:
					case Ve.b:
					case ce.c:
					case xr.f: {
						const {
							collections: n,
							meta: s
						} = t.payload;
						if (!n) return e;
						let r = n;
						if (s) {
							const e = gO(s);
							r = Is()(n, e)
						}
						return Object.assign({}, e, r)
					}
					case xr.d: {
						const {
							collection: n,
							meta: s
						} = t.payload;
						if (!n) return e;
						const r = n.id;
						let o = n;
						if (s) {
							o = gO(s)(n)
						}
						return Object.assign({}, e, {
							[r]: o
						})
					}
					case xr.g: {
						const {
							collectionId: n,
							postId: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								postIds: r.postIds.filter(e => e !== s)
							})
						}) : e
					}
					case xr.a: {
						const {
							collectionId: n,
							postId: s
						} = t.payload, r = e[n];
						return r && s ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								postIds: [...r.postIds, s]
							})
						}) : e
					}
					case xr.e: {
						const {
							collectionId: n
						} = t.payload, s = Object.assign({}, e);
						return delete s[n], s
					}
					case xr.s: {
						const {
							collectionId: n,
							newTitle: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								title: s
							})
						}) : e
					}
					case xr.j: {
						const {
							collectionId: n,
							postIds: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								postIds: [...s]
							})
						}) : e
					}
					case xr.m: {
						const {
							collectionId: n,
							newDescription: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								description: s
							})
						}) : e
					}
					case xr.q: {
						const {
							collectionId: n,
							newLayout: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								displayLayout: s
							})
						}) : e
					}
					default:
						return e
				}
			};
			const yO = {};
			var jO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.b:
						case xr.f: {
							const {
								collections: n
							} = t.payload;
							if (!n) return e;
							const s = Object.keys(n);
							if (!s.length) return e;
							const {
								subredditId: r
							} = n[s[0]];
							return Object.assign({}, e, {
								[r]: s
							})
						}
						case xr.d: {
							const {
								collection: n
							} = t.payload, {
								subredditId: s
							} = n, r = e[s] || [];
							return Object.assign({}, e, {
								[s]: [...r, n.id]
							})
						}
						case xr.e: {
							const {
								collectionId: n,
								collection: s
							} = t.payload;
							if (!s) return e;
							const r = s && e[s.subredditId];
							return r ? Object.assign({}, e, {
								[s.subredditId]: r.filter(e => e !== n)
							}) : e
						}
						default:
							return e
					}
				},
				hO = Object(s.c)({
					models: _O,
					subredditToIds: jO,
					api: fO
				}),
				EO = n("./src/reddit/actions/postFlair.ts"),
				IO = n("./src/reddit/models/Flair/index.ts");
			const vO = {},
				SO = {
					displaySettings: {
						isEnabled: !1,
						position: IO.b.Left
					},
					permissions: {
						canAssignOwn: !1
					},
					templateIds: [],
					templates: {}
				},
				TO = (e, t) => {
					if (!t) return e;
					const n = Object.keys(t);
					return 0 === n.length ? e : n.reduce((e, n) => (e[n] = Object.assign({}, SO, e[n], t[n]), e), Object.assign({}, e))
				};
			var DO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.b:
						case Ue.b:
						case Ge.e:
						case Ge.h:
						case Me.r:
						case ul.b:
						case Fe.b:
						case se.b:
						case se.g:
						case se.k:
						case ce.c:
						case ie.c:
						case re.b:
						case re.e:
						case ae.c:
						case ae.i:
						case ae.e:
						case ae.g:
						case de.e:
						case Ve.b:
						case Ve.b:
						case qe.b:
						case qe.e:
						case oe.b:
						case oe.e:
						case "RECOMMENDED_POSTS_LOADED":
						case We.c:
						case We.c:
						case ue.i:
							return TO(e, t.payload.postFlair);
						case EO.c: {
							const {
								subredditId: n,
								isEnabled: s
							} = t.payload, r = e[n].displaySettings, o = Object.assign({}, r, {
								isEnabled: s
							});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									displaySettings: o
								})
							})
						}
						case EO.a: {
							const {
								subredditId: n,
								canAssignOwn: s
							} = t.payload, r = e[n].permissions, o = Object.assign({}, r, {
								canAssignOwn: s
							});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									permissions: o
								})
							})
						}
						case EO.f: {
							const {
								subredditId: n,
								template: s
							} = t.payload, r = e[n], {
								templates: o,
								templateIds: a
							} = r, c = Object.assign({}, o, {
								[s.id]: s
							}), i = [...a];
							return i.includes(s.id) || i.push(s.id), Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									templates: c,
									templateIds: i
								})
							})
						}
						case EO.b: {
							const {
								subredditId: n,
								templateId: s
							} = t.payload, r = e[n], {
								templates: o,
								templateIds: a
							} = r, c = Ss()(o, s), i = a.filter(e => e !== s);
							return Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									templates: c,
									templateIds: i
								})
							})
						}
						case EO.e:
						case EO.d: {
							const n = t.payload,
								s = e[n.subredditId];
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, s, {
									templateIds: n.templateIds
								})
							})
						}
						case ne.i:
						case ne.f:
						case ne.m:
						case ne.p:
						case ne.v: {
							const {
								response: n
							} = t.payload;
							return TO(e, n.postFlair)
						}
						default:
							return e
					}
				},
				CO = n("./src/reddit/actions/postRequirements/constants.ts");
			const wO = {};
			var AO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case CO.a: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case CO.c:
					case CO.b: {
						const {
							subredditName: n
						} = t.payload;
						return Object(ol.a)(e, n)
					}
					default:
						return e
				}
			};
			const RO = {};
			var PO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : RO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case CO.c:
						case CO.a:
						case CO.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === CO.c;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				kO = Object(s.c)({
					error: AO,
					pending: PO
				}),
				xO = Object(s.c)({
					fetch: kO
				});
			const NO = {};
			var LO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case CO.b: {
							const {
								subredditName: n,
								requirements: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case CO.d: {
							const {
								subredditName: n,
								partialRequirements: s
							} = t.payload, r = e[n];
							return r ? Object.assign({}, e, {
								[n]: Object.assign({}, r, s)
							}) : e
						}
						default:
							return e
					}
				},
				UO = Object(s.c)({
					api: xO,
					models: LO
				}),
				MO = n("./src/reddit/actions/inFeedChaining.ts");
			var FO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MO.a:
						return t.payload.isDismissed;
					default:
						return e
				}
			};
			const GO = {};
			var BO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MO.c: {
						const {
							isDismissed: n,
							listingKey: s,
							postId: r
						} = t.payload;
						if (n) return Object.assign({}, e, {
							[r]: s
						});
						const o = Object.assign({}, e);
						return delete o[r], o
					}
					default:
						return e
				}
			};
			const qO = {};
			var VO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case MO.b:
							return Object.assign({}, e, {
								[t.payload.postId]: t.payload.listingKey
							});
						default:
							return e
					}
				},
				KO = Object(s.c)({
					dismissed: FO,
					dismissedIdToListingKey: BO,
					idToListingKey: VO
				});
			var HO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case j.c:
							return t.payload;
						default:
							return e
					}
				},
				WO = n("./src/reddit/actions/embedAndImage.ts");
			const YO = {};
			var QO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case WO.b: {
							const {
								postId: n
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: !1
							}) : e
						}
						case WO.a: {
							const {
								postId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
					}
					return e
				},
				zO = Object(s.c)({
					loadable: QO
				});
			const JO = {};
			var XO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case j.d: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !e[n]
						})
					}
					default:
						return e
				}
			};
			var ZO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case j.e: {
						const {
							postId: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const $O = {};
			var eg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $O,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.e:
					case Ge.h:
					case se.g:
					case ie.c:
					case Ue.b:
					case de.e:
					case "RECOMMENDED_POSTS_LOADED":
					case ue.i:
					case We.c:
					case ce.c:
						return Z()(Object.assign({}, e), t.payload.postInstances, (e, t) => {
							if (e) return e.concat(t)
						});
					default:
						return e
				}
			};
			const tg = {};
			var ng = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.i: {
							const {
								poll: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.postId]: n.id
							})
						}
						case se.g:
						case ie.c:
						case ue.i:
						case Ue.b:
						case Fe.b:
						case se.b: {
							const {
								governance: n,
								posts: s
							} = t.payload;
							if (n) {
								const t = Object.keys(n).reduce((e, t) => {
									const s = n[t];
									return e[t] = s.poll.id, e
								}, {});
								return Object.assign({}, e, t)
							}
							const r = Object.keys(s).reduce((e, t) => s[t].pollData ? (e[t] = t, e) : e, {});
							return Object.assign({}, e, r)
						}
						default:
							return e
					}
				},
				sg = n("./src/reddit/actions/flairManagement/constants.ts"),
				rg = n("./src/reddit/actions/subredditTopContent.ts"),
				og = n("./src/reddit/helpers/isPost.ts"),
				ag = n("./node_modules/lodash/pickBy.js"),
				cg = n.n(ag);

			function ig(e, t) {
				const n = cg()(t, (function(t) {
					let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
					return !e[n] || !hs()(e[n], t)
				}));
				return Object.keys(n).length > 0 ? Object.assign({}, e, n) : e
			}
			var dg = n("./src/reddit/models/Media/index.ts"),
				ug = n("./src/reddit/models/Post/index.ts"),
				lg = n("./src/reddit/actions/subredditDuplicates.ts"),
				bg = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const pg = {},
				fg = e => {
					const {
						protocol: t,
						domain: n
					} = e;
					return e => {
						const s = Object(mO.b)(e.permalink);
						return Object.assign({}, e, {
							permalink: "".concat(t, "://").concat(n).concat(s)
						})
					}
				},
				mg = e => t => {
					const n = e[t.id];
					return n && n.events && (t.events = n.events, t.source = n.source), t
				},
				Og = e => t => {
					const n = e[t.id];
					return n && n.isSponsored && (t.isSponsored = n.isSponsored), t
				},
				gg = e => t => {
					const n = e[t.id];
					return n && n.numDuplicates && (t.numDuplicates = n.numDuplicates), t
				},
				_g = e => t => {
					const n = e[t.id];
					return t && t.media && n && n.media && Object(dg.C)(t.media) && t.media.isRichtextPreview && Object(dg.C)(n.media) && !n.media.isRichtextPreview && (t.media.richtextContent = n.media.richtextContent, t.media.isRichtextPreview = !1), t
				},
				yg = e => {
					let t = e.source;
					return t && t.outboundUrlCreated && (t = Object.assign({}, t, {
						outboundUrlReceived: Date.now()
					}), e.source = t), e
				},
				jg = e => {
					const {
						allAwardings: t
					} = e, n = bg(e, ["allAwardings"]), s = {};
					return t && t.forEach(e => {
						s[e.id] = e.count
					}), Object.assign({}, n, {
						awardCountsById: s
					})
				},
				hg = e => t => {
					for (let n = 0; n < e.length; n++) t = e[n](t);
					return t
				},
				Eg = (e, t) => Object.assign({}, e, {
					events: t.events,
					source: t.source
				});
			var Ig = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.a:
						if (Ro(t) === (He.yb.COMMENTS || He.yb.DUPLICATES)) {
							const n = Po(t),
								s = ko(t);
							if (n && n.instanceId && s && s.partialPostId) {
								const t = n.instanceId,
									r = Object(ug.m)(s.partialPostId);
								if (e[r] && e[t]) return Object.assign({}, e, {
									[r]: Eg(e[r], e[t])
								})
							}
						}
						return e;
					case Fe.b:
					case se.b: {
						const n = fg(t.payload.meta);
						return Object.assign({}, e, Is()(t.payload.posts, hg([n, yg, jg, mg(e), Og(e), gg(e)])))
					}
					case j.j:
						return ig(e, t.payload);
					case lg.a:
						return ig(e, t.payload.posts);
					case Be.b:
					case Ge.e:
					case Ge.h:
					case re.b:
					case re.e:
					case qe.e:
					case qe.b:
					case oe.e:
					case oe.b:
					case ie.c:
					case se.g:
					case se.k:
					case ie.c:
					case ul.b:
					case Me.r:
					case Ue.b:
					case de.e:
					case "RECOMMENDED_POSTS_LOADED":
					case fl.h:
					case ue.i:
					case Ve.b:
					case ll.e:
					case ll.b:
					case dl.c:
					case dl.d: {
						const n = fg(t.payload.meta);
						return Object.assign({}, e, Is()(t.payload.posts, hg([n, yg, jg, _g(e), gg(e)])))
					}
					case fl.p: {
						if (!t.payload || !t.payload.length) return e;
						const n = {};
						for (const s of t.payload) {
							const t = s,
								r = fg(t.meta);
							Object.assign(n, Is()(t.posts, hg([r, yg, jg, _g(e), gg(e)])))
						}
						return Object.assign({}, e, n)
					}
					case ul.b: {
						const n = fg(t.payload.meta),
							s = e[t.payload.postId];
						return Object.assign({}, e, Is()(t.payload.posts, hg([n, yg, jg, _g(e), gg(e)])), {
							[t.payload.postId]: Object.assign({}, s, {
								numDuplicates: t.payload.count
							})
						})
					}
					case Le.e:
					case We.c:
					case ce.c: {
						const n = fg(t.payload.meta),
							s = Is()(t.payload.posts, hg([n, jg, yg]));
						return Z()(Object.assign({}, e), s, (e, t) => Object.assign({}, t, e))
					}
					case j.k: {
						const n = t.payload;
						return Z()(Object.assign({}, e), n, (e, t) => Object.assign({}, e, t))
					}
					case Cs.a: {
						const {
							id: n,
							vote: s
						} = t.payload, r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object(xs.c)(r, s)
						}) : e
					}
					case ee.b:
					case $.G: {
						const n = t.payload.comment.postId,
							s = e[n];
						if (s) {
							const r = void 0 !== t.payload.numComments ? t.payload.numComments : s.numComments + 1;
							return Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									numComments: r
								})
							})
						}
						return e
					}
					case $.y: {
						const n = t.payload.postId,
							s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								numComments: s.numComments - 1
							})
						}) : e
					}
					case ge.r: {
						const {
							id: n,
							awardings: s,
							gilder: r,
							treatmentTags: o
						} = t.payload, a = e[n];
						return a ? Object.assign({}, e, {
							[n]: Object.assign({}, Rs(a, s, r), {
								treatmentTags: o
							})
						}) : e
					}
					case ge.D: {
						const {
							awardId: n,
							thingId: s
						} = t.payload, r = e[s];
						return r ? Object.assign({}, e, {
							[s]: Ps(r, n)
						}) : e
					}
					case w.l: {
						const {
							posts: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							posts: s
						} = n;
						return Object.assign({}, e, Is()(s, hg([jg])))
					}
					case Ts.b:
					case ne.s: {
						const {
							operation: n,
							ids: s,
							username: r,
							options: o
						} = t.payload, a = s.filter(e => Object(og.a)(e)), c = Object(ks.d)(e, n, a, r, o);
						return Z()(Object.assign({}, e), c, (e, t) => Object.assign({}, e, t))
					}
					case xr.t: {
						const {
							postId: n,
							collectionId: s
						} = t.payload, r = e[n];
						if (r && s) {
							const t = r.collectionIds || [];
							return t.push(s), Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									collectionIds: [...t]
								})
							})
						}
						return e
					}
					case xr.e: {
						const {
							collectionId: n,
							collection: s
						} = t.payload, r = s && s.postIds || [], o = {};
						return r.forEach(t => {
							const s = e[t],
								r = s && s.collectionIds;
							if (r) {
								const e = r.filter(e => e !== n);
								o[t] = Object.assign({}, s, {
									collectionIds: e
								})
							}
						}), Object.assign({}, e, o)
					}
					case xr.g: {
						const {
							collectionId: n,
							postId: s
						} = t.payload;
						if (!n || !s) return e;
						const r = e[s],
							o = r && r.collectionIds;
						if (!o) return e;
						const a = o.filter(e => e !== n);
						return Object.assign({}, e, {
							[s]: Object.assign({}, r, {
								collectionIds: a
							})
						})
					}
					case dl.f: {
						const {
							postId: n
						} = t.payload;
						if (!n) return e;
						const s = e[n];
						if (!s || !s.eventInfo) return e;
						const r = s.eventInfo;
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								eventInfo: Object.assign({}, r, {
									eventIsLive: !0
								})
							})
						})
					}
					case dl.a: {
						const {
							postId: n,
							eventInfo: s
						} = t.payload;
						if (!n || !s) return e;
						const r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								eventInfo: Object.assign({}, s)
							})
						}) : e
					}
					case Ki.g: {
						const n = t.payload.subredditTopContent;
						return n && n.posts && Object.keys(n.posts) ? Object.assign({}, Is()(n.posts, hg([jg])), e) : e
					}
					case ae.c:
					case ae.i:
					case ae.e:
					case ae.g:
					case rg.b:
						return Object.assign({}, Is()(t.payload.posts, hg([jg])), e);
					case j.o: {
						const {
							postId: n,
							richtextContent: s
						} = t.payload, r = e[n];
						return r && r.media && Object(dg.C)(r.media) ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								media: Object.assign({}, r.media, {
									richtextContent: s,
									isRichtextPreview: !1
								})
							})
						}) : e
					}
					case sg.a: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case sg.b: {
						const n = t.payload;
						return Object(ol.a)(e, n)
					}
					case Bl.a: {
						const {
							isDeleted: n,
							height: s,
							postId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								media: Object.assign({}, e[r].media, {
									height: s,
									isDeleted: n
								})
							})
						})
					}
					case $t.b: {
						const n = t.payload.reduce((e, t) => (e[t.id] = t, e), {});
						return Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			var vg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case j.i:
							return t.payload;
						default:
							return e
					}
				},
				Sg = n("./src/reddit/selectors/posts.ts");
			const Tg = {};
			var Dg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case j.l: {
						const {
							postId: n,
							thresholds: s
						} = t.payload, r = e[n] || Object(Sg.h)(), o = s.reduce((e, t) => {
							const {
								maxContinuousTime: n,
								timeAdEntered: s,
								totalTime: r
							} = e[t];
							return e[t] = {
								maxContinuousTime: n,
								timeAdEntered: s || Date.now(),
								totalTime: r
							}, e
						}, Object.assign({}, r));
						return Object.assign({}, e, {
							[n]: Object.assign({}, o)
						})
					}
					case j.m: {
						const {
							postId: n,
							thresholds: s
						} = t.payload, r = e[n] || Object(Sg.h)(), o = s.reduce((e, t) => {
							const n = e[t];
							let {
								maxContinuousTime: s,
								totalTime: r
							} = n;
							if (n.timeAdEntered) {
								const e = Date.now() - n.timeAdEntered;
								r += e, s = Math.max(s, e)
							}
							return e[t] = {
								maxContinuousTime: s,
								totalTime: r
							}, e
						}, Object.assign({}, r));
						return Object.assign({}, e, {
							[n]: Object.assign({}, o)
						})
					}
					default:
						return e
				}
			};
			const Cg = [];
			var wg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case j.n: {
						const {
							postIds: e
						} = t.payload;
						return e
					}
					case se.g:
					case ie.c: {
						const {
							recentPostIds: n
						} = t.payload;
						return n && n.length ? n : e
					}
					default:
						return e
				}
			};
			var Ag = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fo.d:
					case fo.o:
					case fo.k:
					case fo.g:
					case fo.a:
					case fo.m:
					case fo.f:
						return null;
					case fo.j: {
						const {
							message: e
						} = t.payload;
						return e
					}
					case fo.e:
						return "error";
					default:
						return e
				}
			};
			var Rg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fo.g:
						return !0;
					case fo.m:
					case fo.a:
					case fo.f:
					case fo.e:
						return !1;
					default:
						return e
				}
			};
			var Pg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case fo.k:
							return !0;
						case fo.j:
						case fo.e:
						case fo.o:
						case fo.d:
							return !1;
						default:
							return e
					}
				},
				kg = Object(s.c)({
					error: Ag,
					pending: Rg,
					pendingUpdate: Pg
				});
			const xg = {};
			var Ng = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fo.c: {
						const {
							subredditId: e,
							id: n
						} = t.payload;
						return {
							subredditId: e,
							scheduledPostId: n
						}
					}
					default:
						return e
				}
			};
			const Lg = {
				standalonePosts: {
					POSTS_LOADED: fo.m,
					postIdsKey: "standalonePostsIds",
					MUTATION_SUCCEEDED: fo.o
				},
				recurringPosts: {
					POSTS_LOADED: fo.a,
					postIdsKey: "recurringPostsIds",
					MUTATION_SUCCEEDED: fo.d
				}
			};

			function Ug(e) {
				const t = {};
				return function() {
					let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t,
						s = arguments.length > 1 ? arguments[1] : void 0;
					switch (s.type) {
						case Lg[e].POSTS_LOADED:
						case fo.f: {
							const {
								subredditInfoById: t
							} = s.payload, {
								id: r
							} = t, o = t.scheduledPosts[e].models.reduce((e, t) => (e[t.id] = t, e), {});
							return Object.assign({}, n, {
								[r]: Object.assign({}, n[r] || {}, o)
							})
						}
						case fo.i:
						case fo.l: {
							const {
								subredditId: e,
								scheduledPostId: t
							} = s.payload, r = n[e] || {};
							return Object.assign({}, n, {
								[e]: Object.assign({}, Object.keys(r).filter(e => e !== t).reduce((e, t) => (e[t] = r[t], e), {}))
							})
						}
						case fo.h: {
							const {
								subredditId: e
							} = s.payload;
							return Object.keys(n).reduce((t, s) => (s !== e && (t[s] = n[s]), t), {})
						}
						case Lg[e].MUTATION_SUCCEEDED: {
							let t;
							switch (e) {
								case "recurringPosts":
									t = s.payload.scheduledPost;
									break;
								case "standalonePosts":
								default:
									t = s.payload.scheduledPost
							}
							const r = t.subreddit.id,
								o = n[r][t.id],
								a = {
									[t.id]: Object.assign({}, o, t)
								};
							return Object.assign({}, n, {
								[r]: Object.assign({}, n[r] || {}, a)
							})
						}
						default:
							return n
					}
				}
			}
			const Mg = {};

			function Fg(e) {
				return function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mg,
						n = arguments.length > 1 ? arguments[1] : void 0;
					switch (n.type) {
						case Lg[e].POSTS_LOADED:
						case fo.f: {
							const {
								subredditInfoById: s
							} = n.payload, r = s.id, {
								pageInfo: o
							} = s.scheduledPosts[e];
							return Object.assign({}, t, {
								[r]: Object.assign({}, o)
							})
						}
						case fo.h: {
							const {
								subredditId: e
							} = n.payload;
							return Object.keys(t).reduce((n, s) => (s !== e && (n[s] = t[s]), n), {})
						}
						default:
							return t
					}
				}
			}
			var Gg = n("./node_modules/lodash/uniq.js"),
				Bg = n.n(Gg);
			const qg = {};

			function Vg(e) {
				return function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qg,
						n = arguments.length > 1 ? arguments[1] : void 0;
					switch (n.type) {
						case Lg[e].POSTS_LOADED:
						case fo.f: {
							const {
								subredditInfoById: s
							} = n.payload, r = s.id, o = s.scheduledPosts[Lg[e].postIdsKey];
							return Object.assign({}, t, {
								[r]: Bg()([...t[r] || [], ...o])
							})
						}
						case fo.i:
						case fo.l: {
							const {
								subredditId: e,
								scheduledPostId: s
							} = n.payload, r = t[e] || [];
							return Object.assign({}, t, {
								[e]: r.filter(e => e !== s)
							})
						}
						case fo.h: {
							const {
								subredditId: e
							} = n.payload;
							return Object.assign({}, t, {
								[e]: []
							})
						}
						default:
							return t
					}
				}
			}
			var Kg = Object(s.c)({
					models: Ug("recurringPosts"),
					pageInfo: Fg("recurringPosts"),
					postOrder: Vg("recurringPosts"),
					editModal: Ng
				}),
				Hg = Object(s.c)({
					models: Ug("standalonePosts"),
					pageInfo: Fg("standalonePosts"),
					postOrder: Vg("standalonePosts")
				}),
				Wg = Object(s.c)({
					api: kg,
					standalonePosts: Hg,
					recurringPosts: Kg
				});
			const Yg = {};
			var Qg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.l: {
						const {
							auto: n,
							postId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const zg = {};
			var Jg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.h: {
						const {
							postId: n,
							isBuffering: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Xg = {};
			var Zg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.i: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const $g = {};
			var e_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $g,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.j: {
						const {
							postId: n,
							time: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			var t_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.r: {
						const {
							postId: e
						} = t.payload;
						return e
					}
					case E.k:
						return null;
					default:
						return e
				}
			};
			const n_ = {};
			var s_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.u: {
						const {
							postId: n
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					case E.l: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
				}
				return e
			};
			const r_ = {};
			var o_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.o: {
						const {
							postId: n,
							time: s
						} = t.payload, r = e[n] || {
							cached: !0,
							start: s
						};
						return s < r.start ? e : Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								playable: s
							})
						})
					}
					case E.m: {
						const {
							postId: n,
							time: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {
								cached: !1,
								start: s
							}
						})
					}
					default:
						return e
				}
			};
			const a_ = {};
			var c_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.q: {
						const {
							postId: n,
							metadata: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const i_ = {};
			var d_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.v: {
						const {
							postId: n
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					case E.n: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
				}
				return e
			};
			const u_ = {};
			var l_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : u_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.p: {
						const {
							postId: n,
							isPlaying: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const b_ = {};
			var p_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case E.s: {
							const {
								postId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						default:
							return e
					}
				},
				f_ = n("./src/reddit/constants/video.ts");
			const m_ = {};
			var O_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case E.t: {
							const {
								postId: n,
								time: s
							} = t.payload;
							return e[n] && parseInt(s.currentTime.toString(), 10) - parseInt(e[n].currentTime.toString(), 10) < f_.k ? e : Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				g_ = Object(s.c)({
					autoPlayed: Qg,
					buffering: Jg,
					consumed: Zg,
					continuousViewStartedAt: e_,
					fullscreen: t_,
					loadable: s_,
					loadTimes: o_,
					metadata: c_,
					paused: d_,
					playing: l_,
					started: p_,
					time: O_
				}),
				__ = Object(s.c)({
					pixelMetadata: Dg,
					chained: KO,
					embedAndImage: zO,
					expanded: XO,
					focus: ZO,
					instances: eg,
					metaMap: ng,
					models: Ig,
					modToMemberShare: vg,
					crowdControl: HO,
					recent: wg,
					scheduledPosts: Wg,
					video: g_
				}),
				y_ = n("./src/lib/reducers/addAuthentication/index.ts");
			const j_ = {};
			var h_ = Object(y_.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case se.b: {
							const {
								postId: n,
								commentLists: s,
								comments: r
							} = t.payload, o = s[n] && s[n].head;
							return o && r[o.id] && r[o.id].isStickied ? Object.assign({}, e, {
								[n]: o.id
							}) : e
						}
						case $.C: {
							const {
								id: e,
								postId: n
							} = t.payload;
							return {
								[n]: e
							}
						}
						default:
							return e
					}
				}), j_),
				E_ = Object(s.c)({
					data: h_
				});
			const I_ = {};
			var v_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : I_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.f:
					case m.g: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case m.e: {
						const {
							subredditId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const S_ = {};
			var T_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : S_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.f: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case m.g:
						case m.e: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				D_ = Object(s.c)({
					error: v_,
					pending: T_
				});
			const C_ = {};
			var w_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : C_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.d: {
						const {
							product: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: void 0
						})
					}
					case m.c:
					case b.f:
					case b.g:
					case b.i:
					case b.j: {
						const {
							productId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case m.a:
					case b.d:
					case b.h: {
						const {
							productId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const A_ = {};
			var R_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : A_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.c:
						case b.f: {
							const {
								productId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case m.d: {
							const {
								product: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.id]: !1
							})
						}
						case m.a:
						case b.d:
						case b.g: {
							const {
								productId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				P_ = Object(s.c)({
					error: w_,
					pending: R_
				}),
				k_ = Object(s.c)({
					fetch: D_,
					purchase: P_
				});
			var x_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.b:
						return t.payload.productId;
					case r.b:
						return null;
					default:
						return e
				}
			};
			const N_ = {};
			var L_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.i:
						case m.g: {
							const {
								products: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				U_ = Object(s.c)({
					api: k_,
					currentlyPurchasing: x_,
					models: L_
				});
			const M_ = {};
			var F_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.f:
					case re.e:
					case re.c:
					case re.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case re.d:
					case re.a: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const G_ = {};
			var B_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.f:
						case re.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case re.e:
						case re.d:
						case re.b:
						case re.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				q_ = Object(s.c)({
					error: F_,
					pending: B_
				});
			const V_ = {};
			var K_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.e: {
							const {
								key: n,
								commentIds: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case re.b: {
							const {
								key: n,
								commentIds: s
							} = t.payload, r = e[n] || [];
							return Object.assign({}, e, {
								[n]: r.concat(s)
							})
						}
						default:
							return e
					}
				},
				H_ = n("./src/reddit/actions/comment/list.ts");
			const W_ = {};
			var Y_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : W_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case H_.a: {
						const {
							listingKey: n,
							listingName: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case H_.b: {
						const {
							listingKey: n
						} = t.payload;
						return n in e ? Ss()(e, n) : e
					}
					default:
						return e
				}
			};
			const Q_ = {};
			var z_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Q_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {}
						})
					}
					case re.b: {
						const {
							key: n,
							fetchedToken: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								[s]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const J_ = {};
			var X_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : J_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.e:
						case re.b: {
							const {
								key: n,
								dist: s,
								token: r
							} = t.payload;
							return r ? Object.assign({}, e, {
								[n]: {
									dist: s,
									token: r
								}
							}) : Object(ol.a)(e, n)
						}
						default:
							return e
					}
				},
				Z_ = Object(s.c)({
					api: q_,
					endMarkers: Y_,
					fetchedTokens: z_,
					commentIds: K_,
					loadMore: X_
				}),
				$_ = n("./src/reddit/actions/pages/profileModSettings.ts");
			var ey = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $_.a:
							return !1;
						default:
							return e
					}
				},
				ty = Object(s.c)({
					pending: ey
				}),
				ny = Object(s.c)({
					api: ty
				});
			const sy = {};
			var ry = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.c:
					case qe.b:
					case Ve.c:
					case Ve.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case qe.a:
					case Ve.a: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const oy = {};
			var ay = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.c:
						case Ve.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case qe.b:
						case qe.a:
						case Ve.b:
						case Ve.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				cy = Object(s.c)({
					error: ry,
					pending: ay
				});
			const iy = {};
			var dy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {}
						})
					}
					case Ve.b: {
						const {
							key: n,
							fetchedToken: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								[s]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const uy = {};
			var ly = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.b:
					case Ve.b: {
						const {
							key: n,
							overviewIds: s
						} = t.payload, r = e[n] || [];
						return Object.assign({}, e, {
							[n]: [...r, ...s]
						})
					}
					default:
						return e
				}
			};
			const by = {};
			var py = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : by,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.b:
						case Ve.b: {
							const {
								key: n,
								dist: s,
								token: r
							} = t.payload;
							return r ? Object.assign({}, e, {
								[n]: {
									dist: s,
									token: r
								}
							}) : Object(ol.a)(e, n)
						}
						default:
							return e
					}
				},
				fy = Object(s.c)({
					api: cy,
					fetchedTokens: dy,
					ids: ly,
					loadMore: py
				});
			const my = {};
			var Oy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : my,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.f:
					case qe.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case qe.d: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s || {}
						})
					}
					default:
						return e
				}
			};
			const gy = {};
			var _y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.f: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case qe.e:
						case qe.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				yy = Object(s.c)({
					error: Oy,
					pending: _y
				});
			const jy = {};
			var hy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case de.c:
					case de.b: {
						const {
							extraCommentsId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case de.a: {
						const {
							extraCommentsId: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s || {}
						})
					}
					default:
						return e
				}
			};
			const Ey = {};
			var Iy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ey,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case de.c: {
							const {
								extraCommentsId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case de.b:
						case de.a: {
							const {
								extraCommentsId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				vy = Object(s.c)({
					error: hy,
					pending: Iy
				});
			const Sy = {};
			var Ty = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.e:
						case de.b:
						case de.e:
							return Object.assign({}, e, t.payload.extraComments);
						default:
							return e
					}
				},
				Dy = Object(s.c)({
					api: vy,
					models: Ty
				}),
				Cy = n("./src/lib/makeOverviewConversationsItemKey/index.ts"),
				wy = n("./src/reddit/constants/comments.ts");
			const Ay = {};

			function Ry(e) {
				const t = e;
				return Is()(t, e => {
					let {
						depth: t,
						next: n,
						prev: s
					} = e;
					return {
						depth: t,
						next: n,
						prev: s
					}
				})
			}
			const Py = (e, t, n) => {
				const s = {};
				for (const r in t) {
					const e = t[r],
						n = e.postId;
					s.hasOwnProperty(n) ? s[n] = Object.assign({}, s[n], {
						[r]: e
					}) : s[n] = {
						[r]: e
					}
				}
				for (const r in n) {
					const e = n[r],
						t = e.postId;
					s.hasOwnProperty(t) ? s[t] = Object.assign({}, s[t], {
						[r]: e
					}) : s[t] = {
						[t]: e
					}
				}
				return s
			};
			var ky = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ay,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.e:
					case de.e: {
						const {
							comments: n,
							extraComments: s,
							postIds: r,
							profileName: o
						} = t.payload, a = Py(r, n, s), c = {};
						for (const e of r) {
							c[Object(Cy.a)(e, o)] = a.hasOwnProperty(e) ? Ry(a[e]) : {}
						}
						return Object.assign({}, e, c)
					}
					case de.b: {
						const {
							comments: n,
							commentLists: s,
							extraComments: r,
							extraCommentsId: o,
							postIds: a,
							profileName: c
						} = t.payload;
						if (0 === a.length) {
							const t = Object.keys(e).find(t => void 0 !== e[t][o]);
							if (!t) return e;
							const n = Object.assign({}, e[t])[o].prev,
								s = n && n.id || "";
							return Object.assign({}, e, {
								[t]: Object.assign({}, e[t], {
									[s]: Object.assign({}, e[t][s], {
										next: null
									})
								})
							})
						}
						const i = a[0],
							d = Ry(Py(a, n, r)[i]),
							u = Object(Cy.a)(i, c),
							l = Object.assign({}, e[u]),
							b = l[o].prev,
							p = b && b.id || "",
							f = s[i].head,
							m = f && f.id || "",
							O = {
								id: m,
								type: wy.a.Comment
							},
							g = Object.assign({}, l, {
								[p]: Object.assign({}, l[p], {
									next: O
								})
							}, d, {
								[m]: Object.assign({}, d[m], {
									prev: b
								})
							});
						return Object.assign({}, e, {
							[u]: g
						})
					}
					default:
						return e
				}
			};
			const xy = {};
			var Ny = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.e:
					case de.e: {
						const {
							commentLists: n,
							postIds: s,
							profileName: r
						} = t.payload, o = {};
						for (const e of s) {
							o[Object(Cy.a)(e, r)] = n[e] && n[e].head ? n[e].head.id : null
						}
						return Object.assign({}, e, o)
					}
					default:
						return e
				}
			};
			const Ly = {};
			var Uy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ly,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.e:
						case de.e: {
							const {
								postIds: n,
								profileName: s
							} = t.payload, r = {};
							for (const e of n) {
								r[Object(Cy.a)(e, s)] = e
							}
							return Object.assign({}, e, r)
						}
						default:
							return e
					}
				},
				My = Object(s.c)({
					api: yy,
					extraComments: Dy,
					keyToCommentThreadLinkSets: ky,
					keyToHeadCommentId: Ny,
					keyToPostId: Uy
				}),
				Fy = Object(s.c)({
					chrono: fy,
					conversations: My
				});
			const Gy = {};
			var By = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				return t.type, e
			};
			const qy = {};
			var Vy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.a:
					case ae.d: {
						const {
							listingKey: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case ae.b:
					case ae.c:
					case ae.i:
					case ae.f:
					case ae.e:
					case ae.g: {
						const {
							listingKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					default:
						return e
				}
			};
			const Ky = {};
			var Hy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ky,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b:
						case ae.f: {
							const {
								listingKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case ae.a:
						case ae.d:
						case ae.c:
						case ae.i:
						case ae.e:
						case ae.g: {
							const {
								listingKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Wy = Object(s.c)({
					error: Vy,
					pending: Hy
				});
			const Yy = {};
			var Qy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.c:
					case ae.i:
					case ae.e:
					case ae.g: {
						const {
							listingKey: n,
							itemIds: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: [...e[n] || [], ...s]
						})
					}
					default:
						return e
				}
			};
			const zy = {};
			var Jy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.i:
						case ae.c:
						case ae.e:
						case ae.g: {
							const {
								pageInfo: n,
								listingKey: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[s]: n
							}) : zy
						}
						default:
							return e
					}
				},
				Xy = Object(s.c)({
					api: Wy,
					ids: Qy,
					pageInfo: Jy
				}),
				Zy = n("./src/reddit/constants/posts.ts");
			const $y = {};
			var ej = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $y,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case We.c:
						return Object.assign({}, e, t.payload.profileAboutInfo);
					case Zf.k: {
						const n = t.payload;
						return n.profile ? Object.assign({}, e, {
							[n.profile.id]: n.about
						}) : e
					}
					case tm.h: {
						const {
							identifiers: n,
							userIsSubscriber: s
						} = t.payload, r = n.filter(e => e.type === Zy.a.PROFILE);
						return r.length ? r.reduce((e, t) => (e[t.id] = Object.assign({}, e[t.id], {
							userIsSubscriber: s
						}), e), Object.assign({}, e)) : e
					}
					case wl.n: {
						const n = t.payload,
							s = e[n.subredditId];
						if (!s) return e;
						if (s.publicDescription === n.settings.publicDescription) return e;
						const r = Object.assign({}, s, {
							publicDescription: n.settings.publicDescription
						});
						return Object.assign({}, e, {
							[n.subredditId]: r
						})
					}
					default:
						return e
				}
			};
			const tj = {},
				nj = (e, t) => {
					if (!t) return e;
					const n = Object.keys(t);
					if (!n.length) return e;
					const s = {};
					return n.forEach(n => {
						const r = e[n],
							o = Object.assign({}, t[n]);
						r && hs()(r, o) || (s[n] = o)
					}), Object.keys(s).length ? Object.assign({}, e, s) : e
				};
			var sj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.b:
					case Fe.b:
					case se.b:
					case se.g:
					case re.b:
					case re.e:
					case ae.c:
					case ae.i:
					case ae.e:
					case ae.g:
					case qe.b:
					case qe.e:
					case oe.e:
					case Ve.b:
					case Ue.b:
					case Ge.e:
					case Ge.h:
					case Me.u:
					case Zf.h:
					case ul.b:
					case We.c:
					case ue.i:
					case Zf.l:
					case de.b:
					case de.e:
					case ce.c:
					case Be.b:
					case Fr.e:
					case Co.a:
					case ie.c:
					case se.k:
					case "RECOMMENDED_POSTS_LOADED":
					case tm.c:
						return nj(e, t.payload.profiles);
					case We.e: {
						const {
							typeaheadSuggestions: n
						} = t.payload;
						return Object.keys(n).length ? nj(e, n.profiles) : e
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case ne.k: {
						const {
							response: n
						} = t.payload, s = n && n.profiles;
						return nj(e, s)
					}
					case Zf.k: {
						const {
							profile: n
						} = t.payload;
						return n ? nj(e, {
							[n.id]: n
						}) : e
					}
					case wl.n: {
						const n = t.payload,
							{
								title: s,
								over18: r
							} = n.settings,
							o = e[n.subredditId];
						return !o || o.title === s && o.isNSFW === r ? e : Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, o, {
								id: n.subredditId,
								title: s,
								isNSFW: r
							})
						})
					}
					case wl.l:
					case wl.k: {
						const {
							imageUrl: n,
							key: s,
							subredditId: r
						} = t.payload;
						if ("profileIcon" !== s) return e;
						const o = e[r];
						return o ? Object.assign({}, e, {
							[r]: Object.assign({}, o, {
								icon: {
									height: null,
									url: n,
									width: null
								}
							})
						}) : e
					}
					default:
						return e
				}
			};
			const rj = {};
			var oj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zf.c:
						case Zf.f: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[(n || "").toLowerCase()]: !0
							})
						}
						case Zf.a:
						case Zf.b:
						case Zf.d:
						case Zf.e: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[(n || "").toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				aj = Object(s.c)({
					pending: oj
				});
			const cj = {};
			var ij = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Zf.b: {
						const {
							profileName: n,
							data: s
						} = t.payload, r = s.map(e => e.id);
						return Object.assign({}, e, {
							[(n || "").toLowerCase()]: r
						})
					}
					case Zf.e:
					case ae.c:
					case ae.i:
					case ae.e:
					case ae.g: {
						const {
							profileName: n,
							moderatedSubredditIds: s
						} = t.payload;
						return s ? Object.assign({}, e, {
							[n]: [...e[n] || [], ...s]
						}) : e
					}
					default:
						return e
				}
			};
			const dj = {};
			var uj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zf.e: {
							const {
								pageInfo: n,
								profileName: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						case ae.c:
						case ae.i: {
							const {
								moderatedPageInfo: n,
								profileName: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				lj = Object(s.c)({
					api: aj,
					models: ij,
					pageInfo: uj
				});
			const bj = {};
			var pj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zf.i: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !0
							})
						}
						case Zf.g:
						case Zf.h: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				fj = Object(s.c)({
					pending: pj
				});
			const mj = {};
			var Oj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zf.h: {
							const {
								pageInfo: n,
								profileName: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				gj = Object(s.c)({
					api: fj,
					pageInfo: Oj
				}),
				_j = n("./src/reddit/actions/pinnedPost.ts");
			const yj = {};
			var jj = Object(y_.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _j.a: {
						const {
							pinned: n,
							profileId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					case _j.d: {
						const {
							postId: n,
							profileId: s
						} = t.payload, r = e[s] || [];
						return Object.assign({}, e, {
							[s]: [...r, n].slice(-He.T)
						})
					}
					case _j.g: {
						const {
							postId: n,
							profileId: s
						} = t.payload, r = e[s] || [];
						return Object.assign({}, e, {
							[s]: r.filter(e => e !== n)
						})
					}
					default:
						return e
				}
			}), yj);
			const hj = {};
			var Ej = Object(y_.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _j.a: {
						const {
							pinned: n,
							profileId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			}), hj);
			const Ij = {};
			var vj = Object(y_.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ij,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _j.c:
						case _j.f: {
							const {
								postId: n,
								profileId: s
							} = t.payload, r = e[s] || [];
							return Object.assign({}, e, {
								[s]: [...r, n]
							})
						}
						case _j.b:
						case _j.e:
						case _j.d:
						case _j.g: {
							const {
								postId: n,
								profileId: s
							} = t.payload, r = e[s] || [];
							return Object.assign({}, e, {
								[s]: r.filter(e => e !== n)
							})
						}
						default:
							return e
					}
				}), Ij),
				Sj = Object(s.c)({
					data: jj,
					initialData: Ej,
					pending: vj
				}),
				Tj = n("./src/reddit/actions/trophyCase.ts");
			const Dj = {};
			var Cj, wj, Aj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Tj.a: {
							const {
								profileId: n,
								trophyIds: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				Rj = Object(s.c)({
					about: ej,
					models: sj,
					moderated: lj,
					multireddits: gj,
					pinnedPosts: Sj,
					trophyCases: Aj
				});
			n("./src/lib/cache/index.ts");
			! function(e) {
				e.MobilePromoBanner = "mobilePromoBanner", e.UpsellSignUpBannerLarge = "upsellSignUpBannerLarge", e.UpsellSignUpBannerMedium = "upsellSignUpBannerMedium", e.UpsellSignUpBannerSmall = "upsellSignUpBannerSmall"
			}(Cj || (Cj = {})),
			function(e) {
				e[e.FrontPage = 0] = "FrontPage", e[e.SubredditPage = 1] = "SubredditPage", e[e.CommentsPage = 2] = "CommentsPage"
			}(wj || (wj = {}));
			var Pj, kj, xj;
			! function(e) {
				e.mobilePromoBanner = "desktop_xpromo_banner"
			}(Pj || (Pj = {})),
			function(e) {
				e.Test1 = "test_1", e.Test2 = "test_2"
			}(kj || (kj = {})),
			function(e) {
				e.Test1 = "test_1", e.Test2 = "test_2"
			}(xj || (xj = {}));
			! function(e) {
				e.welcome = "signup_upsell_banner_welcome", e.join = "signup_upsell_banner_redditor", e.vote = "signup_upsell_banner_discuss", e.personalize = "signup_upsell_banner_personalize"
			}(Pj || (Pj = {}));
			Object(Ke.a)("PROMO__SHOW_PROMO"), Object(Ke.a)("PROMO__HIDE_PROMO");
			const Nj = {
				mobilePromoBanner: !1,
				upsellSignUpBannerLarge: !1,
				upsellSignUpBannerMedium: !1,
				upsellSignUpBannerSmall: null
			};
			var Lj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "PROMO__SHOW_PROMO": {
							const {
								promoType: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case "PROMO__HIDE_PROMO": {
							const {
								promoType: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Uj = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const Mj = {
				isError: !1,
				isPending: !1,
				global: {
					rpan_config_refresh_rate: Uj.d,
					viewer_streams_refresh: Uj.c,
					viewer_streams_refresh_slop: Uj.e
				},
				subreddits: {},
				isPermanentlyCanceled: !1
			};
			var Fj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Uj.v:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !1,
								global: Object.assign({}, t.payload)
							});
						case Uj.w: {
							const n = t.payload.name.toLowerCase();
							return Object.assign({}, e, {
								isError: !1,
								isPending: !1,
								subreddits: Object.assign({}, e.subreddits, {
									[n]: Object.assign({}, t.payload.config)
								})
							})
						}
						case Uj.E:
							return Object.assign({}, e, {
								isPending: !0
							});
						case Uj.G:
							return Object.assign({}, e, {
								isError: !0,
								isPending: !1
							});
						case Uj.F:
							return Object.assign({}, e, {
								isPermanentlyCanceled: !0,
								isPending: !1
							});
						default:
							return e
					}
				},
				Gj = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			var Bj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.J:
						return Object.assign({}, e, {
							[Uj.b]: t.payload.error
						});
					case Uj.K:
						return Object.assign({}, e, {
							[t.payload.streamId]: t.payload.error
						});
					case Uj.y: {
						const t = Uj.b;
						e[t];
						return Gj(e, ["symbol" == typeof t ? t : t + ""])
					}
					case Uj.x: {
						const n = t.payload.model.post.id;
						e[n];
						return Gj(e, ["symbol" == typeof n ? n : n + ""])
					}
					default:
						return e
				}
			};
			const qj = (e, t, n, s) => Object.assign({}, e, {
				[t]: Object.assign({}, e[t], {
					isPending: n
				}, s && {
					utcTimeStamp: s
				})
			});
			var Vj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.L:
						return qj(e, t.payload, !0);
					case Uj.M:
						return qj(e, Uj.b, !0);
					case Uj.x:
						return qj(e, t.payload.model.post.id, !1, t.payload.utcTimeStamp);
					case Uj.y:
						return qj(e, Uj.b, !1, t.payload.utcTimeStamp);
					case Uj.K:
						return qj(e, t.payload.streamId, !1);
					case Uj.J:
						return qj(e, Uj.b, !1);
					default:
						return e
				}
			};
			const Kj = {
				isError: !1,
				isPending: !1,
				subreddits: []
			};
			var Hj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Uj.u:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !1,
								subreddits: t.payload.subreddits
							});
						case Uj.H:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !0
							});
						case Uj.I:
							return Object.assign({}, e, {
								isError: !0,
								isPending: !1
							});
						default:
							return e
					}
				},
				Wj = Object(s.c)({
					config: Fj,
					error: Bj,
					pending: Vj,
					recommendedViewerSubreddits: Hj
				});
			const Yj = {
				cursor: Uj.W,
				timestamps: {},
				visitOrder: []
			};
			var Qj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.N:
						return Yj;
					case Uj.X: {
						const n = t.payload,
							s = e.visitOrder.includes(n) ? e.visitOrder : [...e.visitOrder, n],
							r = s.indexOf(n);
						return s === e.visitOrder && r === e.cursor ? e : Object.assign({}, e, {
							visitOrder: s,
							cursor: r
						})
					}
					case O.d:
						return zj(e, t.payload.id);
					case Uj.D:
						return zj(e, t.payload);
					case j.k: {
						const n = Object.keys(t.payload).filter(e => t.payload[e].hidden);
						return Jj(e, n)
					}
					case Uj.T: {
						const {
							streamId: n,
							timestamp: s
						} = t.payload;
						return Object.assign({}, e, {
							timestamps: Object.assign({}, e.timestamps, {
								[n]: s
							})
						})
					}
					default:
						return e
				}
			};
			const zj = (e, t) => {
					const n = e.visitOrder.indexOf(t);
					if (-1 === n) return e;
					const s = n > e.cursor ? e.cursor : Math.max(e.cursor - 1, 0);
					return Object.assign({}, e, {
						visitOrder: e.visitOrder.filter(e => e !== t),
						cursor: s
					})
				},
				Jj = (e, t) => {
					const n = e.visitOrder[e.cursor],
						s = new Set(t),
						r = e.visitOrder.filter(e => !s.has(e)),
						o = r.indexOf(n),
						a = o > -1 ? o : Math.max(e.cursor - 1, 0);
					return r.length !== e.visitOrder.length ? Object.assign({}, e, {
						cursor: a,
						visitOrder: r
					}) : e
				},
				Xj = {
					ended: [],
					removed: []
				};

			function Zj(e) {
				return [...new Set(e)]
			}
			var $j = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.s:
						return Object.assign({}, e, {
							ended: Zj(e.ended.concat(t.payload))
						});
					case Uj.t:
						return Object.assign({}, e, {
							removed: Zj(e.removed.concat(t.payload))
						});
					default:
						return e
				}
			};
			const eh = {};
			var th = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.y:
						const {
							listingName: n, models: s
						} = t.payload;
						if (!n) return e;
						const r = s.map(e => e.post.id),
							o = e[n] || [],
							a = [...new Set([...r, ...o])];
						return Object.assign({}, e, {
							[n]: a
						});
					default:
						return e
				}
			};
			const nh = {},
				sh = (e, t) => {
					const n = Object.keys(e).reduce((t, n) => Object.assign({}, t, {
						[n]: Object.assign({}, e[n], {
							rank: Uj.m
						})
					}), {});
					return t.reduce((e, t, n) => Object.assign({}, e, {
						[t.post.id]: Object.assign({}, t, {
							rank: Uj.l - n
						})
					}), n)
				},
				rh = (e, t) => {
					const n = t.post.id,
						s = e[n] ? e[n].rank : Uj.m;
					return Object.assign({}, e, {
						[t.post.id]: Object.assign({}, t, {
							rank: s
						})
					})
				};
			var oh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.x:
						return rh(e, t.payload.model);
					case Uj.y:
						return sh(e, t.payload.models);
					case Uj.C: {
						const n = t.payload.streamId,
							s = t.payload.isUnsetting ? -1 : 1,
							r = (t.payload.isUp ? 1 : 0) * s,
							o = (t.payload.isUp ? 0 : 1) * s;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								downvotes: e[n].downvotes + o,
								upvotes: e[n].upvotes + r
							})
						})
					}
					default:
						return e
				}
			};
			const ah = {
				discoveryUnitThumbnails: {},
				streamPreviews: {}
			};
			var ch = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ah,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.r:
						return Object.assign({}, e, {
							discoveryUnitThumbnails: Object.assign({}, t.payload.reduce((e, t) => Object.assign({}, e, {
								[t.postId]: t.imageUrl
							}), {}))
						});
					case Uj.z:
						return Object.assign({}, e, {
							streamPreviews: Object.assign({}, e.streamPreviews, t.payload.reduce((e, t) => Object.assign({}, e, {
								[t.postId]: t.imageUrl
							}), {}))
						});
					default:
						return e
				}
			};
			const ih = {
				reported: []
			};
			var dh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ih,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.d:
						return Object.assign({}, e, {
							reported: [...e.reported, t.payload.id]
						});
					default:
						return e
				}
			};
			const uh = {
				isIntroFinished: !1
			};
			var lh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uj.A:
						return Object.assign({}, e, t.payload);
					default:
						return e
				}
			};
			const bh = {
				isMuted: !0,
				reportedStreams: [],
				shouldShowOnboardingModal: !0
			};
			var ph = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Uj.B:
							return Object.assign({}, e, t.payload);
						case O.d: {
							const n = t.payload.id;
							return e.reportedStreams.includes(n) ? e : Object.assign({}, e, {
								reportedStreams: [...e.reportedStreams, n]
							})
						}
						default:
							return e
					}
				},
				fh = Object(s.c)({
					api: Wj,
					history: Qj,
					hlsStreams: $j,
					listings: th,
					models: oh,
					preloads: ch,
					reports: dh,
					theaterSettings: lh,
					userSettings: ph
				});
			const mh = {};
			var Oh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "RECOMMENDED_POSTS_LOADED":
							return Object.assign({}, e, t.payload);
						case "RECOMMENDED_POSTS_FAILED":
						default:
							return e
					}
				},
				gh = n("./src/reddit/actions/removalReasons/constants.ts");
			var _h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gh.k:
					case gh.l:
					case gh.b:
					case gh.c:
					case gh.h:
					case gh.i:
					case gh.e:
					case gh.f:
						return null;
					case gh.j:
					case gh.a:
					case gh.g:
					case gh.d:
						return t.payload;
					default:
						return e
				}
			};
			var yh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gh.k:
						case gh.b:
						case gh.h:
						case gh.e:
							return !0;
						case gh.l:
						case gh.j:
						case gh.c:
						case gh.a:
						case gh.i:
						case gh.g:
						case gh.f:
						case gh.d:
							return !1;
						default:
							return e
					}
				},
				jh = Object(s.c)({
					error: _h,
					pending: yh
				}),
				hh = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const Eh = {};
			var Ih = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Eh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gh.l: {
						const {
							response: n
						} = t.payload, {
							data: s
						} = n;
						return Object.assign({}, e, s)
					}
					case gh.c:
					case gh.i: {
						const {
							reason: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case gh.f: {
						const {
							reasonId: n
						} = t.payload, s = n;
						e[s];
						return hh(e, ["symbol" == typeof s ? s : s + ""])
					}
					default:
						return e
				}
			};
			const vh = {};
			var Sh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gh.l: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							order: r
						} = s;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case gh.c: {
						const {
							subredditId: n,
							reason: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: [...e[n], s.id]
						})
					}
					case gh.f: {
						const {
							subredditId: n,
							reasonId: s
						} = t.payload, r = [...e[n]].filter(e => e !== s);
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			var Th = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gh.t: {
							const {
								subredditId: e,
								itemIds: n
							} = t.payload;
							return {
								itemIds: n,
								subredditId: e
							}
						}
						default:
							return e
					}
				},
				Dh = Object(s.c)({
					api: jh,
					models: Ih,
					reasonOrder: Sh,
					removedItemIds: Th
				});
			const Ch = {};
			var wh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ch,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.e:
					case O.d: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case O.c: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case O.f: {
						const n = t.payload;
						return n ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					default:
						return e
				}
			};
			const Ah = {};
			var Rh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ah,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.e: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case O.d:
					case O.c: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case O.f: {
						const n = t.payload;
						return n ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					default:
						return e
				}
			};
			const Ph = {};
			var kh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ph,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case O.d: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case O.e:
						case O.c: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case O.f: {
							const n = t.payload;
							return n ? Object.assign({}, e, {
								[n]: !1
							}) : e
						}
						default:
							return e
					}
				},
				xh = Object(s.c)({
					error: wh,
					pending: Rh,
					success: kh
				});
			var Nh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.a:
						return t.payload;
					case r.c:
						return !t.payload && e;
					case p.a:
						return !1;
					case O.f:
						return !!t.payload && e;
					default:
						return e
				}
			};
			var Lh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.f:
						return t.payload;
					case r.c:
						return t.payload ? null : e;
					case p.a:
						return null;
					default:
						return e
				}
			};
			var Uh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.g:
						return t.payload;
					case O.f:
						return !1;
					default:
						return e
				}
			};
			var Mh = Object(s.c)({
					api: xh,
					openedFromModalPage: Nh,
					postOrCommentId: Lh,
					userIsMod: Uh,
					rulesCategory: function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 ? arguments[1] : void 0;
						switch (t.type) {
							case O.b:
								return t.payload
						}
						return e
					}
				}),
				Fh = n("./src/reddit/actions/pages/report/constants.ts");
			var Gh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fh.a:
						return t.payload;
					default:
						return e
				}
			};
			var Bh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fh.b:
						return t.payload;
					case Fh.c:
					case Fh.d:
						return !1;
					default:
						return e
				}
			};
			var qh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fh.d:
						return !0;
					case Fh.c:
					case Fh.b:
						return !1;
					default:
						return e
				}
			};
			var Vh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fh.c:
							return !0;
						case Fh.b:
						case Fh.d:
							return !1;
						default:
							return e
					}
				},
				Kh = Object(s.c)({
					error: Bh,
					pending: qh,
					success: Vh
				}),
				Hh = n("./src/reddit/actions/reportPageRules/constants.ts");
			const Wh = [];
			var Yh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Hh.a:
							return t.payload;
						default:
							return e
					}
				},
				Qh = Object(s.c)({
					reportPageApi: Kh,
					reportPageRules: Yh,
					initialReason: Gh
				}),
				zh = n("./src/reddit/actions/reportRules.ts");
			const Jh = {
				liveStreamingRules: [],
				sitewideRules: []
			};
			var Xh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case zh.b:
						return Object.assign({}, e, {
							sitewideRules: t.payload
						});
					case zh.a:
						return Object.assign({}, e, {
							liveStreamingRules: t.payload
						});
					default:
						return e
				}
			};
			Object(Ke.a)("REQUEST_HOST_SET");
			var Zh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "REQUEST_HOST_SET":
						return t.payload;
					default:
						return e
				}
			};
			const $h = "RUN_TIME_ENV_VARS__IS_STAGING",
				eE = (Object(Ke.a)($h), {
					staging: !1,
					startTimeInMillis: (new Date).getTime()
				});
			var tE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $h:
						return Object.assign({}, e, {
							staging: !0
						});
					default:
						return e
				}
			};
			const nE = Object.create(null);
			var sE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (null !== Object.getPrototypeOf(e) && (e = Object.assign(Object.create(null), e)), t.type) {
					case We.d: {
						const {
							relatedQueries: n,
							query: s
						} = t.payload;
						if (n) {
							const t = s ? s.toLowerCase() : "";
							return Object.assign(Object.create(null), e, {
								[t]: n
							})
						}
						return e
					}
					default:
						return e
				}
			};
			var rE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case We.f: {
						const {
							searchQuery: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			const oE = Object.create(null);
			var aE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (null !== Object.getPrototypeOf(e) && (e = Object.assign(Object.create(null), e)), t.type) {
						case We.e: {
							const {
								order: n,
								searchQuery: s
							} = t.payload;
							return Object.assign(Object.create(null), e, Object.assign({}, e, {
								[s.toLowerCase()]: n
							}))
						}
						default:
							return e
					}
				},
				cE = n("./src/reddit/models/Search/index.ts");
			const iE = {};
			var dE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.e: {
							const {
								typeaheadSuggestions: n
							} = t.payload, s = {};
							return Object.keys(n).forEach(e => {
								const t = n[e];
								return s[e] = Object(cE.d)(t)
							}), Object.assign({}, e, s)
						}
						default:
							return e
					}
				},
				uE = Object(s.c)({
					idsByQuery: aE,
					models: dE
				});
			const lE = {};
			var bE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c: {
							const {
								viewTreatment: n,
								key: s
							} = t.payload;
							return n ? Object.assign({}, e, {
								[s]: n
							}) : e
						}
						default:
							return e
					}
				},
				pE = Object(s.c)({
					relatedQueries: sE,
					searchQuery: rE,
					typeahead: uE,
					viewTreatment: bE
				}),
				fE = n("./src/reddit/models/SearchDiscoveryUnit/index.ts");
			const mE = {};
			var OE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c: {
						const {
							categoryName: n,
							key: s,
							listingOrder: r,
							postOrder: o,
							posts: a,
							searchQuery: c,
							subreddits: i,
							viewTreatment: d
						} = t.payload, u = {
							subredditIcons: [],
							displayText: null,
							subredditOccurrences: 0,
							searchQuery: c
						};
						if (d === fE.c.Trending || n) {
							const e = [];
							if (r && r.map(t => {
									!e.includes(t.id) && i[t.id] && (e.push(t.id), u.subredditIcons.push({
										url: i[t.id].icon.url,
										subredditName: i[t.id].name
									}), u.displayText || (u.displayText = i[t.id].displayText))
								}), o)
								for (let t = 0; t < o.length; t++) {
									const n = a[o[t]],
										s = n && n.belongsTo ? n.belongsTo.id : void 0;
									s && !e.includes(s) && i[s] && (e.push(s), u.subredditIcons.push({
										url: i[s].icon.url,
										subredditName: i[s].name
									}))
								}
							i && (u.subredditOccurrences = Object.keys(i).length - 1)
						}
						return Object.assign({}, e, {
							[s]: u
						})
					}
					default:
						return e
				}
			};
			const gE = {};
			var _E = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c: {
						const {
							key: n,
							searchDiscoveryUnits: s
						} = t.payload;
						return s && Object.keys(s).length ? Object.assign({}, e, {
							[n]: s
						}) : e
					}
					default:
						return e
				}
			};
			const yE = {};
			var jE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c: {
							const {
								key: n,
								searchDiscoveryUnitOrder: s
							} = t.payload;
							return s ? Object.assign({}, e, {
								[n]: s
							}) : yE
						}
						default:
							return e
					}
				},
				hE = Object(s.c)({
					headerContent: OE,
					models: _E,
					order: jE
				});
			Object(Ke.a)("SEO__CRAWLER_RECEIVED");
			var EE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "SEO__CRAWLER_RECEIVED":
							return t.payload;
						default:
							return e
					}
				},
				IE = n("./src/reddit/actions/seo/linksModule.ts");
			const vE = {};
			var SE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case IE.a:
							return Array.isArray(t.payload) && 0 !== t.payload.length ? Object.assign({}, e, {
								frontpage: t.payload
							}) : e;
						case IE.b:
							return t.payload && t.payload.id && t.payload.data ? Object.assign({}, e, {
								subreddits: Object.assign({}, e.subreddits, {
									[t.payload.id]: t.payload.data
								})
							}) : e;
						default:
							return e
					}
				},
				TE = Object(s.c)({
					crawler: EE,
					linksModule: SE
				}),
				DE = n("./src/reddit/actions/shortcuts/constants.ts");
			var CE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case DE.a:
						return t.payload;
					case p.a:
						return null;
					default:
						return e
				}
			};
			var wE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case DE.b:
							return t.payload || null;
						default:
							return e
					}
				},
				AE = n("./src/reddit/constants/history.ts"),
				RE = n("./src/reddit/constants/shortcuts.ts"),
				PE = n("./src/reddit/helpers/history/index.ts");
			const kE = RE.d.Global,
				xE = e => {
					switch (e.name) {
						case "comments":
						case "duplicates":
						case "metaMembershipPaywallPage":
							return Object(PE.b)(AE.a.IsOverlay) ? RE.d.Lightbox : RE.d.CommentPage;
						case "rpan":
						case "subredditCreation":
							return Object(PE.b)(AE.a.IsOverlay) ? RE.d.Lightbox : kE;
						case "index":
						case "listing":
						case "multireddit":
						case "searchResults":
						case "subreddit":
							return RE.d.Listing;
						case "modQueuePages":
							return RE.d.Modqueue;
						default:
							return kE
					}
				};
			var NE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.a:
							const n = t.payload;
							if (n.routeMatch) {
								const e = n.routeMatch.route.meta;
								return xE(e)
							}
							return kE;
						default:
							return e
					}
				},
				LE = Object(s.c)({
					activeCommentId: CE,
					activePostId: wE,
					namespace: NE
				});
			var UE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					if (e) return e;
					switch (t.type) {
						case $t.d:
						case $t.e:
							return !0;
						default:
							return e
					}
				},
				ME = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				FE = Object(s.c)({
					firstFetch: UE,
					models: ME.b
				}),
				GE = n("./src/reddit/actions/streaming/constants.ts");
			const BE = {};
			var qE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case GE.a: {
							const {
								subredditId: n,
								modSettings: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				VE = Object(s.c)({
					modSettings: qE
				}),
				KE = n("./src/reddit/models/StructuredStyles/index.ts");
			const HE = {};
			var WE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : HE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case g.h:
						case g.b:
						case g.d:
							return t.payload.styles;
						case g.e:
							return HE;
						case g.c: {
							const n = t.payload;
							return Object.assign({}, e, n)
						}
						case g.k: {
							const e = t.payload;
							return Object(KE.h)(e.styles)
						}
						default:
							return e
					}
				},
				YE = n("./src/reddit/actions/exportImportStyles.ts");
			var QE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case YE.c:
					case YE.b:
						return null;
					case YE.a:
						return t.payload;
					default:
						return e
				}
			};
			var zE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case YE.c:
							return !0;
						case YE.b:
						case YE.a:
							return !1;
						default:
							return e
					}
				},
				JE = Object(s.c)({
					error: QE,
					pending: zE
				}),
				XE = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				ZE = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const $E = {};
			var eI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $E,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Fe.b:
						case se.b:
						case ce.c:
						case We.c:
						case Be.b:
						case Co.a: {
							const {
								payload: n
							} = t;
							if (!n.structuredStyles || !n.structuredStyles.data) return e;
							const s = n.structuredStyles.data.flairTemplate;
							return Object.assign({}, e, s)
						}
						case XE.b: {
							const {
								flairId: n,
								template: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case XE.a: {
							const {
								flairId: n
							} = t.payload;
							return Object(ol.a)(e, n)
						}
						case EO.b: {
							const {
								templateId: n
							} = t.payload;
							return Object(ol.a)(e, n)
						}
						case g.k:
							return $E;
						case ZE.b: {
							const {
								templates: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				tI = Object(s.c)({
					models: eI
				});
			const nI = {};
			var sI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.f: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.imageKey]: n.uploadId
						})
					}
					case g.k:
					case g.e:
						return nI;
					default:
						return e
				}
			};
			var rI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.n:
					case g.e:
						return !1;
					case g.a:
						return !0;
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			var oI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.d:
						return t.payload.subredditId;
					case g.e:
						return null;
					case p.a:
						return t.payload.location.search.indexOf("styling=true") > -1 ? e : null;
					case wl.f:
						return null;
					default:
						return e
				}
			};
			const aI = {};
			var cI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Fe.b:
						case se.b:
						case Be.b:
						case Co.a: {
							const {
								payload: n
							} = t;
							if (!n.structuredStyles || !n.structuredStyles.data) return e;
							const s = Object.keys(n.subredditAboutInfo || {});
							if (1 !== s.length) return e;
							const r = s[0],
								o = n.structuredStyles.data.style;
							return Object.assign({}, e, {
								[r]: o
							})
						}
						case We.c:
						case ce.c: {
							const {
								payload: n
							} = t;
							if (!n.structuredStyles || !n.structuredStyles.data) return e;
							if (!n.subredditName) return e;
							let s;
							if (In()(n.subreddits, (e, t) => {
									if (e.name.toLowerCase() === n.subredditName.toLowerCase()) return s = t, !1
								}), !s) return e;
							const r = n.structuredStyles.data.style;
							return Object.assign({}, e, {
								[s]: r
							})
						}
						case g.m: {
							const n = t.payload,
								s = e[n.subredditId];
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, s, n.styles)
							})
						}
						case g.h: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.subredditId]: n.styles
							})
						}
						case g.k: {
							const n = t.payload,
								s = Object(KE.h)(n.styles);
							return Object.assign({}, e, {
								[n.subredditId]: s
							})
						}
						case Zf.k: {
							const n = t.payload,
								{
									banner: s,
									profile: r
								} = n;
							if (!s || !r) return e;
							const o = e[r.id];
							return Object.assign({}, e, {
								[r.id]: Object.assign({}, o, {
									bannerBackgroundImage: s.url
								})
							})
						}
						case wl.l: {
							const n = t.payload;
							if ("profileBanner" === n.key) {
								return ig(e, {
									[n.subredditId]: {
										bannerBackgroundImage: n.imageUrl
									}
								})
							}
							return e
						}
						case wl.k: {
							const n = t.payload;
							if ("profileBanner" === n.key) {
								return ig(e, {
									[n.subredditId]: {
										bannerBackgroundImage: void 0
									}
								})
							}
							return e
						}
						default:
							return e
					}
				},
				iI = Object(s.c)({
					draft: WE,
					exportStyles: JE,
					flairTemplate: tI,
					imagePreviews: sI,
					isBladeEditorDirty: rI,
					isEditing: oI,
					models: cI
				});
			Object(Ke.a)("STYLESHEETS__EXTRACTED_FROM_MANIFEST");
			var dI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "STYLESHEETS__EXTRACTED_FROM_MANIFEST":
							return t.payload;
						default:
							return e
					}
				},
				uI = n("./src/reddit/actions/subredditAutocomplete.ts");
			const lI = {};
			var bI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case uI.c:
					case uI.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case uI.a: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const pI = {};
			var fI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case uI.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case uI.b:
						case uI.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				mI = Object(s.c)({
					error: bI,
					pending: fI
				});
			const OI = {};
			var gI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case uI.b: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: t.payload
							})
						}
						default:
							return e
					}
				},
				_I = Object(s.c)({
					api: mI,
					models: gI
				});
			const yI = {};
			var jI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xn.c: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case xn.a:
					case xn.d: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					default:
						return e
				}
			};
			const hI = {};
			var EI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xn.d: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case xn.a:
					case xn.c: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					default:
						return e
				}
			};
			const II = {};
			var vI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : II,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xn.d: {
							const {
								subredditId: n
							} = t.payload;
							return e[n] ? e : Object.assign({}, e, {
								[n]: !1
							})
						}
						case xn.a: {
							const {
								subredditId: n,
								isSubredditWhitelisted: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case xn.c: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				SI = Object(s.c)({
					error: jI,
					pending: EI,
					whitelist: vI
				}),
				TI = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
					}
					return n
				};
			const DI = {};
			var CI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xn.a:
						return Object.assign({}, e, t.payload.collection);
					case xn.e: {
						const {
							channel: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.channelId]: Object.assign({}, n)
						})
					}
					case xn.f: {
						const {
							channel: n,
							editedSubredditChannelData: s
						} = t.payload;
						return n.name = s.room, n.description = s.description, n.minimumAcctAge = n.minimumAcctAge, n.newMemberAge = n.newMemberAge, Object.assign({}, e, {
							[n.channelId]: Object.assign({}, n)
						})
					}
					case xn.g: {
						const n = t.payload;
						e[n];
						return TI(e, ["symbol" == typeof n ? n : n + ""])
					}
					default:
						return e
				}
			};
			var wI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xn.h:
							return t.payload.channelId;
						case xn.g:
							return e === t.payload ? null : e;
						default:
							return e
					}
				},
				AI = Object(s.c)({
					api: SI,
					models: CI,
					selected: wI
				}),
				RI = n("./src/reddit/actions/subredditMention/constants.ts");
			const PI = {};
			var kI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RI.d:
					case Fe.b:
					case se.b:
					case ce.c:
					case ie.a:
					case ie.c:
					case Be.b:
					case Co.a:
					case re.b:
					case re.e:
					case qe.b:
					case qe.a:
					case qe.e:
					case qe.d:
					case oe.e:
					case de.b:
					case de.e:
					case We.c:
					case ll.e: {
						const n = t.payload.subredditAboutInfo;
						if (!n) return e;
						const s = Object.keys(n);
						return 0 === s.length ? e : s.reduce((e, t) => (n[t] && (e[t] ? e[t] = Object.assign({}, e[t], n[t]) : e[t] = n[t]), e), Object.assign({}, e))
					}
					case Pc.a: {
						const {
							subredditId: n,
							emojisEnabled: s
						} = t.payload, r = e[n], o = Object.assign({}, r, {
							emojisEnabled: s
						});
						return Object.assign({}, e, {
							[n]: o
						})
					}
					case tm.h: {
						const {
							identifiers: n,
							userIsSubscriber: s
						} = t.payload, r = n.filter(e => e.type === Zy.a.SUBREDDIT);
						return r.length ? r.reduce((e, t) => Object(F.setIn)(e, [t.id, "userIsSubscriber"], s), e) : e
					}
					case Ki.g:
					case nn.f:
					case fl.e:
					case fl.m: {
						const {
							subredditsAboutInfo: n
						} = t.payload;
						if (!n) return e;
						const s = Object.keys(n);
						return 0 === s.length ? e : s.reduce((e, t) => (n[t] && (e[t] = e[t] ? Object.assign({}, e[t], n[t]) : n[t]), e), Object.assign({}, e))
					}
					case Pc.b: {
						const n = t.payload,
							{
								emojiCustomSize: s,
								subredditId: r
							} = n,
							o = e[r];
						if (!o) return e;
						const a = Object.assign({}, o);
						if (s) {
							const {
								width: e,
								height: t
							} = s;
							a.emojisCustomSize = [e, t]
						} else delete a.emojisCustomSize;
						return Object.assign({}, e, {
							[r]: a
						})
					}
					case ue.c: {
						const {
							data: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case ge.r: {
						const {
							subredditId: n,
							subredditCoins: s
						} = t.payload;
						if (!n || !s) return e;
						const r = e[n];
						if (!r) return e;
						const o = Object.assign({}, r, {
							coins: s
						});
						return Object.assign({}, e, {
							[n]: o
						})
					}
					default:
						return e
				}
			};
			const xI = {};
			var NI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.b:
					case ue.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case ue.a: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: s
						})
					}
					default:
						return e
				}
			};
			var LI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.b:
							return !0;
						case ue.c:
						case ue.a:
							return !1;
						default:
							return e
					}
				},
				UI = Object(s.c)({
					error: NI,
					pending: LI
				}),
				MI = n("./src/reddit/actions/subredditCreation.ts");
			const FI = {
				apiError: null
			};
			var GI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MI.b: {
						const {
							error: n
						} = t.payload;
						return Object.assign({}, e, {
							apiError: n
						})
					}
					case MI.a:
					case MI.c:
					case MI.d:
						return FI;
					default:
						return e
				}
			};
			var BI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MI.d: {
						const {
							subredditName: e
						} = t.payload;
						return e || null
					}
					case MI.c:
					case MI.b:
						return null;
					default:
						return e
				}
			};
			var qI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case MI.c:
							return !0;
						case MI.d:
						case MI.b:
							return !1;
						default:
							return e
					}
				},
				VI = Object(s.c)({
					error: GI,
					lastCreatedSubredditId: BI,
					pending: qI
				});
			var KI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case fl.r:
							return !0;
						case fl.s:
						case fl.q:
							return !1;
						default:
							return e
					}
				},
				HI = Object(s.c)({
					pending: KI
				});
			const WI = {};
			var YI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : WI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.l:
					case ue.m: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case ue.k: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: s
						})
					}
					default:
						return e
				}
			};
			const QI = {};
			var zI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.l: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !0
							})
						}
						case ue.m:
						case ue.k: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				JI = Object(s.c)({
					error: YI,
					pending: zI
				});
			const XI = {};
			var ZI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : XI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case fl.d:
						case fl.e:
							return Object.assign({}, e, {
								[t.payload.key]: !1
							});
						case fl.f:
							return Object.assign({}, e, {
								[t.payload.key]: !0
							});
						default:
							return e
					}
				},
				$I = Object(s.c)({
					pending: ZI
				});
			var ev = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fl.i: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case fl.k:
					case fl.j:
						return null;
					default:
						return e
				}
			};
			var tv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case fl.k:
							return !0;
						case fl.j:
						case fl.i:
							return !1;
						default:
							return e
					}
				},
				nv = Object(s.c)({
					error: ev,
					pending: tv
				}),
				sv = n("./src/reddit/actions/subredditRules/constants.ts");
			var rv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case sv.c:
							return !0;
						case sv.a:
						case sv.b:
							return !1;
						default:
							return e
					}
				},
				ov = n("./src/reddit/actions/subredditSettings.ts");
			var av = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ov.c:
							return !0;
						case ov.d:
						case ov.b:
							return !1;
						default:
							return e
					}
				},
				cv = Object(s.c)({
					pending: av
				});
			const iv = {};
			var dv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case fl.l:
						case fl.m:
							return Object.assign({}, e, {
								[t.payload.key]: !1
							});
						case fl.n:
							return Object.assign({}, e, {
								[t.payload.key]: !0
							});
						default:
							return e
					}
				},
				uv = Object(s.c)({
					pending: dv
				}),
				lv = n("./src/reddit/actions/pages/subredditWiki/constants.ts");
			const bv = {};
			var pv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lv.c:
					case lv.b: {
						const n = t.payload,
							{
								subredditName: s
							} = n.options;
						return Object.assign({}, e, {
							[s.toLowerCase()]: null
						})
					}
					case lv.a: {
						const n = t.payload,
							{
								options: s,
								error: r
							} = n,
							{
								subredditName: o
							} = s;
						return Object.assign({}, e, {
							[o.toLowerCase()]: r
						})
					}
					default:
						return e
				}
			};
			const fv = {};
			var mv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lv.c: {
							const n = t.payload,
								{
									subredditName: s
								} = n.options;
							return Object.assign({}, e, {
								[s.toLowerCase()]: !0
							})
						}
						case lv.b:
						case lv.a: {
							const n = t.payload,
								{
									subredditName: s
								} = n.options;
							return Object.assign({}, e, {
								[s.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Ov = Object(s.c)({
					error: pv,
					pending: mv
				});
			const gv = {};
			var _v = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case rg.c:
					case rg.b: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case rg.a: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: s
						})
					}
					default:
						return e
				}
			};
			const yv = {};
			var jv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case rg.c: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !0
							})
						}
						case rg.b:
						case rg.a: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				hv = Object(s.c)({
					error: _v,
					pending: jv
				}),
				Ev = Object(s.c)({
					about: UI,
					create: VI,
					inlineEditing: HI,
					models: JI,
					onboarding: $I,
					rankings: nv,
					rules: rv,
					settings: cv,
					similar: uv,
					topContent: hv,
					wiki: Ov
				}),
				Iv = n("./node_modules/lodash/isNil.js"),
				vv = n.n(Iv);
			const Sv = {};
			var Tv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.d: {
							const {
								subredditId: n,
								forceState: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: vv()(s) ? !e[n] : s
							})
						}
						default:
							return e
					}
				},
				Dv = Object(s.c)({
					meta: Tv
				});
			const Cv = {};
			var wv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nn.f: {
						const {
							categoryId: n,
							subredditIds: s
						} = t.payload;
						return gn()(s) ? e : Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Av = {};
			var Rv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Av,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.c: {
							const {
								communityInfo: n,
								id: s,
								type: r
							} = t.payload;
							return n && "subreddit" === r ? Object.assign({}, e, {
								[s]: n
							}) : e
						}
						default:
							return e
					}
				},
				Pv = n("./src/reddit/actions/subredditCrosspostable.ts");
			var kv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pv.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case Pv.c:
					case Pv.b:
						return null;
					default:
						return e
				}
			};
			var xv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Pv.c:
							return !0;
						case Pv.b:
						case Pv.a:
							return !1;
						default:
							return e
					}
				},
				Nv = Object(s.c)({
					errors: kv,
					pending: xv
				});
			const Lv = {};
			var Uv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Pv.b: {
							const {
								subredditIds: n
							} = t.payload;
							return hs()(e, n) ? e : n
						}
						default:
							return e
					}
				},
				Mv = Object(s.c)({
					api: Nv,
					ids: Uv
				});
			const Fv = {};
			var Gv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lg.a: {
							const n = t.payload,
								{
									subredditId: s,
									distinguishKey: r,
									postIds: o
								} = n;
							if (!(s in e)) return Object.assign({}, e, {
								[s]: {
									[r]: o
								}
							});
							const a = e[s];
							return ig(a, {
								[r]: o
							}) === a ? e : Object.assign({}, e, {
								[s]: Object.assign({}, a, {
									[r]: o
								})
							})
						}
						default:
							return e
					}
				},
				Bv = Object(s.c)({
					models: Gv
				});
			const qv = {};
			var Vv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							assets: n,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					case b.g:
					case b.j: {
						const {
							subredditId: n,
							mainHeader: s
						} = t.payload, r = e[n] || {};
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								mainHeader: s
							})
						})
					}
					default:
						return e
				}
			};
			const Kv = {};
			var Hv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							communityJar: n,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Wv = {};
			var Yv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: t.payload
						})
					}
					case d.i: {
						const {
							communityRaw: n,
							subredditId: s
						} = t.payload;
						return n ? Object.assign({}, e, {
							[s]: n
						}) : e
					}
					default:
						return e
				}
			};
			const Qv = {};
			var zv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							subredditId: n,
							distribution: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Jv = {};
			var Xv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							subredditId: n,
							meta: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Zv = {};
			var $v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.q: {
							const {
								subredditId: n,
								releaseNotes: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				eS = Object(s.c)({
					assets: Vv,
					communityJar: Hv,
					communityRaw: Yv,
					distributions: zv,
					meta: Xv,
					releaseNotes: $v
				}),
				tS = n("./node_modules/lodash/isEqualWith.js"),
				nS = n.n(tS),
				sS = n("./src/lib/forceHttps/index.ts");
			const rS = {},
				oS = (e, t) => {
					const n = Object.keys(t);
					return n.length ? n.reduce((n, s) => {
						const r = e[s],
							o = t[s],
							a = r ? Object.assign({}, r, o) : Object.assign({}, o);
						return o.icon.url ? a.icon.url = Object(sS.a)(o.icon.url) : r && r.icon.url ? a.icon = r.icon : a.icon.url = "", r && r.allowChatPostCreation && (a.allowChatPostCreation = !0), Object(F.set)(n, s, a)
					}, e) : e
				},
				aS = (e, t) => {
					return !nS()(e, t, (e, t, n) => {
						if ("subscribers" === n) return !0
					})
				},
				cS = (e, t) => {
					if (!t) return e;
					const n = Object.keys(t);
					if (!n.length) return e;
					const s = {};
					for (let r = 0; r < n.length; r++) {
						const o = n[r],
							a = e[o],
							c = t[o];
						a && !aS(a, c) || (s[o] = c)
					}
					return Object.keys(s).length ? Object.assign({}, e, s) : e
				};
			var iS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tm.c:
						return oS(e, t.payload.subreddits || {});
					case RI.d:
					case nn.f:
					case Ue.b:
					case Ki.g:
					case Ge.e:
					case Ge.h:
					case ne.k:
					case Me.r:
					case Me.u:
					case Zf.h:
					case ul.b:
					case Fe.b:
					case se.b:
					case se.g:
					case se.k:
					case re.b:
					case re.e:
					case ae.c:
					case ae.i:
					case ae.e:
					case ae.g:
					case qe.b:
					case qe.e:
					case oe.b:
					case oe.e:
					case Zf.e:
					case ce.c:
					case ie.c:
					case Be.b:
					case Fr.e:
					case Co.a:
					case Zf.l:
					case de.b:
					case de.e:
					case Ve.b:
					case "RECOMMENDED_POSTS_LOADED":
					case We.c:
					case ue.c:
					case ue.f:
					case ue.i:
					case fl.a:
					case fl.e:
					case fl.m:
					case ll.e:
					case ll.b:
						return cS(e, t.payload.subreddits || {});
					case ne.f:
					case ne.i:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							subreddits: s
						} = n;
						return cS(e, s)
					}
					case We.e: {
						const {
							typeaheadSuggestions: n
						} = t.payload;
						return cS(e, n.subreddits || {})
					}
					case Me.B: {
						const {
							subreddits: n
						} = t.payload;
						return Object.assign({}, n, e)
					}
					case d.g: {
						const n = t.payload;
						return cS(e, n)
					}
					case g.m: {
						const n = t.payload,
							{
								subredditId: s,
								styles: r
							} = n;
						return "communityIcon" in r && e[s] && "string" == typeof r.communityIcon ? Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								communityIcon: r.communityIcon
							})
						}) : e
					}
					case ov.d: {
						const {
							settings: n
						} = t.payload, {
							subredditId: s,
							title: r
						} = n;
						return e[s] && void 0 !== r ? Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								title: r
							})
						}) : e
					}
					default:
						return e
				}
			};
			var dS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.e: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case ue.g:
					case ue.f:
						return null;
					default:
						return e
				}
			};
			var uS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.g:
					case ue.f:
						return !0;
					case ue.e:
						return !1;
					default:
						return e
				}
			};
			var lS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.g:
							return !0;
						case ue.f:
						case ue.e:
							return !1;
						default:
							return e
					}
				},
				bS = Object(s.c)({
					errors: dS,
					fetched: uS,
					pending: lS
				});
			var pS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.f: {
							const {
								subreddits: e
							} = t.payload, n = Object.keys(e);
							return n.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), n
						}
						default:
							return e
					}
				},
				fS = Object(s.c)({
					api: bS,
					order: pS
				});
			const mS = {};
			var OS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fl.e: {
						const {
							key: n,
							subredditIds: s
						} = t.payload;
						return 0 === s.length ? e : Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const gS = {};
			var _S = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.g: {
						const {
							subredditId: n,
							products: s
						} = t.payload, r = Object.keys(s).reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const yS = {};
			var jS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fl.b: {
						const {
							categoryRankingsKey: n
						} = t.payload, s = e[n], r = s && s.length ? [...s, ...t.payload.rankings] : t.payload.rankings;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const hS = {};
			var ES = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fl.c: {
						const {
							categoryRankingsKey: n,
							pageInfo: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const IS = {};
			var vS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sv.b: {
						const {
							rules: n,
							subredditId: s
						} = t.payload, r = {
							[s]: {
								rules: n.rules
							}
						};
						return Object.assign({}, e, r)
					}
					case sv.e: {
						const {
							rules: n,
							subredditId: s
						} = t.payload, r = {
							[s]: {
								rules: [...e[s].rules, ...n.rules]
							}
						};
						return Object.assign({}, e, r)
					}
					case sv.f: {
						const {
							rules: n,
							subredditId: s,
							oldName: r
						} = t.payload;
						n.rules.shortName !== r && (e[s].rules = e[s].rules.filter(e => e.shortName !== r));
						const o = {
							[s]: {
								rules: [...n.rules, ...e[s].rules]
							}
						};
						return o[s].rules.sort((e, t) => e.priority - t.priority), Object.assign({}, e, o)
					}
					case sv.g:
					case sv.d: {
						const {
							rules: n,
							subredditId: s
						} = t.payload, r = {
							[s]: {
								rules: n.rules
							}
						};
						return Object.assign({}, e, r)
					}
					default:
						return e
				}
			};
			const SS = {};
			var TS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ov.a: {
						const e = t.payload;
						return {
							[e.subredditId]: e
						}
					}
					case ov.d: {
						const n = t.payload.settings,
							s = e[n.subredditId] || {};
						return Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, s, n)
						})
					}
					case wl.n: {
						const n = t.payload,
							s = e[n.subredditId] || {},
							r = Object.assign({}, s, n.settings);
						return Object.assign({}, e, {
							[n.subredditId]: r
						})
					}
					default:
						return e
				}
			};
			const DS = {};
			var CS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case fl.m: {
							const {
								key: n,
								subredditIds: s
							} = t.payload;
							return 0 === s.length ? e : Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				wS = n("./src/reddit/actions/wiki/wikiDiff/constants.ts");
			const AS = {};
			var RS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wS.b: {
						const {
							key: n,
							htmlDiff: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {
								htmlDiff: s
							}
						})
					}
					case wS.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								pending: !0
							})
						})
					}
					case wS.a: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								pending: !1,
								error: s
							})
						})
					}
					default:
						return e
				}
			};
			const PS = {};
			var kS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lv.b:
							const n = t.payload,
								{
									subredditWiki: s,
									options: r
								} = n,
								o = s && s.directory;
							if (!o) return e;
							const {
								subredditName: a
							} = r;
							return Object.assign({}, e, {
								[a.toLowerCase()]: o
							});
						default:
							return e
					}
				},
				xS = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const NS = {};
			var LS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lv.b: {
							const {
								subredditWiki: n,
								pageKey: s
							} = t.payload, {
								page: r
							} = n;
							return s && r ? Object.assign({}, e, {
								[s]: r
							}) : e
						}
						case xS.a: {
							const {
								pageKey: n,
								page: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				US = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const MS = {};
			var FS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : MS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case US.c: {
						const {
							settings: n,
							pageKey: s
						} = t.payload;
						return n ? Object.assign({}, e, {
							[s]: n
						}) : e
					}
					case US.d: {
						const {
							isVisible: n,
							editPermissions: s,
							pageKey: r
						} = t.payload, o = e[r];
						return o ? Object.assign({}, e, {
							[r]: Object.assign({}, o, {
								isVisible: n,
								editPermissions: s
							})
						}) : e
					}
					case US.b: {
						const {
							editorsInfo: n,
							afterToken: s,
							pageKey: r
						} = t.payload, o = e[r];
						if (!o) return e;
						const a = [...o.editorsInfo, ...n];
						return Object.assign({}, e, {
							[r]: Object.assign({}, o, {
								editorsInfo: a,
								afterToken: s
							})
						})
					}
					case US.a: {
						const {
							username: n,
							pageKey: s
						} = t.payload, r = e[s];
						if (!r) return e;
						const o = r.editorsInfo.filter(e => e.username !== n);
						return Object.assign({}, e, {
							[s]: Object.assign({}, r, {
								editorsInfo: o
							})
						})
					}
					default:
						return e
				}
			};
			const GS = {};
			var BS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xS.b: {
						const {
							key: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case xS.d:
					case xS.c: {
						const {
							key: n
						} = t.payload;
						return Object(ol.a)(e, n)
					}
					default:
						return e
				}
			};
			const qS = {};
			var VS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xS.d:
						case xS.b:
						case xS.c: {
							const {
								key: n
							} = t.payload, s = t.type === xS.d;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				KS = Object(s.c)({
					error: BS,
					pending: VS
				}),
				HS = n("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const WS = {};
			var YS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : WS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xS.c: {
						const {
							key: n,
							options: s,
							pageInfo: r,
							revisionsIds: o
						} = t.payload, a = e[n], c = s.after && a ? [...a.ids, ...o] : o;
						return Object.assign({}, e, {
							[n]: {
								ids: c,
								pageInfo: r
							}
						})
					}
					case xS.a: {
						const {
							page: {
								revision: n
							},
							pageRevisionsListingKey: s,
							recentRevisionsListingKey: r
						} = t.payload, o = e[s];
						return o && n ? Object.assign({}, Object(ol.a)(e, r), {
							[s]: Object.assign({}, o, {
								ids: [n.id, ...o.ids]
							})
						}) : e
					}
					case HS.a: {
						const {
							pageRevisionsListingKey: n,
							recentRevisionsListingKey: s
						} = t.payload, r = Object.assign({}, e);
						return delete r[n], delete r[s], r
					}
					default:
						return e
				}
			};
			const QS = {};
			var zS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lv.b: {
							const {
								subredditWiki: {
									page: n
								}
							} = t.payload, s = n && n.revision;
							return s && !e[s.id] ? Object.assign({}, e, {
								[s.id]: s
							}) : e
						}
						case xS.c: {
							const {
								revisions: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						case xS.a: {
							const {
								page: n
							} = t.payload, s = n.revision;
							return s ? Object.assign({}, e, {
								[s.id]: s
							}) : e
						}
						case xS.e: {
							const {
								revisionId: n,
								isHidden: s
							} = t.payload, r = e[n];
							return r ? Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									isHidden: s
								})
							}) : e
						}
						default:
							return e
					}
				},
				JS = Object(s.c)({
					api: KS,
					listings: YS,
					models: zS
				}),
				XS = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const ZS = {};
			var $S = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ZS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case XS.c:
					case XS.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const eT = {};
			var tT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case XS.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case XS.d:
					case XS.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(ol.a)(e, n)
					}
					default:
						return e
				}
			};
			const nT = {};
			var sT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case XS.d:
						case XS.c:
						case XS.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === XS.d;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				rT = Object(s.c)({
					error: tT,
					pending: sT
				});
			const oT = {};
			var aT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case XS.c:
					case XS.a: {
						const {
							subredditName: n,
							bannedContributors: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], s)
						})
					}
					case XS.e: {
						const {
							subredditName: n,
							bannedContributor: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], s)
						})
					}
					case XS.f: {
						const {
							subredditName: n,
							userId: s
						} = t.payload, r = Object(ol.a)(e[n], s);
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const cT = {};
			var iT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case XS.c:
						case XS.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Bg()([...e[n] || [], ...s])
							})
						}
						case XS.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Bg()([...s, ...e[n] || []])
							})
						}
						case XS.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: (e[n] || []).filter(e => e !== s)
							})
						}
						default:
							return e
					}
				},
				dT = Object(s.c)({
					afterToken: $S,
					api: rT,
					models: aT,
					userOrder: iT
				});
			const uT = {};
			var lT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case XS.g: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				bT = Object(s.c)({
					listing: dT,
					search: lT
				}),
				pT = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const fT = {};
			var mT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pT.c:
					case pT.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const OT = {};
			var gT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pT.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case pT.d:
					case pT.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(ol.a)(e, n)
					}
					default:
						return e
				}
			};
			const _T = {};
			var yT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _T,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pT.d:
						case pT.c:
						case pT.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === pT.d;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				jT = Object(s.c)({
					error: gT,
					pending: yT
				});
			const hT = {};
			var ET = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pT.c:
					case pT.a: {
						const {
							subredditName: n,
							contributors: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], s)
						})
					}
					case pT.e: {
						const {
							subredditName: n,
							contributor: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], s)
						})
					}
					case pT.f: {
						const {
							subredditName: n,
							userId: s
						} = t.payload, r = Object(ol.a)(e[n], s);
						return Object.assign({}, e, {
							newState: r
						})
					}
					default:
						return e
				}
			};
			const IT = {};
			var vT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pT.c:
						case pT.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Bg()([...e[n] || [], ...s])
							})
						}
						case pT.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: [...s, ...e[n] || []]
							})
						}
						case pT.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: (e[n] || []).filter(e => e !== s)
							})
						}
						default:
							return e
					}
				},
				ST = Object(s.c)({
					afterToken: mT,
					api: jT,
					models: ET,
					userOrder: vT
				});
			const TT = {};
			var DT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : TT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pT.g: {
							const {
								subredditName: n,
								contributor: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				CT = Object(s.c)({
					listing: ST,
					search: DT
				}),
				wT = Object(s.c)({
					diff: RS,
					directory: kS,
					pages: LS,
					pageSettings: FS,
					revisions: JS,
					wikiBannedContributors: bT,
					wikiContributors: CT
				});
			const AT = {};
			var RT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ki.g: {
						const {
							subredditTopContent: n
						} = t.payload;
						return Object.assign({}, e, n.subredditTopContent)
					}
					case rg.b: {
						const {
							subredditTopContent: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			const PT = [];
			var kT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.g:
					case ie.c: {
						const {
							trendingSubredditIds: n
						} = t.payload;
						return n && n.length ? n : e
					}
					default:
						return e
				}
			};
			const xT = {};
			var NT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case RI.d:
							const {
								unavailableSubreddits: n
							} = t.payload;
							return Object.assign({}, e, n);
						default:
							return e
					}
				},
				LT = Object(s.c)({
					about: kI,
					api: Ev,
					appliedFilters: Dv,
					byCategory: wv,
					communityInfo: Rv,
					crosspostable: Mv,
					duplicates: Bv,
					gov: eS,
					models: iS,
					moderated: fS,
					onboarding: OS,
					products: _S,
					rankings: jS,
					rankingsPageInfo: ES,
					rules: vS,
					settings: TS,
					similar: CS,
					subredditWiki: wT,
					topContent: RT,
					trending: kT,
					unavailableModels: NT
				});
			const UT = {};
			var MT = Object(y_.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : UT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c: {
							const {
								postIds: n,
								posts: s
							} = t.payload, r = n.slice(0, 2).reduce((e, t) => {
								if (s[t].isStickied) {
									const n = s[t].belongsTo.id;
									e[n] ? e[n].push(t) : e[n] = [t]
								}
								return e
							}, {});
							return Pe()(Object.assign({}, e), r)
						}
						case j.p: {
							const {
								newStickiedPostList: n,
								subredditId: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				}), UT),
				FT = Object(s.c)({
					data: MT
				});
			const GT = [];
			var BT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tm.d: {
						const {
							makeFavorite: n,
							multiredditsModelsState: s,
							multiredditPath: r
						} = t.payload;
						if (n) {
							const t = [...e],
								n = Xf(t, r, (e, t) => s[e].displayText.toLowerCase() > s[t].displayText.toLowerCase() ? 1 : -1);
							return t.splice(n, 0, r), t
						}
						return e.filter(e => e !== r)
					}
					case Me.u: {
						const {
							multireddits: e
						} = t.payload;
						return lr()(e).filter(e => e.isFavorited).sort((e, t) => e.displayText.toLowerCase() > t.displayText.toLowerCase() ? 1 : -1).map(e => e.url)
					}
					case tm.e: {
						const {
							follow: n,
							multiredditPath: s
						} = t.payload;
						return n ? e : e.filter(e => e !== s)
					}
					case Me.j: {
						const n = t.payload;
						return e.filter(e => e !== n)
					}
					default:
						return e
				}
			};
			var qT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tm.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case tm.b:
					case tm.c:
						return null;
					default:
						return e
				}
			};
			var VT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tm.b:
					case tm.c:
						return !0;
					case tm.a:
						return !1;
					default:
						return e
				}
			};
			var KT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tm.b:
							return !0;
						case tm.c:
						case tm.a:
							return !1;
						default:
							return e
					}
				},
				HT = Object(s.c)({
					errors: qT,
					fetched: VT,
					pending: KT
				});
			const WT = [];
			var YT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : WT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tm.c: {
						const {
							profiles: e,
							favoriteProfileIds: n,
							favoriteSubredditIds: s
						} = t.payload;
						let r;
						return (r = n && n.length ? n : s ? s.filter(t => !!e[t]) : []).sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), r
					}
					case tm.f: {
						const {
							makeFavorite: n,
							identifier: s,
							profileModels: r
						} = t.payload, {
							id: o,
							type: a
						} = s;
						if (a !== Zy.a.PROFILE) return e;
						const c = e ? e.slice() : [];
						if (n) {
							const e = Xf(c, o, (e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1);
							c.splice(e, 0, o)
						} else {
							const e = c.indexOf(o);
							c.splice(e, 1)
						}
						return c
					}
					case tm.h: {
						const {
							identifiers: n,
							userIsSubscriber: s
						} = t.payload, r = n.filter(t => t.type === Zy.a.PROFILE && e.indexOf(t.id) > -1);
						return !r.length || s ? e : r.reduce((e, t) => {
							const n = e.indexOf(t.id);
							return e.splice(n, 1), e
						}, [...e])
					}
					default:
						return e
				}
			};
			const QT = [];
			var zT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tm.c: {
						const {
							subreddits: e,
							favoriteSubredditIds: n
						} = t.payload, s = n ? n.filter(t => !!e[t]) : [];
						return s.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), s
					}
					case tm.f: {
						const {
							makeFavorite: n,
							identifier: s,
							subredditModels: r
						} = t.payload, {
							id: o,
							type: a
						} = s;
						if (a !== Zy.a.SUBREDDIT) return e;
						const c = e ? e.slice() : [];
						if (n) {
							const e = Xf(c, o, (e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1);
							c.splice(e, 0, o)
						} else {
							const e = c.indexOf(o);
							c.splice(e, 1)
						}
						return c
					}
					case tm.h: {
						const {
							identifiers: n,
							userIsSubscriber: s
						} = t.payload, r = n.filter(t => t.type === Zy.a.SUBREDDIT && e.indexOf(t.id) > -1);
						return !r.length || s ? e : r.reduce((e, t) => {
							const n = e.indexOf(t.id);
							return e.splice(n, 1), e
						}, [...e])
					}
					default:
						return e
				}
			};
			const JT = [],
				XT = e => (t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1;
			var ZT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.u: {
							const {
								multireddits: n
							} = t.payload, s = lr()(n).map(e => {
								let {
									url: t
								} = e;
								return t.toLowerCase()
							}).sort(XT(n));
							return hs()(e, s) ? e : s
						}
						case se.k: {
							const {
								account: n,
								multireddits: s,
								multiredditsByUser: r,
								multiredditsModelsState: o
							} = t.payload;
							if (!n) return e;
							const a = r[n.id];
							if (!a || !a.length) return e;
							const c = Object.assign({}, o, s),
								i = Jf()(e, a).sort(XT(c));
							return hs()(e, i) ? e : i
						}
						case tm.e: {
							const {
								follow: n,
								multiredditPath: s,
								multiredditsModelsState: r
							} = t.payload;
							return n ? [...e, s].sort(XT(r)) : e.filter(e => e !== s)
						}
						case Me.j: {
							const n = t.payload;
							return e.filter(e => e !== n)
						}
						case Me.g:
						case Me.m: {
							const {
								multireddit: n,
								multiredditsModelsState: s
							} = t.payload, r = Object.assign({}, s, {
								[n.url]: n
							});
							return [...e, n.url].sort(XT(r))
						}
						default:
							return e
					}
				},
				$T = n("./node_modules/lodash/difference.js"),
				eD = n.n($T);
			const tD = [];
			var nD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Zf.m: {
						const {
							profileOrder: n
						} = t.payload;
						return Bg()([...e, ...n])
					}
					case tm.c: {
						const {
							profiles: e
						} = t.payload, n = Object.keys(e);
						return n.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), n
					}
					case tm.h: {
						const {
							identifiers: n,
							profileModels: s,
							userIsSubscriber: r
						} = t.payload, o = n.filter(e => e.type === Zy.a.PROFILE);
						if (!o.length) return e;
						const a = o.map(e => e.id);
						return r ? Bg()([...e, ...a]).sort((e, t) => s[e].displayText.toLowerCase() > s[t].displayText.toLowerCase() ? 1 : -1) : eD()(e, a)
					}
					default:
						return e
				}
			};
			const sD = [];
			var rD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zf.m: {
							const {
								subredditOrder: n
							} = t.payload;
							return Bg()([...e, ...n])
						}
						case tm.c: {
							const {
								subreddits: e
							} = t.payload, n = Object.keys(e);
							return n.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), n
						}
						case tm.h: {
							const {
								identifiers: n,
								subredditModels: s,
								userIsSubscriber: r
							} = t.payload, o = n.filter(e => e.type === Zy.a.SUBREDDIT && !!e.id);
							if (!o.length) return e;
							const a = o.map(e => e.id);
							return r ? Bg()([...e, ...a]).sort((e, t) => s[e].displayText.toLowerCase() > s[t].displayText.toLowerCase() ? 1 : -1) : eD()(e, a)
						}
						default:
							return e
					}
				},
				oD = Object(s.c)({
					api: HT,
					favoriteMultiOrder: BT,
					favoriteProfileOrder: YT,
					favoriteSubredditOrder: zT,
					multiredditOrder: ZT,
					profileOrder: nD,
					subredditOrder: rD
				}),
				aD = n("./src/reddit/actions/tabBadging.ts");
			var cD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case aD.a:
							const {
								hasUnreadMessages: n
							} = t.payload;
							return n;
						default:
							return e
					}
				},
				iD = n("./src/reddit/actions/tags/constants.ts");
			const dD = {
				pending: !1,
				error: !1
			};
			var uD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case iD.l:
						return Object.assign({}, e, {
							pending: !0
						});
					case iD.m:
						return {
							error: !1, pending: !1
						};
					case iD.k:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const lD = {
				pending: !1,
				error: !1
			};
			var bD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case iD.o:
						return Object.assign({}, e, {
							pending: !0
						});
					case iD.p:
						return {
							error: !1, pending: !1
						};
					case iD.n:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const pD = {
				pending: !1,
				error: !1
			};
			var fD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case iD.t:
						return Object.assign({}, e, {
							pending: !0
						});
					case iD.s:
					case iD.r:
					case iD.e:
					case iD.j:
						return {
							error: !1, pending: !1
						};
					case iD.q:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const mD = {
				pending: !1,
				error: !1
			};
			var OD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case iD.v:
						return Object.assign({}, e, {
							pending: !0
						});
					case iD.w:
						return {
							error: !1, pending: !1
						};
					case iD.u:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const gD = {
				pending: !1,
				error: !1
			};
			var _D = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case iD.g:
							return Object.assign({}, e, {
								pending: !0
							});
						case iD.h:
							return {
								error: !1, pending: !1
							};
						case iD.f:
							return {
								error: !0, pending: !1
							};
						default:
							return e
					}
				},
				yD = Object(s.c)({
					create: uD,
					deleteTag: bD,
					fetch: fD,
					update: OD,
					updatePrimaryTag: _D
				});
			const jD = {
				global: [],
				recommendedGlobal: []
			};
			var hD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case iD.w:
						case iD.r:
						case iD.e:
						case iD.j: {
							const {
								globalSubredditTags: e
							} = t.payload, n = Object.keys(e), s = n.filter(t => e[t].isRecommended);
							return {
								global: n,
								recommendedGlobal: s
							}
						}
						default:
							return e
					}
				},
				ED = n("./node_modules/lodash/uniqWith.js"),
				ID = n.n(ED),
				vD = n("./src/reddit/models/Option/index.ts");
			const SD = {
				selectedOptions: [],
				tagInput: "",
				selectedPrimaryTagId: null
			};
			var TD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case iD.d: {
							const {
								option: n
							} = t.payload;
							return Object.assign({}, e, {
								selectedOptions: ID()([...e.selectedOptions || [], Object.assign({}, n)], vD.a)
							})
						}
						case iD.c: {
							const {
								option: n
							} = t.payload, s = e.selectedOptions.findIndex(e => Object(vD.a)(e, n));
							return e.selectedOptions.splice(s, 1), Object.assign({}, e, {
								selectedOptions: e.selectedOptions
							})
						}
						case iD.b: {
							const {
								input: n
							} = t.payload;
							return Object.assign({}, e, {
								tagInput: n
							})
						}
						case iD.a: {
							const {
								primaryTagId: n
							} = t.payload, s = e.selectedOptions.findIndex(e => e.id === n), r = [...e.selectedOptions];
							return s >= 0 && r.splice(s, 1), Object.assign({}, e, {
								selectedPrimaryTagId: n,
								selectedOptions: r
							})
						}
						default:
							return e
					}
				},
				DD = n("./src/reddit/helpers/tags/index.ts");
			const CD = {
				globalSubredditTags: {},
				subredditScopedTags: {},
				itemTags: {},
				suggestedItemTags: {},
				sortedItemTags: {},
				subredditPrimaryTagId: {}
			};
			var wD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case iD.j: {
							const {
								globalSubredditTags: n,
								subredditScopedTags: s,
								subredditId: r
							} = t.payload;
							return Object.assign({}, e, {
								globalSubredditTags: Object.assign({}, e.globalSubredditTags, n),
								subredditScopedTags: Object.assign({}, e.subredditScopedTags, {
									[r]: Object.assign({}, e.subredditScopedTags[r] || {}, s[r] || {})
								})
							})
						}
						case iD.w:
						case iD.s:
						case iD.r: {
							const {
								primaryTag: n,
								globalSubredditTags: s,
								subredditScopedTags: r,
								itemTags: o,
								suggestedItemTags: a,
								subredditId: c
							} = t.payload, i = Object.assign({}, e.subredditPrimaryTagId);
							return n ? i[c] = n.tag.id : delete i[c], {
								subredditPrimaryTagId: i,
								globalSubredditTags: Object.assign({}, e.globalSubredditTags, s),
								subredditScopedTags: Object.assign({}, e.subredditScopedTags, {
									[c]: Object.assign({}, e.subredditScopedTags[c] || {}, r[c] || {})
								}),
								itemTags: Object.assign({}, e.itemTags, {
									[c]: Object.assign({}, o[c] || {})
								}),
								suggestedItemTags: Object.assign({}, e.suggestedItemTags, {
									[c]: Object.assign({}, a[c] || {})
								}),
								sortedItemTags: Object.assign({}, e.sortedItemTags, {
									[c]: Object(DD.a)(o[c] || {})
								})
							}
						}
						case iD.p: {
							const {
								subredditId: n,
								tags: s
							} = t.payload, r = s.reduce((e, t) => {
								let {
									tagId: n
								} = t;
								return delete e[n], e
							}, Object.assign({}, e.subredditScopedTags[n] || {}));
							return Object.assign({}, e, {
								subredditScopedTags: Object.assign({}, e.subredditScopedTags, {
									[n]: r
								})
							})
						}
						case iD.e: {
							const {
								globalSubredditTags: n
							} = t.payload;
							return Object.assign({}, e, {
								globalSubredditTags: Object.assign({}, e.globalSubredditTags, n)
							})
						}
						case iD.h: {
							const {
								subredditId: n,
								primaryTagId: s,
								secondaryTags: r
							} = t.payload;
							return s && n ? Object.assign({}, e, {
								subredditPrimaryTagId: Object.assign({}, e.subredditPrimaryTagId, {
									[n]: s
								}),
								itemTags: Object.assign({}, e.itemTags, {
									[n]: Object.assign({}, r || {})
								})
							}) : e
						}
						case iD.i: {
							const {
								subredditId: n,
								primaryTagId: s
							} = t.payload;
							return s && n ? Object.assign({}, e, {
								subredditPrimaryTagId: Object.assign({}, e.subredditPrimaryTagId, {
									[n]: s
								})
							}) : e
						}
						default:
							return e
					}
				},
				AD = n("./src/reddit/reducers/tags/selected/index.ts"),
				RD = Object(s.c)({
					api: yD,
					availableGlobalTagOrder: hD,
					models: wD,
					selected: AD.b,
					creation: TD
				}),
				PD = n("./src/reddit/actions/redditEmbed.ts"),
				kD = n("./src/reddit/actions/theme.ts"),
				xD = n("./src/reddit/actions/users.ts"),
				ND = n("./src/reddit/models/Theme/index.ts");
			const LD = {
				current: ND.c,
				cached: {}
			};
			var UD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : LD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case kD.a: {
							const {
								nightmode: e
							} = t.payload;
							return {
								current: e ? ND.b : ND.c,
								cached: {}
							}
						}
						case Cr.a:
						case Cr.b:
						case Cr.h:
						case Cr.i:
						case Cr.f:
						case Cr.j:
						case Ge.e:
						case Ge.h:
						case Fe.a:
						case se.a:
						case Fe.b:
						case se.b:
						case Fe.d:
						case se.d:
						case se.g:
						case ie.c:
						case se.k:
						case se.j:
						case Ue.b:
						case PD.b:
						case ue.i:
						case We.c:
						case ce.c:
						case wl.j:
						case Be.b:
						case Co.a:
						case xD.c:
							if (t.payload && t.payload.preferences && t.payload.preferences.nightmode) {
								const {
									nightmode: e
								} = t.payload.preferences;
								return e ? {
									current: ND.b,
									cached: {}
								} : {
									current: ND.c,
									cached: {}
								}
							}
							return e;
						case re.d:
						case re.e:
						case qe.a:
						case qe.b:
						case qe.d:
						case qe.e:
						case oe.d:
						case oe.e: {
							const {
								account: n
							} = t.payload;
							return n ? n.nightmode ? {
								current: ND.b,
								cached: {}
							} : {
								current: ND.c,
								cached: {}
							} : e
						}
						case ne.h:
						case ne.j:
						case ne.i:
						case ne.g:
						case ne.f:
						case ne.n:
						case ne.m:
						case ne.p:
						case ne.q:
						case ne.w:
						case ne.v:
							if (t.payload && t.payload.response && t.payload.response.preferences && t.payload.response.preferences.nightmode) {
								const {
									nightmode: e
								} = t.payload.response.preferences;
								return e ? {
									current: ND.b,
									cached: {}
								} : {
									current: ND.c,
									cached: {}
								}
							}
							return e;
						case wl.i: {
							if (!t.payload) return e;
							const {
								nightmode: n
							} = t.payload;
							return n ? {
								current: ND.b,
								cached: {}
							} : {
								current: ND.c,
								cached: {}
							}
						}
						case g.d:
							return {
								current: ND.c, cached: {}
							};
						case g.e:
							return t.payload.nightmodeTempUpdated ? {
								current: ND.b,
								cached: {}
							} : e;
						default:
							return e
					}
				},
				MD = n("./src/reddit/actions/toaster.ts");
			const FD = [];
			var GD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case MD.c: {
							const n = t.payload,
								s = [];
							let r = !1;
							for (const t of e) {
								const e = t.id === n.id ? n : t;
								s.push(e), r = r || e === n
							}
							return r || s.push(n), s
						}
						case MD.b: {
							const n = t.payload;
							return e.filter(e => e.id !== n)
						}
						default:
							return e
					}
				},
				BD = n("./src/reddit/actions/tooltip.ts");
			var qD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case BD.c: {
						const {
							tooltipId: n
						} = t.payload;
						return e === n ? null : n
					}
					case BD.a: {
						const {
							tooltipId: n
						} = t.payload;
						return e === n ? e : n
					}
					case BD.b: {
						const {
							tooltipId: n
						} = t.payload;
						return null !== e ? e : n || null
					}
					case BD.e: {
						const {
							tooltipId: n
						} = t.payload;
						return e === n ? null : e
					}
					case ge.I:
					case BD.d:
					case p.a:
					case yu.b:
					case yu.c:
					case yu.a:
						return null;
					default:
						return e
				}
			};
			const VD = {};
			var KD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : VD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ll.e:
						case ll.b:
							return Object.assign({}, e, t.payload.topics);
						default:
							return e
					}
				},
				HD = Object(s.c)({
					models: KD
				}),
				WD = n("./src/reddit/actions/tracing.ts");
			const YD = {
				traceId: void 0
			};
			var QD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case WD.a:
							return t.payload ? {
								traceId: t.payload
							} : e;
						default:
							return e
					}
				},
				zD = n("./src/reddit/actions/tracking.ts");
			const JD = {};
			var XD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case zD.a: {
							const {
								routeKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case zD.b: {
							const {
								routeKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				ZD = Object(s.c)({
					viewportDataLoaded: XD
				}),
				$D = n("./src/reddit/actions/trafficStats/constants.ts");
			var eC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $D.c:
						return !0;
					case $D.b:
					case $D.a:
						return !1;
					default:
						return e
				}
			};
			var tC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $D.b: {
							const {
								trafficStats: e
							} = t.payload;
							return e
						}
						case $D.c:
							return null;
						default:
							return e
					}
				},
				nC = Object(s.c)({
					pending: eC,
					trafficStats: tC
				});
			var sC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.t:
					case l.u:
						return null;
					case l.r: {
						const {
							error: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var rC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.t:
							return !0;
						case l.r:
						case l.u:
							return !1;
						default:
							return e
					}
				},
				oC = Object(s.c)({
					error: sC,
					pending: rC
				});
			var aC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.s:
						return (t.payload ? t.payload.contentId : null) || null;
					case r.b:
					case l.u:
						return null;
					default:
						return e
				}
			};
			var cC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.s:
						return (t.payload ? t.payload.recipient : "") || "";
					case l.u:
						return "";
					default:
						return e
				}
			};
			var iC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.s:
							return t.payload && t.payload.publicAddress || null;
						case r.b:
						case l.u:
							return null;
						default:
							return e
					}
				},
				dC = Object(s.c)({
					api: oC,
					contentId: aC,
					initialRecipient: cC,
					publicAddress: iC
				}),
				uC = Object(s.c)({
					communityPoints: dC
				}),
				lC = n("./src/reddit/actions/search/trending.ts");
			const bC = [];
			var pC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case lC.a: {
							const {
								items: n
							} = t.payload;
							return n || e
						}
						default:
							return e
					}
				},
				fC = Object(s.c)({
					models: pC
				});
			const mC = {};
			var OC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Tj.a: {
							const {
								trophies: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				gC = n("./src/reddit/models/Upload/index.ts");
			const _C = {};
			var yC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _C,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Mo.d: {
						const {
							key: n,
							id: s,
							file: r
						} = t.payload, o = e[n], a = o && o.file === r ? Object.assign({}, o.metadata) : {};
						return Object.assign({}, e, {
							[n]: {
								key: n,
								id: s,
								file: r,
								metadata: a,
								url: void 0,
								status: gC.a.PENDING
							}
						})
					}
					case Mo.h: {
						const {
							key: n
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								status: gC.a.UPLOADING
							})
						})
					}
					case Mo.c: {
						const {
							key: n,
							metadata: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								metadata: s
							})
						})
					}
					case Mo.e: {
						const {
							key: n,
							progress: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								progress: s
							})
						})
					}
					case Mo.g: {
						const {
							key: n,
							url: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								status: gC.a.SUCCESS,
								url: s
							})
						})
					}
					case Mo.b: {
						const {
							key: n,
							error: s
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								status: gC.a.FAILED,
								error: s
							})
						})
					}
					case Mo.a: {
						const {
							key: n
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								status: gC.a.CANCELED
							})
						})
					}
					case Mo.f: {
						const {
							key: n
						} = t.payload, s = e[n];
						return s.metadata.localUrl && window.URL.revokeObjectURL(s.metadata.localUrl), Ss()(e, n)
					}
					case f.C:
						return Ss()(e, us.m);
					default:
						return e
				}
			};
			const jC = {};
			var hC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a: {
							const {
								subredditId: n,
								wallet: s
							} = t.payload;
							if (!s) return e;
							const r = e[n] || {};
							return Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									latest: s,
									byDate: Object.assign({}, r.byDate || {}, {
										[s.at]: s
									})
								})
							})
						}
						case l.x: {
							const n = t.payload,
								s = Object.assign({}, e);
							return Object.keys(n).forEach(t => {
								const r = n[t],
									o = e[t],
									a = {
										latest: o ? o.latest.at <= r.at ? r : o.latest : r,
										byDate: Object.assign({}, o ? o.byDate : {}, {
											[r.at]: r
										})
									};
								s[t] = a
							}), s
						}
						case m.d: {
							const {
								product: n,
								wallet: s
							} = t.payload, r = e[n.subredditId] || {};
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, r, {
									[s.at]: s,
									latest: s
								})
							})
						}
						case l.u: {
							const {
								subredditId: n,
								wallet: s
							} = t.payload, r = e[n] || {};
							return Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									[s.at]: s,
									latest: s
								})
							})
						}
						default:
							return e
					}
				},
				EC = n("./src/reddit/actions/inbox.ts"),
				IC = n("./src/reddit/actions/pages/appeal/constants.ts"),
				vC = n("./src/reddit/actions/pages/userDataRequest/index.ts"),
				SC = n("./src/reddit/actions/sso/constants.ts");
			const TC = (e, t) => {
				if (!t || hs()(e, t)) return e;
				const {
					awardeeKarma: n,
					awarderKarma: s,
					commentKarma: r,
					postKarma: o,
					totalKarma: a
				} = t, c = e ? e.awardeeKarma : 0, i = e ? e.awarderKarma : 0, d = n || c, u = s || i, l = a || d + u + o + r;
				return Object.assign({}, t, {
					awardeeKarma: d,
					awarderKarma: u,
					totalKarma: l
				})
			};
			var DC = Object(y_.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case IC.a:
					case IC.b:
					case Fh.b:
					case Fh.c:
					case Cr.a:
					case Cr.b:
					case Cr.f:
					case Cr.h:
					case Cr.i:
					case Cr.j:
					case Ge.e:
					case Ge.h:
					case Ge.g:
					case Me.q:
					case Me.r:
					case Fe.a:
					case se.a:
					case Fe.b:
					case se.b:
					case se.f:
					case se.g:
					case se.j:
					case se.k:
					case ie.a:
					case re.b:
					case re.a:
					case re.e:
					case re.d:
					case ae.c:
					case ae.i:
					case qe.e:
					case qe.d:
					case qe.b:
					case qe.a:
					case oe.e:
					case oe.d:
					case ie.c:
					case ce.a:
					case ce.c:
					case Be.b:
					case Co.a:
					case We.a:
					case We.c:
					case PD.a:
					case PD.b:
					case wl.j:
					case vC.b:
					case xD.c:
					case ll.e:
						return TC(e, t.payload.account);
					case xD.n:
						return e ? Object.assign({}, e, {
							email: t.payload
						}) : e;
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case ne.h:
					case ne.e:
					case ne.l:
					case ne.o:
					case ne.u: {
						const {
							response: n
						} = t.payload;
						return n ? TC(e, n.account) : e
					}
					case xD.a:
						return e ? Object.assign({}, e, {
							seenLayoutSwitch: !0
						}) : e;
					case r.d:
						return e ? Object.assign({}, e, {
							seenRedesignModal: !0
						}) : e;
					case ge.v:
						return e ? Object.assign({}, e, {
							seenGiveAwardTooltip: !0
						}) : e;
					case wl.l:
					case wl.k: {
						const n = t.payload;
						return e && "profileIcon" === n.key ? Object.assign({}, e, {
							accountIcon: n.imageUrl
						}) : e
					}
					case ge.B:
					case ge.r: {
						const {
							coins: n
						} = t.payload;
						return e ? Object.assign({}, e, {
							coins: n
						}) : e
					}
					case ge.a: {
						const {
							userName: n,
							awarderKarma: s,
							awardeeKarma: r
						} = t.payload;
						if (n.toLowerCase() !== (e && Object(be.e)(e).toLowerCase())) return e;
						const o = r || (e ? e.awardeeKarma : 0) || 0,
							a = s || (e ? e.awarderKarma : 0) || 0,
							c = o + a + (e ? e.postKarma : 0) + (e ? e.commentKarma : 0);
						return e && Object.assign({}, e, {
							awardeeKarma: o,
							awarderKarma: a,
							totalKarma: c
						})
					}
					case Sd.i: {
						const {
							coins: n
						} = t.payload;
						return n && e ? Object.assign({}, e, {
							coins: n
						}) : e
					}
					case EC.a: {
						const {
							inboxCount: n
						} = t.payload;
						return e ? Object.assign({}, e, {
							inboxCount: n
						}) : e
					}
					case SC.a: {
						const {
							linkedIdentity: n
						} = t.payload, s = e && e.linkedIdentities || [];
						return e ? Object.assign({}, e, {
							linkedIdentities: [...s, n]
						}) : e
					}
					case SC.b: {
						const {
							linkedIdentity: n
						} = t.payload, s = e && e.linkedIdentities || [];
						return e ? Object.assign({}, e, {
							linkedIdentities: s.filter(e => e !== n)
						}) : e
					}
					case Du.c: {
						const {
							username: n
						} = t.payload;
						return e ? Object.assign({}, e, {
							displayText: n,
							isNameEditable: !1,
							url: "/user/".concat(n),
							username: n
						}) : e
					}
					default:
						return e
				}
			}), null);
			var CC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xD.m:
					case xD.n:
						return null;
					case xD.l:
						return t.payload;
					default:
						return e
				}
			};
			var wC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xD.m:
							return !0;
						case xD.n:
						case xD.l:
							return !1;
						default:
							return e
					}
				},
				AC = Object(s.c)({
					error: CC,
					pending: wC
				}),
				RC = Object(s.c)({
					api: AC
				});
			var PC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xD.j:
						return !0;
					default:
						return e
				}
			};
			var kC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xD.i:
							return !0;
						case xD.j:
						case xD.h:
							return !1;
						default:
							return e
					}
				},
				xC = Object(s.c)({
					pending: kC,
					emailSent: PC
				}),
				NC = Object(s.c)({
					api: xC
				}),
				LC = Object(s.c)({
					changeEmail: RC,
					sendResetEmail: NC
				}),
				UC = n("./src/reddit/models/WhitelistAndBlocked.ts");
			const MC = {};
			var FC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : MC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Wt.f:
						return Object.assign({}, e, {
							new: UC.a.pending
						});
					case Wt.d:
						return Object.assign({}, e, {
							new: UC.a.error
						});
					case Wt.e:
						return Object.assign({}, e, {
							new: UC.a.waitingForRequest
						});
					case Wt.b: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: UC.a.pending
						})
					}
					case Wt.a: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: UC.a.error
						})
					}
					case Wt.c: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: UC.a.waitingForRequest
						})
					}
					default:
						return e
				}
			};
			const GC = [];
			var BC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Wt.e:
							return [t.payload, ...e];
						case Wt.c: {
							const n = t.payload.name;
							return e.filter(e => e.name !== n)
						}
						case wl.j:
							return t.payload.blockedUsers;
						default:
							return e
					}
				},
				qC = Object(s.c)({
					api: FC,
					data: BC
				}),
				VC = n("./src/reddit/actions/chat/constants.ts"),
				KC = n("./src/reddit/actions/chat/userSettings.ts");
			const HC = VC.a.anybody;
			var WC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : HC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case KC.a:
							if (t.payload) {
								const {
									invitePolicy: e
								} = t.payload;
								return e
							}
							return e;
						default:
							return e
					}
				},
				YC = Object(s.c)({
					invitePolicy: WC
				});
			const QC = (e, t) => void 0 === t || e && t === e.count ? e : Object.assign({}, e, {
				count: t
			});
			var zC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b: {
						const {
							drafts: n
						} = t.payload;
						return e && hs()(e, n) ? e : Object.assign({}, e, n)
					}
					case f.N: {
						const {
							response: {
								draftsCount: n
							}
						} = t.payload;
						return QC(e, n)
					}
					case Fr.e: {
						const {
							postDraftIds: n
						} = t.payload;
						return QC(e, n.length)
					}
					case Fr.c:
					case Fr.l: {
						const {
							draftsCount: n
						} = t.payload;
						return QC(e, n)
					}
					default:
						return e
				}
			};
			const JC = {};
			var XC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Dn.a: {
						const n = t.payload;
						return null === n.local_persisted_experiments_store || void 0 === n.local_persisted_experiments_store ? e : n.local_persisted_experiments_store
					}
					default:
						return e
				}
			};
			const ZC = [];
			var $C = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ZC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qc.a:
							return t.payload.experimentVariants.map(e => {
								let {
									id: t,
									experimentName: n,
									name: s,
									version: r
								} = e;
								return {
									id: parseInt(t),
									name: n,
									variant: s || void 0,
									version: r
								}
							});
						default:
							return e
					}
				},
				ew = Object(s.c)({
					models: $C,
					localPersisted: XC
				});
			var tw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wl.e:
						return !0;
					case wl.d:
						return !1;
					default:
						return e
				}
			};
			var nw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "en",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wl.g:
						return t.payload;
					case wl.j:
						return "string" == typeof t.payload.language ? t.payload.language : e;
					default:
						return e
				}
			};
			const sw = {
				blob: "",
				loid: "",
				loidCreated: "",
				version: -1
			};
			var rw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xD.b:
							return t.payload;
						default:
							return e
					}
				},
				ow = n("./src/reddit/actions/notifications/constants.ts");
			var aw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ow.b: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case ow.d:
					case ow.c:
						return null;
					default:
						return e
				}
			};
			var cw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ow.d:
						return !1;
					case ow.c:
						return !0;
					default:
						return e
				}
			};
			var iw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ow.d:
							return !0;
						case ow.c:
						case ow.b:
							return !1;
						default:
							return e
					}
				},
				dw = Object(s.c)({
					error: aw,
					loaded: cw,
					pending: iw
				});
			var uw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ow.i: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case ow.k:
					case ow.j:
						return null;
					default:
						return e
				}
			};
			var lw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ow.k:
						return !1;
					case ow.j:
						return !0;
					default:
						return e
				}
			};
			var bw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ow.k:
							return !0;
						case ow.j:
						case ow.i:
							return !1;
						default:
							return e
					}
				},
				pw = Object(s.c)({
					error: uw,
					loaded: lw,
					pending: bw
				}),
				fw = Object(s.c)({
					getPreferences: dw,
					setPreferences: pw
				});
			var mw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ow.l:
						return !0;
					case ow.e:
					case ow.g:
					case ow.h:
						return !1;
					default:
						return e
				}
			};
			const Ow = {
				broadcastFollower: !1,
				broadcastRecommendation: !1,
				chatMessages: !1,
				chatRequests: !1,
				commentReplies: !1,
				communityRecommendations: !1,
				liveEvent: !1,
				postFlairAdded: !1,
				postReplies: !1,
				privateMessages: !1,
				threadReplies: !1,
				topLevelComment: !1,
				trendingPosts: !1,
				upvotedComments: !1,
				upvotedPosts: !1,
				usernameMentions: !1,
				userNewFollowers: !1
			};
			var gw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ow,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ow.c:
						case ow.k:
						case ow.i: {
							const {
								preferences: n
							} = t.payload;
							return gn()(n) ? e : n
						}
						default:
							return e
					}
				},
				_w = Object(s.c)({
					api: fw,
					isNotificationPromptVisible: mw,
					preferences: gw
				});
			const yw = {};
			var jw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.i:
						case i.i: {
							const {
								subredditId: n,
								userOwnedBadges: s
							} = t.payload, r = s.reduce((e, t) => (e[t] = !0, e), {});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n] || {}, r)
							})
						}
						case m.d: {
							const {
								userOwnedBadges: n,
								product: s
							} = t.payload, r = n.reduce((e, t) => (e[t] = !0, e), {});
							return Object.assign({}, e, {
								[s.subredditId]: Object.assign({}, e[s.subredditId] || {}, r)
							})
						}
						default:
							return e
					}
				},
				hw = n("./src/reddit/reducers/user/prefs/index.ts");
			var Ew = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xD.d:
							return t.payload;
						default:
							return e
					}
				},
				Iw = n("./src/reddit/actions/session.ts");
			var vw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Iw.a:
					case Iw.b:
					case Iw.c:
					case Iw.e:
						return t.payload;
					case Iw.d:
						return null;
					default:
						return e
				}
			};
			var Sw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Iw.f:
						return !0;
					default:
						return e
				}
			};
			var Tw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xD.k:
						return t.payload;
					default:
						return e
				}
			};
			var Dw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qc.a: {
						const e = t.payload;
						return e.identity && e.identity.isEmployee
					}
					default:
						return e
				}
			};
			var Cw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qc.a:
							return t.payload.isLoggedIn;
						default:
							return e
					}
				},
				ww = Object(s.c)({
					isEmployee: Dw,
					isLoggedIn: Cw
				});
			var Aw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wl.r: {
							const {
								topContentDismissal: n
							} = t.payload;
							return e && hs()(e, n) ? e : Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				Rw = n("./src/reddit/actions/userWhitelist.ts");
			const Pw = {};
			var kw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Rw.e:
						return Object.assign({}, e, {
							new: UC.a.pending
						});
					case Rw.d:
						return Object.assign({}, e, {
							new: UC.a.error
						});
					case Rw.f:
						return Object.assign({}, e, {
							new: UC.a.waitingForRequest
						});
					case Rw.b: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: UC.a.pending
						})
					}
					case Rw.a: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: UC.a.error
						})
					}
					case Rw.c: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: UC.a.waitingForRequest
						})
					}
					default:
						return e
				}
			};
			const xw = [];
			var Nw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Rw.f:
							return [t.payload, ...e];
						case Rw.c: {
							const n = t.payload.name;
							return e.filter(e => e.name !== n)
						}
						case wl.j:
							return t.payload.whitelistedUsers;
						default:
							return e
					}
				},
				Lw = Object(s.c)({
					api: kw,
					data: Nw
				}),
				Uw = Object(s.c)({
					account: DC,
					accountSettings: LC,
					blocked: qC,
					chatSettings: YC,
					drafts: zC,
					experiments: ew,
					isCustomizeFlyoutShowing: tw,
					topContentDismissalPrefsSet: Aw,
					language: nw,
					loid: rw,
					notificationPrefs: _w,
					ownedBadges: jw,
					prefs: hw.b,
					reddaid: Ew,
					session: vw,
					sessionRefreshFailed: Sw,
					sessionTracker: Tw,
					temporaryGQL: ww,
					wallets: hC,
					whitelist: Lw
				});
			var Mw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vC.a:
						return t.payload;
					case vC.b:
					case vC.c:
						return null;
					default:
						return e
				}
			};
			var Fw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vC.c:
						return !0;
					case vC.b:
					case vC.a:
						return !1;
					default:
						return e
				}
			};
			var Gw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vC.b:
						return !0;
					case vC.a:
					case vC.c:
						return !1;
					default:
						return e
				}
			};
			var Bw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vC.b:
							return t.payload.userDataExportEligibility;
						case vC.a:
						case vC.c:
							return !1;
						default:
							return e
					}
				},
				qw = Object(s.c)({
					error: Mw,
					pending: Fw,
					success: Gw,
					userDataExportEligibility: Bw
				}),
				Vw = Object(s.c)({
					userDataRequestPageApi: qw
				});
			const Kw = {};
			var Hw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c:
					case Be.b:
					case Co.a:
					case Fe.b:
					case se.b:
					case le.e:
						return Object.assign({}, e, t.payload.userFlair);
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							userFlair: s
						} = n, r = Object.assign({}, e);
						return Object.keys(s).forEach(e => {
							r[e] || (r[e] = s[e])
						}), r
					}
					case le.i: {
						const {
							subredditId: n,
							applied: s,
							displaySettings: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								applied: s,
								displaySettings: r
							})
						})
					}
					case te.h: {
						const {
							subredditId: n,
							applied: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								applied: s
							})
						})
					}
					case le.d: {
						const {
							subredditId: n,
							isEnabled: s
						} = t.payload, r = e[n].displaySettings, o = Object.assign({}, r, {
							isEnabled: s
						});
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								displaySettings: o
							})
						})
					}
					case le.b: {
						const {
							subredditId: n,
							canAssignOwn: s
						} = t.payload, r = e[n].permissions, o = Object.assign({}, r, {
							canAssignOwn: s
						});
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								permissions: o
							})
						})
					}
					case le.h: {
						const n = t.payload,
							s = e[n.subredditId],
							r = e[n.subredditId].templates,
							o = e[n.subredditId].templateIds,
							a = Object.assign({}, r, {
								[n.template.id]: n.template
							}),
							c = [...o];
						return c.includes(n.template.id) || c.push(n.template.id), Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, s, {
								templates: a,
								templateIds: c
							})
						})
					}
					case le.c: {
						const n = t.payload,
							s = e[n.subredditId],
							r = e[n.subredditId].templates,
							o = e[n.subredditId].templateIds,
							a = Ss()(r, n.templateId),
							c = o.filter(e => e !== n.templateId);
						return Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, s, {
								templates: Object.assign({}, a),
								templateIds: c
							})
						})
					}
					case le.g:
					case le.f: {
						const n = t.payload,
							s = e[n.subredditId];
						return Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, s, {
								templateIds: n.templateIds
							})
						})
					}
					default:
						return e
				}
			};
			const Ww = {};
			var Yw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ww,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xD.g:
					case xD.f: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case xD.e: {
						const {
							username: n,
							error: s
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: s
						})
					}
					default:
						return e
				}
			};
			var Qw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xD.g:
							return !0;
						case xD.f:
						case xD.e:
							return !1;
						default:
							return e
					}
				},
				zw = Object(s.c)({
					error: Yw,
					pending: Qw
				});
			const Jw = {};
			var Xw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.f: {
						const {
							subredditId: n,
							usersAppliedBadges: s
						} = t.payload, r = Object.keys(s).reduce((t, r) => {
							const o = s[r];
							return t[r] = Object.assign({}, e[r] || {}, {
								[n]: o
							}), t
						}, {});
						return Object.assign({}, e, r)
					}
					case i.b: {
						const {
							badgeIds: n,
							subredditId: s,
							userId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r] || {}, {
								[s]: n
							})
						})
					}
					case i.a: {
						const {
							previousBadgeIds: n,
							subredditId: s,
							userId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r] || {}, {
								[s]: n
							})
						})
					}
					case d.a: {
						const {
							badge: n,
							currentAppliedBadges: s,
							placement: r,
							subredditId: o,
							userId: a
						} = t.payload, c = s.filter(e => e.placement !== r).concat(n).filter(Boolean).map(e => e.id);
						return Object.assign({}, e, {
							[a]: Object.assign({}, e[a] || {}, {
								[o]: c
							})
						})
					}
					default:
						return e
				}
			};
			const Zw = {},
				$w = (e, t) => {
					const n = Object.keys(t);
					if (!n.length) return e;
					const s = {};
					return n.forEach(n => {
						const r = e[n],
							o = t[n];
						r && hs()(r, o) || (s[n.toLowerCase()] = o)
					}), Object.keys(s).length ? Object.assign({}, e, s) : e
				};
			var eA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xD.f: {
							const {
								data: n
							} = t.payload;
							return $w(e, n)
						}
						case Zf.k: {
							const {
								user: n
							} = t.payload;
							return $w(e, {
								[n.username]: n
							})
						}
						case ge.r: {
							const {
								gildee: n
							} = t.payload;
							if (!n) return e;
							const s = e[n.toLowerCase()];
							if (!s) return e;
							const r = s.awardedLastMonth,
								o = r ? r.totalCount + 1 : 1,
								a = r && r.topAward;
							return a ? $w(e, {
								[n.toLowerCase()]: Object.assign({}, s, {
									awardedLastMonth: {
										totalCount: o,
										topAward: a
									}
								})
							}) : e
						}
						case ge.a: {
							const {
								userName: n,
								awardeeKarma: s,
								awarderKarma: r
							} = t.payload, o = e[n.toLowerCase()];
							if (!o) return e;
							const a = s || o.awardeeKarma,
								c = r || o.awarderKarma;
							return $w(e, {
								[n.toLowerCase()]: Object.assign({}, o, {
									awardeeKarma: a,
									awarderKarma: c,
									totalKarma: a + c + o.postKarma + o.commentKarma
								})
							})
						}
						case wl.l:
						case wl.k: {
							const {
								imageUrl: n,
								key: s,
								username: r
							} = t.payload;
							if ("profileIcon" !== s) return e;
							const o = r.toLowerCase(),
								a = e[o];
							return a ? $w(e, {
								[o]: Object.assign({}, a, {
									accountIcon: n
								})
							}) : e
						}
						default:
							return e
					}
				},
				tA = n("./src/reddit/actions/usernameAvailable.ts");
			const nA = {};
			var sA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tA.a: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: tA.b.Available
						})
					}
					case tA.c: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: tA.b.Error
						})
					}
					case tA.d: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: tA.b.Pending
						})
					}
					case tA.e: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: tA.b.Unavailable
						})
					}
					default:
						return e
				}
			};
			const rA = {};
			var oA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.o: {
							const {
								subredditId: n,
								wallets: s
							} = t.payload, r = Object.keys(s).reduce((t, r) => {
								const o = e[r] || {},
									a = Object.assign({}, o, {
										[n]: s[r]
									});
								return Object.assign({}, t, {
									[r]: a
								})
							}, {});
							return Object.assign({}, e, r)
						}
						default:
							return e
					}
				},
				aA = Object(s.c)({
					api: zw,
					appliedBadges: Xw,
					models: eA,
					nameAvailable: sA,
					publicWallets: oA
				});
			const cA = {};
			var iA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case se.b:
						case ie.c:
						case ue.i:
						case ce.c:
						case Be.b:
						case Co.a: {
							const {
								structuredStyles: n
							} = t.payload;
							if (!(n && n.data && n.data.content)) return e;
							const s = n.data.content.widgets.layout.idCardWidget,
								r = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== r.length) return e;
							const o = r[0];
							return Object.assign({}, e, {
								[o]: s
							})
						}
						default:
							return e
					}
				},
				dA = n("./src/reddit/actions/widgets/constants.ts");
			const uA = {};
			var lA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case se.b:
						case ce.c:
						case ue.i:
						case ie.c:
						case Be.b: {
							const {
								structuredStyles: n
							} = t.payload;
							if (!(n && n.data && n.data.content)) return e;
							const s = n.data.content.widgets.items,
								r = n.data.content.widgets.layout.topbar.order.filter(e => s[e] && "menu" === s[e].kind);
							if (!r.length) return e;
							const o = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== o.length) return e;
							const a = o[0];
							return Object.assign({}, e, {
								[a]: r[0]
							})
						}
						case dA.g: {
							const n = t.payload;
							return "menu" !== n.widget.kind ? e : Object.assign({}, e, {
								[n.subredditId]: n.widgetId
							})
						}
						case dA.h: {
							const n = t.payload;
							return e[n.subredditId] === n.widgetId ? Object.assign({}, e, {
								[n.subredditId]: null
							}) : e
						}
						default:
							return e
					}
				},
				bA = n("./src/reddit/models/Widgets/index.ts");
			const pA = {};
			var fA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c: {
						const n = t.payload,
							s = n.structuredStyles && n.structuredStyles.data && n.structuredStyles.data.content;
						if (!s) return e;
						const r = s.widgets;
						return Object.assign({}, e, r.items)
					}
					case dA.b: {
						const n = t.payload;
						return Object.assign({}, e, n.widgets.items)
					}
					case g.k: {
						const t = Object.assign({}, e);
						return Object.keys(t).forEach(e => {
							t[e] = Object.assign({}, t[e], {
								styles: Object(bA.m)()
							})
						}), t
					}
					case dA.e: {
						const n = t.payload;
						return Object.assign({}, e, n.widgets.items)
					}
					case dA.i:
					case dA.g: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.widget.id]: n.widget
						})
					}
					case dA.h: {
						const n = t.payload,
							s = Object.assign({}, e);
						return delete s[n.widgetId], s
					}
					case Fe.b:
					case se.b:
					case ie.c:
					case ue.i:
					case ce.c:
					case Be.b:
					case Co.a: {
						const {
							structuredStyles: n
						} = t.payload;
						if (!(n && n.data && n.data.content)) return e;
						const s = n.data.content.widgets;
						return Object.assign({}, e, s.items)
					}
					case tm.h: {
						const {
							userIsSubscriber: n,
							nameIdentifiers: s,
							widgetId: r
						} = t.payload;
						if (!r || !e[r] || "community-list" !== e[r].kind) return Object.assign({}, e);
						const o = n,
							a = e[r],
							c = a.data.map(e => {
								const t = Object.assign({}, e);
								return s.some(e => e.name === t.name) && (t.isSubscribed = o), t
							});
						return Object.assign({}, e, {
							[r]: Object.assign({}, a, {
								data: c
							})
						})
					}
					case ov.d: {
						const {
							settings: n,
							idCardWidgetId: s
						} = t.payload;
						return s && e[s] && "publicDescription" in n && n.publicDescription !== e[s].description ? Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								description: n.publicDescription || ""
							})
						}) : e
					}
					default:
						return e
				}
			};
			const mA = {};
			var OA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c:
					case se.b:
					case ue.i:
					case Be.b: {
						const {
							structuredStyles: n
						} = t.payload;
						if (!(n && n.data && n.data.content)) return e;
						const s = n.data.content.widgets.layout.moderatorWidget,
							r = Object.keys(t.payload.subredditAboutInfo || {});
						if (1 !== r.length) return e;
						const o = r[0];
						return Object.assign({}, e, {
							[o]: s
						})
					}
					default:
						return e
				}
			};
			const gA = {};
			var _A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Be.b:
						case Co.a: {
							const n = t.payload,
								s = n.structuredStyles && n.structuredStyles.data && n.structuredStyles.data.content;
							if (!s) return e;
							const r = Object.keys(n.subredditAboutInfo || {});
							if (1 !== r.length) return e;
							const o = r[0],
								a = s.widgets.layout.sidebar.order;
							return Object.assign({}, e, {
								[o]: a
							})
						}
						case dA.e:
						case dA.b: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.subredditId]: n.widgets.layout.sidebar.order
							})
						}
						case dA.f: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.subredditId]: n.widgetIds
							})
						}
						case dA.g: {
							const n = t.payload;
							if ("menu" === n.widget.kind) return e;
							if (!e[n.subredditId]) return Object.assign({}, e, {
								[n.subredditId]: [n.widgetId]
							});
							const s = e[n.subredditId].concat(n.widgetId);
							return Object.assign({}, e, {
								[n.subredditId]: s
							})
						}
						case dA.h: {
							const n = t.payload;
							if (!e[n.subredditId]) return e;
							const s = e[n.subredditId].filter(e => e !== n.widgetId);
							return Object.assign({}, e, {
								[n.subredditId]: s
							})
						}
						case Fe.b:
						case se.b:
						case ie.c:
						case ce.c:
						case ue.i:
						case Be.b:
						case Co.a: {
							const {
								structuredStyles: n
							} = t.payload;
							if (!(n && n.data && n.data.content)) return e;
							const s = n.data.content.widgets.layout.sidebar.order,
								r = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== r.length) return e;
							const o = r[0];
							return Object.assign({}, e, {
								[o]: s
							})
						}
						default:
							return e
					}
				},
				yA = Object(s.c)({
					idCardIds: iA,
					menuIds: lA,
					models: fA,
					moderatorIds: OA,
					sidebar: _A
				});
			t.a = Object(s.c)({
				accountManagerModalData: a,
				activeModalId: y,
				ads: S,
				apiRequestState: C,
				approvedSubmitters: z,
				authorFlair: Oe,
				awards: st,
				badges: gt,
				banned: Ut,
				blockedRedditors: Ht,
				blockUser: Zt,
				brandSafety: tn,
				categories: Rn,
				chat: Jn,
				claimGold: rs,
				comments: Js,
				commentsListTruncated: Zs,
				commentsPage: vr,
				communityFlairs: Dr,
				contentGate: Ar,
				continueThreads: kr,
				creations: Na,
				dashboard: Ma,
				discoveryUnits: Qa,
				dismissedTruncationList: Xa,
				downToChat: rc,
				economics: Rc,
				emojis: Bc,
				experimentOverrides: Wc,
				externalAccount: hi,
				featureFlags: Ci,
				flairedUsers: Vi,
				focusedVerticals: nd,
				fontFiles: rd,
				gild: _d,
				goldPurchase: gu,
				header: hu,
				imageUploads: vu,
				interceptedAction: Tu,
				isChangeUsernameTooltipShowing: Cu,
				isEmailVerificationTooltipShowing: Au,
				isModeratorWithPostPerms: Pu,
				jsApi: Nu,
				leaderboard: Qu,
				listings: Ul,
				live: Gl,
				mediaPlayback: Kl,
				meta: Yl,
				moderatingSubreddits: zl,
				moderationLog: ub,
				moderationPromptId: lb,
				moderators: Xb,
				modListingPage: rp,
				modModeEnabled: op,
				modQueue: af,
				moreComments: Of,
				multireddits: cm,
				muted: Tm,
				notificationBannerId: Cm,
				nps: Rm,
				oldSiteRules: xm,
				page: Mm,
				platform: Km,
				postCollection: hO,
				postRequirements: UO,
				polls: dO,
				postFlair: DO,
				posts: __,
				postStickiedComments: E_,
				givePremium: Id,
				products: U_,
				profileCommentsPage: Z_,
				profilePrivatePage: Xy,
				profileModSettingsPage: ny,
				profileOverviewPage: Fy,
				profilePostsPage: By,
				profiles: Rj,
				promos: Lj,
				publicAccessNetwork: fh,
				recommendations: Oh,
				removalReasons: Dh,
				reportFlow: Mh,
				reportPage: Qh,
				reportRules: Xh,
				requestHost: Zh,
				runTimeEnvVars: tE,
				search: pE,
				searchDiscoveryUnits: hE,
				seo: TE,
				shortcuts: LE,
				sidebarPromotedPosts: FE,
				streaming: VE,
				structuredStyles: iI,
				stylesheets: dI,
				subredditAutocomplete: _I,
				subredditChannels: AI,
				subreddits: LT,
				subredditStickyPosts: FT,
				subscriptions: oD,
				tabBadged: cD,
				tags: RD,
				themes: UD,
				toaster: GD,
				tooltipId: qD,
				topics: HD,
				tracing: QD,
				tracking: ZD,
				trafficStats: nC,
				transfers: uC,
				trending: fC,
				trophies: OC,
				uploads: yC,
				user: Uw,
				userDataRequestPage: Vw,
				userFlair: Hw,
				users: aA,
				widgets: yA
			})
		},
		"./src/reddit/reducers/sidebarPromotedPosts/models/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./src/reddit/actions/ads/constants.ts");
			! function(e) {
				e[e.FRONTPAGE = 0] = "FRONTPAGE", e[e.COMMENTS_OVERLAY = 1] = "COMMENTS_OVERLAY", e[e.COMMENTS = 2] = "COMMENTS", e[e.SUBREDDIT = 3] = "SUBREDDIT", e[e.MULTIREDDIT = 4] = "MULTIREDDIT", e[e.SEARCH_RESULTS = 5] = "SEARCH_RESULTS"
			}(s || (s = {}));
			const o = {};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.f:
					case r.d: {
						const n = t.payload;
						return Object.assign({}, e, n)
					}
					case r.e:
					case r.f:
						return e;
					case r.h:
						return o;
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/uniqWith.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/values.js"),
				c = n.n(a),
				i = n("./src/reddit/actions/tags/constants.ts"),
				d = n("./src/reddit/models/Option/index.ts"),
				u = n("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(s || (s = {}));
			const l = {
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.w:
					case i.r: {
						const {
							subredditId: n,
							itemTags: s,
							suggestedItemTags: r
						} = t.payload, a = o()([...(e.selectedOptions[n] || []).map(e => {
							if (!e.id) {
								const t = c()(s[n] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return Object.assign({}, Object(u.e)(t, !0), {
									action: null
								})
							}
							return e
						}), ...c()(s[n] || {}).map(e => Object.assign({}, Object(u.e)(e, !0), {
							action: null
						}))], d.a);
						return Object.assign({}, e, {
							selectedOptions: Object.assign({}, e.selectedOptions, {
								[n]: a.map(e => Object.assign({}, e, {
									action: e.id ? null : e.action
								}))
							}),
							selectedSuggestedOptions: Object.assign({}, e.selectedSuggestedOptions, {
								[n]: c()(r[n] || {}).map(e => Object.assign({}, Object(u.e)(e, !0), {
									action: null
								}))
							}),
							deselectedOptions: Object.assign({}, e.deselectedOptions, {
								[n]: []
							})
						})
					}
					case i.D:
					case i.z: {
						const {
							subredditId: n,
							option: r
						} = t.payload, a = t.type === i.z ? "selectedOptions" : "selectedSuggestedOptions", c = t.type === i.z ? "deselectedOptions" : "deselectedSuggestedOptions", u = (e[c][n] || []).slice(), l = u.findIndex(e => Object(d.a)(e, r));
						let b = s.ADD;
						return l > -1 && (b = null, u.splice(l, 1)), Object.assign({}, e, {
							[a]: Object.assign({}, e[a], {
								[n]: o()([...e[a][n] || [], Object.assign({}, r, {
									action: b
								})], d.a)
							}),
							[c]: Object.assign({}, e[c], {
								[n]: u
							})
						})
					}
					case i.C:
					case i.y: {
						const {
							subredditId: n,
							option: r
						} = t.payload, o = t.type === i.y ? "selectedOptions" : "selectedSuggestedOptions", a = t.type === i.y ? "deselectedOptions" : "deselectedSuggestedOptions", c = (e[a][n] || []).slice(), u = (e[o][n] || []).slice(), l = u.findIndex(e => Object(d.a)(e, r));
						return l > -1 && (null === u[l].action && c.push(Object.assign({}, u[l], {
							action: s.REMOVE
						})), u.splice(l, 1)), Object.assign({}, e, {
							[o]: Object.assign({}, e[o], {
								[n]: u
							}),
							[a]: Object.assign({}, e[a], {
								[n]: c
							})
						})
					}
					case i.A: {
						const {
							itemTagsState: n
						} = t.payload, s = Object.keys(n);
						if (!s.length) return e;
						const r = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							o = s.reduce((e, t) => (e.selectedOptions[t] = c()(n[t]).map(e => Object.assign({}, Object(u.e)(e, !0), {
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), r);
						return Object.assign({}, e, {
							inputByItemId: Object.assign({}, e.inputByItemId, o.inputByItemId),
							selectedOptions: Object.assign({}, e.selectedOptions, o.selectedOptions),
							deselectedOptions: Object.assign({}, e.deselectedOptions, o.deselectedOptions)
						})
					}
					case i.B:
					case i.x: {
						const {
							subredditId: n,
							input: s
						} = t.payload, r = t.type === i.x ? "inputByItemId" : "suggestedInputByItemId";
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								[n]: s
							})
						})
					}
					case i.i:
					case i.h: {
						const {
							subredditId: n,
							primaryTagId: s
						} = t.payload;
						if (!s || !n) return e;
						const r = e.selectedOptions[n];
						if (r) {
							const t = r.findIndex(e => e.id === s),
								o = [...r];
							return t >= 0 && o.splice(t, 1), Object.assign({}, e, {
								selectedOptions: Object.assign({}, e.selectedOptions, {
									[n]: o
								})
							})
						}
						return e
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/user/prefs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/isEqual.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/merge.js"),
				c = n.n(a),
				i = n("./node_modules/lodash/pick.js"),
				d = n.n(i),
				u = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/comment/index.ts"),
				b = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/frontpage.ts"),
				f = n("./src/reddit/actions/header.ts"),
				m = n("./src/reddit/actions/modQueue/constants.ts"),
				O = n("./src/reddit/actions/page.ts"),
				g = n("./src/reddit/actions/pages/collectionCommentsPage.ts"),
				_ = n("./src/reddit/actions/pages/modListing/constants.ts"),
				y = n("./src/reddit/actions/pages/postCreation.ts"),
				j = n("./src/reddit/actions/pages/postDraft.ts"),
				h = n("./src/reddit/actions/pages/profileComments.ts"),
				E = n("./src/reddit/actions/pages/profileOverview.ts"),
				I = n("./src/reddit/actions/pages/profilePosts.ts"),
				v = n("./src/reddit/actions/pages/search.ts"),
				S = n("./src/reddit/actions/pages/subreddit.ts"),
				T = n("./src/reddit/actions/pages/topic.ts"),
				D = n("./src/reddit/actions/postCreation/constants.ts"),
				C = n("./src/reddit/actions/postDraft.ts"),
				w = n("./src/reddit/actions/preferences.ts"),
				A = n("./src/reddit/actions/redditEmbed.ts"),
				R = n("./src/reddit/actions/search.ts"),
				P = n("./src/reddit/actions/structuredStyles/constants.ts"),
				k = n("./src/reddit/actions/subreddit.ts"),
				x = n("./src/reddit/actions/users.ts"),
				N = n("./src/reddit/constants/postLayout.ts"),
				L = n("./src/reddit/constants/preferences.ts"),
				U = n("./src/reddit/constants/theme.ts"),
				M = n("./src/reddit/models/PostCreationForm/index.ts"),
				F = n("./src/reddit/models/PostDraft/index.ts"),
				G = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e.Whitelisted = "whitelisted", e.Everyone = "everyone"
			}(s || (s = {}));
			const B = ["acceptPrivateMessages", "allowClickTracking", "autoplayVideo", "collapseReadMessages", "defaultCommentSort", "emailDigests", "emailUnreadMessages", "emailUnsubscribe", "geopopular", "hideAds", "hideFromRobots", "hideNSFW", "highlightComments", "ignoreSuggestedSort", "inBeta", "labelNSFW", "markMessagesRead", "nightmode", "over18", "sendWelcomeMessages", "showMessagesInInbox", "showNotifications", "showTwitter", "showUsernameMentionNotifications", "showActiveCommunities", ...L.a, "loginOtpEnabled"],
				q = {
					acceptPrivateMessages: void 0,
					activityRelevantAds: !0,
					allowClickTracking: !1,
					autoplayVideo: !0,
					collapsedTraySections: G.a,
					commentMode: M.h.RICH_TEXT,
					layout: N.d.Card,
					rememberCommunityLayout: !1,
					defaultCommentSort: u.q.CONFIDENCE,
					editorMode: M.h.RICH_TEXT,
					geopopular: void 0,
					globalTheme: U.a,
					hamburgerTray: void 0,
					hasSeenCustomizeFlyout: !0,
					hideNSFW: !0,
					ignoreSuggestedSort: !1,
					labelNSFW: !0,
					loginOtpEnabled: !1,
					markMessagesRead: !0,
					nightmode: !1,
					openPostInNewTab: !1,
					over18: !1,
					profileLayout: void 0,
					rpanDuDismissalTime: void 0,
					showActiveCommunities: !0,
					showRpanDu: !0,
					showTwitter: !1,
					sort: u.O.Hot,
					stylesEnabled: !0,
					subreddit: {},
					subscriptionsPinned: void 0,
					thirdPartyDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedContent: !0,
					showLocationBasedRecommendations: !0,
					topContentDismissalTime: 0,
					topContentTimesDismissed: 0,
					rememberCommunitySort: !1,
					useMarkdown: !1
				},
				V = {
					rpanDuDismissalTime: 0,
					isContributorRequestTimestamp: 0,
					stylesEnabled: !0,
					layout: void 0,
					sort: void 0
				},
				K = (e, t) => {
					if (!t) return e;
					const n = d()(Object.assign({}, t.account, t), B),
						s = t.subreddit,
						r = Object.assign({}, e.subreddit);
					Object.keys(s || {}).forEach(e => {
						r[e] = Object.assign({}, V, s && s[e])
					});
					const a = Object.assign({}, e, n, {
						subreddit: r
					});
					if (a.useMarkdown !== e.useMarkdown) {
						const e = a.useMarkdown ? M.h.MARKDOWN : M.h.RICH_TEXT;
						a.editorMode = e, a.commentMode = e
					}
					return o()(a, e) ? e : a
				},
				H = (e, t, n) => K(e, {
					subreddit: {
						[t]: Object.assign({}, V, e.subreddit[t], n)
					}
				});
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : q,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.l:
					case l.s: {
						const {
							editorMode: n
						} = t.payload;
						return Object.assign({}, e, {
							commentMode: n
						})
					}
					case D.t:
					case D.O: {
						const {
							editorMode: n
						} = t.payload;
						return Object.assign({}, e, {
							editorMode: n
						})
					}
					case f.d:
						return Object.assign({}, e, {
							subscriptionsPinned: !0
						});
					case f.e:
						return Object.assign({}, e, {
							subscriptionsPinned: !1
						});
					case C.g: {
						const {
							kind: n
						} = t.payload;
						return Object.assign({}, e, {
							editorMode: n === F.b.Markdown ? M.h.MARKDOWN : M.h.RICH_TEXT
						})
					}
					case w.h: {
						const {
							layout: n
						} = t.payload;
						return e.layout === n ? e : Object.assign({}, e, {
							layout: n
						})
					}
					case w.o:
						return void 0 !== t.payload ? Object.assign({}, e, {
							rpanDuDismissalTime: t.payload
						}) : e;
					case w.p: {
						const {
							layout: n,
							subredditId: s
						} = t.payload;
						return H(e, s, {
							layout: n
						})
					}
					case w.e:
						return Object.assign({}, e, {
							hasSeenCustomizeFlyout: !0
						});
					case w.m:
						return e.profileLayout === t.payload.profileLayout ? e : Object.assign({}, e, {
							profileLayout: t.payload.profileLayout
						});
					case b.g:
						return Object.assign({}, e, {
							over18: !0
						});
					case w.b:
						return void 0 !== t.payload ? Object.assign({}, e, {
							autoplayVideo: t.payload.autoplayVideo
						}) : e;
					case w.i:
						return void 0 !== t.payload ? Object.assign({}, e, {
							nightmode: t.payload.nightmode
						}) : e;
					case w.r:
						if (void 0 !== t.payload) {
							const {
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							} = t.payload;
							return Object.assign({}, e, {
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							})
						}
						return e;
					case P.d:
						return t.payload.isNightmodeOn ? Object.assign({}, e, {
							nightmode: !1,
							nightmodeTempUpdated: !0
						}) : e;
					case P.e:
						return t.payload.nightmodeTempUpdated ? Object.assign({}, e, {
							nightmode: !0,
							nightmodeTempUpdated: !1
						}) : e;
					case w.f:
						return void 0 !== t.payload ? Object.assign({}, e, {
							hamburgerTray: t.payload.set
						}) : Object.assign({}, e, {
							hamburgerTray: !e.hamburgerTray
						});
					case w.c:
						return void 0 !== t.payload ? Object.assign({}, e, {
							collapsedTraySections: c()({}, e.collapsedTraySections, t.payload)
						}) : e;
					case b.a:
					case b.b:
					case b.h:
					case b.i:
					case b.f:
					case b.j:
					case _.e:
					case _.h:
					case g.a:
					case O.a:
					case g.b:
					case O.b:
					case g.d:
					case O.d:
					case O.g:
					case S.c:
					case O.k:
					case O.j:
					case h.e:
					case E.e:
					case E.b:
					case I.e:
					case p.b:
					case k.i:
					case R.c:
					case A.b:
					case y.b:
					case j.a:
					case w.j:
					case v.c:
					case w.a:
					case x.c:
					case T.e:
						return t.payload && t.payload.preferences ? K(e, t.payload.preferences) : e;
					case w.q: {
						const {
							subredditId: n,
							prefs: s
						} = t.payload;
						return H(e, n, s)
					}
					case h.d:
					case E.d:
					case E.a:
					case I.d:
						if (t.payload && t.payload.account) {
							const {
								nightmode: n
							} = t.payload.account;
							if (e.nightmode !== n) return Object.assign({}, e, {
								nightmode: n
							})
						}
						return e;
					case m.h:
					case m.j:
					case m.i:
					case m.g:
					case m.f:
					case m.n:
					case m.m:
					case m.p:
					case m.q:
					case m.w:
					case m.v:
						return t.payload && t.payload.response && t.payload.response.preferences ? K(e, t.payload.preferences) : e;
					case w.n: {
						const n = t.payload,
							{
								showActiveCommunities: s
							} = n.additional;
						return e.showActiveCommunities !== s ? Object.assign({}, e, {
							showActiveCommunities: s
						}) : e
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/routes/modListing/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "d", (function() {
				return m
			}));
			var s = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				r = n.n(s),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				a = n("./node_modules/lodash/flatten.js"),
				c = n.n(a),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/actions/pages/modListing/index.ts");
			const u = Object(o.a)({
					resolved: {},
					chunkName: () => "ModListing",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~ModListing"), n.e("CollectionCommentsPage~CommentsPage~Frontpage~MembershipPaywallPage~ModListing~ModQueuePages~Moderat~cabdb502"), n.e("CollectionCommentsPage~CommentsPage~Frontpage~ModListing~ModQueuePages~Multireddit~ProfileOverview~P~6ef4688e"), n.e("Frontpage~ModListing~Multireddit~ProfilePosts~Subreddit~Topic"), n.e("Frontpage~ModListing~Multireddit~ProfilePosts~Subreddit"), n.e("ModListing~Reddit"), n.e("ModListing")]).then(n.bind(null, "./src/reddit/pages/ModListing/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/ModListing/index.tsx"
					}
				}),
				l = "/r/mod",
				b = "/me/f/mod",
				p = [l, b],
				f = c()(p.map(e => Object.keys(i.M).map(t => "".concat(e, "/:sort(").concat(i.M[t], ")?")))),
				m = e => e.startsWith(b),
				O = {
					action: d.b,
					chunk: i.o.MOD_LISTING,
					component: u,
					exact: !0,
					meta: {
						name: i.yb.MOD_LISTING
					},
					path: f,
					prefetches: [i.o.SUBREDDIT, i.o.COMMENTS_PAGE]
				};
			t.c = O
		},
		"./src/reddit/routes/postCreation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			}));
			var s = n("./node_modules/core-js/modules/es6.regexp.replace.js"),
				r = n.n(s),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/actions/pages/postCreation.ts"),
				i = n("./src/reddit/routes/postCreation/constants.ts");
			const d = [i.b, i.c, i.a],
				u = Object(o.a)({
					resolved: {},
					chunkName: () => "PostCreation",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~EconomicsEntryPointsPostFlatlistSupportCTA~InFeedChaining~Poll~PostCreation~Reddit~Subreddit~2c16ee4a"), n.e("vendors~CollectionCommentsPage~CommentsPage~ModerationPages~Poll~PostCreation~Subreddit"), n.e("vendors~ChatMessageInput~FlairEdit~MembershipPaywallPage~PostCreation~RichTextEditor"), n.e("vendors~PostCreation~RichTextEditor"), n.e("vendors~PostCreation"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~InFeedChaining~MembershipPaywallPage~3149a115"), n.e("ChatMessageInput~ChatPost~CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~InFeedChai~d183dc71"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/pages/PostCreation/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/PostCreation/index.tsx"
					}
				}),
				l = e => "/".concat(e, "/submit"),
				b = e => i.c.replace(/:subredditName/, e),
				p = e => i.a.replace(/:profileName/, e),
				f = {
					action: c.e,
					component: u,
					chunk: a.o.POST_CREATION,
					exact: !0,
					meta: {
						name: a.yb.POST_CREATION
					},
					path: d,
					prefetches: [a.o.COMMENTS_PAGE]
				};
			t.a = f
		},
		"./src/reddit/selectors/activeModalId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = e => e.activeModalId,
				r = e => t => t.activeModalId === e
		},
		"./src/reddit/selectors/blockedRedditors.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = e => e.blockedRedditors.api.pending,
				r = e => e.blockedRedditors.list,
				o = (e, t) => {
					const n = (e => {
						const t = r(e);
						return t && t.ids
					})(e);
					return !!n && n.includes(t)
				}
		},
		"./src/reddit/selectors/brandSafety.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/isFakeSubreddit/index.ts"),
				o = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				a = n("./src/reddit/models/WhitelistStatus/index.ts"),
				c = n("./src/reddit/selectors/posts.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			const d = new Set([s.M.NEW, s.M.RISING, s.M.CONTROVERSIAL]),
				u = e => e.brandSafety.hasBrandSafetyBeenAssessed,
				l = (e, t) => {
					let {
						postId: n
					} = t;
					const s = Object(c.O)(e, {
							postId: n
						}),
						r = Object(c.bb)(e, {
							postId: n
						});
					return !(!s || !r) && (r.wls === a.a.ALL_ADS && !s.isNSFW)
				},
				b = e => e.brandSafety.isViewSafe,
				p = e => !e.brandSafety.isViewSafe,
				f = (e, t) => {
					const {
						listingName: n,
						pageLayer: s
					} = t, c = Object(i.z)(e, {
						subredditName: n
					}), u = Object(o.b)(e, {
						pageLayer: s
					});
					return (!u || !d.has(u)) && (!(c || !Object(r.a)(n)) || !!c && c.wls === a.a.ALL_ADS)
				}
		},
		"./src/reddit/selectors/category.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "m", (function() {
				return I
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "i", (function() {
				return D
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/pickBy.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/objectSelector/index.ts"),
				c = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/name/index.ts"),
				d = n("./src/reddit/models/Widgets/index.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const l = [],
				b = e => e.categories.api.list.loaded,
				p = e => e.categories.api.list.pending,
				f = (e, t) => {
					let {
						id: n
					} = t;
					return n ? e.categories.api.subreddits.loaded[n] : void 0
				},
				m = (e, t) => {
					let {
						id: n
					} = t;
					return n ? e.categories.api.subreddits.pending[n] : void 0
				},
				O = (e, t) => {
					let {
						id: n
					} = t;
					return n ? e.categories.models[n] : void 0
				},
				g = (e, t) => {
					let {
						categoryName: n
					} = t;
					const s = e.categories.nameToId[Object(i.f)(n)];
					if (s) return O(e, {
						id: s
					})
				},
				_ = new Set(["nba", "nfl"]),
				y = Object(o.a)((e, t) => t.categoriesOrder || c.vb, (e, t) => t.excludedCategories || _, e => e.categories.ids, e => e.categories.models, (e, t, n, s) => {
					const r = {};
					let o = 1e3;
					const a = [];
					for (const c of n) {
						const n = s[c];
						t.has(Object(i.f)(n.name)) || (e[n.name] || (r[n.name] = o++), a.push(n))
					}
					return a.sort((t, n) => {
						return (e[t.name] || r[t.name]) - (e[n.name] || r[n.name])
					})
				}),
				j = (e, t) => {
					let {
						categoryName: n
					} = t;
					const s = g(e, {
						categoryName: n
					});
					return s && e.subreddits.byCategory[s.id] || l
				},
				h = Object(o.a)((e, t) => {
					let {
						id: n
					} = t;
					if (!n) return l;
					return e.subreddits.byCategory[n] || l
				}, u.X, e => e.subreddits.about, (e, t, n) => e.map(e => Object(d.i)(t[e], n[e]))),
				E = (Object(o.a)(j, u.X, (e, t) => 0 === e.length ? l : e.map(e => t[e])), () => Object(a.a)(Object(o.a)(j, u.X, (e, t) => 0 === e.length ? l : e.map(e => {
					const n = t[e];
					return n ? n.name : ""
				}).filter(Boolean)))),
				I = (e, t) => {
					const n = t ? e.posts.models[t] : null;
					return n && n.postCategories ? n.postCategories : null
				},
				v = Object(o.a)(e => e.subreddits.byCategory, u.X, (e, t) => Object.keys(e).reduce((n, s) => {
					const r = e[s];
					if (!r || 0 === r.length) return n;
					for (const e of r) {
						const r = t[e];
						if (r) {
							const e = Object(i.f)(r.name);
							n[e] || (n[e] = []), n[e].push(Object(i.f)(s))
						}
					}
					return n
				}, {})),
				S = Object(o.a)((e, t) => t.subredditName, v, (e, t) => t[Object(i.f)(e)] || l),
				T = e => e.categories.ranking,
				D = (e, t) => {
					let {
						id: n
					} = t;
					return n && e.categories.ranking[n] || 0
				};
			Object(o.a)(y, T, (e, t) => {
				const n = r()(t, e => e >= 3);
				return 0 === Object.keys(n).length ? e : [...e].sort((e, t) => {
					const s = n[e.id] || 0;
					return (n[t.id] || 0) - s
				})
			})
		},
		"./src/reddit/selectors/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				r = n("./src/reddit/selectors/moderatorPermissions.ts"),
				o = n("./src/reddit/selectors/platform.ts");
			const a = e => e.chat.unread.count,
				c = e => {
					return a(e).basicChannelCount
				},
				i = e => e.chat.promos,
				d = e => !(e.chat.isInited || e.chat.unread.api.pending),
				u = (e, t) => {
					const {
						chatConfig: n
					} = s.c;
					return Object(r.a)(n)(e, t)
				},
				l = e => {
					const t = Object(o.d)(e);
					if (e.chat.subredditSettings.subredditId === t) return e.chat.subredditSettings
				}
		},
		"./src/reddit/selectors/claimgold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = e => e.claimGold.code,
				r = e => e.claimGold.showModal
		},
		"./src/reddit/selectors/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			}));
			var s = n("./src/lib/objectSelector/index.ts");
			const r = e => e.awards.create.api.pending,
				o = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.awards.manageable.order[n];
					return s ? s.map(t => e.awards.models[t]).filter(e => e.isEnabled) : []
				}),
				a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.awards.manageable.api.pending[n]
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.awards.blacklist[n]
				},
				i = (e, t) => e.awards.models[t],
				d = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.awards.usable.order[n];
					return s ? s.map(t => e.awards.models[t]).filter(e => e.isEnabled) : []
				}),
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.awards.usable.api.pending[n]
				}
		},
		"./src/reddit/selectors/communityFlairs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/reselect/es/index.js");
			const r = (e, t) => {
					const n = e.communityFlairs[t];
					return n && n.sortedKeys
				},
				o = Object(s.a)(r, e => e),
				a = (e, t) => {
					const n = e.communityFlairs[t];
					return n && n.models
				},
				c = Object(s.a)(a, e => e),
				i = (Object(s.a)((e, t) => a(e, t), (e, t) => r(e, t), (e, t) => {
					if (t && e) return t.map(t => e[t])
				}), (e, t) => e.communityFlairs.hasOwnProperty(t))
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "f", (function() {
				return _
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeListingKey/index.ts"),
				o = n("./src/lib/objectSelector/index.ts"),
				a = n("./src/reddit/helpers/name/index.ts"),
				c = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				i = n("./src/reddit/selectors/category.ts"),
				d = (n("./src/reddit/selectors/listings.ts"), n("./src/reddit/selectors/posts.ts"));
			n("./src/reddit/selectors/subreddit.ts");
			const u = [],
				l = e => e.discoveryUnits.api.list.loaded,
				b = e => e.discoveryUnits.api.list.pending,
				p = (e, t) => {
					let {
						unitName: n
					} = t;
					const s = e.discoveryUnits.nameToId[Object(a.f)(n)];
					return e.discoveryUnits.models[s]
				},
				f = () => Object(o.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const s = Object(d.R)(e);
					return Object(d.H)(e, {
						listingKey: n
					}).filter(e => {
						const t = s[e];
						return t && !t.isStickied && !t.isSponsored
					})
				}),
				m = () => Object(o.a)((e, t) => {
					let n, {
						categoryName: o,
						id: a,
						unitName: c
					} = t;
					if (o && !(n = Object(i.f)(e, {
							categoryName: o
						}))) return u;
					const d = a || n && n.id,
						l = Object(r.a)(c, s.M.HOT, {
							category: d
						});
					return f()(e, {
						listingKey: l
					})
				}),
				O = e => p(e, {
					unitName: c.c
				}),
				g = new Set(["sequence"]),
				_ = e => {
					const t = e.platform.currentPage;
					if (t) {
						const {
							meta: e,
							urlParams: n
						} = t, s = e && e.name || "", r = n && n.subredditName || "", o = "subreddit" === s, a = g.has(r.toLowerCase());
						return o && a
					}
					return !1
				}
		},
		"./src/reddit/selectors/downToChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = (e, t) => e.downToChat.subreddits[t] && e.downToChat.subreddits[t].bannerEnabled,
				r = (e, t) => e.downToChat.subreddits[t] && e.downToChat.subreddits[t].buttonEnabled,
				o = (e, t) => !!e.downToChat.subreddits[t]
		},
		"./src/reddit/selectors/emailCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const a = Object(s.a)(o.H, o.l, o.x, (e, t, n) => e && !t && !n),
				c = e => (() => 0 === Object(r.i)())() && a(e)
		},
		"./src/reddit/selectors/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "a", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/models/Flair/index.ts"),
				c = n("./src/reddit/selectors/moderatorPermissions.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			const d = [],
				u = e => e.emojis.models,
				l = Object(o.a)(u, (e, t) => t.subredditId, (e, t) => {
					const n = e[t];
					return n ? [...r()(n.emojis), ...r()(n.snoomojis)] : d
				}),
				b = Object(o.a)(l, c.g, (e, t) => t.isFlairModOnly, (e, t) => t.flairTemplateType, (e, t, n, s) => e.filter(e => !(e.modFlairOnly && !t || e.modFlairOnly && !n) && (!(!e.userFlairAllowed && s === a.d.UserFlair) && !(!e.postFlairAllowed && s === a.d.LinkFlair)))),
				p = Object(o.a)(u, (e, t) => t.subredditId, (e, t) => Object.keys(e[t].snoomojis)),
				f = (e, t) => Object(i.w)(e, {
					subredditName: t
				}).emojisEnabled,
				m = {
					emojis: {},
					snoomojis: {}
				},
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return u(e)[n] || m
				},
				g = (e, t) => !!e.emojis.api.list.pending[t]
		},
		"./src/reddit/selectors/experiments/avatarsInComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const c = Object(s.a)(a.H, a.G, (e, t) => e || t),
				i = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: c,
					experimentName: r.g
				}), e => e === r.j.Active),
				d = Object(s.a)(a.H, a.G, (e, t) => !e && !t),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: d,
					experimentName: r.h
				}), e => e === r.j.Active),
				l = Object(s.a)(i, u, (e, t) => e || t)
		},
		"./src/reddit/selectors/experiments/econAwardKarma.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const a = e => {
				const t = Object(r.c)(e, {
					experimentEligibilitySelector: o.H,
					experimentName: s.U
				});
				return !(!t || Object(s.rc)(t))
			}
		},
		"./src/reddit/selectors/experiments/editProfileImagesInline.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/experiments/utils.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const i = Object(s.a)(c.H, c.G, (e, t) => e || t),
				d = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: i,
					experimentName: r.Z,
					expEventOverride: !1
				}), a.a),
				u = Object(s.a)(d, e => e === r.bb.Enabled)
		},
		"./src/reddit/selectors/experiments/frontpageSignup.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return O
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/experiments/utils.ts"),
				i = n("./src/reddit/selectors/meta.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = Object(s.a)(d.O, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return !n || Object(o.y)(n)
				}, i.c, (e, t, n) => !e && t && !n),
				l = Object(s.a)((e, t) => Object(a.c)(e, {
					experimentEligibilitySelector: e => u(e, t),
					experimentName: r.M,
					throttledVariants: {
						[r.cb.CurrentThrottled]: r.M
					}
				}), c.a),
				b = e => e === r.cb.CurrentThrottled,
				p = e => e === r.cb.CurrentThrottled || e === r.cb.CurrentUnthrottled || e === r.cb.CurrentUnthrottledCopy || e === r.cb.NewPopUnthrottledCopy,
				f = e => e === r.cb.NewPopUnthrottledCopy,
				m = e => e === r.cb.NewPageUnthrottledCopy || e === r.cb.NewPageUnthrottledCopyFields,
				O = e => e === r.cb.NewPageUnthrottledCopyFields
		},
		"./src/reddit/selectors/experiments/goldPremiumAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const a = e => !!(e => {
				const t = Object(r.c)(e, {
					experimentEligibilitySelector: e => Object(o.H)(e),
					experimentName: s.eb
				});
				return Object(s.rc)(t) ? void 0 : t
			})(e)
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.C
				}) === s.I.Enabled,
				a = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.B
				}) === s.H.Enabled
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => s.Pb.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Nb
				}),
				a = e => s.Lb.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Eb
				}),
				c = e => s.Xb.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Sb
				}),
				i = e => s.Yb.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Tb
				}),
				d = (e, t, n) => {
					const o = n(e, t);
					return !(!o || !o.meter) && (o.meter.enabled && i(e) && s.pc.Enabled === Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.nc
					}))
				}
		},
		"./src/reddit/selectors/experiments/subredditSeo.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/subreddit.ts"),
				c = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/selectors/widgets.ts");
			const u = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: r.lb,
						customPayloadMaker: e => ({
							request: c.request(e)
						})
					}) === r.tb.LinkModule
				},
				l = Object(s.a)(e => {
					return !!Object(o.c)(e, {
						experimentEligibilitySelector: o.a,
						experimentName: r.lb,
						expEventOverride: !1
					})
				}, i.H, a.Q, d.j, (e, t, n, s) => e && !t && !n.isNSFW && !s.some(e => "community-list" === e))
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const i = Object(s.a)(c.H, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.y)(n)
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.K)(n)
				}, (e, t, n) => !e && !t && n),
				d = Object(s.a)((e, t) => Object(a.c)(e, {
					experimentName: r.O,
					experimentEligibilitySelector: e => i(e, t)
				}), e => e),
				u = e => e === r.hc.NoCommunityWidgets,
				l = e => e === r.hc.NoRulesModerators,
				b = e => e === r.hc.RelatedPostsDu
		},
		"./src/reddit/selectors/experiments/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/constants/experiments.ts");
			const r = e => {
				if (!Object(s.rc)(e)) return e || void 0
			}
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			}));
			var s = n("./src/reddit/models/ExternalAccount/index.ts"),
				r = n("./src/reddit/models/User/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const a = (e, t) => {
					let {
						username: n
					} = t;
					return !!e.externalAccount.api.user.pending[n]
				},
				c = (e, t) => {
					let {
						username: n
					} = t;
					return e.externalAccount.user[n]
				},
				i = e => {
					const t = Object(o.i)(e);
					if (!t) return;
					const n = Object(r.e)(t),
						s = c(e, {
							username: n
						});
					return s ? s.twitter : void 0
				},
				d = e => !!e.externalAccount.api.connect.pending[s.a.Twitter],
				u = (e, t) => {
					let {
						profileName: n
					} = t;
					if (!n) return null;
					const a = c(e, {
						username: n
					});
					if (!a) return null;
					const i = a[s.a.Twitter];
					if (!i) return null;
					const d = Object(o.i)(e);
					if (!(d && Object(r.e)(d).toLowerCase() === n.toLowerCase())) return i;
					const u = Object(o.eb)(e, {
						userName: n
					});
					return u ? u.prefShowTwitter ? i : null : i
				}
		},
		"./src/reddit/selectors/focusedVerticalSuggestion.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return c
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./src/reddit/featureFlags/index.ts"),
				r = n("./src/reddit/selectors/posts.ts"),
				o = n("./src/reddit/selectors/subreddit.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const c = (e, t) => {
					const n = e.focusedVerticals.interactedSubredditIds && e.focusedVerticals.interactedSubredditIds[t];
					if (n) {
						const t = Object(o.Q)(e, {
							subredditId: n
						});
						return t && t.displayText || ""
					}
					return ""
				},
				i = (e, t) => e.focusedVerticals.interactedSubredditIds && e.focusedVerticals.interactedSubredditIds[t] || "",
				d = e => e.focusedVerticals.components.dismissed,
				u = [],
				l = (e, t) => {
					const n = b(e, t);
					if (!n) return u;
					const s = Object(o.U)(e, {
						subredditName: n.name
					});
					return s && s.postIds && s.postIds.length ? s.postIds : u
				},
				b = (e, t) => {
					const n = e.focusedVerticals.recommendedSubredditIds && e.focusedVerticals.recommendedSubredditIds[t];
					return n ? Object(o.Q)(e, {
						subredditId: n
					}) : null
				},
				p = (e, t, n, s, o) => {
					const a = o.find(e => e <= t) || -1,
						c = o.find(e => e > t) || 1 / 0;
					return t !== c && t !== a && (!(a + n > t) && (!(t + n > c) && !((e, t, n) => {
						const s = n[t - 1],
							o = n[t],
							a = o && Object(r.O)(e, {
								postId: s
							}) || null,
							c = o && Object(r.O)(e, {
								postId: o
							}) || null;
						return a && a.isSponsored || c && c.isSponsored
					})(e, t, s)))
				},
				f = [3],
				m = (e, t, n) => {
					let {
						listingKey: s
					} = n;
					const o = t.slice().sort();
					let a = -1;
					const c = Object(r.H)(e, {
							listingKey: s
						}),
						i = [];
					return f.forEach(t => {
						let n = a + t;
						if (!(n >= c.length)) {
							for (; n < c.length && !p(e, n, t, c, o);) n += 1;
							n < c.length && (i.push(n), a = n)
						}
					}), i
				},
				O = e => {
					return e.focusedVerticals.api.pending.focusedVerticalGqlPending
				},
				g = e => {
					return e.focusedVerticals.api.error.focusedVerticalGqlError
				},
				_ = e => e.focusedVerticals.category,
				y = e => e.focusedVerticals.lastLoadedEnv,
				j = e => {
					const t = Object(a.G)(e),
						n = s.d.geoSubredditRecommendationDULoggedIn(e),
						r = s.d.geoSubredditRecommendationDULoggedOut(e);
					return t && n || !t && r
				}
		},
		"./src/reddit/selectors/gild.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			}));
			const s = e => e.gild.gildModalThingId,
				r = (e, t) => e.gild.gildModalId === t,
				o = e => e.gild.isAnonymous,
				a = e => e.gild.isIframed,
				c = e => e.gild.message,
				i = e => e.gild.api.pending,
				d = e => e.gild.api.error,
				u = e => e.gild && e.gild.giveAwardTooltipThingId
		},
		"./src/reddit/selectors/gold/purchaseCatalog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			}));
			const s = e => e.goldPurchase.purchaseCatalog.activeSaleConfig,
				r = e => e.goldPurchase.purchaseCatalog.coinPackages,
				o = e => e.goldPurchase.purchaseCatalog.dealCoinPackages,
				a = (e, t) => {
					return o(e).filter(e => e.mobileId === t)[0]
				},
				c = e => e.goldPurchase.purchaseCatalog.premiumPackages,
				i = e => e.goldPurchase.purchaseCatalog.pending,
				d = e => e.goldPurchase.purchaseCatalog.errorMessage
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "o", (function() {
				return s
			})), n.d(t, "p", (function() {
				return r
			})), n.d(t, "r", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "q", (function() {
				return c
			})), n.d(t, "w", (function() {
				return i
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "n", (function() {
				return u
			})), n.d(t, "x", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "t", (function() {
				return f
			})), n.d(t, "u", (function() {
				return m
			})), n.d(t, "s", (function() {
				return O
			})), n.d(t, "v", (function() {
				return g
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "i", (function() {
				return I
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			}));
			const s = e => e.goldPurchase.purchaseModal.activePage,
				r = e => e.goldPurchase.purchaseModal.gildThingId || void 0,
				o = e => e.goldPurchase.purchaseModal.showModal,
				a = e => e.goldPurchase.purchaseModal.showModal && !e.gild.selectedAward.pennyPrice,
				c = e => e.goldPurchase.purchaseModal.packageId,
				i = e => e.goldPurchase.targetedOffer.packageId,
				d = e => e.goldPurchase.premiumPurchaseModal.activePage,
				u = e => e.goldPurchase.premiumPurchaseModal.showModal,
				l = e => e.goldPurchase.updateCardModal.pending,
				b = e => e.goldPurchase.payment.paymentMethod,
				p = e => e.goldPurchase.payment.cardName,
				f = e => e.goldPurchase.payment.savedCardsPending,
				m = e => e.goldPurchase.payment.savedCards,
				O = e => e.goldPurchase.payment.rememberCard,
				g = e => e.goldPurchase.payment.useSavedCard,
				_ = e => e.goldPurchase.payment.cardValidation.cardCvc,
				y = e => e.goldPurchase.payment.cardValidation.cardExpiry,
				j = e => e.goldPurchase.payment.cardValidation.cardNumber,
				h = e => e.goldPurchase.payment.cardValidation.nameOnCard,
				E = e => e.goldPurchase.payment.cardValidation.postalCode,
				I = e => e.goldPurchase.payment.stripeToken.errorMessage,
				v = e => e.goldPurchase.payment.stripeToken.pending,
				S = e => e.goldPurchase.payment.paypal.passthrough,
				T = e => e.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/header.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => e.header.isSubscriptionsDropdownOpen
		},
		"./src/reddit/selectors/imageUploads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/reddit/models/Image/index.tsx");
			const r = e => e.imageUploads,
				o = (e, t) => {
					let {
						id: n
					} = t;
					return r(e)[n]
				},
				a = (e, t) => {
					const n = r(e),
						o = [];
					for (const r in n) {
						const e = n[r];
						e.kind === s.b.TempUploaded && e.context === t && o.push(e)
					}
					return o
				}
		},
		"./src/reddit/selectors/inFeedChaining.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return p
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "b", (function() {
				return y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeListingKey/index.ts"),
				a = n("./src/reddit/actions/subreddit/similarSubreddit.ts"),
				c = n("./src/reddit/constants/inFeedChaining.ts"),
				i = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				d = n("./src/reddit/selectors/discoveryUnit.ts"),
				u = n("./src/reddit/selectors/posts.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			const b = [],
				p = (e, t) => {
					const n = e.posts.chained.idToListingKey[t.postId];
					return t.listingKey === n
				},
				f = (e, t) => {
					const n = e.posts.chained.dismissedIdToListingKey[t.postId];
					return (e => e.posts.chained.dismissed)(e) || t.listingKey === n
				},
				m = Object(s.a)(e => e.posts.chained.idToListingKey, e => Object.keys(e).filter(t => e[t])),
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return m(e).some(t => {
						const s = Object(u.bb)(e, {
							postId: t
						});
						return !!s && s.id === n
					})
				},
				g = (e, t) => {
					let {
						subredditName: n
					} = t;
					const s = r.Pb.DAY.toUpperCase(),
						a = Object(o.a)(n, r.M.TOP, {
							t: s
						}),
						c = Object(u.H)(e, {
							listingKey: a
						});
					if (0 !== c.length)
						for (const r of c) {
							const t = Object(u.O)(e, {
								postId: r
							});
							if (t && !t.hidden && !t.isSponsored) return t
						}
				},
				_ = (e, t) => {
					let {
						postId: n
					} = t;
					const s = ((e, t) => {
							let {
								postId: n
							} = t;
							const s = Object(u.O)(e, {
								postId: n
							});
							if (!s) return b;
							const r = Object(a.a)({
								subredditIds: [s.belongsTo.id],
								count: c.b
							});
							return Object(l.u)(e, {
								key: r
							})
						})(e, {
							postId: n
						}),
						r = [];
					for (const {
							name: o
						} of s) {
						const t = g(e, {
							subredditName: o
						});
						t && r.push(t.id)
					}
					return r
				},
				y = (e, t) => {
					let {
						listingName: n
					} = t;
					const s = i.b;
					return Object(d.c)(e, {
						unitName: s
					})
				}
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/reddit/featureFlags/index.ts"),
				r = n("./src/reddit/selectors/moderatorPermissions.ts");
			const o = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!s.d.subredditInlineEditing(e)) return !1;
					const o = n ? Object(r.j)(e, {
						subredditId: n
					}) : null;
					return !!o && (e => !!e && e.config)(o)
				},
				a = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/interceptedAction.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => e.interceptedAction
		},
		"./src/reddit/selectors/modQueue.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				o = n("./src/lib/objectSelector/index.ts");
			const a = (e, t) => Object(r.a)({
					onlyOfType: t.queryParams.only,
					profile: t.profileName,
					subreddit: t.subredditName
				}),
				c = Object(o.a)((e, t) => {
					const {
						pageName: n,
						page: s
					} = t, r = a(0, t);
					if (!e.modQueue[n] || !e.modQueue[n].itemOrder[r] || !e.modQueue[n].itemOrder[r][s]) return;
					const o = e.modQueue[n].itemOrder[r][s];
					return o ? o.map(t => e.posts.models[t] || e.comments.models[t]) : []
				}),
				i = (e, t) => {
					const {
						pageName: n
					} = t;
					return !e.modQueue[n] || !e.modQueue[n].api || e.modQueue[n].api.pending
				},
				d = (e, t) => {
					const n = a(0, t);
					return e.modQueue[t.pageName].loadMore[n]
				},
				u = e => Object.keys(e.modQueue.bulkAction.selectedItems),
				l = e => e.modQueue.bulkAction.api.pending,
				b = e => e.modQueue.moderatedCommunitiesOrder.data,
				p = e => {
					const t = e.platform && e.platform.currentPage;
					return t && t.meta && (t.meta.name === s.yb.MODERATION_PAGES || t.meta.name === s.yb.MODQUEUE_PAGES)
				}
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					if (!n) return !1;
					if (e.comments.collapsed[s] && n in e.comments.collapsed[s]) return !!e.comments.collapsed[s][n];
					const r = e.comments.models[n];
					return !!r && ("computedCollapsed" in r ? !!r.computedCollapsed : r.collapsedBecauseCrowdControl ? !e.modModeEnabled : r.collapsed)
				},
				r = (e, t) => {
					let {
						commentId: n
					} = t;
					if (!n) return !1;
					const s = e.comments.models[n];
					return !(!s || !s.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/notificationBanner.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => t => t.notificationBannerId === e
		},
		"./src/reddit/selectors/oldSiteRules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => e.oldSiteRules
		},
		"./src/reddit/selectors/profileOverviewChronoItems.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return c
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "c", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/PostCreationForm/index.ts");
			r.f.Text, r.f.Spoiler, r.f.Text, r.f.Spoiler, o.h.RICH_TEXT, r.f.Text, r.f.Spoiler, o.h.RICH_TEXT, r.f.Text, r.f.Spoiler, o.h.RICH_TEXT;
			var a = n("./src/reddit/helpers/isComment.ts");
			const c = Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const s = e.posts.models;
					return i(e, {
						listingKey: n
					}).filter(e => {
						if (Object(a.a)(e)) return !0; {
							const t = s[e];
							return t && !t.hidden
						}
					})
				}),
				i = Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const s = e.profileOverviewPage.chrono.ids[n];
					return s ? [...s] : []
				}),
				d = Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					return c(e, {
						listingKey: n
					}).reduce((t, n) => {
						const s = Object(a.a)(n) ? e.comments.models[n].postId : n;
						return t[n] = s, t
					}, {})
				}),
				u = (Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const s = e.posts.models;
					return u(e, {
						listingKey: n
					}).filter(e => {
						const t = s[e];
						return t && !t.hidden
					})
				}), Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					return c(e, {
						listingKey: n
					}).map(t => Object(a.a)(t) ? e.comments.models[t].postId : t)
				})),
				l = Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const s = e.posts.models,
						r = u(e, {
							listingKey: n
						}),
						o = {};
					return r.forEach(e => o[e] = s[e]), o
				}),
				b = Object(s.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const s = e.comments.models,
						r = c(e, {
							listingKey: n
						}),
						o = {};
					return r.forEach(e => !!Object(a.a)(e) && (o[e] = s[e])), o
				}),
				p = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.api.error[n]
				},
				f = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.api.pending[n]
				},
				m = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.loadMore[n]
				},
				O = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.fetchedTokens[n]
				}
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "q", (function() {
				return j
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "m", (function() {
				return E
			})), n.d(t, "c", (function() {
				return I
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "n", (function() {
				return S
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/ScheduledPost/index.ts");
			const a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return ((e, t) => {
						let {
							subredditId: n,
							type: s
						} = t;
						return !!e.posts.scheduledPosts[s].models[n]
					})(e, {
						subredditId: n,
						type: o.f.standalonePosts
					})
				},
				c = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return !!e.posts.scheduledPosts[s].pageInfo[n] && e.posts.scheduledPosts[s].pageInfo[n].hasNextPage
				},
				i = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return e.posts.scheduledPosts[s].pageInfo[n] ? e.posts.scheduledPosts[s].pageInfo[n].endCursor : null
				},
				d = e => e.posts.scheduledPosts.api.pending,
				u = e => e.posts.scheduledPosts.api.pendingUpdate,
				l = e => e.posts.scheduledPosts.api.error,
				b = {},
				p = [],
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[n] || b)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[n][t])
				},
				m = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.recurringPosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.recurringPosts.models[n] || b)[t]).map(t => e.posts.scheduledPosts.recurringPosts.models[n][t])
				},
				O = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s,
						type: r
					} = t;
					return (e.posts.scheduledPosts[r].models[n] || b)[s] || void 0
				},
				g = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return O(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.f.standalonePosts
					})
				},
				_ = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					const r = O(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.f.recurringPosts
					});
					return r || r
				},
				y = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return g(e, {
						subredditId: n,
						scheduledPostId: s
					}) || _(e, {
						subredditId: n,
						scheduledPostId: s
					})
				},
				j = e => e.creations.formData.scheduledPostId,
				h = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: n,
							isSpoiler: o,
							isOriginalContent: a
						} = e;
						const c = [];
						return a && c.push({
							text: "OC",
							type: r.f.Oc
						}), t && c.push(...Object(s.b)(t)), o && c.push({
							text: "spoiler",
							type: r.f.Spoiler
						}), n && c.push({
							text: "nsfw",
							type: r.f.Nsfw
						}), c
					})(t)
				},
				E = e => {
					let {
						scheduledPost: t
					} = e;
					const n = h({
							scheduledPost: t
						}),
						s = n.find(e => e.type === r.f.Richtext);
					return s || (n.find(e => e.type === r.f.Text) || null)
				},
				I = e => e.posts.scheduledPosts[o.f.recurringPosts].editModal.scheduledPostId,
				v = e => e.posts.scheduledPosts[o.f.recurringPosts].editModal.subredditId,
				S = e => e.posts.scheduledPosts.api.pendingUpdate
		},
		"./src/reddit/selectors/searchResults.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			}));
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			const s = [],
				r = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.api.error[n]
				},
				o = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.api.pending[n]
				},
				a = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.identifiers[n] || []
				},
				c = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.loadMore[n]
				},
				i = e => {
					const t = e.search.searchQuery;
					if (!t) return s;
					const n = e.search.typeahead.idsByQuery[t.toLowerCase()];
					if (!n) return s;
					const r = [];
					return n.forEach(t => {
						r.push(e.search.typeahead.models[t])
					}), r
				},
				d = e => e.search.typeahead.idsByQuery,
				u = e => {
					const t = e.listings.activeKey;
					return e.search.viewTreatment[t]
				},
				l = e => {
					const t = e.listings.activeKey;
					if (t) return e.searchDiscoveryUnits.headerContent[t]
				},
				b = (e, t) => t ? e.search.relatedQueries[t.toLowerCase()] : s
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/selectors/user.ts");
			const o = e => !Object(r.H)(e) && e.seo.linksModule.frontpage || null,
				a = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				c = Object(s.a)(o, e => e ? e.map(e => Object.assign({}, e, {
					links: e.links.map(e => Object.assign({}, e, {
						title: a(e.url)
					})).filter(e => e.title)
				})) : null),
				i = Object(s.a)(c, e => e ? e.map(e => Object.assign({}, e, {
					links: e.links.filter(e => e.visible)
				})) : null),
				d = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = ((e, t) => {
						let {
							subredditId: n
						} = t;
						return e.seo.linksModule.subreddits && e.seo.linksModule.subreddits[n]
					})(e, {
						subredditId: n
					});
					return s && s.subreddits
				}
		},
		"./src/reddit/selectors/tags.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "D", (function() {
				return g
			})), n.d(t, "E", (function() {
				return _
			})), n.d(t, "l", (function() {
				return y
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "o", (function() {
				return E
			})), n.d(t, "v", (function() {
				return I
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "t", (function() {
				return C
			})), n.d(t, "b", (function() {
				return w
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "c", (function() {
				return P
			})), n.d(t, "s", (function() {
				return k
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "C", (function() {
				return N
			})), n.d(t, "B", (function() {
				return L
			})), n.d(t, "x", (function() {
				return U
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "u", (function() {
				return F
			})), n.d(t, "F", (function() {
				return G
			})), n.d(t, "z", (function() {
				return B
			})), n.d(t, "A", (function() {
				return V
			})), n.d(t, "j", (function() {
				return K
			})), n.d(t, "y", (function() {
				return H
			})), n.d(t, "G", (function() {
				return W
			})), n.d(t, "p", (function() {
				return Y
			})), n.d(t, "q", (function() {
				return Q
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/values.js"),
				a = n.n(o),
				c = n("./src/lib/objectSelector/index.ts"),
				i = n("./src/reddit/helpers/tags/index.ts"),
				d = n("./src/reddit/models/Tags/index.ts");
			const u = e => {
					const t = H(e),
						n = t && t.id;
					return a()((e => {
						const t = l(e) ? A(e) : C(e),
							n = b(e),
							s = t.reduce((e, t) => (e[t.id] = Object(d.f)(t), e), {});
						return n.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), s)
					})(e)).filter(e => !e.selected && e.id !== n)
				},
				l = e => e.tags.creation.tagInput || "",
				b = e => e.tags.creation.selectedOptions || [],
				p = e => {
					const t = [];
					for (let n = 0; n < b(e).length; n++) b(e)[n].id && t.push(b(e)[n].id);
					return t || []
				},
				f = e => (b(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				m = e => {
					const t = [];
					for (let n = 0; n < b(e).length; n++) b(e)[n].id || t.push(b(e)[n].displayText);
					return t || []
				},
				O = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				g = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				_ = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				y = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.inputByItemId[n] || ""
				},
				j = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.suggestedInputByItemId[n] || ""
				},
				h = [],
				E = (e, t) => {
					let {
						subredditId: n
					} = t;
					return r()(I(e, {
						subredditId: n
					}), e => !!e.action) || r()(S(e, {
						subredditId: n
					}), e => !!e.action)
				},
				I = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedOptions[n] || h
				},
				v = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedSuggestedOptions[n] || h
				},
				S = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.deselectedOptions[n] || h
				},
				T = {},
				D = {},
				C = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				w = e => e.tags.models.globalSubredditTags,
				A = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				R = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditScopedTags[n] || D
				},
				P = (e, t) => {
					const n = a()(t);
					for (let s = 0; s < n.length; s++)
						if (n[s].text.toLowerCase().trim() === e.toLowerCase().trim()) return n[s];
					return null
				},
				k = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.itemTags[n] || T
				},
				x = (e, t) => {
					let {
						itemId: n
					} = t;
					return !!e.tags.models.itemTags[n]
				},
				N = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.suggestedItemTags[n] || T
				},
				L = (e, t) => {
					let {
						itemId: n
					} = t;
					return a()(N(e, {
						itemId: n
					})).filter(e => e.isRelevant).map(e => Object(d.e)(e, !0))
				},
				U = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.sortedItemTags[n] || []
				},
				M = Object(c.a)((e, t) => {
					let {
						thingId: n,
						suggested: s = !1
					} = t;
					const r = B(e, {
						subredditId: n
					});
					return a()(((e, t) => {
						let {
							thingId: n,
							suggested: s = !1
						} = t;
						const r = (s ? j(e, {
								subredditId: n
							}) : y(e, {
								subredditId: n
							})) ? A(e) : C(e),
							o = s ? v(e, {
								subredditId: n
							}) : I(e, {
								subredditId: n
							}),
							a = r.reduce((e, t) => (e[t.id] = Object(d.f)(t), e), {});
						return o.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), a)
					})(e, {
						thingId: n,
						suggested: s
					})).filter(e => !e.selected && e.id !== r)
				}),
				F = (e, t) => {
					let {
						subredditId: n
					} = t;
					return I(e, {
						subredditId: n
					}).concat(S(e, {
						subredditId: n
					}))
				},
				G = (e, t) => {
					let {
						subredditId: n
					} = t;
					return I(e, {
						subredditId: n
					}).filter(i.b).map(e => ({
						text: e.displayText,
						type: d.c.CLASSIFICATION
					}))
				},
				B = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditPrimaryTagId[n] || null
				},
				q = (e, t) => t && e.tags.models.globalSubredditTags[t] || null,
				V = (e, t) => {
					const n = B(e, t);
					return q(e, n)
				},
				K = e => e.tags.creation.selectedPrimaryTagId || null,
				H = e => {
					const t = K(e);
					return q(e, t)
				},
				W = e => e.tags.api.updatePrimaryTag.pending,
				Y = (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object.keys(k(e, {
						itemId: n
					})).length > 0
				},
				Q = e => b(e).length > 0
		},
		"./src/reddit/selectors/userDataRequest.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = e => e.userDataRequestPage.userDataRequestPageApi.userDataExportEligibility,
				r = e => e.userDataRequestPage.userDataRequestPageApi
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/selectors/moderatorPermissions.ts");
			const a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.userFlair[n]
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !e.userFlair[n] || e.userFlair[n].displaySettings.isEnabled
				},
				i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.userFlair[n] ? e.userFlair[n].displaySettings.position : r.b.Right
				},
				d = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = a(e, {
						subredditId: n
					});
					if (s) return {
						type: r.d.UserFlair,
						displaySettings: s.displaySettings,
						permissions: s.permissions
					}
				}),
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = c(e, {
							subredditId: n
						}),
						r = d(e, {
							subredditId: n
						}),
						i = a(e, {
							subredditId: n
						});
					if (!s || !r || !i) return !1;
					if (i.applied) return !0;
					const u = Object(o.d)(e, {
							subredditId: n
						}),
						{
							canUserChange: l
						} = r.permissions;
					return !!i.templateIds.find(e => {
						return !i.templates[e].modOnly || u
					}) && l
				}
		},
		"./src/reddit/selectors/video.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			const s = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.buffering[n]
				},
				r = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.consumed[n]
				},
				o = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.playing[n]
				},
				a = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.video.loadTimes[n]
				},
				c = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.video.metadata[n]
				},
				i = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.loadable[n]
				},
				d = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.started[n]
				},
				u = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return null;
					const s = e.posts.video.time[n];
					return s ? s.currentTime / 1e3 : null
				},
				l = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.video.continuousViewStartedAt[n] || 0
				}
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/name/index.ts"),
				a = n("./src/reddit/models/Widgets/index.ts"),
				c = n("./src/reddit/selectors/profile.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			const d = [],
				u = e => e.widgets.models,
				l = Object(s.a)((e, t) => Object(a.r)(t) ? e.widgets.models[t.widgetId] : Object(a.l)(t.widgetKind)),
				b = (e, t) => e.widgets.idCardIds[t.subredditId],
				p = (e, t) => {
					let n = t.subredditId;
					if (!n && t.subredditName && (n = Object(i.E)(e, t.subredditName)), n) {
						const t = b(e, {
							subredditId: n
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				f = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				m = (e, t) => e.widgets.menuIds[t.subredditId],
				O = (e, t) => {
					const n = m(e, t);
					return n ? e.widgets.models[n] : null
				},
				g = (e, t) => {
					const n = e.widgets.sidebar[t.subredditId];
					return Array.isArray(n) ? n.reduce((t, n) => {
						const s = e.widgets.models[n];
						return s && t.push(s.kind), t
					}, []) : d
				},
				_ = (e, t) => {
					const n = f(e, t);
					for (const s of n) {
						const t = e.widgets.models[s];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				y = (e, t) => {
					const n = f(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return n.length ? n : null
				},
				j = Object(s.a)((e, t) => {
					if (t.type === r.a.PROFILE) {
						const n = Object(c.j)(e, {
							profileName: t.name
						});
						return n ? {
							profile: {
								id: n.id,
								name: Object(o.f)(n.name)
							}
						} : {}
					}
					const n = Object(i.z)(e, {
							subredditName: t.name
						}),
						s = Object(i.w)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: s ? s.contentCategory : null,
							id: n.id,
							name: Object(o.f)(n.name)
						}
					}
				})
		}
	}
]);
//# sourceMappingURL=Governance~Reddit.386de343eff29d320f5e.js.map