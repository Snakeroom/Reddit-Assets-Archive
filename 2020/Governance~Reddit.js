// https://www.redditstatic.com/desktop2x/Governance~Reddit.2fe500d6e1ad4dfaa861.js
// Retrieved at 1/27/2020, 3:30:17 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~Reddit"], {
		"./assets/fonts/NotoMono/font.less": function(e, t, n) {},
		"./src/graphql/operations/AllUserMultireddits.json": function(e) {
			e.exports = JSON.parse('{"id":"0a5fcd52ba67"}')
		},
		"./src/graphql/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/graphql/operations/CommunityAwardsBlacklistStatus.json": function(e) {
			e.exports = JSON.parse('{"id":"7af03aa4c24e"}')
		},
		"./src/graphql/operations/CreateCommunityAward.json": function(e) {
			e.exports = JSON.parse('{"id":"38852e4f82b0"}')
		},
		"./src/graphql/operations/CreateGlobalAward.json": function(e) {
			e.exports = JSON.parse('{"id":"13b32e3769d6"}')
		},
		"./src/graphql/operations/CreateLayer.json": function(e) {
			e.exports = JSON.parse('{"id":"eb0c351cea1c"}')
		},
		"./src/graphql/operations/CreateModAward.json": function(e) {
			e.exports = JSON.parse('{"id":"a04c85b4e964"}')
		},
		"./src/graphql/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"639d65a32e0e"}')
		},
		"./src/graphql/operations/DeleteAward.json": function(e) {
			e.exports = JSON.parse('{"id":"4d31f6356d57"}')
		},
		"./src/graphql/operations/DeleteTags.json": function(e) {
			e.exports = JSON.parse('{"id":"85a644f8353a"}')
		},
		"./src/graphql/operations/DisableAward.json": function(e) {
			e.exports = JSON.parse('{"id":"5e453976052b"}')
		},
		"./src/graphql/operations/ExperimentVariants.json": function(e) {
			e.exports = JSON.parse('{"id":"34910619f1e9"}')
		},
		"./src/graphql/operations/FetchBlockedRedditorsInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"1e9183c00f76"}')
		},
		"./src/graphql/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"1d3331c579e0"}')
		},
		"./src/graphql/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"8e39ae6fa332"}')
		},
		"./src/graphql/operations/FocusVerticalSubredditRecommendations.json": function(e) {
			e.exports = JSON.parse('{"id":"b3fe6a8eae7e"}')
		},
		"./src/graphql/operations/Frontpage.json": function(e) {
			e.exports = JSON.parse('{"id":"e895443d0fc2"}')
		},
		"./src/graphql/operations/GetPostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"4231b7734ef9"}')
		},
		"./src/graphql/operations/ManageableAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"08c803ef139c"}')
		},
		"./src/graphql/operations/ModeratedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"3c148c0b5100"}')
		},
		"./src/graphql/operations/MultiredditListing.json": function(e) {
			e.exports = JSON.parse('{"id":"2886e38af0e9"}')
		},
		"./src/graphql/operations/OtherDiscussions.json": function(e) {
			e.exports = JSON.parse('{"id":"92223943b497"}')
		},
		"./src/graphql/operations/RedditorMultireddits.json": function(e) {
			e.exports = JSON.parse('{"id":"3d04e2bb92b5"}')
		},
		"./src/graphql/operations/RichTextPostContent.json": function(e) {
			e.exports = JSON.parse('{"id":"fc24b7b690ad"}')
		},
		"./src/graphql/operations/SinglePost.json": function(e) {
			e.exports = JSON.parse('{"id":"7b5014f7e628"}')
		},
		"./src/graphql/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"7d0ee544a263"}')
		},
		"./src/graphql/operations/SubredditDifficulty.json": function(e) {
			e.exports = JSON.parse('{"id":"1479a476a03b"}')
		},
		"./src/graphql/operations/SubredditModels.json": function(e) {
			e.exports = JSON.parse('{"id":"d98849822078"}')
		},
		"./src/graphql/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"7faf0c31756a"}')
		},
		"./src/graphql/operations/SubredditPostFlairStyleTemplates.json": function(e) {
			e.exports = JSON.parse('{"id":"9a87d9b91dc4"}')
		},
		"./src/graphql/operations/SubredditPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"04417bfe478c"}')
		},
		"./src/graphql/operations/SubredditRecommendations.json": function(e) {
			e.exports = JSON.parse('{"id":"43275c35dbb6"}')
		},
		"./src/graphql/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"0df127946e72"}')
		},
		"./src/graphql/operations/SubredditStyles.json": function(e) {
			e.exports = JSON.parse('{"id":"8d0e34deaa32"}')
		},
		"./src/graphql/operations/SubredditTopContent.json": function(e) {
			e.exports = JSON.parse('{"id":"b0b26048d3d3"}')
		},
		"./src/graphql/operations/SubredditTypeaheadSearch.json": function(e) {
			e.exports = JSON.parse('{"id":"20edc5ee12df"}')
		},
		"./src/graphql/operations/TopSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"9e9ef4c82a00"}')
		},
		"./src/graphql/operations/TopicBySlug.json": function(e) {
			e.exports = JSON.parse('{"id":"17a82305a01e"}')
		},
		"./src/graphql/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/graphql/operations/UpdateSubredditTagStates.json": function(e) {
			e.exports = JSON.parse('{"id":"70f7ff70f03e"}')
		},
		"./src/graphql/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/graphql/operations/UsableAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"745201a7132e"}')
		},
		"./src/graphql/operations/UsableAwardsForProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"0ed9ee84b867"}')
		},
		"./src/graphql/operations/UserDataExportEligibility.json": function(e) {
			e.exports = JSON.parse('{"id":"3817c69d7a39"}')
		},
		"./src/lib/CSSVariableProvider/withTheme.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/CSSVariableProvider/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e) {
				return t => s.a.createElement(o.b.Consumer, null, n => s.a.createElement(e, i({
					theme: n
				}, t)))
			}
		},
		"./src/lib/FocusTrap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = ['input:not([type="hidden"]):not([disabled])', "select:not([disabled])", "textarea:not([disabled])", "a[href]", "button:not([disabled])", '[tabindex]:not([tabindex="-1"]):not([disabled])', "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join();
			class s {
				constructor(e) {
					this.active = !1, this.onKeyDown = e => {
						if ("Tab" === e.key || 9 === e.keyCode) {
							const [t, n] = this.getTabbableNodes();
							if (!t || !n) return;
							e.shiftKey && e.target === t ? (e.preventDefault(), this.tryToFocusNode(n)) : e.shiftKey || e.target !== n || (e.preventDefault(), this.tryToFocusNode(t))
						}
					}, this.container = e
				}
				activate() {
					this.active || (this.active = !0, document.addEventListener("keydown", this.onKeyDown, !0))
				}
				deactivate() {
					this.active && (document.removeEventListener("keydown", this.onKeyDown, !0), this.active = !1)
				}
				getTabbableNodes() {
					const e = this.container.querySelectorAll(r);
					return [e[0], e[e.length - 1]]
				}
				tryToFocusNode(e) {
					e !== document.activeElement && e.focus && e.focus()
				}
			}
		},
		"./src/lib/addAllowQuarantinedParam/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(r.a)(e, {
				allow_quarantined: !0
			})
		},
		"./src/lib/assertNever.ts": function(e, t, n) {
			"use strict";

			function r(e) {
				throw new Error("Unexpected object: ".concat(e))
			}
			n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/lib/base64/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			window.atob;
			const r = window.btoa
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./node_modules/bignumber.js/bignumber.js");

			function s(e, t) {
				const n = new r.BigNumber(e),
					s = new r.BigNumber(t),
					o = new r.BigNumber(n.dividedBy(s)),
					i = new r.BigNumber("100").multipliedBy(o);
				return new r.BigNumber(i).toNumber()
			}
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = "custom"
		},
		"./src/lib/eventTools/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			}));
			var r, s = n("./src/lib/constants/index.ts");

			function o(e, t) {
				const n = e * s.Bb,
					o = t * s.Bb,
					i = Date.now();
				return i < n ? r.Future : i >= n && i <= o ? r.Live : r.Past
			}

			function i(e, t) {
				return o(e, t) === r.Future
			}

			function c(e) {
				return function(e, t) {
					const n = e / t;
					return n >= 0 ? Math.floor(n) : Math.ceil(n)
				}(e * s.Bb - Date.now(), s.w)
			}

			function a(e) {
				const t = e * s.Bb,
					n = new Date,
					r = new Date(t);
				return n.getFullYear() === r.getFullYear() && n.getMonth() === r.getMonth() && n.getDate() === r.getDate()
			}! function(e) {
				e.Future = "before", e.Live = "now", e.Past = "after"
			}(r || (r = {}))
		},
		"./src/lib/filterQueryParams/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			var r = n("./node_modules/lodash/omit.js"),
				s = n.n(r),
				o = n("./node_modules/url/url.js"),
				i = n.n(o);
			t.a = (e, t) => {
				const n = i.a.parse(e, !0);
				return n.search = void 0, n.query = Object.assign({}, s()(n.query, t)), i.a.format(n)
			}
		},
		"./src/lib/forceHttps/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = function(e) {
				return e.startsWith("http") ? e.replace(/^http:\/\//i, "https://") : "https://".concat(e)
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/app/strings/sources/error.js");

			function o(e, t, n) {
				return t ? t.fields && t.fields.length ? t.fields.map(e => e.msg).join(", ") : t.type && s.a[t.type] ? Object(r.a)(e, "error.".concat(t.type)) : 401 === n ? Object(r.a)(e, "error.authentication") : Object(r.a)(e, "error.generic") : ""
			}
		},
		"./src/lib/formatEmojiName/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			const r = ":",
				s = /^:[A-Za-z0-9_-]{1,24}:$/;

			function o(e) {
				return s.test(e) ? e : "".concat(r).concat(e).concat(r)
			}
		},
		"./src/lib/getMobileOperatingSystem/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const r = () => {
					const e = navigator.userAgent || navigator.vendor || window.opera;
					return /android/i.test(e) ? "Android" : /iPad|iPhone|iPod/.test(e) && !window.MSStream ? "iOS" : "unknown"
				},
				s = () => "Android" === r() || "iOS" === r()
		},
		"./src/lib/getParsedUserAgent/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			}));
			var r = n("./node_modules/ua-parser-js/src/ua-parser.js"),
				s = n.n(r);
			const o = e => "mobile" === u(e).device.type,
				i = e => "mobile" !== u(e).device.type,
				c = e => "Chrome" === u(e).browser.name,
				a = e => "Firefox" === u(e).browser.name,
				d = e => "Opera" === u(e).browser.name;

			function u(e) {
				return new s.a(e).getResult()
			}
		},
		"./src/lib/getUrlQueryParams/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/extractQueryParams/index.ts");

			function s() {
				return Object(r.a)(window.location.href)
			}
		},
		"./src/lib/isAdHocMultireddit/index.ts": function(e, t, n) {
			"use strict";
			const r = /^(all|mod)(\b|$)/;
			t.a = e => {
				const t = e.toLowerCase();
				return !r.test(t) && (t.indexOf("+") > -1 && -1 === t.indexOf("-"))
			}
		},
		"./src/lib/isFakeSubreddit/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/constants/page.ts");
			const s = [r.a, r.b, r.d.Frontpage, r.d.All, r.d.Mod, r.d.Friends, r.d.Popular, r.d.Topic].concat(["random", "randnsfw", "myrandom"]);
			t.a = e => {
				const t = e.toLowerCase();
				return s.includes(t) || t.indexOf("+") > -1 || t.indexOf("-") > -1
			}
		},
		"./src/lib/isPinnedAdminPost/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts");
			t.a = (e, t) => e && t === r.B.ADMIN
		},
		"./src/lib/listingSort/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/lib/constants/index.ts");
			const s = e => e === r.N.TOP || e === r.N.CONTROVERSIAL,
				o = e => {
					let {
						timeSort: t
					} = e;
					return (t = s(e.sort) ? t || r.Pb : void 0) === e.timeSort ? e : Object.assign({}, e, {
						timeSort: t
					})
				},
				i = e => {
					const [t, n] = e.split("_");
					return o({
						sort: t,
						timeSort: n
					})
				},
				c = e => {
					const {
						sort: t,
						timeSort: n
					} = o(e);
					return t + (n ? "_".concat(n) : "")
				}
		},
		"./src/lib/loginHref/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./node_modules/history/esm/history.js");
			t.a = (e, t, n) => {
				const o = Object(s.e)(e),
					i = encodeURIComponent("".concat(t).concat(o));
				return "".concat(r.a.accountManagerOrigin).concat(n || "/login", "?dest=").concat(i)
			}
		},
		"./src/lib/makeCollectionCommentsPageKey/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			t.a = function(e, t, n) {
				let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
					s = "collectionCommentsPage--[collection:'".concat(e, "']");
				return t && (s += "--[post:'".concat(t, "']")), n && (s += "--[rootComment:'".concat(n, "']")), r && (r.sort && r.hasSortParam && (s += "--[sort:'".concat(r.sort, "']")), r.context && (s += "--[context:".concat(r.context, "]")), r.depth && (s += "--[depth:".concat(r.depth, "]"))), s
			}
		},
		"./src/lib/makeCommentPermalink/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/redditId/index.ts");
			t.a = (e, t) => {
				let n = e;
				return "/" !== n.substr(-1) && (n += "/"), n += Object(r.c)(t)
			}
		},
		"./src/lib/makeCommentsPageKey/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			t.a = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
					r = "commentsPage--[post:'".concat(e, "']");
				return t && (r += "--[rootComment:'".concat(t, "']")), n && (n.sort && n.hasSortParam && (r += "--[sort:'".concat(n.sort, "']")), n.context && (r += "--[context:".concat(n.context, "]")), n.depth && (r += "--[depth:".concat(n.depth, "]"))), r
			}
		},
		"./src/lib/makeDraftKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/reddit/models/PostDraft/index.ts");

			function s(e, t) {
				return "".concat(r.c[e], "_").concat(t)
			}
		},
		"./src/lib/makeExplorePageKey/index.ts": function(e, t, n) {
			"use strict";

			function r(e) {
				return "Explore--[categoryName:".concat(e.categoryName, "]")
			}
			n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/lib/makeGqlRequest/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/lodash/omit.js"),
				s = n.n(r),
				o = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./src/lib/addQueryParams/index.ts")),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/constants/headers.ts"),
				a = n("./src/lib/env/index.ts"),
				d = n("./src/lib/logs/errors.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/makeRequest/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/customMiddleware/gqlContext.ts"),
				m = n("./src/reddit/singleton/tracing/index.ts");
			n.d(t, "a", (function() {
				return O
			}));
			const f = (e, t) => {
					const n = Object.assign({}, t, {
							headers: Object.assign({}, t.headers || {}, e.headers)
						}),
						r = Object(a.b)() ? [b.a] : [b.a, c.c];
					n.headers = s()(n.headers, r);
					const i = m.a.getTracingHeaders();
					return n.headers = Object.assign({}, n.headers, i), n.endpoint = (e => Object(o.a)(e, {
						request_timestamp: Date.now().toString()
					}))(n.endpoint), n
				},
				g = (e, t, n) => {
					const {
						errors: r
					} = n.body;
					r && r.length && Object(d.a)({
						context: e,
						endpoint: t.endpoint,
						error: r.map(e => e.message).join("\n"),
						type: i.p.GQL
					})
				};

			function O(e, t, n) {
				const r = n && n.traceRequestName ? n.traceRequestName : "gql_api_call";
				return m.a.recordRpcSpanAsync(r, async () => {
					const r = Object(p.b)(e),
						s = Object.assign({}, n ? Object.assign({}, n) : {}, {
							data: t,
							method: i.bb.POST,
							endpoint: r.apiUrl,
							type: "json"
						}),
						o = f(r, s);
					return r.onBeforeRequest(o), Object(l.b)(o).then(e => (r.onResponse(e, {
						allowSetEmptyLoid: t.allowSetEmptyLoid
					}), !e.ok && (Object(u.d)(r, s, e), e.status >= 400) ? Object.assign({}, e, {
						error: {
							type: Object(u.e)(e.status)
						}
					}) : e.body.errors ? (g(r, Object.assign({}, s, {
						operation: t.id || t.query
					}), e), Object.assign({}, e, {
						ok: !1,
						error: {
							type: i.D.BAD_REQUEST,
							fields: e.body.errors.map(e => ({
								msg: e.message || ""
							}))
						}
					})) : (e.ok && e.body, Object.assign({}, e, {
						error: null
					}))))
				})
			}
		},
		"./src/lib/makeListingKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/lib/isAdHocMultireddit/index.ts"),
				s = n("./src/lib/isFakeSubreddit/index.ts");
			const o = e => e.includes("--[sort:");
			t.a = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
					o = e || "";
				return Object(s.a)(o) && Object(r.a)(o) && (o = o.split("+").sort().join("+")), t && (o += "--[sort:'".concat(t, "']")), n.after && (o += "--[after:'".concat(n.after, "']")), n.before && (o += "--[before:'".concat(n.before, "']")), n.category && (o += "--[category:'".concat(n.category, "']")), n.categoryId && (o += "--[category:'".concat(n.categoryId, "']")), n.t && (o += "--[t:'".concat(n.t, "']")), n.geo_filter && (o += "--[geo_filter:'".concat(n.geo_filter, "']")), n.isOtherDiscussions && (o += "--[onOtherDiscussions]"), n.subredditName && (o += "--[subredditName:'".concat(n.subredditName, "']")), n.topicSlug && (o += "--[topic:'".concat(n.topicSlug, "']")), o.toLowerCase()
			}
		},
		"./src/lib/makeOnboardingSubredditsKey/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				let t = "onboarding";
				return e.city && (t += "--[city:'".concat(e.city, "']")), e.country && (t += "--[country:'".concat(e.country, "']")), e.region && (t += "--[region:'".concat(e.region, "']")), t.toLowerCase()
			}
		},
		"./src/lib/makeOverviewConversationsItemKey/index.ts": function(e, t, n) {
			"use strict";
			t.a = (e, t) => {
				return "overviewConversations--[profile:'".concat(t, "']--[post:'").concat(e, "']")
			}
		},
		"./src/lib/makePostCreationPageKey/index.ts": function(e, t, n) {
			"use strict";

			function r(e) {
				let t = "PostCreationPage";
				return e.subredditName && (t += "--[subreddit:".concat(e.subredditName, "]")), e.profileName && (t += "--[profile:".concat(e.profileName, "]")), e.collectionId && (t += "--[collection:".concat(e.collectionId, "]")), t
			}
			n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, n) {
			"use strict";

			function r(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += "--[draftId:".concat(e.draftId, "]")), t
			}
			n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/lib/makeSearchKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r, s = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/parameters.ts");
			! function(e) {
				e.Trending = "trending", e.PromotedTrend = "promoted_trend"
			}(r || (r = {}));
			const i = e => {
					return c(e).join(",")
				},
				c = e => {
					let t;
					return "string" == typeof e ? t = decodeURIComponent(e).split(",").filter(s.Yb).sort() : Array.isArray(e) && (t = e.filter(s.Yb).sort()), t && 0 !== t.length || (t = [s.Jb.Posts, s.Jb.Subreddits, s.Jb.Users]), t
				},
				a = new Set(["f", "n", "0"]),
				d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
					const t = e.toLowerCase();
					return !(0 === t.length || "off" === t || a.has(t[0]))
				},
				u = e => e ? "1" : "",
				l = e => {
					const t = e.sort && Object(s.Xb)(e.sort) ? e.sort : s.zb,
						n = e.t && s.Tb.has(e.t) ? e.t : s.Ab,
						r = c(e.type),
						i = {
							ad: e.ad,
							q: e.q,
							sort: t,
							t: n,
							type: r
						};
					return void 0 !== e.include_over_18 && (i.include_over_18 = u(d(e.include_over_18))), void 0 !== e.restrict_sr && (i.restrict_sr = u(d(e.restrict_sr))), e.is_multi && (i.is_multi = u(d(e.is_multi))), e.category && (i.category = e.category), e[o.b] && (i.category_name = e.category_name), e[o.s] && (i.source = e.source), i
				};
			t.b = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
					r = e || "!";
				return t && (r = "".concat(r, "--[user:").concat(t, "]")), void 0 !== n.include_over_18 && (r = "".concat(r, "--[include_over_18:").concat(n.include_over_18, "]")), n.q && (r = "".concat(r, "--[q:").concat(n.q, "]")), n.restrict_sr && (r = "".concat(r, "--[restrict_sr:").concat(n.restrict_sr, "]")), n.sort && (r = "".concat(r, "--[sort:").concat(n.sort, "]")), n.t && (r = "".concat(r, "--[t:").concat(n.t, "]")), n.category && (r = "".concat(r, "--[c:").concat(n.category, "]")), n.type && (r = "".concat(r, "--[type:").concat(i(n.type), "]")), r.toLowerCase()
			}
		},
		"./src/lib/objectSelector/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var r = n("./node_modules/lodash/isEqual.js"),
				s = n.n(r);

			function o(e) {
				let t = null;
				return (n, r) => {
					const o = e(n, r);
					return s()(o, t) ? t : (t = o, o)
				}
			}
			const i = e => {
				const t = o(e);
				return e => t(e, null)
			}
		},
		"./src/lib/omitKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};

			function s(e, t) {
				if (t in e) {
					const n = t;
					e[n];
					return r(e, ["symbol" == typeof n ? n : n + ""])
				}
				return e
			}
		},
		"./src/lib/permalinkToOverlayLocation/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/history/esm/history.js"),
				s = n("./src/lib/LRUCache/index.ts"),
				o = n("./src/reddit/constants/history.ts"),
				i = n("./src/reddit/helpers/path/index.ts");
			const c = new s.a(250);
			t.a = (e, t) => {
				let n;
				if (!(n = c.get(e + t))) {
					const s = Object(i.b)(e);
					(n = Object(r.c)(s)).state = Object.assign({}, n.state, {
						[o.a.IsOverlay]: !0,
						[o.a.ScrollOnLoad]: t
					}), c.set(e + t, n)
				}
				return n
			}
		},
		"./src/lib/search/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./src/lib/addQueryParams/index.ts");
			const s = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
					return decodeURIComponent(e).replace(/\+/g, " ")
				},
				o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
					return encodeURIComponent(e)
				},
				i = (e, t, n) => {
					return Object(r.a)(e, n).replace(/(\?|&)(q=)([^&]*)/, (e, n, r) => e ? "".concat(n).concat(r).concat(t) : e)
				}
		},
		"./src/lib/truncateText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es7.string.trim-right.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			const r = /\s*[,-:;\u2013\u2014]\s*$/;

			function s(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
				if (e.length <= t || t < 0) return e;
				if ((e = e.trim().replace(/\s+/g, " ")).length <= t) return e;
				t -= n.length;
				let s = e.lastIndexOf(" ", t);
				return s = s > 0 ? s : t, e.slice(0, s).replace(r, "").trimRight() + n
			}
		},
		"./src/lib/unicodeUtils/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = e => {
					let t = 0,
						n = 0;
					const r = [0];
					for (const s of e) t++, n += s.length, r[t] = n;
					return r
				},
				s = e => {
					let t = 0,
						n = 0;
					const r = [];
					for (const s of e) {
						for (let e = 0; e < s.length; e++) r[n] = t, n++;
						t++
					}
					return r[n] = t, r
				}
		},
		"./src/lib/uploadToS3/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/lib/makeRequest/index.ts");
			const i = (e, t) => {
				const n = new FormData;
				return t.fields.forEach(e => {
					e.value && n.append(e.name, e.value)
				}), n.append("file", e), n
			};
			t.a = async (e, t, c) => {
				const a = (() => Object(s.a)(() => Promise.all([n.e("vendors~ExportTheme~ImportTheme~xml2js"), n.e("vendors~xml2js"), n.e("xml2js")]).then(n.t.bind(null, "./node_modules/xml2js/lib/xml2js.js", 7))).then(e => e.default))(),
					d = await Object(o.b)({
						data: i(e, t),
						endpoint: t.action,
						method: r.bb.POST,
						type: null,
						setup: c
					});
				if ("string" != typeof d.body) return d;
				try {
					(await a).parseString(d.body, (e, t) => {
						d.body = t
					})
				} catch (u) {
					d.body = u
				}
				return d
			}
		},
		"./src/reddit/actions/ads/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			}));
			const r = "AD_BRAND_SAFETY_STATUS_RECEIVED",
				s = "FETCH_COMMENTS_PAGE_ADS_COMPLETED",
				o = "FETCH_COMMENTS_PAGE_ADS_FAILED",
				i = "FETCH_SIDEBAR_PROMOTED_POSTS_COMPLETED",
				c = "FETCH_SIDEBAR_PROMOTED_POSTS_FAILED",
				a = "REFRESH_SIDEBAR_PROMOTED_POST_COMPLETED",
				d = "REFRESH_SIDEBAR_PROMOTED_POST_FAILED",
				u = "RESET_SIDEBAR_PROMOTED_POSTS"
		},
		"./src/reddit/actions/ads/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/config.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts");
			const c = async (e, t, n) => {
				const r = {
					count: t
				};
				return n && (r.subreddit = n), Object(i.b)(e, {
					type: "json",
					endpoint: "".concat(s.a.gatewayUrl, "/desktopapi/v1/sidebar_ads"),
					method: o.bb.POST,
					data: r
				})
			};
			var a = n("./src/reddit/helpers/adCount/index.ts"),
				d = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				u = n("./src/reddit/selectors/brandSafety.ts"),
				l = n("./src/reddit/selectors/platform.ts"),
				b = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/actions/ads/constants.ts");
			n.d(t, "d", (function() {
				return f
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "a", (function() {
				return v
			}));
			const m = Object(r.a)(p.a),
				f = e => async (t, n) => {
					const r = n();
					Object(u.c)(r) && Object(u.d)(r) === e.isViewSafe || t(m(e))
				}, g = Object(r.a)(p.d), O = Object(r.a)(p.e), h = Object(r.a)(p.f), y = Object(r.a)(p.g), j = (Object(r.a)(p.h), Object(r.a)(p.b)), _ = (Object(r.a)(p.c), e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = Object(a.b)(o, e),
						u = i.length;
					if (0 === u) return;
					switch (e) {
						case d.a.COMMENTS:
						case d.a.COMMENTS_OVERLAY:
							if (!Object(l.n)(o, {
									page: o.platform.currentPage
								})) return;
							break;
						case d.a.FRONTPAGE:
						case d.a.MULTIREDDIT:
						case d.a.SEARCH_RESULTS:
						case d.a.SUBREDDIT: {
							const e = o.listings.activeKey,
								t = Object(b.O)(o, {
									listingKey: e
								});
							if (!t || !t.length) return;
							break
						}
						default:
							return void 0
					}
					const p = Object(l.e)(o);
					let m;
					if ((m = p ? await c(s(), u, p) : await c(s(), u)).body && m.body.length) {
						const e = m.body,
							n = {};
						for (let t = 0; t < e.length; t++) n[i[t]] = e[t];
						t(g(n))
					} else t(O(m.error))
				}), E = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = await c(s(), 1);
					o.body && o.body.length ? t(h({
						[e]: o.body[0]
					})) : t(y(o.error))
				}, v = e => async (t, n, r) => {
					let {
						apiContext: c
					} = r;
					const a = Object(l.e)(n()),
						d = await (async (e, t, n, r) => {
							const c = {
								count: t,
								subreddit: r,
								post_id: n
							};
							return Object(i.b)(e, {
								type: "json",
								endpoint: "".concat(s.a.gatewayUrl, "/desktopapi/v1/comments_page_ads"),
								method: o.bb.POST,
								data: c
							})
						})(c(), 1, e, a);
					d.body && d.body.length ? t(j(d.body)) : t(O(d.error))
				}
		},
		"./src/reddit/actions/apiRequestHeaders.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "API_REQUEST_HEADERS__set";
			Object(r.a)(s)
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				i = "API_REQUEST_STATE__COMPLETED",
				c = "API_REQUEST_STATE__FAILED",
				a = "API_REQUEST_STATE__RELEASED";

			function d(e) {
				return {
					type: o,
					payload: {
						apiRequestStatus: s.a.Pending,
						apiRequestId: e
					}
				}
			}

			function u(e) {
				return {
					type: i,
					payload: {
						apiRequestStatus: s.a.Complete,
						apiRequestId: e
					}
				}
			}

			function l(e, t) {
				return {
					type: c,
					payload: {
						apiRequestStatus: s.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const b = Object(r.a)(a)
		},
		"./src/reddit/actions/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "IN_CONTEXT_AUTHOR_FLAIR_UPDATED",
				o = Object(r.a)(s)
		},
		"./src/reddit/actions/badge.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "m", (function() {
				return T
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/governance/errorToast.ts"),
				o = n("./src/reddit/endpoints/governance/badges.ts");
			const i = "BADGE__BADGE_MODAL_OPENED",
				c = "BADGE__BADGE_APPLICATION_SUCCESS",
				a = "BADGE__BADGE_APPLICATION_FAILURE",
				d = "BADGE__SUBREDDIT_BADGES_FETCH_SUCCESS",
				u = "BADGE__SUBREDDIT_BADGES_FETCH_FAILURE",
				l = "BADGE__SUBREDDIT_BADGES_FETCH_PENDING",
				b = "BADGE__USER_BADGES_FETCH_SUCCESS",
				p = "BADGE__USER_BADGES_FETCH_FAILURE",
				m = "BADGE__USER_BADGES_FETCH_PENDING",
				f = Object(r.a)(i),
				g = Object(r.a)(c),
				O = Object(r.a)(a),
				h = (Object(r.a)("BADGE__BADGE_APPLICATION_PENDING"), Object(r.a)(d)),
				y = Object(r.a)(u),
				j = Object(r.a)(l),
				_ = Object(r.a)(b),
				E = Object(r.a)(p),
				v = Object(r.a)(m),
				I = e => {
					let {
						badgeIds: t,
						subredditId: n
					} = e;
					return async (e, r, i) => {
						let {
							apiContext: c
						} = i;
						const a = r(),
							d = a.user.account;
						if (d) {
							const r = (a.users.appliedBadges[d.id] || {})[n] || [],
								i = t.length ? t[0] : r[0],
								u = !!t.length;
							e(g({
								badgeIds: t,
								subredditId: n,
								userId: d.id
							}));
							const l = await Object(o.a)(c(), n, i, u);
							l.ok || (e(O({
								badgeIds: t,
								subredditId: n,
								error: l.error,
								previousBadgeIds: r,
								userId: d.id
							})), Object(s.a)(e, l.error))
						}
					}
				},
				S = e => {
					let {
						subredditId: t,
						userIds: n
					} = e;
					return async (e, r, s) => {
						let {
							apiContext: i
						} = s;
						e(j({
							subredditId: t
						}));
						const c = await Object(o.b)(i(), t, n);
						c.ok ? e(h(Object.assign({}, c.body, {
							subredditId: t
						}))) : e(y({
							subredditId: t,
							error: c.error
						}))
					}
				},
				T = e => {
					let {
						subredditId: t
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: s
						} = r;
						const i = n().user.account;
						if (i) {
							e(v({
								subredditId: t
							}));
							const n = await Object(o.c)(s(), t, i.id);
							n.ok ? e(_(Object.assign({}, n.body, {
								subredditId: t
							}))) : e(E({
								subredditId: t,
								error: n.error
							}))
						}
					}
				}
		},
		"./src/reddit/actions/blockedRedditors.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/graphql/operations/FetchBlockedRedditorsInfo.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			const i = (e, t) => Object(o.a)(e, Object.assign({}, s, {
				variables: t
			}), {
				traceRequestName: "get_blocked_redditors_info"
			});
			var c = n("./src/reddit/selectors/blockedRedditors.ts");
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "g", (function() {
				return h
			}));
			const a = "BLOCKED_REDDITORS_LIST__ADD",
				d = "BLOCKED_REDDITORS_LIST__REMOVE",
				u = "BLOCKED_REDDITORS_LIST__FAILED",
				l = "BLOCKED_REDDITORS_LIST__LOADED",
				b = "BLOCKED_REDDITORS_LIST__PENDING",
				p = Object(r.a)(a),
				m = Object(r.a)(d),
				f = Object(r.a)(u),
				g = Object(r.a)(l),
				O = Object(r.a)(b),
				h = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const s = t(),
						o = Object(c.a)(s);
					if (Object(c.b)(s) || o.timestamp && Date.now() - o.timestamp < 36e6) return;
					let a = !1,
						d = "";
					do {
						e(O());
						const t = {
								after: d,
								pageSize: 100
							},
							n = await i(r(), t);
						if (n && n.ok) {
							const {
								data: {
									identity: t
								}
							} = n.body;
							if (t && t.blockedRedditorsInfo) {
								const {
									pageInfo: n,
									edges: r
								} = t.blockedRedditorsInfo;
								if (e(g(r.map(e => e.node.id))), n) {
									const {
										hasNextPage: e,
										endCursor: t
									} = n;
									a = e, d = t || ""
								}
							} else a = !1
						} else {
							a = !1;
							const t = n.error ? n.error.type : "unknown error";
							e(f({
								message: t
							}))
						}
					} while (a)
				}
		},
		"./src/reddit/actions/bulkActions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = "BULKACTION_PENDING",
				s = "BULKACTION_LOADED",
				o = "BULKACTION_FAILED"
		},
		"./src/reddit/actions/category.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "i", (function() {
				return S
			})), n.d(t, "j", (function() {
				return T
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "k", (function() {
				return w
			}));
			var r = n("./node_modules/lodash/isEmpty.js"),
				s = n.n(r),
				o = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/constants/categories.tsx"),
				a = n("./src/reddit/endpoints/category/categoryList.ts"),
				d = n("./src/reddit/endpoints/category/subreddits.ts"),
				u = n("./src/reddit/helpers/localStorage/index.ts"),
				l = n("./src/reddit/selectors/category.ts");
			const b = "CATEGORY__LIST_PENDING",
				p = "CATEGORY__LIST_LOADED",
				m = "CATEGORY__LIST_FAILED",
				f = Object(i.a)(b),
				g = Object(i.a)(p),
				O = Object(i.a)(m),
				h = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t(),
						o = Object(l.j)(s),
						i = Object(l.i)(s);
					if (o || i) return;
					e(f());
					const c = await Object(a.a)(r());
					if (c.ok) {
						const {
							categories: t,
							categoryIds: n
						} = Object(a.b)(c.body);
						e(g({
							categories: t,
							categoryIds: n
						}))
					} else e(O(c.error))
				}, y = "CATEGORY__SUBREDDITS_PENDING", j = "CATEGORY__SUBREDDITS_LOADED", _ = "CATEGORY__SUBREDDITS_FAILED", E = Object(i.a)(y), v = Object(i.a)(j), I = Object(i.a)(_), S = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(l.o)(i, {
							id: e
						}),
						a = Object(l.n)(i, {
							id: e
						});
					if (c || a) return;
					n(E({
						categoryId: e
					}));
					const u = await Object(d.a)(o(), e, t);
					if (u.ok) {
						const t = Object(d.b)(u.body);
						n(v(Object.assign({
							categoryId: e
						}, t)))
					} else n(I({
						categoryId: e,
						error: u.error
					}))
				}, T = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					await t(S(e));
					const a = n(),
						d = Object(l.m)(a, {
							id: e
						});
					if (!d) return;
					const {
						name: u
					} = d, b = Object(l.c)()(a, {
						categoryName: u
					});
					s()(b) || t(Object(o.b)(Object(c.e)(b)))
				}, x = "CATEGORY__RANK_SET", C = Object(i.a)(x), w = e => async (t, n) => {
					const r = Object(l.l)(n(), {
						id: e
					});
					t(C({
						categoryId: e,
						rank: r + 1
					})), Object(u.G)(Object(l.g)(n()))
				}
		},
		"./src/reddit/actions/chat/constants.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.anybody = "Everyone", e.account_age_30_days = "Accounts older than 30 days", e.nobody = "Nobody"
				}(r || (r = {}))
		},
		"./src/reddit/actions/chat/init.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return u
			}));
			var r = n("./src/chat/reducers/subscribe.ts"),
				s = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts");
			let i;
			let c;
			const a = "CHAT__INITED",
				d = Object(o.a)(a),
				u = async (e, t, o) => c ? {
					chatStore: c,
					firstInit: !1
				} : (c = await (async (e, t, r) => {
					const o = Date.now(),
						i = await Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/initializer.ts"))).then(e => e.default);
					return (await i(t(), o, r)).store
				})(0, t, o), await (async (e, t, o) => {
					if (!i) {
						const c = (await Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/reddit/actions/chat/proxy.ts"))).then(e => e.default))(t, o),
							a = Object(r.b)(e, c);
						i = e.subscribe(a)
					}
				})(c, e, t), e(d()), {
					chatStore: c,
					firstInit: !0
				})
		},
		"./src/reddit/actions/chat/sendbirdProxy.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return c
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/chat/index.ts");
			const o = "SENDBIRD_PROXY__SET_CONFIG",
				i = Object(r.a)(o),
				c = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = await Object(s.h)(r());
					o.ok && await e(i(o.body))
				}
		},
		"./src/reddit/actions/chat/subredditChannel.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "b", (function() {
				return x
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/chat/index.ts"),
				o = n("./src/reddit/models/SubredditChannel/index.ts"),
				i = n("./src/reddit/selectors/chat.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const a = "SUBREDDIT_CHANNELS__REQUESTED",
				d = "SUBREDDIT_CHANNELS__ADDED",
				u = "SUBREDDIT_CHANNELS__FAILED",
				l = "SUBREDDIT_CHANNEL__ADDED",
				b = "SUBREDDIT_CHANNEL__SELECTED",
				p = "SUBREDDIT_CHANNEL__EDITED",
				m = "SUBREDDIT_CHANNEL__REMOVED",
				f = Object(r.a)(b),
				g = Object(r.a)(a),
				O = Object(r.a)(u),
				h = Object(r.a)(d),
				y = Object(r.a)(l),
				j = Object(r.a)("SUBREDDIT_CHANNEL__FAILED"),
				_ = e => async (t, n, r) => {
					let {
						apiContext: c
					} = r;
					const {
						user: {
							account: a,
							session: d
						}
					} = n();
					if (!a || !d) return;
					t(g({
						subredditId: e
					}));
					const u = Object(i.e)(n(), {
							subredditId: e
						}),
						l = await Object(s.i)(c(), e, u);
					if (l.ok) {
						const {
							rooms: n,
							subreddit_chat_enabled: r,
							user_subreddit_chat_enabled: s
						} = l.body, i = Object(o.d)(n);
						t(h({
							collection: i,
							subredditId: e,
							isSubredditWhitelisted: !!r,
							isUserSubredditChatEnabled: !!s
						}))
					} else if (l.error) {
						const {
							error: n
						} = l;
						t(O({
							error: n,
							subredditId: e
						}))
					}
				}, E = (e, t) => async (n, r, i) => {
					let {
						apiContext: c
					} = i;
					const {
						user: {
							account: a,
							session: d
						}
					} = r();
					if (!a || !d) return;
					const u = await Object(s.d)(c(), d, t);
					if (u.ok) {
						const r = Object(o.e)(Object.assign({}, u.body, t));
						return await n(y({
							channel: r,
							subredditId: e
						})), r
					}
					n(j(u.error))
				}, v = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const {
						channelSendbirdUrl: c
					} = e, {
						user: {
							session: a
						}
					} = r();
					if (!a) return;
					const d = await Object(s.f)(i(), c, a, t);
					d.ok ? n(I({
						channel: e,
						editedSubredditChannelData: t
					})) : n(j(d.error))
				}, I = Object(r.a)(p), S = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const {
						channelId: i,
						channelSendbirdUrl: a
					} = e, d = n();
					if (!Object(c.K)(d)) return;
					const u = await Object(s.e)(o(), a);
					u.ok ? t(T(i)) : t(j(u.error))
				}, T = Object(r.a)(m), x = "SUBREDDIT_CHANNELS__ENABLED";
			Object(r.a)(x)
		},
		"./src/reddit/actions/chat/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/chat/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = "CHAT_SUBREDDIT_SETTINGS__SET",
				c = Object(r.a)(i),
				a = Object(r.a)("CHAT_SUBREDDIT_SETTINGS__SET_FAILED"),
				d = async (e, t, n) => {
					try {
						if (n) return await e(c(Object.assign({
							subredditId: t
						}, n))), n
					} catch (r) {
						a(r)
					}
				}, u = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					try {
						const r = n();
						if (!Object(o.K)(r)) return;
						const c = await Object(s.g)(i(), e);
						return d(t, e, c)
					} catch (c) {
						a(c)
					}
				}, l = (e, t) => async (n, r, i) => {
					let {
						apiContext: c
					} = i;
					try {
						const i = r();
						if (!Object(o.K)(i)) return;
						const a = await Object(s.j)(c(), e, t);
						a.ok && d(n, e, a.body)
					} catch (u) {
						a(u)
					}
				}
		},
		"./src/reddit/actions/chat/toggle.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/chat/constants/container.ts"),
				i = n("./src/reddit/actions/chat/init.ts"),
				c = n("./src/reddit/helpers/trackers/authorHovercard.ts");
			const a = () => Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/actions/meta.ts"))).then(e => e.setExternalData),
				d = () => Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/actions/container.ts"))).then(e => e.sizeChanged);
			async function u(e, t, n, s) {
				const [{
					chatStore: u,
					firstInit: l
				}, b] = await Promise.all([Object(i.c)(e, t, n), d()]), p = t(), m = await a(), f = Object(c.h)(p, s);
				u.dispatch(m(f)), u.getState().container.size !== o.a.EMBED && u.dispatch(b(o.a.EMBED)), !l && u.dispatch(Object(r.c)(n))
			}
			const l = () => async (e, t) => Promise.all([Object(i.c)(e, t), d()]).then(e => {
				let [{
					chatStore: t,
					firstInit: n
				}, r] = e;
				t.getState().container.size !== o.a.EMBED || n ? t.dispatch(r(o.a.EMBED)) : t.dispatch(r(o.a.HIDDEN))
			}), b = (e, t) => async (r, o) => {
				const i = (await (() => Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/helpers/urls/index.ts"))).then(e => e.channelUserIdUrl))())(e);
				await u(r, o, i, t)
			}, p = (e, t) => async (r, o) => {
				const i = (await (() => Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/helpers/urls/index.ts"))).then(e => e.channelUrl))())(e, t);
				await u(r, o, i)
			}, m = e => async (t, r) => {
				if (!i.b) return;
				const o = await (() => Object(s.a)(() => Promise.all([n.e("vendors~Chat~RedesignChat"), n.e("Chat~RedesignChat"), n.e("RedesignChat")]).then(n.bind(null, "./src/chat/actions/theme.ts"))).then(e => e.switchTheme))();
				i.b.dispatch(o(e))
			}
		},
		"./src/reddit/actions/chat/unreadCount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return y
			}));
			var r, s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/chat/endpoints/sendbird/index.ts"),
				c = n("./src/reddit/selectors/chat.ts"),
				a = n("./src/reddit/selectors/user.ts");
			! function(e) {
				e.SYNC = "UNREAD_COUNT__SYNC", e.REQUEST_FAILED = "UNREAD_COUNT__REQUEST_FAILED", e.REQUEST_PENDING = "UNREAD_COUNT__REQUEST_PENDING", e.REQUEST_SUCCESS = "UNREAD_COUNT__REQUEST_SUCCESS"
			}(r || (r = {}));
			const {
				SYNC: d,
				REQUEST_FAILED: u,
				REQUEST_PENDING: l,
				REQUEST_SUCCESS: b
			} = r, p = Object(o.a)(d), m = Object(o.a)(u), f = Object(o.a)(l), g = Object(o.a)(b);
			let O;
			const h = 5 * s.cb,
				y = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					if (!Object(a.K)(s) || !Object(c.f)(s)) return clearTimeout(O);
					O || e((() => async (e, t, n) => {
						let {
							apiContext: r
						} = n;
						const s = t(),
							{
								session: o
							} = s.user;
						if (o && Object(a.K)(s) && Object(c.f)(s)) {
							e(f());
							const t = await Object(i.i)(r(), o);
							t && t.ok ? e(g({
								basicChannelCount: t.body.unread_count || 0,
								subredditChannelCount: t.body.subreddit_unread_count || 0
							})) : e(m({
								error: t.error
							}))
						}
					})()), O = setTimeout(() => {
						e(y())
					}, h)
				}
		},
		"./src/reddit/actions/chat/userSettings.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/toaster.ts"),
				o = n("./src/config.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts");
			var u = n("./src/reddit/featureFlags/index.ts"),
				l = n("./src/reddit/helpers/trackers/chat.ts"),
				b = n("./src/reddit/i18n/utils.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/telemetry/index.ts"),
				f = n("./src/reddit/actions/chat/constants.ts");
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "c", (function() {
				return v
			}));
			const g = Object(r.a)("USER_SETTINGS__FETCH_PENDING"),
				O = Object(r.a)("USER_SETTINGS__FETCH_FAILURE"),
				h = "USER_SETTINGS__UPDATE_SUCCESS",
				y = Object(r.a)(h),
				j = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					if (!u.d.userInChatUserSettings(s)) return;
					e(g());
					const l = await (e => Object(c.b)(Object(a.a)(e, [d.a]), {
						endpoint: "".concat(o.a.sendbirdServiceUrl, "/").concat("api/v1", "/chat/me/settings"),
						method: i.bb.GET
					}))(r());
					if (l.ok) {
						const t = Object.assign({}, l.body);
						e(y({
							invitePolicy: f.a[t.invite_policy]
						}))
					} else e(O(l.error))
				}, _ = Object(r.a)("USER_SETTINGS__SAVE_PENDING"), E = Object(r.a)("USER_SETTINGS__SAVE_FAILURE"), v = e => async (t, n, r) => {
					let {
						apiContext: g
					} = r;
					const O = n();
					if (!u.d.userInChatUserSettings(O)) return;
					const {
						invitePolicy: h
					} = e, j = Object.keys(f.a).find(e => f.a[e] === h);
					if (j) {
						t(_());
						const e = await (async (e, t) => Object(c.b)(Object(a.a)(t, [d.a]), {
							endpoint: "".concat(o.a.sendbirdServiceUrl, "/").concat("api/v1", "/chat/me/settings"),
							method: i.bb.PUT,
							data: JSON.stringify({
								invite_policy: e
							})
						}))(j, g());
						if (Object(m.a)(Object(l.f)(j)(O)), e.ok) {
							const e = f.a[j];
							t(y({
								invitePolicy: e
							})), t(Object(s.e)({
								kind: p.b.SuccessCommunity,
								text: Object(b.c)("Changes saved")
							}))
						} else t(E(e.error))
					}
				}
		},
		"./src/reddit/actions/claimgold.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/toaster.ts"),
				o = n("./src/reddit/models/Toast/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			var l = async (e, t) => {
				const {
					code: n
				} = t, r = {
					api_type: "json",
					code: n,
					raw_json: 1
				};
				return Object(c.b)(Object(a.a)(e, [d.a]), {
					method: i.bb.POST,
					endpoint: "".concat(e.apiUrl, "/api/claimgold"),
					data: r
				}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
					error: Object(u.a)(e)
				}))
			}, b = n("./src/reddit/helpers/genericServerError/index.ts"), p = n("./src/reddit/i18n/utils.ts"), m = n("./src/reddit/selectors/claimgold.ts"), f = n("./src/reddit/selectors/user.ts");
			n.d(t, "e", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "h", (function() {
				return x
			}));
			const g = "CLAIMGOLD__OPEN_CLAIMGOLD_MODAL",
				O = "CLAIMGOLD__CLOSE_CLAIMGOLD_MODAL",
				h = Object(r.a)(g),
				y = Object(r.a)(O),
				j = () => async (e, t) => {
					const n = t();
					Object(m.b)(n) ? e(y()) : e(h())
				}, _ = "CLAIMGOLD_UPDATE_CODE", E = Object(r.a)(_), v = "CLAIM_GOLD__TRIGGER_LOADER", I = "CLAIM_GOLD__CLAIM_GOLD_PENDING", S = "CLAIM_GOLD__CLAIM_GOLD_SUCCESSFUL", T = "CLAIM_GOLD__CLAIM_GOLD_FAILED", x = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = {
						code: t().claimGold.code
					};
					e(P());
					try {
						const t = await l(r(), s);
						t.error ? e(R(t)) : e(k())
					} catch (o) {
						e(R(o))
					}
				}, C = Object(r.a)(v), w = Object(r.a)(I), P = () => async (e, t) => {
					e(w()), window.setTimeout(() => {
						t().claimGold.api.pending && e(C())
					}, 2e3)
				}, D = Object(r.a)(T), R = e => async (t, n) => {
					const r = Object(f.T)(n());
					await t(D(Object.assign({}, e, {
						error: e.error || Object(b.a)(r)
					})));
					const i = n().claimGold.api.error;
					i && t(Object(s.e)({
						kind: o.b.Error,
						duration: s.a,
						text: i
					}))
				}, A = Object(r.a)(S), k = () => async (e, t) => {
					e(A()), e(Object(s.e)({
						kind: o.b.SuccessCommunity,
						text: Object(p.c)("You have redeemed your gift code successfully")
					}))
				}
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./src/config.ts"),
				s = n("./src/telemetry/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeCommentsPageKey/index.ts"),
				a = n("./src/lib/makeDraftKey/index.ts"),
				d = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/login.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/actions/postCreation/editorContent.ts"),
				p = n("./src/reddit/actions/shortcuts.ts"),
				m = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/actions/vote.ts"),
				g = n("./src/reddit/constants/adEvents.ts"),
				O = n("./src/reddit/constants/modals.ts"),
				h = n("./src/lib/makeApiRequest/index.ts"),
				y = n("./src/lib/omitHeaders/index.ts"),
				j = n("./src/reddit/constants/headers.ts"),
				_ = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				E = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				v = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const I = (e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
					endpoint: Object(_.a)("".concat(e.apiUrl, "/api/save")),
					method: o.bb.POST,
					data: {
						id: t
					}
				}),
				S = (e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
					endpoint: Object(_.a)("".concat(e.apiUrl, "/api/unsave")),
					method: o.bb.POST,
					data: {
						id: t
					}
				}),
				T = (e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
					endpoint: Object(_.a)("".concat(e.apiUrl, "/api/lock")),
					method: o.bb.POST,
					data: {
						id: t
					}
				}),
				x = (e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
					endpoint: Object(_.a)("".concat(e.apiUrl, "/api/unlock")),
					method: o.bb.POST,
					data: {
						id: t
					}
				}),
				C = (e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
					endpoint: "".concat(e.apiUrl, "/api/ignore_reports"),
					method: o.bb.POST,
					data: {
						id: t
					}
				}),
				w = (e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
					endpoint: "".concat(e.apiUrl, "/api/unignore_reports"),
					method: o.bb.POST,
					data: {
						id: t
					}
				});
			var P = n("./src/graphql/operations/CommentToxicity.json"),
				D = n("./src/lib/makeGqlRequest/index.ts"),
				R = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				A = n("./src/reddit/helpers/genericServerError/index.ts"),
				k = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				N = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				L = n("./src/reddit/models/PostCreationForm/index.ts");
			const M = (e, t, n, r) => {
					let s, o;
					if (r === L.h.MARKDOWN) s = n.text, o = null;
					else {
						s = null;
						let e = null;
						n.rteState && (e = R.a.toRichTextJSON(n.rteState).document), o = JSON.stringify({
							document: e
						})
					}
					return Object(D.a)(e, Object.assign({}, P, {
						variables: {
							subredditName: t,
							markdown: s,
							richText: o
						}
					})).then(e => !e.ok || e.body.data.isValidComment)
				},
				U = async (e, t, n, r, s, i) => {
					const c = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: n
					};
					if (i === L.h.MARKDOWN) c.text = r.text;
					else {
						c.text = null;
						let e = null;
						r.rteState && (e = R.a.toRichTextJSON(r.rteState).document), c.richtext_json = JSON.stringify({
							document: e
						})
					}
					return Object(h.b)(Object(y.a)(e, [j.a]), {
						method: o.bb.POST,
						endpoint: Object(_.a)(Object(E.a)(Object(v.a)("".concat(e.apiUrl, "/api/comment.json")))),
						data: c
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? Object.assign({}, e, {
						ok: !1,
						error: Object(N.a)(e)
					}) : Object.assign({}, e, {
						body: {
							comment: Object(k.a)(e.body.json.data.things[0].data, s)
						}
					}) : Object.assign({}, e, {
						body: {
							comment: Object(k.a)(e.body, s)
						}
					}) : Object.assign({}, e, {
						error: e.error || Object(A.a)(t)
					}))
				};
			var F = n("./src/reddit/endpoints/post/index.tsx"),
				B = n("./src/reddit/endpoints/post/convert.ts"),
				G = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				V = n("./src/reddit/featureFlags/index.ts"),
				q = n("./src/reddit/helpers/commentList/index.ts"),
				H = n("./src/reddit/helpers/dom/index.ts"),
				K = n("./src/reddit/helpers/pixels.ts"),
				W = n("./src/reddit/selectors/telemetry.ts");
			var Y = n("./src/reddit/helpers/trackers/commentsPage.ts"),
				z = n("./src/reddit/i18n/utils.ts"),
				J = n("./src/reddit/models/Comment/index.ts"),
				Q = n("./src/reddit/models/Post/index.ts"),
				X = n("./src/reddit/models/PostDraft/index.ts"),
				Z = n("./src/reddit/models/RichTextJson/index.ts"),
				$ = n("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				ee = n("./src/reddit/models/Toast/index.ts"),
				te = n("./src/reddit/models/Vote/index.ts"),
				ne = n("./src/reddit/selectors/comments.ts"),
				re = n("./src/reddit/selectors/moderatingComments.ts"),
				se = n("./src/reddit/selectors/platform.ts"),
				oe = n("./src/reddit/selectors/posts.ts"),
				ie = n("./src/reddit/selectors/user.ts");
			n.d(t, "C", (function() {
				return ce
			})), n.d(t, "ib", (function() {
				return de
			})), n.d(t, "n", (function() {
				return ue
			})), n.d(t, "R", (function() {
				return le
			})), n.d(t, "gb", (function() {
				return be
			})), n.d(t, "L", (function() {
				return fe
			})), n.d(t, "Q", (function() {
				return ge
			})), n.d(t, "X", (function() {
				return Oe
			})), n.d(t, "v", (function() {
				return he
			})), n.d(t, "u", (function() {
				return ye
			})), n.d(t, "t", (function() {
				return je
			})), n.d(t, "Z", (function() {
				return Ie
			})), n.d(t, "rb", (function() {
				return Se
			})), n.d(t, "T", (function() {
				return Te
			})), n.d(t, "i", (function() {
				return xe
			})), n.d(t, "h", (function() {
				return Ce
			})), n.d(t, "d", (function() {
				return we
			})), n.d(t, "e", (function() {
				return Pe
			})), n.d(t, "c", (function() {
				return De
			})), n.d(t, "b", (function() {
				return Re
			})), n.d(t, "j", (function() {
				return Ae
			})), n.d(t, "m", (function() {
				return ke
			})), n.d(t, "N", (function() {
				return Ne
			})), n.d(t, "M", (function() {
				return Le
			})), n.d(t, "W", (function() {
				return Ge
			})), n.d(t, "nb", (function() {
				return Ve
			})), n.d(t, "K", (function() {
				return He
			})), n.d(t, "H", (function() {
				return Ke
			})), n.d(t, "cb", (function() {
				return We
			})), n.d(t, "pb", (function() {
				return Ye
			})), n.d(t, "S", (function() {
				return ze
			})), n.d(t, "E", (function() {
				return Je
			})), n.d(t, "G", (function() {
				return Qe
			})), n.d(t, "F", (function() {
				return Xe
			})), n.d(t, "D", (function() {
				return Ze
			})), n.d(t, "mb", (function() {
				return et
			})), n.d(t, "kb", (function() {
				return tt
			})), n.d(t, "qb", (function() {
				return st
			})), n.d(t, "tb", (function() {
				return ot
			})), n.d(t, "lb", (function() {
				return it
			})), n.d(t, "sb", (function() {
				return ct
			})), n.d(t, "jb", (function() {
				return at
			})), n.d(t, "Y", (function() {
				return dt
			})), n.d(t, "p", (function() {
				return ut
			})), n.d(t, "o", (function() {
				return lt
			})), n.d(t, "k", (function() {
				return bt
			})), n.d(t, "f", (function() {
				return pt
			})), n.d(t, "l", (function() {
				return mt
			})), n.d(t, "O", (function() {
				return gt
			})), n.d(t, "s", (function() {
				return yt
			})), n.d(t, "P", (function() {
				return jt
			})), n.d(t, "ob", (function() {
				return _t
			})), n.d(t, "ab", (function() {
				return Et
			})), n.d(t, "bb", (function() {
				return vt
			})), n.d(t, "fb", (function() {
				return It
			})), n.d(t, "q", (function() {
				return St
			})), n.d(t, "I", (function() {
				return xt
			})), n.d(t, "r", (function() {
				return Ct
			})), n.d(t, "A", (function() {
				return wt
			})), n.d(t, "z", (function() {
				return Pt
			})), n.d(t, "B", (function() {
				return Dt
			})), n.d(t, "g", (function() {
				return Rt
			})), n.d(t, "V", (function() {
				return kt
			})), n.d(t, "U", (function() {
				return Ut
			})), n.d(t, "eb", (function() {
				return Ft
			})), n.d(t, "x", (function() {
				return Bt
			})), n.d(t, "w", (function() {
				return Gt
			})), n.d(t, "y", (function() {
				return Vt
			})), n.d(t, "db", (function() {
				return Wt
			})), n.d(t, "hb", (function() {
				return Yt
			})), n.d(t, "a", (function() {
				return zt
			})), n.d(t, "J", (function() {
				return Jt
			}));
			const ce = "COMMENT__STICKIED_COMMENT_SUCCESS",
				ae = {},
				de = Object(i.a)(ce),
				ue = "COMMENT__MUTATED",
				le = Object(i.a)(ue),
				be = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					if (!Object(ie.K)(n())) return t(Object(u.f)()), void t(Object(l.k)({
						actionSource: l.a.Save,
						redirectUrl: Object(ne.m)(n(), {
							commentId: e
						})
					}));
					const o = n().comments.models[e];
					if (!o) return;
					const i = o.isSaved ? S : I;
					if (t(le({
							[e]: {
								isSaved: !o.isSaved
							}
						})), (await i(s(), e)).ok) {
						const n = o.isSaved ? Object(z.c)("Comment unsaved successfully") : Object(z.c)("Comment saved successfully"),
							r = Object(z.c)("Undo");
						t(Object(m.e)({
							text: n,
							kind: ee.b.Undo,
							buttonText: r,
							buttonAction: be(e)
						}))
					} else t(le({
						[e]: {
							isSaved: o.isSaved
						}
					}))
				}, pe = e => "viewing-comment-".concat(e), me = r.a.telemetry.commentConsumedThreshold, fe = e => async (t, n) => {
					const o = n();
					if (!Object(ne.n)(o, {
							commentId: e
						}) || Math.random() > r.a.telemetry.commentSampleRate) return;
					(e => {
						let {
							state: t,
							commentId: n
						} = e;
						Object(s.a)(Object.assign({
							source: "comment",
							action: "view",
							noun: "comment"
						}, W.defaults(t), {
							profile: W.profile(t),
							post: W.post(t, n),
							media: W.media(t, n),
							subreddit: W.subreddit(t),
							comment: W.comment(t, n)
						}))
					})({
						state: o,
						commentId: e
					}), s.c.start(pe(e));
					const i = setTimeout(() => (e => {
						let {
							state: t,
							commentId: n
						} = e;
						return Object(s.a)(Object.assign({
							source: "comment",
							action: "consume",
							noun: "comment"
						}, W.defaults(t), {
							profile: W.profile(t),
							post: W.post(t, n),
							media: W.media(t, n),
							subreddit: W.subreddit(t),
							comment: W.comment(t, n)
						}))
					})({
						state: o,
						commentId: e
					}), me);
					ae[e] = i
				}, ge = (e, t) => async (n, r) => {
					const o = r(),
						i = pe(e);
					if (Object(ne.n)(o, {
							commentId: e
						}) && s.c.has(i)) {
						const n = s.c.end(i);
						!t && n < me && (clearTimeout(ae[e]), delete ae[e])
					}
				}, Oe = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					if (!Object(ie.K)(n())) return void t(Object(l.i)(O.a.LOGIN_MODAL_ID));
					const o = n().comments.models[e];
					if (!o) return;
					const i = o.isLocked ? x : T;
					t(le({
						[e]: {
							isLocked: !o.isLocked
						}
					})), (await i(s(), e)).ok || t(le({
						[e]: {
							isLocked: o.isLocked
						}
					}))
				}, he = "COMMENT__MORECOMMENTS_PENDING", ye = "COMMENT__MORECOMMENTS_LOADED", je = "COMMENT__MORECOMMENTS_FAILED", _e = Object(i.a)(he), Ee = Object(i.a)(ye), ve = Object(i.a)(je), Ie = (e, t) => async (n, s, i) => {
					let {
						apiContext: c
					} = i;
					const a = s(),
						u = a.moreComments.models[t],
						l = a.platform.currentPage,
						b = l && l.routeMatch,
						p = b && b.match,
						{
							partialPostId: m
						} = p ? p.params : null;
					if (!m) return;
					const f = Object(Q.m)(m);
					n(_e({
						moreCommentsId: u.id
					}));
					const g = await ((e, t, n) => Object(h.b)(e, {
						data: n,
						endpoint: Object(v.a)(Object(E.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/morecomments/").concat(t))),
						method: o.bb.POST,
						type: "json"
					}))(c(), f, {
						token: u.token
					});
					if (g.ok) {
						const t = g.body,
							r = Object(q.a)(t, f, a);
						n(Ee(Object.assign({
							key: e,
							moreCommentsItem: u,
							shouldCollapse: r
						}, t)));
						const s = a.posts.models[f];
						s && "subreddit" === s.belongsTo.type && t.comments && await n(Object(d.a)({
							commentIds: Object.keys(g.body.comments),
							postIds: [s.id],
							skip: ["communityDetails", "subscription"],
							subredditId: s.belongsTo.id
						}))
					} else n(ve(Object.assign({
						moreCommentsItem: u
					}, g.error)))
				}, Se = Object(f.b)(q.b, te.a.upvoted), Te = Object(f.b)(q.b, te.a.downvoted), xe = "COMMENT__FOCUSED_TOGGLED", Ce = "COMMENT__FOCUSED_SET", we = "COMMENT__COLLAPSED_TOGGLED", Pe = "COMMENT__COLLAPSED_UNSET", De = "COMMENTS__HIDDEN_TOGGLED", Re = "COMMENTS__HIDDEN_SET", Ae = "COMMENT_FORM_FOCUS_CHANGED", ke = "COMMENT_MARKED_UNCOLLAPSED", Ne = Object(i.a)(xe), Le = Object(i.a)(Ce), Me = Object(i.a)(we), Ue = Object(i.a)(Pe), Fe = (Object(i.a)(Re), Object(i.a)(De), Object(i.a)(Ae)), Be = Object(i.a)(ke), Ge = e => {
					let {
						hasFocus: t,
						draftKey: n
					} = e;
					return async (e, r) => {
						!r().comments.drafts[n] || e(Fe({
							hasFocus: t,
							draftKey: n
						}))
					}
				}, Ve = e => {
					let {
						commentId: t,
						commentsPageKey: n,
						scrollToAndRemeasure: r
					} = e;
					return async (e, s) => {
						const o = s(),
							i = Object(J.f)(t),
							c = Object(ne.o)(o, {
								commentLink: i,
								commentsPageKey: n
							}),
							a = Object(re.b)(o, {
								commentId: t,
								commentsPageKey: n
							}),
							d = c.depth;
						e(Me({
							commentId: t,
							commentsPageKey: n,
							isCollapsed: a
						})), a || 0 !== d || r(t, !0), Object(p.r)()
					}
				}, qe = e => {
					let {
						commentId: t,
						commentsPageKey: n
					} = e;
					return async (e, r) => {
						e(Ue({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, He = e => {
					let {
						commentLink: t,
						commentsPageKey: n,
						lineDepth: r,
						scrollToAndRemeasure: s
					} = e;
					return async (e, o) => {
						const i = o(),
							c = Object(q.e)(n, t, r, i),
							a = Object(re.b)(i, {
								commentId: t.id,
								commentsPageKey: n
							});
						e(Me({
							commentId: c,
							commentsPageKey: n,
							isCollapsed: a
						})), 0 === r && s(c, !0), Object(p.r)()
					}
				}, Ke = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const i = n(),
						c = i.comments.models[e],
						a = i.user.account ? i.user.account.displayText : null;
					c && a && (t(le({
						[e]: {
							isApproved: !0,
							approvedBy: a,
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (await ((e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
						endpoint: Object(_.a)("".concat(e.apiUrl, "/api/approve")),
						method: o.bb.POST,
						data: {
							id: t
						}
					}))(s(), e)).ok || t(le({
						[e]: {
							isApproved: c.isApproved,
							approvedBy: null,
							bannedBy: c.bannedBy,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam,
							modNote: c.modNote,
							modReasonBy: c.modReasonBy,
							modRemovalReason: c.modRemovalReason,
							numReports: c.numReports || null
						}
					})), Object(p.r)())
				}, We = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					const c = r(),
						a = c.comments.models[e],
						d = c.user.account ? c.user.account.displayText : null;
					a && d && (n(le({
						[e]: {
							approvedBy: null,
							bannedBy: d,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (await ((e, t, n) => Object(h.b)(Object(y.a)(e, [j.a]), {
						endpoint: Object(_.a)("".concat(e.apiUrl, "/api/remove")),
						method: o.bb.POST,
						data: {
							id: t,
							spam: n
						}
					}))(i(), e, t)).ok || n(le({
						[e]: {
							approvedBy: a.approvedBy,
							bannedBy: a.bannedBy,
							isApproved: a.isApproved,
							isRemoved: a.isRemoved,
							isSpam: a.isSpam
						}
					})), Object(p.r)())
				}, Ye = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().comments.models[e];
					if (!o) return;
					const i = o.ignoreReports ? w : C;
					t(le({
						[e]: {
							ignoreReports: !o.ignoreReports
						}
					})), (await i(s(), e)).ok || t(le({
						[e]: {
							ignoreReports: o.ignoreReports
						}
					}))
				}, ze = (e, t, n) => async (r, s, i) => {
					let {
						apiContext: a
					} = i;
					const d = s(),
						u = d.comments.models[e];
					if (!u) return;
					const l = u.postId,
						b = d.postStickiedComments.data[l],
						p = o.g[t];
					r(le({
						[e]: {
							distinguishType: t,
							isAdmin: t === o.B.ADMIN,
							isMod: t === o.B.MODERATOR,
							isStickied: !!n
						}
					})), n && b && b !== e && r(le({
						[b]: {
							isStickied: !1
						}
					})), (await ((e, t, n, r) => Object(h.b)(Object(y.a)(e, [j.a]), {
						endpoint: Object(_.a)("".concat(e.apiUrl, "/api/distinguish/").concat(n)),
						method: o.bb.POST,
						data: {
							id: t,
							sticky: r
						}
					}))(a(), e, p, n || null)).ok ? n && r(de({
						id: e,
						postId: l,
						commentsPageKey: Object(c.a)(l, null, Object.assign({
							sort: o.q.CONFIDENCE
						}, d.platform.currentPage.queryParams))
					})) : (r(le({
						[e]: {
							distinguishType: u.distinguishType,
							isAdmin: u.isAdmin,
							isMod: u.isMod,
							isStickied: u.isStickied
						}
					})), r(le({
						[b]: {
							isStickied: d.comments.models[b].isStickied
						}
					})))
				}, Je = "COMMENT__SUBMIT_COMMENT_PENDING", Qe = "COMMENT__SUBMIT_REPLY_TO_POST_SUCCESS", Xe = "COMMENT__SUBMIT_REPLY_TO_COMMENT_SUCCESS", Ze = "COMMENT__SUBMIT_COMMENT_FAILURE", $e = Object(i.a)(Je), et = Object(i.a)(Qe), tt = Object(i.a)(Xe), nt = Object(i.a)(Ze), rt = (e, t, n, r) => {
					const s = r.ok && r.body,
						o = s && s.comment && s.comment.id;
					Y.f(e, n, t, o)
				}, st = "Toxicity_Warning__Modal", ot = (e, t, n, r, s, o, i) => async (c, a, d) => {
					let {
						gqlContext: u
					} = d;
					const b = a(),
						p = Object(se.f)(b);
					let m = "";
					if (p && (m = p.name), V.d.enableToxicityWarning(b)) {
						if (!(await M(u(), m, s, o))) return void c(Object(l.i)(st))
					}
					c(it(e, t, n, r, s, o, i))
				}, it = (e, t, n, r, s, o, i, c) => async (a, d, u) => {
					let {
						apiContext: b
					} = u;
					a(Object(l.g)(st));
					const f = d(),
						O = f.comments.submit.pending[r];
					if (!f.user.account || O) return;
					a($e({
						draftKey: r,
						draft: s
					}));
					const h = f.user.account.displayText,
						y = s.commentMode;
					let j;
					if ((j = c ? await Object(G.i)(b(), t, s, h) : await U(b(), e, t, s, h, y)).ok) {
						a(et(Object.assign({}, j.body, {
							headCommentId: Object(ne.x)(f, {
								commentsPageKey: n
							}),
							commentsPageKey: n,
							draftKey: r
						})));
						const e = Object(oe.I)(d(), {
							postId: t
						});
						Object(K.a)(e.events, g.a.CommentSubmitted)
					} else {
						const e = j.error && j.error.fields && j.error.fields[0] ? j.error.fields[0].msg : "Something went wrong";
						a(nt({
							draftKey: r,
							error: j.error
						})), a(Object(m.e)({
							duration: m.a,
							kind: ee.b.Error,
							text: Object(z.c)(e)
						}))
					}
					rt(d(), n, o, j), i || Object(p.r)()
				}, ct = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const {
						language: o,
						parentCommentId: i,
						commentsPageKey: c,
						parentCommentDepth: a,
						draftKey: d,
						formData: u,
						editorMode: b
					} = e, p = n(), m = Object(se.f)(p);
					let f = "";
					if (m && (f = m.name), V.d.enableToxicityWarning(p)) {
						if (!(await M(s(), f, u, b))) return void t(Object(l.i)(st))
					}
					t(at({
						commentsPageKey: c,
						draftKey: d,
						language: o,
						parentCommentDepth: a,
						parentCommentId: i,
						formData: u,
						editorMode: b
					}))
				}, at = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const {
						language: o,
						parentCommentId: i,
						commentsPageKey: c,
						parentCommentDepth: a,
						draftKey: d,
						formData: u,
						editorMode: b
					} = e;
					t(Object(l.g)(st));
					const m = n(),
						f = m.comments.submit.pending[d];
					if (!m.user.account || f) return;
					t($e({
						draftKey: d,
						draft: u
					}));
					const g = m.user.account.displayText,
						O = u.commentMode,
						h = await U(s(), o, i, u, g, O);
					h.ok ? t(tt(Object.assign({}, h.body, {
						parentCommentId: i,
						commentsPageKey: c,
						draftKey: d,
						depth: a + 1
					}))) : t(nt({
						draftKey: d,
						error: h.error
					})), rt(n(), c, b, h), Object(p.r)()
				}, dt = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					n().comments.models[e] && (await ((e, t) => Object(h.b)(Object(y.a)(e, [j.a]), {
						endpoint: "".concat(e.apiUrl, "/api/show_comment"),
						method: o.bb.POST,
						data: {
							id: t
						}
					}))(s(), e)).ok && t((e => async (t, n, r) => {
						let {
							apiContext: s
						} = r;
						t(Be({
							commentId: e
						}))
					})(e))
				}, ut = "COMMENT__COMMENT_REPLY_FORM_OPENED", lt = "COMMENT__COMMENT_REPLY_FORM_CANCELLED", bt = "COMMENT__COMMENT_FORM_MUTATED", pt = "COMMENT__COMMENT_DRAFT_CLEARED", mt = "COMMENT__COMMENT_FORM_SWITCHED_MODE", ft = Object(i.a)(ut), gt = Object(i.a)(lt), Ot = Object(i.a)(bt), ht = (Object(i.a)(pt), Object(i.a)(mt)), yt = "INITIALIZE_COMMENT_EDITOR_MODE", jt = (Object(i.a)(yt), (e, t, n) => async (r, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = e === L.h.RICH_TEXT;
					if (!t || "object" == typeof t && Object(Z.F)(t)) r(ht({
						editorMode: e,
						draftKey: n,
						content: c ? Z.i : ""
					})), r(Object(b.c)(e));
					else {
						r(Object(b.b)(n));
						const s = await Object(B.a)(i(), e, c ? t : JSON.stringify(t));
						if (s.ok) {
							const t = s.body.output;
							r(Object(b.a)(n)), r(ht({
								editorMode: e,
								draftKey: n,
								content: t
							})), r(Object(b.c)(e))
						} else r(Object(b.a)(n)), r(Object(m.e)({
							duration: m.a,
							kind: ee.b.Error,
							text: Object(z.c)("Something went wrong")
						}))
					}
				}), _t = e => {
					let {
						commentsPageKey: t,
						parentCommentId: n,
						singleOpen: r
					} = e;
					return async (e, s) => {
						const o = s(),
							i = Object(a.a)(X.c.replyToComment, n);
						if (!Object(ie.K)(s())) return e(Object(u.f)()), void e(Object(l.k)({
							actionSource: l.a.Reply,
							redirectUrl: Object(ne.m)(s(), {
								commentId: n
							})
						}));
						const c = o.comments.replyFormOpen[t],
							d = c && c[n];
						if ((d || c && r) && (Object.keys(c).forEach(n => c[n] && e(gt({
								parentCommentId: n,
								commentsPageKey: t
							}))), d)) return;
						let b = "",
							p = null;
						const m = o.user.prefs.commentMode,
							f = Object(H.d)();
						if (f) {
							const e = f.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (m === L.h.MARKDOWN) b = e.map(e => "> ".concat(e, "\n")).join("");
							else {
								const t = e.map(e => $.s(e, null)).map(e => $.l([e])),
									n = $.s("", null),
									r = $.l([n]);
								p = {
									document: [$.c(t), r]
								}
							}
						}
						const g = o.comments.drafts[i];
						let O;
						O = f ? {
							commentMode: m,
							draftType: X.c.replyToComment,
							rtJson: p,
							text: "".concat(b, "\n")
						} : g || {
							commentMode: m,
							draftType: X.c.replyToComment,
							rtJson: p,
							text: ""
						}, e(ft({
							parentCommentId: n,
							commentsPageKey: t,
							draftKey: i,
							formData: O
						}))
					}
				}, Et = e => async (t, n) => {
					t(qe(e)), t(kt(e))
				}, vt = e => {
					let {
						parentCommentId: t,
						commentsPageKey: n
					} = e;
					return async (e, r) => {
						e(gt({
							parentCommentId: t,
							commentsPageKey: n
						})), e(_t({
							parentCommentId: t,
							commentsPageKey: n
						})), e(qe({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, It = (e, t) => n => n(Ot({
					draftKey: e,
					formData: t
				})), St = "COMMENT__DISABLE_AUTOFOCUS", Tt = Object(i.a)(St), xt = e => t => t(Tt({
					draftKey: e
				})), Ct = "COMMENT__EDIT_COMMENT_ENABLED", wt = "COMMENT__REQUEST_EDIT_PENDING", Pt = "COMMENT__REQUEST_EDIT_FAILURE", Dt = "COMMENT__REQUEST_EDIT_SUCCESS", Rt = "COMMENT__COMMENT_EDIT_FORM_CANCELLED", At = Object(i.a)(Ct), kt = e => {
					let {
						commentId: t,
						commentMode: n,
						commentsPageKey: r,
						draftKey: s,
						text: o
					} = e;
					return async (e, i) => {
						const c = i();
						c.user.account && (Y.c(c), e(At({
							commentId: t,
							commentsPageKey: r,
							draftKey: s,
							formData: {
								text: o,
								commentMode: n,
								rteState: null,
								draftType: X.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Nt = Object(i.a)(wt), Lt = Object(i.a)(Pt), Mt = Object(i.a)(Dt), Ut = Object(i.a)(Rt), Ft = e => {
					let {
						language: t,
						id: n,
						commentsPageKey: r,
						depth: s,
						draftKey: i,
						formData: c
					} = e;
					return async (e, s, a) => {
						let {
							apiContext: d
						} = a;
						const u = s();
						if (!u.user.account) return;
						e(Nt({
							draftKey: i
						})), Y.d(u);
						const l = u.user.account.displayText || "",
							b = c.commentMode,
							p = await (async (e, t, n, r, s, i, c) => {
								const a = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: n
								};
								if (c === L.h.MARKDOWN) a.text = s.text;
								else {
									a.text = null;
									let e = null;
									s.rteState && (e = R.a.toRichTextJSON(s.rteState).document), a.richtext_json = JSON.stringify({
										document: e
									})
								}
								return Object(h.b)(Object(y.a)(e, [j.a]), {
									endpoint: Object(_.a)(Object(v.a)(Object(E.a)("".concat(e.apiUrl, "/api/editusertext")))),
									method: o.bb.POST,
									data: a
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? Object.assign({}, e, {
									ok: !1,
									error: Object(N.a)(e)
								}) : Object.assign({}, e, {
									body: {
										comment: Object(k.a)(e.body.json.data.things[0].data, i)
									}
								}) : Object.assign({}, e, {
									body: {
										comment: Object(k.a)(e.body, i)
									}
								}) : Object.assign({}, e, {
									error: e.error || Object(A.a)(t)
								}))
							})(d(), t, n, 0, c, l, b);
						if (p.ok) {
							const t = p.body;
							e(Mt({
								commentId: n,
								commentsPageKey: r,
								draftKey: i
							})), e(le({
								[n]: Object.assign({}, t.comment)
							}))
						} else e(Lt({
							draftKey: i,
							error: p.error
						}))
					}
				}, Bt = "COMMENT__REQUEST_DELETE_PENDING", Gt = "COMMENT__REQUEST_DELETE_FAILURE", Vt = "COMMENT__REQUEST_DELETE_SUCCESS", qt = Object(i.a)(Bt), Ht = Object(i.a)(Gt), Kt = Object(i.a)(Vt), Wt = (e, t, n) => async (r, s, i) => {
					let {
						apiContext: c
					} = i;
					const a = s();
					if (!a.user.account) return;
					r(qt({
						id: t
					})), Y.a(t, a);
					const d = await ((e, t, n) => Object(h.b)(Object(y.a)(e, [j.a]), {
						endpoint: Object(_.a)("".concat(e.apiUrl, "/api/del")),
						method: o.bb.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? Object.assign({}, e, {
						ok: !1,
						error: Object(N.a)(e)
					}) : Object.assign({}, e, {
						body: {}
					}) : Object.assign({}, e, {
						error: e.error || Object(A.a)(n)
					})))(c(), t, e);
					d.ok ? r(Kt({
						id: t,
						postId: n
					})) : r(Ht({
						id: t,
						error: d.error
					}))
				}, Yt = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = !n().comments.models[e].sendReplies;
					t(le({
						[e]: {
							sendReplies: o
						}
					})), (await Object(F.p)(s(), e, o)).ok || t(le({
						[e]: {
							sendReplies: !o
						}
					}))
				}, zt = "COMMENT__CHANGE_HIGHLIGHT_FILTER", Jt = Object(i.a)(zt)
		},
		"./src/reddit/actions/comment/list.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/helpers/trackers/commentList.ts");
			const o = "COMMENTLIST__MARKED_END",
				i = "COMMENTLIST__UNMARKED_END",
				c = Object(r.a)(o),
				a = Object(r.a)(i),
				d = (e, t) => async (n, r) => {
					const o = r();
					e in o.profileCommentsPage.fetchedTokens ? e in o.profileCommentsPage.commentIds ? n(a({
						listingKey: e
					})) : Object(s.a)(o, e) : n(c({
						listingKey: e,
						listingName: t
					}))
				}
		},
		"./src/reddit/actions/comment/websocket/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = "COMMENT__LIVECOMMENTS__NEWCOMMENT",
				s = "COMMENT__LIVECOMMENTS__UPDATECOMMENT"
		},
		"./src/reddit/actions/commentsListTruncated/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = "COMMENTS_LIST__EXPANDED",
				s = "COMMENTS_LIST__TRUNCATED"
		},
		"./src/reddit/actions/communityFlairs/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			const r = "TOP_COMMUNITY_FLAIR__FETCH_FAILURE",
				s = "TOP_COMMUNITY_FLAIR__FETCH_PENDING",
				o = "TOP_COMMUNITY_FLAIR__FETCH_SUCCESS",
				i = "COMMUNITY_FLAIR__ADD_FLAIRS"
		},
		"./src/reddit/actions/communityFlairs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "d", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/camelCase.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/isEmpty.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/omit.js"),
				a = n.n(c),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/endpoints/flair/index.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				b = n("./src/reddit/models/Flair/index.ts"),
				p = n("./src/reddit/selectors/communityFlairs.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				f = n("./src/reddit/actions/communityFlairs/constants.ts");
			const g = Object(d.a)(f.c),
				O = Object(d.a)(f.d),
				h = Object(d.a)(f.b),
				y = Object(d.a)(f.a),
				j = e => {
					const t = {};
					for (const n in e) {
						t[s()(n)] = e[n]
					}
					return t
				},
				_ = (e, t) => async (n, r) => {
					const o = r(),
						c = Object(p.b)(o, t),
						d = Object(p.c)(o, t) || [],
						u = (e => {
							const t = {};
							return e.map(e => {
								const n = Object(l.g)(e),
									r = s()(n),
									o = r && t.hasOwnProperty(r);
								e.type !== b.f.Spoiler && e.type !== b.f.Nsfw && (o || (t[r] = Object.assign({}, e, {
									id: r
								})))
							}), t
						})(e),
						m = a()(u, d);
					if (i()(m)) return;
					const f = Object.keys(m),
						g = d ? d.concat(f) : f,
						O = c ? Object.assign({}, c, m) : m;
					n(y({
						models: O,
						sortedKeys: g,
						subredditId: t
					}))
				}, E = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = Object(m.G)(n(), e);
					t(g());
					const i = await Object(u.c)(s(), e);
					if (i.ok) {
						const e = i.body.map(j).map(e => Object(l.c)(e));
						t(_(e, o)), t(O())
					} else t(h())
				}, v = (e, t) => {
					const n = [];
					for (const r in e) {
						const s = e[r],
							o = s.belongsTo && s.belongsTo.id === t;
						s.flair && s.flair.length && o && n.push(...s.flair)
					}
					return n
				}, I = e => {
					const t = e && e.data && e.data.content && e.data.content.widgets;
					if (t) {
						const e = t.items;
						for (const t in e) {
							const n = e[t];
							if ("post-flair" === n.kind) return n
						}
					}
				}, S = e => {
					const t = [],
						{
							templates: n
						} = e;
					for (const r in n) {
						const e = n[r];
						e && t.push(e)
					}
					return t
				}
		},
		"./src/reddit/actions/contentGate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "j", (function() {
				return y
			})), n.d(t, "k", (function() {
				return j
			})), n.d(t, "m", (function() {
				return _
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "o", (function() {
				return v
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "p", (function() {
				return S
			})), n.d(t, "i", (function() {
				return T
			}));
			var r = n("./src/config.ts"),
				s = n("./node_modules/js-cookie/src/js.cookie.js"),
				o = n.n(s),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/constants/cookie.ts"),
				a = n("./src/reddit/endpoints/user/preferences.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = "CONTENTGATE__VISITED_GOLD_SUBREDDIT",
				l = "CONTENTGATE__VISITED_PRIVATE_SUBREDDIT",
				b = "CONTENTGATE__VISITED_QUARANTINED_SUBREDDIT",
				p = "CONTENTGATE__SET_OVER_18_PREF",
				m = "CONTENTGATE__VISITED_BANNED_SUBREDDIT",
				f = "CONTENTGATE__VISITED_NONEXISTENT_SUBREDDIT",
				g = "CONTENTGATE__VISITED_DELETED_PROFILE",
				O = "CONTENTGATE__VISITED_SUSPENDED_PROFILE",
				h = Object(i.a)(p),
				y = Object(i.a)(m),
				j = Object(i.a)(f),
				_ = Object(i.a)(u),
				E = Object(i.a)(l),
				v = Object(i.a)(b),
				I = Object(i.a)(g),
				S = Object(i.a)(O),
				T = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const i = t();
					if (Object(d.K)(i) && i.platform.currentPage) await Object(a.f)(s());
					else {
						const e = new Date;
						e.setFullYear(e.getFullYear() + 2), o.a.set(c.g, "1", {
							expires: e,
							domain: r.a.cookieDomain
						})
					}
					e(h({
						over18: !0
					}))
				}
		},
		"./src/reddit/actions/dashboard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "DASHBOARD__COMPONENT_SELECTED",
				o = "DASHBOARD__SUBREDDIT_SELECTED",
				i = "DASHBOARD__SUBREDDIT_LOADED",
				c = Object(r.a)(s),
				a = Object(r.a)(o),
				d = Object(r.a)(i)
		},
		"./src/reddit/actions/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeListingKey/index.ts"),
				i = n("./src/reddit/actions/category.ts"),
				c = n("./src/reddit/actions/pages/subreddit.ts"),
				a = n("./src/lib/addQueryParams/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/lib/stringInterpolate/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				m = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const f = e => {
				const t = [],
					n = {};
				return e.data.children.forEach(e => {
					const r = Object(p.a)(e.data);
					t.push(r.id), n[r.id] = r
				}), {
					postIds: t,
					posts: n
				}
			};
			var g = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				O = n("./src/reddit/selectors/category.ts"),
				h = n("./src/reddit/selectors/discoveryUnit.ts"),
				y = n("./src/reddit/selectors/listings.ts"),
				j = n("./src/reddit/selectors/posts.ts");
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "i", (function() {
				return N
			})), n.d(t, "j", (function() {
				return M
			})), n.d(t, "g", (function() {
				return U
			})), n.d(t, "k", (function() {
				return F
			}));
			var _ = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const E = "DISCOVERY_UNIT__LIST_PENDING",
				v = "DISCOVERY_UNIT__LIST_LOADED",
				I = "DISCOVERY_UNIT__LIST_FAILED",
				S = Object(s.a)(E),
				T = Object(s.a)(v),
				x = Object(s.a)(I),
				C = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t(),
						o = Object(h.i)(s),
						i = Object(h.h)(s);
					if (o || i) return;
					e(S());
					const c = await (e => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_88",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Similar communities to %{subredditName}",
										unit_name: "chaining_similar_subreddits_posts",
										unit_type: "listing"
									}, {
										id: "xd_89",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Mildy similar posts",
										unit_name: "chaining_similar_posts",
										unit_type: "listing"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_93",
										enabled: !0,
										layout: "large",
										surface: "popular",
										title: "Trending posts",
										unit_name: "trending_posts",
										unit_type: "listing"
									}, {
										id: "xd_94",
										enabled: !0,
										layout: "large",
										surface: "popular",
										title: "Top popular for the month",
										unit_name: "top_month_posts",
										unit_type: "listing"
									}, {
										id: "xd_95",
										enabled: !0,
										layout: "large",
										surface: "popular",
										title: "Geopopular posts",
										unit_name: "geopopular_posts",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(r());
					if (c.ok) {
						const {
							discoveryUnits: t
						} = (e => {
							return {
								discoveryUnits: e.global.discovery_config_v1.discovery_units.reduce((e, t) => {
									const n = {
										enabled: t.enabled,
										experiment: t.experiment,
										id: t.id,
										index: t.index,
										layout: t.layout,
										options: t.options,
										parameters: t.parameters,
										subtitle: t.subtitle,
										subtitleIcon: t.subtitle_icon,
										surface: t.surface,
										title: t.title,
										unitName: t.unit_name,
										unitType: t.unit_type,
										url: t.url
									};
									return e[n.id] = n, e
								}, {})
							}
						})(c.body);
						e(T({
							discoveryUnits: t
						}))
					} else e(x({
						error: c.error
					}))
				}, w = "DISCOVERY_UNIT__UNIT_DATA_PENDING", P = "DISCOVERY_UNIT__UNIT_DATA_LOADED", D = "DISCOVERY_UNIT__UNIT_DATA_FAILED", R = Object(s.a)(w), A = Object(s.a)(P), k = Object(s.a)(D), N = (e, t) => async (n, s, i) => {
					let {
						apiContext: c
					} = i;
					const a = s(),
						l = Object(o.a)(e, r.N.HOT, {
							category: t
						}),
						p = Object(y.h)(a, {
							listingKey: l
						}),
						g = !!a.listings.listingOrder.fetchedTokens[l];
					if (p || g) return;
					n(R({
						key: l
					}));
					const O = await ((e, t) => Object(d.b)(Object(u.a)(e, [b.a]), {
						endpoint: Object(m.a)("".concat(e.apiUrl, "/api/posts_in_category.json?category=").concat(t)),
						method: r.bb.GET
					}))(c(), t);
					if (O.ok) {
						const {
							postIds: e,
							posts: t
						} = f(O.body), r = e.length > 0 ? e.length - 1 : 0;
						n(A({
							key: l,
							meta: a.meta,
							postIds: e,
							posts: t,
							token: e[r]
						}))
					} else n(k({
						key: l,
						error: O.error
					}))
				}, L = (e, t, n) => async (s, i, c) => {
					let {
						apiContext: p
					} = c;
					const O = i(),
						y = ((e, t) => Object(o.a)(e.unitName, r.N.HOT, Object.assign({}, e.parameters, t)))(e, t),
						j = Object(h.g)(O, {
							listingKey: y,
							shouldLoadMore: n
						});
					if (!j) return;
					const {
						fetchedToken: E
					} = j;
					if (s(R({
							fetchedToken: E,
							key: y
						})), !e.url) return void s(A({
						fetchedToken: "",
						key: y,
						meta: O.meta,
						token: ""
					}));
					const {
						category: v
					} = t, I = _(t, ["category"]), S = Object.assign({}, I, {
						after: E,
						category_id: v
					}), T = await ((e, t, n) => {
						let s = t.url;
						return t.parameters && (s = Object(a.a)(Object(l.a)(s, t.parameters), t.parameters)), n && (s = Object(a.a)(Object(l.a)(s, n), n)), Object(d.b)(Object(u.a)(e, [b.a]), {
							endpoint: Object(m.a)("".concat(e.apiUrl).concat(s)),
							method: r.bb.GET
						})
					})(p(), e, S);
					if (T.ok) switch (e.unitName) {
						case g.h:
						case g.k:
						case g.i:
						case g.l:
						case g.n:
						case g.o: {
							const {
								postIds: e,
								posts: t
							} = f(T.body);
							s(A({
								fetchedToken: E,
								key: y,
								meta: O.meta,
								postIds: e,
								posts: t,
								token: e[e.length - 1]
							}));
							break
						}
					} else s(k({
						key: y,
						error: T.error
					}))
				}, M = e => async (t, n, s) => {
					let {
						apiContext: i
					} = s;
					const a = Object(o.a)(e, r.N.HOT);
					Object(j.C)(n(), {
						listingKey: a
					}).length > 0 || await t(Object(c.i)(a, e, {}, !0))
				}, U = (e, t, n, r) => async (s, o, c) => {
					let a, {
						apiContext: d
					} = c;
					if (await s(i.h()), !n && !(a = Object(O.h)(o(), {
							categoryName: t
						}))) return;
					const u = n || a && a.id;
					await Promise.all([s(L(e, {
						category: u
					}, r)), s(i.i(u))])
				}, F = (e, t, n) => async (r, s, o) => {
					let {
						apiContext: i
					} = o;
					await Promise.all([r(M(t)), r(L(e, {
						subredditName: t
					}, n))])
				}
		},
		"./src/reddit/actions/dismissedTruncationList/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = "DISMISSED_TRUNCATION_LIST__ADD_SUBREDDIT_ID"
		},
		"./src/reddit/actions/economics/ftue/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = "ECONOMICS__FTUE__TIPPING_HIGHLIGHT_VIEWED",
				s = "ECONOMICS__FTUE__TOP_TIPPERS_VIEWED"
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = e => async t => {
				const r = await (() => Promise.all([n.e("vendors~EconHelperActions~Reddit"), n.e("EconHelperActions")]).then(n.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(r(e))
			}
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "e", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			}));
			const r = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				s = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				c = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			}));
			const r = "ECONOMICS__SUBREDDIT_PREMIUM__ALL_SUBREDDIT_SUBSCRIPTIONS_SUCCESS",
				s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__PURCHASE_MODAL_OPENED",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				b = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS",
				p = "ECONOMICS__SUBREDDIT_PREMIUM__UPLOAD_MODAL_OPENED"
		},
		"./src/reddit/actions/economics/support/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = "ECONOMICS__SUPPORT__SUPPORT_MODAL_OPENED",
				s = "ECONOMICS__SUPPORT__TOTAL_SUPPORT_INCREASED"
		},
		"./src/reddit/actions/economics/tips/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = "ECONOMICS__TIPS__TIP_DETAILS_SUCCESS"
		},
		"./src/reddit/actions/emailVerificationTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "EMAIL_VERIFICATION_TOOLTIP_TOGGLED",
				o = Object(r.a)(s)
		},
		"./src/reddit/actions/embedAndImage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "EMBEDS__UNLOADABLE",
				o = "EMBEDS__LOADABLE",
				i = Object(r.a)(s),
				c = Object(r.a)(o)
		},
		"./src/reddit/actions/emoji.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/lodash/forEach.js"),
				s = n.n(r),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/lib/uploadToS3/index.ts"),
				d = n("./src/reddit/constants/headers.ts");
			const u = async (e, t) => Object(i.b)(Object(c.a)(e, [d.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emojis/all"),
				method: o.bb.GET,
				type: "json"
			}).then(e => (e.ok && (e.body = (e => {
				let t;
				const n = s()(e, (e, n) => ("snoomojis" !== n && (t = n), s()(e, (t, n) => {
					e[n] = {
						name: n,
						userFlairAllowed: t.user_flair_allowed,
						postFlairAllowed: t.post_flair_allowed,
						modFlairOnly: t.mod_flair_only,
						url: t.url
					}
				})));
				return {
					[t]: {
						emojis: n[t],
						snoomojis: n.snoomojis
					}
				}
			})(e.body)), e));
			var l = n("./src/lib/makeActionCreator/index.ts"),
				b = n("./src/reddit/actions/imageUploads.ts"),
				p = n("./src/reddit/actions/toaster.ts"),
				m = n("./src/reddit/helpers/getGenericUploadError.ts"),
				f = n("./src/reddit/helpers/getS3KeyFromUrl/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				O = n("./src/reddit/i18n/utils.ts"),
				h = n("./src/reddit/models/Emoji/index.ts"),
				y = n("./src/reddit/models/Image/index.tsx"),
				j = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/emojis.ts"),
				E = n("./src/reddit/selectors/subreddit.ts");
			n.d(t, "i", (function() {
				return v
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "h", (function() {
				return w
			})), n.d(t, "g", (function() {
				return P
			})), n.d(t, "f", (function() {
				return D
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "q", (function() {
				return U
			})), n.d(t, "p", (function() {
				return B
			})), n.d(t, "l", (function() {
				return G
			})), n.d(t, "m", (function() {
				return V
			})), n.d(t, "j", (function() {
				return q
			})), n.d(t, "k", (function() {
				return H
			})), n.d(t, "b", (function() {
				return K
			})), n.d(t, "n", (function() {
				return Y
			})), n.d(t, "e", (function() {
				return z
			})), n.d(t, "o", (function() {
				return Q
			}));
			const v = "STRUCTURED_STYLES__NEW_EMOJI_ADDED",
				I = Object(l.a)(v),
				S = "STRUCTURED_STYLES__EMOJI_DELETE_LOADED",
				T = "STRUCTURED_STYLES__EMOJI_DELETE_FAILED",
				x = Object(l.a)(S),
				C = Object(l.a)(T),
				w = "GET_ALL_EMOJIS_PENDING",
				P = "GET_ALL_EMOJIS_LOADED",
				D = "GET_ALL_EMOJIS_FAILED",
				R = Object(l.a)(w),
				A = Object(l.a)(P),
				k = Object(l.a)(D),
				N = "STRUCTURED_STYLES__EMOJIS_ENABLED_SETTING_LOADED",
				L = Object(l.a)(N),
				M = e => ({
					text: "Failed to save emoji",
					buttonText: "Retry",
					buttonAction: B(e)
				}),
				U = e => {
					let {
						imageData: t,
						subredditId: n
					} = e;
					return async (e, r, s) => {
						const u = r(),
							l = Object(E.S)(u, {
								subredditId: n
							}).name;
						e(Object(b.k)(t));
						const p = t.file,
							m = await Object(g.g)(p),
							f = await (async (e, t, n, r) => Object(i.b)(Object(c.a)(e, [d.a]), {
								endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji_asset_upload_s3.json"),
								method: o.bb.POST,
								data: {
									filepath: n,
									mimetype: r
								}
							}))(s.apiContext(), l, p.name, m);
						let O = !1;
						if (f.ok) {
							const n = await (async (e, t, n) => Object(a.a)(n, t))(s.apiContext(), f.body.s3UploadLease, p);
							if (n.ok) {
								if (!r().imageUploads[t.id]) return Object(y.d)(t), !1;
								const s = decodeURIComponent(n.body.PostResponse.Location),
									o = f.body.websocketUrl,
									i = Object(y.n)(t, s, o);
								e(Object(b.j)(i)), O = !0
							} else {
								const r = Object(y.k)(t, n.error);
								e(Object(b.i)(r))
							}
						} else {
							const n = Object(y.k)(t, f.error);
							e(Object(b.i)(n))
						}
						return O
					}
				},
				F = (e, t) => async (n, r, s) => {
					const {
						imageData: a,
						subredditId: u,
						emojiName: l,
						settings: m
					} = e, g = Object(f.a)(a.url), O = r(), h = Object(E.S)(O, {
						subredditId: u
					}).name, j = await (async (e, t, n, r, s) => Object(i.b)(Object(c.a)(e, [d.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji.json"),
						method: o.bb.POST,
						data: {
							s3_key: n,
							name: r,
							mod_flair_only: s.modFlairOnly,
							post_flair_allowed: s.postFlairAllowed,
							user_flair_allowed: s.userFlairAllowed
						}
					}))(s.apiContext(), h, g, l, m);
					if (!j.ok) {
						const r = Object(y.k)(a, j.error);
						n(Object(b.i)(r)), n(Object(p.e)(M(e))), t && t.close()
					}
					return j.ok
				}, B = e => async (t, n, r) => {
					const {
						imageData: s,
						subredditId: o,
						emojiName: i,
						settings: c
					} = e;
					if (t(Object(b.k)(s)), !s.websocketUrl) return t(Object(p.e)({
						text: "Could not upload emoji"
					}));
					let a;
					const d = new WebSocket(s.websocketUrl);
					return d.onopen = async () => {
						a = await F(e, d)(t, n, r)
					}, d.onmessage = n => {
						const r = JSON.parse(n.data);
						if ("success" === r.type) {
							a = !0;
							const e = r.payload.emoji_url,
								n = Object(y.o)(s, e);
							t(Object(b.l)(n));
							const d = Object(h.e)(i, n.url, o, c);
							t(I(d)), t(G(o))
						} else {
							const n = Object(m.a)(i),
								r = Object(y.k)(s, n);
							t(Object(b.i)(r)), t(Object(p.e)(M(e)))
						}
						d.close()
					}, d.onerror = n => {
						a = !1;
						const r = Object(m.a)(i),
							o = Object(y.k)(s, r);
						t(Object(b.i)(o)), t(Object(p.e)(M(e))), d.close()
					}, a
				}, G = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n();
					if (Object(_.a)(o, e)) return;
					const i = Object(E.S)(o, {
						subredditId: e
					}).name;
					t(R(e));
					const c = await u(s(), i);
					if (c.ok) {
						const n = c.body;
						t(A({
							subredditId: e,
							data: n
						}))
					} else t(k({
						subredditId: e,
						error: c.error
					}))
				}, V = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					n().emojis[e] || await t(G(e))
				}, q = (e, t) => async (n, r, s) => {
					let {
						apiContext: a
					} = s;
					const u = r(),
						l = Object(E.S)(u, {
							subredditId: t
						}).name,
						b = await (async (e, t, n) => Object(i.b)(Object(c.a)(e, [d.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(n, "/emoji/").concat(t),
							method: o.bb.DELETE,
							type: "json"
						}))(a(), e, l);
					if (b.ok) {
						n(x({
							emojiName: e,
							subredditId: t
						})), n(p.e({
							kind: j.b.SuccessCommunityGreen,
							text: Object(O.c)("Emoji successfully deleted")
						}))
					} else n(C(b.error)), n(p.e({
						kind: j.b.Error,
						text: Object(O.c)("Something went wrong")
					}))
				}, H = (e, t) => async (n, r, s) => {
					let {
						apiContext: a
					} = s;
					const u = r(),
						l = Object(E.S)(u, {
							subredditId: e
						}).name;
					if ((await (async (e, t, n) => Object(i.b)(Object(c.a)(e, [d.a]), {
							endpoint: "".concat(e.apiUrl, "/api/enable_emojis_in_sr.json"),
							method: o.bb.POST,
							data: {
								subreddit: t,
								enable: n
							}
						}))(a(), l, t)).ok) {
						n(L({
							subredditId: e,
							emojisEnabled: t
						}))
					} else n(p.e({
						kind: j.b.Error,
						text: Object(O.c)("Try again later")
					}))
				}, K = "EMOJI_CUSTOM_SIZE_UPDATED", W = Object(l.a)(K), Y = (e, t) => async (n, r, s) => {
					let {
						apiContext: a
					} = s;
					const u = r(),
						l = Object(E.S)(u, {
							subredditId: e
						}).name;
					(await (async (e, t, n) => Object(i.b)(Object(c.a)(e, [d.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji_custom_size"),
						method: o.bb.POST,
						data: n
					}))(a(), l, t)).ok ? n(W({
						subredditId: e,
						emojiCustomSize: t
					})) : n(p.e({
						kind: j.b.Error,
						text: Object(O.c)("Try again later")
					}))
				}, z = "EMOJI_PERMISSIONS_UPDATED", J = Object(l.a)(z), Q = (e, t, n, r) => async (s, a, u) => {
					let {
						apiContext: l
					} = u;
					const b = a(),
						m = Object(E.S)(b, {
							subredditId: r
						}).name;
					(await (async (e, t, n, r) => Object(i.b)(Object(c.a)(e, [d.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(n, "/emoji_permissions.json"),
						method: o.bb.POST,
						data: {
							name: t,
							post_flair_allowed: r.postFlairAllowed,
							user_flair_allowed: r.userFlairAllowed,
							mod_flair_only: r.modFlairOnly
						}
					}))(l(), e, m, n)).ok ? (s(J({
						emojiName: e,
						isSnoomoji: t,
						settings: n,
						subredditId: r
					})), s(p.e({
						kind: j.b.SuccessCommunityGreen,
						text: Object(O.c)("Emoji permissions updated")
					}))) : s(p.e({
						kind: j.b.Error,
						text: Object(O.c)("Try again later")
					}))
				}
		},
		"./src/reddit/actions/eventPosts.ts": function(e, t, n) {
			"use strict";
			n.r(t);
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts");
			var u = (e, t, n, r, o) => Object(c.b)(Object(a.a)(e, [d.a]), {
				endpoint: "".concat(e.apiUrl, "/api/event_post_time.json"),
				method: s.bb.POST,
				data: {
					id: t,
					event_start: n,
					event_end: r,
					event_tz: o
				}
			});
			var l = (e, t) => Object(c.b)(Object(a.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/start_event_post.json"),
					method: s.bb.POST,
					data: {
						id: t
					}
				}),
				b = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/selectors/posts.ts");
			n.d(t, "START_EVENT_NOW_SUCCESS", (function() {
				return f
			})), n.d(t, "startEventNowSuccess", (function() {
				return g
			})), n.d(t, "startEventNowRequested", (function() {
				return O
			})), n.d(t, "EDIT_EVENT_TIME_SUCCESS", (function() {
				return h
			})), n.d(t, "editEventTimeSuccess", (function() {
				return y
			})), n.d(t, "editEventTimeRequested", (function() {
				return j
			}));
			const m = () => r.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4onxm1"
				}),
				f = "START_EVENT_NOW_SUCCESS",
				g = Object(o.a)(f),
				O = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if ((await l(o(), e)).ok) {
						const s = () => r.fbt._("Following event has started successfully: {title}", [r.fbt._param("title", a)], {
							hk: "e9iz9"
						});
						t(g({
							postId: e
						}));
						const o = n(),
							c = Object(p.I)(o, {
								postId: e
							}),
							a = c && c.title || "";
						t(Object(i.e)({
							kind: b.b.SuccessMod,
							text: s()
						}))
					} else t(Object(i.e)({
						kind: b.b.Error,
						text: m()
					}))
				}, h = "EDIT_EVENT_TIME_SUCCESS", y = Object(o.a)(h), j = (e, t) => async (n, o, c) => {
					let {
						apiContext: a
					} = c;
					const d = await u(a(), e, t.startDate, t.endDate, t.timezoneName);
					if (d.ok) {
						const t = d.body,
							c = 14400,
							a = Math.round(t.event_start / s.Bb);
						let u = t.event_end;
						const l = {
							eventStart: a,
							eventEnd: u = u && Math.round(u / s.Bb) || a + c,
							eventIsLive: t.event_is_live
						};
						n(y({
							postId: e,
							eventInfo: l
						}));
						const m = o(),
							f = Object(p.I)(m, {
								postId: e
							}),
							g = f && f.title || "",
							O = () => r.fbt._("Following event time is updated successfully: {title}", [r.fbt._param("title", g)], {
								hk: "1m1w1c"
							});
						n(Object(i.e)({
							kind: b.b.SuccessMod,
							text: O()
						}))
					} else n(Object(i.e)({
						kind: b.b.Error,
						text: m()
					}))
				}
		},
		"./src/reddit/actions/experiments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./src/lib/makeActionCreator/index.ts");
			n("./src/reddit/endpoints/user/index.ts"), n("./src/reddit/models/Post/index.ts"), n("./src/reddit/selectors/telemetry.ts");
			const s = "EXPERIMENTS__REQUEST_LOADED",
				o = (Object(r.a)("EXPERIMENTS__REQUEST_PENDING"), Object(r.a)("EXPERIMENTS__REQUEST_FAILED"), Object(r.a)(s), "EXPERIMENTS__SET_EXPERIMENT_OVERRIDE"),
				i = Object(r.a)(o)
		},
		"./src/reddit/actions/exportImportStyles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "e", (function() {
				return _
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/loadWithRetries/index.ts"),
				o = n("./src/reddit/actions/structuredStyles/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/i18n/utils.ts"),
				a = n("./src/reddit/models/StructuredStyles/index.ts"),
				d = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const l = "STRUCTURED_STYLES__EXPORT_THEME_PENDING",
				b = "STRUCTURED_STYLES__EXPORT_THEME_LOADED",
				p = "STRUCTURED_STYLES__EXPORT_THEME_FAILED",
				m = Object(r.a)(l),
				f = Object(r.a)(b),
				g = Object(r.a)(p),
				O = Object(r.a)("STRUCTURED_STYLES__IMPORT_THEME_PENDING"),
				h = Object(r.a)("STRUCTURED_STYLES__IMPORT_THEME_LOADED"),
				y = Object(r.a)("STRUCTURED_STYLES__IMPORT_THEME_FAILED"),
				j = e => async (t, r) => {
					t(m());
					const o = r(),
						a = Object(u.S)(o, {
							subredditId: e
						}).name,
						l = o.structuredStyles.models[e],
						b = await Object(s.a)(() => Promise.all([n.e("vendors~ExportTheme~ImportTheme~xml2js"), n.e("vendors~ExportTheme~ImportTheme"), n.e("ExportTheme")]).then(n.bind(null, "./src/reddit/helpers/exportTheme/index.ts"))).then(e => e.default),
						p = await b(l, a);
					p.ok ? (t(f()), t(Object(i.e)({
						kind: d.b.SuccessMod,
						text: Object(c.c)("Theme successfully exported")
					}))) : (t(g(p.error)), t(Object(i.e)({
						kind: d.b.Error,
						text: Object(c.c)("Sorry, theme failed to export")
					})))
				}, _ = e => async (t, r) => {
					t(O());
					const u = await Object(s.a)(() => Promise.all([n.e("vendors~ExportTheme~ImportTheme~xml2js"), n.e("vendors~ExportTheme~ImportTheme"), n.e("ImportTheme")]).then(n.bind(null, "./src/reddit/helpers/importTheme/index.ts"))).then(e => e.default),
						l = await u(e);
					l.ok ? (t(h()), t(Object(i.e)({
						kind: d.b.SuccessMod,
						text: Object(c.c)("Theme successfully imported")
					})), 0 !== Object.keys(l.attributes).length && t(Object(o.d)(Object(a.j)(l.attributes)))) : (t(y(l.error)), t(Object(i.e)({
						kind: d.b.Error,
						text: Object(c.c)("Sorry, theme failed to import")
					})))
				}
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/constants/parameters.ts"),
				c = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				l = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const b = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var p = n("./src/reddit/i18n/utils.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/models/User/index.ts"),
				g = n("./src/reddit/selectors/externalAccount.ts"),
				O = n("./src/reddit/selectors/platform.ts"),
				h = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/selectors/user.ts");
			n.d(t, "l", (function() {
				return j
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "p", (function() {
				return A
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "n", (function() {
				return B
			})), n.d(t, "e", (function() {
				return G
			})), n.d(t, "f", (function() {
				return V
			})), n.d(t, "d", (function() {
				return q
			})), n.d(t, "m", (function() {
				return Y
			}));
			const j = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				_ = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				v = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				I = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				S = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				T = Object(r.a)(j),
				x = Object(r.a)(_),
				C = Object(r.a)(E),
				w = Object(r.a)(v),
				P = Object(r.a)(I),
				D = Object(r.a)(S),
				R = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = Object(y.i)(o),
						p = e || i && Object(f.f)(i);
					if (!p) return;
					if (Object(g.d)(o, {
							username: p
						})) return;
					t(T(p));
					const m = await ((e, t) => Object(a.b)(Object(d.a)(e, [u.a]), {
						endpoint: Object(l.a)("".concat(e.apiUrl, "/api/v1/external_account/user/").concat(t, ".json")),
						method: c.bb.GET
					}))(s(), p);
					if (m.ok) {
						const e = b(m.body);
						t(x({
							username: p,
							accountsData: e
						}))
					} else t(C(m.error))
				}, A = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t(),
						o = Object(O.e)(s);
					if (!o) return;
					const i = s.externalAccount.api.subreddit.fetched[o],
						p = s.externalAccount.api.subreddit.pending[o];
					if (i || p) return;
					const m = Object(h.y)(s, {
						subredditName: o
					});
					if (!(m && m.hasExternalAccount)) return;
					e(w(o));
					const f = await ((e, t) => Object(a.b)(Object(d.a)(e, [u.a]), {
						endpoint: Object(l.a)("".concat(e.apiUrl, "/api/v1/external_account/subreddit/").concat(t, ".json")),
						method: c.bb.GET
					}))(r(), o);
					if (f.ok) {
						const t = b(f.body);
						e(P({
							subredditName: o,
							accountsData: t
						}))
					} else e(D(f.error))
				}, k = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", N = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", L = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", M = Object(r.a)(k), U = Object(r.a)(N), F = Object(r.a)(L), B = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					t(M({
						provider: e
					}));
					const o = Object(y.i)(n()),
						i = Object(f.f)(o),
						b = await ((e, t) => Object(a.b)(Object(d.a)(e, [u.a]), {
							endpoint: Object(l.a)("".concat(e.apiUrl, "/api/v1/external_account/").concat(t, "/disconnect.json")),
							method: c.bb.POST
						}))(s(), e);
					b.ok ? t(U({
						provider: e,
						username: i
					})) : t(F({
						provider: e,
						error: b.error
					}))
				}, G = "OAUTH_FLOW_URL_PENDING", V = "OAUTH_FLOW_URL_SUCCESS", q = "OAUTH_FLOW_URL_FAILED", H = Object(r.a)(G), K = Object(r.a)(V), W = Object(r.a)(q), Y = e => async (t, n, r) => {
					let {
						apiContext: b
					} = r;
					t(H({
						provider: e
					}));
					const f = Object(s.a)(window.location.href, {
							[i.c]: e
						}),
						g = await ((e, t, n) => Object(a.b)(Object(d.a)(e, [u.a]), {
							endpoint: Object(l.a)("".concat(e.apiUrl, "/api/v1/external_account/").concat(t, "/connect.json")),
							method: c.bb.POST,
							data: {
								redirect_url: n
							}
						}))(b(), e, f);
					if (g.ok) {
						const {
							redirect_url: n
						} = g.body;
						t(K({
							provider: e
						})), window.location.href = n
					} else t(W({
						provider: e,
						error: g.error
					})), t(Object(o.e)({
						kind: m.b.Error,
						text: Object(p.c)("Something went wrong. Just don't panic.")
					}))
				}
		},
		"./src/reddit/actions/flairManagement/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = "FLAIR_PREVIEW_EXAMPLE_POST_CREATED",
				s = "FLAIR_PREVIEW_EXAMPLE_POST_DELETED"
		},
		"./src/reddit/actions/focusedVerticals/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/focusedVerticals/constants.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/graphql/operations/FocusVerticalSubredditRecommendations.json"),
				c = n("./src/reddit/featureFlags/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				u = n("./src/reddit/selectors/focusedVerticalSuggestion.ts");
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return O
			}));
			const l = Object(r.a)(s.e),
				b = Object(r.a)(s.d),
				p = Object(r.a)(s.f),
				m = Object(r.a)(s.h),
				f = Object(r.a)(s.g),
				g = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const s = t(),
						m = Object(u.d)(s),
						f = Object(u.c)(s),
						g = Object(u.e)(s),
						O = c.d.focusedVerticalsExperiment(s),
						h = s.user.temporaryGQL.isLoggedIn;
					if (m || f && !g || !O || !h) return;
					e(p());
					let y = !1;
					try {
						const t = await (e => Object(o.a)(e, Object.assign({}, i)))(r());
						if (t.ok && t.body) {
							const {
								data: n
							} = t.body, r = n.focusVerticalSubredditRecommendations;
							if (r && r.recommendations && r.recommendations.length && r.interactedSubreddits && r.interactedSubreddits.length && r.interactedSubreddits.length === r.recommendations.length) {
								const t = [...r.recommendations, ...r.interactedSubreddits],
									n = Object(d.d)(t),
									s = Object(a.b)(t),
									o = Object(d.e)(r.recommendations),
									i = {
										recommendedSubredditIds: r.recommendations.map(e => e.id),
										interactedSubredditIds: r.interactedSubreddits.map(e => e.id),
										subreddits: n,
										subredditsAboutInfo: s,
										subredditTopContent: o
									};
								e(l(i))
							}
							y = !0
						}
					} catch (j) {
						y = !1
					}
					y || e(b({
						error: {
							type: "Focused vertical experiment GQL API failed or caught by try and catch"
						}
					}))
				}, O = () => async (e, t, n) => e(g())
		},
		"./src/reddit/actions/frontpage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return _
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "e", (function() {
				return C
			}));
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/lib/getParsedUserAgent/index.ts"),
				i = n("./src/reddit/actions/page.ts"),
				c = n("./src/reddit/constants/parameters.ts"),
				a = n("./src/reddit/endpoints/page/frontpage.ts"),
				d = n("./src/reddit/endpoints/page/subredditPage.ts"),
				u = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				b = n("./src/lib/makeListingKey/index.ts"),
				p = n("./src/lib/constants/index.ts"),
				m = n("./src/reddit/constants/page.ts"),
				f = n("./src/reddit/constants/postLayout.ts"),
				g = n("./src/reddit/contexts/PageLayer/index.tsx"),
				O = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				h = n("./src/reddit/selectors/frontpage.ts"),
				y = n("./src/reddit/selectors/monthsToMinutes.ts"),
				j = n("./src/reddit/selectors/user.ts");
			const _ = "FRONTPAGE__MORE_POSTS_PENDING",
				E = "FRONTPAGE__MORE_POSTS_LOADED",
				v = "FRONTPAGE__MORE_POSTS_FAILED",
				I = Object(l.a)(_),
				S = Object(l.a)(E),
				T = Object(l.a)(v),
				x = e => async (t, n, r) => {
					let {
						apiContext: i,
						gqlContext: l
					} = r;
					const _ = n(),
						E = Object(h.a)(_),
						{
							sort: v = E
						} = e,
						x = _.platform.currentPage ? _.platform.currentPage.queryParams : {},
						C = Object(b.a)(m.b, v, x),
						w = _.listings.postOrder.loadMore[C],
						P = x[c.t] ? x[c.t].toUpperCase() : "",
						D = P in p.Ob && p.Ob[P];
					if (w) {
						const e = _.listings.postOrder.api.pending[C],
							n = _.listings.postOrder.fetchedTokens,
							r = !(!n[C] || !n[C][w.token]);
						if (!e && !r) {
							t(I({
								key: C,
								fetchedToken: w.token
							}));
							const e = !!_.platform.currentPage && !!_.platform.currentPage.queryParams.useMockData,
								n = Object.assign({
									after: w.token,
									dist: w.dist
								}, s()(x, c.k), {
									isMobile: Object(o.e)(_.meta.userAgent),
									sort: v,
									t: Object(u.a)(v, D),
									layout: f.e[Object(g.M)(_, {})],
									useMockData: e
								}),
								r = Object(y.e)(_),
								b = Object(y.g)(_),
								p = r && b;
							if (!p) {
								const e = _.platform.lastPage,
									t = e && e.url;
								t && (n.clickUrl = t)
							}
							const m = p ? () => Object(d.a)(i(), r, n) : () => Object(a.a)(l(), Object(a.c)(_, Object.assign({}, n, {
									limit: f.a
								})), Object(j.R)(_)),
								h = await m(),
								E = Object.assign({}, h.body, Object(O.a)(_, C, h.body));
							h.ok ? t(S(Object.assign({
								key: C,
								fetchedToken: w.token,
								meta: _.meta
							}, E))) : t(T(Object.assign({
								key: C,
								error: h.error,
								fetchedToken: w.token
							}, E)))
						}
					}
				}, C = e => async (t, n) => {
					const r = n(),
						s = Object(h.a)(r),
						{
							sort: o = s
						} = e,
						a = r.platform.currentPage ? r.platform.currentPage.queryParams : {},
						d = Object(b.a)(m.b, o, a),
						l = a[c.t] ? a[c.t].toUpperCase() : "",
						f = l in p.Ob && p.Ob[l];
					await t(Object(i.x)(d, {
						sort: o,
						t: Object(u.a)(o, f)
					}))
				}
		},
		"./src/reddit/actions/global.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/actions/monthsToMinutes.ts"),
				i = n("./src/reddit/actions/publicAccessNetwork/userSettings.ts"),
				c = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./src/lib/localStorageAvailable/index.ts")),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/constants/modals.ts"),
				u = n("./src/reddit/constants/spezModal.ts"),
				l = n("./src/reddit/featureFlags/index.ts"),
				b = n("./src/reddit/selectors/activeModalId.ts"),
				p = n("./src/reddit/selectors/runTimeEnvVars.ts");
			const m = async (e, t) => {
				const n = t();
				if (l.d.spezModal(n) && Object(c.a)() && !Object(b.a)(n)) try {
					const t = Date.now(),
						r = localStorage.getItem(u.f);
					if ((r ? parseInt(r, 10) : 0) > (Object(p.c)(n) ? 0 : u.d)) return;
					localStorage.setItem(u.f, t.toString()), localStorage.getItem(u.f) && e(Object(a.h)(d.a.SPEZ_MODAL))
				} catch (r) {}
			};
			var f = n("./src/reddit/helpers/monthsToMinutes/index.ts"),
				g = n("./src/reddit/selectors/user.ts");
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return y
			}));
			const O = "LOCAL_STORAGE_LOADED",
				h = Object(r.a)(O),
				y = e => async (t, n) => {
					let r = n();
					Object(g.K)(r) ? Object(f.b)() : t(Object(o.h)()), t(Object(i.a)()), (r = n()).user.loid.loid || r.meta.isBot || s.c.captureMessage("User has no LOID set");
					const {
						localStorageData: c
					} = e;
					c && t(h(c)), t(m)
				}
		},
		"./src/reddit/actions/gold/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return O
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "h", (function() {
				return D
			})), n.d(t, "f", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/i18n/utils.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/models/Gold/Award.ts"),
				d = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/activeModalId.ts"),
				l = n("./src/reddit/selectors/communityAwards.ts"),
				b = n("./src/reddit/selectors/profile.ts"),
				p = n("./src/reddit/selectors/user.ts"),
				m = n("./src/reddit/endpoints/gold/communityAwards.ts"),
				f = n("./src/reddit/constants/gold.ts"),
				g = n("./src/reddit/actions/gold/constants.ts");
			const O = (e, t, n, r, s, i, c, a) => async (d, u, l) => {
				let {
					gqlContext: b
				} = l;
				d(j());
				try {
					if ((await Object(m.a)(b(), e, t, n, r, s, i, c, a)).error) {
						const e = Object(o.c)("There was an error creating the award. Please try again.");
						await d(E(e))
					}
				} catch (p) {
					const e = Object(o.c)("There was an error creating the award. Please try again.");
					await d(E(e))
				}
			}, h = (e, t, n, r, s, i, c, a) => async (d, u, l) => {
				let {
					gqlContext: b
				} = l;
				d(j());
				try {
					if ((await Object(m.c)(b(), e, t, n, r, s, i, c, a)).error) {
						const e = Object(o.c)("There was an error creating the award. Please try again.");
						await d(E(e))
					}
				} catch (p) {
					const e = Object(o.c)("There was an error creating the award. Please try again.");
					await d(E(e))
				}
			}, y = e => {
				let {
					awardSubType: t,
					coinPrice: n,
					coinReward: r,
					daysOfDripExtension: s,
					daysOfPremium: i,
					endsAt: c,
					iconHeight: a,
					iconUrl: d,
					iconWidth: u,
					isNew: l,
					name: b,
					startsAt: p
				} = e;
				return async (e, f, g) => {
					let {
						gqlContext: O
					} = g;
					e(j());
					try {
						if ((await Object(m.b)({
								awardSubType: t,
								coinPrice: n,
								coinReward: r,
								context: O(),
								daysOfPremium: i,
								daysOfDripExtension: s,
								endsAt: c,
								iconUrl: d,
								iconWidth: u,
								iconHeight: a,
								isNew: l,
								name: b,
								startsAt: p
							})).error) {
							const t = Object(o.c)("There was an error creating the award. Please try again.");
							await e(E(t))
						}
					} catch (h) {
						const t = Object(o.c)("There was an error creating the award. Please try again.");
						await e(E(t))
					}
				}
			}, j = Object(s.a)(g.e), _ = Object(s.a)(g.d), E = e => async (t, n) => {
				await t(_(e)), t(Object(c.e)({
					kind: d.b.Error,
					duration: c.a,
					text: e
				}))
			}, v = Object(s.a)(g.f), I = e => {
				let {
					award: t,
					subredditId: n
				} = e;
				return async (e, s) => {
					const o = s();
					e(v({
						award: t,
						subredditId: n
					})), Object(u.a)(o) === f.a && e(Object(i.i)(f.a));
					const a = Object(p.T)(o);
					e(Object(c.e)({
						kind: d.b.SuccessCommunity,
						text: Object(r.a)(a, "communityAwards.creationModal.successfullyCreated")
					}))
				}
			}, S = e => async (t, n, r) => {
				let {
					gqlContext: s
				} = r;
				const i = n(),
					c = !!i.awards.manageable.order[e];
				if (!Object(l.b)(i, {
						subredditId: e
					}) && !c) {
					t(T({
						subredditId: e
					}));
					try {
						const [n, r] = await Promise.all([Object(m.i)(s(), e), Object(m.f)(s(), e)]);
						if (!n.ok) {
							const e = Object(o.c)("There was an error loading awards list. Please try again.");
							return void(await t(w(e)))
						}
						if (r.ok && !r.body.data.subreddit.isAwardCreationAllowed) return void(await t(P({
							subredditId: e,
							disabled: !0
						})));
						const i = n.body;
						await t(x({
							awards: i.data.subreddit.manageableAwards,
							subredditId: e
						}))
					} catch (a) {
						const e = Object(o.c)("There was an error loading awards list. Please try again.");
						t(w(e))
					}
				}
			}, T = Object(s.a)(g.E), x = Object(s.a)(g.D), C = Object(s.a)(g.C), w = e => async (t, n) => {
				await t(C(e)), t(Object(c.e)({
					kind: d.b.Error,
					duration: c.a,
					text: e
				}))
			}, P = Object(s.a)(g.a), D = e => async (t, n, r) => {
				let {
					gqlContext: s
				} = r;
				const o = n();
				if (!!!o.awards.usable.order[e]) {
					t(R({
						subredditOrProfileId: e
					}));
					try {
						const n = Object(b.p)(o, {
							profileId: e
						});
						if (n) {
							const r = await Object(m.k)(s(), n.name);
							if (r.ok) {
								const n = r.body;
								return void(await t(A({
									awards: n.data.profile.usableAwards,
									subredditOrProfileId: e
								})))
							}
						} else {
							const n = await Object(m.j)(s(), e);
							if (n.ok) {
								const r = n.body;
								return void(await t(A({
									awards: r.data.subreddit.usableAwards,
									subredditOrProfileId: e
								})))
							}
						}
					} catch (i) {}
					await t(A({
						awards: a.h,
						subredditOrProfileId: e
					}))
				}
			}, R = Object(s.a)(g.M), A = Object(s.a)(g.L), k = (Object(s.a)(g.K), Object(s.a)(g.h), Object(s.a)(g.i), Object(s.a)(g.g), (e, t) => async (n, s, o) => {
				let {
					gqlContext: i
				} = o;
				n(N());
				const a = Object(p.T)(s());
				try {
					if ((await Object(m.h)(i(), t)).error) {
						const e = Object(r.a)(a, "communityAwards.errors.awardDisableError");
						await n(U(e))
					} else {
						await n(L({
							awardId: t,
							subredditId: e
						}));
						const o = Object(l.a)(s(), t);
						if (!o) return;
						const i = Object(r.a)(a, "communityAwards.disableModal.successfullyDisabled", {
							awardName: o.name
						});
						n(Object(c.e)({
							kind: d.b.SuccessCommunity,
							duration: c.a,
							text: i
						}))
					}
				} catch (u) {
					const e = Object(r.a)(a, "communityAwards.errors.awardDisableError");
					await n(U(e))
				}
			}), N = Object(s.a)(g.k), L = Object(s.a)(g.l), M = Object(s.a)(g.j), U = e => async (t, n) => {
				await t(M(e)), t(Object(c.e)({
					kind: d.b.Error,
					duration: c.a,
					text: e
				}))
			}
		},
		"./src/reddit/actions/gold/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "H", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "G", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "F", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "E", (function() {
				return O
			})), n.d(t, "D", (function() {
				return h
			})), n.d(t, "C", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "M", (function() {
				return _
			})), n.d(t, "L", (function() {
				return E
			})), n.d(t, "K", (function() {
				return v
			})), n.d(t, "w", (function() {
				return I
			})), n.d(t, "A", (function() {
				return S
			})), n.d(t, "v", (function() {
				return T
			})), n.d(t, "x", (function() {
				return x
			})), n.d(t, "z", (function() {
				return C
			})), n.d(t, "y", (function() {
				return w
			})), n.d(t, "B", (function() {
				return P
			})), n.d(t, "p", (function() {
				return D
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "s", (function() {
				return A
			})), n.d(t, "r", (function() {
				return k
			})), n.d(t, "n", (function() {
				return N
			})), n.d(t, "q", (function() {
				return L
			})), n.d(t, "m", (function() {
				return M
			})), n.d(t, "J", (function() {
				return U
			})), n.d(t, "I", (function() {
				return F
			})), n.d(t, "t", (function() {
				return B
			})), n.d(t, "u", (function() {
				return G
			}));
			const r = "GIVE_PREMIUM__OPEN_GIVE_PREMIUM_MODAL",
				s = "GIVE_PREMIUM__CLOSE_GIVE_PREMIUM_MODAL",
				o = "GILD__OPEN_GILD_MODAL",
				i = "GILD__CLOSE_GILD_MODAL",
				c = "GILD__OPEN_FRAMED_GILD",
				a = "COMMUNITY_AWARDS__CREATE_AWARD_PENDING",
				d = "COMMUNITY_AWARDS__CREATE_AWARD_SUCCESSFUL",
				u = "COMMUNITY_AWARDS__CREATE_AWARD_FAILED",
				l = "COMMUNITY_AWARDS__DELETE_AWARD_PENDING",
				b = "COMMUNITY_AWARDS__DELETE_AWARD_SUCCESSFUL",
				p = "COMMUNITY_AWARDS__DELETE_AWARD_FAILED",
				m = "COMMUNITY_AWARDS__DISABLE_AWARD_PENDING",
				f = "COMMUNITY_AWARDS__DISABLE_AWARD_SUCCESSFUL",
				g = "COMMUNITY_AWARDS__DISABLE_AWARD_FAILED",
				O = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_PENDING",
				h = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_LOADED",
				y = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_FAILED",
				j = "COMUNITY_AWARDS__BLACKLIST_STATUS_LOADED",
				_ = "COMMUNITY_AWARDS__USABLE_AWARDS_PENDING",
				E = "COMMUNITY_AWARDS__USABLE_AWARDS_LOADED",
				v = "COMMUNITY_AWARDS__USABLE_AWARDS_FAILED",
				I = "GIVE_PREMIUM__GIVE_PREMIUM_PENDING",
				S = "GIVE_PREMIUM__GIVE_PREMIUM_SUCCESSFUL",
				T = "GIVE_PREMIUM__GIVE_PREMIUM_FAILED",
				x = "GIVE_PREMIUM__SELECT_PACKAGE",
				C = "GIVE_PREMIUM__SET_IS_ANONYMOUS",
				w = "GIVE_PREMIUM__SET_INCLUDE_MESSAGE",
				P = "GIVE_PREMIUM__UPDATE_MESSAGE",
				D = "GILD__SET_IS_ANONYMOUS",
				R = "GILD__SET_INCLUDE_MESSAGE",
				A = "GILD__UPDATE_MESSAGE",
				k = "GILD__TRIGGER_LOADER",
				N = "GILD__GILD_PENDING",
				L = "GILD__GILD_SUCCESSFUL",
				M = "GILD__GILD_FAILED",
				U = "GIVE_AWARD__SELECT_AWARD",
				F = "AWARDS__REPORT_AWARD",
				B = "AWARDS__GIVE_AWARD_TOOLTIP_CLOSED",
				G = "AWARDS__GIVE_AWARD_TOOLTIP_OPENED"
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "f", (function() {
				return E
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/messageIframeParent/index.ts"),
				o = n("./src/reddit/helpers/isPost.ts"),
				i = n("./src/reddit/selectors/gild.ts"),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				a = n("./src/reddit/actions/gold/communityAwards.ts"),
				d = n("./src/reddit/components/GildModal/getGildModalId.ts"),
				u = n("./src/reddit/selectors/posts.ts"),
				l = n("./src/reddit/selectors/subreddit.ts"),
				b = n("./src/telemetry/index.ts"),
				p = n("./src/reddit/actions/gold/constants.ts");
			const m = Object(r.a)(p.H),
				f = Object(r.a)(p.c),
				g = () => async (e, t) => {
					const r = t();
					e(f()), Object(c.b)(c.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: s
					} = await n.e("givePremiumTrackers").then(n.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(b.a)(s()(r))
				}, O = Object(r.a)(p.G), h = (e, t) => async (n, r) => {
					const s = r(),
						i = Object(d.a)(e, t);
					n(O({
						thingId: e,
						gildModalId: i
					}));
					const c = Object(l.K)(s, {
						thingId: e
					});
					if (c) Object(a.h)(c.id);
					else if (Object(o.a)(e)) {
						const t = Object(u.I)(s, {
							postId: e
						});
						if (!t) return;
						Object(a.h)(t.belongsTo.id)
					} else;
				}, y = Object(r.a)(p.b), j = Object(r.a)(p.F), _ = () => async (e, t) => {
					const r = t(),
						o = Object(i.d)(r);
					if (Object(i.h)(r)) {
						const e = "close.gild";
						Object(s.a)({
							type: e
						})
					}
					e(y());
					const {
						clickCloseGildModalEvent: a
					} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(b.a)(a(o)(r)), Object(c.b)(c.a.GildingFlow)
				}, E = () => async () => {
					Object(s.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "n", (function() {
				return T
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "i", (function() {
				return P
			})), n.d(t, "j", (function() {
				return R
			})), n.d(t, "k", (function() {
				return A
			})), n.d(t, "l", (function() {
				return k
			}));
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./src/app/strings/index.ts"),
				o = n("./src/config.ts"),
				i = n("./src/lib/formatApiError/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/sentry/index.ts"),
				d = n("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				u = n("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				l = n("./src/reddit/endpoints/gold/purchase.ts"),
				b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				m = n("./src/reddit/models/Gold/Award.ts"),
				f = n("./src/reddit/models/Gold/Coins/index.ts"),
				g = n("./src/reddit/selectors/experiments/goldPaypalSdk.ts"),
				O = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				h = n("./src/reddit/selectors/user.ts");
			const y = "COIN_PURCHASE_MODAL__OPEN_COIN_PURCHASE_MODAL",
				j = "COIN_PURCHASE_MODAL__CLOSE_COIN_PURCHASE_MODAL",
				_ = Object(c.a)(y),
				E = Object(c.a)(j),
				v = "COIN_PURCHASE_MODAL__OPEN_COIN_PURCHASE_MODAL_TO_GILD",
				I = Object(c.a)(v),
				S = (e, t, n, r) => async s => {
					s(I({
						thingId: n
					}));
					const o = Object(f.b)(e, t),
						i = Object(b.c)(b.a.GoldPayment);
					s(D({
						coinPackage: o,
						correlationId: i,
						isOldReddit: r
					}))
				}, T = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const a = r(),
						u = t.coins,
						p = t.pennies,
						m = Object(b.c)(b.a.GoldPayment),
						f = Object(h.T)(a);
					let g, y;
					n(Object(d.stripeTokenPending)());
					const j = Object(O.v)(a);
					if (j || (g = await n(Object(d.validateAndCreateStripeToken)(e)), y = Object(O.r)(a), g)) try {
						const e = await Object(l.e)({
							coins: u,
							context: c(),
							correlationId: m,
							language: f,
							pennies: p,
							rememberCard: y,
							savedCardId: j || void 0,
							token: g
						});
						if (e.error) {
							const t = Object(i.a)(f, e.error, e.status);
							return void n(Object(d.stripeApiError)(t))
						}
						return void n(Object(d.paymentCompleted)({
							coins: e.body.coins ? e.body.coins : 0,
							confirmed: !1
						}))
					} catch (_) {
						const e = Object(i.a)(f, _);
						n(Object(d.stripeApiError)(e))
					} else n(Object(d.stripeApiError)(Object(s.a)(f, "error.type.genericCardValidation")))
				}, x = (e, t, r) => async (o, c, a) => {
					let {
						apiContext: u
					} = a;
					const f = c(),
						g = t.coins,
						y = t.pennies,
						j = Object(b.c)(b.a.GoldPayment),
						_ = Object(h.T)(f);
					let v, I;
					o(Object(d.stripeTokenPending)());
					const S = Object(O.v)(f);
					if (S || (v = await o(Object(d.validateAndCreateStripeToken)(e)), I = Object(O.r)(f), v)) try {
						const {
							gildModalThingId: e,
							isAnonymous: t,
							includeMessage: c,
							message: a,
							selectedAward: b
						} = f.gild;
						if (!e || !b.id) return void o(Object(d.stripeApiError)(Object(s.a)(_, "gold.errors.unknowngild")));
						const O = b.id,
							h = {
								gildType: O,
								includeMessage: c,
								isAnonymous: t,
								message: a
							},
							T = await Object(l.d)({
								coins: g,
								context: u(),
								correlationId: j,
								gildParams: h,
								isOldReddit: r,
								language: _,
								pennies: y,
								rememberCard: I,
								savedCardId: S || void 0,
								thingId: e,
								token: v
							});
						if (T.error) {
							const e = Object(i.a)(_, T.error, T.status);
							return void o(Object(d.stripeApiError)(e))
						} {
							const {
								gildSuccessful: t
							} = await n.e("gildActions").then(n.bind(null, "./src/reddit/actions/gold/gild.ts"));
							o(E()), o(Object(d.paymentCompleted)({
								confirmed: !1
							}));
							const {
								all_awardings: r,
								coins: s
							} = T.body;
							return void o(t({
								awardId: O,
								awardings: r && r.length ? Object(p.a)(r).map(e => ({
									award: Object(m.d)(e),
									total: e.count
								})) : [],
								coins: s,
								id: e
							}))
						}
					} catch (T) {
						const e = Object(i.a)(_, T);
						o(Object(d.stripeApiError)(e))
					} else o(Object(d.stripeApiError)(Object(s.a)(_, "error.type.genericCardValidation")))
				}, C = "COIN_PURCHASE_MODAL__PAYMENT_BLOB_CREATED", w = Object(c.a)(C), P = e => {
					let {
						coinPackage: t,
						correlationId: n
					} = e;
					return async (e, r, s) => {
						let {
							apiContext: c
						} = s;
						e(_({
							coinPackage: t
						}));
						const a = r();
						if (Object(g.a)(a)) return;
						const l = o.a.paypal.buttons["coins".concat(t.coins)] || o.a.paypal.buttons.coins500,
							b = Object(h.T)(a);
						try {
							const t = await Object(u.e)({
								buttonId: l,
								context: c(),
								correlationId: n,
								language: b
							});
							if (t.error) {
								const n = Object(i.a)(b, t.error, t.status);
								e(Object(d.paypalApiError)(n))
							} else e(w(t))
						} catch (p) {
							const t = Object(i.a)(b, p);
							e(Object(d.paypalApiError)(t))
						}
					}
				}, D = e => {
					let {
						coinPackage: t,
						correlationId: n,
						isOldReddit: r
					} = e;
					return async (e, c, a) => {
						let {
							apiContext: l
						} = a;
						e(_({
							coinPackage: t
						}));
						const b = c();
						if (Object(g.a)(b)) return;
						const p = o.a.paypal.buttons["coinsGild".concat(t.coins)] || o.a.paypal.buttons.coinsGild500,
							m = Object(h.T)(b),
							{
								gildModalThingId: f,
								isAnonymous: O,
								message: y,
								selectedAward: j
							} = b.gild,
							E = j.id;
						if (f && E) try {
							const t = await Object(u.d)({
								buttonId: p,
								context: l(),
								correlationId: n,
								gildTypeName: E,
								isAnonymous: O,
								isOldReddit: r,
								language: m,
								message: y,
								thingId: f
							});
							if (t.error) {
								const n = Object(i.a)(m, t.error, t.status);
								e(Object(d.paypalApiError)(n))
							} else e(w(t))
						} catch (v) {
							const t = Object(i.a)(m, v);
							e(Object(d.paypalApiError)(t))
						} else e(Object(d.paypalApiError)(Object(s.a)(m, "gold.errors.unknowngild")))
					}
				}, R = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						c = Object(b.c)(b.a.GoldPayment),
						l = Object(h.T)(o),
						p = e.coins,
						m = e.pennies;
					try {
						const e = await Object(u.a)({
							context: s(),
							coins: p,
							pennies: m,
							correlationId: c
						});
						if (e.error) {
							const n = Object(i.a)(l, e.error);
							return void t(Object(d.paypalApiError)(n))
						} {
							const {
								order_id: t
							} = e.body;
							return t
						}
					} catch (f) {
						a.c.captureException(f);
						const e = Object(i.a)(l, f);
						t(Object(d.paypalApiError)(e))
					}
				}, A = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const c = r(),
						l = Object(b.c)(b.a.GoldPayment),
						p = Object(h.T)(c),
						m = t.coins,
						f = t.pennies;
					try {
						const t = await Object(u.b)({
							context: o(),
							orderId: e,
							coins: m,
							pennies: f,
							correlationId: l
						});
						if (t.error) {
							const e = Object(i.a)(p, t.error);
							return void n(Object(d.paypalApiError)(e))
						} {
							const {
								coins: e
							} = t.body;
							n(Object(d.paymentCompleted)({
								coins: e,
								confirmed: !0
							}))
						}
					} catch (g) {
						a.c.captureException(g);
						const e = Object(i.a)(p, g);
						n(Object(d.paypalApiError)(e))
					}
				}, k = (e, t) => async (s, o, c) => {
					let {
						apiContext: l
					} = c;
					const f = o(),
						g = Object(b.c)(b.a.GoldPayment),
						O = Object(h.T)(f),
						y = t.coins,
						j = t.pennies;
					try {
						const {
							gildModalThingId: t,
							includeMessage: o,
							isAnonymous: c,
							message: a,
							selectedAward: b
						} = f.gild;
						if (!t || !b) return void s(Object(d.paypalApiError)(r.fbt._("Gilding unknown post or comment", null, {
							hk: "4DkIS3"
						})));
						const h = b.id,
							_ = await Object(u.c)({
								context: l(),
								orderId: e,
								coins: y,
								pennies: j,
								thingId: t,
								awardId: h,
								message: o ? a : "",
								isAnonymous: c,
								correlationId: g
							});
						if (_.error) {
							const e = Object(i.a)(O, _.error);
							s(Object(d.paypalApiError)(e))
						} else {
							s(E());
							const {
								all_awardings: e,
								coins: r,
								subreddit_coins: o
							} = _.body;
							s(Object(d.paymentCompleted)({
								coins: r,
								confirmed: !0
							}));
							const {
								gildSuccessful: i
							} = await n.e("gildActions").then(n.bind(null, "./src/reddit/actions/gold/gild.ts"));
							s(i({
								awardId: h,
								awardings: Object(p.a)(e).map(e => ({
									award: Object(m.d)(e),
									total: e.count
								})),
								coins: r,
								id: t,
								subredditCoins: o
							}))
						}
					} catch (_) {
						a.c.captureException(_);
						const e = Object(i.a)(O, _);
						s(Object(d.paypalApiError)(e))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "q", (function() {
				return y
			})), n.d(t, "r", (function() {
				return j
			}));
			const r = "GOLD_PAYMENT__CARD_NAME_EMPTY",
				s = "GOLD_PAYMENT__CARD_NAME_INPUT",
				o = "GOLD_PAYMENT__DELETE_SAVED_CARD",
				i = "GOLD_PAYMENT__FETCHED_STRIPE_INFO",
				c = "GOLD_PAYMENT__PAYMENT_COMPLETED",
				a = "GOLD_PAYMENT__PAYPAL_API_ERROR",
				d = "GOLD_PAYMENT__SAVED_CARDS_PENDING",
				u = "GOLD_PAYMENT__SELECT_PAYMENT_METHOD",
				l = "GOLD_PAYMENT__SELECT_SAVED_CARD",
				b = "GOLD_PAYMENT__STRIPE_API_ERROR",
				p = "GOLD_PAYMENT__STRIPE_ELEMENT_CHANGE",
				m = "GOLD_PAYMENT__CARD_ERROR",
				f = "GOLD_PAYMENT__STRIPE_TOKEN_PENDING",
				g = "GOLD_PAYMENT__TOGGLE_REMEMBER_CARD",
				O = "UPDATE_CARD_MODAL__CLOSE_UPDATE_CARD_MODAL",
				h = "UPDATE_CARD_MODAL__UPDATE_CARD_FAILED",
				y = "UPDATE_CARD_MODAL__UPDATE_CARD_PENDING",
				j = "UPDATE_CARD_MODAL__UPDATE_CARD_SUCCESSFUL"
		},
		"./src/reddit/actions/goldPurchaseModals/payment.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "selectPaymentMethod", (function() {
				return u
			})), n.d(t, "paymentCompleted", (function() {
				return l
			})), n.d(t, "cardNameInput", (function() {
				return b
			})), n.d(t, "cardNameEmpty", (function() {
				return p
			})), n.d(t, "cardElementChange", (function() {
				return m
			})), n.d(t, "stripeTokenPending", (function() {
				return f
			})), n.d(t, "stripeTokenError", (function() {
				return g
			})), n.d(t, "stripeApiError", (function() {
				return O
			})), n.d(t, "validateAndCreateStripeToken", (function() {
				return h
			})), n.d(t, "paypalApiError", (function() {
				return y
			})), n.d(t, "toggleRememberCard", (function() {
				return j
			})), n.d(t, "selectSavedCard", (function() {
				return _
			})), n.d(t, "_deleteSavedCard", (function() {
				return E
			})), n.d(t, "deleteSavedCard", (function() {
				return v
			})), n.d(t, "loadSavedCards", (function() {
				return T
			}));
			var r = n("./src/lib/sentry/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/endpoints/gold/purchase.ts"),
				i = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				c = n("./src/app/strings/index.ts"),
				a = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = Object(s.a)(i.i),
				l = Object(s.a)(i.f),
				b = Object(s.a)(i.b),
				p = Object(s.a)(i.a),
				m = Object(s.a)(i.l),
				f = Object(s.a)(i.n),
				g = Object(s.a)(i.m),
				O = Object(s.a)(i.k),
				h = e => async (t, n) => {
					const r = n(),
						s = Object(a.j)(r),
						{
							token: o,
							error: i
						} = await e.createToken({
							name: s
						});
					if (s.trim()) {
						if (!i && o) return o;
						t(g(i || void 0))
					} else {
						const e = Object(d.T)(r),
							n = Object(c.a)(e, "gold.checkoutForm.yourCardsNameFieldIsIncomplete");
						t(p({
							message: n
						}))
					}
				}, y = Object(s.a)(i.g), j = Object(s.a)(i.o), _ = Object(s.a)(i.j), E = Object(s.a)(i.d), v = e => async (t, n, s) => {
					let {
						apiContext: i
					} = s;
					t(E(e));
					try {
						const t = await Object(o.a)(i(), e);
						if (t.error) throw new Error(t.error.type)
					} catch (c) {
						r.c.captureException(c)
					}
				}, I = Object(s.a)(i.h), S = Object(s.a)(i.e), T = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					e(I());
					const i = t(),
						c = Object(d.T)(i);
					try {
						const t = await Object(o.b)(s(), c);
						if (t.error) throw new Error(t.error.type);
						const n = t.body.map(e => ({
							brand: e.brand,
							cardId: e.card_id,
							expirationMonth: e.exp_month,
							expirationYear: e.exp_year,
							last4: e.last4
						}));
						e(S(n)), n[0] && e(_(n[0].cardId))
					} catch (a) {
						r.c.captureException(a), e(S([]))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "f", (function() {
				return j
			}));
			var r = n("./src/config.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/formatApiError/index.ts"),
				a = n("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				d = n("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				u = n("./src/reddit/endpoints/gold/purchase.ts"),
				l = n("./src/reddit/helpers/correlationIdTracker.ts"),
				b = n("./src/reddit/selectors/user.ts");
			const p = "PREMIUM_PURCHASE_MODAL__OPEN_PREMIUM_PURCHASE_MODAL",
				m = "PREMIUM_PURCHASE_MODAL__CLOSE_PREMIUM_PURCHASE_MODAL",
				f = Object(s.a)(p),
				g = Object(s.a)(m),
				O = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const d = n(),
						p = i.lb,
						m = Object(l.c)(l.a.GoldPayment),
						f = Object(b.T)(d);
					t(Object(a.stripeTokenPending)());
					const g = await t(Object(a.validateAndCreateStripeToken)(e));
					if (g) try {
						const e = await Object(u.f)({
							context: s(),
							correlationId: m,
							language: f,
							pennies: p,
							token: g
						});
						if (e.error) {
							const n = Object(c.a)(f, e.error);
							t(Object(a.stripeApiError)(n))
						} else t(Object(a.paymentCompleted)({
							confirmed: !1
						}))
					} catch (O) {
						const e = Object(c.a)(f, O);
						t(Object(a.stripeApiError)(e))
					} else t(Object(a.stripeApiError)(Object(o.a)(f, "error.type.genericCardValidation")))
				}, h = "PREMIUM_PURCHASE_MODAL__PAYMENT_BLOB_CREATED", y = Object(s.a)(h), j = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					t(f());
					const i = n(),
						u = Object(b.T)(i),
						l = r.a.paypal.buttons.premium;
					try {
						const n = await Object(d.f)({
							buttonId: l,
							context: o(),
							correlationId: e,
							language: u
						});
						if (n.error) {
							const e = Object(c.a)(u, n.error);
							t(Object(a.paypalApiError)(e))
						} else t(y(n))
					} catch (p) {
						const e = Object(c.a)(u, p);
						t(Object(a.paypalApiError)(e))
					}
				}
		},
		"./src/reddit/actions/governance/communityDetails.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/governance/community.ts"),
				o = n("./src/reddit/actions/governance/constants.ts");
			const i = Object(r.a)(o.a),
				c = e => {
					let {
						subredditId: t
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: o
						} = r;
						const c = await Object(s.a)(o(), {
							subredditId: t
						});
						c.ok && e(i(Object.assign({
							subredditId: t
						}, c.body)))
					}
				}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "o", (function() {
				return O
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "q", (function() {
				return y
			})), n.d(t, "r", (function() {
				return j
			})), n.d(t, "s", (function() {
				return _
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "u", (function() {
				return v
			})), n.d(t, "v", (function() {
				return I
			})), n.d(t, "w", (function() {
				return S
			})), n.d(t, "x", (function() {
				return T
			})), n.d(t, "y", (function() {
				return x
			}));
			const r = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				s = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				o = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				i = "GOVERNANCE__OPT_OUT_IN_PENDING",
				c = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				a = "POLL_VOTE_SUCCESS",
				d = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				u = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				l = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				b = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				m = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				f = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				g = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				O = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				h = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				y = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				j = "GOVERNANCE__TRANSFER_FAILURE",
				_ = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				E = "GOVERNANCE__TRANSFER_PENDING",
				v = "GOVERNANCE__TRANSFER_SUCCESS",
				I = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				S = "GOVERNANCE__WALLETS_FETCH_PENDING",
				T = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				x = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/reddit/actions/toaster.ts"),
				s = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				o = n("./src/reddit/models/Toast/index.ts");

			function i(e, t) {
				e(Object(r.e)({
					duration: 5e3,
					kind: o.b.Error,
					text: Object(s.a)(t)
				}))
			}
		},
		"./src/reddit/actions/governance/publicWalletsFetched.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/governance/wallet.ts"),
				o = n("./src/reddit/actions/governance/constants.ts");
			const i = Object(r.a)(o.n),
				c = Object(r.a)(o.o),
				a = Object(r.a)(o.m);
			t.a = e => async (t, n, r) => {
				let {
					apiContext: o
				} = r;
				t(i({
					subredditId: e.subredditId
				}));
				const d = await Object(s.b)(o(), e);
				d.ok ? t(c(Object.assign({
					subredditId: e.subredditId
				}, d.body))) : t(a({
					error: d.error
				}))
			}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return r
			})), n.d(t, "g", (function() {
				return s
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "j", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			}));
			const r = "SUBREDDIT__FLAIRED_USERS_PENDING",
				s = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				i = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				c = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				a = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				d = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				m = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/harbergerTax/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "e", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			}));
			const r = "HARBERGER_TAX__BANNER_MANAGE_MODAL_OPENED",
				s = "HARBERGER_TAX__BANNER_PURCHASE_MODAL_OPENED",
				o = "HARBERGER_TAX__BANNER_CRYPTO_MANAGE_MODAL_OPENED",
				i = "HARBERGER_TAX__BANNER_CRYPTO_PURCHASE_MODAL_OPENED",
				c = "HARBERGER_TAX__BANNER_PURCHASE_FAILURE",
				a = "HARBERGER_TAX__BANNER_PURCHASE_PENDING",
				d = "HARBERGER_TAX__BANNER_PURCHASE_SUCCESS",
				u = "HARBERGER_TAX__BANNER_UPDATE_FAILURE",
				l = "HARBERGER_TAX__BANNER_UPDATE_PENDING",
				b = "HARBERGER_TAX__BANNER_UPDATE_SUCCESS"
		},
		"./src/reddit/actions/header.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "j", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "HEADER__SUBSCRIPTIONS_PINNED",
				o = "HEADER__SUBSCRIPTIONS_UNPINNED",
				i = Object(r.a)(s),
				c = Object(r.a)(o),
				a = "HEADER__DROPDOWN_CLOSED",
				d = "HEADER__DROPDOWN_OPENED",
				u = "HEADER__DROPDOWN_TOGGLED",
				l = Object(r.a)(a),
				b = Object(r.a)(d),
				p = Object(r.a)(u)
		},
		"./src/reddit/actions/imageUploads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "m", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/sentry/index.ts"),
				o = n("./src/lib/uploadToS3/index.ts"),
				i = n("./src/reddit/helpers/getGenericUploadError.ts"),
				c = n("./src/reddit/models/Image/index.tsx"),
				a = n("./src/reddit/selectors/imageUploads.ts");
			const d = "IMAGE_UPLOADS__IMAGE_UPLOAD_PENDING",
				u = "IMAGE_UPLOADS__IMAGE_UPLOAD_LOADED",
				l = "IMAGE_UPLOADS__IMAGE_UPLOAD_SAVED",
				b = "IMAGE_UPLOADS__IMAGE_UPLOAD_FAILED",
				p = "IMAGE_UPLOADS__IMAGE_UPLOAD_CANCELED",
				m = Object(r.a)(d),
				f = Object(r.a)(u),
				g = Object(r.a)(l),
				O = Object(r.a)(b),
				h = Object(r.a)(p),
				y = async (e, t, n, r) => {
					if (!t.ok) throw Object(c.k)(n, t.error);
					let s, i = t.body;
					"s3UploadLease" in i && (i = i.s3UploadLease, s = t.body.websocketUrl);
					const a = await Object(o.a)(n.file, i);
					if (a.ok) {
						if (!e.imageUploads[n.id]) return void Object(c.d)(n);
						const t = decodeURIComponent(a.body.PostResponse.Location);
						return Object(c.n)(n, t, s, r)
					}
					throw Object(c.k)(n, a.error)
				};

			function j(e) {
				return e.split("/").pop()
			}
			const _ = (e, t) => new Promise((n, r) => {
					const o = Object(a.b)(e, t);
					if (!o.length) return n(null);
					const i = o[0].websocketUrl;
					if (!i) return r(new Error("ImageUploads: No websocket URL found"));
					const c = {};
					for (let e = 0; e < o.length; e++) {
						const t = o[e],
							n = j(t.url);
						c[n] = t
					}
					const d = o.length,
						u = new WebSocket(i);
					u.onopen = e => {
						u.onerror = null, n({
							websocket: u,
							imagesByKey: c,
							imageCount: d
						})
					}, u.onerror = e => {
						u.close();
						const t = new Error("ImageUploads: Failed to connect to websocket");
						s.c.captureException(t), r()
					}
				}),
				E = e => (t, n, r) => {
					let {
						apiContext: o
					} = r;
					return new Promise((n, r) => {
						const {
							websocket: o
						} = e;
						let {
							imageCount: a,
							imagesByKey: d
						} = e;

						function u() {
							for (const e in d) {
								const n = d[e],
									r = Object(c.o)(n, n.url);
								t(g(r))
							}
							n(), o.close()
						}
						d = Object.assign({}, d);
						let l = setTimeout(u, 6e4);
						o.onmessage = e => {
							clearTimeout(l);
							const r = JSON.parse(e.data);
							if (r && "success" === r.type) {
								const e = r.payload.url,
									n = j(e),
									s = d[n];
								if (!s) return;
								a -= 1, delete s[n];
								const o = Object(c.o)(s, e);
								t(g(o))
							} else {
								const e = j(r.payload.image_key),
									n = d[e];
								if (!n) return;
								a -= 1, delete n[e];
								const s = Object(i.a)(r.payload.image_key),
									o = Object(c.k)(n, s);
								t(O(o))
							}
							a ? l = setTimeout(u, 6e4) : (o.close(), n())
						}, o.onerror = e => {
							clearTimeout(l);
							const n = Object(i.a)("websocket");
							for (const r in d) {
								const e = d[r],
									s = Object(c.k)(e, n);
								t(O(s))
							}
							o.close();
							const a = new Error("ImageUploads: WebSocket connection failed before all messages received");
							s.c.captureException(a), r()
						}
					})
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "INCONTEXT__BANNED",
				o = "INCONTEXT__MUTED",
				i = Object(r.a)(s),
				c = Object(r.a)(o)
		},
		"./src/reddit/actions/inFeedChaining.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return _
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "e", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/telemetry/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				c = n("./src/reddit/actions/discoveryUnit.ts"),
				a = n("./src/reddit/actions/subreddit/similarSubreddit.ts"),
				d = n("./src/reddit/actions/subreddit/subredditPosts.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/inFeedChaining.ts"),
				b = n("./src/reddit/constants/page.ts"),
				p = n("./src/reddit/endpoints/subreddit/similar.ts"),
				m = n("./src/reddit/helpers/localStorage/index.ts"),
				f = n("./src/reddit/helpers/trackers/discoveryUnit.ts"),
				g = n("./src/reddit/i18n/utils.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/selectors/inFeedChaining.ts"),
				y = n("./src/reddit/selectors/posts.ts"),
				j = n("./src/reddit/selectors/subreddit.ts");
			const _ = "FEED_CHAINING__CHAIN_LOADED",
				E = Object(o.a)(_),
				v = e => {
					const t = Date.now() - e,
						n = Object(m.s)();
					return Object.keys(n).filter(e => n[e].when >= t).map(e => n[e])
				},
				I = e => {
					let {
						listingName: t,
						listingKey: n,
						postId: o
					} = e;
					return async (e, u) => {
						if (!o) return;
						if (!(t === b.g || t === b.c)) return;
						0 === v(s.db).length && Object(m.U)(!1);
						let g = u();
						if (Object(h.d)(g, {
								listingKey: n,
								postId: o
							}) || Object(h.a)(g).length >= l.a || Object(m.A)() || v(s.w).length >= l.a) return;
						const O = Object(y.x)(g, {
							listingKey: n,
							postId: o
						});
						if (O && O.isSponsored) return;
						await e(Object(c.h)()), g = u();
						const _ = Object(h.b)(g, {
							listingName: t
						});
						if (!_) return;
						const I = Object(y.U)(g, {
							postId: o
						});
						if (!I || Object(h.e)(g, {
								subredditId: I.id
							}) || (e => {
								return v(s.w).some(t => t.subredditId === e)
							})(I.id)) return;
						const S = {
							subredditIds: [I.id],
							count: l.b,
							variant: p.a.Factorization
						};
						await e(Object(a.b)(S));
						const T = Object(a.a)(S);
						g = u();
						const x = Object(j.x)(g, {
							key: T
						});
						0 !== x.length ? (await Promise.all(x.map(t => e((e => async (t, n) => {
							const r = s.Ob.DAY.toUpperCase(),
								o = Object(i.a)(e, s.N.TOP, {
									t: r
								});
							Object(y.C)(n(), {
								listingKey: o
							}).length > 0 || await t(Object(d.a)({
								range: r,
								sort: s.H.TOP,
								subredditName: e
							}))
						})(t.name)))), g = u(), Object(h.f)(g, {
							postId: o
						}).length < l.c ? Object(r.a)(Object(f.b)(_, "other", I)(g)) : (Object(m.a)(o, I.id), Object(r.a)(Object(f.c)(_, I)(g)), e(E({
							listingKey: n,
							postId: o
						})))) : Object(r.a)(Object(f.b)(_, "no_chaining", I)(g))
					}
				},
				S = "FEED_CHAINING__CHAIN_TOGGLED",
				T = (Object(o.a)(S), "FEED_CHAINING__CHAINING_TOGGLED"),
				x = Object(o.a)(T),
				C = () => async e => {
					Object(m.U)(!0), e(x({
						isDismissed: !0
					})), e(Object(u.e)(Object(u.d)(Object(g.c)("You'll see this less often."), O.b.Undo, Object(g.c)("Undo"), async () => {
						Object(m.U)(!1), e(x({
							isDismissed: !1
						}))
					})))
				}
		},
		"./src/reddit/actions/inbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "INBOX__COUNT_UPDATE",
				o = Object(r.a)(s)
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "JSAPI__CONSUMER_SUBSCRIBED",
				o = Object(r.a)(s)
		},
		"./src/reddit/actions/layers.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/toaster.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/graphql/operations/CreateLayer.json");
			var c = n("./src/reddit/endpoints/post/create.ts"),
				a = n("./src/reddit/i18n/utils.ts"),
				d = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/layers.ts");
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "l", (function() {
				return v
			}));
			const l = "SUBREDDIT__CREATE_LAYER",
				b = Object(r.a)(l),
				p = "SUBREDDIT__SAVE_LAYER_DRAFT",
				m = Object(r.a)(p),
				f = "SUBREDDIT__OPEN_LAYER_DRAFT",
				g = Object(r.a)(f),
				O = "SUBREDDIT__DELETE_LAYER_DRAFT",
				h = Object(r.a)(O),
				y = "SUBREDDIT__LAYER_SUBMIT_SUCCEEDED",
				j = Object(r.a)(y),
				_ = "SUBREDDIT__LAYER_SUBMIT_FAILED",
				E = Object(r.a)(_),
				v = e => async (t, n, r) => {
					let {
						gqlContext: l
					} = r;
					const b = new WebSocket(e),
						p = Object(u.a)(n()),
						m = () => {
							t(E());
							const e = Object(s.d)(Object(a.c)("Layer upload Error"), d.b.Error);
							t(Object(s.e)(e)), b.close()
						};
					b.onmessage = async e => {
						const n = JSON.parse(e.data),
							r = "success" === n.type ? n.payload.redirect : "",
							u = Object(c.e)(r);
						if (u && p) {
							if ((await ((e, t, n) => Object(o.a)(e, Object.assign({}, i, {
									variables: {
										postId: t,
										box: n
									}
								})))(l(), u, p)).ok) {
								t(j());
								const e = Object(s.d)(Object(a.c)("Layer has been successfully created"), d.b.SuccessCommunityGreen);
								return t(Object(s.e)(e)), void b.close()
							}
							m()
						} else m()
					}, b.onerror = m
				}
		},
		"./src/reddit/actions/leaderboard/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const r = "LEADERBOARD__DATE_RANGE_CHANGED",
				s = "LEADERBOARD__DATE_RANGE_FETCH_FAILURE",
				o = "LEADERBOARD__DATE_RANGE_FETCH_PENDING",
				i = "LEADERBOARD__DATE_RANGE_FETCH_SUCCESS"
		},
		"./src/reddit/actions/login.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			}));
			var r = n("./src/reddit/actions/modal.ts"),
				s = n("./src/reddit/actions/preferences.ts"),
				o = n("./src/reddit/constants/modals.ts"),
				i = n("./src/reddit/constants/postLayout.ts");
			const c = e => async (t, n) => {
				t(Object(r.i)(e)), !n().user.prefs.layout && t(Object(s.u)(i.d.Card))
			}, a = () => async (e, t) => {
				e(c(o.a.LOGIN_MODAL_ID))
			}, d = () => async e => {
				e(c(o.a.REGISTER_MODAL_ID))
			}, u = () => async e => {
				e(c(o.a.CHANGE_PASSWORD_MODAL_ID))
			}, l = () => async e => {
				e(c(o.a.ENABLE_TWO_FACTOR))
			}, b = () => async e => {
				e(c(o.a.DISABLE_TWO_FACTOR))
			}, p = () => async e => {
				e(c(o.a.TWO_FACTOR_BACKUP_CODES))
			}
		},
		"./src/reddit/actions/media.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/models/Media/index.ts"),
				u = n("./src/reddit/actions/video.ts");
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "f", (function() {
				return h
			}));
			const l = "MEDIA__SET_MUTE",
				b = Object(r.a)(l),
				p = "MEDIA__SET_VOLUME",
				m = Object(r.a)(p),
				f = (e, t) => async (n, r) => {
					n(b(e)), !e && t && n(Object(u.F)(t))
				}, g = "MEDIA__EMBED_HEIGHT_MEASURED", O = Object(r.a)(g), h = e => {
					let {
						height: t,
						isDeleted: n,
						postId: r
					} = e;
					return async (e, u, l) => {
						let {
							apiContext: b
						} = l;
						const p = u(),
							{
								media: m
							} = p.posts.models[r];
						e(O({
							height: t,
							isDeleted: n,
							postId: r
						})), null !== m && m.type === d.n.EMBED && m.provider === d.t.Twitter && m.height !== t && await ((e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
							endpoint: Object(a.a)("".concat(e.apiUrl, "/api/set_twitter")),
							method: s.bb.POST,
							data: {
								height: n,
								link: t
							}
						}))(b(), r.substr(3), t)
					}
				}
		},
		"./src/reddit/actions/meta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "META__GEO_CHANGED",
				o = Object(r.a)(s),
				i = "META__META_RECEIVED";
			Object(r.a)(i)
		},
		"./src/reddit/actions/modMode.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./node_modules/js-cookie/src/js.cookie.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/constants/cookie.ts");
			const a = "MOD_MODE_TOGGLED",
				d = Object(i.a)(a),
				u = e => async (t, n, r) => {
					let i, {
						apiContext: a
					} = r;
					if (void 0 !== e) i = e;
					else {
						i = "false" === s.a.get(c.c)
					}
					s.a.set(c.c, i, {
						domain: o.a.cookieDomain
					});
					(document.cookie.match(/mod_mode_enabled=/g) || []).length > 1 && s.a.set(c.c, "", {
						expires: 0,
						path: "/"
					});
					t(d({
						enabled: i
					}))
				}
		},
		"./src/reddit/actions/modQueue/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return r
			})), n.d(t, "i", (function() {
				return s
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "n", (function() {
				return d
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "o", (function() {
				return m
			})), n.d(t, "w", (function() {
				return f
			})), n.d(t, "v", (function() {
				return g
			})), n.d(t, "u", (function() {
				return O
			})), n.d(t, "t", (function() {
				return h
			})), n.d(t, "s", (function() {
				return y
			})), n.d(t, "r", (function() {
				return j
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "c", (function() {
				return I
			})), n.d(t, "d", (function() {
				return S
			}));
			const r = "MODQUEUE_PENDING",
				s = "MODQUEUE_LOADED",
				o = "MODQUEUE_FAILED",
				i = "EDITED_PENDING",
				c = "EDITED_LOADED",
				a = "EDITED_FAILED",
				d = "REPORTS_PENDING",
				u = "REPORTS_LOADED",
				l = "REPORTS_FAILED",
				b = "SPAM_PENDING",
				p = "SPAM_LOADED",
				m = "SPAM_FAILED",
				f = "UNMODERATED_PENDING",
				g = "UNMODERATED_LOADED",
				O = "UNMODERATED_FAILED",
				h = "UNDOACTION_PENDING",
				y = "UNDOACTION_LOADED",
				j = "UNDOACTION_FAILED",
				_ = "MORE_MODERATED_SUBREDDITS_LOADED",
				E = "ALL_MODERATED_COMMUNITIES_LOADED",
				v = "ADD_SELECTED_ITEMS",
				I = "BULK_SELECT_ITEMS",
				S = "BULK_UNSELECT_ITEMS"
		},
		"./src/reddit/actions/modal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "k", (function() {
				return y
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = (n("./src/reddit/actions/media.ts"), n("./src/reddit/constants/modals.ts")),
				o = n("./src/reddit/endpoints/user/index.ts"),
				i = n("./src/reddit/helpers/localStorage/index.ts"),
				c = n("./src/reddit/selectors/activeModalId.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const d = "MODAL_TOGGLED",
				u = Object(r.a)(d),
				l = "CLOSE_ALL_MODALS",
				b = Object(r.a)(l),
				p = "REDESIGN_MODAL_CLOSED",
				m = (Object(r.a)(p), e => async (t, n, r) => {
					Object(c.b)(e)(n()) && t(u(e))
				}),
				f = e => async (t, n, r) => {
					Object(c.b)(e)(n()) || t(u(e))
				}, g = () => async (e, t, n) => {
					Object(i.T)(s.a.REDESIGN_MODAL, !0), Object(a.K)(t()) && Object(o.e)(n.apiContext())
				}, O = "SET_ACCOUNT_MANAGER_MODAL_DATA";
			var h;
			! function(e) {
				e.Explore = "explore", e.HeaderLogin = "header_login", e.HeaderSignup = "header_signup", e.Hide = "hide", e.IdCard = "id_card", e.Post = "post", e.PromoBanner = "promo", e.Reply = "reply", e.Report = "report", e.SubredditLeaderboard = "subreddit_leaderboard", e.Save = "save", e.Subscribe = "subscribe", e.Vote = "vote"
			}(h || (h = {}));
			const y = Object(r.a)(O)
		},
		"./src/reddit/actions/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/profile/index.ts"),
				o = n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"),
				i = n("./src/reddit/models/User/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const a = "MOD_PERMS__REQUEST_LOADED",
				d = Object(r.a)("MOD_PERMS__REQUEST_PENDING"),
				u = Object(r.a)(a),
				l = Object(r.a)("MOD_PERMS__REQUEST_FAILED"),
				b = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					if (!s.user.account) return;
					if (s.isModeratorWithPostPerms) return;
					e(d());
					const i = await Object(o.a)(r());
					i.ok ? e(u(i.body)) : e(l(i.error))
				}, p = () => async (e, t) => {
					const n = Object(c.i)(t());
					if (n) {
						const t = Object(i.f)(n);
						await e(Object(s.b)(t))
					}
				}
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const r = "SUBREDDIT__MODERATION_LOG_LOADED",
				s = "SUBREDDIT__ALL_MODERATORS_LOADED"
		},
		"./src/reddit/actions/monthsToMinutes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "h", (function() {
				return y
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/constants/localStorage.ts"),
				o = n("./src/reddit/helpers/localStorage/index.ts"),
				i = n("./src/reddit/models/MonthsToMinutes/index.ts"),
				c = n("./src/reddit/selectors/monthsToMinutes.ts");
			const a = "M2M_SUBSCRIPTIONS_NAMES_LOADED",
				d = (Object(r.a)(a), "M2M_APPLY_LOGGED_OUT_VOTE"),
				u = Object(r.a)(d),
				l = "M2M_LOADED_FROM_LOCAL_STORAGE",
				b = Object(r.a)(l),
				p = "M2M_EXPAND_ACCOUNT_COMPLETENESS",
				m = (Object(r.a)(p), "M2M_COLLAPSE_ACCOUNT_COMPLETENESS"),
				f = Object(r.a)(m),
				g = "M2M_INIT_FROM_EMPTY_LOCAL_STORAGE",
				O = Object(r.a)(g),
				h = e => ({
					accountCompleteness: {
						collapsed: !1,
						step: i.a.Initial
					},
					homeFeed: {
						similar: [],
						topBanner: {
							isClosed: !1,
							viewsCount: 0
						},
						views: e.homeFeed.views,
						votes: {}
					},
					postsCount: 0,
					subreddits: e.subreddits,
					subscriptions: [],
					tooltip: {},
					views: e.views,
					votes: {
						comments: {},
						posts: {}
					}
				}),
				y = () => async (e, t) => {
					const n = t();
					try {
						const t = Object(o.n)(s.u);
						if (!t) return void e(O());
						const {
							loggedOutV4: r,
							loggedOutV5: a
						} = t;
						let d = null;
						if (a ? d = a : r && (d = (e => ({
								accountCompleteness: {
									collapsed: !1,
									step: i.a.Initial
								},
								homeFeed: {
									similar: [],
									topBanner: {
										isClosed: !1,
										viewsCount: 0
									},
									views: e.homeFeed.views,
									votes: e.homeFeed.votes
								},
								postsCount: 0,
								subreddits: e.subreddits,
								subscriptions: e.subscriptions,
								tooltip: {},
								views: e.views,
								votes: {
									comments: e.votes.comments,
									posts: e.votes.posts
								}
							}))(r)), !d) return void e(O());
						Object(c.w)(n) || (d = h(d)), e(b(d))
					} catch (r) {
						e(O())
					}
				}
		},
		"./src/reddit/actions/monthsToMinutes/accountCompleteness.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "M2M_SET_STEP",
				o = Object(r.a)(s)
		},
		"./src/reddit/actions/monthsToMinutes/homeFeed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "i", (function() {
				return _
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/discoveryUnit.ts"),
				o = n("./src/reddit/endpoints/category/subreddits.ts"),
				i = n("./src/reddit/endpoints/subreddit/similar.ts"),
				c = n("./src/reddit/models/MonthsToMinutes/index.ts"),
				a = n("./src/reddit/selectors/experiments/m2mHomeRedirect.ts"),
				d = n("./src/reddit/selectors/monthsToMinutes.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const l = "M2M_SUBREDDIT_VOTED",
				b = Object(r.a)(l),
				p = "M2M_SIMILAR_SUBREDDITS_LOADED",
				m = Object(r.a)(p),
				f = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = await Object(i.b)(s(), e);
					if (o.error) throw new Error(o.error.type);
					return o.body
				}, g = () => async (e, t) => {
					const n = t();
					if (!Object(d.o)(n)) return;
					if (Object(d.c)(n) !== c.a.Initial) return;
					const r = Object(d.F)(n);
					if (r.length >= c.c) return;
					const s = r.map(e => Object(u.G)(n, e)).filter(Boolean),
						l = c.c - s.length;
					try {
						const t = await e(f({
							count: l,
							subredditIds: s,
							variant: i.a.Factorization
						}));
						let r;
						if (Object(a.c)(n)) r = Object(o.b)(t);
						else {
							const n = await e(f({
									count: l,
									subredditIds: s,
									variant: i.a.CustomModRelevant
								})),
								c = Object(i.c)([t, n], l);
							r = Object(o.b)(c)
						}
						r.subredditIds.length > 0 && e(m(r))
					} catch (b) {}
				}, O = () => async (e, t) => {
					const n = t();
					if (Object(d.n)(n)) return;
					const r = Object(d.A)(n);
					if (0 === r.length) return;
					const o = r.filter(Boolean).join("+");
					await e(Object(s.j)(o))
				}, h = "M2M_CLOSE_HOME_FEED_TOP_BANNER", y = Object(r.a)(h), j = "M2M_VIEW_HOME_FEED_TOP_BANNER", _ = Object(r.a)(j)
		},
		"./src/reddit/actions/monthsToMinutes/initHomeFeed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			}));
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/monthsToMinutes/accountCompleteness.ts"),
				i = n("./src/reddit/actions/page.ts"),
				c = n("./src/reddit/actions/subscription/index.ts"),
				a = n("./src/reddit/constants/posts.ts"),
				d = n("./src/reddit/helpers/monthsToMinutes/index.ts"),
				u = n("./src/reddit/models/MonthsToMinutes/index.ts"),
				l = n("./src/reddit/selectors/monthsToMinutes.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/subscriptions.ts");
			const m = "M2M_SET_HOME_FEED",
				f = Object(s.a)(m),
				g = () => async (e, t) => {
					let n = t();
					if (!Object(l.n)(n)) {
						const r = Object(p.b)(n),
							s = Object(l.A)(n);
						if (r.length < u.c)
							for (const t of s) {
								const r = {
									name: t,
									type: a.a.SUBREDDIT
								};
								Object(b.cb)(n, {
									identifier: r
								}) || await e(Object(c.d)([r], !0))
							}
						e(f(s)), n = t(), Object(d.d)(n)
					}
				}, O = e => {
					let {
						shouldPrepareData: t = !0
					} = e;
					return async e => {
						t && e(g()), e(Object(o.b)(u.a.HomeVisited)), e(Object(i.y)()), e(Object(r.b)("/"))
					}
				}
		},
		"./src/reddit/actions/monthsToMinutes/post.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return g
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/monthsToMinutes/accountCompleteness.ts"),
				i = n("./src/reddit/actions/monthsToMinutes/homeFeed.ts"),
				c = n("./src/reddit/actions/monthsToMinutes/initHomeFeed.ts"),
				a = n("./src/reddit/actions/pages/subreddit.ts"),
				d = n("./src/reddit/models/MonthsToMinutes/index.ts"),
				u = n("./src/reddit/models/Subreddit/index.ts"),
				l = n("./src/reddit/selectors/experiments/m2mHomeRedirect.ts"),
				b = n("./src/reddit/selectors/monthsToMinutes.ts"),
				p = n("./src/reddit/selectors/posts.ts");
			const m = "M2M_POST_VIEWED",
				f = Object(s.a)(m),
				g = e => async (t, n) => {
					let s = n();
					if (!Object(b.w)(s)) return;
					const m = Object(p.U)(s, {
						postId: e
					});
					if (m && t(f({
							postId: e,
							subredditName: m.name
						})), Object(b.p)(s)) {
						await t(Object(i.g)()), s = n();
						const e = Object(l.f)(s);
						if (e && m && !Object(u.e)(m))
							if (Object(b.l)(s)) {
								t(Object(o.b)(d.a.BannerVisible)), await t(Object(c.c)()), s = n();
								const e = Object(b.e)(s);
								e && await t(Object(a.h)(e, {
									sort: r.N.HOT
								}))
							} else Object(l.e)(e) && await t(Object(a.h)(m.name, {
								sort: r.N.TOP
							}))
					}
				}
		},
		"./src/reddit/actions/monthsToMinutes/reset.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return d
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/page.ts"),
				o = n("./src/reddit/helpers/monthsToMinutes/index.ts"),
				i = n("./src/reddit/selectors/monthsToMinutes.ts");
			const c = "M2M_RESET",
				a = Object(r.a)(c),
				d = () => async (e, t) => {
					const n = Object(i.n)(t());
					e(a()), Object(o.a)(), n && e(Object(s.y)())
				}
		},
		"./src/reddit/actions/multireddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "q", (function() {
				return r
			})), n.d(t, "r", (function() {
				return s
			})), n.d(t, "s", (function() {
				return o
			})), n.d(t, "t", (function() {
				return i
			})), n.d(t, "u", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "p", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "A", (function() {
				return v
			})), n.d(t, "B", (function() {
				return I
			})), n.d(t, "z", (function() {
				return S
			})), n.d(t, "y", (function() {
				return T
			})), n.d(t, "v", (function() {
				return x
			})), n.d(t, "w", (function() {
				return C
			})), n.d(t, "x", (function() {
				return w
			})), n.d(t, "d", (function() {
				return P
			}));
			const r = "MULTIREDDIT__MORE_POSTS_FAILED",
				s = "MULTIREDDIT__MORE_POSTS_LOADED",
				o = "MULTIREDDIT__MORE_POSTS_PENDING",
				i = "MULTIREDDIT__MY_MULTIREDDITS_PENDING",
				c = "MULTIREDDIT__MY_MULTIREDDITS_RECEIVED",
				a = "MULTIREDDIT__CREATE_FAILURE",
				d = "MULTIREDDIT__CREATE_PENDING",
				u = "MULTIREDDIT__CREATE_SUCCESS",
				l = "MULTIREDDIT__DELETE_PENDING",
				b = "MULTIREDDIT__DELETE_SUCCESS",
				p = "MULTIREDDIT__DELETE_FAILURE",
				m = "MULTIREDDIT__DUPLICATE_PENDING",
				f = "MULTIREDDIT__DUPLICATE_SUCCESS",
				g = "MULTIREDDIT__DUPLICATE_FAILURE",
				O = "MULTIREDDIT__EDIT_FAILURE",
				h = "MULTIREDDIT__EDIT_PENDING",
				y = "MULTIREDDIT__EDIT_SUCCESS",
				j = "MULTIREDDIT__ADD_SUBREDDIT_FAILURE",
				_ = "MULTIREDDIT__ADD_SUBREDDIT_PENDING",
				E = "MULTIREDDIT__ADD_SUBREDDIT_SUCCESS",
				v = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_PENDING",
				I = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_SUCCESS",
				S = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_FAILURE",
				T = 10,
				x = "MULTIREDDIT__REMOVE_SUBREDDIT_FAILURE",
				C = "MULTIREDDIT__REMOVE_SUBREDDIT_PENDING",
				w = "MULTIREDDIT__REMOVE_SUBREDDIT_SUCCESS";
			var P;
			! function(e) {
				e.InvalidSrQuarantine = "INVALID_SR_QUARANTINE", e.TooManySubreddits = "MULTI_TOO_MANY_SUBREDDITS"
			}(P || (P = {}))
		},
		"./src/reddit/actions/multireddit/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/linkMatchers/customLinks.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/makeListingKey/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/page.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				p = n("./src/reddit/constants/parameters.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				O = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				h = n("./src/graphql/operations/AllUserMultireddits.json"),
				y = n("./src/lib/makeGqlRequest/index.ts"),
				j = (e, t) => Object(y.a)(e, Object.assign({}, h, {
					variables: t
				})),
				_ = n("./src/reddit/endpoints/page/multiredditListing.ts"),
				E = n("./src/graphql/operations/SubredditRecommendations.json"),
				v = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				S = n("./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts"),
				T = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				x = (n("./node_modules/core-js/modules/es6.regexp.split.js"), e => {
					let t = e.over_18 || !1;
					if (!t)
						for (const i of e.subreddits)
							if (i.data.over_18) {
								t = !0;
								break
							} let n = e.quarantine || !1;
					if (!n)
						for (const i of e.subreddits) {
							const e = (i.data.audience_target || "").split(",");
							if (i.data.quarantine || e.indexOf("unsafe") > -1) {
								n = !0;
								break
							}
						}
					const r = e.subreddits.map(e => {
							const t = e.data,
								{
									name: n,
									display_name: r
								} = t;
							return {
								id: n,
								displayName: r.toLowerCase()
							}
						}).sort((e, t) => e.displayName.localeCompare(t.displayName)),
						s = r.filter(e => !e.displayName.startsWith(i.Qb)).map(e => e.id),
						o = r.filter(e => e.displayName.startsWith(i.Qb)).map(e => e.id);
					return {
						created: e.created_utc,
						description: e.description_md,
						descriptionHtml: e.description_html,
						descriptionRtJson: null,
						displayText: e.display_name,
						followerCount: e.num_subscribers,
						icon: e.icon_url,
						isFavorited: !!e.is_favorited,
						isFollowed: !1,
						isNSFW: t,
						isQuarantined: n,
						name: e.name,
						ownerId: e.owner_id,
						profileIds: o,
						subredditCount: e.subreddits.length,
						subredditIds: s,
						url: e.path.toLowerCase(),
						visibility: e.visibility
					}
				}),
				C = n("./src/reddit/i18n/utils.ts"),
				w = n("./src/reddit/models/Multireddit/index.ts"),
				P = n("./src/reddit/models/Toast/index.ts"),
				D = n("./src/reddit/selectors/multireddit.ts"),
				R = n("./src/reddit/selectors/platform.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/selectors/user.ts"),
				N = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				L = n("./src/reddit/actions/multireddit/constants.ts");
			n.d(t, "f", (function() {
				return B
			})), n.d(t, "g", (function() {
				return q
			})), n.d(t, "b", (function() {
				return Y
			})), n.d(t, "d", (function() {
				return Z
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "i", (function() {
				return ie
			})), n.d(t, "c", (function() {
				return ue
			})), n.d(t, "e", (function() {
				return me
			})), n.d(t, "h", (function() {
				return he
			}));
			const M = Object(a.a)(L.q),
				U = Object(a.a)(L.r),
				F = Object(a.a)(L.s),
				B = e => async (t, n, r) => {
					const {
						gqlContext: s
					} = r, {
						sort: o = i.N.HOT,
						multiredditName: c,
						username: a
					} = e, u = n(), l = u.platform.currentPage, b = l ? l.queryParams : {}, p = Object(D.d)(u, {
						multiredditName: c,
						username: a
					}), m = Object(d.a)(p.url, o, b), f = u.listings.postOrder.loadMore[m];
					if (!f) return;
					const g = u.listings.postOrder.api.pending[m],
						O = u.listings.postOrder.fetchedTokens,
						h = O[m] && O[m][f.token] || !1;
					if (g || h) return;
					t(F({
						key: m,
						fetchedToken: f.token
					}));
					const y = p.url.replace(/\/$/, ""),
						j = b.t ? b.t.toUpperCase() : void 0,
						E = {
							after: f.token,
							includeIdentity: !1,
							includeSources: !1,
							path: y,
							range: j,
							sort: o.toUpperCase()
						},
						I = await Object(_.a)(s(), E),
						{
							data: T
						} = I.body,
						x = Object(S.a)(T);
					I.ok && T && T.multireddit ? t(U(Object.assign({
						fetchedToken: f.token,
						key: m,
						meta: u.meta
					}, x, Object(v.a)(u, m, x), {
						multiredditsModelsState: u.multireddits.models
					}))) : t(M(Object.assign({
						error: {
							type: i.D.NOT_FOUND_ERROR
						},
						fetchedToken: f.token,
						key: m
					}, I.body, Object(v.a)(u, m, x))))
				}, G = Object(a.a)(L.t), V = Object(a.a)(L.u), q = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, r, s) => {
						let {
							apiContext: o,
							gqlContext: i
						} = s;
						const c = r();
						if (!Object(k.i)(c)) return;
						if (!e && Object(D.h)(c) || Object(D.i)(c)) return;
						n(G());
						const a = await j(i(), {
							includeSources: t
						});
						if (a.ok) {
							const e = a.body.data.identity.allMultireddits.edges.map(e => e.node),
								t = Object(I.b)(e);
							n(V(Object.assign({}, t, {
								multiredditsModelsState: c.multireddits.models
							})))
						}
					}
				}, H = Object(a.a)(L.e), K = Object(a.a)(L.f), W = Object(a.a)(L.g), Y = e => {
					let {
						description: t,
						displayName: n,
						shouldNavigate: r
					} = e;
					return async (e, s, c) => {
						let {
							apiContext: a
						} = c;
						const d = s(),
							l = Object(k.i)(d);
						if (!l) return;
						e(K());
						const p = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: Object(O.a)("".concat(e.apiUrl, "/api/multi")),
							data: {
								model: JSON.stringify({
									description_md: n,
									display_name: t,
									visibility: "private",
									subreddits: []
								})
							},
							method: i.bb.POST
						}))(a(), n, t);
						if (p.ok) {
							const {
								id: t
							} = l;
							if (await e(W({
									multireddit: x(p.body.data),
									multiredditsModelsState: d.multireddits.models,
									userId: t
								})), r) {
								e(Object(u.f)());
								const t = p.body.data.path.toLowerCase();
								await e(Object(o.b)(t))
							}
							e(Object(b.e)({
								text: Object(C.c)("Custom feed created!")
							}))
						} else e(H(p.error))
					}
				}, z = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t(),
						c = Object(k.i)(o),
						a = Object(R.i)(o) ? Object(R.m)(o) : Object(R.b)(o),
						u = a && a.routeMatch && a.routeMatch.match;
					if (!u) return;
					const b = u.params,
						m = b.sort || i.N.HOT,
						{
							multiredditName: f,
							username: g
						} = b;
					if (!f) return;
					const O = Object(w.h)((g || c && c.displayText || "").toLowerCase(), f.toLowerCase()),
						{
							queryParams: h
						} = u,
						y = Object(d.a)(O, m, h),
						j = p.t in h && h[p.t].toUpperCase() || "",
						_ = i.Ob[j] || !1,
						E = Object(k.i)(o);
					(g || E && E.displayText) && await e(Object(l.C)(y, (g || E.displayText).toLowerCase(), f.toLowerCase(), Object.assign({}, s()(h, p.k), s()(h, p.j), {
						sort: m,
						t: Object(N.a)(m, _)
					})))
				}, J = Object(a.a)(L.k), Q = Object(a.a)(L.l), X = Object(a.a)(L.m), Z = e => {
					let {
						description: t,
						displayName: n,
						fromName: r,
						fromUsername: s
					} = e;
					return async (e, c, a) => {
						let {
							apiContext: d
						} = a;
						const l = c(),
							p = Object(k.i)(l);
						if (!p || !p.displayText) return;
						const h = Object(w.h)((s || p.displayText).toLowerCase(), r.toLowerCase());
						e(Q());
						const y = await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: Object(O.a)("".concat(e.apiUrl, "/api/multi/copy")),
							data: {
								description_md: t.description,
								display_name: t.displayName,
								expand_srs: !0,
								from: t.from
							},
							method: i.bb.POST
						}))(d(), {
							from: h,
							displayName: n,
							description: t
						});
						if (y.ok) {
							const t = x(y.body.data);
							e(Object(u.f)()), e(X({
								multireddit: t,
								multiredditsModelsState: l.multireddits.models,
								userId: p.id
							})), e(Object(b.e)({
								text: Object(C.c)("Custom feed duplicated!"),
								buttonText: Object(C.c)("Go there"),
								buttonAction: Object(o.b)(t.url)
							}))
						} else e(J(y.error)), e(Object(b.e)({
							text: Object(C.c)("Something went wrong duplicating ".concat(Object(C.b)("multiName", r)))
						}))
					}
				}, $ = Object(a.a)(L.b), ee = Object(a.a)(L.c), te = Object(a.a)(L.a), ne = e => {
					let {
						communityInfo: t,
						identifier: n,
						multiredditNames: r
					} = e;
					return async (e, s, o) => {
						let {
							apiContext: a
						} = o;
						const d = s(),
							l = Object(k.i)(d);
						if (!l || d.multireddits.api.addSubreddit.pending) return;
						e($({
							name: n.name
						}));
						const {
							displayText: p
						} = l;
						if (!p) return;
						const h = r.map(e => "/user/".concat(p.toLowerCase(), "/m/").concat(e.toLowerCase())).join(","),
							y = "".concat("profile" === n.type ? i.Qb : "").concat(n.name),
							j = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
								endpoint: Object(O.a)("".concat(e.apiUrl, "/api/multi/bulk_add/r/").concat(t)),
								data: {
									paths: n
								},
								method: i.bb.PUT
							}))(a(), y, h);
						if (j.ok) {
							const s = Object(A.L)(d, {
									identifier: n
								}) || t && t.id || "",
								o = r.map(e => Object(w.h)(p, e));
							e(Object(u.f)()), e(Object(b.e)({
								text: Object(C.c)("Successfully added ".concat(Object(C.b)("prefix", "subreddit" === n.type ? c.d.subreddit : c.d.profile)).concat(Object(C.b)("communityname", n.name), " to ").concat(Object(C.b)("numcommunities", r.length), " custom ").concat(Object(C.a)("feeds", ["feed", "feeds"], r.length), "!"))
							})), await e(ee({
								communityInfo: t,
								id: s,
								multipaths: o,
								type: n.type
							})), 1 === r.length && await e(z())
						} else {
							e(te(j.error));
							let t = Object(C.c)("Sorry, something went wrong adding ".concat(Object(C.b)("subredditName", n.name), "."));
							j.body && (j.body.reason === L.d.TooManySubreddits ? t = Object(C.c)("Maximum communities reached") : j.body.reason === L.d.InvalidSrQuarantine && (t = Object(C.c)("".concat(Object(C.b)("prefix", "subreddit" === n.type ? c.d.subreddit : c.d.profile)).concat(Object(C.b)("communityname", n.name), " is invalid because it is quarantined")))), e(Object(b.e)({
								text: t,
								kind: P.b.Error
							}))
						}
					}
				}, re = Object(a.a)(L.w), se = Object(a.a)(L.x), oe = Object(a.a)(L.v), ie = e => {
					let {
						id: t,
						multiredditName: n,
						name: r,
						type: s
					} = e;
					return async (e, o, c) => {
						let {
							apiContext: a
						} = c;
						const d = o(),
							l = Object(k.i)(d);
						if (!l || !l.displayText || d.multireddits.api.removeSubreddit.pending) return;
						e(re({
							id: t
						}));
						const {
							displayText: p
						} = l, h = Object(w.h)(p, n), y = "".concat("profile" === s ? i.Qb : "").concat(r), j = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: Object(O.a)("".concat(e.apiUrl, "/api/multi").concat(n, "r/").concat(t)),
							method: i.bb.DELETE
						}))(a(), y, h);
						j.ok ? (e(Object(u.f)()), e(se({
							id: t,
							multipath: h,
							type: s
						})), e(Object(b.e)({
							text: Object(C.c)("".concat(Object(C.b)("subredditname", r), " removed from your custom feed!")),
							buttonText: Object(C.c)("undo"),
							buttonAction: ne({
								identifier: {
									name: r,
									type: s
								},
								multiredditNames: [n]
							})
						})), e(z())) : (e(oe(j.error)), e(Object(b.e)({
							text: Object(C.c)("Sorry, something went wrong removing ".concat(Object(C.b)("subredditName", r), "."))
						})))
					}
				}, ce = Object(a.a)(L.h), ae = Object(a.a)(L.i), de = Object(a.a)(L.j), ue = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const c = n();
					if (!Object(k.i)(c)) return;
					t(ae());
					const a = await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), {
						endpoint: Object(O.a)("".concat(e.apiUrl, "/api/multi").concat(t)),
						method: i.bb.DELETE
					}))(s(), e);
					a.ok ? (await t(de(e)), t(Object(u.f)()), await t(Object(o.b)("/")), t(Object(b.e)({
						text: Object(C.c)("Custom feed deleted!")
					}))) : t(ce(a.error))
				}, le = Object(a.a)(L.n), be = Object(a.a)(L.o), pe = Object(a.a)(L.p), me = e => {
					let {
						description: t,
						displayText: n,
						multipath: r,
						visibility: s
					} = e;
					return async (e, o, c) => {
						let {
							apiContext: a
						} = c;
						const d = o();
						if (!Object(k.K)(d)) return;
						e(be());
						const l = await (e => {
							let {
								context: t,
								description: n,
								displayText: r,
								multipath: s,
								visibility: o
							} = e;
							return Object(m.b)(Object(f.a)(t, [g.a]), {
								endpoint: Object(O.a)("".concat(t.apiUrl, "/api/multi").concat(s)),
								data: {
									model: JSON.stringify({
										description_md: n,
										display_name: r,
										visibility: o
									}),
									expand_srs: !0
								},
								method: i.bb.PUT
							})
						})({
							context: a(),
							description: t,
							displayText: n,
							multipath: r,
							visibility: s
						});
						l.ok ? (await e(pe(x(l.body.data))), e(Object(u.f)()), e(Object(b.e)({
							text: Object(C.c)("Custom feed updated!")
						}))) : (e(le(l.error)), e(Object(b.e)({
							kind: P.b.Error,
							text: Object(C.c)("Something went wrong")
						})))
					}
				}, fe = Object(a.a)(L.z), ge = Object(a.a)(L.A), Oe = Object(a.a)(L.B), he = e => {
					let {
						multiredditName: t,
						username: n,
						toExcludeNames: r
					} = e;
					return async (e, s, o) => {
						let {
							gqlContext: i
						} = o;
						const c = s(),
							a = Object(k.i)(c);
						if (!(n || a && a.displayText)) return;
						const d = Object(w.h)(n || a.displayText, t),
							u = c.multireddits.models[d];
						if (!u || !u.subredditIds) return;
						e(ge());
						const l = r && r.reduce((e, t) => {
								const n = Object(A.G)(c, t) || Object(A.H)(c, t);
								return n ? [...e, n] : e
							}, []),
							b = await ((e, t) => Object(y.a)(e, Object.assign({}, E, {
								variables: t
							})))(i(), {
								count: L.y,
								subredditIds: u.subredditIds,
								toExclude: l
							});
						if (b.ok) {
							const {
								data: t
							} = b.body;
							e(Oe({
								multipath: d,
								subreddits: Object(T.b)(t)
							}))
						} else e(fe(b.error))
					}
				}
		},
		"./src/reddit/actions/notificationBanner.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "NOTIFICATION_BANNER_SET",
				o = "NOTIFICATION_BANNER_DISMISSED",
				i = Object(r.a)(s),
				c = Object(r.a)(o)
		},
		"./src/reddit/actions/notifications/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "p", (function() {
				return i
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "o", (function() {
				return d
			})), n.d(t, "n", (function() {
				return u
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "i", (function() {
				return y
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "NOTIFICATIONS__SHOW_NOTIFICATION_PROMPT",
				o = "NOTIFICATIONS__HIDE_NOTIFICATION_PROMPT",
				i = Object(r.a)(s),
				c = (Object(r.a)(o), "NOTIFICATIONS__PERMISSION_GRANTED"),
				a = "NOTIFICATIONS__PERMISSION_DENIED",
				d = Object(r.a)("NOTIFICATIONS__PERMISSION_PENDING"),
				u = Object(r.a)(c),
				l = Object(r.a)(a);
			var b, p;
			! function(e) {
				e[e.NotificationsSupported = 0] = "NotificationsSupported", e[e.BrowserUnsupported = 1] = "BrowserUnsupported", e[e.LocalStorageUnavailable = 2] = "LocalStorageUnavailable", e[e.NotAllRequiredAPIsSupported = 3] = "NotAllRequiredAPIsSupported"
			}(b || (b = {})),
			function(e) {
				e.Granted = "granted", e.Denied = "denied", e.Closed = "closed", e.Default = "default"
			}(p || (p = {}));
			const m = "PUSH__GET_PREFERENCES_PENDING",
				f = "PUSH__GET_PREFERENCES_LOADED",
				g = "PUSH__GET_PREFERENCES_FAILED",
				O = "PUSH__SET_PREFERENCES_PENDING",
				h = "PUSH__SET_PREFERENCES_LOADED",
				y = "PUSH__SET_PREFERENCES_FAILED"
		},
		"./src/reddit/actions/nps.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/config.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts");
			var d = n("./node_modules/@r/frames/compiled.js"),
				u = n("./node_modules/lodash/debounce.js"),
				l = n.n(u),
				b = function(e) {
					document.body.appendChild(function(e) {
						let t;
						const n = l()((function() {
							t && t.contentWindow && d.postMessage(t.contentWindow, "resize.asknicely")
						}), 500);
						return function() {
							return t = function() {
								const t = document.createElement("iframe");
								return t.src = e, t.setAttribute("allowTransparency", "true"), t.style.display = "block", t.style.width = "100%", t.style.height = "1px", t.style.background = "transparent", t.style.border = "none", t
							}(), d.listen("embedjail"), d.receiveMessage(t.contentWindow, "open.embedjail", (function(e) {
								var r;
								r = e.detail, t.style.width = r.dimensions.width, t.style.height = r.dimensions.height, t.style.display = "block", t.style.position = "fixed", t.style.bottom = 0, t.style.zIndex = 2147483647, window.addEventListener("resize", n)
							})), d.receiveMessage(t.contentWindow, "close.embedjail", (function(e) {
								t.parentElement.removeChild(t), d.stopListening("asknicely"), window.removeEventListener("resize", n), t = void 0
							})), window.addEventListener("message", (function(e) {
								"https://live.asknice.ly" !== e.origin && "https://reddit.asknice.ly" !== e.origin || e.data && t && t.contentWindow && d.postMessage(t.contentWindow, e.data + ".asknicely")
							})), t
						}
					}(e)())
				};
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "d", (function() {
				return j
			}));
			const p = "NPS__URL_PENDING",
				m = "NPS__URL_LOADED",
				f = "NPS__URL_FAILED",
				g = Object(r.a)(p),
				O = Object(r.a)(m),
				h = Object(r.a)(f);
			let y = !1;
			const j = () => async (e, t, n) => {
				const r = t();
				if (r.nps.pending) return;
				if (y) return;
				e(g());
				const d = r.platform.currentPage && r.platform.currentPage.queryParams.feature || "",
					u = !!r.user.account,
					l = await ((e, t, n) => Object(i.b)(Object(c.a)(e, [a.a]), {
						data: {
							feature: t,
							app_name: "web2x"
						},
						endpoint: "".concat(n ? s.a.oauthUrl : s.a.apiUrl, "/api/jail/asknicely").concat(n ? "" : ".json"),
						method: o.bb.GET
					}))(n.apiContext(), d, u);
				if (l.ok) {
					const t = l.body;
					t.dest ? (e(O(t)), b(t.dest), y = !0) : e(h())
				} else e(h())
			}
		},
		"./src/reddit/actions/oldSiteRules.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return u
			}));
			const a = "OLD_SITE_RULES_LOADED",
				d = Object(r.a)(a),
				u = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const a = await (e => Object(o.b)(Object(i.a)(e, [c.a]), {
						endpoint: "".concat(e.apiUrl, "/api/site_rules.json"),
						method: s.bb.GET
					}))(r());
					if (a.ok) {
						const {
							site_rules: t
						} = a.body;
						e(d({
							oldSiteRules: t
						}))
					}
				}
		},
		"./src/reddit/actions/otherDiscussions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./src/lib/constants/index.ts");
			const s = e => e.includes("/".concat(r.xb.DUPLICATES, "/")),
				o = e => e.replace("/comments/", "/duplicates/"),
				i = "OTHER_DISCUSSIONS_POSTS_FAILED",
				c = "OTHER_DISCUSSIONS_POSTS_LOADED",
				a = "OTHER_DISCUSSIONS_POSTS_PENDING"
		},
		"./src/reddit/actions/page.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/app/strings/index.ts"),
				c = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/lib/getParsedUserAgent/index.ts"),
				d = n("./src/lib/truncateText/index.ts"),
				u = n("./src/reddit/actions/category.ts"),
				l = n("./src/reddit/actions/discoveryUnit.ts"),
				b = n("./src/reddit/actions/focusedVerticals/index.ts"),
				p = n("./src/reddit/actions/monthsToMinutes/post.ts"),
				m = n("./src/reddit/actions/multireddit/index.ts"),
				f = n("./src/lib/makeActionCreator/index.ts"),
				g = n("./src/lib/makeListingKey/index.ts"),
				O = n("./src/reddit/actions/otherDiscussions/constants.ts"),
				h = n("./src/lib/makeGqlRequest/index.ts"),
				y = n("./src/graphql/operations/OtherDiscussions.json"),
				j = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				I = n("./src/reddit/models/Post/index.ts");
			const S = Object(f.a)(O.a),
				T = Object(f.a)(O.b),
				x = Object(f.a)(O.c),
				C = (e, t) => async (n, r, s) => {
					let {
						gqlContext: o
					} = s;
					const i = r(),
						c = Object(g.a)(e, null, {
							isOtherDiscussions: !0
						}),
						a = i.listings.postOrder.ids[c],
						d = !!i.listings.postOrder.api.error[c];
					if (a && !d) return;
					n(x({
						key: c
					}));
					const u = await ((e, t) => Object(h.a)(e, Object.assign({}, y, {
						variables: t
					})))(o(), t);
					if (!u.ok) return void n(S(u.error));
					const l = u.body,
						b = l && l.data && l.data.post;
					if (!b) return void n(T({
						count: 0,
						key: c,
						meta: i.meta,
						postFlair: {},
						postId: e,
						postIds: [],
						posts: {},
						profiles: {},
						subreddits: {}
					}));
					const {
						otherDiscussions: p,
						otherDiscussionsCount: m
					} = b, {
						postFlair: f,
						postIds: O,
						posts: C,
						profiles: w,
						subreddits: P
					} = (e => {
						const t = {
								postFlair: {},
								postIds: [],
								posts: {},
								profiles: {},
								subreddits: {}
							},
							n = e => {
								const n = Object(_.d)(e);
								t.posts[n.id] = n;
								const {
									crosspostRoot: r
								} = e;
								if (r && r.type === I.a.Post && r.postInfo) {
									const e = Object(_.d)(r.postInfo);
									t.posts[e.id] = e
								}
								switch (e.__typename) {
									case I.f.ProfilePost:
										t.profiles[e.profile.id] || (t.profiles[e.profile.id] = Object(E.a)(e.profile));
										break;
									case I.f.SubredditPost:
										t.subreddits[e.subreddit.id] || (t.subreddits[e.subreddit.id] = Object(v.a)(e.subreddit)), t.postFlair[e.subreddit.id] || (t.postFlair[e.subreddit.id] = Object(j.a)(e.subreddit))
								}
								return n.id
							};
						if (e && e.edges)
							for (const {
									node: r
								} of e.edges) {
								const e = n(r);
								e && t.postIds.push(e)
							}
						return t
					})(p), D = {
						count: m,
						key: c,
						meta: i.meta,
						postFlair: f,
						postId: e,
						postIds: O,
						posts: C,
						profiles: w,
						subreddits: P
					};
					n(T(D))
				};
			var w = n("./src/reddit/actions/pages/subreddit.ts"),
				P = n("./src/reddit/actions/pages/userDataRequest/index.ts"),
				D = n("./src/reddit/actions/railsWidgets.ts"),
				R = n("./src/reddit/actions/shortcuts.ts"),
				A = n("./src/reddit/actions/subredditSettings.ts"),
				k = n("./src/reddit/components/GildModal/getGildModalId.ts"),
				N = n("./src/reddit/constants/thumbnails.ts"),
				L = n("./src/reddit/endpoints/governance/posts.ts"),
				M = n("./src/reddit/endpoints/page/commentsPage.ts"),
				U = n("./src/reddit/endpoints/page/frontpage.ts"),
				F = n("./src/reddit/endpoints/page/multiredditListing.ts"),
				B = n("./src/reddit/endpoints/page/subredditPage.ts"),
				G = n("./src/reddit/i18n/utils.ts"),
				V = n("./src/lib/constants/index.ts"),
				q = (n("./src/lib/makeDraftKey/index.ts"), n("./src/lib/opener/index.ts")),
				H = n("./src/reddit/models/Gold/Coins/index.ts"),
				K = (n("./src/reddit/models/PostDraft/index.ts"), n("./src/reddit/actions/dashboard.ts"), n("./src/reddit/actions/economics/helpers/async.ts")),
				W = n("./src/reddit/actions/externalAccount.ts"),
				Y = n("./src/reddit/actions/gold/modals.ts"),
				z = n("./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts"),
				J = n("./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts"),
				Q = n("./src/reddit/actions/login.ts"),
				X = n("./src/reddit/actions/moderatingSubreddits.ts"),
				Z = (n("./src/reddit/actions/monthsToMinutes/accountCompleteness.ts"), n("./src/reddit/actions/platform.ts")),
				$ = n("./src/reddit/endpoints/me/index.ts"),
				ee = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				te = n("./src/reddit/actions/pages/appeal/constants.ts");
			const ne = Object(f.a)(te.b),
				re = Object(f.a)(te.a);
			var se = n("./src/reddit/actions/post.ts"),
				oe = n("./src/reddit/actions/profile/index.ts"),
				ie = n("./src/reddit/actions/redditEmbed.ts"),
				ce = n("./src/reddit/actions/subreddit.ts"),
				ae = n("./src/reddit/actions/toaster.ts"),
				de = n("./src/reddit/actions/users.ts"),
				ue = n("./src/reddit/constants/adEvents.ts"),
				le = n("./src/reddit/constants/experiments.ts"),
				be = n("./src/reddit/constants/graphql.ts"),
				pe = n("./src/reddit/constants/listings.ts"),
				me = n("./src/reddit/constants/page.ts"),
				fe = n("./src/reddit/constants/parameters.ts"),
				ge = n("./src/reddit/constants/postLayout.ts"),
				Oe = n("./src/reddit/constants/posts.ts"),
				he = n("./src/reddit/contexts/PageLayer/index.tsx");
			const ye = new Set(["t2_hp82e"]);
			var je = n("./src/reddit/helpers/commentList/index.ts"),
				_e = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				Ee = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				ve = n("./src/reddit/helpers/graphql/normalizeFrontpageFromGql/index.ts"),
				Ie = n("./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts"),
				Se = n("./src/reddit/helpers/pixels.ts"),
				Te = n("./src/reddit/models/Comment/index.ts"),
				xe = n("./src/reddit/models/Multireddit/index.ts"),
				Ce = n("./src/reddit/models/Subreddit/index.ts"),
				we = n("./src/reddit/models/Toast/index.ts"),
				Pe = n("./src/reddit/models/User/index.ts"),
				De = n("./src/reddit/selectors/category.ts"),
				Re = n("./src/reddit/selectors/experiments/categoriesPlacement.ts"),
				Ae = n("./src/reddit/selectors/experiments/exploreV2.ts"),
				ke = n("./src/reddit/selectors/experiments/frontpageSignup.ts"),
				Ne = n("./src/reddit/selectors/experiments/postSeo.ts"),
				Le = n("./node_modules/reselect/es/index.js"),
				Me = n("./src/reddit/helpers/chooseVariant/index.ts"),
				Ue = n("./src/reddit/selectors/experiments/utils.ts"),
				Fe = n("./src/reddit/selectors/platform.ts");
			var Be = n("./src/reddit/selectors/subreddit.ts"),
				Ge = n("./src/reddit/selectors/user.ts");
			const Ve = Object(Le.a)(Ge.J, Be.M, Fe.i, Ne.d, e => {
					const t = (e => e.seo.crawler)(e);
					return t && t.name || null
				}, (e, t, n, r, s) => !!s && !e && !n && r && !Object(Ce.e)(t)),
				qe = Object(Le.a)((e, t) => Object(Me.c)(e, {
					experimentEligibilitySelector: e => Ve(e, t),
					experimentName: le.Ab
				}), Ue.a);
			var He = n("./src/reddit/selectors/frontpage.ts"),
				Ke = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				We = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				Ye = n("./src/reddit/selectors/monthsToMinutes.ts"),
				ze = n("./src/reddit/selectors/multireddit.ts"),
				Je = n("./src/reddit/selectors/posts.ts"),
				Qe = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				Xe = n("./src/lib/makeCommentsPageKey/index.ts"),
				Ze = n("./src/lib/matchRoute/index.ts"),
				$e = n("./src/reddit/actions/ads/index.ts"),
				et = n("./src/reddit/featureFlags/index.ts"),
				tt = n("./src/reddit/helpers/canonicalUrls.ts"),
				nt = n("./src/lib/sentry/index.ts"),
				rt = (n("./node_modules/core-js/modules/es6.regexp.constructor.js"), n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/lodash/get.js")),
				st = n.n(rt),
				ot = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const it = {
				path: "",
				extraKeys: ["id"],
				disableExtra: !1,
				replaceMissedObject: !1
			};
			var ct;
			! function(e) {
				e.NotEqual = "ne", e.Missed = "m", e.Length = "l"
			}(ct || (ct = {}));
			const at = e => null !== e && !Array.isArray(e) && "object" == typeof e,
				dt = (e, t, n) => {
					let {
						disableExtra: r,
						extraKeys: s
					} = n;
					return r || !at(t) ? e : s.reduce((e, n) => "".concat(e).concat(t[n] ? ",".concat(n, "=").concat(t[n]) : ""), e)
				},
				ut = (e, t, n) => n ? "".concat(e, "[").concat(t, "]") : "".concat((e && "".concat(e, ".")) + t),
				lt = e => at(e) ? "[Object]" : e,
				bt = e => {
					const {
						o1: t,
						o2: n,
						path: r,
						diffs: s = [],
						replaceMissedObject: o
					} = e, i = ot(e, ["o1", "o2", "path", "diffs", "replaceMissedObject"]);
					if (Array.isArray(t) && Array.isArray(n)) return t.length !== n.length ? [...s, {
						k: ct.Length,
						p: r,
						o1: t,
						o2: n
					}] : t.reduce((s, o, c) => [...s, ...bt(Object.assign({}, e, {
						o1: t[c],
						o2: n[c],
						path: ut(r, dt(c, t[c] || n[c], i), !0)
					}))], s);
					if (at(t) && at(n)) {
						let i = s;
						const c = [];
						for (const s in t) c.push(s), i = i.concat(n.hasOwnProperty(s) ? bt(Object.assign({}, e, {
							o1: t[s],
							o2: n[s],
							path: ut(r, s)
						})) : {
							k: ct.Missed,
							p: ut(r, s),
							o1: o ? lt(t[s]) : t[s]
						});
						for (const e in n) c.includes(e) || i.push({
							k: ct.Missed,
							p: ut(r, e),
							o2: o ? lt(n[e]) : n[e]
						});
						return i
					}
					return t !== n ? [...s, {
						k: ct.NotEqual,
						p: r,
						o1: t,
						o2: n
					}] : s
				},
				pt = e => e[0] instanceof RegExp,
				mt = (e, t) => {
					let [n, r] = e;
					return n.test(t.p) && r(t.o1, t.o2)
				},
				ft = (e, t, n) => {
					const r = e.shift();
					if (!r || !mt(r, t)) return !1;
					for (const [s, o] of e) {
						const e = s.exec(t.p);
						if (!e || !o(st()(n.expected, e[0]), st()(n.actual, e[0]))) return !1
					}
					return !0
				},
				gt = e => {
					if (Array.isArray(e)) return e.reduce((e, t) => e + gt(t), e.length);
					if (!at(e)) return 0;
					const t = Object.keys(e);
					return t.reduce((t, n) => t + gt(e[n]), t.length)
				},
				Ot = /^(account|posts|preferences|profiles|subreddits)\.(?:(t\d{1}_[a-zA-Z0-9]+)\.)?.*$/;
			var ht, yt = (e, t) => bt(Object.assign({}, it, {
					o1: e,
					o2: t
				})),
				jt = n("./src/telemetry/index.ts"),
				_t = n("./src/lib/base64/index.ts"),
				Et = n("./src/lib/makeRequest/index.ts");
			! function(e) {
				e.NumberOfDiffs = "numberOfDiffs", e.DetailedDiffs = "detailedDiffs"
			}(ht || (ht = {}));
			const vt = e => {
				switch (e) {
					case ht.NumberOfDiffs:
						return V.t.NUMBER_OF_DIFFS;
					case ht.DetailedDiffs:
						return V.t.DETAILED_DIFFS
				}
			};

			function It(e, t) {
				return Object(Et.b)({
					method: V.bb.POST,
					endpoint: "/counters/".concat(vt(t.type)),
					data: {
						value: Object(_t.a)(JSON.stringify(Object.assign({
							appName: e
						}, t.data)))
					},
					type: "json"
				})
			}
			var St, Tt = async function(e) {
				let {
					fetchFn: t,
					context: n,
					variables: r,
					normalizer: s,
					dataToCompare: o,
					responseName: i,
					responseTypeName: c,
					diffSettings: a,
					beforeCompare: d
				} = e;
				try {
					const e = Date.now(),
						u = await t(n, r);
					if (u.ok) {
						const t = s(u.body.data),
							n = Date.now() - e;
						d && d(o.response, t);
						const r = yt(o.response, t),
							l = a && a.rules ? ((e, t, n) => e.filter(e => {
								for (const r of t)
									if (pt(r)) {
										if (mt(r, e)) return !1
									} else if (n && ft(r, e, n)) return !1;
								return !0
							}))(r, a.rules, {
								expected: o.response,
								actual: t
							}) : r,
							b = l.length,
							p = gt(o.response),
							m = (e => {
								const t = {
										account: 0,
										posts: 0,
										preferences: 0,
										profiles: 0,
										subreddits: 0
									},
									n = {
										posts: new Set,
										profiles: new Set,
										subreddits: new Set
									};
								for (const r of e) {
									const e = r.p.match(Ot);
									if (!e) continue;
									const s = e[1],
										o = e[2];
									switch (s) {
										case "preferences":
										case "account":
											t[s]++;
											break;
										default:
											n[s] && o && (t[s]++, n[s].add(o))
									}
								}
								for (const r in n) t[r] /= n[r].size || 1;
								return t
							})(l);
						return ((e, t, n, r, s, o) => {
							const i = t ? "".concat(e, "_").concat(t) : e;
							Object(jt.b)(V.l.Redesign, {
								type: "gql",
								responseName: i,
								duration: o
							}), It(V.l.Redesign, {
								type: ht.NumberOfDiffs,
								data: {
									responseName: i,
									numberOfDiffs: n,
									totalDiffs: r
								}
							}), It(V.l.Redesign, {
								type: ht.DetailedDiffs,
								data: Object.assign({
									responseName: e
								}, s)
							})
						})(i, c, b, p, m, n), l.length && nt.c.withScope(t => {
							t.setExtras(Object.assign({
								diff: l,
								numberOfDiffs: b
							}, o.start && {
								responsesDist: e - o.start
							})), Object(nt.a)(t, {
								serverLogging: !1
							}), nt.c.captureMessage("Compare responses: ".concat(i))
						}), Object.assign({}, u, {
							body: t
						})
					}
					return nt.c.withScope(e => {
						e.setExtra("error", u.error), Object(nt.a)(e, {
							serverLogging: !1
						}), nt.c.captureMessage("Gql error in ".concat(i))
					}), u
				} catch (u) {
					nt.c.captureException(u)
				}
			}, xt = n("./src/reddit/helpers/timeApiRoute/index.ts"), Ct = (n("./src/reddit/models/MonthsToMinutes/index.ts"), n("./src/lib/isUrl/index.ts")), wt = n("./src/reddit/models/Media/index.ts");
			! function(e) {
				e.Image = "image", e.Link = "link", e.Video = "video"
			}(St || (St = {}));
			var Pt = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				Dt = n("./src/reddit/actions/seo/linksModule.ts"),
				Rt = n("./src/reddit/actions/subreddit/subredditPosts.ts"),
				At = n("./src/reddit/helpers/graphql/helpers.ts"),
				kt = n("./src/reddit/selectors/dismissedTruncationList.ts"),
				Nt = n("./src/reddit/selectors/experiments/chatPost.ts"),
				Lt = n("./src/reddit/selectors/experiments/m2mHomeRedirect.ts"),
				Mt = n("./src/reddit/selectors/experiments/railsWidgets.ts"),
				Ut = n("./src/reddit/selectors/seo/linksModule.ts"),
				Ft = n("./src/reddit/actions/publicAccessNetwork/api.ts"),
				Bt = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			n.d(t, "n", (function() {
				return Gt
			})), n.d(t, "j", (function() {
				return Vt
			})), n.d(t, "I", (function() {
				return qt
			})), n.d(t, "h", (function() {
				return Ht
			})), n.d(t, "g", (function() {
				return Kt
			})), n.d(t, "f", (function() {
				return Wt
			})), n.d(t, "E", (function() {
				return Qt
			})), n.d(t, "x", (function() {
				return Zt
			})), n.d(t, "z", (function() {
				return tn
			})), n.d(t, "d", (function() {
				return nn
			})), n.d(t, "b", (function() {
				return rn
			})), n.d(t, "a", (function() {
				return sn
			})), n.d(t, "t", (function() {
				return cn
			})), n.d(t, "s", (function() {
				return an
			})), n.d(t, "u", (function() {
				return un
			})), n.d(t, "r", (function() {
				return ln
			})), n.d(t, "c", (function() {
				return bn
			})), n.d(t, "A", (function() {
				return mn
			})), n.d(t, "B", (function() {
				return fn
			})), n.d(t, "o", (function() {
				return gn
			})), n.d(t, "H", (function() {
				return On
			})), n.d(t, "i", (function() {
				return hn
			})), n.d(t, "y", (function() {
				return jn
			})), n.d(t, "m", (function() {
				return _n
			})), n.d(t, "l", (function() {
				return En
			})), n.d(t, "k", (function() {
				return vn
			})), n.d(t, "C", (function() {
				return xn
			})), n.d(t, "D", (function() {
				return Cn
			})), n.d(t, "e", (function() {
				return wn
			})), n.d(t, "q", (function() {
				return Pn
			})), n.d(t, "p", (function() {
				return Dn
			})), n.d(t, "F", (function() {
				return Rn
			})), n.d(t, "G", (function() {
				return An
			})), n.d(t, "v", (function() {
				return kn
			})), n.d(t, "w", (function() {
				return Nn
			})), n.d(t, "J", (function() {
				return Mn
			}));
			const Gt = 25,
				Vt = 100,
				qt = function(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					return async (n, r, s) => {
						let {
							routes: i
						} = s;
						const c = r();
						Object(Ze.a)(e, i, c) ? n(Object(o.b)(e)) : t ? Object(q.d)(e, "_blank") : window.location.assign(e)
					}
				},
				Ht = "PAGE__FRONTPAGE_PENDING",
				Kt = "PAGE__FRONTPAGE_LOADED",
				Wt = "PAGE__FRONTPAGE_FAILED",
				Yt = Object(f.a)(Ht),
				zt = Object(f.a)(Kt),
				Jt = Object(f.a)(Wt),
				Qt = (e, t) => {
					const n = e.user.language;
					return Object(i.a)(n, "title.".concat(t))
				},
				Xt = [/^posts\.[a-z_0-9]+/, (e, t) => t && Object(I.h)(t.author)],
				Zt = (e, t) => async (n, r, s) => {
					const o = r();
					if (o.listings.postOrder.api.pending[e]) return;
					const c = ge.e[Object(he.M)(o, {})];
					t.isMobile = Object(a.e)(o.meta.userAgent), t.recentPostIds = o.posts.recent, t.layout = c, t.useMockData = !!o.platform.currentPage && (!!o.platform.currentPage.queryParams.useMockData && Object(Qe.b)(o)), n(Yt({
						key: e
					}));
					const d = Object(Ye.e)(o),
						l = Object(Ye.g)(o, {
							expEventOverride: !1
						}),
						b = d && l;
					if (b) 0;
					else {
						const e = o.platform.currentPage,
							n = e && e.url;
						n && (t.clickUrl = n)
					}
					const p = b ? () => Object(B.a)(s.apiContext(), d, t) : () => Object(U.a)(s.gqlContext(), Object(U.c)(o, t), Object(Ge.R)(o)),
						m = b ? "multireddit" : "index",
						f = Date.now(),
						g = await Object(xt.a)(m, p);
					n(Object(Z.m)(g.status));
					const O = "error-".concat(e);
					if (g.ok) {
						const i = g.body;
						n(zt(Object.assign({
							key: e,
							meta: o.meta
						}, i)));
						const c = [X.c()(n, r, s)];
						(Object(Ae.a)(o) || !l && Object(Re.g)(o)) && c.push(n(u.h())), !l && Object(Mt.e)(o) && await n(Object(D.a)()), await Promise.all(c), n(ae.f(O)), n(Object($e.b)(Pt.a.FRONTPAGE)), !b && et.d.enableShadowMode(o) && Tt(Object.assign({}, ((e, t) => {
							const n = [V.N.CONTROVERSIAL, V.N.TOP].includes(e) && !t ? V.Pb : t;
							return {
								responseName: "home_feed",
								responseTypeName: "".concat(e).concat(n ? "_" + n : "")
							}
						})(t.sort, t.t), {
							fetchFn: U.b,
							normalizer: ve.a,
							variables: Object(U.c)(o, t),
							context: s.gqlContext(),
							dataToCompare: {
								response: i,
								start: f
							},
							beforeCompare: Ln,
							diffSettings: {
								rules: [
									[/.*/, (e, t) => void 0 === e && [!1, null, void 0].includes(t)],
									[/^features$/, At.f],
									[/^posts\..+\.eventsOnRender$/, At.f],
									[/^posts\..+\.isRoadblock$/, At.f],
									[/^posts\..+\.postCategories$/, At.f],
									[/^account\.geopopular$/, At.f],
									[/^account\.inChat$/, At.f],
									[/^account\.showTwitter$/, At.f],
									[/^posts\..*\.media\.videoPreview$/, At.f],
									[/^posts\..+\.score$/, At.g],
									[/^subreddits\..+\.subscribers$/, At.g],
									[/^posts\..+\.upvoteRatio$/, At.f],
									[/^subreddits\..+\.primaryColor$/, At.d],
									[/^posts\..+\.flair\[\d{1,2}\]\.backgroundColor$/, At.d],
									[/^account.showRecentPosts$/, (e, t) => !!e === t],
									[/^posts\..+\.media\.resolutions\[\d+\]\.url$/, (e, t) => Object(At.b)(e, t, ["height"])],
									[/^posts\..+\.media\.posterUrl$/, (e, t) => Object(At.b)(e, t, ["height"])],
									[/^posts\..+\.preview\.url$/, (e, t) => Object(At.b)(e, t, ["format"])],
									[/^posts\..+\.thumbnail\.url$/, (e, t) => t === N.a.NSFW],
									[/^trendingSubredditIds\[\d+\]$/, At.f],
									[/^subreddits\..+\.wls$/, e => null == e],
									[/^subreddits\..+\.whitelistStatus$/, (e, t) => ("no_ads" === e || "null_value" === e) && void 0 === t],
									[/^posts\..+\.media\.obfuscated$/, At.c],
									[/^posts\..+\.source\.outboundUrl$/, (e, t) => "" === e && void 0 === t || Object(At.e)(e, t, ["app_name", "token"])],
									[/^posts\..+\.source\.outboundUrl(Created|Expiration)$/, (e, t) => Math.abs(t - e) < 1e4],
									[/^posts\..*\.numComments/, (e, t) => Math.abs(t - e) <= 10],
									[/^postFlair\..*\.displaySettings\.position/, (e, t) => "" === e && null === t],
									[/^subreddits\..*\.freeFormReports$/, e => null == e],
									[/^posts\..*\.sendReplies$/, (e, t) => void 0 === t],
									[/^posts\..+\.flair\[\d+\]\.templateId$/, (e, t) => null === e && void 0 === t],
									[/^postInstances\[\d+\]$/, At.f],
									[/^account\.hasAndroidSubscription$/, (e, t) => !1 === e && void 0 === t],
									[/^account\.hasIOSSubscription$/, (e, t) => !1 === e && void 0 === t],
									[/^posts\..+\.media\.content$/, (e, t) => void 0 === e && "" === t],
									[/^posts\..+\.media\.markdownContent$/, (e, t) => void 0 === e && "" === t],
									[/^posts\..+\.crosspostParentId$/, (e, t) => null === e && void 0 === t],
									[/^posts\..+\.crosspostRootId$/, (e, t) => null === e && void 0 === t],
									[/^account\.accountIcon$/, (e, t) => null === e && void 0 === t],
									[/^account\.email$/, (e, t) => null === e && void 0 === t],
									[/^subreddits\..+\.communityIcon$/, (e, t) => "" === e && void 0 === t],
									[
										[/^posts\..*\.sendReplies$/, (e, t) => !1 === t], Xt
									],
									[/^posts\..*\.domainOverride$/, (e, t) => null === e && void 0 === t],
									[/^posts\..*\.callToAction$/, (e, t) => null === e && void 0 === t],
									[/^posts\..*\.contentCategories$/, (e, t) => null === e && void 0 === t],
									[/^posts\..*\.modReports$/, (e, t) => void 0 === e && t && 0 === t.length],
									[/^posts\..*\.previewComments$/, (e, t) => void 0 === e && t && 0 === t.length],
									[/^posts\..*\.userReports$/, (e, t) => void 0 === e && t && 0 === t.length]
								]
							}
						}))
					} else n(Jt(Object.assign({
						error: g.error,
						key: e
					}, g.body))), n(ae.e({
						id: O,
						kind: we.b.Error,
						text: Object(i.a)(o.user.language, "listings.toast.error"),
						buttonText: Object(i.a)(o.user.language, "listings.toast.retryButton"),
						buttonAction: Zt(e, t)
					}))
				}, $t = (e, t) => async (n, r) => {
					const i = r();
					if (!1 === i.user.temporaryGQL.isLoggedIn) {
						if (Object(Ae.a)(i)) return void n(Object(o.b)(Object(c.a)(pe.c[me.d.Explore], e.queryParams)))
					}
					const a = Object(He.a)(i),
						{
							sort: d = a
						} = e.params,
						u = Object(g.a)(me.b, d, e.queryParams),
						l = i.listings.postOrder.ids[u],
						b = i.listings.postOrder.api.error[u],
						p = i.listings.postOrder.api.pending[u],
						m = fe.t in e.queryParams && e.queryParams[fe.t].toUpperCase() || "",
						f = m in V.Ob && V.Ob[m];
					if (p || l && !b && !t) return void(l && (n(Z.l({
						title: Qt(r(), "frontpage")
					})), i.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						n(Object($e.b)(Pt.a.FRONTPAGE))
					})));
					await n(Zt(u, Object.assign({}, s()(e.queryParams, fe.k), s()(e.queryParams, fe.j), {
						sort: d,
						t: Object(Ee.a)(d, f)
					}))), n(Z.l({
						title: Qt(r(), "frontpage")
					})), Object(Me.c)(i, {
						experimentEligibilitySelector: Me.a,
						experimentName: "redesign_aa"
					});
					const O = Object(ke.a)(i, {});
					Object(ke.e)(O) && n(Object(Q.f)())
				}, en = () => async (e, t) => {
					const n = t();
					if (!Object(Ut.a)(n)) return e(Object(Dt.b)())
				}, tn = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					await Promise.all([n(Object(b.a)()), n($t(e, t)), n(en()), n(Object(Ft.c)(Bt.R))])
				}, nn = "PAGE__COMMENTSPAGE_PENDING", rn = "PAGE__COMMENTSPAGE_LOADED", sn = "PAGE__COMMENTSPAGE_FAILED", on = Object(f.a)(nn), cn = Object(f.a)(rn), an = Object(f.a)(sn), dn = (e, t) => {
					const n = Object(Je.U)(e, {
							postId: t
						}),
						r = Object(Je.I)(e, {
							postId: t
						});
					if (!n || !r) return "";
					const s = e.posts.models[t].title,
						o = function(e) {
							return Object(d.a)(e, le.Lb, le.Nb)
						};
					let i;
					switch (s.length >= le.Kb ? i = Object(Ne.f)(e) : s.length <= le.Mb && (i = Object(Ne.k)(e)), i) {
						case le.U.TruncTitleSubBrand:
							return Object(G.c)("".concat(Object(G.b)("postTitle", o(s)), " - ").concat(Object(G.b)("subredditName", n.name), " - Reddit"));
						case le.U.TruncTitleReddit:
							return Object(G.c)("".concat(Object(G.b)("postTitle", o(s)), " - Reddit"));
						case le.U.TruncTitleSub:
							return Object(G.c)("".concat(Object(G.b)("postTitle", o(s)), " - ").concat(Object(G.b)("subredditName", n.name)));
						case le.Y.TitleSubPtypeBrand:
							const e = (e => {
								if (!e.media && e.source && Object(Ct.a)(e.source.url)) return St.Link;
								if (e.media) switch (e.media.type) {
									case wt.n.IMAGE:
										return St.Image;
									case wt.n.VIDEO:
										return St.Video;
									default:
										return
								}
							})(r);
							return e ? Object(G.c)("".concat(Object(G.b)("postTitle", s), " - ").concat(Object(G.b)("postType", e), " - ").concat(Object(G.b)("subredditName", n.name), " - Reddit")) : Object(G.c)("".concat(Object(G.b)("postTitle", s), " - ").concat(Object(G.b)("subredditName", n.name), " - Reddit"));
						case le.Y.TitleSubPtypeCom:
							return Object(G.c)("".concat(Object(G.b)("postTitle", s), " - posted in the ").concat(Object(G.b)("subredditName", n.name), " community"));
						default:
							return Object(G.c)("".concat(Object(G.b)("postTitle", s), " : ").concat(Object(G.b)("subredditName", n.name)))
					}
				}, un = e => async (t, n) => {
					const {
						partialPostId: r,
						partialCommentId: s
					} = e.params, {
						subredditName: o
					} = e.params || "", i = r ? Object(I.m)(r) : "", c = s && Object(Te.e)(s), {
						path: a,
						queryParams: d
					} = e, l = Object(O.d)(a);
					l && t(C(i, {
						postId: i
					}));
					const b = n(),
						{
							instanceId: m
						} = d,
						{
							hasSortParam: f,
							sortToUse: h
						} = Object(_e.a)(b, i),
						y = ["context", "depth", "limit", fe.e].reduce((e, t) => {
							const n = parseInt(d[t]);
							return isNaN(n) || (e[t] = n), e
						}, {
							subredditName: o,
							hasSortParam: f,
							instanceId: m,
							include_categories: !0
						});
					f && (y.sort = h), y.onOtherDiscussions = l, t(se.k(i)), await t(ln(i, c, y, h));
					const j = n().posts.models[i];
					if (j) {
						const r = dn(n(), i),
							s = Object(Be.M)(n(), {
								identifier: j.belongsTo
							});
						if (j.belongsTo.type !== Oe.a.SUBREDDIT || j.isSponsored) j.belongsTo.type === Oe.a.PROFILE && await t(oe.d(s.name));
						else {
							!!Object(Be.R)(b, {
								subredditId: j.belongsTo.id
							}) || await t(ce.o(s.name))
						}
						const c = !!qe(b, {
							identifier: j.belongsTo
						});
						if (!Object(Ce.e)(s) && !Object(Nt.d)(b, {
								postId: i
							}) && s && Object(kt.c)(b, s.id) || !Object(Fe.i)(b) && Object(Ne.d)(b)) {
							const e = Object(g.a)(o, V.N.TOP, {
									t: V.Ob.WEEK
								}),
								r = Object(Je.C)(n(), {
									listingKey: e
								});
							if (!r || 0 === r.length) {
								const e = t(Object(Rt.a)({
									sort: V.H.TOP,
									subredditName: s.name,
									range: V.Ob.WEEK.toUpperCase(),
									adContext: {
										layout: be.a.Card,
										reddaid: b.user.reddaid,
										sourcePostId: i
									}
								}));
								c && await e
							}
						} {
							const e = Object(Lt.f)(b);
							if (e && !Object(Ce.e)(s)) {
								const n = Object(Ye.e)(b);
								n && !Object(Ye.n)(b) ? t(Object(w.h)(n, {
									sort: V.N.HOT
								})) : Object(Lt.e)(e) && t(Object(w.h)(s.name, {
									sort: V.N.TOP
								}))
							}
							t(Object(W.p)())
						}
						t(Z.l({
							title: r
						}));
						const a = n().posts.instances[i] ? e.queryParams.instanceId : j.postId;
						t(Object(R.c)(a)); {
							const e = Object(De.f)(n(), {
								subredditName: s.name
							});
							await Promise.all(e.map(e => t(u.k(e))))
						}
					} else t(Z.l({
						title: Qt(n(), "frontpage")
					}));
					const {
						routePrefix: _
					} = e.params;
					Oe.b[_] === Oe.a.PROFILE ? Object(tt.d)(n(), t, e) : Object(tt.b)(n(), t, e), Object(Ye.w)(n()) && await t(Object(p.b)(i))
				}, ln = (e, t, n, r) => async (s, o, i) => {
					const c = o(),
						a = Object(Xe.a)(e, t, n),
						{
							subredditName: d
						} = n,
						u = c.commentsPage.keyToHeadCommentId.hasOwnProperty(a),
						b = c.commentsPage.api.fullyLoaded[a],
						p = c.commentsPage.api.error[a],
						m = c.commentsPage.api.pending[a],
						f = !c.user.temporaryGQL.isLoggedIn,
						g = r === V.q.CHAT,
						O = !!c.platform.lastPage;
					if ((m || u && !p) && !(g && O)) {
						if (u && !c.sidebarPromotedPosts.firstFetch) {
							const t = Object(Fe.i)(c) ? Pt.a.COMMENTS_OVERLAY : Pt.a.COMMENTS;
							window.addEventListener("load", () => {
								s(Object($e.b)(t)), Math.random() <= .01 && s(Object($e.a)(e))
							})
						}
						return void(b || s(mn(e, t, n)))
					}
					s(l.h());
					const h = c.user.prefs.commentMode;
					s(on({
						key: a,
						postId: e,
						commentMode: h
					}));
					const y = Object.assign({}, n, g ? {
						sort: V.q.LIVE
					} : f ? {
						sort: n.sort,
						depth: 2
					} : {
						sort: n.sort
					}); {
						const t = Object(Je.I)(o(), {
							postId: e
						});
						t && t.numComments && t.numComments > Vt && (y.truncate = Gt)
					}
					let j, _ = await Object(xt.a)("comments", () => Object(M.a)(i.apiContext(), e, t, y));
					if (s(Object(Z.m)(_.status)), _.ok) {
						const t = Object.keys(_.body.posts).filter(e => !!_.body.posts[e].isMeta),
							n = _.body.posts[e];
						if (t.length) {
							const e = await Object(L.a)(i.apiContext(), n.belongsTo.id, t);
							e.ok && (j = e.body)
						}
						const r = Object(je.a)(_.body, e, c);
						s(cn(Object.assign({
							key: a,
							postId: e,
							meta: c.meta,
							governance: j,
							shouldCollapse: r
						}, _.body)))
					} {
						const r = Object(Je.I)(o(), {
							postId: e
						});
						r && _.body.comments && Object.keys(_.body.comments).length < r.numComments ? s(mn(e, t, n)) : _.ok && s(pn({
							key: a
						}));
						const i = Object(Fe.i)(c) ? Pt.a.COMMENTS_OVERLAY : Pt.a.COMMENTS;
						s(Object($e.b)(i)), Math.random() <= .01 && s(Object($e.a)(e))
					}
					if (_.ok) {
						await X.c()(s, o, i), s(ae.f(a));
						const t = Object(Je.I)(o(), {
							postId: e
						});
						Object(Se.a)(t.events, ue.a.CommentsView), t && "subreddit" === t.belongsTo.type && _.body.comments && await s(Object(K.a)({
							commentIds: Object.keys(_.body.comments),
							postIds: [t.id],
							subredditId: t.belongsTo.id
						}))
					} else d && (s(Object(w.j)({
						key: a
					})), _ = await Object(xt.a)("subreddit", () => Object(B.a)(i.apiContext(), d, {})), s(Object(Z.m)(_.status))), s(Object(w.e)(_, d)), s(an(Object.assign({
						error: _.error,
						key: a
					}, _.body)))
				}, bn = "PAGE__COMMENTSPAGE_LOADED_FULL", pn = Object(f.a)(bn), mn = (e, t, n) => async (r, s, o) => {
					const i = Object(Xe.a)(e, t, n),
						c = s(),
						a = await Object(M.a)(o.apiContext(), e, t, n);
					if (r(Object(Z.m)(a.status)), a.ok) {
						const t = Object(je.a)(a.body, e, c);
						r(cn(Object.assign({
							key: i,
							postId: e,
							meta: c.meta,
							shouldCollapse: t
						}, a.body))), r(pn({
							key: i
						}));
						const n = s().posts.models[e],
							o = n && Object(Je.U)(s(), {
								postId: n.id
							});
						n && "subreddit" === n.belongsTo.type && o && Object(We.a)(c, {
							subredditId: o.id
						}) && r(Object(A.f)(o.name, o.id)), n && "subreddit" === n.belongsTo.type && a.body.comments && await r(Object(K.a)({
							commentIds: Object.keys(a.body.comments),
							postIds: [n.id],
							subredditId: n.belongsTo.id
						}))
					} else r(an(Object.assign({
						error: a.error,
						key: i
					}, a.body)))
				}, fn = e => async (t, n, r) => {
					await t(Object(ie.c)(e, !0))
				}, gn = () => async (e, t, n) => {
					await e((() => async (e, t, n) => {
						let {
							apiContext: r
						} = n;
						const s = t(),
							o = await Object($.a)(r());
						if (o.ok && o.body)
							if (o.body.account)
								if (s.user.account && s.user.account.isFPR) {
									const e = "https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/my-account-was-suspended-or-locked";
									window.location.href = e
								} else e(ne(o.body));
						else Object(ee.a)(e, s);
						else e(re(o.error))
					})())
				}, On = (e, t, n) => async (r, s, i) => {
					let {
						routes: c
					} = i;
					const a = s(),
						d = (t || a.platform.currentPage).routeMatch.match,
						u = Object(Ze.a)(d.url, c);
					if (!u) return;
					const l = e.metaKey || e.ctrlKey || 1 === e.button;
					if (u.route && u.route.meta && (u.route.meta.name === V.xb.INDEX || u.route.meta.name === V.xb.MULTIREDDIT || u.route.meta.name === V.xb.SUBREDDIT)) l ? window.open(d.url) : n ? r(Object(o.b)(d.url)) : await r(u.route.action(d, !0));
					else if (u.match && u.match.params && u.match.params.subredditName) {
						const {
							subredditName: e
						} = u.match.params, t = "/r/".concat(e, "/");
						if (l) window.open(t);
						else if (n) r(Object(o.b)(t));
						else {
							const n = Object(g.a)(e, V.N.HOT);
							await r(Object(o.b)(t)), r(Object(w.i)(n, e, {}))
						}
					}
				}, hn = "PAGE__FRONTPAGE_RELOADED", yn = Object(f.a)(hn), jn = e => async (t, n, r) => {
					const s = n(),
						o = s.platform.currentPage.routeMatch.match;
					Object(Ke.q)(s) || Object(Ke.d)(s) || (e || t(yn()), await t(tn(o, !0)))
				}, _n = "PAGE__MULTIREDDIT_FEED_PENDING", En = "PAGE__MULTIREDDIT_FEED_LOADED", vn = "PAGE__MULTIREDDIT_FEED_FAILED", In = Object(f.a)(_n), Sn = Object(f.a)(En), Tn = Object(f.a)(vn), xn = (e, t, n, r, s) => async (o, c, a) => {
					const {
						gqlContext: d
					} = a, u = c();
					if (u.listings.postOrder.api.pending[e]) return;
					o(In({
						key: e
					})), r.layout = ge.e[Object(he.M)(u, {})];
					const l = {
							path: Object(xe.h)(t, n).replace(/\/$/, ""),
							includeIdentity: !0,
							includeSources: !0,
							sort: r.sort ? r.sort.toUpperCase() : void 0,
							range: r.t ? r.t.toUpperCase() : void 0
						},
						b = await Object(xt.a)("multireddit", () => Object(F.a)(d(), l)),
						{
							data: p
						} = b.body,
						f = "error-".concat(e);
					if (b.ok && p) {
						const r = Object(Ie.a)(p);
						if (!p.multireddit) return s && o(ae.f(f)), void o(Tn(Object.assign({}, r, {
							error: {
								type: V.D.NOT_FOUND_ERROR
							},
							key: e
						})));
						o(Sn(Object.assign({
							key: e,
							meta: u.meta
						}, r, {
							account: r.account || Object(Ge.i)(u),
							multiredditsModelsState: u.multireddits.models
						}))), s && o(ae.f(f)), o(Object(m.h)({
							multiredditName: n,
							username: t
						})), window.addEventListener("load", () => {
							o(Object($e.b)(Pt.a.MULTIREDDIT))
						})
					} else s && o(ae.e({
						id: f,
						kind: we.b.Error,
						text: Object(i.a)(u.user.language, "listings.toast.error"),
						buttonText: Object(i.a)(u.user.language, "listings.toast.retryButton"),
						buttonAction: xn(e, t, n, r, s)
					}))
				}, Cn = (e, t) => async (n, r) => {
					const {
						multiredditName: i
					} = e.params;
					let {
						username: a
					} = e.params;
					if (!a) {
						let t = r();
						if (t.user.session && t.user.session.unsafeLoggedOut) return void n(Object(o.c)("/"));
						!t.user.account && t.user.session && await n(de.u()), t = r();
						const {
							account: s
						} = t.user;
						if (!s) return void n(Object(o.c)("/"));
						a = Object(Pe.f)(s);
						let d = "/user/".concat(a, "/m/").concat(i);
						const {
							sort: u
						} = e.params;
						return d += u ? "/".concat(u) : "", void n(Object(o.c)(Object(c.a)(d, e.queryParams)))
					}
					const {
						sort: d = V.N.HOT
					} = e.params, u = {
						multiredditName: i,
						username: a
					}, l = r();
					a || (a = l.user.account ? Object(Pe.f)(l.user.account) : "");
					const b = Object(xe.h)(a, i),
						p = Object(g.a)(b, d, e.queryParams),
						m = l.listings.postOrder.ids[p],
						f = l.listings.postOrder.api.error[p],
						O = l.listings.postOrder.api.pending[p],
						h = fe.t in e.queryParams && e.queryParams[fe.t].toUpperCase() || "",
						y = h in V.Ob && V.Ob[h];
					if (O || m && !f && !t) return void(m && (n(Z.l({
						title: Object(ze.f)(r(), u)
					})), l.sidebarPromotedPosts.firstFetch || n(Object($e.b)(Pt.a.MULTIREDDIT))));
					await n(xn(p, a, i, Object.assign({}, s()(e.queryParams, fe.k), s()(e.queryParams, fe.j), {
						sort: d,
						t: Object(Ee.a)(d, y)
					}), !0));
					const j = r();
					Object(ze.d)(j, u) && n(Z.l({
						title: Object(ze.f)(r(), u)
					})), Object(tt.c)(j, n, e)
				}, wn = "PAGE__DASHBOARD_PENDING", Pn = (Object(f.a)(wn), e => async (t, r) => {
					const s = r();
					t(Z.l({
						title: Qt(s, "coins")
					})), Object(Ge.K)(s) || await t(de.u());
					const i = r(),
						c = e.queryParams;
					if (c.thanks) {
						const e = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/goldPurchaseModals/payment.ts")).then(e => e.paymentCompleted);
						setTimeout(() => {
							c.gild && t(z.e({
								thingId: "THING_ID_PLACEHOLDER"
							})), t(z.g({
								coinPackage: H.a.coins500
							})), t(e({
								confirmed: !1
							}))
						}, 1e3)
					} else if (c.qty) {
						const e = Object(Ge.i)(s);
						if (!Object(Ge.K)(i) || !(e => e && (e.isEmployee || ye.has(e.id)))(e)) return void t(Object(o.c)("/coins"));
						const r = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/goldPurchaseModals/payment.ts")).then(e => e.selectPaymentMethod);
						setTimeout(() => {
							const e = parseInt(c.qty),
								n = Object(H.c)(e);
							t(z.g({
								coinPackage: n
							})), t(r(V.tb))
						}, 500)
					}
				}), Dn = e => async (e, t) => {
					const n = t();
					e(Z.l({
						title: Qt(n, "coins")
					}))
				}, Rn = e => async (t, r) => {
					const s = r();
					if (t(Z.l({
							title: Qt(s, "premium")
						})), e.queryParams.thanks) {
						const e = await Promise.resolve().then(n.bind(null, "./src/reddit/actions/goldPurchaseModals/payment.ts")).then(e => e.paymentCompleted);
						setTimeout(() => {
							t(J.e()), t(e({
								confirmed: !1
							}))
						}, 1e3)
					}
					Object(Ge.K)(s) || await t(de.u())
				}, An = e => async (e, t) => {
					const n = t();
					e(Z.l({
						title: Qt(n, "publicAccessNetwork")
					})), Object(Ge.K)(n) || await e(de.u())
				}, kn = e => async (t, n) => {
					const r = n(),
						s = e.params.thingId;
					t(Object(Y.c)({
						thingId: s,
						gildModalId: Object(k.a)(s)
					})), Object(Ge.K)(r) || await t(de.u());
					const o = n();
					if (!Object(Ge.K)(o)) return t(Object(Y.f)())
				}, Nn = e => async (e, t) => {
					const n = t();
					Object(Ge.K)(n) || await e(de.u());
					const r = t();
					if (!Object(Ge.K)(r)) throw new Error("Failed to login")
				}, Ln = (e, t) => {
					const n = {};
					for (const r in e.postInstances)
						for (const s of e.postInstances[r]) {
							const o = e.postIds.indexOf(s),
								i = t.postIds[o];
							e.posts[s] && t.posts[i] && e.posts[s].postId === t.posts[i].postId && (n[i] = {
								postId: r,
								gwAdPostId: s,
								index: o
							})
						}
					for (const r in n) {
						const e = n[r];
						if (t.postInstances[e.postId]) {
							const n = t.postInstances[e.postId].indexOf(r); - 1 !== n && (t.postInstances[e.postId][n] = e.gwAdPostId)
						}
						t.posts[e.gwAdPostId] = t.posts[r], delete t.posts[r], t.postIds[e.index] = e.gwAdPostId
					}
				}, Mn = () => async (e, t, n) => await e(P.d())
		},
		"./src/reddit/actions/pages/appeal/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const r = "APPEAL_PAGE_LOADED",
				s = "APPEAL_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/collectionCommentsPage.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeCollectionCommentsPageKey/index.ts"),
				i = n("./src/lib/truncateText/index.ts"),
				c = n("./src/reddit/actions/ads/index.ts"),
				a = n("./src/reddit/actions/economics/helpers/async.ts"),
				d = n("./src/reddit/actions/moderatingSubreddits.ts"),
				u = n("./src/reddit/actions/page.ts"),
				l = n("./src/reddit/actions/pages/shared.ts"),
				b = n("./src/reddit/actions/pages/subreddit.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/actions/post.ts"),
				f = n("./src/reddit/actions/profile/index.ts"),
				g = n("./src/reddit/actions/shortcuts.ts"),
				O = n("./src/reddit/actions/subreddit.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				y = n("./src/reddit/constants/adEvents.ts"),
				j = n("./src/reddit/constants/parameters.ts"),
				_ = n("./src/reddit/constants/postCollection.ts"),
				E = n("./src/reddit/constants/posts.ts"),
				v = n("./src/reddit/endpoints/governance/posts.ts"),
				I = n("./src/config.ts"),
				S = n("./src/lib/constants/index.ts"),
				T = n("./src/lib/makeApiRequest/index.ts"),
				x = n("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function C(e, t, n) {
				const r = "".concat(I.a.gatewayUrl, "/desktopapi/v1/collection_postcomments");
				return n ? Object(x.a)("".concat(r, "/").concat(e, "/").concat(t, "/").concat(n)) : t ? Object(x.a)("".concat(r, "/").concat(e, "/").concat(t)) : Object(x.a)("".concat(r, "/").concat(e))
			}
			var w = (e, t, n, r, s) => Object(T.b)(e, {
					data: s,
					endpoint: C(t, n, r),
					method: S.bb.GET
				}),
				P = n("./src/reddit/endpoints/page/subredditPage.ts"),
				D = n("./src/reddit/helpers/canonicalUrls.ts"),
				R = n("./src/reddit/helpers/commentList/index.ts"),
				A = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				k = n("./src/reddit/helpers/pixels.ts"),
				N = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				L = n("./src/reddit/models/Comment/index.ts"),
				M = n("./src/reddit/models/Post/index.ts"),
				U = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				F = n("./src/reddit/selectors/platform.ts"),
				B = n("./src/reddit/selectors/postCollection.ts"),
				G = n("./src/reddit/selectors/posts.ts"),
				V = n("./src/reddit/selectors/subreddit.ts");
			n.d(t, "d", (function() {
				return q
			})), n.d(t, "b", (function() {
				return H
			})), n.d(t, "a", (function() {
				return K
			})), n.d(t, "e", (function() {
				return J
			})), n.d(t, "c", (function() {
				return Q
			}));
			const q = "PAGE__COLLECTIONCOMMENTSPAGE_PENDING",
				H = "PAGE__COLLECTIONCOMMENTSPAGE_LOADED",
				K = "PAGE__COLLECTIONCOMMENTSPAGE_FAILED",
				W = Object(s.a)(q),
				Y = Object(s.a)(H),
				z = Object(s.a)(K),
				J = e => async (t, n) => {
					const {
						collectionId: s,
						partialPostId: o,
						partialCommentId: c,
						subredditName: a = "",
						routePrefix: d
					} = e.params, u = o ? Object(M.m)(o) : "", b = c && Object(L.e)(c), {
						queryParams: h
					} = e, y = n(), {
						instanceId: v
					} = h, I = {
						id: s,
						type: E.b[d]
					}, S = E.b[d] === E.a.PROFILE, {
						hasSortParam: T,
						sortToUse: x
					} = Object(A.a)(y, u), C = ["context", "depth", "limit", j.e].reduce((e, t) => {
						const n = parseInt(h[t]);
						return isNaN(n) || (e[t] = n), e
					}, {
						subredditName: a,
						hasSortParam: T,
						instanceId: v
					});
					T && (C.sort = x), t(m.k(u)), await Promise.all([S ? t(f.d(a)) : Promise.resolve(), t($(s, u, b, C))]);
					const w = ((e, t) => {
						const n = Object(B.q)(e, {
							collectionId: t.id
						});
						if (!n) return "";
						const s = Object(V.M)(e, {
								identifier: t
							}),
							o = Object(r.a)(e.user.language, "title.commentsPage", {
								postTitle: n.title,
								subreddit: s.name
							});
						return Object(i.a)(o, _.c, " ")
					})(n(), I) || Object(l.b)(n(), "frontpage");
					t(p.l({
						title: w
					}));
					const P = n().posts.models[u];
					if (P) {
						const r = Object(V.M)(n(), {
							identifier: P.belongsTo
						});
						if (!P.isSponsored)
							if (P.belongsTo.type === E.a.SUBREDDIT) {
								!!Object(V.R)(y, {
									subredditId: P.belongsTo.id
								}) || await t(O.o(r.name))
							} else await t(f.d(r.name));
						const s = n().posts.instances[u] ? e.queryParams.instanceId : P.postId;
						t(Object(g.c)(s))
					}
					S ? Object(D.d)(n(), t, e) : Object(D.e)(n(), t, e)
				}, Q = "PAGE__COLLECTIONCOMMENTSPAGE_LOADED_FULL", X = Object(s.a)(Q), Z = (e, t, n, r) => async (s, i, c) => {
					const a = Object(o.a)(e, t, n, r),
						d = i();
					t = t || Object(B.p)(d, {
						collectionId: e
					});
					const u = await w(c.apiContext(), e, t, n, r);
					if (s(Object(p.m)(u.status)), u.ok) {
						if (!(t = t || u.body.collections[e].primaryPostId)) return;
						const n = Object(R.a)(u.body, t, d);
						s(Y(Object.assign({
							key: a,
							collectionId: e,
							meta: d.meta,
							postId: t,
							shouldCollapse: n
						}, u.body)));
						const r = d.user.prefs.commentMode;
						s(X({
							commentMode: r,
							key: a,
							postId: t
						}))
					} else s(z(Object.assign({
						error: u.error,
						key: a
					}, u.body)))
				}, $ = (e, t, n, r, s) => async (i, l, m) => {
					const f = Object(o.a)(e, t, n, r),
						g = l();
					t = t || Object(B.p)(g, {
						collectionId: e
					});
					const {
						subredditName: O
					} = r, j = g.commentsPage.keyToHeadCommentId.hasOwnProperty(f), _ = g.commentsPage.api.fullyLoaded[f], E = g.commentsPage.api.error[f];
					if (g.commentsPage.api.pending[f] || j && !E) {
						if (j && !g.sidebarPromotedPosts.firstFetch) {
							const e = Object(F.i)(g) ? U.a.COMMENTS_OVERLAY : U.a.COMMENTS;
							window.addEventListener("load", () => {
								i(Object(c.b)(e))
							})
						}
						return void(_ || s || i(Z(e, t, n, r)))
					}
					const I = g.user.prefs.commentMode;
					i(W({
						key: f,
						collectionId: e,
						commentMode: I,
						postId: t
					}));
					const S = Object.assign({}, r); {
						const e = t && Object(G.I)(l(), {
							postId: t
						});
						e && e.numComments && e.numComments > u.j && (S.truncate = u.n)
					}
					let T, x = await Object(N.a)("comments", () => w(m.apiContext(), e, t, n, S));
					if (i(Object(p.m)(x.status)), x.ok && (t = t || x.body.collections[e].primaryPostId)) {
						const e = Object.keys(x.body.posts).filter(e => !!x.body.posts[e].isMeta),
							n = Object(G.I)(l(), {
								postId: t
							});
						if (e.length) {
							const t = await Object(v.a)(m.apiContext(), n.belongsTo.id, e);
							t.ok && (T = t.body)
						}
					}
					if (!s) {
						const s = t ? Object(G.I)(l(), {
							postId: t
						}) : null;
						s && x.body.comments && Object.keys(x.body.comments).length < s.numComments ? i(Z(e, t, n, r)) : x.ok && i(X({
							commentMode: I,
							key: f,
							postId: t
						}));
						const o = Object(F.i)(g) ? U.a.COMMENTS_OVERLAY : U.a.COMMENTS;
						i(Object(c.b)(o))
					}
					if (x.ok) {
						if (!t) return;
						const e = Object(R.a)(x.body, t, g);
						i(Object(u.t)(Object.assign({
							commentMode: I,
							key: f,
							postId: t,
							meta: g.meta,
							governance: T,
							shouldCollapse: e
						}, x.body))), await d.c()(i, l, m), i(h.f(f));
						const n = Object(G.I)(l(), {
							postId: t
						});
						Object(k.a)(n.events, y.a.CommentsView), !s && n && "subreddit" === n.belongsTo.type && x.body.comments && await i(Object(a.a)({
							commentIds: Object.keys(x.body.comments),
							postIds: [n.id],
							subredditId: n.belongsTo.id
						}))
					} else O && (i(Object(b.j)({
						key: f
					})), x = await Object(N.a)("subreddit", () => Object(P.a)(m.apiContext(), O, {})), i(Object(p.m)(x.status))), i(Object(b.e)(x, O)), i(z(Object.assign({
						error: x.error,
						key: f
					}, x.body)))
				}
		},
		"./src/reddit/actions/pages/explore.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return T
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "a", (function() {
				return C
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "e", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/app/strings/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeExplorePageKey/index.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/category.ts"),
				u = n("./src/reddit/actions/discoveryUnit.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/actions/pages/subreddit.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/constants/explore.ts"),
				g = n("./src/reddit/constants/listings.ts"),
				O = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/selectors/category.ts"),
				j = n("./src/reddit/selectors/discoveryUnit.ts"),
				_ = n("./src/reddit/selectors/experiments/exploreV2.ts"),
				E = n("./src/reddit/selectors/listings.ts"),
				v = n("./src/reddit/selectors/posts.ts"),
				I = n("./src/reddit/selectors/user.ts");
			const S = e => Object(s.a)(e.user.language, "title.frontpage"),
				T = "PAGE__EXPLORE_PAGE_PENDING",
				x = "PAGE__EXPLORE_PAGE_LOADED",
				C = "PAGE__EXPLORE_PAGE_FAILED",
				w = Object(i.a)(T),
				P = Object(i.a)(x),
				D = Object(i.a)(C),
				R = (e, t, n) => async (r, o, i) => {
					const c = o(),
						a = Object(j.a)(c);
					if (!a) {
						r(D({
							key: e,
							error: {}
						}));
						const n = Object(I.T)(c);
						return void r(m.e({
							id: "error-".concat(e),
							kind: h.b.Error,
							text: Object(s.a)(n, "listings.toast.error"),
							buttonText: Object(s.a)(n, "listings.toast.retryButton"),
							buttonAction: k(e, t)
						}))
					}
					const d = Object(E.j)(c, {
							listingKey: e
						}),
						l = d ? d.token : void 0;
					if (d) {
						if (!n) return; {
							const t = Object(E.h)(c, {
									listingKey: e
								}),
								n = Object(E.i)(c, {
									listingKey: e,
									token: d.token
								});
							if (t || n) return
						}
					} else {
						const t = Object(E.h)(c, {
								listingKey: e
							}),
							n = Object(E.f)(c, {
								listingKey: e
							});
						if (t || n) return
					}
					r(w({
						key: e
					}));
					const b = Object(y.e)(c, {}),
						p = l ? b.findIndex(e => e.id === l) + 1 : 0,
						g = b.slice(p, p + f.a);
					await Promise.all(g.map(e => r(u.g(a, e.name))));
					const O = Math.min(p + f.a - 1, b.length - 1);
					r(P({
						fetchedToken: l,
						ids: g.map(e => {
							let {
								id: t
							} = e;
							return t
						}),
						key: e,
						token: b[O].id
					}))
				}, A = (e, t, n, r) => async (o, i, c) => {
					let a = i();
					const l = Object(j.d)(a),
						b = Object(y.h)(a, {
							categoryName: n
						});
					if (!l || !b) {
						o(D({
							key: e,
							error: {}
						}));
						const n = Object(I.T)(a);
						return void o(m.e({
							id: "error-".concat(e),
							kind: h.b.Error,
							text: Object(s.a)(n, "listings.toast.error"),
							buttonText: Object(s.a)(n, "listings.toast.retryButton"),
							buttonAction: k(e, t)
						}))
					}
					const p = Object(E.j)(a, {
							listingKey: e
						}),
						g = p ? p.token : void 0,
						O = Object(E.h)(a, {
							listingKey: e
						});
					if (p) {
						if (!r) return; {
							const t = Object(E.i)(a, {
								listingKey: e,
								token: p.token
							});
							if (O || t) return
						}
					} else {
						const t = Object(E.f)(a, {
							listingKey: e
						});
						if (O || t) return
					}
					o(w({
						key: e
					})), await o(d.i(b.id)), a = i();
					const _ = Object(y.d)(a, {
							categoryName: n
						}),
						v = g ? _.findIndex(e => e.id === g) + 1 : 0,
						S = _.slice(v, v + f.b);
					await Promise.all(S.map(e => o(u.k(l, e.name)))), o(P({
						fetchedToken: g,
						ids: S.map(e => {
							let {
								id: t
							} = e;
							return t
						}),
						key: e,
						token: _[Math.min(v + f.b - 1, _.length - 1)].id
					}))
				}, k = (e, t, n) => async (r, s, o) => {
					await Promise.all([r(u.h()), r(d.h())]);
					const i = t.categoryName ? () => r(A(e, t, t.categoryName, n)) : () => r(R(e, t, n));
					await Object(O.a)("explore", i), t.categoryName ? await r(A(e, t, t.categoryName, n)) : await r(R(e, t, n))
				}, N = e => async (t, n, s) => {
					const i = n();
					if (!Object(_.a)(i)) return void t(Object(r.b)("/"));
					const d = Object(c.a)(e.params);
					if (Object(E.h)(i, {
							listingKey: d
						})) return;
					const u = Object(a.a)(g.b.Popular, o.N.HOT);
					0 === Object(v.C)(i, {
						listingKey: u
					}).length && await t(Object(b.i)(u, g.b.Popular, {}, !0)), Object(I.K)(n()) ? t(Object(r.b)("/")) : (t(Object(l.k)({
						actionSource: l.a.Explore,
						redirectUrl: "/"
					})), await t(k(d, e.params)), t(p.l({
						title: S(n())
					})))
				}
		},
		"./src/reddit/actions/pages/modListing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			}));
			const r = "PAGE__MOD_LISTING_PAGE_PENDING",
				s = "PAGE__MOD_LISTING_PAGE_LOADED",
				o = "PAGE__MOD_LISTING_PAGE_FAILED",
				i = "MOD_LISTING_MORE_POSTS_PENDING",
				c = "MOD_LISTING_MORE_POSTS_LOADED",
				a = "MOD_LISTING_MORE_POSTS_FAILED",
				d = "MOD_LISTING_HIDE_SUBREDDIT_SUCCESS",
				u = "MOD_LISTING_HIDE_SUBREDDIT_PENDING",
				l = "MOD_LISTING_HIDE_SUBREDDIT_FAILED",
				b = "MOD_LISTING_UNHIDE_SUBREDDIT_SUCCESS",
				p = "MOD_LISTING_UNHIDE_SUBREDDIT_PENDING",
				m = "MOD_LISTING_UNHIDE_SUBREDDIT_FAILED"
		},
		"./src/reddit/actions/pages/modListing/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/platform.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/page.ts"),
				b = n("./src/reddit/constants/parameters.ts"),
				p = n("./src/config.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				O = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				h = n("./src/reddit/helpers/name/index.ts"),
				y = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				j = (e, t) => Object(m.b)(e, {
					data: t,
					endpoint: Object(O.a)(Object(y.a)("".concat(p.a.gatewayUrl, "/desktopapi/v1/mod"))),
					method: i.bb.GET
				});
			const _ = (e, t, n, r) => Object(m.b)(Object(f.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/filter/user/").concat(t, "/f/mod/").concat(Object(h.b)(n)),
					method: r ? i.bb.PUT : i.bb.DELETE,
					data: {
						model: JSON.stringify({
							name: Object(h.g)(n)
						})
					}
				}),
				E = (e, t, n) => _(e, t, n, !0),
				v = (e, t, n) => _(e, t, n, !1);
			var I = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				S = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				T = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				x = n("./src/reddit/i18n/utils.ts"),
				C = n("./src/reddit/models/Toast/index.ts"),
				w = n("./src/reddit/routes/modListing/index.ts"),
				P = n("./src/reddit/selectors/user.ts"),
				D = n("./src/reddit/actions/pages/modListing/constants.ts");
			n.d(t, "b", (function() {
				return L
			})), n.d(t, "c", (function() {
				return B
			})), n.d(t, "a", (function() {
				return J
			})), n.d(t, "d", (function() {
				return Q
			}));
			const R = Object(c.a)(D.f),
				A = Object(c.a)(D.e),
				k = Object(c.a)(D.d),
				N = (e, t) => async (n, r, s) => {
					const i = r(),
						c = i.listings.postOrder.api.pending[e],
						a = Object(P.T)(i);
					if (c) return;
					n(R({
						key: e
					}));
					const d = await Object(T.a)("modListing", () => j(s.apiContext(), t)),
						l = "error-".concat(e);
					d.ok ? (n(A(Object.assign({
						key: e,
						meta: i.meta
					}, d.body))), n(u.f(l))) : (n(k(Object.assign({
						error: d.error,
						key: e
					}, d.body))), 401 === d.status ? Object(S.a)(n, i) : n(u.e({
						id: l,
						kind: C.b.Error,
						text: Object(o.a)(a, "listings.toast.error"),
						buttonText: Object(o.a)(a, "listings.toast.retryButton"),
						buttonAction: N(e, t)
					})))
				}, L = (e, t) => async (n, r) => {
					const {
						sort: o = i.O
					} = e.params, c = Object(w.d)(e.path), u = c ? l.f : l.e, p = Object(a.a)(u, o, e.queryParams), m = r(), f = m.listings.postOrder.ids[p], g = m.listings.postOrder.api.error[p];
					if (m.listings.postOrder.api.pending[p] || f && !g && !t) return void(f && n(d.l({
						title: Object(x.c)("Subreddits you moderate")
					})));
					const O = G(e.queryParams);
					await n(N(p, Object.assign({}, s()(e.queryParams, b.k), s()(e.queryParams, b.j), {
						filtered: !!c || void 0,
						moderated_srs: !0,
						sort: o,
						t: Object(I.a)(o, O)
					}))), n(d.l({
						title: Object(x.c)("Subreddits you moderate")
					}))
				}, M = Object(c.a)(D.i), U = Object(c.a)(D.h), F = Object(c.a)(D.g), B = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const c = n(),
						d = c.platform.currentPage;
					if (!d) return;
					const {
						sort: u = i.O
					} = e, p = d.queryParams, m = Object(w.d)(d.url), f = m ? l.f : l.e, g = Object(a.a)(f, u, p), O = c.listings.postOrder.loadMore[g];
					if (!O) return;
					const h = c.listings.postOrder.api.pending[g],
						y = c.listings.postOrder.fetchedTokens,
						_ = !(!y[g] || !y[g][O.token]);
					if (h || _) return;
					const E = G(p);
					t(M({
						key: g,
						fetchedToken: O.token
					}));
					const v = await j(o(), Object.assign({
							after: O.token,
							dist: O.dist,
							filtered: !!m || void 0,
							sort: u,
							t: Object(I.a)(u, E)
						}, s()(p, b.k))),
						S = c.listings.postOrder.ids[g],
						T = Object.assign({}, v.body, {
							postIds: (v.body.postIds || []).filter(e => !S || !S.includes(e))
						});
					v.ok ? t(U(Object.assign({
						key: g,
						fetchedToken: O.token,
						meta: c.meta
					}, T))) : t(F(Object.assign({
						key: g,
						error: v.error,
						fetchedToken: O.token
					}, T)))
				};

			function G(e) {
				const t = b.t in e && e[b.t].toUpperCase() || "";
				return t in i.Ob && i.Ob[t]
			}
			const V = Object(c.a)(D.c),
				q = Object(c.a)(D.b),
				H = Object(c.a)(D.a),
				K = Object(c.a)(D.l),
				W = Object(c.a)(D.k),
				Y = Object(c.a)(D.j),
				z = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(P.i)(i),
						[a, d, u, l] = t ? [q, V, H, E] : [W, K, Y, v];
					if (!c || !c.displayText) return;
					const {
						currentPage: b
					} = i.platform;
					if (!b || !b.routeMatch) return;
					n(a(e));
					const p = await l(o(), c.displayText, e);
					p.ok ? (await n(L(b.routeMatch.match, !0)), n(d(e))) : n(u(p.body))
				}, J = e => z(e, !0), Q = e => z(e, !1)
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/app/strings/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/filterQueryParams/index.ts"),
				c = n("./src/lib/isFakeSubreddit/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/makePostCreationPageKey/index.ts"),
				u = n("./src/reddit/actions/economics/helpers/async.ts"),
				l = n("./src/reddit/actions/externalAccount.ts"),
				b = n("./src/reddit/actions/platform.ts"),
				p = n("./src/reddit/actions/post.ts"),
				m = n("./src/reddit/actions/postCreation/general.ts"),
				f = n("./src/reddit/actions/postRequirements/index.ts"),
				g = n("./src/reddit/actions/profile/index.ts"),
				O = n("./src/reddit/actions/subreddit.ts"),
				h = n("./src/reddit/actions/subredditDifficulty/index.ts"),
				y = n("./src/reddit/actions/subredditDuplicates.ts"),
				j = n("./src/config.ts"),
				_ = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				v = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				I = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				S = n("./src/reddit/helpers/trackers/postComposer.ts"),
				T = n("./src/reddit/models/User/index.ts"),
				x = n("./src/reddit/selectors/experiments/subredditDifficulty.ts"),
				C = n("./src/reddit/selectors/postCollection.ts"),
				w = n("./src/reddit/selectors/postCreations.ts"),
				P = n("./src/reddit/selectors/postRequirements.ts"),
				D = n("./src/reddit/selectors/posts.ts"),
				R = n("./src/reddit/selectors/profile.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/selectors/user.ts");
			n.d(t, "c", (function() {
				return L
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "d", (function() {
				return q
			})), n.d(t, "e", (function() {
				return H
			}));
			const N = e => {
					const t = e.user.language,
						n = e.platform.currentPage;
					let r = "Reddit";
					if (n && n.urlParams.subredditName) {
						const {
							subredditName: t
						} = n.urlParams, s = Object(A.B)(e, {
							subredditName: t
						});
						s && (r = s.name)
					}
					return Object(s.a)(t, "title.submit", {
						subreddit: r
					})
				},
				L = "POST_CREATION__PAGE_PENDING",
				M = "POST_CREATION__PAGE_LOADED",
				U = "POST_CREATION__PAGE_FAILED",
				F = Object(a.a)(L),
				B = Object(a.a)(M),
				G = Object(a.a)(U),
				V = () => async (e, t) => {
					const n = t(),
						r = Object(w.a)(n);
					r !== Object(w.ab)(n) && e(Object(m.h)({
						submissionType: r
					}))
				}, q = e => async (t, n, r) => {
					const {
						collectionId: s,
						profileName: i,
						subredditName: a
					} = e, u = Object(d.a)(e), b = n(), p = b.creations.api.page.pending[u], m = b.creations.api.page.fetched[u], h = b.creations.api.page.error[u];
					if (p) return;
					if (m && !h) return void t(V());
					const y = [];
					t(F({
						key: u
					}));
					let v = a;
					if (!a && i && (v = "u_".concat(i)), y.push(((e, t) => Object(_.b)(e, {
							method: o.bb.GET,
							endpoint: Object(E.a)("".concat(j.a.gatewayUrl, "/desktopapi/v1/submitpage")),
							data: {
								subreddit: t.subredditName,
								collection_id: t.collectionId
							}
						}))(r.apiContext(), {
							subredditName: v,
							collectionId: s
						})), a) {
						!!Object(P.b)(n(), {
							subredditName: a
						}) || Object(c.a)(a) || y.push(t(Object(f.a)(a)))
					}
					i && (y.push(t(g.d(i))), y.push(t(g.b(i))));
					const [S] = await Object(I.a)("postCreation", () => Promise.all(y));
					if (S.ok) {
						const e = S.body,
							{
								posts: r = {}
							} = e;
						await t(B(Object.assign({
							key: u,
							meta: b.meta
						}, e, {
							posts: r
						}))), t(V());
						const s = Object(k.i)(n());
						s && s.hasUserProfile && await t(g.d(Object(T.f)(s))), await t(l.o()), a && !Object(c.a)(a) && await t(O.o(a))
					} else t(G({
						error: S.error,
						key: u
					}))
				}, H = e => async (t, n) => {
					const {
						subredditName: s,
						profileName: c
					} = e.params, a = e.queryParams, d = a.collection;
					let l;
					if (await t(q({
							collectionId: d,
							profileName: c,
							subredditName: s
						})), s) {
						l = Object(A.B)(n(), {
							subredditName: s
						}), Object(x.e)(n()) && t(Object(h.a)(l.id)), await t(Object(u.a)({
							subredditName: s
						}))
					} else c && (l = Object(R.j)(n(), {
						profileName: c
					}));
					if (a.source_id) await t(((e, t) => async (n, r) => {
						const {
							subredditName: s,
							profileName: o
						} = e, i = [];
						let c;
						s ? c = Object(A.G)(r(), s) : o && (c = Object(k.ab)(r(), {
							userName: o
						})), c && i.push(n(Object(y.b)(c, t))), i.push(n(Object(p.D)(t))), await Promise.all(i);
						const a = Object(D.e)(r(), {
							postId: t
						});
						n(Object(m.l)({
							postId: t,
							postTitle: a ? a.title : ""
						}))
					})(e.params, a.source_id));
					else if (d) {
						const s = Object(C.q)(n(), {
							collectionId: d
						});
						l && s && s.subredditId === l.id || t(Object(r.c)(Object(i.a)(e.url, ["collection"])))
					}
					const f = n();
					Object(k.K)(f) ? (((e, t) => {
						const n = e.platform.lastPage;
						t && n && n.meta && n.meta.name === o.xb.POST_CREATION && S.u(e)
					})(n(), s), t(b.l({
						title: N(n())
					}))) : Object(v.a)(t, f)
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/makePostDraftPageKey/index.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				i = n("./src/config.ts"),
				c = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				u = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				l = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				b = n("./src/reddit/helpers/timeApiRoute/index.ts");
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return O
			}));
			const p = "POST_DRAFT__PAGE_LOADED",
				m = (Object(r.a)("POST_DRAFT__PAGE_PENDING"), Object(r.a)(p)),
				f = Object(r.a)("POST_DRAFT__PAGE_FAILED"),
				g = e => async (t, n, r) => {
					const {
						draftId: p,
						profileName: g
					} = e, O = Object(s.a)(e), h = n(), y = h.creations.api.page.pending[O], j = h.creations.api.page.fetched[O], _ = h.creations.api.page.error[O];
					if (y || j && !_ || !p) return;
					t(o.d(g));
					const E = await Object(b.a)("postDraft", () => ((e, t, n) => Object(a.b)(e, {
						endpoint: Object(d.a)(Object(u.a)("".concat(i.a.gatewayUrl, "/desktopapi/v1/draftpreviewpage/").concat(n, "/").concat(t))),
						method: c.bb.GET
					}))(r.apiContext(), p, g));
					if (E.ok) {
						const e = E.body;
						e.drafts[p].kind = Object(l.b)(e.drafts[p].kind), t(m(Object.assign({}, e, {
							key: O
						})))
					} else t(f({
						error: E.error,
						key: O
					}))
				}, O = e => async (t, n, r) => {
					await t(g(e.params))
				}
		},
		"./src/reddit/actions/pages/profileComments.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/difference.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/contentGate.ts"),
				u = n("./src/reddit/actions/externalAccount.ts"),
				l = n("./src/reddit/actions/moderatingSubreddits.ts"),
				b = n("./src/reddit/actions/pages/profileShared.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/actions/profile/index.ts"),
				f = n("./src/reddit/actions/subreddit.ts"),
				g = n("./src/reddit/constants/errors.ts"),
				O = n("./src/reddit/constants/parameters.ts"),
				h = n("./src/reddit/contexts/PageLayer/index.tsx"),
				y = n("./src/config.ts"),
				j = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				_ = n("./src/lib/constants/index.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				v = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const I = (e, t, n) => Object(E.b)(e, {
				data: n,
				endpoint: Object(j.a)(Object(v.a)("".concat(y.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/comments"))),
				method: _.bb.GET
			});
			var S = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				T = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				x = n("./src/reddit/selectors/profile.ts"),
				C = n("./src/reddit/selectors/profileComments.ts");
			n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "c", (function() {
				return L
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "g", (function() {
				return V
			}));
			const w = "PAGE__PROFILE_COMMENTS_PENDING",
				P = "PAGE__PROFILE_COMMENTS_LOADED",
				D = "PAGE__PROFILE_COMMENTS_FAILED",
				R = Object(c.a)(w),
				A = Object(c.a)(P),
				k = Object(c.a)(D),
				N = e => async (t, n, r) => {
					const {
						queryParams: s,
						params: o
					} = e, {
						sort: c,
						t: h
					} = Object(b.b)(s), {
						profileName: y
					} = o, j = Object(a.a)("u_".concat(y), c, e.queryParams), {
						profileCommentsPage: _
					} = n(), E = _.commentIds[j], v = _.api.error[j], C = _.api.pending[j];
					if (await t(m.d(y)), C || E && !v) {
						if (E) {
							const e = Object(x.q)(n(), {
								profileName: y
							});
							t(p.l({
								title: e
							}))
						}
						return
					}
					const w = Object.assign({}, i()(e.queryParams, [...O.k, O.g]), {
						sort: c,
						t: Object(S.a)(c, h)
					});
					t(R({
						key: j
					}));
					const P = await Object(T.a)("profileComments", () => I(r.apiContext(), y, w));
					if (!P.ok) return t(k({
						account: P.body.data ? P.body.data.account : null,
						error: P.body.reason ? {
							type: P.body.reason
						} : P.error,
						key: j
					})), P.body.reason === g.a.DeletedProfile && t(Object(d.l)({
						profileName: y
					})), void t(p.m(P.status));
					const D = P.body;
					t(A(Object.assign({
						key: j,
						meta: n().meta
					}, D))), await Promise.all([t(Object(b.c)(y)), t(Object(f.q)()), t(Object(l.b)()), t(u.o(y))])
				}, L = "PROFILE_COMMENTS__MORE_ITEMS_PENDING", M = "PROFILE_COMMENTS__MORE_ITEMS_LOADED", U = "PROFILE_COMMENTS__MORE_ITEMS_FAILED", F = Object(c.a)(L), B = Object(c.a)(M), G = Object(c.a)(U), V = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t(),
						{
							currentPage: c
						} = o.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: d,
						params: u
					} = c.routeMatch.match, {
						sort: l,
						t: p
					} = Object(b.b)(d), {
						profileName: m
					} = u, f = Object(a.a)("u_".concat(m), l, d), g = Object(C.d)(o, {
						listingKey: f
					});
					if (!g) return;
					const y = Object(C.b)(o, {
							listingKey: f
						}),
						j = Object(C.c)(o, {
							listingKey: f
						}),
						_ = j && j[g.token];
					if (y || _) return;
					e(F({
						key: f,
						fetchedToken: g.token
					}));
					const E = await I(r(), m, Object.assign({
						after: g.token,
						dist: g.dist,
						sort: l,
						t: p
					}, i()(d, O.k), {
						layout: Object(h.M)(o, {}).toLowerCase()
					}));
					if (E.ok) {
						const t = Object(C.f)(o, {
								listingKey: f
							}),
							n = Object.assign({}, E.body, {
								commentIds: s()(E.body.commentIds, t)
							});
						e(B(Object.assign({
							fetchedToken: g.token,
							key: f,
							meta: o.meta
						}, n)))
					} else e(G({
						account: E.body.data ? E.body.data.account : null,
						error: E.error,
						fetchedToken: g.token,
						key: f
					}))
				}
		},
		"./src/reddit/actions/pages/profileModSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/preferences.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				i = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				c = n("./src/reddit/models/User/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const d = "PAGE__PROFILE_MOD_SETTINGS_LOADED",
				u = Object(r.a)(d),
				l = e => async (t, n) => {
					const r = [t(s.x()), t(Object(o.d)(e.params.profileName))];
					await Promise.all(r);
					const d = Object(a.i)(n());
					d ? (await t(Object(o.b)(Object(c.f)(d))), t(u())) : Object(i.a)(t, n())
				}
		},
		"./src/reddit/actions/pages/profileOverview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "c", (function() {
				return w
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "g", (function() {
				return U
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/reddit/actions/moderatingSubreddits.ts"),
				i = n("./src/reddit/actions/pages/profileShared.ts"),
				c = n("./src/reddit/actions/subreddit.ts"),
				a = n("./src/reddit/endpoints/page/profileOverviewPage.ts"),
				d = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/constants/postLayout.ts"),
				l = n("./src/reddit/constants/parameters.ts"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/selectors/listings.ts"),
				m = n("./src/reddit/selectors/profile.ts"),
				f = n("./src/reddit/selectors/profileOverviewChronoItems.ts"),
				g = n("./src/lib/makeActionCreator/index.ts"),
				O = n("./src/reddit/actions/contentGate.ts"),
				h = n("./src/reddit/actions/externalAccount.ts"),
				y = n("./src/reddit/actions/pinnedPost.ts"),
				j = n("./src/reddit/actions/platform.ts"),
				_ = n("./src/reddit/actions/profile/index.ts"),
				E = n("./src/reddit/actions/trophyCase.ts"),
				v = n("./src/reddit/constants/errors.ts"),
				I = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				S = n("./src/reddit/helpers/timeApiRoute/index.ts");
			const T = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_PENDING",
				x = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_LOADED",
				C = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_FAILED",
				w = "PAGE__PROFILE_OVERVIEW_CHRONO_PENDING",
				P = "PAGE__PROFILE_OVERVIEW_CHRONO_LOADED",
				D = "PAGE__PROFILE_OVERVIEW_CHRONO_FAILED",
				R = Object(g.a)(T),
				A = Object(g.a)(x),
				k = Object(g.a)(C),
				N = Object(g.a)(w),
				L = Object(g.a)(P),
				M = Object(g.a)(D),
				U = e => async (t, n, r) => {
					const {
						queryParams: g,
						params: T
					} = e, {
						sort: x,
						t: C
					} = Object(i.a)(n(), g), {
						profileName: w
					} = T, P = u.e[Object(b.M)(n(), {})], D = w.toLowerCase(), U = Object.assign({}, s()(e.queryParams, l.k), {
						sort: x,
						layout: P,
						t: C
					});
					if (await t(_.d(D)), P === u.e[u.g.Compact]) {
						const r = Object(I.a)(D, d.ib, x, e.queryParams);
						if (n().profileOverviewPage.chrono.ids[r]) return;
						await t(((e, t, n, r) => async (r, s, o) => {
							const i = s(),
								c = !!Object(f.f)(i, {
									listingKey: e
								}).length,
								d = !!Object(f.a)(i, {
									listingKey: e
								});
							if (!!Object(f.b)(i, {
									listingKey: e
								}) || c && !d) return;
							r(N({
								key: e
							}));
							const u = await Object(S.a)("profile", () => Object(a.a)(o.apiContext(), t, n)),
								l = u.body,
								{
									pinned: b
								} = l;
							if (u.ok) {
								r(L(Object.assign({
									key: e,
									meta: i.meta
								}, l)));
								const n = Object(m.m)(i, t);
								r(Object(y.h)({
									profileId: n,
									pinned: b
								}))
							} else r(M({
								account: u.body.data ? u.body.data.account : null,
								error: u.body.reason ? {
									type: u.body.reason
								} : u.error,
								key: e
							})), u.body.reason === v.a.DeletedProfile && r(Object(O.l)({
								profileName: t
							})), r(Object(j.m)(u.status))
						})(r, D, U))
					} else {
						const r = Object(I.a)(D, d.jb, x, e.queryParams);
						if (n().listings.postOrder.ids[r] && !n().listings.postOrder.api.error[r]) return;
						await t(((e, t, n, r) => async (r, s, o) => {
							const i = s(),
								c = !!i.listings.postOrder.ids[e],
								d = !!Object(p.c)(i, {
									listingKey: e
								});
							if (!!Object(p.d)(i, {
									listingKey: e
								}) || c && !d) return;
							r(R({
								key: e
							}));
							const u = await Object(S.a)("profile", () => Object(a.b)(o.apiContext(), t, n)),
								l = u.body,
								{
									pinned: b,
									postIds: f
								} = l;
							if (u.ok) {
								r(A(Object.assign({
									key: e,
									meta: i.meta,
									profileName: t
								}, l, {
									postIds: f
								})));
								const n = Object(m.m)(i, t);
								r(Object(y.h)({
									profileId: n,
									pinned: b
								}))
							} else r(k({
								account: u.body.data ? u.body.data.account : null,
								error: u.body.reason ? {
									type: u.body.reason
								} : u.error,
								key: e
							})), u.body.reason === v.a.DeletedProfile && r(Object(O.l)({
								profileName: t
							})), r(Object(j.m)(u.status))
						})(r, D, U))
					}
					await t(Object(c.q)()), await t(Object(o.b)());
					const B = n();
					if (!B.platform.currentPage) return;
					if (200 !== B.platform.currentPage.status) return;
					const G = Object(m.m)(n(), D);
					await t(E.b(D, G)), t(j.l({
						title: F(n(), w)
					}));
					const V = [t(_.b(D)), t(h.o(w)), t(_.e(w))];
					await Promise.all(V)
				}, F = (e, t) => Object(m.q)(e, {
					profileName: t
				})
		},
		"./src/reddit/actions/pages/profilePosts.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				c = n("./src/reddit/actions/contentGate.ts"),
				a = n("./src/reddit/actions/externalAccount.ts"),
				d = n("./src/reddit/actions/moderatingSubreddits.ts"),
				u = n("./src/reddit/actions/pages/profileShared.ts"),
				l = n("./src/reddit/actions/pinnedPost.ts"),
				b = n("./src/reddit/actions/platform.ts"),
				p = n("./src/reddit/actions/profile/index.ts"),
				m = n("./src/reddit/actions/subreddit.ts"),
				f = n("./src/reddit/constants/errors.ts"),
				g = n("./src/reddit/constants/parameters.ts"),
				O = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/config.ts"),
				y = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				j = n("./src/lib/constants/index.ts"),
				_ = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const v = (e, t, n) => Object(_.b)(e, {
				data: n,
				endpoint: Object(y.a)(Object(E.a)("".concat(h.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/posts"))),
				method: j.bb.GET
			}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? Object.assign({}, e, {
				body: Object.assign({}, e.body, {
					pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
				})
			}) : e);
			var I = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				S = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				T = n("./src/reddit/selectors/listings.ts"),
				x = n("./src/reddit/selectors/profile.ts");
			n.d(t, "f", (function() {
				return C
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "h", (function() {
				return k
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "b", (function() {
				return L
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "g", (function() {
				return G
			}));
			const C = "PAGE__PROFILE_POSTS_PENDING",
				w = "PAGE__PROFILE_POSTS_LOADED",
				P = "PAGE__PROFILE_POSTS_FAILED",
				D = Object(o.a)(C),
				R = Object(o.a)(w),
				A = Object(o.a)(P),
				k = e => async (t, n, r) => {
					const {
						queryParams: o,
						params: h
					} = e, {
						sort: y,
						t: j
					} = Object(u.b)(o), {
						profileName: _
					} = h, E = Object(i.a)("u_".concat(_), y, o), C = n(), w = C.listings.postOrder.ids[E], P = Object(T.c)(C, {
						listingKey: E
					}), k = Object(T.d)(C, {
						listingKey: E
					});
					if (await t(p.d(_)), k || w && !P) {
						if (w) {
							const e = Object(x.q)(n(), {
								profileName: _
							});
							t(b.l({
								title: e
							}))
						}
						return
					}
					const N = Object.assign({}, s()(e.queryParams, [...g.k, ...g.j, g.g]), {
						layout: Object(O.M)(C, {}).toLowerCase(),
						sort: y,
						t: Object(I.a)(y, j)
					});
					t(D({
						key: E
					}));
					const L = await Object(S.a)("profilePosts", () => v(r.apiContext(), _, N));
					if (!L.ok) return t(A({
						account: L.body.data ? L.body.data.account : null,
						error: L.body.reason ? {
							type: L.body.reason
						} : L.error,
						key: E
					})), L.body.reason === f.a.DeletedProfile && t(Object(c.l)({
						profileName: _
					})), void t(b.m(L.status));
					const M = L.body;
					t(R(Object.assign({
						key: E,
						meta: n().meta
					}, M)));
					const U = Object(x.m)(n(), _),
						{
							pinned: F
						} = M;
					t(Object(l.h)({
						profileId: U,
						pinned: F
					})), await Promise.all([t(Object(u.c)(_)), t(Object(m.q)()), t(Object(d.b)()), t(a.o(_))])
				}, N = "PROFILE_POSTS__MORE_POSTS_PENDING", L = "PROFILE_POSTS__MORE_POSTS_LOADED", M = "PROFILE_POSTS__MORE_POSTS_FAILED", U = Object(o.a)(N), F = Object(o.a)(L), B = Object(o.a)(M), G = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t(),
						{
							currentPage: c
						} = o.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: a,
						params: d
					} = c.routeMatch.match, {
						sort: l,
						t: b
					} = Object(u.b)(a), {
						profileName: p
					} = d, m = Object(i.a)("u_".concat(p), l, a), f = Object(T.g)(o, {
						listingKey: m
					});
					if (!f) return;
					const h = Object(T.d)(o, {
							listingKey: m
						}),
						y = Object(T.e)(o, {
							listingKey: m,
							token: f.token
						});
					if (h || y) return;
					e(U({
						key: m,
						fetchedToken: f.token
					}));
					const j = Object.assign({
							after: f.token,
							dist: f.dist,
							sort: l,
							t: b
						}, s()(a, g.k), {
							layout: Object(O.M)(o, {}).toLowerCase()
						}),
						_ = await v(r(), p, j),
						E = o.listings.postOrder.ids[m],
						I = _.body.postIds || [],
						S = Object.assign({}, _.body, {
							postIds: I.filter(e => !E || !E.includes(e))
						});
					_.ok ? (e(F(Object.assign({
						fetchedToken: f.token,
						key: m,
						meta: o.meta
					}, S))), await e(Object(u.c)(p))) : e(B({
						account: _.body.data ? _.body.data.account : null,
						error: _.error,
						fetchedToken: f.token,
						key: m
					}))
				}
		},
		"./src/reddit/actions/pages/profilePrivate/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			}));
			const r = 25,
				s = "PAGE__PROFILE_PRIVATE_PENDING",
				o = "PAGE__PROFILE_PRIVATE_MIXED_LOADED",
				i = "PAGE__PROFILE_PRIVATE_POSTS_LOADED",
				c = "PAGE__PROFILE_PRIVATE_FAILED",
				a = "MORE__PROFILE_PRIVATE_PENDING",
				d = "MORE__PROFILE_PRIVATE_MIXED_LOADED",
				u = "MORE__PROFILE_PRIVATE_POSTS_LOADED",
				l = "MORE__PROFILE_PRIVATE_FAILED"
		},
		"./src/reddit/actions/pages/profileShared.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/defaults.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				c = n("./src/reddit/actions/platform.ts"),
				a = n("./src/reddit/actions/profile/index.ts"),
				d = n("./src/reddit/actions/trophyCase.ts"),
				u = n("./src/reddit/selectors/profile.ts"),
				l = n("./src/lib/constants/index.ts");
			const b = {
				sort: l.rb,
				t: l.sb
			};

			function p(e) {
				return s()(i()(e, ["t", "sort"]), b)
			}

			function m(e, t) {
				return p(t)
			}
			const f = e => async (t, n, r) => {
				const s = [t(g(e)), t(O(e)), t(Object(a.e)(e))];
				await Promise.all(s)
			}, g = e => async (t, n, r) => {
				const s = Object(u.m)(n(), e);
				await t(d.b(e, s))
			}, O = e => async (t, n, r) => {
				const s = Object(u.q)(n(), {
					profileName: e
				});
				t(c.l({
					title: s
				})), await t(a.b(e))
			}
		},
		"./src/reddit/actions/pages/report/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			const r = "REPORT_PAGE__FAILED",
				s = "REPORT_PAGE__PENDING",
				o = "REPORT_PAGE__LOADED",
				i = "REPORT_PAGE_INITIAL_REASON__SET"
		},
		"./src/reddit/actions/pages/search.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return I
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "e", (function() {
				return R
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeSearchKey/index.ts"),
				d = n("./src/reddit/actions/ads/index.ts"),
				u = n("./src/reddit/actions/category.ts"),
				l = n("./src/reddit/actions/communityFlairs/index.ts"),
				b = n("./src/reddit/actions/discoveryUnit.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/actions/search.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/constants/parameters.ts"),
				O = n("./src/reddit/endpoints/page/search.ts"),
				h = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				y = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				j = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				E = n("./src/reddit/selectors/subreddit.ts");
			const v = (e, t) => {
					const n = e.user.language;
					return Object(o.a)(n, "title.".concat(t))
				},
				I = "SEARCH__SEARCH_PENDING",
				S = "SEARCH__SEARCH_RESULTS_RECEIVED",
				T = "SEARCH__SEARCH_FAILED",
				x = Object(c.a)(I),
				C = Object(c.a)(S),
				w = Object(c.a)(T),
				P = (e, t) => Object(o.a)(e.user.language, "search.title", {
					query: t || "None"
				}),
				D = (e, t, n, r) => async (s, c, a) => {
					let {
						apiContext: p
					} = a;
					const v = c(),
						I = t[g.b],
						S = t.category;
					(I || S) && (await Promise.all([s(b.h()), s(u.h())]), S && await Promise.all([s(u.i(S, 10)), s(b.i(y.n, S))]));
					const {
						q: T
					} = t, P = !!T && i.yb.some(e => T.includes("".concat(e, ":")));
					let R = t.type.indexOf(i.Jb.Posts) > -1 || !(!n || !t.restrict_sr) || P;
					if (R) {
						const t = v.listings.postOrder.ids[e],
							n = v.listings.postOrder.api.error[e];
						R = !(v.listings.postOrder.api.pending[e] || t && !n)
					}
					let A = t.type.indexOf(i.Jb.Subreddits) > -1 || t.type.indexOf(i.Jb.Users) > -1;
					if (A) {
						const t = v.listings.listingOrder.identifiers[e],
							n = v.listings.listingOrder.api.error[e];
						A = !(v.listings.listingOrder.api.pending[e] || t && !n)
					}
					if (!R && !A) return void(v.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						s(Object(d.b)(_.a.SEARCH_RESULTS))
					}));
					t.q && s(Object(m.h)(t.q));
					const k = "error-".concat(e),
						{
							type: N
						} = t;
					s(x({
						key: e,
						type: N
					}));
					const L = await Object(h.a)("searchResults", () => Object(O.a)(p(), n, r, Object.assign({}, t, {
						type: (t.type || []).join(","),
						b: !P
					})));
					if (L.ok) {
						const o = {
								key: e,
								type: N,
								meta: v.meta,
								searchQuery: t.q,
								subredditName: n,
								username: r
							},
							i = L.body;
						if (s(C(Object.assign({
								categoryName: I
							}, o, i))), s(f.f(k)), s(Object(d.b)(_.a.SEARCH_RESULTS)), n) {
							const e = Object(E.G)(c(), n),
								t = Object(l.c)(i.posts, e),
								r = Object(l.b)(i.structuredStyles || {}),
								o = (r ? Object(l.d)(r) : []).concat(t);
							s(Object(l.a)(o, e))
						}
					} else s(w(Object.assign({
						key: e,
						error: L.error,
						type: N
					}, L.body))), s(f.e({
						id: k,
						kind: j.b.Error,
						text: Object(o.a)(v.user.language, "search.toast.error"),
						buttonText: Object(o.a)(v.user.language, "search.toast.retryButton"),
						buttonAction: D(e, t, n, r)
					}))
				}, R = e => async (t, n, r) => {
					const o = Object(a.c)(s()(e.queryParams, g.q)),
						c = e.params.subredditName || e.params.multiredditName,
						{
							username: d
						} = e.params,
						u = Object(a.b)(c, d, o),
						l = n();
					await t(D(u, o, c, d));
					const b = n();
					let m = !1;
					const {
						type: f = []
					} = o, O = f.indexOf(i.Jb.Posts) > -1, h = f.indexOf(i.Jb.Subreddits) > -1 || f.indexOf(i.Jb.Users) > -1;
					O && b.listings.postOrder.api.error[u] && (m = !0), h && b.listings.listingOrder.api.error[u] && (m = !0), t(m ? p.l({
						title: v(l, "frontpage")
					}) : p.l({
						title: P(b, o.q)
					}))
				}
		},
		"./src/reddit/actions/pages/shared.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = n("./src/reddit/helpers/routeKey/index.ts"),
				i = n("./src/reddit/helpers/trackers/screenview.ts"),
				c = n("./src/telemetry/index.ts"),
				a = n("./src/telemetry/models/Timer.ts");
			const d = (e, t) => {
					const n = e.user.language;
					return Object(r.a)(n, "title.".concat(t))
				},
				u = () => async (e, t) => {
					const n = t(),
						{
							currentPage: r
						} = n.platform;
					if (!r) return;
					const d = r.routeMatch,
						u = Object(s.a)(n),
						l = Object(o.c)(d, n, u);
					l && c.c.has(l) && Object(i.g)(d, n, a.TimerType.InApp, c.c.end(l))
				}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/some.js"),
				i = n.n(o),
				c = n("./src/app/strings/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/isAdHocMultireddit/index.ts"),
				u = n("./src/lib/isFakeSubreddit/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/makeListingKey/index.ts"),
				m = n("./src/lib/makeSearchKey/index.ts"),
				f = n("./src/reddit/actions/ads/index.ts"),
				g = n("./src/reddit/actions/category.ts"),
				O = n("./src/reddit/actions/communityFlairs/index.ts"),
				h = n("./src/reddit/actions/contentGate.ts"),
				y = n("./src/reddit/actions/discoveryUnit.ts"),
				j = n("./src/reddit/actions/economics/helpers/async.ts"),
				_ = n("./src/reddit/actions/externalAccount.ts"),
				E = n("./src/reddit/actions/moderatingSubreddits.ts"),
				v = n("./src/reddit/actions/pages/search.ts"),
				I = n("./src/reddit/actions/platform.ts"),
				S = n("./src/reddit/actions/railsWidgets.ts"),
				T = n("./src/reddit/actions/structuredStyles/index.ts"),
				x = n("./src/reddit/actions/subreddit.ts"),
				C = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/react-router-redux/es/index.js")),
				w = n("./src/reddit/actions/toaster.ts"),
				P = n("./src/reddit/helpers/localStorage/index.ts"),
				D = n("./src/reddit/models/Subreddit/index.ts"),
				R = n("./src/reddit/models/Toast/index.ts"),
				A = n("./src/reddit/routes/postCreation/constants.ts"),
				k = n("./src/reddit/selectors/moderatorPermissions.ts"),
				N = n("./src/reddit/selectors/platform.ts"),
				L = n("./src/reddit/selectors/subreddit.ts"),
				M = n("./src/reddit/selectors/user.ts"),
				U = n("./src/reddit/selectors/widgets.ts");
			const F = () => async (e, t, n) => {
				const r = t(),
					s = Object(N.f)(r);
				if (!s || s.type !== D.c.Public) return;
				const o = s.name,
					i = Object(N.m)(r),
					c = Object(L.y)(r, {
						subredditName: o
					});
				if (!c) return;
				const {
					activity7Day: a
				} = c, d = !!a && a >= 51 && a <= 100, l = !o || Object(u.a)(o), b = i && i.urlParams.subredditName === o, p = Object(M.K)(r), m = Object(k.g)(r, {
					subredditId: Object(L.G)(r, o)
				});
				if (l || b || Object(P.p)() || !d || !p || m) return;
				const f = Object(U.d)(t(), {
					subredditName: o
				});
				if (!f || !f.currentlyViewingCount) return;
				const g = (24 * f.currentlyViewingCount * 7).toString(),
					O = g[0].padEnd(g.length, "0");
				e(Object(w.e)({
					buttonAction: async () => e(Object(C.b)("/r/".concat(o).concat(A.b))),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: R.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(P.R)(),
					secondButtonText: "Dismiss",
					text: "There have been over ".concat(O, " visits to r/").concat(o, " in the past week. Create a new post and start the next conversation.")
				}))
			};
			var B = n("./src/reddit/actions/subredditSettings.ts"),
				G = n("./src/reddit/actions/tags/index.ts"),
				V = n("./src/reddit/constants/page.ts"),
				q = n("./src/reddit/constants/parameters.ts"),
				H = n("./src/reddit/constants/postLayout.ts"),
				K = n("./src/reddit/contexts/PageLayer/index.tsx"),
				W = n("./src/reddit/endpoints/governance/posts.ts"),
				Y = n("./src/reddit/endpoints/page/subredditPage.ts"),
				z = n("./src/reddit/helpers/canonicalUrls.ts"),
				J = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				Q = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				X = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				Z = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				$ = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				ee = n("./src/reddit/models/RichTextJson/index.ts"),
				te = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				ne = n("./src/reddit/selectors/communityFlairs.ts"),
				re = n("./src/reddit/selectors/experiments/categoriesPlacement.ts"),
				se = n("./src/reddit/selectors/experiments/exploreV2.ts"),
				oe = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				ie = n("./src/reddit/selectors/experiments/railsWidgets.ts"),
				ce = n("./src/reddit/selectors/experiments/topPosts.ts"),
				ae = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				de = n("./src/reddit/selectors/multireddit.ts"),
				ue = n("./src/reddit/selectors/posts.ts"),
				le = n("./src/reddit/actions/publicAccessNetwork/api.ts");
			n.d(t, "e", (function() {
				return be
			})), n.d(t, "c", (function() {
				return pe
			})), n.d(t, "b", (function() {
				return me
			})), n.d(t, "a", (function() {
				return fe
			})), n.d(t, "j", (function() {
				return ge
			})), n.d(t, "i", (function() {
				return ye
			})), n.d(t, "h", (function() {
				return je
			})), n.d(t, "d", (function() {
				return Ee
			})), n.d(t, "f", (function() {
				return ve
			})), n.d(t, "g", (function() {
				return Ie
			})), n.d(t, "k", (function() {
				return Se
			}));
			const be = (e, t) => async n => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: r,
							reason: s
						}
					} = e, o = r ? r.account : void 0, i = r && r.features || void 0, c = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (s === b.a.NotFoundSubreddit) n(h.k({
							account: o,
							features: i,
							subredditName: c
						}));
						else if (s === b.a.BannedSubreddit) {
						const e = r ? r.banMessage : void 0;
						n(h.j({
							banMessage: e,
							account: o,
							features: i,
							subredditName: c
						}))
					}
					if (403 === e.status)
						if (s === b.a.GoldSubreddit) n(h.m({
							account: o,
							features: i,
							subredditName: c
						}));
						else if (s === b.a.PrivateSubreddit) n(h.n({
						account: o,
						features: i,
						subredditDescription: r.description || "",
						subredditName: c
					}));
					else if (s === b.a.QuarantinedSubreddit) {
						const e = !r || void 0 === r.quarantineRequiresEmailOptin || r.quarantineRequiresEmailOptin;
						n(h.o({
							account: o,
							features: i,
							subredditName: c,
							quarantineRequiresEmail: e,
							quarantineMessage: r.quarantineMessage,
							quarantineMessageHtml: r.quarantineMessageHtml || "",
							quarantineMessageRTJson: r.quarantineMessageRTJson || ee.i
						}))
					}
				}
			}, pe = "PAGE__SUBREDDIT_PENDING", me = "PAGE__SUBREDDIT_LOADED", fe = "PAGE__SUBREDDIT_FAILED", ge = Object(l.a)(pe), Oe = Object(l.a)(me), he = Object(l.a)(fe), ye = (e, t, n, r) => async (s, o, d) => {
				const l = o(),
					b = Object(M.K)(l);
				if (l.listings.postOrder.api.pending[e]) return;
				const p = t !== V.d.All && t !== V.d.Popular || !l.posts.recent.length ? n : Object.assign({}, n, {
					recentPostIds: l.posts.recent
				});
				p.layout = H.e[Object(K.M)(l, {})], s(ge({
					key: e
				}));
				const m = Object(oe.b)(l) ? () => Object(Y.b)(d.gqlContext(), Object(Y.c)(l, t, p), b) : () => Object(Y.a)(d.apiContext(), t, p),
					h = await Object(X.a)("subreddit", m),
					y = h.body;
				s(I.m(h.status));
				const v = "error-".concat(e),
					T = Object(u.a)(t) || i()(y.subreddits, e => e.name.toLowerCase() === t.toLowerCase());
				if (h.ok && T) {
					let n;
					const i = y.postIds.filter(e => !!y.posts[e].isMeta);
					if (i.length) {
						const e = Object.keys(y.subreddits).reduce((e, n) => {
							const r = y.subreddits[n];
							return r.name.toLowerCase() === t.toLowerCase() ? r.id : e
						}, null);
						if (e) {
							const t = await Object(W.a)(d.apiContext(), e, i);
							t.ok && (n = t.body)
						}
					}
					if (s(Oe(Object.assign({
							key: e,
							meta: l.meta,
							governance: n
						}, y, {
							postIds: y.postIds
						}))), !Object(u.a)(t)) {
						const e = Object(L.G)(o(), t);
						!!Object(L.R)(l, {
							subredditId: e
						}) || await x.o(t)(s, o, d);
						const n = Object(O.c)(y.posts, e),
							r = Object(O.b)(y.structuredStyles),
							i = (r ? Object(O.d)(r) : []).concat(n);
						s(Object(O.a)(i, e))
					}
					const c = [E.c()(s, o, d)];
					t === V.d.Popular && ((Object(se.a)(l) || Object(re.g)(l)) && c.push(s(g.h())), Object(ie.e)(l) && c.push(s(Object(S.a)()))), await Promise.all(c), r && s(w.f(v)), s(Object(f.b)(te.a.SUBREDDIT)), s(Object(_.p)());
					const a = Object(L.G)(o(), t);
					if (a) {
						const e = [s(Object(j.a)({
							subredditId: a,
							postIds: y.postIds,
							skip: ["subscription"]
						}))];
						Object(ae.a)(o(), {
							subredditId: a
						}) && e.push(s(Object(B.f)(t, a)), s(Object(G.i)(a, Z.a.idCard))), await Promise.all(e)
					}
				} else {
					if (403 === h.status || 404 === h.status) return void s(be(h, t));
					s(he(Object.assign({
						error: !h.ok && h.error || {
							type: a.D.NOT_FOUND_ERROR
						},
						key: e
					}, y))), r && s(w.e({
						id: v,
						kind: R.b.Error,
						text: Object(c.a)(l.user.language, "listings.toast.error"),
						buttonText: Object(c.a)(l.user.language, "listings.toast.retryButton"),
						buttonAction: ye(e, t, n, r)
					}))
				}
			}, je = (e, t, n) => async (r, s) => {
				const o = s(),
					i = Object(p.a)(e, t.sort, t);
				Object(ue.C)(o, {
					listingKey: i
				}).length > 0 || await r(ye(i, e, t, n))
			}, _e = (e, t) => {
				if (Object(u.a)(t)) {
					if (Object(d.a)(t)) {
						return Object(de.a)(e, {
							listingName: t
						}).displayText
					}
					switch (t.toLowerCase()) {
						case V.d.Popular:
							return "r/popular";
						case V.d.All:
							return "r/all"
					}
				}
				return Object(L.V)(e, {
					subredditName: t
				})
			}, Ee = (e, t) => {
				const n = e.f;
				if (n) return {
					[q.o]: n,
					[q.p]: "1",
					[q.h]: t ? "1" : "",
					sort: a.Hb.New
				}
			}, ve = (e, t) => {
				const n = Ee(e, t);
				return n && Object(m.c)(n)
			}, Ie = (e, t, n, r) => r ? Object(m.b)(e, void 0, r) : Object(p.a)(e, t, n), Se = (e, t) => async (n, r, o) => {
				const {
					subredditName: i
				} = e.params, {
					styling: c
				} = e.queryParams, d = r(), l = Object(J.a)(e.params), b = ve(e.queryParams, Object(M.Y)(d)), m = Ie(i, l, e.queryParams, b), g = l, h = d.listings.postOrder.api.error[m], j = d.listings.postOrder.api.pending[m];
				let E = !!d.listings.postOrder.ids[m];
				const S = d.listings.postOrder.listingSort[m];
				S && S.hasChanged && (E = !1);
				let x = Object(L.G)(d, i);
				const C = (e, t) => "true" === c && ((e, t) => Object(k.a)($.c.config)(e, {
						subredditId: t
					}) || Object(k.a)($.c.flair)(e, {
						subredditId: t
					}))(e, t),
					w = q.t in e.queryParams && e.queryParams[q.t].toUpperCase() || "",
					P = w in a.Ob && a.Ob[w];
				if (j || E && !h && !t) {
					if (C(d, x) && n(T.i(x)), E) {
						const t = _e(r(), i);
						n(I.l({
							title: t
						})), Object(z.e)(r(), n, e), window.addEventListener("load", () => {
							n(Object(_.p)())
						}), d.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							n(Object(f.b)(te.a.SUBREDDIT))
						}), n(F())
					}
					return
				}
				n(y.h());
				const D = n(Object(le.c)("r/".concat(i)));
				if (b) await n(Object(v.d)(m, b, i));
				else {
					const t = Object.assign({}, s()(e.queryParams, [...q.k, ...q.j, q.g]), {
							sort: g,
							t: Object(Q.a)(g, P)
						}),
						r = d.user.prefs.geopopular || d.meta.country;
					!t[q.g] && r && (t[q.g] = r), await n(ye(m, i, t, !0))
				}
				const R = d.platform.currentPage,
					A = Object(ce.d)(d, {
						pageLayer: R
					});
				if (Object(ce.a)(A) || Object(ce.b)(A) || Object(ce.c)(A)) {
					const e = Object(p.a)(i, a.N.TOP, {
							t: a.Ob.WEEK
						}),
						t = {
							sort: a.N.TOP,
							t: a.Ob.WEEK
						};
					await n(ye(e, i, t, !1))
				}
				x = x || Object(L.G)(r(), i), Object(ne.a)(d, x) || Object(u.a)(i) || await n(Object(O.e)(i)), C(r(), x) && n(T.i(x)), Object(z.e)(r(), n, e);
				const N = _e(r(), i);
				n(I.l({
					title: N
				})), n(F()), await D
			}
		},
		"./src/reddit/actions/pages/subredditLeaderboard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "b", (function() {
				return y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/reddit/actions/category.ts"),
				o = n("./src/reddit/actions/modal.ts"),
				i = n("./src/reddit/actions/platform.ts"),
				c = n("./src/reddit/actions/subreddit/topSubreddits.ts"),
				a = n("./src/reddit/actions/users.ts"),
				d = n("./src/reddit/constants/listings.ts"),
				u = n("./src/reddit/constants/subredditLeaderboard.ts"),
				l = n("./src/reddit/helpers/categoryPickerWidget/index.ts"),
				b = n("./src/reddit/i18n/utils.ts"),
				p = n("./src/reddit/selectors/category.ts"),
				m = n("./src/reddit/selectors/experiments/upAndComingLeaderboard.ts"),
				f = n("./src/reddit/selectors/subredditLeaderboard.ts"),
				g = n("./src/reddit/selectors/user.ts");
			const O = (e, t) => t && e === u.h,
				h = e => async (t, n) => {
					t(Object(o.k)({
						actionSource: o.a.SubredditLeaderboard,
						redirectUrl: d.c[d.b.SubredditLeaderboard]
					})), t(i.l({
						title: Object(b.c)("Todays Top Communities")
					}));
					const s = e.params && e.params.categoryName,
						c = s && Object(l.b)(s);
					Object(m.b)(n()) || c !== u.m || t(Object(r.b)("/subreddits/leaderboard")), await t(y(c))
				}, y = e => async (t, n) => {
					await t(Object(s.h)());
					const r = n(),
						o = Object(g.L)(r),
						i = Object(m.b)(r) && e === u.m;
					if (Object(f.a)(r, e)) return;
					const d = e && Object(p.h)(r, {
							categoryName: e
						}),
						l = d && d.id || u.d,
						b = O(e, o),
						h = ((e, t) => ({
							categoryId: e,
							isOnlyModIncluded: t
						}))(l, b),
						y = Object(f.d)(l, b, i);
					await Promise.all([t(Object(c.a)(h, y)), t(Object(a.u)())])
				}
		},
		"./src/reddit/actions/pages/subredditWiki/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = "PAGE__SUBREDDIT_WIKI_PAGE_PENDING",
				s = "PAGE__SUBREDDIT_WIKI_PAGE_LOADED",
				o = "PAGE__SUBREDDIT_WIKI_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/topic.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/makeListingKey/index.ts"),
				o = n("./src/reddit/actions/platform.ts"),
				i = n("./src/reddit/constants/listings.ts"),
				c = n("./src/graphql/operations/TopicBySlug.json"),
				a = n("./src/lib/makeGqlRequest/index.ts");
			var d = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				b = n("./src/reddit/i18n/utils.ts"),
				p = n("./src/reddit/models/Post/index.ts"),
				m = n("./node_modules/reselect/es/index.js"),
				f = n("./src/reddit/constants/experiments.ts"),
				g = n("./src/reddit/helpers/chooseVariant/index.ts"),
				O = n("./src/reddit/selectors/experiments/utils.ts");
			const h = Object(m.a)(e => Object(g.c)(e, {
				experimentEligibilitySelector: g.a,
				experimentName: f.t
			}), O.a);
			var y = n("./src/reddit/selectors/listings.ts"),
				j = n("./src/reddit/selectors/topic.ts");
			n.d(t, "f", (function() {
				return _
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "g", (function() {
				return L
			}));
			const _ = "TOPIC_PAGE__DATA_PENDING",
				E = "TOPIC_PAGE__DATA_LOADED",
				v = "TOPIC_PAGE__DATA_FAILED",
				I = Object(r.a)(_),
				S = Object(r.a)(E),
				T = Object(r.a)(v),
				x = "TOPIC_PAGE__MORE_POSTS_PENDING",
				C = "TOPIC_PAGE__MORE_POSTS_LOADED",
				w = "TOPIC_PAGE__MORE_POSTS_FAILED",
				P = Object(r.a)(x),
				D = Object(r.a)(C),
				R = Object(r.a)(w),
				A = async (e, t, n) => {
					const r = await ((e, t) => Object(a.a)(e, Object.assign({}, c, {
						variables: t
					})))(e, Object.assign({
						includeTopic: !0,
						includePosts: !0,
						includeSubreddits: !0,
						firstPosts: 20,
						firstSubreddits: 30,
						topicSlug: t
					}, n));
					if (!r.ok) throw r;
					return (e => {
						const t = {},
							n = [],
							r = {},
							s = {};
						if (!e.topicBySlug) return;
						const o = e.topicBySlug.posts && e.topicBySlug.posts.edges || [];
						for (const u of o) {
							const e = u && u.node;
							if (e && (n.push(e.id), t[e.id] = Object(d.d)(e), e.__typename === p.f.SubredditPost && e.subreddit && e.subreddit.id)) {
								const {
									subreddit: t
								} = e;
								r[t.id] = Object(l.a)(t)
							}
						}
						const i = [],
							c = e.topicBySlug.subreddits && e.topicBySlug.subreddits.edges || [];
						for (const d of c) {
							const e = d && d.node;
							if (e && e.id) {
								r[e.id] = Object(l.a)(e);
								const t = Object(u.a)(e)[e.id];
								t && (s[e.id] = t, i.push(e.id))
							}
						}
						const a = {
								id: e.topicBySlug.id,
								name: e.topicBySlug.name,
								namePlural: e.topicBySlug.namePlural,
								slug: e.topicBySlug.slug,
								subredditIds: i
							},
							b = a.id ? {
								[a.id]: a
							} : void 0,
							m = e.topicBySlug.posts && e.topicBySlug.posts.pageInfo;
						return {
							postIds: n,
							posts: t,
							subredditAboutInfo: s,
							subreddits: r,
							token: m && m.hasNextPage ? m.endCursor : void 0,
							topics: b
						}
					})(r.body.data)
				}, k = (e, t) => {
					const n = Object(j.b)(e, t, !0);
					return n && Object(b.c)("".concat(n, " on Reddit"))
				}, N = (e, t) => async (n, r, c) => {
					let {
						gqlContext: a
					} = c;
					const d = r();
					if (!h(d)) return void n(o.m(404));
					const u = e.params.topicSlug,
						l = Object(s.a)(i.b.Topic, null, Object.assign({}, e.params, {
							topicSlug: u
						})),
						b = Object(y.c)(d, {
							listingKey: l
						}),
						p = Object(y.d)(d, {
							listingKey: l
						}),
						m = !!d.listings.postOrder.ids[l];
					if (p || m && !b && !t) {
						if (m) {
							const e = k(r(), u);
							e && n(o.l({
								title: e
							}))
						}
						return
					}
					let f;
					n(I({
						key: l
					}));
					try {
						f = await A(a(), u)
					} catch (O) {
						const e = O.error;
						if (!(e.fields && e.fields.some(e => "Topic not found" === e.msg))) throw n(T({
							key: l,
							error: e
						})), n(o.m(O.status || 500)), new Error("Topic page fetching failed: upstream service error")
					}
					if (!(e => !!(e && e.topics && Object.keys(e.topics).length > 0 && (Object.keys(e.posts).length > 0 || Object.keys(e.subreddits).length > 0)))(f)) return void n(o.m(404));
					n(S(Object.assign({}, f, {
						key: l,
						meta: d.meta
					})));
					const g = k(r(), u);
					g && n(o.l({
						title: g
					}))
				}, L = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const c = n(),
						a = e.topicSlug,
						d = Object(s.a)(i.b.Topic, null, e),
						u = Object(y.g)(c, {
							listingKey: d
						});
					if (!u) return;
					const l = Object(y.d)(c, {
							listingKey: d
						}),
						b = Object(y.e)(c, {
							listingKey: d,
							token: u.token
						});
					if (l || b) return;
					let p;
					t(P({
						key: d
					}));
					try {
						p = await A(o(), a, {
							afterPosts: u.token,
							includeSubreddits: !1,
							includeTopic: !1
						})
					} catch (m) {
						return void t(R({
							key: d,
							error: m
						}))
					}
					p && t(D(Object.assign({}, p, {
						key: d,
						fetchedToken: u.token,
						meta: c.meta
					})))
				}
		},
		"./src/reddit/actions/pages/userDataRequest/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/me/index.ts"),
				o = n("./src/graphql/operations/UserDataExportEligibility.json"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/selectors/userDataRequest.ts");
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return g
			}));
			const u = "USER_DATA_REQUEST_PAGE_LOADING",
				l = "USER_DATA_REQUEST_PAGE_LOADED",
				b = "USER_DATA_REQUEST_PAGE_FAILED",
				p = Object(r.a)(u),
				m = Object(r.a)(l),
				f = Object(r.a)(b),
				g = () => async (e, t, n) => {
					let {
						apiContext: r,
						gqlContext: u
					} = n;
					const l = t(),
						b = Object(a.i)(l),
						g = Object(d.b)(l);
					if (b && g.success) return;
					e(p());
					const O = await Object(s.a)(r());
					if (!O.ok || !O.body) return void e(f(O.error));
					if (!O.body.account) return void Object(c.a)(e, l);
					const h = await (e => Object(i.a)(e, Object.assign({}, o)))(u());
					if (!h.ok) return void e(f());
					const y = O.body,
						j = h.body;
					e(m({
						account: y.account,
						userDataExportEligibility: j.data.identity.userDataExportEligibility.isUserEligibleForDataExport
					}))
				}
		},
		"./src/reddit/actions/pinnedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "i", (function() {
				return A
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/constants/modals.ts"),
				d = n("./src/reddit/endpoints/post/index.tsx"),
				u = n("./src/reddit/models/Toast/index.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/profile.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const m = "PINNEDPOST__PINNED_POSTS_LOADED",
				f = Object(o.a)(m),
				g = "PINNEDPOST__PIN_POST_SUCCESS",
				O = "PINNEDPOST__UNPIN_POST_SUCCESS",
				h = Object(o.a)(g),
				y = Object(o.a)(O),
				j = "PINNEDPOST__PIN_POST_PENDING",
				_ = "PINNEDPOST__UNPIN_POST_PENDING",
				E = Object(o.a)(j),
				v = Object(o.a)(_),
				I = "PINNEDPOST__PIN_POST_FAILURE",
				S = "PINNEDPOST__UNPIN_POST_FAILURE",
				T = Object(o.a)(I),
				x = Object(o.a)(S),
				C = (e, t) => Object(c.e)({
					buttonAction: A(t, !0),
					buttonText: Object(r.a)(e, "posts.postPinnedUndo"),
					kind: u.b.SuccessMod,
					text: Object(r.a)(e, "posts.postPinned")
				}),
				w = (e, t, n) => Object(c.e)({
					buttonAction: A(t, !0),
					buttonText: Object(r.a)(e, "posts.postUnpinnedUndo"),
					kind: u.b.SuccessMod,
					text: Object(r.a)(e, n ? "posts.postUnpinnedReloadPage" : "posts.postUnpinned")
				}),
				P = e => Object(c.e)({
					kind: u.b.Error,
					text: Object(r.a)(e, "posts.couldNotPinPost")
				}),
				D = e => Object(c.e)({
					kind: u.b.Error,
					text: Object(r.a)(e, "posts.couldNotPinPostRemovedPost")
				}),
				R = e => Object(c.e)({
					kind: u.b.Error,
					text: Object(r.a)(e, "posts.couldNotUnpinPost")
				}),
				A = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, r, o) => {
						let {
							apiContext: c
						} = o;
						const u = r(),
							m = u.posts.models[e];
						if (!m) return;
						const f = !Object(l.t)(u, {
								postId: e
							}),
							g = Object(p.T)(u);
						if (f && m.isRemoved) return n(D(g));
						const O = m.author,
							j = Object(b.m)(u, O),
							[_, I, S, A, k] = f ? [E, h, T, C, P] : [v, y, x, w, R];
						if (f) {
							if (Object(l.Q)(u, {
									profileName: O
								}).length >= s.U) return void n(Object(i.i)(a.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const N = Object(l.n)(u, e, O),
							L = !f && N;
						n(_({
							postId: e,
							profileId: j
						})), (await Object(d.s)(c(), e, f, !0)).ok ? (n(I({
							postId: e,
							profileId: j
						})), t || n(A(g, e, L))) : (n(S({
							postId: e,
							profileId: j
						})), n(k(g)))
					}
				}
		},
		"./src/reddit/actions/platform.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.search.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./src/lib/areUrlsEqual/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/logs/errors.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/matchRoute/index.ts"),
				a = (n("./src/lib/addQueryParams/index.ts"), n("./src/reddit/actions/monthsToMinutes.ts")),
				d = n("./src/reddit/constants/experiments.ts"),
				u = n("./src/reddit/constants/listings.ts"),
				l = n("./src/reddit/helpers/routeKey/index.ts"),
				b = n("./src/reddit/selectors/experiments/postSeo.ts");
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/helpers/chooseVariant/index.ts");
			new Set([s.xb.COMMENTS, s.xb.INDEX, s.xb.LISTING, s.xb.PROFILE_COMMENTS, s.xb.PROFILE_OVERVIEW, s.xb.PROFILE_POSTS, s.xb.SUBREDDIT]);
			var p = n("./src/reddit/selectors/monthsToMinutes.ts"),
				m = n("./src/reddit/selectors/platform.ts");
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "m", (function() {
				return S
			})), n.d(t, "l", (function() {
				return T
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "g", (function() {
				return w
			}));
			const f = "PLATFORM__HISTORY_LOCATION_SET",
				g = "PLATFORM__INITIAL_REFERRER_SET",
				O = "PLATFORM__NAVIGATION_CONFIRMATION_REQUESTED",
				h = "PLATFORM__NAVIGATION_CONFIRMATION_DISCARDED",
				y = "PLATFORM__PAGE_META_SET",
				j = "PLATFORM__PAGE_STATUS_SET",
				_ = e => async (t, n, r) => {
					const {
						currentPage: s
					} = n().platform;
					if (!s) return;
					const o = Object(c.a)(s.url, e);
					o && o.route.action(o.match)(t, n, r)
				}, E = (e, t, n) => async (o, i, c) => {
					const f = i().platform.currentPage;
					(!n || n.route.chunk === s.o.SUBREDDIT && u.a.has(n.match.params.subredditName.toLowerCase())) && window.location.replace("https://www.reddit.com".concat(e.pathname).concat(e.search));
					const g = n ? Object(l.d)(n, i()).listingKey : null,
						{
							user: O
						} = i(),
						h = n && n.match && n.match.queryParams,
						y = h && h["experiment_".concat(d.hb)];
					Object(b.h)(i()), e.pathname.split("/").some(e => "comments" === e), Object(m.i)(i());
					o(v({
						action: t,
						listingKey: g,
						location: e,
						routeMatch: n,
						user: O
					}));
					const j = i();
					if (!Object(p.w)(j) || Object(p.p)(j) || Object(p.a)(j) || o(Object(a.j)()), (!f || !Object(r.a)(f.url, e)) && n) {
						const {
							match: e
						} = n;
						await n.route.action(e)(o, i, c)
					}
				}, v = Object(i.a)(f), I = (Object(i.a)(g), Object(i.a)(y)), S = Object(i.a)(j), T = e => async (t, n, r) => {
					const s = n(),
						{
							currentPage: o
						} = s.platform;
					if (!o) return;
					const {
						key: i
					} = o;
					await t(I({
						key: i,
						meta: e
					}))
				}, x = Object(i.a)(O), C = Object(i.a)(h), w = () => async (e, t, n) => {
					if (window !== window.parent) {
						Object(o.b)(n.apiContext(), {
							extra: {
								errorType: s.p.NOT_ALLOWED_ACCESS,
								value: "Page was unexpectedly loaded inside iframe"
							}
						});
						try {
							window.top.location.href = window.location.href
						} catch (r) {}
					}
				}
		},
		"./src/reddit/actions/polls.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "POLLS__POLL_CREATION_UPDATED",
				o = Object(r.a)(s)
		},
		"./src/reddit/actions/post.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./node_modules/js-cookie/src/js.cookie.js"),
				o = n.n(s),
				i = n("./src/app/strings/index.ts"),
				c = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/lib/copyToClipboard/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/login.ts"),
				l = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/reportFlow.ts"),
				p = n("./src/reddit/actions/video.ts"),
				m = n("./src/reddit/actions/vote.ts"),
				f = n("./src/reddit/constants/cookie.ts"),
				g = n("./src/reddit/constants/history.ts"),
				O = n("./src/reddit/constants/posts.ts"),
				h = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				y = n("./src/reddit/helpers/overlay/index.ts"),
				j = n("./src/reddit/i18n/utils.ts"),
				_ = n("./src/reddit/models/Media/index.ts"),
				E = n("./src/reddit/endpoints/post/index.tsx"),
				v = n("./src/lib/makeGqlRequest/index.ts"),
				I = n("./src/graphql/operations/SinglePost.json");
			var S = n("./src/graphql/operations/RichTextPostContent.json");
			var T = n("./src/lib/constants/index.ts"),
				x = n("./src/lib/makeListingKey/index.ts"),
				C = n("./node_modules/react-router-redux/es/index.js"),
				w = n("./src/reddit/actions/modal.ts"),
				P = n("./src/reddit/actions/toaster.ts"),
				D = n("./src/reddit/constants/adEvents.ts"),
				R = n("./src/reddit/constants/modals.ts"),
				A = n("./src/reddit/endpoints/page/commentsPage.ts"),
				k = n("./src/reddit/helpers/pixels.ts"),
				N = n("./src/reddit/helpers/trackers/post.ts"),
				L = n("./src/reddit/models/Flair/index.ts"),
				M = n("./src/reddit/models/Toast/index.ts"),
				U = n("./src/reddit/models/User/index.ts"),
				F = n("./src/reddit/models/Vote/index.ts"),
				B = n("./src/reddit/selectors/platform.ts"),
				G = n("./src/reddit/selectors/user.ts"),
				V = n("./src/reddit/constants/viewabilityEvents.ts"),
				q = n("./src/reddit/selectors/posts.ts"),
				H = n("./src/telemetry/index.ts");
			n.d(t, "c", (function() {
				return K
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "f", (function() {
				return Y
			})), n.d(t, "e", (function() {
				return z
			})), n.d(t, "p", (function() {
				return J
			})), n.d(t, "j", (function() {
				return X
			})), n.d(t, "E", (function() {
				return $
			})), n.d(t, "K", (function() {
				return ee
			})), n.d(t, "G", (function() {
				return te
			})), n.d(t, "N", (function() {
				return re
			})), n.d(t, "o", (function() {
				return se
			})), n.d(t, "A", (function() {
				return ie
			})), n.d(t, "B", (function() {
				return ce
			})), n.d(t, "a", (function() {
				return ae
			})), n.d(t, "b", (function() {
				return de
			})), n.d(t, "C", (function() {
				return be
			})), n.d(t, "l", (function() {
				return pe
			})), n.d(t, "F", (function() {
				return me
			})), n.d(t, "z", (function() {
				return fe
			})), n.d(t, "u", (function() {
				return ge
			})), n.d(t, "J", (function() {
				return Oe
			})), n.d(t, "w", (function() {
				return he
			})), n.d(t, "v", (function() {
				return ye
			})), n.d(t, "n", (function() {
				return je
			})), n.d(t, "L", (function() {
				return _e
			})), n.d(t, "M", (function() {
				return Ee
			})), n.d(t, "t", (function() {
				return Ie
			})), n.d(t, "g", (function() {
				return Se
			})), n.d(t, "m", (function() {
				return xe
			})), n.d(t, "k", (function() {
				return Ce
			})), n.d(t, "H", (function() {
				return we
			})), n.d(t, "y", (function() {
				return Pe
			})), n.d(t, "D", (function() {
				return De
			})), n.d(t, "s", (function() {
				return Re
			})), n.d(t, "x", (function() {
				return Ae
			})), n.d(t, "h", (function() {
				return ke
			})), n.d(t, "r", (function() {
				return Le
			})), n.d(t, "I", (function() {
				return Me
			})), n.d(t, "i", (function() {
				return Ue
			})), n.d(t, "q", (function() {
				return Be
			}));
			const K = "POST__EXPANDED_TOGGLED",
				W = "POST__FOCUS_CHANGED",
				Y = "POSTS__MUTATED",
				z = "POSTS_LOADED",
				J = Object(d.a)(K),
				Q = (Object(d.a)(W), Object(d.a)(z)),
				X = "POST__STICKY_POST_SUCCESS",
				Z = Object(d.a)(X),
				$ = Object(d.a)(Y),
				ee = (e, t, n, r) => async (s, o, c) => {
					let {
						apiContext: a
					} = c;
					const d = o().posts.models[e];
					if (!d) return;
					if (!Object(G.K)(o())) return s(Object(w.k)({
						actionSource: w.a.Hide,
						redirectUrl: d.permalink
					})), void s(Object(u.f)());
					s($({
						[e]: {
							hidden: t
						}
					}));
					const l = o(),
						b = Object(G.T)(l);
					let p;
					if ((p = t ? await Object(E.g)(a(), e) : await Object(E.t)(a(), e)).ok) {
						if (r) {
							const r = t ? Object(i.a)(b, "posts.hiddenSuccess") : Object(i.a)(b, "posts.unhiddenSuccess"),
								o = Object(P.d)(r, M.b.Undo, Object(i.a)(b, "posts.hiddenUndo"), ee(e, !t, n, !1));
							s(Object(P.e)(o))
						}
					} else if (s($({
							[e]: {
								hidden: !t
							}
						})), r) {
						const e = Object(P.d)(Object(i.a)(b, "error.generic"), M.b.Error);
						s(Object(P.e)(e))
					}
				}, te = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().posts.models[e];
					if (!o) return;
					if (!Object(G.K)(n())) return t(Object(u.f)()), void t(Object(w.k)({
						actionSource: w.a.Save,
						redirectUrl: o.permalink
					}));
					const c = o.saved ? E.x : E.o;
					if (t($({
							[e]: {
								saved: !o.saved
							}
						})), (await c(s(), e)).ok) {
						const r = Object(G.T)(n()),
							s = o.saved ? Object(i.a)(r, "posts.unsavedSuccess") : Object(i.a)(r, "posts.savedSuccess"),
							c = Object(P.d)(s, M.b.Undo, Object(i.a)(r, "posts.savedUndo"), te(e));
						t(Object(P.e)(c))
					} else t($({
						[e]: {
							saved: o.saved
						}
					}))
				}, ne = (e, t) => t().posts.models[e], re = Object(m.b)(ne, F.a.upvoted), se = Object(m.b)(ne, F.a.downvoted), oe = e => "viewing-".concat(e), ie = (e, t) => async (n, r) => {
					const s = r();
					N.i(s, e, t), H.c.start(oe(e))
				}, ce = (e, t, n) => async (s, o) => {
					const i = o(),
						c = oe(e);
					if (H.c.has(c)) {
						const s = H.c.end("viewing-".concat(e));
						!t && s > r.a.telemetry.postConsumedThreshold && N.a(i, e, s, n)
					}
				}, ae = "AD__IMPRESSION", de = "AD__VIEWABLE_IMPRESSION", ue = Object(d.a)(ae), le = Object(d.a)(de), be = (e, t) => async (n, r) => {
					const s = e.media && "video" === e.media.type;
					if (s && t === V.a.VideoViewable) n(Object(p.B)(e.id));
					else if (s && t === V.a.VideoFullyViewable) n(Object(p.A)(e.id));
					else if (e.isSponsored) return t === V.a.Impression ? (n((e => async t => {
						e.isSponsored && (Object(k.a)(e.events, D.a.Impression), t(ue({
							postId: e.id
						})))
					})(e)), void(e.isBlank || N.h(r(), e.id))) : void n((e => async t => {
						e.isSponsored && (Object(k.a)(e.events, D.a.ViewableImpression), t(le({
							postId: e.id
						})))
					})(e))
				}, pe = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.posts.models[e],
						c = o.user.account ? o.user.account.displayText : null;
					i && (t($({
						[e]: {
							approvedBy: c,
							bannedBy: null,
							isApproved: !0,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							numReports: 0,
							modRemovalReason: null,
							modReasonBy: null
						}
					})), (await Object(E.b)(s(), e)).ok || t($({
						[e]: {
							approvedBy: null,
							bannedBy: i.bannedBy,
							isApproved: i.isApproved,
							isRemoved: i.isRemoved,
							isSpam: i.isSpam,
							modNote: i.modNote,
							numReports: i.numReports || null,
							modRemovalReason: i.modRemovalReason,
							modReasonBy: i.modReasonBy
						}
					})))
				}, me = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = i.posts.models[e],
						a = i.user.account ? i.user.account.displayText : null;
					c && a && (n($({
						[e]: {
							approvedBy: null,
							bannedBy: a,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (await Object(E.l)(o(), e, t)).ok || n($({
						[e]: {
							approvedBy: c.approvedBy,
							bannedBy: c.bannedBy,
							isApproved: c.isApproved,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam
						}
					})))
				}, fe = (e, t, n) => async (r, s, o) => {
					let {
						apiContext: c
					} = o;
					const a = s(),
						d = a.posts.models[e],
						u = Object(G.T)(a);
					if (d)
						if (r($({
								[e]: {
									hidden: !0
								}
							})), (await Object(E.c)(c(), e)).ok) {
							const e = Object(P.d)(Object(i.a)(u, "posts.deleteSuccess"), M.b.SuccessMod);
							if (n) r(Object(C.b)(t.state[g.a.CloseLocation]));
							else {
								const e = Object(B.f)(a);
								e && r(Object(C.b)(e.url))
							}
							r(Object(P.e)(e))
						} else {
							r($({
								[e]: {
									hidden: !1
								}
							}));
							const t = Object(P.d)(Object(i.a)(u, "error.generic"), M.b.Error);
							r(Object(P.e)(t))
						}
				}, ge = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().posts.models[e];
					if (!o) return;
					const i = o.isLocked ? E.v : E.i;
					t($({
						[e]: {
							isLocked: !o.isLocked
						}
					})), (await i(s(), e)).ok || t($({
						[e]: {
							isLocked: o.isLocked
						}
					}))
				}, Oe = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().posts.models[e];
					if (!o) return;
					const i = o.isSpoiler ? E.y : E.r,
						c = o.isSpoiler ? o.flair.filter(e => e.type !== L.f.Spoiler) : [...o.flair, {
							text: "spoiler",
							type: L.f.Spoiler
						}];
					t($({
						[e]: {
							isSpoiler: !o.isSpoiler,
							flair: c
						}
					})), (await i(s(), e)).ok || t($({
						[e]: {
							isSpoiler: o.isSpoiler,
							flair: o.flair
						}
					}))
				}, he = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = Object(q.I)(n(), {
						postId: e
					});
					o && (t($({
						[e]: {
							isOriginalContent: !o.isOriginalContent
						}
					})), (await Object(E.k)(s(), e, !o.isOriginalContent)).ok || t($({
						[e]: {
							isOriginalContent: o.isOriginalContent
						}
					})))
				}, ye = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().posts.models[e];
					if (!o) return;
					const i = o.isNSFW ? E.w : E.j,
						c = o.isNSFW ? o.flair.filter(e => e.type !== L.f.Nsfw) : [...o.flair, {
							text: "nsfw",
							type: L.f.Nsfw
						}];
					t($({
						[e]: {
							isNSFW: !o.isNSFW,
							flair: c
						}
					})), (await i(s(), e)).ok ? await t(Pe(e)) : t($({
						[e]: {
							isNSFW: o.isNSFW,
							flair: o.flair
						}
					}))
				}, je = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r().posts.models[e];
					if (!i) return;
					const c = T.g[t];
					n($({
						[e]: {
							distinguishType: t
						}
					})), (await Object(E.d)(o(), e, c)).ok || n($({
						[e]: {
							distinguishType: i.distinguishType
						}
					}))
				}, _e = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().posts.models[e];
					if (!o) return;
					const i = o.ignoreReports ? E.u : E.h;
					t($({
						[e]: {
							ignoreReports: !o.ignoreReports
						}
					})), (await i(s(), e)).ok || t($({
						[e]: {
							ignoreReports: o.ignoreReports
						}
					}))
				}, Ee = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.posts.models[e];
					if (!i) return;
					const c = !i.isStickied;
					t($({
						[e]: {
							isStickied: c
						}
					}));
					const a = o.subredditStickyPosts.data[i.belongsTo.id];
					let d;
					if (c && a && a.length >= 2 && (d = a[1], t($({
							[d]: {
								isStickied: !1
							}
						}))), (await Object(E.s)(s(), e, c, !1)).ok) {
						const n = i.belongsTo.id,
							r = ve(e, c, o.subredditStickyPosts.data[i.belongsTo.id]),
							s = o.subreddits.models[n].name,
							a = Object(x.a)(s, T.O, {});
						t(Z({
							newStickiedPostList: r,
							subredditId: n,
							listingKey: a
						}))
					} else t($({
						[e]: {
							isStickied: i.isStickied
						}
					})), d && t($({
						[d]: {
							isStickied: !0
						}
					}))
				}, ve = (e, t, n) => {
					const r = n ? [...n] : [];
					return t ? (r.length >= 2 && r.splice(1, 1, e), r) : r.filter((function(t) {
						return t !== e
					}))
				}, Ie = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().user.language;
					if (Object(a.a)(e)) {
						const e = Object(P.d)(Object(i.a)(o, "posts.copyLinkSuccess"), M.b.SuccessCommunity);
						t(Object(P.e)(e))
					} else {
						const e = Object(P.d)(Object(i.a)(o, "error.generic"), M.b.Error);
						t(Object(P.e)(e))
					}
				}, Se = "PREFERENCES__RECENT_POSTS_UPDATED", Te = Object(d.a)(Se), xe = () => async (e, t) => {
					const n = t();
					if (!n.user.account) return;
					const s = Object(U.f)(n.user.account);
					o.a.remove("".concat(s).concat(f.h), {
						domain: r.a.cookieDomain
					}), e(Te({
						postIds: []
					}))
				}, Ce = e => async (t, n) => {
					const s = n();
					if (!s.user.account || !s.user.account.showRecentPosts || s.posts.recent.indexOf(e) > -1) return;
					const i = Object(U.f)(s.user.account),
						c = s.posts.recent ? s.posts.recent.slice(0) : [];
					c.push(e), c.length > O.c && c.shift(), o.a.set("".concat(i).concat(f.h), "".concat(c.join(",")), {
						domain: r.a.cookieDomain
					}), t(Te({
						postIds: c
					}))
				}, we = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = !n().posts.models[e].sendReplies;
					t($({
						[e]: {
							sendReplies: o
						}
					})), (await Object(E.p)(s(), e, o)).ok || t($({
						[e]: {
							sendReplies: !o
						}
					}))
				}, Pe = e => async (t, n, r) => {
					if (Object(q.I)(n(), {
							postId: e
						})) return;
					const s = await Object(A.a)(r.apiContext(), e, void 0, {
						limit: 1,
						truncate: 0
					});
					if (t(Object(l.m)(s.status)), s.ok) {
						const e = s.body;
						t(Q(e.posts))
					}
				}, De = e => async (t, n) => {
					await t(Pe(e));
					const r = Object(q.I)(n(), {
						postId: e
					});
					r && r.crosspostRootId && await t(Pe(r.crosspostRootId))
				}, Re = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n();
					if (!Object(G.K)(o)) return void t(Object(w.i)(R.a.LOGIN_MODAL_ID));
					const c = Object(q.I)(o, {
						postId: e
					});
					if (!c) return;
					const a = c.isFollowed,
						d = o.posts.instances[e] || [],
						u = [e, ...d];
					t($(u.reduce((e, t) => Object.assign({}, e, {
						[t]: {
							isFollowed: !a
						}
					}), {})));
					const l = await Object(E.f)(s(), e, !c.isFollowed),
						b = Object(G.T)(o);
					l.ok ? t(Object(P.e)({
						kind: M.b.SuccessMod,
						text: Object(i.a)(b, a ? "posts.event.successfullyUnfollowed" : "posts.event.successfullyFollowed")
					})) : (t($(u.reduce((e, t) => Object.assign({}, e, {
						[t]: {
							isFollowed: a
						}
					}), {}))), t(Object(P.e)({
						kind: M.b.Error,
						text: Object(i.a)(b, "posts.event.followFailed")
					})))
				}, Ae = e => {
					let {
						postOrComment: t,
						queryParams: n,
						clickInfo: r
					} = e;
					return async (e, s) => {
						const o = s(),
							i = r && r.hasNewTabModifier;
						let a = t.permalink;
						n && (a = Object(c.a)(a, n)), o.user.prefs.openPostInNewTab || i ? window.open(a) : e(Object(y.a)(a))
					}
				}, ke = "RICH_TEXT_POST_CONTENT_LOADED", Ne = Object(d.a)(ke), Le = e => async (t, n, r) => {
					const s = n(),
						o = Object(q.I)(s, {
							postId: e
						}),
						c = Object(G.T)(s);
					if (!(o && o.media && Object(_.C)(o.media) && o.media.isRichtextPreview)) return;
					const a = await ((e, t) => Object(v.a)(e, Object.assign({}, S, {
						variables: t
					})))(r.gqlContext(), {
						postId: e
					});
					if (a.ok) {
						const {
							data: n
						} = a.body, r = n.post && n.post.content && n.post.content.richtext;
						r && t(Ne({
							postId: e,
							richtextContent: JSON.parse(r)
						}))
					} else t(Object(P.e)({
						kind: M.b.Error,
						text: Object(i.a)(c, "error.genericPage")
					}))
				}, Me = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					(await Object(E.q)(o(), e, t)).ok ? n($({
						[t]: {
							contestMode: e
						}
					})) : n(Object(P.e)({
						kind: M.b.Error,
						text: Object(j.c)("Something went wrong")
					}))
				}, Ue = "SINGLE_POST_LOADED", Fe = Object(d.a)(Ue), Be = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const o = n(),
						c = Object(q.I)(o, {
							postId: e
						}),
						a = Object(G.T)(o);
					if (c) return void t(Object(b.j)(e, !1, !1, !0));
					const d = await ((e, t) => Object(v.a)(e, Object.assign({}, I, {
						variables: t
					})))(s(), {
						postId: e
					});
					if (d.ok) {
						const {
							data: n
						} = d.body;
						if (n.postInfoById) {
							const r = Object(h.d)(n.postInfoById);
							t(Fe(r)), t(Object(b.j)(e, !1, !1, !0))
						}
					} else t(Object(P.e)({
						kind: M.b.Error,
						text: Object(i.a)(a, "error.genericPage")
					}))
				}
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "t", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "r", (function() {
				return l
			})), n.d(t, "s", (function() {
				return b
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "q", (function() {
				return _
			})), n.d(t, "o", (function() {
				return E
			}));
			const r = "CREATE_COLLECTION_PENDING",
				s = "CREATE_COLLECTION_SUCCESS",
				o = "CREATE_COLLECTION_FAILED",
				i = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				c = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				a = "ADD_POST_TO_COLLECTION_SUCCESS",
				d = "UPDATE_POST_WITH_COLLECTION_ID",
				u = "DELETE_COLLECTION_SUCCESS",
				l = "UPDATE_COLLECTION_PENDING",
				b = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				m = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				f = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				g = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				O = "REORDER_COLLECTION_PENDING",
				h = "REORDER_COLLECTION_SUCCESS",
				y = "REORDER_COLLECTION_FAILED",
				j = "UPDATE_COLLECTION_LAYOUT_PENDING",
				_ = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				E = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "I", (function() {
				return r
			})), n.d(t, "J", (function() {
				return s
			})), n.d(t, "m", (function() {
				return o
			})), n.d(t, "n", (function() {
				return i
			})), n.d(t, "z", (function() {
				return c
			})), n.d(t, "F", (function() {
				return a
			})), n.d(t, "G", (function() {
				return d
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "E", (function() {
				return l
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "O", (function() {
				return p
			})), n.d(t, "o", (function() {
				return m
			})), n.d(t, "B", (function() {
				return f
			})), n.d(t, "t", (function() {
				return g
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "i", (function() {
				return I
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "k", (function() {
				return T
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "Q", (function() {
				return C
			})), n.d(t, "P", (function() {
				return w
			})), n.d(t, "R", (function() {
				return P
			})), n.d(t, "S", (function() {
				return D
			})), n.d(t, "T", (function() {
				return R
			})), n.d(t, "U", (function() {
				return A
			})), n.d(t, "V", (function() {
				return k
			})), n.d(t, "W", (function() {
				return N
			})), n.d(t, "X", (function() {
				return L
			})), n.d(t, "s", (function() {
				return M
			})), n.d(t, "C", (function() {
				return U
			})), n.d(t, "x", (function() {
				return F
			})), n.d(t, "v", (function() {
				return B
			})), n.d(t, "w", (function() {
				return G
			})), n.d(t, "u", (function() {
				return V
			})), n.d(t, "y", (function() {
				return q
			})), n.d(t, "N", (function() {
				return H
			})), n.d(t, "p", (function() {
				return K
			})), n.d(t, "A", (function() {
				return W
			})), n.d(t, "Y", (function() {
				return Y
			})), n.d(t, "H", (function() {
				return z
			})), n.d(t, "a", (function() {
				return J
			})), n.d(t, "D", (function() {
				return Q
			})), n.d(t, "L", (function() {
				return X
			})), n.d(t, "M", (function() {
				return Z
			})), n.d(t, "K", (function() {
				return $
			}));
			const r = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				s = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				o = "POST_CREATION_EDIT_COMPLETE",
				i = "POST_CREATION_EDIT_FAILED",
				c = "POST_CREATION_PENDING_EDIT",
				a = "POST_CREATION_START_EDITING_POST",
				d = "POST_CREATION_STOP_EDITING_POST",
				u = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				l = "STARTED_CONVERTING_EDITOR_CONTENT",
				b = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				m = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				f = "POST_TITLE_FETCHED",
				g = "INITIALIZE_EDITOR_MODE",
				O = "POST_CREATION__CHANGE_FLAIR",
				h = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				y = "POST_CREATION__CHANGE_LINK_BODY",
				j = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				_ = "POST_CREATION__CHANGE_MEDIA_BODY",
				E = "POST_CREATION__CHANGE_POST_SCHEDULE",
				v = "POST_CREATION__CHANGE_RECAPTCHA",
				I = "POST_CREATION__CHANGE_RTE_STATE",
				S = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				T = "POST_CREATION__CHANGE_TITLE",
				x = "POST_CREATION__GOV_TYPE_CHANGED",
				C = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				w = "POST_CREATION__TOGGLE_IS_CHANGED",
				P = "POST_CREATION__TOGGLE_IS_GOV",
				D = "POST_CREATION__TOGGLE_IS_NSFW",
				R = "POST_CREATION__TOGGLE_IS_OC",
				A = "POST_CREATION__TOGGLE_IS_POLL",
				k = "POST_CREATION__TOGGLE_IS_SPOILER",
				N = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				L = "POST_CREATION__TOGGLE_SEND_REPLIES",
				M = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				U = "POST_CREATION__RESET_FORM",
				F = "POST_CREATION__MODAL_TOGGLED",
				B = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				G = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				V = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				q = "POST_CREATION__PENDING",
				H = "POST_CREATION__SUCCEEDED",
				K = "POST_CREATION__FAILED",
				W = "POST_CREATION__POLL_FAILED",
				Y = "POST_CREATION__VALIDATION_FAILED",
				z = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				J = "POST_CREATION__CAPTCHA_REQUIRED",
				Q = "POST_CREATION__SET_SUBMIT_MODE",
				X = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				Z = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				$ = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED"
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/post/convert.ts"),
				c = n("./src/reddit/helpers/localStorage/index.ts"),
				a = n("./src/reddit/helpers/trackers/postComposer.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				u = n("./src/reddit/models/RichTextJson/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/selectors/user.ts"),
				p = n("./src/reddit/actions/postCreation/constants.ts");
			const m = Object(s.a)(p.E),
				f = Object(s.a)(p.q),
				g = Object(s.a)(p.O),
				O = (e, t, n) => async (s, c, O) => {
					let {
						apiContext: y
					} = O;
					a.i(c(), t);
					const j = t === d.h.MARKDOWN,
						_ = t === d.h.RICH_TEXT,
						E = Object(b.T)(c()),
						v = p.l;
					if (j && Object(u.F)(n)) return s(g({
						editorKey: e,
						editorMode: d.h.MARKDOWN,
						content: ""
					})), void s(h(t));
					if (_ && !n) return s(g({
						editorKey: e,
						editorMode: d.h.RICH_TEXT,
						content: u.i
					})), void s(h(t));
					s(m(v));
					const I = await Object(i.a)(y(), t, j ? JSON.stringify(n) : n);
					I.ok ? (s(f(v)), s(g({
						editorKey: e,
						editorMode: t,
						content: I.body.output
					})), s(h(t))) : (s(f(v)), s(Object(o.e)({
						duration: o.a,
						kind: l.b.Error,
						text: Object(r.a)(E, "error.generic")
					})))
				}, h = e => async (t, n) => {
					const s = Object(c.h)();
					if (s >= 3) return;
					const i = n().user.prefs.useMarkdown ? d.h.MARKDOWN : d.h.RICH_TEXT,
						a = Object(b.T)(n());
					if (e === i) return;
					const u = e === d.h.MARKDOWN ? "postCreation.editorModeModeHintToast.makeMarkdownDefault" : "postCreation.editorModeModeHintToast.makeRTEDefault";
					t(Object(o.e)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: Object(r.a)(a, "postCreation.editorModeModeHintToast.button"),
						kind: l.b.SuccessCommunity,
						text: Object(r.a)(a, u)
					})), Object(c.K)(s + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return m
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "t", (function() {
				return C
			})), n.d(t, "s", (function() {
				return w
			})), n.d(t, "u", (function() {
				return P
			})), n.d(t, "v", (function() {
				return D
			})), n.d(t, "w", (function() {
				return R
			})), n.d(t, "x", (function() {
				return A
			})), n.d(t, "z", (function() {
				return k
			})), n.d(t, "A", (function() {
				return N
			})), n.d(t, "l", (function() {
				return L
			})), n.d(t, "r", (function() {
				return M
			})), n.d(t, "q", (function() {
				return F
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "y", (function() {
				return G
			})), n.d(t, "p", (function() {
				return V
			})), n.d(t, "n", (function() {
				return q
			}));
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/lib/isUrl/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				a = n("./src/reddit/endpoints/post/index.tsx"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				u = n("./src/reddit/routes/postCreation/constants.ts"),
				l = n("./src/reddit/selectors/postCollection.ts"),
				b = n("./src/reddit/selectors/postCreations.ts"),
				p = n("./src/reddit/actions/postCreation/constants.ts");
			const m = Object(o.a)(p.o),
				f = Object(o.a)(p.B),
				g = (Object(o.a)(p.t), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				O = Object(o.a)(p.b),
				h = Object(o.a)(p.c),
				y = Object(o.a)(p.d),
				j = Object(o.a)(p.e),
				_ = Object(o.a)(p.f),
				E = Object(o.a)(p.g),
				v = Object(o.a)(p.h),
				I = Object(o.a)(p.i),
				S = Object(o.a)(p.j),
				T = Object(o.a)(p.k),
				x = Object(o.a)(p.r),
				C = Object(o.a)(p.Q),
				w = Object(o.a)(p.P),
				P = (Object(o.a)(p.R), Object(o.a)(p.S)),
				D = Object(o.a)(p.T),
				R = Object(o.a)(p.U),
				A = Object(o.a)(p.V),
				k = Object(o.a)(p.W),
				N = Object(o.a)(p.X),
				L = Object(o.a)(p.s),
				M = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					t(y(e)), Object(s.a)(e) && t((e => async (t, n, r) => {
						let {
							apiContext: s
						} = r;
						const o = await Object(a.e)(s(), e);
						o.ok && o.body && o.body.json && o.body.json.data && t(f(o.body.json.data))
					})(e))
				}, U = Object(o.a)(p.C), F = (e, t) => async (n, s) => {
					n(U()), n(e ? Object(r.b)(u.b) : Object(r.b)(Object(b.R)(s(), {
						pageLayer: t
					})))
				}, B = Object(o.a)(i.c), G = e => async t => {
					e ? e === d.d ? t(B(e)) : t(i.i(e)) : (t(B(e)), t(i.i(e)))
				}, V = e => async (t, n) => {
					const r = n(),
						s = Object(c.E)(e),
						o = Object(b.z)(r);
					if (s && o) {
						Object(b.M)(r) !== d.c && t(G(d.c))
					} else t(F(!1, e))
				}, q = e => async (t, n) => {
					const r = n();
					Object(l.m)(r, {
						subredditId: e
					}) ? t(i.i(d.a)) : t(i.i(d.b))
				}
		},
		"./src/reddit/actions/postCreation/subredditChange.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return E
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			}));
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/filterQueryParams/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/pages/postCreation.ts"),
				u = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = n("./src/reddit/helpers/name/index.ts"),
				b = n("./src/reddit/models/PostCreationForm/index.ts"),
				p = n("./src/reddit/routes/postCreation/index.ts"),
				m = n("./src/reddit/routes/postCreation/constants.ts"),
				f = n("./src/reddit/selectors/platform.ts"),
				g = n("./src/reddit/selectors/postCreations.ts"),
				O = n("./src/reddit/selectors/subreddit.ts"),
				h = n("./src/reddit/actions/postCreation/constants.ts"),
				y = n("./src/reddit/actions/postCreation/general.ts");
			const j = Object(c.a)(h.L),
				_ = Object(c.a)(h.M),
				E = Object(c.a)(h.K),
				v = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s, c = r();
					const {
						name: p,
						isProfile: m
					} = e, h = Object(f.f)(c), y = h && !m && Object(l.a)(h.name, p), _ = c.creations.api.subreddit.change.pending;
					if (y || _) return;
					const E = Object(u.t)(t);
					if (!p) return void n(I(e, E));
					n(j(e));
					const v = m ? {
						profileName: p
					} : {
						subredditName: p
					};
					if (await n(Object(d.d)(v)), m || !Object(g.v)(c)) return n(I(e, E));
					const S = e.allowedPostTypes || Object(O.A)(r(), {
						subredditName: p
					});
					if (!S) return void n(I(e, E));
					let T;
					c = r();
					const x = Object(g.ab)(c),
						C = Object(g.v)(c);
					if (x === o.Fb.MEDIA && C) {
						const {
							mediaType: e,
							video: t
						} = Object(g.K)(c);
						if ("image" !== e || S.images) {
							if ("video" === e && !S.videos) {
								const e = t && t.duration || 0;
								S.images ? e > o.Y && (T = b.q.VideoWillBeRemovedTooLongForGif) : T = b.q.VideoWillBeRemovedMediaNotAllowed
							}
						} else T = b.q.ImageWillBeRemoved
					}
					n(T ? Object(a.i)(T) : I(Object.assign({}, e, {
						allowedPostTypes: S
					}), E))
				}, I = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (o, i) => {
						const {
							name: c,
							isProfile: a
						} = e, d = i().platform.currentPage, u = d.queryParams, l = a ? p.b : p.c;
						let b = "";
						b = c ? l(c) : m.b, b = Object(s.a)(b, Object.assign({}, u, {
							draft: t || u.draft
						})), (t || d.url.toLowerCase() !== b.toLowerCase()) && (o(_(e)), n && o(Object(y.s)(!0)), o(Object(y.j)()), o(Object(r.c)(b)))
					}
				}, S = e => async (t, n) => {
					const o = n().platform.currentPage,
						i = o.queryParams,
						c = Object(s.a)(o.url, Object.assign({}, i, {
							collection: e
						}));
					t(Object(r.c)(c))
				}, T = () => async (e, t) => {
					const n = t().platform.currentPage,
						s = Object(i.a)(n.url, ["collection"]);
					e(Object(r.c)(s))
				}
		},
		"./src/reddit/actions/postDraft.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/postCreation/general.ts"),
				c = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/models/StructuredStyles/index.ts");
			var p = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/name/index.ts"),
				f = n("./src/reddit/models/PostDraft/index.ts"),
				g = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts"),
				O = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				h = n("./src/reddit/models/Subreddit/index.ts");
			const y = e => {
				let t = e.drafts.reduce((e, t) => {
					const n = (e => {
						let t;
						return t = "link" === e.kind ? {
							kind: f.b.Link,
							body: e.body || void 0
						} : "markdown" === e.kind ? {
							kind: f.b.Markdown,
							body: e.body || void 0
						} : {
							kind: f.b.RichText,
							body: e.body || void 0
						}, Object.assign({
							subredditId: e.subreddit || void 0,
							contentCategory: e.content_category || void 0,
							created: e.created,
							flair: e.flair,
							id: e.id,
							isChatPost: !!e.discussion_type,
							isNSFW: !!e.nsfw,
							isOriginalContent: !!e.original_content,
							isSpoiler: !!e.spoiler,
							modified: e.modified || void 0,
							sendReplies: !!e.send_replies,
							isPublicLink: !!e.is_public_link,
							title: e.title || ""
						}, t)
					})(t);
					return e.postDraftIds.push(n.id), e.postDrafts[n.id] = n, e
				}, {
					postDraftIds: [],
					postDrafts: {},
					profiles: {},
					subreddits: {}
				});
				return t = e.subreddits.reduce((e, t) => {
					if (t.subreddit_type === h.c.User) {
						const n = Object(g.a)(t, Object(m.f)(t.display_name_prefixed));
						e.profiles[n.id] = n
					} else {
						const n = Object(O.a)(t);
						e.subreddits[n.id] = n
					}
					return e
				}, t)
			};
			var j = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				_ = n("./src/reddit/models/PostCreationForm/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				I = n("./src/reddit/models/User/index.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				T = n("./src/reddit/selectors/postDraft.ts"),
				x = n("./src/reddit/selectors/profile.ts"),
				C = n("./src/reddit/selectors/subreddit.ts"),
				w = n("./src/reddit/selectors/user.ts");
			n.d(t, "f", (function() {
				return P
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "p", (function() {
				return L
			})), n.d(t, "j", (function() {
				return M
			})), n.d(t, "l", (function() {
				return U
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "k", (function() {
				return G
			})), n.d(t, "h", (function() {
				return V
			})), n.d(t, "n", (function() {
				return q
			})), n.d(t, "s", (function() {
				return Q
			})), n.d(t, "r", (function() {
				return X
			})), n.d(t, "g", (function() {
				return Z
			})), n.d(t, "q", (function() {
				return ee
			})), n.d(t, "c", (function() {
				return te
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return re
			})), n.d(t, "o", (function() {
				return ce
			}));
			const P = "POST_DRAFT__LIST_PENDING",
				D = "POST_DRAFT__LIST_LOADED",
				R = "POST_DRAFT__LIST_FAILED",
				A = Object(o.a)(P),
				k = Object(o.a)(D),
				N = Object(o.a)(R),
				L = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t();
					if (!Object(w.i)(o) || Object(T.b)(o)) return;
					e(A());
					const i = await (e => Object(u.b)(Object(l.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/drafts.json"),
						method: r.bb.GET
					}))(s());
					i.ok ? e(k(y(i.body))) : e(N(i.error))
				}, M = "POST_DRAFT__SAVE_DRAFT_PENDING", U = "POST_DRAFT__SAVE_DRAFT_SUCCEEDED", F = "POST_DRAFT__SAVE_DRAFT_FAILED", B = "POST_DRAFT__SAVE_DRAFT_VALIDATION_FAILED", G = "POST_DRAFT__SAVE_DRAFT_SUBMIT_VALIDATION_FAILED", V = "POST_DRAFT__SAVE_DRAFT_CAPTCHA_REQUIRED", q = "POST_CREATION__TOGGLE_DRAFT_IS_PUBLIC", H = Object(o.a)(M), K = Object(o.a)(U), W = Object(o.a)(F), Y = Object(o.a)(B), z = Object(o.a)(G), J = Object(o.a)(V), Q = Object(o.a)(q), X = e => async (t, n, o) => {
					let {
						apiContext: i
					} = o;
					const d = n(),
						b = Object(T.g)(d),
						m = Object(S.Q)(d);
					if (b || m) return;
					const f = Object(T.h)(d, e);
					if (!f) return;
					t(H(f)), E.e(d, f);
					const g = await ((e, t, n) => Object(u.b)(Object(l.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/draft"),
						method: n ? r.bb.PUT : r.bb.POST,
						data: Object(j.a)(t)
					}).then(e => e.body.fields && Object(_.v)(e.body.fields[0]) ? Object.assign({}, e, {
						body: {},
						error: {
							type: r.D.SUBMIT_VALIDATION_ERROR,
							fields: [{
								field: e.body.fields[0],
								msg: e.body.explanation
							}]
						}
					}) : e))(i(), f, e);
					if (g.ok) {
						const {
							id: n,
							draftsCount: r
						} = Object(j.c)(g.body);
						t(K({
							draftId: n,
							draftsCount: r
						})), e || t(Object(c.a)(f.destSubreddit, n, !1))
					} else {
						const e = g.error;
						e.type === r.D.BAD_CAPTCHA_ERROR ? t(J()) : e.type === r.D.VALIDATION_ERROR ? t(Y(e)) : e.type === r.D.SUBMIT_VALIDATION_ERROR ? t(z(e)) : t(W(e));
						const n = Object(w.T)(d);
						t(Object(a.e)({
							duration: a.a,
							kind: v.b.Error,
							text: Object(s.a)(n, e)
						}))
					}
				}, Z = "POST_DRAFT__LOAD_DRAFT", $ = Object(o.a)(Z), ee = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					t($(e));
					let o = _.e;
					const i = n();
					if (e.subredditId) {
						const t = Object(C.S)(i, {
								subredditId: e.subredditId
							}),
							n = Object(x.p)(i, {
								profileId: e.subredditId
							}),
							r = Object(w.i)(i);
						t ? o = {
							isProfile: !1,
							name: t.name
						} : n && r && (o = {
							isProfile: !0,
							name: Object(I.f)(r)
						})
					}
					await t(Object(c.a)(o, e.id, !1));
					const a = Object(T.h)(n(), e.id);
					a && E.h(n(), a)
				}, te = "POST_DELETE_DRAFT_SUCCEEDED", ne = "POST_DELETE_DRAFT_FAILED", re = "POST_DELETE_DRAFT_PENDING", se = Object(o.a)(te), oe = Object(o.a)(ne), ie = Object(o.a)(re), ce = (e, t) => async (n, o, c) => {
					let {
						apiContext: p
					} = c;
					const m = o();
					if (Object(T.a)(m, e)) return;
					const f = Object(T.d)(m, {
						draftId: e
					});
					f && E.f(m, f), n(ie({
						draftId: e
					}));
					const g = await (async (e, t) => Object(u.b)(Object(l.a)(e, [b.g]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/draft?draft_id=").concat(t),
						method: r.bb.DELETE
					}))(p(), e);
					if (g.ok) {
						const {
							draftsCount: r
						} = Object(j.c)(g.body);
						n(se({
							draftId: e,
							draftsCount: r
						}));
						const s = Object(d.t)(t);
						e === s && n(Object(i.q)(!0, t))
					} else {
						const t = g.error,
							r = Object(w.T)(o());
						n(oe({
							draftId: e,
							apiError: t
						})), n(Object(a.e)({
							duration: a.a,
							kind: v.b.Error,
							text: Object(s.a)(r, t)
						}))
					}
				}
		},
		"./src/reddit/actions/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "l", (function() {
				return L
			})), n.d(t, "k", (function() {
				return M
			})), n.d(t, "j", (function() {
				return U
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "i", (function() {
				return B
			})), n.d(t, "h", (function() {
				return G
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				i = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/flair/index.ts"),
				d = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/selectors/postFlair.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/selectors/user.ts");
			const f = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				g = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				O = Object(s.a)(f),
				h = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				y = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				j = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				_ = Object(s.a)(y),
				E = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				v = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				I = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				S = Object(s.a)(v),
				T = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				x = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				C = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				w = Object(s.a)(x),
				P = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				D = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				R = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				A = Object(s.a)(D),
				k = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				N = Object(s.a)(R),
				L = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(p.S)(i, {
							subredditId: e
						}).name;
					n(g());
					const d = await Object(a.k)(o(), c, t);
					if (d.ok) {
						n(O({
							subredditId: e,
							isEnabled: t
						}))
					} else n(h());
					return d.ok
				}, M = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(p.S)(i, {
							subredditId: e
						}).name;
					n(j());
					const d = await Object(a.j)(o(), t, u.d.LinkFlair, c);
					if (d.ok) {
						n(_({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(E());
					return d.ok
				}, U = (e, t) => async (n, s, o) => {
					let {
						apiContext: d
					} = o;
					const b = s(),
						f = Object(p.S)(b, {
							subredditId: t
						}).name,
						g = Object(m.T)(b);
					n(I());
					const O = await Object(a.f)(d(), e, f, u.d.LinkFlair);
					let h = O.ok && !(O.body && !1 === O.body.success);
					if (h) {
						const r = O.body;
						if (n(S({
								subredditId: t,
								template: r
							})), r.id) {
							const s = e.styleTemplate,
								o = b.structuredStyles.flairTemplate.models[r.id];
							s ? h = await n(Object(i.d)(t, r.id, s)) : o && (h = await n(Object(i.c)(t, r.id)))
						}
					}
					if (h) {
						const e = Object(c.d)(Object(r.a)(g, "structuredStyles.forms.flair.toast.flairSaved"), l.b.SuccessMod);
						n(Object(c.e)(e))
					} else {
						n(T());
						const s = Object(c.d)(Object(r.a)(g, "structuredStyles.forms.flair.toast.flairNotSaved"), l.b.Error, Object(r.a)(g, "structuredStyles.forms.flair.toast.retryButtonText"), U(e, t));
						n(Object(c.e)(s))
					}
					return h
				}, F = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const d = s(),
						u = Object(p.S)(d, {
							subredditId: t
						}).name,
						b = Object(m.T)(d);
					if (n(C()), (await Object(a.b)(i(), e, u)).ok) {
						n(w({
							subredditId: t,
							templateId: e
						}));
						const s = Object(c.d)(Object(r.a)(b, "structuredStyles.forms.flair.toast.flairDeleted"), l.b.SuccessMod);
						n(Object(c.e)(s))
					} else {
						n(P());
						const s = Object(c.d)(Object(r.a)(b, "structuredStyles.forms.flair.toast.flairNotDeleted"), l.b.Error, Object(r.a)(b, "structuredStyles.forms.flair.toast.retryButtonText"), F(e, t));
						n(Object(c.e)(s))
					}
				}, B = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const d = s(),
						f = Object(b.d)(d, {
							subredditId: t
						}).templateIds,
						g = Object(p.S)(d, {
							subredditId: t
						}).name,
						O = Object(m.T)(d);
					if (n(A({
							subredditId: t,
							templateIds: e
						})), (await Object(a.e)(i(), g, u.d.LinkFlair, e)).ok) {
						n(k());
						const e = Object(c.d)(Object(r.a)(O, "structuredStyles.forms.flair.toast.flairReorderSuccess"), l.b.SuccessMod);
						n(Object(c.e)(e))
					} else {
						n(N({
							subredditId: t,
							templateIds: f
						}));
						const s = Object(c.d)(Object(r.a)(O, "structuredStyles.forms.flair.toast.flairReorderFailure"), l.b.Error, Object(r.a)(O, "structuredStyles.forms.flair.toast.retryButtonText"), B(e, t));
						n(Object(c.e)(s))
					}
				}, G = e => {
					let {
						post: t,
						previewFlair: n,
						selectedTemplateId: r
					} = e;
					return async (e, s, i) => {
						let {
							apiContext: c
						} = i;
						const u = t.flair.filter(e => !Object(d.p)(e.type));
						if (n && u.unshift(n), e(Object(o.E)({
								[t.id]: {
									flair: u
								}
							})), n) {
							const e = Object(d.g)(n);
							Object(a.h)(c(), t.id, r, e)
						} else Object(a.h)(c(), t.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/lodash/forEach.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/isEqual.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/values.js"),
				a = n.n(c),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/imageUploads.ts"),
				l = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts");
			var g = n("./src/reddit/helpers/trackers/blade.ts"),
				O = n("./src/reddit/models/Image/index.tsx"),
				h = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/telemetry/index.ts");
			n.d(t, "b", (function() {
				return E
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "c", (function() {
				return x
			}));
			var j = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const _ = e => {
					let {
						subredditId: t,
						flairId: n,
						imageKey: r,
						imageData: s
					} = e;
					return async (e, o, i) => {
						const c = o(),
							a = Object(h.S)(c, {
								subredditId: t
							});
						if (!a) return !1;
						e(Object(u.k)(s));
						const d = await (async (e, t, n, r, s, o) => Object(p.b)(Object(m.a)(e, [f.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_style_asset_upload_s3/").concat(n),
							method: b.bb.POST,
							data: {
								filepath: r,
								imagetype: s,
								mimetype: o
							}
						}))(i.apiContext(), a.name, n, s.file.name, r, await Object(l.g)(s.file));
						let g = !1;
						try {
							const t = await Object(u.g)(o(), d, s, O.a.FlairTemplates);
							t && e(Object(u.j)(t)), g = !0
						} catch (y) {
							if (y instanceof Error) throw y;
							e(Object(u.i)(y))
						}
						return g
					}
				},
				E = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				v = Object(d.a)(E),
				I = (e, t, n) => async (r, o, c) => {
					const {
						apiContext: d
					} = c;
					let l = o();
					const {
						pendingImages: E
					} = n;
					let I = j(n, ["pendingImages"]);
					const S = Object(h.S)(l, {
						subredditId: e
					});
					if (!S) return !1;
					const T = l.structuredStyles.flairTemplate.models[t];
					if (T && i()(T, I)) return !0;
					if (E) {
						const n = [];
						if (s()(E, (s, o) => {
								s && n.push(r(_({
									flairId: t,
									imageData: Object(O.m)(s),
									imageKey: o,
									subredditId: e
								})))
							}), !(await Promise.all(n)).every(e => e)) return !1;
						I = ((e, t, n) => {
							const r = Object.assign({}, e);
							return s()(t, (e, t) => {
								const s = e && n.imageUploads[e.id];
								s && s.kind === O.b.TempUploaded && (r[t] = s.url)
							}), r
						})(I, E, o())
					}
					l = o();
					let x = null,
						C = null;
					const w = [];
					try {
						(x = await Object(u.f)(l, O.a.FlairTemplates)) && (C = Object(u.m)(x)(r, o, c), w.push(...a()(x.imagesByKey)))
					} catch (A) {
						return !1
					}
					const P = await (async (e, t, n, r) => Object(p.b)(Object(m.a)(e, [f.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_styles/").concat(n),
							method: b.bb.PUT,
							data: r
						}))(d(), S.name, t, I),
						D = T ? "edit_post_flair_template" : "save_post_flair_template",
						R = Object(g.e)(l, D);
					if (P.ok) {
						let e;
						if (C) try {
							await C, e = ((e, t, n) => {
								const r = Object.assign({}, e);
								return t.forEach(e => {
									const t = n.imageUploads[e.id];
									t && t.kind === O.b.Uploaded && (e.url === r.postBackgroundImage ? r.postBackgroundImage = t.url : e.url === r.postPlaceholderImage && (r.postPlaceholderImage = t.url))
								}), r
							})(I, w, o())
						} catch (A) {
							e = null
						} else e = I;
						r(v({
							flairId: t,
							template: e || I
						}))
					} else x && x.websocket.close();
					return Object(y.a)(Object.assign({}, R, {
						actionInfo: Object.assign({}, R.actionInfo, {
							success: P.ok
						})
					})), P.ok
				}, S = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", T = Object(d.a)(S), x = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(h.S)(i, {
							subredditId: e
						});
					if (!c) return !1;
					const a = await (async (e, t, n) => Object(p.b)(Object(m.a)(e, [f.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_styles/").concat(n),
							method: b.bb.DELETE
						}))(o(), c.name, t),
						d = Object(g.e)(i, "delete_flair_template");
					return a.ok && n(T({
						flairId: t
					})), Object(y.a)(Object.assign({}, d, {
						actionInfo: Object.assign({}, d.actionInfo, {
							success: a.ok
						})
					})), a.ok
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				s = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/postList.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = (n("./src/reddit/actions/embedAndImage.ts"), n("./src/reddit/actions/video.ts"), n("./src/reddit/helpers/trackers/postList.ts"));
			n("./src/reddit/constants/postLayout.ts"), n("./src/reddit/selectors/platform.ts"), n("./src/reddit/selectors/posts.ts");
			n("./src/reddit/selectors/video.ts");
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			const o = "POSTLIST__MARKED_END",
				i = "POSTLIST__UNMARKED_END",
				c = Object(r.a)(o),
				a = Object(r.a)(i),
				d = (e, t) => async (n, r) => {
					const o = r();
					e in o.listings.postOrder.fetchedTokens ? e in o.listings.postOrder.ids ? n(a({
						listingKey: e
					})) : s.j(o, e) : n(c({
						listingKey: e,
						listingName: t
					}))
				}
		},
		"./src/reddit/actions/postRequirements/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const r = "POST_REQUIREMENTS_FAILED",
				s = "POST_REQUIREMENTS_LOADED",
				o = "POST_REQUIREMENTS_PENDING",
				i = "POST_REQUIREMENTS_UPDATED"
		},
		"./src/reddit/actions/postRequirements/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/lodash/camelCase.js"),
				s = n.n(r),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/graphql/operations/GetPostRequirements.json"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/graphql/operations/UpdatePostRequirements.json"),
				l = n("./src/reddit/endpoints/subreddit/about.ts"),
				b = n("./src/reddit/i18n/utils.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/postRequirements.ts"),
				f = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/actions/postRequirements/constants.ts");
			n.d(t, "a", (function() {
				return j
			})), n.d(t, "b", (function() {
				return E
			}));
			const O = Object(i.a)(g.b),
				h = Object(i.a)(g.c),
				y = Object(i.a)(g.a),
				j = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const i = {
						subredditName: e.toLowerCase()
					};
					if (Object(m.a)(n(), i)) return;
					t(h(i));
					let c = Object(f.G)(n(), e);
					if (!c) {
						const n = await Object(l.a)(s(), e, !1);
						if (n.ok) {
							c = n.body.data.subreddit.id
						}
						if (!c) {
							const e = n.error || {
								type: o.D.NOT_FOUND_ERROR
							};
							return void t(y(Object.assign({}, i, {
								error: e
							})))
						}
					}
					let u = null;
					const b = await ((e, t) => Object(d.a)(e, Object.assign({}, a, {
						variables: t
					})))(s(), {
						subredditId: c
					});
					if (b.ok) {
						const e = b.body;
						u = e.data.subreddit && e.data.subreddit.postRequirements
					}
					if (u) t(O(Object.assign({}, i, {
						requirements: u
					})));
					else {
						const e = b.error || {
							type: o.D.UNKNOWN_ERROR
						};
						t(y(Object.assign({}, i, {
							error: e
						})))
					}
				}, _ = Object(i.a)(g.d), E = (e, t) => async (n, r, s) => {
					let {
						gqlContext: o
					} = s;
					const i = e.toLowerCase(),
						a = Object(f.G)(r(), e);
					if (!a) return {
						success: !1
					};
					const l = Object.assign({
							subredditId: a
						}, t),
						m = await ((e, t) => Object(d.a)(e, Object.assign({}, u, {
							variables: t
						})))(o(), {
							input: l
						});
					let g = !1,
						O = null;
					if (m.ok) {
						const e = m.body;
						g = e.data.updatePostRequirements.ok, O = v(e.data.updatePostRequirements.fieldErrors)
					}
					return g ? (n(_({
						subredditName: i,
						partialRequirements: t
					})), {
						success: !0
					}) : (n(Object(c.e)({
						duration: c.a,
						id: "REQUIREMENTS_SAVE_ERROR",
						kind: p.b.Error,
						text: O && O.length ? O[0].message : Object(b.c)("Something went wrong")
					})), {
						success: !1,
						errors: O || void 0
					})
				}, v = e => e && e.map(e => Object.assign({}, e, {
					field: s()(e.field)
				}))
		},
		"./src/reddit/actions/preferences.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/Base64/base64.js"),
				s = n("./src/config.ts"),
				o = n("./node_modules/js-cookie/src/js.cookie.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/isEmpty.js"),
				a = n.n(c),
				d = n("./node_modules/lodash/omit.js"),
				u = n.n(d),
				l = n("./node_modules/lodash/pick.js"),
				b = n.n(l),
				p = n("./src/app/strings/index.ts"),
				m = n("./src/lib/constants/index.ts"),
				f = n("./src/lib/makeActionCreator/index.ts"),
				g = n("./src/reddit/actions/chat/toggle.ts"),
				O = n("./src/reddit/actions/users.ts"),
				h = n("./src/reddit/constants/cookie.ts"),
				y = n("./src/reddit/endpoints/user/preferences.ts"),
				j = n("./src/reddit/i18n/utils.ts"),
				_ = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				v = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				I = n("./src/reddit/actions/toaster.ts"),
				S = n("./src/reddit/constants/preferences.ts"),
				T = n("./src/reddit/endpoints/subreddit/settings.ts"),
				x = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				C = n("./src/reddit/models/Toast/index.ts"),
				w = n("./src/reddit/models/User/index.ts"),
				P = n("./src/reddit/selectors/structuredStyles.ts"),
				D = n("./src/reddit/selectors/subreddit.ts"),
				R = n("./src/reddit/selectors/user.ts");
			n.d(t, "b", (function() {
				return A
			})), n.d(t, "h", (function() {
				return k
			})), n.d(t, "g", (function() {
				return N
			})), n.d(t, "o", (function() {
				return L
			})), n.d(t, "e", (function() {
				return M
			})), n.d(t, "d", (function() {
				return U
			})), n.d(t, "l", (function() {
				return F
			})), n.d(t, "f", (function() {
				return B
			})), n.d(t, "n", (function() {
				return G
			})), n.d(t, "q", (function() {
				return V
			})), n.d(t, "s", (function() {
				return W
			})), n.d(t, "c", (function() {
				return X
			})), n.d(t, "u", (function() {
				return Z
			})), n.d(t, "v", (function() {
				return $
			})), n.d(t, "t", (function() {
				return ee
			})), n.d(t, "w", (function() {
				return te
			})), n.d(t, "D", (function() {
				return ne
			})), n.d(t, "B", (function() {
				return re
			})), n.d(t, "a", (function() {
				return se
			})), n.d(t, "p", (function() {
				return oe
			})), n.d(t, "C", (function() {
				return de
			})), n.d(t, "F", (function() {
				return ue
			})), n.d(t, "i", (function() {
				return le
			})), n.d(t, "k", (function() {
				return fe
			})), n.d(t, "j", (function() {
				return Oe
			})), n.d(t, "x", (function() {
				return ye
			})), n.d(t, "A", (function() {
				return je
			})), n.d(t, "r", (function() {
				return _e
			})), n.d(t, "z", (function() {
				return Ee
			})), n.d(t, "y", (function() {
				return ve
			})), n.d(t, "m", (function() {
				return Ie
			})), n.d(t, "E", (function() {
				return xe
			})), n.d(t, "H", (function() {
				return Ce
			})), n.d(t, "G", (function() {
				return we
			}));
			const A = "PREFERENCES__AUTOPLAY_TOGGLED",
				k = "PREFERENCES__NIGHTMODE_TOGGLED",
				N = "PREFERENCES__LAYOUT_CHANGED",
				L = "PREFERENCES__SUBREDDIT_LAYOUT_CHANGED",
				M = "PREFERENCES__CUSTOMIZE_FLYOUT_SHOWN",
				U = "PREFERENCES__CUSTOMIZE_FLYOUT_DISMISSED",
				F = "PREFERENCES__PROFILE_LAYOUT_CHANGED",
				B = "PREFERENCES__HAMBURGER_TRAY_TOGGLED",
				G = "PREFERENCES__RPAN_DU_DISMISSED",
				V = "PREFERENCES__TOP_CONTENT_DISMISSAL_PREF_SET",
				q = Object(f.a)(N),
				H = Object(f.a)(L),
				K = Object(f.a)(M),
				W = Object(f.a)(U),
				Y = Object(f.a)(G),
				z = Object(f.a)(V),
				J = (Object(f.a)(F), Object(f.a)(A)),
				Q = Object(f.a)(k),
				X = (Object(f.a)(B), "PREFERENCES__COLLAPSED_TRAY_TOGGLED"),
				Z = (Object(f.a)(X), e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					t(q({
						layout: e
					})), t(Object(O.r)())
				}),
				$ = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(R.bb)(i),
						{
							hasSeenCustomizeFlyout: a
						} = i.user.prefs;
					a || n(K()), t && c ? (n(H({
						subredditId: t,
						layout: e
					})), n(Ce(t, {
						layout: e
					}, !1)), a || n(ue({
						hasSeenCustomizeFlyout: !0
					}, !1))) : (n(Z(e)), n(ue(a ? {
						layout: e
					} : {
						layout: e,
						hasSeenCustomizeFlyout: !0
					}, !1)))
				}, ee = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					n().user.account && await Object(y.d)(e, s())
				}, te = e => async (t, n, o) => {
					let {
						apiContext: c
					} = o;
					const a = n();
					if (Object(P.j)(a)) {
						const e = Object(R.T)(a);
						t(Object(I.e)({
							kind: C.b.Error,
							text: Object(p.a)(e, "structuredStyles.modal.nightmode.description")
						}))
					} else {
						if (a.user.account) await Object(y.e)(e, c());
						else {
							const t = i.a.get(h.k);
							if (t) {
								const n = JSON.parse(Object(r.atob)(t));
								n.prefs.nightmode = e, i.a.set(h.k, btoa(JSON.stringify(n)), {
									domain: s.a.cookieDomain
								})
							}
						}
						t(Q({
							nightmode: e
						})), t(Object(g.d)(e)), i.a.remove(h.e, {
							domain: s.a.cookieDomain
						})
					}
				}, ne = () => async (e, t, n) => {
					let {
						apiContext: o
					} = n;
					const c = t(),
						a = c.user.prefs.topContentTimesDismissed + 1,
						d = Date.now();
					if (c.user.account) e(ue({
						topContentDismissalTime: d,
						topContentTimesDismissed: a
					}, !1));
					else {
						const e = i.a.get(h.k);
						if (e) {
							const t = JSON.parse(Object(r.atob)(e));
							t.prefs[S.d] = d, t.prefs[S.e] = a, i.a.set(h.k, btoa(JSON.stringify(t)), {
								domain: s.a.cookieDomain
							})
						}
					}
					e(z({
						topContentDismissalTime: d,
						topContentTimesDismissed: a
					})), e(Object(I.e)({
						kind: C.b.SuccessCommunity,
						text: Object(j.c)("Got it! We will show you less of this")
					}))
				}, re = () => async (e, t, n) => {
					let {
						apiContext: o
					} = n;
					const c = Date.now(),
						a = t(),
						d = Object(j.c)("Got it! We will show you less of this");
					if (a.user.account) e(ue({
						rpanDuDismissalTime: c
					}, !1));
					else {
						const e = i.a.get(h.k);
						if (e) {
							const t = JSON.parse(Object(r.atob)(e));
							t.prefs[S.b] = c, i.a.set(h.k, btoa(JSON.stringify(t)), {
								domain: s.a.cookieDomain
							})
						}
					}
					e(Object(I.e)({
						kind: C.b.SuccessCommunity,
						text: d
					})), e(Y(c))
				}, se = "SETTINGS__ACCOUNT_PREFS_UPDATE_SUCCESS", oe = "SETTINGS__SUBREDDIT_PREFS_UPDATED", ie = Object(f.a)("SETTINGS__UPDATE_PENDING"), ce = Object(f.a)("SETTINGS__UPDATE_FAILURE"), ae = Object(f.a)(se), de = Object(f.a)(oe), ue = function(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
					return async (r, s, o) => {
						let {
							apiContext: i
						} = o;
						r(ie());
						const c = u()(e, S.a),
							d = b()(e, S.a),
							l = [];
						a()(c) || l.push(Object(y.g)(c, i())), a()(d) || l.push(Object(y.b)(d, i())), (await Promise.all(l)).every(e => e.ok) ? (r(ae({
							preferences: e
						})), t && r(Object(I.e)({
							kind: C.b.SuccessCommunity,
							text: n || Object(j.c)("Changes saved")
						}))) : (r(ce()), t && r(Object(I.e)({
							kind: C.b.Error,
							text: Object(j.c)("Changes failed to save")
						})))
					}
				}, le = "SETTINGS__SUCCESS", be = Object(f.a)("SETTINGS__PENDING"), pe = Object(f.a)("SETTINGS__FAILURE"), me = Object(f.a)(le), fe = "SETTINGS__PROFILE_IMAGE_UPDATE_SUCCESS", ge = Object(f.a)(fe), Oe = "SETTINGS__PROFILE_IMAGE_DELETE_SUCCESS", he = Object(f.a)(Oe), ye = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					t(be());
					const i = await ((e, t) => Object(E.b)(e, {
						endpoint: Object(v.a)("".concat(s.a.gatewayUrl, "/desktopapi/v1/prefs")),
						method: m.bb.GET,
						data: {
							timestamp: t ? Date.now() : void 0
						}
					}))(o(), e);
					i.ok ? t(me(i.body)) : t(pe())
				}, je = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					if (n().user.account) await Object(y.a)(e, s());
					else {
						const e = i.a.get(h.f);
						if (e) {
							const t = JSON.parse(decodeURIComponent(e));
							t.pref_quarantine_optin = !0, i.a.set(h.f, JSON.stringify(encodeURIComponent(t)), m.x)
						} else {
							const e = JSON.stringify({
								pref_quarantine_optin: !0
							});
							i.a.set(h.f, e, m.x)
						}
					}
				}, _e = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					n().user.account && await Object(y.c)(e, s()), t(J({
						autoplayVideo: e
					}))
				}, Ee = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = Object(R.i)(r());
					if (!i || !i.profileId) return;
					const c = Object(R.T)(r()),
						a = Object(w.f)(i),
						d = m.Qb + a,
						u = await Object(_.g)(o(), d, t, e.file);
					if (u.ok) {
						const e = decodeURIComponent(u.body.PostResponse.Location);
						n(ge({
							imageUrl: e,
							key: t,
							subredditId: i.profileId,
							username: a
						})), (await Object(_.e)(o(), d, {
							[t]: e
						})).ok ? (n(Object(I.e)({
							kind: C.b.SuccessCommunity,
							text: Object(p.a)(c, "settings.page.saveRequestSuccess")
						})), Object(x.g)(r(), t)) : n(Object(I.e)({
							kind: C.b.Error,
							text: Object(p.a)(c, "settings.page.saveRequestFailure")
						}))
					} else n(Object(I.e)({
						kind: C.b.Error,
						text: Object(p.a)(c, "settings.profileForm.images.errors." + t)
					}))
				}, ve = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = Object(R.i)(n());
					if (!o || !o.profileId) return;
					const i = Object(w.f)(o),
						c = m.Qb + i,
						a = {
							profileIcon: "icon",
							profileBanner: "banner"
						} [e],
						d = Object(R.T)(n()),
						u = await Object(T.b)(s(), c, a);
					if (u.ok) {
						const r = u.body[a + "_img"];
						t(he({
							imageUrl: r,
							key: e,
							subredditId: o.profileId,
							username: i
						})), t(Object(I.e)({
							kind: C.b.SuccessCommunity,
							text: Object(p.a)(d, "settings.page.saveRequestSuccess")
						})), Object(x.f)(n(), e)
					} else t(Object(I.e)({
						kind: C.b.Error,
						text: Object(p.a)(d, "settings.page.saveRequestFailure")
					}))
				}, Ie = "SETTINGS__PROFILE_SETTINGS_UPDATE_SUCCESS", Se = Object(f.a)(Ie), Te = Object(f.a)("SETTINGS__PROFILE_SETTINGS_UPDATE_FAILED"), xe = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = Object(R.i)(r());
					if (!i || !i.profileId) return !1;
					const c = [],
						a = r().subreddits.settings[i.profileId],
						d = Object.assign({}, a, e);
					c.push(Object(T.f)(o(), i.profileId, d));
					const {
						showActiveCommunities: u,
						prevShowActiveCommunities: l
					} = t;
					u !== l && c.push(Object(y.g)({
						showActiveCommunities: u
					}, o()));
					const b = Object(R.T)(r());
					return (await Promise.all(c)).every(e => e.ok) ? (n(Se({
						settings: e,
						additional: t,
						subredditId: i.profileId
					})), Object(x.i)(r()), n(Object(I.e)({
						kind: C.b.SuccessCommunity,
						text: Object(p.a)(b, "settings.page.saveRequestSuccess")
					})), !0) : (n(Te()), n(Object(I.e)({
						kind: C.b.Error,
						text: Object(p.a)(b, "settings.page.saveRequestFailure")
					})), !1)
				}, Ce = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (r, s, o) => {
						let {
							apiContext: i
						} = o;
						const c = s(),
							a = Object(R.T)(c),
							d = c.user.prefs.subreddit[e];
						r(de({
							subredditId: e,
							prefs: t
						})), (await Object(y.h)(e, t, i())).ok ? n && r(Object(I.e)({
							kind: C.b.SuccessCommunity,
							text: Object(p.a)(a, "settings.page.saveRequestSuccess")
						})) : (d && r(de({
							subredditId: e,
							prefs: d
						})), n && r(Object(I.e)({
							kind: C.b.Error,
							text: Object(p.a)(a, "settings.page.saveRequestFailure")
						})))
					}
				}, we = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r();
					Object(D.S)(i, {
						subredditId: e
					}) && i.user.prefs.rememberCommunitySort && n(Ce(e, {
						sort: t
					}, !1))
				}
		},
		"./src/reddit/actions/product.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "j", (function() {
				return E
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/governance/errorToast.ts"),
				o = n("./src/reddit/endpoints/governance/badges.ts"),
				i = n("./src/reddit/endpoints/governance/products/badges.ts");
			const c = "PRODUCT__BADGE_PURCHASE_OPENED",
				a = "PRODUCT__BADGE_PURCHASE_SUCCESS",
				d = "PRODUCT__BADGE_PURCHASE_FAILURE",
				u = "PRODUCT__BADGE_PURCHASE_PENDING",
				l = "PRODUCT__FETCH_SUCCESS",
				b = "PRODUCT__FETCH_FAILURE",
				p = "PRODUCT__FETCH_PENDING",
				m = Object(r.a)(c),
				f = Object(r.a)(a),
				g = Object(r.a)(d),
				O = Object(r.a)(u),
				h = Object(r.a)(l),
				y = Object(r.a)(b),
				j = Object(r.a)(p),
				_ = e => {
					let {
						productId: t
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: c
						} = r;
						const a = n(),
							d = a.products.models[t],
							u = a.user.account,
							l = !!a.products.api.purchase.pending[t];
						if (d && d.price && !l) {
							e(O({
								productId: t
							}));
							const n = await Object(i.c)(c(), {
								price: d.price,
								products: [{
									productId: t,
									quantity: "1"
								}],
								subredditId: d.subredditId
							});
							let r;
							if (n.ok && u && (r = await Object(o.c)(c(), d.subredditId, u.id)), n.ok) {
								if (r && r.ok) {
									const {
										badges: t,
										userOwnedBadges: s
									} = r.body;
									e(f({
										product: d,
										badges: t,
										userOwnedBadges: s,
										wallet: n.body.wallet
									}))
								}
							} else e(g({
								productId: t,
								error: n.error
							})), Object(s.a)(e, n.error)
						}
					}
				},
				E = e => {
					let {
						subredditId: t
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: s
						} = r;
						e(j({
							subredditId: t
						}));
						const o = await Object(i.a)(s(), t);
						o.ok ? e(h({
							subredditId: t,
							products: o.body
						})) : e(y({
							subredditId: t,
							error: o.error
						}))
					}
				}
		},
		"./src/reddit/actions/profile/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return r
			})), n.d(t, "j", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "l", (function() {
				return a
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "g", (function() {
				return f
			}));
			const r = "PROFILE__PROFILE_INFO_LOADED",
				s = "PROFILE__PROFILE_INFO_FAILED",
				o = "PROFILE__MODERATED_SUBREDDITS_PENDING",
				i = "PROFILE__MODERATED_SUBREDDITS_LOADED",
				c = "PROFILE__MODERATED_SUBREDDITS_FAILED",
				a = "PROFILE__RECEIVED_MODERATED_SUBREDDITS_MODELS",
				d = "PROFILE__RECEIVED_MODERATED_SUBREDDITS_SUBSCRIPTIONS",
				u = "MORE__PROFILE_GQL_MODERATED_PENDING",
				l = "MORE__PROFILE_GQL_MODERATED_LOADED",
				b = "MORE__PROFILE_GQL_MODERATED_FAILED",
				p = "PROFILE__MULTIREDDITS_PENDING",
				m = "PROFILE__MULTIREDDITS_LOADED",
				f = "PROFILE__MULTIREDDITS_FAILED"
		},
		"./src/reddit/actions/profile/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/actions/contentGate.ts"),
				i = n("./src/reddit/actions/pages/profilePrivate/constants.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts");
			var u = n("./src/graphql/operations/ModeratedSubreddits.json"),
				l = n("./src/lib/makeGqlRequest/index.ts");
			var b = n("./src/graphql/operations/RedditorMultireddits.json");
			var p = n("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				m = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts");
			var f = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				g = e => Object.assign({
					accountIcon: e.icon_img,
					awardedLastMonth: e.awarded_last_month ? Object(f.c)(e.awarded_last_month) : null,
					commentKarma: e.comment_karma,
					created: e.created,
					displayName: e.name,
					displayNamePrefixed: e.subreddit && e.subreddit.display_name_prefixed,
					displayText: e.name,
					hasUserProfile: !!e.subreddit,
					hideFromRobots: !!e.hide_from_robots,
					id: "".concat(s.vb.Account, "_").concat(e.id),
					isEmployee: e.is_employee,
					isFollowing: e.has_subscribed,
					isGold: e.is_gold,
					isAdmin: e.is_admin,
					isMod: e.is_mod,
					isNSFW: !(!e.subreddit || !e.subreddit.over_18),
					prefShowSnoovatar: e.pref_show_snoovatar,
					prefShowTwitter: e.pref_show_twitter,
					postKarma: e.link_karma,
					url: "/user/".concat(e.name, "/"),
					username: e.name
				}, e.subreddit ? {
					profileId: e.subreddit.name
				} : null),
				O = e => ({
					commentKarma: e.comment_karma,
					hasExternalAccount: e.has_external_account,
					postKarma: e.link_karma,
					prefShowTwitter: e.pref_show_twitter,
					publicDescription: e.subreddit ? e.subreddit.public_description : "",
					userIsSubscriber: e.subreddit && e.subreddit.user_is_subscriber || !1
				}),
				h = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts");
			var y = n("./src/reddit/models/User/index.ts"),
				j = n("./src/reddit/selectors/profile.ts"),
				_ = n("./src/reddit/selectors/subscriptions.ts"),
				E = n("./src/reddit/selectors/user.ts"),
				v = n("./src/reddit/actions/profile/constants.ts");
			n.d(t, "a", (function() {
				return D
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "e", (function() {
				return G
			}));
			const I = Object(r.a)(v.k),
				S = Object(r.a)(v.j),
				T = Object(r.a)(v.c),
				x = Object(r.a)(v.b),
				C = Object(r.a)(v.a),
				w = Object(r.a)(v.l),
				P = Object(r.a)(v.m),
				D = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = Object(E.i)(t());
					s && s.profileId && await e(R(Object(y.f)(s)))
				}, R = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					const u = n();
					if (!!(Object(j.j)(u, {
							profileName: e
						}) && Object(j.h)(u, {
							profileName: e
						}) && Object(E.ib)(u, {
							userName: e
						}))) return;
					const l = await ((e, t) => Object(c.b)(Object(a.a)(e, [d.a]), {
						endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/about.json"),
						method: s.bb.GET,
						data: {
							gilding_detail: 1,
							awarded_detail: 1,
							raw_json: 1
						}
					}))(i(), e);
					l.ok ? (l.body && l.body.data && l.body.data.is_suspended && t(Object(o.p)({
						profileName: e
					})), t(I(function(e) {
						const {
							data: t
						} = e;
						return Object.assign({
							about: O(t),
							banner: t.subreddit && t.subreddit.banner_img && {
								height: t.subreddit.banner_size && t.subreddit.banner_size[1],
								url: t.subreddit.banner_img,
								width: t.subreddit.banner_size && t.subreddit.banner_size[0]
							},
							user: g(t),
							features: t.features
						}, t.subreddit ? {
							profile: Object(h.a)(t.subreddit, t.name)
						} : null)
					}(l.body)))) : t(S(l.body))
				}, A = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = {
						profileName: e
					};
					if (Object(j.a)(n(), i)) return;
					if (Object(j.k)(n(), i)) return;
					t(T(i));
					const u = await ((e, t) => Object(c.b)(Object(a.a)(e, [d.a]), {
						endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/moderated_subreddits.json"),
						method: s.bb.GET,
						data: {
							raw_json: 1
						}
					}))(o(), e);
					if (u.ok) {
						const r = function(e) {
							return e ? e.map(e => ({
								communityIcon: e.community_icon,
								displayText: e.sr_display_name_prefixed,
								icon: {
									height: e.icon_size ? e.icon_size[1] : 0,
									url: e.icon_img ? e.icon_img : "",
									width: e.icon_size ? e.icon_size[0] : 0
								},
								id: e.name,
								isNSFW: e.over_18,
								isQuarantined: !!e.quarantine,
								name: "user" === e.subreddit_type ? e.sr.slice(s.Qb.length) : e.sr,
								primaryColor: e.primary_color,
								subscribers: e.subscribers,
								title: e.title,
								type: e.subreddit_type,
								url: e.url,
								wls: e.wls
							})) : []
						}(u.body.data);
						t(x({
							profileName: e,
							data: r
						}));
						const o = {},
							i = {};
						if (r.forEach(e => {
								("user" === e.type ? i : o)[e.id] = e
							}), t(w({
								subreddits: o,
								profiles: i
							})), !Object(_.g)(n())) {
							const e = (e => {
								const t = e.filter(e => e.user_is_subscriber);
								return {
									subredditOrder: t.filter(e => "user" !== e.subreddit_type).map(e => e.name),
									profileOrder: t.filter(e => "user" === e.subreddit_type).map(e => e.name)
								}
							})(u.body.data || []);
							t(P(e))
						}
					} else t(C(u.body))
				}, k = Object(r.a)(v.f), N = Object(r.a)(v.e), L = Object(r.a)(v.d), M = e => async (t, n, r) => {
					const s = n(),
						o = e.toLowerCase(),
						{
							pageInfo: c
						} = s.profiles.moderated;
					if (!c[o] || !c[o].hasNextPage || !c[o].endCursor) return;
					t(k({
						profileName: o
					}));
					const a = await ((e, t) => Object(l.a)(e, Object.assign({}, u, {
							variables: t
						})))(r.gqlContext(), {
							name: o,
							after: c[o].endCursor,
							first: i.h
						}),
						d = a.body.data;
					if (a.ok) {
						const e = Object(m.b)(d.redditor.moderatedSubreddits);
						t(N(Object.assign({
							profileName: o
						}, e)))
					} else t(L(a.error))
				}, U = Object(r.a)(v.i), F = Object(r.a)(v.h), B = Object(r.a)(v.g), G = (e, t) => async (n, r, o) => {
					const c = r(),
						a = e.toLowerCase(),
						d = {
							profileName: a
						};
					if (Object(j.b)(c, d)) return;
					if (!t && Object(j.l)(c, d)) return;
					const {
						pageInfo: u
					} = c.profiles.multireddits;
					if (t && (!u[a] || !u[a].hasNextPage || !u[a].endCursor)) return;
					n(U(d));
					const m = await ((e, t) => Object(l.a)(e, Object.assign({}, b, {
							variables: t
						})))(o.gqlContext(), {
							name: a,
							first: t ? i.h : s.Cb,
							after: t ? u[a].endCursor : void 0
						}),
						f = m.body.data;
					if (m.ok) {
						const e = f.redditorInfoByName.multireddits.edges.map(e => e.node),
							t = Object(p.b)(e);
						n(F(Object.assign({}, d, t, {
							pageInfo: f.redditorInfoByName.multireddits.pageInfo,
							multiredditsModelsState: c.multireddits.models
						})))
					} else n(B(Object.assign({}, d, {
						error: m.error
					})))
				}
		},
		"./src/reddit/actions/profileConversations.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./node_modules/lodash/difference.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				c = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/pages/profileShared.ts"),
				u = n("./src/reddit/constants/parameters.ts"),
				l = n("./src/reddit/constants/things.ts"),
				b = n("./src/config.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var f = n("./src/reddit/helpers/makeProfileListingKey/index.ts");
			n.d(t, "f", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "g", (function() {
				return w
			}));
			const g = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_PENDING",
				O = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_LOADED",
				h = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_FAILED",
				y = "PROFILE__EXTRACOMMENTS_PENDING",
				j = "PROFILE__EXTRACOMMENTS_LOADED",
				_ = "PROFILE__EXTRACOMMENTS_FAILED",
				E = Object(a.a)(g),
				v = Object(a.a)(O),
				I = Object(a.a)(h),
				S = Object(a.a)(j),
				T = Object(a.a)(y),
				x = Object(a.a)(_),
				C = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t(),
						{
							currentPage: a
						} = o.platform;
					if (!a || !a.routeMatch) return;
					const {
						queryParams: l,
						params: g
					} = a.routeMatch.match, {
						sort: O,
						t: h
					} = Object(d.a)(o, l), {
						profileName: y
					} = g, j = y.toLowerCase(), _ = Object(f.a)(j, c.jb, O, l), S = o.listings.postOrder.loadMore[_];
					if (!S) return;
					const T = o.listings.postOrder.api.pending[_],
						{
							fetchedTokens: x
						} = o.listings.postOrder,
						C = !(!x[_] || !x[_][S.token]);
					if (T || C) return;
					e(E({
						key: _,
						fetchedToken: S.token
					}));
					const w = await ((e, t, n) => Object(p.b)(e, {
						data: n,
						endpoint: Object(m.a)("".concat(b.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/conversations")),
						method: c.bb.GET
					}))(r(), y, Object.assign({
						after: S.token,
						dist: S.dist,
						sort: O,
						t: h
					}, i()(l, u.k)));
					if (w.ok) {
						const t = o.listings.postOrder.ids[_],
							n = Object.assign({}, w.body, {
								postIds: s()(w.body.postIds, t)
							});
						e(v(Object.assign({
							fetchedToken: S.token,
							key: _,
							meta: o.meta,
							profileName: y
						}, n)))
					} else e(I({
						error: w.error,
						fetchedToken: S.token,
						key: _,
						account: w.body.data ? w.body.data.account : null
					}))
				}, w = (e, t, n) => async (r, s, o) => {
					let {
						apiContext: i
					} = o;
					if (s().profileOverviewPage.conversations.extraComments.api.pending[n]) return;
					r(T({
						extraCommentsId: n
					}));
					let a = t;
					t.startsWith(l.b) && (a = t.slice(l.b.length));
					const d = n.split("-")[1],
						u = await ((e, t, n, r) => Object(p.b)(e, {
							endpoint: Object(m.a)("".concat(b.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/morecomments/").concat(n)),
							method: c.bb.GET,
							type: "json",
							data: {
								after: r,
								limit: 14
							}
						}))(i(), e, a, d);
					u.ok ? r(S(Object.assign({
						profileName: e,
						extraCommentsId: n
					}, u.body))) : r(x(u.body))
				}
		},
		"./src/reddit/actions/profileOverviewChrono.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "d", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./node_modules/lodash/difference.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				d = n("./src/reddit/selectors/profileOverviewChronoItems.ts"),
				u = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/constants/parameters.ts"),
				b = n("./src/reddit/actions/pages/profileShared.ts"),
				p = n("./src/reddit/endpoints/page/profileOverviewPage.ts");
			const m = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_PENDING",
				f = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_LOADED",
				g = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_FAILED",
				O = Object(c.a)(m),
				h = Object(c.a)(f),
				y = Object(c.a)(g),
				j = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t(),
						{
							currentPage: c
						} = o.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: m,
						params: f
					} = c.routeMatch.match, {
						sort: g,
						t: j
					} = Object(b.a)(o, m), {
						profileName: _
					} = f, E = Object(a.a)(_, u.ib, g, m), v = Object(d.d)(o, {
						listingKey: E
					});
					if (!v) return;
					const I = Object(d.b)(o, {
							listingKey: E
						}),
						S = Object(d.c)(o, {
							listingKey: E
						}),
						T = S && S[v.token];
					if (I || T) return;
					e(O({
						key: E,
						fetchedToken: v.token
					}));
					const x = await Object(p.a)(r(), _, Object.assign({
						after: v.token,
						dist: v.dist,
						sort: g,
						t: j
					}, i()(m, l.k)));
					if (x.ok) {
						const t = Object(d.f)(o, {
								listingKey: E
							}),
							n = Object.assign({}, x.body, {
								overviewIds: s()(x.body.overviewIds, t)
							});
						e(h(Object.assign({
							fetchedToken: v.token,
							key: E,
							meta: o.meta
						}, n)))
					} else e(y({
						error: x.error,
						fetchedToken: v.token,
						key: E,
						account: x.body.data ? x.body.data.account : null
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return _
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/post.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				c = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				a = n("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const d = Object(r.a)(o.x),
				u = Object(r.a)(o.y),
				l = Object(r.a)(o.G),
				b = (Object(r.a)(o.H), Object(r.a)(o.I)),
				p = Object(r.a)(o.T),
				m = e => async (t, n) => {
					if (Object(c.a)(n())) return Object(c.b)(n()) ? t(f(e)) : t((() => async (e, t, n) => {
						let {
							gqlContext: r
						} = n;
						const s = Object(a.l)(t()),
							o = s.global.lastUpdated || 0,
							c = 1e3 * s.global.rpan_config_refresh_rate;
						if (s.isPending || Date.now() < o + c) return;
						e(l());
						const u = await Object(i.a)(r());
						u.ok && u.body ? e(d(Object.assign({}, u.body, {
							lastUpdated: Date.now()
						}))) : e(b())
					})())
				}, f = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const o = Object(a.l)(n()),
						c = Object(a.n)(n(), {
							subreddit: e
						}),
						p = c && c.lastUpdated || 0,
						m = 1e3 * o.global.rpan_config_refresh_rate;
					if (o.isPending || o.isPermanentlyCanceled || Date.now() < p + m) return;
					t(l());
					const f = await Object(i.b)(s(), e);
					if (!f.ok) return void t(b());
					const g = f.body;
					t(d(Object.assign({}, g.global, {
						lastUpdated: Date.now()
					}))), t(u({
						name: e,
						config: Object.assign({}, g.listing_info, {
							lastUpdated: Date.now()
						})
					}))
				}, g = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					t(p()), await Object(i.h)(s(), e)
				}, O = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					n().posts.models[e] || await t(Object(s.y)(e))
				}, h = Object(r.a)(o.w), y = Object(r.a)(o.J), j = Object(r.a)(o.K), _ = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const s = t();
					if (!Object(c.b)(s) || Object(a.i)(s)) return;
					e(y());
					const o = await Object(i.c)(r());
					o.ok && o.body && o.body.data ? e(h({
						subreddits: o.body.data
					})) : e(j({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "F", (function() {
				return s
			})), n.d(t, "Y", (function() {
				return o
			})), n.d(t, "X", (function() {
				return i
			})), n.d(t, "P", (function() {
				return c
			})), n.d(t, "x", (function() {
				return a
			})), n.d(t, "y", (function() {
				return d
			})), n.d(t, "G", (function() {
				return u
			})), n.d(t, "I", (function() {
				return l
			})), n.d(t, "H", (function() {
				return b
			})), n.d(t, "u", (function() {
				return p
			})), n.d(t, "v", (function() {
				return m
			})), n.d(t, "z", (function() {
				return f
			})), n.d(t, "N", (function() {
				return g
			})), n.d(t, "M", (function() {
				return O
			})), n.d(t, "O", (function() {
				return h
			})), n.d(t, "A", (function() {
				return y
			})), n.d(t, "L", (function() {
				return j
			})), n.d(t, "w", (function() {
				return _
			})), n.d(t, "J", (function() {
				return E
			})), n.d(t, "K", (function() {
				return v
			})), n.d(t, "E", (function() {
				return I
			})), n.d(t, "C", (function() {
				return S
			})), n.d(t, "U", (function() {
				return T
			})), n.d(t, "D", (function() {
				return x
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "t", (function() {
				return w
			})), n.d(t, "B", (function() {
				return P
			})), n.d(t, "T", (function() {
				return D
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "n", (function() {
				return A
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "f", (function() {
				return L
			})), n.d(t, "i", (function() {
				return M
			})), n.d(t, "c", (function() {
				return U
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "l", (function() {
				return B
			})), n.d(t, "r", (function() {
				return G
			})), n.d(t, "s", (function() {
				return V
			})), n.d(t, "Z", (function() {
				return q
			})), n.d(t, "W", (function() {
				return H
			})), n.d(t, "V", (function() {
				return K
			})), n.d(t, "a", (function() {
				return W
			})), n.d(t, "m", (function() {
				return Y
			})), n.d(t, "R", (function() {
				return z
			})), n.d(t, "h", (function() {
				return J
			})), n.d(t, "j", (function() {
				return Q
			})), n.d(t, "k", (function() {
				return X
			})), n.d(t, "q", (function() {
				return Z
			})), n.d(t, "p", (function() {
				return $
			})), n.d(t, "Q", (function() {
				return ee
			})), n.d(t, "S", (function() {
				return te
			}));
			var r = n("./src/config.ts");
			const s = "RPAN__REMOVE_STREAM_FROM_HISTORY",
				o = "RPAN__VISIT_STREAM",
				i = -1,
				c = "RPAN__RESET_HISTORY",
				a = "RPAN__RECEIVE_GLOBAL_CONFIG",
				d = "RPAN__RECEIVE_SUBREDDIT_CONFIG",
				u = "RPAN__REQUEST_CONFIG",
				l = "RPAN__REQUEST_CONFIG_FAILED",
				b = "RPAN__REQUEST_CONFIG_CANCELED",
				p = "RPAN__RECEIVE_HLS_STREAM_ENDED",
				m = "RPAN__RECEIVE_HLS_STREAM_REMOVED",
				f = "RPAN__RECEIVE_STREAM_MODEL",
				g = "RPAN__REQUEST_STREAM_MODEL",
				O = "RPAN__REQUEST_STREAM_FAILED",
				h = "RPAN__REQUEST_STREAM_MODEL_BATCH",
				y = "RPAN__RECEIVE_STREAM_MODEL_BATCH",
				j = "RPAN__REQUEST_STREAM_BATCH_FAILED",
				_ = "RPAN__RECEIVE_RECOMMENDED_VIEWER_SUBREDDITS",
				E = "RPAN__REQUEST_RECOMMENDED_VIEWER_SUBREDDITS",
				v = "RPAN__REQUEST_RECOMMENDED_VIEWER_SUBREDDITS_FAILED",
				I = "RPAN__RECEIVE_VOTE",
				S = "RPAN__RECEIVE_THEATER_SETTINGS",
				T = "RPAN__UPDATE_VIDEO_TIMESTAMP",
				x = "RPAN__RECEIVE_USER_SETTINGS",
				C = "RPAN__BATCH_OP",
				w = "RPAN__RECEIVE_DISCOVERY_UNIT_THUMBNAILS",
				P = "RPAN__RECEIVE_STREAM_PREVIEWS",
				D = "RPAN__SEND_HEARTBEAT",
				R = 0,
				A = 9999,
				k = 30,
				N = 6,
				L = 5,
				M = 5,
				U = 57,
				F = 60,
				B = 7e3,
				G = 1e3,
				V = 400,
				q = 1e3,
				H = "https://watch.redd.it/",
				K = ".m3u8",
				W = 3e4,
				Y = "".concat(r.a.assetPath, "/img/trending-placeholder.png"),
				z = "home",
				J = 3,
				Q = 4,
				X = 1e4,
				Z = 500,
				$ = 2e3,
				ee = "".concat(r.a.redditUrl, "/r/").concat("pan"),
				te = "https://www.redditinc.com/policies/broadcasting-content-policy"
		},
		"./src/reddit/actions/publicAccessNetwork/streams.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "j", (function() {
				return w
			}));
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			var r = n("./node_modules/query-string/index.js"),
				s = n.n(r),
				o = (n("./src/config.ts"), n("./src/lib/constants/index.ts")),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				a = n("./src/reddit/constants/things.ts"),
				d = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				u = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				l = n("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const b = e => e.startsWith(a.b) ? e.slice(3) : e,
				p = e => e.startsWith(a.b) ? e : "".concat(a.b).concat(e),
				m = e => "/".concat(o.xb.PUBLIC_ACCESS_NETWORK).concat(e ? "/".concat(b(e)) : ""),
				f = () => "/".concat(o.xb.PUBLIC_ACCESS_NETWORK, "/"),
				g = e => "".concat(f(), "r/").concat(e, "/"),
				O = e => {
					let {
						post: t
					} = e;
					return "".concat(g(t.subreddit.name)).concat(b(t.id))
				},
				h = e => {
					const t = location && location.search || "",
						n = s.a.parse(t);
					"home" === e && (n.related = e);
					const r = s.a.stringify(n);
					return r ? "?".concat(r) : ""
				},
				y = Object(i.a)(c.N),
				j = Object(i.a)(c.z),
				_ = Object(i.a)(c.O),
				E = Object(i.a)(c.A),
				v = Object(i.a)(c.M),
				I = Object(i.a)(c.L),
				S = Object(i.a)(c.u),
				T = Object(i.a)(c.v),
				x = e => t => t.post.subreddit.name !== e ? t : Object.assign({}, t, {
					post: Object.assign({}, t.post, {
						subreddit: Object.assign({}, t.post.subreddit, {
							name: "pan"
						})
					})
				}),
				C = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const o = p(e),
						i = n();
					if (Object(l.e)(i, o)) return;
					t(y(o));
					const c = await Object(d.d)(s(), o),
						a = Date.now();
					if (c.ok && c.body && c.body.data) {
						let e = c.body.data;
						const r = Object(l.b)(n());
						r && "pan" !== r && (e = x(r)(e)), t(j({
							model: e,
							utcTimeStamp: a
						}))
					} else t(R({
						streamId: o,
						error: c.error,
						utcTimeStamp: a
					}))
				}, w = e => async (t, n) => Object(u.b)(n()) ? t(D(e)) : t(P()), P = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const s = t();
					if (Object(l.g)(s)) return;
					e(_());
					const o = await Object(d.f)(r()),
						i = Date.now();
					if (o.ok && o.body && o.body.data) {
						const t = o.body.data;
						e(E({
							models: t,
							utcTimeStamp: i
						}))
					} else e(A({
						error: o.error,
						utcTimeStamp: i
					}))
				}, D = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const o = n();
					if (Object(l.g)(o)) return;
					t(_());
					const i = await Object(d.e)(s(), e),
						c = Date.now();
					if (i.ok && i.body && i.body.data) {
						let r = i.body.data;
						const s = Object(l.b)(n());
						s && "pan" !== s && (r = r.map(x(s))), t(E({
							listingName: e,
							models: r,
							utcTimeStamp: c
						}))
					} else t(A({
						error: i.error,
						utcTimeStamp: c
					}))
				}, R = e => async t => {
					t(v(e))
				}, A = e => async t => {
					t(I(e))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/userSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = n("./src/reddit/constants/localStorage.ts"),
				i = n("./src/reddit/helpers/localStorage/index.ts");
			const c = Object(r.a)(s.D),
				a = e => async t => {
					await t(c(e)), t(l())
				}, d = () => async e => {
					const t = u();
					t && e(c(t))
				}, u = () => {
					return Object(i.n)(o.A) || void 0
				}, l = () => async (e, t) => {
					const n = t().publicAccessNetwork.userSettings;
					Object(i.Q)(o.A, n)
				}
		},
		"./src/reddit/actions/railsWidgets.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeListingKey/index.ts"),
				o = n("./src/lib/makeOnboardingSubredditsKey/index.ts"),
				i = n("./src/reddit/actions/discoveryUnit.ts"),
				c = n("./src/reddit/actions/pages/subreddit.ts"),
				a = n("./src/reddit/actions/pages/subredditLeaderboard.ts"),
				d = n("./src/reddit/actions/search/trending.ts"),
				u = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/actions/subreddit/constants.ts"),
				b = n("./src/reddit/endpoints/category/subreddits.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts"),
				g = n("./src/reddit/selectors/subreddit.ts");
			const O = Object(u.a)(l.f),
				h = Object(u.a)(l.e),
				y = Object(u.a)(l.d),
				j = e => async (t, n, s) => {
					let {
						apiContext: i
					} = s;
					const c = n(),
						a = Object(o.a)(e),
						d = Object(g.r)(c, {
							key: a
						}),
						u = Object(g.p)(c, {
							key: a
						});
					if (d || u.length > 0) return;
					t(O({
						key: a
					}));
					const l = await ((e, t) => Object(p.b)(Object(m.a)(e, [f.a]), {
						data: {
							city: t.city || void 0,
							country: t.country || void 0,
							region: t.region || void 0
						},
						endpoint: "".concat(e.apiUrl, "/api/subreddit_onboarding.json"),
						method: r.bb.GET
					}))(i(), e);
					if (l.ok) {
						const e = Object(b.b)(l.body);
						t(h(Object.assign({
							key: a
						}, e)))
					} else {
						const e = l.error;
						t(y({
							key: a,
							error: e
						}))
					}
				};
			var _ = n("./src/reddit/constants/categories.tsx"),
				E = n("./src/reddit/constants/listings.ts"),
				v = n("./src/reddit/selectors/experiments/categoriesPlacement.ts"),
				I = n("./src/reddit/selectors/experiments/railsWidgets.ts"),
				S = n("./src/reddit/selectors/meta.ts"),
				T = n("./src/reddit/selectors/posts.ts");
			n.d(t, "a", (function() {
				return x
			}));
			const x = () => async (e, t) => {
				let n = t();
				const u = Object(I.e)(n);
				if (u)
					if (await Promise.all([e(Object(i.h)()), e(Object(a.b)())]), Object(I.b)(u)) {
						const t = Object(s.a)(E.b.Popular, r.N.TOP);
						if (Object(T.C)(n, {
								listingKey: t
							}).length > 0) return;
						await e(Object(c.i)(t, E.b.Popular, {
							sort: r.N.TOP
						}))
					} else if (Object(I.c)(u)) await e(Object(d.b)());
				else if (Object(I.a)(u)) {
					if (!Object(v.d)(n)) return;
					const i = {
						city: Object(S.a)(n),
						country: Object(S.b)(n),
						region: Object(S.h)(n)
					};
					await e(j(i)), n = t();
					const a = Object(o.a)(i),
						d = Object(g.q)(n, {
							key: a
						}),
						u = Object(_.d)(d),
						l = Object(s.a)(u, r.N.HOT);
					if (Object(T.C)(n, {
							listingKey: l
						}).length > 0) return;
					await e(Object(c.i)(l, u, {
						sort: r.N.HOT
					}))
				}
			}
		},
		"./src/reddit/actions/recommendations.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/lib/makeActionCreator/index.ts");
			n("./src/config.ts"), n("./src/lib/constants/index.ts"), n("./src/lib/makeApiRequest/index.ts"), n("./src/reddit/helpers/addRedesignIdentifier/index.ts"), n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = "RECOMMENDED_POSTS_FAILED",
				o = "RECOMMENDED_POSTS_LOADED";
			Object(r.a)(o), Object(r.a)(s)
		},
		"./src/reddit/actions/redditEmbed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/endpoints/me/index.ts"),
				o = n("./src/reddit/helpers/pageActionLoginRedirect.ts");
			const i = "REDDIT_EMBED_LOADED",
				c = "REDDIT_EMBED_FAILED",
				a = Object(r.a)("REDDIT_EMBED_PENDING"),
				d = Object(r.a)(i),
				u = Object(r.a)(c),
				l = (e, t) => async (e, n, r) => {
					let {
						apiContext: i
					} = r;
					const c = n();
					e(a());
					const l = await Object(s.a)(i());
					l.ok && l.body ? !t || l.body.account ? e(d(l.body)) : Object(o.a)(e, c) : e(u(l.error))
				}
		},
		"./src/reddit/actions/removalReasons/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return r
			})), n.d(t, "l", (function() {
				return s
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "s", (function() {
				return g
			})), n.d(t, "q", (function() {
				return O
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "o", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "m", (function() {
				return _
			})), n.d(t, "t", (function() {
				return E
			}));
			const r = "REMOVALREASONS__LOAD_PENDING",
				s = "REMOVALREASONS__LOAD_SUCCESS",
				o = "REMOVALREASONS__LOAD_FAILED",
				i = "REMOVALREASONS__ADD_PENDING",
				c = "REMOVALREASONS__ADD_SUCCESS",
				a = "REMOVALREASONS__ADD_FAILED",
				d = "REMOVALREASONS__EDIT_PENDING",
				u = "REMOVALREASONS__EDIT_SUCCESS",
				l = "REMOVALREASONS__EDIT_FAILED",
				b = "REMOVALREASONS__DELETE_PENDING",
				p = "REMOVALREASONS__DELETE_SUCCESS",
				m = "REMOVALREASONS__DELETE_FAILED",
				f = "REMOVALREASONS__SUBMIT_PENDING",
				g = "REMOVALREASONS__SUBMIT_SUCCESS",
				O = "REMOVALREASONS__SUBMIT_FAILED",
				h = "REMOVALREASONS__MESSAGE_PENDING",
				y = "REMOVALREASONS__MESSAGE_PRIVATE_SUCCESS",
				j = "REMOVALREASONS__MESSAGE_PUBLIC_SUCCESS",
				_ = "REMOVALREASONS__MESSAGE_FAILED",
				E = "REMOVALREASONS__REMOVEDITEMS_SELECTED"
		},
		"./src/reddit/actions/reportFlow.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "j", (function() {
				return D
			})), n.d(t, "g", (function() {
				return R
			})), n.d(t, "i", (function() {
				return N
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/login.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/reportRules.ts"),
				a = n("./src/reddit/actions/subreddit.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/actions/users.ts"),
				l = n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"),
				b = n("./src/reddit/endpoints/post/index.tsx"),
				p = n("./src/reddit/helpers/isComment.ts"),
				m = n("./src/reddit/helpers/isPost.ts"),
				f = n("./src/reddit/models/Post/index.ts"),
				g = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/user.ts");
			const y = "LAYER_REPORT_PREFIX_",
				j = "REPORT__PENDING",
				_ = "REPORT__LOADED",
				E = "REPORT__FAILED",
				v = Object(s.a)(j),
				I = Object(s.a)(_),
				S = Object(s.a)(E),
				T = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = e.id,
						a = s(),
						u = a.reportFlow.api.pending[c],
						l = a.reportFlow.userIsMod;
					if (u) return;
					n(v({
						id: c
					}));
					const p = await Object(b.m)(i(), e),
						m = "error-report-".concat(c);
					if (p.ok) n(I({
						id: c
					})), n(d.f(m)), !t.isAbuseOfReportButton && l && n(N());
					else {
						n(S({
							id: c
						}));
						const s = p.error && p.error.fields && p.error.fields.length ? p.error.fields[0].msg : "";
						n(d.e({
							id: m,
							kind: g.b.Error,
							text: s || Object(r.a)(a.user.language, "error.tryAgainLater"),
							buttonText: Object(r.a)(a.user.language, "reportFlow.reportRequest.retry"),
							buttonAction: T(e, t)
						}))
					}
				}, x = "REPORT_FLOW__TARGET_SET", C = "REPORT_FLOW__OPENED_FROM_MODAL_PAGE", w = Object(s.a)(x), P = Object(s.a)(C), D = (e, t, n, r) => async (s, d, l) => {
					let {
						apiContext: b
					} = l;
					const g = d(),
						j = Object(p.a)(e),
						_ = Object(m.a)(e);
					if (!_ && !j) return;
					const E = j ? g.comments.models[e] : g.posts.models[e];
					if (!E) return;
					if (!Object(h.K)(d())) return s(Object(o.f)()), void s(Object(i.k)({
						actionSource: i.a.Report,
						redirectUrl: E.permalink
					}));
					s(Object(u.B)(E.author));
					const v = Object(O.U)(g, {
							postId: j ? g.comments.models[e].postId : g.posts.models[e].id
						}),
						I = n || _ && Object(f.i)(E) || j && L(E, g);
					I || g.reportRules.sitewideRules && g.reportRules.sitewideRules.length || s(Object(c.d)()), !I || g.reportRules.liveStreamingRules && g.reportRules.liveStreamingRules.length || s(Object(c.c)()), v && s(Object(a.o)(v.name, v.type)), s(w(r ? y + e : e)), s(P(!!t)), v && s(k(v.name))
				}, R = "REPORT_FLOW__USER_IS_MOD_SET", A = Object(s.a)(R), k = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = await Object(l.a)(s());
					t(A(o.ok && !!o.body[e]))
				}, N = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					e(w(null))
				}, L = (e, t) => {
					const n = e.postId,
						r = n && t.posts.models[n];
					return !!r && Object(f.i)(r)
				}
		},
		"./src/reddit/actions/reportPageRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = "REPORT_PAGE_RULES__LOADED"
		},
		"./src/reddit/actions/reportRules.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts");
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			}));
			const d = "SITEWIDE_RULES_LOADED",
				u = "LIVESTREAMING_RULES_LOADED",
				l = Object(s.a)(d),
				b = Object(s.a)(u),
				p = Object(r.e)("reportFlow.sectionHeaders.spamAndAbuse"),
				m = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					if (!s.user || !s.user.language) return;
					const d = await (e => Object(i.b)(Object(c.a)(e, [a.a]), {
						endpoint: "".concat(e.apiUrl, "/api/sitewide_rules.json"),
						method: o.bb.GET
					}))(r());
					if (d.ok) {
						const t = d.body,
							n = g(t.sitewide_rules, s.user.language);
						e(l(n))
					}
				}, f = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					if (!s.user || !s.user.language) return;
					const d = await (e => Object(i.b)(Object(c.a)(e, [a.a]), {
						endpoint: "".concat(e.apiUrl, "/api/livestream_rules.json"),
						method: o.bb.GET
					}))(r());
					if (d.ok) {
						const t = d.body,
							n = g(t.livestream_rules, s.user.language);
						e(b(n))
					}
				}, g = (e, t) => {
					let n = [];
					if (e && e.length > 2) {
						const r = {
							reasonTextToShow: p(t),
							nextStepReasons: [e[0], e[1]]
						};
						n.push(r), n = n.concat(e.slice(2))
					}
					return n
				}
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "o", (function() {
				return O
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "p", (function() {
				return y
			}));
			var r = n("./node_modules/fbt/lib/FbtPublic.js");
			const s = "SCHEDULED_POSTS_REQUESTED",
				o = "SCHEDULED_POSTS_LOADED",
				i = "SCHEDULED_POSTS_FAILED",
				c = "SCHEDULED_POST_CREATION_SUCCEEDED",
				a = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				d = "SCHEDULED_POST_MUTATE_REQUESTED",
				u = "SCHEDULED_POST_MUTATE_SUCCESS",
				l = "SCHEDULED_POST__EDIT_LOAD",
				b = "SCHEDULED_POST__DELETE_SUCCESS",
				p = () => r.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				m = () => r.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				f = () => r.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				g = () => r.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				O = () => r.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				h = () => r.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				y = () => r.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				})
		},
		"./src/reddit/actions/search.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeSearchKey/index.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/parameters.ts"),
				l = n("./src/reddit/actions/pages/subreddit.ts"),
				b = n("./src/reddit/endpoints/page/search.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts");
			var g = async (e, t) => Object(p.b)(Object(m.a)(e, [f.a]), {
				endpoint: "".concat(e.apiUrl, "/api/related_queries_v1.json?query=").concat(t),
				method: i.bb.GET
			}), O = n("./src/reddit/models/Toast/index.ts"), h = n("./src/reddit/selectors/searchResults.ts"), y = n("./src/reddit/selectors/user.ts");
			n.d(t, "b", (function() {
				return j
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "h", (function() {
				return P
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "e", (function() {
				return R
			})), n.d(t, "i", (function() {
				return A
			}));
			const j = "SEARCH__MORE_RESULTS_PENDING",
				_ = "SEARCH__MORE_RESULTS_RECEIVED",
				E = "SEARCH__MORE_RESULTS_FAILED",
				v = "SEARCH__RELATED_QUERIES_RECEIVED",
				I = "SEARCH__UPDATE_SEARCH_QUERY",
				S = Object(c.a)(I),
				T = Object(c.a)(j),
				x = Object(c.a)(_),
				C = Object(c.a)(E),
				w = Object(c.a)(v),
				P = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = Object(h.g)(o, e);
					if (i && i.length > 0) return;
					const c = await g(s(), e);
					if (c.ok) {
						const n = (e => ({
							relatedQueries: e.body.related_queries
						}))(c);
						t(w({
							query: e,
							relatedQueries: n.relatedQueries
						}))
					}
				}, D = e => async (t, n, r) => {
					let {
						apiContext: c
					} = r;
					const p = n(),
						{
							queryParams: m
						} = p.platform.currentPage,
						f = Object(l.d)(m, Object(y.Y)(p)),
						g = p.platform.currentPage.urlParams.subredditName || p.platform.currentPage.urlParams.multiredditName,
						{
							username: h
						} = p.platform.currentPage.urlParams,
						j = f || s()(m, u.q),
						_ = Object(a.c)(j),
						E = Object.assign({}, _, {
							sort: _.category ? i.Hb.Relevance : _.sort,
							t: _.category ? i.Ob.DAY : _.t
						}),
						v = Object(a.b)(g, h, E);
					let I;
					if (e.indexOf(i.Jb.Posts) > -1) {
						const e = p.listings.postOrder.loadMore[v];
						if (!e) return;
						const t = p.listings.postOrder.api.pending[v],
							n = p.listings.postOrder.fetchedTokens,
							r = n[v] && n[v][e.token];
						if (t || r) return;
						I = e.token
					} else {
						if (!(e.indexOf(i.Jb.Subreddits) > -1 || e.indexOf(i.Jb.Users) > -1)) throw new Error("Should not attempt to fetch more results without a search type"); {
							const e = p.listings.listingOrder.loadMore[v];
							if (!e) return;
							const t = p.listings.listingOrder.api.pending[v],
								n = p.listings.listingOrder.fetchedTokens,
								r = n[v] && n[v][e.token];
							if (t || r) return;
							I = e.token
						}
					}
					const S = "error-".concat(v);
					t(T({
						fetchedToken: I,
						key: v,
						type: e
					}));
					const w = await Object(b.a)(c(), g, h, Object.assign({}, E, {
						after: I,
						type: (_.type || []).join(","),
						b: !0
					}));
					w.ok ? (t(x(Object.assign({
						key: v,
						fetchedToken: I,
						meta: p.meta,
						subredditOrMultiName: g,
						type: e
					}, w.body))), t(d.f(S))) : (t(C(Object.assign({
						key: v,
						error: w.error,
						fetchedToken: I,
						meta: p.meta,
						type: e
					}, w.body))), t(d.e({
						id: S,
						kind: O.b.Error,
						text: Object(o.a)(p.user.language, "search.toast.moreResultsError"),
						buttonText: Object(o.a)(p.user.language, "search.toast.retryButton"),
						buttonAction: D(e)
					})))
				}, R = "SEARCH__TYPEAHEAD_SUCCESS", A = Object(c.a)(R)
		},
		"./src/reddit/actions/search/trending.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./node_modules/uuid/v4.js"),
				o = n.n(s),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/getUrlQueryParams/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				l = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				b = n("./src/reddit/models/Search/index.ts");
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			}));
			const p = "PAGE__TRENDING_SEARCHES_LOADED",
				m = Object(r.a)(p),
				f = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = await (e => {
						const t = {
							withAds: 1,
							ad: Object(c.a)().get("ad")
						};
						return Object(a.b)(Object(d.a)(e, [u.a]), {
							endpoint: "".concat(e.apiUrl, "/api/trending_searches_v1.json"),
							method: i.bb.GET,
							data: t
						})
					})(r());
					if (s.ok) {
						const t = (e => {
							const t = [];
							if (e.body && e.body.trending_searches) {
								const n = e.body.trending_searches.length;
								for (let r = 0; r < n; r++) {
									const n = e.body.trending_searches[r],
										s = n.results.data.children.length > 0 ? n.results.data.children[0].data : null,
										i = {
											id: o()(),
											post: s ? Object(l.a)(s) : null,
											rawQuery: n.query_string,
											searchQuery: n.display_string,
											section: b.c.trending,
											isWhitelisted: n.is_subreddit_whitelisted,
											subredditInfo: s ? {
												icon: s.sr_detail.community_icon || s.sr_detail.icon_img,
												displayText: s.sr_detail.display_name_prefixed
											} : null,
											subredditOccurrences: n.subreddit_occurences - 1,
											type: b.b.text
										};
									t.push(i)
								}
							}
							return t
						})(s);
						return e(m({
							items: t
						})), t
					}
					return null
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/loadWithRetries/index.ts");
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			}));
			const o = "FRONTPAGE_LINKS__REQUEST_LOADED",
				i = Object(r.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				c = Object(r.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				a = Object(r.a)(o),
				d = () => async e => {
					e(i());
					const t = await (async () => (await Object(s.a)(() => n.e("FrontpageLinks").then(n.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default)();
					e(t ? a(t) : c())
				}
		},
		"./src/reddit/actions/shortcuts.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/comment/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/monthsToMinutes/initHomeFeed.ts"),
				a = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/components/Comments/helpers/hiddenComments.ts"),
				l = n("./src/reddit/constants/elementIds.ts"),
				b = n("./src/reddit/constants/modals.ts"),
				p = n("./src/reddit/constants/postLayout.ts"),
				m = n("./src/reddit/constants/shortcuts.ts"),
				f = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				g = n("./src/reddit/helpers/overlay/index.ts"),
				O = n("./src/reddit/helpers/routeKey/index.ts"),
				h = n("./src/reddit/helpers/trackers/lightbox.ts"),
				y = n("./src/reddit/selectors/telemetry.ts");
			const j = e => () => ({
					source: "shortcuts",
					action: "submit",
					noun: e
				}),
				_ = (e, t) => n => ({
					source: "shortcuts",
					action: "submit",
					noun: e,
					post: y.post(n, t)
				}),
				E = (e, t) => n => ({
					source: "shortcuts",
					action: "submit",
					noun: e,
					comment: y.comment(n, t)
				}),
				v = j("show_panel"),
				I = j("esc_close"),
				S = j("c_create_post");
			j("q_navigation");
			var T = n("./src/reddit/selectors/experiments/m2mHomeRedirect.ts"),
				x = n("./src/reddit/selectors/gild.ts"),
				C = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				w = n("./src/reddit/selectors/listings.ts"),
				P = n("./src/reddit/selectors/platform.ts");
			n.d(t, "a", (function() {
				return D
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "c", (function() {
				return k
			})), n.d(t, "l", (function() {
				return N
			})), n.d(t, "k", (function() {
				return L
			})), n.d(t, "p", (function() {
				return M
			})), n.d(t, "j", (function() {
				return U
			})), n.d(t, "o", (function() {
				return F
			})), n.d(t, "t", (function() {
				return B
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "s", (function() {
				return V
			})), n.d(t, "h", (function() {
				return q
			})), n.d(t, "g", (function() {
				return H
			})), n.d(t, "e", (function() {
				return K
			})), n.d(t, "m", (function() {
				return W
			})), n.d(t, "q", (function() {
				return Y
			})), n.d(t, "i", (function() {
				return z
			})), n.d(t, "n", (function() {
				return J
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "r", (function() {
				return ne
			}));
			const D = "SHORTCUTS__ACTIVE_COMMENT_SET",
				R = "SHORTCUTS__ACTIVE_POST_SET",
				A = Object(s.a)(D),
				k = Object(s.a)(R),
				N = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					t(Object(i.i)(b.a.KEYBOARD_SHORTCUTS)), e(v)
				}, L = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = i.shortcuts.activePostId,
						a = i.listings.activeKey,
						d = i.listings.postOrder.ids[a];
					if (!c || d && d.indexOf(c) < 0) {
						const e = d[0];
						return n(k(e)), void ee(e)
					}
					let u, l = c;
					do {
						if (!(u = Object(w.b)(i, {
								postId: l
							})) || !u.nextPost) return;
						l = u.nextPost.id
					} while (i.posts.models[l].hidden);
					i.shortcuts.namespace === m.d.Lightbox ? (Z(n, u.nextPost), e(t ? h.b(c, "next_post", !0) : (e => _("n_next", e))(l))) : (n(k(l)), ee(l), e((e => _("j_next", e))(l)))
				}, M = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.shortcuts.activePostId,
						c = o.listings.activeKey,
						a = o.listings.postOrder.ids[c];
					if (!i || a && a.indexOf(i) < 0) return t(k(a[0])), void ee(a[0]);
					if (0 === a.indexOf(i)) return;
					let d, u = i;
					do {
						if (!(d = Object(w.b)(o, {
								postId: u
							})) || !d.prevPost) return;
						u = d.prevPost.id
					} while (o.posts.models[u].hidden);
					o.shortcuts.namespace === m.d.Lightbox ? (Z(t, d.prevPost), e((e => _("p_previous", e))(u))) : (t(k(u)), ee(u), e((e => _("k_previous", e))(u)))
				}, U = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = $(o);
					if (!i) return;
					let c;
					const a = o.shortcuts.activeCommentId;
					if (a) {
						const e = o.comments.collapsed[i],
							t = o.commentsPage.keyToCommentThreadLinkSets[i];
						if (e[c = a])
							do {
								if (!t[c].next) return;
								c = t[c].next.id
							} while (u.b(c));
						else c = t[c].next.id
					} else {
						const e = o.commentsPage.keyToHeadCommentId[i];
						if (!e) return;
						c = e
					}
					t(A(c)), ee(c), e((e => E("j_next", e))(c))
				}, F = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = $(o);
					if (!i) return;
					let c;
					const a = o.shortcuts.activeCommentId;
					if (a && a !== o.commentsPage.keyToHeadCommentId[i]) {
						const e = o.commentsPage.keyToCommentThreadLinkSets[i];
						for (c = e[a].prev.id; u.b(c);) c = e[c].prev.id
					} else {
						const e = o.commentsPage.keyToHeadCommentId[i];
						if (!e || a === e) return;
						c = e
					}
					t(A(c)), ee(c), e((e => E("k_previous", e))(c))
				}, B = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const i = n(),
						{
							activeCommentId: c,
							activePostId: d
						} = i.shortcuts,
						u = $(i);
					u && (c && !i.comments.collapsed[u][c] ? (t(o.rb(c)), e((e => E("a_upvote", e))(c))) : d && (t(a.N(d)), e((e => _("a_upvote", e))(d))))
				}, G = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const i = n(),
						{
							activeCommentId: c,
							activePostId: d
						} = i.shortcuts,
						u = $(i);
					u && (c && !i.comments.collapsed[u][c] ? (t(o.T(c)), e((e => E("z_downvote", e))(c))) : d && (t(a.o(d)), e((e => _("z_downvote", e))(d))))
				}, V = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const i = n(),
						{
							activeCommentId: c,
							activePostId: d
						} = i.shortcuts,
						u = $(i);
					u && (c && !i.comments.collapsed[u][c] ? (t(o.gb(c)), e((e => E("s_save", e))(c))) : d && (t(a.G(d)), e((e => _("s_save", e))(d))))
				}, q = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.shortcuts.activePostId;
					i && !o.posts.models[i].isSponsored && (t(a.K(i, !o.posts.models[i].hidden, o.shortcuts.namespace === m.d.Lightbox, !0)), t(L(e)), e((e => _("h_hide", e))(i)))
				}, H = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.shortcuts.activePostId,
						c = p.b[o.user.prefs.layout];
					if (i && (c === p.g.Compact || c === p.g.Classic)) {
						const n = o.posts.models[i].crosspostRootId;
						(o.posts.models[i].media || n && o.posts.models[n] && o.posts.models[n].media) && (t(a.p({
							postId: i
						})), e((e => _("x_expando", e))(i)))
					}
				}, K = e => async (t, n, s) => {
					let {
						apiContext: i
					} = s;
					const c = n(),
						a = c.shortcuts.activeCommentId,
						d = $(c);
					if (d && a) {
						if (c.comments.models[a]) t(o.nb({
							commentId: a,
							commentsPageKey: d,
							scrollToAndRemeasure: () => null
						}));
						else if (c.continueThreads.models[a]) {
							const e = c.continueThreads.models[a].parentId,
								n = c.comments.models[e].permalink;
							t(Object(r.b)(n))
						} else t(F(e)), t(o.Z(d, a));
						e((e => E("enter_comment_collapse", e))(a))
					}
				}, W = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.listings.activeKey,
						c = o.listings.postOrder.ids[i],
						a = o.shortcuts.activePostId;
					!c || !a || c.indexOf(a) < 0 || (t(Object(g.a)(o.posts.models[a].permalink)), e((e => _("enter_open_post", e))(a)))
				}, Y = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const i = n(),
						c = $(i),
						{
							activeCommentId: a
						} = i.shortcuts;
					a && c && c !== i.listings.activeKey && (t(o.ob({
						commentsPageKey: c,
						parentCommentId: a
					})), e((e => E("r_comment", e))(a)))
				}, z = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const i = n();
					if (!i.user.account) return;
					const c = Object(P.f)(i),
						a = c ? c.url : "/";
					t(Object(r.b)("".concat(a, "submit"))), e(S)
				}, J = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						{
							activePostId: i
						} = o.shortcuts;
					if (i) {
						const t = o.posts.models[i];
						if (t.source) {
							const n = t.source.url,
								r = window.open(n, "_blank");
							r && r.focus(), e((e => _("l_go_to_link", e))(i))
						}
					}
				}, Q = [C.d, C.q, e => !!Object(x.d)(e)], X = (e, t, n) => async (s, a, u) => {
					let {
						apiContext: l
					} = u;
					const b = a();
					for (const e of Q)
						if (e(b)) return;
					const p = document.activeElement,
						f = b.shortcuts.activeCommentId,
						g = $(b);
					if (p && "true" === p.contentEditable && f && g) s(o.O({
						parentCommentId: f,
						commentsPageKey: g
					})), ee(f);
					else if (b.activeModalId) te(m.b), s(Object(i.i)(b.activeModalId));
					else if (b.toaster[0]) te(m.b), s(Object(d.f)(b.toaster[0].id));
					else if (b.shortcuts.namespace === m.d.Lightbox && b.platform.currentPage) {
						const e = Object(T.f)(b);
						if (n && Object(T.d)(e)) te(m.b), s(Object(c.b)({
							shouldPrepareData: !1
						}));
						else {
							const e = b.platform.currentPage.locationState.closeLocation;
							e && (te(m.b), s(Object(r.b)(e)))
						}
					}
					const {
						activePostId: O
					} = b.shortcuts;
					e(t && O ? h.b(O, "close", !0) : I)
				}, Z = (e, t) => {
					te(m.b), e(k(t.id)), document.body.style.overflow = "", ee(t.id), document.body.style.overflow = "hidden", e(Object(g.a)(t.permalink));
					const n = document.getElementById(l.d);
					n && n.scrollTo(0, 0)
				}, $ = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const n = t.routeMatch,
						r = Object(f.a)(e);
					return Object(O.c)(n, e, r)
				}, ee = e => {
					const t = document.getElementById(e);
					t && t.focus()
				}, te = e => {
					const t = document.getElementById(e),
						n = window.scrollX,
						r = window.scrollY;
					t && (t.focus(), window.scrollTo(n, r))
				}, ne = () => {
					te(m.b)
				}
		},
		"./src/reddit/actions/streaming/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = "SUBREDDIT__STREAMING_MOD_SETTINGS_LOADED"
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return r
			})), n.d(t, "k", (function() {
				return s
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "m", (function() {
				return g
			}));
			const r = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				s = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				i = "SUBREDDIT__STYLES_PENDING",
				c = "SUBREDDIT__STYLES_LOADED",
				a = "SUBREDDIT__STYLES_FAILED",
				d = "STRUCTURED_STYLES__DRAFT_REPLACED",
				u = "STRUCTURED_STYLES__DRAFT_UPDATED",
				l = "STRUCTURED_STYLES__EDITING_STOPPED",
				b = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				m = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				f = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				g = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/omit.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				c = n("./node_modules/react-router-redux/es/index.js"),
				a = n("./src/lib/filterQueryParams/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/apiRequestState.ts"),
				l = n("./src/reddit/actions/imageUploads.ts"),
				b = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				m = e => Object.assign({}, e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				}, e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				}, e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				}, e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}),
				f = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const h = Object(d.a)(O.c),
				y = Object(d.a)(O.b),
				j = Object(d.a)(O.a);
			var _ = n("./src/reddit/actions/widgets/index.ts"),
				E = n("./src/reddit/constants/modals.ts"),
				v = n("./src/reddit/helpers/getGenericUploadError.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				S = n("./src/reddit/helpers/media/index.ts"),
				T = n("./src/reddit/models/Image/index.tsx"),
				x = n("./src/reddit/models/StructuredStyles/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				w = n("./src/reddit/selectors/platform.ts"),
				P = n("./src/reddit/selectors/structuredStyles.ts"),
				D = n("./src/reddit/selectors/user.ts"),
				R = n("./src/reddit/helpers/trackers/blade.ts"),
				A = n("./src/telemetry/index.ts"),
				k = n("./src/reddit/actions/structuredStyles/constants.ts");
			n.d(t, "l", (function() {
				return N
			})), n.d(t, "k", (function() {
				return U
			})), n.d(t, "j", (function() {
				return V
			})), n.d(t, "e", (function() {
				return H
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "g", (function() {
				return z
			})), n.d(t, "c", (function() {
				return Q
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "b", (function() {
				return $
			})), n.d(t, "m", (function() {
				return ee
			})), n.d(t, "a", (function() {
				return te
			})), n.d(t, "h", (function() {
				return ne
			})), n.d(t, "i", (function() {
				return re
			}));
			const N = Object(d.a)(k.m),
				L = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				M = e => {
					const t = Object.assign({}, e);
					return Object.keys(e).forEach(n => {
						L[n] && !e[n] && L[n].forEach(e => t[e] = null)
					}), t
				},
				U = (e, t, n, r) => async (s, o, i) => {
					const {
						apiContext: c
					} = i, a = o(), d = M(t), b = a.structuredStyles.models[e];
					let m;
					for (const e in d)
						if (d[e] !== b[e]) {
							m = !0;
							break
						} if (!m) return;
					s(Object(u.h)(r));
					const f = Object(R.i)(n)(a);
					let O = null,
						h = null;
					try {
						(O = await Object(l.f)(o(), T.a.StructuredStyles)) && (h = Object(l.m)(O)(s, o, i))
					} catch (E) {
						const e = Object(v.a)("webSocket");
						return void s(Object(u.f)(r, e))
					}
					const y = Object(g.S)(a, {
							subredditId: e
						}).name,
						j = await p.e(c(), y, d),
						_ = {};
					if (j.ok) {
						if (h) try {
							await h
						} catch (E) {}
						const n = Object(P.g)(o(), {
							apiRequestId: r
						});
						for (const e in n)
							if (e in t) {
								const t = Object(P.h)(o(), {
									name: e
								});
								t && Object(T.j)(t) && (_[e] = n[e])
							} Object.keys(_).length && s(K(_)), s(Object(u.e)(r)), s(N({
							subredditId: e,
							styles: Object.assign({}, d, _)
						}))
					} else O && O.websocket.close(), s(Object(u.f)(r, j.error));
					Object(A.a)(Object.assign({}, f, {
						actionInfo: Object.assign({}, f.actionInfo, {
							success: j.ok
						})
					}))
				}, F = Object(d.a)(k.l), B = Object(d.a)(k.k), G = Object(d.a)(k.j), V = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					t(F({
						subredditId: e
					}));
					const o = Object(g.S)(n(), {
							subredditId: e
						}).name,
						i = await p.f(s(), o);
					if (i.ok) {
						const r = n().structuredStyles.models[e],
							s = r ? r.mobileKeyColor : null;
						t(B({
							subredditId: e,
							styles: {
								mobileKeyColor: s
							}
						}))
					} else t(G(Object.assign({
						subredditId: e
					}, i.error)))
				}, q = Object(d.a)(k.d), H = e => async (t, n, r) => {
					const s = n(),
						o = s.structuredStyles.models[e] || {},
						i = Object(D.V)(s);
					t(q({
						isNightmodeOn: i,
						styles: o,
						subredditId: e
					})), ce(e, !1)(t, n, r), (e => async (t, n, r) => {
						let {
							gqlContext: s
						} = r;
						const o = n(),
							i = Object(g.S)(o, {
								subredditId: e
							});
						if (!i) return;
						const c = Object(f.d)(o, {
								subredditId: e
							}),
							a = c && c.templateIds;
						if (!a || !a.length) return;
						t(h({
							subredditId: e
						}));
						const d = await Object(p.a)(s(), i.name, a);
						if (d.ok) {
							const n = {};
							if (d.body) {
								const {
									data: e
								} = d.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) n[t.id] = m(t)
							}
							t(y({
								subredditId: e,
								templates: n
							}))
						} else t(j({
							subredditId: e,
							error: d.error
						}))
					})(e)(t, n, r), Object(_.g)(e, !1)(t, n, r)
				}, K = Object(d.a)(k.c), W = e => async (t, n, r) => {
					const s = M(e),
						o = n();
					for (const e in s)
						if (Object(x.l)(e))
							if (s[e]) {
								if ("string" != typeof s[e]) {
									const o = s[e],
										i = await Object(T.e)(o);
									z(e, i)(t, n, r), s[e] = ""
								}
							} else {
								const n = Object(P.h)(o, {
									name: e
								});
								n && t(Object(l.h)(n))
							} t(K(s))
				}, Y = Object(d.a)(k.f), z = (e, t, n) => async (r, s, o) => {
					const i = s(),
						c = n || i.structuredStyles.isEditing,
						a = Object(g.S)(i, {
							subredditId: c
						}).name;
					r(Y({
						imageKey: e,
						uploadId: t.id
					})), r(Object(l.k)(t));
					const d = await p.d(o.apiContext(), a, t.file.name, e, await Object(S.g)(t.file));
					try {
						const n = await Object(l.g)(s(), d, t, T.a.StructuredStyles);
						if (n) {
							const t = n.url;
							r(Object(l.j)(n)), r(K({
								[e]: t
							}))
						}
					} catch (u) {
						if (u instanceof Error) throw u;
						r(Object(l.i)(u))
					}
				}, J = Object(d.a)(k.b), Q = (e, t, n) => async (r, o, c) => {
					const a = o(),
						d = a.structuredStyles.models[e] || {},
						u = a.structuredStyles.draft,
						l = Object(R.h)(t)(a);
					if (n) {
						const t = i()(d, n),
							o = s()(u, n),
							c = Object.assign({}, o, t);
						r(J({
							subredditId: e,
							styles: c
						}))
					} else {
						r(J({
							subredditId: e,
							styles: d
						}))
					}
					Object(A.a)(l)
				}, X = Object(d.a)(k.e), Z = () => async (e, t, n) => {
					const r = t(),
						s = Object(D.W)(r),
						o = !!Object(w.a)(r);
					if (e(X({
							nightmodeTempUpdated: s
						})), o) return;
					const {
						url: i
					} = r.platform.currentPage;
					i && e(Object(c.c)(Object(a.a)(i, ["styling", "route"])))
				}, $ = Object(d.a)(k.a), ee = Object(d.a)(k.n), te = () => async e => e(Z()), ne = e => async (t, n) => {
					const r = n(),
						s = Object(P.j)(r);
					!Object(C.b)(E.a.BLADE_UNSAVED_CHANGES)(r) && s && (Object(P.a)(r, {
						subredditId: e
					}) ? t(Object(b.i)(E.a.BLADE_UNSAVED_CHANGES)) : t(te()))
				}, re = e => async (t, n) => {
					const r = n();
					Object(P.j)(r) || t(Object(D.V)(r) ? Object(b.i)(E.a.BLADE_NIGHTMODE) : H(e))
				}, se = Object(d.a)(k.i), oe = Object(d.a)(k.h), ie = Object(d.a)(k.g), ce = (e, t) => async (n, r, s) => {
					let {
						gqlContext: o,
						apiContext: i
					} = s;
					n(se({
						subredditId: e
					}));
					const c = Object(g.S)(r(), {
						subredditId: e
					});
					if (!c) return;
					if (!t) {
						const r = await p.c(i(), c.name, t);
						if (r.ok) {
							const t = r.body,
								s = t.data ? t.data.style : {};
							n(oe({
								subredditId: e,
								styles: s
							}))
						} else n(ie(Object.assign({
							subredditId: e
						}, r.error)));
						return
					}
					const a = await p.b(o(), c.name);
					if (a.ok) {
						let t = {};
						if (a.body) {
							const {
								data: e
							} = a.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(I.a)(e.subreddit.styles))
						}
						n(oe({
							subredditId: e,
							styles: t
						}))
					} else n(ie(Object.assign({
						subredditId: e
					}, a.error)))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/listingSort/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/makeListingKey/index.ts"),
				u = n("./src/reddit/actions/economics/helpers/async.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/actions/oldSiteRules.ts"),
				p = n("./src/reddit/actions/pages/subreddit.ts"),
				m = n("./src/reddit/actions/preferences.ts"),
				f = n("./src/reddit/actions/subredditRules/constants.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				O = n("./src/reddit/constants/modals.ts"),
				h = n("./src/reddit/constants/parameters.ts"),
				y = n("./src/reddit/constants/postLayout.ts"),
				j = n("./src/reddit/contexts/PageLayer/index.tsx"),
				_ = n("./src/reddit/endpoints/governance/posts.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				v = n("./src/lib/omitHeaders/index.ts"),
				I = n("./src/reddit/constants/headers.ts"),
				S = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var T = n("./src/reddit/endpoints/modQueue/index.ts"),
				x = n("./src/reddit/endpoints/page/subredditPage.ts"),
				C = n("./src/reddit/endpoints/subreddit/about.ts"),
				w = n("./src/reddit/endpoints/subreddit/rules.ts"),
				P = n("./src/reddit/endpoints/user/preferences.ts"),
				D = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				R = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				N = n("./src/reddit/i18n/utils.ts"),
				L = n("./src/reddit/models/Subreddit/index.ts"),
				M = n("./src/reddit/models/Toast/index.ts"),
				U = n("./src/reddit/models/User/index.ts"),
				F = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				B = n("./src/reddit/selectors/oldSiteRules.ts"),
				G = n("./src/reddit/selectors/profile.ts"),
				V = n("./src/reddit/selectors/subreddit.ts"),
				q = n("./src/reddit/selectors/user.ts");
			n.d(t, "m", (function() {
				return K
			})), n.d(t, "l", (function() {
				return W
			})), n.d(t, "k", (function() {
				return Y
			})), n.d(t, "j", (function() {
				return z
			})), n.d(t, "i", (function() {
				return J
			})), n.d(t, "h", (function() {
				return Q
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "p", (function() {
				return te
			})), n.d(t, "o", (function() {
				return oe
			})), n.d(t, "r", (function() {
				return ae
			})), n.d(t, "g", (function() {
				return de
			})), n.d(t, "f", (function() {
				return ue
			})), n.d(t, "e", (function() {
				return le
			})), n.d(t, "q", (function() {
				return fe
			})), n.d(t, "b", (function() {
				return ge
			})), n.d(t, "c", (function() {
				return Oe
			})), n.d(t, "a", (function() {
				return he
			})), n.d(t, "t", (function() {
				return Ee
			})), n.d(t, "n", (function() {
				return ve
			})), n.d(t, "s", (function() {
				return Ie
			}));
			const H = {},
				K = "SUBREDDIT__MODEL_SUCCEEDED",
				W = "SUBREDDIT__MODEL_PENDING",
				Y = "SUBREDDIT__MODEL_FAILED",
				z = "SUBREDDIT__MORE_POSTS_PENDING",
				J = "SUBREDDIT__MORE_POSTS_LOADED",
				Q = "SUBREDDIT__MORE_POSTS_FAILED",
				X = "SUBREDDIT__META_FILTER_TOGGLED",
				Z = Object(a.a)(z),
				$ = Object(a.a)(J),
				ee = Object(a.a)(Q),
				te = Object(a.a)(X),
				ne = Object(a.a)(f.b),
				re = Object(a.a)(f.c),
				se = Object(a.a)(f.a),
				oe = (e, t) => async (n, r) => {
					await (t === L.c.User ? n(ie(e)) : n(ce(e))), 0 === Object(B.a)(r()).length && n(Object(b.b)())
				}, ie = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = Object(G.m)(n(), e),
						i = await Object(w.c)(s(), e);
					if (i.ok) {
						const e = i.body;
						t(ne({
							rules: e,
							subredditId: o
						}))
					}
				}, ce = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const i = Object(V.G)(n(), e),
						c = Object(q.T)(n());
					t(re());
					const a = await Object(w.b)(s(), e);
					if (a.ok) {
						const e = a.body;
						t(ne({
							rules: e,
							subredditId: i
						}))
					} else {
						t(se());
						const n = "error-block-".concat(e);
						t(g.e({
							id: n,
							kind: M.b.Error,
							text: Object(o.a)(c, "error.tryAgainLater")
						}))
					}
				}, ae = e => async (t, n, r) => {
					let {
						apiContext: o,
						gqlContext: i
					} = r;
					const {
						subredditName: a
					} = e;
					let l = e.t;
					const b = Object(R.a)(e),
						p = n(),
						m = p.platform.currentPage ? p.platform.currentPage.queryParams : {},
						f = Object(d.a)(a, b, Object.assign({
							t: l
						}, m)),
						g = p.listings.postOrder.loadMore[f],
						O = p.listings.postOrder.listingSort[f];
					let E = b;
					if (O && !E) {
						const e = Object(c.d)(O.sort);
						E = e.sort, l = e.timeSort
					}
					const v = p.listings.postOrder.api.pending[f],
						{
							fetchedTokens: I
						} = p.listings.postOrder,
						S = !(!I[f] || !I[f][g.token]);
					if (v || S) return;
					t(Z({
						key: f,
						fetchedToken: g.token
					}));
					const T = Object.assign({
						after: g.token,
						dist: g.dist,
						layout: y.e[Object(j.M)(p, {})],
						sort: E,
						t: l
					}, s()(m, [...h.k, h.g]));
					T[h.g] || (T[h.g] = p.user.prefs.geopopular || p.meta.country);
					const C = Object(F.a)(p) ? () => Object(x.b)(i(), Object(x.c)(p, a, Object.assign({}, T, {
							limit: y.a
						})), Object(q.R)(p)) : () => Object(x.a)(o(), a, T),
						w = await C(),
						P = Object.assign({}, w.body, Object(D.a)(p, f, w.body));
					if (w.ok) {
						let e;
						const r = P.postIds.filter(e => !!P.posts[e].isMeta),
							s = Object(V.G)(n(), a);
						if (r.length) {
							const t = await Object(_.a)(o(), s, r);
							t.ok && (e = t.body)
						}
						t($(Object.assign({
							fetchedToken: g.token,
							key: f,
							meta: p.meta,
							governance: e
						}, P))), await t(Object(u.a)({
							subredditId: s,
							postIds: P.postIds,
							skip: ["communityDetails", "subscription"]
						}))
					} else t(ee(Object.assign({
						error: w.error,
						fetchedToken: g.token,
						key: f
					}, P)))
				}, de = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", ue = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", le = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", be = Object(a.a)(de), pe = Object(a.a)(ue), me = Object(a.a)(le), fe = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					if (!s.user.account || s.subreddits.moderated.api.fetched) return;
					e(be());
					const o = await Object(T.b)(r(), i.fb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					o.ok ? e(pe(o.body)) : e(me({
						error: o.error
					}))
				}, ge = "SUBREDDIT__ABOUT_PENDING", Oe = "SUBREDDIT__ABOUT_SUCCEEDED", he = "SUBREDDIT__ABOUT_FAILED", ye = Object(a.a)(ge), je = Object(a.a)(Oe), _e = Object(a.a)(he), Ee = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					const o = n();
					if (Object(V.y)(o, {
							subredditName: e
						}) || o.subreddits.api.about.error[e.toLowerCase()] || o.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(ye({
						subredditName: e
					}));
					const i = !Object(V.G)(o, e),
						c = await Object(C.a)(s(), e, i);
					if (c.ok) {
						const n = c.body.data.subreddit,
							r = Object(A.a)(n),
							s = i ? Object(k.a)(n) : void 0;
						t(je({
							subredditName: e,
							subreddits: s ? {
								[s.id]: s
							} : void 0,
							data: r
						}))
					} else t(_e({
						subredditName: e,
						error: c.error
					}))
				}, ve = (e, t, n) => async (r, s, o) => {
					let {
						apiContext: c
					} = o;
					const a = Object(V.G)(s(), e.substring(2)),
						d = Object(q.i)(s());
					if (d) {
						const s = Object(U.f)(d),
							o = t + "\n\n   *To approve this user*, visit [the approved users page for " + e + "](https://www.reddit.com/" + e + "/about/contributors?user=" + s + ') and click "ADD USER".\n    Approving this user gives them permission to ' + n + ". You can change these community restrictions from the [community settings](/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + s + "](/u/" + s + ") or reply to this message to start a conversation.",
							u = {
								to: "/".concat(e),
								subject: Object(N.c)("I would like to join ".concat(Object(N.b)("displayName", e))),
								text: o
							};
						if ((await ((e, t) => Object(E.b)(Object(v.a)(e, [I.a]), {
								endpoint: Object(S.a)("".concat(e.apiUrl, "/api/compose")),
								method: i.bb.POST,
								data: t
							}))(c(), u)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							r(Object(m.C)({
								subredditId: a,
								prefs: t
							})), Object(P.h)(a, t, c()), r(Object(l.i)(O.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, Ie = e => async (t, n) => {
					const r = n(),
						{
							subredditName: s
						} = e,
						o = e.t,
						i = Object(R.a)(e),
						c = r.platform.currentPage ? r.platform.currentPage.queryParams : H,
						a = Object(d.a)(s, i, Object.assign({
							t: o
						}, c)),
						u = Object.assign({
							t: o,
							sort: i
						}, c);
					await t(Object(p.i)(a, s, u, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "n", (function() {
				return l
			})), n.d(t, "m", (function() {
				return b
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "q", (function() {
				return y
			}));
			const r = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				s = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				i = "SUBREDDIT__POSTS_LOADED",
				c = "SUBREDDIT__POSTS_SET_FAILED",
				a = "SUBREDDIT__RANKINGS_PENDING",
				d = "SUBREDDIT__RANKINGS_LOADED",
				u = "SUBREDDIT__RANKINGS_FAILED",
				l = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				b = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				m = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				f = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				g = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				O = "SUBREDDIT__EDIT_REQUESTED",
				h = "SUBREDDIT__EDIT_FAILED",
				y = "SUBREDDIT__EDIT_SUCCESS"
		},
		"./src/reddit/actions/subreddit/similarSubreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return b
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/subreddit/constants.ts"),
				o = n("./src/reddit/endpoints/category/subreddits.ts"),
				i = n("./src/reddit/endpoints/subreddit/similar.ts"),
				c = n("./src/reddit/selectors/subreddit.ts");
			const a = e => {
					let t = e.subredditIds.join(",");
					return e.count && (t += "--[count:'".concat(e.count, "']")), e.variant && (t += "--[variant:'".concat(e.variant, "']")), t.toLowerCase()
				},
				d = Object(r.a)(s.n),
				u = Object(r.a)(s.m),
				l = Object(r.a)(s.l),
				b = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const b = n(),
						p = a(e),
						m = Object(c.w)(b, {
							key: p
						}),
						f = Object(c.v)(b, {
							key: p
						});
					if (m || f.length > 0) return;
					t(d({
						key: p
					}));
					const g = await Object(i.b)(s(), e);
					if (g.ok) {
						const e = Object(o.b)(g.body);
						t(u(Object.assign({
							key: p
						}, e)))
					} else {
						const e = g.error;
						t(l({
							key: p,
							error: e
						}))
					}
				}
		},
		"./src/reddit/actions/subreddit/subredditPosts.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeListingKey/index.ts"),
				i = n("./src/reddit/actions/subreddit/constants.ts"),
				c = n("./src/graphql/operations/SubredditPosts.json"),
				a = n("./src/lib/makeGqlRequest/index.ts");
			var d = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			n.d(t, "a", (function() {
				return b
			}));
			const u = Object(s.a)(i.h),
				l = Object(s.a)(i.g),
				b = e => async (t, n, s) => {
					let {
						gqlContext: i
					} = s;
					try {
						const s = n(),
							l = s.posts && s.posts.models,
							b = (await ((e, t) => Object(a.a)(e, Object.assign({}, c, {
								variables: t
							})))(i(), e)).body,
							{
								posts: p
							} = b && b.data && b.data.subreddit,
							m = ((e, t) => {
								const {
									edges: n
								} = e, r = n.filter(e => (e => !e.node.crosspostRoot)(e) && ((e, t) => !t.hasOwnProperty(e.node.id))(e, t));
								return Object.assign({}, e, {
									edges: r
								})
							})(p, l);
						if (!m.edges.length) return;
						const f = (e => {
								let {
									edges: t
								} = e;
								const n = [];
								for (const {
										node: r
									} of t) n.push(Object(d.d)(r));
								return n
							})(m),
							{
								range: g,
								sort: O,
								subredditName: h
							} = e,
							y = Object(o.a)(h, r.N[O], {
								t: g
							}),
							j = (e => e.reduce((e, t) => (e[t.id] = t, e), {}))(f),
							_ = f.map(e => e.id),
							E = {
								dist: p.dist,
								key: y,
								meta: s.meta,
								postIds: _,
								posts: j
							};
						t(u(E))
					} catch (b) {
						l(b)
					}
				}
		},
		"./src/reddit/actions/subreddit/topSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var r = n("./node_modules/lodash/sampleSize.js"),
				s = n.n(r),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/subreddit/constants.ts"),
				c = n("./src/reddit/constants/subredditLeaderboard.ts"),
				a = n("./src/reddit/endpoints/subreddit/models.ts"),
				d = n("./src/reddit/endpoints/subreddit/topSubreddits.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeTopSubredditsFromGql/index.ts"),
				l = n("./src/reddit/selectors/experiments/upAndComingLeaderboard.ts");
			const b = Object(o.a)(i.k),
				p = Object(o.a)(i.j),
				m = Object(o.a)(i.i),
				f = Object(o.a)(i.a),
				g = Object(o.a)(i.b),
				O = Object(o.a)(i.c),
				h = (e, t) => async (n, r, s) => {
					let {
						gqlContext: o
					} = s;
					if (t === c.l) return void(Object(l.b)(r()) && n(y()));
					n(b());
					const i = await Object(d.a)(o(), e);
					if (i.ok) {
						const e = i.body,
							r = e && e.data && e.data.subredditLeaderboard,
							{
								pageInfo: s,
								rankings: o,
								subreddits: c
							} = Object(u.b)(r);
						n(f({
							subreddits: c
						})), n(g({
							categoryRankingsKey: t,
							rankings: o
						})), n(O({
							categoryRankingsKey: t,
							pageInfo: s
						})), n(p())
					} else {
						const e = i.error;
						n(m({
							error: e
						}))
					}
				}, y = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const o = s()(l.a, 25);
					e(b());
					const i = await Object(a.a)(r(), {
						names: o
					});
					if (!i.ok) {
						const t = i.error;
						return void e(m({
							error: t
						}))
					}
					const d = i.body,
						O = d && d.data && d.data.subredditsInfoByNames,
						{
							rankings: h,
							subreddits: y
						} = Object(u.a)(O);
					e(f({
						subreddits: y
					})), e(g({
						categoryRankingsKey: c.l,
						rankings: h
					})), e(p())
				}
		},
		"./src/reddit/actions/subredditAutocomplete.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/graphql/operations/SubredditTypeaheadSearch.json"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = (e, t) => Object(o.a)(e, Object.assign({}, s, {
					variables: t
				})),
				c = n("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts"),
				a = e => {
					let {
						allowedPostTypes: t,
						id: n,
						isCrosspostDestination: r,
						isNsfw: s,
						name: o,
						styles: i,
						subscribersCount: a
					} = e;
					return {
						allowedPostTypes: Object(c.a)(t),
						communityIcon: i && i.icon || "",
						icon: i && i.legacyIcon && i.legacyIcon.url || "",
						id: n,
						isCrosspostDestination: r,
						isNsfw: s,
						name: o,
						primaryColor: i && i.primaryColor || "",
						subscribers: a
					}
				},
				d = n("./src/reddit/helpers/name/index.ts"),
				u = n("./src/reddit/selectors/subredditAutocomplete.ts");
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return O
			}));
			const l = "SUBREDDIT_AUTOCOMPLETE__PENDING",
				b = "SUBREDDIT_AUTOCOMPLETE__LOADED",
				p = "SUBREDDIT_AUTOCOMPLETE__FAILED",
				m = Object(r.a)(l),
				f = Object(r.a)(b),
				g = Object(r.a)(p),
				O = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, r, s) => {
						let {
							gqlContext: o
						} = s;
						const c = Object(d.f)(e);
						if (!c) return;
						const l = r(),
							b = l.subredditAutocomplete;
						if (b.api.pending[c] || b.models[c]) return;
						if (Object(u.b)(l, {
								substring: c
							})) return;
						n(m({
							key: c
						}));
						const p = await i(o(), {
							query: c,
							includeNsfw: t
						});
						if (p.ok) {
							const e = p.body.data.subredditTypeahead.subreddits.edges.map(e => a(e.node));
							n(f(Object.assign({
								key: c
							}, {
								key: c,
								subreddits: e
							})))
						} else n(g({
							key: c,
							error: p.error
						}))
					}
				}
		},
		"./src/reddit/actions/subredditCreation.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const u = e => ({
				public_description: e.publicDescription,
				name: e.name,
				type: e.type,
				over_18: e.over18,
				restrict_commenting: e.restrictCommenting,
				restrict_posting: e.restrictPosting,
				existing_tags: e.existingTags.join(","),
				new_tags: e.newTags.join(",")
			});
			var l = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/telemetry/index.ts");
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "f", (function() {
				return E
			}));
			const m = "SUBREDDIT__CREATE_PENDING",
				f = "SUBREDDIT__CREATE_SUCCEEDED",
				g = "SUBREDDIT__CREATE_FAILED",
				O = "SUBREDDIT__CREATE_CLEARED",
				h = Object(s.a)(m),
				y = Object(s.a)(f),
				j = Object(s.a)(g),
				_ = Object(s.a)(O),
				E = e => async (t, n, s) => {
					let {
						apiContext: m
					} = s;
					const f = n(),
						{
							name: g,
							type: O
						} = e;
					if (Object(b.l)(f)) return;
					t(h({
						subredditName: g
					}));
					const _ = await ((e, t) => Object(i.b)(Object(c.a)(e, [a.a]), {
						endpoint: Object(d.a)("".concat(e.apiUrl, "/api/v1/subreddit/create_subreddit")),
						method: o.bb.POST,
						data: u(t)
					}))(m(), e);
					if (_.ok) {
						const n = _.body,
							s = n.fullname;
						Object(p.a)(Object(l.c)(O, e, s)(f)), t(y({
							subredditName: g
						})), window.location.href = "".concat(r.a.redditUrl).concat(n.path, "new")
					} else _.error && Object(p.a)(Object(l.d)(_.error.type)(f)), t(j({
						subredditName: g,
						error: _.error
					}))
				}
		},
		"./src/reddit/actions/subredditCrosspostable.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/subscription/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			}));
			const u = "SUBREDDIT_CROSSPOSTABLE__PENDING",
				l = "SUBREDDIT_CROSSPOSTABLE__LOADED",
				b = "SUBREDDIT_CROSSPOSTABLE__FAILED",
				p = (Object(r.a)(u), Object(r.a)(l)),
				m = Object(r.a)(b),
				f = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					await e(s.e());
					const {
						api: u,
						ids: l
					} = t().subreddits.crosspostable;
					if (u.pending || Object.keys(l).length) return;
					const b = await ((e, t) => Object(i.b)(Object(c.a)(e, [a.a]), {
						data: t,
						endpoint: "".concat(e.apiUrl, "/api/crosspostable_subreddits.json"),
						method: o.bb.GET
					}))(r(), {
						sr_detail: !1
					});
					if (b.ok) {
						const n = t(),
							r = b.body && b.body.length ? b.body.map(e => Object(d.G)(n, e)).filter(e => !!e).reduce((e, t) => (e[t] = !0, e), {}) : {};
						e(p({
							subredditIds: r
						}))
					} else e(m({
						error: b.error
					}))
				}
		},
		"./src/reddit/actions/subredditDifficulty/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const r = "SUBREDDIT__DIFFICULTY_LOADED",
				s = "SUBREDDIT__DIFFICULTY_FAILED"
		},
		"./src/reddit/actions/subredditDifficulty/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/subredditDifficulty/constants.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/graphql/operations/SubredditDifficulty.json"),
				c = n("./src/lib/makeGqlRequest/index.ts");
			var a = n("./src/reddit/i18n/utils.ts"),
				d = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/subredditDifficulty.ts");
			n.d(t, "a", (function() {
				return p
			}));
			const l = Object(r.a)(s.b),
				b = Object(r.a)(s.a),
				p = e => async (t, n, r) => {
					let {
						gqlContext: s
					} = r;
					if (Object(u.a)(n(), {
							subredditId: e
						})) return;
					const p = await ((e, t) => Object(c.a)(e, Object.assign({}, i, {
						variables: t
					})))(s(), {
						ids: [e]
					});
					if (p.ok) {
						const n = p.body.data;
						n ? t(l({
							subredditId: e,
							subreddits: n.subreddits
						})) : (t(b(e)), t(o.e({
							id: "error-block-subredditDifficulty",
							kind: d.b.Error,
							text: Object(a.c)("Something went wrong")
						})))
					} else t(b(e)), t(o.e({
						id: "error-block-subredditDifficulty",
						kind: d.b.Error,
						text: Object(a.c)("Something went wrong")
					}))
				}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/config.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/models/Post/index.ts");
			var a = n("./src/reddit/models/Duplicates/index.ts"),
				d = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/selectors/profile.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return m
			}));
			const b = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(r.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(r.a)(b)),
				m = (e, t) => async (n, r, b) => {
					let {
						apiContext: m
					} = b;
					const f = Object(l.S)(r(), {
						subredditId: e
					}) || Object(u.p)(r(), {
						profileId: e
					});
					if (!f) return;
					const g = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(d.e)(f) ? s.Qb + f.name : f.name
						},
						O = await ((e, t, n) => Object(i.b)(e, {
							data: n,
							endpoint: "".concat(o.a.gatewayUrl, "/desktopapi/v1/duplicates/").concat(Object(c.n)(t)),
							method: s.bb.GET
						}))(m(), t, g);
					if (O.ok) {
						const r = O.body;
						n(p({
							distinguishKey: Object(a.a)(t, g),
							postIds: r.postIds,
							posts: r.posts,
							profiles: r.profiles,
							subreddits: r.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditMention/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			const r = "SUBREDDIT_MENTION_LOADED",
				s = "SUBREDDIT__MODEL_SUCCEEDED",
				o = "SUBREDDIT__MODEL_PENDING",
				i = "SUBREDDIT__MODEL_FAILED"
		},
		"./src/reddit/actions/subredditModeration.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/lodash/get.js"),
				o = n.n(s),
				i = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/app/strings/index.ts"),
				a = n("./src/reddit/actions/apiRequestState.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subreddit.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				b = n("./src/reddit/constants/modals.ts"),
				p = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts");
			const O = (e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/contributors"),
				method: p.bb.GET,
				data: n
			});
			var h = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const y = (e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
					endpoint: Object(h.a)("".concat(e.apiUrl, "/api/v1/").concat(t, "/banned")),
					method: p.bb.GET,
					data: n
				}),
				j = (e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators"),
					method: p.bb.GET,
					data: Object.assign({}, n, {
						count: 10
					})
				}),
				_ = (e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators_invited"),
					method: p.bb.GET,
					data: Object.assign({}, n, {
						count: 50
					})
				}),
				E = (e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/muted"),
					method: p.bb.GET,
					data: n
				});
			var v = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				I = n("./src/reddit/i18n/utils.ts"),
				S = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				T = n("./src/reddit/models/SubredditModeration/index.ts"),
				x = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/models/User/index.ts"),
				w = n("./src/reddit/selectors/activeModalId.ts"),
				P = n("./src/reddit/selectors/subreddit.ts"),
				D = n("./src/reddit/selectors/subredditModeration.ts"),
				R = n("./src/reddit/selectors/user.ts");
			n.d(t, "J", (function() {
				return A
			})), n.d(t, "H", (function() {
				return k
			})), n.d(t, "G", (function() {
				return N
			})), n.d(t, "ib", (function() {
				return F
			})), n.d(t, "M", (function() {
				return B
			})), n.d(t, "L", (function() {
				return G
			})), n.d(t, "K", (function() {
				return V
			})), n.d(t, "jb", (function() {
				return W
			})), n.d(t, "I", (function() {
				return Y
			})), n.d(t, "N", (function() {
				return z
			})), n.d(t, "ob", (function() {
				return X
			})), n.d(t, "hb", (function() {
				return Z
			})), n.d(t, "e", (function() {
				return $
			})), n.d(t, "d", (function() {
				return ee
			})), n.d(t, "c", (function() {
				return te
			})), n.d(t, "V", (function() {
				return oe
			})), n.d(t, "h", (function() {
				return ie
			})), n.d(t, "g", (function() {
				return ce
			})), n.d(t, "f", (function() {
				return ae
			})), n.d(t, "W", (function() {
				return be
			})), n.d(t, "b", (function() {
				return pe
			})), n.d(t, "i", (function() {
				return me
			})), n.d(t, "U", (function() {
				return Oe
			})), n.d(t, "mb", (function() {
				return he
			})), n.d(t, "m", (function() {
				return ye
			})), n.d(t, "l", (function() {
				return je
			})), n.d(t, "k", (function() {
				return _e
			})), n.d(t, "Z", (function() {
				return Se
			})), n.d(t, "p", (function() {
				return Te
			})), n.d(t, "o", (function() {
				return xe
			})), n.d(t, "n", (function() {
				return Ce
			})), n.d(t, "ab", (function() {
				return Re
			})), n.d(t, "j", (function() {
				return Ae
			})), n.d(t, "q", (function() {
				return ke
			})), n.d(t, "Y", (function() {
				return Me
			})), n.d(t, "nb", (function() {
				return Ue
			})), n.d(t, "C", (function() {
				return Fe
			})), n.d(t, "B", (function() {
				return Be
			})), n.d(t, "A", (function() {
				return Ge
			})), n.d(t, "t", (function() {
				return Ke
			})), n.d(t, "s", (function() {
				return We
			})), n.d(t, "r", (function() {
				return Ye
			})), n.d(t, "fb", (function() {
				return Xe
			})), n.d(t, "db", (function() {
				return Ze
			})), n.d(t, "x", (function() {
				return $e
			})), n.d(t, "w", (function() {
				return et
			})), n.d(t, "v", (function() {
				return tt
			})), n.d(t, "eb", (function() {
				return ot
			})), n.d(t, "a", (function() {
				return it
			})), n.d(t, "T", (function() {
				return ut
			})), n.d(t, "Q", (function() {
				return lt
			})), n.d(t, "R", (function() {
				return ft
			})), n.d(t, "lb", (function() {
				return Ot
			})), n.d(t, "u", (function() {
				return ht
			})), n.d(t, "cb", (function() {
				return Et
			})), n.d(t, "F", (function() {
				return vt
			})), n.d(t, "E", (function() {
				return It
			})), n.d(t, "D", (function() {
				return St
			})), n.d(t, "gb", (function() {
				return wt
			})), n.d(t, "y", (function() {
				return Pt
			})), n.d(t, "O", (function() {
				return Rt
			})), n.d(t, "S", (function() {
				return kt
			})), n.d(t, "z", (function() {
				return Nt
			})), n.d(t, "bb", (function() {
				return Mt
			})), n.d(t, "P", (function() {
				return Ut
			})), n.d(t, "kb", (function() {
				return Vt
			})), n.d(t, "X", (function() {
				return qt
			}));
			const A = "SUBREDDIT__MUTEDUSERS_PENDING",
				k = "SUBREDDIT__MUTEDUSERS_LOADED",
				N = "SUBREDDIT__MUTEDUSERS_FAILED",
				L = Object(i.a)(A),
				M = Object(i.a)(k),
				U = Object(i.a)(N),
				F = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, s) => {
						let {
							apiContext: o
						} = s;
						const i = r(),
							c = t.after || "",
							a = Object(T.d)(e, c),
							d = i.muted.fetchedTokens[a];
						if (i.muted.api.pending[a] || d) return;
						n(L({
							subredditId: e,
							fetchedToken: c
						}));
						const u = i.subreddits.models[e].name,
							l = await E(o(), u, t);
						l.ok ? n(M(Object.assign({}, l.body, {
							fetchedToken: c
						}))) : n(U({
							subredditId: e,
							fetchedToken: c
						}))
					}
				},
				B = "SUBREDDIT_MUTEDUSERS_SEARCH_PENDING",
				G = "SUBREDDIT_MUTEDUSERS_SEARCH_LOADED",
				V = "SUBREDDIT_MUTEDUSERS_SEARCH_FAILED",
				q = Object(i.a)(B),
				H = Object(i.a)(G),
				K = Object(i.a)(V),
				W = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r().subreddits.models[e].name,
						c = {
							username: Object(v.a)(t)
						};
					n(q());
					const a = await E(o(), i, c);
					a.ok ? n(H(a.body)) : n(K(a.error))
				}, Y = "SUBREDDIT_MUTEDUSERS_MUTED_SUCCESS", z = "SUBREDDIT_MUTEDUSERS_UNMUTED_SUCCESS", J = Object(i.a)(Y), Q = Object(i.a)(z), X = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					const a = r(),
						d = a.subreddits.models[e].url,
						u = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: p.bb.POST,
							data: {
								api_type: "json",
								id: n,
								type: "muted"
							}
						}))(i(), d, t);
					if (u.ok) n(Q({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(u, "body.json.errors[0][1]", Object(c.a)(a.user.language, "error.type.generic"));
						n(Object(l.e)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Z = (e, t, n) => async (r, s, i) => {
					let {
						apiContext: a
					} = i;
					const d = s(),
						u = d.subreddits.models[e].url,
						b = d.subreddits.models[e].name;
					t = Object(v.a)(t);
					const O = await ((e, t, n, r) => Object(m.b)(Object(f.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: p.bb.POST,
						data: {
							api_type: "json",
							name: n,
							note: r,
							type: "muted"
						}
					}))(a(), u, t, n);
					if (O.ok) {
						const e = {
							username: t
						};
						r(Object(l.e)({
							kind: x.b.SuccessMod,
							text: Object(I.c)("Successfully muted a user")
						}));
						const n = await E(a(), b, e);
						n.ok && r(J(n.body))
					} else {
						const e = o()(O, "body.json.errors[0][1]", Object(c.a)(d.user.language, "error.type.generic"));
						r(Object(l.e)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, $ = "SUBREDDIT__APPROVEDSUBMITTERS_PENDING", ee = "SUBREDDIT__APPROVEDSUBMITTERS_LOADED", te = "SUBREDDIT__APPROVEDSUBMITTERS_FAILED", ne = Object(i.a)($), re = Object(i.a)(ee), se = Object(i.a)(te), oe = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, s) => {
						let {
							apiContext: o
						} = s;
						const i = r(),
							c = t.after || "",
							a = Object(T.d)(e, c),
							d = i.approvedSubmitters.fetchedTokens[a];
						if (i.approvedSubmitters.api.pending[a] || d) return;
						n(ne({
							subredditId: e,
							fetchedToken: c
						}));
						const u = i.subreddits.models[e].name,
							l = await O(o(), u, t);
						l.ok ? n(re(Object.assign({}, l.body, {
							fetchedToken: c
						}))) : n(se({
							subredditId: e,
							fetchedToken: c
						}))
					}
				}, ie = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_PENDING", ce = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_LOADED", ae = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_FAILED", de = Object(i.a)(ie), ue = Object(i.a)(ce), le = Object(i.a)(ae), be = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r().subreddits.models[e].name,
						c = {
							username: Object(v.a)(t)
						};
					n(de());
					const a = await O(o(), i, c);
					a.ok ? n(ue(a.body)) : n(le(a.error))
				}, pe = "SUBREDDIT_APPROVEDSUBMITTERS_APPROVED_SUCCESS", me = "SUBREDDIT_APPROVEDSUBMITTERS_UNAPPROVED_SUCCESS", fe = Object(i.a)(pe), ge = Object(i.a)(me), Oe = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					const a = r(),
						d = a.subreddits.models[e].url,
						u = a.subreddits.models[e].name;
					t = Object(v.a)(t);
					const b = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: p.bb.POST,
						data: {
							api_type: "json",
							name: n,
							type: "contributor"
						}
					}))(i(), d, t);
					if (b.ok) {
						const e = {
							username: t
						};
						n(Object(l.e)({
							kind: x.b.SuccessMod,
							text: Object(I.c)("Successfully added an approved submitter")
						}));
						const r = await O(i(), u, e);
						r.ok && n(fe(r.body))
					} else {
						const e = o()(b, "body.json.errors[0][1]", Object(c.a)(a.user.language, "error.type.generic"));
						n(Object(l.e)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, he = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					const a = r(),
						d = a.subreddits.models[e].url,
						u = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: p.bb.POST,
							data: {
								api_type: "json",
								id: n,
								type: "contributor"
							}
						}))(i(), d, t);
					if (u.ok) n(ge({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(u, "body.json.errors[0][1]", Object(c.a)(a.user.language, "error.type.generic"));
						n(Object(l.e)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, ye = "SUBREDDIT__BANNEDUSERS_PENDING", je = "SUBREDDIT__BANNEDUSERS_LOADED", _e = "SUBREDDIT__BANNEDUSERS_FAILED", Ee = Object(i.a)(ye), ve = Object(i.a)(je), Ie = Object(i.a)(_e), Se = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, s) => {
						let {
							apiContext: o
						} = s;
						const i = r(),
							c = t.after || "",
							a = Object(T.d)(e, c),
							d = i.banned.fetchedTokens[a];
						if (i.banned.api.pending[a] || d) return;
						n(Ee({
							subredditId: e,
							fetchedToken: c
						}));
						const u = i.subreddits.models[e].name,
							l = await y(o(), u, t);
						l.ok ? n(ve(Object.assign({}, l.body, {
							fetchedToken: c
						}))) : n(Ie({
							subredditId: e,
							fetchedToken: c
						}))
					}
				}, Te = "SUBREDDIT_BANNEDUSERS_SEARCH_PENDING", xe = "SUBREDDIT_BANNEDUSERS_SEARCH_LOADED", Ce = "SUBREDDIT_BANNEDUSERS_SEARCH_FAILED", we = Object(i.a)(Te), Pe = Object(i.a)(xe), De = Object(i.a)(Ce), Re = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r().subreddits.models[e].name,
						c = {
							username: Object(v.a)(t)
						};
					n(we());
					const a = await y(o(), i, c);
					a.ok ? n(Pe(a.body)) : n(De(a.error))
				}, Ae = "SUBREDDIT_BANNEDUSERS_BAN_SUCCESS", ke = "SUBREDDIT_BANNEDUSERS_UNBAN_SUCCESS", Ne = Object(i.a)(Ae), Le = Object(i.a)(ke), Me = (e, t, n) => async (r, s, i) => {
					let {
						apiContext: d
					} = i;
					const u = s(),
						b = u.subreddits.models[e].url,
						O = u.subreddits.models[e].name;
					t.username = Object(v.a)(t.username), r(Object(a.h)(n));
					const h = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: p.bb.POST,
						data: {
							api_type: "json",
							ban_reason: n.reason,
							ban_message: n.banMessage,
							duration: n.duration,
							name: n.username,
							note: n.modNote,
							ban_context: n.contextId,
							type: "banned"
						}
					}))(d(), b, t);
					if (h.ok) {
						r(Object(a.e)(n));
						const e = {
							username: t.username
						};
						r(Object(l.e)({
							kind: x.b.SuccessMod,
							text: Object(I.c)("Successfully banned a user")
						}));
						const s = await y(d(), O, e);
						s.ok && r(Ne(s.body))
					} else {
						r(Object(a.f)(n, h.error));
						const e = o()(h, "body.json.errors[0][1]", Object(c.a)(u.user.language, "error.type.generic"));
						r(Object(l.e)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Ue = (e, t) => async (n, s, i) => {
					let {
						apiContext: a
					} = i;
					const d = s(),
						u = d.subreddits.models[e].url,
						b = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: p.bb.POST,
							data: {
								api_type: "json",
								id: n,
								type: "banned"
							}
						}))(a(), u, t);
					if (b.ok) n(Le({
						subredditId: e,
						userId: t
					})), n(Object(l.e)({
						kind: x.b.SuccessMod,
						text: r.fbt._("Successfully unbanned a user", null, {
							hk: "OgqK6"
						})
					}));
					else {
						const e = o()(b, "body.json.errors[0][1]", Object(c.a)(d.user.language, "error.type.generic"));
						n(Object(l.e)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Fe = "SUBREDDIT__MODERATORS_PENDING", Be = "SUBREDDIT__MODERATORS_LOADED", Ge = "SUBREDDIT__MODERATORS_FAILED", Ve = Object(i.a)(Fe), qe = Object(i.a)(Be), He = Object(i.a)(Ge), Ke = "SUBREDDIT__EDITABLEMODERATORS_PENDING", We = "SUBREDDIT__EDITABLEMODERATORS_LOADED", Ye = "SUBREDDIT__EDITABLEMODERATORS_FAILED", ze = Object(i.a)(Ke), Je = Object(i.a)(We), Qe = Object(i.a)(Ye), Xe = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(P.S)(i, {
							subredditId: e
						}).name,
						a = t && t.after ? t.after : "",
						d = t && t.before ? t.before : "",
						u = Object(T.d)(e, a, d),
						l = i.moderators.userOrder.data[u],
						b = i.moderators.userOrder.api.error[u];
					if (i.moderators.userOrder.api.pending[u] || l && !b) return;
					n(Ve({
						subredditId: e,
						key: u
					}));
					const p = await j(o(), c, t);
					if (p.ok) {
						const t = {
							key: u,
							response: p.body,
							subredditId: e
						};
						n(qe(t))
					} else {
						const t = {
							error: p.error,
							subredditId: e,
							key: u
						};
						n(He(t))
					}
				}, Ze = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(P.S)(i, {
							subredditId: e
						}).name,
						a = t && t.afterEditable ? t.afterEditable : "",
						d = t && t.beforeEditable ? t.beforeEditable : "",
						u = Object(T.d)(e, a, d),
						l = i.moderators.editableUserOrder.data[u],
						b = i.moderators.editableUserOrder.api.error[u];
					if (i.moderators.editableUserOrder.api.pending[u] || l && !b) return;
					n(ze({
						subredditId: e,
						key: u
					}));
					const O = Object.assign({}, t, {
							after: a,
							before: d
						}),
						h = await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators_editable"),
							method: p.bb.GET,
							data: Object.assign({}, n, {
								count: 10
							})
						}))(o(), c, O);
					if (h.ok) {
						const t = {
							key: u,
							response: h.body,
							subredditId: e
						};
						n(Je(t))
					} else {
						const t = {
							key: u,
							error: h.error,
							subredditId: e
						};
						n(Qe(t))
					}
				}, $e = "SUBREDDIT__INVITEDMODERATORS_PENDING", et = "SUBREDDIT__INVITEDMODERATORS_LOADED", tt = "SUBREDDIT__INVITEDMODERATORS_FAILED", nt = Object(i.a)($e), rt = Object(i.a)(et), st = Object(i.a)(tt), ot = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = Object(P.S)(o, {
							subredditId: e
						}).name;
					if (o.moderators.invitedModerators.api.pending) return;
					t(nt());
					const c = await _(s(), i);
					if (c.ok) {
						const e = c.body;
						t(rt(e))
					} else t(st(c.error))
				}, it = "SUBREDDIT__ADDMODERATOR__SUCCESS", ct = Object(i.a)("SUBREDDIT__ADDMODERATOR_PENDING"), at = Object(i.a)(it), dt = Object(i.a)("SUBREDDIT__ADDMODERATOR__FAILED"), ut = (e, t, n) => async (r, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = s(),
						a = Object(P.S)(c, {
							subredditId: e
						}),
						d = a.name,
						u = a.url;
					t = Object(v.a)(t), r(ct());
					const b = Object(S.d)(n),
						O = await ((e, t, n, r) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
							method: p.bb.POST,
							data: {
								name: n,
								type: "moderator_invite",
								permissions: r,
								api_type: "json"
							}
						}))(i(), u, t, b);
					if (O.ok) {
						const n = await _(i(), d, {
							username: t
						});
						if (O.ok) {
							const t = n.body,
								s = t.moderatorIds[0];
							c.moderators.invitedModerators.models[e][s] ? r(Object(l.e)({
								kind: x.b.SuccessCommunity,
								text: Object(I.c)("That user is already invited")
							})) : (r(Object(l.e)({
								kind: x.b.SuccessMod,
								text: Object(I.c)("Successfully added a moderator")
							})), r(at(t)))
						}
					} else {
						const e = O.body.json && O.body.json.errors;
						e && e[0] && e[0][1] && r(Object(l.e)({
							kind: x.b.Error,
							text: e[0][1],
							duration: 3e3
						})), r(dt())
					}
				}, lt = "SUBREDDIT__REMOVEMODERATOR__SUCCESS", bt = Object(i.a)("SUBREDDIT__REMOVEMODERATOR_PENDING"), pt = Object(i.a)(lt), mt = Object(i.a)("SUBREDDIT__REMOVEMODERATOR__FAILED"), ft = "SUBREDDIT__RESIGNMODERATOR__SUCCESS", gt = Object(i.a)(ft), Ot = (e, t, n, r) => async (s, o, i) => {
					let {
						apiContext: c
					} = i;
					const a = o(),
						d = a.subreddits.models[e].name,
						u = Object(T.d)(e, n, r);
					if (s(bt()), (await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/unfriend"),
							method: p.bb.POST,
							data: {
								id: n,
								type: "moderator",
								r: t,
								api_type: "json"
							}
						}))(c(), d, t)).ok) {
						s(pt({
							subredditId: e,
							userId: t,
							key: u
						}));
						const n = Object(R.i)(a);
						n && n.id === t && s(gt({
							subredditId: e,
							userId: t
						}))
					} else s(mt())
				}, ht = "SUBREDDIT__EDITMODERATOR__SUCCESS", yt = Object(i.a)("SUBREDDIT__EDITMODERATOR_PENDING"), jt = Object(i.a)(ht), _t = Object(i.a)("SUBREDDIT__EDITMODERATOR__FAILED"), Et = (e, t, n, r) => async (s, o, i) => {
					let {
						apiContext: c
					} = i;
					const a = o().subreddits.models[e].url;
					s(yt());
					const d = Object(S.d)(n);
					if ((await ((e, t, n, r) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/setpermissions"),
							method: p.bb.POST,
							data: {
								name: n,
								type: "moderator",
								permissions: r,
								api_type: "json"
							}
						}))(c(), a, t, d)).ok) {
						s(jt({
							permissions: n,
							subredditId: e,
							userId: r
						}))
					} else s(_t())
				}, vt = "SUBREDDIT_MODERATORS_SEARCH_PENDING", It = "SUBREDDIT_MODERATORS_SEARCH_LOADED", St = "SUBREDDIT_MODERATORS_SEARCH_FAILED", Tt = Object(i.a)(vt), xt = Object(i.a)(It), Ct = Object(i.a)(St), wt = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r().subreddits.models[e].name,
						c = {
							username: Object(v.a)(t)
						};
					n(Tt());
					const a = await j(o(), i, c);
					a.ok ? n(xt(a.body)) : n(Ct(a.error))
				}, Pt = "SUBREDDIT_MODERATORS_ACCEPT_INVITE_SUCCESS", Dt = Object(i.a)(Pt), Rt = "SUBREDDIT_NEWMODERATORPERMISSIONS_LOADED", At = Object(i.a)(Rt), kt = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n(),
						i = o.user.account;
					if (!i) return;
					const c = o.subreddits.models[e],
						a = c.url,
						d = c.name;
					if ((await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/accept_moderator_invite"),
							method: p.bb.POST,
							data: {
								api_type: "json"
							}
						}))(s(), a)).ok) {
						t(Dt({
							subredditId: e
						})), t(Ze(e)), t(ot(e)), t(Xe(e));
						const n = {
								username: Object(C.f)(i)
							},
							r = await j(s(), d, n);
						if (r.ok) {
							const n = r.body.moderators[i.id];
							n && t(At({
								[e]: n.modPermissions
							}))
						}
					}
				}, Nt = "SUBREDDIT_MODERATORS_DECLINE_INVITE_SUCCESS", Lt = Object(i.a)(Nt), Mt = e => async (t, n, r) => {
					let {
						apiContext: s
					} = r;
					const o = n().subreddits.models[e].name;
					(await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/decline_mod_invite"),
						method: p.bb.POST,
						data: {
							api_type: "json"
						}
					}))(s(), o)).ok && t(Lt({
						subredditId: e
					}))
				}, Ut = "SUBREDDIT__REMOVEINVITEDMODERATOR__SUCCESS", Ft = Object(i.a)("SUBREDDIT__REMOVEINVITEDMODERATOR_PENDING"), Bt = Object(i.a)(Ut), Gt = Object(i.a)("SUBREDDIT__REMOVEINVITEDMODERATOR__FAILED"), Vt = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(P.S)(i, {
							subredditId: e
						}).name;
					n(Ft()), (await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/unfriend"),
						method: p.bb.POST,
						data: {
							id: n,
							type: "moderator_invite",
							r: t,
							api_type: "json"
						}
					}))(o(), c, t)).ok ? n(Bt({
						subredditId: e,
						userId: t
					})) : n(Gt())
				}, qt = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r();
					await Promise.all([(async () => {
						if (!Object(w.b)(b.a.BAN_USER)(i) && !Object(P.P)(i, {
								subredditId: e
							})) {
							const t = Object(P.S)(i, {
								subredditId: e
							});
							await n(Object(u.o)(t.name))
						}
					})(), (async () => {
						const r = Object(R.ib)(i, {
							userName: t
						});
						if (!r) return;
						const s = Object(D.m)(i, {
							subredditId: e
						});
						s && s[r.id] || await n(Se(e, {
							username: t
						}))
					})()]), n(Object(d.i)(b.a.BAN_USER))
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			const r = "SUBREDDIT__RULES_LOADED",
				s = "SUBREDDIT__RULES_PENDING",
				o = "SUBREDDIT__RULES_FAILED",
				i = "SUBREDDIT__RULE_ADDED",
				c = "SUBREDDIT__RULE_EDITED",
				a = "SUBREDDIT__RULE_REMOVED",
				d = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			})), n.d(t, "f", (function() {
				return S
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "b", (function() {
				return w
			})), n.d(t, "h", (function() {
				return A
			})), n.d(t, "g", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/lodash/invert.js"),
				o = n.n(s),
				i = n("./node_modules/lodash/pick.js"),
				c = n.n(i),
				a = n("./node_modules/lodash/xor.js"),
				d = n.n(a),
				u = n("./src/app/strings/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				b = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/reddit/endpoints/subreddit/settings.ts"),
				m = n("./src/reddit/i18n/utils.ts"),
				f = n("./src/telemetry/index.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				O = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/models/User/index.ts"),
				j = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/selectors/user.ts"),
				E = n("./src/reddit/selectors/widgets.ts");
			const v = "SUBREDDIT_SETTINGS_LOADED",
				I = Object(b.a)(v),
				S = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					if (!t || !Object(j.U)(r(), t)) {
						const t = await Object(p.c)(o(), e);
						t && t.ok && n(I(t.body))
					}
				}, T = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = Object(_.i)(t());
					s && await e(S(l.Qb + Object(y.f)(s)))
				}, x = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", C = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", w = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", P = Object(b.a)(x), D = Object(b.a)(C), R = Object(b.a)(w), A = function e(t, n) {
					let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (s, i, a) => {
						let {
							apiContext: l
						} = a;
						s(P());
						const b = i(),
							y = c()(Object(j.U)(b, t), ...Object.keys(n)),
							v = await Object(p.g)(l(), t, n),
							I = Object(_.T)(b);
						if (v.ok) {
							const i = Object(p.d)(v.body, o()(p.a));
							s(D({
								settings: Object.assign({}, i, {
									subredditId: t
								}),
								idCardWidgetId: Object(E.c)(b, {
									subredditId: t
								})
							}));
							const c = {};
							r && 0 === d()(Object.keys(n), Object.keys(y)).length && (c.buttonText = Object(m.c)("Undo"), c.buttonAction = e(t, y, r)), s(Object(g.e)(Object.assign({
								kind: h.b.SuccessCommunity,
								text: Object(u.a)(I, "subredditCreation.updateCommunitySuccess")
							}, c)))
						} else s(R()), s(Object(g.e)({
							kind: h.b.Error,
							text: Object(u.a)(I, "error.tryAgainLater"),
							buttonText: Object(m.c)("Retry"),
							buttonAction: e(t, n)
						})), r && Object(f.a)(Object(O.c)(b, "BE returned an error:"))
					}
				}, k = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = await Object(p.e)(i(), e, t),
						a = Object(_.T)(s());
					c.ok ? n(Object(g.e)({
						kind: h.b.SuccessCommunity,
						text: r.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : n(Object(g.e)({
						kind: h.b.Error,
						text: Object(u.a)(a, "error.tryAgainLater")
					}))
				}
		},
		"./src/reddit/actions/subredditTopContent.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/preferences.ts"),
				o = n("./src/graphql/operations/SubredditTopContent.json"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			}));
			const a = "SUBREDDIT_TOP_CONTENT__PENDING",
				d = "SUBREDDIT_TOP_CONTENT__LOADED",
				u = "SUBREDDIT_TOP_CONTENT__FAILED",
				l = Object(r.a)(a),
				b = Object(r.a)(d),
				p = Object(r.a)(u),
				m = e => async (t, n, r) => {
					const a = e.toLowerCase(),
						d = n(),
						{
							api: u,
							topContent: m
						} = d.subreddits;
					if (u.topContent.pending[a] || m[a]) return;
					t(l({
						subredditName: a
					})), t(Object(s.x)());
					const f = await ((e, t) => Object(i.a)(e, Object.assign({}, o, {
						variables: t
					})))(r.gqlContext(), {
						subredditName: a
					});
					if (f.ok) {
						const e = f.body.data.subreddit;
						if (e) {
							const n = Object(c.c)(e);
							n && t(b(Object.assign({
								subredditName: a
							}, n)))
						}
					} else t(p({
						subredditName: a,
						error: f.error
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			}));
			const r = "SUBSCRIPTION__FETCH_DATA_PENDING",
				s = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				o = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				i = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				c = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				a = "SUBSCRIPTION__ORDER_LOADED",
				d = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/linkMatchers/customLinks.ts"),
				c = n("./src/reddit/actions/login.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/monthsToMinutes/homeFeed.ts"),
				u = n("./src/reddit/actions/monthsToMinutes/reset.ts"),
				l = n("./src/reddit/actions/subscription/constants.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				p = n("./src/reddit/constants/posts.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts");
			var O = n("./src/config.ts"),
				h = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var y = n("./src/reddit/helpers/monthsToMinutes/index.ts"),
				j = n("./src/reddit/i18n/utils.ts"),
				_ = n("./src/reddit/models/MonthsToMinutes/index.ts"),
				E = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/reddit/selectors/monthsToMinutes.ts"),
				I = n("./src/reddit/selectors/profile.ts"),
				S = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/reddit/selectors/subscriptions.ts"),
				x = n("./node_modules/reselect/es/index.js");
			const C = Object(x.a)(e => e.toaster, (e, t) => t, (e, t) => e.find(e => e.customToastType === t));
			var w = n("./src/reddit/selectors/user.ts");
			n.d(t, "e", (function() {
				return N
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "c", (function() {
				return U
			})), n.d(t, "a", (function() {
				return B
			})), n.d(t, "b", (function() {
				return V
			}));
			const P = Object(j.c)("Sorry, failed to update favorites."),
				D = Object(s.a)(l.c),
				R = Object(s.a)(l.b),
				A = Object(s.a)(l.a),
				k = Object(s.a)(l.h),
				N = (Object(s.a)(l.i), Object(s.a)(l.g), () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t();
					if (!o.user.account || o.subscriptions.api.fetched) return;
					e(R());
					const i = await (e => Object(m.b)(e, {
						endpoint: "".concat(O.a.gatewayUrl, "/desktopapi/v1/subscriptions"),
						method: r.bb.GET
					}))(s());
					i.ok ? e(D(i.body)) : e(A({
						error: i.error
					}))
				}),
				L = (e, t, n) => async (s, l, O) => {
					let {
						apiContext: x
					} = O;
					const P = Object(w.T)(l()),
						D = e.map(e => e.type === p.a.SUBREDDIT ? {
							id: Object(S.G)(l(), e.name),
							name: e.name,
							type: e.type
						} : {
							id: Object(I.m)(l(), e.name),
							name: "".concat(r.Qb).concat(e.name),
							type: e.type
						}),
						R = Object(v.w)(l()) && Object(v.n)(l());
					if (Object(w.K)(l()))
						if (s(k({
								identifiers: D,
								nameIdentifiers: e,
								profileModels: l().profiles.models,
								shouldUpdateLoggedOutHomeFeed: R,
								subredditModels: l().subreddits.models,
								subscriptionsCount: Object(T.c)(l()),
								userIsSubscriber: t,
								widgetId: n
							})), (await ((e, t) => {
								let {
									subredditIds: n,
									subredditNames: s,
									subscribe: o
								} = t;
								return Object(m.b)(Object(f.a)(e, [g.a]), {
									method: r.bb.POST,
									endpoint: Object(h.a)("".concat(e.apiUrl, "/api/subscribe")),
									data: {
										action: o ? "sub" : "unsub",
										sr: n && n.join(",") || void 0,
										sr_name: s && s.join(",") || void 0,
										api_type: "json"
									}
								})
							})(x(), {
								subredditNames: D.map(e => {
									let {
										name: t
									} = e;
									return t
								}),
								subscribe: t
							})).ok) {
							if (t) {
								const n = 1 === e.length ? "".concat("subreddit" === e[0].type ? i.d.subreddit : i.d.profile).concat(e[0].name) : "".concat(e.length, " ").concat(Object(j.a)("communities", ["community", "communities"], e.length));
								s(Object(b.e)({
									text: 1 === e.length && "profile" === e[0].type ? Object(j.c)("Sucessfully ".concat(t ? "followed" : "unfollowed", " ").concat(Object(j.b)("communityname", n))) : Object(j.c)("Sucessfully ".concat(t ? "joined" : "left", " ").concat(Object(j.b)("communityname", n)))
								}))
							}
						} else s(k({
							identifiers: D,
							nameIdentifiers: e,
							profileModels: l().profiles.models,
							shouldUpdateLoggedOutHomeFeed: R,
							subredditModels: l().subreddits.models,
							subscriptionsCount: Object(T.c)(l()),
							userIsSubscriber: !t,
							widgetId: n
						})), s(Object(b.e)(Object(b.d)(Object(o.a)(P, "profile.somethingWentWrongTryAgain"), E.b.Error)));
					else if (Object(v.w)(l()) && !e.some(e => e.type === p.a.PROFILE)) {
						let r = Object(T.c)(l());
						if (t && r >= _.b) return void(C(l(), E.a.subscribeCap) || s(Object(b.e)({
							text: "",
							duration: -1,
							kind: E.b.Custom,
							customToastType: E.a.subscribeCap
						})));
						s(k({
							identifiers: D,
							nameIdentifiers: e,
							profileModels: l().profiles.models,
							shouldUpdateLoggedOutHomeFeed: R,
							subredditModels: l().subreddits.models,
							subscriptionsCount: Object(T.c)(l()),
							userIsSubscriber: t,
							widgetId: n
						}));
						const o = l();
						0 === (r = Object(T.c)(o)) ? s(Object(u.b)()) : Object(v.p)(o) ? await s(Object(d.g)()) : Object(v.n)(o) && Object(y.d)(o)
					} else s(Object(a.k)({
						actionSource: a.a.Subscribe
					})), s(Object(c.f)())
				}, M = Object(s.a)(l.f), U = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const i = n(),
						c = Object(S.M)(i, {
							identifier: e
						});
					if (!c) throw new Error("actions.subscription -- No subreddit or profile found with id ".concat(e.id));
					const a = e.type === p.a.SUBREDDIT ? c.name : "u_".concat(c.name),
						d = i.subscriptions.favoriteSubredditOrder || [],
						u = i.subscriptions.favoriteProfileOrder || [],
						l = d.indexOf(e.id),
						O = u.indexOf(e.id),
						h = -1 === l && -1 === O,
						y = i.subreddits.models,
						j = i.profiles.models;
					t(M({
						makeFavorite: h,
						identifier: e,
						subredditModels: y,
						profileModels: j
					}));
					const _ = {
							type: e.type,
							name: c.name
						},
						v = () => Object(S.cb)(n(), {
							identifier: _
						});
					(v() || (await t(L([_], !0)), v())) && ((await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/favorite"),
						data: {
							make_favorite: n ? "true" : "false",
							sr_name: t,
							api_type: "json"
						}
					}))(o(), a, h)).ok || (t(M({
						makeFavorite: !h,
						identifier: e,
						subredditModels: y,
						profileModels: j
					})), t(Object(b.e)({
						text: P,
						kind: E.b.Error
					}))))
				}, F = Object(s.a)(l.d), B = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const i = n().multireddits.models,
						c = () => {
							t(Object(b.e)({
								text: P,
								kind: E.b.Error
							}))
						},
						a = i[e];
					if (!a) return void c();
					const d = !a.isFavorited;
					t(F({
						makeFavorite: d,
						multiredditPath: e,
						multiredditsModelsState: i
					})), (await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/multi/favorite"),
						data: {
							make_favorite: n ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(o(), e, d)).ok || (t(F({
						makeFavorite: !d,
						multiredditPath: e,
						multiredditsModelsState: i
					})), c())
				}, G = Object(s.a)(l.e), V = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const i = n(),
						c = i.multireddits.models;
					if (!Object(w.K)(i)) return;
					const a = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(b.e)({
								text: Object(j.c)("Sorry, failed to ".concat(Object(j.b)("followAction", e ? Object(j.c)("follow") : Object(j.c)("unfollow")))),
								kind: E.b.Error
							}))
						},
						d = c[e];
					if (!d) return void a();
					const u = !d.isFollowed;
					t(G({
						follow: u,
						multiredditPath: e,
						multiredditsModelsState: c
					})), (await ((e, t, n) => Object(m.b)(Object(f.a)(e, [g.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/multi/subscribe"),
						data: {
							action: n ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(o(), e, u)).ok || (t(G({
						follow: !u,
						multiredditPath: e,
						multiredditsModelsState: c
					})), a(u))
				}
		},
		"./src/reddit/actions/tabBadging.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/actions/chat/unreadCount.ts"),
				o = n("./src/reddit/actions/inbox.ts"),
				i = n("./src/reddit/selectors/chat.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const a = "TAB__UPDATE_HAS_UNREAD_MESSAGES_BADGE",
				d = Object(r.a)(a),
				u = e => async (t, n) => {
					const r = n(),
						a = Object(i.a)(r),
						d = Object(i.d)(r),
						u = Object(c.F)(r),
						{
							basicChannelCount: l,
							inboxCount: b
						} = e;
					a !== l && t(Object(s.b)(Object.assign({}, d, {
						basicChannelCount: l
					}))), b && u !== b && t(Object(o.b)({
						inboxCount: b
					}))
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "o", (function() {
				return r
			})), n.d(t, "e", (function() {
				return s
			})), n.d(t, "m", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "n", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "p", (function() {
				return g
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "u", (function() {
				return h
			})), n.d(t, "y", (function() {
				return y
			})), n.d(t, "t", (function() {
				return j
			})), n.d(t, "x", (function() {
				return _
			})), n.d(t, "s", (function() {
				return E
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "b", (function() {
				return x
			}));
			const r = "TAGS__REQUESTED",
				s = "TAGS__AVAILABLE_LOADED",
				o = "TAGS__LOADED",
				i = "TAGS__FAILURE",
				c = "TAGS__RELEVANCE_LOADED",
				a = "TAGS__CREATE_REQUESTED",
				d = "TAGS__CREATE_SUCCESS",
				u = "TAGS__CREATE_FAILURE",
				l = "TAGS__DELETE_REQUESTED",
				b = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				m = "TAGS__UPDATE_STATE_REQUESTED",
				f = "TAGS__UPDATE_STATE_SUCCESS",
				g = "TAGS__UPDATE_STATE_FAILURE",
				O = "TAGS__OPTIONS_CANCELLED",
				h = "TAGS__OPTION_SELECTED",
				y = "TAGS__SUGGESTED_OPTION_SELECTED",
				j = "TAGS__OPTION_DESELECTED",
				_ = "TAGS__SUGGESTED_OPTION_DESELECTED",
				E = "TAGS__INPUT_CHANGED",
				v = "TAGS__SUGGESTED_INPUT_CHANGED",
				I = "GLOBAL__TAGS__LOADED",
				S = "CREATION__TAGS_INPUT_CHANGED",
				T = "CREATION__TAGS_OPTION_SELECTED",
				x = "CREATION__TAGS_OPTION_DESELECTED"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tags/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts");
			const c = e => {
				const {
					subreddit: t
				} = e, n = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, t) => {
					let {
						node: n
					} = t;
					return e[n.subreddit && n.subreddit.id || "global"][n.id] = n, e
				}, n);
				const r = {
					[t.id]: {}
				};
				t.tags && t.tags.edges.reduce((e, n) => {
					let {
						node: r
					} = n;
					return e[t.id][r.tag.id] = r, e
				}, r);
				const s = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, n) => {
					let {
						node: r
					} = n;
					return e[t.id][r.tag.id] = r, e
				}, s), {
					globalSubredditTags: n.global,
					subredditScopedTags: {
						[t.id]: n[t.id]
					},
					subredditId: t.id,
					itemTags: r,
					suggestedItemTags: s
				}
			};
			var a = n("./src/graphql/operations/CreateSubredditTags.json"),
				d = n("./src/lib/makeGqlRequest/index.ts");
			var u = n("./src/graphql/operations/DeleteTags.json");
			var l = n("./src/graphql/operations/FetchGlobalTags.json"),
				b = n("./src/graphql/operations/FetchSubredditTags.json");
			const p = 1050,
				m = (e, t) => {
					let {
						subredditId: n,
						pageSize: r = p,
						after: s,
						includeAvailableTags: o
					} = t;
					return Object(d.a)(e, Object.assign({}, b, {
						variables: {
							subredditId: n,
							pageSize: r,
							after: s,
							includeAvailableTags: o
						}
					}))
				};
			var f, g = n("./src/graphql/operations/UpdateSubredditTagStates.json");
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(f || (f = {}));
			const O = (e, t) => Object(d.a)(e, Object.assign({}, g, {
				variables: t
			}));
			var h = n("./src/graphql/operations/UpdateSubredditTagStatesRelevance.json");
			const y = (e, t) => Object(d.a)(e, Object.assign({}, h, {
				variables: t
			}));
			var j = n("./src/reddit/featureFlags/communityTopics.ts"),
				_ = n("./src/reddit/helpers/tags/index.ts"),
				E = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				v = n("./src/reddit/i18n/utils.ts"),
				I = n("./src/reddit/models/Tags/index.ts"),
				S = n("./src/reddit/models/Toast/index.ts"),
				T = n("./src/reddit/reducers/tags/selected/index.ts"),
				x = n("./src/reddit/selectors/tags.ts"),
				C = n("./src/reddit/selectors/user.ts");
			n.d(t, "l", (function() {
				return H
			})), n.d(t, "o", (function() {
				return K
			})), n.d(t, "k", (function() {
				return W
			})), n.d(t, "n", (function() {
				return Y
			})), n.d(t, "j", (function() {
				return z
			})), n.d(t, "m", (function() {
				return J
			})), n.d(t, "c", (function() {
				return Q
			})), n.d(t, "b", (function() {
				return X
			})), n.d(t, "a", (function() {
				return Z
			})), n.d(t, "i", (function() {
				return ee
			})), n.d(t, "e", (function() {
				return re
			})), n.d(t, "h", (function() {
				return ce
			})), n.d(t, "g", (function() {
				return ae
			})), n.d(t, "d", (function() {
				return de
			})), n.d(t, "p", (function() {
				return ue
			})), n.d(t, "f", (function() {
				return le
			}));
			const w = Object(s.a)(o.d),
				P = Object(s.a)(o.o),
				D = Object(s.a)(o.e),
				R = Object(s.a)(o.m),
				A = Object(s.a)(o.n),
				k = Object(s.a)(o.l),
				N = Object(s.a)(o.g),
				L = Object(s.a)(o.h),
				M = Object(s.a)(o.f),
				U = Object(s.a)(o.j),
				F = Object(s.a)(o.k),
				B = Object(s.a)(o.i),
				G = Object(s.a)(o.q),
				V = Object(s.a)(o.r),
				q = Object(s.a)(o.p),
				H = Object(s.a)(o.u),
				K = Object(s.a)(o.y),
				W = Object(s.a)(o.t),
				Y = Object(s.a)(o.x),
				z = Object(s.a)(o.s),
				J = Object(s.a)(o.w),
				Q = Object(s.a)(o.c),
				X = Object(s.a)(o.b),
				Z = Object(s.a)(o.a),
				$ = Object(s.a)(o.v),
				ee = function e(t, n) {
					let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (o, a, d) => {
						let {
							gqlContext: u
						} = d;
						const l = a();
						if (!Object(j.b)()) return;
						o(P());
						const b = await m(u(), {
							subredditId: t
						});
						if (b.ok) {
							const e = b.body;
							o(R(c(e.data))), s && E.h(a(), t, {
								context: n
							})
						} else {
							o(k());
							const c = s ? "topics_save" : "topics_load";
							E.g(l, t, c, {
								context: n
							}), o(Object(i.e)(Object(i.d)(Object(r.a)(Object(C.T)(l), "communityTopics.loadFailed"), S.b.Error, Object(r.a)(Object(C.T)(l), "communityTopics.retry"), e(t, n, s))))
						}
					}
				},
				te = e => async (t, n, s) => {
					let {
						gqlContext: o
					} = s;
					const a = n();
					if (!Object(j.b)()) return;
					t(P());
					const d = await m(o(), {
						subredditId: e
					});
					if (d.ok) {
						const e = d.body;
						t(A(c(e.data)))
					} else t(k()), t(Object(i.e)(Object(i.d)(Object(r.a)(Object(C.T)(a), "communityTopics.loadFailed"), S.b.Error, Object(r.a)(Object(C.T)(a), "communityTopics.retry"), A(e))))
				}, ne = (e, t) => async (n, s, o) => {
					let {
						gqlContext: a
					} = o;
					const d = s();
					if (!Object(j.b)()) return;
					n(P());
					const u = await m(a(), {
						subredditId: e
					});
					if (u.ok) {
						const e = u.body;
						n(D(c(e.data)))
					} else n(k()), E.g(d, e, "available_topics_load", {
						context: t
					}), n(Object(i.e)(Object(i.d)(Object(r.a)(Object(C.T)(d), "communityTopics.loadFailed"), S.b.Error, Object(r.a)(Object(C.T)(d), "communityTopics.retry"), ne(e, t))))
				}, re = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const s = t();
					if (Object(x.o)(s)) return;
					e(P());
					const o = await ((e, t) => {
						let {
							pageSize: n = p,
							after: r
						} = t;
						return Object(d.a)(e, Object.assign({}, l, {
							variables: {
								pageSize: n,
								after: r
							}
						}))
					})(r(), {});
					if (o.ok) {
						const t = o.body;
						e(w((e => {
							return {
								globalSubredditTags: e.globalTags.edges.reduce((e, t) => (e[t.node.id] = t.node, e), {})
							}
						})(t.data)))
					}
				}, se = (e, t) => async (n, r, s) => {
					let {
						gqlContext: o
					} = s;
					if (!t.length) return;
					n(N());
					const i = t.map(t => Object.assign({
							subredditId: e
						}, t)),
						c = await ((e, t) => Object(d.a)(e, Object.assign({}, a, {
							variables: t
						})))(o(), {
							input: i
						}),
						u = c.body && c.body.data || null;
					c.ok && u && u.createSubredditTags && u.createSubredditTags.ok ? n(L()) : n(M())
				}, oe = (e, t) => async (n, r, s) => {
					let {
						gqlContext: o
					} = s;
					if (!t.length) return;
					n(U());
					const i = await ((e, t) => Object(d.a)(e, Object.assign({}, u, {
							variables: t
						})))(o(), {
							input: t
						}),
						c = i.body && i.body.data || null;
					i.ok && c && c.deleteTags && c.deleteTags.ok ? n(F({
						subredditId: e,
						tags: t
					})) : n(B())
				}, ie = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (r, s, o) => {
						let {
							gqlContext: i
						} = o;
						if (!t.length && !n.length) return;
						r(G());
						const c = await O(i(), {
								input: {
									subredditId: e,
									tagStates: t,
									suggestedTagStates: n
								}
							}),
							a = c.body && c.body.data || null;
						c.ok && a && a.updateSubredditTagStates && a.updateSubredditTagStates.ok ? r(V()) : r(q())
					}
				}, ce = function e(t, n) {
					let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (o, c, a) => {
						const d = c(),
							u = Object(x.q)(d, {
								subredditId: t
							}),
							l = Object(x.d)(d, {
								subredditId: t
							}),
							b = Object(x.y)(d, {
								subredditId: t
							}),
							p = Object(x.z)(d, {
								subredditId: t
							}),
							m = u.filter(e => !!e.id && !!e.action).map(e => ({
								tagId: e.id,
								state: e.action === T.a.ADD ? f.TAGGED : f.NONE
							}));
						if (b.length > 0) {
							const e = new Set([...Object.keys(l)]);
							await se(t, b)(o, c, a), await ne(t, n)(o, c, a);
							const r = Object(x.d)(c(), {
									subredditId: t
								}),
								s = new Set([...Object.keys(r).filter(t => !e.has(t))]);
							b.forEach(e => {
								for (const t of s) {
									const n = r[t];
									if (n && n.text.toLowerCase() === e.text.toLowerCase() && n.type === e.type) return s.delete(t), void m.push({
										tagId: n.id,
										state: f.TAGGED
									})
								}
							})
						}
						await Promise.all([ie(t, m)(o, c, a), oe(t, p)(o, c, a)]), Object(x.w)(c()) ? o(Object(i.e)(Object(i.d)(Object(r.a)(Object(C.T)(d), "communityTopics.savePartialFailed"), S.b.Error, Object(r.a)(Object(C.T)(d), "communityTopics.retry"), e(t, n, s)))) : s && o(Object(i.e)(Object(i.d)(Object(v.c)("Community topics saved!"), S.b.SuccessCommunity))), o(ee(t, n, !0))
					}
				}, ae = (e, t, n) => async (r, s, o) => {
					const c = {
						state: f.TAGGED
					};
					if (Object(_.b)(t)) {
						const i = Object(x.d)(s(), {
								subredditId: e
							}),
							a = new Set([...Object.keys(i)]);
						await se(e, [{
							text: t.displayText,
							type: I.c.CLASSIFICATION
						}])(r, s, o), await ne(e, n)(r, s, o);
						const d = Object(x.d)(s(), {
								subredditId: e
							}),
							u = new Set([...Object.keys(d).filter(e => !a.has(e))]);
						for (const e of u) {
							const n = d[e];
							n && n.text.toLowerCase() === t.displayText.toLowerCase() && n.type === I.c.CLASSIFICATION && (c.tagId = n.id)
						}
					} else {
						if (!t.id) return void r(Object(i.e)(Object(i.d)(Object(v.c)("Whoops, we couldn't save that topic. Please try again later."), S.b.Error)));
						c.tagId = t.id
					}(e => !!e.tagId && !!e.state)(c) ? (await ie(e, [], [c])(r, s, o), r(ee(e, n, !1))) : r(Object(i.e)(Object(i.d)(Object(v.c)("Whoops, we couldn't save that topic. Please try again later."), S.b.Error)))
				}, de = (e, t, n) => async (r, s, o) => {
					if (!t.id) return void r(ee(e, n, !1));
					const i = s(),
						c = [ie(e, [], [{
							state: f.NONE,
							tagId: t.id
						}])(r, s, o)],
						a = Object(x.p)(i, {
							itemId: e
						}),
						d = Object(x.d)(i, {
							subredditId: e
						});
					!a[t.id] && d[t.id] && c.push(oe(e, [{
						tagId: t.id
					}])(r, s, o)), await Promise.all(c), r(ee(e, n, !1))
				}, ue = function e(t, n, r, s) {
					let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (c, a, d) => {
						let {
							gqlContext: u
						} = d;
						if (!(await y(u(), {
								input: {
									tagStatesRelevance: n,
									suggestedTagStatesRelevance: r
								}
							})).ok) return c(Object(i.e)(Object(i.d)(Object(v.c)("Whoops! Unable to update topics relevance status"), S.b.Error, Object(v.c)("Retry"), e(t, n, r, s, o)))), void c(te(t));
						if (o)
							for (const e of r) E.f(a(), e, {
								context: s
							});
						c(Object(i.e)(Object(i.d)(Object(v.c)("Successfully updated topics relevance!"), S.b.SuccessCommunity, Object(v.c)("Undo"), e(t, n.map(e => Object.assign({}, e, {
							isRelevant: !e.isRelevant
						})), r.map(e => Object.assign({}, e, {
							isRelevant: !e.isRelevant
						})), s, o)))), c(te(t))
					}
				}, le = e => async (t, n) => {
					t($({
						itemTagsState: {
							[e]: Object(x.p)(n(), {
								itemId: e
							})
						}
					}))
				}
		},
		"./src/reddit/actions/theme.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "THEME_CHANGED",
				o = (Object(r.a)(s), "BOOTUP_THEME"),
				i = Object(r.a)(o)
		},
		"./src/reddit/actions/toaster.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return m
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/models/Toast/index.ts");
			const o = 5e3,
				i = s.b.SuccessCommunity,
				c = "TOAST__DISPLAYED",
				a = "TOAST__DISMISSED",
				d = Object(r.a)(c),
				u = Object(r.a)(a),
				l = e => async (t, n) => {
					const r = b(e);
					t(d(r)), r.duration > 0 && window.setTimeout(() => t(u(r.id)), r.duration)
				}, b = e => Object.assign({}, e, {
					duration: e.duration || p(e.kind),
					id: e.id || Date.now().toString(),
					kind: e.kind || i
				}), p = e => {
					switch (e) {
						case s.b.Error:
							return -1;
						case s.b.Undo:
							return 1e4;
						case s.b.SuccessCommunity:
						case s.b.SuccessMod:
						default:
							return o
					}
				}, m = (e, t, n, r, s, o) => ({
					text: e,
					kind: t,
					buttonText: n,
					buttonAction: r,
					secondButtonText: s,
					secondButtonAction: o
				})
		},
		"./src/reddit/actions/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "h", (function() {
				return l
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "TOOLTIP__DROPDOWN_TOGGLED",
				o = "TOOLTIP__DROPDOWN_SET",
				i = "TOOLTIP__DROPDOWN_UNSET",
				c = "TOOLTIP__DROPDOWN_SET_IF_NONE",
				a = "TOOLTIP__DROPDOWN_UNSET_IF_ACTIVE",
				d = Object(r.a)(o),
				u = Object(r.a)(s),
				l = Object(r.a)(i);
			Object(r.a)(c), Object(r.a)(a)
		},
		"./src/reddit/actions/tracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			var r = n("./src/lib/makeActionCreator/index.ts");
			const s = "TRACKING__VIEWPORT_DATA_LOADED",
				o = "TRACKING__VIEWPORT_DATA_UNLOADED",
				i = Object(r.a)(s);
			Object(r.a)(o)
		},
		"./src/reddit/actions/trafficStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = "SUBREDDIT__TRAFFIC_STATS_LOADED",
				s = "SUBREDDIT__TRAFFIC_STATS_PENDING",
				o = "SUBREDDIT__TRAFFIC_STATS_FAILED"
		},
		"./src/reddit/actions/trophyCase.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/lodash/pickBy.js")),
				o = n.n(s),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/lib/redditId/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			var l = (e, t) => Object(c.b)(Object(a.a)(e, [u.a]), {
				method: i.bb.GET,
				endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/trophies.json")
			}).then(e => {
				const t = e.body && e.body.data && e.body.data.trophies;
				if (e.ok && t) {
					const n = o()(t.map(b), "id"),
						r = Object.keys(n);
					return Object.assign({}, e, {
						body: {
							trophies: n,
							trophyIds: r
						}
					})
				}
				return e
			});
			const b = e => ({
				awardId: e.data.award_id,
				description: e.data.description || "",
				icon: e.data.icon_40 || "",
				id: Object(d.b)(e.data.id, e.kind),
				name: e.data.name,
				url: e.data.url || ""
			});
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return g
			}));
			const p = "TROPHYCASE__FETCH_SUCCESS",
				m = Object(r.a)(p),
				f = Object(r.a)("TROPHYCASE__FETCH_FAILED"),
				g = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = await l(o(), e);
					i.ok ? n(m(Object.assign({
						profileId: t,
						profileName: e
					}, i.body))) : n(f({
						profileId: t,
						error: i.error
					}))
				}
		},
		"./src/reddit/actions/upload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "k", (function() {
				return w
			})), n.d(t, "i", (function() {
				return P
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/get.js"),
				s = n.n(r),
				o = n("./node_modules/uuid/v4.js"),
				i = n.n(o),
				c = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/uploadToS3/index.ts"),
				d = n("./src/reddit/models/Upload/index.ts");
			const u = "UPLOAD_PENDING",
				l = "UPLOAD_UPLOADING",
				b = "UPLOAD_METADATA_CHANGED",
				p = "UPLOAD_PROGRESS",
				m = "UPLOAD_SUCCESS",
				f = "UPLOAD_FAILED",
				g = "UPLOAD_CANCELED",
				O = "UPLOAD_REMOVED",
				h = Object(c.a)(u),
				y = Object(c.a)(l),
				j = Object(c.a)(b),
				_ = Object(c.a)(p),
				E = Object(c.a)(m),
				v = Object(c.a)(f),
				I = Object(c.a)(g),
				S = Object(c.a)(O),
				T = new Map,
				x = (e, t) => {
					const n = T.get(e) || [];
					n.push(t), T.set(e, n)
				},
				C = (e, t) => {
					const n = T.get(e);
					n && n.forEach(n => n(e, t)), T.delete(e)
				},
				w = function(e, t, n) {
					let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (o, c, u) => {
						let {
							apiContext: l
						} = u;
						const b = t;
						if (c().uploads[b] && Object(d.d)(c().uploads[b])) return;
						const p = i()(),
							m = () => {
								const e = c().uploads[b];
								return !e || e.id !== p || e.status === d.a.CANCELED
							};
						o(h({
							key: b,
							id: p,
							file: e
						}));
						const {
							uploadLease: f,
							websocketUrl: g,
							error: O
						} = await n(c().uploads[b]);
						if (m()) return;
						if (O || !f) return void o(v({
							key: b,
							error: O
						}));
						let j;
						x(p, () => {
							j && j.abort()
						}), o(y({
							key: b
						}));
						const I = await Object(a.a)(e, f, e => (j = e, r && e.on("progress", e => {
							if (!m() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								o(_({
									key: b,
									progress: t
								}))
							}
						}), e));
						if (j = null, !m())
							if (I.ok) {
								const e = decodeURIComponent(I.body.PostResponse.Location);
								o(E({
									key: b,
									url: e,
									websocketUrl: g
								}))
							} else {
								const e = s()(I, "body.Error.Message.0"),
									t = Object.assign({
										type: "ERROR"
									}, e ? {
										fields: [{
											field: "0",
											msg: e
										}]
									} : {});
								o(v({
									key: b,
									error: t
								}))
							}
					}
				},
				P = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, r) => {
						const s = r().uploads[e];
						s && (C(s.id, t), n(t ? S({
							key: e
						}) : I({
							key: e
						})))
					}
				}
		},
		"./src/reddit/actions/userBlocks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "g", (function() {
				return v
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/accounts/index.ts"),
				c = n("./src/reddit/models/Toast/index.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/actions/blockedRedditors.ts");
			const u = "USER_BLOCK__PENDING",
				l = "USER_BLOCK__LOADED",
				b = "USER_BLOCK__FAILED",
				p = Object(s.a)(u),
				m = Object(s.a)(l),
				f = Object(s.a)(b),
				g = e => async (t, n, s) => {
					let {
						apiContext: a
					} = s;
					const u = n();
					if (u.blockUser.api.pending[e]) return;
					t(p({
						username: e
					}));
					const l = await Object(i.a)(a(), e),
						b = "error-block-".concat(e);
					if (l.ok) l.body.name && t(m(l.body)), l.body.id && t(Object(d.f)(l.body.id)), t(o.f(b)), t(o.e({
						kind: c.b.SuccessCommunity,
						text: Object(r.a)(u.user.language, "settings.page.saveRequestSuccess")
					}));
					else {
						const n = {
							type: l.error ? l.error.type : "Unknown error",
							username: e
						};
						t(f(n)), t(o.e({
							id: b,
							kind: c.b.Error,
							text: Object(r.a)(u.user.language, "error.tryAgainLater"),
							buttonText: Object(r.a)(u.user.language, "reportFlow.blockUser.retry"),
							buttonAction: g(e)
						}))
					}
				}, O = "USER_UNBLOCK__PENDING", h = "USER_UNBLOCK__SUCCESS", y = "USER_UNBLOCK__FAILED", j = Object(s.a)(O), _ = Object(s.a)(h), E = Object(s.a)(y), v = e => async (t, n, s) => {
					let {
						apiContext: u
					} = s;
					const l = n(),
						b = Object(a.i)(l),
						p = b ? b.id : void 0,
						m = l.user.blocked.data.filter(t => t.name === e)[0];
					p && (t(j({
						name: e
					})), (await Object(i.b)(u(), p, e)).ok ? (t(_({
						name: e
					})), m && m.id && t(Object(d.h)(m.id)), t(o.e({
						kind: c.b.SuccessCommunity,
						text: Object(r.a)(l.user.language, "settings.page.saveRequestSuccess")
					}))) : (t(o.e({
						kind: c.b.Error,
						text: Object(r.a)(l.user.language, "error.tryAgainLater")
					})), t(E({
						name: e
					}))))
				}
		},
		"./src/reddit/actions/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return O
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "c", (function() {
				return D
			})), n.d(t, "g", (function() {
				return N
			})), n.d(t, "f", (function() {
				return L
			})), n.d(t, "e", (function() {
				return B
			})), n.d(t, "o", (function() {
				return H
			})), n.d(t, "n", (function() {
				return K
			})), n.d(t, "m", (function() {
				return W
			})), n.d(t, "l", (function() {
				return Y
			})), n.d(t, "j", (function() {
				return z
			})), n.d(t, "k", (function() {
				return J
			})), n.d(t, "p", (function() {
				return Q
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/isEmpty.js"),
				i = n.n(o),
				c = n("./src/reddit/actions/authorFlair.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/flair/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/models/Flair/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/models/User/index.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/selectors/userFlair.ts");
			const O = "USER_FLAIR_DATA__MUTATED",
				h = "AUTHOR_FLAIR_DATA__MUTATED",
				y = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				j = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING"),
				_ = Object(s.a)(y),
				E = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED"),
				v = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				I = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				S = Object(s.a)(v),
				T = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				x = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				C = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING"),
				w = Object(s.a)(x),
				P = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED"),
				D = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				R = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING"),
				A = Object(s.a)(D),
				k = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED"),
				N = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				L = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				M = Object(s.a)(N),
				U = Object(s.a)("STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS"),
				F = Object(s.a)(L),
				B = "USERFLAIR_FETCH_SUCCESS",
				G = Object(s.a)(B),
				V = Object(s.a)(O),
				q = Object(s.a)(h),
				H = (e, t, n, r, s) => async (o, i, c) => {
					let {
						apiContext: a
					} = c;
					const l = i(),
						b = l.user.account,
						f = b ? Object(p.f)(b) : void 0,
						O = Object(g.c)(l, {
							subredditId: s
						}),
						h = Object.assign({}, O.displaySettings, {
							isUserEnabled: n
						}),
						y = {
							userName: r,
							subredditId: s,
							applied: e,
							displaySettings: h
						};
					o(r === f ? V(y) : q(y));
					const j = Object(m.S)(l, {
							subredditId: s
						}),
						_ = t && e ? Object(u.g)(e) : void 0;
					Object(d.g)(a(), r, j.name, t, _), Object(d.i)(a(), n, j.name)
				}, K = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(m.S)(i, {
							subredditId: e
						}).name;
					n(j());
					const a = await Object(d.l)(o(), c, t);
					if (a.ok) {
						n(_({
							subredditId: e,
							isEnabled: t
						}))
					} else n(E());
					return a.ok
				}, W = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = r(),
						c = Object(m.S)(i, {
							subredditId: e
						}).name;
					n(I());
					const a = await Object(d.j)(o(), t, l.d.UserFlair, c);
					if (a.ok) {
						n(S({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(T());
					return a.ok
				}, Y = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = s(),
						u = Object(m.S)(c, {
							subredditId: t
						}).name,
						p = Object(f.T)(c);
					n(C());
					const g = await Object(d.f)(i(), e, u, l.d.UserFlair),
						O = g.ok && !(g.body && !1 === g.body.success);
					if (O) {
						const e = {
							subredditId: t,
							template: g.body
						};
						n(w(e));
						const s = Object(a.d)(Object(r.a)(p, "structuredStyles.forms.flair.toast.flairSaved"), b.b.SuccessMod);
						n(Object(a.e)(s))
					} else {
						n(P());
						const s = Object(a.d)(Object(r.a)(p, "structuredStyles.forms.flair.toast.flairNotSaved"), b.b.Error, Object(r.a)(p, "structuredStyles.forms.flair.toast.retryButtonText"), Y(e, t));
						n(Object(a.e)(s))
					}
					return O
				}, z = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = s(),
						u = Object(m.S)(c, {
							subredditId: t
						}).name,
						l = Object(f.T)(c);
					if (n(R()), (await Object(d.b)(i(), e, u)).ok) {
						n(A({
							subredditId: t,
							templateId: e
						}));
						const s = Object(a.d)(Object(r.a)(l, "structuredStyles.forms.flair.toast.flairDeleted"), b.b.SuccessMod);
						n(Object(a.e)(s))
					} else {
						n(k());
						const s = Object(a.d)(Object(r.a)(l, "structuredStyles.forms.flair.toast.flairNotDeleted"), b.b.Error, Object(r.a)(l, "structuredStyles.forms.flair.toast.retryButtonText"), z(e, t));
						n(Object(a.e)(s))
					}
				}, J = (e, t) => async (n, s, o) => {
					let {
						apiContext: i
					} = o;
					const c = s(),
						u = Object(m.S)(c, {
							subredditId: t
						}).name,
						p = Object(g.c)(c, {
							subredditId: t
						}).templateIds,
						O = Object(f.T)(c);
					if (n(M({
							subredditId: t,
							templateIds: e
						})), (await Object(d.e)(i(), u, l.d.UserFlair, e)).ok) {
						n(U());
						const e = Object(a.d)(Object(r.a)(O, "structuredStyles.forms.flair.toast.flairReorderSuccess"), b.b.SuccessMod);
						n(Object(a.e)(e))
					} else {
						n(F({
							subredditId: t,
							templateIds: p
						}));
						const s = Object(a.d)(Object(r.a)(O, "structuredStyles.forms.flair.toast.flairReorderFailure"), b.b.Error, Object(r.a)(O, "structuredStyles.forms.flair.toast.retryButtonText"), J(e, t));
						n(Object(a.e)(s))
					}
				}, Q = (e, t) => async (n, s, o) => {
					let {
						apiContext: u
					} = o;
					const l = s(),
						p = l.userFlair;
					if (p && p[e] && p[e].displaySettings.isEnabled && i()(p[e].templateIds)) {
						const s = Object(m.S)(l, {
								subredditId: e
							}).name,
							o = await Object(d.d)(u(), s);
						if (o.ok) n(G(o.body)), n(Object(c.b)({
							username: t,
							subredditId: e
						}));
						else {
							const e = Object(f.T)(l),
								t = Object(a.d)(Object(r.a)(e, "error.type.generic"), b.b.Error);
							n(Object(a.e)(t))
						}
					} else n(Object(c.b)({
						username: t,
						subredditId: e
					}))
				}
		},
		"./src/reddit/actions/userWhitelist.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "h", (function() {
				return _
			}));
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/accounts/index.ts"),
				c = n("./src/reddit/models/Toast/index.ts");
			const a = "USER_WHITELIST__PENDING",
				d = "USER_WHITELIST__SUCCESS",
				u = "USER_WHITELIST__FAILED",
				l = Object(s.a)(a),
				b = Object(s.a)(d),
				p = Object(s.a)(u),
				m = e => async (t, n, s) => {
					let {
						apiContext: a
					} = s;
					t(l());
					const d = await Object(i.d)(a(), e),
						u = n();
					d.ok ? d.body.name && (t(b(d.body)), t(o.e({
						kind: c.b.SuccessCommunity,
						text: Object(r.a)(u.user.language, "settings.page.saveRequestSuccess")
					}))) : (t(p()), t(o.e({
						kind: c.b.Error,
						text: Object(r.a)(u.user.language, "error.tryAgainLater")
					})))
				}, f = "USER_UNWHITELIST__PENDING", g = "USER_UNWHITELIST__SUCCESS", O = "USER_UNWHITELIST__FAILED", h = Object(s.a)(f), y = Object(s.a)(g), j = Object(s.a)(O), _ = e => async (t, n, s) => {
					let {
						apiContext: a
					} = s;
					const d = n();
					t(h({
						name: e
					})), (await Object(i.c)(a(), e)).ok ? (t(y({
						name: e
					})), t(o.e({
						kind: c.b.SuccessCommunity,
						text: Object(r.a)(d.user.language, "settings.page.saveRequestSuccess")
					}))) : (t(j({
						name: e
					})), t(o.e({
						kind: c.b.Error,
						text: Object(r.a)(d.user.language, "error.tryAgainLater")
					})))
				}
		},
		"./src/reddit/actions/usernameAvailable.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			var a;
			n.d(t, "b", (function() {
					return a
				})), n.d(t, "a", (function() {
					return d
				})), n.d(t, "c", (function() {
					return u
				})), n.d(t, "d", (function() {
					return l
				})), n.d(t, "e", (function() {
					return b
				})), n.d(t, "f", (function() {
					return O
				})),
				function(e) {
					e[e.Available = 0] = "Available", e[e.Error = 1] = "Error", e[e.Pending = 2] = "Pending", e[e.Unavailable = 3] = "Unavailable"
				}(a || (a = {}));
			const d = "USERNAME_AVAILABLE__AVAILABLE",
				u = "USERNAME_AVAILABLE__FAILURE",
				l = "USERNAME_AVAILABLE__PENDING",
				b = "USERNAME_AVAILABLE__UNAVAILABLE",
				p = Object(r.a)(d),
				m = Object(r.a)(u),
				f = Object(r.a)(l),
				g = Object(r.a)(b),
				O = e => {
					let {
						username: t
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: d
						} = r;
						const u = n().users.nameAvailable;
						if (!u[t] || u[t] === a.Error) {
							e(f({
								username: t
							}));
							const n = await ((e, t) => Object(o.b)(Object(i.a)(e, [c.a]), {
								method: s.bb.GET,
								endpoint: "".concat(e.apiUrl, "/api/username_available.json?user=").concat(t.username),
								type: "json"
							}))(d(), {
								username: t
							});
							n.ok ? n.body ? e(p({
								username: t
							})) : e(g({
								username: t
							})) : e(m({
								username: t
							}))
						}
					}
				}
		},
		"./src/reddit/actions/users.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/app/strings/index.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/emailVerificationTooltip.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/notificationBanner.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/components/NotificationBanners/bannerIds.ts"),
				l = n("./src/reddit/components/Settings/modalIds.ts"),
				b = n("./src/reddit/endpoints/user/index.ts"),
				p = n("./src/reddit/i18n/utils.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				O = n("./src/config.ts"),
				h = n("./src/reddit/helpers/getErrorMsgFromR2JQueryResponse.ts"),
				y = (n("./node_modules/core-js/modules/es7.promise.finally.js"), n("./node_modules/promise-retry/index.js")),
				j = n.n(y),
				_ = n("./src/lib/makeRequest/index.ts");
			var E = n("./src/reddit/constants/history.ts"),
				v = n("./src/reddit/endpoints/session/index.ts"),
				I = n("./node_modules/js-cookie/src/js.cookie.js"),
				S = n.n(I),
				T = n("./src/lib/constants/cookie.ts");
			const x = e => {
				S.a.remove(e, {
					domain: O.a.cookieDomain
				})
			};
			var C = n("./src/reddit/helpers/history/index.ts");
			const w = 2 * s.cb;
			var P = e => Date.now() + w < new Date(e.expires).getTime(),
				D = n("./src/reddit/helpers/localStorage/index.ts"),
				R = n("./src/reddit/helpers/monthsToMinutes/index.ts"),
				A = async (e, t) => {
					let n = t.accessToken;
					await j()(async (r, o) => {
						if (!P(t) || !n) {
							const s = await Object(v.a)(e, t);
							if (s.ok) {
								const e = s.body;
								n = e.accessToken
							} else if (1 === o) return r()
						}
						const i = await Object(m.b)(e, {
							endpoint: "/logoutproxy",
							method: s.bb.POST,
							data: {
								access_token: n
							}
						});
						if (await async function(e, t) {
								return await Object(_.b)({
									method: s.bb.POST,
									endpoint: "/timings/logoutrequest",
									data: {
										appName: e.statsAppName,
										successful: t
									},
									type: "json"
								})
							}(e, i && i.ok), !i.ok) return r()
					}, {
						retries: 1
					}).catch(() => {}).finally(() => {
						[T.c, T.g, T.d, T.h, T.i].forEach(x), Object(R.b)(), Object(D.B)(null), Object(C.a)(E.a.JustLoggedOut, !0), window.location.reload()
					})
				}, k = n("./src/reddit/helpers/redesignOptoutCookie/index.ts"), N = n("./src/reddit/helpers/trackers/emailCollection.ts"), L = n("./src/reddit/helpers/trackers/emailVerification.ts"), M = n("./src/reddit/models/Toast/index.ts"), U = n("./src/reddit/selectors/activeModalId.ts"), F = n("./src/reddit/selectors/emailCollection.ts"), B = n("./src/reddit/selectors/notificationBanner.ts"), G = n("./src/reddit/selectors/user.ts"), V = n("./src/telemetry/index.ts");
			n.d(t, "d", (function() {
				return H
			})), n.d(t, "t", (function() {
				return K
			})), n.d(t, "i", (function() {
				return W
			})), n.d(t, "h", (function() {
				return Y
			})), n.d(t, "g", (function() {
				return z
			})), n.d(t, "m", (function() {
				return J
			})), n.d(t, "f", (function() {
				return Q
			})), n.d(t, "B", (function() {
				return ee
			})), n.d(t, "e", (function() {
				return te
			})), n.d(t, "u", (function() {
				return re
			})), n.d(t, "s", (function() {
				return se
			})), n.d(t, "A", (function() {
				return oe
			})), n.d(t, "v", (function() {
				return ie
			})), n.d(t, "b", (function() {
				return ce
			})), n.d(t, "a", (function() {
				return ae
			})), n.d(t, "q", (function() {
				return de
			})), n.d(t, "c", (function() {
				return ue
			})), n.d(t, "r", (function() {
				return be
			})), n.d(t, "x", (function() {
				return pe
			})), n.d(t, "o", (function() {
				return me
			})), n.d(t, "p", (function() {
				return fe
			})), n.d(t, "n", (function() {
				return ge
			})), n.d(t, "w", (function() {
				return _e
			})), n.d(t, "y", (function() {
				return Ee
			})), n.d(t, "k", (function() {
				return ve
			})), n.d(t, "l", (function() {
				return Ie
			})), n.d(t, "j", (function() {
				return Se
			})), n.d(t, "z", (function() {
				return we
			}));
			var q = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const H = "USER__LOID_RECEIVED",
				K = Object(o.a)(H),
				W = "USER__REQUEST_PENDING",
				Y = "USER__REQUEST_LOADED",
				z = "USER__REQUEST_FAILED",
				J = "USER__SESSION_TRACKER_RECEIVED",
				Q = "USER__REDDAID_RECEIVED",
				X = Object(o.a)(W),
				Z = Object(o.a)(Y),
				$ = Object(o.a)(z),
				ee = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (n().users.models[e.toLowerCase()] || e === s.z) return;
					t(X({
						username: e
					}));
					const i = await Object(b.b)(o(), e);
					if (i.ok) {
						const n = {
							data: i.body
						};
						n.username = e, t(Z(n))
					} else {
						const n = i.error;
						n.username = e, t($(n))
					}
				}, te = "USER__MYSELF_LOADED", ne = Object(o.a)(te), re = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t();
					if (o.user.account || !o.user.session || o.user.session.unsafeLoggedOut) return;
					const i = await (e => Object(m.b)(e, {
						endpoint: "".concat(O.a.gatewayUrl, "/desktopapi/v1/me"),
						method: s.bb.GET,
						data: {
							api_type: "json",
							gilding_detail: 1,
							awarded_detail: 1
						}
					}))(r());
					i.ok && e(ne(i.body))
				}, se = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t().user.session;
					Object(k.a)(), s && A(r(), s)
				}, oe = Object(o.a)(J), ie = Object(o.a)(Q), ce = "USER__FTU_UX_VIEWED", ae = "USER__FEATURES_VIEWED_HISTORY_LOADED", de = Object(o.a)(ce), ue = (Object(o.a)(ae), "USER__LAYOUT_SWITCH_VIEWED"), le = Object(o.a)(ue), be = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const s = t();
					s.user.account && !s.user.account.seenLayoutSwitch && (e(le()), Object(b.d)(r()))
				}, pe = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), {
							method: s.bb.POST,
							endpoint: "".concat(e.apiUrl, "/api/deactivate_user"),
							data: {
								user: t.username,
								passwd: t.password,
								confirm: t.checkbox,
								deactivate_message: t.feedback
							}
						}))(o(), e),
						c = n().user.session;
					i.ok && i.body && i.body.success ? c && A(o(), c) : t(Object(d.e)({
						kind: M.b.Error,
						text: "Something went wrong deactivating your account. Try again later."
					}))
				}, me = "USER__UPDATE_EMAIL_PENDING", fe = "USER__UPDATE_EMAIL_SUCCESS", ge = "USER__UPDATE_EMAIL_FAILURE", Oe = Object(o.a)(me), he = Object(o.a)(fe), ye = Object(o.a)(ge), je = (e, t) => {
					t.isEmailVerificationTooltipShowing && e(Object(i.b)())
				}, _e = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = q(e, []);
					if (Object(G.G)(n(), "changeEmail")) return;
					t(Oe());
					const c = await ((e, t) => {
							let {
								newEmail: n,
								password: r
							} = t;
							return Object(m.b)(Object(f.a)(e, [g.a]), {
								method: s.bb.POST,
								endpoint: "".concat(e.apiUrl, "/api/update_email"),
								data: Object.assign({}, r && {
									curpass: r
								}, {
									email: n
								})
							})
						})(o(), i),
						d = n();
					if (c.ok && c.body && c.body.success) {
						Object(B.a)(u.a.EmailCollectionBannerId)(d) && t(Object(a.c)(u.a.EmailCollectionBannerId)), Object(F.a)(d) && Object(V.a)(Object(N.c)(d));
						const e = Object(G.I)(d);
						e || await t(Ee()), t(he(i.newEmail)), e && t(xe()), je(t, d)
					} else {
						const e = Object(h.b)(c, "Something went wrong updating your email. Try again later.");
						t(ye(e))
					}
				}, Ee = e => async (t, n, o) => {
					let {
						apiContext: i
					} = o;
					const a = await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), Object.assign({
							method: s.bb.GET,
							endpoint: "".concat(e.apiUrl, "/api/send_verification_email")
						}, t.source && {
							data: t
						})))(i(), {
							source: e
						}),
						u = n();
					if (a.ok && a.body && a.body.success) {
						e && (Object(V.a)(Object(L.f)(e)(u)), je(t, u));
						const n = Object(U.a)(u),
							r = n === l.c || n === l.d ? l.d : l.b;
						t(Object(c.i)(r))
					} else {
						const e = Object(G.T)(u);
						t(Object(d.e)({
							duration: d.a,
							kind: M.b.Error,
							text: Object(r.a)(e, "emailVerification.banner.error")
						}))
					}
				}, ve = "USER__SEND_RESET_EMAIL_PENDING", Ie = "USER__SEND_RESET_EMAIL_SUCCESS", Se = "USER__SEND_RESET_EMAIL_FAILURE", Te = Object(o.a)(ve), xe = Object(o.a)(Ie), Ce = Object(o.a)(Se), we = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (Object(G.G)(n(), "sendResetEmail")) return;
					t(Te());
					const i = await ((e, t) => Object(m.b)(Object(f.a)(e, [g.a]), {
						method: s.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/password"),
						data: {
							email: t.curEmail,
							name: t.name
						}
					}))(o(), e);
					if (!i.ok || !i.body || !i.body.success) {
						const e = Object(h.b)(i, "Something went wrong sending the reset email. Please try again.");
						return t(Ce()), void t(Object(d.e)({
							duration: d.a,
							kind: M.b.Error,
							text: Object(p.c)(e)
						}))
					}
					t(xe())
				}
		},
		"./src/reddit/actions/video.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return m
			})), n.d(t, "q", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "m", (function() {
				return y
			})), n.d(t, "n", (function() {
				return j
			})), n.d(t, "p", (function() {
				return _
			})), n.d(t, "r", (function() {
				return E
			})), n.d(t, "t", (function() {
				return v
			})), n.d(t, "u", (function() {
				return I
			})), n.d(t, "s", (function() {
				return S
			})), n.d(t, "g", (function() {
				return T
			})), n.d(t, "o", (function() {
				return x
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "c", (function() {
				return D
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "e", (function() {
				return A
			})), n.d(t, "f", (function() {
				return k
			})), n.d(t, "y", (function() {
				return L
			})), n.d(t, "B", (function() {
				return H
			})), n.d(t, "A", (function() {
				return K
			})), n.d(t, "N", (function() {
				return W
			})), n.d(t, "F", (function() {
				return Y
			})), n.d(t, "O", (function() {
				return z
			})), n.d(t, "P", (function() {
				return J
			})), n.d(t, "C", (function() {
				return X
			})), n.d(t, "D", (function() {
				return $
			})), n.d(t, "H", (function() {
				return ne
			})), n.d(t, "L", (function() {
				return re
			})), n.d(t, "z", (function() {
				return se
			})), n.d(t, "M", (function() {
				return ie
			})), n.d(t, "K", (function() {
				return de
			})), n.d(t, "J", (function() {
				return ue
			})), n.d(t, "w", (function() {
				return le
			})), n.d(t, "I", (function() {
				return be
			})), n.d(t, "v", (function() {
				return pe
			})), n.d(t, "E", (function() {
				return me
			})), n.d(t, "G", (function() {
				return fe
			})), n.d(t, "x", (function() {
				return ge
			}));
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/reddit/constants/adEvents.ts"),
				o = n("./src/reddit/constants/video.ts"),
				i = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/helpers/pixels.ts"),
				a = n("./src/reddit/helpers/trackers/media.ts"),
				d = n("./src/reddit/helpers/trackers/postList.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/telemetry.ts"),
				p = (n("./src/reddit/selectors/video.ts"), n("./src/telemetry/index.ts"));
			const m = "VIDEO__CONSUMED",
				f = "VIDEO__SET_FULLSCREEN",
				g = "VIDEO__EXIT_FULLSCREEN",
				O = "VIDEO__LOADABLE",
				h = "VIDEO__LOADING",
				y = "VIDEO__PAUSED",
				j = "VIDEO__PLAYABLE",
				_ = "VIDEO__METADATA_RECEIVED",
				E = "VIDEO__STARTED",
				v = "VIDEO__UNLOADABLE",
				I = "VIDEO__UNPAUSED",
				S = "VIDEO__TIME_UPDATED",
				T = "VIDEO__BUFFERING",
				x = "VIDEO__PLAYING",
				C = "VIDEO__CONTINUOUS_VIEW_STARTED_AT",
				w = "AD__VIDEO_VIEWABLE",
				P = "AD__VIDEO_FULLY_VIEWABLE",
				D = "AD__VIDEO_STARTED",
				R = "AD__VIDEO_PLAYED_WITH_SOUND",
				A = "AD__VIDEO_WATCHED_PERCENT",
				k = "AD__VIDEO_WATCHED_SECONDS",
				N = (() => {
					let e = "";
					return (t, n, r, s) => async (o, c) => {
						if (null != t) {
							e !== t && (e = t, Object(i.d)(i.a.VideoView));
							const o = c(),
								d = s ? a.b(t, n, r) : a.a(t, n, r);
							Object(p.a)(Object.assign({}, b.defaults(o), d(o)))
						}
					}
				})(),
				L = Object(r.a)(C),
				M = Object(r.a)(w),
				U = Object(r.a)(P),
				F = Object(r.a)(D),
				B = Object(r.a)(R),
				G = Object(r.a)("AD__VIDEO_PLAYED_EXPANDED"),
				V = Object(r.a)(A),
				q = Object(r.a)(k),
				H = e => async (t, n) => {
					const r = Object(l.I)(n(), {
						postId: e
					});
					t(N(e, "is_viewable", "video", !1)), r.isSponsored && (Object(c.a)(r.events, s.a.VideoViewableImpression), t(M({
						postId: e
					})))
				}, K = e => async (t, n) => {
					const r = Object(l.I)(n(), {
						postId: e
					});
					t(N(e, "is_fully_viewable", "video", !1)), r.isSponsored && (Object(c.a)(r.events, s.a.VideoFullyViewableImpression), t(U({
						postId: e
					})))
				}, W = e => async (t, n) => {
					const r = Object(l.I)(n(), {
						postId: e
					});
					t(N(e, "start", "video", !1)), r.isSponsored && (Object(c.a)(r.events, s.a.VideoStarted), t(F({
						postId: e
					})))
				}, Y = e => async (t, n) => {
					const r = Object(l.I)(n(), {
						postId: e
					});
					t(N(e, "play_with_sound", "video", !1)), t(N(e, "is_viewable", "video", !1)), t(N(e, "is_fully_viewable", "video", !1)), r.isSponsored && (Object(c.a)(r.events, s.a.VideoPlayedWithSound), Object(c.a)(r.events, s.a.VideoViewableImpression), Object(c.a)(r.events, s.a.VideoFullyViewableImpression), t(B({
						postId: e
					})), t(M({
						postId: e
					})), t(U({
						postId: e
					})))
				}, z = (e, t) => async (n, r) => {
					const i = Object(l.I)(r(), {
						postId: t
					});
					let a, d;
					switch (e) {
						case o.b:
							a = "watch_25_percent", d = s.a.VideoWatched25;
							break;
						case o.c:
							a = "watch_50_percent", d = s.a.VideoWatched50;
							break;
						case o.d:
							a = "watch_75_percent", d = s.a.VideoWatched75;
							break;
						case o.e:
							a = "watch_95_percent", d = s.a.VideoWatched95;
							break;
						default:
							a = "watch_100_percent", d = s.a.VideoWatched100
					}
					n(N(t, a, "video", !1)), i.isSponsored && (Object(c.a)(i.events, d), n(V({
						postId: t,
						percentage: e
					})))
				}, J = (e, t) => async (n, r) => {
					const i = Object(l.I)(r(), {
						postId: t
					});
					let a, d;
					switch (e) {
						case o.g:
							a = "watch_3_seconds", d = s.a.VideoWatchedSeconds3;
							break;
						case o.h:
							a = "watch_5_seconds", d = s.a.VideoWatchedSeconds5;
							break;
						default:
							a = "watch_10_seconds", d = s.a.VideoWatchedSeconds10
					}
					n(N(t, a, "video", !1)), i.isSponsored && (Object(c.a)(i.events, d), n(q({
						postId: t,
						seconds: e
					})))
				}, Q = Object(r.a)(m), X = Object(r.a)(O), Z = Object(r.a)(h), $ = Object(r.a)(y), ee = Object(r.a)(j), te = Object(r.a)(f), ne = Object(r.a)(_), re = Object(r.a)(S), se = Object(r.a)(g), oe = Object(r.a)(E), ie = Object(r.a)(v), ce = Object(r.a)(I), ae = Object(r.a)(T), de = Object(r.a)(x), ue = e => async (t, n) => {
					const r = Object(l.I)(n(), {
						postId: e
					});
					t(te({
						postId: e
					})), ((e, t, n) => {
						n(N(t, "play_expanded", "video", !1)), n(N(t, "is_viewable", "video", !1)), n(N(t, "is_fully_viewable", "video", !1)), e.isSponsored && (Object(c.a)(e.events, s.a.VideoPlayedExpanded), Object(c.a)(e.events, s.a.VideoViewableImpression), Object(c.a)(e.events, s.a.VideoFullyViewableImpression), n(G({
							postId: t
						})), n(M({
							postId: t
						})), n(U({
							postId: t
						})))
					})(r, e, t)
				}, le = (e, t) => async (n, r) => {
					const s = r();
					s.posts.video.autoPlayed[e] && Object(u.k)(s) && (d.d(s, e), void 0 !== t && n(ae({
						postId: e,
						isBuffering: t
					})))
				}, be = e => async (t, n) => {
					const r = n();
					r.posts.video.autoPlayed[e] && Object(u.k)(r) && d.h(r, e)
				}, pe = (e, t) => async (n, r) => {
					n(Z({
						postId: e,
						time: t
					}));
					const s = r();
					Object(u.k)(s) && d.f(s, e)
				}, me = (e, t) => async (n, r) => {
					n(ee({
						postId: e,
						time: t
					}));
					const s = r();
					Object(u.k)(s) && d.a(s, e)
				}, fe = e => async (t, n) => {
					const r = n(),
						s = r.posts.video.autoPlayed[e],
						o = r.posts.video.started[e];
					t(oe({
						postId: e
					})), t(ce({
						postId: e
					})), !o && s && Object(u.k)(r) && d.c(r, e)
				}, ge = e => async (t, n) => {
					const r = n(),
						s = r.posts.video.autoPlayed[e],
						o = r.posts.video.consumed[e];
					t(Q({
						postId: e
					})), s && Object(u.k)(r) && !o && d.b(r, e)
				}
		},
		"./src/reddit/actions/vote.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/actions/tooltip.ts"),
				i = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				c = n("./src/reddit/endpoints/user/index.ts"),
				a = n("./src/reddit/actions/gold/constants.ts");
			const d = Object(r.a)(a.t),
				u = Object(r.a)(a.u);
			var l = n("./src/reddit/actions/login.ts"),
				b = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/monthsToMinutes/homeFeed.ts"),
				m = n("./src/reddit/constants/adEvents.ts"),
				f = n("./src/lib/constants/index.ts"),
				g = n("./src/lib/makeApiRequest/index.ts"),
				O = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				y = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var j = n("./src/reddit/featureFlags/index.ts"),
				_ = n("./src/reddit/helpers/favoriteCreators/index.ts"),
				E = n("./src/reddit/helpers/isComment.ts"),
				v = n("./src/reddit/helpers/isPost.ts"),
				I = n("./src/reddit/helpers/pixels.ts"),
				S = n("./src/reddit/helpers/trackers/gild.ts"),
				T = n("./src/reddit/models/Vote/index.ts"),
				x = n("./src/reddit/selectors/comments.ts"),
				C = n("./src/reddit/constants/experiments.ts"),
				w = n("./src/reddit/helpers/chooseVariant/index.ts"),
				P = n("./src/reddit/selectors/user.ts");
			var D = n("./src/reddit/selectors/gild.ts"),
				R = n("./src/reddit/selectors/monthsToMinutes.ts"),
				A = n("./src/reddit/selectors/platform.ts"),
				k = n("./src/reddit/selectors/posts.ts"),
				N = n("./src/reddit/selectors/telemetry.ts");
			n.d(t, "a", (function() {
				return L
			})), n.d(t, "b", (function() {
				return U
			}));
			const L = "VOTE__VOTE_CAST",
				M = Object(r.a)(L),
				U = (e, t) => n => async (r, a, L) => {
					let {
						apiContext: U
					} = L;
					if (!Object(P.K)(a()) && !Object(R.w)(a())) return r(Object(b.k)({
						actionSource: b.a.Vote
					})), void r(Object(l.f)());
					const F = e(n, a),
						B = T.b(F, t),
						G = Object(v.a)(n) ? F.postId : n;
					if (r(M({
							id: G,
							isInstance: !1,
							vote: t
						})), (a().posts.instances[G] || []).forEach(e => {
							r(M({
								id: e,
								isInstance: !0,
								vote: t
							}))
						}), B)
						if (Object(v.a)(n)) {
							const e = Object(k.I)(a(), {
									postId: n
								}),
								r = t > 0 ? m.a.Upvote : m.a.Downvote;
							Object(I.a)(e.events, r)
						} else if (Object(E.a)(n)) {
						const e = Object(x.n)(a(), {
							commentId: n
						});
						if (e) {
							const n = Object(k.I)(a(), {
									postId: e.postId
								}),
								r = t > 0 ? m.a.CommentUpvote : m.a.CommentDownvote;
							Object(I.a)(n.events, r)
						}
					}
					const V = a(),
						q = Object(A.i)(V),
						H = !!Object(D.f)(V),
						K = Object(P.cb)(V);
					if (H ? r((() => async (e, t, n) => {
							let {
								apiContext: r
							} = n;
							e(d()), e(Object(o.h)())
						})()) : Object(v.a)(G) && B === T.a.upvoted && !K && (e => {
							const t = Object(w.c)(e, {
								experimentEligibilitySelector: e => Object(P.K)(e),
								experimentName: C.K
							});
							return Object(C.Wb)(t) ? void 0 : t
						})(V) && (r(((e, t) => async (n, r, s) => {
							let {
								apiContext: a
							} = s;
							n(u(e)), n(Object(o.g)({
								tooltipId: Object(i.a)("View--GiveAward", e, t ? "lightbox" : void 0)
							})), Object(c.c)(a())
						})(G, q)), Object(s.a)(Object(S.viewGiveAwardTooltipEvent)(G)(V))), Object(v.a)(n) && B === T.a.upvoted && j.d.spFavoriteCreators(V)) {
						const e = Object(k.I)(V, {
							postId: n
						});
						Object(_.a)(e.belongsTo.id, e.authorId)
					}
					if (Object(P.K)(V)) {
						(await ((e, t, n) => Object(g.b)(Object(O.a)(e, [h.a]), {
							endpoint: Object(y.a)("".concat(e.apiUrl, "/api/vote")),
							method: f.bb.POST,
							data: {
								id: t,
								dir: n,
								api_type: "json"
							}
						}))(U(), G, B)).ok || r(M({
							id: G,
							isInstance: !1,
							vote: t
						}))
					} else if (Object(R.w)(V)) {
						const e = Object(N.subredditByPostOrCommentId)(V, n);
						e && e.name && r(Object(p.h)({
							id: n,
							subredditName: e.name
						})), await r(Object(p.g)())
					}
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return r
			})), n.d(t, "i", (function() {
				return s
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			}));
			const r = "WIDGETS__WIDGET_CREATED",
				s = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				i = "WIDGETS_SORTED",
				c = "WIDGETS__STARTED_EDITING_WIDGET",
				a = "WIDGETS__LOADED",
				d = "SUBREDDIT__WIDGETS_PENDING",
				u = "SUBREDDIT__WIDGETS_LOADED",
				l = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/makeActionCreator/index.ts"),
				s = n("./src/app/strings/index.ts"),
				o = n("./src/reddit/actions/apiRequestState.ts"),
				i = n("./src/reddit/actions/imageUploads.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			const b = async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widgets"),
				method: a.bb.GET,
				type: "json",
				data: {
					progressive_images: n
				}
			});
			var p = n("./src/reddit/helpers/getGenericUploadError.ts"),
				m = n("./src/reddit/helpers/media/index.ts"),
				f = n("./src/lib/assertNever.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/models/Image/index.tsx"),
				h = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/models/Widgets/index.ts"),
				j = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/reddit/actions/widgets/constants.ts");
			n.d(t, "c", (function() {
				return v
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "h", (function() {
				return w
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "b", (function() {
				return D
			})), n.d(t, "f", (function() {
				return A
			})), n.d(t, "g", (function() {
				return M
			}));
			const E = Object(r.a)(_.g),
				v = (e, t, n) => async (r, b, m) => {
					const {
						apiContext: f
					} = m;
					r(Object(o.h)(n));
					const _ = b(),
						v = Object(g.S)(_, {
							subredditId: e
						}).name,
						I = Object(j.T)(_),
						S = Object(y.k)(t);
					let T = null,
						x = null;
					try {
						(T = await Object(i.f)(_, O.a.Widgets)) && (x = Object(i.m)(T)(r, b, m))
					} catch (w) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					const C = await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget"),
						method: a.bb.POST,
						type: "json",
						data: n
					}))(f(), v, S);
					if (C.ok) {
						let i = C.body;
						const a = i.id;
						if ("calendar" === t.kind && r(Object(c.e)({
								kind: h.b.SuccessMod,
								text: Object(s.a)(I, "structuredStyles.widgets.calendar.toastText.created")
							})), T) {
							try {
								await x
							} catch (w) {}
							i = await r(U(e, a)) || i
						}
						r(E({
							subredditId: e,
							widget: i,
							widgetId: a
						})), r(Object(o.e)(n))
					} else T && T.websocket.close(), r(Object(o.f)(n, C.error))
				}, I = Object(r.a)(_.i), S = (e, t, n) => async (r, b, m) => {
					const {
						apiContext: _
					} = m;
					r(Object(o.h)(n));
					const E = t.id,
						v = b(),
						S = Object(g.S)(v, {
							subredditId: e
						}).name,
						T = Object(j.T)(v),
						x = Object(y.k)(t);
					let C = null,
						w = null;
					try {
						(C = await Object(i.f)(v, O.a.Widgets)) && (w = Object(i.m)(C)(r, b, m))
					} catch (D) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					const P = await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget/").concat(n.id),
						method: a.bb.PUT,
						type: "json",
						data: n
					}))(_(), S, x);
					if (P.ok) {
						let i = function(e, t, n) {
							switch (e.kind) {
								case "calendar":
								case "id-card":
								case "subreddit-rules":
									return Object.assign({}, e, t);
								case "community-list": {
									const r = {};
									for (const t of e.data) r[t.name] = t;
									return Object.assign({}, t, {
										data: t.data.map(e => {
											if (!("subscribers" in r[e])) {
												const t = {
														subredditName: e
													},
													r = Object(g.B)(n, t),
													s = Object(g.y)(n, t);
												return {
													name: r.name,
													subscribers: r ? r.subscribers : void 0,
													iconUrl: r ? r.communityIcon : void 0,
													isNSFW: r ? r.isNSFW : void 0,
													isSubscribed: s ? s.userIsSubscriber : void 0
												}
											}
											return r[e]
										})
									})
								}
								case "button":
								case "custom":
								case "image":
								case "menu":
								case "moderators":
								case "textarea":
								case "post-flair":
									return t;
								default:
									return Object(f.a)(e)
							}
						}(t, P.body, v);
						if (w) {
							try {
								await w
							} catch (D) {}
							i = await r(U(e, E)) || i
						}
						r(I({
							subredditId: e,
							widgetId: E,
							widget: i
						})), "calendar" === t.kind && r(Object(c.e)({
							kind: h.b.SuccessMod,
							text: Object(s.a)(T, "structuredStyles.widgets.calendar.toastText.updated")
						})), r(Object(o.e)(n))
					} else C && C.websocket.close(), r(Object(o.f)(n, P.error))
				}, T = Object(r.a)(_.h), x = (e, t, n) => async (r, s, i) => {
					let {
						apiContext: c
					} = i;
					r(Object(o.h)(n));
					const b = t.id,
						p = Object(g.S)(s(), {
							subredditId: e
						}).name,
						m = await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
							endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget/").concat(n.id),
							method: a.bb.DELETE,
							type: "json"
						}))(c(), p, t);
					m.ok ? (r(Object(o.e)(n)), r(T({
						subredditId: e,
						widgetId: b
					}))) : r(Object(o.f)(n, m.error))
				}, C = Object(r.a)(_.f), w = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = Object(g.S)(r(), {
						subredditId: e
					}).name;
					(await (async (e, t, n) => Object(d.b)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget_order/sidebar"),
						method: a.bb.PATCH,
						type: "json",
						data: n
					}))(o(), i, t)).ok && n(C({
						subredditId: e,
						widgetIds: t
					}))
				}, P = e => {
					let {
						imageData: t
					} = e;
					return async (e, n, r) => {
						const s = n(),
							o = s.structuredStyles.isEditing,
							c = Object(g.S)(s, {
								subredditId: o
							}).name;
						e(Object(i.k)(t));
						const b = await (async (e, t, n, r) => Object(d.b)(Object(u.a)(e, [l.a]), {
							endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget_image_upload_s3"),
							method: a.bb.POST,
							data: {
								filepath: n,
								mimetype: r
							}
						}))(r.apiContext(), c, t.file.name, await Object(m.g)(t.file));
						let p = !1;
						try {
							const r = await Object(i.g)(n(), b, t, O.a.Widgets);
							r && (e(Object(i.j)(r)), p = !0)
						} catch (f) {
							if (f instanceof Error) throw f;
							e(Object(i.i)(f))
						}
						return p
					}
				}, D = Object(r.a)(_.d), R = Object(r.a)(_.e), A = (e, t) => async (n, r, s) => {
					let {
						apiContext: i
					} = s;
					n(Object(o.h)(t));
					const c = Object(g.S)(r(), {
							subredditId: e
						}).name,
						a = await b(i(), c);
					if (a.ok) {
						const r = a.body;
						n(R({
							subredditId: e,
							widgets: r
						})), n(Object(o.e)(t))
					} else n(Object(o.f)(t, a.error))
				}, k = Object(r.a)(_.c), N = Object(r.a)(_.b), L = Object(r.a)(_.a), M = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					n(k({
						subredditId: e
					}));
					const i = Object(g.S)(r(), {
							subredditId: e
						}).name,
						c = await b(o(), i, t);
					if (c.ok) {
						const t = c.body;
						n(N({
							subredditId: e,
							widgets: t
						}))
					} else n(L({
						subredditId: e,
						error: c.error
					}))
				}, U = (e, t) => async (n, r, s) => {
					let {
						apiContext: o
					} = s;
					const i = Object(g.S)(r(), {
							subredditId: e
						}).name,
						c = await b(o(), i, !0);
					if (c.ok) return c.body.items[t]
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			}));
			const r = "WIKI_BANNED_CONTRIBUTORS_PENDING",
				s = "WIKI_BANNED_CONTRIBUTORS_LOADED",
				o = "WIKI_BANNED_CONTRIBUTORS_FAILED",
				i = "MORE_WIKI_BANNED_CONTRIBUTORS_LOADED",
				c = "WIKI_BANNED_CONTRIBUTOR_ADDED",
				a = "WIKI_BANNED_CONTRIBUTOR_REMOVED",
				d = "WIKI_BANNED_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			}));
			const r = "WIKI_CONTRIBUTORS_PENDING",
				s = "WIKI_CONTRIBUTORS_LOADED",
				o = "WIKI_CONTRIBUTORS_FAILED",
				i = "MORE_WIKI_CONTRIBUTORS_LOADED",
				c = "WIKI_CONTRIBUTOR_ADDED",
				a = "WIKI_CONTRIBUTOR_REMOVED",
				d = "WIKI_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiDiff/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = "WIKI_DIFF_PENDING",
				s = "WIKI_DIFF_LOADED",
				o = "WIKI_DIFF_FAILED"
		},
		"./src/reddit/actions/wiki/wikiEditing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = "WIKI_PAGE_SAVE_SUCCESS"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			const r = "PAGE__SUBREDDIT_WIKI_PAGE_SETTINGS_LOADED",
				s = "SUBREDDIT_WIKI_PAGE_SETTINGS_UPDATED",
				o = "SUBREDDIT_WIKI_PAGE_CONTRIBUTOR_REOVED",
				i = "SUBREDDIT_WIKI_PAGE_MORE_CONTRIBUTORS_LOADED"
		},
		"./src/reddit/actions/wiki/wikiRevisions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			}));
			const r = "WIKI_REVISIONS_PENDING",
				s = "WIKI_REVISIONS_LOADED",
				o = "WIKI_REVISIONS_FAILED",
				i = "WIKI_PAGE_REVERT_SUCCESS",
				c = "WIKI_REVISION_TOGGLE_VISIBILITY"
		},
		"./src/reddit/components/Comments/helpers/hiddenComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			let r = {};

			function s(e) {
				return e in r
			}

			function o(e) {
				r[e] = !0
			}

			function i() {
				r = {}
			}
		},
		"./src/reddit/components/ContentGate/index.m.less": function(e, t, n) {
			e.exports = {
				ButtonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				buttonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				Container: "_32zGs4bO3IunZfS9bSJY0_",
				container: "_32zGs4bO3IunZfS9bSJY0_",
				Description: "_3VTI5BOpJO70xoBKSqz3O9",
				description: "_3VTI5BOpJO70xoBKSqz3O9",
				PrivateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				privateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				PrivateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				privateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				PrivateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				privateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				Link: "o4oSRcSrppMzf__hxJKxn",
				link: "o4oSRcSrppMzf__hxJKxn",
				LinkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				linkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				LinkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				linkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				SecondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				secondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				SecondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				secondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				GoHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				goHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				Image: "_1jefpljVGT-eHObg40F8Dm",
				image: "_1jefpljVGT-eHObg40F8Dm",
				ImagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				imagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				LeftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				leftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				LeftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				leftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				SecondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				secondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				SecondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				secondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				Title: "_2XKLlvmuqdor3RvVbYZfgz",
				title: "_2XKLlvmuqdor3RvVbYZfgz",
				PageBody: "bDDEX4BSkswHAG_45VkFB",
				pageBody: "bDDEX4BSkswHAG_45VkFB",
				QuarantineMessageWrapper: "_3wi4h3DGgmtUEzxlHDUM0n",
				quarantineMessageWrapper: "_3wi4h3DGgmtUEzxlHDUM0n"
			}
		},
		"./src/reddit/components/ContentGate/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./node_modules/react/index.js"),
				o = n.n(s),
				i = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/react-router/esm/react-router.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/app/strings/index.ts"),
				u = n("./src/lib/loginHref/index.ts"),
				l = n("./src/reddit/actions/contentGate.ts"),
				b = n("./src/reddit/actions/preferences.ts"),
				p = n("./src/reddit/components/CreateCommunityButton/index.tsx"),
				m = n("./src/lib/lessComponent.tsx"),
				f = n("./src/reddit/i18n/components.tsx"),
				g = n("./src/reddit/components/Footer/index.m.less"),
				O = n.n(g);
			const h = m.a.div("FooterContainer", O.a),
				y = m.a.div("UserAgreement", O.a),
				j = m.a.a("UserAgreementLink", O.a),
				_ = m.a.a("PrivacyLink", O.a),
				E = Object(a.c)({
					language: e => e.user.language
				});
			var v = Object(i.b)(E)(e => {
					const {
						language: t
					} = e;
					return o.a.createElement(h, null, o.a.createElement(y, null, o.a.createElement(f.c, null, "Use of this site constitutes acceptance of our "), o.a.createElement(j, {
						href: "".concat(r.a.redditUrl, "/help/useragreement")
					}, o.a.createElement(f.c, null, "User Agreement")), o.a.createElement(f.c, null, " and  "), o.a.createElement(_, {
						href: "".concat(r.a.redditUrl, "/help/privacypolicy")
					}, o.a.createElement(f.c, null, "Privacy Policy")), Object(d.a)(t, "footer.legalbottom.part3", {
						year: (new Date).getFullYear()
					})))
				}),
				I = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				S = n("./src/reddit/components/RichTextJson/index.tsx"),
				T = (n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/lodash/flatMap.js")),
				x = n.n(T),
				C = n("./src/lib/linkMatchers/index.ts"),
				w = n("./src/reddit/controls/OutboundLink/index.tsx");
			const P = /\[(.+?)\]\((.+?)\)/g,
				D = e => {
					const t = e.split(P);
					if (1 === t.length) return [e];
					const n = [];
					for (let r = 0; r < t.length; r += 3) {
						const [e, s, o] = t.slice(r, r + 3);
						n.push(e), n.push([o, s])
					}
					return n
				};
			var R = o.a.memo(e => {
					let t = [e.text];
					return e.parseMdLinks && (t = x()(t, D)), e.parseRegularLinks && (t = x()(t, e => Array.isArray(e) ? [e] : (e => {
						const t = C.e.match(e);
						if (!t) return [e];
						const n = [];
						let r = null;
						for (const s of t) n.push(e.slice(r ? r.lastIndex : 0, s.index)), r = s, n.push([s.url, s.text]);
						return r && n.push(e.slice(r.lastIndex)), n
					})(e))), o.a.createElement(o.a.Fragment, null, " ", t.map((t, n) => {
						if (Array.isArray(t)) {
							const [r, s] = t;
							return o.a.createElement(w.a, {
								className: e.linkClassName,
								href: r,
								isSponsored: !1,
								key: n,
								source: null
							}, s)
						}
						return o.a.createElement("span", {
							key: n
						}, t)
					}), " ")
				}),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				k = n("./src/reddit/controls/Button/index.tsx"),
				N = n("./src/reddit/selectors/meta.ts"),
				L = n("./src/reddit/selectors/user.ts"),
				M = n("./src/reddit/components/ContentGate/index.m.less"),
				U = n.n(M);
			n.d(t, "a", (function() {
				return ce
			}));
			const {
				fbt: F
			} = n("./node_modules/fbt/lib/FbtPublic.js"), B = m.a.div("ButtonsContainer", U.a), G = m.a.div("Container", U.a), V = m.a.div("Description", U.a), q = m.a.div("PrivateSubredditDetails", U.a), H = m.a.div("PrivateSubredditDescription", U.a), K = m.a.h3("PrivateSubredditName", U.a), W = m.a.a("Link", U.a), Y = m.a.wrapped(k.h, "LinkRouterButton", U.a), z = m.a.wrapped(k.g, "LinkButton", U.a), J = m.a.wrapped(k.k, "SecondaryLinkRouterButton", U.a), Q = m.a.wrapped(k.j, "SecondaryLinkButton", U.a), X = m.a.wrapped(Y, "GoHomeLinkButton", U.a), Z = m.a.img("Image", U.a), $ = m.a.img("ImagePlaceholder", U.a), ee = m.a.wrapped(Y, "LeftLinkRouterButton", U.a), te = m.a.wrapped(z, "LeftLinkButton", U.a), ne = m.a.wrapped(Q, "SecondaryLeftLinkButton", U.a), re = m.a.wrapped(J, "SecondaryLeftLinkRouterButton", U.a), se = m.a.h3("Title", U.a), oe = m.a.div("PageBody", U.a), ie = m.a.div("QuarantineMessageWrapper", U.a);
			var ce;
			! function(e) {
				e.CustomFeedDoesNotExist = "CustomFeedDoesNotExist", e.GoldSubreddit = "GoldSubreddit", e.Nsfw = "Nsfw", e.NsfwCustomFeed = "NsfwCustomFeed", e.PrivateSubreddit = "PrivateSubreddit", e.ProfileDoesNotExist = "ProfileDoesNotExist", e.ProfileDeleted = "ProfileDeleted", e.ProfileSuspended = "ProfileSuspended", e.QuarantinedSubreddit = "QuarantinedSubreddit", e.SubredditBanned = "SubredditBanned", e.SubredditDoesNotExist = "SubredditDoesNotExist"
			}(ce || (ce = {}));
			const ae = Object(a.c)({
					language: L.T,
					origin: N.g,
					user: L.i
				}),
				de = Object(A.t)(),
				ue = Object(i.b)(ae, (e, t) => {
					let {
						subredditName: n
					} = t;
					return {
						continueToQuarantinedSubreddit: async () => {
							await e(b.A(n)), window.location.reload()
						},
						setCookieAndRedirect: async () => {
							await e(l.i()), window.location.reload()
						}
					}
				}),
				le = e => {
					const {
						banMessage: t,
						contentGateType: n,
						continueToQuarantinedSubreddit: s,
						language: i,
						location: c,
						origin: a,
						pageLayer: l,
						quarantineRequiresEmail: b,
						quarantineMessage: m,
						quarantineMessageHtml: g,
						quarantineMessageRTJson: O,
						setCookieAndRedirect: h,
						subredditDescription: y,
						subredditName: j,
						user: _
					} = e;
					switch (n) {
						case ce.GoldSubreddit:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/gold/premium-crest.png")
							}), o.a.createElement(se, null, Object(d.a)(i, "contentGate.goldSubreddit.titlePremium", {
								subredditName: j
							})), o.a.createElement(V, null, o.a.createElement(f.c, null, "The moderators in this community have set it to Reddit Premium members only. You must upgrade to a Reddit Premium membership to continue.")), o.a.createElement(B, null, _ ? o.a.createElement(ne, {
								href: "".concat(r.a.redditUrl, "/premium")
							}, o.a.createElement(f.c, null, "Get Premium")) : o.a.createElement(te, {
								href: Object(u.a)(c, a)
							}, o.a.createElement(f.c, null, "Sign Up")), _ ? o.a.createElement(Y, {
								to: "/"
							}, o.a.createElement(f.c, null, "Go Home")) : o.a.createElement(Q, {
								href: Object(u.a)(c, a)
							}, o.a.createElement(f.c, null, "Log In"))));
						case ce.Nsfw:
						case ce.NsfwCustomFeed:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/content-gate-icons/nsfw.png")
							}), o.a.createElement(se, null, n === ce.Nsfw ? Object(d.a)(i, "contentGate.over18.title") : o.a.createElement(f.c, null, "You must be 18+ to view this Custom Feed")), o.a.createElement(V, null, o.a.createElement(f.c, null, "You must be at least eighteen years old to view this content. Are you over eighteen and willing to see adult content?")), o.a.createElement(B, null, o.a.createElement(ee, {
								to: "/"
							}, o.a.createElement(f.c, null, "No")), o.a.createElement(Q, {
								onClick: h
							}, o.a.createElement(f.c, null, "Yes"))));
						case ce.PrivateSubreddit:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/content-gate-icons/private.png")
							}), o.a.createElement(se, null, Object(d.a)(i, "contentGate.privateSubreddit.title", {
								subredditName: j
							})), y && y.length && o.a.createElement(q, null, o.a.createElement(K, null, "r/", j), o.a.createElement(H, null, o.a.createElement("div", null, y))), o.a.createElement(V, null, o.a.createElement(f.c, null, "The moderators in this community have set it to private. You must be a moderator or approved user to visit.")), o.a.createElement(B, null, _ ? o.a.createElement(ne, {
								href: "".concat(r.a.redditUrl, "/message/compose?to=/r/").concat(j)
							}, o.a.createElement(f.c, null, "Message Mods")) : o.a.createElement(ne, {
								href: Object(u.a)(c, a)
							}, o.a.createElement(f.c, null, "Sign Up")), o.a.createElement(Y, {
								to: "/"
							}, _ ? Object(d.a)(i, "contentGate.privateSubreddit.goHome") : Object(d.a)(i, "contentGate.privateSubreddit.exploreReddit"))));
						case ce.QuarantinedSubreddit:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/content-gate-icons/quarantined.png")
							}), o.a.createElement(se, null, o.a.createElement(f.c, null, "Are you sure you want to view this community?")), o.a.createElement(V, null, o.a.createElement(f.c, null, "This community is"), " ", o.a.createElement(W, {
								href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/quarantined-subreddits"
							}, o.a.createElement(f.c, null, "quarantined")), o.a.createElement(ie, null, O ? o.a.createElement(S.a, {
								content: O,
								rtJsonElementProps: {
									pageLayer: l
								}
							}) : g ? o.a.createElement(I.a, {
								html: g
							}) : m || F._("Quarantined communities are dedicated to shocking or highly offensive content. You must be logged in with a verified email to continue.", null, {
								hk: "3kRIzE"
							})), o.a.createElement(f.c, null, "Are you certain you want to continue?")), o.a.createElement(B, null, ((e, t, n, s) => {
								return !(e && e.hasVerifiedEmail) && s ? o.a.createElement(B, null, o.a.createElement(re, {
									to: "/"
								}, o.a.createElement(f.c, null, "No Thank You")), o.a.createElement(z, {
									href: "".concat(r.a.redditUrl, "/prefs/update")
								}, o.a.createElement(f.c, null, "Verify Email"))) : o.a.createElement(B, null, o.a.createElement(ee, {
									to: "/"
								}, o.a.createElement(f.c, null, "No Thank You")), o.a.createElement(Q, {
									onClick: n
								}, o.a.createElement(f.c, null, "Continue")))
							})(_, 0, s, b)));
						case ce.SubredditBanned:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/content-gate-icons/banned.png")
							}), o.a.createElement(se, null, Object(d.a)(i, "contentGate.subredditBanned.title", {
								subredditName: j
							})), (e => o.a.createElement(V, null, e ? o.a.createElement(R, {
								linkClassName: U.a.Link,
								text: e,
								parseMdLinks: !0,
								parseRegularLinks: !0
							}) : o.a.createElement(f.c, null, "This community has been banned for violating the Reddit rules.")))(t), o.a.createElement(B, null, o.a.createElement(Y, {
								to: "/"
							}, o.a.createElement(f.c, null, "Explore Reddit"))));
						case ce.SubredditDoesNotExist:
							return o.a.createElement("div", null, o.a.createElement($, null), o.a.createElement(se, null, F._("Sorry, there arent any communities on Reddit with that name.", null, {
								hk: "31DRpe"
							})), o.a.createElement(V, null, F._("This community may have been banned or the community name is incorrect.", null, {
								hk: "1lYMG2"
							})), o.a.createElement(B, null, _ && o.a.createElement(p.a, {
								eventSource: "content_gate"
							}), o.a.createElement(X, {
								to: "/"
							}, o.a.createElement(f.c, null, "Go Home"))));
						case ce.ProfileDoesNotExist:
						case ce.ProfileDeleted:
						case ce.ProfileSuspended:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/snoomoji/snoo_thoughtful.png")
							}), o.a.createElement(se, null, (e => {
								const {
									contentGateType: t
								} = e;
								switch (t) {
									case ce.ProfileDeleted:
										return o.a.createElement(f.c, null, "This user has deleted their account.");
									case ce.ProfileSuspended:
										return o.a.createElement(o.a.Fragment, null, o.a.createElement(f.c, null, "This account has been"), " ", o.a.createElement(W, {
											href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/suspensions"
										}, o.a.createElement(f.c, null, "suspended")), ".");
									case ce.ProfileDoesNotExist:
										return o.a.createElement(o.a.Fragment, null, o.a.createElement(se, null, F._("Sorry, nobody on Reddit goes by that name.", null, {
											hk: "3i02av"
										})), o.a.createElement(V, null, F._("The person may have been banned or the username is incorrect.", null, {
											hk: "36ab4J"
										})))
								}
							})(e)), o.a.createElement(B, null, o.a.createElement(X, {
								to: "/"
							}, o.a.createElement(f.c, null, "Go Home"))));
						case ce.CustomFeedDoesNotExist:
							return o.a.createElement("div", null, o.a.createElement(Z, {
								src: "".concat(r.a.assetPath, "/img/snoomoji/snoo_thoughtful.png")
							}), o.a.createElement(se, null, o.a.createElement(f.c, null, "Sorry, this custom feed is private or does not exist.")), o.a.createElement(B, null, o.a.createElement(X, {
								to: "/"
							}, o.a.createElement(f.c, null, "Go Home"))))
					}
				};
			t.b = de(ue(Object(c.i)(e => o.a.createElement(G, null, o.a.createElement("div", null, o.a.createElement(oe, null, le(e))), o.a.createElement(v, null)))))
		},
		"./src/reddit/components/CreateCommunityButton/index.m.less": function(e, t, n) {
			e.exports = {
				SecondaryButton: "_3U-J6NPoBHbyibarrb7T3F",
				secondaryButton: "_3U-J6NPoBHbyibarrb7T3F",
				StyledTooltip: "FIYolDqalszTnjjNfThfT",
				styledTooltip: "FIYolDqalszTnjjNfThfT"
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/actions/tooltip.ts"),
				a = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/helpers/overlay/index.ts"),
				b = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				p = n("./src/reddit/i18n/components.tsx"),
				m = n("./src/reddit/i18n/utils.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/components/CreateCommunityButton/index.m.less"),
				O = n.n(g),
				h = n("./src/lib/lessComponent.tsx");
			const y = "create-community-button",
				j = h.a.wrapped(u.i, "SecondaryButton", O.a),
				_ = h.a.wrapped(a.c, "StyledTooltip", O.a),
				E = Object(i.c)({
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(f.eb)(e),
					userIsSuspended: f.P
				});
			t.a = Object(o.b)(E, (e, t) => {
				let {
					eventSource: n
				} = t;
				return {
					openCommunityCreation: t => {
						t(Object(b.b)(n)), e(Object(l.a)("/subreddits/create"))
					},
					onShowTooltip: () => e(Object(c.f)({
						tooltipId: y
					})),
					onHideTooltip: () => e(Object(c.h)())
				}
			})(Object(d.b)(e => {
				let {
					className: t,
					eventSource: n,
					onShowTooltip: r,
					onHideTooltip: o,
					openCommunityCreation: i,
					sendEvent: c,
					userDoesNotHaveEnoughExpToCreateCommunity: a,
					userIsSuspended: d
				} = e;
				return s.a.createElement(j, {
					className: t,
					disabled: d || a,
					onClick: () => i(c),
					onMouseEnter: r,
					onMouseLeave: o,
					id: y
				}, s.a.createElement(p.c, null, "Create Community"), a ? s.a.createElement(_, {
					caretOnTop: !0,
					tooltipId: y,
					text: Object(m.c)("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.")
				}) : d ? s.a.createElement(_, {
					caretOnTop: !0,
					tooltipId: y,
					text: Object(m.c)("Accounts banned from the site can not create communities until the ban is lifted.")
				}) : null)
			}))
		},
		"./src/reddit/components/Flatlist/getFlatlistTooltipId.ts": function(e, t, n) {
			"use strict";
			t.a = (e, t, n) => {
				const r = "".concat(e, "--").concat(t);
				return n ? "".concat(r, "--").concat(n) : r
			}
		},
		"./src/reddit/components/Footer/index.m.less": function(e, t, n) {
			e.exports = {
				FooterContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				footerContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				UserAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				userAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				UserAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				userAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				PrivacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				privacyLink: "_2mk2nvnRu7inPdJY2i-H79"
			}
		},
		"./src/reddit/components/GildModal/getGildModalId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			}));
			const r = (e, t) => {
				const n = "".concat("GILD_MODAL_ID", "-[thingId: ").concat(e, "]");
				return void 0 !== t ? n + "-isOverlay[".concat(t, "]") : n
			};
			t.a = r
		},
		"./src/reddit/components/HTML5StreamPlayer/BlurImage/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_1chxf6wi6yizUXVYKuz67P",
				component: "_1chxf6wi6yizUXVYKuz67P"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/ControlBar/index.m.less": function(e, t, n) {
			e.exports = {
				baseControlStyles: "_2rtFq5-gNnsnqTzEcTSmVx",
				TooltipControl: "_1mDDkogVo82R5-IFxvyPRX",
				tooltipControl: "_1mDDkogVo82R5-IFxvyPRX",
				NormalControl: "_3MU1RfVON0x2Jtnz9Zq3FA",
				normalControl: "_3MU1RfVON0x2Jtnz9Zq3FA",
				baseIconStyles: "_2c7UOdkceyJz77qZPoGPAL",
				ControlSnoo: "_2Zt53GmI1y_S0N7pA0jMc0",
				controlSnoo: "_2Zt53GmI1y_S0N7pA0jMc0",
				ControlPlay: "fqsG3oqeIwcEC-HTRf23d",
				controlPlay: "fqsG3oqeIwcEC-HTRf23d",
				ControlVolume: "_2W9KLflUho3xU7KURAaHwH",
				controlVolume: "_2W9KLflUho3xU7KURAaHwH",
				AnimatedSettingIconParent: "_3KjMjt45Pg4_LoShJNFMEf",
				animatedSettingIconParent: "_3KjMjt45Pg4_LoShJNFMEf",
				ControlExpand: "_3ly5pJnuzH6jga1JGXpOXD",
				controlExpand: "_3ly5pJnuzH6jga1JGXpOXD",
				ControlCollapse: "_3uhleNVV7YkJm0tszcz4z9",
				controlCollapse: "_3uhleNVV7YkJm0tszcz4z9",
				Time: "_1z-qg2gzYKkI37gkYYJCi0",
				time: "_1z-qg2gzYKkI37gkYYJCi0",
				LeftTime: "_3-_K1uspRApIM1_dkDMKnM",
				leftTime: "_3-_K1uspRApIM1_dkDMKnM",
				RightTime: "_1HVKaY4Y3yukzOicpaGXLB",
				rightTime: "_1HVKaY4Y3yukzOicpaGXLB",
				LiveLabel: "_1s8L9kNAgwvsmhnrpHl4Ef",
				liveLabel: "_1s8L9kNAgwvsmhnrpHl4Ef",
				ControlScrubber: "_3YQsKErciDXsBNWhb0bzul",
				controlScrubber: "_3YQsKErciDXsBNWhb0bzul",
				VolumeControl: "_3nTkqMMtsoqxVmhplDRef3",
				volumeControl: "_3nTkqMMtsoqxVmhplDRef3",
				SettingIcon: "X3KvZpgZg_2f0etJY2Ba7",
				settingIcon: "X3KvZpgZg_2f0etJY2Ba7",
				VideoSettingContainer: "_1s7GuSZPqjgn0QP60a6asr",
				videoSettingContainer: "_1s7GuSZPqjgn0QP60a6asr",
				ControlBarContainer: "gUpEQXQu8G8UvISmBIPsj",
				controlBarContainer: "gUpEQXQu8G8UvISmBIPsj",
				mIsFullScreen: "IlN7iDYa9yzeFlgOo0JQe",
				mHasZeroOpacity: "_1RZSSlyqzokrcxh0ESwE2e"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/ControlBar/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				o = n.n(s),
				i = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				d = e => o.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, o.a.createElement("path", {
					d: "M14.41,13H17a1,1,0,0,0,0-2H12a1,1,0,0,0-1,1v5a1,1,0,0,0,2,0V14.41l3.24,3.24a1,1,0,0,0,1.41-1.41Z",
					fill: "#FFFFFF"
				}), o.a.createElement("path", {
					d: "M8,2A1,1,0,0,0,7,3V5.59L3.76,2.34A1,1,0,0,0,2.34,3.76L5.59,7H3A1,1,0,0,0,3,9H8A1,1,0,0,0,9,8V3A1,1,0,0,0,8,2Z",
					fill: "#FFFFFF"
				})),
				u = e => o.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, o.a.createElement("path", {
					d: "M9,3A1,1,0,0,0,8,2H3A1,1,0,0,0,2,3V8A1,1,0,0,0,4,8V5.41L7.24,8.66A1,1,0,0,0,8.66,7.24L5.41,4H8A1,1,0,0,0,9,3Z",
					fill: "#FFFFFF"
				}), o.a.createElement("path", {
					d: "M17,11a1,1,0,0,0-1,1v2.59l-3.24-3.24a1,1,0,0,0-1.41,1.41L14.59,16H12a1,1,0,0,0,0,2h5a1,1,0,0,0,1-1V12A1,1,0,0,0,17,11Z",
					fill: "#FFFFFF"
				})),
				l = n("./src/reddit/icons/svgs/VideoMute/index.tsx"),
				b = e => o.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, o.a.createElement("rect", {
					x: "11",
					y: "2",
					width: "6",
					height: "16",
					rx: "1",
					ry: "1",
					fill: "#FFFFFF"
				}), o.a.createElement("rect", {
					x: "3",
					y: "2",
					width: "6",
					height: "16",
					rx: "1",
					ry: "1",
					fill: "#FFFFFF"
				})),
				p = e => o.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, o.a.createElement("path", {
					d: "M18.5,9.14l-12-7A1,1,0,0,0,5,3V17a1,1,0,0,0,1.5.86l12-7a1,1,0,0,0,0-1.73Z",
					fill: "#FFFFFF"
				})),
				m = n("./src/reddit/icons/svgs/VideoVolume/index.tsx"),
				f = n("./src/reddit/components/HTML5StreamPlayer/ControlGradient/index.m.less"),
				g = n.n(f),
				O = c.a.div("Component", g.a),
				h = n("./node_modules/lodash/clamp.js"),
				y = n.n(h),
				j = n("./node_modules/react-dom/index.js"),
				_ = n.n(j),
				E = n("./src/lib/fastdom/index.ts");
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			const v = e => {
					const t = Math.floor(e / 60).toString();
					let n = Math.trunc(e % 60).toString();
					return n = "0".concat(n).slice(-2), "".concat(t, ":").concat(n)
				},
				I = (e, t) => {
					let n = Math.floor(e / 60).toString(),
						r = Math.trunc(e % 60).toString();
					const s = Math.floor(t / 60).toString();
					return n.length < s.length && (n = "0".concat(n).slice(-2)), r = "0".concat(r).slice(-2), "".concat(n, ":").concat(r)
				};
			var S = n("./src/reddit/constants/keycodes.ts"),
				T = n("./src/reddit/components/HTML5StreamPlayer/SeekBar/index.m.less"),
				x = n.n(T);
			const C = c.a.div("Thumb", x.a),
				w = c.a.div("ProgressBar", x.a),
				P = c.a.div("Floating", x.a),
				D = c.a.video("PreviewVideo", x.a),
				R = c.a.div("PreviewTime", x.a),
				A = c.a.div("VideoSeekbar", x.a);
			class k extends o.a.PureComponent {
				constructor(e) {
					super(e), this.setParentRect = e => this.parentRect = e, this.setPreviewThumbnailContainer = e => this.previewThumbnailContainer = e, this.setPreviewThumbnailVideo = e => this.previewThumbnailVideo = e, this.setPreviewThumbnailTime = e => this.previewThumbnailTime = e, this.setProgressBar = e => this.progressBar = e, this.handleMouseDown = e => {
						if (0 === e.button && this.parentRect) {
							const t = this.parentRect.getBoundingClientRect();
							let n = (e.clientX - t.left) / t.width * 100;
							n = Math.min(Math.max(n, 0), 100), this.setProgress(n, !0)
						}
					}, this.handleMouseMove = e => {
						if (e.stopPropagation(), this.parentRect) {
							const t = this.parentRect.getBoundingClientRect();
							let n = (e.clientX - t.left) / t.width * 100;
							n = Math.min(Math.max(n, 0), 100), this.setLookahead(n), this.props.active && this.setProgress(n, !0)
						}
					}, this.handleMouseUp = e => {
						if (this.props.active) {
							const e = this.state.progressPercent * this.props.totalTime / 100;
							this.props.updatePosition(e), this.progressBar && this.progressThumb && (this.progressBar.style.width = null, this.progressThumb.style.marginLeft = null)
						}
					}, this.handleMouseLeave = e => {
						this.setLookahead(0)
					}, this.handleKeyDown = e => {
						switch (e.key) {
							case S.b.ArrowRight:
								return void this.jumpPlayback(5);
							case S.b.ArrowLeft:
								return void this.jumpPlayback(-5);
							case S.b.Space:
								return this.props.playPauseVideo(), void e.preventDefault()
						}
					}, this.setProgressThumbRef = e => {
						this.progressThumb = e, e && E.a.read(() => {
							const t = e.getBoundingClientRect().width / 2;
							E.a.write(() => {
								this.setState({
									thumbOffset: t
								})
							})
						})
					}, this.state = {
						thumbMargin: "",
						thumbOffset: null,
						isMouseDown: !1,
						progressPercent: 0,
						percent: 0
					}
				}
				jumpPlayback(e) {
					const {
						currentTime: t,
						totalTime: n
					} = this.props, r = y()(t + e, 0, n);
					r !== t && this.props.updatePosition(r)
				}
				getCurrentPercent() {
					const {
						currentTime: e,
						totalTime: t
					} = this.props;
					return e && t ? 100 * e / t : 0
				}
				setProgress(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					this.progressBar && this.progressThumb && (!this.props.active || t) && (this.progressBar.style.width = "calc(" + e + "% + " + this.state.thumbOffset + "px)", this.progressThumb.style.marginLeft = "calc(" + e + "% - " + this.state.thumbOffset + "px)", this.setState({
						progressPercent: e
					}), this.props.updateContinuousStartTime && this.props.updateContinuousStartTime(1e3 * this.props.currentTime))
				}
				getThumbMargin(e) {
					return this.props.active && this.progressThumb ? this.progressThumb.style.marginLeft || "0" : "calc(".concat(e, "% - ").concat(this.state.thumbOffset || 0, "px)")
				}
				getProgressWidth(e) {
					return this.props.active && this.progressBar ? this.progressBar.style.width : "".concat(e, "%")
				}
				setLookahead(e) {
					if (this.lookaheadBar && this.previewThumbnailContainer && this.previewThumbnailTime && this.parentRect) {
						this.lookaheadBar.style.width = e + "%";
						const {
							totalTime: t
						} = this.props, n = t * (e / 100);
						isNaN(n) || (this.previewThumbnailVideo && (this.previewThumbnailVideo.currentTime = n), this.previewThumbnailTime.innerHTML = I(n, t));
						const r = _.a.findDOMNode(this);
						if (!r || !r.parentNode) return;
						const s = r.parentNode;
						if (!(s instanceof Element)) return;
						const o = s.getBoundingClientRect(),
							i = this.parentRect.getBoundingClientRect(),
							c = this.previewThumbnailContainer.getBoundingClientRect(),
							a = o.left - i.left,
							d = o.right - i.left - c.width,
							u = e / 100 * i.width - c.width / 2;
						this.previewThumbnailContainer.style.left = Math.max(a, Math.min(u, d)) + "px"
					}
				}
				getBufferedStyle() {
					const {
						bufferedRanges: e
					} = this.props, {
						progressPercent: t
					} = this.state, n = this.getCurrentPercent();
					let r = t;
					for (let s = 0; s < e.length; s++) e[s].start <= n && (r = e[s].end);
					return r = y()(r, 0, 100), {
						width: "".concat(r, "%")
					}
				}
				render() {
					const {
						active: e
					} = this.props, {
						progressPercent: t
					} = this.state, n = this.getCurrentPercent();
					let s = e ? t : n;
					s = y()(s, 0, 100);
					const c = {
							width: this.getProgressWidth(s) || "0"
						},
						a = {
							marginLeft: this.getThumbMargin(s),
							opacity: e ? 1 : 0
						};
					return o.a.createElement(A, {
						innerRef: this.setParentRect,
						onKeyDown: this.handleKeyDown,
						onMouseLeave: this.handleMouseLeave,
						onMouseMove: this.handleMouseMove
					}, o.a.createElement("div", {
						"aria-label": r.fbt._("Seek Slider", null, {
							hk: "1fNTBw"
						}),
						"aria-valuemax": Math.round(this.props.totalTime),
						"aria-valuemin": 0,
						"aria-valuenow": this.props.currentTime,
						className: x.a.Mainbar,
						role: "slider",
						tabIndex: 0
					}, o.a.createElement("div", {
						className: Object(i.a)(x.a.Bar, x.a.Background)
					}), o.a.createElement("div", {
						className: Object(i.a)(x.a.Bar, x.a.Lookahead),
						ref: e => this.lookaheadBar = e
					}), o.a.createElement("div", {
						className: Object(i.a)(x.a.Bar, x.a.Buffered),
						style: this.getBufferedStyle()
					}), o.a.createElement(w, {
						className: this.props.isLive && x.a.Live,
						innerRef: this.setProgressBar,
						style: c
					})), o.a.createElement(C, {
						className: this.props.isLive && x.a.Live,
						innerRef: this.setProgressThumbRef,
						style: a
					}), !this.props.controlBarIsHidden && o.a.createElement(P, {
						innerRef: this.setPreviewThumbnailContainer
					}, this.props.thumbSource && o.a.createElement(D, {
						innerRef: this.setPreviewThumbnailVideo,
						src: this.props.thumbSource
					}), o.a.createElement(R, {
						innerRef: this.setPreviewThumbnailTime
					})))
				}
			}
			var N = n("./node_modules/react-router-dom/esm/react-router-dom.js");
			var L = e => o.a.createElement("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					width: "16px",
					height: "16px",
					viewBox: "0 0 20 20"
				}, o.a.createElement("g", {
					fill: "none",
					fillRule: "evenodd"
				}, o.a.createElement("polygon", {
					points: "0 20 20 20 20 0 0 0"
				}), o.a.createElement("path", {
					fill: "#FFF",
					d: "M13.43,13.02125 C12.5683333,13.02125 11.8675,12.3204167 11.8675,11.45875 C11.8675,10.5970833 12.5683333,9.89583333 13.43,9.89583333 C14.2916667,9.89583333 14.9925,10.5970833 14.9925,11.45875 C14.9925,12.3204167 14.2916667,13.02125 13.43,13.02125 M13.705,15.5875 C12.63875,16.6525 10.595,16.735 9.99416667,16.735 C9.39333333,16.735 7.34958333,16.6525 6.28458333,15.5870833 C6.12625,15.4291667 6.12625,15.1725 6.28458333,15.0145833 C6.4425,14.8566667 6.69916667,14.85625 6.85708333,15.0145833 C7.52916667,15.6866667 8.96708333,15.9254167 9.99416667,15.9254167 C11.02125,15.9254167 12.4595833,15.6866667 13.1329167,15.0141667 C13.29125,14.85625 13.5475,14.8566667 13.7054167,15.0145833 C13.8633333,15.1729167 13.8633333,15.4291667 13.705,15.5875 M4.9925,11.45875 C4.9925,10.5970833 5.69375,9.89583333 6.55583333,9.89583333 C7.41666667,9.89583333 8.1175,10.5970833 8.1175,11.45875 C8.1175,12.32 7.41666667,13.0208333 6.55583333,13.0208333 C5.69375,13.0208333 4.9925,12.32 4.9925,11.45875 M19.99,9.89583333 C19.99,8.68791667 19.0108333,7.70833333 17.8025,7.70833333 C17.2129167,7.70833333 16.67875,7.94291667 16.2854167,8.32208333 C14.79,7.24333333 12.73,6.54625 10.4354167,6.46625 L11.4316667,1.77833333 L14.6875,2.47041667 C14.7270833,3.29791667 15.405,3.95833333 16.2425,3.95833333 C17.1054167,3.95833333 17.805,3.25875 17.805,2.39583333 C17.805,1.53291667 17.1054167,0.833333333 16.2425,0.833333333 C15.62875,0.833333333 15.1029167,1.19083333 14.8475,1.70541667 L11.2120833,0.932916667 C11.1108333,0.910833333 11.005,0.930833333 10.9183333,0.987083333 C10.83125,1.04375 10.7704167,1.1325 10.74875,1.23375 L9.65541667,6.37791667 C9.64916667,6.4075 9.65416667,6.43541667 9.65458333,6.46458333 C7.31875,6.52583333 5.21875,7.22458333 3.7,8.31833333 C3.30708333,7.94125 2.775,7.70833333 2.1875,7.70833333 C0.979166667,7.70833333 0,8.68791667 0,9.89583333 C0,10.785 0.530833333,11.5483333 1.29208333,11.8904167 C1.25833333,12.1079167 1.24,12.32875 1.24,12.5520833 C1.24,15.9179167 5.1575,18.6458333 9.99,18.6458333 C14.8225,18.6458333 18.74,15.9179167 18.74,12.5520833 C18.74,12.33 18.7220833,12.1108333 18.68875,11.895 C19.455,11.5545833 19.99,10.7883333 19.99,9.89583333"
				}))),
				M = n("./src/reddit/components/HTML5StreamPlayer/SnooButton/index.m.less"),
				U = n.n(M);
			var F = c.a.wrapped(e => o.a.createElement("div", {
					className: e.className
				}, "string" == typeof e.postUrl ? o.a.createElement("a", {
					href: e.postUrl
				}, o.a.createElement(L, null)) : o.a.createElement(N.a, {
					to: e.postUrl
				}, o.a.createElement(L, null))), "Component", U.a),
				B = n("./src/reddit/components/HTML5StreamPlayer/Tooltip/index.tsx"),
				G = n("./src/reddit/components/HTML5StreamPlayer/VolumeControl/index.m.less"),
				V = n.n(G);
			class q extends s.Component {
				constructor(e) {
					super(e), this.step = .1, this.max = 1, this.min = 0, this.handleMouseDown = e => {
						if (0 === e.button && this.track) {
							e.preventDefault(), this.setState({
								isMouseDown: !0
							});
							const t = this.track.getBoundingClientRect(),
								n = 100 - (e.clientY - t.top) / t.height * 100,
								r = (this.max - this.min) * (n / 100);
							this.setState({
								value: this.adjustValue(r)
							})
						}
					}, this.handleMouseMove = e => {
						if (this.state.isMouseDown && this.track) {
							const t = this.track.getBoundingClientRect(),
								n = 100 - (e.clientY - t.top) / t.height * 100,
								r = (this.max - this.min) * (n / 100);
							this.setState({
								value: this.adjustValue(r)
							})
						}
					}, this.handleMouseUp = e => {
						this.state.isMouseDown && this.setState({
							isMouseDown: !1
						}), this.props.setVolume(this.state.value, !0)
					}, this.state = {
						isMouseDown: !1,
						value: 0
					}
				}
				convertVolumeToPercent(e) {
					if ("number" != typeof e) return 100;
					const t = y()(e, this.min, this.max);
					let n = 0;
					if (t) {
						n = 20 * Math.log10(t) / 40 + 1
					}
					return this.calculatePercent(n)
				}
				calculatePercent(e) {
					return (e - this.min) / (this.max - this.min) * 100
				}
				adjustValue(e) {
					const t = y()(e, this.min, this.max);
					let n;
					if (1 === t || 0 === t) n = t;
					else {
						const e = 40 * (t - 1);
						n = Math.pow(10, e / 20)
					}
					return this.props.setVolume(n, !1), n
				}
				render() {
					const {
						active: e,
						className: t,
						isLive: n,
						isMuted: r,
						volume: s
					} = this.props, {
						value: c
					} = this.state, a = r ? 0 : e ? c : s, d = this.convertVolumeToPercent(a);
					return o.a.createElement("div", {
						className: Object(i.a)(V.a.VolumeControl, t),
						ref: e => this.container = e
					}, o.a.createElement("div", {
						className: Object(i.a)(V.a.SliderTrack, V.a.SliderBar),
						ref: e => this.track = e
					}, o.a.createElement("div", {
						className: Object(i.a)(V.a.SliderProgress, V.a.SliderBar, {
							[V.a.Live]: n
						}),
						ref: e => this.progress = e,
						style: {
							height: "".concat(d, "%")
						}
					}, o.a.createElement("div", {
						className: V.a.SliderThumb
					}))))
				}
			}
			var H = n("./src/reddit/components/HTML5StreamPlayer/ControlBar/index.m.less"),
				K = n.n(H);

			function W() {
				return (W = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var Y = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const z = c.a.wrapped(B.a, "TooltipControl", K.a),
				J = c.a.div("NormalControl", K.a),
				Q = c.a.wrapped(z, "ControlSnoo", K.a),
				X = c.a.wrapped(z, "ControlPlay", K.a),
				Z = c.a.wrapped(J, "Time", K.a),
				$ = c.a.wrapped(Z, "LeftTime", K.a),
				ee = c.a.wrapped(Z, "RightTime", K.a),
				te = c.a.div("LiveLabel", K.a),
				ne = c.a.wrapped(J, "ControlScrubber", K.a),
				re = c.a.wrapped(J, "ControlVolume", K.a),
				se = c.a.wrapped(z, "ControlExpand", K.a),
				oe = c.a.wrapped(z, "ControlCollapse", K.a),
				ie = e => {
					var {
						className: t,
						isFullScreen: n,
						zeroOpacity: r,
						innerRef: s
					} = e, c = Y(e, ["className", "isFullScreen", "zeroOpacity", "innerRef"]);
					return o.a.createElement("div", W({
						className: Object(i.a)(K.a.ControlBarContainer, t, {
							[K.a.mIsFullScreen]: n,
							[K.a.mHasZeroOpacity]: r
						}),
						ref: s
					}, c))
				};
			class ce extends o.a.Component {
				constructor(e) {
					super(e), this.state = {
						currentTime: e.currentTime,
						totalTime: e.totalTime,
						bufferedRanges: []
					}
				}
				setCurrentTime(e) {
					this.setState({
						currentTime: e
					})
				}
				setTotalTime(e) {
					this.setState({
						totalTime: e
					})
				}
				setBufferedRanges(e) {
					this.setState({
						bufferedRanges: e
					})
				}
				renderContent() {
					const {
						hideFullScreenButton: e,
						hideGradient: t,
						postUrl: n,
						isListing: s,
						isLive: i,
						settingsButton: c,
						settingChange: l,
						showSettingsIcon: m
					} = this.props, f = r.fbt._("View Comments", null, {
						hk: "2Vf8xl"
					}), g = r.fbt._("Play", null, {
						hk: "2cQV3h"
					}), h = r.fbt._("Pause", null, {
						hk: "2YnRgT"
					}), y = r.fbt._("Exit Fullscreen", null, {
						hk: "LnrWa"
					}), j = r.fbt._("Fullscreen", null, {
						hk: "3JvSdn"
					}), {
						currentTime: _
					} = this.state, {
						totalTime: E
					} = i ? this.state : this.props, S = this.props.isPaused ? g : h;
					return o.a.createElement(o.a.Fragment, null, !t && o.a.createElement(O, null), n && s && o.a.createElement(Q, {
						tooltip: f
					}, o.a.createElement("div", {
						onClick: this.props.clickSnoo
					}, o.a.createElement(F, {
						postUrl: n
					}))), o.a.createElement(X, {
						tooltip: S
					}, o.a.createElement("button", {
						"aria-label": S,
						onClick: this.props.playPauseVideo
					}, this.props.isPaused ? o.a.createElement(p, null) : o.a.createElement(b, null))), o.a.createElement($, null, I(_, E)), o.a.createElement(ne, null, o.a.createElement(k, {
						active: l === a.a.SeekBar,
						bufferedRanges: this.state.bufferedRanges,
						controlBarIsHidden: this.props.hideControlBar,
						currentTime: _,
						isLive: i,
						ref: this.props.seekBarRef,
						thumbSource: this.props.scrubberThumbSource,
						totalTime: E,
						playPauseVideo: this.props.playPauseVideo,
						updatePosition: this.props.setVideoPosition,
						updateContinuousStartTime: this.props.updateContinuousStartTime
					})), i ? o.a.createElement(te, {
						"aria-label": r.fbt._("live", null, {
							hk: "1rkHRc"
						}),
						onClick: () => this.props.setVideoPosition(E)
					}, r.fbt._("Live", null, {
						hk: "3bCYlO"
					})) : o.a.createElement(ee, null, v(E)), m && c, !e && (this.props.isFullScreen ? o.a.createElement(oe, {
						tooltip: y
					}, o.a.createElement("button", {
						"aria-label": y,
						onClick: this.props.exitFullScreen
					}, o.a.createElement(d, null))) : o.a.createElement(se, {
						tooltip: j
					}, o.a.createElement("button", {
						"aria-label": j,
						onClick: this.props.enterFullScreen
					}, o.a.createElement(u, null)))))
				}
				render() {
					const {
						controlBarRef: e,
						isLive: t
					} = this.props;
					return o.a.createElement(ie, {
						className: this.props.className,
						innerRef: t => e && e(t),
						isFullScreen: this.props.isFullScreen,
						zeroOpacity: this.props.hideControlBar
					}, this.renderContent(), this.props.hasAudio && o.a.createElement(re, {
						className: this.props.showVolumeIcon ? "disableHide" : ""
					}, o.a.createElement(q, {
						className: K.a.VolumeControl,
						ref: e => this.props.volumeRef(e),
						active: this.props.settingChange === a.a.Volume,
						isMuted: this.props.isMuted,
						isLive: t,
						setVolume: this.props.setVolume,
						volume: this.props.volume
					}), o.a.createElement("button", {
						onClick: this.props.toggleMute
					}, this.props.isMuted ? o.a.createElement(l.a, null) : o.a.createElement(m.a, null))))
				}
			}
			t.a = ce
		},
		"./src/reddit/components/HTML5StreamPlayer/ControlGradient/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_3YDPJHFl8YQG4TIAGQwHwK",
				component: "_3YDPJHFl8YQG4TIAGQwHwK"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/ReplayVideo/index.m.less": function(e, t, n) {
			e.exports = {
				Centered: "_241TIL5Gnyx3yLobU95FlI",
				centered: "_241TIL5Gnyx3yLobU95FlI",
				EndedOverlay: "_3G7xHJZQMrQlpjhNDQI2fe",
				endedOverlay: "_3G7xHJZQMrQlpjhNDQI2fe",
				ReplayText: "qDCxOHuaGNjcgDp5-rvJr",
				replayText: "qDCxOHuaGNjcgDp5-rvJr",
				ReplayButton: "_2KpvSaYm8FNb5KzZzf4-TO",
				replayButton: "_2KpvSaYm8FNb5KzZzf4-TO"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/SeekBar/index.m.less": function(e, t, n) {
			e.exports = {
				Thumb: "_2MDmJfq0z5K-d2xH--GnRU",
				thumb: "_2MDmJfq0z5K-d2xH--GnRU",
				ProgressBar: "_3fnsfWuIyofBJBBCbeOZzM",
				progressBar: "_3fnsfWuIyofBJBBCbeOZzM",
				Floating: "AZ2rAoFxu6aiCBbBq02Sr",
				floating: "AZ2rAoFxu6aiCBbBq02Sr",
				PreviewVideo: "V26VfIGfGxnmQGCoWYGY7",
				previewVideo: "V26VfIGfGxnmQGCoWYGY7",
				PreviewTime: "_2PInUKITfsesytaTfWfG42",
				previewTime: "_2PInUKITfsesytaTfWfG42",
				VideoSeekbar: "_3-Dc7BBLD7JWsyF3pV-rsH",
				videoSeekbar: "_3-Dc7BBLD7JWsyF3pV-rsH",
				Mainbar: "_2uVDwsKlmWPhYjwe_hYwKZ",
				mainbar: "_2uVDwsKlmWPhYjwe_hYwKZ",
				Bar: "_4UI_04IgDx06P4biEkiF3",
				bar: "_4UI_04IgDx06P4biEkiF3",
				Background: "_2uPlpBWBrO4n82P3YvBGF_",
				background: "_2uPlpBWBrO4n82P3YvBGF_",
				Lookahead: "l8jnP9bxmZRCAmhfPBTa1",
				lookahead: "l8jnP9bxmZRCAmhfPBTa1",
				Buffered: "_169ZVSyFxp9z4y1H0OYA7w",
				buffered: "_169ZVSyFxp9z4y1H0OYA7w",
				Progress: "_3LxsYVQvMOr6phpuWaScdt",
				progress: "_3LxsYVQvMOr6phpuWaScdt",
				Live: "YTPNvBfuKbdKUEJL6hPJT",
				live: "YTPNvBfuKbdKUEJL6hPJT"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/SettingControl/index.m.less": function(e, t, n) {
			e.exports = {
				SettingControlContainer: "_2XC4hSYLNzvTJ9n8Qx5t2E",
				settingControlContainer: "_2XC4hSYLNzvTJ9n8Qx5t2E",
				mIsActive: "KE4seaOPBFBF1jhkJyWzD",
				VideoSettingContainer: "C_R5GVVZDJEPfB_2ZVw_j",
				videoSettingContainer: "C_R5GVVZDJEPfB_2ZVw_j",
				VideoResolutionContainer: "_3IZDbV1r5OQ2PtnsjF02A",
				videoResolutionContainer: "_3IZDbV1r5OQ2PtnsjF02A",
				VideoResolutionButton: "bAXkjkzl_SYFOHtU-04DK",
				videoResolutionButton: "bAXkjkzl_SYFOHtU-04DK",
				AutoplayContainer: "_2BOpKj2--T_MqNo_ZMRxNG",
				autoplayContainer: "_2BOpKj2--T_MqNo_ZMRxNG",
				SetAutoplayButton: "_3FgC5gbpQJUntY23YtQ89Z",
				setAutoplayButton: "_3FgC5gbpQJUntY23YtQ89Z",
				VideoResolutionDescription: "_1n_g7VROCpBaLnT_3bzFIL",
				videoResolutionDescription: "_1n_g7VROCpBaLnT_3bzFIL",
				AutoplayDescription: "_2NY4rl5z4S5VUOfEs8PdJ_",
				autoplayDescription: "_2NY4rl5z4S5VUOfEs8PdJ_",
				VideoHd: "UyJedjQe5dUxEFYt6pF_G",
				videoHd: "UyJedjQe5dUxEFYt6pF_G"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/SnooButton/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_1f5l9XSRXju5gjEllP1vw6",
				component: "_1f5l9XSRXju5gjEllP1vw6"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/Tooltip/index.m.less": function(e, t, n) {
			e.exports = {
				TooltipPopup: "_1BLNYd_poiSXsApjISxu_9",
				tooltipPopup: "_1BLNYd_poiSXsApjISxu_9",
				TooltipControl: "_7xWC34a6DkOCXgS96vOSO",
				tooltipControl: "_7xWC34a6DkOCXgS96vOSO",
				mNotDisable: "_2BgDJndeb40Gp_YvmIR_81"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/Tooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/fastdom/index.ts"),
				c = n("./src/reddit/components/HTML5StreamPlayer/Tooltip/index.m.less"),
				a = n.n(c),
				d = n("./src/lib/lessComponent.tsx");

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const b = 8,
				p = d.a.span("TooltipPopup", a.a),
				m = e => {
					var {
						className: t,
						setRef: n,
						disable: r
					} = e, i = l(e, ["className", "setRef", "disable"]);
					return s.a.createElement("div", u({
						className: Object(o.a)(a.a.TooltipControl, t, {
							[a.a.mNotDisable]: !r
						}),
						ref: n
					}, i))
				};
			class f extends r.Component {
				constructor() {
					super(...arguments), this.onMouseEnter = () => {
						i.a.read(this.setPosition)
					}, this.setPosition = () => {
						const {
							container: e,
							tooltipContainer: t
						} = this;
						if (e && t && this.props.tooltip) {
							const n = t.getBoundingClientRect(),
								r = e.getBoundingClientRect(),
								s = e.parentNode.getBoundingClientRect(),
								o = s.left - r.left + b,
								c = s.right - r.left - n.width - b,
								a = r.width / 2 - n.width / 2;
							i.a.write(() => {
								t.style.left = Math.max(o, Math.min(a, c)) + "px"
							})
						}
					}
				}
				componentDidMount() {
					this.container && this.container.addEventListener("focusin", this.setPosition)
				}
				componentWillUnmount() {
					this.container && this.container.removeEventListener("focusin", this.setPosition)
				}
				render() {
					const {
						className: e,
						children: t,
						disable: n,
						tooltip: r
					} = this.props;
					return s.a.createElement(m, {
						onMouseEnter: this.onMouseEnter,
						setRef: e => this.container = e,
						className: e,
						disable: n
					}, s.a.createElement(p, {
						className: a.a.TooltipPopup,
						innerRef: e => this.tooltipContainer = e
					}, r), t)
				}
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/VideoContainer/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2UrTEvz_DRsDezLCxNpGnZ",
				component: "_2UrTEvz_DRsDezLCxNpGnZ",
				mIsNotVisible: "ziid7jHsA37M8sq6Set2x"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/VideoOverlay/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_3UEq__yL-82zX4EyuluREz",
				component: "_3UEq__yL-82zX4EyuluREz"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/VolumeControl/index.m.less": function(e, t, n) {
			e.exports = {
				VolumeControl: "_3IYkqm44eWg992tFnELzuW",
				volumeControl: "_3IYkqm44eWg992tFnELzuW",
				SliderBar: "_1iy-RNoDbjuTYxfwaLdPRO",
				sliderBar: "_1iy-RNoDbjuTYxfwaLdPRO",
				SliderTrack: "gzyVgIvE9b8wMmHefFf6i",
				sliderTrack: "gzyVgIvE9b8wMmHefFf6i",
				SliderProgress: "_2mdWr-OXgnLh-fdDgEEb6E",
				sliderProgress: "_2mdWr-OXgnLh-fdDgEEb6E",
				Live: "_2GyJbEWZL04QA2bbVtv_Qu",
				live: "_2GyJbEWZL04QA2bbVtv_Qu",
				SliderThumb: "_320cReGqgLhY1pPA-fM8Z7",
				sliderThumb: "_320cReGqgLhY1pPA-fM8Z7"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/index.m.less": function(e, t, n) {
			e.exports = {
				RedditVideoPlayerRoot: "_3QOPLw8PZipW3i8kDxod81",
				redditVideoPlayerRoot: "_3QOPLw8PZipW3i8kDxod81",
				RedditVideoPlayerRoot__Fullscreen: "_1znUHTb50VqdFqfWmai1ts",
				redditVideoPlayerRootFullscreen: "_1znUHTb50VqdFqfWmai1ts",
				HTML5StreamPlayer__VideoFullscreen: "_6p8buRs-LijHSXx1H4MGe",
				html5StreamPlayerVideoFullscreen: "_6p8buRs-LijHSXx1H4MGe",
				HTML5StreamPlayer: "zRGpGBNtA_hojI_RK9ouQ",
				html5StreamPlayer: "zRGpGBNtA_hojI_RK9ouQ",
				HTML5StreamPlayer__VideoRegular: "_1EQJpXY7ExS04odI1YBBlj",
				html5StreamPlayerVideoRegular: "_1EQJpXY7ExS04odI1YBBlj"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./node_modules/bowser/src/bowser.js"),
				s = n.n(r),
				o = n("./node_modules/crypto-js/sha256.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/debounce.js"),
				a = n.n(c),
				d = n("./node_modules/react/index.js"),
				u = n.n(d),
				l = n("./node_modules/react-redux/es/index.js"),
				b = n("./src/reddit/models/Media/index.ts"),
				p = n("./node_modules/reselect/es/index.js"),
				m = n("./src/reddit/helpers/overlay/index.ts"),
				f = n("./src/lib/classNames/index.ts"),
				g = n("./src/lib/domUtils/index.ts"),
				O = n("./src/lib/getMobileOperatingSystem/index.ts"),
				h = n("./src/lib/loadWithRetries/index.ts"),
				y = n("./src/lib/sentry/index.ts"),
				j = n("./src/reddit/actions/media.ts"),
				_ = n("./src/reddit/actions/preferences.ts"),
				E = n("./src/reddit/actions/video.ts"),
				v = () => Object(h.a)(() => n.e("vendors~MuxEmbed").then(n.t.bind(null, "./node_modules/mux-embed/dist/mux.js", 7))),
				I = n("./src/reddit/components/Media/LoadingIcon/index.tsx"),
				S = n("./src/reddit/components/PlayButton/index.tsx"),
				T = n("./src/reddit/components/TrackingHelper/index.tsx"),
				x = n("./src/reddit/constants/video.ts"),
				C = n("./src/reddit/contexts/InsideOverlay.tsx"),
				w = n("./src/reddit/helpers/media/index.ts"),
				P = n("./src/reddit/helpers/trackers/media.ts"),
				D = n("./src/reddit/constants/experiments.ts"),
				R = n("./src/reddit/helpers/chooseVariant/index.ts");
			const A = e => {
					const t = Object(R.c)(e, {
						experimentEligibilitySelector: R.a,
						experimentName: D.db
					});
					return Object(D.Wb)(t) ? void 0 : t
				},
				k = e => e === D.fb.On,
				N = e => {
					const t = Object(R.c)(e, {
						experimentEligibilitySelector: R.a,
						experimentName: D.eb
					});
					return Object(D.Wb)(t) ? void 0 : t
				},
				L = e => e === D.fb.On;
			var M = n("./src/reddit/selectors/media.ts"),
				U = n("./src/reddit/selectors/platform.ts"),
				F = n("./src/reddit/selectors/posts.ts"),
				B = n("./src/reddit/selectors/user.ts"),
				G = n("./src/reddit/selectors/video.ts"),
				V = n("./src/reddit/components/HTML5StreamPlayer/BlurImage/index.m.less"),
				q = n.n(V),
				H = n("./src/lib/lessComponent.tsx"),
				K = H.a.img("Component", q.a),
				W = n("./src/reddit/components/HTML5StreamPlayer/ControlBar/index.tsx"),
				Y = n("./src/app/strings/index.ts"),
				z = (n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/fbt/lib/FbtPublic.js")),
				J = e => u.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 77.06 60"
				}, u.a.createElement("g", {
					fill: "none"
				}, u.a.createElement("path", {
					d: "M75.17,11.35l-44.9,46.7a6.17,6.17,0,0,1-9,0L1.88,37.55a6.83,6.83,0,0,1,0-9.4,6.17,6.17,0,0,1,9,0l15,15.8L66.27,2a6.17,6.17,0,0,1,9,0A6.93,6.93,0,0,1,75.17,11.35Z",
					fill: "#FFFFFF"
				}))),
				Q = n("./src/reddit/components/HTML5StreamPlayer/SettingControl/index.m.less"),
				X = n.n(Q);

			function Z() {
				return (Z = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var $ = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const ee = 0,
				te = [1080, 720],
				ne = [...te, 480, 360, 240, ee],
				re = e => u.a.createElement("button", {
					"aria-checked": e.isChecked,
					className: X.a.SetAutoplayButton,
					onClick: e.onClick,
					role: "checkbox",
					tabIndex: 0
				}, u.a.createElement(J, null), u.a.createElement("div", {
					className: X.a.AutoplayDescription
				}, z.fbt._("Autoplay", null, {
					hk: "1x30w1"
				}))),
				se = e => {
					const {
						resolution: t,
						onClick: n,
						isChecked: r
					} = e;
					return u.a.createElement("button", {
						"aria-checked": r,
						className: X.a.VideoResolutionButton,
						onClick: n,
						role: "radio",
						tabIndex: 0
					}, u.a.createElement(J, null), u.a.createElement("div", {
						className: X.a.VideoResolutionDescription
					}, t === ee ? z.fbt._("Auto", null, {
						hk: "6zgZT"
					}) : u.a.createElement(u.a.Fragment, null, u.a.createElement("span", null, t, "p"), te.includes(t) && u.a.createElement("span", {
						className: X.a.VideoHd
					}, "", z.fbt._("HD", null, {
						hk: "2KjxjH"
					})))))
				},
				oe = e => {
					var {
						isActive: t,
						className: n,
						innerRef: r
					} = e, s = $(e, ["isActive", "className", "innerRef"]);
					return u.a.createElement("div", Z({
						className: Object(f.a)(X.a.SettingControlContainer, n, {
							[X.a.mIsActive]: t
						}),
						ref: r
					}, s))
				};
			class ie extends d.Component {
				constructor() {
					super(...arguments), this.container = null, this.state = {
						autoplayPref: this.props.autoplayPref
					}, this.setContainerRef = e => this.container = e, this.setResolution = e => {
						this.props.setResolution(e)
					}, this.setAutoplay = e => {
						const t = !this.state.autoplayPref;
						this.setState({
							autoplayPref: t
						}), this.props.setAutoplay(t)
					}
				}
				componentDidMount() {
					if (this.container) {
						const e = this.container.querySelector("[tabindex]");
						e && e.focus()
					}
				}
				render() {
					const {
						active: e,
						bitrateInfo: t,
						className: n,
						isLoggedIn: r,
						resolution: s
					} = this.props, o = [...t.map(e => e.height), ee];
					return u.a.createElement(oe, {
						innerRef: this.setContainerRef,
						className: Object(f.a)(X.a.VideoSettingContainer, n),
						isActive: e
					}, r && u.a.createElement("div", {
						className: X.a.AutoplayContainer
					}, u.a.createElement(re, {
						isChecked: this.state.autoplayPref,
						onClick: this.setAutoplay
					})), u.a.createElement("div", {
						className: X.a.VideoResolutionContainer,
						role: "radiogroup"
					}, ne.map((e, t) => o.includes(e) ? u.a.createElement(se, {
						key: t,
						resolution: e,
						onClick: () => this.setResolution(e),
						isChecked: s === e
					}) : null)))
				}
			}
			var ce = n("./src/reddit/components/HTML5StreamPlayer/Tooltip/index.tsx");
			var ae = e => u.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, u.a.createElement("path", {
					fill: "#fff",
					d: "M18.5,8.94,16.32,8.5h0a6.46,6.46,0,0,0-.79-1.9h0l1.23-1.85a1.08,1.08,0,0,0-1.5-1.5L13.41,4.47h0a6.45,6.45,0,0,0-1.9-.79h0L11.06,1.5a1.08,1.08,0,0,0-2.12,0L8.5,3.68h0a6.45,6.45,0,0,0-1.9.79h0L4.74,3.24a1.08,1.08,0,0,0-1.5,1.5L4.47,6.59h0a6.45,6.45,0,0,0-.79,1.9h0L1.5,8.94a1.08,1.08,0,0,0,0,2.12l2.18.44h0a6.45,6.45,0,0,0,.79,1.9h0L3.24,15.26a1.08,1.08,0,0,0,1.5,1.5l1.85-1.23h0a6.45,6.45,0,0,0,1.9.79h0l.44,2.18a1.08,1.08,0,0,0,2.12,0l.44-2.18h0a6.45,6.45,0,0,0,1.9-.79h0l1.85,1.23a1.08,1.08,0,0,0,1.5-1.5l-1.23-1.85h0a6.45,6.45,0,0,0,.79-1.9h0l2.18-.44a1.08,1.08,0,0,0,0-2.12ZM10,13.5A3.5,3.5,0,1,1,13.5,10,3.5,3.5,0,0,1,10,13.5Z"
				})),
				de = n("./src/reddit/components/HTML5StreamPlayer/ControlBar/index.m.less"),
				ue = n.n(de);
			const le = H.a.wrapped(ce.a, "TooltipControl", ue.a),
				be = H.a.wrapped(le, "ControlSetting", ue.a),
				pe = Object(Y.a)("en", "video.settingTooltip");
			class me extends d.Component {
				render() {
					const {
						autoplayPref: e,
						bitrateInfo: t,
						isLoggedIn: n,
						resolution: r,
						setAutoplay: s,
						setResolution: o,
						settingChange: i,
						settingRef: c,
						toggleSetting: a
					} = this.props;
					return u.a.createElement(be, {
						key: "setting",
						className: ue.a.AnimatedSettingIconParent,
						tooltip: pe,
						disable: i === mt.Settings
					}, i === mt.Settings && u.a.createElement(ie, {
						className: ue.a.VideoSettingContainer,
						isLoggedIn: n,
						autoplayPref: e,
						active: i === mt.Settings,
						ref: e => c(e),
						resolution: r,
						setResolution: o,
						setAutoplay: s,
						bitrateInfo: t
					}), u.a.createElement("button", {
						"aria-expanded": i === mt.Settings,
						"aria-haspopup": !0,
						"aria-label": pe,
						onClick: a
					}, u.a.createElement(ae, {
						className: ue.a.SettingIcon
					})))
				}
			}
			var fe = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				ge = n("./src/reddit/selectors/telemetry.ts"),
				Oe = n("./src/reddit/icons/svgs/VideoApplyNow/index.m.less"),
				he = n.n(Oe);
			var ye = e => u.a.createElement("svg", {
					className: Object(f.a)(he.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M27.7 20.4h-7.4c-.2 0-.4-.2-.4-.4s.2-.5.5-.5h7.3c.3 0 .5.2.5.5s-.3.4-.5.4m0 3.1h-7.4c-.2 0-.4-.3-.4-.5 0-.3.2-.5.5-.5h7.3c.3 0 .5.2.5.5-.1.2-.3.5-.5.5m0 3h-7.4c-.2 0-.4-.2-.4-.5s.2-.5.5-.5h7.3c.3 0 .5.2.5.5-.1.3-.3.5-.5.5m0 3h-7.4c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h7.3c.3 0 .5.2.5.5s-.2.5-.4.5m2-12.2h-2.2c-.3-.6-1-1-1.7-1h-3.6c-.7 0-1.4.4-1.7 1h-2.2c-.5 0-1 .4-1 1v12.5c0 .5.4 1 1 1h11.5c.5 0 1-.4 1-1V18.2c-.1-.5-.5-.9-1.1-.9"
				}))),
				je = n("./src/reddit/icons/svgs/VideoContactUs/index.m.less"),
				_e = n.n(je);
			var Ee = e => u.a.createElement("svg", {
					className: Object(f.a)(_e.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M34.5 23.7s-.1 0 0 0c-.1 0-.1 0 0 0-.1 0-.1 0 0 0-.1-.1-.1-.1-.2-.1l-15.4-7.2c-.1-.1-.3-.1-.5 0-.1.1-.2.2-.2.4v4.3c0 .2.2.4.4.5l10.3 1.9H18.2c-.1 0-.2 0-.2.1L15.6 25c-.2.1-.3.3-.2.6.1.2.2.3.5.3l2.4-.2v5.5c0 .2.1.3.2.4.1 0 .2.1.3.1h.2l15.4-7.2s.1 0 .1-.1c0 0 .1 0 .1-.1.1-.1.1-.2.1-.3-.1-.1-.2-.2-.2-.3"
				}))),
				ve = n("./src/reddit/icons/svgs/VideoGetAQuote/index.m.less"),
				Ie = n.n(ve);
			var Se = e => u.a.createElement("svg", {
					className: Object(f.a)(Ie.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M19.5 17.3h3.1l-1.8 5h2.3v6.5h-6.8v-6l3.2-5.5zm8.5 0h3.1l-1.8 5h2.3v6.5h-6.8v-6l3.2-5.5z"
				}))),
				Te = n("./src/reddit/icons/svgs/VideoGetShowtimes/index.m.less"),
				xe = n.n(Te);
			var Ce = e => u.a.createElement("svg", {
					className: Object(f.a)(xe.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M32.2 20.3c-.3-.2-.7-.2-1 0l-2.4 1.4v-1.5c0-1.1-.9-1.9-1.9-1.9h-7.7c-1.1 0-1.9.9-1.9 1.9v7.7c0 1.1.9 1.9 1.9 1.9h7.7c1.1 0 1.9-.9 1.9-1.9v-1.6l2.4 1.4c.2.1.3.1.5.1s.3 0 .5-.1c.3-.2.5-.5.5-.8v-5.8c-.1-.3-.2-.6-.5-.8"
				}))),
				we = n("./src/reddit/icons/svgs/VideoInstall/index.m.less"),
				Pe = n.n(we);
			var De = e => u.a.createElement("svg", {
					className: Object(f.a)(Pe.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M30.7 25c.5 0 1 .4 1 1v2.9c0 1.6-1.3 2.9-2.9 2.9h-9.6c-1.6 0-2.9-1.3-2.9-2.9v-3c0-.5.4-1 1-1s1 .4 1 1v2.9c0 .5.4 1 1 1h9.6c.5 0 1-.4 1-1v-2.9c-.1-.5.3-.9.8-.9zm-7.4 1.6l-2.9-2.9c-.4-.4-.4-1 0-1.4.4-.4 1-.4 1.4 0l1.2 1.3v-6.3c0-.5.4-1 1-1 .5 0 1 .4 1 1v6.3l1.2-1.2c.4-.4 1-.4 1.4 0 .4.4.4 1 0 1.4l-2.9 2.8c-.1.1-.2.2-.3.2-.2.1-.3.1-.4.1-.1 0-.2 0-.4-.1-.1 0-.2-.1-.3-.2z"
				}))),
				Re = n("./src/reddit/icons/svgs/VideoLearnMore/index.m.less"),
				Ae = n.n(Re);
			var ke = e => u.a.createElement("svg", {
					className: Object(f.a)(Ae.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M25.4 24c0 .8-.6 1.4-1.4 1.4s-1.4-.6-1.4-1.4.6-1.4 1.4-1.4 1.4.6 1.4 1.4zm5.3 0c0 .8-.6 1.4-1.4 1.4-.8 0-1.4-.6-1.4-1.4s.6-1.4 1.4-1.4c.8 0 1.4.6 1.4 1.4zm-10.5 0c0 .8-.6 1.4-1.4 1.4s-1.5-.6-1.5-1.4.6-1.4 1.4-1.4 1.5.6 1.5 1.4z"
				}))),
				Ne = n("./src/reddit/icons/svgs/VideoPlayNow/index.m.less"),
				Le = n.n(Ne);
			var Me = e => u.a.createElement("svg", {
					className: Object(f.a)(Le.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M32.5,23.5c-0.7,0-1.4-0.6-1.4-1.4c0-0.7,0.6-1.4,1.4-1.4s1.4,0.6,1.4,1.4 C33.8,22.8,33.2,23.5,32.5,23.5 M29.8,26.2c-0.7,0-1.4-0.6-1.4-1.4c0-0.7,0.6-1.4,1.4-1.4c0.7,0,1.4,0.6,1.4,1.4 C31.1,25.6,30.5,26.2,29.8,26.2 M27.1,23.5c-0.7,0-1.4-0.6-1.4-1.4c0-0.7,0.6-1.4,1.4-1.4c0.7,0,1.4,0.6,1.4,1.4 C28.4,22.8,27.8,23.5,27.1,23.5 M21.6,23.1H20v1.7c0,0.6-0.5,1-1,1s-1-0.5-1-1v-1.7h-1.7c-0.6,0-1-0.5-1-1c0-0.6,0.5-1,1-1H18 v-1.7c0-0.6,0.5-1,1-1s1,0.5,1,1v1.7h1.7c0.6,0,1,0.5,1,1C22.7,22.7,22.2,23.1,21.6,23.1 M29.8,18c0.7,0,1.4,0.6,1.4,1.4 c0,0.7-0.6,1.4-1.4,1.4c-0.7,0-1.4-0.6-1.4-1.4C28.4,18.6,29,18,29.8,18 M37.3,28.1l-1.7-9.5c-0.4-1.9-2-3.3-4-3.3H17.1 c-2,0-3.6,1.4-4,3.3l-1.7,9.5c-0.2,1.2,0.1,2.4,0.9,3.3c0.8,0.9,1.9,1.5,3.1,1.5h0.2c1.8,0,3.3-1.1,3.9-2.8l0.4-1.3h8.9 l0.4,1.3c0.6,1.7,2.1,2.8,3.9,2.8h0.2c1.2,0,2.3-0.5,3.1-1.5C37.2,30.5,37.5,29.3,37.3,28.1"
				}))),
				Ue = n("./src/reddit/icons/svgs/VideoSeeMenu/index.m.less"),
				Fe = n.n(Ue);
			var Be = e => u.a.createElement("svg", {
					className: Object(f.a)(Fe.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M29.3 20.2h-5.8c-.2 0-.5-.3-.5-.5 0-.3.2-.5.5-.5h5.8c.3 0 .5.2.5.5 0 .2-.3.5-.5.5zm0 4.3h-5.8c-.2 0-.5-.2-.5-.5s.2-.5.5-.5h5.8c.3 0 .5.2.5.5s-.3.5-.5.5zm0 4.3h-5.8c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h5.8c.3 0 .5.2.5.5s-.3.5-.5.5zm-8.2-8.2c0 .3-.2.5-.5.5h-1.9c-.3 0-.5-.2-.5-.5v-1.9c0-.3.2-.5.5-.5h1.9c.3 0 .5.2.5.5v1.9zm0 4.4c0 .3-.2.5-.5.5h-1.9c-.3 0-.5-.2-.5-.5v-2c0-.3.2-.5.5-.5h1.9c.3 0 .5.2.5.5v2zm0 4.3c0 .3-.2.5-.5.5h-1.9c-.3 0-.5-.2-.5-.5v-1.9c0-.3.2-.5.5-.5h1.9c.3 0 .5.2.5.5v1.9zm8.7-13H18.2c-1.1 0-1.9.9-1.9 1.9v11.5c0 1.1.9 1.9 1.9 1.9h11.5c1.1 0 1.9-.9 1.9-1.9V18.2c.1-1-.8-1.9-1.8-1.9z"
				}))),
				Ge = n("./src/reddit/icons/svgs/VideoShopNow/index.m.less"),
				Ve = n.n(Ge);
			var qe = e => u.a.createElement("svg", {
					className: Object(f.a)(Ve.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M29 26c-.6 0-1-.4-1-1 0-.5.4-1 1-1s1 .4 1 1-.5 1-1 1zm-6.9-6c0-.5.4-1 1-1H27c.6 0 1 .4 1 1v2.1h-5.9V20zM21 26c-.6 0-1-.4-1-1 0-.5.4-1 1-1s1 .4 1 1-.5 1-1 1zm11.7-3.6c-.2-.2-.5-.3-.7-.3h-2V20c0-1.6-1.3-3-3-3h-3.9c-1.7 0-3 1.3-3 3v2.1H18c-.3 0-.6.1-.7.3-.2.2-.3.5-.2.8l1 9c.1.5.5.9 1 .9h12c.5 0 .9-.4 1-.9l1-9c-.1-.4-.2-.6-.4-.8z"
				}))),
				He = n("./src/reddit/icons/svgs/VideoSignUp/index.m.less"),
				Ke = n.n(He);
			var We = e => u.a.createElement("svg", {
					className: Object(f.a)(Ke.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M27.7 20.4h-7.4c-.2 0-.4-.2-.4-.4s.2-.5.5-.5h7.3c.3 0 .5.2.5.5s-.3.4-.5.4m0 3.1h-7.4c-.2 0-.4-.3-.4-.5 0-.3.2-.5.5-.5h7.3c.3 0 .5.2.5.5-.1.2-.3.5-.5.5m0 3h-7.4c-.2 0-.4-.2-.4-.5s.2-.5.5-.5h7.3c.3 0 .5.2.5.5-.1.3-.3.5-.5.5m0 3h-7.4c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h7.3c.3 0 .5.2.5.5s-.2.5-.4.5m2-12.2h-2.2c-.3-.6-1-1-1.7-1h-3.6c-.7 0-1.4.4-1.7 1h-2.2c-.5 0-1 .4-1 1v12.5c0 .5.4 1 1 1h11.5c.5 0 1-.4 1-1V18.2c-.1-.5-.5-.9-1.1-.9"
				}))),
				Ye = n("./src/reddit/icons/svgs/VideoViewMore/index.m.less"),
				ze = n.n(Ye);
			var Je = e => u.a.createElement("svg", {
					className: Object(f.a)(ze.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M29.8 23H25v-4.8c0-.5-.4-1-1-1s-1 .4-1 1V23h-4.8c-.5 0-1 .4-1 1s.4 1 1 1H23v4.8c0 .5.4 1 1 1s1-.4 1-1V25h4.8c.5 0 1-.4 1-1s-.5-1-1-1"
				}))),
				Qe = n("./src/reddit/icons/svgs/VideoWatchNow/index.m.less"),
				Xe = n.n(Qe);
			var Ze = e => u.a.createElement("svg", {
					className: Object(f.a)(Xe.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, u.a.createElement("g", {
					transform: "translate(1 1)"
				}, u.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), u.a.createElement("path", {
					fill: "#fff",
					d: "M32.2 20.3c-.3-.2-.7-.2-1 0l-2.4 1.4v-1.5c0-1.1-.9-1.9-1.9-1.9h-7.7c-1.1 0-1.9.9-1.9 1.9v7.7c0 1.1.9 1.9 1.9 1.9h7.7c1.1 0 1.9-.9 1.9-1.9v-1.6l2.4 1.4c.2.1.3.1.5.1s.3 0 .5-.1c.3-.2.5-.5.5-.8v-5.8c-.1-.3-.2-.6-.5-.8"
				}))),
				$e = n("./src/reddit/components/VideoCTA/index.m.less"),
				et = n.n($e);
			const tt = {
				"Apply Now": u.a.createElement(ye, null),
				"Contact Us": u.a.createElement(Ee, null),
				"Learn More": u.a.createElement(ke, null),
				"Get a Quote": u.a.createElement(Se, null),
				"Get Showtimes": u.a.createElement(Ce, null),
				Install: u.a.createElement(De, null),
				Download: u.a.createElement(De, null),
				"Learn More": u.a.createElement(ke, null),
				"Play Now": u.a.createElement(Me, null),
				"See Menu": u.a.createElement(Be, null),
				"Shop Now": u.a.createElement(qe, null),
				"Sign Up": u.a.createElement(We, null),
				"View More": u.a.createElement(Je, null),
				"Watch Now": u.a.createElement(Ze, null)
			};
			var nt = Object(T.b)(e => {
					const {
						callToAction: t,
						sendEvent: n,
						source: r
					} = e;
					return u.a.createElement(fe.a, {
						className: et.a.ctaLink,
						onClick: e => n(e => Object.assign({}, Object(ge.defaults)(e), {
							source: "videoplayer",
							action: "click",
							noun: "callToAction"
						})),
						href: r.url,
						isSponsored: !0,
						source: r
					}, u.a.createElement("div", {
						className: et.a.ctaWrapper
					}, (e => tt[e = e || "Learn More"])(t), u.a.createElement("span", {
						className: et.a.ctaText
					}, t || "Learn More")))
				}),
				rt = n("./src/reddit/icons/svgs/VideoReplay/index.tsx"),
				st = n("./src/reddit/components/HTML5StreamPlayer/ReplayVideo/index.m.less"),
				ot = n.n(st);
			const it = H.a.div("Centered", ot.a),
				ct = H.a.div("EndedOverlay", ot.a),
				at = H.a.span("ReplayText", ot.a),
				dt = H.a.button("ReplayButton", ot.a);
			var ut = e => {
					const {
						onClick: t,
						source: n,
						callToAction: r
					} = e;
					return u.a.createElement(ct, {
						onClick: t
					}, u.a.createElement(it, null, u.a.createElement(dt, null, u.a.createElement(rt.a, null), u.a.createElement(at, {
						className: "replay-video"
					}, z.fbt._("Replay Video", null, {
						hk: "1iD2Wj"
					}))), n && r && u.a.createElement(nt, {
						callToAction: r,
						source: n
					})))
				},
				lt = n("./src/reddit/components/HTML5StreamPlayer/VideoContainer/index.m.less"),
				bt = n.n(lt);

			function pt() {
				return (pt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var mt, ft = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				},
				gt = e => {
					var {
						className: t,
						isVisible: n,
						setRef: r
					} = e, s = ft(e, ["className", "isVisible", "setRef"]);
					return u.a.createElement("div", pt({
						className: Object(f.a)(bt.a.Component, t, {
							[bt.a.mIsNotVisible]: !n
						}),
						ref: r
					}, s))
				},
				Ot = n("./src/reddit/components/HTML5StreamPlayer/VideoOverlay/index.m.less"),
				ht = n.n(Ot),
				yt = H.a.div("Component", ht.a),
				jt = n("./src/reddit/components/HTML5StreamPlayer/index.m.less"),
				_t = n.n(jt);
			n.d(t, "a", (function() {
					return mt
				})),
				function(e) {
					e[e.SeekBar = 0] = "SeekBar", e[e.Settings = 1] = "Settings", e[e.Volume = 2] = "Volume"
				}(mt || (mt = {}));
			const Et = 3e3,
				vt = 6e3,
				It = 100,
				St = Object(l.b)(() => Object(p.c)({
					isLoggedIn: B.K,
					autoplayPref: B.b,
					currentTime: G.d,
					currentUser: B.i,
					isMutedPreference: M.a,
					isOverlayOpen: U.i,
					language: B.T,
					loadTimes: G.f,
					metadata: G.g,
					muxSamplingAVariant: A,
					muxSamplingBVariant: N,
					postUrl: F.K,
					started: G.i,
					volume: M.b
				}), (e, t) => {
					let {
						postId: n
					} = t;
					return {
						exitVideoFullscreen: () => e(E.z()),
						onLoadStarted: t => {
							n && e(E.v(n, t))
						},
						onMetadataReceived: t => e(E.H({
							metadata: t,
							postId: t.id
						})),
						onPlayable: t => {
							n && e(E.E(n, t))
						},
						onUpdateVideoTime: a()(t => {
							n && e(E.L({
								postId: n,
								time: t
							}))
						}, x.k, {
							maxWait: x.l
						}),
						openLightbox: t => {
							t ? e(Object(m.a)(t)) : y.c.withScope(e => {
								e.setExtra("info", {
									postId: n,
									postUrl: t
								}), y.c.captureMessage("Post lightbox cannot be opened with a falsy postUrl")
							})
						},
						setPlaying: t => {
							n && e(E.K({
								postId: n,
								isPlaying: t
							}))
						},
						setAutoplayPref: t => e(_.r(t)),
						setVideoFullscreen: () => {
							n && e(E.J(n))
						},
						setVideoMuted: t => e(j.d(t, n)),
						setVideoVolume: t => e(j.e(t)),
						onWatchedPercent: t => {
							n && e(E.O(t, n))
						},
						onWatchedSeconds: t => {
							n && e(E.P(t, n))
						},
						onUpdateContinuousViewStartTime: t => {
							n && e(E.y({
								postId: n,
								time: t
							}))
						},
						onVideoStarted: () => {
							n && e(E.N(n))
						}
					}
				});
			class Tt extends d.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.percentagePixelsFired = {
						[x.b]: !1,
						[x.c]: !1,
						[x.d]: !1,
						[x.e]: !1,
						[x.a]: !1
					}, this.timePixelsFired = {
						[x.g]: !1,
						[x.h]: !1,
						[x.f]: !1
					}, this.sendEvent = function(e, n) {
						let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
						const s = t.HTML5StreamPlayerVideo;
						if (s && null != t.props.postId) {
							const s = r ? P.b(t.props.postId, e, n) : P.a(t.props.postId, e, n);
							t.props.sendEvent(s)
						}
					}, this.getVideoQualityList = () => {
						if (this.dashPlayer) {
							const e = this.dashPlayer.getBitrateInfoListFor("video");
							this.setState({
								bitrateInfo: e
							})
						}
					}, this.getAudioInfo = () => {
						if (this.props.isGif) this.setState({
							hasAudio: !1
						});
						else if (this.dashPlayer) {
							const e = this.dashPlayer.getActiveStream(),
								t = !!e && e.hasMedia("audio");
							this.setState({
								hasAudio: t
							})
						}
					}, this.handleKeyDown = e => {
						this.updateUsingKeyStatus(e)
					}, this.handleKeyUp = e => {
						this.updateUsingKeyStatus(e)
					}, this.handleMouseEnter = e => {
						const t = this.HTML5StreamPlayerVideo;
						t && this.controlBarApi && this.controlBarApi.setCurrentTime(t.currentTime), this.resetControlBarFadeTimer()
					}, this.handleMouseDown = e => {
						e.stopPropagation();
						const {
							seekBar: t,
							volumeControl: n
						} = this;
						n && n.container && n.container.contains(e.target) ? (this.setState({
							settingChange: mt.Volume
						}), n.handleMouseDown(e)) : t && t.parentRect && t.parentRect.contains(e.target) && (this.setState({
							settingChange: mt.SeekBar
						}), t.handleMouseDown(e)), this.state.usingKeys && this.setState({
							usingKeys: !1
						})
					}, this.handleMouseMove = e => {
						const {
							controlBar: t,
							seekBar: n,
							volumeControl: r
						} = this;
						switch (this.setState({
							hasHovered: !0
						}), t && t.contains(e.target) ? this.clearControlBarFadeTimer() : this.resetControlBarFadeTimer(), this.state.settingChange) {
							case mt.SeekBar:
								n && n.handleMouseMove(e);
								break;
							case mt.Volume:
								r && r.handleMouseMove(e);
								break;
							case mt.Settings:
						}
					}, this.handleMouseUp = e => {
						e.stopPropagation();
						const {
							controlBar: t,
							seekBar: n,
							volumeControl: r
						} = this;
						switch (this.state.settingChange) {
							case mt.SeekBar:
								if (n) {
									this.setState({
										ignoreUnderrunsUntil: Date.now() + It
									}), n.handleMouseUp(e), this.sendEvent("click", "seek");
									const t = this.HTML5StreamPlayerVideo;
									this.state.videoEnded && t && t.currentTime !== t.duration && this.playVideo()
								}
								break;
							case mt.Volume:
								r && (r.handleMouseUp(e), this.sendEvent("click", "volume"));
								break;
							case mt.Settings:
								if (t && t.contains(e.target)) return;
								break;
							default:
								if (t && !t.contains(e.target)) {
									const {
										playerClickPlay: t = !0
									} = this.props;
									if (this.props.trackPostClick && this.props.trackPostClick("media")(), this.resetControlBarFadeTimer(), this.state.videoEnded) return;
									this.props.isGif && this.props.isListing && !this.state.videoPaused ? this.props.openLightbox(this.props.postUrl) : !t && this.state.videoPaused || this.playPauseVideo(e)
								}
						}
						this.setState({
							settingChange: void 0
						})
					}, this.handleMouseLeave = e => {
						switch (this.clearControlBarFadeTimer(), this.setState({
							hideControlBar: !0
						}), this.state.settingChange) {
							case mt.SeekBar:
							case mt.Volume:
							case mt.Settings:
							default:
								this.setState({
									settingChange: void 0
								})
						}
					}, this.handleClick = e => {
						e.stopPropagation()
					}, this.setContainerRef = e => this.HTML5StreamPlayerContainer = e, this.setControlBarRef = e => this.controlBar = e, this.setControlBarApi = e => this.controlBarApi = e, this.setVolumeRef = e => this.volumeControl = e, this.setSeekBarRef = e => this.seekBar = e, this.setSettingRef = e => this.settingControl = e, this.onCanPlay = () => {
						if (this.HTML5StreamPlayerVideo && !this.state.videoLoaded) {
							this.setState({
								videoLoaded: !0,
								videoWaiting: !1
							});
							let t = !0;
							try {
								const e = localStorage.getItem("preview_video");
								(t = !e || JSON.parse(e)) || this.props.setVideoMuted(!1)
							} catch (e) {}
							this.props.autoPlay && (this.props.autoplayPref || this.props.shouldIgnoreAutoplayPref) || this.props.isExpando ? this.playVideo() : this.pauseVideo()
						}
					}, this.clearControlBarFadeTimer = () => {
						const {
							controlBarFadeTimer: e
						} = this;
						e && clearTimeout(e)
					}, this.resetControlBarFadeTimer = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Et;
						t.clearControlBarFadeTimer(), t.setState({
							hideControlBar: !1
						}), t.controlBarFadeTimer = window.setTimeout(() => {
							t.setState({
								hideControlBar: !0
							})
						}, e)
					}, this.exitHandler = () => {
						this.state.videoFullScreen && !Object(g.b)() && this.exitFullScreen()
					}, this.playPauseVideo = e => {
						const t = this.HTML5StreamPlayerVideo;
						t && (t.paused && this.state.videoPaused ? (this.playVideo(), this.sendEvent("click", "play"), this.setState({
							videoManualPaused: !1
						})) : (this.pauseVideo(), this.sendEvent("click", "pause"), this.setState({
							videoManualPaused: !0
						})))
					}, this.playVideo = async () => {
						const e = this.HTML5StreamPlayerVideo;
						if (e) try {
							await e.play(), e.currentTime < 1 && this.props.onVideoStarted(), this.setVideoMute(this.state.isMuted), this.props.setPlaying(!0), this.setState({
								videoEnded: !1
							})
						} catch (t) {}
					}, this.pauseVideo = () => {
						const e = this.HTML5StreamPlayerVideo;
						e && (e.pause(), this.props.setPlaying(!1), this.setState({
							videoPaused: !0
						}))
					}, this.resetVideo = e => {
						this.state.videoEnded && (this.playVideo(), this.sendEvent("click", "replay"), this.setState({
							ignoreUnderrunsUntil: Date.now() + It,
							videoEnded: !1,
							videoManualPaused: !1
						}))
					}, this.exitFullScreen = () => {
						document.exitFullScreen ? document.exitFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen(), this.setState({
							videoFullScreen: !1
						}), null != this.props.postId && (this.sendEvent("change", "pagetype", !0), this.props.exitVideoFullscreen())
					}, this.enterFullScreen = () => {
						const e = this.HTML5StreamPlayerContainer;
						e && (e.requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.mozRequestFullScreen && e.mozRequestFullScreen()), this.setState({
							videoFullScreen: !0
						}), this.sendEvent("click", "fullscreen"), null != this.props.postId && (this.sendEvent("change", "pagetype", !0), this.props.setVideoFullscreen())
					}, this.setVolume = (e, t) => {
						const n = this.HTML5StreamPlayerVideo;
						n && (t ? 0 !== e && this.props.setVideoVolume(e) : (n.volume = e, e || this.state.isMuted ? e && this.state.isMuted && this.setVideoMute(!1) : this.setVideoMute(!0)))
					}, this.toggleMuteVideo = e => {
						if (e.stopPropagation(), this.HTML5StreamPlayerVideo) {
							const e = !this.state.isMuted;
							this.setVideoMute(e);
							const t = e ? "mute" : "unmute";
							this.sendEvent("click", t);
							const n = e ? "true" : "false";
							localStorage.setItem("preview_video", n)
						}
					}, this.setVideoMute = e => {
						const t = this.HTML5StreamPlayerVideo;
						this.setState({
							isMuted: e
						}), this.props.setVideoMuted(e), t && (t.muted = e, e || (t.volume = this.props.volume))
					}, this.clickSnoo = e => {
						this.state.videoFullScreen && this.exitFullScreen(), this.sendEvent("click", "snoo")
					}, this.setAutoplay = e => {
						this.props.setAutoplayPref(e), e ? this.sendEvent("click", "video_autoplay_on") : this.sendEvent("click", "video_autoplay_off")
					}, this.setResolution = e => {
						const {
							bitrateInfo: t
						} = this.state;
						if (t && this.dashPlayer) {
							if (e === ee) this.dashPlayer.setAutoSwitchQualityFor("video", !0);
							else {
								const n = t.findIndex(t => t.height === e);
								this.dashPlayer.setAutoSwitchQualityFor("video", !1), this.dashPlayer.setQualityFor("video", n)
							}
							this.setState({
								resolution: e
							})
						}
					}, this.toggleSetting = e => {
						this.state.settingChange === mt.Settings ? this.setState({
							settingChange: void 0
						}) : this.setState({
							settingChange: mt.Settings
						})
					}, this.setVideoPos = e => {
						const t = this.HTML5StreamPlayerVideo;
						t && (this.controlBarApi && !this.state.hideControlBar && this.controlBarApi.setCurrentTime(e), t.currentTime = e)
					}, this.updateTime = () => {
						const e = performance.now(),
							t = this.HTML5StreamPlayerVideo;
						if (t) {
							let n = this.state.maxTimeServed;
							if (this.state.lastUpdate && !this.state.videoPaused && (n += e - this.state.lastUpdate), t.currentTime && t.duration) {
								let r = !1;
								this.triggerAdWatchedPixels(t.currentTime, t.duration, n / 1e3), t.currentTime >= t.duration && (this.props.isGif || (r = !0, this.pauseVideo())), this.controlBarApi && !this.state.hideControlBar && this.controlBarApi.setCurrentTime(t.currentTime), this.setState({
									videoEnded: r,
									maxTimeServed: n,
									lastUpdate: e
								})
							}
							if (this.props.postId) {
								const e = {
									currentTime: 1e3 * t.currentTime,
									maxTimeServed: n
								};
								this.props.onUpdateVideoTime(e)
							}
						}
					}, this.triggerAdWatchedPixels = (e, t, n) => {
						const r = this.getWatchedPercentRange(e, t);
						n >= t && this.triggerPercentagePixels(x.a), this.triggerPercentagePixels(r);
						n / t >= .95 && this.triggerTimeWatchedPixels(x.f), this.triggerTimeWatchedPixels(n)
					}, this.updateContinuousStartTime = e => {
						this.props.onUpdateContinuousViewStartTime(e)
					}, this.onVideoPlayable = e => {
						this.props.metadata || this.sendTransformedMetadata(e)
					}, this.onPlaying = e => {
						const t = performance.now();
						this.props.metadata || this.sendTransformedMetadata(e), this.setState({
							videoWaiting: !1,
							videoPaused: !1,
							lastUpdate: t
						})
					}, this.sendTransformedMetadata = e => {
						null != this.props.postId && this.props.onMetadataReceived({
							id: this.props.postId,
							length: 1e3 * e.target.duration,
							originalHeight: e.target.videoHeight,
							originalWidth: e.target.videoWidth
						}), this.setState({
							totalTime: e.target.duration
						})
					}, Tt.dashjs || (Tt.dashjs = Object(h.a)(() => n.e("vendors~dashjs").then(n.t.bind(null, "./node_modules/dashjs/build/es5/index.js", 7)))), this.state = {
						bitrateInfo: [],
						hasAudio: !1,
						hasHovered: !1,
						hideControlBar: !0,
						isMuted: e.isListing || e.isMutedPreference,
						lastUpdate: null,
						ignoreUnderrunsUntil: 0,
						maxTimeServed: 0,
						muxPlayerInitTime: 0,
						resolution: ee,
						scrubPosition: 0,
						settingChange: void 0,
						settingSeekBar: !1,
						settingVolume: !1,
						thumbPosition: 0,
						totalTime: 0,
						videoEnded: !1,
						videoFullScreen: !1,
						videoInView: !1,
						videoLoaded: !1,
						videoManualPaused: !1,
						videoPaused: !e.autoPlay,
						videoScrollPaused: !0,
						videoWaiting: !0,
						usingKeys: !1
					}
				}
				componentDidMount() {
					Tt.dashjs.then(e => {
						const t = this.HTML5StreamPlayerVideo,
							n = this.props.mpegDashSource;
						if (!t || !n) return;
						this.dashPlayer = e.MediaPlayer().create(), this.dashPlayer.getDebug().setLogToBrowserConsole(!1);
						try {
							this.dashPlayer.initialize(t, n, t.autoplay), this.setState({
								muxPlayerInitTime: Date.now()
							}), this.dashPlayer.setFastSwitchEnabled(!0), this.dashPlayer.setInitialBitrateFor("video", 999999999), this.dashPlayer.setAutoSwitchQualityFor("video", !0)
						} catch (s) {
							return
						}
						null != this.props.postId && this.props.onLoadStarted(performance.now()), this.dashPlayer.on(e.MediaPlayer.events.STREAM_INITIALIZED, () => {
							this.getVideoQualityList(), this.getAudioInfo(), null != this.props.postId && this.props.onPlayable(performance.now()), this.controlBarApi && !this.state.hideControlBar && this.controlBarApi.setCurrentTime(0)
						}), this.dashPlayer.on(e.MediaPlayer.events.BUFFER_EMPTY, e => {
							if (null != this.props.postId && Date.now() > this.state.ignoreUnderrunsUntil) {
								const e = P.c(this.props.postId);
								this.props.sendEvent(e), this.setState({
									ignoreUnderrunsUntil: Date.now() + It
								})
							}
						}), this.dashPlayer.on(e.MediaPlayer.events.METRIC_ADDED, e => {
							if (null == this.props.postId) return;
							if (!e || !e.value || !e.metric) return;
							if ("HttpList" !== e.metric) return;
							const t = e.value;
							if ("MediaSegment" !== t.type) return;
							let n, r, s;
							if (t._responseHeaders.split("\n").forEach(e => {
									const t = e.split(":");
									if (2 !== t.length) return;
									const o = t[0].trim(),
										i = t[1].trim();
									"x-cdn-server-region" === o && (n = i), "x-cdn-client-region" === o && (r = i), "x-cdn-name" === o && (s = i)
								}), !n || !r || !s) return;
							Tt.lastGeoPathSeen = Object(w.n)(s, n, r);
							parseInt(i()(this.props.postId).toString(), 16)
						});
						let r = !1;
						Tt.lastGeoPathSeen && ("NA-NA" === Tt.lastGeoPathSeen && this.props.muxSamplingAVariant && k(this.props.muxSamplingAVariant) && (r = !0), "NA-NA" !== Tt.lastGeoPathSeen && this.props.muxSamplingBVariant && L(this.props.muxSamplingBVariant) && (r = !0)), r && v().then(e => {
							if (void 0 !== typeof e) {
								const n = Object(b.y)(this.props.mpegDashSource);
								e.monitor(t, {
									debug: !1,
									disableCookies: !0,
									respectDoNotTrack: !0,
									dashjs: this.dashPlayer,
									data: {
										env_key: "p4fn8p6669977uf0tf86rmkoi",
										player_name: "Reddit Player",
										player_init_time: this.state.muxPlayerInitTime,
										viewer_user_id: null,
										experiment_name: Tt.lastGeoPathSeen,
										video_id: n,
										video_duration: void 0 !== this.props.metadata ? this.props.metadata.length : 0,
										video_stream_type: "on-demand",
										video_cdn: "Fastly"
									}
								})
							}
						})
					});
					const e = this.HTML5StreamPlayerVideo;
					document.addEventListener("webkitfullscreenchange", this.exitHandler, !1), document.addEventListener("fullscreenchange", this.exitHandler, !1), document.addEventListener("mozfullscreenchange", this.exitHandler, !1), document.addEventListener("MSFullscreenChange", this.exitHandler, !1), e && (Object(O.a)() ? e.play() : s.a.safari && !this.props.mpegDashSource && setTimeout(async () => {
						try {
							await e.play()
						} catch (t) {} finally {
							e.pause()
						}
					}), e.oncanplay = () => this.onCanPlay(), e.onprogress = () => this.setBuffered(), e.onseeked = () => this.setState({
						videoWaiting: !1
					}), e.onwaiting = () => this.setState({
						videoWaiting: !0
					}), e.onplaying = e => this.onPlaying(e), e.onloadeddata = e => this.onVideoPlayable(e), e.onloadedmetadata = e => this.sendTransformedMetadata(e), this.props.currentTime && (e.currentTime = this.props.currentTime))
				}
				resetMediaPlayer() {
					this.dashPlayer && this.dashPlayer.reset()
				}
				componentWillUnmount() {
					document.removeEventListener("webkitfullscreenchange", this.exitHandler, !1), document.removeEventListener("fullscreenchange", this.exitHandler, !1), document.removeEventListener("mozfullscreenchange", this.exitHandler, !1), document.removeEventListener("MSFullscreenChange", this.exitHandler, !1), this.resetMediaPlayer(), this.clearControlBarFadeTimer(), null == this.props.postId || this.state.videoScrollPaused || this.sendEvent("served", "video", !0)
				}
				shouldComponentUpdate(e, t) {
					const n = !!this.props.isListing && !this.props.isOverlayOpen && e.isOverlayOpen,
						r = !!this.props.isListing && this.props.isOverlayOpen && !e.isOverlayOpen,
						s = this.props.isOverlayOpen !== e.isOverlayOpen;
					return t.videoFullScreen !== this.state.videoFullScreen || t.videoPaused !== this.state.videoPaused || t.isMuted !== this.state.isMuted || t.hideControlBar !== this.state.hideControlBar || t.settingChange !== this.state.settingChange || t.videoScrollPaused !== this.state.videoScrollPaused || t.videoWaiting !== this.state.videoWaiting || e.shouldPause !== this.props.shouldPause || e.shouldStop !== this.props.shouldStop || t.videoLoaded !== this.state.videoLoaded || t.usingKeys !== this.state.usingKeys || t.resolution !== this.state.resolution || n || r || s
				}
				componentWillReceiveProps(e) {
					const t = this.HTML5StreamPlayerVideo,
						n = t && !t.paused,
						r = !e.shouldStop && this.props.shouldStop,
						s = e.shouldStop && !this.props.shouldStop,
						o = !e.shouldPause && this.props.shouldPause,
						i = e.shouldPause && !this.props.shouldPause,
						c = !this.props.shouldPause && !this.props.shouldStop,
						a = !e.isOverlay && !this.props.isOverlay,
						d = e.isOverlayOpen && !this.props.isOverlayOpen,
						u = !e.isOverlayOpen && this.props.isOverlayOpen,
						l = (c || n) && a && d,
						b = c && a && u;
					if (r && (this.setState({
							videoScrollPaused: !1
						}), this.sendEvent("view", "autoplay")), (o || b) && (!this.state.videoManualPaused && t && t.currentTime < t.duration && (e.currentTime && (t.currentTime = e.currentTime), (this.props.autoplayPref || this.props.shouldIgnoreAutoplayPref || this.props.isOverlay) && this.playVideo()), b && this.sendEvent("change", "pagetype", !0)), (i || l) && (this.pauseVideo(), l && this.sendEvent("change", "pagetype", !0)), s && (this.setState({
							videoScrollPaused: !0
						}), this.sendEvent("served", "video", !0), this.state.videoEnded || (this.sendEvent("scroll", "pause"), this.setVideoMute(!0))), e.mpegDashSource && this.props.mpegDashSource !== e.mpegDashSource) {
						const {
							dashPlayer: t
						} = this;
						try {
							t.setAutoPlay(e.autoPlay), t.attachSource(e.mpegDashSource)
						} catch (p) {}
					}
				}
				updateUsingKeyStatus(e) {
					if (0 !== e.location) return;
					this.state.usingKeys || this.setState({
						usingKeys: !0
					});
					let t = vt;
					this.state.settingChange === mt.Settings && (t = 5 * vt), this.resetControlBarFadeTimer(t)
				}
				setBuffered() {
					const e = this.HTML5StreamPlayerVideo;
					if (e && this.controlBarApi) {
						const t = [];
						for (let n = 0; n < e.buffered.length; n++) {
							const r = {
								start: e.buffered.start(n) / e.duration * 100,
								end: e.buffered.end(n) / e.duration * 100
							};
							t.push(r)
						}
						this.controlBarApi.setBufferedRanges(t)
					}
				}
				getWatchedPercentRange(e, t) {
					const n = e / t;
					return 1 === n ? x.a : n >= .95 ? x.e : n >= .75 ? x.d : n >= .5 ? x.c : n >= .25 ? x.b : 0
				}
				triggerPercentagePixels(e) {
					x.i.forEach(t => {
						t <= e && !this.percentagePixelsFired[t] && (this.props.onWatchedPercent(t), this.percentagePixelsFired[t] = !0)
					})
				}
				triggerTimeWatchedPixels(e) {
					x.j.forEach(t => {
						t <= e && !this.timePixelsFired[t] && (this.props.onWatchedSeconds(t), this.timePixelsFired[t] = !0)
					})
				}
				render() {
					const {
						className: e,
						hideUntilLoaded: t,
						playerClickPlay: n = !0,
						showControlBar: r = !0,
						showSettingsIcon: s = !0
					} = this.props, {
						hasAudio: o,
						hasHovered: i,
						hideControlBar: c,
						isMuted: a,
						settingChange: d,
						videoEnded: l,
						videoLoaded: b
					} = this.state, p = this.HTML5StreamPlayerVideo, m = d === mt.SeekBar, g = b || !t, O = g && p && 0 !== p.currentTime, h = !i && a, y = l && !m, j = Object.assign({}, this.props, {
						bitrateInfo: this.state.bitrateInfo,
						resolution: this.state.resolution,
						setAutoplay: this.setAutoplay,
						setResolution: this.setResolution,
						settingChange: d,
						settingRef: this.setSettingRef,
						toggleSetting: this.toggleSetting
					});
					return u.a.createElement(gt, {
						setRef: this.setContainerRef,
						className: Object(f.a)(e, this.state.videoFullScreen ? _t.a.RedditVideoPlayerRoot__Fullscreen : _t.a.RedditVideoPlayerRoot, this.state.usingKeys ? "using-keys" : null),
						isVisible: g,
						onClick: this.handleClick,
						onKeyDown: this.handleKeyDown,
						onKeyUp: this.handleKeyUp,
						onMouseDown: this.handleMouseDown,
						onMouseEnter: this.handleMouseEnter,
						onMouseLeave: this.handleMouseLeave,
						onMouseMove: this.handleMouseMove,
						onMouseUp: this.handleMouseUp
					}, this.props.blurImageSrc && u.a.createElement(K, {
						src: this.props.blurImageSrc
					}), u.a.createElement("video", {
						poster: this.props.posterUrl,
						loop: this.props.isGif,
						autoPlay: this.props.autoPlay,
						muted: a,
						onTimeUpdate: this.updateTime,
						preload: "metadata",
						ref: e => this.HTML5StreamPlayerVideo = e,
						className: this.state.videoFullScreen ? _t.a.HTML5StreamPlayer__VideoFullscreen : _t.a.HTML5StreamPlayer__VideoRegular
					}, this.props.hlsSource && u.a.createElement("source", {
						src: this.props.hlsSource,
						type: "application/vnd.apple.mpegURL"
					}), this.props.otherSource && u.a.createElement("source", {
						src: this.props.otherSource
					})), y ? u.a.createElement(ut, {
						onClick: this.resetVideo,
						source: this.props.callToActionSource,
						callToAction: this.props.callToActionText
					}) : u.a.createElement(yt, null), this.state.videoWaiting ? O && u.a.createElement(I.a, null) : this.state.videoPaused && !y && u.a.createElement(S.a, {
						onClick: n ? void 0 : this.playPauseVideo
					}), r && u.a.createElement(W.a, {
						clickSnoo: this.clickSnoo,
						controlBarRef: this.setControlBarRef,
						currentTime: p ? p.currentTime : 0,
						hasAudio: o,
						updateContinuousStartTime: this.updateContinuousStartTime,
						enterFullScreen: this.enterFullScreen,
						exitFullScreen: this.exitFullScreen,
						hideControlBar: c,
						isFullScreen: this.state.videoFullScreen,
						isListing: this.props.isListing,
						isMuted: this.state.isMuted,
						isPaused: this.state.videoPaused,
						playPauseVideo: this.playPauseVideo,
						postUrl: this.props.postUrl,
						ref: this.setControlBarApi,
						settingsButton: u.a.createElement(me, j),
						scrubberThumbSource: this.props.scrubberThumbSource,
						seekBarRef: this.setSeekBarRef,
						settingChange: d,
						setVideoPosition: this.setVideoPos,
						setVolume: this.setVolume,
						showSettingsIcon: s,
						showVolumeIcon: h,
						toggleMute: this.toggleMuteVideo,
						totalTime: this.state.totalTime,
						volume: this.props.volume,
						volumeRef: this.setVolumeRef
					}))
				}
			}
			t.b = St(Object(T.b)(Object(C.b)(Tt)))
		},
		"./src/reddit/components/InfoTextTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				Text: "HQ2VJViRjokXpRbJzPvvc",
				text: "HQ2VJViRjokXpRbJzPvvc",
				BottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				bottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				"fade-in": "_1tIZttmhLdrIGrB-6VvZcT",
				fadeIn: "_1tIZttmhLdrIGrB-6VvZcT"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				a = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				d = n("./src/reddit/selectors/tooltip.ts"),
				u = n("./src/reddit/components/InfoTextTooltip/index.m.less"),
				l = n.n(u),
				b = n("./src/lib/lessComponent.tsx");

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			const m = b.a.div("Text", l.a),
				f = b.a.div("BottomText", l.a),
				g = e => s.a.createElement(m, {
					className: e.className,
					style: e.style
				}, e.text, e.children),
				O = e => {
					const t = e.overflow ? e.overflow.left : 0;
					return s.a.createElement(f, {
						className: e.className,
						style: Object.assign({}, e.style, {
							"--infoTextTooltip-overflow-left": "".concat(t, "px")
						})
					}, e.text, e.children)
				},
				h = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(d.b)(n)(e)
					}
				}),
				y = Object(a.a)(O, [c.a.Click, c.a.Keydown]),
				j = Object(a.a)(g, [c.a.Click, c.a.Keydown]),
				_ = Object(o.b)(h);
			t.c = _(e => {
				const {
					caretOnTop: t
				} = e;
				return t ? s.a.createElement(y, p({}, e, {
					targetPosition: ["center", "bottom"],
					tooltipPosition: ["center", "top"]
				})) : s.a.createElement(j, p({}, e, {
					targetPosition: ["center", "top"],
					tooltipPosition: ["center", "bottom"]
				}))
			})
		},
		"./src/reddit/components/Media/EmbedBox/index.m.less": function(e, t, n) {
			e.exports = {
				embedBox: "_3K6DCjWs2dQ93YYZDOHjib"
			}
		},
		"./src/reddit/components/Media/EmbedBox/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/forceHttps/index.ts"),
				u = n("./src/reddit/constants/tracking.ts"),
				l = n("./src/reddit/models/Media/index.ts"),
				b = n("./src/reddit/selectors/user.ts"),
				p = n("./src/reddit/components/Media/EmbedBox/index.m.less"),
				m = n.n(p);
			const f = Object(o.b)(() => Object(i.c)({
				isNightmodeOn: b.V
			}));
			t.a = f(e => {
				const t = {
						responsive: "true",
						is_nightmode: e.isNightmodeOn
					},
					n = e.isResponsive ? Object(c.a)(Object(d.a)(e.source), t) : Object(d.a)(e.source),
					r = {
						overflow: "hidden"
					};
				return r.width = e.width && !e.fullWidth ? "".concat(e.width, "px") : "100%", e.showCentered && (r.margin = "0 auto"), e.isListing || (r.maxHeight = "".concat(l.e, "px")), void 0 !== e.maxHeight && (r.maxHeight = e.maxHeight || void 0), s.a.createElement("iframe", {
					className: Object(a.a)(u.a, m.a.embedBox, e.className),
					height: e.height,
					width: e.width && !e.fullWidth ? e.width : "100%",
					onLoad: e.onLoad,
					ref: e.childRef,
					title: e.title,
					scrolling: "no",
					src: n,
					style: r,
					allowFullScreen: !0
				})
			})
		},
		"./src/reddit/components/Media/ImageBox/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3Oa0THmZ3f5iZXAQ0hBJ0k",
				image: "_2_tDEnGMLxpM6uOa2kaDB3",
				mShowCentered: "_1XWObl-3b9tPy64oaG6fax",
				mShowBlurred: "_3oBPn1sFwq76ZAxXgwRhhn",
				seeMore: "_3hUbl08LBz2mbXjy0iYhOS",
				unblurButtonContainer: "c1UAj_LbgdGBuJFlKbnrQ",
				unblurButton: "_2Ws3wFSVPzJhnW46FsoxLv"
			}
		},
		"./src/reddit/components/Media/ImageBox/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return E
			})), n.d(t, "c", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./node_modules/react/index.js"),
				o = n.n(s),
				i = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/forceHttps/index.ts"),
				l = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				b = n("./src/reddit/components/PlayButton/index.tsx"),
				p = n("./src/reddit/constants/elementClassNames.ts"),
				m = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				g = n("./src/reddit/selectors/user.ts"),
				O = n("./src/reddit/constants/tracking.ts"),
				h = n("./src/reddit/components/Media/ImageBox/index.m.less"),
				y = n.n(h);

			function j() {
				return (j = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var _ = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const E = (e, t) => {
					return e / t > 16 / 9
				},
				v = e => e > 2 * m.e,
				I = e => {
					const t = Object(d.a)(y.a.image, p.h, e.className, {
							[y.a.mShowCentered]: e.showCentered,
							[y.a.mShowBlurred]: e.shouldBlur
						}),
						n = {};
					return e.showFull || e.isTall || (n.maxHeight = "".concat(m.i, "px")), e.isListing || e.isTall && v(e.height) || (n.maxHeight = "".concat(m.e, "px")), e.isExpando && e.maxHeight && (n.maxHeight = "".concat(e.maxHeight, "px")), e.isExpando && e.maxWidth && (n.maxWidth = "".concat(e.maxWidth, "px")), o.a.createElement("img", {
						alt: r.fbt._("Post image", null, {
							hk: "3KfCgs"
						}),
						className: t,
						src: e.src,
						style: n
					})
				},
				S = e => {
					const t = {};
					return (!e.showFull && E(e.height, e.width) || e.shouldBlur) && (t.overflow = "hidden"), e.showFull || (t.maxHeight = "".concat(m.i, "px"), e.shouldBlur && (t.maxWidth = E(e.height, e.width) ? "".concat(m.w, "px") : "".concat(e.width, "px"))), e.showCentered && (t.margin = "0 auto"), e.isExpando && e.maxHeight && (t.maxHeight = "".concat(e.maxHeight, "px")), o.a.createElement("div", {
						className: Object(d.a)(y.a.container, e.className),
						style: t
					}, e.children)
				},
				T = Object(a.c)({
					postPermalink: f.H,
					shouldOpenPostInNewTab: g.X
				}),
				x = Object(i.b)(T);
			t.a = x(e => e.outboundUrl ? o.a.createElement("a", {
				href: e.outboundUrl,
				target: "_blank"
			}, w(e)) : e.isListing && e.postPermalink ? o.a.createElement(c.a, {
				target: e.shouldOpenPostInNewTab ? "_blank" : void 0,
				to: Object(l.a)(e.postPermalink)
			}, w(e)) : w(e));
			const C = (e, t) => o.a.createElement(I, {
					className: Object(d.a)(t.imageClassName, {
						[O.a]: !e
					}),
					height: t.height,
					isExpando: !!t.isExpando,
					isListing: t.isListing,
					isTall: e,
					maxHeight: t.maxHeight,
					maxWidth: t.maxWidth,
					shouldBlur: t.shouldBlur,
					showCentered: t.showCentered,
					showFull: t.showFull,
					src: Object(u.a)(t.source),
					width: t.width
				}),
				w = e => {
					var {
						onClick: t
					} = e, n = _(e, ["onClick"]);
					const s = E(n.height, n.width),
						i = v(n.height) && s;
					let c;
					return n.isNSFW && n.isSpoiler ? c = r.fbt._("Click to see nsfw spoiler", null, {
						hk: "4EdPWu"
					}) : n.isNSFW ? c = r.fbt._("Click to see nsfw", null, {
						hk: "4CErse"
					}) : n.isSpoiler && (c = r.fbt._("Click to see spoiler", null, {
						hk: "1x3iUE"
					})), o.a.createElement(S, j({}, n, {
						className: "".concat(s ? "".concat(O.a, " ") : "").concat(n.className || "")
					}), n.isListing ? o.a.createElement("div", {
						className: n.contentImageClassName
					}, C(s, n)) : o.a.createElement("a", {
						href: n.originalSource,
						onClick: t,
						style: i ? {
							maxWidth: "50%"
						} : {},
						target: "_blank"
					}, C(s, n)), n.isListing && !n.showFull && n.height > m.i && E(n.height, n.width) && o.a.createElement("div", {
						className: y.a.seeMore
					}, r.fbt._("see full image", null, {
						hk: "1Qygw5"
					})), n.isVideoThumbnail && o.a.createElement(b.a, {
						onClick: t
					}), n.shouldBlur && !n.isVideoThumbnail && !n.isListing && o.a.createElement("div", {
						className: y.a.unblurButtonContainer
					}, o.a.createElement("button", {
						className: y.a.unblurButton
					}, c)))
				}
		},
		"./src/reddit/components/Media/LoadingIcon/index.m.less": function(e, t, n) {
			e.exports = {
				image: "_1Wd26c2ichqUxeZVJStEJT"
			}
		},
		"./src/reddit/components/Media/LoadingIcon/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/reddit/components/Media/LoadingIcon/index.m.less"),
				c = n.n(i);
			t.a = () => s.a.createElement("img", {
				className: c.a.image,
				src: "".concat(o.a.assetPath, "/img/loading.gif")
			})
		},
		"./src/reddit/components/Media/MediaContainer/index.m.less": function(e, t, n) {
			e.exports = {
				blur: "_2iaYXFpGyyEGq1rp02cl5w",
				container: "m3aNC6yp8RrNM_-a0rrfa",
				video: "_3PIKVMCKdveCEcyiKr43sU",
				spacer: "_3gBRFDB5C34UWyxEe_U6mD",
				wrapper: "_3JgI-GOrkmyIeDeyzXdyUD",
				mColoredBackground: "_2CSlKHjH7lsjx0IpjORx14"
			}
		},
		"./src/reddit/components/Media/MediaContainer/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/forceHttps/index.ts"),
				c = n("./src/reddit/models/Media/index.ts"),
				a = n("./src/reddit/components/Media/MediaContainer/index.m.less"),
				d = n.n(a);
			const u = e => {
				let t = null;
				(e.showFull || e.height < c.i) && (t = e.height);
				const n = Object.assign({}, t ? {
						maxHeight: "".concat(t, "px")
					} : {}, e.showFull && !e.showCentered ? {
						maxWidth: "".concat(e.width, "px")
					} : {}, e.blurSrc ? {
						overflow: "hidden"
					} : {}),
					r = e.blurSrc ? s.a.createElement("img", {
						className: d.a.blur,
						src: Object(i.a)(e.blurSrc)
					}) : null,
					a = ((e, t, n) => n ? 100 * n : e && t ? e / t * 100 : 100 * c.c)(e.height, e.width, e.forceAspectRatio);
				return s.a.createElement("div", {
					className: Object(o.a)(d.a.container, e.className, {
						[d.a.video]: e.isVideo
					}),
					"data-click-id": "media",
					style: n
				}, r, s.a.createElement("div", {
					className: d.a.spacer,
					style: {
						paddingBottom: "".concat(a, "%")
					}
				}), s.a.createElement("div", {
					className: Object(o.a)(d.a.wrapper, {
						[d.a.mColoredBackground]: !e.blurSrc
					})
				}, e.children))
			};
			t.a = e => {
				if (!e.isListing && !e.alwaysWrapMedia || e.isExpando) {
					return s.a.Children.only(e.children) || s.a.createElement("div", null)
				}
				return s.a.createElement(u, e)
			}
		},
		"./src/reddit/components/Media/VideoBox/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3spkFGVnKMHZ83pDAhW3Mx",
				centered: "_2b68Lt6xHaLir5082LDDA9",
				styledVideo: "tErWI93xEKrI2OkozPs7J"
			}
		},
		"./src/reddit/components/Media/VideoBox/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/lodash/throttle.js"),
				s = n.n(r),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				c = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				u = n("./src/reddit/actions/video.ts"),
				l = n("./src/reddit/constants/tracking.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				p = n("./src/reddit/selectors/user.ts"),
				m = n("./src/reddit/selectors/video.ts");
			n("./node_modules/core-js/modules/es6.symbol.js");
			const f = 100,
				g = f / 2 / 1e3;
			var O = n("./src/lib/forceHttps/index.ts");

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var y = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			class j extends i.a.Component {
				constructor(e) {
					super(e), this.toggle = e => {
						if (e) {
							const e = this.play();
							e && e.catch && e.catch(() => {})
						} else this.pause()
					}, this.ref = null
				}
				play() {
					if (this.ref && this.ref.play) return this.ref.play()
				}
				pause() {
					if (this.ref && this.ref.pause) return this.ref.pause()
				}
				componentDidMount() {
					this.initEventHandlers(), this.toggle(!this.props.shouldPause && (this.props.autoplay || this.props.isNotCardView))
				}
				componentWillUnmount() {
					this.destroyEventHandlers()
				}
				componentWillReceiveProps(e) {
					this.props.shouldPause !== e.shouldPause && this.toggle(!e.shouldPause && (e.autoplay || e.isNotCardView))
				}
				destroyEventHandlers() {
					this.ref && this.cancelBufferingDetector && this.cancelBufferingDetector()
				}
				initEventHandlers() {
					this.ref && this.props.onBufferingChange && (this.cancelBufferingDetector = function(e, t) {
						let n = !1,
							r = !1;
						const s = () => n = !0,
							o = () => r = !0;
						e.addEventListener("loadeddata", s), e.addEventListener("play", o), e.addEventListener("playing", o);
						let i = !1,
							c = 0,
							a = 0;
						const d = window.setInterval(() => {
							if (a = e.currentTime, r) return r = !1, void(c = a);
							if (e.paused || e.seeking || !n) return void(c = a);
							const s = i;
							4 === e.readyState ? i = !1 : !i && a >= c && a < c + g ? i = !0 : i && a >= c && a > c + g && (i = !1), c = a, s !== i && t(i)
						}, f);
						return () => {
							clearInterval(d), e.removeEventListener("playing", o), e.removeEventListener("play", o), e.removeEventListener("loadeddata", s)
						}
					}(this.ref, this.props.onBufferingChange))
				}
				render() {
					const e = this.props,
						{
							autoplay: t,
							isListing: n,
							isNotCardView: r,
							onBufferingChange: s,
							shouldLoad: o,
							shouldPause: c,
							showCentered: a,
							showFull: d,
							source: u
						} = e,
						l = y(e, ["autoplay", "isListing", "isNotCardView", "onBufferingChange", "shouldLoad", "shouldPause", "showCentered", "showFull", "source"]);
					return i.a.createElement("video", h({}, l, {
						ref: e => {
							this.ref = e
						},
						muted: !0
					}), i.a.createElement("source", {
						src: Object(O.a)(this.props.source)
					}))
				}
			}
			var _ = j,
				E = n("./src/reddit/components/Media/VideoBox/index.m.less"),
				v = n.n(E);
			const I = Object(a.c)({
					autoplayPref: p.b,
					consumed: m.b,
					loadTimes: m.f,
					metadata: m.g,
					started: m.i
				}),
				S = Object(c.b)(I, (e, t) => {
					let {
						postId: n
					} = t;
					return {
						onBufferingChanged: t => {
							e(t ? u.w(n) : u.I(n))
						},
						onLoadStarted: t => e(u.v(n, t)),
						onMetadataReceived: t => e(u.H({
							metadata: t,
							postId: n
						})),
						onPaused: () => e(u.D({
							postId: n
						})),
						onPlayable: t => e(u.E(n, t)),
						onPlaying: () => e(u.G(n)),
						onWatched: () => e(u.x(n)),
						onViewableImpression: () => e(u.B(n)),
						onFullyViewableImpression: () => e(u.A(n)),
						onPlayedWithSound: () => e(u.F(n)),
						onWatchedPercent: t => e(u.O(t, n))
					}
				});
			class T extends i.a.Component {
				constructor() {
					super(...arguments), this.percentTriggered = 0, this._checkForConsumption = s()(e => {
						if (this.props.consumed) return;
						const {
							target: t
						} = e;
						t && t.played && 1 === t.played.length && 0 === t.played.start(0) && t.played.end(0) === t.duration && this.props.onWatched()
					}, 200), this.onTimeUpdate = e => {
						e.persist(), this._checkForConsumption(e)
					}, this.onVideoPlayable = e => {
						this.props.metadata || this.sendTransformedMetadata(e), this.props.started || this.props.onPlayable(e.timeStamp)
					}, this.loadStarted = e => {
						this.props.onLoadStarted(e.timeStamp)
					}, this.sendTransformedMetadata = e => {
						this.props.onMetadataReceived({
							id: this.props.postId,
							length: 1e3 * e.target.duration,
							originalHeight: e.target.videoHeight,
							originalWidth: e.target.videoWidth
						})
					}, this.onPaused = e => {
						this.props.onPaused()
					}, this.onPlaying = e => {
						this.props.loadTimes || this.onVideoPlayable(e), this.props.metadata || this.sendTransformedMetadata(e), this.props.onPlaying()
					}, this.renderVideoPlayer = () => {
						const {
							showCentered: e,
							isListing: t
						} = this.props, n = {};
						return e && (n.margin = "0 auto"), t || (n.maxHeight = "".concat(b.e, "px")), i.a.createElement(_, {
							autoplay: this.props.autoplayPref,
							className: Object(d.a)(l.a, v.a.styledVideo),
							height: this.props.height,
							isListing: this.props.isListing,
							isNotCardView: this.props.isNotCardView,
							key: this.props.postId,
							loop: !0,
							onBufferingChange: this.props.onBufferingChanged,
							onLoadStart: this.loadStarted,
							onLoadedData: this.onVideoPlayable,
							onLoadedMetadata: this.sendTransformedMetadata,
							onPause: this.props.onPaused,
							onPlaying: this.onPlaying,
							onTimeUpdate: this.onTimeUpdate,
							shouldLoad: this.props.shouldLoad,
							shouldPause: this.props.shouldPause,
							showCentered: this.props.showCentered,
							showFull: this.props.showFull,
							source: this.props.source,
							style: n,
							width: this.props.width
						})
					}
				}
				render() {
					return this.props.isListing ? this.renderVideoPlayer() : i.a.createElement("div", {
						className: Object(d.a)(v.a.container, this.props.className, {
							[v.a.centered]: this.props.showCentered
						})
					}, i.a.createElement("a", {
						href: this.props.originalSource,
						target: "_blank"
					}, this.renderVideoPlayer()))
				}
			}
			t.a = S(T)
		},
		"./src/reddit/components/NotificationBanners/bannerIds.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.EmailCollectionBannerId = "email-collection-banner-id"
				}(r || (r = {}))
		},
		"./src/reddit/components/OverlayAwareTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/reddit/constants/elementIds.ts"),
				c = n("./src/reddit/contexts/InsideOverlay.tsx");

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}

			function d(e, t) {
				const n = Object(o.a)(e, t);
				class r extends s.a.PureComponent {
					constructor() {
						super(...arguments), this.state = {
							container: null
						}
					}
					componentDidMount() {
						if (this.props.isOverlay) {
							const e = document.getElementById(i.d);
							this.setState({
								container: e
							})
						}
					}
					render() {
						return s.a.createElement(n, a({}, this.props, {
							container: this.state.container,
							excludeContainerPosition: this.props.isOverlay
						}))
					}
				}
				return Object(c.b)(r)
			}
		},
		"./src/reddit/components/PlayButton/index.m.less": function(e, t, n) {
			e.exports = {
				PlayIcon: "_2XQ3ZY6qCbEm9_WtvLLFru",
				playIcon: "_2XQ3ZY6qCbEm9_WtvLLFru",
				PlayContainer: "vLH0XV-l8Y4mNGUvw4HHy",
				playContainer: "vLH0XV-l8Y4mNGUvw4HHy"
			}
		},
		"./src/reddit/components/PlayButton/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/icons/svgs/VideoNewPlayButton/index.m.less"),
				a = n.n(c);
			var d = e => s.a.createElement("svg", {
					className: Object(i.a)(a.a.icon, e.className),
					viewBox: "0 0 50 50",
					xmlns: "http://www.w3.org/2000/svg"
				}, s.a.createElement("g", {
					transform: "translate(1 1)"
				}, s.a.createElement("circle", {
					cx: "24",
					cy: "24",
					r: "24",
					fill: "none",
					stroke: "#fff",
					strokeWidth: "1.92"
				}), s.a.createElement("path", {
					fill: "#fff",
					d: "M33.1 22.2l-11.5-6.7c-.3-.2-.7-.2-1 0-.3.2-.4.5-.4.8v13.4c0 .3.2.7.5.8.1.1.3.1.5.1s.3 0 .5-.1l11.5-6.7c.3-.2.5-.5.5-.8-.1-.3-.3-.6-.6-.8"
				}))),
				u = n("./src/reddit/components/PlayButton/index.m.less"),
				l = n.n(u);
			const b = o.a.wrapped(d, "PlayIcon", l.a),
				p = o.a.div("PlayContainer", l.a);
			t.a = e => s.a.createElement(p, {
				className: e.className,
				onClick: e.onClick
			}, s.a.createElement(b, null))
		},
		"./src/reddit/components/RawHTMLDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				StyledRawHTMLDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH",
				styledRawHtmlDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/polished/dist/polished.es.js"),
				s = n("./node_modules/react/index.js"),
				o = n.n(s),
				i = n("./node_modules/react-redux/es/index.js"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/actions/page.ts"),
				u = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				l = n("./src/reddit/components/RawHTMLDisplay/index.m.less"),
				b = n.n(l);
			const p = Object(i.b)(null, e => ({
					onNavigate: t => e(Object(d.I)(t))
				})),
				m = a.a.wrapped(e => o.a.createElement("div", {
					className: e.className,
					dangerouslySetInnerHTML: {
						__html: e.html
					},
					onClick: t => {
						((e, t, n) => {
							if (!e.ctrlKey && !e.metaKey && 1 !== e.button && "A" === e.target.tagName) {
								e.preventDefault(), t(e.target.getAttribute("href"))
							}
							e.target.classList && e.target.classList.contains("md-spoiler-text") && (e.target.dataset.revealed = !0), n && n(e)
						})(t, e.onNavigate, e.onClick)
					},
					style: Object.assign({}, e.style, {
						"--RawHTMLDisplay-tr-even": Object(r.j)(Object(u.a)(e).body, .8),
						"--RawHTMLDisplay-tr-odd": Object(r.j)(Object(u.a)(e).line, .8)
					})
				}), "StyledRawHTMLDisplay", b.a);
			t.a = p(Object(c.a)(m))
		},
		"./src/reddit/components/RichTextEditor/RTEState/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "a", (function() {
				return g
			}));
			var r = n("./node_modules/lodash/isEqual.js"),
				s = n.n(r),
				o = n("./node_modules/uuid/v4.js"),
				i = n.n(o),
				c = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				a = n("./src/reddit/models/RichTextJson/index.ts");
			let d;
			const u = e => d = e,
				l = () => {
					if (!d) throw new Error("DraftHelpers must be initialized!");
					return d
				},
				b = () => i()().slice(-6),
				p = /\S/,
				m = e => e && e.document && Array.isArray(e.document);
			class f {
				static hasContent(e) {
					if (e.isBound) {
						return e.editorState.getCurrentContent().getBlockMap().some(e => !!e && (Object(c.t)(e.getType()) || Object(c.v)(e.getType()) || p.test(e.getText())))
					}
					return !Object(a.F)(e.initialRTJSON)
				}
				static getTextLength(e) {
					return e.isBound ? e.editorState.getCurrentContent().getPlainText().length : 0
				}
				static getRawText(e) {
					if (e.isBound) return e.editorState.getCurrentContent().getPlainText()
				}
				static isContentEqual(e, t) {
					if (e.isBound && t.isBound) {
						return e.editorState.getCurrentContent() === t.editorState.getCurrentContent()
					}
					return !e.isBound && !t.isBound && s()(e.initialRTJSON, t.initialRTJSON)
				}
				static toRichTextJSON(e, t) {
					if (e.isBound) {
						const n = e.editorState.getCurrentContent();
						return {
							document: l().draftToRTFJson(n, t)
						}
					}
					return e.initialRTJSON
				}
				static getPendingThumbnailUploads(e, t) {
					if (e.isBound) {
						const {
							editorState: n
						} = e;
						return l().getPendingThumbnailUploads(n.getCurrentContent(), t)
					}
				}
				static getMediaCount(e) {
					if (e.isBound) {
						const {
							editorState: t
						} = e;
						return l().getMediaCount(t.getCurrentContent())
					}
					return {
						gifvideo: 0,
						image: 0,
						video: 0,
						total: 0
					}
				}
				static isAllMediaUploaded(e, t) {
					if (e.isBound) {
						const n = e.editorState.getCurrentContent();
						return l().isAllMediaUploaded(n, t)
					}
					return !0
				}
			}
			f.createInitial = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a.i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				return m(e) ? {
					isBound: !1,
					editorKey: b(),
					initialRTJSON: e,
					mediaMetadataMap: t
				} : (console.warn("invalid RTJSON", e), f.createInitial())
			};
			const g = f
		},
		"./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return r
			})), n.d(t, "g", (function() {
				return s
			})), n.d(t, "r", (function() {
				return i
			})), n.d(t, "n", (function() {
				return c
			})), n.d(t, "m", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "s", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "q", (function() {
				return f
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "u", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "o", (function() {
				return _
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "d", (function() {
				return I
			})), n.d(t, "c", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/app/strings/index.ts");
			const r = {
					BOLD: "BOLD",
					ITALIC: "ITALIC",
					SPOILER: "SPOILER",
					STRIKETHROUGH: "STRIKETHROUGH",
					SUBSCRIPT: "SUBSCRIPT",
					SUPERSCRIPT: "SUPERSCRIPT",
					UNDERLINE: "UNDERLINE",
					MONOSPACE: "MONOSPACE",
					HIGHLIGHT: "HIGHLIGHT"
				},
				s = {
					H1: "header-one",
					H2: "header-two",
					H3: "header-three",
					H4: "header-four",
					H5: "header-five",
					H6: "header-six"
				},
				o = new Set(["header-one", "header-two", "header-three", "header-four", "header-five", "header-six"]),
				i = e => o.has(e),
				c = "unstyled",
				a = {
					"header-one": 1,
					"header-two": 2,
					"header-three": 3,
					"header-four": 4,
					"header-five": 5,
					"header-six": 6
				},
				d = {
					1: "header-one",
					2: "header-two",
					3: "header-two",
					4: "header-two",
					5: "header-two",
					6: "header-two"
				},
				u = {
					ORDERED: "ordered-list-item",
					UNORDERED: "unordered-list-item"
				},
				l = e => "ordered-list-item" === e || "unordered-list-item" === e,
				b = "blockquote",
				p = e => e === b,
				m = "code-block",
				f = e => e === m,
				g = "table-cell",
				O = e => e === g,
				h = "media-caption",
				y = e => e === h,
				j = "atomic",
				_ = e => e === j,
				E = e => _(e) || y(e),
				v = Object.assign({
					CODE_BLOCK: m,
					BLOCK_QUOTE: b,
					ATOMIC_BLOCK: j,
					ORDERED_LIST: u.ORDERED,
					TABLE_CELL: g,
					UNORDERED_LIST: u.UNORDERED,
					UNSTYLED: c,
					MEDIA_CAPTION: h
				}, s),
				I = [c, b, g, u.ORDERED, u.UNORDERED],
				S = [c, b, u.ORDERED, u.UNORDERED]
		},
		"./src/reddit/components/RichTextJson/Emote/index.m.less": function(e, t, n) {
			e.exports = {
				container: "JnJcJlA7hHeajn8Um_Bh5"
			}
		},
		"./src/reddit/components/RichTextJson/SpoilerText.m.less": function(e, t, n) {
			e.exports = {
				InnerSpan: "_3mIYu0jAt23sIWGr4pFcI",
				innerSpan: "_3mIYu0jAt23sIWGr4pFcI",
				TooltipTarget: "_2XOXS9oLSigrX7LIefjqhe",
				tooltipTarget: "_2XOXS9oLSigrX7LIefjqhe",
				SpoilerWrapper: "_2v4IIjPhKL0PDaWaWtjJ1E",
				spoilerWrapper: "_2v4IIjPhKL0PDaWaWtjJ1E",
				isOpen: "_15VS32zBYFUDI5ssldQhEK",
				Component: "_3CBmNG6xIaLHHh1ts_10tN",
				component: "_3CBmNG6xIaLHHh1ts_10tN"
			}
		},
		"./src/reddit/components/RichTextJson/SpoilerText.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				c = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				a = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				d = n("./src/reddit/i18n/utils.ts"),
				u = n("./src/reddit/components/RichTextJson/SpoilerText.m.less"),
				l = n.n(u),
				b = n("./src/lib/lessComponent.tsx");

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var m = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const f = ["left", "top"],
				g = ["left", "bottom"],
				O = b.a.span("InnerSpan", l.a),
				h = b.a.span("TooltipTarget", l.a),
				y = b.a.span("SpoilerWrapper", l.a),
				j = b.a.wrapped(e => {
					var {
						className: t,
						isOpen: n
					} = e, r = m(e, ["className", "isOpen"]);
					return s.a.createElement(y, p({}, r, {
						className: Object(o.a)(t, {
							[l.a.isOpen]: n
						})
					}))
				}, "SpoilerWrapper", l.a),
				_ = Object(a.a)(b.a.wrapped(c.b, "Component", l.a), [i.a.Click, i.a.Keydown]);
			class E extends s.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.onClick = e => {
						const {
							isOpen: t
						} = this.state;
						t || (e.preventDefault(), e.stopPropagation(), this.setState({
							isOpen: !0
						}))
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.state.isOpen || this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						isOpen: !1,
						showTooltip: !1
					}
				}
				render() {
					const {
						isOpen: e,
						showTooltip: t
					} = this.state;
					return s.a.createElement(j, {
						isOpen: e,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						onClick: this.onClick
					}, s.a.createElement(O, null, s.a.createElement(h, {
						innerRef: this.setTooltipTargetRef
					}), s.a.createElement(_, {
						isOpen: t,
						tooltipTarget: this.tooltipTargetElement,
						text: Object(d.c)("Reveal spoiler"),
						targetPosition: f,
						tooltipPosition: g
					}), this.props.children))
				}
			}
			t.a = E
		},
		"./src/reddit/components/RichTextJson/elements.m.less": function(e, t, n) {
			e.exports = {
				H1: "_7T4UafM1PdBGycd5na9nF",
				h1: "_7T4UafM1PdBGycd5na9nF",
				H2: "_1WODZhR-x-fbMu3MOL9cH1",
				h2: "_1WODZhR-x-fbMu3MOL9cH1",
				H3: "WFFrvt6_3z5B7MBcYKr8U",
				h3: "WFFrvt6_3z5B7MBcYKr8U",
				H4: "_2UlSUuiYR4BRv_FiLxCcu9",
				h4: "_2UlSUuiYR4BRv_FiLxCcu9",
				H5: "hnYPKCNkyo9X6QpCXHj1I",
				h5: "hnYPKCNkyo9X6QpCXHj1I",
				H6: "_1ceLNhXCFZ1_Lj9Th4go_C",
				h6: "_1ceLNhXCFZ1_Lj9Th4go_C",
				Hr: "_2ACwpV3Y0LKhHHKbsxNmmY",
				hr: "_2ACwpV3Y0LKhHHKbsxNmmY",
				M: "_34q3PgLsx9zIU5BiSOjFoM",
				m: "_34q3PgLsx9zIU5BiSOjFoM",
				Pre: "_3GnarIQX9tD_qsgXkfSDz1",
				pre: "_3GnarIQX9tD_qsgXkfSDz1",
				Blockquote: "_28lDeogZhLGXvE95QRPeDL",
				blockquote: "_28lDeogZhLGXvE95QRPeDL",
				P: "_1qeIAgB0cPwnLhDF9XSiJM",
				p: "_1qeIAgB0cPwnLhDF9XSiJM",
				Li: "_3gqTEjt4x9UIIpWiro7YXz",
				li: "_3gqTEjt4x9UIIpWiro7YXz",
				Ul: "_33MEMislY0GAlB78wL1_CR",
				ul: "_33MEMislY0GAlB78wL1_CR",
				Ol: "_1eJr7K139jnMstd4HajqYP",
				ol: "_1eJr7K139jnMstd4HajqYP",
				B: "_12FoOEddL7j_RgMQN0SNeU",
				b: "_12FoOEddL7j_RgMQN0SNeU",
				I: "_7s4syPYtk5hfUIjySXcRE",
				i: "_7s4syPYtk5hfUIjySXcRE",
				U: "HoWuCifWxDx-PnwllGmZd",
				u: "HoWuCifWxDx-PnwllGmZd",
				Sub: "_2aQztsTwdz2uTN4arsyBD6",
				sub: "_2aQztsTwdz2uTN4arsyBD6",
				Sup: "_1jsgSPRO0cMQfs1UZrSovE",
				sup: "_1jsgSPRO0cMQfs1UZrSovE",
				Table: "MRH-njmSb5ZTkfb1o4dqv",
				table: "MRH-njmSb5ZTkfb1o4dqv",
				Tr: "s6JZe6869f81l9E_5G7Q9",
				tr: "s6JZe6869f81l9E_5G7Q9",
				Tdl: "_3DYfYn_cczg1wj_a3hhyV6",
				tdl: "_3DYfYn_cczg1wj_a3hhyV6",
				Tdc: "_1LHijgw3WoeCUe8AUewfUB",
				tdc: "_1LHijgw3WoeCUe8AUewfUB",
				Tdr: "_3DqGFKR55y45L5IxBTgsFz",
				tdr: "_3DqGFKR55y45L5IxBTgsFz",
				Thl: "_4uv59XIILEFm6V3BmtSuR",
				thl: "_4uv59XIILEFm6V3BmtSuR",
				Thc: "_3TNkDptlyGOiWXvdX_acOB",
				thc: "_3TNkDptlyGOiWXvdX_acOB",
				Thr: "_1AUCpXmm3maPuEbUSe90Y8",
				thr: "_1AUCpXmm3maPuEbUSe90Y8",
				A: "_3t5uN8xUmg0TOwRCOGQEcU",
				a: "_3t5uN8xUmg0TOwRCOGQEcU"
			}
		},
		"./src/reddit/components/RichTextJson/elements.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "w", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "i", (function() {
				return h
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "u", (function() {
				return _
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "m", (function() {
				return I
			})), n.d(t, "n", (function() {
				return S
			})), n.d(t, "t", (function() {
				return T
			})), n.d(t, "p", (function() {
				return x
			})), n.d(t, "o", (function() {
				return C
			})), n.d(t, "q", (function() {
				return w
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "r", (function() {
				return D
			})), n.d(t, "a", (function() {
				return R
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/components/RichTextJson/elements.m.less"),
				c = n.n(i),
				a = n("./src/lib/lessComponent.tsx");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			const u = [a.a.div("H1", c.a), a.a.div("H2", c.a), a.a.div("H3", c.a), a.a.div("H4", c.a), a.a.div("H5", c.a), a.a.div("H6", c.a)],
				l = a.a.hr("Hr", c.a),
				b = a.a.code("M", c.a),
				p = a.a.pre("Pre", c.a),
				m = a.a.blockquote("Blockquote", c.a),
				f = a.a.p("P", c.a),
				g = a.a.li("Li", c.a),
				O = a.a.ul("Ul", c.a),
				h = a.a.ol("Ol", c.a),
				y = a.a.strong("B", c.a),
				j = a.a.em("I", c.a),
				_ = a.a.span("U", c.a),
				E = e => s.a.createElement("del", e),
				v = a.a.sub("Sub", c.a),
				I = a.a.sup("Sup", c.a),
				S = a.a.table("Table", c.a),
				T = a.a.tr("Tr", c.a),
				x = a.a.td("Tdl", c.a),
				C = a.a.td("Tdc", c.a),
				w = a.a.td("Tdr", c.a),
				P = a.a.th("Thl", c.a),
				D = a.a.th("Thc", c.a),
				R = (a.a.th("Thr", c.a), a.a.wrapped(e => s.a.createElement(o.a, d({}, e, {
					isSponsored: !1,
					source: null
				})), "A", c.a))
		},
		"./src/reddit/components/RichTextJson/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_292iotee39Lmt0MkQZ2hPV",
				container: "_292iotee39Lmt0MkQZ2hPV"
			}
		},
		"./src/reddit/components/RichTextJson/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return I
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "a", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/lodash/findLastIndex.js"),
				s = n.n(r),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				c = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/sentry/index.ts"),
				u = n("./src/reddit/constants/elementClassNames.ts"),
				l = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				b = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				p = n("./src/reddit/models/RichTextJson/index.ts"),
				m = n("./src/reddit/components/RichTextJson/media.tsx"),
				f = n("./src/reddit/components/RichTextJson/renderers.tsx"),
				g = n("./src/reddit/components/RichTextJson/index.m.less"),
				O = n.n(g),
				h = n("./src/lib/lessComponent.tsx");

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var j = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const _ = h.a.div("Container", O.a),
				E = Object(a.a)(e => {
					var {
						flairStyleTemplate: t
					} = e, n = j(e, ["flairStyleTemplate"]);
					return i.a.createElement(_, y({}, n, {
						style: {
							color: Object(b.a)(Object(l.a)(Object.assign({
								flairStyleTemplate: t
							}, n)))
						}
					}))
				}),
				v = e => e.e === p.k ? !!e.c && !e.c.every(e => !e.t) : e.e !== p.u || !!e.c && !e.c.every(e => e.e === p.A && !e.t),
				I = e => s()(e, v),
				S = e => e.findIndex(v),
				T = e => {
					const {
						className: t,
						content: n,
						language: r,
						postId: s,
						renderMediaAsLinks: o,
						rtJsonElementProps: a,
						useExplicitTextColor: d
					} = e, l = n.document, b = [], g = e.mediaMetadata || null, O = S(l), h = I(l);
					if (-1 !== O)
						for (let i = O; i <= h; i++) {
							const e = l[i];
							switch (e.e) {
								case p.k:
									b.push(f.c(e, a, i));
									break;
								case p.l:
									b.push(f.d(i));
									break;
								case p.b:
									b.push(f.a(e, g, a, i));
									break;
								case p.c:
									b.push(f.b(e, i));
									break;
								case p.p:
									b.push(f.f(e, g, a, i));
									break;
								case p.z:
									b.push(f.h(e, g, a, i));
									break;
								case p.u:
									b.push(f.g(e, g, a, i));
									break;
								case p.h:
									b.push(Object(m.a)(e, i));
									break;
								case p.m:
								case p.a:
								case p.D:
									b.push(...Object(m.b)(e, i, g, o, r, s))
							}
						}
					return d ? i.a.createElement(_, {
						className: Object(c.a)(u.k, t)
					}, b) : i.a.createElement(E, {
						className: Object(c.a)(u.k, t),
						flairStyleTemplate: e.flairStyleTemplate
					}, b)
				};
			class x extends i.a.Component {
				constructor() {
					super(...arguments), this.hasError = !1, this.state = {
						hasError: !1
					}, this.renderDefaultFallback = () => "Something went wrong while trying to render this"
				}
				componentDidCatch(e) {
					this.setState({
						hasError: !0
					}), this.logError(e)
				}
				logError(e) {
					d.c.withScope(t => {
						t.setExtra("objectInfo", this.props.rtJsonElementProps.renderingObjectInfo), t.setTag("rtjson", "rendering"), d.c.captureException(e)
					})
				}
				render() {
					const e = this.props,
						{
							renderFallback: t = this.renderDefaultFallback
						} = e,
						n = j(e, ["renderFallback"]);
					if (this.hasError || this.state.hasError) return t();
					try {
						return T(n)
					} catch (r) {
						return this.hasError = !0, this.logError(r), t()
					}
				}
			}
		},
		"./src/reddit/components/RichTextJson/media.m.less": function(e, t, n) {
			e.exports = {
				A: "_1PlxnYkerei9iGJsL9JyrP",
				a: "_1PlxnYkerei9iGJsL9JyrP",
				ImageBox: "_2LjgQiHLCZ9LDbCQx5KaOi",
				imageBox: "_2LjgQiHLCZ9LDbCQx5KaOi",
				MediaContainer: "_1uZBAwg0skEanBXfZsIWJh",
				mediaContainer: "_1uZBAwg0skEanBXfZsIWJh",
				Caption: "FJNSiirwoPtG58aeGw2Jx",
				caption: "FJNSiirwoPtG58aeGw2Jx",
				Placeholder: "_2-H7KMbqeJxA6VjyAX4GMX",
				placeholder: "_2-H7KMbqeJxA6VjyAX4GMX",
				giphy: "_3J81Ds3WITP7zlq_PlUmGf"
			}
		},
		"./src/reddit/components/RichTextJson/media.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			})), n.d(t, "b", (function() {
				return w
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				c = n("./src/reddit/components/Media/EmbedBox/index.tsx"),
				a = n("./src/reddit/components/Media/ImageBox/index.tsx"),
				d = n("./src/reddit/components/Media/MediaContainer/index.tsx"),
				u = n("./src/reddit/components/Media/VideoBox/index.tsx"),
				l = n("./src/reddit/helpers/richTextJson/index.ts"),
				b = n("./src/reddit/i18n/utils.ts"),
				p = n("./src/reddit/models/RichTextJson/index.ts"),
				m = n("./src/reddit/components/RichTextJson/elements.tsx"),
				f = n("./src/reddit/components/RichTextJson/media.m.less"),
				g = n.n(f),
				O = n("./src/lib/lessComponent.tsx");

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var y = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const j = /\/(\w+)\/asset\/(\w+)\//,
				_ = O.a.wrapped(m.a, "A", g.a),
				E = O.a.wrapped(a.a, "ImageBox", g.a),
				v = O.a.wrapped(e => {
					var {
						className: t,
						width: n
					} = e, r = y(e, ["className", "width"]);
					return s.a.createElement(d.a, h({
						className: t,
						width: n
					}, r))
				}, "MediaContainer", g.a),
				I = O.a.wrapped(e => s.a.createElement("p", e), "Caption", g.a),
				S = O.a.div("Placeholder", g.a),
				T = O.a.wrapped(e => {
					var {
						className: t,
						e: n
					} = e, r = y(e, ["className", "e"]);
					const o = n === p.D ? Object(b.c)("Processing video...") : Object(b.c)("Processing image...");
					return s.a.createElement(S, h({
						className: t,
						style: {
							"--placeholder-content-text": "'".concat(o, "'")
						}
					}, r))
				}, "Placeholder", g.a),
				x = (e, t) => {
					let {
						c: n,
						x: r,
						y: o
					} = e;
					return s.a.createElement(v, {
						height: o,
						isListing: !1,
						key: t,
						showCentered: !0,
						showFull: !0,
						width: r
					}, s.a.createElement(c.a, {
						isListing: !1,
						source: n,
						height: o,
						width: r,
						showCentered: !0,
						showFull: !0
					}))
				},
				C = (e, t, n) => {
					const r = e.c;
					let i = "";
					return n && (n.e === p.s ? i = n.s.u : n.e === p.r ? i = n.s.gif : n.e === p.t && (i = (e => {
						const t = j.exec(e);
						return t ? "".concat(o.a.redditUrl, "/link/").concat(t[1], "/video/").concat(t[2], "/player") : ""
					})(n.dashUrl))), i ? s.a.createElement(_, {
						href: i,
						key: t,
						title: r
					}, r || i) : null
				},
				w = (e, t, n, r, o, c) => {
					const a = p.E(n, e.id);
					if (r) return [C(e, t, a)];
					const d = [];
					return a ? a.e === p.s ? d.push(((e, t) => {
						let {
							id: n,
							s: r
						} = e;
						return s.a.createElement(v, {
							height: r.y,
							isListing: !1,
							key: t,
							showCentered: !0,
							showFull: !0,
							width: r.x
						}, s.a.createElement(E, {
							originalSource: r.u,
							postId: n,
							source: r.u,
							height: r.y,
							width: r.x,
							shouldBlur: !1,
							showCentered: !0,
							showFull: !0,
							isListing: !1
						}))
					})(a, t)) : a.e === p.r ? d.push(((e, t) => {
						let {
							id: n,
							ext: r,
							s: o
						} = e;
						if (Object(l.d)(n)) {
							const e = r || Object(l.c)(n);
							return s.a.createElement(_, {
								href: e,
								key: t,
								target: "_blank"
							}, o.mp4 ? s.a.createElement("video", {
								className: g.a.giphy,
								loop: !0,
								autoPlay: !0,
								muted: !0
							}, s.a.createElement("source", {
								src: o.mp4
							})) : {
								originalSource: e
							})
						}
						return s.a.createElement(v, {
							height: o.y,
							isListing: !1,
							key: t,
							showCentered: !0,
							showFull: !0,
							width: o.x
						}, s.a.createElement(u.a, {
							height: o.y,
							isListing: !1,
							isNotCardView: !0,
							originalSource: o.mp4,
							width: o.x,
							postId: n,
							source: o.mp4,
							shouldPause: !1,
							showCentered: !0,
							shouldLoad: !0,
							showFull: !0
						}))
					})(a, t)) : a.e === p.t && d.push(((e, t, n) => {
						let {
							hlsUrl: r,
							dashUrl: o,
							x: c,
							y: a,
							isGif: d
						} = e;
						return s.a.createElement(v, {
							height: a,
							isListing: !1,
							isVideo: !0,
							key: t,
							showCentered: !0,
							showFull: !0,
							width: c
						}, s.a.createElement(i.b, {
							shouldLoad: !0,
							shouldPause: !0,
							autoPlay: d,
							hlsSource: r,
							mpegDashSource: o,
							postId: n,
							isGif: d
						}))
					})(a, t, c)) : d.push(function(e, t) {
						let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "en";
						return s.a.createElement(T, {
							e,
							key: t,
							language: n
						})
					}(e.e, t, o)), e.c && d.push(((e, t) => s.a.createElement(I, {
						key: t
					}, e))(e.c, "caption".concat(t))), d
				}
		},
		"./src/reddit/components/RichTextJson/renderers.tsx": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/unicodeUtils/index.ts"),
				s = n("./node_modules/lodash/reduce.js"),
				o = n.n(s),
				i = n("./node_modules/react/index.js"),
				c = n.n(i),
				a = n("./src/reddit/components/RichTextJson/elements.tsx"),
				d = n("./node_modules/uuid/v4.js"),
				u = n.n(d),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				b = n("./src/reddit/models/Product/index.ts"),
				p = n("./src/reddit/models/RichTextJson/index.ts"),
				m = n("./src/reddit/selectors/telemetry.ts"),
				f = n("./src/higherOrderComponents/makeAsync.tsx");
			var g = Object(f.a)({
					ErrorComponent: () => null,
					LoadingComponent: () => null,
					getComponent: () => n.e("RichTextJsonEmoteTooltip").then(n.bind(null, "./src/reddit/components/RichTextJson/Emote/Tooltip/index.tsx")).then(e => e.default)
				}),
				O = n("./src/reddit/components/RichTextJson/Emote/index.m.less"),
				h = n.n(O);
			const y = 1e3,
				j = 1e3;
			var _;
			! function(e) {
				e[e.Inside = 0] = "Inside", e[e.Outside = 1] = "Outside"
			}(_ || (_ = {}));
			class E extends c.a.Component {
				constructor() {
					super(...arguments), this.mouseLocation = _.Outside, this.state = {
						tooltipOpen: !1
					}, this.onClick = () => this.sendEvent("click"), this.onMouseOver = () => {
						this.mouseLocation = _.Inside, setTimeout(() => {
							this.mouseLocation === _.Inside && (this.setState({
								tooltipOpen: !0
							}), this.sendEvent("view"))
						}, y)
					}, this.onMouseOut = () => {
						this.mouseLocation = _.Outside, setTimeout(() => {
							this.mouseLocation !== _.Inside && this.setState({
								tooltipOpen: !1
							})
						}, j)
					}, this.sendEvent = e => {
						this.props.sendEvent(t => {
							const n = m.defaults(t);
							return Object.assign({
								source: "meta",
								action: e,
								noun: "emote"
							}, n, {
								actionInfo: Object.assign({}, n.actionInfo, {
									reason: this.props.node.id
								}),
								subreddit: m.subreddit(t)
							})
						})
					}
				}
				render() {
					const {
						node: e,
						media: t
					} = this.props;
					let n, r, s;
					t.e === p.s ? (n = t.s.x, r = t.s.y, s = t.s.u) : t.e === p.r && (n = t.s.x, r = t.s.y, s = t.s.gif);
					const o = this.state.tooltipOpen ? u()() : void 0;
					return s ? c.a.createElement("div", {
						className: h.a.container,
						onClick: this.onClick,
						onMouseEnter: this.onMouseOver,
						onMouseLeave: this.onMouseOut
					}, c.a.createElement("img", {
						id: o,
						src: s,
						width: n,
						height: r,
						title: ":".concat(Object(b.b)(e.id), ":")
					}), this.state.tooltipOpen && c.a.createElement(g, {
						isOpen: !0,
						emoteId: e.id,
						targetPosition: ["left", "bottom"],
						tooltipId: o,
						tooltipPosition: ["left", "top"]
					})) : null
				}
			}
			var v = Object(l.b)(E),
				I = n("./src/reddit/components/RichTextJson/media.tsx"),
				S = n("./src/reddit/components/RichTextJson/SpoilerText.tsx"),
				T = n("./node_modules/react-redux/es/index.js"),
				x = n("./node_modules/reselect/es/index.js"),
				C = n("./src/lib/loadWithRetries/index.ts"),
				w = n("./src/reddit/components/SubredditMention/SubredditIcon/index.tsx"),
				P = n("./src/reddit/components/SubredditMention/SubredditIconsWeighting/index.m.less"),
				D = n.n(P);
			var R = Object(f.a)({
					ErrorComponent: () => null,
					getComponent: () => Object(C.a)(() => n.e("SubredditMentionWithIcon").then(n.bind(null, "./src/reddit/components/SubredditMention/SubredditIconsWeighting/index.tsx"))).then(e => e.default),
					LoadingComponent: e => {
						let {
							subredditName: t
						} = e;
						return c.a.createElement("span", {
							className: D.a.subredditMentionContainer
						}, c.a.createElement(w.a, {
							href: "/r/".concat(t, "/")
						}, c.a.createElement("span", {
							className: D.a.subredditIconContainer
						}, c.a.createElement(w.b, null)), "r/".concat(t)))
					}
				}),
				A = n("./src/reddit/constants/experiments.ts"),
				k = n("./src/reddit/helpers/trackers/subredditMentions.ts"),
				N = n("./src/reddit/selectors/subredditMention.ts");
			class L extends c.a.PureComponent {
				constructor() {
					super(...arguments), this.handleOnClick = () => {
						const {
							rtJsonElementProps: e,
							sendEvent: t,
							subredditName: n
						} = this.props;
						t(Object(k.a)(Object.assign({}, e, {
							subredditName: n
						})))
					}
				}
				render() {
					const {
						subredditName: e
					} = this.props;
					return c.a.createElement(a.a, {
						onClick: this.handleOnClick,
						href: "/r/".concat(e, "/")
					}, "r/".concat(e))
				}
			}
			const M = Object(l.b)(L),
				U = Object(x.c)({
					isFeatureFlagEnabled: N.b,
					isUserInTreatment: N.e,
					userVariant: N.a
				});
			var F = Object(T.b)(U)(e => {
					let {
						isFeatureFlagEnabled: t,
						isUserInTreatment: n,
						subredditName: r,
						userVariant: s,
						rtJsonElementProps: o
					} = e;
					if (!n || !t) return c.a.createElement(M, {
						subredditName: r,
						rtJsonElementProps: o
					});
					switch (s) {
						case A.Ib.SmIcon:
							return c.a.createElement(R, {
								subredditName: r,
								rtJsonElementProps: o
							});
						case A.Ib.SmIconHc:
							return c.a.createElement(R, {
								subredditName: r,
								isHoverable: !0,
								rtJsonElementProps: o
							});
						default:
							return c.a.createElement(M, {
								subredditName: r,
								rtJsonElementProps: o
							})
					}
				}),
				B = n("./src/reddit/helpers/richTextJson/index.ts");
			n.d(t, "c", (function() {
				return G
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "a", (function() {
				return q
			})), n.d(t, "b", (function() {
				return H
			})), n.d(t, "f", (function() {
				return K
			})), n.d(t, "h", (function() {
				return Y
			})), n.d(t, "g", (function() {
				return z
			})), n.d(t, "i", (function() {
				return J
			})), n.d(t, "e", (function() {
				return Q
			}));
			const G = (e, t, n) => {
					const r = e.c || [],
						s = e.l,
						o = [],
						i = r.length;
					for (let c = 0; c < i; c++) {
						const e = r[c];
						o.push(e.e === p.w ? e.t : Q(e, t, c))
					}
					const d = a.w[s - 1];
					return c.a.createElement(d, {
						key: n
					}, o)
				},
				V = e => c.a.createElement(a.e, {
					key: e
				}),
				q = (e, t, n, r) => {
					const s = e.c;
					if (!s) return;
					const o = s.length,
						i = [];
					for (let c = 0; c < o; c++) i.push(W(s[c], t, n, c));
					return c.a.createElement(a.c, {
						key: r
					}, i)
				},
				H = (e, t) => {
					const n = e.c;
					return c.a.createElement(a.k, {
						key: t
					}, c.a.createElement(a.h, null, n.reduce((e, t, n, r) => e += t.t + (n < r.length ? "\n" : ""), "")))
				},
				K = (e, t, n, r) => {
					let {
						renderingObjectInfo: s
					} = n;
					const o = e.c,
						i = [],
						d = o.length;
					for (let l = 0; l < d; l++) {
						const e = o[l].c;
						e && e.length && i.push(c.a.createElement(a.g, {
							key: l
						}, e.map((e, n) => W(e, t, {
							renderingObjectInfo: s
						}, n))))
					}
					const u = e.o ? a.i : a.v;
					return c.a.createElement(u, {
						key: r
					}, i)
				},
				W = (e, t, n, r) => {
					switch (e.e) {
						case p.b:
							return q(e, t, n, r);
						case p.c:
							return H(e, r);
						case p.k:
							return G(e, n, r);
						case p.l:
							return V(r);
						case p.p:
							return K(e, t, n, r);
						case p.u:
							return z(e, t, n, r);
						case p.z:
							return Y(e, t, n, r)
					}
				},
				Y = (e, t, n, r) => {
					const s = e.c,
						o = e.h,
						i = s.length,
						d = o.length,
						u = [],
						l = [],
						b = [];
					for (let a = 0; a < d; a++) {
						const e = o[a],
							{
								H: r,
								D: s
							} = ee(e.a),
							{
								c: i = []
							} = e;
						u.push(c.a.createElement(r, {
							key: a
						}, J(i, t, n))), b[a] = s
					}
					for (let p = 0; p < i; p++) {
						const e = s[p],
							r = e.length,
							o = [];
						for (let s = 0; s < r; s++) {
							const r = b[s],
								{
									c: i = []
								} = e[s];
							o.push(c.a.createElement(r, {
								key: s
							}, J(i, t, n)))
						}
						l.push(c.a.createElement(a.t, {
							key: p
						}, o))
					}
					return c.a.createElement(a.n, {
						key: r
					}, c.a.createElement("thead", null, c.a.createElement(a.t, null, u)), c.a.createElement("tbody", null, l))
				},
				z = (e, t, n, r) => {
					if (!e.c || !e.c.length) return (e => c.a.createElement(a.j, {
						key: e
					}, c.a.createElement("br", null)))(r);
					const s = e.c[0];
					return s.e !== p.m && s.e !== p.a || !Object(B.d)(s.id) ? c.a.createElement(a.j, {
						key: r
					}, J(e.c, t, n)) : Object(I.b)(s, r, t)
				},
				J = (e, t, n) => {
					const r = [],
						s = e.length;
					for (let o = 0; o < s; o++) {
						const s = e[o];
						if (s.e === p.A) r.push(X(s, o));
						else if (s.e === p.x) r.push(c.a.createElement(S.a, {
							key: o
						}, J(s.c, t, n)));
						else if (s.e === p.n) r.push(c.a.createElement("br", {
							key: o
						}));
						else if (s.e === p.m || s.e === p.a) {
							if (s.id.startsWith("emote|")) {
								const e = p.E(t, s.id);
								e && r.push(c.a.createElement(v, {
									key: o,
									node: s,
									media: e
								}))
							}
						} else r.push(Q(s, n, o))
					}
					return r
				},
				Q = (e, t, n) => {
					switch (e.e) {
						case p.o:
							return c.a.createElement(a.a, {
								href: e.u,
								key: n,
								title: e.a
							}, X({
								t: e.t,
								f: e.f
							}, 0));
						case p.y:
							return c.a.createElement(F, {
								key: n,
								rtJsonElementProps: t,
								subredditName: e.t
							});
						case p.B:
						case p.C:
							return c.a.createElement(a.a, {
								href: "/u/".concat(e.t, "/"),
								key: n
							}, "".concat(e.l ? "/" : "", "u/").concat(e.t));
						case p.g:
						case p.v:
							return c.a.createElement(a.a, {
								href: e.t,
								key: n
							}, e.t)
					}
				},
				X = (e, t) => {
					const {
						f: n,
						t: s
					} = e, o = [];
					if (!n) return $(0, s, t);
					const i = Object(r.a)(s);
					let c = 0,
						a = 0;
					const d = n.length;
					for (; c < d; c++) {
						const [e, t, r] = n[c], d = t + r, u = i[t], l = i[d] - u;
						u > a && o.push($(0, s.substr(a, u - a), "between".concat(c))), o.push($(e, s.substr(u, l), c)), a = u + l
					}
					return a < s.length && o.push($(0, s.substr(a), "remaining".concat(c))), o
				},
				Z = {
					[p.j.monospace]: a.h,
					[p.j.bold]: a.b,
					[p.j.italic]: a.f,
					[p.j.underline]: a.u,
					[p.j.strikethrough]: a.d,
					[p.j.subscript]: a.l,
					[p.j.superscript]: a.m
				},
				$ = (e, t, n) => {
					let r = t;
					return r = o()(Z, (t, r, s) => e & parseInt(s, 10) ? c.a.createElement(r, {
						key: n
					}, t) : t, r)
				},
				ee = e => {
					switch (e) {
						case p.f:
							return {
								H: a.r, D: a.q
							};
						case p.d:
							return {
								H: a.r, D: a.o
							};
						case p.e:
						default:
							return {
								H: a.r, D: a.p
							}
					}
				}
		},
		"./src/reddit/components/Settings/modalIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const r = "change_email_modal_id",
				s = "check_email_modal_id",
				o = "set_email_modal_id",
				i = "verify_email_modal_id"
		},
		"./src/reddit/components/SubredditIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Image: "_34CfAAowTqdbNDYXz5tBTW",
				image: "_34CfAAowTqdbNDYXz5tBTW",
				PlanetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				planetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				BackupImage: "RK004G8fbNOkGdNLEzm67",
				backupImage: "RK004G8fbNOkGdNLEzm67",
				iconContainer: "_7nyhK_sDI_8i22XNdcMzb",
				editableIcon: "_1AxWRIyg1lV9-r_CmqYj0o",
				flexContainer: "-Mpi2pdgifDBOdpUYX2vh",
				clickableUploadText: "_3H6u2CWhsluIPVF14GpEaA",
				inTopBar: "_1UpdjN7u66BU606z97t4HS",
				emptyUploadButton: "ndkYE2hc8Y-V3NHpSYvxA",
				transition: "_1iA7YdCRjbU9Rd_2VNGvsw",
				emptyEditableIcon: "_1h9JeZaSDxkh67Ns3QVUP2",
				emptyPlusButton: "Dh1qxsy_tIctL9f4LEzv9",
				imageUploader: "JBITiVY1zX1mMDq-sHkru",
				tooltip: "uBysfP6qQHdIRAFM6EbWH",
				loadingIcon: "_3Dk8QRKhQImYqds2lSF6G4",
				loadingIconInTopBar: "_1U3KLnHX2TdXL5lNrrv4EW",
				emptyEditableIconInTopBar: "_3-i_fdY8zqHIo3CjuVzTYE"
			}
		},
		"./src/reddit/components/SubredditIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/reddit/constants/colors.ts"),
				i = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				c = n("./src/reddit/i18n/utils.ts"),
				a = n("./src/reddit/icons/svgs/CircledPlanet/index.tsx"),
				d = n("./src/reddit/components/SubredditIcon/index.m.less"),
				u = n.n(d),
				l = n("./src/lib/lessComponent.tsx");

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const m = l.a.img("Image", u.a),
				f = e => {
					var {
						iconColor: t
					} = e, n = p(e, ["iconColor"]);
					return s.a.createElement(m, b({
						style: {
							backgroundColor: t || ""
						}
					}, n))
				},
				g = l.a.wrapped(e => {
					var {
						className: t,
						color: n
					} = e, r = p(e, ["className", "color"]);
					return s.a.createElement(a.a, b({
						className: t,
						style: {
							background: n || ""
						}
					}, r))
				}, "PlanetIcon", u.a),
				O = l.a.div("BackupImage", u.a);
			t.b = e => {
				let t, n;
				if (e.subredditOrProfile) {
					const {
						url: r,
						color: s
					} = Object(i.a)({
						shouldHideNsfwIcon: !!e.shouldHideNsfwIcon,
						subredditOrProfile: e.subredditOrProfile
					});
					t = r, n = s
				} else t = e.iconUrl, n = e.primaryColor || o.a.alienblue;
				if (t) {
					const r = s.a.createElement(f, {
						alt: Object(c.c)("Subreddit icon"),
						className: e.className,
						iconColor: n,
						role: "presentation",
						src: t
					});
					return e.linkTo ? s.a.createElement("a", {
						href: e.linkTo
					}, r) : r
				}
				const r = s.a.createElement(g, {
					className: e.className,
					color: e.redditStyle ? o.a.alienblue : n,
					role: "presentation"
				});
				return e.linkTo ? s.a.createElement("a", {
					href: e.linkTo
				}, r) : r
			}
		},
		"./src/reddit/components/SubredditMention/SubredditIcon/index.m.less": function(e, t, n) {
			e.exports = {
				S: "Zwo7CZoszMU6kBYhWyIC7",
				s: "Zwo7CZoszMU6kBYhWyIC7",
				SubredditIcon: "_33bYVIxJlbFcqiiYlexnqp",
				subredditIcon: "_33bYVIxJlbFcqiiYlexnqp"
			}
		},
		"./src/reddit/components/SubredditMention/SubredditIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/SubredditIcon/index.tsx"),
				c = n("./src/reddit/controls/OutboundLink/index.tsx"),
				a = n("./src/reddit/components/SubredditMention/SubredditIcon/index.m.less"),
				d = n.n(a);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			const l = o.a.wrapped(i.b, "SubredditIcon", d.a),
				b = o.a.wrapped(e => s.a.createElement(c.a, u({}, e, {
					isSponsored: !1,
					source: null
				})), "S", d.a)
		},
		"./src/reddit/components/SubredditMention/SubredditIconsWeighting/index.m.less": function(e, t, n) {
			e.exports = {
				topPostsTitle: "_2Pw8j7a2DYkjTDOFbIdODA",
				hovercardStyle: "_2ktYI4-r7C-HaMk9ulbwog",
				top: "_3rKUrAbYNFvE7-nMDs6lwZ",
				subredditMentionContainer: "_1e2szH8g0XMMM_EuCN8Olk",
				subredditIconContainer: "_3kpwADnYG-SH40aaSdX3ZE"
			}
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			}));
			var r = n("./node_modules/prop-types/index.js"),
				s = n.n(r),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				c = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			class u extends i.a.Component {
				getChildContext() {
					return {
						sendEvent: e => {
							{
								const t = this.context.store.getState(),
									n = e(t);
								Object(a.a)(Object.assign({}, c.defaults(t), n))
							}
						}
					}
				}
				render() {
					return this.props.children ? i.a.Children.only(this.props.children) : null
				}
			}

			function l(e) {
				var t;
				return (t = class extends i.a.Component {
					render() {
						return i.a.createElement(e, d({}, this.props, {
							sendEvent: this.context.sendEvent
						}))
					}
				}).contextTypes = {
					sendEvent: s.a.func
				}, t
			}
			u.contextTypes = {
				store: s.a.object.isRequired
			}, u.childContextTypes = {
				sendEvent: s.a.func.isRequired
			}
		},
		"./src/reddit/components/VideoCTA/index.m.less": function(e, t, n) {
			e.exports = {
				ctaLink: "_2FH_xFiDZCFtYKBJAmSpeD",
				ctaText: "_3uyGw8SwblJ37jvDUd-0Z_",
				ctaWrapper: "_267SSeon8aryjeoh4UclX8"
			}
		},
		"./src/reddit/constants/adEvents.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e[e.Impression = 1] = "Impression", e[e.Click = 2] = "Click", e[e.CommentsView = 3] = "CommentsView", e[e.Upvote = 4] = "Upvote", e[e.Downvote = 5] = "Downvote", e[e.CommentSubmitted = 6] = "CommentSubmitted", e[e.ViewableImpression = 7] = "ViewableImpression", e[e.CommentUpvote = 8] = "CommentUpvote", e[e.CommentDownvote = 9] = "CommentDownvote", e[e.VideoViewableImpression = 100] = "VideoViewableImpression", e[e.VideoFullyViewableImpression = 101] = "VideoFullyViewableImpression", e[e.VideoPlayedWithSound = 102] = "VideoPlayedWithSound", e[e.VideoPlayedExpanded = 103] = "VideoPlayedExpanded", e[e.VideoWatched25 = 104] = "VideoWatched25", e[e.VideoWatched50 = 105] = "VideoWatched50", e[e.VideoWatched75 = 106] = "VideoWatched75", e[e.VideoWatched95 = 107] = "VideoWatched95", e[e.VideoWatched100 = 108] = "VideoWatched100", e[e.VideoStarted = 109] = "VideoStarted", e[e.VideoWatchedSeconds3 = 110] = "VideoWatchedSeconds3", e[e.VideoWatchedSeconds5 = 111] = "VideoWatchedSeconds5", e[e.VideoWatchedSeconds10 = 112] = "VideoWatchedSeconds10"
				}(r || (r = {}))
		},
		"./src/reddit/constants/blade.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "e", (function() {
				return g
			}));
			var r, s, o = n("./node_modules/fbt/lib/FbtPublic.js"),
				i = n("./src/config.ts");
			! function(e) {
				e.NameAndIcon = "nameAndIcon", e.Banner = "banner", e.Global = "global"
			}(r || (r = {})),
			function(e) {
				e.Appearance = "community_appearance", e.Main = "community_mod_tools", e.MenuLinks = "menu_links", e.PostFlairManagement = "postflairmanagement", e.Structure = "community_structure", e.UserFlairManagement = "userflairmanagement", e.Widgets = "community_widgets"
			}(s || (s = {}));
			const c = {
					global: "theme",
					nameAndIcon: "name_icon",
					banner: "banner",
					menu: "menu",
					post: "posts",
					exportImport: "export_import",
					menuLinks: "menu_links",
					widgets: "widgets",
					addWidget: "add_widget",
					editWidget: "edit_widget",
					newWidget: "new_widget",
					reorderWidgets: "reorder_widgets",
					main: "main",
					css: "css",
					idCard: "id_card"
				},
				a = {
					global: s.Appearance,
					nameAndIcon: s.Appearance,
					banner: s.Appearance,
					menu: s.Appearance,
					post: s.Appearance,
					exportImport: s.Appearance,
					menuLinks: s.Appearance,
					widgets: s.Appearance,
					addWidget: s.Widgets,
					editWidget: s.Widgets,
					newWidget: s.Widgets,
					reorderWidgets: s.Widgets,
					main: s.Main,
					css: s.Appearance,
					idCard: "id_card"
				},
				d = {
					button: "button_widget",
					calendar: "calendar_widget",
					custom: "custom_widget",
					image: "image_widget",
					"id-card": "id_card",
					moderators: "moderators_widget",
					"community-list": "community_list_widget",
					"subreddit-rules": "rules_widget",
					textarea: "text_widget",
					"post-flair": "post_flair_widget"
				};
			var u;
			! function(e) {
				e.Add = "add", e.AssignOwnOff = "assign_own_off", e.AssignOwnOn = "assign_own_on", e.Edit = "edit", e.EnableOff = "enable_off", e.EnableOn = "enable_on", e.Remove = "remove", e.Reorder = "reorder"
			}(u || (u = {}));
			const l = {
					primaryColor: s.Appearance,
					highlightColor: s.Appearance,
					backgroundColor: s.Appearance,
					postTitleColor: s.Appearance,
					postBackgroundColor: s.Appearance,
					postDownvoteCountColor: s.Appearance,
					postUpvoteCountColor: s.Appearance,
					bannerBackgroundColor: s.Appearance,
					bannerOverlayColor: s.Appearance,
					menuBackgroundColor: s.Appearance,
					menuLinkColorActive: s.Appearance,
					menuLinkColorInactive: s.Appearance,
					menuLinkColorHover: s.Appearance,
					mobileKeyColor: s.Appearance,
					sidebarWidgetBackgroundColor: s.Widgets,
					sidebarWidgetHeaderColor: s.Widgets,
					submenuBackgroundColor: s.Appearance,
					buttonWidgetButtonColor: s.Widgets,
					buttonWidgetTextColor: s.Widgets,
					buttonWidgetFillColor: s.Widgets,
					buttonWidgetHoverButtonColor: s.Widgets,
					buttonWidgetHoverTextColor: s.Widgets,
					buttonWidgetHoverFillColor: s.Widgets
				},
				b = {
					primaryColor: c.global,
					highlightColor: c.global,
					backgroundColor: c.global,
					postTitleColor: c.post,
					postBackgroundColor: c.post,
					postDownvoteCountColor: c.post,
					postUpvoteCountColor: c.post,
					bannerBackgroundColor: c.banner,
					bannerOverlayColor: c.banner,
					menuBackgroundColor: c.menu,
					menuLinkColorActive: c.menu,
					menuLinkColorInactive: c.menu,
					menuLinkColorHover: c.menu,
					mobileKeyColor: void 0,
					sidebarWidgetBackgroundColor: c.widgets,
					sidebarWidgetHeaderColor: c.widgets,
					submenuBackgroundColor: c.menu,
					buttonWidgetButtonColor: c.widgets,
					buttonWidgetTextColor: c.widgets,
					buttonWidgetFillColor: c.widgets,
					buttonWidgetHoverButtonColor: c.widgets,
					buttonWidgetHoverTextColor: c.widgets,
					buttonWidgetHoverFillColor: c.widgets
				},
				p = {
					main: () => o.fbt._("Back to mod tools", null, {
						hk: "1guMLb"
					}),
					global: () => o.fbt._("Color theme", null, {
						hk: "1I2aAx"
					}),
					banner: () => o.fbt._("Banner", null, {
						hk: "2dndoU"
					}),
					menu: () => o.fbt._("Menu", null, {
						hk: "2Pk5Cr"
					}),
					nameAndIcon: () => o.fbt._("Name & icon", null, {
						hk: "35BKW5"
					}),
					post: () => o.fbt._("Posts", null, {
						hk: "2lz5Zh"
					}),
					exportImport: () => o.fbt._("Manage themes", null, {
						hk: "3JIztr"
					}),
					widgets: () => o.fbt._("Sidebar widgets", null, {
						hk: "1qjncj"
					}),
					addWidget: () => o.fbt._("Add widget", null, {
						hk: "43u3IF"
					}),
					newWidget: () => o.fbt._("New widget", null, {
						hk: "2cXd2M"
					}),
					editWidget: () => o.fbt._("Edit widget", null, {
						hk: "1ZiXVl"
					}),
					menuLinks: () => o.fbt._("Menu links", null, {
						hk: "3SqTA5"
					}),
					css: () => "",
					reorderWidgets: () => "",
					idCard: () => ""
				},
				m = {
					button: () => o.fbt._("Button", null, {
						hk: "3SHU34"
					}),
					"subreddit-rules": () => o.fbt._("Rules", null, {
						hk: "7pEZ"
					}),
					textarea: () => o.fbt._("Textarea", null, {
						hk: "3cLKEP"
					}),
					image: () => o.fbt._("Images", null, {
						hk: "1NsC47"
					}),
					"community-list": () => o.fbt._("Community list", null, {
						hk: "13K5M4"
					}),
					calendar: () => o.fbt._("Calendar", null, {
						hk: "4nqD1o"
					}),
					custom: () => o.fbt._("Custom", null, {
						hk: "4sag5Y"
					}),
					"id-card": () => o.fbt._("ID Card", null, {
						hk: "3RSm35"
					}),
					"post-flair": () => o.fbt._("Post flair", null, {
						hk: "NclBb"
					})
				},
				f = e => "".concat(i.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/").concat(e),
				g = {
					exportImport: f("360008722771-Customize-Appearance-overview"),
					global: f("360008551632-Color-theme"),
					nameAndIcon: f("360008805651-Name-icon"),
					banner: f("360010112892-Banner"),
					menu: f("360010387851-Menu"),
					post: f("360010192832-Posts"),
					menuLinks: f("360010442571-Menu-Links"),
					widgets: f("360010364372-Sidebar-Widgets")
				}
		},
		"./src/reddit/constants/categories.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "f", (function() {
				return b
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r, s = n("./src/reddit/helpers/name/index.ts");
			! function(e) {
				e.Advice = "advice", e.Animals = "animals", e.Art = "art", e.DIY = "dIY", e.Electronics = "electronics", e.Entertainment = "entertainment", e.Fashion = "fashion", e.Food = "food", e.Funny = "funny", e.Gaming = "gaming", e.Health = "health", e.Memes = "memes", e.Music = "music", e.News = "news", e.Outdoors = "outdoors", e.Photography = "photography", e.PicsAndGifs = "picsAndGifs", e.Relationships = "relationships", e.Science = "science", e.Sports = "sports", e.Tv = "tv", e.Tech = "tech", e.Travel = "travel", e.VideoGames = "videoGames", e.Videos = "videos", e.Vroom = "vroom", e.Writing = "writing"
			}(r || (r = {}));
			const o = e => {
					let t = "";
					for (let n = 0; n < e.length; n++) t += e[n], n < e.length - 1 && (t += "+");
					return t
				},
				i = e => "/r/".concat(o(e), "/"),
				c = ["#FAAF2A", "#96DE50", "#F9862D", "#2EA1EA", "#297ACA", "#4DCF65", "#96DE50", "#F9862D", "#FAAF2A", "#297ACA", "#2EA1EA", "#2EA1EA", "#37D2BB", "#4DCF65", "#297ACB", "#96DE50", "#F9862D", "#FAAF2A", "#297ACA", "#2EA1EA", "#297ACA", "#37D2BB", "#96DE50", "#37D2BB", "#4DCF65", "#37D2BB", "#F9862D"],
				a = "event",
				d = "geopopular",
				u = /\s/g,
				l = /&/g,
				b = e => e ? Object(s.f)(e).replace(u, "_").replace(l, "and") : ""
		},
		"./src/reddit/constants/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			}));
			const r = {
					public: "room_public",
					private: "room_private"
				},
				s = 140,
				o = 30,
				i = 10,
				c = 500;
			var a;
			! function(e) {
				e.SubredditChatNotifcationFtux = "chat_subreddit_notification_ftux"
			}(a || (a = {}))
		},
		"./src/reddit/constants/comments.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.Comment = "comment", e.MoreComments = "moreComments", e.ContinueThread = "continueThread"
				}(r || (r = {}))
		},
		"./src/reddit/constants/cookie.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			}));
			const r = "USER",
				s = "alphaModal",
				o = "over18",
				i = "mod_mode_enabled",
				c = "m2m_v5",
				a = "recent_srs",
				d = "_recentclicks2",
				u = "eu_cookie_v2",
				l = "uapp_cookie",
				b = "nightmode",
				p = "_options"
		},
		"./src/reddit/constants/elementClassNames.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "l", (function() {
				return c
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "p", (function() {
				return u
			})), n.d(t, "o", (function() {
				return l
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			}));
			const r = "DraftEditor-contentwrapper",
				s = "public-DraftStyleDefault-block",
				o = "data-offset-key",
				i = "hovered",
				c = "scrollerItem",
				a = "threadline",
				d = "header-user-dropdown",
				u = "voteButton",
				l = "unsubscribe-icon-button",
				b = "RichTextJSON-root",
				p = "ImageBox-image",
				m = "content-type-link",
				f = "styled-outbound-link",
				g = "disco-layout-small-container",
				O = "ListingLayout-backgroundContainer",
				h = "ListingLayout-outerContainer"
		},
		"./src/reddit/constants/elementIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			const r = "bladeContainer",
				s = "header",
				o = "overlayScrollContainer",
				i = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/errors.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.BannedProfile = "BANNED", e.DeletedProfile = "DELETED", e.NotFoundProfile = "NOT_FOUND", e.ForbiddenProfile = "FORBIDDEN"
				}(r || (r = {})),
				function(e) {
					e.Unknown = "Unknown"
				}(s || (s = {}))
		},
		"./src/reddit/constants/experiments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "Pb", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "ub", (function() {
				return o
			})), n.d(t, "vb", (function() {
				return i
			})), n.d(t, "Ob", (function() {
				return c
			})), n.d(t, "Eb", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "S", (function() {
				return l
			})), n.d(t, "kb", (function() {
				return b
			})), n.d(t, "db", (function() {
				return p
			})), n.d(t, "eb", (function() {
				return m
			})), n.d(t, "hb", (function() {
				return f
			})), n.d(t, "ib", (function() {
				return g
			})), n.d(t, "jb", (function() {
				return O
			})), n.d(t, "F", (function() {
				return h
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "q", (function() {
				return j
			})), n.d(t, "J", (function() {
				return _
			})), n.d(t, "K", (function() {
				return E
			})), n.d(t, "L", (function() {
				return v
			})), n.d(t, "M", (function() {
				return I
			})), n.d(t, "C", (function() {
				return S
			})), n.d(t, "lb", (function() {
				return T
			})), n.d(t, "Bb", (function() {
				return x
			})), n.d(t, "mb", (function() {
				return C
			})), n.d(t, "A", (function() {
				return w
			})), n.d(t, "E", (function() {
				return P
			})), n.d(t, "D", (function() {
				return D
			})), n.d(t, "Cb", (function() {
				return R
			})), n.d(t, "wb", (function() {
				return A
			})), n.d(t, "B", (function() {
				return k
			})), n.d(t, "G", (function() {
				return N
			})), n.d(t, "h", (function() {
				return L
			})), n.d(t, "Db", (function() {
				return M
			})), n.d(t, "o", (function() {
				return U
			})), n.d(t, "n", (function() {
				return F
			})), n.d(t, "Tb", (function() {
				return B
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "Ab", (function() {
				return V
			})), n.d(t, "O", (function() {
				return q
			})), n.d(t, "Q", (function() {
				return H
			})), n.d(t, "P", (function() {
				return K
			})), n.d(t, "N", (function() {
				return W
			})), n.d(t, "R", (function() {
				return Y
			})), n.d(t, "a", (function() {
				return z
			})), n.d(t, "p", (function() {
				return J
			})), n.d(t, "gb", (function() {
				return Q
			})), n.d(t, "t", (function() {
				return X
			})), n.d(t, "r", (function() {
				return Z
			})), n.d(t, "s", (function() {
				return $
			})), n.d(t, "Wb", (function() {
				return te
			})), n.d(t, "Sb", (function() {
				return ae
			})), n.d(t, "i", (function() {
				return de
			})), n.d(t, "Rb", (function() {
				return ue
			})), n.d(t, "xb", (function() {
				return be
			})), n.d(t, "zb", (function() {
				return pe
			})), n.d(t, "Z", (function() {
				return me
			})), n.d(t, "Fb", (function() {
				return fe
			})), n.d(t, "Jb", (function() {
				return ge
			})), n.d(t, "k", (function() {
				return Oe
			})), n.d(t, "sb", (function() {
				return he
			})), n.d(t, "pb", (function() {
				return ye
			})), n.d(t, "qb", (function() {
				return _e
			})), n.d(t, "fb", (function() {
				return Ee
			})), n.d(t, "rb", (function() {
				return ve
			})), n.d(t, "ab", (function() {
				return Se
			})), n.d(t, "x", (function() {
				return Ce
			})), n.d(t, "T", (function() {
				return Pe
			})), n.d(t, "tb", (function() {
				return De
			})), n.d(t, "Gb", (function() {
				return Re
			})), n.d(t, "j", (function() {
				return Le
			})), n.d(t, "Qb", (function() {
				return Ue
			})), n.d(t, "ob", (function() {
				return Fe
			})), n.d(t, "Hb", (function() {
				return Be
			})), n.d(t, "I", (function() {
				return Ge
			})), n.d(t, "yb", (function() {
				return Ve
			})), n.d(t, "m", (function() {
				return qe
			})), n.d(t, "Ib", (function() {
				return He
			})), n.d(t, "v", (function() {
				return Ke
			})), n.d(t, "u", (function() {
				return We
			})), n.d(t, "Ub", (function() {
				return Ye
			})), n.d(t, "l", (function() {
				return ze
			})), n.d(t, "V", (function() {
				return Qe
			})), n.d(t, "X", (function() {
				return Xe
			})), n.d(t, "W", (function() {
				return Ze
			})), n.d(t, "U", (function() {
				return $e
			})), n.d(t, "Y", (function() {
				return et
			})), n.d(t, "w", (function() {
				return nt
			})), n.d(t, "nb", (function() {
				return rt
			})), n.d(t, "y", (function() {
				return ot
			})), n.d(t, "z", (function() {
				return it
			})), n.d(t, "b", (function() {
				return ct
			})), n.d(t, "H", (function() {
				return at
			})), n.d(t, "Vb", (function() {
				return dt
			})), n.d(t, "bb", (function() {
				return ut
			})), n.d(t, "cb", (function() {
				return lt
			})), n.d(t, "Lb", (function() {
				return bt
			})), n.d(t, "Kb", (function() {
				return pt
			})), n.d(t, "Mb", (function() {
				return mt
			})), n.d(t, "Nb", (function() {
				return ft
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const r = "typeahead_redesign",
				s = "categories_entrypoint_redesign",
				o = "rails_search_results_follow_button",
				i = "redesign_explore_logged_out_v2",
				c = "trends_all_platforms",
				a = "subreddit_top_content",
				d = "chat_posts_rollout_web",
				u = "chat_posts_holdout",
				l = "guest_survey_1",
				b = "desktop_seo_post_v2_truncate",
				p = "mux_sampling_a",
				m = "mux_sampling_b",
				f = "desktop_seo_post_v2_comment_depth",
				g = "desktop_seo_post_v2_declutter",
				O = "desktop_seo_post_v2_id_card",
				h = "desktop_m2m_home_redirect",
				y = "collapse_pinned_comments",
				j = "d2x_shell_render_mitigation",
				_ = "gold_awarded_comment_highlight",
				E = "gold_extended_awards_tooltip",
				v = "gold_paypal_sdk",
				I = "gold_profile_gilded",
				S = "desktop_general_cleanup",
				T = "rpan_entry_point",
				x = "streaming_subreddit_integration",
				C = "public_awarding",
				w = "desktop_cat_nav_placement_frontpage",
				P = "desktop_guest_exp_top_posts",
				D = "desktop_guest_exp_post_height",
				R = "desktop_posting_difficulty_v2",
				A = "redesign_subreddit_search_fix",
				k = "desktop_frontpage_signup_v1",
				N = "desktop_rails_widgets_frontpage",
				L = "create_polls_painted_door",
				M = "subreddit_mention_d2x",
				U = "d2x_gql_subreddit_page",
				F = "d2x_gql_subreddit_more_posts",
				B = "up_and_coming_leaderboard",
				G = "web_chat_simple_reply",
				V = "d2x_server_load_listing_below",
				q = "guest_post_page_null_self_text",
				H = "guest_post_page_self_text",
				K = "guest_post_page_qa_desc",
				W = "guest_post_page_long_titles",
				Y = "guest_post_page_short_titles",
				z = "ad_left_sidebar_removed",
				J = "d2x_listing_below_all",
				Q = "polls_ga",
				X = "d2x_topic_pages",
				Z = "d2x_tab_badging_logged_in",
				$ = "d2x_tab_badging_logged_out";
			var ee;
			! function(e) {
				e.Control1 = "control_1", e.Control2 = "control_2"
			}(ee || (ee = {}));
			const te = e => e === ee.Control1 || e === ee.Control2;
			var ne, re, se, oe, ie, ce, ae, de, ue, le, be, pe, me, fe, ge, Oe, he, ye, je, _e, Ee, ve, Ie, Se, Te, xe, Ce, we, Pe, De, Re, Ae, ke, Ne, Le, Me, Ue, Fe, Be, Ge, Ve, qe, He, Ke, We, Ye, ze, Je, Qe, Xe, Ze, $e, et, tt, nt, rt, st, ot, it;
			! function(e) {
				e.Enabled = "enabled"
			}(ne || (ne = {})),
			function(e) {
				e.Enabled = "enabled"
			}(re || (re = {})),
			function(e) {
				e.Enabled = "enabled"
			}(se || (se = {})),
			function(e) {
				e.Enabled = "enabled"
			}(oe || (oe = {})),
			function(e) {
				e.Enabled = "enabled"
			}(ie || (ie = {})),
			function(e) {
				e.Enabled = "enabled"
			}(ce || (ce = {})),
			function(e) {
				e.Treatment1 = "treatment_1"
			}(ae || (ae = {})),
			function(e) {
				e.Treatment1 = "treatment_1"
			}(de || (de = {})),
			function(e) {
				e.Holdout = "holdout", e.AdHoldout = "ad_holdout"
			}(ue || (ue = {})),
			function(e) {
				e.TestTreatment1 = "toast", e.TestTreatment2 = "popup", e.TestTreatment3 = "knoxses"
			}(le || (le = {})),
			function(e) {
				e.Treatment1 = "treatment_1"
			}(be || (be = {})),
			function(e) {
				e.ExploreOld = "explore_old", e.ExploreStandardSearchPost = "explore_standard_search_post", e.ExploreStandardSearchCommunity = "explore_standard_search_community", e.ExploreTrendingSearchCommunity = "explore_trending_search_community", e.ExploreTrendingDUCommunity = "explore_trending_du_community", e.ExploreTrendingDUCommunityPopular = "explore_trending_du_community_pop"
			}(pe || (pe = {})),
			function(e) {
				e.On = "on"
			}(me || (me = {})),
			function(e) {
				e.Active = "active"
			}(fe || (fe = {})),
			function(e) {
				e.ShowTopContent = "show_top_content"
			}(ge || (ge = {})),
			function(e) {
				e.Rollout = "enabled", e.Holdout = "holdout"
			}(Oe || (Oe = {})),
			function(e) {
				e.Truncate = "truncate", e.SmallBanner = "small_banner", e.Both = "both"
			}(he || (he = {})),
			function(e) {
				e.Max1 = "max_1", e.Max2 = "max_2"
			}(ye || (ye = {})),
			function(e) {
				e.Treatment1 = "treatment_1", e.Treatment2 = "treatment_2"
			}(je || (je = {})),
			function(e) {
				e.NoActions = "no_actions", e.NoAds = "no_ads", e.NoWidgets = "no_widgets", e.Combined = "combined"
			}(_e || (_e = {})),
			function(e) {
				e.On = "on"
			}(Ee || (Ee = {})),
			function(e) {
				e.IdCard = "id_card", e.RailSwap = "rail_swap"
			}(ve || (ve = {})),
			function(e) {
				e.Narrow = "narrow", e.NarrowCard = "narrow_card"
			}(Ie || (Ie = {})),
			function(e) {
				e.ListingCapped = "listing_capped", e.ListingInfinite = "listing_infinite", e.RightRail = "right_rail", e.ListingInfiniteLightbox = "listing_infinite_lightbox", e.RightRailLightbox = "right_rail_lightbox"
			}(Se || (Se = {})),
			function(e) {
				e.Lightbox = "lightbox"
			}(Te || (Te = {})),
			function(e) {
				e.Enabled = "enabled"
			}(xe || (xe = {})),
			function(e) {
				e.ShellRendered = "shell_rendered"
			}(Ce || (Ce = {})),
			function(e) {
				e.Variant1 = "variant_1"
			}(we || (we = {})),
			function(e) {
				e.TopBanner = "top_banner", e.SortView = "sort_view", e.All = "all"
			}(Pe || (Pe = {})),
			function(e) {
				e.Enabled = "enabled"
			}(De || (De = {})),
			function(e) {
				e.Enabled = "enabled"
			}(Re || (Re = {})),
			function(e) {
				e.Treatment1 = "treatment_1"
			}(Ae || (Ae = {})),
			function(e) {
				e.PostsFromDifferentCommunities = "posts_from_different_communities", e.CommunityDescWithPosts = "community_desc_with_posts"
			}(ke || (ke = {})),
			function(e) {
				e.PostsFromDifferentCommunities = "posts_from_different_communities", e.CommunityDescWithPosts = "community_desc_with_posts"
			}(Ne || (Ne = {})),
			function(e) {
				e.Left = "left", e.LeftBlue = "left_blue", e.Top = "top", e.TopBlue = "top_blue"
			}(Le || (Le = {})),
			function(e) {
				e.TopicsAndDescriptionRequired = "all_required", e.NoneRequired = "none_required"
			}(Me || (Me = {})),
			function(e) {
				e.NoCommunityWidgets = "no_community_widgets", e.NoRulesModerators = "no_rules_moderators", e.RelatedPostsDu = "related_posts_du"
			}(Ue || (Ue = {})),
			function(e) {
				e.MediumHeight = "medium_height", e.OnlyTitles = "only_titles"
			}(Fe || (Fe = {})),
			function(e) {
				e.Treatment1 = "sub_diff_warning_v1", e.Treatment2 = "sub_diff_warning_v2", e.Treatment3 = "sub_diff_recs_v1", e.Treatment4 = "sub_diff_recs_v2"
			}(Be || (Be = {})),
			function(e) {
				e.CurrentThrottled = "current_throttled", e.CurrentUnthrottled = "current_unthrottled", e.CurrentUnthrottledCopy = "current_unthrottled_copy", e.NewPageUnthrottledCopy = "new_page_unthrottled_copy", e.NewPageUnthrottledCopyFields = "new_page_unthrottled_copy_fields", e.NewPopUnthrottledCopy = "new_pop_unthrottled_copy"
			}(Ge || (Ge = {})),
			function(e) {
				e.TopMonth = "top_month", e.Trending = "trending", e.Geo = "geo"
			}(Ve || (Ve = {})),
			function(e) {
				e.Treatment = "treatment"
			}(qe || (qe = {})),
			function(e) {
				e.SmIcon = "sm_icon", e.SmIconHc = "sm_icon_hc"
			}(He || (He = {})),
			function(e) {
				e.Enabled = "enabled"
			}(Ke || (Ke = {})),
			function(e) {
				e.Enabled = "enabled"
			}(We || (We = {})),
			function(e) {
				e.All = "all"
			}(Ye || (Ye = {})),
			function(e) {
				e.Enabled = "enabled"
			}(ze || (ze = {})),
			function(e) {
				e.Treatment = "treatment"
			}(Je || (Je = {})),
			function(e) {
				e.Metadata = "metadata"
			}(Qe || (Qe = {})),
			function(e) {
				e.SelfText = "self_text"
			}(Xe || (Xe = {})),
			function(e) {
				e.PostDescription = "post_description", e.TopComment = "top_comment"
			}(Ze || (Ze = {})),
			function(e) {
				e.TruncTitleSubBrand = "trunc_title_sub_brand", e.TruncTitleReddit = "trunc_title_reddit", e.TruncTitleSub = "trunc_title_sub"
			}($e || ($e = {})),
			function(e) {
				e.TitleSubPtypeBrand = "title_sub_ptype_brand", e.TitleSubPtypeCom = "title_sub_ptype_com"
			}(et || (et = {})),
			function(e) {
				e.Enabled = "enabled"
			}(tt || (tt = {})),
			function(e) {
				e.Active = "active"
			}(nt || (nt = {})),
			function(e) {
				e.Enabled = "enabled"
			}(rt || (rt = {})),
			function(e) {
				e.On = "on"
			}(st || (st = {})),
			function(e) {
				e.BadgeCounterBottom = "badge_counter_bottom", e.BadgeCounterTop = "badge_counter_top", e.BadgeOnlyBottom = "badge_only_bottom"
			}(ot || (ot = {})),
			function(e) {
				e.BadgeOnlyBottom = "badge_only_bottom", e.BadgeOnlyTop = "badge_only_top"
			}(it || (it = {}));
			const ct = {
					[Z]: [ot.BadgeCounterBottom, ot.BadgeCounterTop, ot.BadgeOnlyBottom],
					[$]: [it.BadgeOnlyBottom, it.BadgeOnlyTop],
					[X]: [st.On],
					[Q]: [rt.Enabled],
					[J]: [nt.Active],
					[W]: [$e.TruncTitleSubBrand, $e.TruncTitleReddit, $e.TruncTitleSub],
					[Y]: [et.TitleSubPtypeBrand, et.TitleSubPtypeCom],
					[V]: [Je.Treatment],
					[q]: [Qe.Metadata],
					[H]: [Xe.SelfText],
					[K]: [Ze.PostDescription, Ze.TopComment],
					[B]: [Ye.All],
					[M]: [He.SmIcon, He.SmIconHc],
					[U]: [Ke.Enabled],
					[F]: [We.Enabled],
					[L]: [qe.Treatment],
					[N]: [Ve.TopMonth, Ve.Trending, Ve.Geo],
					[k]: [Ge.CurrentThrottled, Ge.CurrentUnthrottled, Ge.CurrentUnthrottledCopy, Ge.NewPageUnthrottledCopy, Ge.NewPageUnthrottledCopyFields, Ge.NewPopUnthrottledCopy],
					[A]: [fe.Active],
					[D]: [Fe.OnlyTitles, Fe.MediumHeight],
					[P]: [Ue.NoCommunityWidgets, Ue.NoRulesModerators, Ue.RelatedPostsDu],
					community_creation_topics: [Me.TopicsAndDescriptionRequired, Me.NoneRequired],
					[w]: [Le.Top, Le.Left, Le.TopBlue, Le.LeftBlue],
					[T]: [De.Enabled],
					[x]: [Re.Enabled],
					[C]: [Ae.Treatment1],
					focused_vertical_suggestion_v2: [ke.PostsFromDifferentCommunities, ke.CommunityDescWithPosts],
					focused_vertical_suggestion_test: [Ne.PostsFromDifferentCommunities, Ne.CommunityDescWithPosts],
					[S]: [Pe.TopBanner, Pe.SortView, Pe.All],
					[G]: [ze.Enabled],
					[_]: [ne.Enabled],
					[I]: [re.Enabled],
					[E]: [se.Enabled],
					[v]: [oe.Enabled],
					gold_premium_awards: [ie.Enabled],
					gold_premium_indicator: [ce.Enabled],
					[y]: [xe.Enabled],
					desktop_seo_post_v2_lightbox: [Te.Lightbox],
					[h]: [Se.ListingCapped, Se.ListingInfinite, Se.RightRail, Se.ListingInfiniteLightbox, Se.RightRailLightbox],
					desktop_seo_post_v2_narrow: [Ie.Narrow, Ie.NarrowCard],
					[O]: [ve.IdCard, ve.RailSwap],
					[g]: [_e.NoActions, _e.NoAds, _e.NoWidgets, _e.Combined],
					[f]: [ye.Max1, ye.Max2],
					[b]: [he.Truncate, he.SmallBanner, he.Both],
					[l]: [me.On],
					[c]: [ue.Holdout, ue.AdHoldout],
					[r]: [ae.Treatment1],
					[s]: [de.Treatment1],
					[o]: [be.Treatment1],
					[i]: [pe.ExploreOld, pe.ExploreStandardSearchPost, pe.ExploreStandardSearchCommunity, pe.ExploreTrendingSearchCommunity, pe.ExploreTrendingDUCommunity, pe.ExploreTrendingDUCommunityPopular],
					[a]: [ge.ShowTopContent],
					[d]: [Oe.Rollout],
					[u]: [Oe.Holdout],
					[p]: [Ee.On],
					[m]: [Ee.On],
					[R]: [Be.Treatment1, Be.Treatment2, Be.Treatment3, Be.Treatment4],
					[z]: [tt.Enabled]
				},
				at = new Set([X, w, k, i, l, h, "focused_vertical_suggestion_v2", N, V, M]),
				dt = e => e.reduce((e, t, n) => (e[t] = n + 1, e), {}),
				ut = (dt(["NFL", "Gaming", "Memes", "Funny", "Sports", "Wholesome", "Video Games", "Pics & Gifs", "Mindblowing", "Videos", "News", "Cringe", "Schadenfreude", "Science", "Relationships", "Learning", "Photography", "Vroom", "Tech", "Crypto", "TV", "Aww", "Popcorn", "Parenting", "Discussion", "Food", "Beauty", "Outdoors", "Fashion", "Books & Writing", "Art & Design", "Nostalgia", "Music", "Travel", "Health & Fitness"]), dt(["NFL", "Discussion", "Relationships", "Sports", "Gaming", "News", "Beauty", "Health & Fitness", "Learning", "Parenting", "Tech", "Crypto", "Science", "Video Games", "TV", "Popcorn", "Vroom", "Food", "Outdoors", "Fashion", "Books & Writing", "Art & Design", "Nostalgia", "Music", "Travel", "Photography", "Funny", "Wholesome", "Memes", "Aww", "Pics & Gifs", "Mindblowing", "Videos", "Cringe", "Schadenfreude"])),
				lt = dt(["Video Games", "Memes", "Sports", "Wholesome", "Pics & Gifs", "Mindblowing", "Videos", "News", "Science", "Relationships", "Finance & Business", "Learning", "Photography", "Vroom", "Tech", "Crypto", "TV", "Aww", "Parenting", "Discussion", "Gaming", "Food", "Beauty", "Outdoors", "Fashion", "Books & Writing", "Art & Design", "Music", "Travel", "Health & Fitness"]),
				bt = 50,
				pt = 41,
				mt = 20,
				ft = " "
		},
		"./src/reddit/constants/explore.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = 3,
				s = 3
		},
		"./src/reddit/constants/featureThrottling.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/models/FeatureThrottling/index.ts");
			n.d(t, "a", (function() {
				return o
			}));
			const o = {
				[r.B]: (e => ({
					times: e,
					type: s.b.TimesPerSession
				}))(1)
			}
		},
		"./src/reddit/constants/flair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			}));
			var r = n("./src/reddit/constants/colors.ts"),
				s = n("./src/reddit/models/Flair/index.ts");
			const o = 64,
				i = 10,
				c = 10,
				a = 100,
				d = c * (a + 1),
				u = {
					backgroundColor: r.a.defaultFlair,
					id: "",
					modOnly: !1,
					textColor: s.e.Dark,
					textEditable: !1,
					richtext: [],
					text: "",
					type: s.f.Richtext
				},
				l = "t3_flairPreviewExamplePost",
				b = 350
		},
		"./src/reddit/constants/gold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			}));
			const r = "ModerationPage--Modal--AddAward",
				s = "ModerationPage--Modal--DeleteAwardConfirmation",
				o = 20,
				i = 4,
				c = 1e4,
				a = .2,
				d = .1,
				u = .1
		},
		"./src/reddit/constants/graphql.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(r || (r = {}))
		},
		"./src/reddit/constants/history.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.IsOverlay = "isOverlay", e.ScrollOnLoad = "scrollOnLoad", e.CloseLocation = "closeLocation", e.JustLoggedIn = "JustLoggedIn", e.JustLoggedOut = "JustLoggedOut"
				}(r || (r = {}))
		},
		"./src/reddit/constants/inFeedChaining.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			const r = 3,
				s = 5,
				o = 10
		},
		"./src/reddit/constants/keycodes.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "a", (function() {
					return r
				})), n.d(t, "b", (function() {
					return s
				})),
				function(e) {
					e[e.ArrowDown = 40] = "ArrowDown", e[e.ArrowLeft = 37] = "ArrowLeft", e[e.ArrowRight = 39] = "ArrowRight", e[e.ArrowUp = 38] = "ArrowUp", e[e.Backspace = 8] = "Backspace", e[e.Delete = 46] = "Delete", e[e.Enter = 13] = "Enter", e[e.Escape = 27] = "Escape", e[e.F = 70] = "F", e[e.K = 75] = "K", e[e.Space = 32] = "Space", e[e.Tab = 9] = "Tab", e[e.Comma = 188] = "Comma"
				}(r || (r = {})),
				function(e) {
					e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.ArrowUp = "ArrowUp", e.Enter = "Enter", e.Escape = "Escape", e.F = "f", e.Tab = "Tab", e.Space = " ", e.Comma = ","
				}(s || (s = {}))
		},
		"./src/reddit/constants/listings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/i18n/utils.ts");
			const r = new Set(["friends", "random"]);
			var s;
			! function(e) {
				e.All = "all", e.Explore = "explore", e.Home = "home", e.Rpan = "rpan", e.Popular = "popular", e.SubredditCreation = "subredditCreation", e.SubredditLeaderboard = "subredditLeaderboard", e.Topic = "topic", e.Layer = "layer"
			}(s || (s = {}));
			const o = {
				[s.Home]: "/",
				[s.Popular]: "/r/popular/",
				[s.All]: "/r/all/",
				[s.Explore]: "/explore/",
				[s.Rpan]: "/rpan/",
				[s.SubredditCreation]: "/subreddits/create",
				[s.SubredditLeaderboard]: "/subreddits/leaderboard/",
				[s.Topic]: "/t/",
				[s.Layer]: "/r/layer/"
			}
		},
		"./src/reddit/constants/modals.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.ADD_REMOVAL_REASON = "add_removal_reason", e.ALPHA_CONSUMER = "alpha_consumer", e.BADGE_PICKER = "badge_picker", e.BADGE_PURCHASE = "badge_purchase", e.BAN_USER = "ban_user", e.BLADE_NIGHTMODE = "blade_nightmode", e.BLADE_UNSAVED_CHANGES = "blade_unsaved_changes", e.CHANGE_PASSWORD_MODAL_ID = "account_manager_change_password", e.CONFIRM_CLOSE_COIN_MODAL_ID = "confirm_close_coin_modal_id", e.CONFIRM_CLOSE_PREMIUM_MODAL_ID = "confirm_close_premium_modal_id", e.CONTRIBUTOR_REQUEST = "contributor_request", e.CONTRIBUTOR_REQUEST_PENDING = "contributor_request_pending", e.CREATE_SUBREDDIT_CHAT = "create_subreddit_chat", e.DELETE_SUBREDDIT_CHAT = "delete_subreddit_chat", e.DISABLE_TWO_FACTOR = "disable_2fa_modal", e.ECONOMY_SUPPORT_MODAL = "economy_support_modal", e.EDIT_SUBREDDIT_CHAT = "edit_subreddit_chat", e.ENABLE_TWO_FACTOR = "enable_2fa_modal", e.GOLD_INTRODUCTION = "gold_introduction", e.GOLD_MODAL_CLICK_TEST = "gold_modal_click_test", e.GOVERNANCE_OPT_OUT = "governance_opt_out", e.GOVERNANCE_RELEASE_NOTES = "governance_release_notes", e.HARBERGER_TAX_CRYPTO_BANNER_MANAGE = "harberger_tax_crypto_banner_manage", e.HARBERGER_TAX_CRYPTO_BANNER_PURCHASE = "hargerger_tax_crypto_banner_purchase", e.HARBERGER_TAX_BANNER_MANAGE = "harberger_tax_banner_manage", e.HARBERGER_TAX_BANNER_PURCHASE = "harberger_tax_banner_purchase", e.KEYBOARD_SHORTCUTS = "keyboard_shortcuts", e.LOGIN_MODAL_ID = "account_manager_login", e.MANAGE_SUBREDDIT_CHAT = "manage_subreddit_chat", e.MULTIREDDIT_ADD_SUBREDDIT = "multireddit_add_subreddit", e.MULTIREDDIT_CREATE = "multireddit_create", e.MULTIREDDIT_DUPLICATE = "multireddit_duplicate", e.MULTIREDDIT_EDIT = "multireddit_edit", e.MUTE_USER = "mute_user", e.PINNED_POSTS_LIMIT_REACHED = "pinned_posts_limit_reached", e.REDESIGN_MODAL = "redesign_modal", e.REGISTER_MODAL_ID = "account_manager_register", e.SPEZ_MODAL = "spez_modal", e.SUBREDDIT_CHAT_SETTINGS = "subreddit_chat_settings", e.SUBREDDIT_PREMIUM_BADGE_MANAGEMENT = "subreddit_premium_badge_management", e.SUBREDDIT_PREMIUM_GIFT_MODAL = "subreddit_premium_gift", e.SUBREDDIT_PREMIUM_PURCHASE_MODAL = "subreddit_premium_purchase", e.SUBREDDIT_PREMIUM_UPLOAD_MODAL = "subreddit_premium_upload", e.TRANSFER_POINTS = "community_points_transfer", e.TWO_FACTOR_BACKUP_CODES = "two_factor_backup_codes", e.USER_FLAIR_MODAL_ID = "user_flair_modal", e.PAINTER_MODAL = "painter_modal", e.WALLET_REGISTRATION_MODAL = "wallet_registration_modal"
				}(r || (r = {}))
		},
		"./src/reddit/constants/page.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return s
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			}));
			const r = "(frontpage)",
				s = "(modListing)",
				o = "(modListingFiltered)",
				i = "(explore)";
			var c;
			! function(e) {
				e.Frontpage = "frontpage", e.All = "all", e.Mod = "mod", e.Friends = "friends", e.Popular = "popular", e.Explore = "explore", e.PostDetail = "postDetail", e.Topic = "topic", e.OtherDiscussions = "otherDiscussions"
			}(c || (c = {}));
			const a = c.Frontpage,
				d = c.Popular;
			var u;
			! function(e) {
				e[e.Top = 0] = "Top", e[e.Posts = 1] = "Posts", e[e.Listings = 2] = "Listings"
			}(u || (u = {}))
		},
		"./src/reddit/constants/parameters.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "l", (function() {
				return d
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "n", (function() {
				return l
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "t", (function() {
				return g
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "u", (function() {
				return h
			})), n.d(t, "v", (function() {
				return y
			})), n.d(t, "s", (function() {
				return j
			})), n.d(t, "w", (function() {
				return _
			})), n.d(t, "x", (function() {
				return E
			})), n.d(t, "y", (function() {
				return v
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "k", (function() {
				return S
			})), n.d(t, "j", (function() {
				return T
			})), n.d(t, "q", (function() {
				return x
			}));
			const r = "category",
				s = "category_name",
				o = "draft",
				i = "f",
				c = "include_over_18",
				a = "is_multi",
				d = "moderator",
				u = "action",
				l = "newUser",
				b = "q",
				p = "connected_account",
				m = "restrict_sr",
				f = "sort",
				g = "t",
				O = "geo_filter",
				h = "verified",
				y = "verifiedEmail",
				j = "source",
				_ = "v",
				E = "v2",
				v = "show_source",
				I = "feature",
				S = ["ad", "adHash", "clickUrl", g, I],
				T = ["after", "before"],
				x = ["ad", "include_over_18", "q", "restrict_sr", "sort", "t", "type", I, a, r, s, j]
		},
		"./src/reddit/constants/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			}));
			const r = 160,
				s = 120,
				o = 50
		},
		"./src/reddit/constants/preferences.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			}));
			const r = "rpanDuDismissalTime",
				s = "showRpanDu",
				o = "topContentDismissalTime",
				i = "topContentTimesDismissed",
				c = [...["openPostInNewTab", "rememberCommunitySort", "sort", "stylesEnabled", "useMarkdown", "layout", "rememberCommunityLayout", "hasSeenCustomizeFlyout", r, s, o, i], "activityRelevantAds", "thirdPartyDataPersonalizedAds", "thirdPartySiteDataPersonalizedAds", "thirdPartySiteDataPersonalizedContent"]
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "d", (function() {
					return r
				})), n.d(t, "c", (function() {
					return s
				})), n.d(t, "b", (function() {
					return o
				})), n.d(t, "a", (function() {
					return i
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue"
				}(r || (r = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(s || (s = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				i = [9, 13, 32]
		},
		"./src/reddit/constants/spezModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			}));
			const r = "spezmodal",
				s = 15692976e5,
				o = 1569384e6,
				i = "https://www.usa.gov/register-to-vote",
				c = "https://out.reddit.com/t3_d0jy34?url=https%3A%2F%2Fwww.usa.gov%2Fregister-to-vote&token=AQAA7CWNXTo30aiSOjHV2gAgr4pleLxES4SoxFPkO0-ihMCYQYSC&app_name=web2x",
				a = 1569531372e3
		},
		"./src/reddit/constants/subredditLeaderboard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "l", (function() {
				return d
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "f", (function() {
				return f
			}));
			const r = "DEFAULT",
				s = "",
				o = "All Communities",
				i = "top",
				c = "MOD",
				a = "moderating",
				d = "UPANDCOMING",
				u = "up-and-coming",
				l = "/subreddits/leaderboard/",
				b = {
					id: s,
					name: s
				},
				p = {
					id: d,
					name: u
				},
				m = [{
					name: "Sports",
					id: "c1015",
					path: "".concat(l, "sports/")
				}, {
					name: "News",
					id: "c1009",
					path: "".concat(l, "news/")
				}, {
					name: "Gaming",
					id: "c1005",
					path: "".concat(l, "gaming/")
				}, {
					name: "Aww",
					id: "c1000",
					path: "".concat(l, "aww/")
				}],
				f = ["Sports", "Gaming", "News", "TV", "Aww", "Memes", "Pics & Gifs", "Travel", "Tech", "Music"]
		},
		"./src/reddit/constants/things.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = "t1_",
				s = "t3_"
		},
		"./src/reddit/constants/thumbnails.ts": function(e, t, n) {
			"use strict";
			var r;
			! function(e) {
				e.NSFW = "nsfw", e.SELF = "self", e.IMAGE = "image", e.DEFAULT = "default", e.SPOILER = "spoiler"
			}(r || (r = {})), t.a = r
		},
		"./src/reddit/constants/tracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = {
					CLICK: "click",
					CLOSE: "close",
					COMPLETE: "complete",
					DISABLE: "disable",
					DRAG: "drag",
					ENABLE: "enable",
					REJECT: "reject",
					START: "start",
					STOP: "stop",
					VIEW: "view"
				},
				s = {
					POST: "post",
					SCREEN: "screen"
				},
				o = "media-element"
		},
		"./src/reddit/constants/video.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return r
			})), n.d(t, "l", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			}));
			const r = 250,
				s = 500,
				o = 25,
				i = 50,
				c = 75,
				a = 95,
				d = 100,
				u = [o, i, c, a, d],
				l = 3,
				b = 5,
				p = 10,
				m = [l, b, p]
		},
		"./src/reddit/constants/viewabilityEvents.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e[e.Viewable = 1] = "Viewable", e[e.VideoViewable = 2] = "VideoViewable", e[e.VideoFullyViewable = 3] = "VideoFullyViewable", e[e.Impression = 4] = "Impression"
				}(r || (r = {}))
		},
		"./src/reddit/constants/wiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return r
			})), n.d(t, "i", (function() {
				return s
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			}));
			var r;
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			! function(e) {
				e.Create = "create", e.Edit = "edit", e.Revisions = "revisions", e.Settings = "settings"
			}(r || (r = {}));
			const s = "index",
				o = "pages",
				i = "config/automoderator",
				c = "reddit.com",
				a = ["config/description", "config/sidebar", "config/stylesheet", "config/submit_text"],
				d = "fromWikiEditButton",
				u = 256,
				l = 128,
				b = new Set(["edit", "revisions", "settings", "discussions", "revisions", "pages", "create"]),
				p = new Set(["reddit", "config", "special"]),
				m = 3
		},
		"./src/reddit/contexts/InsideOverlay.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			const i = s.a.createContext(!1);

			function c(e) {
				return class extends s.a.Component {
					render() {
						return s.a.createElement(i.Consumer, null, t => s.a.createElement(e, o({}, this.props, {
							isOverlay: t
						})))
					}
				}
			}
		},
		"./src/reddit/contexts/PageLayer/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "t", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/reddit/contexts/PageLayer/selectors.ts");
			n.d(t, "b", (function() {
				return o.a
			})), n.d(t, "c", (function() {
				return o.c
			})), n.d(t, "d", (function() {
				return o.d
			})), n.d(t, "e", (function() {
				return o.e
			})), n.d(t, "f", (function() {
				return o.f
			})), n.d(t, "g", (function() {
				return o.g
			})), n.d(t, "h", (function() {
				return o.h
			})), n.d(t, "i", (function() {
				return o.i
			})), n.d(t, "j", (function() {
				return o.j
			})), n.d(t, "k", (function() {
				return o.k
			})), n.d(t, "l", (function() {
				return o.l
			})), n.d(t, "m", (function() {
				return o.m
			})), n.d(t, "n", (function() {
				return o.n
			})), n.d(t, "o", (function() {
				return o.o
			})), n.d(t, "p", (function() {
				return o.p
			})), n.d(t, "q", (function() {
				return o.q
			})), n.d(t, "r", (function() {
				return o.r
			})), n.d(t, "s", (function() {
				return o.s
			})), n.d(t, "u", (function() {
				return o.t
			})), n.d(t, "v", (function() {
				return o.u
			})), n.d(t, "w", (function() {
				return o.v
			})), n.d(t, "x", (function() {
				return o.w
			})), n.d(t, "y", (function() {
				return o.x
			})), n.d(t, "z", (function() {
				return o.y
			})), n.d(t, "A", (function() {
				return o.z
			})), n.d(t, "B", (function() {
				return o.A
			})), n.d(t, "C", (function() {
				return o.B
			})), n.d(t, "D", (function() {
				return o.C
			})), n.d(t, "E", (function() {
				return o.D
			})), n.d(t, "F", (function() {
				return o.E
			})), n.d(t, "G", (function() {
				return o.F
			})), n.d(t, "H", (function() {
				return o.G
			})), n.d(t, "I", (function() {
				return o.H
			})), n.d(t, "J", (function() {
				return o.I
			})), n.d(t, "K", (function() {
				return o.J
			})), n.d(t, "L", (function() {
				return o.K
			})), n.d(t, "M", (function() {
				return o.L
			})), n.d(t, "N", (function() {
				return o.M
			})), n.d(t, "O", (function() {
				return o.N
			})), n.d(t, "P", (function() {
				return o.O
			})), n.d(t, "Q", (function() {
				return o.P
			})), n.d(t, "R", (function() {
				return o.Q
			})), n.d(t, "S", (function() {
				return o.R
			})), n.d(t, "T", (function() {
				return o.S
			})), n.d(t, "U", (function() {
				return o.T
			})), n.d(t, "V", (function() {
				return o.U
			}));
			const i = s.a.createContext(null),
				c = (e, t) => void 0 !== t ? Object.keys(t).reduce((n, r) => (n[r] = t[r](e), n), {}) : {
					pageLayer: e
				};

			function a(e) {
				return t => (class extends s.a.Component {
					constructor() {
						super(...arguments), this.renderChildren = n => {
							const r = Object.assign({}, this.props, c(n, e));
							return s.a.createElement(t, r)
						}
					}
					render() {
						return s.a.createElement(i.Consumer, null, this.renderChildren)
					}
				})
			}
		},
		"./src/reddit/contexts/PageLayer/selectors.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./node_modules/lodash/isEmpty.js"),
				s = n.n(r),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/isFakeSubreddit/index.ts"),
				a = n("./src/lib/objectSelector/index.ts"),
				d = n("./src/lib/search/index.ts"),
				u = n("./src/reddit/constants/categories.tsx"),
				l = n("./src/reddit/constants/page.ts"),
				b = n("./src/reddit/constants/parameters.ts"),
				p = n("./src/reddit/constants/postLayout.ts"),
				m = n("./src/reddit/constants/posts.ts");
			const f = {
				access: !0,
				config: !0,
				flair: !0,
				mail: !0,
				posts: !0,
				wiki: !0,
				chatConfig: !0,
				chatOperator: !0,
				all: !0
			};
			var g = n("./src/reddit/helpers/flair.ts"),
				O = (n("./node_modules/core-js/modules/es6.array.sort.js"), n("./src/lib/listingSort/index.ts")),
				h = n("./src/lib/makeListingKey/index.ts"),
				y = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				j = n("./src/reddit/selectors/frontpage.ts");
			var _ = (e, t) => {
					const {
						routeMatch: n,
						urlParams: r,
						queryParams: s
					} = t;
					if (!n) return;
					const o = (e => {
						const {
							routeMatch: t,
							urlParams: n,
							queryParams: r
						} = e;
						if (!t) return;
						let s = "";
						switch (t.route.meta.name) {
							case i.xb.PROFILE_COMMENTS:
							case i.xb.PROFILE_POSTS:
								s = r.sort;
								break;
							default:
								s = n.sort
						}
						return s || void 0
					})(t);
					switch (n.route.meta.name) {
						case i.xb.INDEX:
						case i.xb.LISTING:
							return o || Object(j.a)(e);
						case i.xb.SUBREDDIT: {
							const t = r,
								{
									subredditName: n
								} = t,
								o = Object(y.a)(t),
								c = Object(h.a)(n, o, s),
								a = e.listings.postOrder.listingSort[c];
							if (a) {
								const {
									sort: e
								} = Object(O.d)(a.sort);
								return e
							}
							return i.O
						}
						default:
							return o || i.O
					}
				},
				E = n("./src/reddit/models/Flair/index.ts"),
				v = n("./src/reddit/models/Image/index.tsx"),
				I = n("./src/reddit/selectors/experiments/categoriesPlacement.ts"),
				S = n("./src/reddit/selectors/monthsToMinutes.ts"),
				T = n("./src/reddit/selectors/multireddit.ts"),
				x = n("./src/reddit/selectors/postCollection.ts"),
				C = n("./src/reddit/selectors/postDraft.ts"),
				w = n("./src/reddit/selectors/profile.ts"),
				P = n("./src/reddit/selectors/subreddit.ts"),
				D = n("./src/reddit/selectors/subredditModeration.ts"),
				R = n("./src/reddit/selectors/user.ts");
			n.d(t, "e", (function() {
				return A
			})), n.d(t, "y", (function() {
				return k
			})), n.d(t, "E", (function() {
				return N
			})), n.d(t, "K", (function() {
				return L
			})), n.d(t, "M", (function() {
				return M
			})), n.d(t, "x", (function() {
				return U
			})), n.d(t, "C", (function() {
				return F
			})), n.d(t, "A", (function() {
				return B
			})), n.d(t, "S", (function() {
				return G
			})), n.d(t, "v", (function() {
				return V
			})), n.d(t, "u", (function() {
				return q
			})), n.d(t, "z", (function() {
				return H
			})), n.d(t, "J", (function() {
				return K
			})), n.d(t, "D", (function() {
				return Y
			})), n.d(t, "H", (function() {
				return J
			})), n.d(t, "F", (function() {
				return Q
			})), n.d(t, "I", (function() {
				return X
			})), n.d(t, "w", (function() {
				return Z
			})), n.d(t, "c", (function() {
				return $
			})), n.d(t, "a", (function() {
				return ee
			})), n.d(t, "s", (function() {
				return te
			})), n.d(t, "d", (function() {
				return ne
			})), n.d(t, "n", (function() {
				return re
			})), n.d(t, "q", (function() {
				return se
			})), n.d(t, "m", (function() {
				return oe
			})), n.d(t, "o", (function() {
				return ie
			})), n.d(t, "p", (function() {
				return ce
			})), n.d(t, "G", (function() {
				return ae
			})), n.d(t, "h", (function() {
				return de
			})), n.d(t, "i", (function() {
				return ue
			})), n.d(t, "j", (function() {
				return le
			})), n.d(t, "k", (function() {
				return be
			})), n.d(t, "B", (function() {
				return pe
			})), n.d(t, "g", (function() {
				return me
			})), n.d(t, "O", (function() {
				return fe
			})), n.d(t, "Q", (function() {
				return ge
			})), n.d(t, "T", (function() {
				return Oe
			})), n.d(t, "U", (function() {
				return he
			})), n.d(t, "L", (function() {
				return ye
			})), n.d(t, "N", (function() {
				return je
			})), n.d(t, "r", (function() {
				return _e
			})), n.d(t, "P", (function() {
				return Ee
			})), n.d(t, "b", (function() {
				return ve
			})), n.d(t, "t", (function() {
				return Ie
			})), n.d(t, "R", (function() {
				return Se
			})), n.d(t, "f", (function() {
				return Te
			})), n.d(t, "l", (function() {
				return xe
			}));
			const A = e => e ? e.url : "",
				k = e => !!(e && e.routeMatch && i.o.FRONTPAGE.includes(e.routeMatch.route.chunk)),
				N = e => e && e.routeMatch && [i.o.FRONTPAGE, i.o.MULTIREDDIT, i.o.SUBREDDIT].includes(e.routeMatch.route.chunk),
				L = e => e && e.routeMatch && e.routeMatch.route.chunk === i.o.TOPIC,
				M = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (!n || !N(n) || !n.routeMatch) return null;
					const {
						match: r
					} = n.routeMatch, s = r.params.subredditName;
					if (!s) return null;
					const o = Object(P.B)(e, {
						subredditName: s
					});
					return o ? o.name : s
				},
				U = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = M(e, {
						pageLayer: n
					});
					return !!r && Object(c.a)(r)
				},
				F = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = M(e, {
							pageLayer: n
						}),
						s = k(n),
						o = Object(R.K)(e);
					return r === l.g || !o && s && !Object(S.g)(e)
				},
				B = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = M(e, {
						pageLayer: n
					});
					return !(r && !Object(c.a)(r))
				},
				G = e => {
					if (!e || !e.routeMatch) return;
					const {
						route: t
					} = e.routeMatch;
					return t.meta.name
				},
				V = e => !(!e || !e.meta || e.meta.name !== i.xb.COMMENTS),
				q = e => !!(e && e.meta && e.meta.name === i.xb.COMMENTS && e.urlParams.partialCommentId),
				H = e => !(!e || !e.meta || e.meta.name !== i.xb.SEARCH_RESULTS || e.urlParams.subredditName),
				K = e => !!(e && e.meta && e.meta.name === i.xb.SEARCH_RESULTS && e.urlParams.subredditName),
				W = e => !(!e || !e.meta || e.meta.name !== i.xb.COMMENTS || m.b[e.urlParams.routePrefix] !== m.a.PROFILE),
				Y = e => !(!e || !e.meta || e.meta.name !== i.xb.POST_CREATION),
				z = e => !(!e || !e.meta || e.meta.name !== i.xb.POST_DRAFT),
				J = e => !!(e && e.meta && i.ob.has(e.meta.name)),
				Q = e => !!(e && e.meta && i.mb.has(e.meta.name)),
				X = e => !!(e && e.meta && i.Gb.has(e.meta.name)),
				Z = e => !(!e || !e.meta || e.meta.name !== i.xb.EXPLORE),
				$ = e => {
					const t = e && e.urlParams;
					if (!t) return;
					const {
						multiredditName: n,
						username: r
					} = t;
					return {
						multiredditName: n,
						username: r
					}
				},
				ee = e => {
					const t = e && e.urlParams;
					return t ? t.categoryName : void 0
				},
				te = e => {
					const t = e && e.urlParams;
					return t ? t.topicSlug : void 0
				},
				ne = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = $(n);
					if (!r) return null;
					const {
						multiredditName: s,
						username: o
					} = r;
					return s ? Object(T.d)(e, {
						multiredditName: s,
						username: o
					}) : null
				},
				re = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (z(n)) {
						const t = Ie(n);
						return Object(C.e)(e, {
							draftId: t
						})
					}
					const r = n && n.urlParams;
					return r ? r.subredditName : void 0
				},
				se = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (n && n.urlParams && m.b[n.urlParams.routePrefix] === m.a.PROFILE) return null;
					const r = re(e, {
						pageLayer: n
					});
					return r ? Object(P.B)(e, {
						subredditName: r
					}) : null
				},
				oe = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = re(e, {
						pageLayer: n
					});
					return r ? Object(P.G)(e, r) : null
				},
				ie = (e, t) => se(e, t) || le(e, t),
				ce = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = ((e, t) => {
						let {
							pageLayer: n
						} = t;
						const r = oe(e, {
							pageLayer: n
						});
						return r ? e.postFlair[r] : null
					})(e, {
						pageLayer: n
					});
					return r ? r.displaySettings.position : E.b.Right
				},
				ae = e => !!(e && e.routeMatch && i.pb.has(e.routeMatch.route.meta.name)) || W(e) || (e => !(!e || !e.meta || e.meta.name !== i.xb.COLLECTION_COMMENTS || m.b[e.urlParams.routePrefix] !== m.a.PROFILE))(e),
				de = e => {
					const t = e && e.urlParams;
					return t ? t.profileName : void 0
				},
				ue = e => {
					if (e && e.routeMatch && G(e) === i.xb.PROFILE_PRIVATE) return e.routeMatch.match.params.listingType
				},
				le = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = W(n) ? re(e, {
						pageLayer: n
					}) : de(n);
					return r ? Object(w.j)(e, {
						profileName: r
					}) : null
				},
				be = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = W(n) ? re(e, {
						pageLayer: n
					}) : de(n);
					return r ? Object(R.ib)(e, {
						userName: r
					}) : null
				},
				pe = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = le(e, {
							pageLayer: n
						}),
						s = Object(R.i)(e),
						o = s && (s.username ? s.username : s.displayText);
					return !(!o || !r || o !== r.name)
				},
				me = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (pe(e, {
							pageLayer: n
						})) return f
				},
				fe = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (!n) return;
					const {
						key: r
					} = n;
					return e.platform.referrers[r]
				},
				ge = e => e ? e.queryParams : {},
				Oe = e => {
					const t = G(e);
					if (e && t && t === i.xb.SEARCH_RESULTS) return e.queryParams[b.b] ? Object(d.a)(e.queryParams[b.b]) : Object(d.a)(e.queryParams[b.o])
				},
				he = e => e ? e.url : "",
				ye = (e, t) => {
					let n, {
						pageLayer: r
					} = t;
					if (void 0 !== (n = void 0 === r ? e.platform.currentPage : r)) {
						const t = G(n);
						if (t === i.xb.POST_CREATION) return p.g.Large;
						if (t === i.xb.SUBREDDIT_WIKI) return p.g.Classic;
						if (t === i.xb.EXPLORE) return p.g.Classic;
						if (t === i.xb.TOPIC || Object(I.a)(e, {
								pageLayer: r
							}) && (k(r) || F(e, {
								pageLayer: r
							}))) return p.g.Large;
						if (t === i.xb.PROFILE_SNOOBUILDER) return p.g.Classic;
						if (t === i.xb.SUBREDDIT && e.user.prefs.rememberCommunityLayout) {
							const t = ((e, t) => {
								let {
									pageLayer: n
								} = t;
								const r = oe(e, {
									pageLayer: n
								});
								if (r) {
									const t = e.user.prefs.subreddit[r];
									if (t && t.layout) return t.layout
								}
								return null
							})(e, {
								pageLayer: r
							});
							if (t) return p.b[t]
						}
						if (i.pb.has(t)) {
							return je(e, {
								pageLayer: r
							}) ? t === i.xb.PROFILE_POSTS || t === i.xb.PROFILE_PRIVATE ? p.g.Classic : p.g.Compact : t === i.xb.PROFILE_OVERVIEW ? p.g.Large : p.g.Classic
						}
					}
					return e.user.prefs.layout ? p.b[e.user.prefs.layout] : p.g.Classic
				},
				je = (e, t) => {
					let {
						pageLayer: n
					} = t;
					return !!Object(D.t)(e) || !(!n || !n.meta) && n.meta.name === i.xb.MODQUEUE_PAGES
				},
				_e = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = oe(e, {
						pageLayer: n
					});
					if (!r) return !0;
					const s = e.subreddits.about[r];
					return !s || s.showMedia
				},
				Ee = Object(a.a)((e, t) => {
					let {
						pageLayer: n,
						postId: r,
						flairStyleTemplateDraft: s
					} = t;
					const o = e.posts.models[r];
					if (!o) return;
					const c = o.flair.find(e => Object(g.p)(e.type));
					if (!c || void 0 === c.templateId) return;
					const a = oe(e, {
						pageLayer: n
					});
					if (!a || a !== o.belongsTo.id) return;
					if (!e.structuredStyles.models[a]) return;
					const d = e.structuredStyles.flairTemplate,
						u = !!s;
					if (n && n.meta && n.meta.name === i.xb.MODERATION_PAGES && !s) return;
					let l = s || d.models[c.templateId];
					if (!l) return;
					const b = !u && Object(R.V)(e),
						p = n && n.locationState && n.locationState.isOverlay;
					if (b || p) {
						if (!l.postPlaceholderImage) return;
						l = {
							postPlaceholderImage: l.postPlaceholderImage
						}
					}
					return Object.keys(l).filter(e => l[e] !== v.c).reduce((e, t) => (e[t] = l[t], e), {})
				}),
				ve = (e, t) => {
					let {
						pageLayer: n
					} = t;
					return n ? _(e, n) : void 0
				},
				Ie = e => {
					if (e) return z(e) ? e.urlParams.draftId : e.queryParams.draft
				},
				Se = e => e && e.queryParams || {},
				Te = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const r = (e => e ? e.queryParams.collection : void 0)(n);
					return r ? Object(x.q)(e, {
						collectionId: r
					}) : void 0
				},
				xe = Object(o.a)(re, e => e.categories.models, e => e.subreddits.models, e => e.subreddits.byCategory, (e, t, n, r) => {
					if (!e) return;
					const o = Object.keys(t).find(t => {
						const o = r[t];
						if (s()(o)) return !1;
						const i = o.map(e => n[e].name);
						return !s()(i) && Object(u.d)(i) === e
					});
					return o ? t[o] : void 0
				})
		},
		"./src/reddit/controls/Button/index.m.less": function(e, t, n) {
			e.exports = {
				DangerButtonStyles: "_2TFttKq5FzfEJ75z_ZdIum",
				dangerButtonStyles: "_2TFttKq5FzfEJ75z_ZdIum",
				DangerButton: "_1K_eZyG6kthwPn55PD-EMM",
				dangerButton: "_1K_eZyG6kthwPn55PD-EMM",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				PrimaryLinkButton: "wLV79_wV-ziNiWmf3Y7OV",
				primaryLinkButton: "wLV79_wV-ziNiWmf3Y7OV",
				PrimaryRouterLink: "_3UhcBirLMXHSbN5vYYBGSF",
				primaryRouterLink: "_3UhcBirLMXHSbN5vYYBGSF",
				PrimaryButton: "_2JBsHFobuapzGwpHQjrDlD",
				primaryButton: "_2JBsHFobuapzGwpHQjrDlD",
				SecondaryLinkButton: "_1HunhFR-0b-AYs0WG9mU_P",
				secondaryLinkButton: "_1HunhFR-0b-AYs0WG9mU_P",
				SecondaryRouterLink: "_2yhUdcPyG1k3qsmDb4y6u_",
				secondaryRouterLink: "_2yhUdcPyG1k3qsmDb4y6u_",
				SecondaryButton: "PiO8QDmoJoOL2sDjJAk4C",
				secondaryButton: "PiO8QDmoJoOL2sDjJAk4C",
				TertiaryButton: "_1McO-Omm_mC2bkTnVgD6NV",
				tertiaryButton: "_1McO-Omm_mC2bkTnVgD6NV",
				TertiaryLinkButton: "_9Yn-qhIEvQgFU6jnrKkSC",
				tertiaryLinkButton: "_9Yn-qhIEvQgFU6jnrKkSC",
				TertiaryRouterLink: "SuTcOCtRzb-pPZYaAZTjh",
				tertiaryRouterLink: "SuTcOCtRzb-pPZYaAZTjh",
				GoldButton: "_2GYoN_LmWsKeeYnfg8wF7N",
				goldButton: "_2GYoN_LmWsKeeYnfg8wF7N",
				PremiumButton: "_14IRbTHWqATJbFJ9PgPswU",
				premiumButton: "_14IRbTHWqATJbFJ9PgPswU",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return p
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "j", (function() {
				return j
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "o", (function() {
				return I
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "d", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				c = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/Button/index.m.less"),
				d = n.n(a);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const b = (e, t, n) => Object(o.a)(e, {
				[d.a.redditStyle]: !(!t && !n)
			});
			c.a.wrapped(e => {
				const {
					className: t,
					redditStyle: n,
					"data-redditstyle": r
				} = e, o = l(e, ["className", "redditStyle", "data-redditstyle"]);
				return s.a.createElement("button", u({
					className: b(t, n, r)
				}, o))
			}, "Button", d.a);
			const p = e => {
					var {
						className: t,
						redditStyle: n,
						"data-redditstyle": r
					} = e, o = l(e, ["className", "redditStyle", "data-redditstyle"]);
					return s.a.createElement(i.a, u({
						className: b(t, n, r)
					}, o))
				},
				m = e => {
					var {
						className: t,
						redditStyle: n,
						"data-redditstyle": r
					} = e, o = l(e, ["className", "redditStyle", "data-redditstyle"]);
					return s.a.createElement("a", u({
						className: b(t, n, r)
					}, o))
				},
				f = e => {
					var {
						className: t,
						redditStyle: n,
						"data-redditstyle": r
					} = e, o = l(e, ["className", "redditStyle", "data-redditstyle"]);
					return s.a.createElement("button", u({
						className: b(t, n, r)
					}, o))
				},
				g = c.a.wrapped(m, "PrimaryLinkButton", d.a),
				O = c.a.wrapped(p, "PrimaryRouterLink", d.a),
				h = c.a.wrapped(f, "PrimaryButton", d.a),
				y = c.a.wrapped(f, "DangerButton", d.a),
				j = c.a.wrapped(m, "SecondaryLinkButton", d.a),
				_ = c.a.wrapped(p, "SecondaryRouterLink", d.a),
				E = c.a.wrapped(f, "SecondaryButton", d.a),
				v = c.a.wrapped(f, "TertiaryButton", d.a),
				I = (c.a.wrapped(m, "TertiaryLinkButton", d.a), c.a.wrapped(p, "TertiaryRouterLink", d.a)),
				S = c.a.wrapped(f, "GoldButton", d.a),
				T = c.a.wrapped(f, "PremiumButton", d.a),
				x = c.a.wrapped(f, "ChatButton", d.a),
				C = c.a.wrapped(f, "InlineTextButton", d.a)
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/helpers/path/index.ts"),
				a = n("./src/reddit/controls/InternalLink/index.m.less"),
				d = n.n(a);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			t.a = e => {
				var {
					children: t,
					className: n,
					disabled: r,
					replace: a,
					to: b
				} = e, p = l(e, ["children", "className", "disabled", "replace", "to"]);
				return r ? s.a.createElement("span", {
					className: Object(i.a)(d.a.disabledLink, n)
				}, t) : ("string" == typeof b && (b = Object(c.b)(b)), s.a.createElement(o.a, u({
					className: n,
					to: b
				}, p), t))
			}
		},
		"./src/reddit/controls/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/lodash/omit.js"),
				s = n.n(r),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				c = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/addQueryParams/index.ts");
			var u = (e, t) => t ? Object(d.a)(e, {
					user_id: t
				}) : e,
				l = n("./src/lib/opener/index.ts"),
				b = n("./src/lib/redditId/index.ts"),
				p = n("./src/reddit/selectors/user.ts");

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			const f = Object(a.a)(p.a, p.i, (e, t) => ({
					allowClickTracking: e,
					userId: t ? Object(b.a)(t.id) : null
				})),
				g = Object(c.b)(f, {}),
				O = (e, t, n, r) => {
					r && t.outboundUrl && t.outboundUrlExpiration && t.outboundUrlExpiration > Date.now() && (e.href = u(t.outboundUrl, n))
				},
				h = g(e => {
					const {
						allowClickTracking: t,
						href: n,
						isSponsored: r,
						source: o,
						userId: c
					} = e;
					let a = s()(e, ["allowClickTracking", "isSponsored", "source", "userId"]);
					const d = o && o.outboundUrl && r ? o.outboundUrl : n;
					return a = Object.assign({}, a, {
						href: d,
						rel: l.a,
						target: l.c.BLANK
					}), !o || (e => {
						const {
							outboundUrlCreated: t,
							outboundUrlReceived: n
						} = e;
						return !(!t || !n) && (t > n + 3e5 || t < n - 36e5)
					})(o) ? i.a.createElement("a", a) : i.a.createElement("a", m({}, a, {
						onMouseDown: e => {
							if (1 === e.button || 2 === e.button || e.ctrlKey) return !0;
							O(e.currentTarget, o, c, t)
						},
						onMouseLeave: e => ((e, t) => {
							e.href = t
						})(e.currentTarget, d),
						onTouchStart: e => O(e.currentTarget, o, c, t)
					}))
				});
			t.a = h
		},
		"./src/reddit/controls/OutboundLink/styled.tsx": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/lessComponent.tsx"),
				s = n("./src/reddit/constants/elementClassNames.ts"),
				o = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/controls/OutboundLink/styles.m.less"),
				c = n.n(i);
			t.a = r.a.wrapped(o.a, "styledOutboundLink", {
				styledOutboundLink: "".concat(c.a.styledOutboundLink, " ").concat(s.m)
			})
		},
		"./src/reddit/controls/OutboundLink/styles.m.less": function(e, t, n) {
			e.exports = {
				styledOutboundLink: "_13svhQIUZqD9PVzFcLwOKT"
			}
		},
		"./src/reddit/customMiddleware/gqlContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			}));
			var r = n("./src/config.ts");
			const s = e => {
					let {
						apiUrl: t,
						onBeforeRequest: n,
						onResponse: r,
						statsAppName: s,
						headers: o
					} = e;
					return {
						apiUrl: t,
						onBeforeRequest: n,
						onResponse: r,
						statsAppName: s,
						headers: o()
					}
				},
				o = {
					unsafeLoggedOut: !1,
					accessToken: ""
				};
			t.a = e => {
				let t = () => o;
				return {
					gqlContext: () => {
						const {
							headers: n,
							onBeforeRequest: s,
							onResponse: o,
							statsAppName: i
						} = e();
						return {
							apiUrl: r.a.gqlUrl,
							onBeforeRequest: s,
							onResponse: o,
							statsAppName: i,
							headers: () => (e => {
								const {
									unsafeLoggedOut: n,
									accessToken: r
								} = t();
								return n ? Object.assign({}, e, {
									Authorization: "Bearer ".concat(r)
								}) : Object.assign({}, e)
							})(n)
						}
					},
					middleware: e => (t = () => (e => {
						if (!e.user.session) return o;
						const {
							unsafeLoggedOut: t,
							accessToken: n
						} = e.user.session;
						return {
							unsafeLoggedOut: !!t,
							accessToken: n
						}
					})(e.getState()), e => t => e(t))
				}
			}
		},
		"./src/reddit/endpoints/accounts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			const c = async (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/block_user"),
				method: r.bb.POST
			}), a = async (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
				data: {
					name: n,
					container: t,
					type: "enemy"
				},
				endpoint: "".concat(e.apiUrl, "/api/unfriend"),
				method: r.bb.POST
			}), d = async (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/add_whitelisted?include_model"),
				method: r.bb.POST
			}), u = async (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/remove_whitelisted"),
				method: r.bb.POST
			})
		},
		"./src/reddit/endpoints/category/categoryList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/categories.tsx"),
				c = n("./src/reddit/constants/headers.ts");
			const a = e => {
				const t = {},
					n = [];
				return e.forEach((e, r) => {
					const s = {
						attr: e.category_attr,
						color: e.category_color || i.a[r % i.a.length],
						icon: e.category_icon,
						id: e.category_id,
						name: e.category_name
					};
					n.push(s.id), t[s.id] = s
				}), {
					categories: t,
					categoryIds: n
				}
			};
			t.a = e => Object(s.b)(Object(o.a)(e, [c.a]), {
				endpoint: "".concat(e.apiUrl, "/api/available_subreddit_categories.json?use_extended_categories=true"),
				method: r.bb.GET
			})
		},
		"./src/reddit/endpoints/category/subreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				a = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = e => {
				const t = [],
					n = [],
					r = {},
					s = {};
				return e.data.children.forEach(e => {
					let {
						data: o
					} = e;
					const i = Object(c.a)(o);
					t.push(i.id), n.push(i.name), r[i.id] = i, s[i.id] = {
						accountsActive: o.accounts_active,
						allOriginalContent: o.all_original_content,
						bannerBackgroundColor: o.banner_background_color,
						bannerBackgroundImage: o.banner_background_image,
						contentCategory: o.content_category,
						allowChatPostCreation: o.allow_chat_post_creation,
						keyColor: o.key_color,
						originalContentTagEnabled: o.original_content_tag_enabled,
						publicDescription: o.public_description,
						subscribers: o.subscribers,
						userIsSubscriber: o.user_is_subscriber
					}
				}), {
					subredditIds: t,
					subredditNames: n,
					subreddits: r,
					subredditsAboutInfo: s
				}
			};
			t.a = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
				return Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(a.a)("".concat(e.apiUrl, "/api/subreddits_in_category.json?category_id=").concat(t, "&limit=").concat(n)),
					method: r.bb.GET
				})
			}
		},
		"./src/reddit/endpoints/chat/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "j", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			const a = "api/v1",
				d = "".concat(a, "/sendbird");
			var u;
			! function(e) {
				e.PUBLIC = "all"
			}(u || (u = {}));
			const l = 10,
				b = 10;
			class p extends Error {
				constructor(e, t) {
					super(e), this.response = t
				}
			}
			const m = async (e, t, n) => {
				const d = {};
				return n && (d.public_mode = u.PUBLIC), Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(a, "/subreddit/").concat(t, "/channels"),
					method: s.bb.GET,
					data: d
				})
			}, f = async (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
				endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(a, "/subreddit/channels/create"),
				method: s.bb.POST,
				data: JSON.stringify({
					room: n.room,
					room_type: n.roomType,
					description: n.description,
					subreddit: n.subreddit,
					automute_account_age_threshold: n.minimumAcctAge,
					automute_on_join_duration: n.newMemberAge
				})
			}), g = async (e, t, n, d) => Object(o.b)(Object(i.a)(e, [c.a]), {
				endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(a, "/subreddit/channels/").concat(t),
				method: s.bb.PUT,
				data: JSON.stringify({
					room: d.room,
					description: d.description,
					automute_account_age_threshold: d.minimumAcctAge,
					automute_on_join_duration: d.newMemberAge
				})
			}), O = async (e, t) => Object(o.b)(Object(i.a)(e, [c.a]), {
				endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(a, "/subreddit/channels/").concat(t),
				method: s.bb.DELETE
			}), h = async e => Object(o.b)(Object(i.a)(e, [c.a]), {
				endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(d, "/config"),
				method: s.bb.GET
			});
			var y, j;

			function _(e) {
				const t = {
					bannedWords: e.profanity_filter && e.profanity_filter.keywords,
					regexes: e.profanity_filter && e.profanity_filter.regex_filters,
					rateLimit: e.user_messages_per_channel,
					domains: e.domain_filter && e.domain_filter.domains && e.domain_filter.domains.join(", "),
					useDefaultProfanityFilter: e.profanity_filter && e.profanity_filter.should_check_global,
					domainFilterOption: void 0
				};
				if (!1 === e.allow_links) t.domainFilterOption = j.BLOCK_ALL_DOMAINS;
				else {
					const {
						domain_filter: {
							type: n
						} = {
							type: void 0
						}
					} = e;
					n === y.BLOCK_MODE ? t.domainFilterOption = j.BLOCK_BANNED_DOMAINS : n === y.ALLOW_MODE ? t.domainFilterOption = j.ALLOW_APPROVED_DOMAINS : t.domainFilterOption = j.ALLOW_ALL_DOMAINS
				}
				return t
			}

			function E(e) {
				const t = {};
				return e.rateLimit && e.rateLimit > 0 && (t.user_messages_per_channel = e.rateLimit, t.user_messages_per_channel_duration = b), void 0 === e.bannedWords && void 0 === e.regexes && void 0 === e.useDefaultProfanityFilter || (t.profanity_filter = {
					keywords: e.bannedWords,
					regex_filters: e.regexes,
					should_check_global: e.useDefaultProfanityFilter
				}), e.domainFilterOption === j.BLOCK_ALL_DOMAINS ? (t.allow_links = !1, t.domain_filter = {
					type: y.DISABLE
				}) : e.domainFilterOption === j.ALLOW_ALL_DOMAINS ? (t.allow_links = !0, t.domain_filter = {
					type: y.DISABLE
				}) : e.domainFilterOption === j.ALLOW_APPROVED_DOMAINS && e.domains ? (t.allow_links = !0, t.domain_filter = {
					type: y.ALLOW_MODE,
					domains: e.domains.split(",")
				}) : e.domainFilterOption === j.BLOCK_BANNED_DOMAINS && e.domains && (t.allow_links = !0, t.domain_filter = {
					type: y.BLOCK_MODE,
					domains: e.domains.split(",")
				}), t
			}
			async function v(e, t) {
				const n = await Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(a, "/chat/subreddit/").concat(t, "/settings"),
					method: s.bb.GET
				});
				if (n.ok && n.body) return _(n.body)
			}
			async function I(e, t, n) {
					const d = await Object(o.b)(Object(i.a)(e, [c.a]), {
						endpoint: "".concat(r.a.sendbirdServiceUrl, "/").concat(a, "/chat/subreddit/").concat(t, "/settings"),
						method: s.bb.PUT,
						data: JSON.stringify(E(n))
					});
					if (d.ok && d.body) return Object.assign({}, d, {
						body: _(d.body)
					});
					throw new p("Failed to update subreddit chat settings", d)
				}! function(e) {
					e[e.BLOCK_MODE = 2] = "BLOCK_MODE", e[e.ALLOW_MODE = 1] = "ALLOW_MODE", e[e.DISABLE = 0] = "DISABLE"
				}(y || (y = {})),
				function(e) {
					e.ALLOW_ALL_DOMAINS = "Allow all domains", e.ALLOW_APPROVED_DOMAINS = "Allow links to approved domains", e.BLOCK_BANNED_DOMAINS = "Block links to banned domains", e.BLOCK_ALL_DOMAINS = "Block all domains"
				}(j || (j = {}))
		},
		"./src/reddit/endpoints/economics/tips.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./src/config.ts"),
				s = n("./src/reddit/endpoints/governance/requester.ts");

			function o(e, t) {
				return Object(s.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: "".concat(r.a.metaUrl, "/tips-details/").concat(t.subredditId),
					method: "post",
					data: {
						contentIds: t.contentIds
					}
				})
			}
		},
		"./src/reddit/endpoints/flair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			}));
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t, n, r, a, d) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(n, "/api/selectflair"),
					method: s.bb.POST,
					data: {
						api_type: "json",
						flair_template_id: r,
						name: t,
						text: a,
						css_class: d
					}
				}),
				u = (e, t, n, r) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/selectflair"),
					method: s.bb.POST,
					data: {
						api_type: "json",
						flair_template_id: n,
						link: t,
						text: r
					}
				}),
				l = (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(n, "/api/setflairenabled"),
					method: s.bb.POST,
					data: {
						api_type: "json",
						flair_enabled: t
					}
				}),
				b = async (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_user_flair.json"),
					method: s.bb.POST,
					data: {
						subreddit: t,
						enabled: n
					}
				}), p = async (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_link_flair.json"),
					method: s.bb.POST,
					data: {
						subreddit: t,
						enabled: n
					}
				}), m = async (e, t, n, r) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_user_flair_self_assign.json"),
					method: s.bb.POST,
					data: {
						subreddit: r,
						flair_type: n,
						enabled: t
					}
				}), f = async (e, t, n, r) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/flairtemplate_v2"),
					method: s.bb.POST,
					data: {
						allowable_content: t.allowableContent,
						css_class: t.cssClass,
						flair_template_id: t.id,
						text: t.text,
						text_editable: t.textEditable,
						flair_type: r,
						text_color: t.textColor,
						background_color: t.backgroundColor,
						max_emojis: t.maxEmojis,
						mod_only: t.modOnly,
						r: n
					}
				}), g = async (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/deleteflairtemplate"),
					method: s.bb.POST,
					data: {
						flair_template_id: t,
						r: n
					}
				}), O = async (e, t, n, r) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_template_order/").concat(n),
					method: s.bb.PATCH,
					type: "json",
					data: r
				}), h = async (e, t) => Object(o.b)(e, {
					endpoint: "".concat(r.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t, "/userFlair"),
					method: s.bb.GET,
					headers: {
						[c.a]: c.a
					}
				}), y = async (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(n, "/api/deleteflair"),
					method: s.bb.POST,
					data: {
						api_type: "json",
						name: t
					}
				}), j = async (e, t) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: Object(a.a)("".concat(e.apiUrl, "/api/top_flair_in_subreddit.json?subreddit=").concat(t)),
					method: s.bb.GET
				})
		},
		"./src/reddit/endpoints/gold/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return y
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "i", (function() {
				return S
			})), n.d(t, "j", (function() {
				return T
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "h", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/graphql/operations/DeleteAward.json"),
				c = n("./src/graphql/operations/DisableAward.json"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/lib/uploadToS3/index.ts"),
				u = n("./src/graphql/operations/CommunityAwardsBlacklistStatus.json"),
				l = n("./src/graphql/operations/CreateCommunityAward.json"),
				b = n("./src/graphql/operations/CreateGlobalAward.json"),
				p = n("./src/graphql/operations/CreateModAward.json"),
				m = n("./src/graphql/operations/ManageableAwards.json"),
				f = n("./src/graphql/operations/UsableAwards.json"),
				g = n("./src/graphql/operations/UsableAwardsForProfile.json"),
				O = n("./src/reddit/constants/headers.ts"),
				h = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const y = (e, t, n, o) => {
					const i = {
						subreddit: t,
						filepath: n,
						mimetype: o
					};
					return Object(s.b)(Object(a.a)(e, [O.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/v1/community_awards/award_asset_upload_s3"),
						data: i
					})
				},
				j = async (e, t) => Object(d.a)(t, e), _ = (e, t, n, r, s, i, c, a, d) => Object(o.a)(e, Object.assign({}, l, {
					variables: {
						coinPrice: c,
						iconHeight: i,
						iconWidth: s,
						iconUrl: r,
						name: n,
						subredditId: t,
						startsAt: a,
						endsAt: d
					}
				})), E = (e, t, n, r, s, i, c, a, d) => Object(o.a)(e, Object.assign({}, p, {
					variables: {
						iconHeight: i,
						iconWidth: s,
						iconUrl: r,
						monthsOfPremium: c,
						name: n,
						subredditId: t,
						startsAt: a,
						endsAt: d
					}
				})), v = e => {
					let {
						context: t,
						awardSubType: n,
						name: r,
						iconUrl: s,
						iconWidth: i,
						iconHeight: c,
						isNew: a,
						daysOfPremium: d,
						daysOfDripExtension: u,
						coinPrice: l,
						coinReward: p,
						startsAt: m,
						endsAt: f
					} = e;
					return Object(o.a)(t, Object.assign({}, b, {
						variables: {
							awardSubType: n,
							iconHeight: c,
							iconWidth: i,
							iconUrl: s,
							isNew: a,
							daysOfPremium: d,
							daysOfDripExtension: u,
							coinPrice: l,
							coinReward: p,
							name: r,
							startsAt: m,
							endsAt: f
						}
					}))
				}, I = (e, t) => Object(o.a)(e, Object.assign({}, u, {
					variables: {
						subredditId: t
					}
				})), S = (e, t) => Object(o.a)(e, Object.assign({}, m, {
					variables: {
						subredditId: t
					}
				})), T = (e, t) => Object(o.a)(e, Object.assign({}, f, {
					variables: {
						subredditId: t,
						includeAppreciation: !0
					}
				})), x = (e, t) => Object(o.a)(e, Object.assign({}, g, {
					variables: {
						profileName: t,
						includeAppreciation: !0
					}
				})), C = (e, t) => Object(o.a)(e, Object.assign({}, i, {
					variables: {
						awardId: t
					}
				})), w = (e, t) => Object(o.a)(e, Object.assign({}, c, {
					variables: {
						awardId: t
					}
				})), P = async (e, t, n) => {
					const o = {
						api_type: "json",
						award_id: t,
						raw_json: 1
					};
					return Object(s.b)(Object(a.a)(e, [O.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/report_award"),
						data: o
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
						error: Object(h.a)(e)
					}))
				}
		},
		"./src/reddit/endpoints/gold/paypalPurchases.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				a = n("./src/reddit/endpoints/gold/purchase.ts");
			const d = async e => {
				let {
					buttonId: t,
					context: n,
					correlationId: d,
					language: u
				} = e;
				const l = {
						button_id: t,
						correlation_id: d
					},
					b = "".concat(n.apiUrl, "/api/v2/gold/paypal/initiate_coins_payment"),
					p = Object(c.a)(b);
				return Object(s.b)(Object(o.a)(n, [i.a]), {
					method: r.bb.POST,
					endpoint: p,
					data: l
				}).then(a.c)
			}, u = async e => {
				let {
					buttonId: t,
					context: n,
					correlationId: d,
					language: u
				} = e;
				const l = {
						button_id: t,
						correlation_id: d
					},
					b = "".concat(n.apiUrl, "/api/v2/gold/paypal/initiate_premium_payment"),
					p = Object(c.a)(b);
				return Object(s.b)(Object(o.a)(n, [i.a]), {
					method: r.bb.POST,
					endpoint: p,
					data: l
				}).then(a.c)
			}, l = async e => {
				let {
					buttonId: t,
					context: n,
					correlationId: d,
					gildTypeName: u,
					isAnonymous: l,
					isOldReddit: b,
					language: p,
					message: m,
					thingId: f
				} = e;
				const g = {
						button_id: t,
						thing_id: f,
						gild_type: u,
						message: m,
						is_anonymous: l,
						correlation_id: d
					},
					O = "".concat(n.apiUrl, "/api/v2/gold/paypal/initiate_coins_and_gild_payment"),
					h = b ? O : Object(c.a)(O);
				return Object(s.b)(Object(o.a)(n, [i.a]), {
					method: r.bb.POST,
					endpoint: h,
					data: g
				}).then(a.c)
			}, b = async e => {
				let {
					context: t,
					coins: n,
					pennies: c,
					correlationId: d
				} = e;
				const u = {
					coins: n,
					pennies: c,
					correlation_id: d
				};
				return Object(s.b)(Object(o.a)(t, [i.a]), {
					method: r.bb.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/create_coin_purchase_order"),
					data: u
				}).then(a.c)
			}, p = async e => {
				let {
					context: t,
					orderId: n,
					coins: c,
					pennies: d,
					correlationId: u
				} = e;
				const l = {
					order_id: n,
					coins: c,
					pennies: d,
					correlation_id: u
				};
				return Object(s.b)(Object(o.a)(t, [i.a]), {
					method: r.bb.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/execute_coin_order"),
					data: l
				}).then(a.c)
			}, m = async e => {
				let {
					awardId: t,
					context: n,
					coins: c,
					correlationId: d,
					isAnonymous: u,
					message: l,
					orderId: b,
					pennies: p,
					thingId: m
				} = e;
				const f = {
					award_id: t,
					coins: c,
					correlation_id: d,
					is_anonymous: u,
					message: l,
					order_id: b,
					pennies: p,
					thing_id: m
				};
				return Object(s.b)(Object(o.a)(n, [i.a]), {
					method: r.bb.POST,
					endpoint: "".concat(n.apiUrl, "/api/v2/gold/paypal/execute_coin_with_gild_order"),
					data: f
				}).then(a.c)
			}
		},
		"./src/reddit/endpoints/gold/purchase.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				a = n("./src/reddit/helpers/genericServerError/index.ts"),
				d = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const u = e => e.ok ? e.body.json && e.body.json.errors.length ? Object.assign({}, e, {
					ok: !1,
					error: Object(d.a)(e)
				}) : Object.assign({}, e) : Object.assign({}, e, {
					error: e.error || Object(a.b)()
				}),
				l = async e => {
					let {
						coins: t,
						context: n,
						correlationId: a,
						language: d,
						pennies: l,
						rememberCard: b,
						token: p,
						savedCardId: m
					} = e;
					const f = {
							token: p ? p.id : void 0,
							coins: t,
							pennies: l,
							remember_card: b,
							card_id: m,
							correlation_id: a
						},
						g = "".concat(n.apiUrl, "/api/v2/gold/stripe/buy_coins"),
						O = Object(c.a)(g);
					return Object(s.b)(Object(o.a)(n, [i.a]), {
						method: r.bb.POST,
						endpoint: O,
						data: f
					}).then(u)
				}, b = async e => {
					let {
						coins: t,
						context: n,
						correlationId: a,
						gildParams: d,
						isOldReddit: l,
						language: b,
						pennies: p,
						rememberCard: m,
						thingId: f,
						token: g,
						savedCardId: O
					} = e;
					const {
						gildType: h,
						includeMessage: y,
						isAnonymous: j,
						message: _
					} = d, E = {
						token: g ? g.id : void 0,
						coins: t,
						pennies: p,
						thing_id: f,
						gild_type: h,
						message: y ? _ : "",
						is_anonymous: j,
						remember_card: m,
						card_id: O,
						correlation_id: a
					}, v = "".concat(n.apiUrl, "/api/v2/gold/stripe/buy_coins_and_gild"), I = l ? v : Object(c.a)(v);
					return Object(s.b)(Object(o.a)(n, [i.a]), {
						method: r.bb.POST,
						endpoint: I,
						data: E
					}).then(u)
				}, p = async e => {
					let {
						context: t,
						correlationId: n,
						language: a,
						pennies: d,
						token: l
					} = e;
					const b = {
							token: l.id,
							pennies: d,
							correlation_id: n
						},
						p = "".concat(t.apiUrl, "/api/v2/gold/stripe/buy_premium_subscription"),
						m = Object(c.a)(p);
					return Object(s.b)(Object(o.a)(t, [i.a]), {
						method: r.bb.POST,
						endpoint: m,
						data: b
					}).then(u)
				}, m = async (e, t, n) => {
					const c = {
						token: n.id
					};
					return Object(s.b)(Object(o.a)(e, [i.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/update_creditcard"),
						data: c
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
						error: Object(d.a)(e)
					}))
				}, f = async (e, t) => {
					const n = {
						card_id: t
					};
					return Object(s.b)(Object(o.a)(e, [i.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/delete_creditcard"),
						data: n
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
						error: Object(d.a)(e)
					}))
				}, g = async (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					method: r.bb.GET,
					endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/creditcards")
				}).then(e => e.ok ? Object.assign({}, e) : Object.assign({}, e, {
					error: Object(d.a)(e)
				}))
		},
		"./src/reddit/endpoints/governance/badges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/config.ts"),
				s = n("./src/reddit/endpoints/governance/requester.ts");
			async function o(e, t, n) {
				const o = Object(s.a)(e, {
						headers: {
							"X-HTTP-Method-Override": "GET"
						},
						method: "post",
						endpoint: "".concat(r.a.metaUrl, "/badges/").concat(t),
						data: {
							selected: !0,
							users: n
						}
					}),
					i = await o;
				if (i.ok) {
					const e = {},
						t = {},
						n = i.body;
					return Object.keys(n).forEach(r => {
						const s = n[r];
						t[r] = s, e[s.userId] || (e[s.userId] = []), e[s.userId].push(s.id)
					}), Object.assign({}, i, {
						body: {
							badges: t,
							usersAppliedBadges: e
						}
					})
				}
				return i
			}
			async function i(e, t, n) {
				const o = await Object(s.a)(e, {
					method: "get",
					endpoint: "".concat(r.a.metaUrl, "/badges/").concat(t, "?users=").concat(n)
				});
				if (o.ok) {
					const e = {},
						t = [],
						n = o.body;
					return Object.keys(n).forEach(r => {
						const s = n[r];
						e[r] = s, t.push(s.id)
					}), Object.assign({}, o, {
						body: {
							badges: e,
							userOwnedBadges: t
						}
					})
				}
				return o
			}

			function c(e, t, n) {
				let o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
				return Object(s.a)(e, {
					method: "patch",
					endpoint: "".concat(r.a.metaUrl, "/badges/").concat(t, "/").concat(n),
					data: {
						selected: o
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/community.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(o.a)(e, {
					endpoint: "".concat(r.a.metaUrl, "/communities/").concat(t.subredditId, "/me"),
					method: s.bb.GET
				})
			}
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./src/config.ts"),
				s = (n("./src/reddit/models/Poll/index.ts"), n("./src/reddit/endpoints/governance/requester.ts"));

			function o(e, t, n) {
				return Object(s.a)(e, {
					method: "get",
					endpoint: "".concat(r.a.metaUrl, "/polls/").concat(t, "?postIds=").concat(n.join(","))
				})
			}
		},
		"./src/reddit/endpoints/governance/products/badges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			}));
			var r = n("./src/config.ts"),
				s = n("./src/reddit/endpoints/governance/requester.ts");

			function o(e, t) {
				return Object(s.a)(e, {
					method: "get",
					endpoint: "".concat(r.a.metaUrl, "/products/").concat(t, "?types=badge")
				})
			}

			function i(e, t) {
				return Object(s.a)(e, {
					method: "get",
					endpoint: "".concat(r.a.metaUrl, "/products/").concat(t, "?types=badge,membership")
				})
			}

			function c(e, t) {
				return Object(s.a)(e, {
					method: "post",
					endpoint: "".concat(r.a.metaUrl, "/orders"),
					data: t
				})
			}

			function a(e, t) {
				return Object(s.a)(e, {
					method: "post",
					endpoint: "".concat(r.a.metaUrl, "/orders"),
					data: {
						currency: "usd",
						price: t.price,
						products: t.products,
						providerArgs: {
							paymentNonce: t.nonce
						},
						providerName: "braintree",
						subredditId: t.subredditId
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/lib/makeApiRequest/index.ts");

			function s(e, t) {
				return Object(r.b)(e, Object.assign({
					type: "json"
				}, t)).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : Object.assign({}, e.body, {
							code: e.status
						}),
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			}));
			var r = n("./src/config.ts"),
				s = (n("./src/lib/bigNumberUtils/percent.ts"), n("./src/lib/constants/index.ts")),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(o.a)(e, {
					endpoint: "".concat(r.a.metaUrl, "/wallets/").concat(t.subredditId, "/me"),
					method: s.bb.GET
				}).then(e => {
					if (e.ok) {
						const n = e.body,
							r = {
								[t.subredditId]: n
							};
						return Object.assign({}, e, {
							body: r
						})
					}
					return e
				})
			}

			function c(e, t) {
				return Object(o.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: "".concat(r.a.metaUrl, "/wallets/").concat(t.subredditId),
					method: s.bb.POST,
					data: t.userIds
				}).then(e => e.ok ? Object.assign({}, e, {
					body: {
						wallets: e.body
					}
				}) : e)
			}
		},
		"./src/reddit/endpoints/me/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts");
			const i = e => Object(o.b)(e, {
				endpoint: "".concat(r.a.gatewayUrl, "/desktopapi/v1/me"),
				method: s.bb.GET
			})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			}));
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t, n) => Object(o.b)(e, {
					endpoint: Object(a.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/").concat(t)),
					method: s.bb.GET,
					data: Object.assign({
						moderated_limit: 25
					}, n)
				}),
				u = (e, t, n) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/modactions/").concat(t),
					method: s.bb.POST,
					type: "json",
					data: n
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			t.a = async e => Object(s.b)(Object(o.a)(e, [i.a]), {
				endpoint: "".concat(e.apiUrl, "/subreddit_permissions"),
				method: r.bb.GET
			})
		},
		"./src/reddit/endpoints/moderator/structuredStyles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "a", (function() {
				return h
			}));
			var r = n("./src/graphql/operations/SubredditPostFlairStyleTemplates.json"),
				s = n("./src/graphql/operations/SubredditStyles.json"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/lib/uploadToS3/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				l = n("./src/reddit/helpers/media/index.ts");
			const b = async (e, t, n) => Object(i.b)(Object(a.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: o.bb.GET,
				data: {
					progressive_images: n
				}
			}), p = async (e, t, n) => Object(i.b)(Object(a.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: o.bb.PATCH,
				data: n
			}), m = async (e, t) => Object(i.b)(Object(a.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: o.bb.DELETE
			}), f = async (e, t, n, r, s) => Object(i.b)(Object(a.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/style_asset_upload_s3/").concat(t),
				method: o.bb.POST,
				data: {
					filepath: n,
					imagetype: r,
					mimetype: s
				}
			}), g = async (e, t, n, r) => {
				const s = await Object(l.g)(r),
					o = await f(e, t, r.name, n, s);
				if (!o.ok) return o;
				let i = o.body;
				return "s3UploadLease" in i && (i = i.s3UploadLease), Object(d.a)(r, i)
			}, O = (e, t) => Object(c.a)(e, Object.assign({}, s, {
				variables: {
					subredditName: t
				}
			})), h = (e, t, n) => Object(c.a)(e, Object.assign({}, r, {
				variables: {
					subredditName: t,
					templateIds: n
				}
			}))
		},
		"./src/reddit/endpoints/page/commentsPage.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				c = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			t.a = (e, t, n, a) => {
				const d = n ? "".concat(r.a.gatewayUrl, "/desktopapi/v1/postcomments/").concat(t, "/").concat(n) : "".concat(r.a.gatewayUrl, "/desktopapi/v1/postcomments/").concat(t);
				return Object(o.b)(e, {
					data: a,
					endpoint: Object(i.a)(Object(c.a)(d)),
					method: s.bb.GET,
					traceRequestName: "get_comments_page"
				})
			}
		},
		"./src/reddit/endpoints/page/frontpage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/graphql/operations/Frontpage.json"),
				s = n("./src/lib/base64/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/performanceTimings/index.tsx"),
				a = n("./src/reddit/constants/graphql.ts"),
				d = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeFrontpageFromGql/index.ts"),
				l = n("./src/reddit/selectors/platform.ts"),
				b = n("./src/reddit/selectors/user.ts");
			const p = (e, t) => Object(i.a)(e, Object.assign({}, r, {
					variables: t
				})),
				m = (e, t) => {
					const {
						after: n,
						dist: r,
						isMobile: o,
						layout: i,
						limit: c,
						sort: u,
						t: p
					} = t, m = Object(b.R)(e), f = Object(l.q)(e), g = {
						recentPostIds: e.posts.recent,
						includeIdentity: m && !e.user.account,
						includeFeatured: !0,
						adContext: {
							layout: i ? i.toUpperCase() : a.a.Card,
							reddaid: e.user.reddaid,
							distance: r
						}
					};
					return u && (g.sort = u.toUpperCase()), p && (g.range = p.toUpperCase()), o ? g.pageSize = Object(d.a)(i) : c && (g.pageSize = c), f && f.ad && (g.forceAds = {
						ad: f.ad
					}), n && (g.after = Object(s.a)(n)), g
				},
				f = async (e, t, n) => {
					const r = Date.now(),
						s = await p(e, t),
						i = Date.now();
					if (!s.ok) return s;
					const a = Date.now(),
						d = Object(u.a)(s.body.data),
						l = Date.now(),
						b = [{
							duration: i - r,
							logKeyType: c.a.gqlFetchTiming
						}, {
							duration: l - a,
							logKeyType: c.a.gqlNormalizationTiming
						}];
					return Object(c.h)(o.o.FRONTPAGE, n, b), Object.assign({}, s, {
						body: d
					})
				}
		},
		"./src/reddit/endpoints/page/multiredditListing.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/graphql/operations/MultiredditListing.json"),
				s = n("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t) => Object(s.a)(e, Object.assign({}, r, {
				variables: t
			}))
		},
		"./src/reddit/endpoints/page/profileOverviewPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var r = n("./src/config.ts"),
				s = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const a = (e, t, n) => Object(i.b)(e, {
					data: n,
					endpoint: Object(s.a)(Object(c.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/conversations"))),
					method: o.bb.GET
				}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? Object.assign({}, e, {
					body: Object.assign({}, e.body, {
						pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
					})
				}) : e),
				d = (e, t, n) => Object(i.b)(e, {
					data: n,
					endpoint: Object(s.a)(Object(c.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/overview"))),
					method: o.bb.GET
				}).then(e => "pinned" in e.body ? e : "overviewIds" in e.body ? Object.assign({}, e, {
					body: Object.assign({}, e.body, {
						pinned: e.body.overviewIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
					})
				}) : e)
		},
		"./src/reddit/endpoints/page/search.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/search/index.ts"),
				c = n("./src/reddit/helpers/correlationIdTracker.ts"),
				a = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t) => {
				let n = t ? Object.assign({}, e, {
					type: e.restrict_sr ? "link" : e.type
				}) : e;
				(n = n.type ? n : Object.assign({}, n, {
					type: "link,sr,user"
				})).q = Object(i.a)(e.q);
				const r = Object(c.c)(c.a.SearchResults);
				return r && (n.search_correlation_id = r), n
			};
			t.a = (e, t, n, i) => Object(o.b)(e, {
				data: d(i || {}, t),
				endpoint: Object(a.a)(n ? "".concat(r.a.gatewayUrl, "/desktopapi/v1/multireddits/").concat(n, "/").concat(t, "/search") : t ? "".concat(r.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t, "/search") : "".concat(r.a.gatewayUrl, "/desktopapi/v1/search")),
				method: s.bb.GET
			})
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/config.ts"),
				s = n("./src/graphql/operations/SubredditPage.json"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/isAdHocMultireddit/index.ts"),
				c = n("./src/lib/isFakeSubreddit/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/lib/performanceTimings/index.tsx"),
				l = n("./src/reddit/constants/graphql.ts"),
				b = n("./src/reddit/constants/page.ts"),
				p = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				m = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				f = n("./src/reddit/models/Post/index.ts"),
				g = n("./src/reddit/models/RichTextJson/index.ts"),
				O = n("./src/reddit/models/Subreddit/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				S = e => {
					let {
						isAccessEnabled: t,
						isAllAllowed: n,
						isChatConfigEditingAllowed: r,
						isChatOperator: s,
						isConfigEditingAllowed: o,
						isFlairEditingAllowed: i,
						isMailEditingAllowed: c,
						isPostEditingAllowed: a,
						isWikiEditingAllowed: d
					} = e;
					return {
						access: t,
						all: n,
						chatConfig: r,
						chatOperator: s,
						config: o,
						flair: i,
						mail: c,
						posts: a,
						wiki: d
					}
				},
				T = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/helpers.ts");
			const w = e => {
				switch (e) {
					case O.b.Banned:
						return a.a.BannedSubreddit;
					case O.b.GoldOnly:
						return a.a.GoldSubreddit;
					case O.b.Private:
						return a.a.PrivateSubreddit;
					case O.b.Quarantined:
						return a.a.QuarantinedSubreddit;
					case O.b.Unknown:
						return a.a.ForbiddenSubreddit
				}
			};
			var P = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				D = n("./src/reddit/selectors/platform.ts"),
				R = n("./src/reddit/selectors/user.ts");
			n.d(t, "c", (function() {
				return k
			})), n.d(t, "b", (function() {
				return N
			}));
			var A = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const k = (e, t, n) => {
					const {
						after: r,
						geo_filter: s,
						isMobile: o,
						layout: a,
						limit: d,
						recentPostIds: u,
						sort: p,
						t: f
					} = n, g = Object(R.R)(e), O = Object(D.q)(e), h = Object(i.a)(t), y = Object(c.a)(t), j = {
						name: t,
						includeIdentity: g && !e.user.account,
						adContext: {
							layout: a ? a.toUpperCase() : l.a.Card,
							reddaid: e.user.reddaid
						},
						isFake: y,
						includeRecents: y && u && u.length > 0 || !1,
						includeTrending: y,
						isAdHocMulti: h,
						isAll: t === b.d.All,
						isPopular: t === b.d.Popular,
						recentPostIds: u || [],
						subredditNames: h ? t.split("+") : []
					};
					return p && (j.sort = p.toUpperCase()), f && (j.range = f.toUpperCase()), o ? j.pageSize = Object(m.a)(a) : d && (j.pageSize = d), O && O.ad && (j.forceAds = {
						ad: O.ad
					}), (O && O.geo_filter || s) && (j.region = O && O.geo_filter || s), r && (j.after = btoa(r)), j
				},
				N = async (e, t, n) => {
					const r = Date.now(),
						i = await ((e, t) => Object(d.a)(e, Object.assign({}, s, {
							variables: t
						})))(e, t),
						c = Date.now();
					if (!i.ok || !i.body) return i;
					const l = i.body,
						b = Date.now(),
						p = (e => {
							let {
								adhocMultiredditByNames: t,
								all: n,
								identity: r,
								popular: s,
								recentPosts: o,
								subredditInfoByName: i,
								trendingSubreddits: c
							} = e;
							const d = {
								authorFlair: {},
								postIds: [],
								postInstances: {},
								posts: {},
								postFlair: {},
								profiles: {},
								recentPostIds: [],
								structuredStyles: {},
								subredditAboutInfo: {},
								subredditPermissions: {},
								subreddits: {},
								trendingSubredditIds: []
							};
							if (!i) return {
								reason: a.a.NotFoundSubreddit,
								data: {
									account: r && Object(x.a)(r) || null
								}
							};
							if (Object(O.f)(i)) {
								const {
									banMessage: e,
									publicDescriptionText: t,
									quarantineMessage: n,
									isEmailRequiredForQuarantineOptin: s
								} = i;
								return {
									reason: w(i.forbiddenReason),
									data: Object.assign({
										account: r && Object(x.a)(r) || null,
										banMessage: e || void 0,
										description: t,
										quarantineRequiresEmailOptin: s
									}, n ? {
										quarantineMessage: n.markdown,
										quarantineMessageRTJson: Object(C.k)(n.richtext, g.i)
									} : {})
								}
							}
							const u = e => {
									if (e.__typename === f.f.DeletedProfilePost || e.__typename === f.f.DeletedSubredditPost) return null;
									if (d.posts[e.id]) return e.id;
									const t = Object(j.d)(e);
									d.posts[t.id] = t;
									const {
										crosspostRoot: n
									} = e;
									n && n.type === f.a.Post && n.postInfo && u(n.postInfo);
									let r = t.id;
									switch (e.authorFlair && (d.authorFlair[t.belongsTo.id] || (d.authorFlair[t.belongsTo.id] = {}), d.authorFlair[t.belongsTo.id][t.author] = Object(h.a)(e.authorFlair)[0]), e.__typename) {
										case f.f.ProfilePost:
											d.profiles[e.profile.id] || (d.profiles[e.profile.id] = Object(E.a)(e.profile));
											break;
										case f.f.SubredditPost:
											d.subreddits[e.subreddit.id] || (d.subreddits[e.subreddit.id] = Object(I.a)(e.subreddit)), d.postFlair[e.subreddit.id] || (d.postFlair[e.subreddit.id] = Object(y.a)(e.subreddit));
											break;
										case f.f.AdPost:
											const n = Object(j.b)(e);
											if (!n) {
												r = null;
												break
											}
											r = n, d.posts[n] = Object.assign({}, t, {
												id: n,
												permalink: "".concat(t.permalink, "?instanceId=").concat(encodeURIComponent(n))
											}), d.posts[t.id] || (d.posts[t.id] = Object.assign({}, t, {
												events: []
											})), d.postInstances[e.id] || (d.postInstances[e.id] = []), d.postInstances[e.id].push(n)
									}
									return r
								},
								l = i || s || n || t;
							for (const {
									node: a
								} of l.posts.edges) {
								const e = u(a);
								e && d.postIds.push(e)
							}
							i && i.styles && (d.structuredStyles = {
								data: {
									style: Object(T.a)(i.styles)
								}
							});
							const b = d.postIds.length - 1,
								p = b >= 0 ? d.postIds[b] : "",
								m = l.posts.dist;
							if (c) {
								d.trendingSubredditIds = c.map(e => e.id);
								for (const e of c) d.subreddits[e.id] = Object(I.a)(e)
							}
							if (o)
								for (const a of o) {
									const e = u(a);
									e && d.recentPostIds.push(e)
								}
							return Object.assign({}, d, {
								account: r && Object(x.a)(r) || null,
								preferences: r && r.preferences && Object(_.a)(r.preferences, r.interactions) || null,
								subredditAboutInfo: i && Object(v.a)(i),
								subredditPermissions: i && i.modPermissions && S(i.modPermissions),
								token: p
							}, null !== m && {
								dist: m
							})
						})(l.data),
						m = Date.now(),
						P = [{
							duration: c - r,
							logKeyType: u.a.gqlFetchTiming
						}, {
							duration: m - b,
							logKeyType: u.a.gqlNormalizationTiming
						}];
					return Object(u.h)(o.o.SUBREDDIT, n, P), Object.assign({}, i, {
						ok: !!l.data.subredditInfoByName && !Object(O.f)(l.data.subredditInfoByName),
						status: L(l.data),
						body: p
					})
				}, L = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(O.f)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === O.b.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === O.b.GoldOnly || e.subredditInfoByName.forbiddenReason === O.b.Private || e.subredditInfoByName.forbiddenReason === O.b.Quarantined) return 403
					}
					return 200
				}, M = e => {
					var {
						recentPostIds: t
					} = e, n = A(e, ["recentPostIds"]);
					return t && t.length ? Object.assign({}, n, {
						recentPostIds: t.join(",")
					}) : n
				};
			t.a = (e, t, n) => Object(a.b)(e, {
				endpoint: Object(p.a)(Object(P.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t))),
				method: o.bb.GET,
				data: n && M(n) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts");
			t.a = (e, t, n) => {
				const d = {
					output_mode: "markdown" === t ? t : "rtjson"
				};
				return t === a.h.MARKDOWN ? d.richtext_json = n : d.markdown_text = n, Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/convert_rte_body_format")),
					method: r.bb.POST,
					data: d
				})
			}
		},
		"./src/reddit/endpoints/post/create.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "a", (function() {
				return y
			}));
			var r = n("./node_modules/url/url.js"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/helpers/name/index.ts"),
				l = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				b = n("./src/reddit/models/Post/index.ts"),
				p = n("./src/reddit/models/PostCreationForm/index.ts"),
				m = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const f = e => {
					switch (e.kind) {
						case p.p.CROSSPOST:
							return p.p.CROSSPOST;
						case p.p.LINK:
							return p.p.LINK;
						case p.p.POLL:
							return p.p.POLL;
						case p.p.MEDIA:
							return e.makeGif ? p.p.VIDEO_GIF : e.mediaType;
						default:
							return "self"
					}
				},
				g = e => {
					const t = Object(u.f)(e.destSubreddit.name);
					return Object.assign({
						sr: t,
						api_type: "json",
						show_error_list: !0,
						draft_id: e.draftId || void 0,
						title: e.title,
						discussion_type: e.isChatPost ? b.b.Chat : void 0,
						spoiler: e.isSpoiler,
						nsfw: e.isNSFW
					}, e.kind !== p.p.POLL ? Object.assign({
						kind: f(e),
						original_content: e.isOC
					}, e.destSubreddit.isProfile ? {
						sr: "u_".concat(t),
						submit_type: "profile"
					} : {
						sr: t,
						submit_type: "subreddit"
					}) : {}, {
						post_to_twitter: e.postToTwitter,
						sendreplies: e.sendReplies
					}, e.gRecaptchaResponse ? {
						"g-recaptcha-response": e.gRecaptchaResponse
					} : {}, {
						resubmit: e.resubmit
					}, (e => {
						switch (e.kind) {
							case p.p.RICH_TEXT:
								return {
									richtext_json: JSON.stringify({
										document: e.document
									})
								};
							case p.p.MARKDOWN:
								return {
									text: e.markdown
								};
							case p.p.LINK:
							case p.p.MEDIA:
								return {
									url: e.url
								};
							case p.p.CROSSPOST:
								return {
									crosspost_fullname: e.sourcePostId
								};
							case p.p.POLL:
								return {
									duration: Math.floor(e.poll.duration / 864e5), options: e.poll.options.map(e => e.text), text: e.markdown, raw_rtjson: "markdown" in e ? null : JSON.stringify({
										document: e.document
									})
								}
						}
					})(e), e.kind === p.p.MEDIA && "video" === e.mediaType ? {
						video_poster_url: e.videoThumbnailUrl
					} : {}, e.kind === p.p.MEDIA && e.makeGif ? {
						make_gif: "on"
					} : {}, e.flair ? {
						flair_id: e.flair.templateId,
						flair_text: Object(d.g)(e.flair)
					} : {}, e.validate_on_submit ? {
						validate_on_submit: e.validate_on_submit
					} : {}, e.eventSchedule && {
						event_start: e.eventSchedule.startDate,
						event_end: e.eventSchedule.endDate,
						event_tz: e.eventSchedule.timezoneName,
						unlist: e.eventSchedule.submitTime === p.i.AtEventTime
					}, e.collectionId && {
						collection_id: e.collectionId
					})
				},
				O = e => {
					const t = /comments\/(\w+)\/.*$/.exec(e),
						n = t && t[1];
					return n ? "".concat(s.vb.Post, "_").concat(n) : ""
				},
				h = async (e, t) => {
					if (!e.ok) return Object(l.b)(e);
					const n = e.body.json.data;
					let s = n.url;
					s || t.kind !== p.p.MEDIA || (s = await ((e, t) => new Promise(n => {
						const r = new WebSocket(e),
							s = e => {
								r.close(), clearTimeout(o), n(e)
							},
							o = setTimeout(() => {
								s("")
							}, t);
						r.onmessage = e => {
							const t = JSON.parse(e.data),
								n = "success" === t.type ? t.payload.redirect : "";
							s(n)
						}, r.onerror = e => {
							s("")
						}
					}))(n.websocket_url, 3e4));
					const o = n.id || O(s),
						i = Object(r.parse)(s).path,
						c = n.drafts_count;
					return Object.assign({}, e, {
						body: {
							id: o,
							path: i,
							draftsCount: c
						}
					})
				}, y = (e, t) => Object(o.b)(Object(i.a)(e, [c.a]), {
					endpoint: Object(m.a)(Object(a.a)("".concat(e.apiUrl, "/api/submit_poll_post.json?resubmit=true"))),
					method: s.bb.POST,
					data: g(t),
					type: "json"
				}).then(e => h(e, t));
			t.b = (e, t) => Object(o.b)(Object(i.a)(e, [c.a]), {
				endpoint: Object(m.a)(Object(a.a)("".concat(e.apiUrl, "/api/submit?resubmit=true"))),
				method: s.bb.POST,
				data: g(t)
			}).then(async e => await h(e, t))
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return u
			}));
			var r = n("./src/reddit/helpers/flair.ts"),
				s = n("./src/reddit/models/PostDraft/index.ts");
			const o = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				i = e => {
					switch (e.kind) {
						case s.b.Link:
							return "link";
						case s.b.Markdown:
							return "markdown";
						case s.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				c = e => {
					switch (e) {
						case "link":
							return s.b.Link;
						case "markdown":
							return s.b.Markdown;
						case "richtext":
							return s.b.RichText;
						default:
							return "self"
					}
				},
				a = e => e.title.substring(0, 300),
				d = e => {
					switch (e.kind) {
						case s.b.Link:
						case s.b.Markdown:
							return e.body;
						case s.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				u = e => Object.assign({
					id: e.draftId || void 0
				}, (e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {})(e), {
					kind: i(e),
					title: a(e),
					body: d(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC
				}, (e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(r.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				})(e.flair), {
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/post/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var a = n("./src/reddit/helpers/reportPage/index.ts");
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "t", (function() {
				return m
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "v", (function() {
				return g
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "w", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "o", (function() {
				return v
			})), n.d(t, "x", (function() {
				return I
			})), n.d(t, "r", (function() {
				return S
			})), n.d(t, "y", (function() {
				return T
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "u", (function() {
				return C
			})), n.d(t, "s", (function() {
				return w
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "m", (function() {
				return D
			})), n.d(t, "n", (function() {
				return A
			})), n.d(t, "q", (function() {
				return N
			}));
			const d = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/approve")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				u = (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/distinguish/").concat(n)),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				l = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/fetch_title")),
					method: r.bb.POST,
					data: {
						url: t,
						api_type: "json"
					}
				}),
				b = (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/follow_post")),
					method: r.bb.POST,
					data: {
						follow: n,
						fullname: t
					}
				}),
				p = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/hide")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				m = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unhide")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				f = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/lock")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				g = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unlock")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				O = (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/set_original_content")),
					method: r.bb.POST,
					data: {
						fullname: t,
						should_set_oc: n
					}
				}),
				h = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/marknsfw")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unmarknsfw")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				j = (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: "".concat(e.apiUrl, "/api/sendreplies"),
					method: r.bb.POST,
					data: {
						id: t,
						state: n
					}
				}),
				_ = (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/remove")),
					method: r.bb.POST,
					data: {
						id: t,
						spam: n
					}
				}),
				E = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/del")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				v = (e, t) => ((e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/save")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}))(e, t),
				I = (e, t) => ((e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unsave")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}))(e, t),
				S = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/spoiler")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				T = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/unspoiler")),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				x = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: "".concat(e.apiUrl, "/api/ignore_reports"),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				C = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: "".concat(e.apiUrl, "/api/unignore_reports"),
					method: r.bb.POST,
					data: {
						id: t
					}
				}),
				w = (e, t, n, c) => Object(s.b)(Object(o.a)(e, [i.a]), {
					endpoint: "".concat(e.apiUrl, "/api/set_subreddit_sticky"),
					method: r.bb.POST,
					data: {
						id: t,
						state: n,
						to_profile: c
					}
				});
			var P;
			! function(e) {
				e.Rule = "rule", e.SiteRule = "siteRule", e.Other = "other", e.FileComplaint = "fileComplaint"
			}(P || (P = {}));
			const D = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					method: r.bb.POST,
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/report")),
					data: R(t)
				}),
				R = e => {
					const t = Object.assign({
							thing_id: e.id,
							api_type: "json"
						}, e.timestamp && {
							live_stream_relative_report_time_sec: e.timestamp.toString()
						}),
						{
							reportFlowPayload: n
						} = e;
					switch (n.customText && (t.custom_text = n.customText), n.kind) {
						case P.Other:
							return Object.assign({}, t, {
								reason: "other",
								other_reason: n.rule
							});
						case P.Rule:
							return Object.assign({}, t, {
								reason: n.rule,
								rule_reason: n.rule
							});
						case P.SiteRule:
						default:
							return Object.assign({}, t, {
								reason: "site_reason_selected",
								site_reason: n.rule
							})
					}
				},
				A = (e, t) => Object(s.b)(Object(o.a)(e, [i.a]), {
					method: r.bb.POST,
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/report")),
					data: k(t)
				}),
				k = e => {
					const t = Object(a.b)(e);
					return Object.assign({}, t, {
						api_type: "json",
						from_help_desk: !0
					})
				},
				N = async (e, t, n) => Object(s.b)(Object(o.a)(e, [i.a]), {
					method: r.bb.POST,
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/set_contest_mode/")),
					data: {
						api_type: "json",
						id: n,
						state: t
					}
				})
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "i", (function() {
				return v
			}));
			var r = n("./node_modules/lodash/omit.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/constants/headers.ts"),
				a = n("./src/lib/makeRequest/index.ts"),
				d = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				u = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				l = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				b = n("./src/reddit/i18n/utils.ts"),
				p = n("./src/reddit/models/PostCreationForm/index.ts"),
				m = n("./src/reddit/models/Vote/index.ts");
			const f = async e => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/rpan_config_v1"),
				method: i.bb.GET,
				headers: s()(e.headers(), [c.c, c.b]),
				timeoutMs: void 0
			}).then(T), g = async (e, t) => {
				let n;
				return n = t === d.R ? "/config" : "/".concat(t, "/config"), Object(a.b)({
					endpoint: "".concat(o.a.streamingApiUrl).concat(n),
					method: i.bb.GET,
					headers: s()(e.headers(), [c.c, c.b]),
					timeoutMs: void 0
				}).then(T)
			}, O = async (e, t) => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(t),
				method: i.bb.GET,
				headers: s()(e.headers(), [c.c, c.b])
			}).then(T), h = async e => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos"),
				method: i.bb.GET,
				headers: s()(e.headers(), [c.c, c.b])
			}).then(T), y = async (e, t) => {
				let n;
				return n = t === d.R ? "/broadcasts" : "/".concat(t, "/broadcasts"), Object(a.b)({
					endpoint: "".concat(o.a.streamingApiUrl).concat(n),
					method: i.bb.GET,
					headers: s()(e.headers(), [c.c, c.b])
				}).then(T)
			}, j = async e => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/recommended_viewer_subreddits"),
				method: i.bb.GET,
				headers: s()(e.headers(), [c.c, c.b])
			}).then(T), _ = async (e, t, n) => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(t, "/vote/").concat(x(n)),
				method: i.bb.POST,
				headers: s()(e.headers, [c.c, c.b])
			}).then(T), E = async (e, t) => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(t, "/heartbeat"),
				method: i.bb.POST,
				headers: s()(e.headers(), [c.c, c.b])
			}).then(T), v = async (e, t, n, r) => {
				const s = n.rteState;
				if (!s) return Promise.reject(new Error("Editor state is undefined"));
				const o = u.a.getRawText(s);
				return o ? I(e, t, o).then(e => e.ok && e.body && e.body.data ? Object.assign({}, e, {
					body: {
						parentId: t,
						comment: Object.assign({}, Object(l.a)(e.body.data, r), {
							media: S(s)
						})
					},
					error: void 0
				}) : e) : Promise.reject(new Error("Cannot send empty message"))
			}, I = async (e, t, n) => Object(a.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(t, "/comment"),
				method: i.bb.POST,
				headers: s()(e.headers, [c.c, c.b]),
				data: {
					text: n
				},
				type: "json"
			}).then(T), S = e => ({
				type: "rtjson",
				richtextContent: {
					document: u.a.toRichTextJSON(e).document
				},
				rteMode: p.h.RICH_TEXT
			}), T = e => {
				if (e.ok) return Object.assign({}, e, {
					error: void 0
				}); {
					const t = {
						type: 404 === e.status ? i.D.NOT_FOUND_ERROR : i.D.SERVER_ERROR
					};
					return 429 === e.status && (t.fields = [{
						field: "",
						msg: Object(b.c)("Try again later")
					}]), Object.assign({}, e, {
						error: t
					})
				}
			}, x = e => e === m.a.upvoted ? "up" : e === m.a.downvoted ? "down" : "unset"
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/graphql/operations/SubredditAbout.json"),
				s = n("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t, n) => Object(s.a)(e, Object.assign({}, r, {
				variables: {
					subredditName: t,
					includeSubreddit: n
				}
			}))
		},
		"./src/reddit/endpoints/subreddit/models.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/graphql/operations/SubredditModels.json"),
				s = n("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t) => Object(s.a)(e, Object.assign({}, r, {
				variables: t
			}))
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/lodash/camelCase.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/mapKeys.js"),
				i = n.n(o),
				c = n("./src/graphql/operations/SubredditRules.json"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/graphql/helpers.ts"),
				m = n("./src/reddit/models/Rule/index.ts");
			n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "e", (function() {
				return v
			}));
			const f = e => {
					let {
						rules: t
					} = e;
					return {
						rules: t.map(e => Object.assign({}, i()(e, (e, t) => s()(t)), {
							kind: "link" === e.kind ? "post" : e.kind
						}))
					}
				},
				g = (e, t) => Object(u.a)(e, Object.assign({}, c, {
					variables: {
						subredditName: t
					}
				})).then(e => (e.ok && e.body && (e.body = (e => {
					return {
						rules: (e.data.subreddit && e.data.subreddit.rules || []).map(e => ({
							kind: m.b[e.kind],
							description: e.content.markdown,
							descriptionRichText: e.content.richtext,
							shortName: e.name,
							violationReason: e.violationReason || "",
							createdUtc: Object(p.j)(e.createdAt, p.a.Millis),
							priority: e.priority
						}))
					}
				})(e.body)), e)),
				O = (e, t) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/about/rules.json"),
					method: a.bb.GET
				}).then(e => (e.ok && e.body.rules && (e.body = f(e.body)), e)),
				h = e => e.ok ? (e.body = Object(m.g)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				y = async (e, t, n) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/add_subreddit_rule"),
					method: a.bb.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === m.a.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => h(e)), j = async (e, t, n, r) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/update_subreddit_rule"),
					method: a.bb.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === m.a.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						old_short_name: r,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => h(e)), _ = async (e, t, n) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/remove_subreddit_rule"),
					method: a.bb.POST,
					data: {
						r: t,
						short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => h(e)), E = e => e.map(e => encodeURIComponent(e)).join(), v = async (e, t, n) => Object(d.b)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/reorder_subreddit_rules"),
					method: a.bb.POST,
					data: {
						r: t,
						new_rule_order: E(n),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => h(e))
		},
		"./src/reddit/endpoints/subreddit/settings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = n("./src/reddit/constants/headers.ts");
			const a = (e, t, n) => Object(s.b)(Object(o.a)(e, [c.a]), {
					method: r.bb.POST,
					endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/delete_sr_").concat(n),
					data: {
						raw_json: 1
					}
				}),
				d = (e, t) => Object(s.b)(Object(o.a)(e, [c.a]), {
					method: r.bb.GET,
					endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/about/edit.json"),
					data: {
						raw_json: 1
					}
				}).then(e => e.ok ? Object.assign({}, e, {
					body: Object.assign({}, b(e.body.data))
				}) : e),
				u = (e, t, n) => Object(s.b)(Object(o.a)(e, [c.a]), {
					method: r.bb.PATCH,
					endpoint: Object(i.a)("".concat(e.apiUrl, "/api/v1/subreddit/update_settings")),
					type: "json",
					data: Object.assign({}, p(n, f), {
						sr: t
					})
				}),
				l = (e, t, n) => {
					const i = Object.assign({}, m(n), {
						sr: t
					});
					return Object(s.b)(Object(o.a)(e, [c.a]), {
						method: r.bb.POST,
						endpoint: "".concat(e.apiUrl, "/api/site_admin"),
						data: i
					})
				},
				b = e => ({
					allowChatPostCreation: e.allow_chat_post_creation,
					allowDiscovery: e.allow_discovery,
					allowImages: e.allow_images,
					allowPolls: e.allow_polls,
					allowPostCrossposts: e.allow_post_crossposts,
					collapseDeletedComments: e.collapse_deleted_comments,
					commentScoreHideMins: e.comment_score_hide_mins,
					contentOptions: e.content_options,
					contentVisible: e.default_set,
					crowdControlMode: e.crowd_control_mode,
					crowdControlChatLevel: e.crowd_control_chat_level,
					crowdControlLevel: e.crowd_control_level,
					description: e.description,
					disableContributorRequests: e.disable_contributor_requests,
					domain: e.domain,
					excludeBannedModqueue: e.exclude_banned_modqueue,
					headerHoverText: e.header_hover_text,
					hideAds: e.hide_ads,
					isChatPostFeatureEnabled: e.is_chat_post_feature_enabled,
					keyColor: e.key_color,
					language: e.language,
					over18: e.over_18,
					publicDescription: e.public_description,
					publicTraffic: e.public_traffic,
					restrictCommenting: e.restrict_commenting,
					restrictPosting: e.restrict_posting,
					showMedia: e.show_media,
					showMediaPreview: e.show_media_preview,
					spamComments: e.spam_comments,
					spamLinks: e.spam_links,
					spamSelfposts: e.spam_selfposts,
					spoilersEnabled: e.spoilers_enabled,
					submitLinkLabel: e.submit_link_label,
					submitText: e.submit_text,
					submitTextLabel: e.submit_text_label,
					subredditId: e.subreddit_id,
					subredditType: e.subreddit_type,
					suggestedCommentSort: e.suggested_comment_sort,
					title: e.title,
					welcomeMessageEnabled: e.welcome_message_enabled,
					welcomeMessageText: e.welcome_message_text,
					wikiEditAge: e.wiki_edit_age,
					wikiEditKarma: e.wiki_edit_karma,
					wikimode: e.wikimode
				}),
				p = (e, t) => {
					const n = {};
					for (const r in e) n[t[r]] = e[r];
					return n
				},
				m = e => ({
					allow_polls: e.allowPolls,
					allow_post_crossposts: e.allowPostCrossposts,
					allow_chat_post_creation: e.allowChatPostCreation,
					allow_images: e.allowImages,
					allow_discovery: e.allowDiscovery,
					allow_top: e.contentVisible,
					api_type: "json",
					collapse_deleted_comments: e.collapseDeletedComments,
					comment_score_hide_mins: e.commentScoreHideMins,
					crowd_control_mode: e.crowdControlMode,
					crowd_control_level: e.crowdControlLevel,
					crowd_control_chat_level: e.crowdControlChatLevel,
					disable_contributor_requests: e.disableContributorRequests,
					description: e.description,
					domain: e.domain,
					exclude_banned_modqueue: e.excludeBannedModqueue,
					"header-title": e.headerHoverText,
					hide_ads: e.hideAds,
					is_chat_post_feature_enabled: e.isChatPostFeatureEnabled,
					key_color: e.keyColor,
					lang: e.language,
					link_type: e.contentOptions,
					over_18: e.over18,
					public_description: e.publicDescription,
					public_traffic: e.publicTraffic,
					restrict_commenting: e.restrictCommenting,
					restrict_posting: e.restrictPosting,
					show_media: e.showMedia,
					show_media_preview: e.showMediaPreview,
					spam_comments: e.spamComments,
					spam_links: e.spamLinks,
					spam_selfposts: e.spamSelfposts,
					spoilers_enabled: e.spoilersEnabled,
					sr: e.subredditId,
					submit_link_label: e.submitLinkLabel,
					submit_text: e.submitText,
					submit_text_label: e.submitTextLabel,
					suggested_comment_sort: e.suggestedCommentSort,
					title: e.title,
					type: e.subredditType,
					welcome_message_enabled: e.welcomeMessageEnabled,
					welcome_message_text: e.welcomeMessageText,
					wiki_edit_age: e.wikiEditAge,
					wiki_edit_karma: e.wikiEditKarma,
					wikimode: e.wikimode
				}),
				f = {
					allowPostCrossposts: "allow_post_crossposts",
					allowImages: "allow_images",
					allowChatPostCreation: "allow_chat_post_creation",
					allowDiscovery: "allow_discovery",
					allowPolls: "allow_polls",
					contentVisible: "allow_top",
					collapseDeletedComments: "collapse_deleted_comments",
					commentScoreHideMins: "comment_score_hide_mins",
					crowdControlMode: "crowd_control_mode",
					crowdControlLevel: "crowd_control_level",
					crowdControlChatLevel: "crowd_control_chat_level",
					description: "description",
					disableContributorRequests: "disable_contributor_requests",
					domain: "domain",
					excludeBannedModqueue: "exclude_banned_modqueue",
					headerHoverText: "header-title",
					hideAds: "hide_ads",
					isChatPostFeatureEnabled: "is_chat_post_feature_enabled",
					keyColor: "key_color",
					language: "lang",
					contentOptions: "link_type",
					over18: "over_18",
					publicDescription: "public_description",
					publicTraffic: "public_traffic",
					restrictCommenting: "restrict_commenting",
					restrictPosting: "restrict_posting",
					showMedia: "show_media",
					showMediaPreview: "show_media_preview",
					spamComments: "spam_comments",
					spamLinks: "spam_links",
					spamSelfposts: "spam_selfposts",
					spoilersEnabled: "spoilers_enabled",
					submitLinkLabel: "submit_link_label",
					submitText: "submit_text",
					submitTextLabel: "submit_text_label",
					suggestedCommentSort: "suggested_comment_sort",
					title: "title",
					subredditType: "type",
					welcomeMessageEnabled: "welcome_message_enabled",
					welcomeMessageText: "welcome_message_text",
					wikiEditAge: "wiki_edit_age",
					wikiEditKarma: "wiki_edit_karma",
					wikimode: "wikimode"
				},
				g = (e, t, n) => Object(s.b)(Object(o.a)(e, [c.a]), {
					method: r.bb.POST,
					endpoint: Object(i.a)("".concat(e.apiUrl, "/api/v1/subreddit/test_welcome_message")),
					data: {
						sr: t,
						test_message_text: n
					}
				})
		},
		"./src/reddit/endpoints/subreddit/similar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/models/MonthsToMinutes/index.ts");
			! function(e) {
				e.Factorization = "factorization", e.CustomModRelevant = "custom_mod_relevant"
			}(r || (r = {}));
			const d = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a.c;
				const n = new Set,
					r = e.map(e => e.data.children).map(e => e.reduce((e, t) => {
						const r = t.data.name;
						return n.has(r) || (e.push(t), n.add(r)), e
					}, [])),
					s = Math.max(...r.map(e => e.length)),
					o = [];
				for (let i = 0; i < s; i++) r.forEach(e => {
					const t = e[i];
					t && o.push(t)
				});
				return {
					data: {
						children: o.slice(0, t)
					}
				}
			};
			t.b = (e, t) => Object(o.b)(Object(i.a)(e, [c.a]), {
				data: {
					sr_fullnames: t.subredditIds.join(","),
					limit: t.count,
					variant: t.variant
				},
				endpoint: "".concat(e.apiUrl, "/api/similar_subreddits.json"),
				method: s.bb.GET
			})
		},
		"./src/reddit/endpoints/subreddit/topSubreddits.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/graphql/operations/TopSubreddits.json"),
				s = n("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t) => Object(s.a)(e, Object.assign({}, r, {
				variables: t
			}))
		},
		"./src/reddit/endpoints/user/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			}));
			var r = n("./src/config.ts"),
				s = n("./src/graphql/operations/ExperimentVariants.json"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const l = (e, t) => Object(i.b)(e, {
					endpoint: Object(u.a)("".concat(r.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/about")),
					method: o.bb.GET,
					data: {
						api_type: "json",
						gilding_detail: 1,
						awarded_detail: 1
					}
				}),
				b = e => Object(i.b)(Object(a.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_layout_switch"),
					method: o.bb.POST
				}),
				p = e => Object(i.b)(Object(a.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_give_award_tooltip"),
					method: o.bb.POST
				}),
				m = e => Object(i.b)(Object(a.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_modal"),
					method: o.bb.POST
				}),
				f = (e, t) => Object(c.a)(e, Object.assign({}, s, {
					variables: t
				}), {
					traceRequestName: "get_experiments"
				})
		},
		"./src/reddit/endpoints/user/preferences.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts");
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const c = {
				activityRelevantAds: "activity_relevant_ads",
				acceptPrivateMessages: "accept_pms",
				allowClickTracking: "allow_clicktracking",
				collapseReadMessages: "collapse_read_messages",
				defaultCommentSort: "default_comment_sort",
				emailDigests: "email_digests",
				emailUnreadMessages: "email_messages",
				emailUnsubscribe: "email_unsubscribe_all",
				geopopular: "geopopular",
				hasSeenCustomizeFlyout: "has_seen_customize_flyout",
				hideAds: "hide_ads",
				hideFromRobots: "hide_from_robots",
				hideNSFW: "no_profanity",
				highlightComments: "highlight_new_comments",
				ignoreSuggestedSort: "ignore_suggested_sort",
				inBeta: "beta",
				labelNSFW: "label_nsfw",
				markMessagesRead: "mark_messages_read",
				nightmode: "nightmode",
				over18: "over_18",
				sendWelcomeMessages: "send_welcome_messages",
				showMessagesInInbox: "threaded_messages",
				showNotifications: "live_orangereds",
				showUsernameMentionNotifications: "monitor_mentions",
				privateFeeds: "private_feeds",
				autoplayVideo: "video_autoplay",
				rpanDuDismissalTime: "rpan_du_dismissal_time",
				showActiveCommunities: "top_karma_subreddits",
				showRpanDu: n("./src/reddit/constants/preferences.ts").c,
				showTwitter: "show_twitter",
				stylesEnabled: "styles_enabled",
				openPostInNewTab: "open_post_in_new_tab",
				rememberCommunitySort: "remember_community_sort",
				useMarkdown: "use_markdown",
				sort: "sort",
				layout: "layout",
				rememberCommunityLayout: "remember_community_layout",
				topContentDismissalTime: "top_content_dismissal_time",
				topContentTimesDismissed: "top_content_times_dismissed",
				thirdPartyDataPersonalizedAds: "third_party_data_personalized_ads",
				thirdPartySiteDataPersonalizedAds: "third_party_site_data_personalized_ads",
				thirdPartySiteDataPersonalizedContent: "third_party_site_data_personalized_content"
			};
			var a = e => {
				const t = {};
				return Object.keys(e).map(n => {
					c.hasOwnProperty(n) && (t[c[n]] = e[n])
				}), t
			};
			const d = {
				isContributorRequestTimestamp: "is_contributor_request_timestamp",
				sort: "sort",
				stylesEnabled: "styles_enabled",
				layout: "layout"
			};
			var u = e => {
					const t = {};
					return Object.keys(e).map(n => {
						t[d[n]] = e[n]
					}), t
				},
				l = n("./src/reddit/constants/headers.ts");
			n.d(t, "f", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "h", (function() {
				return y
			}));
			const b = e => Object(o.b)(Object(i.a)(e, [l.a]), {
					method: s.bb.PATCH,
					endpoint: "".concat(e.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						over_18: "true"
					}
				}),
				p = (e, t) => Object(o.b)(Object(i.a)(t, [l.a]), {
					method: s.bb.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						video_autoplay: e
					}
				}),
				m = (e, t) => Object(o.b)(Object(i.a)(t, [l.a]), {
					method: s.bb.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						nightmode: e
					}
				}),
				f = (e, t) => Object(o.b)(Object(i.a)(t, [l.a]), {
					method: s.bb.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						geopopular: e
					}
				}),
				g = (e, t) => Object(o.b)(Object(i.a)(t, [l.a]), {
					method: s.bb.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: a(e)
				}),
				O = (e, t) => Object(o.b)(Object(i.a)(t, [l.a]), {
					method: s.bb.POST,
					endpoint: "".concat(t.apiUrl, "/api/quarantine_optin"),
					data: {
						sr_name: e,
						api_type: "json",
						accept: !0
					}
				}),
				h = (e, t) => Object(o.b)(t, {
					method: s.bb.POST,
					endpoint: "".concat(r.a.gatewayUrl, "/desktopapi/v1/set_preferences"),
					type: "json",
					data: {
						type: "account",
						preferences: a(e)
					}
				}),
				y = (e, t, n) => Object(o.b)(n, {
					method: s.bb.POST,
					endpoint: "".concat(r.a.gatewayUrl, "/desktopapi/v1/set_preferences"),
					type: "json",
					data: {
						type: "subreddit",
						subreddit_id: e,
						preferences: u(t)
					}
				})
		},
		"./src/reddit/featureFlags/communityTopics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/reddit/models/User/index.ts"),
				s = n("./src/reddit/selectors/user.ts");
			const o = () => !0,
				i = new Set(["0perspective", "coachzzz", "flash_55", "mikapp", "ggalex", "jdawg1000", "hidehidehidden", "ringrob"]),
				c = e => {
					if (!e.user.account) return !1;
					const t = Object(r.f)(e.user.account).toLowerCase();
					return Object(s.H)(e) && i.has(t)
				}
		},
		"./src/reddit/featureFlags/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./node_modules/lodash/isNil.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/mapValues.js"),
				i = n.n(o),
				c = n("./src/lib/getParsedUserAgent/index.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/crypto-js/sha256.js")),
				u = n.n(d),
				l = n("./src/reddit/constants/spezModal.ts");
			var b = n("./src/reddit/selectors/runTimeEnvVars.ts");
			const p = e => t => !e(t),
				m = function() {
					for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
					return e => t.some(t => t(e))
				},
				f = function() {
					for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
					return e => t.every(t => t(e))
				},
				g = e => t => ((e, t) => {
					let {
						user: n
					} = e;
					const r = n && n.features;
					return !(!r || !r[t])
				})(t, e),
				O = (e, t) => n => {
					const r = n.meta.pageloadServerTime;
					return r > e && r < t
				},
				h = e => !0,
				y = e => !1,
				j = e => !1,
				_ = a.H,
				E = m(j, b.c),
				v = e => !!e.user.session,
				I = O(l.d, l.e),
				S = O(15492132e5, 15492561e5);
			var T = n("./src/reddit/featureFlags/communityTopics.ts"),
				x = n("./src/reddit/featureFlags/layers.ts"),
				C = n("./src/reddit/selectors/moderatorPermissions.ts"),
				w = n("./src/reddit/selectors/platform.ts"),
				P = n("./src/reddit/selectors/subreddit.ts");
			const D = new Set(["ZombieSubreddits", "scheduled_posts_test", "gameofthrones", "LateShow", "WritingPrompts", "DCFU", "FlashTV", "supergirlTV", "TheOrville", "BuffaloBills", "rbny", "seahawks", "Mariners", "NASCAR", "BlackOps4", "CODZombies", "LabourUK", "StreetOutlaws", "pokemon", "pokemontrades", "SVExchange", "brakebills", "askhistorianspanel", "ClashRoyale", "Brawlstars", "CasualConversation", "tf2", "SCP", "DankMemesFromSite19", "TitansTV", "youngjustice", "DCDoomPatrol", "swampthingtv", "HarleyQuinnTV", "StargirlDCU", "Pigifs", "MovieDetails", "FruitsBasket", "Charleston", "TeraOnline", "indianapolis", "warhawk", "lounge", "GetMotivated", "Stormlight_Archive", "Cosmere", "brandonsanderson", "thelegendarium", "StarWarsBattlefront", "SandersForPresident", "cincinnati", "girlsfrontline", "Romania", "ClevelandIndians", "shortcuts", "HomePod", "Snooful", "slovenia", "TheGita", "TheMahabharata", "TheRamayana", "AnthemTheGame", "Games", "chile", "TheMandalorianTV", "LokiTV", "WANDAVISION", "CassianAndor", "OnePunchMan", "india", "xxketo4u2", "xxKetoOver50", "TheVoice", "nfl", "mac", "blackmirror", "appletv", "Psephology", "AppleArcade", "AppleTVPlus", "overwatch", "dankmemes", "arg", "slideforreddit", "TacoBell", "MonsterHunter", "shadownet", "shadownetwork", "TheFantasyInn", "GameDevs", "musicproduction", "PromoteYourMusic", "HipHopCollabs", "SpotifyPlaylists", "puppy101", "HauntingOfHillHouse", "SecularTarot", "StandardPoodles", "F1FeederSeries", "FormulaE", "TohokuJapan", "ketoscience", "TechnicalDeathMetal", "DebateAnAtheist", "KetoNews", "manatees", "BillHsomething", "chromatics", "cerner", "911FOX", "MarvelAvengersProject", "PantheonMMO", "Superman", "batman", "DCcomics", "discworld", "panelshow", "panelshows", "intothebadlands", "dndnext", "FireEmblemHeroes", "fireemblem", "streetwear", "svc518", "Mississauga", "rupaulsdragrace", "SpoiledDragRace", "RPDR_UK", "Jaguars", "alteredcarbon", "Letterkenny", "DarkSaint", "kotobukiya", "MegamiDevice", "FrameArms", "BoomBeach", "GolfClash", "WomensSoccer", "problemgambling", "gambling", "hamiltonmusical", "GoNets", "summonerswar", "eagles", "Arrow", "BlackLightning", "boardgames", "BoardGameExchange", "kosovo", "angelsbaseball", "orangecounty", "Socialism", "PaisosCatalans", "Amsterdam", "ElectricForest", "bassnectar", "nfrealmusic", "sillyrosster", "PS4Pro", "PSVR", "PS5", "comptia", "starwarscanon", "projectfi", "android_beta", "Sekiro", "Nioh", "denvernuggets", "giantbomb", "titanfolk", "attackontitan", "residentevil", "maryland", "traaaaaaannnnnnnnnns", "WeAreNotAsking", "redditvision_sc", "redditvision_nf", "urbanplanning", "valveindex", "HiTMAN", "Competitiveoverwatch", "ProjectRunway", "sitecore", "aem", "YangForPresidentHQ", "MaddenMobileForums", "InsiderMemeTrading", "CommentAwardsForum", "AsianBeautyAdvice", "NewOrleans", "malefashionadvice", "HBOGameofThrones", "AskBibleScholars", "EMS", "NewToEMS", "ItalyInformatica", "antiassholedesign", "BleachBraveSouls", "selectivemutism", "weddingplanning", "INDYCAR", "leagueoflegends", "Albania", "westcoasteagles", "CitiesSkylines", "Comcast_Xfinity", "AssassinsCreed", "iOSProgramming", "MarvelStudios", "cryptocurrency", "BostonUprising", "HarryPotterWU", "Gnomesinthings", "TheSilphRoad", "SpaceXLounge", "FinalFantasy", "the_revolupun", "pathfinder2e", "Drugs", "retrogaming", "FallenOrder", "TaylorSwift", "Dachschaden", "pathofexile", "BoneAppleTea", "MarioKartWii", "bostontrees", "MAMMJ", "NYCtrees", "chitrees", "Philippines", "boottoobig", "thedivision", "travisscott", "jitakyoei", "shieldbro", "islamabad", "CarletonU", "Charlotte", "BestDisney", "Arithmancy", "sysadmin", "progmetal", "discgolf", "adultswim", "greenday", "Rainbow6", "TibiaMMO", "gaybros", "bangtan", "Splatoon", "zerocarb", "Aleague", "phoenix", "xcxheads", "judocss", "Cloud9", "asoiaf", "alttpr", "spacex", "csgo", "ffxiv", "MMA", "Gwent", "NBA2k", "Colts", "MCPE", "Gunpla", "Muse", "disney", "eddit", "excel", "Bestbuy", "judo", "SubredditDrama", "TrollYChromosome", "stepschallenge", "survivor", "whatssnoo", "DotA2", "wtwave", "Paladins", "GreenBayPackers", "SAO_RisingSteel", "SwagBucks", "StarWars", "JustNotRight", "britisharmy", "RoleReversal", "DogsAndDesserts", "AjaxAmsterdam", "QTCinderella", "MissouriPolitics", "theworldofchertia", "FFBraveExvius", "algeria"].map(e => e.toLowerCase())),
				R = new Set(["QATrustedUser", "redesign", "legaladvice", "askwomen", "exmormon", "bestoflegaladvice", "relationships", "makeupaddiction", "rupaulsdragrace", "politicalhumor", "amitheasshole", "christianity", "askwomenadvice", "mariners", "analog", "futurology", "writingprompts", "blackpeopletwitter", "ffxiv", "dogswithjobs", "gaming", "science", "politics", "games", "Colorado", "iphone", "Seattle", "tifu", "nottheonion", "Denver", "convopolis", "JARTEM", "markistest", "chattest", "browns", "TwoXChromosomes", "jailbreak", "modernwarfare", "linux", "kpop", "lgbt", "rage", "MorbidReality", "BigBoobsGW", "discordapp", "SCP", "LosAngelesRams", "pathofexile", "3amjokes", "bisexual", "Military", "weightroom", "london", "actuallesbians", "gatesopencomeonin", "FortniteCompetitive", "fireemblem", "melbourne", "traaaaaaannnnnnnnnns", "China", "JUSTNOFAMILY", "theydidthemonstermath", "transtimelines", "sandiego", "syriancivilwar", "ontario", "Browns", "pittsburgh", "MtF", "phoenix", "florida", "greece", "Stadia", "arizona", "NewOrleans", "Charlotte", "Detroit", "trans", "Miami", "Sacramento", "ask_transgender", "BlackLadiesFitness", "stlouisblues", "Virginia", "AskScienceFiction", "motogp", "AzureLane", "lifeisstrange", "DarlingInTheFranxx", "flightsim", "twice", "selfie", "coys", "askcarsales", "FulfillmentByAmazon", "SonicTheHedgehog", "ContraPoints", "GenderCritical", "Columbus", "ElectricForest", "titanfolk", "NPR", "BethesdaSoftworks", "coversongs", "velvethippos", "feemagers", "5ToubunNoHanayome", "Neverwinter", "Habs", "Toyota", "Bestbuy", "plexshares", "TheWalkingDeadGame", "blessedcomments", "bassnectar", "Pete_Buttigieg", "GamerGhazi", "battlebots", "pelotoncycle", "Epstein", "androidcirclejerk", "CatsWithDogs", "immigration", "MysteryDungeon", "Dogfree", "Justnofil", "rollerblading", "Charleston", "PuertoRico", "PennStateUniversity", "angelsbaseball", "Spokane", "leagueoflegends", "CasualConversation", "unitedkingdom", "PeopleSellingMirrors", "personalfinance", "TheBukuProject", "Fitness", "Minecraft", "voodoo", "nfl", "ReformedHumor", "pcgaming", "nra", "DnD", "scifi", "comics", "CarletonU", "cursedcomments", "JUSTNOMIL", "ItalyInformatica", "TrollXChromosomes", "tuesday", "formula1", "asoiaf", "LetterstoJNMIL", "NotMyJob", "canada", "ClevelandIndians", "vegaslocals", "SandersForPresident", "medicine", "socialism", "Iowa", "BattlefieldV", "badhistory", "FireEmblemHeroes", "nova", "hinduism", "Vive", "TrueCrimeDiscussion", "SeattleWA", "razer", "DuelLinks", "EnoughTrumpSpam", "Megumin", "HaveWeMet", "Konosuba", "cowboys", "collapse", "disneyvacation", "ADHD", "teslamotors", "insaneparents", "marvelstudios", "baseball", "askaconservative", "apple", "MadeMeSmile", "circumcision", "AskMen", "cars", "europe", "JoeBiden", "transsupport", "PoliticalMemes", "brisbane", "omad"].map(e => e.toLowerCase()));
			var A = n("./src/reddit/featureFlags/subredditPoints.ts");
			const k = new Set(["askaliberal", "asktransgender", "askwomen", "bisexual", "blackladies", "exchristian", "exmormon", "gendercynical", "girlgamers", "neoliberal", "nothowgirlswork", "progresspics", "subredditdrama", "teenagers", "thegirlsurvivalguide", "thequickbrowncorgi", "traaaaaaannnnnnnnnns", "transpositive", "trollxchromosomes", "twoxchromosomes"]);
			n.d(t, "d", (function() {
				return L
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "f", (function() {
				return U
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "b", (function() {
				return G
			})), n.d(t, "c", (function() {
				return V
			})), n.d(t, "e", (function() {
				return q
			}));
			const N = {
					introModal: p(E),
					markdownMode: E,
					modQueue: m(E, _),
					spBadges: A.c,
					spCustomBadges: A.e,
					spCommunityTipJar: A.d,
					spEmotes: A.f,
					spEmotesModTools: A.g,
					spFavoriteCreators: A.h,
					spFreeTrialSubscriptions: A.i,
					spGiphy: A.j,
					spGovPolls: A.k,
					spHarberger: A.l,
					spKarmaPoints: A.m,
					spLeaderboard: A.n,
					spLoadtest: A.o,
					spPoints: A.p,
					spPolls: A.q,
					spPremium: A.r,
					spPremiumSubscriptions: A.s,
					spPremiumUpsells: A.t,
					spPublicPoints: A.u,
					spSpinoffs: A.v,
					spStellarWalletRegistration: A.w,
					spSupport: A.x,
					spTipping: A.y,
					spTopTippers: A.z,
					spWalletRegistrationBanner: A.A,
					scheduledPosts: m(E, e => {
						const t = Object(w.e)(e),
							n = !!t && Object(C.e)(e, {
								subredditId: Object(P.G)(e, t)
							});
						return !!t && n && D.has(t.toLowerCase())
					}),
					communityTopics: T.b,
					adminCommunityTopics: T.a,
					events: m(g("event_posts"), E),
					collections: m(g("collections"), E),
					rteVideoPoster: E,
					userSeenSubredditChatFtux: a.db,
					userInChat: a.B,
					userInSubredditChat: a.E,
					userInChatUserSettings: a.C,
					devAndStagingWatermark: E,
					fpsMeter: y,
					rabbitHole: y,
					measureScrollFPS: _,
					showVerboseErrors: m(E, _),
					uappBanner: y,
					experiments: f(v, p(j)),
					enableGraphQl: v,
					importExportThemes: _,
					flairRestrictions: h,
					newPostRequirements: h,
					spezModal: m(E, f(I, function() {
						for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
						return e => t.some(t => t === e.meta.country)
					}("US"))),
					superbOwl: S,
					enableShadowMode: (e => t => ((e, t) => {
						let {
							user: n
						} = e;
						if (0 === t) return !1;
						const r = n && n.loid.loid;
						return !!r && parseInt(u()(r).toString(), 16) % 1e3 < 10 * t
					})(t, e))(0),
					pushNotificationsBrowserSupported: e => {
						const t = navigator.userAgent,
							n = Object(c.a)(t).browser.version;
						if (!n) return !1;
						let r;
						try {
							r = n.split(/[^\d]/)[0]
						} catch (s) {
							return !1
						}
						return !!(Object(c.b)(t) && parseInt(r) >= 50 && Object(c.c)(t)) || (!!(Object(c.d)(t) && parseInt(r) > 52 && Object(c.c)(t)) || !!(Object(c.f)(t) && parseInt(r) >= 27 && Object(c.c)(t)))
					},
					enableCrowdControlMode: e => !1,
					enableCrowdControlLevel: e => {
						const t = Object(w.e)(e);
						return !!t && R.has(t.toLowerCase())
					},
					enableToxicityWarning: e => {
						const t = Object(w.e)(e);
						return !!t && k.has(t.toLowerCase())
					},
					snoovatar30: E,
					isEmailPermissionRequired: g("is_email_permission_required"),
					focusedVerticalsExperiment: h,
					subredditInlineEditing: h,
					layersEmbed: x.b,
					layersEmbedQuickLink: x.c,
					subredditMentionD2xExperiment: h,
					__requiredDoNotRemove: y
				},
				L = i()(N, (e, t) => n => {
					const r = n.featureFlags.overrides[t];
					return s()(r) ? e(n) : r
				}),
				M = Object.keys(N),
				U = e => e.filter(e => "__requiredDoNotRemove" !== e),
				F = /^feature_(.*)$/i,
				B = e => {
					const t = e.match(F);
					if (null !== t) return t[1]
				},
				G = "FEATURES__FEATURE_SET",
				V = "FEATURES__FEATURE_TOGGLED",
				q = e => {
					let {
						featureName: t
					} = e;
					return (e, n) => {
						const r = (0, L[t])(n());
						e((e => {
							let {
								featureName: t,
								currentValue: n
							} = e;
							return {
								type: V,
								payload: {
									featureName: t,
									currentValue: n
								}
							}
						})({
							featureName: t,
							currentValue: r
						}))
					}
				}
		},
		"./src/reddit/featureFlags/layers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/reddit/selectors/platform.ts");
			const s = new Set(["layer", "isslayerstest"]);
			const o = e => {
					const t = Object(r.e)(e);
					return !!t && a(t.toLowerCase())
				},
				i = e => o(e) && !1,
				c = e => o(e) && !0,
				a = e => s.has(e.toLowerCase()),
				d = () => !1
		},
		"./src/reddit/featureFlags/profileCollections.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/reddit/models/User/index.ts");
			const s = new Set(["0perspective", "almondparfitt", "almondparfitt", "avocadoast", "chtorrr", "coachzzz", "crowd__pleaser", "dadintech", "flash_55", "igabeup", "kalluraya", "kp-krunal", "kpkrunal", "lakelly000", "sodypop", "vlkoti", "wokata", "wting", "mynameizkhan", "mattkula", "wokata", "vladkonon", "jamiewu683", "casualwill", "Mother_of_Memes", "hardleyjeannite", "recklessmaterialism"]),
				o = e => {
					if (!e.user.account) return !1;
					const t = Object(r.f)(e.user.account).toLowerCase();
					return s.has(t)
				}
		},
		"./src/reddit/featureFlags/subredditPoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return j
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "c", (function() {
				return P
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "f", (function() {
				return A
			})), n.d(t, "g", (function() {
				return k
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "i", (function() {
				return L
			})), n.d(t, "j", (function() {
				return M
			})), n.d(t, "k", (function() {
				return U
			})), n.d(t, "l", (function() {
				return F
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "n", (function() {
				return G
			})), n.d(t, "o", (function() {
				return V
			})), n.d(t, "p", (function() {
				return q
			})), n.d(t, "q", (function() {
				return H
			})), n.d(t, "r", (function() {
				return K
			})), n.d(t, "s", (function() {
				return W
			})), n.d(t, "t", (function() {
				return Y
			})), n.d(t, "u", (function() {
				return z
			})), n.d(t, "v", (function() {
				return J
			})), n.d(t, "w", (function() {
				return Q
			})), n.d(t, "y", (function() {
				return X
			})), n.d(t, "A", (function() {
				return Z
			})), n.d(t, "x", (function() {
				return $
			})), n.d(t, "z", (function() {
				return ee
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/reddit/selectors/platform.ts");
			const s = new Set(["daonuts", "ethtrader", "karma_chameleon", "pointsrtesty", "stellartest"]),
				o = new Set(["badgesroyaletest", "fortnitebr", "funkygoose"]),
				i = new Set(["funkygoose"]),
				c = new Set(["badgesroyaletest", "fortnitebr", "funkygoose"]),
				a = new Set(["fortnitebr", "funkygoose"]),
				d = new Set(["funkygoose"]),
				u = new Set(["badgesroyaletest", "fortnitebr"]),
				l = new Set(["badgesroyaletest", "daonuts", "ethtrader", "fortnitebr", "funkygoose", "stellartest"]),
				b = new Set(["daonuts", "ethtrader", "funkygoose", "funkygooseeggs", "karma_chameleon", "modtestmeyourpoints", "mountainbiking", "nr4madastest", "pointsrtesty", "project_kairos", "qameplease", "stellar", "stellartest"]),
				p = new Set(["daonuts", "ethtrader", "funkygoose", "stellar"]),
				m = new Set(["badgesroyaletest", "fortnitebr"]),
				f = new Set(["badgesroyaletest", "daonuts", "ethtrader", "fortnitebr", "funkygoose", "stellar", "stellartest"]),
				g = new Set([]),
				O = new Set(["daonuts", "ethtrader", "funkygoose", "funkygooseeggs", "karma_chameleon", "modtestmeyourpoints", "mountainbiking", "nr4madastest", "pointsrtesty", "project_kairos", "qameplease", "stellar", "stellartest"]),
				h = new Set(["daonuts", "ethtrader", "funkygoose", "funkygooseeggs", "karma_chameleon", "modtestmeyourpoints", "mountainbiking", "nr4madastest", "pointsrtesty", "project_kairos", "qameplease", "stellar", "stellartest"]),
				y = new Set(["daonuts", "ethtrader", "funkygoose", "badgesroyaletest", "fortnitebr", "stellartest"]),
				j = new Set(["badgesroyaletest", "daonuts", "ethtrader", "fortnitebr", "funkygoose", "stellartest"]),
				_ = new Set(["badgesroyaletest", "fortnitebr", "funkygoose"]),
				E = new Set(["daonuts", "ethtrader", "funkygoose", "mountainbiking", "stellar", "stellartest"]),
				v = new Set(["funkygoose"]),
				I = new Set(["badgesroyaletest", "daonuts", "ethtrader", "fortnitebr", "funkygoose", "shittymorph", "stellartest"]),
				S = new Set(["daonuts", "ethtrader", "funkygoose", "mountainbiking", "stellar", "stellartest"]),
				T = new Set(["funkygoose"]),
				x = new Set(["stellar", "stellartest"]),
				C = new Set(["daonuts", "ethtrader"]),
				w = function() {
					for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
					return e => {
						const n = Object(r.e)(e);
						if (n) {
							for (const e of t)
								if (!e.has(n.toLowerCase())) return !1;
							return !0
						}
						return !1
					}
				},
				P = w(O, s),
				D = w(o),
				R = w(I, i),
				A = w(c),
				k = w(a),
				N = w(I, d),
				L = w(j, u),
				M = w(l),
				U = w(O, h, b),
				F = w(O, p),
				B = w(m),
				G = w(f),
				V = w(g),
				q = w(O),
				H = w(O, h),
				K = w(I, y),
				W = w(I, j),
				Y = w(I, _),
				z = w(E),
				J = w(O, v),
				Q = w(x),
				X = w(E, S),
				Z = w(C),
				$ = w(I),
				ee = w(I, T)
		},
		"./src/reddit/helpers/adCount/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				o = n("./src/reddit/selectors/platform.ts");
			const i = (e, t, n) => [e, t, n].join("/"),
				c = (e, t) => {
					switch (t) {
						case s.a.SUBREDDIT:
						case s.a.COMMENTS_OVERLAY:
						case s.a.COMMENTS: {
							const t = Object(o.i)(e);
							return [i(r.c.ABOVE_THE_FOLD, t, 0), i(r.c.BELOW_THE_FOLD, t, 1)]
						}
						case s.a.FRONTPAGE:
							return [i(r.c.ABOVE_THE_FOLD, !1, 0), i(r.c.BELOW_THE_FOLD, !1, 1)];
						case s.a.MULTIREDDIT:
						case s.a.SEARCH_RESULTS:
							return [i(r.c.BELOW_THE_FOLD, !1, 0)];
						default:
							return [i(r.c.ABOVE_THE_FOLD, !1, 0), i(r.c.BELOW_THE_FOLD, !1, 1)]
					}
				}
		},
		"./src/reddit/helpers/addRedesignIdentifier/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			}));
			var r = n("./src/config.ts"),
				s = n("./node_modules/url/url.js"),
				o = n.n(s),
				i = n("./src/lib/addQueryParams/index.ts");

			function c(e) {
				const {
					protocol: t,
					host: n
				} = o.a.parse(e), s = "".concat(t, "//").concat(n) === r.a.oauthUrl ? r.a.telemetry.appName.redesignR2 : r.a.telemetry.appName.redesign, c = {
					redditWebClient: s,
					app: "".concat(s, "-").concat("client", "-").concat("production")
				};
				return Object(i.a)(e, c)
			}
			const a = () => {
				const e = r.a.telemetry.appName.redesignR2;
				return {
					redditWebClient: e,
					app: "".concat(e, "-").concat("client", "-").concat("production")
				}
			}
		},
		"./src/reddit/helpers/canonicalUrls.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./node_modules/react-router-redux/es/index.js"),
				s = n("./node_modules/url/url.js"),
				o = n.n(s),
				i = n("./src/lib/addQueryParams/index.ts"),
				c = n("./src/lib/isAdHocMultireddit/index.ts"),
				a = n("./src/lib/isFakeSubreddit/index.ts"),
				d = n("./src/reddit/actions/otherDiscussions/constants.ts"),
				u = n("./src/reddit/models/Comment/index.ts"),
				l = n("./src/reddit/models/Post/index.ts"),
				b = (n("./src/reddit/selectors/meta.ts"), n("./src/reddit/selectors/multireddit.ts")),
				p = n("./src/reddit/selectors/subreddit.ts");
			const m = (e, t, n, s) => {
					const o = Object(i.a)(n, s),
						c = e.platform && e.platform.currentPage && e.platform.currentPage.locationState || void 0;
					t(Object(r.c)(o, c))
				},
				f = (e, t, n) => {
					const {
						params: r,
						queryParams: s,
						url: o
					} = n, {
						multiredditName: i,
						username: c
					} = r, a = Object(b.g)(e, {
						multiredditName: i,
						username: c
					});
					if (!a) return;
					const d = o === a,
						u = o.endsWith("/");
					if (d && u) return;
					const l = u ? o : "".concat(o, "/"),
						p = d ? l : "".concat(a).concat(l.substr(a.length));
					m(e, t, p, s)
				},
				g = (e, t, n) => {
					const {
						params: r,
						queryParams: s,
						url: o
					} = n, {
						subredditName: i
					} = r;
					if (i) {
						const n = "/user/".concat(i, "/"),
							r = o.endsWith("/"),
							c = Object(p.b)(e, {
								profileName: i
							});
						if (!c) return;
						const a = n === c;
						if (a && r) return;
						const d = r ? o : "".concat(o, "/"),
							u = a ? d : d.replace(n, c);
						m(e, t, u, s)
					}
				},
				O = (e, t) => {
					let n;
					if (Object(a.a)(t) && Object(c.a)(t)) {
						const {
							subredditIds: r
						} = Object(b.a)(e, {
							listingName: t
						});
						if (!r) return;
						const s = Object(p.Z)(e, {
							subredditIds: r
						}).map(e => e.name).sort().join("+");
						n = "/r/".concat(s, "/")
					}
					return n
				},
				h = (e, t, n) => {
					const {
						params: r,
						queryParams: s,
						url: i
					} = n, {
						partialCommentId: c,
						partialPostId: a
					} = r, b = c ? Object(u.e)(c) : "", p = a ? Object(l.m)(a) : "";
					if (b) {
						const n = e.comments.models[b];
						if (!n) return;
						const r = o.a.parse(n.permalink).pathname;
						r && r !== i && m(e, t, r, s)
					} else if (p) {
						const r = e.posts.models[p];
						if (!r) return;
						const c = o.a.parse(r.permalink).pathname,
							a = Object(d.d)(n.path),
							u = c && a ? Object(d.e)(c) : c;
						c && c !== i && !a ? m(e, t, c, s) : u && u !== Object(d.e)(i) && a && m(e, t, u, s)
					}
				},
				y = e => e.replace(/\/$/, ""),
				j = (e, t, n) => {
					const {
						params: r,
						queryParams: s,
						url: o
					} = n, {
						subredditName: i
					} = r;
					if (i) {
						const n = "/r/".concat(i, "/"),
							r = o.endsWith("/");
						let d = o;
						if (Object(a.a)(i) && Object(c.a)(i)) {
							const t = O(e, i);
							t && (d = d.replace(y(n), y(t)))
						} else {
							const t = Object(p.d)(e, {
								subredditName: i
							});
							if (!t) return;
							const s = (Object(a.a)(i) ? n.toLowerCase() : n) === t;
							if (s && r) return;
							const c = r ? o : "".concat(o, "/");
							d = s ? c : c.replace(y(n), y(t))
						}
						d !== o && m(e, t, d, s)
					}
				}
		},
		"./src/reddit/helpers/categoryPickerWidget/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./src/reddit/helpers/name/index.ts");
			const s = (e, t) => t.map(t => {
					const n = Object(r.f)(t.name),
						s = n.split(" & ").join("_and_");
					return Object.assign({}, t, {
						name: n,
						path: t.path || "".concat(e).concat(s, "/")
					})
				}),
				o = e => Object(r.f)(e).split("_and_").join(" & ")
		},
		"./src/reddit/helpers/chooseVariant/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/featureThrottling/store/index.ts"),
				i = n("./src/lib/env/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const a = Object(r.a)(e => e.page && e.user ? e.user.experiments.models.concat(e.page.experiments.models) : [], (e, t) => t.experimentName, (e, t) => e.find(e => {
					let {
						name: n
					} = e;
					return n.toLowerCase() === t.toLowerCase()
				})),
				d = (e, t) => {
					let {
						experimentName: n
					} = t;
					const r = Object(c.i)(e),
						o = !!r && r.isEmployee;
					return (Object(i.a)() || o || s.H.has(n.toLowerCase())) && e.experimentOverrides ? e.experimentOverrides[n.toLowerCase()] : void 0
				};
			var u = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				b = n("./src/telemetry/index.ts"),
				p = n("./src/telemetry/models/Event.ts");
			const m = (e, t, n) => {
					Object(b.a)(Object.assign({
						source: p.e.Experiment,
						action: p.c.Expose,
						noun: p.d.UserId,
						actionInfo: void 0,
						app: l.app(),
						experiment: t,
						referrer: void 0,
						session: void 0,
						user: e
					}, n))
				},
				f = (e, t) => {
					const n = l.request(e),
						r = (e => e.page.experiments.canonicalUrl)(e);
					r && (n.canonical_url = r);
					const s = d(e, t),
						o = void 0 !== s,
						i = a(e, t);
					let c;
					o ? c = {
						id: -1,
						isOverride: !0,
						name: t.experimentName,
						variant: s,
						version: "-1"
					} : i && (c = Object.assign({}, i, {
						isOverride: !1
					}));
					const m = Object(u.o)(e),
						f = m ? l.post(e, m) : void 0;
					Object(b.a)({
						source: p.e.Experiment,
						action: p.c.Expose,
						noun: p.d.CanonicalUrl,
						actionInfo: void 0,
						app: l.app(),
						experiment: c,
						post: f,
						request: n,
						referrer: void 0,
						session: void 0,
						subreddit: l.subreddit(e),
						user: l.user(e)
					})
				};
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return E
			}));
			const g = (e, t) => {
					if (!t.experimentEligibilitySelector(e)) return !1;
					if (t.isThrottled && o.a.isFeatureThrottled(t.experimentName)) return !1;
					if (t.throttledVariants) {
						const n = ((e, t) => {
								const n = a(e, t),
									r = d(e, t);
								return void 0 !== r ? r : n && n.name || void 0
							})(e, t),
							r = n && t.throttledVariants[n];
						if (r && o.a.isFeatureThrottled(r)) return !1
					}
					return !0
				},
				O = () => !0,
				h = {},
				y = [s.d, s.e],
				j = Object(r.a)((e, t) => e, a, d, g, (e, t) => t.expEventOverride, (e, t) => t.experimentName, (e, t, n, r, s, o) => {
					if (!r) return;
					if (!t) return n && h[o] !== n && !1 !== s && (f(e, {
						experimentName: o
					}), h[o] = n), n;
					const i = t.name,
						c = void 0 !== n ? n : t.variant;
					if (c) {
						h[i] === c || !1 === s || f(e, {
							experimentName: o
						})
					}
					return c
				}),
				_ = Object(r.a)(a, d, e => l.user(e), (e, t) => t.expEventOverride, (e, t) => t.customPayloadMaker && t.customPayloadMaker(e), g, (e, t) => t.experimentName, (function(e, t, n, r) {
					let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
						o = arguments.length > 5 ? arguments[5] : void 0,
						i = arguments.length > 6 ? arguments[6] : void 0;
					if (!o) return;
					if (!e) return t && !1 !== r && h[i] !== t && !y.includes(i) && (m(n, {
						id: -1,
						isOverride: !0,
						name: i,
						variant: t,
						version: "-1"
					}, s), h[i] = t), t;
					const c = e.name,
						{
							id: a
						} = e,
						d = void 0 !== t,
						u = d ? t : e.variant;
					if (u) {
						const t = -1 === a,
							o = h[c] === u;
						t || o || !1 === r || y.includes(i) || (m(n, Object.assign({}, e, {
							isOverride: d,
							variant: u
						}), s), h[c] = u)
					}
					return d ? t : u
				})),
				E = (e, t) => {
					const n = l.user(e),
						r = a(e, t),
						s = d(e, t),
						o = void 0 !== s;
					if (r) {
						const e = o ? s : r.variant;
						e && m(n, Object.assign({}, r, {
							isOverride: o,
							variant: e
						}), {})
					}
				}
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/reddit/constants/comments.ts"),
				s = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts");
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			}));
			const c = (e, t) => t().comments.models[e],
				a = e => {
					switch (e.commentLink.type) {
						case r.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case r.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case r.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				d = (e, t) => e.type === r.a.MoreComments ? t[e.id].numComments : 1,
				u = (e, t, n, r) => {
					let o = Object(s.o)(r, {
							commentLink: t,
							commentsPageKey: e
						}),
						i = t;
					for (; o && o.depth > n && o.prev && (i = o.prev, (o = Object(s.o)(r, {
							commentLink: i,
							commentsPageKey: e
						})) && !(o.depth <= n)););
					return i.id
				},
				l = (e, t, n) => {
					const {
						commentLists: r,
						comments: s
					} = e, {
						head: c
					} = r[t];
					if (c) return Object.keys(s).filter(e => {
						const t = s[e];
						return !(!t.isStickied || !((e, t) => {
							const n = Object(i.c)(e, {
								experimentEligibilitySelector: i.a,
								experimentName: o.g,
								expEventOverride: t
							});
							return !!(Object(o.Wb)(n) ? void 0 : n)
						})(n)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/correlationIdTracker.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var r, s = n("./node_modules/uuid/v4.js"),
				o = n.n(s);
			! function(e) {
				e.AwardCreationFlow = "AwardCreationFlow", e.AwardDeletionFlow = "AwardDeletionFlow", e.Explore = "Explore", e.GildingFlow = "GildingFlow", e.GiftPremiumFlow = "GiftPremiumFlow", e.GoldPayment = "GoldPayment", e.PostComposer = "PostComposer", e.PremiumSettings = "PremiumSettings", e.SearchResults = "SearchResults", e.VideoView = "VideoView"
			}(r || (r = {}));
			const i = {},
				c = e => i[e],
				a = e => i[e] = o()(),
				d = e => i[e] = void 0
		},
		"./src/reddit/helpers/dom/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var r = n("./node_modules/lodash/map.js"),
				s = n.n(r),
				o = n("./src/lib/FocusTrap/index.ts");
			const i = e => "INPUT" === e.tagName.toUpperCase() || "TEXTAREA" === e.tagName.toUpperCase() || "DIV" === e.tagName.toUpperCase() && e.isContentEditable,
				c = e => {
					let t = e;
					do {
						if (i(t)) return !0
					} while (t = t.parentElement);
					return !1
				},
				a = () => {
					const e = document.getSelection();
					return !!e && (e.rangeCount > 0 && e.getRangeAt(0).toString().length > 0)
				},
				d = () => a() ? (() => {
					const e = document.getSelection();
					if (!e) return [];
					const t = e.getRangeAt(0).cloneContents().childNodes;
					return s()(t, e => e.textContent || "")
				})() : null,
				u = (e, t) => {
					const n = document.createRange();
					return n.selectNode(t), e.compareBoundaryPoints(Range.END_TO_START, n) < 0 && e.compareBoundaryPoints(Range.START_TO_END, n) > 0
				},
				l = e => {
					const t = window.getSelection();
					if (1 !== t.rangeCount) return;
					const n = t.getRangeAt(0);
					if (!u(n, e)) return;
					const {
						startContainer: r,
						startOffset: s,
						endContainer: o,
						endOffset: i
					} = n, c = document.createRange();
					c.selectNode(e);
					let a = !0;
					if (-1 === c.compareBoundaryPoints(Range.START_TO_START, n) && (c.setStart(r, s), a = !1), 1 === c.compareBoundaryPoints(Range.END_TO_END, n) && (c.setEnd(o, i), a = !1), a) return [e];
					const d = document.createElement("div");
					return d.appendChild(c.cloneContents()), [...d.childNodes]
				},
				b = (e, t, n) => {
					let r = e;
					for (; r && (!n || !n(r));) {
						if (r && t(r)) return r;
						r = r.parentElement
					}
				},
				p = e => e && e.parentElement && b(e.parentElement, e => "static" !== window.getComputedStyle(e).getPropertyValue("position")),
				m = e => {
					if (!e || e.hidden) return !0;
					if (window.getComputedStyle) {
						const t = window.getComputedStyle(e);
						if ("none" === t.display || "hidden" === t.visibility) return !0
					}
					return !!e.parentElement && m(e.parentElement)
				},
				f = e => {
					e.querySelectorAll(o.a).forEach(e => {
						e.tabIndex = -1
					})
				}
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");

			function r(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let n = 0;
				return e.placement && t.placement && (n = e.placement.localeCompare(t.placement)), 0 === n && e.position && t.position && (n = e.position - t.position), 0 === n && (n = e.title.localeCompare(t.title)), n
			}

			function s(e) {
				return [...e].sort(r)
			}
		},
		"./src/reddit/helpers/favoriteCreators/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./src/lib/constants/index.ts"), n("./src/config.ts"), n("./src/reddit/endpoints/governance/requester.ts");
			n("./src/reddit/endpoints/economics/tips.ts");
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			const r = {
					creators: {},
					lastFetch: 0,
					posts: [],
					tippablePosts: {}
				},
				s = e => "favorite-creators-".concat(e),
				o = e => {
					try {
						const t = localStorage.getItem(s(e));
						if (t) return Object.assign({}, r, JSON.parse(t))
					} catch (t) {}
					return r
				},
				i = (e, t) => {
					try {
						return localStorage.setItem(s(e), JSON.stringify(t)), !0
					} catch (n) {}
					return !1
				},
				c = e => {
					const t = o(e).creators;
					return Object.keys(t).sort((e, n) => t[e] - t[n]).slice(0, 100)
				},
				a = (e, t) => {
					const n = o(e);
					if (Object.keys(n.creators).length >= 200 && !n.creators[t]) {
						const t = c(e),
							r = t[t.length - 1];
						delete n.creators[r]
					}
					return n.creators[t] = (n.creators[t] || 0) + 1, i(e, n)
				},
				d = (e, t) => {
					const n = o(e);
					return delete n.creators[t], i(e, n)
				}
		},
		"./src/reddit/helpers/featureThrottling/store/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/uuid/v4.js"),
				s = n.n(r),
				o = n("./src/reddit/constants/featureThrottling.ts"),
				i = n("./src/reddit/helpers/localStorage/index.ts"),
				c = n("./node_modules/lodash/uniq.js"),
				a = n.n(c),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./src/reddit/models/FeatureThrottling/index.ts");
			const l = [],
				b = (e, t, n) => {
					switch (e.type) {
						case u.b.TimesPerPeriod: {
							const n = Date.now() - e.period;
							return t.filter(e => e.when >= n).length < e.times
						}
						case u.b.TimesPerSession:
							return t.filter(e => e.sessionId === n).length < e.times;
						case u.b.TimesTotal:
							return t.length < e.times;
						case u.b.NthSession:
							return a()([...t.map(e => e.sessionId), n]).length % e.nth == 0;
						case u.b.Combined:
							return (e.op === u.a.And ? Array.prototype.every : Array.prototype.some).call(e.configs, e => b(e, t, n));
						default:
							return !1
					}
				},
				p = Object(d.a)((e, t) => t.name, (e, t) => t.sessionId, (e, t) => o.a[t.name], (e, t) => e[t.name] || l, (e, t, n, r) => {
					if (!n) return !1;
					try {
						return b(n, r, t)
					} catch (s) {
						return !1
					}
				}),
				m = (e, t) => !p(e, t);
			const f = new class {
				constructor() {
					this.isReady = !1, this.listeners = new Set, this.sessionId = "", this.throttlingData = {}, this.subscribe = e => {
						this.listeners.has(e) || (this.listeners.add(e), this.isReady && e(this.throttlingData))
					}, this.unsubscribe = e => {
						this.listeners.delete(e)
					}, this.persistToLSAndNotify = e => {
						Object(i.L)(this.throttlingData), this.notifyAll(e)
					}, this.isFeatureThrottled = e => !!this.isReady && m(this.throttlingData, {
						name: e,
						sessionId: this.sessionId
					}), this.throttleFeature = e => {
						o.a[e] && !this.isFeatureThrottled(e) && (this.throttlingData = Object.assign({}, this.throttlingData, {
							[e]: [...this.throttlingData[e] || [], {
								sessionId: this.sessionId,
								when: Date.now()
							}]
						}), this.persistToLSAndNotify(e))
					}, this.resetFeature = e => {
						o.a[e] && (this.throttlingData = Object.assign({}, this.throttlingData, {
							[e]: []
						}), this.persistToLSAndNotify(e))
					}
				}
				initialize() {
					const e = Object(i.j)();
					if (!e) return;
					const t = Object.keys(o.a);
					let n = !1;
					Object.keys(e).forEach(r => {
						t.includes(r) || (delete e[r], n = !0)
					}), n && Object(i.L)(e), this.throttlingData = e, this.sessionId = s()(), this.isReady = !0, this.notifyAll()
				}
				notifyAll(e) {
					this.isReady && this.listeners.forEach(t => {
						t(this.throttlingData, e)
					})
				}
			};
			t.a = f
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/lodash/findLastIndex.js"),
				s = n.n(r),
				o = n("./src/reddit/models/WhitelistStatus/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/index.ts"),
				a = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const d = (e, t) => {
				let {
					subreddits: n,
					profiles: r
				} = t;
				const s = n[e.belongsTo.id] || r[e.belongsTo.id];
				return !e.isNSFW && s && s.wls === o.a.ALL_ADS
			};
			t.a = (e, t, n) => {
				var {
					postIds: r,
					posts: o,
					subreddits: u,
					profiles: l
				} = n, b = a(n, ["postIds", "posts", "subreddits", "profiles"]);
				const p = e.listings.postOrder.ids[t],
					m = (r || []).filter(e => !p || !p.includes(e)),
					f = p.map(t => e.posts.models[t]),
					g = f.length - (s()(f, e => e.isSponsored) + 1),
					O = m.map(e => o[e]);
				let h;
				const y = [],
					j = {
						subreddits: u,
						profiles: l
					};
				for (let s = 0; s < O.length; s++) {
					const n = O[s];
					let r = !1;
					if (n.isSponsored) {
						const e = s > 0 && O[s - 1],
							t = s < O.length - 1 && O[s + 1];
						e && d(e, j) && t && d(t, j) && (r = !0)
					}
					n.isSponsored && r && (null == h && g + s >= 3 || s - h >= 3) ? (h = s, y.push(n.id)) : n.isSponsored ? n.isSponsored && Object(c.a)(Object.assign({
						source: "feed",
						action: "remove",
						noun: "ad"
					}, i.defaults(e), {
						listing: i.listing(e, t)
					})) : y.push(n.id)
				}
				return Object.assign({}, b, {
					subreddits: u,
					profiles: l,
					posts: o,
					postIds: y
				})
			}
		},
		"./src/reddit/helpers/flair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "p", (function() {
				return l
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "q", (function() {
				return O
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "r", (function() {
				return P
			})), n.d(t, "k", (function() {
				return D
			})), n.d(t, "m", (function() {
				return R
			})), n.d(t, "j", (function() {
				return A
			})), n.d(t, "e", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./node_modules/lodash/isEqual.js"),
				s = n.n(r),
				o = n("./src/lib/addQueryParams/index.ts"),
				i = n("./src/lib/formatEmojiName/index.ts"),
				c = n("./src/reddit/constants/colors.ts"),
				a = n("./src/reddit/constants/flair.ts"),
				d = n("./src/reddit/i18n/utils.ts"),
				u = n("./src/reddit/models/Flair/index.ts");
			const l = e => e === u.f.Text || e === u.f.Richtext || e === u.f.Image || e === u.f.Meta,
				b = e => e.e === u.c.Emoji ? Object(i.b)(e.a) : e.t,
				p = e => e.type === u.f.Richtext ? e.richtext.map(b).join("") : e.text || "",
				m = e => p(e).length,
				f = (e, t) => p(e) === p(t),
				g = e => !e.allowableContent || e.allowableContent === u.a.Emoji || e.allowableContent === u.a.All,
				O = e => !e.allowableContent || e.allowableContent === u.a.Text || e.allowableContent === u.a.All,
				h = e => !!e.find(e => e.e === u.c.Text),
				y = e => e.type === u.f.Richtext ? h(e.richtext) : !!e.text,
				j = e => e.type === u.f.Richtext ? e.richtext.reduce((e, t) => t.e === u.c.Emoji ? e + 1 : e, 0) : 0,
				_ = e => ({
					e: u.c.Text,
					t: e
				}),
				E = (e, t) => ({
					e: u.c.Emoji,
					a: e,
					u: t
				}),
				v = function(e) {
					let t, n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					return t = e.type === u.f.Richtext ? {
						backgroundColor: e.backgroundColor,
						cssClass: e.cssClass,
						richtext: e.richtext,
						templateId: e.id,
						textColor: e.textColor,
						type: e.type
					} : {
						backgroundColor: e.backgroundColor,
						cssClass: e.cssClass,
						templateId: e.id,
						text: e.text,
						textColor: e.textColor,
						type: e.type
					}, n && (t = C({
						flair: t,
						template: e
					})), t
				},
				I = () => {
					return {
						backgroundColor: c.a.defaultFlair,
						text: "",
						textColor: u.e.Dark,
						type: u.f.Text
					}
				},
				S = e => {
					let {
						maxEmojis: t
					} = e;
					if ("string" == typeof t) {
						const e = parseInt(t, 10);
						return Number.isInteger(e) ? e : a.d
					}
					return "number" == typeof t ? t : a.d
				},
				T = (e, t) => {
					if (t >= e.length) return e;
					let n = e,
						r = -1,
						s = 0,
						o = -1;
					for (let i = 0; i < e.length; i++)
						if (e[i].e === u.c.Emoji)
							if (++s === t) o = i;
							else if (s > t) {
						r = o + 1;
						break
					}
					if (r >= 0) {
						n = e.slice(0, r);
						let t = "";
						for (let n = r; n < e.length; n++) t += b(e[n]);
						n.push(_(t))
					}
					return n
				},
				x = (e, t) => {
					const n = e.type === u.f.Richtext ? e.richtext : [],
						r = p(e);
					return Object.assign({}, t, {
						type: e.type,
						richtext: n,
						text: r
					})
				},
				C = e => {
					const {
						flair: t,
						template: n,
						ignoreTextAllowance: r = !1
					} = e, s = !!r || O(n);
					let o = t;
					if (t.type === u.f.Richtext) {
						let e = t.richtext;
						e = g(n) ? T(e, S(n)) : T(e, 0), !s && h(e) && (e = e.filter(e => e.e !== u.c.Text)), e !== t.richtext && (o = Object.assign({}, t, {
							richtext: e
						}))
					} else t.text && !s && (o = Object.assign({}, t, {
						text: ""
					}));
					return o
				},
				w = () => !0,
				P = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : w;
					const {
						emojis: r,
						snoomojis: o
					} = t, c = e.type === u.f.Richtext ? e.richtext : [_(e.text)], a = [];
					return c.forEach(e => {
						if (e.e === u.c.Text) {
							e.t.split(/(:[-\w]+:)/).forEach(e => {
								if (!e) return;
								if (i.a.test(e)) {
									const t = e,
										s = t.slice(1, -1),
										i = r[s] || o[s];
									if (i && n(i)) {
										const e = E(t, i.url);
										return void a.push(e)
									}
								}
								const t = a[a.length - 1];
								t && t.e === u.c.Text ? t.t += e : a.push(_(e))
							})
						} else a.push(e)
					}), s()(a, c) ? e : Object.assign({}, e, {
						type: u.f.Richtext,
						richtext: a
					})
				},
				D = e => {
					const t = S(e),
						n = Object(d.a)("emojiCount", ["emoji", "emojis"], t);
					return e.allowableContent === u.a.Emoji ? Object(d.c)("Allows up to ".concat(Object(d.b)("emojiCount", t), " ").concat(n, " only")) : e.allowableContent === u.a.Text ? Object(d.c)("Allows text only") : Object(d.c)("Allows text and up to ".concat(Object(d.b)("emojiCount", t), " ").concat(n))
				},
				R = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
					const r = m(e),
						s = O(t),
						o = g(t);
					if (0 === r && !n.allowBlank) return s && o ? Object(d.c)("Error: text or emoji is required") : o ? Object(d.c)("Error: emoji is required") : Object(d.c)("Error: text is required");
					if (r > a.g && !n.allowOverflow) return Object(d.c)("Error: character limit exceeded");
					const i = S(t),
						c = j(e);
					return !s && y(e) ? Object(d.c)("Error: Only emojis allowed") : !o && c > 0 ? Object(d.c)("Error: Emojis aren't allowed") : c > i ? Object(d.c)("Error: Exceeds ".concat(Object(d.b)("maxEmojiCount", i), " emoji limit")) : void 0
				},
				A = e => 'flair_name:"'.concat(p(e), '"'),
				k = (e, t) => Object(o.a)(e, {
					f: t
				})
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var r = n("./node_modules/fbt/lib/FbtPublic.js"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/app/strings/index.ts");
			const i = Object(o.e)("error.type.generic");
			t.a = e => ({
				type: s.D.SERVER_ERROR,
				fields: [{
					field: "",
					msg: i(e)
				}]
			});
			const c = () => ({
				type: s.D.SERVER_ERROR,
				fields: [{
					field: "",
					msg: r.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getCommentsPageSort/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/extractQueryParams/index.ts"),
				o = n("./node_modules/lodash/fromPairs.js"),
				i = n.n(o),
				c = n("./src/reddit/constants/parameters.ts"),
				a = n("./src/reddit/selectors/experiments/chatPost.ts"),
				d = n("./src/reddit/selectors/user.ts");
			t.a = (e, t) => {
				const {
					user: n
				} = e, o = t && e.posts.models[t], u = o && o.suggestedSort ? o.suggestedSort : "", l = !!n && Object(d.A)(e);
				let b, p = r.r,
					m = !1;
				n && n.prefs && (b = n.prefs.defaultCommentSort), l ? p = b : u ? p = u : b && (p = b);
				const f = (e => {
						const t = e.platform.currentPage && e.platform.currentPage.url;
						return t && i()([...Object(s.a)(t)]) || new Set([])
					})(e),
					g = c.r in f ? f[c.r] : "";
				return (r.Sb.has(g) ? g : p) === g && (p = g), g && (m = !0), Object(a.d)(e, {
					postId: t
				}) && (p = r.q.CHAT, m = !1), {
					hasSortParam: m,
					sortToUse: p
				}
			}
		},
		"./src/reddit/helpers/getErrorMsgFromR2JQueryResponse.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const r = {
					INVALID_EMAIL: "You entered an invalid email. Please try again.",
					RATELIMITED: "You are doing that too much. Please try later.",
					WRONG_PASSWORD: "You entered an incorrect password. Please try again."
				},
				s = (e, t) => -1 !== e.indexOf(t);

			function o(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Something went wrong. Please try again.";
				const n = e && e.body && e.body.jquery && e.body.jquery[14] && e.body.jquery[14][3] && e.body.jquery[14][3][0];
				return "string" != typeof n ? t : s(n, "the following emails are invalid") ? r.INVALID_EMAIL : s(n, "wrong password") ? r.WRONG_PASSWORD : s(n, "you are doing that too much") ? r.RATELIMITED : t
			}
		},
		"./src/reddit/helpers/getGenericUploadError.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/lib/constants/index.ts");

			function s(e) {
				return {
					type: r.D.UNKNOWN_ERROR,
					fields: [{
						field: e,
						msg: "Image failed to upload"
					}]
				}
			}
		},
		"./src/reddit/helpers/getPostFromRouteMatch/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./src/reddit/models/Post/index.ts"),
				s = n("./src/lib/constants/index.ts");
			t.a = (e, t) => {
				if (!t) {
					const {
						currentPage: n
					} = e.platform;
					if (!n) return null;
					t = n.routeMatch
				}
				const {
					name: n
				} = t.route.meta;
				if (n === s.xb.COMMENTS || n === s.xb.DUPLICATES) {
					const {
						partialPostId: n
					} = t.match.params, s = Object(r.m)(n);
					return e.posts.models[s]
				}
				return null
			}
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/reddit/constants/postLayout.ts");

			function s(e) {
				return e ? r.c[e] : r.f
			}
		},
		"./src/reddit/helpers/getRichTextContent/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/env/index.ts"),
				s = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/helpers/isComment.ts"),
				i = n("./src/reddit/models/RichTextJson/index.ts"),
				c = (n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./src/reddit/models/RichTextJson/nodeMakers.ts"));
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			}));
			const a = {
				document: "[Unable to render content]".split("\n").map(e => Object(c.l)([Object(c.s)(e, null)]))
			};
			const d = (e, t) => {
					const n = Object(o.a)(t.id),
						i = "getRichTextContent: ".concat(e, " (in ").concat(n ? "comment" : "post", ")");
					s.c.withScope(e => {
						e.setExtra("info", {
							id: t.id,
							permalink: t.permalink,
							media: t.media
						}), e.setTag("rtjson", "getting_content"), s.c.captureMessage(i)
					}), Object(r.b)() || console.log("".concat(t.id, ": ").concat(i))
				},
				u = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					const r = void 0 === t ? a : t,
						s = e.media;
					if (!s) return n && d("Media object is missing", e), r;
					if ("rtjson" !== s.type) return n && d("Media object type is not rtjson", e), r;
					const o = s.richtextContent;
					return o ? Array.isArray(o.document) ? o : (n && d("Invalid richtextContent document", e), r) : (n && d("Missing richtextContent property", e), r)
				},
				l = e => !!u(e, null, !1),
				b = e => {
					const t = u(e, null, !1);
					if (!t) return;
					const n = t.document,
						r = [];
					return n.forEach(e => {
						if (e.e === i.u) {
							e.c.forEach(e => {
								e.e === i.A && r.push(e.t)
							})
						}
					}), 0 !== r.length ? r.join(" ") : void 0
				},
				p = e => {
					const t = u(e, null, !1);
					if (!t) return !1;
					const n = t.document,
						r = [];
					if (n.length > 0) {
						const e = n[0];
						if (e.e === i.u) {
							if (e.c.forEach(e => {
									e.e === i.A && r.push(e.t)
								}), r.length > 0 && r.join("").trim().length > 0) return !0
						}
					}
					return !1
				};
			t.a = u
		},
		"./src/reddit/helpers/getS3KeyFromUrl/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/url/url.js"),
				s = n.n(r);
			t.a = e => {
				const {
					pathname: t = ""
				} = s.a.parse(e);
				return t.startsWith("/") ? t.slice(1) : t
			}
		},
		"./src/reddit/helpers/getSubredditErrorProps/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/components/ContentGate/index.tsx");
			t.a = (e, t, n) => {
				let s, o, i, c, a, d;
				return e ? e.quarantinedSubreddit ? (o = r.a.QuarantinedSubreddit, c = e.quarantineMessage, a = e.quarantineMessageHtml, d = e.quarantineRequiresEmail) : e.privateSubreddit ? (o = r.a.PrivateSubreddit, i = e.subredditDescription) : e.goldSubreddit ? o = r.a.GoldSubreddit : e.subredditBanned ? (o = r.a.SubredditBanned, s = e.subredditBanMessage) : e.subredditDoesNotExist && (o = r.a.SubredditDoesNotExist) : t && (o = r.a.Nsfw), o && n ? {
					banMessage: s,
					contentGateType: o,
					subredditDescription: i,
					subredditName: n,
					quarantineMessage: c,
					quarantineMessageHtml: a,
					quarantineRequiresEmail: d
				} : void 0
			}
		},
		"./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./src/config.ts"),
				s = n("./src/reddit/models/StructuredStyles/index.ts");
			const o = {};
			t.a = e => e.subredditOrProfile ? {
				url: e.shouldHideNsfwIcon && e.subredditOrProfile.isNSFW ? "".concat(r.a.assetPath, "/img/avatar_over18.png") : e.subredditOrProfile.communityIcon || e.subredditOrProfile.icon.url,
				color: Object(s.i)(e.subredditOrProfile)
			} : o
		},
		"./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/isFakeSubreddit/index.ts");
			t.a = e => {
				const {
					sort: t,
					subredditName: n
				} = e, o = !n || Object(s.a)(n) ? r.O : void 0;
				return t || o
			}
		},
		"./src/reddit/helpers/getSubredditUrl/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/isFakeSubreddit/index.ts");
			t.a = e => e && !Object(r.a)(e.name) ? e.url : ""
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(s.a)(e) ? t || r.Pb : void 0
			}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function s(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : "Something wen't wrong. Please try again later."
			}
		},
		"./src/reddit/helpers/graphql/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return s
			})), n.d(t, "i", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "j", (function() {
				return a
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "e", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./src/reddit/models/Gold/Award.ts");
			const s = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					try {
						return JSON.parse(e)
					} catch (n) {
						return t
					}
				},
				o = e => {
					switch (e) {
						case "UP":
							return 1;
						case "DOWN":
							return -1;
						default:
							return 0
					}
				},
				i = e => e.reduce((e, t) => {
					let {
						award: n,
						total: s
					} = t;
					if (void 0 !== n.icon) {
						const t = Object(r.e)(n, s);
						e.push(t)
					}
					return e
				}, []);
			var c;
			! function(e) {
				e[e.Seconds = 3] = "Seconds", e[e.Millis = 0] = "Millis"
			}(c || (c = {}));
			const a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.Seconds;
					if (!e) return 0;
					let n = Date.parse(e);
					return Number.isNaN(n) && (n = Date.parse(e.replace("+0000", "Z"))), Number.isNaN(n) || n <= 0 ? 0 : n - n % Math.pow(10, t)
				},
				d = e => {
					const t = {},
						n = e.split("?")[1];
					if (!n) return t;
					const r = n.split("&");
					for (const s of r) {
						const [e, n] = s.split("=");
						t[e] = n
					}
					return t
				},
				u = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					if ("string" != typeof e || "string" != typeof t || e.split("?")[0] !== t.split("?")[0]) return !1;
					const r = ["auto", "crop", ...n],
						s = d(e),
						o = d(t),
						i = new Set([...Object.keys(s), ...Object.keys(o)]),
						c = [...i].filter(e => !r.includes(e));
					return c.every(e => {
						switch (e) {
							case "s":
								return s[e] && o[e];
							case "blur":
								const t = parseInt(s[e]),
									n = parseInt(o[e]);
								return !isNaN(t) && !isNaN(n) && Math.abs(t - n) <= 10;
							default:
								return s[e] === o[e]
						}
					})
				},
				l = (e, t) => e === t || u(e, t),
				b = () => !0,
				p = (e, t) => e && e.toUpperCase() === t,
				m = (e, t) => Math.abs(e - t) < Math.max(20, .1 * e),
				f = window.URL,
				g = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					try {
						const r = new f(e),
							s = new f(t);
						for (const e of n) r.searchParams.delete(e), s.searchParams.delete(e);
						return r.searchParams.sort(), s.searchParams.sort(), r.toString() === s.toString()
					} catch (r) {
						return !1
					}
				}
		},
		"./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/models/Subreddit/index.ts");
			const s = {
				[r.a.Image]: "images",
				[r.a.Link]: "links",
				[r.a.Spoiler]: "spoilers",
				[r.a.Text]: "text",
				[r.a.Video]: "videos",
				[r.a.Poll]: "polls"
			};
			t.a = e => {
				return Object.assign({}, {
					images: !1,
					links: !1,
					spoilers: !1,
					text: !1,
					videos: !1,
					polls: !1
				}, e.reduce((e, t) => (e[s[t]] = !0, e), {}))
			}
		},
		"./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			}));
			var r = n("./src/reddit/models/Flair/index.ts"),
				s = n("./src/reddit/helpers/graphql/helpers.ts");
			const o = e => {
					switch (e) {
						case r.h.Dark:
							return r.e.Dark;
						case r.h.Light:
							return r.e.Light
					}
				},
				i = (e, t, n, o, i) => {
					const c = [];
					return i === r.f.Richtext ? (c.push(Object.assign({
						type: i,
						richtext: Object(s.k)(o, []) || []
					}, e)), t && c.push(Object.assign({
						type: r.f.Text,
						text: t
					}, e))) : c.push(Object.assign({
						type: i,
						text: n
					}, e)), c
				},
				c = e => {
					const {
						text: t,
						richtext: n
					} = e, {
						id: r,
						textColor: s,
						type: c,
						text: a,
						backgroundColor: d,
						cssClass: u
					} = e.template, l = Object.assign({
						backgroundColor: d || "",
						cssClass: u
					}, r && {
						templateId: r
					}, s && {
						textColor: o(s)
					});
					return i(l, a || "", t, n, c)
				},
				a = e => {
					const {
						text: t,
						richtext: n,
						cssClass: r
					} = e, {
						id: s,
						textColor: c,
						type: a,
						text: d,
						backgroundColor: u,
						cssClass: l,
						richtext: b
					} = e.template, p = Object.assign({
						backgroundColor: u || "",
						cssClass: r || l
					}, s && {
						templateId: s
					}, c && {
						textColor: o(c)
					});
					return i(p, d || "", t || "", n || b, a)
				}
		},
		"./src/reddit/helpers/graphql/normalizeFrontpageFromGql/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/models/Post/index.ts"),
				s = n("./src/reddit/models/Live/index.ts"),
				o = (e, t) => t ? {
					announcementUrl: t.url,
					buttonCta: t.callToAction,
					description: t.description || "",
					icon: s.a[t.icon] && t.icon.toLowerCase(),
					id: t.id,
					isAnnouncement: !0,
					numTimesDismissable: t.maxDismissCount,
					title: t.title,
					viewerCount: 0
				} : e ? {
					announcementUrl: "",
					buttonCta: "",
					description: e.description || "",
					icon: "",
					id: e.id,
					isAnnouncement: !1,
					numTimesDismissable: 0,
					title: e.title,
					viewerCount: e.viewerCount
				} : null,
				i = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts");
			t.a = e => {
				let {
					trendingSubreddits: t = [],
					identity: n,
					home: s,
					featuredAnnouncement: b,
					featuredLiveEvent: p,
					recentPosts: m = []
				} = e;
				const f = [],
					g = [],
					O = {
						postIds: [],
						postInstances: {},
						posts: {},
						postFlair: {},
						profiles: {},
						subreddits: {}
					},
					h = e => {
						if (O.posts[e.id]) return e.id;
						const t = Object(c.d)(e);
						O.posts[t.id] = t;
						const {
							crosspostRoot: n
						} = e;
						n && n.type === r.a.Post && n.postInfo && h(n.postInfo);
						let s = t.id;
						switch (e.__typename) {
							case r.f.ProfilePost:
								O.profiles[e.profile.id] || (O.profiles[e.profile.id] = Object(d.a)(e.profile));
								break;
							case r.f.SubredditPost:
								O.subreddits[e.subreddit.id] || (O.subreddits[e.subreddit.id] = Object(u.a)(e.subreddit)), O.postFlair[e.subreddit.id] || (O.postFlair[e.subreddit.id] = Object(i.a)(e.subreddit));
								break;
							case r.f.AdPost:
								const n = Object(c.b)(e);
								if (!n) {
									s = null;
									break
								}
								s = n, O.posts[n] = Object.assign({}, t, {
									id: n,
									permalink: "".concat(t.permalink, "?instanceId=").concat(encodeURIComponent(n))
								}), O.posts[t.id] || (O.posts[t.id] = Object.assign({}, t, {
									events: []
								})), O.postInstances[e.id] || (O.postInstances[e.id] = []), O.postInstances[e.id].push(n)
						}
						return s
					};
				for (const r of t) {
					const e = Object(u.a)(r);
					O.subreddits[e.id] = e, f.push(e.id)
				}
				for (const {
						node: r
					} of s.posts.edges) {
					const e = h(r);
					e && O.postIds.push(e)
				}
				for (const r of m) {
					if (!r) continue;
					const e = h(r);
					e && g.push(e)
				}
				const y = O.postIds.length - 1,
					j = y >= 0 ? O.postIds[y] : "",
					_ = s.posts.dist;
				return Object.assign({}, O, {
					account: n && Object(l.a)(n) || null,
					featuredLiveThread: o(p, b) || {},
					preferences: n && n.preferences && Object(a.a)(n.preferences, n.interactions) || null
				}, 0 !== f.length && {
					trendingSubredditIds: f
				}, 0 !== g.length && {
					recentPostIds: g
				}, {
					token: j
				}, null !== _ && {
					dist: _
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeModeratorPartFromGql/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/helpers/graphql/helpers.ts");
			const s = (e, t) => !!e && (e.verdict === "MOD_".concat(t.toUpperCase()) || e.verdict === "ADMIN_".concat(t.toUpperCase())),
				o = e => e && e.length ? e.map(e => [e.reason || "", e.author && e.author.name || ""]) : null,
				i = e => e && e.length ? e.map(e => [e.reason || "", e.count || 0]) : null;
			t.a = e => {
				let {
					moderationInfo: t
				} = e;
				if (!t) return;
				const n = (e => e && e.verdictBy && e.verdictBy.name || null)(t),
					c = (e => e && Object(r.j)(e.verdictAt) || null)(t),
					a = s(t, "spammed"),
					d = s(t, "approved"),
					u = s(t, "removed"),
					{
						approvedBy: l = null,
						approvedAtUTC: b = null,
						bannedBy: p = null,
						bannedAtUTC: m = null
					} = d ? {
						approvedBy: n,
						approvedAtUTC: c
					} : {
						bannedBy: n,
						bannedAtUTC: c
					};
				return Object.assign({
					isSpam: a,
					isApproved: d,
					isRemoved: u,
					ignoreReports: t.isReportingIgnored,
					numReports: t.reportCount || null,
					modNote: t.modNote,
					approvedBy: l,
					approvedAtUTC: b,
					bannedBy: p,
					bannedAtUTC: m
				}, u && {
					modReasonBy: n
				}, {
					modReports: o(t.modReports) || [],
					userReports: i(t.userReports) || [],
					modReportsDismissed: o(t.dismissedModReports) || [],
					userReportsDismissed: i(t.dismissedUserReports) || []
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return f
			}));
			var r = n("./node_modules/lodash/forEach.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/merge.js"),
				i = n.n(o),
				c = n("./src/lib/env/index.ts"),
				a = n("./src/lib/sentry/index.ts"),
				d = n("./src/reddit/helpers/graphql/helpers.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				b = n("./src/reddit/models/GqlTopLevelField.ts"),
				p = n("./src/reddit/models/Multireddit/index.ts");

			function m(e) {
				const t = {
					multireddits: {},
					multiredditsByUser: {},
					subreddits: {},
					profiles: {}
				};
				if (!e) return t;
				const {
					path: n
				} = e, r = n.toLowerCase(), s = r.endsWith("/") ? r : r + "/", o = {
					created: 0,
					description: e.descriptionContent ? e.descriptionContent.markdown : "",
					descriptionHtml: null,
					descriptionRtJson: e.descriptionContent ? JSON.parse(e.descriptionContent.richtext) : null,
					displayText: e.displayName,
					followerCount: e.followerCount,
					name: e.name,
					icon: e.icon,
					isFavorited: e.isFavorited,
					isFollowed: e.isFollowed,
					isNSFW: e.isNsfw || !1,
					isQuarantined: e.isQuarantined || !1,
					subredditCount: e.subredditCount,
					ownerId: e.ownerInfo.id,
					url: s,
					visibility: e.visibility && e.visibility.toLowerCase() || p.e.Private
				};
				if (o.created = Object(d.j)(e.createdAt) / 1e3, e.sources) {
					o.subredditIds = [], o.profileIds = [];
					for (const {
							node: n
						} of e.sources.edges) {
						if (n.__typename === b.a.Subreddit) o.subredditIds.push(n.id), t.subreddits[n.id] = t.subreddits[n.id] || Object(l.a)(n);
						else if (n.__typename === b.a.Profile) o.profileIds.push(n.id), t.profiles[n.id] = t.profiles[n.id] || Object(u.a)(n);
						else {
							const e = 'Unexpected Multireddit.sources node with type "'.concat(n.__typename, '"');
							Object(c.b)() ? a.c.captureMessage(e) : console.error(e)
						}
						n.isNSFW && (o.isNSFW = !0), n.isQuarantined && (o.isQuarantined = !0)
					}
				}
				return t.multireddits[s] = o, t.multiredditsByUser[e.ownerInfo.id] = [s], t
			}

			function f(e) {
				const t = {},
					n = {},
					r = {},
					o = {},
					c = e.map(m);
				for (const a of c) s()(a.multiredditsByUser, (e, t) => {
					n[t] = [...n[t] || [], ...e]
				}), i()(t, a.multireddits), i()(r, a.profiles), i()(o, a.subreddits);
				return {
					multireddits: t,
					multiredditsByUser: n,
					profiles: r,
					subreddits: o
				}
			}
			t.a = m
		},
		"./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				s = n("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				o = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				i = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				u = n("./src/reddit/models/Post/index.ts");
			t.a = e => {
				const t = {
					account: null,
					dist: 0,
					features: null,
					multireddits: {},
					multiredditsByUser: {},
					pageInfo: null,
					postFlair: {},
					postIds: [],
					postInstances: {},
					posts: {},
					preferences: null,
					profiles: {},
					subreddits: {},
					token: void 0
				};
				if (!e) return t;
				const {
					identity: n,
					multireddit: l
				} = e;
				if (n && (t.account = Object(d.a)(n) || null, t.preferences = Object(c.a)(n.preferences, n.interactions) || null), !l) return t;
				const {
					posts: b
				} = l;
				if (b) {
					t.pageInfo = b.pageInfo;
					for (const {
							node: e
						} of b.edges) {
						const n = e;
						t.postIds.push(n.id);
						const {
							post: s,
							crosspost: c
						} = n && Object(i.a)(n);
						t.posts[s.id] = s, c && (t.posts[c.id] = c), n.__typename !== u.f.DeletedProfilePost && n.__typename !== u.f.DeletedSubredditPost && (n.authorFlair && (t.postFlair[s.belongsTo.id] || (t.postFlair[s.belongsTo.id] = {}), t.postFlair[s.belongsTo.id][s.author] = Object(r.a)(n.authorFlair)[0]), n.__typename === u.f.SubredditPost && (t.subreddits[n.subreddit.id] || (t.subreddits[n.subreddit.id] = Object(a.a)(n.subreddit)), t.postFlair[n.subreddit.id] || (t.postFlair[n.subreddit.id] = Object(o.a)(n.subreddit))))
					}
				} else t.pageInfo = {
					endCursor: null,
					hasNextPage: !1,
					hasPreviousPage: !1,
					startCursor: null
				};
				t.postIds.length && (t.dist = t.postIds.length), t.pageInfo.hasNextPage && (t.token = t.pageInfo.endCursor || "");
				const {
					multireddits: p,
					multiredditsByUser: m,
					profiles: f,
					subreddits: g
				} = Object(s.a)(l);
				return Object.assign({}, t, {
					multireddits: p,
					multiredditsByUser: m,
					profiles: Object.assign({}, t.profiles, f),
					subreddits: Object.assign({}, t.subreddits, g)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/models/Flair/index.ts");

			function s(e) {
				switch (e) {
					case r.g.LEFT:
						return r.b.Left;
					case r.g.RIGHT:
						return r.b.Right;
					default:
						return null
				}
			}

			function o(e) {
				let {
					isEnabled: t = !1,
					position: n
				} = e;
				return {
					isEnabled: t,
					position: s(n)
				}
			}
			t.a = e => {
				let {
					postFlairSettings: t
				} = e;
				return Object.assign({}, t && {
					displaySettings: t && o(t)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFromGql/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.match.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/constants/adEvents.ts"),
				i = n("./src/reddit/constants/thumbnails.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizeModeratorPartFromGql/index.ts");
			const d = /i\.redd\.it|v\.redd\.it|i\.reddituploads\.com/;
			var u = n("./src/reddit/models/Flair/index.ts"),
				l = n("./src/reddit/models/Media/index.ts");
			const b = e => {
				switch (e) {
					case "IMPRESSION":
						return o.a.Impression;
					case "CLICK":
						return o.a.Click;
					case "COMMENTS_VIEW":
						return o.a.CommentsView;
					case "UPVOTE":
						return o.a.Upvote;
					case "DOWNVOTE":
						return o.a.Downvote;
					case "COMMENT_SUBMITTED":
						return o.a.CommentSubmitted;
					case "VIEWABLE_IMPRESSION":
						return o.a.ViewableImpression;
					case "COMMENT_UPVOTE":
						return o.a.CommentUpvote;
					case "COMMENT_DOWNVOTE":
						return o.a.CommentDownvote;
					case "VIDEO_VIEWABLE_IMPRESSION":
						return o.a.VideoViewableImpression;
					case "VIDEO_FULLY_VIEWABLE_IMPRESSION":
						return o.a.VideoFullyViewableImpression;
					case "VIDEO_PLAYED_WITH_SOUND":
						return o.a.VideoPlayedWithSound;
					case "VIDEO_PLAYED_EXPANDED":
						return o.a.VideoPlayedExpanded;
					case "VIDEO_WATCHED_25":
						return o.a.VideoWatched25;
					case "VIDEO_WATCHED_50":
						return o.a.VideoWatched50;
					case "VIDEO_WATCHED_75":
						return o.a.VideoWatched75;
					case "VIDEO_WATCHED_95":
						return o.a.VideoWatched95;
					case "VIDEO_WATCHED_100":
						return o.a.VideoWatched100;
					case "VIDEO_STARTED":
						return o.a.VideoStarted;
					case "VIDEO_WATCHED_3_SECS":
						return o.a.VideoWatchedSeconds3;
					case "VIDEO_WATCHED_5_SECS":
						return o.a.VideoWatchedSeconds5;
					case "VIDEO_WATCHED_10_SECS":
						return o.a.VideoWatchedSeconds10
				}
			};
			var p = n("./src/reddit/models/Post/index.ts"),
				m = n("./src/reddit/models/PostCreationForm/index.ts"),
				f = n("./src/reddit/models/RichTextJson/index.ts"),
				g = n("./src/reddit/models/User/index.ts"),
				O = n("./src/reddit/helpers/graphql/helpers.ts");
			n.d(t, "c", (function() {
				return y
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "d", (function() {
				return B
			}));
			var h = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const y = e => e.__typename === p.f.DeletedProfilePost || e.__typename === p.f.DeletedSubredditPost,
				j = [p.e.Embed, p.e.Image, p.e.Video, p.e.Gifvideo],
				_ = e => {
					const t = e.thumbnail ? Object.assign({
						url: e.thumbnail.url
					}, e.thumbnail.dimensions) : {
						url: i.a.DEFAULT,
						width: null,
						height: null
					};
					return e.__typename === p.f.AdPost && e.authorOnlyInfo && t.url ? t : e.__typename !== p.f.SubredditPost || e.subreddit.isThumbnailsEnabled ? t : e.isSelfPost ? Object.assign({}, t, {
						url: i.a.SELF
					}) : e.media && e.media.typeHint && j.includes(e.media.typeHint) ? Object.assign({}, t, {
						url: i.a.IMAGE
					}) : Object.assign({}, t, {
						url: i.a.DEFAULT
					})
				},
				E = e => {
					switch (e.__typename) {
						case p.f.SubredditPost:
							return {
								id: e.subreddit.id, type: "subreddit"
							};
						default:
							return {
								id: e.profile.id, type: "profile"
							}
					}
				},
				v = e => {
					var {
						flair: t,
						isNsfw: n,
						isSpoiler: r
					} = e, s = h(e, ["flair", "isNsfw", "isSpoiler"]);
					const o = [];
					t && o.push(...Object(c.b)(t)), r && o.push({
						text: "spoiler",
						type: u.f.Spoiler
					}), n && o.push({
						text: "nsfw",
						type: u.f.Nsfw
					});
					let i = !1;
					return s.__typename === p.f.ProfilePost ? i = s.profile.isQuarantined : s.__typename === p.f.SubredditPost && (i = s.subreddit.isQuarantined), i && o.push({
						text: "quarantined",
						type: u.f.Quarantined
					}), o
				},
				I = e => e.map(e => {
					let {
						type: t,
						url: n
					} = e;
					return {
						url: n || "",
						type: b(t)
					}
				}),
				S = e => {
					var {
						domain: t,
						url: n
					} = e, r = h(e, ["domain", "url"]);
					if (r.__typename === p.f.AdPost || !r.isSelfPost && !(e => d.test(e))(t || "")) {
						const e = r.outboundLink && r.outboundLink.expiresAt && Object(O.j)(r.outboundLink.expiresAt);
						return Object.assign({
							displayText: t || "",
							url: n || ""
						}, r.outboundLink && {
							outboundUrl: r.outboundLink.url || void 0,
							outboundUrlCreated: e && e - 36e5 || void 0,
							outboundUrlExpiration: e || void 0
						})
					}
					return null
				},
				T = {
					small: 108,
					medium: 216,
					large: 320,
					xlarge: 640,
					xxlarge: 960,
					xxxlarge: 1080
				},
				x = (e, t) => {
					const n = e && (t ? e.animated : e.still);
					if (!n) return [];
					const r = e && e.still && e.still.source ? e.still.source.dimensions.width : 0;
					return Object.keys(T).reduce((e, s) => {
						const o = n[t ? "".concat(t, "_").concat(s) : s];
						if (!o || T[s] > r) return e;
						const i = Object.assign({
							url: o.url
						}, o.dimensions);
						return i ? [...e, i] : e
					}, [])
				},
				C = e => {
					const {
						media: t,
						isSelfPost: n
					} = e;
					if (n) return e.content && e.content.richtext ? l.n.RTJSON : l.n.TEXT;
					switch (t && t.typeHint) {
						case p.e.Image:
							return l.n.IMAGE;
						case p.e.Gifvideo:
							return l.n.GIFVIDEO;
						case p.e.Video:
							return l.n.VIDEO;
						case p.e.Embed:
							return l.n.EMBED;
						default:
							return null
					}
				},
				w = e => e.authorOnlyInfo && e.authorOnlyInfo.contentMode === p.d.Markdown ? m.h.MARKDOWN : m.h.RICH_TEXT,
				P = e => Math.min(e.height, e.width),
				D = (e, t) => {
					const {
						media: n,
						content: r
					} = e, s = (e => e.isSpoiler || e.isNsfw)(e) ? n && n.obfuscatedStill && n.obfuscatedStill.source && n.obfuscatedStill.source.url : null;
					switch (t) {
						case l.n.VIDEO: {
							const e = 400,
								r = x(n),
								o = n && n.still && n.still.source && Object.assign({
									url: n.still.source.url
								}, n.still.source.dimensions);
							let i;
							if (r.length) {
								i = r.reduce((e, t) => e.width > t.width ? e : t);
								const t = r.reduce((t, n) => P(n) > e && o && P(n) < P(o) ? [...t, n] : t, []);
								t.length && (i = t.reduce((e, t) => P(e) < P(t) ? e : t))
							} else i = o;
							return {
								type: t,
								obfuscated: s,
								hlsUrl: n && n.streaming && n.streaming.hlsUrl || "",
								dashUrl: n && n.streaming && n.streaming.dashUrl || "",
								isGif: !!n && !!n.streaming && n.streaming.isGif,
								scrubberThumbSource: n && n.streaming && n.streaming.scrubberMediaUrl || "",
								width: n && n.streaming ? n.streaming.dimensions.width : 0,
								height: n && n.streaming ? n.streaming.dimensions.height : 0,
								posterUrl: i && i.url || void 0
							}
						}
						case l.n.TEXT:
							return {
								type: t, obfuscated: null, markdownContent: e.content ? e.content.markdown : "", content: "", rteMode: w(e)
							};
						case l.n.RTJSON:
							return {
								type: t, obfuscated: null, markdownContent: e.content ? e.content.markdown : "", richtextContent: Object(O.k)(r.richtext, f.i), content: "", rteMode: w(e), mediaMetadata: F(e)
							};
						case l.n.IMAGE: {
							const r = n && n.animated && n.animated.gif_source ? "gif" : null;
							let o = "";
							return "i.redd.it" === e.domain && e.url ? o = e.url : n && n.still && n.still.source && (o = n.still.source.url), {
								type: t,
								obfuscated: s,
								resolutions: x(n, r),
								width: n && n.still && n.still.source ? n.still.source.dimensions.width : 0,
								height: n && n.still && n.still.source ? n.still.source.dimensions.height : 0,
								content: o
							}
						}
						case l.n.EMBED:
							return {
								type: t, obfuscated: s, width: n && n.video && n.video.dimensions && n.video.dimensions.width || 0, height: n && n.video && n.video.dimensions && n.video.dimensions.height || 0, provider: n && n.video && n.video.attribution && n.video.attribution.providerName || "", content: n && n.video && n.video.embedUrl ? n.video.embedUrl : ""
							};
						case l.n.GIFVIDEO:
							return {
								type: t, obfuscated: s, resolutions: x(n, "mp4"), width: n && n.still && n.still.source ? n.still.source.dimensions.width : 0, height: n && n.still && n.still.source ? n.still.source.dimensions.height : 0, gifBackgroundImage: n && n.still && n.still.source ? n.still.source.url : "", content: n && n.animated && n.animated.mp4_source ? n.animated.mp4_source.url : ""
							};
						default:
							return null
					}
				},
				R = {
					events: [],
					isBlank: !1,
					isSponsored: !1
				},
				A = /\.gif\?(.*$)/,
				k = e => {
					const t = e.adEvents.find(e => b(e.type) === o.a.Impression),
						n = t && t.url && t.url.match(A);
					return n && n[1] ? "t3_".concat(n[1]) : null
				},
				N = e => e ? e.toLowerCase() : null,
				L = e => {
					let {
						isLive: t,
						startsAt: n,
						endsAt: r
					} = e;
					return {
						eventIsLive: t,
						eventStart: Date.parse(n),
						eventEnd: Date.parse(r)
					}
				};
			t.a = e => {
				const t = {
						post: B(e)
					},
					{
						crosspostRoot: n
					} = e;
				return n && n.type === p.a.Post && n.postInfo && (t.crosspost = B(n.postInfo)), t
			};
			const M = e => e && e.__typename !== g.d.DeletedRedditor ? "name" in e && e.name || "" : r.z,
				U = e => !(!e || e.__typename !== g.d.AvailableRedditor) && !!e.isPremiumMember,
				F = e => e.content && e.content.richtextMedia && e.content.richtextMedia.length ? e.content.richtextMedia.reduce((e, t) => {
					switch (t.__typename) {
						case p.c.ImageAsset:
							"image/gif" === t.mimetype ? e[t.id] = {
								e: f.r,
								id: t.id,
								s: {
									gif: t.url,
									x: t.height,
									y: t.width
								}
							} : e[t.id] = {
								e: f.s,
								id: t.id,
								s: {
									u: t.url,
									x: t.height,
									y: t.width
								}
							};
							break;
						case p.c.VideoAsset:
							e[t.id] = {
								dashUrl: t.dashUrl,
								e: f.t,
								hlsUrl: t.hlsUrl,
								id: t.id,
								x: t.height,
								y: t.width
							}
					}
					return e
				}, {}) : null,
				B = e => {
					const {
						awardings: t,
						commentCount: n,
						createdAt: o,
						crosspostCount: i,
						crosspostRoot: c,
						discussionType: d,
						domain: u,
						id: l,
						isArchived: b,
						isContestMode: m,
						isFollowed: f,
						isGildable: g,
						isHidden: h,
						isLocked: y,
						isNsfw: j,
						isOriginalContent: T,
						isSaved: x,
						isSpoiler: w,
						isStickied: P,
						liveCommentsWebsocket: A,
						permalink: k,
						removedBy: F,
						removedByCategory: B,
						score: G,
						suggestedCommentSort: V,
						title: q,
						upvoteRatio: H,
						viewCount: K,
						voteState: W
					} = e, Y = B && "NONE" !== B ? B.toLowerCase() : null, z = c && (c.type === p.a.Post ? c.postInfo && c.postInfo.id : c.comment && c.comment.id);
					c && !z && s.c.withScope(e => {
						e.setExtra("postId", l), Object(s.a)(e, {
							serverLogging: !1
						}), s.c.captureMessage("Lack of post or comment in crosspostRoot")
					});
					const J = t ? Object(O.h)(t) : void 0,
						Q = Object.assign({
							allAwardings: J,
							author: r.z,
							authorId: "",
							approvedAtUTC: null,
							approvedBy: null,
							bannedAtUTC: null,
							bannedBy: null,
							belongsTo: {
								id: "",
								type: "subreddit"
							},
							contestMode: m,
							created: Object(O.j)(o),
							crosspostParentId: z,
							crosspostRootId: z,
							discussionType: d,
							distinguishType: null,
							domain: u || "",
							events: [],
							flair: v(e),
							hidden: h,
							id: l,
							ignoreReports: !1,
							isApproved: !1,
							isArchived: b,
							isAuthorPremium: !1,
							isBlank: !1,
							isCrosspostable: !1,
							isFollowed: f,
							isGildable: g,
							isLocked: y,
							isMediaOnly: !1,
							isMeta: !1,
							isNSFW: j,
							isOriginalContent: T,
							isPinned: !1,
							isRemoved: !1,
							isScoreHidden: null === G,
							isSpam: !1,
							isSpoiler: w,
							isSponsored: !1,
							isStickied: P,
							liveCommentsWebsocket: A,
							media: null,
							modReports: [],
							numComments: n || 0,
							numCrossposts: i || 0,
							numReports: null,
							permalink: "https://www.reddit.com".concat(k),
							postCategories: null,
							postId: l,
							previewComments: [],
							removedBy: F && F.name ? F.name : null,
							removedByCategory: Y,
							saved: x,
							score: null !== G && G > 0 ? G : 0,
							sendReplies: !1,
							source: S(e),
							suggestedSort: V && r.q[V] || null,
							thumbnail: {
								height: null,
								url: "",
								width: null
							},
							title: q || "",
							upvoteRatio: H,
							userReports: [],
							viewCount: K || 0,
							voteState: W ? Object(O.i)(W) : 0
						}, e.__typename === p.f.AdPost ? (e => {
							const {
								adEvents: t,
								callToAction: n,
								domain: r,
								isBlank: s
							} = e;
							return {
								callToAction: n,
								domainOverride: r,
								events: I(t),
								isBlank: s,
								isSponsored: !0
							}
						})(e) : R, Object(a.a)(e));
					if (e.__typename === p.f.DeletedProfilePost || e.__typename === p.f.DeletedSubredditPost) return Q;
					const {
						authorInfo: X,
						authorOnlyInfo: Z,
						distinguishedAs: $,
						isCrosspostable: ee,
						isMediaOnly: te,
						isPollIncluded: ne,
						media: re,
						postEventInfo: se
					} = e, oe = (e => e && e.still && e.still.source ? Object.assign({
						url: e.still.source.url
					}, e.still.source.dimensions) : void 0)(re);
					return Object.assign({}, Q, {
						author: X && M(X) || r.z,
						authorId: X && X.id || "",
						belongsTo: E(e),
						distinguishType: N($),
						isCrosspostable: ee,
						isMediaOnly: te,
						isMeta: ne,
						isAuthorPremium: U(X),
						media: D(e, C(e)),
						thumbnail: _(e)
					}, oe && {
						preview: oe
					}, Z && {
						sendReplies: Z.isReceivingPostReplies
					}, se && {
						eventInfo: L(se)
					})
				}
		},
		"./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/models/User/index.ts");
			t.a = (e, t) => ({
				allowClickTracking: e.isClickTrackingEnabled,
				autoplayVideo: !e.isVideoAutoplayDisabled,
				defaultCommentSort: e.defaultCommentSort && s.c[e.defaultCommentSort] ? r.q[e.defaultCommentSort] : r.q.CONFIDENCE,
				geopopular: e.geopopular,
				hideNSFW: e.isNsfwMediaBlocked,
				ignoreSuggestedSort: e.isSuggestedSortIgnored,
				labelNSFW: e.isNsfwLabelShown,
				markMessagesRead: e.isMessageAutoReadEnabled,
				nightmode: e.isNightModeEnabled,
				over18: e.isNsfwContentShown,
				account: {
					openPostInNewTab: e.isNewTabOpenedForPostView,
					rpanDuDismissalTime: e.rpanDuDismissedAt,
					sort: e.globalCommunityPostFeedSort.range ? "".concat(e.globalCommunityPostFeedSort.sort.toLowerCase(), "_").concat(e.globalCommunityPostFeedSort.range.toLowerCase()) : e.globalCommunityPostFeedSort.sort.toLowerCase(),
					showRpanDu: e.isRpanDuShown,
					stylesEnabled: e.isCommunityStylingEnabled,
					rememberCommunitySort: e.isCommunityPostFeedSortingPreserved,
					useMarkdown: e.isMarkdownDefaultEditorMode,
					rememberCommunityLayout: e.isCommunityLayoutPreserved,
					layout: e.postFeedLayout.toLowerCase(),
					hasSeenCustomizeFlyout: t && t.isDefaultPostLayoutAware
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var r = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				s = n("./src/reddit/models/Subreddit/index.ts"),
				o = n("./src/reddit/models/User/index.ts"),
				i = n("./src/reddit/models/WhitelistStatus/index.ts");
			const c = e => {
				let {
					pageInfo: t,
					edges: n
				} = e;
				const s = {
					moderatedSubredditIds: [],
					pageInfo: t,
					subreddits: {}
				};
				for (const {
						node: o
					} of n) {
					const e = Object(r.a)(o);
					s.subreddits[e.id] = e, s.moderatedSubredditIds.push(e.id)
				}
				return s
			};
			t.a = e => {
				let {
					name: t,
					path: n,
					redditorInfo: r,
					styles: c,
					wls: a,
					id: d,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				} = e;
				const {
					height: m,
					icon: f,
					width: g
				} = c && c.legacyIcon && {
					height: c.legacyIcon.dimensions.height,
					icon: c.legacyIcon.url,
					width: c.legacyIcon.dimensions.width
				} || {
					height: null,
					icon: c && c.icon || "",
					width: null
				}, O = c && c.legacyPrimaryColor, h = r && r.__typename === o.d.AvailableRedditor && r.prefixedName || "";
				return Object.assign({
					url: n,
					displayText: h,
					icon: {
						url: f,
						width: g,
						height: m
					},
					communityIcon: f,
					type: s.c.User,
					name: t.substr(2)
				}, O && {
					primaryColor: O
				}, a && {
					whitelistStatus: a.toLowerCase(),
					wls: i.a[a]
				}, {
					id: d,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var r = n("./src/reddit/helpers/graphql/helpers.ts"),
				s = n("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts");
			const o = e => {
					const t = Object(s.a)(e.allowedPostTypes),
						n = e.moderation ? e.moderation.coins : void 0;
					return {
						[e.id]: {
							accountsActive: e.activeCount,
							activity7Day: e.activity7Day,
							allOriginalContent: !1,
							allowedPostTypes: t,
							allowChatPostCreation: e.isChatPostCreationAllowed,
							coins: n,
							created: Object(r.j)(e.createdAt),
							disableContributorRequests: !1,
							emojisEnabled: !0,
							isChatPostFeatureEnabled: e.isChatPostFeatureEnabled,
							isCrosspostableSubreddit: e.isCrosspostDestination,
							originalContentTagEnabled: !0,
							publicDescription: e.publicDescription.markdown,
							restrictCommenting: !1,
							restrictPosting: !0,
							showMedia: !0,
							subscribers: e.subscribersCount,
							userIsBanned: e.isUserBanned,
							userIsContributor: e.isContributor,
							userIsSubscriber: e.isSubscribed,
							usingNewModmail: !0
						}
					}
				},
				i = e => e.reduce((e, t) => Object.assign({}, e, o(t)), {});
			t.a = o
		},
		"./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				o = n("./src/reddit/models/GqlTopLevelField.ts"),
				i = n("./src/reddit/models/WhitelistStatus/index.ts");
			const c = e => e.subredditRecommendations.recommendations.map(u).reduce((e, t) => (e[t.id] = t, e), {}),
				a = e => {
					const t = {
							posts: {},
							subredditTopContent: {}
						},
						n = [],
						{
							__typename: i
						} = e;
					if (i !== o.a.Subreddit) return null;
					const {
						id: c,
						isSubscribed: a,
						name: d,
						topContent: u
					} = e, {
						posts: l,
						range: b
					} = u;
					return l.forEach(e => {
						const {
							post: r,
							crosspost: o
						} = Object(s.a)(e), i = r.id;
						if (t.posts[i] = r, n.push(i), o) {
							const e = o.id;
							t.posts[e] = o
						}
					}), t.subredditTopContent[d.toLowerCase()] = {
						id: c,
						isSubscribed: a,
						name: d,
						postIds: n,
						range: r.Ob[b]
					}, t
				},
				d = e => e.reduce((e, t) => {
					const n = a(t);
					if (!n) return e;
					const r = e || {
						posts: {},
						subredditTopContent: {}
					};
					return {
						posts: Object.assign({}, r.posts, n.posts),
						subredditTopContent: Object.assign({}, r.subredditTopContent, n.subredditTopContent)
					}
				}, null),
				u = e => {
					const {
						path: t,
						prefixedName: n,
						type: r,
						styles: s,
						wls: o,
						id: c,
						isQuarantined: a,
						isNSFW: d,
						name: u,
						subscribers: l,
						title: b,
						isFreeFormReportingAllowed: p
					} = e, {
						height: m,
						icon: f,
						width: g
					} = s && s.legacyIcon && {
						height: s.legacyIcon.dimensions.height,
						icon: s.legacyIcon.url,
						width: s.legacyIcon.dimensions.width
					} || {
						height: null,
						icon: s && s.icon || "",
						width: null
					}, O = s && s.primaryColor, h = s && s.icon;
					return Object.assign({
						url: t,
						displayText: n,
						icon: {
							url: f,
							width: g,
							height: m
						}
					}, h && {
						communityIcon: h
					}, {
						type: r.toLowerCase(),
						primaryColor: O || ""
					}, o && {
						whitelistStatus: o.toLowerCase(),
						wls: i.a[o]
					}, {
						freeFormReports: p,
						id: c,
						isQuarantined: a,
						isNSFW: d,
						name: u,
						subscribers: l,
						title: b
					})
				},
				l = e => e.reduce((e, t) => {
					const n = u(t);
					return e[n.id] = n, e
				}, {}),
				b = e => e;
			t.a = u
		},
		"./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			t.a = e => {
				const t = {
					menuPosition: e.menuPosition ? e.menuPosition.toLowerCase() : void 0,
					bannerCommunityNameFormat: e.bannerCommunityNameFormat ? e.bannerCommunityNameFormat.toLowerCase() : void 0,
					bannerShowCommunityIcon: e.bannerShowCommunityIcon ? e.bannerShowCommunityIcon.toLowerCase() : void 0,
					bannerHeight: e.bannerHeight ? e.bannerHeight.toLowerCase() : void 0,
					postVoteIcons: e.postVoteIcons ? e.postVoteIcons.toLowerCase() : void 0,
					submenuBackgroundStyle: e.submenuBackgroundStyle ? e.submenuBackgroundStyle.toLowerCase() : void 0,
					backgroundImagePosition: e.backgroundImagePosition ? e.backgroundImagePosition.toLowerCase() : void 0,
					bannerBackgroundImagePosition: e.bannerBackgroundImagePosition ? e.bannerBackgroundImagePosition.toLowerCase() : void 0,
					bannerPositionedImagePosition: e.bannerPositionedImagePosition ? e.bannerPositionedImagePosition.toLowerCase() : void 0,
					postBackgroundImagePosition: e.postBackgroundImagePosition ? e.postBackgroundImagePosition.toLowerCase() : void 0,
					postPlaceholderImagePosition: e.postPlaceholderImagePosition ? e.postPlaceholderImagePosition.toLowerCase() : void 0,
					menuBackgroundOpacity: e.menuBackgroundOpacity || void 0,
					backgroundImage: e.backgroundImage || void 0,
					bannerBackgroundImage: e.bannerBackgroundImage || void 0,
					bannerPositionedImage: e.bannerPositionedImage || void 0,
					communityIcon: e.icon || void 0,
					menuBackgroundImage: e.menuBackgroundImage || void 0,
					postBackgroundImage: e.postBackgroundImage || void 0,
					postDownvoteIconActive: e.postDownvoteIconActive || void 0,
					postDownvoteIconInactive: e.postDownvoteIconInactive || void 0,
					postPlaceholderImage: e.postPlaceholderImage || void 0,
					postUpvoteIconActive: e.postUpvoteIconActive || void 0,
					postUpvoteIconInactive: e.postUpvoteIconInactive || void 0,
					bannerBackgroundColor: e.bannerBackgroundColor || void 0,
					bannerOverlayColor: e.bannerOverlayColor || void 0,
					menuBackgroundColor: e.menuBackgroundColor || void 0,
					menuLinkColorActive: e.menuLinkColorActive || void 0,
					menuLinkColorInactive: e.menuLinkColorInactive || void 0,
					menuLinkColorHover: e.menuLinkColorHover || void 0,
					submenuBackgroundColor: e.submenuBackgroundColor || void 0,
					primaryColor: e.primaryColor || void 0,
					highlightColor: e.highlightColor || void 0,
					postTitleColor: e.postTitleColor || void 0,
					backgroundColor: e.backgroundColor || void 0,
					postBackgroundColor: e.postBackgroundColor || void 0,
					postDownvoteCountColor: e.postDownvoteCountColor || void 0,
					postUpvoteCountColor: e.postUpvoteCountColor || void 0,
					mobileKeyColor: e.mobileKeyColor || void 0,
					mobileBannerImage: e.mobileBannerImage || void 0,
					sidebarWidgetHeaderColor: e.sidebarWidgetHeaderColor || void 0,
					sidebarWidgetBackgroundColor: e.sidebarWidgetBackgroundColor || void 0,
					secondaryBannerPositionedImage: e.secondaryBannerPositionedImage || void 0
				};
				return Object.keys(t).forEach(e => {
					void 0 === t[e] && delete t[e]
				}), t
			}
		},
		"./src/reddit/helpers/graphql/normalizeTopSubredditsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/lodash/isEmpty.js"),
				s = n.n(r),
				o = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				i = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const c = e => {
					let {
						edges: t,
						pageInfo: n
					} = e;
					const r = {},
						s = [];
					for (let c of t) {
						const {
							node: e
						} = c, t = i(c, ["node"]), n = Object(o.a)(e);
						r[n.id] = n, s.push(t)
					}
					return {
						pageInfo: n,
						rankings: s,
						subreddits: r
					}
				},
				a = e => {
					let {
						edges: t
					} = e;
					const n = {},
						r = [];
					for (let s of t) {
						const {
							node: e
						} = s, t = i(s, ["node"]), c = Object(o.a)(e);
						n[c.id] = Object.assign({}, c, {
							bannerBackgroundImage: e && e.styles && e.styles.bannerBackgroundImage
						}), r.push(t)
					}
					return {
						rankings: r,
						subreddits: n
					}
				},
				d = e => {
					const t = {},
						n = [];
					for (let r = 0; r < e.length; r++) {
						const i = e[r];
						if (s()(i)) continue;
						const c = Object(o.a)(i);
						t[c.id] = c, n.push({
							id: c.id,
							rank: r,
							rankDelta: 0,
							cursor: ""
						})
					}
					return {
						rankings: n,
						subreddits: t
					}
				}
		},
		"./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/reddit/models/User/index.ts"),
				s = n("./src/reddit/helpers/graphql/helpers.ts"),
				o = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const i = e => e && e.expiresAt && Object(s.j)(e.expiresAt, s.a.Seconds) / 1e3 || null,
				c = e => e && e.unreadCount ? e.unreadCount : 0,
				a = /^u\//,
				d = e => e.replace(a, "/user/"),
				u = e => e.__typename === r.d.DeletedRedditor ? null : "name" in e && e.name || null;
			t.a = e => {
				var {
					redditor: t,
					inbox: n,
					premium: a,
					preferences: u,
					coins: l
				} = e, b = o(e, ["redditor", "inbox", "premium", "preferences", "coins"]);
				let p = {
					commentKarma: 0,
					hasUserProfile: !1,
					id: t.id,
					isGold: !1,
					postKarma: 0,
					url: ""
				};
				if (t.__typename === r.d.AvailableRedditor) {
					const {
						karma: e,
						profile: n
					} = t, r = n && n.styles && n.styles.legacyIcon && n.styles.legacyIcon.url;
					p = Object.assign({}, p, r && {
						accountIcon: r
					}, {
						commentKarma: e ? e.fromComments : 0,
						displayText: t.name,
						hasExternalAccount: t.isLinkedToExternalAccount,
						hasUserProfile: !!n,
						isGold: !!t.isGilded,
						postKarma: e ? e.fromPosts : 0,
						profileId: n && n.id || void 0,
						url: t.prefixedName && d(t.prefixedName) || void 0
					})
				}
				const {
					interactions: m,
					modMail: f
				} = b;
				return Object.assign({}, p, {
					coins: l,
					created: Object(s.j)(b.createdAt, s.a.Seconds) / 1e3,
					goldExpiration: i(a),
					hasUnreadMail: c(n) > 0,
					hasUnreadModmail: !!f && f.isUnread,
					hasUnreadOldModmail: !!f && f.isUnread,
					hasVerifiedEmail: !!b.isEmailVerified,
					inboxCount: c(n),
					inRedesignBeta: u.isInRedesignBeta,
					isEmployee: !!b.isEmployee,
					isFPR: !!b.isForcePasswordReset,
					isMod: !!b.isModerator,
					isSuspended: b.isSuspended,
					nightmode: u.isNightModeEnabled,
					seenLayoutSwitch: !!m && m.isLayoutSwitchAware,
					seenGiveAwardTooltip: !!m && m.isGiveAwardTooltipAware,
					seenPremiumAdblockModal: !!m && m.isAdblockModalAware,
					seenRedesignModal: !!m && m.isRedesignModalAware,
					seenSubredditChatFtux: !!m && m.isSubredditChatAware,
					showRecentPosts: u.isRecentPostsShown,
					showTrending: u.isTrendingSubredditsShown
				}, a && a.subscription && {
					hasAndroidSubscription: a.subscription.isAndroidAvailable,
					hasGoldSubscription: a.subscription.isGoldAvailable,
					hasIOSSubscription: a.subscription.isIOSAvailable,
					hasPaypalSubscription: a.subscription.isPaypalAvailable,
					hasStripeSubscription: a.subscription.isStripeAvailable
				})
			}
		},
		"./src/reddit/helpers/history/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			}));
			var r = n("./node_modules/lodash/omit.js"),
				s = n.n(r);
			const o = (e, t) => {
					const n = history.state ? history.state.state : {},
						r = Object.assign({}, history.state, {
							state: Object.assign({}, n, {
								[e]: t
							})
						});
					history.replaceState(r, window.document.title)
				},
				i = e => {
					const t = Object.assign({}, history.state, {
						state: Object.assign({}, s()(history.state.state, e))
					});
					history.replaceState(t, window.document.title)
				},
				c = e => history && history.state && history.state.state && history.state.state[e]
		},
		"./src/reddit/helpers/isComment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/reddit/constants/things.ts");

			function s(e) {
				if (!e) return !1;
				return e.substring(0, 3) === r.a
			}
			const o = e => s(e.id);
			t.a = s
		},
		"./src/reddit/helpers/isPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/reddit/constants/things.ts");

			function s(e) {
				if (!e) return !1;
				return e.substring(0, 3) === r.b
			}
			const o = e => s(e.id);
			t.a = s
		},
		"./src/reddit/helpers/makeProfileListingKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeListingKey/index.ts");
			const o = (e, t) => "".concat(r.Qb).concat(e.toLowerCase(), "--private--").concat(t);
			t.a = function(e, t, n) {
				let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
				const i = "".concat(r.Qb).concat(e, "--").concat(t);
				return Object(s.a)(i, n, o)
			}
		},
		"./src/reddit/helpers/media/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "j", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/models/Media/index.ts");

			function o(e) {
				return new Promise((t, n) => {
					try {
						const r = new FileReader;
						r.onloadend = e => {
							try {
								const n = e.target.result,
									r = new Uint8Array(n).subarray(0, 4);
								let s = "";
								for (let e = 0; e < r.length; e++) s += r[e].toString(16);
								const o = function(e) {
									switch (e) {
										case "89504e47":
											return "image/png";
										case "47494638":
											return "image/gif";
										default:
											return "ffd8ff" === e.slice(0, 6) ? "image/jpeg" : null
									}
								}(s);
								t(o)
							} catch (r) {
								n(r)
							}
						}, r.readAsArrayBuffer(e)
					} catch (r) {
						n(r)
					}
				})
			}
			const i = e => e.startsWith("video/"),
				c = e => e.startsWith("image/"),
				a = e => "image/gif" === e,
				d = e => {
					if (e) return i(e) ? "video" : c(e) ? "image" : void 0
				},
				u = e => r.a.has(e) || r.b.has(e),
				l = e => window.URL && window.URL.createObjectURL ? window.URL.createObjectURL(e) : null;

			function b(e, t) {
				try {
					return new File([e], t, {
						type: e.type,
						lastModified: Date.now()
					})
				} catch (n) {
					const r = new Blob([e], {
						type: e.type
					});
					return Object.assign(r, {
						name: t,
						lastModified: Date.now()
					}), r
				}
			}

			function p(e) {
				const t = atob(e.split(",")[1]),
					n = e.split(",")[0].split(":")[1].split(";")[0],
					r = new Uint8Array(t.length);
				for (let s = 0; s < t.length; s++) r[s] = t.charCodeAt(s);
				return new Blob([r], {
					type: n
				})
			}
			const m = (e, t, n) => {
					e.addEventListener(t, r => (e.removeEventListener(t, n), n(r)))
				},
				f = (e, t) => new Promise((n, r) => {
					const s = () => {
						e.readyState >= 2 && n(e)
					};
					m(e, "error", () => {
						r(new Error("Invalid video source"))
					}), ["loadedmetadata", "loadeddata", "suspend"].forEach(t => m(e, t, s)), e.src = t, s()
				}),
				g = (e, t) => new Promise(n => {
					m(e, "seeked", () => n(e)), e.currentTime = t
				});
			async function O(e, t, n) {
				let r = e.currentTime;
				for (; null !== r;) {
					await g(e, r), t.height = e.videoHeight, t.width = e.videoWidth;
					const s = t.getContext("2d");
					s && s.drawImage(e, 0, 0), r = n({
						dataUrl: t.toDataURL(),
						time: e.currentTime
					})
				}
			}
			async function h(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				const n = document.createElement("video");
				let r;
				if (await f(n, e), t) {
					n.currentTime = 0;
					const e = document.createElement("canvas");
					await O(n, e, e => (r = e, null))
				}
				return {
					width: n.videoWidth,
					height: n.videoHeight,
					duration: n.duration,
					firstFrame: r
				}
			}
			const y = (e, t, n) => {
					if ("fastly" === e) {
						let e;
						return (e = t.startsWith("US-") || "North-America" === t ? "NA" : t.startsWith("EU-") ? "EU" : t.startsWith("Asia-") || "Asia" === t ? "AS" : "APAC" === t ? "OC" : t.startsWith("SA-") ? "SA" : "South-Africa" === t ? "AF" : "UNKNOWN") + "-" + n
					}
				},
				j = (e, t, n) => {
					if (e.media && (e.media.type === s.n.IMAGE || e.media.type === s.n.GIFVIDEO)) {
						const r = e.media.resolutions;
						for (let e = 0; e < r.length; e++) {
							const s = r[e];
							if (s.width >= t || s.height >= n) return s
						}
					}
					if (e.thumbnail && !e.isNSFW && !e.isSpoiler) {
						const r = e.thumbnail,
							s = r && r.width || 0,
							o = r && r.height || 0;
						if (s >= t || o >= n) return e.thumbnail
					}
					return null
				}
		},
		"./src/reddit/helpers/monthsToMinutes/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var r = n("./node_modules/js-cookie/src/js.cookie.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/reddit/constants/cookie.ts"),
				c = n("./src/reddit/constants/localStorage.ts"),
				a = n("./src/reddit/selectors/monthsToMinutes.ts");
			const d = () => s.a.get(i.d),
				u = e => {
					const t = (e => e.join(","))(Object(a.h)(e)),
						n = new Date;
					n.setFullYear(n.getFullYear() + 2), s.a.set(i.d, t, {
						expires: n,
						domain: o.a.cookieDomain
					})
				},
				l = () => {
					s.a.remove(i.d, {
						domain: o.a.cookieDomain
					})
				},
				b = () => {
					localStorage.removeItem(c.u), l()
				}
		},
		"./src/reddit/helpers/name/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/lodash/capitalize.js");
			const r = /^(r|u)?\//i,
				s = /^r\//i,
				o = /^u\//i,
				i = e => e.replace(r, ""),
				c = e => i(e.toLowerCase().trim()),
				a = e => "r/".concat(i(e)),
				d = e => "u/".concat(i(e)),
				u = e => r.test(e),
				l = e => s.test(e),
				b = e => o.test(e),
				p = (e, t) => !((e, t) => u(e) && u(t) && e[0].toLowerCase() !== t[0].toLowerCase())(e, t) && c(e) === c(t)
		},
		"./src/reddit/helpers/normalizeUsername/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = e => {
				const t = /^((\/u\/)|(u\/))/;
				return /^((\/u\/)|(u\/))(.+)/.test(e) ? e.replace(t, "") : e
			}
		},
		"./src/reddit/helpers/onBeforeRequestFactory/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/url/url.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/lib/addQueryParams/index.ts"),
				c = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.constructor.js"), n("./src/reddit/selectors/subreddit.ts"));
			const a = new RegExp("^/desktopapi/v1/(duplicates/[^/]+|frontpage|news|search|subreddits/(all|popular))(/|$)"),
				d = new RegExp("^/desktopapi/v1/(search|subreddits|postcomments|collection_postcomments|submitpage)(/|$)"),
				u = new RegExp("^/desktopapi/v1/(subreddits|postcomments|collection_postcomments)/?$"),
				l = (new RegExp("^/desktopapi/v1/(postcomments)(/+|$)"), new RegExp("^/desktopapi/v1/frontpage/?$")),
				b = new RegExp("^/desktopapi/v1/submitpage(/|$)");
			var p = (e, t, n) => {
					const r = new Set;
					e.user.session && !e.user.session.unsafeLoggedOut && (e.user.account || (r.add("identity"), r.add("prefs"), r.add("prefsAccount")), (e => !a.test(e.pathname || ""))(t) && r.add("identity")), !e.live.isFrontpageLoaded && (e => l.test(e.pathname || ""))(t) && r.add("featuredLiveThread");
					const s = t.pathname || "";
					if (d.test(s) || u.test(s)) {
						const s = ((e, t) => {
								if (b.test(e.pathname || "")) {
									const {
										subreddit: e
									} = t.data;
									return e
								}
							})(t, n),
							o = e.platform.currentPage,
							i = o && o.urlParams.subredditName,
							a = s || i || "",
							d = Object(c.G)(e, a);
						d && e.structuredStyles.models[d] || r.add("structuredStyles"), e.user.prefs.subreddit[d] || r.add("prefsSubreddit")
					}
					return [...r].join(",")
				},
				m = n("./src/reddit/selectors/user.ts");
			t.a = e => t => {
				const n = s.a.parse(t.endpoint, !0),
					{
						host: r,
						protocol: c
					} = n;
				if ("".concat(c, "//").concat(r) === o.a.gatewayUrl) {
					const r = {},
						s = Object(m.Y)(e.getState()) ? "1" : "";
					r.allow_over18 = s, r.include = p(e.getState(), n, t), t.endpoint = Object(i.a)(t.endpoint, r)
				}
			}
		},
		"./src/reddit/helpers/overlay/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			}));
			var r = n("./node_modules/history/esm/history.js"),
				s = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/reddit/helpers/path/index.ts");
			const i = e => {
					if ("string" == typeof e) return Object(r.c)(Object(o.b)(e), {
						isOverlay: !0
					}); {
						const t = Object(r.c)(e);
						return t.state = Object.assign({}, t.state || {}, {
							isOverlay: !0
						}), t
					}
				},
				c = e => Object(s.b)(i(e))
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/history/esm/history.js"), n("./src/reddit/actions/platform.ts");
			var r = n("./src/config.ts");
			t.a = (e, t) => {
				const n = t.platform.currentPage && t.platform.currentPage.url;
				let s = "".concat(r.a.accountManagerOrigin, "/login/");
				const o = window.location.origin;
				n && (s += "?dest=".concat(encodeURIComponent("".concat(o).concat(n)))), window.location.href = s
			}
		},
		"./src/reddit/helpers/path/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./node_modules/path-browserify/index.js"),
				s = n.n(r);
			const o = (e, t) => s.a.join(s.a.sep, e || "", t),
				i = e => e.replace(/^.*\/\/[^\/]+/, "")
		},
		"./src/reddit/helpers/pixels.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var r = n("./src/lib/LRUCache/index.ts"),
				s = n("./src/lib/sentry/index.ts");
			const o = new r.a(1e3),
				i = e => {
					let {
						url: t,
						type: n
					} = e;
					if (!t) return s.c.captureMessage("Pixel of type ".concat(n, " has no url")), !1;
					if (!o.get(t)) {
						return (new Image).src = t, o.set(t, !0), !0
					}
					return !1
				},
				c = (e, t) => e.filter(e => e.type === t).every(i)
		},
		"./src/reddit/helpers/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = e => !!e.collectionIds && e.collectionIds.length >= 1
		},
		"./src/reddit/helpers/postEvent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = e => e && !!e.eventInfo
		},
		"./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			}));
			var r = n("./src/reddit/models/Gold/Award.ts");
			t.a = e => e.map(e => ({
				awardType: e.award_type,
				awardSubType: e.award_sub_type ? e.award_sub_type : r.a.Global,
				coinPrice: e.coin_price,
				coinReward: e.coin_reward,
				count: e.count,
				daysOfDripExtension: e.days_of_drip_extension,
				daysOfPremium: e.days_of_premium,
				description: e.description,
				iconUrl: e.icon_url,
				resizedIcons: e.resized_icons,
				id: e.id,
				isEnabled: e.is_enabled,
				isNew: !!e.is_new,
				name: e.name,
				subredditCoinReward: e.subreddit_coin_reward
			}));
			const s = e => {
					const {
						icon_url: t,
						resized_icons: n
					} = e;
					let s, o, i;
					for (const {
							url: r,
							width: c
						} of n || []) 32 === c && (s = {
						url: r
					}), 64 === c && (o = {
						url: r
					}), 128 === c && (i = {
						url: r
					});
					return {
						awardType: e.award_type.toUpperCase(),
						awardSubType: e.award_sub_type ? e.award_sub_type.toUpperCase() : r.b.Global,
						coinPrice: e.coin_price,
						coinReward: e.coin_reward,
						daysOfDripExtension: e.days_of_drip_extension,
						daysOfPremium: e.days_of_premium,
						description: e.description,
						id: e.id,
						isEnabled: e.is_enabled,
						isNew: !!e.is_new,
						name: e.name,
						icon: {
							url: t
						},
						icon32: s,
						icon64: o,
						icon128: i,
						subredditCoinReward: e.subreddit_coin_reward
					}
				},
				o = e => {
					const {
						top_award: t,
						total_count: n
					} = e;
					return {
						topAward: t && s(t),
						totalCount: n
					}
				}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/helpers/isComment.ts"),
				o = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				i = n("./src/reddit/models/Vote/index.ts"),
				c = e => !0 === e ? i.a.upvoted : !1 === e ? i.a.downvoted : i.a.notVoted,
				a = n("./src/reddit/models/Comment/index.ts");
			n.d(t, "b", (function() {
				return d
			}));
			t.a = (e, t) => {
				const n = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					created: e.created_utc,
					deletedBy: u(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === r.z,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: d(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(s.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: c(e.likes)
				};
				return e.all_awardings && (n.allAwardings = Object(o.a)(e.all_awardings)), e.awarders && (n.awarders = e.awarders), e.associated_award && (n.associatedAwardId = e.associated_award.id, n.associatedAward = Object(o.b)(e.associated_award)), n
			};
			const d = e => "string" == typeof e ? JSON.parse(e) : e,
				u = e => e.author !== r.z ? null : e.body === r.A ? a.a.User : e.body === r.wb ? a.a.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				s = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/Media/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/models/Vote/index.ts");
			const a = e => {
					const t = [];
					return e.link_flair_richtext && e.link_flair_richtext.length && t.push({
						richtext: e.link_flair_richtext,
						type: s.f.Richtext,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.link_flair_text && t.push({
						text: e.link_flair_text,
						type: s.f.Text,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.spoiler && t.push({
						text: "spoiler",
						type: s.f.Spoiler
					}), e.over_18 && t.push({
						text: "nsfw",
						type: s.f.Nsfw
					}), t
				},
				d = e => e ? e.map(e => ({
					categoryId: e.category_id,
					categoryName: e.category_name
				})) : [],
				u = e => {
					const t = e.preview && e.preview.enabled;
					let n = !1,
						r = null,
						s = {},
						c = {};
					const a = e.over_18 || e.spoiler;
					if (e.preview && (n = !!(c = e.preview.images[0].variants).mp4, s = e.preview.images[0].source, a && (r = c.obfuscated.source.url)), e.is_self) return Object.assign({
						content: e.selftext_html,
						type: o.n.TEXT,
						markdownContent: e.selftext,
						obfuscated: r,
						rteMode: e.rte_mode || i.h.RICH_TEXT
					}, e.rtjson && {
						richtextContent: e.rtjson,
						type: o.n.RTJSON,
						mediaMetadata: e.media_metadata
					});
					if (e.media && e.media.reddit_video) {
						const t = e.media.reddit_video;
						return {
							hlsUrl: t.hls_url,
							dashUrl: t.dash_url,
							isGif: t.is_gif,
							scrubberThumbSource: t.scrubber_media_url,
							obfuscated: r,
							posterUrl: t.url,
							width: t.width,
							height: t.height,
							type: o.n.VIDEO
						}
					}
					if (e.secure_media && e.secure_media.oembed) {
						return {
							content: e.secure_media_embed.media_domain_url,
							type: o.n.EMBED,
							width: e.secure_media.oembed.width,
							height: e.secure_media.oembed.height,
							obfuscated: r,
							provider: e.secure_media.oembed.provider_name
						}
					}
					if (t && n) return {
						content: c.mp4.source.url,
						type: o.n.GIFVIDEO,
						width: c.mp4.source.width,
						height: c.mp4.source.height,
						gifBackgroundImage: s.url,
						gifBackgroundResolutions: e.preview.images[0].resolutions,
						obfuscated: r,
						resolutions: c.mp4.resolutions
					};
					if (t) {
						const t = c.gif ? c.gif.resolutions : e.preview.images[0].resolutions;
						return {
							content: s.url,
							type: o.n.IMAGE,
							width: s.width,
							height: s.height,
							obfuscated: r,
							resolutions: t
						}
					}
					return null
				},
				l = e => {
					const t = {};
					if (e.promoted && e.outbound_link || !e.is_self && !e.is_reddit_media_domain) {
						if (t.displayText = e.domain, t.url = e.url, e.outbound_link) {
							const n = e.outbound_link;
							t.outboundUrl = n.url, t.outboundUrlExpiration = n.expiration, t.outboundUrlCreated = n.created
						}
						return t
					}
					return null
				};
			t.a = e => {
				return {
					allAwardings: e.all_awardings ? Object(r.a)(e.all_awardings) : [],
					awarders: e.awarders,
					author: e.author,
					authorId: e.author_fullname,
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					belongsTo: {
						type: "user" === e.subreddit_type ? "profile" : "subreddit",
						id: e.subreddit_id || ""
					},
					callToAction: e.call_to_action || null,
					contestMode: e.contest_mode,
					created: 1e3 * e.created,
					crosspostParentId: e.cross_post_parent_id || null,
					crosspostRootId: e.cross_post_root_id || null,
					discussionType: e.discussion_type || null,
					distinguishType: e.distinguish_type || null,
					domain: e.domain,
					domainOverride: e.domain_override || null,
					events: e.events || [],
					flair: a(e),
					hidden: e.hidden,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isApproved: e.approved,
					isArchived: e.archived,
					isAuthorPremium: e.author_premium,
					isBlank: e.is_blank,
					isCrosspostable: e.is_crosspostable,
					isFollowed: e.is_followed || !1,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMediaOnly: e.media_only,
					isMeta: e.is_meta,
					isNSFW: e.over_18,
					isOriginalContent: e.is_original_content,
					isPinned: e.pinned,
					isRemoved: e.removed,
					isSpam: e.spam,
					isSpoiler: e.spoiler,
					isSponsored: e.promoted,
					isStickied: e.stickied,
					liveCommentsWebsocket: e.liveCommentsWebsocket || e.websocket_url,
					media: u(e),
					modNote: e.mod_note || null,
					modReports: e.mod_reports,
					numComments: e.num_comments,
					numCrossposts: e.num_crossposts || 0,
					numDuplicates: e.num_duplicates,
					numReports: e.num_reports || 0,
					permalink: "https://www.reddit.com".concat(e.permalink),
					postCategories: d(e.post_categories),
					preview: e.preview && e.preview.images && e.preview.images[0] && e.preview.images[0].source ? {
						url: e.preview.images[0].source.url,
						width: e.preview.images[0].source.width,
						height: e.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: e.previous_visits,
					postId: e.name,
					modRemovalReason: e.mod_reason_title,
					modReasonBy: e.mod_reason_by,
					removedBy: e.removed_by,
					removedByCategory: e.removed_by_category,
					saved: e.saved,
					score: e.score,
					isScoreHidden: !!e.hide_score,
					sendReplies: e.send_replies,
					source: l(e),
					suggestedSort: e.suggested_sort,
					thumbnail: {
						url: e.thumbnail,
						width: e.thumbnail_width,
						height: e.thumbnail_height
					},
					title: e.title,
					userReports: e.user_reports,
					upvoteRatio: e.upvote_ratio,
					viewCount: e.view_count || 0,
					voteState: Object(c.d)(e.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				s = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			t.a = (e, t) => {
				const n = Object(r.a)(e),
					{
						wls: o
					} = n,
					i = s(n, ["wls"]);
				return Object.assign({}, i, {
					name: t
				})
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var r = n("./src/lib/constants/index.ts");
			const s = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case r.D.NO_STRIPE_SUBSCRIPTION:
							case r.D.USER_DOESNT_EXIST:
							case r.D.USER_REQUIRED_ERROR:
							case r.D.VALIDATION_ERROR:
								return e;
							case r.D.NO_USER:
							case r.D.NO_TEXT:
							case r.D.NO_URL:
								return r.D.VALIDATION_ERROR;
							case r.D.CREDIT_CARD_FAILURE:
							case r.D.CREDIT_CARD_FAILURE_GENERIC:
								return r.D.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return r.D.SUBMIT_VALIDATION_ERROR
						}
					}
					return r.D.VALIDATION_ERROR
				},
				o = e => {
					const t = e.body;
					return {
						type: s(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				i = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? Object.assign({}, e, {
						error: o(e)
					}) : e
				};
			t.a = o
		},
		"./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => ({
				allowContractors: e.allow_contractors,
				communityIcon: e.community_icon,
				displayText: e.display_name_prefixed,
				icon: {
					height: e.icon_size ? e.icon_size[1] : 0,
					url: e.community_icon || e.icon_img || "",
					width: e.icon_size ? e.icon_size[0] : 0
				},
				id: e.name,
				isNSFW: e.over_18 || e.over18,
				isQuarantined: !!e.quarantine,
				name: e.display_name,
				primaryColor: e.primary_color,
				subscribers: e.subscribers,
				title: e.title,
				type: e.subreddit_type,
				url: e.url,
				wls: e.wls
			})
		},
		"./src/reddit/helpers/redesignOptoutCookie/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var r = n("./src/config.ts"),
				s = n("./node_modules/js-cookie/src/js.cookie.js"),
				o = n.n(s);
			const i = "redesign_optout";

			function c() {
				const e = new Date;
				return e.setFullYear(e.getFullYear() + 3), e
			}

			function a() {
				o.a.get(i) || o.a.set(i, "true", {
					domain: r.a.cookieDomain,
					expires: c()
				})
			}

			function d() {
				o.a.get(i) && o.a.remove(i, {
					domain: r.a.cookieDomain
				})
			}
		},
		"./src/reddit/helpers/reportPage/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var r = n("./src/reddit/models/RulesSequence/index.ts");
			const s = "(?:old\\.reddit\\.".concat("(?:com|local)", "|new\\.reddit\\.").concat("(?:com|local)", "|reddit\\.").concat("(?:com|local)", "|www\\.reddit\\.").concat("(?:com|local)", ")"),
				o = "(?:".concat("(?:r)", "|").concat("(?:user|u)", ")"),
				i = "(?:https?://)",
				c = "^".concat(i).concat(s, "/").concat(o, "/").concat("(?:[^/]+)", "/comments/").concat("(?:\\w+)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "(?:/.*)?"),
				a = "^".concat(i).concat(s, "/").concat(o, "/").concat("(?:[^/]+)", "/comments/").concat("(\\w+)", "(?:/.*)?"),
				d = "^".concat(i).concat(s, "/message/messages/").concat("(\\w+)", "(?:/.*)?"),
				u = "^".concat(i, "?").concat("(?:mod.reddit.com/mail)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "(?:/)?$"),
				l = "^".concat(i, "?").concat("(?:mod.reddit.com/mail)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "/").concat("(\\w+)", "(?:/)?$"),
				b = "(?:".concat(a, "|").concat(c, "|").concat(d, "|").concat(u, "|").concat(l, ")"),
				p = "(?:(?:".concat(i, "?").concat(s, "/)?").concat("(?:user|u)", "/)?").concat("([\\w-]+)", "(?:/)?"),
				m = "(?:(?:".concat(i, "?").concat(s, "/)?").concat("(?:r)", "/)?").concat("([\\w-]+)", "(?:/)?"),
				f = e => {
					const t = new RegExp(c),
						n = new RegExp(a),
						r = new RegExp(d),
						s = new RegExp(u),
						o = new RegExp(l);
					let i, b, f;
					if (e.thingUrl) {
						const c = e.thingUrl.trim();
						if (t.test(c)) {
							const e = t.exec(c);
							e && e.length > 1 && (i = "t1_" + e[1])
						} else if (n.test(c)) {
							const e = n.exec(c);
							e && e.length > 1 && (i = "t3_" + e[1])
						} else if (r.test(c)) {
							const e = r.exec(c);
							e && e.length > 1 && (i = "t4_" + e[1])
						} else if (o.test(c)) {
							const e = o.exec(c);
							e && e.length > 2 && (b = e[1], f = e[2])
						} else if (s.test(c)) {
							const e = s.exec(c);
							e && e.length > 1 && (b = e[1])
						}
					}
					const g = new RegExp(p),
						O = new RegExp(m),
						h = [];
					let y;
					if (e.subredditName) {
						const t = e.subredditName.trim();
						if (O.test(t)) {
							const e = O.exec(t);
							e && e.length > 1 && (y = e[1])
						}
					}
					if (e.usernames && e.usernames.length)
						for (let c = 0; c < e.usernames.length; c++) {
							const t = e.usernames[c].trim();
							if (g.test(t)) {
								const e = g.exec(t);
								e && e.length > 1 && h.push(e[1])
							}
						}
					const {
						reason: j
					} = e;
					return {
						reason: "site_reason_selected",
						site_reason: j.reasonText,
						additional_info: e.additionalInfo ? e.additionalInfo.join(",") : void 0,
						custom_text: e.customText,
						modmail_conv_id: b,
						modmail_msg_id: f,
						sr_name: y,
						thing_id: i,
						usernames: h.length ? h.join(",") : void 0
					}
				},
				g = (e, t) => {
					const n = new r.a;
					return O(n, e, t, 0), n
				},
				O = (e, t, n, r) => {
					for (let s = 0; s < t.length; s++) {
						const o = t[s];
						e.update(s, r);
						const i = e.getSequence().length;
						if (o.reasonAsParam === n) return;
						if (o.nextStepReasons && o.nextStepReasons.length && (O(e, o.nextStepReasons, n, r + 1), e.getSequence().length > i)) return;
						e.cut(r - 1)
					}
				}
		},
		"./src/reddit/helpers/richTextJson/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			const r = "giphy|",
				s = "|downsized";

			function o(e, t) {
				return r + e + (t ? s : "")
			}

			function i(e) {
				return e && 0 === e.indexOf(r)
			}

			function c(e) {
				const t = e && e.media && e.media.mediaMetadata;
				return !!t && Object.keys(t).some(i)
			}

			function a(e) {
				let t = e.substring(r.length);
				return t.indexOf("|") && (t = t.split("|")[0]), "https://giphy.com/gifs/".concat(t)
			}
		},
		"./src/reddit/helpers/routeKey/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return S
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "b", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeCommentsPageKey/index.ts"),
				c = n("./src/lib/makeExplorePageKey/index.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/lib/makePostCreationPageKey/index.ts"),
				u = n("./src/lib/makeSearchKey/index.ts"),
				l = n("./src/reddit/constants/postLayout.ts"),
				b = n("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				p = n("./src/reddit/constants/listings.ts"),
				m = n("./src/reddit/constants/page.ts"),
				f = n("./src/reddit/constants/parameters.ts"),
				g = n("./src/reddit/constants/wiki.ts"),
				O = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				h = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				y = n("./src/reddit/models/Comment/index.ts"),
				j = n("./src/reddit/models/Multireddit/index.ts"),
				_ = n("./src/reddit/models/Post/index.ts"),
				E = n("./src/reddit/models/User/index.ts"),
				v = n("./src/reddit/routes/modListing/index.ts"),
				I = n("./src/reddit/selectors/frontpage.ts");
			const S = (e, t, n) => {
					const {
						route: r
					} = e, {
						name: s
					} = r.meta;
					if (!s || !o.M.has(s) && s !== o.xb.COINS && s !== o.xb.COMMENTS && s !== o.xb.POST_CREATION && s !== o.xb.PREMIUM && s !== o.xb.PUBLIC_ACCESS_NETWORK && s !== o.xb.SEARCH_RESULTS && s !== o.xb.EXPLORE && s !== o.xb.SETTINGS && s !== o.xb.SUBREDDIT_WIKI || !n && (s === o.xb.COMMENTS || s === o.xb.DUPLICATES)) return null;
					switch (s) {
						case o.xb.POST_CREATION:
							return Object(d.a)(e.match.params);
						case o.xb.INDEX:
						case o.xb.LISTING:
						case o.xb.SUBREDDIT:
						case o.xb.TOPIC:
							return x(e, t).listingKey;
						case o.xb.PROFILE_COMMENTS:
						case o.xb.PROFILE_POSTS:
						case o.xb.PROFILE_OVERVIEW:
						case o.xb.PROFILE_PRIVATE:
							return C(e, t);
						case o.xb.MULTIREDDIT:
							return w(e, t);
						case o.xb.COMMENTS:
							return D(e, t, n);
						case o.xb.SEARCH_RESULTS:
							return P(e);
						case o.xb.SUBREDDIT_WIKI:
							return k(e);
						case o.xb.COINS:
						case o.xb.PREMIUM:
						case o.xb.PUBLIC_ACCESS_NETWORK:
							return s;
						case o.xb.SETTINGS:
							return R(e);
						case o.xb.EXPLORE:
							return A(e);
						default:
							return null
					}
				},
				T = {
					listingKey: null
				},
				x = (e, t) => {
					const {
						route: n,
						match: r
					} = e, {
						name: s
					} = n.meta;
					if (!o.M.has(s) && s !== o.xb.POST_CREATION && s !== o.xb.SUBREDDIT_WIKI) return T;
					const {
						queryParams: i
					} = r;
					switch (s) {
						case o.xb.INDEX:
						case o.xb.LISTING: {
							const e = Object(I.a)(t),
								n = r.params,
								s = n.sort ? n.sort : e;
							return {
								listingKey: Object(a.a)(m.b, s, i),
								sort: s
							}
						}
						case o.xb.PROFILE_COMMENTS:
						case o.xb.PROFILE_POSTS: {
							const {
								profileName: e
							} = r.params, {
								sort: t
							} = i;
							return {
								listingKey: Object(a.a)("u_".concat(e), t, i),
								sort: t
							}
						}
						case o.xb.POST_CREATION:
						case o.xb.SUBREDDIT: {
							const e = r.params,
								{
									subredditName: t
								} = e,
								n = i.f,
								s = Object(h.a)(e);
							if (n) {
								const e = {
										[f.o]: n,
										[f.p]: "1"
									},
									r = Object(u.c)(e);
								return {
									listingKey: Object(u.b)(t, void 0, r),
									sort: s
								}
							}
							return {
								listingKey: Object(a.a)(t, s, i),
								sort: s
							}
						}
						case o.xb.TOPIC: {
							const e = r.params,
								t = e.sort || o.O,
								n = e.topicSlug;
							return {
								listingKey: Object(a.a)(p.b.Topic, t, Object.assign({}, e, {
									topicSlug: n
								})),
								sort: t
							}
						}
						case o.xb.MOD_LISTING: {
							const e = r.params,
								{
									sort: t = o.O
								} = e,
								n = Object(v.d)(r.path) ? m.f : m.e;
							return {
								listingKey: Object(a.a)(n, t, i),
								sort: t
							}
						}
						case o.xb.MULTIREDDIT:
							return {
								listingKey: w(e, t)
							};
						case o.xb.SEARCH_RESULTS:
							return {
								listingKey: S(e, t, null)
							};
						default:
							return T
					}
				},
				C = (e, t) => {
					const {
						route: n,
						match: r
					} = e, {
						name: s
					} = n.meta;
					if (!o.M.has(s) && s !== o.xb.POST_CREATION) return null;
					const {
						params: i,
						queryParams: c
					} = r, {
						profileName: d
					} = i, {
						sort: u = o.rb
					} = c;
					switch (s) {
						case o.xb.PROFILE_OVERVIEW:
							const e = (t.user.prefs && t.user.prefs.profileLayout ? t.user.prefs.profileLayout : l.g.Large) === l.g.Compact ? o.ib : o.jb;
							return Object(b.a)((d || "").toLowerCase(), e, u, c);
						case o.xb.PROFILE_COMMENTS:
						case o.xb.PROFILE_POSTS:
							return Object(a.a)("u_".concat(d), u, c);
						case o.xb.PROFILE_PRIVATE:
							const {
								listingType: n
							} = i;
							return Object(b.b)(d.toLowerCase(), n);
						default:
							return null
					}
				},
				w = (e, t) => {
					const {
						route: n,
						match: r
					} = e, {
						name: s
					} = n.meta;
					if (s !== o.xb.MULTIREDDIT) return null;
					const {
						params: i,
						queryParams: c
					} = r, {
						multiredditName: d,
						sort: u = o.N.HOT
					} = i;
					let {
						username: l
					} = i;
					l || (l = t.user.account ? Object(E.f)(t.user.account) : "me");
					const b = Object(j.h)(l, d);
					return Object(a.a)(b, u, c)
				},
				P = e => {
					const {
						route: t,
						match: n
					} = e, {
						name: r
					} = t.meta;
					if (r !== o.xb.SEARCH_RESULTS) return null;
					const {
						subredditName: i
					} = n.params, {
						username: c
					} = n.params, a = Object(u.c)(s()(n.queryParams, f.q));
					return Object(u.b)(i, c, a)
				},
				D = (e, t, n) => {
					const {
						route: r,
						match: s
					} = e, {
						name: c
					} = r.meta;
					if (!c || c !== o.xb.COMMENTS) return null;
					const {
						partialCommentId: a,
						partialPostId: d
					} = s.params, u = Object(_.m)(d), l = a && Object(y.e)(a), {
						hasSortParam: b,
						sortToUse: p
					} = Object(O.a)(t, u);
					return Object(i.a)(u, l, {
						sort: p,
						hasSortParam: b
					})
				},
				R = e => "SettingsPage-" + e.match.params.page,
				A = e => {
					const {
						route: t,
						match: n
					} = e, {
						name: r
					} = t.meta;
					if (!r || r !== o.xb.EXPLORE) return null;
					const {
						categoryName: s
					} = n.queryParams;
					return Object(c.a)({
						categoryName: s
					})
				},
				k = e => {
					const {
						route: t,
						match: n
					} = e;
					if (t.meta.name !== o.xb.SUBREDDIT_WIKI) return;
					const {
						subredditName: r = g.e,
						wikiPageName: s,
						wikiSubRoute: i
					} = n.params;
					return ["Wiki", r, i, s].join("--")
				}
		},
		"./src/reddit/helpers/styles/postBackgroundColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/polished/dist/polished.es.js");
			var r = n("./src/reddit/models/Theme/NewColorSystem/index.ts");

			function s(e) {
				return e.flairStyleTemplate && e.flairStyleTemplate.postBackgroundColor ? e.flairStyleTemplate.postBackgroundColor : Object(r.a)(e).post
			}
		},
		"./src/reddit/helpers/styles/smartTextColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var r = n("./node_modules/polished/dist/polished.es.js"),
				s = n("./src/reddit/models/NewStructuredStyles/index.ts");
			const o = e => Object(r.b)(e) < .6;

			function i(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.a.bodyText,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.b.bodyText;
				return o(e) ? n : t
			}
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/lodash/values.js"),
				s = n.n(r);
			const o = e => s()(e).sort((t, n) => {
					const r = e[t.tag.id].tag.text.toLowerCase(),
						s = e[n.tag.id].tag.text.toLowerCase();
					return r < s ? -1 : r > s ? 1 : 0
				}),
				i = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/timeApiRoute/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/telemetry/index.ts");
			async function o(e, t) {
				const n = s.c.start();
				try {
					const o = await t();
					return Object(s.b)(r.l.Redesign, {
						page: e,
						type: "route",
						duration: s.c.end(n)
					}), o
				} finally {
					s.c.cancel(n)
				}
			}
		},
		"./src/reddit/helpers/trackers/authorHovercard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var r = n("./src/reddit/helpers/isComment.ts"),
				s = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => ({
					comment: t && Object(r.a)(t) ? s.comment(e, t) : null,
					post: t ? s.post(e, t) : null,
					profile: s.profile(e),
					screen: s.screen(e)
				}),
				i = (e, t) => n => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: e
				}, o(n, t)),
				c = e => t => Object.assign({
					source: "user_hovercard",
					action: "view",
					noun: "hover_user_hovercard"
				}, o(t, e)),
				a = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "mute_dialog_in_context"
				}, o(t, e)),
				d = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "ban_dialog_in_context"
				}, o(t, e)),
				u = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "unban_user_in_context"
				}, o(t, e)),
				l = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "change_user_flair_in_context",
					userSubreddit: s.userSubreddit(t)
				}, o(t, e)),
				b = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "create_chat"
				}, e && o(t, e))
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "k", (function() {
				return O
			}));
			var r = n("./src/reddit/constants/blade.ts"),
				s = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => n => Object.assign({}, s.defaults(n), {
					source: r.d.Appearance,
					action: "click",
					noun: e,
					actionInfo: s.actionInfo(n, {
						paneName: t
					}),
					subreddit: s.subreddit(n)
				}),
				i = e => o("save_style", e),
				c = e => o("cancel_style", e),
				a = e => t => ({
					source: r.d.Structure,
					action: "click",
					noun: e,
					screen: s.screen(t),
					subreddit: s.subreddit(t)
				}),
				d = e => t => ({
					source: r.d.Appearance,
					action: "click",
					noun: e,
					screen: s.screen(t),
					subreddit: s.subreddit(t)
				}),
				u = (e, t) => n => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: s.actionInfo(n, {
						paneName: r.g[t]
					}),
					screen: s.screen(n),
					subreddit: s.subreddit(n)
				}),
				l = e => t => ({
					source: r.h[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: s.actionInfo(t, {
						paneName: r.g[e]
					}),
					screen: s.screen(t),
					subreddit: s.subreddit(t)
				}),
				b = e => ({
					screen: s.screen(e),
					subreddit: s.subreddit(e)
				}),
				p = () => e => Object.assign({
					source: r.d.Appearance,
					action: "view",
					noun: "blade"
				}, b(e)),
				m = e => t => Object.assign({
					source: r.a[e],
					action: "click",
					noun: r.b[e]
				}, b(t)),
				f = () => e => Object.assign({
					source: r.d.Appearance,
					action: "click",
					noun: "back"
				}, b(e)),
				g = (e, t) => Object.assign({}, s.defaults(e), (e => t => Object.assign({
					source: r.d.PostFlairManagement,
					action: "click",
					noun: e
				}, b(t)))(t)(e)),
				O = e => t => ({
					source: r.d.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: s.screen(t),
					subreddit: s.subreddit(t),
					userSubreddit: s.userSubreddit(t)
				})
		},
		"./src/reddit/helpers/trackers/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "f", (function() {
				return y
			}));
			var r = n("./src/reddit/constants/chat.ts"),
				s = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/telemetry/models/Event.ts");
			const i = e => ({
					screen: Object(s.screen)(e),
					subreddit: Object(s.subreddit)(e)
				}),
				c = () => e => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "view",
					noun: "chat_rooms",
					chat: Object(s.numberChannels)(e)
				}, i(e)),
				a = e => t => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "click",
					noun: "view_room",
					chat: Object(s.channel)(t, e)
				}, i(t)),
				d = e => t => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "click",
					noun: "join_room",
					chat: Object(s.channel)(t, e)
				}, i(t)),
				u = () => e => Object.assign({
					source: o.b.ChatSidebarWidget,
					action: "click",
					noun: "view_all_rooms",
					chat: Object(s.numberChannels)(e)
				}, i(e)),
				l = e => t => Object.assign({
					source: o.b.ChatSidebarModal,
					action: "click",
					noun: "view_room",
					chat: Object(s.channel)(t, e)
				}, i(t)),
				b = e => t => Object.assign({
					source: o.b.ChatSidebarModal,
					action: "click",
					noun: "join_room",
					chat: Object(s.channel)(t, e)
				}, i(t)),
				p = () => e => Object.assign({
					source: o.b.ChatSetup,
					action: "view",
					noun: "create_chat_room"
				}, i(e)),
				m = e => t => {
					const {
						channelSendbirdUrl: n,
						type: s
					} = e;
					return Object.assign({
						source: o.b.ChatSetup,
						action: "submit",
						noun: "create_chat_room",
						chat: {
							id: n,
							type: r.f[s]
						}
					}, i(t))
				},
				f = () => e => Object.assign({
					source: o.b.ChatSetup,
					action: "view",
					noun: "edit_chat_room"
				}, i(e)),
				g = e => t => {
					const {
						channelSendbirdUrl: n,
						type: s
					} = e;
					return Object.assign({
						source: o.b.ChatSetup,
						action: "submit",
						noun: "edit_chat_room",
						chat: {
							id: n,
							type: r.f[s]
						}
					}, i(t))
				},
				O = e => t => {
					const {
						channelSendbirdUrl: n,
						type: s
					} = e;
					return Object.assign({
						source: o.b.ChatSetup,
						action: "submit",
						noun: "delete_chat_room",
						chat: {
							id: n,
							type: r.f[s]
						}
					}, i(t))
				},
				h = () => e => Object.assign({
					source: o.b.Nav,
					action: "view",
					noun: "orangered_06"
				}, i(e)),
				y = e => t => Object.assign({
					source: "settings_privacy",
					action: "save",
					noun: "receive_chat_invites",
					setting: {
						value: e,
						oldValue: e
					},
					actionInfo: Object(s.actionInfo)(t, {
						settingValue: e
					})
				}, Object(s.defaults)(t))
		},
		"./src/reddit/helpers/trackers/coins.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			}));
			var r = n("./src/reddit/selectors/telemetry.ts"),
				s = n("./node_modules/uuid/v4.js"),
				o = n.n(s);
			let i;
			const c = () => i,
				a = () => i = o()(),
				d = () => i = void 0,
				u = "coins_marketing",
				l = () => e => Object.assign({
					source: u,
					action: "click",
					noun: "get_coins",
					correlationId: c()
				}, r.defaults(e)),
				b = e => t => Object.assign({
					source: u,
					action: "click",
					noun: "coins_".concat(e),
					correlationId: c()
				}, r.defaults(t)),
				p = () => e => Object.assign({
					source: u,
					action: "click",
					noun: "get_premium",
					correlationId: c()
				}, r.defaults(e))
		},
		"./src/reddit/helpers/trackers/commentList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./src/telemetry/index.ts"),
				s = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => {
				Object(r.a)(Object.assign({
					action: "view",
					source: "commentlist",
					noun: "bottom"
				}, s.defaults(e), {
					listing: s.listing(e, t),
					subreddit: s.subreddit(e)
				}))
			}
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			}));
			var r = n("./src/reddit/models/PostDraft/index.ts"),
				s = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/selectors/comments.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const d = e => {
					const t = Object(c.o)(e);
					return Object.assign({
						source: "comment_composer",
						action: o.c.CLICK
					}, Object(a.defaults)(e), {
						screen: Object(a.screen)(e),
						subreddit: Object(a.subreddit)(e),
						post: t ? Object(a.post)(e, t) : null,
						profile: Object(a.profile)(e)
					})
				},
				u = (e, t, n, r) => {
					const o = {
							commentId: r,
							commentsPageKey: n
						},
						c = r && Object(i.j)(e, o) || 0;
					return Object(s.a)(Object.assign({
						noun: "comment"
					}, d(e), {
						comment: r ? Object(a.comment)(e, r) : null,
						listing: Object(a.listing)(e, void 0, {
							depth: c
						}),
						commentComposer: {
							editorMode: t
						}
					}))
				},
				l = e => Object(s.a)(Object.assign({
					noun: "cancel"
				}, d(e))),
				b = (e, t) => {
					t === r.c.replyToPost && Object(s.a)(Object.assign({
						noun: "input"
					}, d(e)))
				},
				p = (e, t) => Object(s.a)(Object.assign({
					source: "comment",
					noun: "delete",
					action: "click"
				}, Object(a.defaults)(t), {
					screen: Object(a.screen)(t),
					subreddit: Object(a.subreddit)(t),
					post: Object(a.post)(t, e)
				})),
				m = e => Object(s.a)(Object.assign({
					noun: "edit"
				}, d(e))),
				f = e => Object(s.a)(Object.assign({
					noun: "save_edit"
				}, d(e)))
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return O
			}));
			var r, s = n("./src/reddit/selectors/tags.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(r || (r = {}));
			const c = (e, t) => Object(s.t)(e, {
					itemId: t
				}).reduce((e, t) => {
					let {
						topicTagIds: n,
						topicTagContents: r,
						topicTagTypes: s
					} = e;
					return n.push(t.tag.id), r.push(t.tag.text), s.push(t.tag.type), {
						topicTagIds: n,
						topicTagContents: r,
						topicTagTypes: s
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				a = (e, t, n) => {
					if (!n.id) return {
						content: n.displayText
					};
					const r = Object(s.b)(e)[n.id] || Object(s.d)(e, {
						subredditId: t
					})[n.id];
					return r ? {
						id: r.id,
						content: r.text,
						type: r.type
					} : null
				},
				d = (e, t, n) => {
					if (!n) return null;
					const r = Object(s.b)(e)[n] || Object(s.d)(e, {
						subredditId: t
					})[n];
					return r ? {
						id: r.id,
						content: r.text,
						type: r.type
					} : null
				},
				u = (e, t, n) => Object.assign({}, o.defaults(e), {
					subreddit: Object.assign({}, o.subreddit(e) || {}, {
						id: t
					}, c(e, t)),
					source: n.context,
					action: "click"
				}),
				l = (e, t, n) => {
					Object(i.a)(((e, t, n) => Object.assign({}, u(e, t.subredditId, n), {
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: d(e, t.subredditId, t.tagId)
					}))(e, t, n))
				},
				b = (e, t, n, r) => {
					Object(i.a)(Object.assign({}, u(e, t, r), {
						topicTag: a(e, t, n),
						noun: "add_related_topic"
					}))
				},
				p = (e, t, n, r) => {
					return !Object(s.k)(e, {
						subredditId: t
					}) && n.id ? Object(i.a)(((e, t, n, r) => Object.assign({}, u(e, t, r), {
						topicTag: a(e, t, n),
						noun: "topic_auto_suggest"
					}))(e, t, n, r)) : n.id ? Object(i.a)(((e, t, n, r) => Object.assign({}, u(e, t, r), {
						topicTag: a(e, t, n),
						noun: "topic_auto_complete"
					}))(e, t, n, r)) : Object(i.a)(((e, t, n, r) => Object.assign({}, u(e, t, r), {
						topicTag: a(e, t, n),
						noun: "topic_add_new"
					}))(e, t, n, r))
				},
				m = (e, t, n, r) => Object(i.a)(Object.assign({}, u(e, t, r), {
					topicTag: a(e, t, n),
					noun: "topic_remove"
				})),
				f = (e, t, n) => Object(i.a)(Object.assign({}, u(e, t, n), {
					noun: "topic_tag_field"
				})),
				g = (e, t, n) => Object(i.a)(Object.assign({}, u(e, t, n), {
					noun: n.context === r.communitySettings ? "save" : "save_community_topics"
				})),
				O = (e, t, n, r) => {
					const s = u(e, t, r);
					Object(i.a)(Object.assign({}, s, {
						action: "view",
						noun: "error",
						actionInfo: Object.assign({}, s.actionInfo, {
							reason: n
						})
					}))
				}
		},
		"./src/reddit/helpers/trackers/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "K", (function() {
				return I
			})), n.d(t, "L", (function() {
				return S
			})), n.d(t, "A", (function() {
				return T
			})), n.d(t, "B", (function() {
				return x
			})), n.d(t, "E", (function() {
				return C
			})), n.d(t, "F", (function() {
				return w
			})), n.d(t, "h", (function() {
				return P
			})), n.d(t, "v", (function() {
				return D
			})), n.d(t, "w", (function() {
				return R
			})), n.d(t, "J", (function() {
				return A
			})), n.d(t, "u", (function() {
				return k
			})), n.d(t, "x", (function() {
				return N
			})), n.d(t, "y", (function() {
				return L
			})), n.d(t, "z", (function() {
				return M
			})), n.d(t, "C", (function() {
				return U
			})), n.d(t, "D", (function() {
				return F
			})), n.d(t, "M", (function() {
				return B
			})), n.d(t, "s", (function() {
				return G
			})), n.d(t, "t", (function() {
				return V
			})), n.d(t, "G", (function() {
				return q
			})), n.d(t, "H", (function() {
				return H
			})), n.d(t, "I", (function() {
				return K
			})), n.d(t, "c", (function() {
				return W
			})), n.d(t, "b", (function() {
				return Y
			})), n.d(t, "a", (function() {
				return z
			})), n.d(t, "e", (function() {
				return J
			})), n.d(t, "d", (function() {
				return Q
			})), n.d(t, "r", (function() {
				return $
			})), n.d(t, "l", (function() {
				return ee
			})), n.d(t, "q", (function() {
				return te
			})), n.d(t, "j", (function() {
				return ne
			})), n.d(t, "k", (function() {
				return re
			})), n.d(t, "m", (function() {
				return se
			})), n.d(t, "o", (function() {
				return oe
			})), n.d(t, "p", (function() {
				return ie
			})), n.d(t, "n", (function() {
				return ce
			})), n.d(t, "i", (function() {
				return ae
			}));
			var r, s = n("./src/lib/stringInterpolate/index.ts"),
				o = n("./src/reddit/actions/focusedVerticals/constants.ts"),
				i = n("./src/reddit/constants/categories.tsx"),
				c = n("./src/reddit/constants/tracking.ts"),
				a = n("./src/reddit/helpers/correlationIdTracker.ts"),
				d = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				u = n("./src/reddit/models/Widgets/index.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/telemetry.ts"),
				p = n("./src/reddit/selectors/widgets.ts"),
				m = n("./src/telemetry/index.ts");
			! function(e) {
				e.HEADER_SUBREDDIT = "header_subreddit", e.ITEM_POST = "item_post", e.ITEM_POST_SUBREDDIT = "item_post_subreddit", e.ITEM_SUBREDDIT = "item_subreddit", e.ITEM_SUBREDDIT_HIDE = "item_subreddit_hide", e.ITEM_SUBREDDIT_SUBSCRIBE = "item_subreddit_subscribe", e.ITEM_SUBREDDIT_UNSUBSCRIBE = "item_subreddit_unsubscribe"
			}(r || (r = {}));
			const f = "discovery_unit",
				g = (e, t, n) => Object.assign({}, b.defaults(e), {
					source: f,
					screen: b.screen(e),
					discoveryUnit: {
						id: t.id,
						type: t.unitType,
						title: t.title && n ? Object(s.a)(t.title, {
							subredditName: n.name
						}) : t.title,
						name: t.unitName
					}
				}),
				O = (e, t, n) => Object.assign({}, g(e, t, n), {
					source: "global",
					action: "view",
					noun: "discovery_unit"
				}),
				h = (e, t) => Object.assign({}, b.defaults(e), {
					correlationId: Object(a.c)(a.a.SearchResults),
					screen: b.screen(e),
					noun: "search_result_discovery_unit",
					post: t ? b.post(e, t) : null,
					discoveryUnit: {
						name: d.s,
						id: "xd_72",
						type: "listing"
					}
				}),
				y = (e, t) => {
					Object(m.a)(j(t)(e))
				},
				j = (e, t) => n => O(n, e, t),
				_ = (e, t, n, r) => "unitName" in t ? g(e, t, r) : ((e, t, n) => Object.assign({}, b.defaults(e), {
					source: "search",
					screen: b.screen(e),
					search: n ? Object.assign({}, b.search(e, n), {
						structureType: b.StructureType.Trending
					}) : null,
					discoveryUnit: {
						id: t.name,
						type: "listing",
						title: t.layout.title,
						name: t.name
					}
				}))(e, t, n),
				E = (e, t, n, s, o) => Object.assign({}, _(e, t, s, o), {
					action: "view",
					noun: r.ITEM_POST,
					post: b.post(e, n)
				}),
				v = e => {
					let {
						post: t,
						rawQuery: n,
						searchQuery: r
					} = e;
					return {
						displayQuery: decodeURIComponent(r),
						rawQuery: n ? decodeURIComponent(n) : void 0,
						structureType: t && t.isSponsored ? b.StructureType.PromotedTrend : b.StructureType.Trending
					}
				},
				I = (e, t) => {
					const n = t.post ? t.post.id : void 0;
					Object(m.a)(Object.assign({}, h(e, n), {
						metaSearch: v(t),
						source: "search",
						action: "click"
					}))
				},
				S = (e, t) => {
					const n = t.post ? t.post.id : void 0;
					Object(m.a)(Object.assign({}, h(e, n), {
						metaSearch: v(t),
						source: "search",
						action: "view"
					}))
				},
				T = (e, t, n, r) => {
					Object(m.a)(E(e, t, n, r))
				},
				x = (e, t, n, r) => s => E(s, e, t, n, r),
				C = (e, t, n, s) => {
					const o = _(e, t, s);
					Object(m.a)(Object.assign({}, o, Object(p.b)(e, n), {
						action: "view",
						noun: r.ITEM_SUBREDDIT
					}))
				},
				w = (e, t, n) => {
					Object(m.a)(Object.assign({}, g(e, t), {
						source: f,
						action: c.c.CLICK,
						noun: "title_category",
						subreddit: {
							categoryName: Object(i.f)(n)
						}
					}))
				},
				P = (e, t) => {
					Object(m.a)(Object.assign({}, g(e, t), {
						source: f,
						action: c.c.CLICK,
						noun: "show_less_often"
					}))
				},
				D = (e, t, n, r) => {
					Object(m.a)(R(t, n, r)(e))
				},
				R = (e, t, n, s) => o => {
					const i = _(o, e, n, s);
					return Object.assign({}, i, {
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_POST,
						post: b.post(o, t)
					})
				},
				A = () => e => t => ({
					source: "search",
					action: c.c.CLICK,
					noun: r.ITEM_POST,
					post: b.post(t, e),
					search: {
						structureType: b.StructureType.Trending
					}
				}),
				k = (e, t) => n => s => Object.assign({}, e ? g(s, e, t) : {}, {
					source: f,
					action: c.c.CLICK,
					noun: r.ITEM_POST,
					post: b.post(s, n)
				}),
				N = (e, t, n, r) => {
					Object(m.a)(L(t, n, r)(e))
				},
				L = (e, t, n, r) => s => {
					const o = Object(l.b)(s, {
							postId: t
						}),
						i = o ? Object(p.b)(s, o) : void 0,
						a = _(s, e, n, r);
					return Object.assign({}, a, i, {
						source: f,
						action: c.c.CLICK,
						noun: "item_post_subreddit",
						post: b.post(s, t)
					})
				},
				M = (e, t, n) => r => s => {
					const o = Object(l.b)(s, {
							postId: t
						}),
						i = o ? Object(p.b)(s, o) : void 0,
						a = _(s, e, void 0, n);
					return Object.assign({}, a, i, {
						source: f,
						action: c.c.CLICK,
						noun: r ? "item_post_subreddit_unsubscribe" : "item_post_subreddit_subscribe",
						post: b.post(s, t)
					})
				},
				U = (e, t, n) => {
					Object(m.a)(Object.assign({}, g(e, t), Object(p.b)(e, n), {
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_SUBREDDIT
					}))
				},
				F = (e, t) => n => r => Object.assign({}, g(r, e), Object(p.b)(r, t), {
					source: f,
					action: c.c.CLICK,
					noun: n ? "item_subreddit_unsubscribe" : "item_subreddit_subscribe"
				}),
				B = (e, t, n) => {
					const r = _(e, t);
					Object(m.a)(Object.assign({}, r, Object(p.b)(e, n), {
						source: "search",
						action: c.c.CLICK,
						noun: "search_result_discovery_unit_subreddit"
					}))
				},
				G = (e, t, n) => {
					const r = _(e, t);
					Object(m.a)(Object.assign({}, r, Object(p.b)(e, n), {
						source: f,
						action: c.c.CLICK,
						noun: "footer_subreddit"
					}))
				},
				V = (e, t) => n => {
					const r = t ? Object(u.j)(t) : void 0,
						s = r ? Object(p.b)(n, r) : void 0;
					return Object.assign({}, g(n, e, t), s, {
						source: f,
						action: c.c.CLICK,
						noun: "footer_subreddit"
					})
				},
				q = (e, t, n) => {
					Object(m.a)(Object.assign({}, g(e, t), Object(p.b)(e, n), {
						source: f,
						action: c.c.CLICK,
						noun: "title_subreddit"
					}))
				},
				H = (e, t) => n => {
					const r = Object(u.j)(t);
					return Object.assign({}, g(n, e, t), Object(p.b)(n, r), {
						source: f,
						action: c.c.CLICK,
						noun: "title_subreddit"
					})
				},
				K = (e, t) => n => r => Object.assign({}, g(r, e), Object(p.b)(r, t), {
					source: f,
					action: c.c.CLICK,
					noun: n ? "title_subreddit_unsubscribe" : "title_subreddit_subscribe"
				}),
				W = (e, t) => n => Object.assign({}, g(n, e, t), {
					action: "status",
					actionInfo: b.actionInfo(n, {
						success: !0
					}),
					noun: "loading"
				}),
				Y = (e, t, n) => r => Object.assign({}, g(r, e, n), {
					action: "status",
					actionInfo: b.actionInfo(r, {
						reason: t,
						success: !1
					}),
					noun: "loading"
				}),
				z = (e, t) => n => Object.assign({}, g(n, e, t), {
					action: "click",
					noun: "close"
				}),
				J = (e, t, n) => r => Object.assign({}, _(r, e, t, n), {
					action: "click",
					noun: "scroll"
				}),
				Q = (e, t) => n => Object.assign({}, g(n, e, t), {
					action: "click",
					noun: "overflow_menu"
				}),
				X = () => ({
					id: "xd_focus_verticals",
					unitType: d.f.Listing,
					experiment: "",
					title: o.a,
					unitName: "focused_vertical_suggestion",
					enabled: !1,
					layout: d.d.Large,
					surface: d.e.Frontpage,
					url: "gql.reddit.com"
				}),
				Z = (e, t, n) => b.actionInfo(e, {
					position: n
				}),
				$ = (e, t, n) => {
					const r = X();
					return e => Object.assign({}, O(e, r), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t)
					})
				},
				ee = (e, t, n) => {
					const r = X();
					return e => Object.assign({}, E(e, r, t), {
						actionInfo: Z(e, 0, n)
					})
				},
				te = (e, t, n) => {
					const s = X();
					return e => Object.assign({}, g(e, s), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t) || null,
						source: f,
						action: c.c.VIEW,
						noun: r.ITEM_SUBREDDIT
					})
				},
				ne = (e, t, n) => {
					const s = X();
					return e => Object.assign({}, g(e, s), {
						actionInfo: Z(e, 0, n),
						post: b.post(e, t) || null,
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_POST
					})
				},
				re = (e, t, n, s) => {
					const o = X();
					return e => Object.assign({}, g(e, o), {
						actionInfo: Z(e, 0, s),
						subreddit: b.subredditById(e, n) || null,
						post: b.post(e, t) || null,
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_POST_SUBREDDIT
					})
				},
				se = (e, t, n) => {
					const s = X();
					return e => Object.assign({}, g(e, s), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t) || null,
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_SUBREDDIT
					})
				},
				oe = (e, t, n, s) => {
					const o = X();
					return e => Object.assign({}, g(e, o), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t) || null,
						post: s ? b.post(e, s) : null,
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_SUBREDDIT_SUBSCRIBE
					})
				},
				ie = (e, t, n, s) => {
					const o = X();
					return e => Object.assign({}, g(e, o), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t) || null,
						post: s ? b.post(e, s) : null,
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_SUBREDDIT_UNSUBSCRIBE
					})
				},
				ce = (e, t, n) => {
					const s = X();
					return e => Object.assign({}, g(e, s), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t) || null,
						source: f,
						action: c.c.CLICK,
						noun: r.ITEM_SUBREDDIT_HIDE
					})
				},
				ae = (e, t, n) => {
					const s = X();
					return e => Object.assign({}, g(e, s), {
						actionInfo: Z(e, 0, n),
						subreddit: b.subredditById(e, t) || null,
						source: f,
						action: c.c.CLICK,
						noun: r.HEADER_SUBREDDIT
					})
				}
		},
		"./src/reddit/helpers/trackers/emailCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var r = n("./src/reddit/constants/tracking.ts"),
				s = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					action: r.c.VIEW,
					actionInfo: s.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "email_collection"
				}),
				i = e => t => ({
					source: e,
					action: r.c.CLICK,
					actionInfo: s.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "add_email_collection"
				}),
				c = e => t => ({
					source: e,
					action: "close",
					actionInfo: s.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "email_collection"
				}),
				a = e => Object.assign({}, s.defaults(e), {
					source: "popup",
					action: r.c.CLICK,
					actionInfo: s.actionInfo(e, {
						settingValue: "footer_2"
					}),
					noun: "save_email_collection"
				}),
				d = e => t => Object.assign({}, s.defaults(t), {
					source: "popup",
					action: r.c.CLICK,
					actionInfo: s.actionInfo(t, {
						reason: e ? "1" : "0",
						settingValue: "footer_2"
					}),
					noun: "email_digest_check"
				}),
				u = e => Object.assign({}, s.defaults(e), {
					source: "popup",
					action: r.c.CLICK,
					actionInfo: s.actionInfo(e, {
						settingValue: "footer_2"
					}),
					noun: "email_settings_link"
				})
		},
		"./src/reddit/helpers/trackers/emailVerification.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var r = n("./src/reddit/selectors/telemetry.ts");
			const s = "tooltip",
				o = e => t => Object.assign({}, Object(r.defaults)(t), {
					action: "view",
					noun: "verification",
					source: e
				}),
				i = e => t => Object.assign({}, Object(r.defaults)(t), {
					action: "close",
					noun: "verification",
					source: e
				}),
				c = (e, t) => n => Object.assign({}, Object(r.defaults)(n), {
					action: "click",
					noun: "verification_".concat(t),
					source: e
				}),
				a = e => t => Object.assign({}, Object(r.defaults)(t), {
					action: "send",
					noun: "verification_email_".concat(e),
					source: "email"
				}),
				d = e => t => Object.assign({}, Object(r.defaults)(t), {
					action: "click",
					noun: "verification_email_".concat(e),
					source: "email"
				}),
				u = () => e => Object.assign({}, Object(r.defaults)(e), {
					action: "confirm",
					noun: "verification_email",
					source: "email"
				})
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getAwardTypeFromAward", (function() {
				return c
			})), n.d(t, "clickGildEvent", (function() {
				return u
			})), n.d(t, "clickRpanGiveAward", (function() {
				return l
			})), n.d(t, "clickAddAward", (function() {
				return b
			})), n.d(t, "viewGildModalEvent", (function() {
				return p
			})), n.d(t, "clickSelectAwardEvent", (function() {
				return m
			})), n.d(t, "viewGiveAwardTooltipEvent", (function() {
				return f
			})), n.d(t, "triggerAnonymousEvent", (function() {
				return g
			})), n.d(t, "clickMessageInputEvent", (function() {
				return O
			})), n.d(t, "typeMessageInputEvent", (function() {
				return h
			})), n.d(t, "clickLearnMoreLinkEvent", (function() {
				return y
			})), n.d(t, "clickQuestionMarkEvent", (function() {
				return j
			})), n.d(t, "clickConfirmAwardEvent", (function() {
				return _
			})), n.d(t, "clickNextButtonEvent", (function() {
				return E
			})), n.d(t, "clickCloseGildModalEvent", (function() {
				return v
			})), n.d(t, "viewSuccessAwardEvent", (function() {
				return I
			}));
			var r = n("./src/reddit/models/Gold/Award.ts"),
				s = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/helpers/isComment.ts");
			const c = e => e.awardType === r.c.Global && e.awardSubType === r.b.Global ? e.id : e.awardType === r.c.Global && e.awardSubType === r.b.Appreciation ? "gid_appreciation" : e.awardType === r.c.Community ? "gid_community" : "gid_mod",
				a = e => ({
					awardId: e.id,
					awardName: e.name,
					numberCoinsToRecipient: e.coinReward,
					type: c(e)
				}),
				d = (e, t) => Object.assign({}, s.defaults(e), {
					comment: s.comment(e, t),
					correlationId: Object(o.c)(o.a.GildingFlow),
					post: s.post(e, t),
					screen: s.screen(e),
					subreddit: s.subreddit(e)
				}),
				u = e => t => Object.assign({}, d(t, e), {
					source: Object(i.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold"
				}),
				l = e => t => Object.assign({}, d(t, e), {
					source: "stream_player",
					action: "click",
					noun: "give_gold"
				}),
				b = e => t => Object.assign({}, d(t, e), {
					source: Object(i.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award"
				}),
				p = (e, t, n) => r => Object.assign({}, d(r, n), {
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				m = (e, t) => n => Object.assign({}, d(n, t), {
					source: "give_gold",
					action: "click",
					noun: c(e),
					goldPurchase: a(e)
				}),
				f = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "view",
					noun: "tooltip"
				}),
				g = (e, t) => n => Object.assign({}, d(n, t), {
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				O = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				h = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				y = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				j = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				_ = (e, t) => n => Object.assign({}, d(n, e), {
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: Object.assign({
						contentType: Object(i.a)(e) ? "comment" : "post"
					}, a(t))
				}),
				E = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				v = e => t => Object.assign({}, d(t, e), {
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				I = (e, t, n) => r => Object.assign({}, d(r, e), {
					source: "give_gold",
					action: "view",
					noun: "success",
					goldPurchase: Object.assign({
						contentType: Object(i.a)(e) ? "comment" : "post",
						numberCoins: t
					}, a(n))
				})
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			var r, s = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(r || (r = {}));
			const i = e => ({
					subreddit: o.subreddit(e),
					userSubreddit: o.userSubreddit(e)
				}),
				c = e => Object.assign({
					source: "subreddit_tooltip",
					noun: r.SubredditInlineTooltip,
					action: s.c.VIEW
				}, i(e)),
				a = e => Object.assign({
					source: "id_card",
					noun: r.EditSubredditIcon,
					action: s.c.CLICK
				}, i(e)),
				d = e => Object.assign({
					source: "id_card",
					noun: r.EditSubredditDescription,
					action: s.c.CLICK
				}, i(e)),
				u = (e, t) => n => Object.assign({
					source: "id_card",
					noun: r.SaveDescription,
					action: s.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					}
				}, i(n)),
				l = (e, t) => Object.assign({
					source: "id_card",
					noun: r.Error,
					action: s.c.VIEW
				}, i(e), o.defaults(e), {
					actionInfo: o.actionInfo(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/lightbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			}));
			var r = n("./src/reddit/constants/tracking.ts"),
				s = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/selectors/platform.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const c = e => ({
					profile: i.profile(e),
					screen: i.screen(e),
					subreddit: i.subreddit(e)
				}),
				a = (e, t, n) => r => Object.assign({
					source: Object(o.i)(r) || n ? "post_lightbox" : "post_detail",
					action: "click",
					noun: t
				}, c(r), {
					post: i.post(r, e)
				}),
				d = (e, t) => n => {
					const r = i.currentPost(n);
					return r ? a(r.id, e, t)(n) : Object.assign({
						source: Object(o.i)(n) || t ? "post_lightbox" : "post_detail",
						action: "click",
						noun: e
					}, c(n))
				},
				u = (e, t) => n => Object(s.a)(Object.assign({}, a(e, t)(n), i.defaults(n))),
				l = e => t => Object.assign({
					source: "id_card",
					action: r.c.CLICK,
					noun: e
				}, c(t), {
					post: i.currentPost(t),
					userSubreddit: i.userSubreddit(t)
				})
		},
		"./src/reddit/helpers/trackers/media.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var r = n("./src/reddit/selectors/telemetry.ts");
			const s = (e, t, n) => s => ({
					source: "videoplayer",
					action: t,
					noun: n,
					post: r.post(s, e),
					media: r.media(s, e),
					profile: r.profile(s),
					subreddit: r.subreddit(s),
					actionInfo: r.mediaActionInfo(s, e),
					correlationId: r.videoCorrelationId()
				}),
				o = e => t => ({
					source: "videoplayer",
					action: "underrun",
					noun: "playback",
					post: r.post(t, e),
					profile: r.profile(t),
					subreddit: r.subreddit(t),
					actionInfo: r.mediaActionInfo(t, e),
					media: r.media(t, e)
				}),
				i = (e, t, n) => o => Object.assign({}, s(e, t, n)(o), {
					timer: r.videoPlayerFirstFrameTimer(o, e),
					media: Object.assign({}, r.media(o, e), r.videoPlayerMaxTimeServed(o, e))
				})
		},
		"./src/reddit/helpers/trackers/post.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return y
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/models/Post/index.ts"),
				o = n("./src/telemetry/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const c = e => e && e.meta && e.meta.name && e.meta.name === r.xb.DUPLICATES,
				a = (e, t, n) => {
					const {
						currentPage: r
					} = e.platform, s = c(r) ? "other_discussions" : "post";
					return Object(o.a)(Object.assign({
						source: s,
						action: "view",
						noun: "post"
					}, i.defaults(e), {
						actionInfo: i.actionInfo(e, {
							position: n
						}),
						post: i.post(e, t),
						profile: i.profile(e),
						media: i.media(e, t),
						screen: i.screen(e),
						subreddit: i.subreddit(e)
					}))
				},
				d = (e, t) => Object(o.a)(Object.assign({
					source: "post",
					action: "view",
					noun: "ad"
				}, i.defaults(e), {
					post: i.post(e, t),
					media: i.media(e, t),
					screen: i.screen(e),
					subreddit: i.subreddit(e)
				})),
				u = (e, t, n, r) => Object(o.a)(Object.assign({
					source: "post",
					action: "consume",
					noun: "post"
				}, i.defaults(e), {
					actionInfo: i.actionInfo(e, {
						position: r
					}),
					post: i.post(e, t, n),
					media: i.media(e, t),
					screen: i.screen(e),
					subreddit: i.subreddit(e)
				})),
				l = (e, t, n, r) => ({
					noun: r,
					post: i.post(e, t),
					source: n
				}),
				b = (e, t, n, r) => {
					const {
						currentPage: o
					} = e.platform;
					if (c(o)) {
						const n = Object(s.m)(o && o.urlParams.partialPostId || "");
						return {
							noun: "post",
							post: i.post(e, n),
							source: "other_discussions",
							targetPost: i.post(e, t)
						}
					}
					return l(e, t, n, r)
				},
				p = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "post";
					return r => {
						const {
							currentPage: s
						} = r.platform, o = c(s) ? b(r, e, n, t) : l(r, e, n, t);
						return Object.assign({}, o, i.defaults(r), {
							action: "click",
							media: i.media(r, e),
							subreddit: i.subreddit(r) || i.subredditByPostOrCommentId(r, e)
						})
					}
				},
				m = (e, t) => n => Object(o.a)(Object.assign({
					source: "post",
					action: "click",
					noun: t
				}, i.defaults(n), {
					post: i.post(n, e),
					media: i.media(n, e),
					screen: i.screen(n),
					session: i.session(n),
					subreddit: i.subreddit(n)
				})),
				f = (e, t) => ({
					post: i.post(e, t),
					profile: i.profile(e)
				}),
				g = e => t => Object.assign({
					action: "pin",
					noun: "post",
					source: "profile"
				}, f(t, e), i.defaults(t)),
				O = e => t => Object.assign({
					action: "unpin",
					noun: "post",
					source: "profile"
				}, f(t, e), i.defaults(t)),
				h = (e, t, n) => r => Object.assign({
					action: "click",
					noun: "vote",
					source: "poll"
				}, i.defaults(r), {
					poll: i.poll(r, e, !0, n),
					post: i.post(r, t),
					subreddit: i.subreddit(r),
					userSubreddit: i.userSubreddit(r)
				}),
				y = (e, t) => n => Object.assign({
					action: "view",
					noun: "results",
					source: "poll"
				}, i.defaults(n), {
					poll: i.poll(n, e, !1),
					post: i.post(n, t),
					subreddit: i.subreddit(n),
					userSubreddit: i.userSubreddit(n)
				})
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "u", (function() {
				return y
			})), n.d(t, "t", (function() {
				return j
			})), n.d(t, "p", (function() {
				return _
			})), n.d(t, "m", (function() {
				return E
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "x", (function() {
				return I
			})), n.d(t, "o", (function() {
				return S
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "l", (function() {
				return w
			})), n.d(t, "k", (function() {
				return P
			})), n.d(t, "w", (function() {
				return D
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "j", (function() {
				return k
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "f", (function() {
				return M
			})), n.d(t, "b", (function() {
				return U
			})), n.d(t, "s", (function() {
				return F
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "v", (function() {
				return G
			}));
			var r = n("./src/reddit/constants/tracking.ts"),
				s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/helpers/media/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/models/PostDraft/index.ts"),
				a = n("./src/reddit/selectors/postDraft.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				u = n("./src/reddit/selectors/user.ts"),
				l = n("./src/telemetry/index.ts"),
				b = n("./src/telemetry/models/PostComposer.ts"),
				p = n("./src/telemetry/models/PostDraft.ts");
			const m = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					crosspost: "crosspost"
				},
				f = e => Object.assign({
					source: "post_composer",
					action: r.c.CLICK
				}, d.defaults(e), {
					screen: d.screen(e),
					correlationId: Object(s.c)(s.a.PostComposer)
				}),
				g = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === i.h.MARKDOWN ? "markdown" : "rte"
				},
				O = e => {
					Object(l.a)(Object.assign({
						noun: "cancel"
					}, f(e)))
				},
				h = e => {
					Object(l.a)(Object.assign({
						noun: "discard"
					}, f(e)))
				},
				y = e => {
					Object(l.a)(Object.assign({
						noun: "subreddit_choice",
						subreddit: d.subreddit(e)
					}, f(e), {
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				j = e => {
					Object(l.a)(Object.assign({
						noun: "subreddit_selector"
					}, f(e)))
				},
				_ = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "post_type_selector",
						postComposer: {
							type: m[t]
						}
					}, f(e)))
				},
				E = () => e => Object.assign({
					noun: "add_option"
				}, f(e)),
				v = () => e => Object.assign({
					noun: "voting_length"
				}, f(e)),
				I = (e, t, n) => {
					"image_upload" === t || "video_upload" === t ? Object(l.a)(Object.assign({
						noun: t
					}, f(e))) : Object(l.a)(Object.assign({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: n ? "on" : "off"
						}
					}, f(e)))
				},
				S = (e, t, n) => {
					Object(l.a)(Object.assign({
						noun: "post",
						subreddit: d.subreddit(e),
						postComposer: Object.assign({
							type: t
						}, g(e, t)),
						post: n ? d.post(e, n) : null
					}, f(e)))
				},
				T = (e, t) => {
					const n = t === i.h.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(l.a)(Object.assign({
						noun: n
					}, f(e)))
				},
				x = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "save",
						subreddit: d.subreddit(e),
						postComposer: Object.assign({
							type: t
						}, g(e, t))
					}, f(e)))
				},
				C = (e, t) => {
					const n = e.uploads[t];
					n.error && Object(l.a)(Object.assign({}, f(e), {
						noun: "media",
						action: r.c.REJECT,
						actionInfo: Object.assign({}, d.actionInfo(e), {
							reason: JSON.stringify(n.error)
						})
					}))
				},
				w = (e, t) => {
					t.forEach(t => {
						const n = Object(o.f)(t.type);
						n && Object(l.a)(Object.assign({}, f(e), {
							action: r.c.DRAG,
							noun: n
						}))
					})
				},
				P = (e, t, n) => {
					Object(l.a)(Object.assign({}, f(e), {
						noun: "input",
						postComposer: {
							inputType: n
						},
						action: t,
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				D = (e, t, n) => {
					Object(l.a)(Object.assign({}, f(e), {
						noun: n,
						action: Object(b.getToggleAction)(t),
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				R = e => {
					Object(l.a)(Object.assign({}, f(e), {
						noun: "hide_oc_description",
						action: r.c.CLICK
					}))
				},
				A = (e, t) => {
					if (t) {
						const n = d.subredditById(e, t);
						if (n) return {
							subreddit: n
						};
						const r = d.profileById(e, t);
						if (r) return {
							profile: r
						}
					}
				},
				k = (e, t) => {
					const {
						draftId: n,
						destSubreddit: r
					} = t, s = Object(u.i)(e), o = Object(a.d)(e, {
						draftId: n
					}), i = {
						authorId: s ? s.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: n || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case c.b.Link:
							i.type = p.DraftType.Link, i.urlLength = t.body.length;
							break;
						case c.b.Markdown:
							i.type = p.DraftType.Self, i.bodyTextLength = t.body.length;
							break;
						case c.b.RichText:
							i.type = p.DraftType.RichText, t.documentStats && (i.bodyTextLength = t.documentStats.textLength, i.numberRteImages = t.documentStats.rteImagesCount, i.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case c.b.Image:
							i.type = p.DraftType.Image;
							break;
						case c.b.Video:
							i.type = p.DraftType.Video
					}
					return Object.assign({
						postDraft: i
					}, A(e, r.id))
				},
				N = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "draft_load"
					}, f(e), k(e, t)))
				},
				L = (e, t) => {
					Object(l.a)(Object.assign({
						noun: t.draftId ? "draft_update" : "draft_create"
					}, f(e), k(e, t)))
				},
				M = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "draft_delete"
					}, f(e), ((e, t) => {
						const n = Object(u.i)(e),
							r = {
								authorId: n ? n.id : void 0,
								createdTimestamp: t.created,
								id: t.id,
								nsfw: t.isNSFW,
								originalContent: t.isOriginalContent,
								spoiler: t.isSpoiler,
								titleLength: t.title.length
							};
						switch (t.kind) {
							case c.b.Link:
								r.type = p.DraftType.Link, r.urlLength = (t.body || "").length;
								break;
							case c.b.Markdown:
								r.type = p.DraftType.Self, r.bodyTextLength = (t.body || "").length;
								break;
							case c.b.RichText:
								r.type = p.DraftType.RichText
						}
						return Object.assign({
							postDraft: r
						}, A(e, t.subredditId))
					})(e, t)))
				},
				U = e => {
					Object(l.a)(Object.assign({}, f(e), {
						noun: "social_connect_link",
						action: r.c.CLICK
					}))
				},
				F = (e, t) => {
					Object(l.a)(Object.assign({}, f(e), {
						noun: "twitter_share_checkbox",
						action: Object(b.getToggleAction)(t)
					}))
				},
				B = (e, t, n) => {
					Object(l.a)(Object.assign({}, f(e), k(e, t), {
						noun: "draft_share",
						action: n ? r.c.ENABLE : r.c.DISABLE
					}))
				},
				G = (e, t, n, r) => {
					Object(l.a)(Object.assign({}, f(e), {
						noun: "suggested_subreddit",
						subreddit: {
							id: n,
							name: r,
							postDifficultyRating: t
						}
					}))
				}
		},
		"./src/reddit/helpers/trackers/postList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			}));
			var r = n("./src/telemetry/index.ts"),
				s = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => Object.assign({}, s.defaults(e), {
					media: s.media(e, t),
					post: s.post(e, t),
					profile: s.profile(e),
					subreddit: s.subreddit(e)
				}),
				i = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "stop",
						noun: "autoplay_initial_load"
					}))
				},
				c = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "complete",
						noun: "autoplay_initial_load"
					}))
				},
				a = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay_initial_load"
					}))
				},
				d = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay_network_load"
					}))
				},
				u = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "consume",
						noun: "autoplay"
					}))
				},
				l = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay"
					}))
				},
				b = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "start",
						noun: "autoplay_buffering"
					}))
				},
				p = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "stop",
						noun: "autoplay"
					}))
				},
				m = (e, t) => {
					Object(r.a)(Object.assign({}, o(e, t), {
						source: "postlist",
						action: "stop",
						noun: "autoplay_buffering"
					}))
				},
				f = (e, t) => {
					Object(r.a)(Object.assign({
						action: "view",
						source: "postlist",
						noun: "bottom"
					}, s.defaults(e), {
						listing: s.listing(e, t),
						subreddit: s.subreddit(e)
					}))
				}
		},
		"./src/reddit/helpers/trackers/premium.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			}));
			var r = n("./src/reddit/selectors/telemetry.ts"),
				s = n("./node_modules/uuid/v4.js"),
				o = n.n(s);
			let i;
			const c = () => i,
				a = () => i = o()(),
				d = () => i = void 0,
				u = "premium_marketing",
				l = () => e => Object.assign({
					source: u,
					action: "click",
					noun: "get_premium",
					correlationId: c()
				}, r.defaults(e)),
				b = () => e => Object.assign({
					source: u,
					action: "click",
					noun: "price",
					correlationId: c()
				}, r.defaults(e)),
				p = () => e => Object.assign({
					source: u,
					action: "click",
					noun: "redeem_code",
					correlationId: c()
				}, r.defaults(e)),
				m = () => e => Object.assign({
					source: u,
					action: "click",
					noun: "manage",
					correlationId: c()
				}, r.defaults(e))
		},
		"./src/reddit/helpers/trackers/profileSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "a", (function() {
				return E
			}));
			var r = n("./node_modules/lodash/pick.js"),
				s = n.n(r),
				o = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/index.ts"),
				a = n("./src/telemetry/models/PostComposer.ts");
			const d = e => Object.assign({
					source: "profile_settings"
				}, Object(i.defaults)(e)),
				u = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
					const n = Object(i.currentProfileModelSelector)(e);
					if (n) return s()(n, ["id", "name", "type", ...t])
				},
				l = e => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "twitter_connect_link",
						action: o.c.CLICK
					}))
				},
				b = e => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "twitter_disconnect_link",
						action: o.c.CLICK
					}))
				},
				p = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "display_twitter_checkbox",
						action: Object(a.getToggleAction)(t)
					}))
				},
				m = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						noun: "twitter_account",
						action: o.c.CLICK,
						profile: {
							id: t.id,
							name: t.username
						}
					}))
				},
				f = e => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, ["display_name", "about", "avatar_url", "cover_url", "nsfw", "content_visible", "communities_visible"]),
						action: o.c.VIEW,
						noun: "settings_page"
					}))
				},
				g = {
					profileIcon: "avatar",
					profileBanner: "cover"
				},
				O = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, ["avatar_url", "cover_url"]),
						action: "upload",
						noun: g[t]
					}))
				},
				h = (e, t) => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, []),
						action: "remove",
						noun: g[t]
					}))
				},
				y = e => {
					Object(c.a)(Object.assign({}, d(e), {
						profile: u(e, ["display_name", "about", "nsfw", "content_visible", "communities_visible"]),
						action: "click",
						noun: "save_settings"
					}))
				},
				j = e => t => Object.assign({}, d(t), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "content_visible"
				}),
				_ = e => t => Object.assign({}, d(t), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "nsfw"
				}),
				E = e => t => Object.assign({}, d(t), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "active_in_communities"
				})
		},
		"./src/reddit/helpers/trackers/screenview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return _
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "m", (function() {
				return T
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "f", (function() {
				return P
			})), n.d(t, "a", (function() {
				return R
			})), n.d(t, "i", (function() {
				return A
			})), n.d(t, "n", (function() {
				return M
			})), n.d(t, "p", (function() {
				return U
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "o", (function() {
				return V
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makePostDraftPageKey/index.ts"),
				o = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				i = n("./src/reddit/helpers/routeKey/index.ts"),
				c = n("./src/reddit/helpers/trackers/postComposer.ts"),
				a = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				d = n("./src/reddit/models/Comment/index.ts"),
				u = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/selectors/profile.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/helpers/correlationIdTracker.ts"),
				m = n("./src/reddit/helpers/trackers/coins.ts"),
				f = n("./src/reddit/helpers/trackers/premium.ts"),
				g = n("./src/reddit/helpers/trackers/searchResults.ts"),
				O = n("./src/reddit/selectors/experiments/searchFix.ts"),
				h = n("./src/reddit/selectors/postDraft.ts"),
				y = n("./src/reddit/selectors/telemetry.ts"),
				j = n("./src/telemetry/index.ts");
			const _ = (e, t, n, c) => {
					const {
						route: l
					} = e, {
						name: b
					} = l.meta;
					if (b) switch (b) {
						case r.xb.COMMENTS: {
							const {
								partialCommentId: r,
								partialPostId: s
							} = e.match.params, a = Object(u.m)(s), l = Object(i.a)(e, t, t.posts.models[a]);
							if (!l) return;
							const b = r && Object(d.e)(r),
								{
									sortToUse: p
								} = Object(o.a)(t, a);
							Object(j.a)(x(l, a, b, n, c, p)(t));
							break
						}
						case r.xb.INDEX:
						case r.xb.LISTING:
						case r.xb.MULTIREDDIT:
						case r.xb.SUBREDDIT: {
							const s = Object(i.d)(e, t);
							if (!s.listingKey) return;
							const {
								params: o,
								queryParams: a
							} = e.match, {
								sort: d = (s.sort ? s.sort : r.N.HOT)
							} = o, u = a.t;
							Object(j.a)(E(s.listingKey, d, n, c, u)(t));
							break
						}
						case r.xb.TOPIC: {
							const s = Object(i.d)(e, t);
							if (!s.listingKey) return;
							const {
								params: o
							} = e.match, a = s.sort ? s.sort : r.O, {
								sort: d = a,
								topicSlug: u
							} = o;
							Object(j.a)(G(s.listingKey, u, d, n, c)(t));
							break
						}
						case r.xb.PROFILE_OVERVIEW: {
							const s = Object(i.e)(e, t);
							if (!s) return;
							const {
								params: o,
								queryParams: a
							} = e.match, {
								sort: d = r.rb
							} = o, u = a.t;
							Object(j.a)(v(s, d, n, c, u)(t));
							break
						}
						case r.xb.PROFILE_POSTS: {
							const s = Object(i.e)(e, t);
							if (!s) return;
							const {
								queryParams: o
							} = e.match, {
								sort: a = r.rb,
								t: d = r.Pb
							} = o;
							Object(j.a)(I(s, a, n, c, d)(t));
							break
						}
						case r.xb.PROFILE_COMMENTS: {
							const s = Object(i.e)(e, t);
							if (!s) return;
							const {
								queryParams: o
							} = e.match, {
								sort: a = r.rb,
								t: d = r.Pb
							} = o;
							Object(j.a)(S(s, a, n, c, d)(t));
							break
						}
						case r.xb.SETTINGS:
							e.match.params.page === r.Kb.Profile ? Object(a.j)(t) : Object(j.a)(N(n, c)(t));
							break;
						case r.xb.POST_CREATION:
							break;
						case r.xb.POST_DRAFT: {
							const {
								draftId: r
							} = e.match.params, o = Object(s.a)(e.match.params);
							if (!o) return;
							D(t, o, r, n, c);
							break
						}
						case r.xb.SUBREDDIT_WIKI:
							Object(j.a)(B(n, c)(t));
							break;
						case r.xb.COINS:
							Object(j.a)(R(n, c)(t));
							break;
						case r.xb.PREMIUM:
							Object(j.a)(A(n, c)(t));
							break;
						case r.xb.APPEAL:
							Object(j.a)(k(n, c)(t));
							break;
						case r.xb.EXPLORE: {
							const r = Object(i.b)(e);
							if (!r) return;
							Object(j.a)(L(r, n, c)(t));
							break
						}
					}
				},
				E = (e, t, n, r, s, o) => i => {
					const {
						api: c
					} = i.listings.postOrder, a = !c.error[e] && !c.pending[e];
					return Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(i), {
						actionInfo: y.actionInfo(i, {
							success: a
						}),
						customFeed: y.customFeed(i),
						listing: y.listing(i, e, {
							sort: t,
							sortTime: s
						}),
						subreddit: y.subreddit(i),
						timer: y.timer(n, r),
						userSubreddit: y.userSubreddit(i),
						adblock: y.adblock(i),
						postFlair: {
							title: o
						}
					})
				},
				v = (e, t, n, r, s) => o => {
					const i = y.listing(o, e);
					i && (i.sort = t, s && (i.sortTime = s));
					const {
						api: c
					} = o.listings.postOrder, a = !c.error[e] && !c.pending[e];
					return Object.assign({
						listing: i,
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(o), {
						actionInfo: y.actionInfo(o, {
							success: a
						}),
						profile: y.profile(o),
						subreddit: y.subreddit(o),
						timer: y.timer(n, r),
						userSubreddit: y.userSubreddit(o),
						adblock: y.adblock(o)
					})
				},
				I = (e, t, n, r, s) => o => {
					const i = y.listing(o, e);
					i && (i.sort = t, s && (i.sortTime = s));
					const {
						api: c
					} = o.listings.postOrder, a = !c.error[e] && !c.pending[e];
					return Object.assign({
						listing: i,
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(o), {
						actionInfo: y.actionInfo(o, {
							success: a
						}),
						profile: y.profile(o),
						subreddit: y.subreddit(o),
						timer: y.timer(n, r),
						userSubreddit: y.userSubreddit(o),
						adblock: y.adblock(o)
					})
				},
				S = (e, t, n, r, s) => o => {
					const i = y.profileComments(o, e);
					i && (i.sort = t, s && (i.sortTime = s));
					const {
						api: c
					} = o.profileCommentsPage, a = !c.error[e] && !c.pending[e];
					return Object.assign({
						listing: i,
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(o), {
						actionInfo: y.actionInfo(o, {
							success: a
						}),
						profile: y.profile(o),
						subreddit: y.subreddit(o),
						timer: y.timer(n, r),
						userSubreddit: y.userSubreddit(o),
						adblock: y.adblock(o)
					})
				},
				T = e => (t, n) => r => {
					const s = !r.profilePrivatePage.api.error[e] && !r.profilePrivatePage.api.pending[e];
					return Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(r), {
						actionInfo: y.actionInfo(r, {
							success: s
						}),
						profile: y.profile(r),
						subreddit: y.subreddit(r),
						timer: y.timer(n, t),
						userSubreddit: y.userSubreddit(r),
						adblock: y.adblock(r)
					})
				},
				x = (e, t, n, r, s, o) => i => {
					const {
						api: c
					} = i.commentsPage, a = !c.error[e] && !c.pending[e], d = Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(i), {
						actionInfo: y.actionInfo(i, {
							success: a
						}),
						post: y.post(i, t),
						profile: y.profile(i),
						subreddit: y.subreddit(i),
						timer: y.timer(r, s),
						userSubreddit: y.userSubreddit(i),
						adblock: y.adblock(i),
						postEvent: y.postEventI13nSelector(i, {
							postId: t
						}),
						postCollection: y.postCollectionI13nSelector(i, {
							postId: t
						}),
						listing: y.listing(i, void 0, {
							sort: o
						})
					});
					return n && (d.comment = y.comment(i, n)), d
				},
				C = (e, t, n) => r => {
					const s = r.creations.api.page.fetched[e],
						o = r.platform.currentPage ? r.platform.currentPage.queryParams.source_id : void 0;
					return Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(r), {
						actionInfo: y.actionInfo(r, {
							success: s
						}),
						post: o ? y.post(r, o) : void 0,
						subreddit: y.subreddit(r),
						timer: y.timer(t, n),
						userSubreddit: y.userSubreddit(r),
						adblock: y.adblock(r)
					})
				},
				w = (e, t, n) => {
					Object(j.a)(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(e), {
						actionInfo: y.actionInfo(e, {
							success: t
						}),
						subreddit: y.subredditById(e, Object(b.G)(e, n)),
						userSubreddit: y.userSubreddit(e),
						adblock: y.adblock(e)
					}))
				},
				P = (e, t, n, r) => {
					Object(j.a)(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(e), {
						profile: y.profileById(e, Object(l.m)(e, r)),
						subreddit: y.subredditById(e, Object(b.G)(e, n)),
						userSubreddit: y.userSubreddit(e),
						adblock: y.adblock(e)
					}))
				},
				D = (e, t, n, r, s) => {
					const o = e.creations.api.page.pending[t],
						i = !e.creations.api.page.error[t] && !o && !!n,
						a = Object(h.h)(e, n);
					Object(j.a)(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(e), {
						actionInfo: y.actionInfo(e, {
							success: i
						}),
						subreddit: y.subreddit(e),
						timer: y.timer(r, s),
						userSubreddit: y.userSubreddit(e),
						adblock: y.adblock(e)
					}, a ? Object(c.j)(e, a) : {}))
				},
				R = (e, t) => n => Object.assign({
					source: "coins_marketing",
					action: "view",
					noun: "page",
					correlationId: m.e()
				}, y.defaults(n), {
					timer: y.timer(e, t),
					adblock: y.adblock(n)
				}),
				A = (e, t) => n => Object.assign({
					source: "premium_marketing",
					action: "view",
					noun: "page",
					correlationId: f.f()
				}, y.defaults(n), {
					timer: y.timer(e, t),
					adblock: y.adblock(n)
				}),
				k = (e, t) => n => Object.assign({
					source: "appeal",
					action: "view",
					noun: "page"
				}, y.defaults(n), {
					timer: y.timer(e, t)
				}),
				N = (e, t) => n => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, y.defaults(n), {
					timer: y.timer(e, t)
				}),
				L = (e, t, n) => r => {
					const {
						api: s
					} = r.listings.listingOrder, o = !s.error[e] && !s.pending[e];
					return Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, y.defaults(r), {
						actionInfo: y.actionInfo(r, {
							success: o
						}),
						timer: y.timer(t, n),
						userSubreddit: y.userSubreddit(r),
						adblock: y.adblock(r)
					})
				},
				M = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, y.defaults(e)),
				U = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, y.defaults(e)),
				F = () => e => Object.assign({
					action: "view",
					source: "global",
					noun: "screen"
				}, y.defaults(e)),
				B = (e, t) => n => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, y.defaults(n), {
					customFeed: y.customFeed(n),
					subreddit: y.subreddit(n),
					timer: y.timer(e, t),
					userSubreddit: y.userSubreddit(n),
					adblock: y.adblock(n)
				}),
				G = (e, t, n, r, s, o) => t => Object.assign({}, E(e, n, r, s, o)(t)),
				V = (e, t, n, s, o) => i => {
					let c = !0;
					if (t.type.indexOf(r.Jb.Posts) > -1) {
						const {
							api: t
						} = i.listings.listingOrder;
						c = c && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(r.Jb.Subreddits) > -1 || t.type.indexOf(r.Jb.Users) > -1) {
						const {
							api: t
						} = i.listings.postOrder;
						c = c && !t.error[e] && !t.pending[e]
					}
					const a = Object(O.c)(i),
						d = o && Object(O.b)(a);
					return Object.assign({}, g.b(i, t), {
						source: "global",
						action: "view",
						noun: "screen",
						actionInfo: y.actionInfo(i, {
							success: c
						}),
						timer: y.timer(n, s),
						search: Object.assign({}, y.search(i, t), d && {
							originElement: o
						})
					}, d && {
						correlationId: Object(p.c)(p.a.SearchResults)
					})
				}
		},
		"./src/reddit/helpers/trackers/searchResults.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "m", (function() {
				return p
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return v
			}));
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/selectors/experiments/searchFix.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const c = "search",
				a = "search_results_best",
				d = (e, t) => {
					const n = i.subreddit(e);
					return {
						screen: i.screen(e),
						subreddit: n && t && t.restrict_sr ? n : null
					}
				},
				u = (e, t) => n => {
					const r = t;
					return r.structureType = "related", Object.assign({
						action: e,
						correlationId: Object(s.c)(s.a.SearchResults),
						noun: "related_search",
						source: c,
						search: i.search(n, r)
					}, d(n))
				},
				l = (e, t, n, r) => s => Object.assign({}, d(s, n), {
					source: c,
					action: "click",
					noun: t,
					actionInfo: i.actionInfo(s, r ? {
						pageType: "search_results_best",
						position: 0
					} : void 0),
					discoveryUnit: r ? i.discoveryUnit(r) : null,
					search: i.search(s, n),
					post: i.post(s, e),
					media: i.media(s, e)
				}),
				b = (e, t, n) => s => {
					let o = !0;
					if (t.type.indexOf(r.Jb.Posts) > -1) {
						const {
							api: t
						} = s.listings.listingOrder;
						o = o && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(r.Jb.Subreddits) > -1 || t.type.indexOf(r.Jb.Users) > -1) {
						const {
							api: t
						} = s.listings.postOrder;
						o = o && !t.error[e] && !t.pending[e]
					}
					return Object.assign({}, d(s, t), {
						source: c,
						action: "view",
						noun: "search_results_post",
						actionInfo: i.actionInfo(s, {
							success: o,
							pageType: "search_results_best",
							position: 0
						}),
						discoveryUnit: i.discoveryUnit(n),
						search: i.search(s, t)
					})
				},
				p = (e, t) => n => ({
					action: "view",
					actionInfo: i.actionInfo(n),
					metaSearch: i.metaSearch(t),
					noun: e,
					screen: i.screen(n),
					search: i.smartSearch(n, t),
					source: c
				}),
				m = (e, t) => n => ({
					action: "click",
					actionInfo: i.actionInfo(n),
					noun: e,
					metaSearch: i.metaSearch(t),
					screen: i.screen(n),
					search: i.smartSearch(n, t),
					source: c
				}),
				f = (e, t, n) => r => ({
					action: t,
					actionInfo: i.actionInfo(r),
					noun: e,
					screen: i.screen(r),
					search: i.search(r, n),
					source: a
				});
			var g;
			! function(e) {
				e.TopResults = "tab_top_results", e.Posts = "tab_posts", e.CommunitiesAndUsers = "tab_communities"
			}(g || (g = {}));
			const O = (e, t) => n => Object.assign({}, d(n, t), {
					source: c,
					action: "click",
					noun: e,
					correlationId: Object(s.c)(s.a.SearchResults),
					actionInfo: i.actionInfo(n),
					search: i.search(n, t)
				}),
				h = (e, t) => n => Object.assign({}, d(n, t), {
					source: c,
					action: "click",
					noun: e,
					correlationId: Object(s.c)(s.a.SearchResults),
					actionInfo: i.actionInfo(n),
					search: i.search(n, t)
				}),
				y = (e, t) => n => ({
					action: "click",
					correlationId: Object(s.c)(s.a.SearchResults),
					noun: e ? r.Ib.ToSubreddit : r.Ib.ToGlobal,
					search: i.search(n, t),
					source: c
				}),
				j = (e, t, n, r) => a => {
					const u = Object(o.c)(a),
						l = r && Object(o.b)(u);
					return Object.assign({}, d(a, n), {
						source: c,
						action: "click",
						noun: "search_result_post",
						correlationId: Object(s.c)(s.a.SearchResults),
						actionInfo: i.actionInfo(a, {
							relativePosition: i.getRelativePostOrder(a, t, e)
						}),
						search: Object.assign({}, i.search(a, n), l && {
							originElement: r
						}),
						post: i.post(a, t)
					})
				},
				_ = (e, t) => n => {
					const r = Object(o.c)(n),
						a = t && Object(o.b)(r);
					return Object.assign({}, d(n, e), {
						source: c,
						action: "click",
						noun: "search_result_subreddit",
						correlationId: Object(s.c)(s.a.SearchResults),
						actionInfo: i.actionInfo(n),
						search: Object.assign({}, i.search(n, e), a && {
							originElement: t
						}),
						subreddit: i.subreddit(n)
					})
				},
				E = (e, t, n, r) => a => {
					const u = Object(o.c)(a),
						l = r && Object(o.b)(u);
					return Object.assign({}, d(a, n), {
						source: c,
						action: "view",
						noun: "search_results_post",
						correlationId: Object(s.c)(s.a.SearchResults),
						actionInfo: i.actionInfo(a, {
							relativePosition: i.getRelativePostOrder(a, t, e),
							position: i.getAbsoluteOrder(a, t, e)
						}),
						search: Object.assign({}, i.search(a, n), l && {
							originElement: r
						}),
						post: i.post(a, t)
					})
				},
				v = (e, t, n) => r => {
					const a = Object(o.c)(r),
						u = n && Object(o.b)(a);
					return Object.assign({}, d(r), {
						source: c,
						action: "click",
						noun: "search_result_".concat(e),
						correlationId: Object(s.c)(s.a.SearchResults),
						actionInfo: i.actionInfo(r),
						search: Object.assign({}, i.search(r, t), u && {
							originElement: n
						}),
						[e]: i[e](r)
					})
				}
		},
		"./src/reddit/helpers/trackers/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			}));
			var r = n("./src/reddit/selectors/telemetry.ts");
			const s = e => t => Object.assign({
					source: e,
					noun: "create_community_button",
					action: "click"
				}, r.defaults(t), {
					actionInfo: r.actionInfo(t, {
						settingValue: t.user.account && t.user.account.isMod ? "existing_mod" : "new_mod"
					})
				}),
				o = (e, t, n) => s => Object.assign({
					source: "community_form",
					noun: "save_community_button",
					action: "click"
				}, r.defaults(s), {
					actionInfo: r.actionInfo(s, {
						settingValue: e
					}),
					subreddit: {
						id: n,
						name: t.name,
						publicDescription: t.publicDescription,
						nsfw: t.over18,
						accessType: t.type,
						topicTagContents: t.allTags
					}
				}),
				i = () => e => Object.assign({
					source: "community_form",
					noun: "cancel",
					action: "click"
				}, r.defaults(e), {
					actionInfo: r.actionInfo(e)
				}),
				c = e => t => Object.assign({
					source: "community_form",
					noun: "error_message",
					action: "view"
				}, r.defaults(t), {
					actionInfo: r.actionInfo(t, {
						reason: e
					})
				})
		},
		"./src/reddit/helpers/trackers/subredditMentions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "e", (function() {
				return E
			}));
			var r, s, o = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/contexts/PageLayer/index.tsx"),
				c = n("./src/reddit/helpers/isComment.ts"),
				a = n("./src/reddit/helpers/isPost.ts"),
				d = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				u = n("./src/reddit/selectors/subreddit.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				b = n("./src/telemetry/models/Outbound.ts");
			! function(e) {
				e.INTERNAL_LINK = "internal_link", e.SUBREDDIT_HOVERCARD = "subreddit_mentions_hovercard", e.HEADER_SUBREDDIT = "header_subreddit", e.HEADER_SUBREDDIT_SUBSCRIBE = "header_subreddit_subscribe", e.HEADER_SUBREDDIT_UNSUBSCRIBE = "header_subreddit_unsubscribe", e.ITEM_POST = "item_post"
			}(r || (r = {})),
			function(e) {
				e.LINK = "link", e.DISCOVERY_UNIT = "discovery_unit"
			}(s || (s = {}));
			const p = e => Object.assign({}, l.defaults(e), {
					source: s,
					screen: l.screen(e),
					discoveryUnit: {
						id: "xd_100",
						name: r.SUBREDDIT_HOVERCARD,
						type: d.f.Listing,
						title: r.SUBREDDIT_HOVERCARD
					}
				}),
				m = (e, t) => {
					let {
						renderingObjectInfo: n,
						pageLayer: r
					} = t;
					if (n && (Object(c.b)(n) || Object(a.b)(n))) return Object(c.b)(n) ? b.SourceElement.Comment : Object(i.w)(r) ? b.SourceElement.PostDetail : Object(i.F)(r) ? b.SourceElement.ListingPostDetail : void 0
				},
				f = (e, t) => {
					const {
						renderingObjectInfo: n
					} = t;
					if (!n || !Object(a.b)(n) && !Object(c.b)(n)) return {};
					const r = Object(a.b)(n) ? n.belongsTo.id : n.subredditId;
					return Object.assign({
						post: l.post(e, n.id),
						subreddit: l.subredditById(e, r)
					}, ((e, t) => {
						const {
							renderingObjectInfo: n,
							subredditName: r
						} = t;
						if (!n || !Object(a.b)(n) && !Object(c.b)(n)) return {
							outbound: void 0
						};
						const s = Object(a.b)(n) ? "postId" : "commentId",
							o = {
								url: "/r/".concat(r, "/"),
								sourceElement: m(0, t),
								subredditName: r,
								[s]: n.id
							},
							i = Object(u.B)(e, {
								subredditName: r
							});
						return i ? {
							outbound: Object.assign({}, o, {
								url: i.url,
								subredditId: i.id
							})
						} : {
							outbound: Object.assign({}, o)
						}
					})(e, t))
				},
				g = e => t => Object.assign({}, (e => Object.assign({}, l.defaults(e), {
					source: s.LINK,
					action: o.c.CLICK,
					noun: r.INTERNAL_LINK
				}))(t), f(t, e)),
				O = e => t => Object.assign({}, p(t), {
					source: "global",
					action: o.c.VIEW,
					noun: r.SUBREDDIT_HOVERCARD,
					subreddit: l.subredditByName(t, e),
					screen: l.screen(t)
				}),
				h = (e, t) => n => Object.assign({}, p(n), {
					source: s.DISCOVERY_UNIT,
					action: o.c.VIEW,
					noun: r.ITEM_POST,
					post: l.post(n, t),
					subreddit: l.subredditByName(n, e),
					screen: l.screen(n)
				}),
				y = (e, t) => n => Object.assign({}, p(n), {
					source: s.DISCOVERY_UNIT,
					action: o.c.CLICK,
					noun: r.ITEM_POST,
					post: l.post(n, t),
					subreddit: l.subredditByName(n, e),
					screen: l.screen(n)
				}),
				j = e => t => Object.assign({}, p(t), {
					subreddit: l.subredditById(t, e) || null,
					source: s.DISCOVERY_UNIT,
					action: o.c.CLICK,
					noun: r.HEADER_SUBREDDIT
				}),
				_ = e => t => Object.assign({}, p(t), {
					subreddit: l.subredditById(t, e) || null,
					source: s.DISCOVERY_UNIT,
					action: o.c.CLICK,
					noun: r.HEADER_SUBREDDIT_SUBSCRIBE
				}),
				E = e => t => Object.assign({}, p(t), {
					subreddit: l.subredditById(t, e) || null,
					source: s.DISCOVERY_UNIT,
					action: o.c.CLICK,
					noun: r.HEADER_SUBREDDIT_UNSUBSCRIBE
				})
		},
		"./src/reddit/i18n/components.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			}));
			var r = n("./node_modules/react/index.js"),
				s = n.n(r);

			function o(e) {
				return s.a.createElement(s.a.Fragment, null, e.children)
			}

			function i(e) {
				return s.a.createElement(s.a.Fragment, null, e.children)
			}

			function c(e) {
				return s.a.createElement(s.a.Fragment, null, 1 === e.count ? e.singular : e.plural)
			}
		},
		"./src/reddit/icons/svgs/CircledPlanet/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => s.a.createElement("svg", o({
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, e), s.a.createElement("path", {
				d: "M15.8286,15.8998 C15.3466,16.3788 12.6326,15.5598 8.5516,11.4798 C4.4706,7.3968 3.6486,4.6858 4.1316,4.2038 C4.3566,3.9788 4.9286,3.9208 5.9126,4.3518 C5.6166,4.5678 5.3306,4.8008 5.0666,5.0658 C5.0536,5.0798 5.0416,5.0948 5.0266,5.1098 C5.5756,6.4268 6.8946,8.4088 9.2596,10.7728 C11.6206,13.1338 13.6046,14.4538 14.9246,15.0028 C14.9376,14.9898 14.9526,14.9778 14.9666,14.9638 C15.2316,14.6988 15.4646,14.4128 15.6786,14.1178 C16.1096,15.1028 16.0526,15.6748 15.8286,15.8998 M16.7526,11.8998 C17.4066,9.5458 16.8136,6.9138 14.9666,5.0658 C13.6436,3.7438 11.8866,3.0148 10.0166,3.0148 C9.3686,3.0148 8.7356,3.1078 8.1286,3.2768 C5.7306,1.7598 3.9176,1.5898 2.7176,2.7898 C1.4036,4.1028 2.0736,6.1918 3.2866,8.1688 C2.6446,10.5128 3.2276,13.1258 5.0666,14.9638 C6.3886,16.2868 8.1456,17.0148 10.0166,17.0148 C10.6536,17.0148 11.2746,16.9178 11.8736,16.7518 C13.0856,17.4938 14.3406,18.0318 15.4316,18.0318 C16.1156,18.0318 16.7366,17.8198 17.2426,17.3138 C18.4416,16.1138 18.2706,14.2988 16.7526,11.8998"
			}))
		},
		"./src/reddit/icons/svgs/VideoApplyNow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1x0QJr7iXMkiGpOnQbAvYN"
			}
		},
		"./src/reddit/icons/svgs/VideoContactUs/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_11XLCF2uLCEj35_lDddpNT"
			}
		},
		"./src/reddit/icons/svgs/VideoGetAQuote/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "Ui8OEQfWnkN9BO2o-qSXV"
			}
		},
		"./src/reddit/icons/svgs/VideoGetShowtimes/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "o2NVVhdZrQ3VeGMHO8aA0"
			}
		},
		"./src/reddit/icons/svgs/VideoInstall/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_3DFi9BDKHWFWnty75sJhyJ"
			}
		},
		"./src/reddit/icons/svgs/VideoLearnMore/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1PkP2GybP9Bh6mN4gmbPN4"
			}
		},
		"./src/reddit/icons/svgs/VideoMute/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r);
			t.a = e => s.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, s.a.createElement("path", {
				d: "M16.41,10.5l1.79-1.79a1,1,0,0,0-1.41-1.41L15,9.09,13.21,7.29a1,1,0,0,0-1.41,1.41l1.79,1.79-1.79,1.79a1,1,0,1,0,1.41,1.41L15,11.91l1.79,1.79a1,1,0,0,0,1.41-1.41Z",
				fill: "#FFFFFF"
			}), s.a.createElement("path", {
				d: "M9.7,1.54a.5.5,0,0,0-.54.09L3.81,6.5H1.5A.5.5,0,0,0,1,7v6a.5.5,0,0,0,.5.5H3.81l5.36,4.87a.5.5,0,0,0,.34.13.49.49,0,0,0,.2,0A.5.5,0,0,0,10,18V2A.5.5,0,0,0,9.7,1.54Z",
				fill: "#FFFFFF"
			}))
		},
		"./src/reddit/icons/svgs/VideoNewPlayButton/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "eI6Ep6BNFA5DZjPWNVb4O"
			}
		},
		"./src/reddit/icons/svgs/VideoPlayNow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1EfHCA6m0dIgLYzGW2aor1"
			}
		},
		"./src/reddit/icons/svgs/VideoReplay/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_3N5UJK0Os17icJ33e54tfY"
			}
		},
		"./src/reddit/icons/svgs/VideoReplay/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/VideoReplay/index.m.less"),
				c = n.n(i);
			t.a = e => s.a.createElement("svg", {
				className: Object(o.a)(c.a.icon, e.className),
				viewBox: "0 0 50 50",
				xmlns: "http://www.w3.org/2000/svg"
			}, s.a.createElement("g", {
				transform: "translate(1 1)"
			}, s.a.createElement("circle", {
				cx: "24",
				cy: "24",
				r: "24",
				fill: "none",
				stroke: "#fff",
				strokeWidth: "1.92"
			}), s.a.createElement("path", {
				fill: "#fff",
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2"
			})))
		},
		"./src/reddit/icons/svgs/VideoSeeMenu/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "G2_89gx6TwcALtRI4k7hc"
			}
		},
		"./src/reddit/icons/svgs/VideoShopNow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2kG3YOJULmYUC8YtVtNO9J"
			}
		},
		"./src/reddit/icons/svgs/VideoSignUp/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1NxifIlpri3Af8fEoxkaUr"
			}
		},
		"./src/reddit/icons/svgs/VideoViewMore/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2X_GdgwreX3clU-MfCHx-Y"
			}
		},
		"./src/reddit/icons/svgs/VideoVolume/index.tsx": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/react/index.js"),
				s = n.n(r);
			t.a = e => s.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, s.a.createElement("path", {
				d: "M12.67,3.1a1,1,0,0,0-.33,2,5,5,0,0,1,0,9.85,1,1,0,0,0,.17,2h.17a7,7,0,0,0,0-13.79Z",
				fill: "#FFFFFF"
			}), s.a.createElement("path", {
				d: "M9.7,1.54a.5.5,0,0,0-.54.09L3.81,6.5H1.5A.5.5,0,0,0,1,7v6a.5.5,0,0,0,.5.5H3.81l5.36,4.87a.5.5,0,0,0,.34.13.49.49,0,0,0,.2,0A.5.5,0,0,0,10,18V2A.5.5,0,0,0,9.7,1.54Z",
				fill: "#FFFFFF"
			}), s.a.createElement("path", {
				d: "M12,10.86a1,1,0,0,0,1,1.73,3,3,0,0,0,0-5.17,1,1,0,0,0-1,1.73,1,1,0,0,1,0,1.72Z",
				fill: "#FFFFFF"
			}))
		},
		"./src/reddit/icons/svgs/VideoWatchNow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "egx9Z9oH6-wpjLKKhAEoM"
			}
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			}));
			var r, s = n("./node_modules/uuid/v4.js"),
				o = n.n(s);
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(r || (r = {}));
			const i = () => o()()
		},
		"./src/reddit/models/Badge/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./src/config.ts");

			function o(e) {
				return "userId" in e
			}

			function i(e) {
				return !(!e.extra || !e.extra.membership) && !!e.extra.membership.included
			}

			function c(e, t, n) {
				const r = n.media[0],
					s = Object.keys(r);
				if (r["0x0"]) return r["0x0"];
				let o = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (s.forEach(n => {
						const s = r[n],
							[i, c] = n.split("x").map(e => parseInt(e));
						(i < o.width && i >= e || c < o.height && c >= t) && (o = {
							height: c,
							width: i,
							url: s
						})
					}), !o.url && s.length) {
					const e = Object.keys(r)[0],
						t = r[e],
						[n, s] = e.split("x").map(e => parseInt(e));
					o = {
						height: s,
						width: n,
						url: t
					}
				}
				return o.url
			}

			function a(e) {
				return e.startsWith("https") ? e : "".concat(s.a.assetPath, "/").concat(e)
			}

			function d(e, t, n) {
				const r = c(e, t, n),
					s = c(2 * e, 2 * t, n);
				return {
					url: a(r),
					url2x: a(s)
				}
			}! function(e) {
				e.First = "p1", e.Second = "p2"
			}(r || (r = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			}));
			var r, s, o = n("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(r || (r = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(s || (s = {}));
			const i = {
					[r.Loyalty]: o.a.First,
					[r.Achievement]: o.a.Second,
					[r.Cosmetic]: void 0
				},
				c = e => e === o.a.First ? r.Loyalty : e === o.a.Second ? r.Achievement : r.Cosmetic
		},
		"./src/reddit/models/Comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			}));
			var r, s, o = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/constants/comments.ts"),
				c = n("./src/reddit/constants/things.ts");
			! function(e) {
				e.User = "user", e.Moderator = "moderator"
			}(r || (r = {})),
			function(e) {
				e.None = "", e.Friend = "F", e.Submitter = "S", e.Moderator = "M", e.Admin = "A", e.Alumni = "special", e.Cake = "cake"
			}(s || (s = {}));
			const a = e => "".concat(c.a).concat(e && e.toLowerCase()),
				d = e => ({
					id: e,
					type: i.a.Comment
				}),
				u = e => e.author === o.z;
			var l;
			! function(e) {
				e.DeletedComment = "DeletedComment", e.Comment = "Comment"
			}(l || (l = {}))
		},
		"./src/reddit/models/DiscoveryUnit/index.ts": function(e, t, n) {
			"use strict";
			var r, s, o, i;
			n.d(t, "f", (function() {
					return r
				})), n.d(t, "e", (function() {
					return s
				})), n.d(t, "d", (function() {
					return o
				})), n.d(t, "h", (function() {
					return c
				})), n.d(t, "k", (function() {
					return a
				})), n.d(t, "i", (function() {
					return d
				})), n.d(t, "l", (function() {
					return u
				})), n.d(t, "c", (function() {
					return l
				})), n.d(t, "n", (function() {
					return b
				})), n.d(t, "o", (function() {
					return p
				})), n.d(t, "s", (function() {
					return m
				})), n.d(t, "a", (function() {
					return f
				})), n.d(t, "b", (function() {
					return g
				})), n.d(t, "m", (function() {
					return O
				})), n.d(t, "j", (function() {
					return h
				})), n.d(t, "q", (function() {
					return y
				})), n.d(t, "r", (function() {
					return j
				})), n.d(t, "t", (function() {
					return _
				})), n.d(t, "p", (function() {
					return E
				})), n.d(t, "g", (function() {
					return v
				})),
				function(e) {
					e.Community = "community", e.CommunityCategory = "community_category", e.FavoriteSubreddits = "favorite_subreddits", e.Listing = "listing", e.RecentlyVisitedSubreddits = "recently_visited_subreddits", e.SubredditListing = "subreddit_listing"
				}(r || (r = {})),
				function(e) {
					e.Comments = "comments", e.Communities = "communities", e.Explore = "explore", e.Frontpage = "front_page", e.Popular = "popular", e.SubredditListing = "subreddit_listing"
				}(s || (s = {})),
				function(e) {
					e.Large = "large", e.Small = "small"
				}(o || (o = {})),
				function(e) {
					e.Wide = "wide", e.Description = "description", e.ActionButton = "action_button", e.SeeMore = "see_more", e.HideItems = "hide_items", e.HideUnit = "hide_unit", e.ShowLess = "show_less", e.PostShowSubredditHeader = "post_show_subreddit_header", e.UnitShowSubredditHeader = "unit_show_subreddit_header", e.PreviewMode = "preview_mode"
				}(i || (i = {}));
			const c = "posts_in_category_rails_hero",
				a = "posts_in_subreddit_hero",
				d = "posts_in_category_rails_small",
				u = "posts_in_subreddit_small",
				l = "community_banner_posts",
				b = "search_posts",
				p = "search_subreddits",
				m = "trending_on_popular",
				f = "best_of_community",
				g = "chaining_similar_subreddits_posts",
				O = "posts_in_subreddit_vertical",
				h = "posts_in_rec_home",
				y = "top_week_posts",
				j = "top_week_posts_large",
				_ = "trending_posts",
				E = "top_month_posts",
				v = "geopopular_posts"
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");

			function r(e, t) {
				return "".concat(e, "-sort[").concat(t.sort, "]-crossposts_only[").concat(t.crossposts_only, "]")
			}
		},
		"./src/reddit/models/Emoji/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			}));
			const r = 24,
				s = 64e3,
				o = 128,
				i = 128,
				c = (e, t, n, r) => Object.assign({
					name: e,
					url: t,
					subredditId: n
				}, r)
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.Twitter = "twitter"
				}(r || (r = {}))
		},
		"./src/reddit/models/FeatureThrottling/index.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "b", (function() {
					return r
				})), n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e[e.TimesPerSession = 0] = "TimesPerSession", e[e.TimesTotal = 1] = "TimesTotal", e[e.TimesPerPeriod = 2] = "TimesPerPeriod", e[e.NthSession = 3] = "NthSession", e[e.Combined = 4] = "Combined"
				}(r || (r = {})),
				function(e) {
					e.And = "and", e.Or = "or"
				}(s || (s = {}))
		},
		"./src/reddit/models/Flair/index.ts": function(e, t, n) {
			"use strict";
			var r, s, o, i, c, a, d, u;
			n.d(t, "c", (function() {
					return r
				})), n.d(t, "f", (function() {
					return s
				})), n.d(t, "e", (function() {
					return o
				})), n.d(t, "a", (function() {
					return i
				})), n.d(t, "d", (function() {
					return c
				})), n.d(t, "b", (function() {
					return a
				})), n.d(t, "h", (function() {
					return d
				})), n.d(t, "g", (function() {
					return u
				})),
				function(e) {
					e.Text = "text", e.Emoji = "emoji"
				}(r || (r = {})),
				function(e) {
					e.Image = "image", e.Meta = "meta", e.Nsfw = "nsfw", e.Oc = "oc", e.Richtext = "richtext", e.Spoiler = "spoiler", e.Text = "text", e.Quarantined = "quarantined"
				}(s || (s = {})),
				function(e) {
					e.Dark = "dark", e.Light = "light"
				}(o || (o = {})),
				function(e) {
					e.Text = "text", e.Emoji = "emoji", e.All = "all"
				}(i || (i = {})),
				function(e) {
					e.UserFlair = "USER_FLAIR", e.LinkFlair = "LINK_FLAIR"
				}(c || (c = {})),
				function(e) {
					e.Left = "left", e.Right = "right"
				}(a || (a = {})),
				function(e) {
					e.Dark = "DARK", e.Light = "LIGHT"
				}(d || (d = {})),
				function(e) {
					e.RIGHT = "RIGHT", e.LEFT = "LEFT"
				}(u || (u = {}))
		},
		"./src/reddit/models/Gold/Award.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "k", (function() {
				return c
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return h
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var r, s, o = n("./src/config.ts"),
				i = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			! function(e) {
				e.Global = "GLOBAL", e.Moderator = "MODERATOR", e.Community = "COMMUNITY"
			}(r || (r = {})),
			function(e) {
				e.Global = "GLOBAL", e.Moderator = "MODERATOR", e.Community = "COMMUNITY", e.Appreciation = "APPRECIATION"
			}(s || (s = {}));
			const c = {
					awardType: r.Global,
					awardSubType: s.Global,
					coinPrice: 100,
					coinReward: 0,
					description: "",
					daysOfDripExtension: 0,
					icon: {
						url: "".concat(o.a.assetPath, "/img/gold/badges/award-silver-medium.png?v=2")
					},
					id: "gid_1",
					isEnabled: !0,
					isNew: !1,
					name: "Silver",
					daysOfPremium: 0
				},
				a = {
					awardType: r.Global,
					awardSubType: s.Global,
					coinPrice: 500,
					coinReward: 100,
					description: "",
					daysOfDripExtension: 0,
					icon: {
						url: "".concat(o.a.assetPath, "/img/gold/badges/award-gold-medium.png?v=2")
					},
					id: "gid_2",
					isEnabled: !0,
					isNew: !1,
					name: "Gold",
					daysOfPremium: 7
				},
				d = {
					awardType: r.Global,
					awardSubType: s.Global,
					coinPrice: 1800,
					coinReward: 0,
					description: "",
					daysOfDripExtension: 31,
					icon: {
						url: "".concat(o.a.assetPath, "/img/gold/badges/award-platinum-medium.png?v=2")
					},
					id: "gid_3",
					isEnabled: !0,
					isNew: !1,
					name: "Platinum",
					daysOfPremium: 31
				},
				u = [c, a, d];
			u.reduce((e, t) => (e[t.id] = t, e), {});
			var l, b;
			! function(e) {
				e.Global = "global", e.Community = "community", e.Moderator = "moderator"
			}(l || (l = {})),
			function(e) {
				e.Global = "global", e.Community = "community", e.Moderator = "moderator", e.Appreciation = "appreciation"
			}(b || (b = {}));
			const p = {
					500: 8,
					1e3: 4,
					2e3: 1,
					5e3: 1,
					1e4: 1,
					4e4: 1
				},
				m = e => {
					const t = e.reduce((e, t) => t.awardType !== r.Community ? e : (e[t.coinPrice] = (e[t.coinPrice] || 0) + 1, e), {}),
						n = e.map(e => ({
							price: e.coinPrice,
							filled: !0,
							award: e
						}));
					return Object.keys(p).forEach(e => {
						const r = t[e] || 0,
							s = Math.max(p[e] - r, 0);
						s > 0 && n.push({
							filled: !1,
							price: parseInt(e),
							quantity: s
						})
					}), n
				},
				f = e => {
					const t = e.reduce((e, t) => t.awardType !== r.Community ? e : (e[t.coinPrice] = (e[t.coinPrice] || 0) + 1, e), {});
					return Object.keys(p).reduce((e, n) => {
						const r = t[n] || 0;
						return p[n] - r > 0 ? [...e, parseInt(n)] : e
					}, [])
				};

			function g(e) {
				return e.sort((e, t) => e.awardType === r.Moderator && t.awardType !== r.Moderator ? -1 : t.awardType === r.Moderator && e.awardType !== r.Moderator ? 1 : t.coinPrice - e.coinPrice)
			}

			function O(e) {
				const {
					count: t,
					iconUrl: n,
					resizedIcons: r
				} = e, s = i(e, ["count", "iconUrl", "resizedIcons"]);
				let o, c;
				for (const {
						url: i,
						width: a
					} of r || []) 32 === a && (o = {
					url: i
				}), 128 === a && (c = {
					url: i
				});
				return Object.assign({}, s, {
					icon: {
						url: n
					},
					icon32: o,
					icon128: c,
					awardType: s.awardType.toUpperCase(),
					awardSubType: s.awardSubType.toUpperCase()
				})
			}

			function h(e, t) {
				const {
					awardType: n,
					awardSubType: r,
					icon: s,
					icon32: o,
					icon128: c
				} = e, a = i(e, ["awardType", "awardSubType", "icon", "icon32", "icon128"]), d = [];
				return o && d.push({
					height: 32,
					url: o.url,
					width: 32
				}), c && d.push({
					height: 128,
					url: c.url,
					width: 128
				}), Object.assign({
					awardType: n.toLowerCase(),
					awardSubType: r ? r.toLowerCase() : b.Global,
					count: t,
					iconUrl: s.url,
					resizedIcons: d
				}, a)
			}
		},
		"./src/reddit/models/Gold/Coins/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			var r = n("./src/config.ts");
			const s = {
					coins500: {
						coins: 500,
						pennies: 199,
						assetPath: "".concat(r.a.assetPath, "/img/gold/coins-package-500.png")
					},
					coins1100: {
						coins: 1100,
						pennies: 399,
						assetPath: "".concat(r.a.assetPath, "/img/gold/coins-package-1100.png"),
						percentBonus: 10
					},
					coins1800: {
						coins: 1800,
						pennies: 599,
						assetPath: "".concat(r.a.assetPath, "/img/gold/coins-package-1800.png"),
						percentBonus: 20
					},
					coins7200: {
						coins: 7200,
						pennies: 1999,
						assetPath: "".concat(r.a.assetPath, "/img/gold/coins-package-7200.png"),
						percentBonus: 43
					},
					coins40000: {
						coins: 4e4,
						pennies: 9999,
						assetPath: "".concat(r.a.assetPath, "/img/gold/coins-package-40000.png"),
						percentBonus: 59
					},
					coinsVariable: {
						coins: 1 / 0,
						pennies: 1 / 0,
						assetPath: "".concat(r.a.assetPath, "/img/gold/coins-package-40000.png")
					}
				},
				o = (e, t) => {
					for (const n in s) {
						if ("coins500" === n) continue;
						const r = s[n];
						if (t - r.coins <= e) return r
					}
					return s.coins40000
				},
				i = e => {
					const t = s.coins40000;
					if (e <= t.coins) return o(0, e);
					const n = t.pennies / t.coins,
						r = s.coinsVariable;
					return r.coins = e, r.pennies = Math.ceil(n * e), r
				}
		},
		"./src/reddit/models/GqlTopLevelField.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.Comment = "Comment", e.Multireddit = "Multireddit", e.PostInfo = "PostInfo", e.Profile = "Profile", e.RedditorInfo = "RedditorInfo", e.Subreddit = "Subreddit", e.UnavailableSubreddit = "UnavailableSubreddit"
				}(r || (r = {}))
		},
		"./src/reddit/models/Live/index.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "b", (function() {
					return r
				})), n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Ama = "ama", e.Announcement = "announcement", e.Document = "document", e.Moderation = "moderation", e.Snoo = "snoo"
				}(r || (r = {})),
				function(e) {
					e.Ama = "AMA", e.Announcement = "ANNOUNCEMENT", e.Document = "DOCUMENT", e.Moderation = "MODERATION", e.Snoo = "SNOO"
				}(s || (s = {}))
		},
		"./src/reddit/models/Media/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "t", (function() {
				return r
			})), n.d(t, "D", (function() {
				return i
			})), n.d(t, "E", (function() {
				return c
			})), n.d(t, "B", (function() {
				return a
			})), n.d(t, "C", (function() {
				return d
			})), n.d(t, "n", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "w", (function() {
				return g
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "o", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "s", (function() {
				return I
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "q", (function() {
				return x
			})), n.d(t, "v", (function() {
				return C
			})), n.d(t, "u", (function() {
				return w
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "x", (function() {
				return R
			})), n.d(t, "A", (function() {
				return A
			})), n.d(t, "y", (function() {
				return k
			})), n.d(t, "z", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./node_modules/url/url.js"),
				o = n.n(s);
			! function(e) {
				e.YouTube = "YouTube", e.Vimeo = "Vimeo", e.BandCamp = "BandCamp", e.Gfycat = "Gfycat", e.GfycatOld = "gfycat", e.Giphy = "Giphy", e.Imgur = "Imgur", e.SoundCloud = "SoundCloud", e.Spotify = "Spotify", e.Streamable = "Streamable", e.Twitch = "Twitch.tv", e.Twitter = "Twitter", e.IFrameEmbed = "iframe embed"
			}(r || (r = {}));
			const i = e => "text" === e.type,
				c = e => "video" === e.type,
				a = e => "image" === e.type,
				d = e => "rtjson" === e.type,
				u = {
					TEXT: "text",
					VIDEO: "video",
					IMAGE: "image",
					EMBED: "embed",
					GIFVIDEO: "gifvideo",
					RTJSON: "rtjson"
				},
				l = new Set([u.TEXT, u.IMAGE, u.RTJSON]),
				b = 512,
				p = 250,
				m = 60,
				f = 0,
				g = 608,
				O = .5625,
				h = 869,
				y = 273,
				j = 486,
				_ = 700,
				E = 822,
				v = 363,
				I = 645,
				S = new Set([r.Gfycat, r.GfycatOld, r.Giphy, r.SoundCloud, r.Spotify, r.Twitter, r.Vimeo, r.YouTube]),
				T = new Set([r.BandCamp, r.Gfycat, r.GfycatOld, r.Giphy, r.Imgur, r.SoundCloud, r.Spotify, r.Streamable, r.Twitch, r.Twitter, r.YouTube, r.Vimeo]),
				x = new Set([r.SoundCloud, r.Spotify, r.Streamable, r.Twitter, r.Vimeo, r.YouTube]),
				C = new Set([r.Gfycat, r.GfycatOld, r.Imgur]),
				w = ["gif", "jpeg", "jpg", "png", "tiff"],
				P = new Set([u.VIDEO, u.GIFVIDEO, u.EMBED]);
			var D, R;
			! function(e) {
				e.Mute = "mute", e.Pause = "pause", e.Play = "play"
			}(D || (D = {})),
			function(e) {
				e.Pause = "pauseVideo", e.Play = "playVideo", e.Mute = "mute"
			}(R || (R = {}));
			const A = e => e.source ? e.source.url : e.media && e.media.type !== u.VIDEO && e.media.content ? e.media.content : "",
				k = e => {
					const t = o.a.parse(e);
					if (t && t.pathname) return t.pathname.split("/")[1]
				},
				N = e => {
					if (!c(e)) return;
					const t = e;
					let n;
					if (t.hlsUrl) n = t.hlsUrl;
					else {
						if (!t.dashUrl) return;
						n = t.dashUrl
					}
					return k(n)
				}
		},
		"./src/reddit/models/ModQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			var r = n("./src/reddit/helpers/isPost.ts"),
				s = n("./src/reddit/models/Flair/index.ts");
			const o = 1;
			var i;
			! function(e) {
				e.Approve = "approve", e.Flair = "flair", e.IgnoreReports = "ignore_reports", e.Lock = "lock", e.MarkNSFW = "mark_nsfw", e.RemovalReason = "removal_reason", e.Remove = "remove", e.Spam = "spam", e.Spoiler = "spoiler", e.UnignoreReports = "unignore_reports", e.Unlock = "unlock", e.UnmarkNSFW = "unmark_nsfw", e.Unspoiler = "unspoiler"
			}(i || (i = {}));
			const c = {},
				a = {
					ignore_reports: i.UnignoreReports,
					lock: i.Unlock,
					mark_nsfw: i.UnmarkNSFW,
					remove: i.Approve,
					spam: i.Approve,
					spoiler: i.Unspoiler,
					unignore_reports: i.IgnoreReports,
					unlock: i.Lock,
					unmark_nsfw: i.MarkNSFW,
					unspoiler: i.Spoiler
				},
				d = (e, t, n, o, a) => {
					switch (t) {
						case "approve": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									approvedBy: o,
									isApproved: !0,
									isRemoved: !1,
									isSpam: !1,
									bannedBy: null,
									modNote: null,
									modReasonBy: null,
									modRemovalReason: null,
									numReports: 0
								}
							}), e
						}
						case "flair": {
							const t = {};
							return n.forEach(n => {
								if (Object(r.a)(n)) {
									const r = e[n].flair.filter(e => e.type === s.f.Nsfw || e.type === s.f.Spoiler);
									a && a.flair && r.push(a.flair), t[n] = {
										flair: r
									}
								}
							}), t
						}
						case "ignore_reports": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									ignoreReports: !0
								}
							}), e
						}
						case "lock": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									isLocked: !0
								}
							}), e
						}
						case "mark_nsfw": {
							const t = {},
								o = {
									text: "nsfw",
									type: s.f.Nsfw
								};
							return n.forEach(n => {
								if (Object(r.a)(n)) {
									const r = e[n],
										s = r.isNSFW ? r.flair : r.flair ? [...r.flair, o] : {
											[n]: o
										};
									t[n] = {
										isNSFW: !0,
										flair: s
									}
								}
							}), t
						}
						case "remove": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									approvedBy: null,
									isApproved: !1,
									isRemoved: !0,
									isSpam: !1,
									bannedBy: o
								}
							}), e
						}
						case "spam": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									approvedBy: null,
									isApproved: !1,
									isRemoved: !1,
									isSpam: !0,
									bannedBy: o
								}
							}), e
						}
						case "spoiler": {
							const t = {},
								o = {
									text: "spoiler",
									type: s.f.Spoiler
								};
							return n.forEach(n => {
								if (Object(r.a)(n)) {
									const r = e[n],
										s = r.isSpoiler ? r.flair : r.flair ? [...r.flair, o] : {
											[n]: o
										};
									t[n] = {
										isSpoiler: !0,
										flair: s
									}
								}
							}), t
						}
						case "unignore_reports": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									ignoreReports: !1
								}
							}), e
						}
						case "unlock": {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									isLocked: !1
								}
							}), e
						}
						case "unmark_nsfw": {
							const t = {};
							return n.forEach(n => {
								if (Object(r.a)(n)) {
									const r = e[n],
										o = r.flair ? r.flair.filter(e => e.type !== s.f.Nsfw) : null;
									t[n] = {
										isNSFW: !1,
										flair: o
									}
								}
							}), t
						}
						case "unspoiler": {
							const t = {};
							return n.forEach(n => {
								if (Object(r.a)(n)) {
									const r = e[n],
										o = r.flair ? r.flair.filter(e => e.type !== s.f.Spoiler) : null;
									t[n] = {
										isSpoiler: !1,
										flair: o
									}
								}
							}), t
						}
						case i.RemovalReason: {
							const e = {};
							return n.forEach(t => {
								e[t] = {
									modNote: a && a.modNote,
									modReasonBy: o,
									modRemovalReason: a && a.removalReason
								}
							}), e
						}
						default:
							return c
					}
				}
		},
		"./src/reddit/models/ModeratingSubreddits/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./node_modules/lodash/snakeCase.js"),
				o = n.n(s);
			! function(e) {
				e.access = "access", e.config = "config", e.flair = "flair", e.mail = "mail", e.posts = "posts", e.wiki = "wiki", e.chatConfig = "chatConfig", e.chatOperator = "chatOperator", e.all = "all"
			}(r || (r = {}));
			const i = Object.freeze({
					all: !0,
					access: !0,
					chatConfig: !0,
					chatOperator: !0,
					config: !0,
					flair: !0,
					mail: !0,
					posts: !0,
					wiki: !0
				}),
				c = i,
				a = e => {
					return Object.keys(e).map(t => (e[t] ? "+" : "-") + o()(t)).join(",")
				}
		},
		"./src/reddit/models/MonthsToMinutes/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			const r = 9,
				s = 10,
				o = 2;
			var i, c, a, d;
			! function(e) {
				e.Home = "home_active", e.SubscribeFeed = "subscribe_feed", e.SubscribeIdCard = "subscribe_id", e.SubscribeReminder = "subscribe_reminder", e.Vote = "vote", e.VoteReminder = "vote_reminder", e.VoteSuccess = "vote_success"
			}(i || (i = {})),
			function(e) {
				e[e.Welcome = 0] = "Welcome", e[e.Subscribe = 1] = "Subscribe", e[e.Vote = 2] = "Vote", e[e.Signup = 3] = "Signup"
			}(c || (c = {})),
			function(e) {
				e.Subscribe = "Subscribe", e.Vote = "Vote"
			}(a || (a = {})),
			function(e) {
				e.Initial = "initial", e.BannerVisible = "bannerVisible", e.HomeVisited = "homeVisited"
			}(d || (d = {}))
		},
		"./src/reddit/models/Multireddit/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			}));
			const r = 50,
				s = 500,
				o = 2;
			var i, c;

			function a(e) {
				return "string" == typeof e.url
			}! function(e) {
				e.Hidden = "hidden", e.Private = "private", e.Public = "public"
			}(i || (i = {})),
			function(e) {
				e.TooShort = "tooshort", e.SameName = "samename", e.Generic = "generic"
			}(c || (c = {}));
			const d = (e, t) => "/user/".concat(e, "/m/").concat(t, "/").toLowerCase(),
				u = e => /^\/user\/([^/]+)\//.exec(e)[1];

			function l(e) {
				return !!e.subredditIds || !!e.profileIds
			}
		},
		"./src/reddit/models/Option/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const r = e => !e.id,
				s = e => !!e.id,
				o = (e, t) => r(e) && r(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!s(e) || !s(t)) && e.id === t.id
		},
		"./src/reddit/models/Poll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var r, s, o = n("./node_modules/bignumber.js/bignumber.js");
			! function(e) {
				e.GovGeneric = "governance:generic", e.ReplaceTopMod = "governance:replace-top-mod", e.Spinoff = "governance:spin-off", e.GA = "ga"
			}(r || (r = {})),
			function(e) {
				e.ByVoters = "byVoters", e.ByVotingPower = "byVotingPower"
			}(s || (s = {}));
			const i = {
				[r.ReplaceTopMod]: () => [{
					text: "Yes"
				}, {
					text: "No"
				}],
				[r.Spinoff]: e => [{
					text: e ? "Yes, I'd like to join r/".concat(e) : "Yes, I'd like to join the new community"
				}, {
					text: "No"
				}]
			};

			function c(e, t) {
				return !!e.options.filter(e => t.options[e.id].userSelected).length
			}

			function a(e, t) {
				return new Date(e.endsAt).getTime() < Date.now() || c(e, t)
			}

			function d(e, t) {
				let n = e.options[0],
					r = new o.BigNumber(t.options[n.id].votes);
				for (const s of e.options) {
					const e = new o.BigNumber(t.options[s.id].votes);
					e.isGreaterThan(r) && (n = s, r = e)
				}
				return n
			}

			function u(e) {
				switch (e.type) {
					case r.GovGeneric:
					case r.ReplaceTopMod:
					case r.Spinoff:
						return !0;
					default:
						return !1
				}
			}
		},
		"./src/reddit/models/Post/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "g", (function() {
				return s
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "n", (function() {
				return u
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "l", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "k", (function() {
				return _
			}));
			var r, s, o = n("./src/reddit/constants/posts.ts"),
				i = n("./src/reddit/constants/things.ts"),
				c = n("./src/reddit/models/PublicAccessNetwork/index.ts"),
				a = n("./src/lib/constants/index.ts");
			! function(e) {
				e.Chat = "CHAT", e.Comment = "COMMENT"
			}(r || (r = {})),
			function(e) {
				e.AntiEvilOps = "anti_evil_ops", e.Author = "author", e.AuthorDeleted = "deleted", e.AutomodFiltered = "automod_filtered", e.CommunityOps = "community_ops", e.ContentTakedown = "content_takedown", e.CopyrightTakedown = "copyright_takedown", e.Moderator = "moderator", e.Reddit = "reddit"
			}(s || (s = {}));
			const d = e => "".concat(i.b).concat(e && e.toLowerCase()),
				u = e => e.startsWith(i.b) ? e.substr(i.b.length) : e,
				l = e => e === a.z;
			var b, p, m, f, g, O;
			! function(e) {
				e.AdPost = "AdPost", e.DeletedProfilePost = "DeletedProfilePost", e.DeletedSubredditPost = "DeletedSubredditPost", e.ProfilePost = "ProfilePost", e.SubredditPost = "SubredditPost"
			}(b || (b = {})),
			function(e) {
				e.MOD_APPROVED = "MOD_APPROVED", e.MOD_REMOVED = "MOD_REMOVED", e.MOD_SPAMMED = "MOD_SPAMMED", e.ADMIN_REMOVED = "ADMIN_REMOVED", e.ADMIN_APPROVED = "ADMIN_APPROVED", e.ADMIN_SPAMMED = "ADMIN_SPAMMED"
			}(p || (p = {})),
			function(e) {
				e.ImageAsset = "ImageAsset", e.VideoAsset = "VideoAsset"
			}(m || (m = {})),
			function(e) {
				e.Post = "POST", e.Comment = "COMMENT"
			}(f || (f = {})),
			function(e) {
				e.Embed = "EMBED", e.Image = "IMAGE", e.Video = "VIDEO", e.Gifvideo = "GIFVIDEO"
			}(g || (g = {})),
			function(e) {
				e.Richtext = "RICHTEXT", e.Markdown = "MARKDOWN"
			}(O || (O = {}));
			const h = e => e.belongsTo.type === o.a.PROFILE,
				y = e => e.belongsTo.type === o.a.SUBREDDIT,
				j = e => !!e.source && Object(c.a)(e.source.url),
				_ = e => e.isStickied
		},
		"./src/reddit/models/PostCollection/index.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.TIMELINE = "TIMELINE", e.GALLERY = "GALLERY"
				}(r || (r = {}))
		},
		"./src/reddit/models/PostCreationForm/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return s
			})), n.d(t, "n", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "r", (function() {
				return c
			})), n.d(t, "v", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "q", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "o", (function() {
				return E
			})), n.d(t, "s", (function() {
				return v
			})), n.d(t, "t", (function() {
				return I
			})), n.d(t, "u", (function() {
				return S
			})), n.d(t, "i", (function() {
				return T
			}));
			var r = n("./src/reddit/models/Upload/index.ts");
			const s = Object(r.e)(r.b.POST_CREATION_MEDIA),
				o = Object(r.e)(r.b.POST_CREATION_VIDEO_POSTER),
				i = {
					isProfile: !1,
					name: ""
				};
			var c;
			! function(e) {
				e[e.Post = 0] = "Post", e[e.Draft = 1] = "Draft", e[e.ScheduledPost = 2] = "ScheduledPost"
			}(c || (c = {}));
			const a = ["title", "body", "link", "flair"],
				d = e => a.includes(e);
			var u, l, b, p, m, f, g;
			! function(e) {
				e.MARKDOWN = "markdown", e.RICH_TEXT = "richtext"
			}(u || (u = {})),
			function(e) {
				e.POST_CREATION = "POST_CREATION", e.POST_EDITING = "POST_EDITING"
			}(l || (l = {})),
			function(e) {
				e.CLICK = "click", e.TYPE = "type"
			}(b || (b = {})),
			function(e) {
				e.TITLE = "title", e.BODY = "body", e.URL = "url"
			}(p || (p = {})),
			function(e) {
				e.CROSSPOST = "crosspost", e.LINK = "link", e.RICH_TEXT = "richText", e.MARKDOWN = "markdown", e.MEDIA = "media", e.VIDEO_GIF = "videogif", e.SELF = "self", e.POLL = "poll"
			}(m || (m = {})),
			function(e) {
				e.ImageWillBeRemoved = "SrChangePrompt_ImageWillBeRemoved", e.VideoWillBeRemovedMediaNotAllowed = "SrChangePrompt_VideoWillBeRemovedMediaNotAllowed", e.VideoWillBeRemovedTooLongForGif = "SrChangePrompt_VideoWillBeRemovedTooLongForGif"
			}(f || (f = {})),
			function(e) {
				e.POST_OVERFLOW_MENU = "postOverflowMenu", e.COLLECTION_INFO_POST = "colletionInfoPost"
			}(g || (g = {}));
			const O = "POST_DRAFTS_MODAL_ID",
				h = "COLLECTIONS_LIST_MODAL_ID",
				y = "CREATE_COLLECTION_MODAL_ID",
				j = "DISCARD_POST_ON_CREATE_POST_MODAL_ID",
				_ = "EVENT_SCHEDULE_PICKER_MODAL_ID",
				E = "POST_SCHEDULE_PICKER_MODAL_ID",
				v = (e, t, n) => "".concat(_, "-[postId: ").concat(e, "]-isOverlay[").concat(t, "]-pos[").concat(n, "]"),
				I = (e, t) => "".concat(h, "-[postId: ").concat(e, "]-isOverlay[").concat(t, "]"),
				S = (e, t) => "".concat(y, "-[postId: ").concat(e, "]-isOverlay[").concat(t, "]");
			var T;
			! function(e) {
				e.Now = "now", e.AtEventTime = "atEventTime"
			}(T || (T = {}))
		},
		"./src/reddit/models/PostDraft/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return i
			}));
			var r, s, o = n("./src/lib/constants/index.ts");
			! function(e) {
				e[e.Image = 0] = "Image", e[e.Link = 1] = "Link", e[e.Markdown = 2] = "Markdown", e[e.RichText = 3] = "RichText", e[e.Video = 4] = "Video"
			}(r || (r = {})),
			function(e) {
				e[e.replyToPost = 0] = "replyToPost", e[e.replyToComment = 1] = "replyToComment", e[e.edit = 2] = "edit"
			}(s || (s = {}));
			const i = {
				[r.Image]: o.Fb.MEDIA,
				[r.Link]: o.Fb.LINK_ONLY,
				[r.Markdown]: o.Fb.POST,
				[r.RichText]: o.Fb.POST,
				[r.Video]: o.Fb.MEDIA
			}
		},
		"./src/reddit/models/PostRequirements/index.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "b", (function() {
					return r
				})), n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.None = "NONE", e.Whitelist = "WHITELIST", e.Blacklist = "BLACKLIST"
				}(r || (r = {})),
				function(e) {
					e.None = "NONE", e.Required = "REQUIRED", e.NotAllowed = "NOT_ALLOWED"
				}(s || (s = {}))
		},
		"./src/reddit/models/Product/index.ts": function(e, t, n) {
			"use strict";
			var r;

			function s(e) {
				return e.substring(e.lastIndexOf("|") + 1)
			}
			n.d(t, "a", (function() {
					return r
				})), n.d(t, "b", (function() {
					return s
				})),
				function(e) {
					e.Badge = "badge", e.EmotesPack = "emotes_pack", e.Giphy = "giphy", e.Membership = "membership"
				}(r || (r = {}))
		},
		"./src/reddit/models/Profile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var r;
			! function(e) {
				e.Downvoted = "downvoted", e.Hidden = "hidden", e.Saved = "saved", e.Upvoted = "upvoted", e.ReceivedGildings = "gilded", e.GivenGildings = "given"
			}(r || (r = {}))
		},
		"./src/reddit/models/Profile/mock.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./src/config.ts"),
				s = n("./src/reddit/models/Subreddit/index.ts");
			const o = {
				t5_100: {
					id: "t5_100",
					isNSFW: !1,
					displayText: "u/cfb",
					name: "cfb",
					title: "CFB Title",
					type: s.c.User,
					url: "/user/cfb",
					subscribers: 1,
					icon: {
						url: "".concat(r.a.assetPath, "/img/placeholder_gradient_light-280.png"),
						width: 120,
						height: 120
					}
				},
				t5_200: {
					id: "t5_200",
					isNSFW: !1,
					displayText: "u/test",
					name: "test",
					title: "Test User Title",
					type: s.c.User,
					url: "/user/test",
					subscribers: 10,
					icon: {
						url: "".concat(r.a.assetPath, "/img/placeholder_gradient_light-280.png"),
						width: 120,
						height: 120
					}
				},
				t5_300: {
					id: "t5_200",
					isNSFW: !1,
					displayText: "u/shitty_watercolour",
					name: "shitty_watercolour",
					title: "Shitty_Watercolour Title",
					type: s.c.User,
					url: "/user/shitty_watercolour",
					subscribers: 20,
					icon: {
						url: "".concat(r.a.assetPath, "/img/placeholder_gradient_light-280.png"),
						width: 120,
						height: 120
					}
				}
			}
		},
		"./src/reddit/models/PublicAccessNetwork/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var r, s = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			! function(e) {
				e.NOT_STARTED = "NOT_STARTED", e.PUBLISHED = "PUBLISHED", e.IS_LIVE = "IS_LIVE", e.DISCONNECTED = "DISCONNECTED", e.KILLED = "KILLED", e.PURGED = "PURGED", e.ENDED = "ENDED"
			}(r || (r = {}));
			const o = e => !!e && e.toLowerCase().startsWith(s.W) && e.toLowerCase().endsWith(s.V)
		},
		"./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(r.a)(e, {
				emotes_as_images: !0
			})
		},
		"./src/reddit/models/RichTextJson/addRTJParam.ts": function(e, t, n) {
			"use strict";
			var r = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(r.a)(e, {
				rtj: "only"
			})
		},
		"./src/reddit/models/RichTextJson/index.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "j", (function() {
					return r
				})), n.d(t, "A", (function() {
					return s
				})), n.d(t, "w", (function() {
					return o
				})), n.d(t, "n", (function() {
					return i
				})), n.d(t, "o", (function() {
					return c
				})), n.d(t, "g", (function() {
					return a
				})), n.d(t, "v", (function() {
					return d
				})), n.d(t, "y", (function() {
					return u
				})), n.d(t, "B", (function() {
					return l
				})), n.d(t, "C", (function() {
					return b
				})), n.d(t, "x", (function() {
					return p
				})), n.d(t, "u", (function() {
					return m
				})), n.d(t, "k", (function() {
					return f
				})), n.d(t, "l", (function() {
					return g
				})), n.d(t, "b", (function() {
					return O
				})), n.d(t, "c", (function() {
					return h
				})), n.d(t, "q", (function() {
					return y
				})), n.d(t, "p", (function() {
					return j
				})), n.d(t, "e", (function() {
					return _
				})), n.d(t, "f", (function() {
					return E
				})), n.d(t, "d", (function() {
					return v
				})), n.d(t, "z", (function() {
					return I
				})), n.d(t, "h", (function() {
					return S
				})), n.d(t, "m", (function() {
					return T
				})), n.d(t, "s", (function() {
					return C
				})), n.d(t, "a", (function() {
					return w
				})), n.d(t, "r", (function() {
					return P
				})), n.d(t, "D", (function() {
					return D
				})), n.d(t, "t", (function() {
					return R
				})), n.d(t, "i", (function() {
					return A
				})), n.d(t, "F", (function() {
					return k
				})), n.d(t, "E", (function() {
					return N
				})),
				function(e) {
					e[e.bold = 1] = "bold", e[e.italic = 2] = "italic", e[e.underline = 4] = "underline", e[e.strikethrough = 8] = "strikethrough", e[e.subscript = 16] = "subscript", e[e.superscript = 32] = "superscript", e[e.monospace = 64] = "monospace"
				}(r || (r = {}));
			const s = "text",
				o = "raw",
				i = "br",
				c = "link",
				a = "c/",
				d = "p/",
				u = "r/",
				l = "u/",
				b = "@",
				p = "spoilertext",
				m = "par",
				f = "h",
				g = "hr",
				O = "blockquote",
				h = "code",
				y = "li",
				j = "list",
				_ = "L",
				E = "R",
				v = "C",
				I = "table",
				S = "embed",
				T = "img";
			var x;
			! function(e) {
				e.Valid = "valid", e.Unprocessed = "unprocessed", e.Failed = "failed", e.Invalid = "invalid"
			}(x || (x = {}));
			const C = "Image",
				w = "gif",
				P = "AnimatedImage",
				D = "video",
				R = "RedditVideo",
				A = {
					document: []
				},
				k = e => !e || !e.document || (e => 0 === e.length || 1 === e.length && (e => "par" === e.e && (!e.c || 0 === e.c.length))(e[0]))(e.document),
				N = (e, t) => {
					const n = e && e[t];
					if (n && (!n.status || n.status === x.Valid)) return n
				}
		},
		"./src/reddit/models/RichTextJson/nodeMakers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "s", (function() {
				return s
			})), n.d(t, "m", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "n", (function() {
				return c
			})), n.d(t, "o", (function() {
				return a
			})), n.d(t, "t", (function() {
				return d
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "r", (function() {
				return h
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "u", (function() {
				return _
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "a", (function() {
				return I
			}));
			var r = n("./src/reddit/models/RichTextJson/index.ts");
			const s = (e, t) => Object.assign({
					e: r.A,
					t: e
				}, t ? {
					f: t
				} : null),
				o = e => ({
					e: r.w,
					t: e
				}),
				i = (e, t, n) => Object.assign({
					e: r.o,
					t: e,
					u: t
				}, n ? {
					f: n
				} : null),
				c = e => ({
					e: r.x,
					c: [s(e, null)]
				}),
				a = (e, t) => ({
					e: r.y,
					t: e,
					l: t
				}),
				d = (e, t) => ({
					e: r.B,
					t: e,
					l: t
				}),
				u = e => ({
					e: r.u,
					c: e
				}),
				l = (e, t) => ({
					e: r.k,
					l: e,
					c: t
				}),
				b = e => ({
					e: r.b,
					c: e
				}),
				p = e => ({
					e: "code",
					c: e
				}),
				m = e => ({
					e: r.q,
					c: e
				}),
				f = (e, t) => ({
					e: r.p,
					c: e,
					o: t
				}),
				g = (e, t) => Object.assign({
					c: e
				}, t ? {
					a: t
				} : {}),
				O = e => ({
					c: e
				}),
				h = (e, t) => ({
					e: r.z,
					h: e,
					c: t
				}),
				y = (e, t) => ({
					e: r.m,
					id: e,
					c: t
				}),
				j = (e, t) => ({
					e: r.a,
					id: e,
					c: t
				}),
				_ = (e, t, n, s) => Object.assign({
					e: r.D,
					id: e,
					c: t,
					gifify: s
				}, n ? {
					p: y(n)
				} : {}),
				E = (e, t) => "image/gif" === t ? {
					e: r.a,
					id: e
				} : {
					e: r.m,
					id: e
				},
				v = () => ({
					e: r.n
				}),
				I = {
					e: r.u,
					c: [{
						e: r.A,
						t: ""
					}]
				}
		},
		"./src/reddit/models/Rule/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			}));
			const r = {
					all: "all",
					post: "post",
					comment: "comment"
				},
				s = {
					all: "all",
					link: "post",
					comment: "comment"
				},
				o = {
					LINK_AND_COMMENT: "all",
					LINK: "post",
					COMMENT: "comment"
				},
				i = 15,
				c = 100,
				a = 100,
				d = 500,
				u = e => ({
					rules: e.map(e => ({
						kind: s[e.kind],
						description: e.description,
						descriptionHtml: e.description_html,
						shortName: e.short_name,
						violationReason: e.violation_reason,
						createdUtc: e.created_utc,
						priority: e.priority
					}))
				})
		},
		"./src/reddit/models/RulesSequence/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			class r {
				constructor() {
					this.sequence = []
				}
				getSequence() {
					return this.sequence
				}
				update(e, t) {
					const n = this.sequence.slice(0, t);
					n.push(e), this.sequence = n
				}
				cut(e) {
					const t = this.sequence.slice(0, e + 1);
					this.sequence = t
				}
			}
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var r, s, o, i = n("./src/reddit/models/GqlTopLevelField.ts"),
				c = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e.LINK = "LINK", e.SELF = "SELF"
			}(r || (r = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(s || (s = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(o || (o = {}));
			const a = e => e.__typename === c.d.AvailableRedditor,
				d = e => e.__typename === i.a.Subreddit;
			var u, l;
			! function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(u || (u = {})),
			function(e) {
				e.Hourly = "hourly", e.Daily = "daily", e.Weekly = "weekly", e.Monthly = "monthly", e.Annually = "annually"
			}(l || (l = {}));
			const b = "custom"
		},
		"./src/reddit/models/SearchDiscoveryUnit/index.ts": function(e, t, n) {
			"use strict";
			var r, s, o;
			n.d(t, "c", (function() {
					return r
				})), n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return o
				})),
				function(e) {
					e.Default = "DEFAULT", e.Trending = "TRENDING"
				}(r || (r = {})),
				function(e) {
					e.Communities = "COMMUNITIES", e.Posts = "POSTS", e.Queries = "QUERIES"
				}(s || (s = {})),
				function(e) {
					e.Carousel = "CAROUSEL", e.Hero = "HERO", e.Row = "ROW", e.Widget = "WIDGET", e.PromotedTrendHero = "PROMOTED_TREND_HERO"
				}(o || (o = {}))
		},
		"./src/reddit/models/Subreddit/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			}));
			var r, s, o = n("./src/reddit/models/GqlTopLevelField.ts");
			! function(e) {
				e.Archived = "archived", e.EmployeesOnly = "employees_only", e.GoldOnly = "gold_only", e.GoldRestricted = "gold_restricted", e.Private = "private", e.Public = "public", e.Restricted = "restricted", e.User = "user"
			}(r || (r = {})),
			function(e) {
				e.Unknown = "UNKNOWN", e.Private = "PRIVATE", e.GoldOnly = "GOLD_ONLY", e.Banned = "BANNED", e.Quarantined = "QUARANTINED"
			}(s || (s = {}));
			const i = e => "__typename" in e && e.__typename === o.a.UnavailableSubreddit,
				c = e => "__typename" in e && e.__typename === o.a.UnavailableSubreddit,
				a = e => e.type === r.User;
			var d;

			function u(e) {
				return !!e && (e.originalContentTagEnabled || !!e.contentCategory)
			}! function(e) {
				e.Image = "IMAGE", e.Link = "LINK", e.Spoiler = "SPOILER", e.Text = "TEXT", e.Video = "VIDEO", e.Poll = "POLL"
			}(d || (d = {}))
		},
		"./src/reddit/models/Subreddit/mock.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/config.ts"),
				s = n("./src/reddit/models/Subreddit/index.ts"),
				o = n("./src/reddit/models/WhitelistStatus/index.ts");
			const i = {
				t5_1: {
					id: "t5_1",
					displayText: "r/cfb",
					name: "cfb",
					title: "CFB Title",
					type: s.c.Public,
					url: "/r/cfb",
					icon: {
						url: "".concat(r.a.assetPath, "/img/placeholder_gradient_light-280.png"),
						width: 120,
						height: 120
					},
					subscribers: 14343103,
					wls: o.a.ALL_ADS,
					isNSFW: !1
				},
				t5_2: {
					id: "t5_2",
					displayText: "r/test",
					name: "test",
					title: "Test Title",
					type: s.c.Private,
					url: "/r/test",
					icon: {
						url: "".concat(r.a.assetPath, "/img/placeholder_gradient_light-280.png"),
						width: 120,
						height: 120
					},
					subscribers: 1,
					wls: void 0,
					isNSFW: !1
				},
				t5_3: {
					id: "t5_2",
					displayText: "r/test",
					name: "test",
					title: "Gold Title",
					type: s.c.GoldOnly,
					url: "/r/test",
					icon: {
						url: "".concat(r.a.assetPath, "/img/placeholder_gradient_light-280.png"),
						width: 120,
						height: 120
					},
					subscribers: 1,
					wls: void 0,
					isNSFW: !1
				}
			}
		},
		"./src/reddit/models/SubredditAutocomplete/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			}));
			var r, s = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				o = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e[e.OWN_PROFILE = 0] = "OWN_PROFILE", e[e.SUBSCRIBED_TO_SUBREDDIT = 1] = "SUBSCRIBED_TO_SUBREDDIT", e[e.OTHER_SUBREDDIT = 2] = "OTHER_SUBREDDIT", e[e.MODERATED_SUBREDDIT = 3] = "MODERATED_SUBREDDIT"
			}(r || (r = {}));
			const i = (e, t) => c(e, r.SUBSCRIBED_TO_SUBREDDIT, t),
				c = (e, t, n) => {
					const {
						color: r,
						url: o
					} = Object(s.a)({
						shouldHideNsfwIcon: n,
						subredditOrProfile: e
					});
					return {
						iconUrl: o,
						id: e.id,
						isNsfw: e.isNSFW,
						name: e.name,
						primaryColor: r,
						subscribers: e.subscribers,
						type: t
					}
				},
				a = e => ({
					iconUrl: e.accountIcon,
					id: e.id,
					name: Object(o.f)(e),
					type: r.OWN_PROFILE
				})
		},
		"./src/reddit/models/SubredditChannel/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			}));
			var r, s, o = n("./src/chat/models/Channel/utils/removeSendbirdPrefix.ts");
			! function(e) {
				e.Public = "public", e.Private = "private"
			}(r || (r = {})),
			function(e) {
				e.Joined = "joined", e.Invited = "invited", e.Unsorted = "none"
			}(s || (s = {}));
			const i = {
					channelId: "",
					channelSendbirdUrl: "",
					subredditId: "",
					name: "",
					description: "",
					membersCount: 0,
					type: r.Public,
					channelState: s.Unsorted,
					minimumAcctAge: 0,
					newMemberAge: 0,
					isModQueue: !1
				},
				c = e => {
					const t = {};
					return e.length && e.forEach(e => {
						const n = (e => ({
							channelId: Object(o.a)(e.url),
							channelSendbirdUrl: e.url,
							channelState: e.member_state,
							subredditId: e.subreddit.id,
							isModQueue: e.is_modqueue,
							name: e.name,
							type: e.type,
							description: e.description,
							membersCount: e.member_count,
							minimumAcctAge: e.automute_account_age_threshold || 0,
							newMemberAge: e.automute_on_join_duration || 0
						}))(e);
						t[n.channelId] = n
					}), t
				},
				a = e => ({
					channelId: Object(o.a)(e.channel_url),
					channelSendbirdUrl: e.channel_url,
					channelState: s.Joined,
					subredditId: e.subreddit_id,
					isModQueue: !1,
					name: e.room,
					type: e.roomType,
					description: e.description,
					membersCount: 1,
					minimumAcctAge: e.automute_account_age_threshold,
					newMemberAge: e.automute_on_join_duration
				})
		},
		"./src/reddit/models/SubredditModeration/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const r = 999;
			var s;
			! function(e) {
				e.Editable = "editable", e.Invited = "invited"
			}(s || (s = {}));
			const o = {
					searchTerm: null,
					userId: null,
					username: null
				},
				i = (e, t, n) => "".concat(e, "-").concat(((e, t) => t || e || "1")(n, t))
		},
		"./src/reddit/models/SubredditRestrictions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			}));
			var r, s, o, i, c = n("./src/reddit/i18n/utils.ts");
			! function(e) {
				e.Create = "create", e.Draft = "draft"
			}(r || (r = {})),
			function(e) {
				e.Comment = "comment_composer", e.IdCard = "id_card", e.PostSubmission = "post_submission"
			}(s || (s = {})),
			function(e) {
				e.PostAndComment = "post and comment", e.Post = "post", e.Comment = "comment", e.View = "view"
			}(o || (o = {})),
			function(e) {
				e.Post = "restrictPosting", e.Comment = "restrictCommenting"
			}(i || (i = {}));
			const a = {
					[o.Post]: Object(c.c)("post"),
					[o.Comment]: Object(c.c)("comment"),
					[o.PostAndComment]: Object(c.c)("post and comment")
				},
				d = {
					[r.Create]: Object(c.c)("create"),
					[r.Draft]: Object(c.c)("draft")
				},
				u = e => Object(c.c)("Anyone can view this community, but only approved users can ".concat(Object(c.b)("restrictionType", a[e] || a[o.Post])))
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return c
			}));
			const r = 25,
				s = 64;
			var o;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(o || (o = {}));
			const i = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: e.id,
						displayText: e.text,
						selected: t
					}
				},
				c = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return i(e.tag, t)
				}
		},
		"./src/reddit/models/Toast/index.ts": function(e, t, n) {
			"use strict";
			var r, s, o;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.AuthError = "auth-error"
				}(r || (r = {})),
				function(e) {
					e[e.SuccessCommunity = 0] = "SuccessCommunity", e[e.SuccessCommunityGreen = 1] = "SuccessCommunityGreen", e[e.SuccessMod = 2] = "SuccessMod", e[e.Error = 3] = "Error", e[e.Undo = 4] = "Undo", e[e.EuCookiePolicy = 5] = "EuCookiePolicy", e[e.UappBanner = 6] = "UappBanner", e[e.AuthError = 7] = "AuthError", e[e.Custom = 8] = "Custom", e[e.Modal = 9] = "Modal"
				}(s || (s = {})),
				function(e) {
					e[e.subscribeMilestone = 0] = "subscribeMilestone", e[e.subscribeCap = 1] = "subscribeCap", e[e.voteMilestone = 2] = "voteMilestone"
				}(o || (o = {}))
		},
		"./src/reddit/models/Upload/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./src/reddit/helpers/getS3KeyFromUrl/index.ts");
			const s = {
					POST_CREATION_MEDIA: "POST_CREATION_MEDIA",
					POST_CREATION_VIDEO_POSTER: "POST_CREATION_VIDEO_POSTER",
					RTE_MEDIA: "RTE_MEDIA"
				},
				o = (e, t) => t ? "".concat(e).concat("/").concat(t) : e,
				i = e => Object(r.a)(e).split("/").slice(-1)[0],
				c = {
					PENDING: "PENDING",
					UPLOADING: "UPLOADING",
					SUCCESS: "SUCCESS",
					FAILED: "FAILED",
					CANCELED: "CANCELED"
				},
				a = e => {
					let {
						status: t
					} = e;
					return t === c.PENDING || t === c.UPLOADING
				}
		},
		"./src/reddit/models/User/index.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "b", (function() {
					return o
				})), n.d(t, "a", (function() {
					return c
				})), n.d(t, "f", (function() {
					return a
				})), n.d(t, "e", (function() {
					return d
				})), n.d(t, "d", (function() {
					return u
				})), n.d(t, "c", (function() {
					return l
				})),
				function(e) {
					e.CommentForm = "commentForm"
				}(r || (r = {})),
				function(e) {
					e.MarkdownModeNotification = "markdownModeNotification"
				}(s || (s = {}));
			const o = {
				commentForm: {
					markdownModeNotification: !1
				}
			};
			var i;
			! function(e) {
				e.Favorites = "favorites", e.Multis = "multis", e.Moderating = "moderating", e.Subscriptions = "subscriptions", e.Profiles = "profiles"
			}(i || (i = {}));
			const c = {
					favorites: !1,
					multis: !1,
					moderating: !1,
					subscriptions: !1,
					profiles: !1
				},
				a = e => {
					const t = e.username || e.displayText;
					if (!t) throw new Error("Invalid username!");
					return t
				},
				d = e => {
					const t = 1e3 * e.created;
					if (t) return new Date(t).getTime()
				};
			var u, l;
			! function(e) {
				e.AvailableRedditor = "Redditor", e.DeletedRedditor = "DeletedRedditor", e.UnavailableRedditor = "UnavailableRedditor"
			}(u || (u = {})),
			function(e) {
				e.BLANK = "BLANK", e.CONFIDENCE = "CONFIDENCE", e.CONTROVERSIAL = "CONTROVERSIAL", e.LIVE = "LIVE", e.NEW = "NEW", e.OLD = "OLD", e.QA = "QA", e.RANDOM = "RANDOM", e.TOP = "TOP"
			}(l || (l = {}))
		},
		"./src/reddit/models/Vote/index.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})), n.d(t, "b", (function() {
					return s
				})), n.d(t, "d", (function() {
					return o
				})), n.d(t, "c", (function() {
					return i
				})), n.d(t, "e", (function() {
					return c
				})),
				function(e) {
					e[e.downvoted = -1] = "downvoted", e[e.notVoted = 0] = "notVoted", e[e.upvoted = 1] = "upvoted"
				}(r || (r = {}));
			const s = (e, t) => e.voteState === t ? r.notVoted : t,
				o = e => {
					switch (e) {
						case !0:
							return r.upvoted;
						case !1:
							return r.downvoted;
						default:
							return r.notVoted
					}
				},
				i = (e, t) => {
					const n = e.voteState === t,
						r = n ? 0 : t,
						s = n ? e.score - t : e.score - e.voteState + t;
					return Object.assign({}, e, {
						voteState: r,
						score: s
					})
				},
				c = e => "UP" === e ? r.upvoted : "DOWN" === e ? r.downvoted : r.notVoted
		},
		"./src/reddit/models/WhitelistAndBlocked.ts": function(e, t, n) {
			"use strict";
			var r;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.pending = "pending", e.error = "error", e.waitingForRequest = "waitingForRequest"
				}(r || (r = {}))
		},
		"./src/reddit/models/WhitelistStatus/index.ts": function(e, t, n) {
			"use strict";
			var r, s;
			n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e[e.NO_ADS = 0] = "NO_ADS", e[e.HOUSE_ONLY = 1] = "HOUSE_ONLY", e[e.PROMO_ADULT_NSFW = 3] = "PROMO_ADULT_NSFW", e[e.PROMO_ALL = 5] = "PROMO_ALL", e[e.ALL_ADS = 6] = "ALL_ADS"
				}(r || (r = {})),
				function(e) {
					e.NO_ADS = "NO_ADS", e.HOUSE_ONLY = "HOUSE_ONLY", e.PROMO_SPECIFIED = "PROMO_SPECIFIED", e.PROMO_ADULT_NSFW = "PROMO_ADULT_NSFW", e.PROMO_ADULT = "PROMO_ADULT", e.PROMO_ALL = "PROMO_ALL", e.ALL_ADS = "ALL_ADS"
				}(s || (s = {}))
		},
		"./src/reddit/models/Widgets/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "m", (function() {
				return o
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "j", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "r", (function() {
				return L
			})), n.d(t, "k", (function() {
				return M
			})), n.d(t, "l", (function() {
				return U
			})), n.d(t, "p", (function() {
				return F
			})), n.d(t, "o", (function() {
				return B
			})), n.d(t, "q", (function() {
				return G
			}));
			var r = n("./src/reddit/models/Subreddit/index.ts");
			const s = 1,
				o = () => ({
					backgroundColor: null,
					headerColor: null
				}),
				i = () => ({
					id: null,
					kind: "textarea",
					shortName: "",
					text: "",
					textHtml: void 0,
					styles: o()
				}),
				c = e => {
					return {
						id: e.id,
						kind: e.kind,
						text: e.text,
						shortName: e.shortName,
						styles: e.styles
					}
				},
				a = () => ({
					currentlyViewingCount: 0,
					currentlyViewingText: "",
					description: "",
					id: null,
					kind: "id-card",
					shortName: "Community details",
					subscribersCount: 0,
					subscribersText: "",
					styles: o()
				});
			var d;
			! function(e) {
				e.Text = "text", e.Image = "image"
			}(d || (d = {}));
			const u = 32,
				l = 288,
				b = e => {
					return {
						id: e.id,
						kind: e.kind,
						shortName: e.shortName,
						description: e.description,
						buttons: e.buttons,
						styles: e.styles
					}
				},
				p = () => ({
					id: null,
					kind: "button",
					shortName: "",
					description: null,
					descriptionHtml: null,
					buttons: [],
					styles: o()
				}),
				m = () => ({
					kind: d.Text,
					text: "",
					url: "",
					color: "#000000",
					hoverState: void 0
				}),
				f = e => e.kind === d.Image ? e.linkUrl : e.url,
				g = {
					FULL: "full",
					COMPACT: "compact"
				},
				O = e => {
					return {
						id: e.id,
						display: e.display,
						kind: e.kind,
						subreddit: e.subreddit,
						shortName: "Subreddit Rules",
						styles: e.styles
					}
				},
				h = () => ({
					id: null,
					kind: "subreddit-rules",
					display: "full",
					data: [],
					subreddit: "",
					shortName: "Subreddit Rules",
					styles: o()
				});
			var y;
			! function(e) {
				e.Cloud = "cloud", e.List = "list"
			}(y || (y = {}));
			const j = () => ({
					id: null,
					kind: "post-flair",
					display: y.List,
					order: [],
					shortName: "",
					styles: o(),
					templates: {}
				}),
				_ = e => {
					return {
						id: e.id,
						display: e.display,
						kind: e.kind,
						order: e.order,
						shortName: e.shortName,
						styles: e.styles
					}
				},
				E = (e, t) => {
					const n = {
						id: e.id,
						displayText: e.displayText,
						name: e.name,
						subscribers: e.subscribers,
						iconUrl: e.icon && e.icon.url,
						isSubscribed: !1,
						type: "subreddit",
						primaryColor: e.primaryColor,
						isNSFW: e.isNSFW
					};
					return t && t.publicDescription && (n.description = t.publicDescription), t && t.bannerBackgroundImage && (n.bannerBackgroundImage = t.bannerBackgroundImage), t && t.bannerBackgroundColor && (n.bannerBackgroundColor = t.bannerBackgroundColor), n
				},
				v = e => ({
					id: e.id,
					name: e.name,
					subscribers: e.subscribers,
					iconUrl: e && e.icon.url,
					type: "profile",
					isNSFW: e.isNSFW
				}),
				I = e => Object(r.e)(e) ? v(e) : E(e),
				S = e => ({
					iconUrl: e.iconUrl,
					id: e.id,
					name: e.name,
					subscribers: e.subscribers,
					primaryColor: e.primaryColor,
					type: "subreddit",
					isNSFW: e.isNsfw || !1
				}),
				T = e => {
					const t = e.data.map(e => e.name),
						n = Object.assign({}, e);
					return n.data = t, n
				},
				x = () => ({
					id: null,
					kind: "community-list",
					shortName: "",
					data: [],
					description: "",
					styles: o()
				}),
				C = () => ({
					id: null,
					kind: "calendar",
					shortName: "",
					configuration: {
						numEvents: 10,
						showDate: !0,
						showTime: !0,
						showTitle: !0,
						showLocation: !0,
						showDescription: !0
					},
					configuredAtUTC: null,
					data: [],
					googleCalendarId: "",
					moderator: null,
					requiresSync: !0,
					synchronizedAtUTC: null,
					styles: o()
				}),
				w = e => {
					return {
						id: e.id,
						kind: e.kind,
						shortName: e.shortName,
						googleCalendarId: e.googleCalendarId,
						moderator: e.moderator,
						requiresSync: e.requiresSync,
						configuredAtUTC: e.configuredAtUTC,
						configuration: Object.assign({}, e.configuration, {
							numEvents: e.configuration.numEvents || 10
						}),
						data: e.data,
						styles: e.styles
					}
				},
				P = e => (e.data.forEach((function(e) {
					void 0 === e.linkUrl && (e.linkUrl = "")
				})), e),
				D = () => ({
					data: [],
					id: null,
					kind: "image",
					shortName: ""
				}),
				R = () => ({
					id: null,
					kind: "custom",
					shortName: "",
					text: "",
					css: "",
					height: null,
					imageData: []
				}),
				A = e => ({
					id: e.id,
					kind: e.kind,
					shortName: e.shortName,
					text: e.text,
					css: e.css,
					height: e.height,
					imageData: e.imageData
				}),
				k = e => ({
					id: e.id,
					kind: e.kind,
					styles: e.styles
				}),
				N = () => ({
					id: null,
					kind: "menu",
					data: [],
					showWiki: !1
				});

			function L(e) {
				return "widgetId" in e
			}

			function M(e) {
				switch (e.kind) {
					case "subreddit-rules":
						return O(e);
					case "community-list":
						return T(e);
					case "image":
						return P(e);
					case "calendar":
						return w(e);
					case "textarea":
						return c(e);
					case "button":
						return b(e);
					case "custom":
						return A(e);
					case "moderators":
						return k(e);
					case "post-flair":
						return _(e);
					default:
						return e
				}
			}

			function U(e) {
				switch (e) {
					case "textarea":
						return i();
					case "button":
						return p();
					case "subreddit-rules":
						return h();
					case "image":
						return D();
					case "community-list":
						return x();
					case "calendar":
						return C();
					case "menu":
						return N();
					case "custom":
						return R();
					case "id-card":
						return a();
					case "post-flair":
						return j();
					default:
						throw new Error("Unknown widget type encountered")
				}
			}

			function F(e) {
				return "structuredStyles.widgets.".concat(e, ".label")
			}

			function B(e) {
				return "structuredStyles.widgets.".concat(e, ".description")
			}

			function G(e) {
				switch (e.kind) {
					case "textarea":
					case "button":
					case "image":
					case "subreddit-rules":
					case "community-list":
					case "calendar":
					case "custom":
					case "id-card":
					case "post-flair":
						return e.shortName;
					default:
						return e.kind
				}
			}
			var V;
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(V || (V = {}))
		},
		"./src/reddit/reducers/comments/visitHighlightingFilter/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r, s = n("./src/reddit/actions/comment/index.ts"),
				o = n("./src/reddit/actions/platform.ts");
			! function(e) {
				e.First = "First", e.Last = "Last", e.None = "None"
			}(r || (r = {}));
			const i = r.Last;
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.a:
						return i;
					case s.a:
						return t.payload.sort;
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r, s = n("./src/reddit/actions/economics/paymentSystems/constants.ts"),
				o = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(r || (r = {}));
			const i = {
				status: r.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.a:
						if (e.status === r.Fetched && e.data.stripe && e.data.stripe.sources) {
							const n = t.payload.cardId,
								r = e.data.stripe.sources,
								s = n,
								i = (r[s], o(r, ["symbol" == typeof s ? s : s + ""]));
							return Object.assign({}, e, {
								data: Object.assign({}, e.data, {
									stripe: Object.assign({}, e.data.stripe, {
										sources: i
									})
								})
							})
						}
						return e;
					case s.e:
						if (e.status === r.Fetched && e.data.braintree && e.data.braintree.sources) {
							const n = t.payload.sourceId,
								r = e.data.braintree.sources,
								s = n,
								i = (r[s], o(r, ["symbol" == typeof s ? s : s + ""]));
							return Object.assign({}, e, {
								data: Object.assign({}, e.data, {
									braintree: Object.assign({}, e.data.braintree, {
										sources: i
									})
								})
							})
						}
						return e;
					case s.b:
						return {
							error: t.payload.error, status: r.Failure
						};
					case s.c:
						return {
							data: t.payload, status: r.Fetched
						};
					case s.d:
						return {
							status: r.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./src/lib/constants/specialMembership.ts"),
				o = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				i = n("./src/reddit/helpers/economics/sortBadges.ts"),
				c = n("./src/reddit/models/Badge/index.ts"),
				a = n("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(r || (r = {}));
			const d = {};

			function u(e) {
				return "userId" in e
			}

			function l(e, t, n, r) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(s => {
						let o;
						(o = e.placement ? e.placement === c.a.First ? r[a.a.Loyalty][s] : r[a.a.Achievement][s] : u(e) ? r[a.a.Cosmetic][a.c.MyBadges][s] : r[a.a.Cosmetic][a.c.Gallery][s]) && (u(e) ? n.has(e.id) && o.unlocked.push(e) : t.has(e.id) || o.locked.push(e))
					})
				})
			}

			function b(e) {
				const t = (e, t) => {
					const n = parseInt(e.price || "0"),
						r = parseInt(t.price || "0");
					return n === r ? Object(i.b)(e, t) : n - r
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === s.a).map(b).sort((e, n) => {
					const r = t[e.id],
						s = t[n.id];
					return Object(i.b)(r, s)
				})
			}

			function m(e) {
				const t = {
					[a.a.Loyalty]: {},
					[a.a.Achievement]: {},
					[a.a.Cosmetic]: {
						[a.c.Gallery]: {},
						[a.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(n => {
					const r = e.collections[n],
						s = {
							description: r.description,
							highlight: r.extra && r.extra.style && r.extra.style.color,
							id: r.id,
							locked: [],
							title: r.title,
							unlocked: []
						};
					t[a.a.Loyalty][n] = Object.assign({}, s, {
						locked: [],
						unlocked: []
					}), t[a.a.Achievement][n] = Object.assign({}, s, {
						locked: [],
						unlocked: []
					}), t[a.a.Cosmetic][a.c.Gallery][n] = Object.assign({}, s, {
						locked: [],
						unlocked: []
					}), t[a.a.Cosmetic][a.c.MyBadges][n] = Object.assign({}, s, {
						locked: [],
						unlocked: []
					})
				});
				const n = new Set;
				e.userOwnedBadges.forEach(t => {
					const r = e.badges[t];
					r && n.add(r.type)
				});
				const r = new Set(e.userOwnedBadges);
				return l(Object.keys(e.badges).map(t => e.badges[t]), n, r, t), l(Object.keys(e.products).map(t => e.products[t]), n, r, t), {
					collections: {
						[a.a.Loyalty]: p(t[a.a.Loyalty], e.collections),
						[a.a.Achievement]: p(t[a.a.Achievement], e.collections),
						[a.a.Cosmetic]: {
							[a.c.Gallery]: p(t[a.a.Cosmetic][a.c.Gallery], e.collections),
							[a.c.MyBadges]: p(t[a.a.Cosmetic][a.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.b: {
						const {
							subredditId: n
						} = t.payload, s = e[n];
						return s && s.status === r.Fetched ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								data: Object.assign({}, s.data),
								raw: Object.assign({}, s.raw)
							})
						}) : e
					}
					case o.i: {
						const {
							subredditId: n
						} = t.payload, s = e[n];
						return s && s.status === r.Fetched ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								data: Object.assign({}, s.data, {
									subscription: Object.assign({}, s.data.subscription || {}, {
										settings: {
											renew: !1
										}
									})
								}),
								raw: Object.assign({}, s.raw, {
									subscription: Object.assign({}, s.raw.subscription || {}, {
										settings: {
											renew: !1
										}
									})
								})
							})
						}) : e
					}
					case o.j: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.subredditId]: {
								raw: n,
								data: m(n),
								status: r.Fetched
							}
						})
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/index.ts": function(e, t, n) {
			"use strict";
			var r = n("./node_modules/redux/es/index.js"),
				s = n("./src/reddit/actions/modal.ts");
			const o = {};
			var i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case s.e:
							if (!t.payload.actionSource && !t.payload.redirectUrl) return o;
							return Object.assign({}, e, t.payload);
						default:
							return e
					}
				},
				c = n("./src/reddit/actions/authorFlair.ts"),
				a = n("./src/reddit/actions/badge.ts"),
				d = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				u = n("./src/reddit/actions/economics/support/constants.ts"),
				l = n("./src/reddit/actions/governance/constants.ts"),
				b = n("./src/reddit/actions/harbergerTax/constants.ts"),
				p = n("./src/reddit/actions/layers.ts"),
				m = n("./src/reddit/actions/platform.ts"),
				f = n("./src/reddit/actions/postCreation/constants.ts"),
				g = n("./src/reddit/actions/product.ts"),
				O = n("./src/reddit/actions/reportFlow.ts"),
				h = n("./src/reddit/actions/structuredStyles/constants.ts"),
				y = n("./src/reddit/constants/modals.ts");
			var j = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case s.c: {
							const n = t.payload;
							return e === n ? null : n
						}
						case s.b:
						case f.x:
						case p.c:
						case p.d:
						case s.d:
						case m.a:
						case O.f:
							return null;
						case h.e:
							return e === y.a.BLADE_UNSAVED_CHANGES ? null : e;
						case h.d:
							return e === y.a.BLADE_NIGHTMODE ? null : e;
						case c.a:
							return e === y.a.USER_FLAIR_MODAL_ID ? null : y.a.USER_FLAIR_MODAL_ID;
						case a.c:
							return y.a.BADGE_PICKER;
						case g.b:
							return y.a.BADGE_PURCHASE;
						case l.e:
							return y.a.GOVERNANCE_OPT_OUT;
						case l.s:
							return y.a.TRANSFER_POINTS;
						case l.p:
							return y.a.GOVERNANCE_RELEASE_NOTES;
						case b.e:
							return y.a.HARBERGER_TAX_BANNER_PURCHASE;
						case b.c:
							return y.a.HARBERGER_TAX_BANNER_MANAGE;
						case b.b:
							return y.a.HARBERGER_TAX_CRYPTO_BANNER_PURCHASE;
						case b.a:
							return y.a.HARBERGER_TAX_CRYPTO_BANNER_MANAGE;
						case u.a:
							return y.a.ECONOMY_SUPPORT_MODAL;
						case l.y:
							return y.a.WALLET_REGISTRATION_MODAL;
						case d.g:
							return y.a.SUBREDDIT_PREMIUM_PURCHASE_MODAL;
						case d.d:
							return y.a.SUBREDDIT_PREMIUM_BADGE_MANAGEMENT;
						case d.k:
							return y.a.SUBREDDIT_PREMIUM_UPLOAD_MODAL;
						case p.a:
						case p.e:
							return y.a.PAINTER_MODAL;
						default:
							return e
					}
				},
				_ = n("./src/reddit/actions/post.ts"),
				E = n("./src/reddit/actions/video.ts");
			const v = {};

			function I(e, t, n) {
				const r = e[t] || {};
				return Object.assign({}, e, {
					[t]: Object.assign({}, r, {
						[n]: Date.now()
					})
				})
			}
			var S = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _.a:
							return I(e, t.payload.postId, "adImpression");
						case _.b:
							return I(e, t.payload.postId, "adViewableImpression");
						case E.d:
							return I(e, t.payload.postId, "adVideoViewable");
						case E.a:
							return I(e, t.payload.postId, "adVideoFullyViewable");
						case E.c:
							return I(e, t.payload.postId, "adVideoStarted");
						case E.b:
							return I(e, t.payload.postId, "adVideoPlayedWithSound");
						case E.q:
							return I(e, t.payload.postId, "adVideoPlayedExpanded");
						case E.e: {
							const {
								postId: n,
								percentage: r
							} = t.payload;
							return I(e, n, "adVideoWatchedPercent".concat(r))
						}
						case E.f: {
							const {
								postId: n,
								seconds: r
							} = t.payload;
							return I(e, n, "adVideoWatchedSeconds".concat(r))
						}
						default:
							return e
					}
				},
				T = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/apiRequestState.ts"));
			const x = {};
			var C = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case T.d:
						case T.a:
						case T.b: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.apiRequestId]: n
							})
						}
						case T.c: {
							const n = t.payload;
							if (!(n in e)) return e;
							if (1 === Object.keys(e).length) return x;
							const r = Object.assign({}, e);
							return delete r[n], r
						}
						default:
							return e
					}
				},
				w = n("./src/reddit/actions/subredditModeration.ts");
			var P = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.e:
						case w.d:
							return null;
						case w.c:
							return t.payload;
						default:
							return e
					}
				},
				D = n("./src/reddit/models/SubredditModeration/index.ts");
			const R = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.e: {
							const {
								subredditId: n,
								fetchedToken: r
							} = t.payload, s = Object(D.d)(n, r);
							return Object.assign({}, e, {
								[s]: !0
							})
						}
						case w.d:
						case w.c: {
							const {
								subredditId: n,
								fetchedToken: r
							} = t.payload, s = Object(D.d)(n, r);
							return Object.assign({}, e, {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				k = Object(r.c)({
					error: P,
					pending: A
				});
			const N = {};
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.d: {
						const {
							fetchedToken: n,
							subredditId: r
						} = t.payload, s = Object(D.d)(r, n);
						return Object.assign({}, e, {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			const M = {};
			var U = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.d: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				F = n("./node_modules/icepick/icepick.js");
			const B = {};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : B,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.b:
					case w.d: {
						const {
							subredditId: n,
							approvedSubmitters: r
						} = t.payload, s = {
							[n]: r
						};
						return Object(F.merge)(e, s)
					}
					case w.i: {
						const {
							subredditId: n,
							userId: r
						} = t.payload;
						return Object(F.unsetIn)(e, [n, r])
					}
					default:
						return e
				}
			};
			var V = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.h:
					case w.g:
						return null;
					case w.f:
						return t.payload;
					default:
						return e
				}
			};
			var q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.h:
							return !0;
						case w.g:
						case w.f:
							return !1;
						default:
							return e
					}
				},
				H = Object(r.c)({
					error: V,
					pending: q
				});
			var K = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.h:
							return null;
						case w.g: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				W = Object(r.c)({
					api: H,
					result: K
				});
			const Y = {};
			var z = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.d: {
							const {
								subredditId: n,
								approvedSubmitterIds: r
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: [...e[n], ...r]
							}) : Object.assign({}, e, {
								[n]: r
							})
						}
						case w.i: {
							const {
								subredditId: n,
								userId: r
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== r)
							}
						}
						case w.b: {
							const {
								subredditId: n,
								approvedSubmitterIds: r
							} = t.payload, s = r[0];
							return s && e[n] && -1 === e[n].indexOf(s) ? {
								[n]: [s, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				J = Object(r.c)({
					api: k,
					fetchedTokens: L,
					loadMore: U,
					models: G,
					search: W,
					userOrder: z
				});
			var Q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.a:
							return t.payload;
						default:
							return e
					}
				},
				X = n("./node_modules/lodash/mergeWith.js"),
				Z = n.n(X),
				$ = n("./src/reddit/actions/comment/index.ts"),
				ee = n("./src/reddit/actions/comment/websocket/constants.ts"),
				te = n("./src/reddit/actions/grantUserFlair/constants.ts"),
				ne = n("./src/reddit/actions/modQueue/constants.ts"),
				re = n("./src/reddit/actions/page.ts"),
				se = n("./src/reddit/actions/pages/profileComments.ts"),
				oe = n("./src/reddit/actions/pages/profilePosts.ts"),
				ie = n("./src/reddit/actions/pages/profilePrivate/constants.ts"),
				ce = n("./src/reddit/actions/pages/search.ts"),
				ae = n("./src/reddit/actions/pages/subreddit.ts"),
				de = n("./src/reddit/actions/profileConversations.ts"),
				ue = n("./src/reddit/actions/subreddit.ts"),
				le = n("./src/reddit/actions/userFlair.ts"),
				be = n("./src/reddit/models/User/index.ts");
			const pe = {};
			var me = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.a:
					case ee.b: {
						const n = t.payload,
							{
								authorFlair: r
							} = n;
						if (r) {
							return Z()(Object.assign({}, e), r, (e, t, n) => {
								if ("richtext" === n) return t
							})
						}
						return e
					}
					case ie.c:
					case ie.i:
					case ie.e:
					case ie.g:
					case ce.c: {
						const {
							authorFlair: n
						} = t.payload;
						if (n) {
							return Object(F.merge)(e, n)
						}
						return e
					}
					case $.u:
					case ae.b:
					case re.b:
					case se.b:
					case se.e:
					case oe.e:
					case oe.b:
					case de.e:
					case ue.i:
						return fe(e, t.payload);
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
						return fe(e, t.payload.response);
					case le.i: {
						const {
							subredditId: n,
							userName: r,
							applied: s,
							displaySettings: {
								isUserEnabled: o
							}
						} = t.payload;
						return Object(F.setIn)(e, [n, r], o ? s : null)
					}
					case te.h:
					case te.b: {
						const {
							subredditId: n,
							userName: r,
							applied: s
						} = t.payload;
						return e[n] && e[n][r] ? Object(F.setIn)(e, [n, r], s) : e
					}
					case le.a: {
						const {
							subredditId: n,
							userName: r,
							applied: s,
							displaySettings: {
								isEnabled: o
							}
						} = t.payload;
						return Object(F.setIn)(e, [n, r], o ? s : null)
					}
					default:
						return e
				}
			};
			const fe = (e, t) => {
				let {
					account: n,
					authorFlair: r,
					userFlair: s
				} = t;
				const o = Object(F.merge)(e, r);
				if (!s || !n) return o;
				const i = Object.keys(s)[0];
				if (!i) return o;
				const c = s[i],
					a = Object(be.f)(n),
					d = c.applied,
					u = c.displaySettings && c.displaySettings.isUserEnabled;
				return a && d && u ? Object(F.merge)(o, {
					[i]: {
						[a]: d
					}
				}) : o
			};
			var ge = Object(r.c)({
					inContext: Q,
					models: me
				}),
				Oe = n("./src/reddit/actions/gold/constants.ts");
			const he = {};
			var ye = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : he,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.a: {
						const {
							disabled: n,
							subredditId: r
						} = t.payload;
						return n ? Object.assign({}, e, {
							[r]: n
						}) : e
					}
					default:
						return e
				}
			};
			var je = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.e:
					case Oe.f:
						return null;
					case Oe.d:
						return t.payload;
					default:
						return e
				}
			};
			var _e = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.a:
						case Oe.f:
						case Oe.d:
							return !1;
						case Oe.e:
							return !0;
						default:
							return e
					}
				},
				Ee = Object(r.c)({
					error: je,
					pending: _e
				}),
				ve = Object(r.c)({
					api: Ee
				});
			var Ie = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.E:
					case Oe.D:
						return null;
					case Oe.C:
						return t.payload;
					default:
						return e
				}
			};
			const Se = {};
			var Te = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Se,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.E: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Oe.D:
						case Oe.C: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				xe = Object(r.c)({
					error: Ie,
					pending: Te
				});
			const Ce = {};
			var we = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ce,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.D: {
							const {
								awards: n,
								subredditId: r
							} = t.payload, s = n.map(e => e.id);
							return Object.assign({}, e, {
								[r]: s
							})
						}
						case Oe.f: {
							const {
								award: n,
								subredditId: r
							} = t.payload;
							if (n && n.id) {
								if (!e[r]) return Object.assign({}, e, {
									[r]: [n.id]
								});
								if (-1 === e[r].indexOf(n.id)) return Object.assign({}, e, {
									[r]: [n.id, ...e[r]]
								})
							}
							return e
						}
						case Oe.i: {
							const {
								awardId: n,
								subredditId: r
							} = t.payload, s = Object.assign({}, e);
							if (s[r]) {
								const e = s[r].indexOf(n);
								if (-1 !== e) {
									const t = [...s[r]];
									return t.splice(e, 1), s[r] = t, s
								}
							}
							return e
						}
						default:
							return e
					}
				},
				Pe = Object(r.c)({
					api: xe,
					order: we
				}),
				De = n("./node_modules/lodash/merge.js"),
				Re = n.n(De);
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			const Ae = e => {
				const t = e.split("+");
				if (1 === t.length) return e;
				const n = "".concat(t[1].substring(0, 2), ":").concat(t[1].substring(2));
				return "".concat(t[0], "+").concat(n)
			};
			var ke = e => (e.startsAt && (e.startsAt = "number" == typeof e.startsAt ? new Date(e.startsAt).toISOString() : Ae(e.startsAt)), e.endsAt && (e.endsAt = "number" == typeof e.endsAt ? new Date(e.endsAt).toISOString() : Ae(e.endsAt)), e),
				Ne = n("./src/reddit/models/Gold/Award.ts"),
				Le = n("./src/reddit/actions/discoveryUnit.ts"),
				Me = n("./src/reddit/actions/frontpage.ts"),
				Ue = n("./src/reddit/actions/multireddit/constants.ts"),
				Fe = n("./src/reddit/actions/pages/collectionCommentsPage.ts"),
				Be = n("./src/reddit/actions/pages/modListing/constants.ts"),
				Ge = n("./src/reddit/actions/pages/postCreation.ts"),
				Ve = n("./src/reddit/actions/pages/profileOverview.ts"),
				qe = n("./src/reddit/actions/profileOverviewChrono.ts"),
				He = n("./src/reddit/actions/recommendations.ts"),
				Ke = n("./src/reddit/actions/search.ts");
			const We = {},
				Ye = (e => t => {
					for (let n = 0; n < e.length; n++) t = e[n](t);
					return t
				})([ke]);
			var ze = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : We,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.D:
					case Oe.L: {
						const {
							awards: n
						} = t.payload, r = n.reduce((e, t) => (e[t.id] = Ye(t), e), {});
						return Re()(Object.assign({}, e), r)
					}
					case Oe.f: {
						const {
							award: n
						} = t.payload;
						return n && n.id ? e[n.id] ? Re()(Object.assign({}, e), {
							[n.id]: Ye(n)
						}) : Object.assign({}, e, {
							[n.id]: Ye(n)
						}) : e
					}
					case Oe.l: {
						const {
							awardId: n
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								isEnabled: !1
							})
						}) : e
					}
					case Fe.b:
					case $.u:
					case ee.a:
					case Ge.b:
					case Le.e:
					case Me.b:
					case Be.e:
					case Be.h:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case Ue.r:
					case re.b:
					case re.g:
					case re.l:
					case ce.c:
					case se.b:
					case se.e:
					case de.b:
					case de.e:
					case Ve.b:
					case Ve.e:
					case qe.b:
					case oe.b:
					case oe.e:
					case ie.c:
					case ie.e:
					case ie.i:
					case ie.g:
					case He.b:
					case Ke.c:
					case ue.i:
					case ae.b: {
						const n = {},
							r = t.payload.posts || [],
							s = t.payload.comments || [];
						for (const e in r) {
							const t = r[e].allAwardings || [];
							for (const e of t) n[e.id] = Ye(Object(Ne.d)(e))
						}
						for (const e in s) {
							const t = s[e],
								{
									associatedAward: r,
									allAwardings: o = []
								} = t;
							for (const e of o) n[e.id] = Ye(Object(Ne.d)(e));
							r && (n[r.id] = Ye(r))
						}
						return Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			var Je = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.M:
					case Oe.L:
						return null;
					case Oe.K:
						return t.payload;
					default:
						return e
				}
			};
			const Qe = {};
			var Xe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.M: {
							const {
								subredditOrProfileId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Oe.L:
						case Oe.K: {
							const {
								subredditOrProfileId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Ze = Object(r.c)({
					error: Je,
					pending: Xe
				});
			const $e = {};
			var et = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $e,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.L: {
							const {
								awards: n,
								subredditOrProfileId: r
							} = t.payload, s = n.map(e => e.id);
							return Object.assign({}, e, {
								[r]: s
							})
						}
						default:
							return e
					}
				},
				tt = Object(r.c)({
					api: Ze,
					order: et
				}),
				nt = Object(r.c)({
					blacklist: ye,
					create: ve,
					manageable: Pe,
					models: ze,
					usable: tt
				});
			const rt = {};
			var st = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.e:
					case a.f: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case a.d: {
						const {
							subredditId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const ot = {};
			var it = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ot,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case a.e: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case a.f:
						case a.d: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				ct = Object(r.c)({
					error: st,
					pending: it
				});
			const at = {};
			var dt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : at,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.h:
					case a.i: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case a.g: {
						const {
							subredditId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const ut = {};
			var lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ut,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case a.h: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case a.i:
						case a.g: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				bt = Object(r.c)({
					error: dt,
					pending: lt
				}),
				pt = Object(r.c)({
					subreddit: ct,
					user: bt
				});
			const mt = {};
			var ft = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.j:
						case a.f:
						case a.i:
						case g.d: {
							const {
								badges: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				gt = Object(r.c)({
					api: pt,
					models: ft
				});
			var Ot = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.m:
					case w.l:
						return null;
					case w.k:
						return t.payload;
					default:
						return e
				}
			};
			const ht = {};
			var yt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ht,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.m: {
							const {
								subredditId: n,
								fetchedToken: r
							} = t.payload, s = Object(D.d)(n, r);
							return Object.assign({}, e, {
								[s]: !0
							})
						}
						case w.l:
						case w.k: {
							const {
								subredditId: n,
								fetchedToken: r
							} = t.payload, s = Object(D.d)(n, r);
							return Object.assign({}, e, {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				jt = Object(r.c)({
					error: Ot,
					pending: yt
				});
			const _t = {};
			var Et = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _t,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.l: {
							const {
								fetchedToken: n,
								subredditId: r
							} = t.payload, s = Object(D.d)(r, n);
							return Object.assign({}, e, {
								[s]: !0
							})
						}
						default:
							return e
					}
				},
				vt = n("./src/reddit/actions/inContextModeration.ts");
			var It = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vt.a:
						return t.payload;
					default:
						return e
				}
			};
			const St = {};
			var Tt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : St,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.l: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const xt = {};
			var Ct = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.j:
					case w.l: {
						const {
							subredditId: n,
							bannedUsers: r
						} = t.payload;
						return Object(F.merge)(e, {
							[n]: r
						})
					}
					case w.q: {
						const {
							subredditId: n,
							userId: r
						} = t.payload;
						return Object(F.unsetIn)(e, [n, r])
					}
					default:
						return e
				}
			};
			var wt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.p:
					case w.o:
						return null;
					case w.n:
						return t.payload;
					default:
						return e
				}
			};
			var Pt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.p:
							return !0;
						case w.o:
						case w.n:
							return !1;
						default:
							return e
					}
				},
				Dt = Object(r.c)({
					error: wt,
					pending: Pt
				});
			var Rt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.p:
						case w.n:
							return null;
						case w.o: {
							const e = t.payload.bannedUserIds[0];
							return e ? t.payload.bannedUsers[e] : null
						}
						default:
							return e
					}
				},
				At = Object(r.c)({
					api: Dt,
					result: Rt
				});
			const kt = {};
			var Nt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.l: {
							const {
								subredditId: n,
								bannedUserIds: r
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: [...e[n], ...r]
							}) : Object.assign({}, e, {
								[n]: r
							})
						}
						case w.q: {
							const {
								subredditId: n,
								userId: r
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== r)
							}
						}
						case w.j: {
							const {
								subredditId: n,
								bannedUserIds: r
							} = t.payload, s = r[0];
							return s && e[n] && -1 === e[n].indexOf(s) ? {
								[n]: [s, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Lt = Object(r.c)({
					api: jt,
					fetchedTokens: Et,
					inContext: It,
					loadMore: Tt,
					models: Ct,
					search: At,
					userOrder: Nt
				}),
				Mt = n("./src/reddit/actions/blockedRedditors.ts");
			const Ut = {
				message: ""
			};
			var Ft = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ut,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Mt.c:
					case Mt.d:
						return e;
					case Mt.b:
						return t.payload;
					default:
						return e
				}
			};
			var Bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Mt.d:
							return !0;
						case Mt.c:
						case Mt.b:
							return !1;
						default:
							return e
					}
				},
				Gt = Object(r.c)({
					error: Ft,
					pending: Bt
				});
			const Vt = {
				ids: []
			};
			var qt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Mt.a:
							return {
								ids: [...e.ids, t.payload], timestamp: e.timestamp
							};
						case Mt.e:
							const n = e.ids.slice();
							return n.splice(e.ids.indexOf(t.payload), 1), Object.assign({}, e, {
								ids: n
							});
						case Mt.c:
							return {
								ids: [...e.ids, ...t.payload], timestamp: Date.now()
							};
						default:
							return e
					}
				},
				Ht = Object(r.c)({
					api: Gt,
					list: qt
				}),
				Kt = n("./src/reddit/actions/userBlocks.ts");
			const Wt = {};
			var Yt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Kt.f:
					case Kt.e: {
						const {
							userId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Kt.d: {
						const {
							userId: n,
							type: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const zt = {};
			var Jt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Kt.f: {
							const {
								userId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Kt.e:
						case Kt.d: {
							const {
								userId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Qt = Object(r.c)({
					error: Yt,
					pending: Jt
				}),
				Xt = Object(r.c)({
					api: Qt
				}),
				Zt = n("./src/reddit/actions/ads/constants.ts");
			const $t = {
				isViewSafe: !0,
				hasBrandSafetyBeenAssessed: !1
			};
			var en = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $t,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zt.a:
							return e.isViewSafe === t.payload.isViewSafe && e.hasBrandSafetyBeenAssessed ? e : Object.assign({}, e, {
								isViewSafe: t.payload.isViewSafe,
								hasBrandSafetyBeenAssessed: !0
							});
						case ae.c:
						case re.m:
						case re.h:
							return e.hasBrandSafetyBeenAssessed ? Object.assign({}, e, {
								hasBrandSafetyBeenAssessed: !1
							}) : e;
						default:
							return e
					}
				},
				tn = n("./src/reddit/actions/category.ts");
			var nn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tn.b:
					case tn.c:
						return null;
					case tn.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			var rn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tn.c:
						return !1;
					case tn.b:
						return !0;
					default:
						return e
				}
			};
			var sn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tn.c:
							return !0;
						case tn.b:
						case tn.a:
							return !1;
						default:
							return e
					}
				},
				on = Object(r.c)({
					error: nn,
					loaded: rn,
					pending: sn
				});
			const cn = {};
			var an = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tn.g:
					case tn.f: {
						const {
							categoryId: n
						} = t.payload, r = Object.assign({}, e);
						return delete r[n], r
					}
					case tn.e: {
						const {
							categoryId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const dn = {};
			var un = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tn.g: {
						const {
							categoryId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case tn.f: {
						const {
							categoryId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const ln = {};
			var bn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ln,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tn.g: {
							const {
								categoryId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case tn.f:
						case tn.e: {
							const {
								categoryId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				pn = Object(r.c)({
					error: an,
					loaded: un,
					pending: bn
				}),
				mn = Object(r.c)({
					list: on,
					subreddits: pn
				}),
				fn = n("./node_modules/lodash/isEmpty.js"),
				gn = n.n(fn);
			const On = [];
			var hn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : On,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tn.b: {
						const {
							categoryIds: n
						} = t.payload;
						return gn()(n) ? e : n
					}
					default:
						return e
				}
			};
			const yn = {};
			var jn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tn.b: {
							const {
								categories: n
							} = t.payload;
							return gn()(n) ? e : Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				_n = n("./node_modules/lodash/forOwn.js"),
				En = n.n(_n),
				vn = n("./src/reddit/helpers/name/index.ts");
			const In = {};
			var Sn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : In,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tn.b: {
							const {
								categories: n
							} = t.payload;
							if (gn()(n)) return e;
							const r = {};
							return En()(n, e => {
								r[Object(vn.f)(e.name)] = e.id
							}), Object.assign({}, e, r)
						}
						default:
							return e
					}
				},
				Tn = n("./src/reddit/actions/global.ts"),
				xn = n("./src/reddit/constants/localStorage.ts");
			const Cn = {};
			var wn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Tn.a:
							return t.payload[xn.d] || e;
						case tn.d: {
							const {
								categoryId: n,
								rank: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				Pn = Object(r.c)({
					api: mn,
					ids: hn,
					models: jn,
					nameToId: Sn,
					ranking: wn
				}),
				Dn = n("./src/reddit/actions/chat/init.ts");
			var Rn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Dn.a:
							return !0;
						default:
							return e
					}
				},
				An = n("./src/reddit/actions/chat/sendbirdProxy.ts"),
				kn = n("./src/reddit/actions/chat/subredditChannel.ts");
			var Nn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case kn.b:
						case kn.a:
							return !!t.payload.isUserSubredditChatEnabled;
						case An.a:
							const {
								user_subreddit_chat_enabled: n
							} = t.payload;
							return n;
						default:
							return e
					}
				},
				Ln = n("./src/chat/actions/promo/constants.ts");
			const Mn = {
				displaySubredditChatFtux: !1
			};
			var Un = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ln.a: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ln.b: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Fn = n("./src/reddit/actions/chat/subredditSettings.ts");
			const Bn = {
				subredditId: null,
				bannedWords: "",
				domains: "",
				rateLimit: -1,
				regexes: []
			};
			var Gn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fn.a:
							return Object.assign({}, t.payload);
						default:
							return e
					}
				},
				Vn = n("./src/reddit/actions/chat/unreadCount.ts");
			const qn = {
				apiError: null
			};
			var Hn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Vn.a.REQUEST_FAILED: {
						const e = t.payload;
						return Object.assign({}, qn, {
							apiError: e
						})
					}
					case Vn.a.REQUEST_SUCCESS:
					case Vn.a.REQUEST_PENDING:
						return qn;
					default:
						return e
				}
			};
			var Kn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Vn.a.REQUEST_PENDING:
							return !0;
						case Vn.a.REQUEST_FAILED:
						case Vn.a.REQUEST_SUCCESS:
							return !1;
						default:
							return e
					}
				},
				Wn = Object(r.c)({
					error: Hn,
					pending: Kn
				});
			const Yn = {
				basicChannelCount: 0,
				subredditChannelCount: 0
			};
			var zn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Vn.a.SYNC:
						case Vn.a.REQUEST_SUCCESS: {
							const e = t.payload;
							return Object.assign({}, e)
						}
						default:
							return e
					}
				},
				Jn = Object(r.c)({
					api: Wn,
					count: zn
				}),
				Qn = Object(r.c)({
					isInited: Rn,
					isUserSubredditChatEnabled: Nn,
					subredditSettings: Gn,
					promos: Un,
					unread: Jn
				}),
				Xn = n("./src/reddit/actions/claimgold.ts");
			var Zn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xn.a:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg;
					case Xn.d:
					case Xn.e:
					case Xn.c:
						return null;
					default:
						return e
				}
			};
			var $n = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xn.d:
					case Xn.c:
					case Xn.a:
						return !1;
					case Xn.b:
						return !0;
					default:
						return e
				}
			};
			var er = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xn.b:
						case Xn.d:
						case Xn.c:
						case Xn.a:
							return !1;
						case Xn.f:
							return !0;
						default:
							return e
					}
				},
				tr = Object(r.c)({
					error: Zn,
					pending: $n,
					showLoader: er
				});
			var nr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xn.g:
						return t.payload;
					case Xn.e:
						return "";
					default:
						return e
				}
			};
			var rr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xn.e:
							return !0;
						case Xn.c:
						case Xn.d:
							return !1;
						default:
							return e
					}
				},
				sr = Object(r.c)({
					api: tr,
					code: nr,
					showModal: rr
				}),
				or = n("./node_modules/lodash/get.js"),
				ir = n.n(or);
			const cr = {};
			var ar = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.d: {
							const {
								commentsPageKey: n,
								commentId: r,
								isCollapsed: s
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									[r]: !ir()(e, [n, r], s)
								})
							})
						}
						case $.e: {
							const {
								commentsPageKey: n,
								commentId: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									[r]: !1
								})
							})
						}
						case $.u:
						case Fe.b:
						case re.b: {
							const {
								key: n,
								shouldCollapse: r
							} = t.payload;
							if (!r) return e;
							const s = r.reduce((e, t) => Object.assign({}, e, {
								[t]: !0
							}), {});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], s)
							})
						}
						default:
							return e
					}
				},
				dr = n("./src/lib/makeDraftKey/index.ts"),
				ur = n("./src/reddit/models/PostCreationForm/index.ts"),
				lr = n("./src/reddit/models/PostDraft/index.ts");
			const br = {};
			var pr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : br,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.q: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								autofocusDisabled: !0
							})
						})
					}
					case $.j: {
						const {
							draftKey: n,
							hasFocus: r
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								hasFocus: r
							})
						}) : e
					}
					case re.e: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {
								rteState: null,
								draftType: lr.c.replyToPost
							}
						})
					}
					case Fe.b:
					case Fe.c:
					case re.d: {
						const {
							postId: n,
							commentMode: r
						} = t.payload, s = Object(dr.a)(lr.c.replyToPost, n);
						return Object.assign({}, e, {
							[s]: {
								commentMode: r,
								draftType: lr.c.replyToPost,
								hasFocus: !1,
								rteState: null,
								text: ""
							}
						})
					}
					case re.b: {
						const {
							postId: n,
							preferences: r
						} = t.payload;
						if (!r || void 0 === r.useMarkdown) return e;
						const s = Object(dr.a)(lr.c.replyToPost, n),
							o = r.useMarkdown ? ur.h.MARKDOWN : ur.h.RICH_TEXT;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								commentMode: o
							})
						})
					}
					case $.l:
						const {
							draftKey: n, content: r, editorMode: s
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								commentMode: s,
								rteState: null,
								text: s === ur.h.MARKDOWN ? r : "",
								rtJson: s === ur.h.RICH_TEXT ? r : null
							})
						}) : e;
					case $.r:
					case $.p: {
						const {
							draftKey: n,
							formData: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								hasFocus: !0
							})
						})
					}
					case $.k: {
						const {
							draftKey: n,
							formData: r
						} = t.payload;
						return null === e[n] ? e : Object.assign({}, e, {
							[n]: Object.assign({}, e[n], r)
						})
					}
					case $.f: {
						const {
							draftKey: n
						} = t.payload, r = e[n];
						return r && r.draftType === lr.c.replyToPost ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								rteState: null,
								text: ""
							})
						}) : Object.assign({}, e, {
							[n]: null
						})
					}
					case $.G: {
						const {
							draftKey: n
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								rteState: null,
								text: ""
							})
						})
					}
					case $.F:
					case $.B: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case $.E: {
						const {
							draftKey: n,
							draft: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const mr = {};
			var fr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.h: {
						const {
							commentListNodeId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case $.i: {
						const {
							commentListNodeId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !e[n]
						})
					}
					default:
						return e
				}
			};
			const gr = {};
			var Or = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.c: {
						const {
							commentListNodeIds: n,
							commentsPageKey: r
						} = t.payload, s = n.reduce((t, n) => (t[n] = !ir()(e, [r, n], !1), t), {});
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], s)
						})
					}
					case $.b: {
						const {
							commentListNodeIds: n,
							commentsPageKey: r
						} = t.payload, s = n.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], s)
						})
					}
					case $.u:
					case Fe.b:
					case re.b: {
						const {
							key: n,
							shouldHide: r
						} = t.payload;
						if (!r) return e;
						const s = r.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], s)
						})
					}
					default:
						return e
				}
			};
			const hr = {};
			var yr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.r: {
							const {
								commentId: n,
								commentsPageKey: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: Object.assign({}, e[r], {
									[n]: !0
								})
							})
						}
						case $.g:
						case $.z:
						case $.B: {
							const {
								commentId: n,
								commentsPageKey: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: Object.assign({}, e[r], {
									[n]: !1
								})
							})
						}
						default:
							return e
					}
				},
				jr = (n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/lodash/isEqual.js")),
				_r = n.n(jr),
				Er = n("./node_modules/lodash/mapValues.js"),
				vr = n.n(Er),
				Ir = n("./node_modules/lodash/omit.js"),
				Sr = n.n(Ir),
				Tr = n("./src/reddit/actions/bulkActions/constants.ts"),
				xr = n("./src/reddit/actions/modMode.ts"),
				Cr = n("./src/reddit/actions/vote.ts"),
				wr = n("./src/reddit/helpers/isComment.ts"),
				Pr = n("./src/reddit/models/Comment/index.ts");
			const Dr = (e, t, n) => {
				const r = {};
				for (const o of t) r[o.award.id] = o.total;
				const s = n ? e.awarders && e.awarders.length ? e.awarders.includes(n) ? e.awarders : [n, ...e.awarders] : [n] : e.awarders;
				return Object.assign({}, e, {
					awarders: s,
					awardCountsById: r
				})
			};
			var Rr = n("./src/reddit/models/ModQueue/index.ts"),
				Ar = n("./src/reddit/models/Vote/index.ts"),
				kr = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const Nr = {},
				Lr = e => t => {
					for (let n = 0; n < e.length; n++) t = e[n](t);
					return t
				},
				Mr = ["next", "prev", "depth"],
				Ur = e => Sr()(e, Mr),
				Fr = e => {
					const {
						allAwardings: t,
						associatedAward: n
					} = e, r = kr(e, ["allAwardings", "associatedAward"]), s = Object.assign({}, r);
					if (t) {
						const e = {};
						for (const n of t) e[n.id] = n.count;
						s.awardCountsById = e
					}
					return n && (s.associatedAwardId = n.id), s
				};
			var Br = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.a:
					case ee.b:
					case $.F:
					case $.G: {
						const {
							comment: n
						} = t.payload, r = Lr([Fr]);
						return Object.assign({}, e, {
							[n.id]: r(n)
						})
					}
					case $.u:
					case Fe.b:
					case re.b:
					case se.b:
					case se.e:
					case Ve.b:
					case Ve.e:
					case de.b:
					case de.e:
					case qe.b:
					case ie.i:
					case ie.g:
					case ie.c:
					case ie.e: {
						const n = Object.assign({}, e),
							r = Lr([Ur, Fr]);
						for (const s in t.payload.comments) {
							const o = e[s],
								i = t.payload.comments[s];
							o ? _r()(o, i) || (i.postAuthor || (i.postAuthor = o.postAuthor), i.postTitle || (i.postTitle = o.postTitle), n[s] = r(i)) : n[s] = r(i)
						}
						return n
					}
					case $.y: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								isDeleted: !0,
								deletedBy: Pr.a.User
							})
						})
					}
					case $.n: {
						const n = t.payload;
						return Z()(Object.assign({}, e), n, (e, t) => Object.assign({}, e, t))
					}
					case Cr.a: {
						const {
							id: n,
							vote: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object(Ar.c)(s, r)
						}) : e
					}
					case Oe.q: {
						const {
							awardings: n,
							id: r,
							gilder: s
						} = t.payload, o = e[r];
						return o ? Object.assign({}, e, {
							[r]: Dr(o, n, s)
						}) : e
					}
					case w.l: {
						const {
							comments: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							comments: r
						} = n, s = Lr([Fr]);
						return Object.assign({}, e, vr()(r, s))
					}
					case Tr.b:
					case ne.s: {
						const {
							operation: n,
							ids: r,
							username: s,
							options: o
						} = t.payload, i = r.filter(e => Object(wr.a)(e)), c = Object(Rr.d)(e, n, i, s, o);
						return Z()(Object.assign({}, e), c, (e, t) => Object.assign({}, e, t))
					}
					case ce.c: {
						const {
							comments: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case xr.a: {
						const n = Object.assign({}, e);
						for (const r in e)
							if (e.hasOwnProperty(r)) {
								const s = e[r];
								n[r].computedCollapsed = s.collapsedBecauseCrowdControl ? !t.payload.enabled : s.collapsed
							} return n
					}
					case $.m: {
						const {
							commentId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								collapsedBecauseCrowdControl: !1
							})
						})
					}
					default:
						return e
				}
			};
			const Gr = {};
			var Vr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.p: {
						const {
							parentCommentId: n,
							commentsPageKey: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								[n]: !0
							})
						})
					}
					case $.o:
					case $.F: {
						const {
							parentCommentId: n,
							commentsPageKey: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								[n]: !1
							})
						})
					}
					default:
						return e
				}
			};
			const qr = {};
			var Hr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.o:
					case $.E:
					case $.A:
					case $.G:
					case $.F:
					case $.B: {
						const {
							draftKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case $.D:
					case $.z: {
						const {
							draftKey: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case $.w: {
						const {
							id: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case $.x:
					case $.y: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					default:
						return e
				}
			};
			const Kr = {};
			var Wr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.E:
						case $.A: {
							const {
								draftKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case $.F:
						case $.G:
						case $.B:
						case $.D:
						case $.z: {
							const {
								draftKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case $.x: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case $.y:
						case $.w: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Yr = Object(r.c)({
					error: Hr,
					pending: Wr
				}),
				zr = n("./src/reddit/reducers/comments/visitHighlightingFilter/index.ts"),
				Jr = Object(r.c)({
					collapsed: ar,
					drafts: pr,
					focused: fr,
					hidden: Or,
					isEditing: yr,
					models: Br,
					replyFormOpen: Vr,
					submit: Yr,
					visitHighlightFilter: zr.b
				}),
				Qr = n("./src/reddit/actions/commentsListTruncated/constants.ts");
			var Xr = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Qr.a:
						return !1;
					case Qr.b:
						return !0;
					default:
						return e
				}
			};
			const Zr = [];
			var $r = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Zt.b:
						return t.payload;
					case Zt.c:
					default:
						return e
				}
			};
			const es = {};
			var ts = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : es,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fe.d:
					case Fe.b:
					case re.d:
					case re.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Fe.a:
					case re.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r || {}
						})
					}
					default:
						return e
				}
			};
			const ns = {};
			var rs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ns,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fe.c:
					case re.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const ss = {};
			var os = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ss,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.d:
						case re.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Fe.b:
						case Fe.a:
						case re.b:
						case re.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				is = Object(r.c)({
					error: ts,
					fullyLoaded: rs,
					pending: os
				}),
				cs = (n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/lodash/uniqBy.js")),
				as = n.n(cs),
				ds = n("./node_modules/lodash/values.js"),
				us = n.n(ds);
			const ls = {};

			function bs(e, t) {
				return us()(e).map(e => {
					const n = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
					return {
						id: e.id,
						created: n,
						stickied: e.isStickied,
						authorId: e.authorId
					}
				})
			}

			function ps(e) {
				return as()(e, "id").sort((e, t) => e.created - t.created)
			}
			var ms = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ls,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.b:
						case $.u:
						case Fe.b: {
							const {
								comments: n,
								key: r
							} = t.payload, s = e[r] ? e[r] : [], o = bs(n, s.find(e => e.stickied)), i = ps([...s, ...o]);
							return Object.assign({}, e, {
								[r]: [...i]
							})
						}
						case ee.a:
						case ee.b:
						case $.G:
						case $.F: {
							const {
								comment: {
									id: n,
									created: r,
									isStickied: s,
									authorId: o
								},
								commentsPageKey: i
							} = t.payload;
							return Object.assign({}, e, {
								[i]: [...ps([...e[i] ? e[i] : [], {
									id: n,
									created: r,
									stickied: s,
									authorId: o
								}])]
							})
						}
						default:
							return e
					}
				},
				fs = n("./src/reddit/helpers/commentList/index.ts");
			const gs = {};

			function Os(e) {
				const t = e;
				return vr()(t, e => {
					let {
						depth: t,
						next: n,
						prev: r
					} = e;
					return {
						depth: t,
						next: n,
						prev: r
					}
				})
			}
			var hs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gs,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.u: {
						const {
							comments: n,
							commentLists: r,
							continueThreads: s,
							key: o,
							moreCommentsItem: i,
							moreComments: c
						} = t.payload, a = r[i.postId], d = e[o], u = {}, l = d[i.id];
						if (l && l.prev) {
							const {
								id: e
							} = l.prev;
							u[e] = Object.assign({}, d[e], {
								next: a.head || l.next
							})
						}
						if (l && l.next) {
							const {
								id: e
							} = l.next;
							u[e] = Object.assign({}, d[e], {
								prev: a.tail || l.prev
							})
						}
						if (a.head && a.tail) {
							const e = Object(fs.c)({
									commentLink: a.head,
									commentsDict: n,
									moreCommentsDict: c,
									continueThreadDict: s
								}),
								t = Object(fs.c)({
									commentLink: a.tail,
									commentsDict: n,
									moreCommentsDict: c,
									continueThreadDict: s
								});
							l && (e.prev = l.prev, t.next = l.next)
						}
						return Object.assign({}, e, {
							[o]: Object.assign({}, e[o], Os(n), Os(s), Os(c), u)
						})
					}
					case Fe.b:
					case re.b: {
						const {
							comments: n,
							continueThreads: r,
							key: s,
							moreComments: o
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], Os(n), Os(r), Os(o))
						})
					}
					case ee.a:
					case $.G: {
						const {
							comment: n,
							commentsPageKey: r,
							headCommentId: s
						} = t.payload, o = e[r], i = {};
						let c = null;
						return s && (i[s] = Object.assign({}, o[s], {
							prev: Object(Pr.f)(n.id)
						}), c = Object(Pr.f)(s)), Object.assign({}, e, {
							[r]: Object.assign({}, e[r], i, {
								[n.id]: {
									depth: 0,
									next: c,
									prev: null
								}
							})
						})
					}
					case $.F: {
						const {
							comment: n,
							commentsPageKey: r,
							parentCommentId: s,
							depth: o
						} = t.payload, i = e[r], c = {};
						let a = null;
						if (!i[s]) return e;
						const d = i[s].next;
						return d && (c[d.id] = Object.assign({}, i[d.id], {
							prev: Object(Pr.f)(n.id)
						}), a = d), c[s] = Object.assign({}, i[s], {
							next: Object(Pr.f)(n.id)
						}), Object.assign({}, e, {
							[r]: Object.assign({}, e[r], c, {
								[n.id]: {
									depth: o,
									next: a,
									prev: Object(Pr.f)(s)
								}
							})
						})
					}
					default:
						return e
				}
			};
			const ys = {};
			var js = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ys,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.a:
					case ee.b:
					case $.G: {
						const {
							comment: n,
							commentsPageKey: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n.id
						})
					}
					case Fe.b:
					case re.b: {
						const {
							commentLists: n,
							key: r,
							postId: s
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n[s] && n[s].head ? n[s].head.id : null
						})
					}
					default:
						return e
				}
			};
			const _s = {};
			var Es = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _s,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.d:
						case Fe.b:
						case Fe.c:
						case re.d: {
							const {
								key: n,
								postId: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case $.G: {
							const {
								parentId: n,
								commentsPageKey: r
							} = t.payload;
							return e[r] ? e : Object.assign({}, e, {
								[r]: n
							})
						}
						default:
							return e
					}
				},
				vs = Object(r.c)({
					api: is,
					keyToChatCommentLinks: ms,
					keyToCommentThreadLinkSets: hs,
					keyToHeadCommentId: js,
					keyToPostId: Es,
					ads: $r
				}),
				Is = n("./src/reddit/actions/communityFlairs/constants.ts");
			const Ss = {};
			var Ts = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ss,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Is.a: {
							const {
								models: n,
								sortedKeys: r,
								subredditId: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: {
									sortedKeys: r,
									models: n
								}
							})
						}
						default:
							return e
					}
				},
				xs = n("./src/lib/constants/index.ts"),
				Cs = n("./src/reddit/actions/contentGate.ts");
			const ws = {};
			var Ps = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ws,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cs.a: {
						const {
							subredditName: n
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										goldSubreddit: !0
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									goldSubreddit: !0
								}
							})
						}
						return e
					}
					case Cs.b: {
						const {
							subredditDescription: n,
							subredditName: r
						} = t.payload;
						if (r) {
							if (e[r]) {
								const t = {
									[r]: {
										privateSubreddit: !0,
										subredditDescription: n
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[r]: {
									privateSubreddit: !0,
									subredditDescription: n
								}
							})
						}
						return e
					}
					case Cs.e: {
						const {
							subredditName: n,
							quarantineRequiresEmail: r,
							quarantineMessage: s,
							quarantineMessageHtml: o,
							quarantineMessageRTJson: i
						} = t.payload;
						return n ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								quarantinedSubreddit: !0,
								quarantineRequiresEmail: r,
								quarantineMessage: s,
								quarantineMessageHtml: o,
								quarantineMessageRTJson: i
							})
						}) : e
					}
					case Cs.g: {
						const {
							subredditName: n,
							banMessage: r
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										subredditBanned: !0,
										subredditBanMessage: r
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									subredditBanned: !0,
									subredditBanMessage: r
								}
							})
						}
						return e
					}
					case Cs.h: {
						const {
							subredditName: n
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										subredditDoesNotExist: !0
									}
								};
								return Z()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign({}, e, {
								[n]: {
									subredditDoesNotExist: !0
								}
							})
						}
						return e
					}
					case Cs.c:
					case Cs.d: {
						const {
							profileName: n
						} = t.payload, r = xs.Qb + n.toLocaleLowerCase(), s = e[r] || {}, o = t.type === Cs.c ? {
							profileDeleted: !0
						} : {
							profileSuspended: !0
						};
						return Object.assign({}, e, {
							[r]: Object.assign({}, s, o)
						})
					}
					default:
						return e
				}
			};
			const Ds = {};
			var Rs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ds,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.u:
						case Fe.b:
						case re.b:
							return Object.assign({}, e, t.payload.continueThreads);
						default:
							return e
					}
				},
				As = Object(r.c)({
					models: Rs
				}),
				ks = n("./src/reddit/actions/postCollection/constants.ts");
			var Ns = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.c:
					case ks.d:
					case ks.c:
					case ks.s:
					case ks.r:
						return null;
					case ks.b:
					case ks.n:
						return t.payload;
					default:
						return e
				}
			};
			var Ls = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ks.c:
						case ks.r:
							return !0;
						case ks.d:
						case ks.b:
						case ks.s:
						case ks.n:
							return !1;
						default:
							return e
					}
				},
				Ms = Object(r.c)({
					error: Ns,
					pending: Ls
				}),
				Us = Object(r.c)({
					createOrUpdate: Ms
				}),
				Fs = n("./src/reddit/actions/postDraft.ts");
			const Bs = {};
			var Gs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bs,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fs.c:
					case Fs.b: {
						const {
							draftId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Fs.a: {
						const {
							apiError: n,
							draftId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			const Vs = {};
			var qs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vs,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fs.b: {
							const {
								draftId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Fs.c:
						case Fs.a: {
							const {
								draftId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Hs = Object(r.c)({
					error: Gs,
					pending: qs
				});
			var Ks = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fs.d:
						return t.payload;
					case Fs.f:
					case Fs.e:
						return null;
					default:
						return e
				}
			};
			var Ws = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fs.f:
							return !0;
						case Fs.e:
						case Fs.d:
							return !1;
						default:
							return e
					}
				},
				Ys = Object(r.c)({
					error: Ks,
					pending: Ws
				});
			const zs = {
				apiError: null,
				needsCaptcha: !1,
				validationError: null,
				submitValidationError: null
			};
			var Js = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zs,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fs.l:
					case Fs.j:
						return zs;
					case Fs.i: {
						const e = t.payload;
						return Object.assign({}, zs, {
							apiError: e
						})
					}
					case Fs.m: {
						const e = t.payload;
						return Object.assign({}, zs, {
							validationError: e
						})
					}
					case Fs.k: {
						const e = t.payload;
						return Object.assign({}, zs, {
							submitValidationError: e
						})
					}
					case Fs.h:
						return Object.assign({}, zs, {
							needsCaptcha: !0
						});
					default:
						return e
				}
			};
			var Qs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fs.j:
							return !0;
						case Fs.l:
						case Fs.i:
						case Fs.m:
						case Fs.k:
						case Fs.h:
							return !1;
						default:
							return e
					}
				},
				Xs = Object(r.c)({
					error: Js,
					pending: Qs
				}),
				Zs = Object(r.c)({
					deleteDraft: Hs,
					listing: Ys,
					save: Xs
				});
			const $s = {};
			var eo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $s,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.E: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case f.q: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				to = Object(r.c)({
					pending: eo
				});
			var no = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.v:
					case f.w:
					case f.d:
					case f.e:
					case f.f:
					case f.j:
					case f.k:
					case f.o:
					case f.M:
						return null;
					case f.u:
						return t.payload;
					default:
						return e
				}
			};
			var ro = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.v:
							return !0;
						case f.w:
						case f.u:
							return !1;
						default:
							return e
					}
				},
				so = Object(r.c)({
					error: no,
					pending: ro
				}),
				oo = Object(r.c)({
					converting: to,
					mediaUpload: so
				});
			const io = {};
			var co = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : io,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.b:
					case Ge.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ge.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const ao = {};
			var uo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ao,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case Ge.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const lo = {};
			var bo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ge.b:
						case Ge.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				po = Object(r.c)({
					error: co,
					fetched: uo,
					pending: bo
				}),
				mo = n("./src/reddit/actions/scheduledPosts/constants.ts");
			const fo = {
				apiError: null,
				needsCaptcha: !1,
				pollError: void 0,
				validationError: null,
				submitValidationError: null
			};
			var go = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.N:
					case mo.d:
					case f.y:
					case f.c:
					case f.d:
					case f.e:
					case f.f:
					case f.j:
					case f.k:
					case f.o:
					case f.M:
					case f.C:
						return fo;
					case f.i: {
						const {
							isContentChanged: n
						} = t.payload;
						return n ? fo : e
					}
					case f.p: {
						const e = t.payload;
						return Object.assign({}, fo, {
							apiError: e
						})
					}
					case f.Y: {
						const e = t.payload;
						return Object.assign({}, fo, {
							validationError: e
						})
					}
					case f.I:
					case f.H: {
						const e = t.payload;
						return Object.assign({}, fo, {
							submitValidationError: e
						})
					}
					case f.a:
						return Object.assign({}, fo, {
							needsCaptcha: !0
						});
					case f.A:
						return Object.assign({}, fo, {
							pollError: t.payload
						});
					default:
						return e
				}
			};
			var Oo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.y:
							return !0;
						case f.N:
						case mo.d:
						case f.p:
						case f.Y:
						case f.H:
						case f.I:
						case f.A:
						case f.a:
							return !1;
						default:
							return e
					}
				},
				ho = Object(r.c)({
					error: go,
					pending: Oo
				});
			var yo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.z:
					case f.F:
						return null;
					case f.n:
						return t.payload;
					default:
						return e
				}
			};
			var jo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.z:
							return !0;
						case f.n:
						case f.m:
							return !1;
						default:
							return e
					}
				},
				_o = Object(r.c)({
					error: yo,
					pending: jo
				}),
				Eo = Object(r.c)({
					submit: ho,
					update: _o
				});
			var vo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.M:
					case f.K:
					case f.L:
						return null;
					default:
						return e
				}
			};
			var Io = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.L:
							return !0;
						case f.K:
						case f.M:
							return !1;
						default:
							return e
					}
				},
				So = Object(r.c)({
					error: vo,
					pending: Io
				}),
				To = Object(r.c)({
					change: So
				}),
				xo = Object(r.c)({
					collection: Us,
					draft: Zs,
					editor: oo,
					page: po,
					post: Eo,
					subreddit: To
				}),
				Co = n("./src/reddit/actions/pages/postDraft.ts");
			const wo = {};
			var Po = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fs.e: {
						const {
							postDrafts: e
						} = t.payload;
						return e || wo
					}
					case Fs.c: {
						const n = e,
							{
								draftId: r
							} = t.payload;
						return Sr()(n, r)
					}
					case f.N: {
						const {
							draftId: n
						} = t.payload;
						return n ? Sr()(e, n) : e
					}
					case Co.a: {
						const {
							drafts: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			const Do = e => {
					if (e.payload && e.payload.routeMatch) return e.payload.routeMatch.route.meta.name
				},
				Ro = e => {
					if (e.payload && e.payload.routeMatch && e.payload.routeMatch.match) return e.payload.routeMatch.match.queryParams
				},
				Ao = e => {
					if (e.payload && e.payload.routeMatch && e.payload.routeMatch.match) return e.payload.routeMatch.match.params
				};
			var ko = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.d:
							return t.payload || "";
						case f.C:
							return "";
						case m.a: {
							if (Do(t) !== xs.xb.POST_CREATION) return "";
							const n = Ro(t);
							return n && n.url ? n.url || "" : e
						}
						case Fs.g: {
							const e = t.payload;
							return e.kind === lr.b.Link && e.body || ""
						}
						case mo.f:
							return t.payload.url || "";
						default:
							return e
					}
				},
				No = (n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./src/reddit/models/ScheduledPost/index.ts"));
			const Lo = e => e ? e.replace(/\+/g, " ") : "";
			var Mo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.e:
							return t.payload || "";
						case f.C:
						case f.G:
							return "";
						case f.O:
							return t.payload.editorMode === ur.h.MARKDOWN ? t.payload.content || "" : e;
						case m.a: {
							if (Do(t) !== xs.xb.POST_CREATION) return "";
							const n = Ro(t);
							return n && n.text ? Lo(n.text) : e
						}
						case Fs.g: {
							const e = t.payload;
							return e.kind === lr.b.Markdown && e.body || ""
						}
						case mo.f: {
							const e = t.payload;
							return e.contentType === No.a.TEXT ? e.body : ""
						}
						default:
							return e
					}
				},
				Uo = n("./src/reddit/actions/upload.ts");
			var Fo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.f:
							return t.payload || null;
						case f.C:
							return null;
						case m.a:
							return Do(t) !== xs.xb.POST_CREATION ? null : e;
						case Fs.g:
							return null;
						case Uo.a:
						case Uo.f: {
							const {
								key: n
							} = t.payload;
							return n === ur.m ? null : e
						}
						case mo.f:
							return null;
						default:
							return e
					}
				},
				Bo = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				Go = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts");
			const Vo = Bo.a.createInitial;
			var qo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vo(),
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.i: {
							const {
								rteState: e
							} = t.payload;
							return e
						}
						case f.C:
							return Bo.a.createInitial();
						case f.O: {
							const n = t.payload;
							return n.editorMode === ur.h.RICH_TEXT && n.editorKey === ur.g.POST_CREATION ? Bo.a.createInitial(n.content) : e
						}
						case m.a:
							return Do(t) !== xs.xb.POST_CREATION ? Bo.a.createInitial() : e;
						case Fs.g: {
							const e = t.payload;
							return e.kind === lr.b.RichText ? Bo.a.createInitial(e.body) : Bo.a.createInitial()
						}
						case mo.f: {
							const e = t.payload;
							return Bo.a.createInitial(e.contentType === No.a.RTJSON ? Object(Go.b)(e.body) : void 0)
						}
						default:
							return e
					}
				},
				Ho = Object(r.c)({
					link: ko,
					markdown: Mo,
					media: Fo,
					rte: qo
				});
			var Ko = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b:
							return t.payload || null;
						case f.C:
						case Fs.g:
						case mo.f:
						case f.M:
							return null;
						case m.a:
							return Do(t) === xs.xb.POST_CREATION ? e : null;
						default:
							return e
					}
				},
				Wo = n("./src/reddit/selectors/scheduledPosts/index.ts");
			var Yo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.c:
						return t.payload || null;
					case mo.f: {
						const e = t.payload;
						return Object(Wo.g)({
							scheduledPost: e
						}) || null
					}
					case f.C:
						return null;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION ? e : null;
					case Fs.g:
						return t.payload.flair || null;
					default:
						return e
				}
			};
			var zo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.r:
						return t.payload.type || null;
					case mo.f:
					case f.j:
					case f.C:
					case m.a:
						return null;
					default:
						return e
				}
			};
			var Jo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.Q:
						return t.payload || !1;
					case mo.f:
					case f.C:
						return !1;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case Fs.g:
						return t.payload.isChatPost || !1;
					default:
						return e
				}
			};
			var Qo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.S:
						return t.payload || !1;
					case f.C:
						return !1;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case Fs.g:
						return t.payload.isNSFW || !1;
					case mo.f:
						return t.payload.isNsfw;
					default:
						return e
				}
			};
			var Xo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.T:
						return t.payload || !1;
					case f.C:
						return !1;
					case f.M: {
						const {
							name: n
						} = t.payload;
						return !!n && e
					}
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case Fs.g:
						return t.payload.isOriginalContent || !1;
					case mo.f:
						return t.payload.isOriginalContent;
					default:
						return e
				}
			};
			var Zo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.U:
						return t.payload || !1;
					case mo.f:
					case f.C:
						return !1;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					default:
						return e
				}
			};
			var $o = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mo.f:
					case f.C:
						return !1;
					case Fs.n:
						return t.payload;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case Fs.g:
						return t.payload.isPublicLink;
					default:
						return e
				}
			};
			var ei = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.V:
						return t.payload || !1;
					case f.C:
						return !1;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case Fs.g:
						return t.payload.isSpoiler || !1;
					case mo.f:
						return t.payload.isSpoiler;
					default:
						return e
				}
			};
			var ti = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.b: {
						const {
							subredditName: e
						} = t.payload;
						return e
					}
					case m.a:
					case f.j:
					case f.r:
					case f.C:
					case l.i:
						return "";
					default:
						return e
				}
			};
			var ni = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.c: {
						const {
							username: e
						} = t.payload;
						return e
					}
					case m.a:
					case f.j:
					case f.r:
					case f.C:
					case l.i:
						return "";
					default:
						return e
				}
			};
			var ri = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.L:
						case f.M:
							return t.payload;
						case f.K:
						case m.a:
							return null;
						default:
							return e
					}
				},
				si = n("./src/reddit/actions/polls.ts");
			var oi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case si.a:
						return Object.assign({}, t.payload);
					case mo.f:
					case l.i:
					case f.C:
						return null;
					default:
						return e
				}
			};
			var ii = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.g:
						return t.payload || null;
					case f.C:
					case Fs.g:
					case f.M:
						return null;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION ? e : null;
					case mo.f: {
						const e = t.payload;
						return {
							submitDate: e.publishAt,
							timezoneName: e.clientTimezone,
							frequencyOption: null,
							recurrenceInfo: null
						}
					}
					default:
						return e
				}
			};
			var ci = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				const {
					type: n,
					payload: r
				} = t;
				switch (n) {
					case f.W:
						return r || !1;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case mo.f:
					case Fs.g:
						return !1;
					default:
						return e
				}
			};
			var ai = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.h:
						return t.payload || "";
					case m.a:
						return Do(t) !== xs.xb.POST_CREATION ? "" : e;
					default:
						return e
				}
			};
			var di = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.a:
						return Do(t) !== xs.xb.POST_CREATION ? null : e;
					case f.C:
						return null;
					case mo.f:
						return t.payload.id;
					default:
						return e
				}
			};
			var ui = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.C:
						return !0;
					case f.X:
						return t.payload;
					case m.a:
						return Do(t) !== xs.xb.POST_CREATION || e;
					case Fs.g:
						return t.payload.sendReplies;
					case mo.f:
						return t.payload.isSendReplies;
					default:
						return e
				}
			};
			const li = xs.Fb.POST;
			var bi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : li,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.C:
						case p.d:
						case p.c:
							return li;
						case f.s:
							return xs.Fb.CROSSPOST;
						case p.a:
							return xs.Fb.MEDIA;
						case f.j:
							return t.payload.submissionType || li;
						case m.a: {
							if (Do(t) !== xs.xb.POST_CREATION) return li;
							const n = Ro(t);
							if (!n) return e;
							const {
								title: r = "",
								url: s,
								text: o = "",
								media: i = !1,
								selftext: c = !1
							} = n, a = r && !o && !c;
							return i ? xs.Fb.MEDIA : void 0 !== s || a ? xs.Fb.LINK_ONLY : o || c ? xs.Fb.POST : e
						}
						case Fs.g: {
							const e = t.payload;
							return lr.a[e.kind]
						}
						case mo.f:
							return t.payload.url ? xs.Fb.LINK_ONLY : xs.Fb.POST;
						default:
							return e
					}
				},
				pi = n("./src/reddit/models/Poll/index.ts");
			const mi = e => e ? e.replace(/\+/g, " ") : "",
				fi = e => "Should ".concat(e || "username", " become the top moderator?"),
				gi = e => e ? "Should we spin-off to r/".concat(e, "?") : "Should we spin-off to a new community?";
			var Oi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.s:
							return t.payload.postTitle || "";
						case f.k:
							return t.payload || "";
						case f.B: {
							const {
								title: n
							} = t.payload;
							return e || (n || "")
						}
						case f.C:
						case p.d:
						case p.c:
							return "";
						case m.a: {
							if (Do(t) !== xs.xb.POST_CREATION) return "";
							const n = Ro(t);
							return n && n.title ? mi(n.title) : e
						}
						case Fs.g:
							return t.payload.title;
						case f.r: {
							const {
								oldType: n,
								type: r
							} = t.payload;
							return r === pi.a.ReplaceTopMod ? fi("") : r === pi.a.Spinoff ? gi("") : n === pi.a.ReplaceTopMod || n === pi.a.Spinoff ? "" : e
						}
						case l.c: {
							const {
								username: e
							} = t.payload;
							return fi(e)
						}
						case l.b: {
							const {
								subredditName: e
							} = t.payload;
							return gi(e)
						}
						case f.j: {
							const {
								extra: n
							} = t.payload;
							return !n || n.govType !== pi.a.ReplaceTopMod && n.govType !== pi.a.Spinoff ? e : ""
						}
						case mo.f:
							return t.payload.title;
						default:
							return e
					}
				},
				hi = Object(r.c)({
					body: Ho,
					eventSchedule: Ko,
					flair: Yo,
					govType: zo,
					isChatPost: Jo,
					isNSFW: Qo,
					isOC: Xo,
					isPoll: Zo,
					isPublicLink: $o,
					isSpoiler: ei,
					newSubreddit: ti,
					newTopMod: ni,
					nextSubreddit: ri,
					polls: oi,
					postSchedule: ii,
					postToTwitter: ci,
					recaptcha: ai,
					scheduledPostId: di,
					sendReplies: ui,
					submissionType: bi,
					title: Oi
				});
			var yi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.a:
						return Do(t) === xs.xb.POST_CREATION ? e : null;
					case f.F: {
						const {
							editorMode: e
						} = t.payload;
						return e
					}
					case f.G:
						return null;
					case f.O: {
						const {
							editorMode: e
						} = t.payload;
						return e
					}
					case mo.f:
						return t.payload.contentType === No.a.RTJSON ? ur.h.RICH_TEXT : ur.h.MARKDOWN;
					default:
						return e
				}
			};
			const ji = {
					title: [],
					body: [],
					link: [],
					flair: []
				},
				_i = (e, t) => {
					const n = (t.fields || []).filter(e => {
						let {
							field: t
						} = e;
						return Object(ur.v)(t)
					});
					if (!n.length) return e;
					const r = n.reduce((e, t) => (e[t.field] || (e[t.field] = []), e[t.field].push(t.msg), e), {});
					return Object.assign({}, e, r)
				};
			var Ei = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ji,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.c:
					case f.d:
					case f.e:
						return e[xs.kb.BODY] ? Object.assign({}, e, {
							[xs.kb.BODY]: []
						}) : e;
					case f.i: {
						const {
							isContentChanged: n
						} = t.payload;
						return e[xs.kb.BODY] && n ? Object.assign({}, e, {
							[xs.kb.BODY]: []
						}) : e
					}
					case f.k:
						return e[xs.kb.TITLE] ? Object.assign({}, e, {
							[xs.kb.TITLE]: []
						}) : e;
					case f.J: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n]: []
						})
					}
					case f.o: {
						const n = t.payload;
						return n ? Object.assign({}, e, {
							[n]: []
						}) : ji
					}
					case f.I:
					case f.H: {
						const n = t.payload;
						return _i(e, n)
					}
					case m.a:
						return Do(t) !== xs.xb.POST_CREATION ? ji : e;
					default:
						return e
				}
			};
			var vi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.b:
					case f.c:
					case f.d:
					case f.e:
					case f.f:
					case f.g:
					case f.k:
					case f.j:
					case f.S:
					case f.T:
					case f.V:
					case Fs.n:
					case f.X:
						return !0;
					case f.i: {
						const {
							isContentChanged: n
						} = t.payload;
						return !!n || e
					}
					case f.N:
					case mo.d:
						return !1;
					case f.P:
						return t.payload;
					case m.a:
						return Do(t) === xs.xb.POST_CREATION && e;
					case f.C:
					case Fs.l:
					case Fs.g:
						return !1;
					default:
						return e
				}
			};
			var Ii = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.x:
						return e === t.payload ? null : t.payload || null;
					case s.c:
						return t.payload ? null : e;
					case m.a:
						return Do(t) !== xs.xb.POST_CREATION ? null : e;
					default:
						return e
				}
			};
			const Si = ur.r.Post;
			var Ti = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Si,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.y:
							return ur.r.Post;
						case f.D:
							return t.payload;
						case Fs.j:
							return ur.r.Draft;
						case m.a:
							return Do(t) !== xs.xb.POST_CREATION ? Si : e;
						default:
							return e
					}
				},
				xi = Object(r.c)({
					editorMode: yi,
					fieldValidation: Ei,
					isChanged: vi,
					modalId: Ii,
					submitMode: Ti
				});
			var Ci = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.F:
						return t.payload.editorMode === ur.h.MARKDOWN ? t.payload.postContent || "" : e;
					case f.G:
						return "";
					case f.O:
						return t.payload.editorMode === ur.h.MARKDOWN ? t.payload.content || "" : e;
					default:
						return e
				}
			};
			const wi = Bo.a.createInitial;
			var Pi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wi(),
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.G:
							return Bo.a.createInitial();
						case f.F: {
							const n = t.payload;
							return n.editorMode === ur.h.RICH_TEXT && "object" == typeof n.postContent ? Bo.a.createInitial(n.postContent, n.mediaMetadata) : e
						}
						case f.O: {
							const n = t.payload;
							return n.editorMode === ur.h.RICH_TEXT && n.editorKey === ur.g.POST_EDITING ? Bo.a.createInitial(n.content) : e
						}
						default:
							return e
					}
				},
				Di = Object(r.c)({
					markdown: Ci,
					rte: Pi
				});
			var Ri = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.F: {
							const {
								postId: e
							} = t.payload;
							return e
						}
						case f.G:
							return null;
						default:
							return e
					}
				},
				Ai = Object(r.c)({
					draft: Di,
					postId: Ri
				}),
				ki = Object(r.c)({
					api: xo,
					drafts: Po,
					formData: hi,
					formState: xi,
					postEditing: Ai
				}),
				Ni = n("./src/reddit/actions/dashboard.ts");
			const Li = {
				selectedComponent: null,
				subredditPending: !1,
				subredditLoaded: {}
			};
			var Mi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Li,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ni.a:
						return Object.assign({}, e, {
							selectedComponent: t.payload
						});
					case Ni.c: {
						const n = t.payload,
							r = e.subredditLoaded[n];
						return Object.assign({}, e, {
							subredditPending: !r,
							subredditLoaded: Object.assign({}, e.subredditLoaded, {
								[n]: r || !1
							})
						})
					}
					case Ni.b: {
						const n = t.payload;
						return Object.assign({}, e, {
							subredditPending: !1,
							subredditLoaded: Object.assign({}, e.subredditLoaded, {
								[n]: !0
							})
						})
					}
					default:
						return e
				}
			};
			var Ui = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.b:
					case Le.c:
						return null;
					case Le.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			var Fi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.c:
						return !1;
					case Le.b:
						return !0;
					default:
						return e
				}
			};
			var Bi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.c:
							return !0;
						case Le.b:
						case Le.a:
							return !1;
						default:
							return e
					}
				},
				Gi = Object(r.c)({
					error: Ui,
					loaded: Fi,
					pending: Bi
				}),
				Vi = Object(r.c)({
					list: Gi
				});
			const qi = {};
			var Hi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.b: {
						const {
							discoveryUnits: n
						} = t.payload;
						return gn()(n) ? e : Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			const Ki = {};
			var Wi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ki,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.b: {
							const {
								discoveryUnits: n
							} = t.payload;
							if (gn()(n)) return e;
							const r = {};
							return En()(n, e => {
								r[Object(vn.f)(e.unitName)] = e.id
							}), Object.assign({}, e, r)
						}
						default:
							return e
					}
				},
				Yi = Object(r.c)({
					api: Vi,
					models: Hi,
					nameToId: Wi
				}),
				zi = n("./src/reddit/actions/dismissedTruncationList/constants.ts");
			const Ji = [];
			var Qi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ji,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case zi.a: {
							const {
								subredditId: n
							} = t.payload;
							return [...e, n]
						}
						default:
							return e
					}
				},
				Xi = n("./src/reddit/models/Badge/managementPage.ts");
			const Zi = {
				badgeType: Xi.a.Cosmetic,
				view: Xi.c.Gallery
			};
			var $i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.d: {
						const {
							badge: n,
							initialView: r
						} = t.payload;
						return n || r ? Object.assign({}, e, {
							badgeType: n ? Object(Xi.d)(n.placement) : e.badgeType,
							view: r
						}) : e
					}
					case d.c: {
						const n = t.payload;
						return Object.assign({}, e, {
							badgeType: n
						})
					}
					case d.e: {
						const n = t.payload;
						return Object.assign({}, e, {
							view: n
						})
					}
					case s.b:
						return Zi;
					default:
						return e
				}
			};
			var ec = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.d:
						return {
							badge: t.payload.badge
						};
					case s.b:
						return null;
					case d.g:
						return t.payload;
					case d.k:
						return t.payload || null;
					default:
						return e
				}
			};
			var tc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case u.a:
						return t.payload;
					case s.b:
						return null;
					default:
						return e
				}
			};
			const nc = {};
			var rc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.f: {
							const {
								emotes: n,
								emoteCollections: r
							} = t.payload.products, s = {};
							return n.forEach(e => {
								const t = e.extra && e.extra.assets,
									n = Object.keys(e.collections || {})[0] || e.title,
									o = r[n];
								s[n] || (s[n] = {
									emotes: {},
									position: o ? o.position : 0,
									title: o ? o.title : e.title
								}), t && Object.keys(t).forEach(r => {
									const o = t[r];
									s[n].emotes[r] = {
										id: r,
										emoji: o.emoji,
										extra: {
											rtDescription: e.extra && e.extra.rtDescription
										},
										fullId: "emote|".concat(e.id, "|").concat(r),
										imageType: o.emoji.type,
										sticker: o.sticker
									}
								})
							}), Object.assign({}, e, {
								[t.payload.subredditId]: Object.keys(s).map(e => s[e]).sort((e, t) => e.position - t.position)
							})
						}
						default:
							return e
					}
				},
				sc = n("./src/reddit/actions/economics/ftue/constants.ts");
			const oc = {
				tippingHighlightViewed: null,
				topTippersViewed: null
			};
			var ic = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sc.a:
						return Object.assign({}, e, {
							tippingHighlightViewed: !0
						});
					case sc.b:
						return Object.assign({}, e, {
							tippingHighlightViewed: !0,
							topTippersViewed: !0
						});
					default:
						return e
				}
			};
			const cc = {};
			var ac = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.f: {
							const n = t.payload.products.giphy.length > 0;
							return Object.assign({}, e, {
								[t.payload.subredditId]: {
									hasGifProduct: n
								}
							})
						}
						default:
							return e
					}
				},
				dc = n("./src/reddit/reducers/economics/paymentSystems/index.ts");
			const uc = {
				allSubscriptionsFetched: !1,
				data: {}
			};
			var lc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.a: {
							const n = t.payload;
							return {
								allSubscriptionsFetched: !0,
								data: Object.assign({}, e.data, n)
							}
						}
						case d.i: {
							const {
								subredditId: n
							} = t.payload;
							return e.data[n] ? Object.assign({}, e, {
								data: Object.assign({}, e.data, {
									[n]: Object.assign({}, e.data[n], {
										settings: {
											renew: !1
										}
									})
								})
							}) : e
						}
						default:
							return e
					}
				},
				bc = n("./src/reddit/reducers/economics/subredditPremium/index.ts"),
				pc = n("./src/reddit/actions/economics/tips/constants.ts"),
				mc = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const fc = {};
			var gc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pc.a: {
							const {
								subredditId: n,
								tipData: r
							} = t.payload, s = e[n] || {};
							return Object.assign({}, e, {
								[n]: Object.assign({}, s, r)
							})
						}
						case u.b: {
							const {
								accountId: n,
								accountUsername: r,
								anonymous: s,
								amount: o,
								contentId: i,
								subredditId: c
							} = t.payload, a = e[c] || {}, d = a[i] || {}, u = d.amounts || {
								usdr: {
									amount: "0",
									users: {}
								}
							}, l = u.usdr, b = l.amount || "0", p = String(parseInt(b) + parseInt(o)), m = u.usdr.users || {}, {
								anonymous: f = {
									amount: "0",
									includesUser: !1,
									numUsers: 0
								}
							} = m, g = mc(m, ["anonymous"]), O = s ? Object.assign({}, g, {
								anonymous: {
									amount: String(parseInt(f.amount) + parseInt(o)),
									includesUser: !0,
									numUsers: f.includesUser ? f.numUsers : f.numUsers + 1
								}
							}) : Object.assign({}, m, {
								[n]: Object.assign({}, m[n] || {}, {
									amount: m[n] ? String(parseInt(m[n].amount || "0") + parseInt(o)) : o,
									username: r
								})
							});
							return Object.assign({}, e, {
								[c]: Object.assign({}, a, {
									[i]: Object.assign({}, d, {
										amounts: Object.assign({}, u, {
											usdr: Object.assign({}, l, {
												amount: p,
												users: O
											})
										})
									})
								})
							})
						}
						default:
							return e
					}
				},
				Oc = Object(r.c)({
					currentBadgeManagementScreen: $i,
					currentModalArgs: ec,
					currentPaymentTarget: tc,
					emotes: rc,
					ftue: ic,
					gifs: ac,
					paymentSystems: dc.b,
					specialMemberships: lc,
					subredditPremium: bc.b,
					tipDetails: gc
				}),
				hc = n("./src/reddit/actions/emoji.ts"),
				yc = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const jc = {};
			var _c = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hc.h: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case hc.g: {
							const {
								subredditId: n
							} = t.payload, r = n;
							e[r];
							return yc(e, ["symbol" == typeof r ? r : r + ""])
						}
						case hc.f: {
							const {
								subredditId: n
							} = t.payload, r = n;
							e[r];
							return yc(e, ["symbol" == typeof r ? r : r + ""])
						}
						default:
							return e
					}
				},
				Ec = Object(r.c)({
					pending: _c
				}),
				vc = Object(r.c)({
					list: Ec
				}),
				Ic = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const Sc = {};
			var Tc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hc.f:
						case hc.c:
							return e;
						case hc.g: {
							const {
								data: e
							} = t.payload;
							return e
						}
						case hc.d: {
							const {
								emojiName: n,
								subredditId: r
							} = t.payload, s = e[r].emojis, o = n, i = (s[o], Ic(s, ["symbol" == typeof o ? o : o + ""]));
							return Object.assign({}, e, {
								[r]: Object.assign({}, e[r], {
									emojis: i
								})
							})
						}
						case hc.i: {
							const n = t.payload,
								r = e[n.subredditId].emojis,
								s = {
									url: n.url,
									name: n.name,
									userFlairAllowed: n.userFlairAllowed,
									postFlairAllowed: n.postFlairAllowed,
									modFlairOnly: n.modFlairOnly
								},
								o = Object.assign({}, r, {
									[n.name]: s
								});
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, e[n.subredditId], {
									emojis: o
								})
							})
						}
						case hc.e: {
							const {
								emojiName: n,
								isSnoomoji: r,
								settings: s,
								subredditId: o
							} = t.payload, i = r ? "snoomojis" : "emojis", c = e[o][i], a = Object.assign({}, c, {
								[n]: Object.assign({}, c[n], s)
							});
							return Object.assign({}, e, {
								[o]: Object.assign({}, e[o], {
									[i]: a
								})
							})
						}
						default:
							return e
					}
				},
				xc = Object(r.c)({
					api: vc,
					models: Tc
				}),
				Cc = n("./src/reddit/actions/experiments.ts");
			const wc = /^experiment_(.*)$/i,
				Pc = e => {
					const t = e.match(wc);
					if (null !== t) return t[1]
				},
				Dc = {};
			var Rc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.a: {
							const n = Ro(t);
							if (!n) return e;
							const r = {};
							for (const e in n) {
								const t = Pc(e);
								t && (r[t.toLowerCase()] = n[e] || "")
							}
							return gn()(r) ? e : Object.assign({}, e, r)
						}
						case Cc.b: {
							const {
								experimentName: n,
								override: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[n]: r || ""
							}) : e
						}
						default:
							return e
					}
				},
				Ac = n("./src/reddit/actions/externalAccount.ts");
			const kc = {};
			var Nc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ac.e:
					case Ac.f: {
						const {
							provider: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ac.d: {
						const {
							provider: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Lc = {};
			var Mc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ac.e: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ac.f:
						case Ac.d: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Uc = Object(r.c)({
					error: Nc,
					pending: Mc
				});
			const Fc = {};
			var Bc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ac.l:
					case Ac.k: {
						const {
							provider: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ac.j: {
						const {
							provider: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Gc = {};
			var Vc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ac.b: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ac.c:
						case Ac.a: {
							const {
								provider: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				qc = Object(r.c)({
					error: Bc,
					pending: Vc
				});
			const Hc = {};
			var Kc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ac.i:
					case Ac.h: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ac.g: {
						const {
							subredditName: n,
							apiError: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Wc = {};
			var Yc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ac.h: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const zc = {};
			var Jc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ac.i: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ac.h:
						case Ac.g: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Qc = Object(r.c)({
					error: Kc,
					fetched: Yc,
					pending: Jc
				});
			const Xc = {};
			var Zc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ac.l:
					case Ac.k: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ac.j: {
						const {
							username: n,
							apiError: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const $c = {};
			var ea = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $c,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ac.l: {
							const {
								username: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ac.k:
						case Ac.j: {
							const {
								username: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				ta = Object(r.c)({
					error: Zc,
					pending: ea
				}),
				na = Object(r.c)({
					connect: Uc,
					disconnect: qc,
					user: ta,
					subreddit: Qc
				});
			const ra = {};
			var sa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ra,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ac.h: {
						const {
							subredditName: n,
							accountsData: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const oa = {};
			var ia = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oa,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ac.k: {
							const {
								username: n,
								accountsData: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case Ac.c: {
							const {
								username: n,
								provider: r
							} = t.payload, s = e[n];
							return s && s[r] ? Object.assign({}, e, {
								[n]: Sr()(s, r)
							}) : e
						}
						default:
							return e
					}
				},
				ca = Object(r.c)({
					api: na,
					user: ia,
					subreddit: sa
				}),
				aa = n("./src/reddit/featureFlags/index.ts");
			const da = new Set(["0", "disabled", "false", "off", ""]);
			var ua = e => !da.has(e.toLowerCase());
			const la = aa.a.reduce((e, t) => (e[t.toLowerCase()] = t, e), {}),
				ba = aa.a.reduce((e, t) => (e[t] = null, e), {});
			var pa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ba,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.a: {
							const n = Ro(t);
							if (void 0 !== n) {
								const t = {};
								for (const e in n) {
									const r = Object(aa.g)(e);
									if (r) {
										const s = la[r.toLowerCase()];
										if (s) {
											const r = n[e],
												o = "string" != typeof r || ua(r);
											t[s] = o
										}
									}
								}
								if (Object.keys(t).length > 0) return Object.assign({}, e, t)
							}
							return e
						}
						case aa.b: {
							const {
								featureName: n,
								currentValue: r
							} = t.payload;
							return r === e[n] ? e : Object.assign({}, e, {
								[n]: r
							})
						}
						case aa.c: {
							const {
								featureName: n,
								currentValue: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !r
							})
						}
						default:
							return e
					}
				},
				ma = Object(r.c)({
					overrides: pa
				});
			var fa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g:
					case te.i:
						return null;
					case te.f:
						return t.payload;
					default:
						return e
				}
			};
			var ga = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.i:
							return !0;
						case te.g:
						case te.f:
							return !1;
						default:
							return e
					}
				},
				Oa = Object(r.c)({
					error: fa,
					pending: ga
				});
			const ha = {};
			var ya = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ha,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g:
					case te.k: {
						const {
							subredditId: n,
							flairedUsers: r
						} = t.payload;
						return Re()(Object.assign({}, e), {
							[n]: r
						})
					}
					case te.c: {
						const {
							subredditId: n,
							userName: r
						} = t.payload, s = Sr()(e[n], r);
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case te.a:
					case te.b:
					case te.h:
						const {
							subredditId: n, userName: r, applied: s
						} = t.payload;
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								[r]: s
							})
						}) : e;
					default:
						return e
				}
			};
			const ja = {};
			var _a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ja,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g: {
						const {
							key: n,
							pageInfo: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			var Ea = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.l:
					case te.k:
						return null;
					case te.j:
						return t.payload;
					default:
						return e
				}
			};
			var va = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.l:
							return !0;
						case te.k:
						case te.j:
							return !1;
						default:
							return e
					}
				},
				Ia = Object(r.c)({
					error: Ea,
					pending: va
				});
			var Sa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case te.c: {
							const {
								userName: n
							} = t.payload;
							return e === n ? null : e
						}
						default:
							return e
					}
				},
				Ta = Object(r.c)({
					api: Ia,
					result: Sa
				});
			const xa = {};
			var Ca = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xa,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.g: {
							const {
								key: n,
								userOrder: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case te.a: {
							const {
								key: n,
								userName: r
							} = t.payload;
							if (!n) return e;
							if (!e[n].includes(r)) {
								const t = [...e[n], r];
								return Object.assign({}, e, {
									[n]: t
								})
							}
							return e
						}
						case te.c: {
							const {
								userName: n
							} = t.payload, r = {};
							for (const t in e) r[t] = e[t].filter(e => e !== n);
							return r
						}
						default:
							return e
					}
				},
				wa = Object(r.c)({
					api: Oa,
					models: ya,
					pageInfo: _a,
					search: Ta,
					userOrder: Ca
				}),
				Pa = n("./src/reddit/actions/focusedVerticals/constants.ts");
			const Da = {
				focusedVerticalGqlError: null
			};
			var Ra = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Da,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pa.f:
					case Pa.e:
						return Object.assign({}, e, {
							focusedVerticalGqlError: null
						});
					case Pa.d:
						return Object.assign({}, e, {
							focusedVerticalGqlError: t.payload
						});
					default:
						return e
				}
			};
			const Aa = {
				focusedVerticalGqlPending: !1
			};
			var ka = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Aa,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Pa.f:
							return Object.assign({}, e, {
								focusedVerticalGqlPending: !0
							});
						case Pa.d:
						case Pa.e:
							return Object.assign({}, e, {
								focusedVerticalGqlPending: !1
							});
						default:
							return e
					}
				},
				Na = Object(r.c)({
					error: Ra,
					pending: ka
				});
			const La = {
				dismissed: !0
			};
			var Ma = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : La,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pa.h:
						return {
							dismissed: !1
						};
					case Pa.g:
						return {
							dismissed: !0
						};
					default:
						return e
				}
			};
			var Ua = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pa.e:
						return t.payload.interactedSubredditIds || null;
					default:
						return e
				}
			};
			var Fa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Pa.e:
							return t.payload.recommendedSubredditIds || null;
						default:
							return e
					}
				},
				Ba = Object(r.c)({
					api: Na,
					components: Ma,
					interactedSubredditIds: Ua,
					recommendedSubredditIds: Fa
				}),
				Ga = n("./src/lib/makeActionCreator/index.ts");
			Object(Ga.a)("FONTS_FONT_FILES_PARSED");
			const Va = [];
			var qa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Va,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "FONTS_FONT_FILES_PARSED":
						return t.payload.fonts;
					default:
						return e
				}
			};
			var Ha = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.m:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg || "An unknown error occurred";
					case Oe.b:
					case m.a:
					case Oe.G:
					case Oe.q:
						return null;
					default:
						return e
				}
			};
			var Ka = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.b:
					case m.a:
					case Oe.q:
					case Oe.m:
						return !1;
					case Oe.n:
						return !0;
					default:
						return e
				}
			};
			var Wa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.n:
						case Oe.b:
						case m.a:
						case Oe.q:
						case Oe.m:
							return !1;
						case Oe.r:
							return !0;
						default:
							return e
					}
				},
				Ya = Object(r.c)({
					error: Ha,
					pending: Ka,
					showLoader: Wa
				});
			var za = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				const n = t.payload;
				switch (t.type) {
					case Oe.F:
					case Oe.G:
						return n.gildModalId;
					case Oe.q:
					case m.a:
					case Oe.b:
						return null;
					default:
						return e
				}
			};
			var Ja = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				const n = t.payload;
				switch (t.type) {
					case Oe.F:
					case Oe.G:
						return n.thingId;
					case Oe.q:
					case m.a:
					case Oe.b:
						return null;
					default:
						return e
				}
			};
			var Qa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.u:
						return t.payload;
					case Oe.t:
					case Oe.G:
						return null;
					default:
						return e
				}
			};
			var Xa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.o:
						return t.payload;
					case Oe.G:
						return !1;
					default:
						return e
				}
			};
			var Za = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.p:
						return t.payload;
					case Oe.G:
						return !1;
					default:
						return e
				}
			};
			var $a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.F:
						return !0;
					default:
						return e
				}
			};
			var ed = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.s:
						return t.payload;
					case Oe.G:
						return "";
					default:
						return e
				}
			};
			const td = Ne.i;
			var nd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : td,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.J:
							return t.payload;
						case Oe.G:
							return td;
						default:
							return e
					}
				},
				rd = Object(r.c)({
					api: Ya,
					gildModalId: za,
					gildModalThingId: Ja,
					includeMessage: Xa,
					isAnonymous: Za,
					isIframed: $a,
					message: ed,
					giveAwardTooltipThingId: Qa,
					selectedAward: nd
				});
			var sd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Oe.v:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg || "An unknown error occurred";
					case Oe.c:
					case m.a:
					case Oe.H:
					case Oe.A:
						return null;
					default:
						return e
				}
			};
			var od = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.c:
						case m.a:
						case Oe.A:
						case Oe.v:
							return !1;
						case Oe.w:
							return !0;
						default:
							return e
					}
				},
				id = Object(r.c)({
					error: sd,
					pending: od
				});
			var cd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oe.H:
							return t.payload;
						case m.a:
						case Oe.c:
						case Oe.A:
							return "";
						default:
							return e
					}
				},
				ad = Object(r.c)({
					api: id,
					givePremiumModalAccountName: cd
				}),
				dd = n("./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts"),
				ud = n("./src/reddit/actions/goldPurchaseModals/constants.ts");
			var ld = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "selectPayment",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case dd.b:
						return "selectPayment";
					case ud.f:
						return "paymentCompleted";
					default:
						return e
				}
			};
			var bd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case dd.a:
					case Oe.b:
					case Oe.q:
						return null;
					case dd.c:
						return t.payload && t.payload.thingId ? t.payload.thingId : e;
					default:
						return e
				}
			};
			var pd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case dd.b: {
						const {
							coinPackage: e
						} = t.payload;
						return e
					}
					case ud.f:
					case dd.a:
						return null;
					default:
						return e
				}
			};
			var md = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dd.b:
							return !0;
						case Oe.G:
						case m.a:
						case dd.a:
							return !1;
						default:
							return e
					}
				},
				fd = Object(r.c)({
					activePage: ld,
					gildThingId: bd,
					purchasePackage: pd,
					showModal: md
				}),
				gd = n("./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts");
			var Od = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.b: {
						const {
							cardName: e
						} = t.payload;
						return e
					}
					case ud.i:
						return t.payload !== xs.tb ? "" : e;
					case dd.a:
					case gd.a:
					case ud.c:
					case m.a:
						return "";
					default:
						return e
				}
			};
			var hd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.l: {
						const {
							error: n,
							elementType: r
						} = t.payload;
						return "cardCvc" === r ? n && n.message || "" : e
					}
					case ud.i:
						return t.payload !== xs.tb ? "" : e;
					case dd.a:
					case gd.a:
					case ud.c:
					case m.a:
						return "";
					default:
						return e
				}
			};
			var yd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.l: {
						const {
							error: n,
							elementType: r
						} = t.payload;
						return "cardExpiry" === r ? n && n.message || "" : e
					}
					case ud.i:
						return t.payload !== xs.tb ? "" : e;
					case dd.a:
					case gd.a:
					case ud.c:
					case m.a:
						return "";
					default:
						return e
				}
			};
			var jd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.l: {
						const {
							error: n,
							elementType: r
						} = t.payload;
						return "cardNumber" === r ? n && n.message || "" : e
					}
					case ud.i:
						return t.payload !== xs.tb ? "" : e;
					case dd.a:
					case gd.a:
					case ud.c:
					case m.a:
						return "";
					default:
						return e
				}
			};
			var _d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.a:
						return t.payload.message || e;
					case ud.b:
						return "";
					case ud.i:
						return t.payload !== xs.tb ? "" : e;
					case dd.a:
					case gd.a:
					case ud.c:
					case m.a:
						return "";
					default:
						return e
				}
			};
			var Ed = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ud.l: {
							const {
								error: n,
								elementType: r
							} = t.payload;
							return "postalCode" === r ? n && n.message || "" : e
						}
						case ud.i:
							return t.payload !== xs.tb ? "" : e;
						case dd.a:
						case gd.a:
						case ud.c:
						case m.a:
							return "";
						default:
							return e
					}
				},
				vd = Object(r.c)({
					cardCvc: hd,
					cardExpiry: yd,
					cardNumber: jd,
					nameOnCard: _d,
					postalCode: Ed
				});
			const Id = xs.ub;
			var Sd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Id,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case dd.b:
					case gd.b:
						return Id;
					case ud.i:
						return t.payload;
					default:
						return e
				}
			};
			var Td = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.g:
						return t.payload || e;
					case ud.i: {
						const {
							method: n
						} = t.payload;
						return n === xs.ub ? null : e
					}
					case dd.b:
					case gd.b:
					case Oe.G:
						return null;
					default:
						return e
				}
			};
			var xd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dd.b:
						case gd.b:
							return "";
						case dd.d:
						case gd.c: {
							const e = t.payload;
							return e.body && e.body.passthrough ? e.body.passthrough : ""
						}
						default:
							return e
					}
				},
				Cd = Object(r.c)({
					errorMessage: Td,
					passthrough: xd
				});
			var wd = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.o:
						return !e;
					case ud.i:
						return t.payload !== xs.tb || e;
					case dd.a:
					case gd.a:
					case m.a:
						return !0;
					default:
						return e
				}
			};
			const Pd = [];
			var Dd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.e:
						return t.payload;
					case ud.d: {
						const n = t.payload;
						return e.filter(e => e.cardId !== n)
					}
					default:
						return e
				}
			};
			var Rd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.h:
						return !0;
					case ud.e:
						return !1;
					default:
						return e
				}
			};
			var Ad = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ud.a:
					case ud.m:
						return t.payload.message || e;
					case ud.k:
						return t.payload;
					case ud.l:
					case ud.b:
					case ud.n:
						return null;
					case ud.i:
						return t.payload === xs.tb ? null : e;
					default:
						return e
				}
			};
			var kd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ud.a:
						case ud.k:
						case ud.m:
							return !1;
						case ud.i:
							return t.payload !== xs.tb && e;
						case ud.n:
							return !0;
						default:
							return e
					}
				},
				Nd = Object(r.c)({
					errorMessage: Ad,
					pending: kd
				});
			var Ld = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ud.j:
							return t.payload;
						case ud.d:
							return t.payload === e ? null : e;
						default:
							return e
					}
				},
				Md = Object(r.c)({
					cardName: Od,
					cardValidation: vd,
					paymentMethod: Sd,
					paypal: Cd,
					rememberCard: wd,
					savedCards: Dd,
					savedCardsPending: Rd,
					stripeToken: Nd,
					useSavedCard: Ld
				});
			var Ud = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "selectPayment",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gd.b:
						return "selectPayment";
					case ud.f:
						return "paymentCompleted";
					default:
						return e
				}
			};
			var Fd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gd.b:
							return !0;
						case m.a:
						case gd.a:
							return !1;
						default:
							return e
					}
				},
				Bd = Object(r.c)({
					activePage: Ud,
					showModal: Fd
				});
			var Gd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ud.p:
						case ud.r:
							return !1;
						case ud.q:
							return !0;
						default:
							return e
					}
				},
				Vd = Object(r.c)({
					pending: Gd
				}),
				qd = Object(r.c)({
					coinPurchaseModal: fd,
					payment: Md,
					premiumPurchaseModal: Bd,
					updateCardModal: Vd
				}),
				Hd = n("./src/reddit/actions/header.ts"),
				Kd = n("./src/reddit/actions/overlayEvents.ts");
			var Wd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Hd.a:
							return !1;
						case Hd.b:
							return !0;
						case Hd.c:
							return !e;
						case Kd.b:
							return !1;
						default:
							return e
					}
				},
				Yd = Object(r.c)({
					isSubscriptionsDropdownOpen: Wd
				}),
				zd = n("./src/reddit/actions/imageUploads.ts");
			const Jd = {};
			var Qd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jd,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case zd.d: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.id]: n
							})
						}
						case zd.c:
						case zd.e:
						case zd.b: {
							const n = t.payload;
							return e[n.id] ? Object.assign({}, e, {
								[n.id]: n
							}) : e
						}
						case zd.a: {
							const n = t.payload;
							if (!e[n.id]) return e;
							const r = Object.assign({}, e);
							return delete r[n.id], r
						}
						default:
							return e
					}
				},
				Xd = n("./src/reddit/actions/emailVerificationTooltip.ts");
			var Zd = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xd.a:
							return !e;
						default:
							return e
					}
				},
				$d = n("./src/reddit/actions/moderatingSubreddits.ts");
			var eu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $d.a: {
							if (e) return e;
							const n = t.payload;
							return Object.keys(n).some(e => !0 === n[e].posts)
						}
						case ae.b:
						case Fe.b:
						case re.b:
						case Ge.b: {
							if (e) return e;
							const {
								payload: n
							} = t;
							return n.subredditPermissions && n.subreddits ? n.subredditPermissions.posts : e
						}
						case ne.i:
						case ne.f:
						case ne.m:
						case ne.p:
						case ne.v: {
							if (e) return e;
							const {
								response: n
							} = t.payload, {
								moderatingSubreddits: r,
								moderatingProfiles: s
							} = n;
							let o = Object.keys(r).some(e => !0 === r[e].posts);
							if (!o) {
								o = Object.keys(s).some(e => !0 === r[e].posts)
							}
							return o
						}
						default:
							return e
					}
				},
				tu = n("./src/reddit/actions/jsApi.ts");
			const nu = [];
			var ru = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tu.a: {
						const n = t.payload;
						return -1 === e.indexOf(n) && (e = [...e, n]).sort(), e
					}
					default:
						return e
				}
			};
			var su = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.f:
						return t.payload;
					case p.a:
					case p.d:
					case p.b:
						return null;
					default:
						return e
				}
			};
			var ou = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.a:
						return t.payload.background;
					default:
						return e
				}
			};
			var iu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.a:
						return t.payload.box;
					default:
						return e
				}
			};
			var cu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.a:
							return Date.now();
						default:
							return e
					}
				},
				au = Object(r.c)({
					draft: su,
					editorBackground: ou,
					layerBox: iu,
					startTime: cu
				}),
				du = n("./src/reddit/actions/leaderboard/constants.ts"),
				uu = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const lu = {};
			var bu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case du.b: {
							const {
								key: n,
								data: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case du.c:
						case du.d: {
							const {
								key: n
							} = t.payload, r = n;
							e[r];
							return uu(e, ["symbol" == typeof r ? r : r + ""])
						}
						default:
							return e
					}
				},
				pu = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const mu = {};
			var fu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case du.b:
						case du.d: {
							const {
								key: n
							} = t.payload, r = n;
							e[r];
							return pu(e, ["symbol" == typeof r ? r : r + ""])
						}
						case du.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						default:
							return e
					}
				},
				gu = Object(r.c)({
					error: bu,
					pending: fu
				});
			const Ou = {};
			var hu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ou,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case du.a: {
						const {
							dateRange: n,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			const yu = {};
			var ju = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case du.d: {
							const {
								key: n,
								data: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				_u = Object(r.c)({
					api: gu,
					dateRangeSelection: hu,
					models: ju
				});
			var Eu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.a: {
							const {
								listingKey: n
							} = t.payload;
							return n || e
						}
						default:
							return e
					}
				},
				vu = n("./src/reddit/actions/pages/explore.ts");
			const Iu = {};
			var Su = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Iu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ke.b:
					case Ke.c:
					case ce.b:
					case ce.c: {
						const {
							key: n,
							type: r
						} = t.payload;
						return -1 === r.indexOf(xs.Jb.Subreddits) && -1 === r.indexOf(xs.Jb.Users) ? e : Object.assign({}, e, {
							[n]: null
						})
					}
					case Ke.a:
					case ce.a: {
						const {
							key: n,
							error: r,
							type: s
						} = t.payload;
						return -1 === s.indexOf(xs.Jb.Subreddits) && -1 === s.indexOf(xs.Jb.Users) ? e : Object.assign({}, e, {
							[n]: r
						})
					}
					case Le.f:
					case Le.e:
					case vu.c:
					case vu.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Le.d:
					case vu.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Tu = {};
			var xu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ke.b:
						case ce.b: {
							const {
								key: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(xs.Jb.Subreddits) && -1 === r.indexOf(xs.Jb.Users) ? e : Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ke.c:
						case Ke.a:
						case ce.c:
						case ce.a: {
							const {
								key: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(xs.Jb.Subreddits) && -1 === r.indexOf(xs.Jb.Users) ? e : Object.assign({}, e, {
								[n]: !1
							})
						}
						case Le.f:
						case vu.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Le.e:
						case Le.d:
						case vu.b:
						case vu.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Cu = Object(r.c)({
					error: Su,
					pending: xu
				});
			const wu = {};
			var Pu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ke.c: {
						const {
							fetchedToken: n,
							key: r,
							type: s
						} = t.payload;
						if (-1 === s.indexOf(xs.Jb.Subreddits) && -1 === s.indexOf(xs.Jb.Users)) return e;
						const o = e[r];
						return Object.assign({}, e, {
							[r]: Object.assign({}, o, {
								[n]: !0
							})
						})
					}
					case Le.e:
					case vu.b: {
						const {
							fetchedToken: n,
							key: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								[n]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const Du = {};
			var Ru = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Du,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ke.c: {
						const {
							key: n,
							listingOrder: r,
							type: s
						} = t.payload;
						return -1 === s.indexOf(xs.Jb.Subreddits) && -1 === s.indexOf(xs.Jb.Users) ? e : Object.assign({}, e, {
							[n]: e[n].concat(r)
						})
					}
					case ce.c: {
						const {
							key: n,
							listingOrder: r,
							type: s
						} = t.payload;
						return -1 === s.indexOf(xs.Jb.Subreddits) && -1 === s.indexOf(xs.Jb.Users) ? e : Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Au = {};
			var ku = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Au,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vu.b: {
							const {
								key: n,
								ids: r
							} = t.payload;
							return r && 0 !== r.length ? Object.assign({}, e, {
								[n]: [...e[n] || [], ...r]
							}) : e
						}
						default:
							return e
					}
				},
				Nu = n("./src/lib/omitKey/index.ts");
			const Lu = {};
			var Mu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ke.c:
						case ce.c: {
							const {
								key: n,
								tokens: r,
								type: s
							} = t.payload;
							return -1 === s.indexOf(xs.Jb.Subreddits) && -1 === s.indexOf(xs.Jb.Users) ? e : r.listings ? Object.assign({}, e, {
								[n]: {
									token: r.listings
								}
							}) : Object(Nu.a)(e, n)
						}
						case Le.e:
						case vu.b: {
							const {
								key: n,
								token: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: {
									token: r
								}
							})
						}
						default:
							return e
					}
				},
				Uu = Object(r.c)({
					api: Cu,
					identifiers: Ru,
					ids: ku,
					fetchedTokens: Pu,
					loadMore: Mu
				}),
				Fu = n("./src/reddit/actions/otherDiscussions/constants.ts"),
				Bu = n("./src/reddit/actions/pages/topic.ts");
			const Gu = {};
			var Vu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.h:
						case re.g:
						case re.m:
						case re.l:
						case ae.c:
						case ae.b:
						case Me.c:
						case Me.b:
						case Be.e:
						case Be.f:
						case Be.i:
						case Be.h:
						case Ue.s:
						case Ue.r:
						case Fu.b:
						case Fu.c:
						case oe.f:
						case oe.e:
						case oe.c:
						case oe.b:
						case de.f:
						case de.e:
						case Ve.f:
						case Ve.e:
						case ue.j:
						case ue.i:
						case Bu.f:
						case Bu.e:
						case Bu.c:
						case Bu.b: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: null
							})
						}
						case ce.b:
						case ce.c:
						case Ke.b:
						case Ke.c: {
							const {
								key: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(xs.Jb.Posts) ? e : Object.assign({}, e, {
								[n]: null
							})
						}
						case re.f:
						case re.k:
						case ae.a:
						case Me.a:
						case Be.g:
						case Ue.q:
						case Fu.a:
						case ue.h:
						case de.d:
						case Ve.d:
						case oe.d:
						case oe.a:
						case Bu.d:
						case Bu.a: {
							const {
								key: n,
								error: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case ce.a:
						case Ke.a: {
							const {
								error: n,
								key: r,
								type: s
							} = t.payload;
							return -1 === s.indexOf(xs.Jb.Posts) ? e : Object.assign({}, e, {
								[r]: n
							})
						}
						default:
							return e
					}
				},
				qu = n("./src/reddit/actions/subreddit/constants.ts");
			const Hu = {};
			var Ku = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.h:
						case re.m:
						case oe.f:
						case Ve.f:
						case ae.c:
						case Me.c:
						case Be.f:
						case Be.i:
						case Ue.s:
						case Fu.c:
						case de.f:
						case oe.c:
						case ue.j:
						case Bu.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case ce.b:
						case Ke.b: {
							const {
								key: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(xs.Jb.Posts) ? e : Object.assign({}, e, {
								[n]: !0
							})
						}
						case re.g:
						case re.f:
						case re.k:
						case re.l:
						case Ve.d:
						case Ve.e:
						case oe.d:
						case oe.e:
						case ae.b:
						case ae.a:
						case Me.b:
						case Me.a:
						case Be.e:
						case Be.d:
						case Be.h:
						case Be.g:
						case Ue.r:
						case Ue.q:
						case de.d:
						case de.e:
						case oe.a:
						case oe.b:
						case qu.h:
						case Fu.b:
						case Fu.a:
						case ue.i:
						case ue.h: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case ce.c:
						case ce.a:
						case Ke.c:
						case Ke.a: {
							const {
								key: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(xs.Jb.Posts) ? e : Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Wu = Object(r.c)({
					error: Vu,
					pending: Ku
				}),
				Yu = n("./src/reddit/actions/postList.ts");
			const zu = {};
			var Ju = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yu.a: {
						const {
							listingKey: n,
							listingName: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case Yu.b: {
						const {
							listingKey: n
						} = t.payload;
						return n in e ? Sr()(e, [n]) : e
					}
					default:
						return e
				}
			};
			const Qu = {};
			var Xu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.e:
					case re.g:
					case re.l:
					case ae.b:
					case oe.e:
					case Bu.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {}
						})
					}
					case Me.b:
					case Be.h:
					case Ue.r:
					case de.e:
					case oe.b:
					case ue.i:
					case Bu.b: {
						const {
							key: n,
							fetchedToken: r
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								[r]: !0
							})
						})
					}
					case Ke.c: {
						const {
							fetchedToken: n,
							key: r,
							type: s
						} = t.payload;
						if (s.indexOf(xs.Jb.Posts) > -1) {
							const t = e[r];
							return Object.assign({}, e, {
								[r]: Object.assign({}, t, {
									[n]: !0
								})
							})
						}
						return e
					}
					default:
						return e
				}
			};
			const Zu = {};
			var $u = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.h:
						case Be.f:
						case re.m:
						case oe.f:
						case ae.c:
						case Ve.f:
						case oe.f:
						case Bu.f: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: []
							})
						}
						case Le.e:
						case Be.e:
						case re.g:
						case re.l:
						case ae.b:
						case qu.h:
						case Fu.b:
						case Ve.e:
						case oe.e:
						case He.b:
						case Bu.e: {
							const {
								key: n,
								postIds: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case Me.b:
						case Be.h:
						case Ue.r:
						case oe.b:
						case de.e:
						case ue.i:
						case Bu.b: {
							const {
								key: n,
								postIds: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: e[n].concat(r)
							})
						}
						case ce.c: {
							const {
								key: n,
								postOrder: r,
								type: s
							} = t.payload;
							return -1 === s.indexOf(xs.Jb.Posts) ? e : Object.assign({}, e, {
								[n]: r
							})
						}
						case Ke.c: {
							const {
								key: n,
								postOrder: r,
								type: s
							} = t.payload;
							return -1 === s.indexOf(xs.Jb.Posts) ? e : Object.assign({}, e, {
								[n]: e[n].concat(r)
							})
						}
						case _.j: {
							const {
								newStickiedPostList: n,
								listingKey: r
							} = t.payload;
							if (!e[r]) return e;
							const s = [...e[r]].filter(e => !n.includes(e));
							return s.unshift(...n), Object.assign({}, e, {
								[r]: s
							})
						}
						default:
							return e
					}
				},
				el = n("./src/lib/makeListingKey/index.ts"),
				tl = n("./src/reddit/actions/preferences.ts");
			const nl = {};
			var rl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.b: {
						const {
							key: n,
							listingSort: r
						} = t.payload;
						return r && !Object(el.b)(n) ? Object.assign({}, e, {
							[n]: {
								sort: r,
								hasChanged: !1
							}
						}) : e
					}
					case tl.a:
					case tl.p: {
						const t = {};
						return Object.keys(e).forEach(n => {
							t[n] = Object.assign({}, e[n], {
								hasChanged: !0
							})
						}), t
					}
					default:
						return e
				}
			};
			const sl = {};
			var ol = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.g:
						case re.l:
						case ae.b:
						case Ve.e:
						case oe.e:
						case Me.b:
						case Be.e:
						case Be.h:
						case Ue.r:
						case de.e:
						case oe.b:
						case ue.i:
						case Bu.e:
						case Bu.b: {
							const {
								key: n,
								token: r,
								dist: s
							} = t.payload;
							return r ? Object.assign({}, e, {
								[n]: {
									token: r,
									dist: s
								}
							}) : Object(Nu.a)(e, n)
						}
						case Ke.c:
						case ce.c: {
							const {
								key: n,
								tokens: r,
								type: s
							} = t.payload;
							return -1 === s.indexOf(xs.Jb.Posts) ? e : r.posts ? Object.assign({}, e, {
								[n]: {
									token: r.posts
								}
							}) : Object(Nu.a)(e, n)
						}
						default:
							return e
					}
				},
				il = Object(r.c)({
					api: Wu,
					endMarkers: Ju,
					fetchedTokens: Xu,
					ids: $u,
					listingSort: rl,
					loadMore: ol
				}),
				cl = Object(r.c)({
					activeKey: Eu,
					listingOrder: Uu,
					postOrder: il
				});
			var al = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.g:
						return gn()(t.payload.featuredLiveThread) ? e : t.payload.featuredLiveThread;
					default:
						return e
				}
			};
			var dl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.g:
							return !0;
						default:
							return e
					}
				},
				ul = Object(r.c)({
					featured: al,
					isFrontpageLoaded: dl
				}),
				ll = n("./src/reddit/actions/media.ts");
			var bl = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ll.b:
						return t.payload;
					default:
						return e
				}
			};
			var pl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ll.c:
							return t.payload;
						default:
							return e
					}
				},
				ml = Object(r.c)({
					isMuted: bl,
					volume: pl
				}),
				fl = n("./src/reddit/actions/meta.ts");
			const gl = {
				city: "",
				country: "",
				crawler: void 0,
				domain: "",
				isBot: !1,
				isSessionSeo: !1,
				method: "",
				protocol: "",
				region: "",
				sessionReferrerDomain: "",
				userAgent: "",
				pageloadServerTime: 0
			};
			var Ol = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case fl.b:
						return t.payload;
					case fl.a:
						return Object.assign({}, e, t.payload);
					default:
						return e
				}
			};
			const hl = {};
			var yl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b:
						case Fe.b:
						case re.b:
						case Ge.b: {
							const {
								payload: n
							} = t;
							if (!n.subredditPermissions || !n.subreddits) return e;
							const r = Object.keys(n.subredditAboutInfo || {});
							if (1 !== r.length) return e;
							const s = r[0];
							return Object.assign({}, e, {
								[s]: n.subredditPermissions
							})
						}
						case ne.i:
						case ne.f:
						case ne.m:
						case ne.p:
						case ne.v: {
							const {
								response: n
							} = t.payload, {
								moderatingSubreddits: r,
								moderatingProfiles: s
							} = n;
							return Object.assign({}, e, r, s)
						}
						case ue.f:
						case Be.e:
						case ne.k: {
							const n = t.payload,
								{
									moderatingSubreddits: r,
									moderatingProfiles: s
								} = n;
							return Object.assign({}, e, r, s)
						}
						case w.R: {
							const {
								subredditId: n
							} = t.payload;
							return Object(Nu.a)(e, n)
						}
						case w.O: {
							const n = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				jl = n("./src/reddit/actions/moderationLog/constants.ts");
			const _l = {};
			var El = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jl.b: {
						const {
							actionIds: n,
							key: r,
							subredditId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s] || {}, {
								[r]: n
							})
						})
					}
					default:
						return e
				}
			};
			const vl = {};
			var Il = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jl.b: {
							const {
								normalizedModerationLog: n,
								subredditId: r
							} = t.payload, s = {};
							n.forEach(e => {
								s[e.id] = e
							});
							const o = {
								[r]: s
							};
							return Re()(Object.assign({}, e), o)
						}
						default:
							return e
					}
				},
				Sl = Object(r.c)({
					itemOrder: El,
					models: Il
				});
			var Tl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jl.b: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const xl = {};
			var Cl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jl.b: {
						const {
							hasNextPage: n,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			const wl = {};
			var Pl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jl.b: {
						const {
							hasPreviousPage: n,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			const Dl = [];
			var Rl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jl.a: {
						const {
							normalizedModerators: n,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			var Al = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jl.b: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				kl = Object(r.c)({
					actions: Sl,
					endCursor: Tl,
					hasNextPage: Cl,
					hasPreviousPage: Pl,
					moderators: Rl,
					startCursor: Al
				});
			const Nl = {};
			var Ll = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.E:
					case w.s: {
						const {
							subredditId: n,
							moderators: r
						} = t.payload.response || t.payload, s = {
							[n]: r
						};
						return Object(F.merge)(e, s)
					}
					case w.u: {
						const {
							subredditId: n,
							userId: r,
							permissions: s
						} = t.payload;
						return Object(F.setIn)(e, [n, r, "modPermissions"], s)
					}
					case w.Q: {
						const {
							subredditId: n,
							userId: r
						} = t.payload;
						return Object(F.unsetIn)(e, [n, r])
					}
					default:
						return e
				}
			};
			const Ml = {};
			var Ul = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ml,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.t:
					case w.s: {
						const {
							key: n,
							subredditId: r
						} = t.payload;
						return r ? Object.assign({}, e, {
							[n]: null
						}) : e
					}
					case w.r: {
						const {
							error: n,
							key: r,
							subredditId: s
						} = t.payload;
						return s ? Object.assign({}, e, {
							[r]: n
						}) : e
					}
					default:
						return e
				}
			};
			const Fl = {};
			var Bl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.r:
						case w.s: {
							const {
								subredditId: n,
								key: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[r]: !1
							}) : e
						}
						case w.t: {
							const {
								subredditId: n,
								key: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[r]: !0
							}) : e
						}
						default:
							return e
					}
				},
				Gl = Object(r.c)({
					error: Ul,
					pending: Bl
				});
			const Vl = {};
			var ql = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.s: {
							const {
								subredditId: n,
								response: r,
								key: s
							} = t.payload;
							return Object(F.setIn)(e, [n, s], r.moderatorIds)
						}
						case w.Q: {
							const {
								subredditId: n,
								userId: r,
								key: s
							} = t.payload, o = e[n][s].filter(e => e !== r);
							return Object(F.setIn)(e, [n, s], o)
						}
						default:
							return e
					}
				},
				Hl = Object(r.c)({
					data: ql,
					api: Gl
				});
			var Kl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.x:
					case w.w:
						return null;
					case w.v:
						return t.payload;
					default:
						return e
				}
			};
			var Wl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.w:
						case w.v:
							return !1;
						case w.x:
							return !0;
						default:
							return e
					}
				},
				Yl = Object(r.c)({
					error: Kl,
					pending: Wl
				});
			const zl = {};
			var Jl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.w: {
						const {
							subredditId: n,
							moderators: r
						} = t.payload;
						return Object(F.set)(e, n, r)
					}
					case w.P: {
						const {
							subredditId: n,
							userId: r
						} = t.payload;
						return Object(F.unsetIn)(e, [n, r])
					}
					case w.a: {
						const n = t.payload,
							{
								subredditId: r,
								moderators: s
							} = n,
							o = {
								[r]: s
							};
						return Object(F.merge)(e, o)
					}
					default:
						return e
				}
			};
			const Ql = {};
			var Xl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ql,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.w: {
							const {
								subredditId: n,
								moderatorIds: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case w.P: {
							const {
								subredditId: n,
								userId: r
							} = t.payload, s = e[n].filter(e => e !== r);
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case w.a: {
							const n = t.payload,
								{
									subredditId: r,
									moderatorIds: s
								} = n,
								o = [...e[r] || [], ...s];
							return Object.assign({}, e, {
								[r]: o
							})
						}
						default:
							return e
					}
				},
				Zl = Object(r.c)({
					api: Yl,
					models: Jl,
					userOrder: Xl
				});
			const $l = {};
			var eb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							subredditId: n,
							response: r
						} = t.payload, {
							invitePending: s
						} = r, o = {
							[n]: s
						};
						return Object(F.merge)(e, o)
					}
					case w.y:
					case w.z: {
						const {
							subredditId: n
						} = t.payload;
						return Object(F.unset)(e, n)
					}
					default:
						return e
				}
			};
			const tb = {};
			var nb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.s: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const rb = {};
			var sb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const ob = {};
			var ib = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ob,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							response: n
						} = t.payload, r = {
							[n.subredditId]: n.moderators
						};
						return Object(F.merge)(Object.assign({}, e), r)
					}
					case w.u: {
						const n = t.payload,
							{
								subredditId: r,
								userId: s,
								permissions: o
							} = n;
						return e[r] && e[r][s] ? Object(F.setIn)(e, [r, s, "modPermissions"], o) : e
					}
					default:
						return e
				}
			};
			var cb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.F:
					case w.E:
						return null;
					case w.D:
						return t.payload;
					default:
						return e
				}
			};
			var ab = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.F:
							return !0;
						case w.E:
						case w.D:
							return !1;
						default:
							return e
					}
				},
				db = Object(r.c)({
					error: cb,
					pending: ab
				});
			var ub = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.F:
						case w.D:
						case w.Q:
							return null;
						case w.E: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case w.u: {
							const {
								userId: n,
								permissions: r
							} = t.payload;
							return e && e.id === n && !_r()(e.modPermissions, r) ? Object.assign({}, e, {
								modPermissions: r
							}) : e
						}
						default:
							return e
					}
				},
				lb = Object(r.c)({
					api: db,
					result: ub
				});
			const bb = {};
			var pb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.C:
					case w.B: {
						const {
							subredditId: n,
							key: r
						} = t.payload;
						return n ? Object.assign({}, e, {
							[r]: null
						}) : e
					}
					case w.A: {
						const {
							error: n,
							subredditId: r,
							key: s
						} = t.payload;
						return r ? Object.assign({}, e, {
							[s]: n
						}) : e
					}
					default:
						return e
				}
			};
			const mb = {};
			var fb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.A:
						case w.B: {
							const {
								subredditId: n,
								key: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[r]: !1
							}) : e
						}
						case w.C: {
							const {
								subredditId: n,
								key: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[r]: !0
							}) : e
						}
						default:
							return e
					}
				},
				gb = Object(r.c)({
					error: pb,
					pending: fb
				});
			const Ob = {};
			var hb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ob,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.B: {
							const {
								response: n,
								subredditId: r,
								key: s
							} = t.payload, {
								moderatorIds: o
							} = n;
							return Object(F.merge)(e, {
								[r]: {
									[s]: o
								}
							})
						}
						case w.Q: {
							const {
								subredditId: n,
								userId: r
							} = t.payload, s = Object.assign({}, e[n]);
							return Object.keys(e[n]).forEach(t => {
								const o = e[n][t].filter(e => e !== r);
								s[t] = o
							}), Object(F.set)(e, n, s)
						}
						default:
							return e
					}
				},
				yb = Object(r.c)({
					data: hb,
					api: gb
				}),
				jb = Object(r.c)({
					editableModerators: Ll,
					editableUserOrder: Hl,
					invitedModerators: Zl,
					invitePending: eb,
					loadMoreModerators: sb,
					loadMoreEditableModerators: nb,
					models: ib,
					search: lb,
					userOrder: yb
				});
			var _b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b:
					case Be.k:
						return null;
					case Be.a:
					case Be.j:
						return t.payload;
					default:
						return e
				}
			};
			var Eb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.b:
						case Be.k:
							return !0;
						case Be.c:
						case Be.a:
						case Be.l:
						case Be.j:
							return !1;
						default:
							return e
					}
				},
				vb = Object(r.c)({
					error: _b,
					pending: Eb
				});
			const Ib = [];
			var Sb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ib,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.e: {
							const n = t.payload,
								{
									filteredSubreddits: r
								} = n;
							return r || e
						}
						case Be.j: {
							const n = t.payload;
							return [...e, n]
						}
						case Be.k:
						case Be.a: {
							const n = t.payload;
							return e.filter(e => e !== n)
						}
						default:
							return e
					}
				},
				Tb = Object(r.c)({
					api: vb,
					names: Sb
				}),
				xb = Object(r.c)({
					filteredSubreddits: Tb
				});
			var Cb = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xr.a:
						return t.payload.enabled;
					default:
						return e
				}
			};
			var wb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Tr.c:
					case Tr.b:
						return null;
					case Tr.a:
						return t.payload;
					default:
						return e
				}
			};
			var Pb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Tr.c:
							return !0;
						case Tr.b:
						case Tr.a:
						case ne.s:
						case ne.r:
							return !1;
						default:
							return e
					}
				},
				Db = Object(r.c)({
					error: wb,
					pending: Pb
				});
			const Rb = {};
			var Ab = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.a: {
						const {
							ids: n
						} = t.payload, r = {};
						return n.forEach(e => r[e] = !0), Object.assign({}, e, r)
					}
					case ne.d: {
						const {
							ids: n
						} = t.payload;
						return Sr()(e, n)
					}
					case ne.c: {
						const {
							ids: e
						} = t.payload, n = {};
						return e.forEach(e => n[e] = !0), n
					}
					default:
						return e
				}
			};
			const kb = {};
			var Nb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Tr.b: {
							const {
								operation: e,
								ids: n
							} = t.payload;
							return "approve" === e ? kb : {
								[Rr.c[e]]: n
							}
						}
						default:
							return e
					}
				},
				Lb = Object(r.c)({
					api: Db,
					selectedItems: Ab,
					undoLastAction: Nb
				});
			var Mb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.g:
					case ne.f:
						return null;
					case ne.e:
						return t.payload;
					default:
						return e
				}
			};
			var Ub = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.g:
							return !0;
						case ne.f:
						case ne.e:
							return !1;
						default:
							return e
					}
				},
				Fb = Object(r.c)({
					error: Mb,
					pending: Ub
				});
			const Bb = {};
			var Gb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.f: {
						const {
							listingKey: n,
							page: r,
							response: s
						} = t.payload, {
							modqueue: o
						} = s;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[r]: o
							})
						})
					}
					default:
						return e
				}
			};
			const Vb = {};
			var qb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.f: {
							const {
								listingKey: n,
								response: r
							} = t.payload, {
								modqueue: s
							} = r, o = s[s.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				Hb = Object(r.c)({
					api: Fb,
					itemOrder: Gb,
					loadMore: qb
				});
			var Kb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.e: {
						const n = t.payload,
							{
								moderatingSubreddits: r
							} = n;
						return r ? null : e
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: n
						} = e;
						return n
					}
					case ne.k: {
						const e = t.payload,
							{
								moderatedAfter: n
							} = e;
						return n
					}
					default:
						return e
				}
			};
			const Wb = [];
			var Yb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: e
						} = t.payload, {
							listingOrder: n
						} = e;
						return n
					}
					case ne.k: {
						const n = t.payload,
							{
								listingOrder: r
							} = n;
						return [...e, ...r]
					}
					case Be.e: {
						const n = t.payload,
							{
								listingOrder: r
							} = n;
						return r || e
					}
					default:
						return e
				}
			};
			var zb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b:
						return !0;
					default:
						return e
				}
			};
			var Jb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.k:
							return !0;
						case ne.b:
							return !1;
						default:
							return e
					}
				},
				Qb = Object(r.c)({
					after: Kb,
					data: Yb,
					loaded: zb,
					pending: Jb
				});
			var Xb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.j:
					case ne.i:
						return null;
					case ne.h:
						return t.payload;
					default:
						return e
				}
			};
			var Zb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.j:
							return !0;
						case ne.i:
						case ne.h:
							return !1;
						default:
							return e
					}
				},
				$b = Object(r.c)({
					error: Xb,
					pending: Zb
				});
			const ep = {};
			var tp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ep,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.i: {
						const {
							listingKey: n,
							page: r,
							response: s
						} = t.payload, {
							modqueue: o
						} = s;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[r]: o
							})
						})
					}
					default:
						return e
				}
			};
			const np = {};
			var rp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : np,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.i: {
							const {
								listingKey: n,
								response: r
							} = t.payload, {
								modqueue: s
							} = r, o = s[s.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				sp = Object(r.c)({
					api: $b,
					itemOrder: tp,
					loadMore: rp
				});
			var op = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.n:
					case ne.m:
						return null;
					case ne.l:
						return t.payload;
					default:
						return e
				}
			};
			var ip = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.n:
							return !0;
						case ne.m:
						case ne.l:
							return !1;
						default:
							return e
					}
				},
				cp = Object(r.c)({
					error: op,
					pending: ip
				});
			const ap = {};
			var dp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ap,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.m: {
						const {
							listingKey: n,
							page: r,
							response: s
						} = t.payload, {
							modqueue: o
						} = s;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[r]: o
							})
						})
					}
					default:
						return e
				}
			};
			const up = {};
			var lp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : up,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.m: {
							const {
								listingKey: n,
								response: r
							} = t.payload, {
								modqueue: s
							} = r, o = s[s.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				bp = Object(r.c)({
					api: cp,
					itemOrder: dp,
					loadMore: lp
				});
			var pp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.q:
					case ne.p:
						return null;
					case ne.o:
						return t.payload;
					default:
						return e
				}
			};
			var mp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.q:
							return !0;
						case ne.p:
						case ne.o:
							return !1;
						default:
							return e
					}
				},
				fp = Object(r.c)({
					error: pp,
					pending: mp
				});
			const gp = {};
			var Op = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.p: {
						const {
							listingKey: n,
							page: r,
							response: s
						} = t.payload, {
							modqueue: o
						} = s;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[r]: o
							})
						})
					}
					default:
						return e
				}
			};
			const hp = {};
			var yp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.p: {
							const {
								listingKey: n,
								response: r
							} = t.payload, {
								modqueue: s
							} = r, o = s[s.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				jp = Object(r.c)({
					api: fp,
					itemOrder: Op,
					loadMore: yp
				});
			var _p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.w:
					case ne.v:
						return null;
					case ne.u:
						return t.payload;
					default:
						return e
				}
			};
			var Ep = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.w:
							return !0;
						case ne.v:
						case ne.u:
							return !1;
						default:
							return e
					}
				},
				vp = Object(r.c)({
					error: _p,
					pending: Ep
				});
			const Ip = {};
			var Sp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ip,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.v: {
						const {
							listingKey: n,
							page: r,
							response: s
						} = t.payload, {
							modqueue: o
						} = s;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n] || {}, {
								[r]: o
							})
						})
					}
					default:
						return e
				}
			};
			const Tp = {};
			var xp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.v: {
							const {
								listingKey: n,
								response: r
							} = t.payload, {
								modqueue: s
							} = r, o = s[s.length - 1] || null;
							return Object.assign({}, e, {
								[n]: o
							})
						}
						default:
							return e
					}
				},
				Cp = Object(r.c)({
					api: vp,
					itemOrder: Sp,
					loadMore: xp
				}),
				wp = Object(r.c)({
					bulkAction: Lb,
					edited: Hb,
					moderatedCommunitiesOrder: Qb,
					modqueue: sp,
					reports: bp,
					spam: jp,
					unmoderated: Cp
				}),
				Pp = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const Dp = {};
			var Rp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.v: {
						const {
							moreCommentsId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case $.u: {
						const {
							moreCommentsItem: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: null
						})
					}
					case $.t: {
						const n = t.payload,
							{
								moreCommentsItem: r
							} = n,
							s = Pp(n, ["moreCommentsItem"]);
						return Object.assign({}, e, {
							[r.id]: s || {}
						})
					}
					default:
						return e
				}
			};
			const Ap = {};
			var kp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ap,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.v: {
							const {
								moreCommentsId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case $.t:
						case $.u: {
							const {
								moreCommentsItem: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.id]: !1
							})
						}
						default:
							return e
					}
				},
				Np = Object(r.c)({
					error: Rp,
					pending: kp
				});
			const Lp = {};
			var Mp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.u:
						case Fe.b:
						case re.b:
							return Object.assign({}, e, t.payload.moreComments);
						default:
							return e
					}
				},
				Up = Object(r.c)({
					api: Np,
					models: Mp
				});
			var Fp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.b:
					case Ue.c:
						return null;
					case Ue.a:
						return t.payload;
					default:
						return e
				}
			};
			var Bp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.a:
					case Ue.c:
						return !0;
					case Ue.b:
						return !1;
					default:
						return e
				}
			};
			var Gp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.l:
						case Ue.a:
						case Ue.c:
							return null;
						case Ue.b: {
							const {
								name: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				Vp = Object(r.c)({
					error: Fp,
					fetched: Bp,
					pending: Gp
				});
			var qp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.f:
					case Ue.g:
						return null;
					case Ue.e:
						return t.payload;
					default:
						return e
				}
			};
			var Hp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.e:
					case Ue.g:
						return !0;
					case Ue.f:
						return !1;
					default:
						return e
				}
			};
			var Kp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.e:
						case Ue.g:
							return !1;
						case Ue.f:
							return !0;
						default:
							return e
					}
				},
				Wp = Object(r.c)({
					error: qp,
					fetched: Hp,
					pending: Kp
				});
			var Yp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.i:
					case Ue.j:
						return null;
					case Ue.h:
						return t.payload;
					default:
						return e
				}
			};
			var zp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.h:
					case Ue.j:
						return !0;
					case Ue.i:
						return !1;
					default:
						return e
				}
			};
			var Jp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.h:
						case Ue.j:
							return !1;
						case Ue.i:
							return !0;
						default:
							return e
					}
				},
				Qp = Object(r.c)({
					error: Yp,
					fetched: zp,
					pending: Jp
				});
			var Xp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.l:
					case Ue.m:
						return null;
					case Ue.k:
						return t.payload;
					default:
						return e
				}
			};
			var Zp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.k:
					case Ue.m:
						return !0;
					case Ue.l:
						return !1;
					default:
						return e
				}
			};
			var $p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.k:
						case Ue.m:
							return !1;
						case Ue.l:
							return !0;
						default:
							return e
					}
				},
				em = Object(r.c)({
					error: Xp,
					fetched: Zp,
					pending: $p
				});
			var tm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.o:
					case Ue.p:
						return null;
					case Ue.n:
						return t.payload;
					default:
						return e
				}
			};
			var nm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.n:
					case Ue.p:
						return !0;
					case Ue.o:
						return !1;
					default:
						return e
				}
			};
			var rm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.n:
						case Ue.p:
							return !1;
						case Ue.o:
							return !0;
						default:
							return e
					}
				},
				sm = Object(r.c)({
					error: tm,
					fetched: nm,
					pending: rm
				});
			var om = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.t:
						return !1;
					case Ue.u:
						return !0;
					default:
						return e
				}
			};
			var im = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.t:
							return !0;
						case Ue.u:
							return !1;
						default:
							return e
					}
				},
				cm = Object(r.c)({
					fetched: om,
					pending: im
				});
			var am = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.A:
					case Ue.B:
						return null;
					case Ue.z:
						return t.payload;
					default:
						return e
				}
			};
			var dm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.A:
					case Ue.z:
						return !1;
					case Ue.B:
						return !0;
					default:
						return e
				}
			};
			var um = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.A:
							return !0;
						case Ue.B:
						case Ue.z:
							return !1;
						default:
							return e
					}
				},
				lm = Object(r.c)({
					error: am,
					fetched: dm,
					pending: um
				});
			var bm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.w:
					case Ue.x:
						return null;
					case Ue.v:
						return t.payload;
					default:
						return e
				}
			};
			var pm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.v:
					case Ue.x:
						return !0;
					case Ue.w:
						return !1;
					default:
						return e
				}
			};
			var mm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.v:
						case Ue.x:
							return null;
						case Ue.w:
							const {
								id: n
							} = t.payload;
							return n;
						default:
							return e
					}
				},
				fm = Object(r.c)({
					error: bm,
					fetched: pm,
					pending: mm
				}),
				gm = Object(r.c)({
					addSubreddit: Vp,
					create: Wp,
					deleteMulti: Qp,
					duplicate: em,
					edit: sm,
					forUser: cm,
					recommendations: lm,
					removeSubreddit: fm
				}),
				Om = n("./node_modules/lodash/union.js"),
				hm = n.n(Om);

			function ym(e, t, n) {
				let r, s, o = e.length - 1,
					i = 0;
				for (; i <= o;) {
					const c = n(r = e[s = (i + o) / 2 | 0], t);
					if (c < 0) {
						if ((i = s + 1) > o) return i
					} else {
						if (!(c > 0)) return s;
						if ((o = s - 1) < i) return o + 1
					}
				}
				return (i + o) / 2 | 0
			}
			var jm = n("./src/reddit/actions/profile/constants.ts");
			const _m = {};
			var Em = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.l:
						case Ue.r:
						case Ue.u:
						case jm.h: {
							const {
								multireddits: n,
								multiredditsByUser: r,
								multiredditsModelsState: s
							} = t.payload, o = Object.assign({}, e), i = Object.assign({}, n, s);
							for (const t in r) {
								const n = r[t],
									s = e[t];
								o[t] = hm()(s, n).sort((e, t) => i[e].displayText.toLowerCase() > i[t].displayText.toLowerCase() ? 1 : -1)
							}
							return _r()(e, o) ? e : o
						}
						case Ue.g:
						case Ue.m: {
							const {
								userId: n,
								multireddit: r
							} = t.payload, s = e[n] ? e[n].slice() : [], o = ym(s, r.url, (e, t) => e > t ? 1 : -1);
							return s.splice(o, 0, r.url), Object.assign({}, e, {
								[n]: s
							})
						}
						case Ue.j: {
							const n = t.payload;
							for (const t in e) {
								const r = e[t];
								if (r.indexOf(n) > -1) return Object.assign({}, e, {
									[t]: r.filter(e => e !== n)
								})
							}
							return e
						}
						default:
							return e
					}
				},
				vm = n("./src/reddit/actions/subscription/constants.ts"),
				Im = n("./src/reddit/models/Multireddit/index.ts");
			const Sm = {};
			var Tm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.l:
					case Ue.r:
					case Ue.u:
					case jm.h: {
						let n = {};
						for (const r in t.payload.multireddits) {
							const s = Object.assign({}, t.payload.multireddits[r]),
								o = e[r];
							o && !Object(Im.g)(s) && (s.subredditIds = o.subredditIds, s.profileIds = o.profileIds), r in e && _r()(e[s.url], s) || (n = Object.assign({}, n, {
								[r]: s
							}))
						}
						return gn()(n) ? e : Object.assign({}, e, n)
					}
					case Ue.g:
					case Ue.m: {
						const {
							multireddit: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.url]: n
						})
					}
					case Ue.j: {
						const n = t.payload,
							r = Object.assign({}, e);
						return delete r[n], r
					}
					case Ue.p: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.url]: n
						})
					}
					case Ue.x: {
						const {
							id: n,
							multipath: r,
							type: s
						} = t.payload, o = e[r], i = "subreddit" === s ? (o.subredditIds || []).filter(e => e !== n) : o.subredditIds, c = "profile" === s ? (o.profileIds || []).filter(e => e !== n) : o.profileIds;
						return Object.assign({}, e, {
							[r]: Object.assign({}, o, {
								profileIds: c,
								subredditIds: i
							})
						})
					}
					case vm.d: {
						const {
							makeFavorite: n,
							multiredditPath: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								isFavorited: n
							})
						})
					}
					case vm.e: {
						const {
							follow: n,
							multiredditPath: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								isFollowed: n,
								isFavorited: !1
							})
						})
					}
					case Ue.c: {
						const {
							id: n,
							multipaths: r,
							type: s
						} = t.payload, o = r.reduce((t, r) => {
							const o = e[r],
								i = "subreddit" === s ? [...o.subredditIds || [], n] : o.subredditIds,
								c = "profile" === s ? [...o.profileIds || [], n] : o.profileIds;
							return Object.assign({}, t, {
								[r]: Object.assign({}, o, {
									subredditIds: i,
									profileIds: c
								})
							})
						}, {});
						return Object.assign({}, e, o)
					}
					default:
						return e
				}
			};
			const xm = {};
			var Cm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.B: {
							const {
								multipath: n,
								subreddits: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Object.keys(r)
							})
						}
						default:
							return e
					}
				},
				wm = Object(r.c)({
					api: gm,
					byUserId: Em,
					models: Tm,
					recommendations: Cm
				});
			var Pm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.J:
					case w.H:
						return null;
					case w.G:
						return t.payload;
					default:
						return e
				}
			};
			const Dm = {};
			var Rm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.J: {
							const {
								subredditId: n,
								fetchedToken: r
							} = t.payload, s = Object(D.d)(n, r);
							return Object.assign({}, e, {
								[s]: !0
							})
						}
						case w.H:
						case w.G: {
							const {
								subredditId: n,
								fetchedToken: r
							} = t.payload, s = Object(D.d)(n, r);
							return Object.assign({}, e, {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Am = Object(r.c)({
					error: Pm,
					pending: Rm
				});
			const km = {};
			var Nm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : km,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.H: {
						const {
							fetchedToken: n,
							subredditId: r
						} = t.payload, s = Object(D.d)(r, n);
						return Object.assign({}, e, {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			var Lm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vt.b:
						return t.payload;
					default:
						return e
				}
			};
			const Mm = {};
			var Um = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.H: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const Fm = {};
			var Bm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.I:
					case w.H: {
						const {
							subredditId: n,
							mutedUsers: r
						} = t.payload, s = {
							[n]: r
						};
						return Object(F.merge)(e, s)
					}
					case w.N: {
						const {
							subredditId: n,
							userId: r
						} = t.payload;
						return Object(F.unsetIn)(e, [n, r])
					}
					default:
						return e
				}
			};
			var Gm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.M:
					case w.L:
						return null;
					case w.K:
						return t.payload;
					default:
						return e
				}
			};
			var Vm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.M:
							return !0;
						case w.L:
						case w.K:
							return !1;
						default:
							return e
					}
				},
				qm = Object(r.c)({
					error: Gm,
					pending: Vm
				});
			var Hm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.M:
						case w.K:
							return null;
						case w.L: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				Km = Object(r.c)({
					api: qm,
					result: Hm
				});
			const Wm = {};
			var Ym = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.H: {
							const {
								subredditId: n,
								mutedUserIds: r
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: [...e[n], ...r]
							}) : Object.assign({}, e, {
								[n]: r
							})
						}
						case w.N: {
							const {
								subredditId: n,
								userId: r
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== r)
							}
						}
						case w.I: {
							const {
								subredditId: n,
								mutedUserIds: r
							} = t.payload, s = r[0];
							return s && e[n] && -1 === e[n].indexOf(s) ? {
								[n]: [s, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				zm = Object(r.c)({
					api: Am,
					fetchedTokens: Nm,
					inContext: Lm,
					loadMore: Um,
					models: Bm,
					search: Km,
					userOrder: Ym
				}),
				Jm = n("./src/reddit/actions/notificationBanner.ts");
			var Qm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Jm.b:
							return t.payload.notificationBannerId;
						case Jm.a:
							return null;
						default:
							return e
					}
				},
				Xm = n("./src/reddit/actions/nps.ts");
			const Zm = {
				pending: !1,
				success: !1,
				dest: void 0
			};
			var $m = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xm.c:
							return Object.assign({}, Zm, {
								pending: !0
							});
						case Xm.a:
							return Zm;
						case Xm.b: {
							const {
								dest: e
							} = t.payload;
							return Object.assign({}, Zm, {
								success: !0,
								dest: e
							})
						}
						default:
							return e
					}
				},
				ef = n("./src/reddit/actions/oldSiteRules.ts");
			const tf = [];
			var nf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ef.a:
						return t.payload.oldSiteRules;
					default:
						return e
				}
			};
			const rf = [];
			var sf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cc.a: {
						const {
							pageExperimentVariants: e
						} = t.payload;
						return (e ? e.experiments : []).map(e => {
							let {
								id: t,
								experimentName: n,
								name: r,
								version: s
							} = e;
							return {
								id: parseInt(t),
								name: n,
								variant: r || void 0,
								version: s
							}
						})
					}
					default:
						return e
				}
			};
			var of = Object(r.c)({
				models: sf,
				canonicalUrl: function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cc.a: {
							const {
								pageExperimentVariants: e
							} = t.payload;
							return e && e.canonicalUrl ? e.canonicalUrl : null
						}
						default:
							return e
					}
				}
			}), cf = Object(r.c)({
				experiments: of
			}), af = n("./node_modules/history/esm/history.js"), df = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const uf = {
					allowNavigationCallback: null,
					currentPage: null,
					lastPage: null,
					referrers: {},
					sessionReferrer: null,
					metas: {}
				},
				lf = (e, t) => ({
					key: e,
					locationState: {},
					meta: null,
					queryParams: {},
					routeMatch: null,
					status: 404,
					url: t,
					urlParams: {}
				}),
				bf = (e, t, n, r) => {
					const s = n.route,
						{
							action: o
						} = s,
						i = df(s, ["action"]);
					return {
						key: e,
						locationState: r.state,
						meta: n.route.meta,
						queryParams: n.match.queryParams,
						routeMatch: Object.assign({}, n, {
							route: i
						}),
						status: 200,
						url: t,
						urlParams: n.match.params
					}
				};
			var pf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.a: {
							const n = e.currentPage,
								r = t.payload,
								{
									routeMatch: s,
									location: o
								} = r,
								{
									key: i
								} = o;
							if (void 0 === i) return e;
							const c = Object(af.e)(o),
								a = s ? bf(i, c, s, o) : lf(i, c);
							let {
								referrers: d
							} = e;
							if ("PUSH" === r.action) {
								const e = n && n.url || "";
								d = Object.assign({}, d, {
									[i]: e
								})
							} else if ("REPLACE" === r.action && n && d[n.key]) {
								const e = n.key,
									t = d[e],
									r = df(d, ["symbol" == typeof e ? e : e + ""]);
								d = Object.assign({}, r, {
									[i]: t
								})
							}
							return Object.assign({}, e, {
								referrers: d,
								currentPage: a,
								lastPage: n
							})
						}
						case m.e: {
							const n = t.payload,
								{
									key: r,
									meta: s
								} = n;
							return Object.assign({}, e, {
								metas: Object.assign({}, e.metas, {
									[r]: s
								})
							})
						}
						case m.f: {
							if (!e.currentPage) return e;
							const n = t.payload,
								r = Object.assign({}, e.currentPage, {
									status: n
								});
							return Object.assign({}, e, {
								currentPage: r
							})
						}
						case Fe.b:
						case re.b:
							return !e.currentPage || t.payload.postMeta, e;
						case m.b:
							return e;
						case m.d: {
							const {
								allowNavigationCallback: n
							} = t.payload;
							return Object.assign({}, e, {
								allowNavigationCallback: n
							})
						}
						case m.c:
							return Object.assign({}, e, {
								allowNavigationCallback: null
							});
						default:
							return e
					}
				},
				mf = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const ff = {};
			var gf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ff,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.l: {
						const {
							pollId: n
						} = t.payload.pollResults, r = n;
						e[r];
						return mf(e, ["symbol" == typeof r ? r : r + ""])
					}
					case l.k: {
						const {
							pollId: n
						} = t.payload, r = n;
						e[r];
						return mf(e, ["symbol" == typeof r ? r : r + ""])
					}
					case l.j: {
						const {
							pollId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Of = {};
			var hf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Of,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.l: {
							const {
								pollId: n
							} = t.payload.pollResults;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case l.j: {
							const {
								pollId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case l.k: {
							const {
								pollId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						default:
							return e
					}
				},
				yf = Object(r.c)({
					error: gf,
					pending: hf
				}),
				jf = Object(r.c)({
					voting: yf
				});
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			const _f = e => {
				const {
					options: t,
					totalVoteCount: n,
					userSelection: r
				} = e;
				return {
					options: t.reduce((e, t) => {
						let {
							id: n,
							voteCount: s
						} = t;
						return Object.assign({}, e, {
							[n.toString()]: {
								id: n,
								votes: (s || 0).toString(),
								userSelected: n === r
							}
						})
					}, {}),
					totalVotes: n.toString()
				}
			};
			var Ef = e => {
				if (!e.pollData) return null;
				const {
					id: t,
					created: n,
					authorId: r,
					belongsTo: s
				} = e, {
					options: o,
					votingEndTimestamp: i
				} = e.pollData;
				let c = 0;
				const a = [];
				return o.forEach(e => {
					c += e.voteCount, a.push({
						id: e.id.toString(),
						text: e.text
					})
				}), {
					id: t,
					createdAt: n,
					creatorId: r,
					subredditId: s.id,
					endsAt: i,
					postId: t,
					options: a,
					totalVoters: c,
					type: pi.a.GA
				}
			};
			const vf = {};
			var If = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.i: {
						const {
							poll: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case re.g:
					case ae.b:
					case ue.i:
					case Me.b:
					case Fe.b:
					case re.b: {
						const {
							governance: n,
							posts: r
						} = t.payload;
						if (n) {
							const t = Object.keys(n).reduce((e, t) => {
								const r = n[t].poll;
								return e[r.id] = r, e
							}, {});
							return Object.assign({}, e, t)
						}
						const s = {};
						return Object.keys(r).forEach(e => {
							r[e].pollData && (s[e] = Ef(r[e]))
						}), Object.assign({}, e, s)
					}
					default:
						return e
				}
			};
			const Sf = {};
			var Tf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.l: {
						const {
							[pi.b.ByVoters]: n, pollId: r
						} = t.payload.pollResults;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					case l.f: {
						const {
							pollId: n,
							optionId: r,
							options: s
						} = t.payload;
						let o = 0;
						const i = {};
						for (const e of s) o += e.voteCount, i[e.id] = {
							id: parseInt(e.id),
							userSelected: e.id === r,
							votes: e.voteCount.toString()
						};
						return Object.assign({}, e, {
							[n]: {
								options: i,
								totalVotes: o.toString()
							}
						})
					}
					case re.g:
					case ae.b:
					case ue.i:
					case Me.b:
					case Fe.b:
					case re.b: {
						const {
							governance: n,
							posts: r
						} = t.payload;
						if (n) {
							const t = Object.keys(n).reduce((e, t) => {
								const r = n[t],
									{
										[pi.b.ByVoters]: s,
										pollId: o
									} = r.pollResults;
								return e[o] = s, e
							}, {});
							return Object.assign({}, e, t)
						}
						const s = Object.keys(r).reduce((e, t) => {
							if (!r[t].pollData) return e;
							const n = _f(r[t].pollData);
							return n ? (e[t] = n, e) : e
						}, {});
						return Object.keys(s).length ? Object.assign({}, e, s) : e
					}
					default:
						return e
				}
			};
			const xf = {};
			var Cf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.l: {
							const {
								[pi.b.ByVotingPower]: n, pollId: r
							} = t.payload.pollResults;
							return Object.assign({}, e, {
								[r]: n
							})
						}
						case re.g:
						case ae.b:
						case ue.i:
						case Me.b:
						case Fe.b:
						case re.b: {
							const {
								governance: n
							} = t.payload;
							if (n) {
								const t = Object.keys(n).reduce((e, t) => {
									const r = n[t],
										{
											[pi.b.ByVotingPower]: s,
											pollId: o
										} = r.pollResults;
									return e[o] = s, e
								}, {});
								return Object.assign({}, e, t)
							}
							return e
						}
						default:
							return e
					}
				},
				wf = Object(r.c)({
					byVoters: Tf,
					byVotingPower: Cf
				});
			const Pf = {};
			var Df = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.l: {
							const {
								pollId: n,
								rewardPoints: r
							} = t.payload.pollResults;
							return r ? Object.assign({}, e, {
								[n]: r
							}) : e
						}
						default:
							return e
					}
				},
				Rf = Object(r.c)({
					api: jf,
					models: If,
					results: wf,
					rewards: Df
				});
			const Af = {
				reorderError: null,
				updateDescriptionError: null,
				updateLayoutError: null
			};
			var kf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Af,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ks.i:
					case ks.j:
						return Object.assign({}, e, {
							reorderError: null
						});
					case ks.h:
						return Object.assign({}, e, {
							reorderError: t.payload
						});
					case ks.l:
					case ks.m:
						return Object.assign({}, e, {
							updateDescriptionError: null
						});
					case ks.k:
						return Object.assign({}, e, {
							updateDescriptionError: t.payload
						});
					case ks.p:
					case ks.q:
						return Object.assign({}, e, {
							updateLayoutError: null
						});
					case ks.o:
						return Object.assign({}, e, {
							updateLayoutError: t.payload
						});
					default:
						return e
				}
			};
			const Nf = {
				reorderPending: !1,
				updateDescriptionPending: !1,
				updateLayoutPending: !1
			};
			var Lf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ks.i:
							return Object.assign({}, e, {
								reorderPending: !0
							});
						case ks.h:
						case ks.j:
							return Object.assign({}, e, {
								reorderPending: !1
							});
						case ks.l:
							return Object.assign({}, e, {
								updateDescriptionPending: !0
							});
						case ks.k:
						case ks.m:
							return Object.assign({}, e, {
								updateDescriptionPending: !1
							});
						case ks.p:
							return Object.assign({}, e, {
								updateLayoutPending: !0
							});
						case ks.o:
						case ks.q:
							return Object.assign({}, e, {
								updateLayoutPending: !1
							});
						default:
							return e
					}
				},
				Mf = Object(r.c)({
					error: kf,
					pending: Lf
				}),
				Uf = n("./src/reddit/helpers/path/index.ts");
			const Ff = {},
				Bf = e => {
					const {
						protocol: t,
						domain: n
					} = e;
					return e => {
						const r = Object(Uf.b)(e.permalink);
						return Object.assign({}, e, {
							permalink: "".concat(t, "://").concat(n).concat(r)
						})
					}
				};
			var Gf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ff,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.b:
					case Be.e:
					case Be.h:
					case se.b:
					case se.e:
					case Ve.e:
					case Ve.b:
					case oe.e:
					case oe.b:
					case ae.b:
					case re.g:
					case re.l:
					case ae.b:
					case Fe.b:
					case re.b:
					case _.e:
					case Ue.r:
					case Me.b:
					case de.e:
					case He.b:
					case ue.i:
					case Ke.c:
					case qe.b:
					case ce.c:
					case ks.f: {
						const {
							collections: n,
							meta: r
						} = t.payload;
						if (!n) return e;
						let s = n;
						if (r) {
							const e = Bf(r);
							s = vr()(n, e)
						}
						return Object.assign({}, e, s)
					}
					case ks.d: {
						const {
							collection: n,
							meta: r
						} = t.payload;
						if (!n) return e;
						const s = n.id;
						let o = n;
						if (r) {
							o = Bf(r)(n)
						}
						return Object.assign({}, e, {
							[s]: o
						})
					}
					case ks.g: {
						const {
							collectionId: n,
							postId: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								postIds: s.postIds.filter(e => e !== r)
							})
						}) : e
					}
					case ks.a: {
						const {
							collectionId: n,
							postId: r
						} = t.payload, s = e[n];
						return s && r ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								postIds: [...s.postIds, r]
							})
						}) : e
					}
					case ks.e: {
						const {
							collectionId: n
						} = t.payload, r = Object.assign({}, e);
						return delete r[n], r
					}
					case ks.s: {
						const {
							collectionId: n,
							newTitle: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								title: r
							})
						}) : e
					}
					case ks.j: {
						const {
							collectionId: n,
							postIds: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								postIds: [...r]
							})
						}) : e
					}
					case ks.m: {
						const {
							collectionId: n,
							newDescription: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								description: r
							})
						}) : e
					}
					case ks.q: {
						const {
							collectionId: n,
							newLayout: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								displayLayout: r
							})
						}) : e
					}
					default:
						return e
				}
			};
			const Vf = {};
			var qf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.b:
						case ks.f: {
							const {
								collections: n
							} = t.payload;
							if (!n) return e;
							const r = Object.keys(n);
							if (!r.length) return e;
							const {
								subredditId: s
							} = n[r[0]];
							return Object.assign({}, e, {
								[s]: r
							})
						}
						case ks.d: {
							const {
								collection: n
							} = t.payload, {
								subredditId: r
							} = n, s = e[r] || [];
							return Object.assign({}, e, {
								[r]: [...s, n.id]
							})
						}
						case ks.e: {
							const {
								collectionId: n,
								collection: r
							} = t.payload;
							if (!r) return e;
							const s = r && e[r.subredditId];
							return s ? Object.assign({}, e, {
								[r.subredditId]: s.filter(e => e !== n)
							}) : e
						}
						default:
							return e
					}
				},
				Hf = Object(r.c)({
					models: Gf,
					subredditToIds: qf,
					api: Mf
				}),
				Kf = n("./src/reddit/actions/postFlair.ts"),
				Wf = n("./src/reddit/models/Flair/index.ts");
			const Yf = {},
				zf = {
					displaySettings: {
						isEnabled: !1,
						position: Wf.b.Left
					},
					permissions: {
						canAssignOwn: !1
					},
					templateIds: [],
					templates: {}
				},
				Jf = (e, t) => {
					if (!t) return e;
					const n = Object.keys(t);
					return 0 === n.length ? e : n.reduce((e, n) => (e[n] = Object.assign({}, zf, e[n], t[n]), e), Object.assign({}, e))
				};
			var Qf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.b:
						case Me.b:
						case Be.e:
						case Be.h:
						case Ue.r:
						case Fu.b:
						case Fe.b:
						case re.b:
						case re.g:
						case re.l:
						case ce.c:
						case ae.b:
						case se.b:
						case se.e:
						case ie.c:
						case ie.i:
						case ie.e:
						case ie.g:
						case de.e:
						case qe.b:
						case qe.b:
						case Ve.b:
						case Ve.e:
						case oe.b:
						case oe.e:
						case He.b:
						case Ke.c:
						case Ke.c:
						case ue.i:
							return Jf(e, t.payload.postFlair);
						case Kf.c: {
							const {
								subredditId: n,
								isEnabled: r
							} = t.payload, s = e[n].displaySettings, o = Object.assign({}, s, {
								isEnabled: r
							});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									displaySettings: o
								})
							})
						}
						case Kf.a: {
							const {
								subredditId: n,
								canAssignOwn: r
							} = t.payload, s = e[n].permissions, o = Object.assign({}, s, {
								canAssignOwn: r
							});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n], {
									permissions: o
								})
							})
						}
						case Kf.f: {
							const {
								subredditId: n,
								template: r
							} = t.payload, s = e[n], {
								templates: o,
								templateIds: i
							} = s, c = Object.assign({}, o, {
								[r.id]: r
							}), a = [...i];
							return a.includes(r.id) || a.push(r.id), Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									templates: c,
									templateIds: a
								})
							})
						}
						case Kf.b: {
							const {
								subredditId: n,
								templateId: r
							} = t.payload, s = e[n], {
								templates: o,
								templateIds: i
							} = s, c = Sr()(o, r), a = i.filter(e => e !== r);
							return Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									templates: c,
									templateIds: a
								})
							})
						}
						case Kf.e:
						case Kf.d: {
							const n = t.payload,
								r = e[n.subredditId];
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, r, {
									templateIds: n.templateIds
								})
							})
						}
						case ne.i:
						case ne.f:
						case ne.m:
						case ne.p:
						case ne.v: {
							const {
								response: n
							} = t.payload;
							return Jf(e, n.postFlair)
						}
						default:
							return e
					}
				},
				Xf = n("./src/reddit/actions/postRequirements/constants.ts");
			const Zf = {};
			var $f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xf.a: {
						const {
							subredditName: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case Xf.c:
					case Xf.b: {
						const {
							subredditName: n
						} = t.payload;
						return Object(Nu.a)(e, n)
					}
					default:
						return e
				}
			};
			const eg = {};
			var tg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xf.c:
						case Xf.a:
						case Xf.b: {
							const {
								subredditName: n
							} = t.payload, r = t.type === Xf.c;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				ng = Object(r.c)({
					error: $f,
					pending: tg
				}),
				rg = Object(r.c)({
					fetch: ng
				});
			const sg = {};
			var og = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xf.b: {
							const {
								subredditName: n,
								requirements: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case Xf.d: {
							const {
								subredditName: n,
								partialRequirements: r
							} = t.payload, s = e[n];
							return s ? Object.assign({}, e, {
								[n]: Object.assign({}, s, r)
							}) : e
						}
						default:
							return e
					}
				},
				ig = Object(r.c)({
					api: rg,
					models: og
				}),
				cg = n("./src/reddit/actions/inFeedChaining.ts");
			var ag = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case cg.a:
						return t.payload.isDismissed;
					default:
						return e
				}
			};
			const dg = {};
			var ug = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case cg.c: {
						const {
							isDismissed: n,
							listingKey: r,
							postId: s
						} = t.payload;
						if (n) return Object.assign({}, e, {
							[s]: r
						});
						const o = Object.assign({}, e);
						return delete o[s], o
					}
					default:
						return e
				}
			};
			const lg = {};
			var bg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case cg.b:
							return Object.assign({}, e, {
								[t.payload.postId]: t.payload.listingKey
							});
						default:
							return e
					}
				},
				pg = Object(r.c)({
					dismissed: ag,
					dismissedIdToListingKey: ug,
					idToListingKey: bg
				}),
				mg = n("./src/reddit/actions/embedAndImage.ts");
			const fg = {};
			var gg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mg.b: {
							const {
								postId: n
							} = t.payload;
							return e[n] ? Object.assign({}, e, {
								[n]: !1
							}) : e
						}
						case mg.a: {
							const {
								postId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
					}
					return e
				},
				Og = Object(r.c)({
					loadable: gg
				});
			const hg = {};
			var yg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _.c: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !e[n]
						})
					}
					default:
						return e
				}
			};
			var jg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _.d: {
						const {
							postId: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const _g = {};
			var Eg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _g,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.e:
					case Be.h:
					case re.g:
					case ae.b:
					case Me.b:
					case de.e:
					case He.b:
					case ue.i:
					case Ke.c:
					case ce.c:
						return Z()(Object.assign({}, e), t.payload.postInstances, (e, t) => {
							if (e) return e.concat(t)
						});
					default:
						return e
				}
			};
			const vg = {};
			var Ig = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.i: {
							const {
								poll: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.postId]: n.id
							})
						}
						case re.g:
						case ae.b:
						case ue.i:
						case Me.b:
						case Fe.b:
						case re.b: {
							const {
								governance: n,
								posts: r
							} = t.payload;
							if (n) {
								const t = Object.keys(n).reduce((e, t) => {
									const r = n[t];
									return e[t] = r.poll.id, e
								}, {});
								return Object.assign({}, e, t)
							}
							const s = Object.keys(r).reduce((e, t) => r[t].pollData ? (e[t] = t, e) : e, {});
							return Object.assign({}, e, s)
						}
						default:
							return e
					}
				},
				Sg = n("./src/reddit/actions/eventPosts.ts"),
				Tg = n("./src/reddit/actions/flairManagement/constants.ts"),
				xg = n("./src/reddit/actions/monthsToMinutes.ts"),
				Cg = n("./src/reddit/actions/subredditTopContent.ts"),
				wg = n("./src/reddit/helpers/isPost.ts"),
				Pg = n("./node_modules/lodash/pickBy.js"),
				Dg = n.n(Pg);

			function Rg(e, t) {
				const n = Dg()(t, (function(t) {
					let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
					return !e[n] || !_r()(e[n], t)
				}));
				return Object.keys(n).length > 0 ? Object.assign({}, e, n) : e
			}
			var Ag = n("./src/reddit/models/Media/index.ts"),
				kg = n("./src/reddit/models/Post/index.ts"),
				Ng = n("./src/reddit/actions/subredditDuplicates.ts"),
				Lg = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const Mg = {},
				Ug = e => {
					const {
						protocol: t,
						domain: n
					} = e;
					return e => {
						const r = Object(Uf.b)(e.permalink);
						return Object.assign({}, e, {
							permalink: "".concat(t, "://").concat(n).concat(r)
						})
					}
				},
				Fg = e => t => {
					const n = e[t.id];
					return n && n.events && (t.events = n.events, t.source = n.source), t
				},
				Bg = e => t => {
					const n = e[t.id];
					return n && n.isSponsored && (t.isSponsored = n.isSponsored), t
				},
				Gg = e => t => {
					const n = e[t.id];
					return n && n.numDuplicates && (t.numDuplicates = n.numDuplicates), t
				},
				Vg = e => t => {
					const n = e[t.id];
					return t && t.media && n && n.media && Object(Ag.C)(t.media) && t.media.isRichtextPreview && Object(Ag.C)(n.media) && !n.media.isRichtextPreview && (t.media.richtextContent = n.media.richtextContent, t.media.isRichtextPreview = !1), t
				},
				qg = e => {
					let t = e.source;
					return t && t.outboundUrlCreated && (t = Object.assign({}, t, {
						outboundUrlReceived: Date.now()
					}), e.source = t), e
				},
				Hg = e => {
					const {
						allAwardings: t
					} = e, n = Lg(e, ["allAwardings"]);
					if (!t) return e;
					const r = {};
					for (const s of t) r[s.id] = s.count;
					return Object.assign({}, n, {
						awardCountsById: r
					})
				},
				Kg = e => t => {
					for (let n = 0; n < e.length; n++) t = e[n](t);
					return t
				},
				Wg = (e, t) => Object.assign({}, e, {
					events: t.events,
					source: t.source
				}),
				Yg = (e, t) => {
					const n = {},
						r = t.posts;
					return Object.keys(r).length ? (Object.keys(r).map(t => {
						const s = r[t],
							o = e[t];
						o && (n[t] = o.voteState === Ar.a.notVoted ? Object(Ar.c)(o, s) : o)
					}), Object.assign({}, e, n)) : e
				};
			var zg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case m.a:
						if (Do(t) === (xs.xb.COMMENTS || xs.xb.DUPLICATES)) {
							const n = Ro(t),
								r = Ao(t);
							if (n && n.instanceId && r && r.partialPostId) {
								const t = n.instanceId,
									s = Object(kg.m)(r.partialPostId);
								if (e[s] && e[t]) return Object.assign({}, e, {
									[s]: Wg(e[s], e[t])
								})
							}
						}
						return e;
					case Fe.b:
					case re.b: {
						const n = Ug(t.payload.meta);
						return Object.assign({}, e, vr()(t.payload.posts, Kg([n, qg, Hg, Fg(e), Bg(e), Gg(e)])))
					}
					case _.e:
						return Rg(e, t.payload);
					case _.i: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case Ng.a:
						return Rg(e, t.payload.posts);
					case Ge.b:
					case Be.e:
					case Be.h:
					case se.b:
					case se.e:
					case Ve.e:
					case Ve.b:
					case oe.e:
					case oe.b:
					case ae.b:
					case re.g:
					case re.l:
					case ae.b:
					case Fu.b:
					case Ue.r:
					case Me.b:
					case de.e:
					case He.b:
					case qu.h:
					case ue.i:
					case qe.b:
					case Bu.e:
					case Bu.b: {
						const n = Ug(t.payload.meta);
						return Object.assign({}, e, vr()(t.payload.posts, Kg([n, qg, Hg, Vg(e), Gg(e)])))
					}
					case Fu.b: {
						const n = Ug(t.payload.meta),
							r = e[t.payload.postId];
						return Object.assign({}, e, vr()(t.payload.posts, Kg([n, qg, Hg, Vg(e), Gg(e)])), {
							[t.payload.postId]: Object.assign({}, r, {
								numDuplicates: t.payload.count
							})
						})
					}
					case Le.e:
					case Ke.c:
					case ce.c: {
						const n = Ug(t.payload.meta),
							r = vr()(t.payload.posts, Kg([n, Hg, qg]));
						return Z()(Object.assign({}, e), r, (e, t) => Object.assign({}, t, e))
					}
					case _.f: {
						const n = t.payload;
						return Z()(Object.assign({}, e), n, (e, t) => Object.assign({}, e, t))
					}
					case Cr.a: {
						const {
							id: n,
							vote: r
						} = t.payload, s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object(Ar.c)(s, r)
						}) : e
					}
					case ee.a:
					case $.G: {
						const n = t.payload.comment.postId,
							r = e[n];
						if (r) {
							const s = void 0 !== t.payload.numComments ? t.payload.numComments : r.numComments + 1;
							return Object.assign({}, e, {
								[n]: Object.assign({}, r, {
									numComments: s
								})
							})
						}
						return e
					}
					case $.y: {
						const n = t.payload.postId,
							r = e[n];
						return r ? Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								numComments: r.numComments - 1
							})
						}) : e
					}
					case Oe.q: {
						const {
							id: n,
							awardings: r,
							gilder: s
						} = t.payload, o = e[n];
						return o ? Object.assign({}, e, {
							[n]: Dr(o, r, s)
						}) : e
					}
					case w.l: {
						const {
							posts: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							posts: r
						} = n;
						return Object.assign({}, e, vr()(r, Kg([Hg])))
					}
					case Tr.b:
					case ne.s: {
						const {
							operation: n,
							ids: r,
							username: s,
							options: o
						} = t.payload, i = r.filter(e => Object(wg.a)(e)), c = Object(Rr.d)(e, n, i, s, o);
						return Z()(Object.assign({}, e), c, (e, t) => Object.assign({}, e, t))
					}
					case xg.a:
						return Yg(e, t.payload);
					case xg.e: {
						const n = t.payload;
						return Yg(e, n.votes)
					}
					case ks.t: {
						const {
							postId: n,
							collectionId: r
						} = t.payload, s = e[n];
						if (s && r) {
							const t = s.collectionIds || [];
							return t.push(r), Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									collectionIds: [...t]
								})
							})
						}
						return e
					}
					case ks.e: {
						const {
							collectionId: n,
							collection: r
						} = t.payload, s = r && r.postIds || [], o = {};
						return s.forEach(t => {
							const r = e[t],
								s = r && r.collectionIds;
							if (s) {
								const e = s.filter(e => e !== n);
								o[t] = Object.assign({}, r, {
									collectionIds: e
								})
							}
						}), Object.assign({}, e, o)
					}
					case ks.g: {
						const {
							collectionId: n,
							postId: r
						} = t.payload;
						if (!n || !r) return e;
						const s = e[r],
							o = s && s.collectionIds;
						if (!o) return e;
						const i = o.filter(e => e !== n);
						return Object.assign({}, e, {
							[r]: Object.assign({}, s, {
								collectionIds: i
							})
						})
					}
					case Sg.START_EVENT_NOW_SUCCESS: {
						const {
							postId: n
						} = t.payload;
						if (!n) return e;
						const r = e[n];
						if (!r || !r.eventInfo) return e;
						const s = r.eventInfo;
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								eventInfo: Object.assign({}, s, {
									eventIsLive: !0
								})
							})
						})
					}
					case Sg.EDIT_EVENT_TIME_SUCCESS: {
						const {
							postId: n,
							eventInfo: r
						} = t.payload;
						if (!n || !r) return e;
						const s = e[n];
						return s ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								eventInfo: Object.assign({}, r)
							})
						}) : e
					}
					case Pa.e: {
						const n = t.payload.subredditTopContent;
						return n && n.posts && Object.keys(n.posts) ? Object.assign({}, vr()(n.posts, Kg([Hg])), e) : e
					}
					case ie.c:
					case ie.i:
					case ie.e:
					case ie.g:
					case Cg.b:
						return Object.assign({}, vr()(t.payload.posts, Kg([Hg])), e);
					case _.h: {
						const {
							postId: n,
							richtextContent: r
						} = t.payload, s = e[n];
						return s && s.media && Object(Ag.C)(s.media) ? Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								media: Object.assign({}, s.media, {
									richtextContent: r,
									isRichtextPreview: !1
								})
							})
						}) : e
					}
					case Tg.a: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case Tg.b: {
						const n = t.payload;
						return Object(Nu.a)(e, n)
					}
					case ll.a: {
						const {
							isDeleted: n,
							height: r,
							postId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								media: Object.assign({}, e[s].media, {
									height: r,
									isDeleted: n
								})
							})
						})
					}
					default:
						return e
				}
			};
			const Jg = [];
			var Qg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _.g: {
						const {
							postIds: e
						} = t.payload;
						return e
					}
					case re.g:
					case ae.b: {
						const {
							recentPostIds: n
						} = t.payload;
						return n && n.length ? n : e
					}
					default:
						return e
				}
			};
			var Xg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mo.c:
					case mo.b:
						return !1;
					case mo.a:
						return !0;
					default:
						return e
				}
			};
			var Zg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mo.c:
						return !0;
					case mo.b:
					case mo.a:
						return !1;
					default:
						return e
				}
			};
			var $g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mo.g:
							return !0;
						case mo.a:
						case mo.h:
							return !1;
						default:
							return e
					}
				},
				eO = Object(r.c)({
					error: Xg,
					pending: Zg,
					pendingUpdate: $g
				});
			const tO = {};
			var nO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mo.b: {
						const {
							subredditInfoById: n
						} = t.payload, {
							id: r
						} = n, s = n.scheduledPosts.standalonePosts.models.reduce((e, t) => (e[t.id] = t, e), {});
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r] || {}, s)
						})
					}
					case mo.e:
					case mo.i: {
						const {
							subredditId: n,
							scheduledPostId: r
						} = t.payload, s = e[n] || {};
						return Object.assign({}, e, {
							[n]: Object.assign({}, Object.keys(s).filter(e => e !== r).reduce((e, t) => (e[t] = s[t], e), {}))
						})
					}
					case mo.d: {
						const {
							subredditId: n
						} = t.payload;
						return Object.keys(e).reduce((t, r) => (r !== n && (t[r] = e[r]), t), {})
					}
					case mo.h: {
						const {
							scheduledPost: n
						} = t.payload, r = n.subreddit.id, s = e[r][n.id], o = {
							[n.id]: Object.assign({}, s, n)
						};
						return Object.assign({}, e, {
							[r]: Object.assign({}, e[r] || {}, o)
						})
					}
					default:
						return e
				}
			};
			const rO = {};
			var sO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mo.b: {
							const {
								subredditInfoById: n
							} = t.payload, r = n.id, {
								pageInfo: s
							} = n.scheduledPosts.standalonePosts;
							return Object.assign({}, e, {
								[r]: Object.assign({}, s)
							})
						}
						case mo.d: {
							const {
								subredditId: n
							} = t.payload;
							return Object.keys(e).reduce((t, r) => (r !== n && (t[r] = e[r]), t), {})
						}
						default:
							return e
					}
				},
				oO = n("./node_modules/lodash/uniq.js"),
				iO = n.n(oO);
			const cO = {};
			var aO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mo.b: {
							const {
								subredditInfoById: n
							} = t.payload, r = n.id, s = n.scheduledPosts.standalonePostsIds;
							return Object.assign({}, e, {
								[r]: iO()([...e[r] || [], ...s])
							})
						}
						case mo.e:
						case mo.i: {
							const {
								subredditId: n,
								scheduledPostId: r
							} = t.payload, s = e[n] || [];
							return Object.assign({}, e, {
								[n]: s.filter(e => e !== r)
							})
						}
						case mo.d: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: []
							})
						}
						default:
							return e
					}
				},
				dO = Object(r.c)({
					models: nO,
					pageInfo: sO,
					postOrder: aO
				}),
				uO = Object(r.c)({
					api: eO,
					standalonePosts: dO
				});
			const lO = {};
			var bO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.k: {
						const {
							auto: n,
							postId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			const pO = {};
			var mO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.g: {
						const {
							postId: n,
							isBuffering: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const fO = {};
			var gO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.h: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					default:
						return e
				}
			};
			const OO = {};
			var hO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.i: {
						const {
							postId: n,
							time: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			var yO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.q: {
						const {
							postId: e
						} = t.payload;
						return e
					}
					case E.j:
						return null;
					default:
						return e
				}
			};
			const jO = {};
			var _O = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.t: {
						const {
							postId: n
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					case E.k: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
				}
				return e
			};
			const EO = {};
			var vO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : EO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.n: {
						const {
							postId: n,
							time: r
						} = t.payload, s = e[n] || {
							cached: !0,
							start: r
						};
						return r < s.start ? e : Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								playable: r
							})
						})
					}
					case E.l: {
						const {
							postId: n,
							time: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {
								cached: !1,
								start: r
							}
						})
					}
					default:
						return e
				}
			};
			const IO = {};
			var SO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.p: {
						const {
							postId: n,
							metadata: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const TO = {};
			var xO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : TO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.u: {
						const {
							postId: n
						} = t.payload;
						return e[n] ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					case E.m: {
						const {
							postId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
				}
				return e
			};
			const CO = {};
			var wO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case E.o: {
						const {
							postId: n,
							isPlaying: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const PO = {};
			var DO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case E.r: {
							const {
								postId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						default:
							return e
					}
				},
				RO = n("./src/reddit/constants/video.ts");
			const AO = {};
			var kO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case E.s: {
							const {
								postId: n,
								time: r
							} = t.payload;
							return e[n] && parseInt(r.currentTime.toString(), 10) - parseInt(e[n].currentTime.toString(), 10) < RO.k ? e : Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				NO = Object(r.c)({
					autoPlayed: bO,
					buffering: mO,
					consumed: gO,
					continuousViewStartedAt: hO,
					fullscreen: yO,
					loadable: _O,
					loadTimes: vO,
					metadata: SO,
					paused: xO,
					playing: wO,
					started: DO,
					time: kO
				}),
				LO = Object(r.c)({
					chained: pg,
					embedAndImage: Og,
					expanded: yg,
					focus: jg,
					instances: Eg,
					metaMap: Ig,
					models: zg,
					recent: Qg,
					scheduledPosts: uO,
					video: NO
				}),
				MO = n("./src/lib/reducers/addAuthentication/index.ts");
			const UO = {};
			var FO = Object(MO.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : UO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case re.b: {
							const {
								postId: n,
								commentLists: r,
								comments: s
							} = t.payload, o = r[n] && r[n].head;
							return o && s[o.id] && s[o.id].isStickied ? Object.assign({}, e, {
								[n]: o.id
							}) : e
						}
						case $.C: {
							const {
								id: e,
								postId: n
							} = t.payload;
							return {
								[n]: e
							}
						}
						default:
							return e
					}
				}), UO),
				BO = Object(r.c)({
					data: FO
				});
			const GO = {};
			var VO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.f:
					case g.g: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case g.e: {
						const {
							subredditId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const qO = {};
			var HO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case g.f: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case g.g:
						case g.e: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				KO = Object(r.c)({
					error: VO,
					pending: HO
				});
			const WO = {};
			var YO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : WO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.d: {
						const {
							product: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: void 0
						})
					}
					case g.c:
					case b.f:
					case b.g:
					case b.i:
					case b.j: {
						const {
							productId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: void 0
						})
					}
					case g.a:
					case b.d:
					case b.h: {
						const {
							productId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const zO = {};
			var JO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case g.c:
						case b.f: {
							const {
								productId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case g.d: {
							const {
								product: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.id]: !1
							})
						}
						case g.a:
						case b.d:
						case b.g: {
							const {
								productId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				QO = Object(r.c)({
					error: YO,
					pending: JO
				}),
				XO = Object(r.c)({
					fetch: KO,
					purchase: QO
				});
			var ZO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.b:
						return t.payload.productId;
					case s.b:
						return null;
					default:
						return e
				}
			};
			const $O = {};
			var eh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $O,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.j:
						case g.g: {
							const {
								products: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				th = Object(r.c)({
					api: XO,
					currentlyPurchasing: ZO,
					models: eh
				});
			const nh = {};
			var rh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.f:
					case se.e:
					case se.c:
					case se.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case se.d:
					case se.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const sh = {};
			var oh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.f:
						case se.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case se.e:
						case se.d:
						case se.b:
						case se.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				ih = Object(r.c)({
					error: rh,
					pending: oh
				});
			const ch = {};
			var ah = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ch,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.e: {
							const {
								key: n,
								commentIds: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case se.b: {
							const {
								key: n,
								commentIds: r
							} = t.payload, s = e[n] || [];
							return Object.assign({}, e, {
								[n]: s.concat(r)
							})
						}
						default:
							return e
					}
				},
				dh = n("./src/reddit/actions/comment/list.ts");
			const uh = {};
			var lh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case dh.a: {
						const {
							listingKey: n,
							listingName: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case dh.b: {
						const {
							listingKey: n
						} = t.payload;
						return n in e ? Sr()(e, n) : e
					}
					default:
						return e
				}
			};
			const bh = {};
			var ph = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {}
						})
					}
					case se.b: {
						const {
							key: n,
							fetchedToken: r
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								[r]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const mh = {};
			var fh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.e:
						case se.b: {
							const {
								key: n,
								dist: r,
								token: s
							} = t.payload;
							return s ? Object.assign({}, e, {
								[n]: {
									dist: r,
									token: s
								}
							}) : Object(Nu.a)(e, n)
						}
						default:
							return e
					}
				},
				gh = Object(r.c)({
					api: ih,
					endMarkers: lh,
					fetchedTokens: ph,
					commentIds: ah,
					loadMore: fh
				}),
				Oh = n("./src/reddit/actions/pages/profileModSettings.ts");
			var hh = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Oh.a:
							return !1;
						default:
							return e
					}
				},
				yh = Object(r.c)({
					pending: hh
				}),
				jh = Object(r.c)({
					api: yh
				});
			const _h = {};
			var Eh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _h,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ve.c:
					case Ve.b:
					case qe.c:
					case qe.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ve.a:
					case qe.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const vh = {};
			var Ih = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ve.c:
						case qe.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ve.b:
						case Ve.a:
						case qe.b:
						case qe.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Sh = Object(r.c)({
					error: Eh,
					pending: Ih
				});
			const Th = {};
			var xh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Th,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ve.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {}
						})
					}
					case qe.b: {
						const {
							key: n,
							fetchedToken: r
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								[r]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const Ch = {};
			var wh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ch,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ve.b:
					case qe.b: {
						const {
							key: n,
							overviewIds: r
						} = t.payload, s = e[n] || [];
						return Object.assign({}, e, {
							[n]: [...s, ...r]
						})
					}
					default:
						return e
				}
			};
			const Ph = {};
			var Dh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ph,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ve.b:
						case qe.b: {
							const {
								key: n,
								dist: r,
								token: s
							} = t.payload;
							return s ? Object.assign({}, e, {
								[n]: {
									dist: r,
									token: s
								}
							}) : Object(Nu.a)(e, n)
						}
						default:
							return e
					}
				},
				Rh = Object(r.c)({
					api: Sh,
					fetchedTokens: xh,
					ids: wh,
					loadMore: Dh
				});
			const Ah = {};
			var kh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ah,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ve.f:
					case Ve.e: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case Ve.d: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r || {}
						})
					}
					default:
						return e
				}
			};
			const Nh = {};
			var Lh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ve.f: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case Ve.e:
						case Ve.d: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Mh = Object(r.c)({
					error: kh,
					pending: Lh
				});
			const Uh = {};
			var Fh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Uh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case de.c:
					case de.b: {
						const {
							extraCommentsId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case de.a: {
						const {
							extraCommentsId: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r || {}
						})
					}
					default:
						return e
				}
			};
			const Bh = {};
			var Gh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case de.c: {
							const {
								extraCommentsId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case de.b:
						case de.a: {
							const {
								extraCommentsId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Vh = Object(r.c)({
					error: Fh,
					pending: Gh
				});
			const qh = {};
			var Hh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ve.e:
						case de.b:
						case de.e:
							return Object.assign({}, e, t.payload.extraComments);
						default:
							return e
					}
				},
				Kh = Object(r.c)({
					api: Vh,
					models: Hh
				}),
				Wh = n("./src/lib/makeOverviewConversationsItemKey/index.ts"),
				Yh = n("./src/reddit/constants/comments.ts");
			const zh = {};

			function Jh(e) {
				const t = e;
				return vr()(t, e => {
					let {
						depth: t,
						next: n,
						prev: r
					} = e;
					return {
						depth: t,
						next: n,
						prev: r
					}
				})
			}
			const Qh = (e, t, n) => {
				const r = {};
				for (const s in t) {
					const e = t[s],
						n = e.postId;
					r.hasOwnProperty(n) ? r[n] = Object.assign({}, r[n], {
						[s]: e
					}) : r[n] = {
						[s]: e
					}
				}
				for (const s in n) {
					const e = n[s],
						t = e.postId;
					r.hasOwnProperty(t) ? r[t] = Object.assign({}, r[t], {
						[s]: e
					}) : r[t] = {
						[t]: e
					}
				}
				return r
			};
			var Xh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ve.e:
					case de.e: {
						const {
							comments: n,
							extraComments: r,
							postIds: s,
							profileName: o
						} = t.payload, i = Qh(s, n, r), c = {};
						for (const e of s) {
							c[Object(Wh.a)(e, o)] = i.hasOwnProperty(e) ? Jh(i[e]) : {}
						}
						return Object.assign({}, e, c)
					}
					case de.b: {
						const {
							comments: n,
							commentLists: r,
							extraComments: s,
							extraCommentsId: o,
							postIds: i,
							profileName: c
						} = t.payload;
						if (0 === i.length) {
							const t = Object.keys(e).find(t => void 0 !== e[t][o]);
							if (!t) return e;
							const n = Object.assign({}, e[t])[o].prev,
								r = n && n.id || "";
							return Object.assign({}, e, {
								[t]: Object.assign({}, e[t], {
									[r]: Object.assign({}, e[t][r], {
										next: null
									})
								})
							})
						}
						const a = i[0],
							d = Jh(Qh(i, n, s)[a]),
							u = Object(Wh.a)(a, c),
							l = Object.assign({}, e[u]),
							b = l[o].prev,
							p = b && b.id || "",
							m = r[a].head,
							f = m && m.id || "",
							g = {
								id: f,
								type: Yh.a.Comment
							},
							O = Object.assign({}, l, {
								[p]: Object.assign({}, l[p], {
									next: g
								})
							}, d, {
								[f]: Object.assign({}, d[f], {
									prev: b
								})
							});
						return Object.assign({}, e, {
							[u]: O
						})
					}
					default:
						return e
				}
			};
			const Zh = {};
			var $h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ve.e:
					case de.e: {
						const {
							commentLists: n,
							postIds: r,
							profileName: s
						} = t.payload, o = {};
						for (const e of r) {
							o[Object(Wh.a)(e, s)] = n[e] && n[e].head ? n[e].head.id : null
						}
						return Object.assign({}, e, o)
					}
					default:
						return e
				}
			};
			const ey = {};
			var ty = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ey,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ve.e:
						case de.e: {
							const {
								postIds: n,
								profileName: r
							} = t.payload, s = {};
							for (const e of n) {
								s[Object(Wh.a)(e, r)] = e
							}
							return Object.assign({}, e, s)
						}
						default:
							return e
					}
				},
				ny = Object(r.c)({
					api: Mh,
					extraComments: Kh,
					keyToCommentThreadLinkSets: Xh,
					keyToHeadCommentId: $h,
					keyToPostId: ty
				}),
				ry = Object(r.c)({
					chrono: Rh,
					conversations: ny
				});
			const sy = {};
			var oy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				return t.type, e
			};
			const iy = {};
			var cy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.a:
					case ie.d: {
						const {
							listingKey: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case ie.b:
					case ie.c:
					case ie.i:
					case ie.f:
					case ie.e:
					case ie.g: {
						const {
							listingKey: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					default:
						return e
				}
			};
			const ay = {};
			var dy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ay,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.b:
						case ie.f: {
							const {
								listingKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case ie.a:
						case ie.d:
						case ie.c:
						case ie.i:
						case ie.e:
						case ie.g: {
							const {
								listingKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				uy = Object(r.c)({
					error: cy,
					pending: dy
				});
			const ly = {};
			var by = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ly,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c:
					case ie.i:
					case ie.e:
					case ie.g: {
						const {
							listingKey: n,
							itemIds: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: [...e[n] || [], ...r]
						})
					}
					default:
						return e
				}
			};
			const py = {};
			var my = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : py,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.i:
						case ie.c:
						case ie.e:
						case ie.g: {
							const {
								pageInfo: n,
								listingKey: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[r]: n
							}) : py
						}
						default:
							return e
					}
				},
				fy = Object(r.c)({
					api: uy,
					ids: by,
					pageInfo: my
				}),
				gy = n("./src/reddit/constants/posts.ts");
			const Oy = {};
			var hy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Oy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case Ke.c:
						return Object.assign({}, e, t.payload.profileAboutInfo);
					case jm.k: {
						const n = t.payload;
						return n.profile ? Object.assign({}, e, {
							[n.profile.id]: n.about
						}) : e
					}
					case vm.h: {
						const {
							identifiers: n,
							userIsSubscriber: r
						} = t.payload, s = n.filter(e => e.type === gy.a.PROFILE);
						return s.length ? s.reduce((e, t) => (e[t.id] = Object.assign({}, e[t.id], {
							userIsSubscriber: r
						}), e), Object.assign({}, e)) : e
					}
					case tl.m: {
						const n = t.payload,
							r = e[n.subredditId];
						if (!r) return e;
						if (r.publicDescription === n.settings.publicDescription) return e;
						const s = Object.assign({}, r, {
							publicDescription: n.settings.publicDescription
						});
						return Object.assign({}, e, {
							[n.subredditId]: s
						})
					}
					default:
						return e
				}
			};
			const yy = {},
				jy = (e, t) => {
					if (!t) return e;
					const n = Object.keys(t);
					if (!n.length) return e;
					const r = {};
					return n.forEach(n => {
						const s = e[n],
							o = Object.assign({}, t[n]);
						s && _r()(s, o) || (r[n] = o)
					}), Object.keys(r).length ? Object.assign({}, e, r) : e
				};
			var _y = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.b:
					case Fe.b:
					case re.b:
					case re.g:
					case se.b:
					case se.e:
					case ie.c:
					case ie.i:
					case ie.e:
					case ie.g:
					case Ve.b:
					case Ve.e:
					case oe.e:
					case qe.b:
					case Me.b:
					case Be.e:
					case Be.h:
					case Ue.u:
					case jm.h:
					case Fu.b:
					case Ke.c:
					case ue.i:
					case jm.l:
					case de.b:
					case de.e:
					case ce.c:
					case Ge.b:
					case Fs.e:
					case Co.a:
					case ae.b:
					case re.l:
					case He.b:
					case vm.c:
						return jy(e, t.payload.profiles);
					case Ke.e: {
						const {
							typeaheadSuggestions: n
						} = t.payload;
						return Object.keys(n).length ? jy(e, n.profiles) : e
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case ne.k: {
						const {
							response: n
						} = t.payload, r = n && n.profiles;
						return jy(e, r)
					}
					case jm.k: {
						const {
							profile: n
						} = t.payload;
						return n ? jy(e, {
							[n.id]: n
						}) : e
					}
					case tl.m: {
						const n = t.payload,
							{
								title: r,
								over18: s
							} = n.settings,
							o = e[n.subredditId];
						return !o || o.title === r && o.isNSFW === s ? e : Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, o, {
								id: n.subredditId,
								title: r,
								isNSFW: s
							})
						})
					}
					case tl.k:
					case tl.j: {
						const {
							imageUrl: n,
							key: r,
							subredditId: s
						} = t.payload;
						if ("profileIcon" !== r) return e;
						const o = e[s];
						return o ? Object.assign({}, e, {
							[s]: Object.assign({}, o, {
								icon: {
									height: null,
									url: n,
									width: null
								}
							})
						}) : e
					}
					default:
						return e
				}
			};
			const Ey = {};
			var vy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ey,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jm.c:
						case jm.f: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[(n || "").toLowerCase()]: !0
							})
						}
						case jm.a:
						case jm.b:
						case jm.d:
						case jm.e: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[(n || "").toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Iy = Object(r.c)({
					pending: vy
				});
			const Sy = {};
			var Ty = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jm.b: {
						const {
							profileName: n,
							data: r
						} = t.payload, s = r.map(e => e.id);
						return Object.assign({}, e, {
							[(n || "").toLowerCase()]: s
						})
					}
					case jm.e:
					case ie.c:
					case ie.i:
					case ie.e:
					case ie.g: {
						const {
							profileName: n,
							moderatedSubredditIds: r
						} = t.payload;
						return r ? Object.assign({}, e, {
							[n]: [...e[n] || [], ...r]
						}) : e
					}
					default:
						return e
				}
			};
			const xy = {};
			var Cy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jm.e: {
							const {
								pageInfo: n,
								profileName: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: n
							})
						}
						case ie.c:
						case ie.i: {
							const {
								moderatedPageInfo: n,
								profileName: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: n
							})
						}
						default:
							return e
					}
				},
				wy = Object(r.c)({
					api: Iy,
					models: Ty,
					pageInfo: Cy
				});
			const Py = {};
			var Dy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Py,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jm.i: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !0
							})
						}
						case jm.g:
						case jm.h: {
							const {
								profileName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Ry = Object(r.c)({
					pending: Dy
				});
			const Ay = {};
			var ky = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ay,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jm.h: {
							const {
								pageInfo: n,
								profileName: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: n
							})
						}
						default:
							return e
					}
				},
				Ny = Object(r.c)({
					api: Ry,
					pageInfo: ky
				}),
				Ly = n("./src/reddit/actions/pinnedPost.ts");
			const My = {};
			var Uy = Object(MO.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : My,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ly.a: {
						const {
							pinned: n,
							profileId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					case Ly.d: {
						const {
							postId: n,
							profileId: r
						} = t.payload, s = e[r] || [];
						return Object.assign({}, e, {
							[r]: [...s, n].slice(-xs.U)
						})
					}
					case Ly.g: {
						const {
							postId: n,
							profileId: r
						} = t.payload, s = e[r] || [];
						return Object.assign({}, e, {
							[r]: s.filter(e => e !== n)
						})
					}
					default:
						return e
				}
			}), My);
			const Fy = {};
			var By = Object(MO.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ly.a: {
						const {
							pinned: n,
							profileId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			}), Fy);
			const Gy = {};
			var Vy = Object(MO.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ly.c:
						case Ly.f: {
							const {
								postId: n,
								profileId: r
							} = t.payload, s = e[r] || [];
							return Object.assign({}, e, {
								[r]: [...s, n]
							})
						}
						case Ly.b:
						case Ly.e:
						case Ly.d:
						case Ly.g: {
							const {
								postId: n,
								profileId: r
							} = t.payload, s = e[r] || [];
							return Object.assign({}, e, {
								[r]: s.filter(e => e !== n)
							})
						}
						default:
							return e
					}
				}), Gy),
				qy = Object(r.c)({
					data: Uy,
					initialData: By,
					pending: Vy
				}),
				Hy = n("./src/reddit/actions/trophyCase.ts");
			const Ky = {};
			var Wy, Yy, zy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ky,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Hy.a: {
							const {
								profileId: n,
								trophyIds: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				Jy = Object(r.c)({
					about: hy,
					models: _y,
					moderated: wy,
					multireddits: Ny,
					pinnedPosts: qy,
					trophyCases: zy
				});
			n("./src/lib/cache/index.ts");
			! function(e) {
				e.MobilePromoBanner = "mobilePromoBanner", e.UpsellSignUpBannerLarge = "upsellSignUpBannerLarge", e.UpsellSignUpBannerMedium = "upsellSignUpBannerMedium", e.UpsellSignUpBannerSmall = "upsellSignUpBannerSmall"
			}(Wy || (Wy = {})),
			function(e) {
				e[e.FrontPage = 0] = "FrontPage", e[e.SubredditPage = 1] = "SubredditPage", e[e.CommentsPage = 2] = "CommentsPage"
			}(Yy || (Yy = {}));
			var Qy, Xy, Zy;
			! function(e) {
				e.mobilePromoBanner = "desktop_xpromo_banner"
			}(Qy || (Qy = {})),
			function(e) {
				e.Test1 = "test_1", e.Test2 = "test_2"
			}(Xy || (Xy = {})),
			function(e) {
				e.Test1 = "test_1", e.Test2 = "test_2"
			}(Zy || (Zy = {}));
			! function(e) {
				e.welcome = "signup_upsell_banner_welcome", e.join = "signup_upsell_banner_redditor", e.vote = "signup_upsell_banner_discuss", e.personalize = "signup_upsell_banner_personalize"
			}(Qy || (Qy = {}));
			Object(Ga.a)("PROMO__SHOW_PROMO"), Object(Ga.a)("PROMO__HIDE_PROMO");
			const $y = {
				mobilePromoBanner: !1,
				upsellSignUpBannerLarge: !1,
				upsellSignUpBannerMedium: !1,
				upsellSignUpBannerSmall: null
			};
			var ej = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "PROMO__SHOW_PROMO": {
							const {
								promoType: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case "PROMO__HIDE_PROMO": {
							const {
								promoType: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				tj = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const nj = {
				isError: !1,
				isPending: !1,
				global: {
					rpan_config_refresh_rate: tj.d,
					viewer_streams_refresh: tj.c,
					viewer_streams_refresh_slop: tj.e
				},
				subreddits: {},
				isPermanentlyCanceled: !1
			};
			var rj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tj.x:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !1,
								global: Object.assign({}, t.payload)
							});
						case tj.y:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !1,
								subreddits: Object.assign({}, e.subreddits, {
									[t.payload.name]: Object.assign({}, t.payload.config)
								})
							});
						case tj.G:
							return Object.assign({}, e, {
								isPending: !0
							});
						case tj.I:
							return Object.assign({}, e, {
								isError: !0,
								isPending: !1
							});
						case tj.H:
							return Object.assign({}, e, {
								isPermanentlyCanceled: !0,
								isPending: !1
							});
						default:
							return e
					}
				},
				sj = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			var oj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.L:
						return Object.assign({}, e, {
							[tj.b]: t.payload.error
						});
					case tj.M:
						return Object.assign({}, e, {
							[t.payload.streamId]: t.payload.error
						});
					case tj.A: {
						const t = tj.b;
						e[t];
						return sj(e, ["symbol" == typeof t ? t : t + ""])
					}
					case tj.z: {
						const n = t.payload.model.post.id;
						e[n];
						return sj(e, ["symbol" == typeof n ? n : n + ""])
					}
					default:
						return e
				}
			};
			const ij = (e, t, n, r) => Object.assign({}, e, {
				[t]: Object.assign({}, e[t], {
					isPending: n
				}, r && {
					utcTimeStamp: r
				})
			});
			var cj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.N:
						return ij(e, t.payload, !0);
					case tj.O:
						return ij(e, tj.b, !0);
					case tj.z:
						return ij(e, t.payload.model.post.id, !1, t.payload.utcTimeStamp);
					case tj.A:
						return ij(e, tj.b, !1, t.payload.utcTimeStamp);
					case tj.M:
						return ij(e, t.payload.streamId, !1);
					case tj.L:
						return ij(e, tj.b, !1);
					default:
						return e
				}
			};
			const aj = {
				isError: !1,
				isPending: !1,
				subreddits: []
			};
			var dj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tj.w:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !1,
								subreddits: t.payload.subreddits
							});
						case tj.J:
							return Object.assign({}, e, {
								isError: !1,
								isPending: !0
							});
						case tj.K:
							return Object.assign({}, e, {
								isError: !0,
								isPending: !1
							});
						default:
							return e
					}
				},
				uj = Object(r.c)({
					config: rj,
					error: oj,
					pending: cj,
					recommendedViewerSubreddits: dj
				});
			const lj = {
				cursor: tj.X,
				timestamps: {},
				visitOrder: []
			};
			var bj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.P:
						return lj;
					case tj.Y: {
						const n = t.payload,
							r = e.visitOrder.includes(n) ? e.visitOrder : [...e.visitOrder, n],
							s = r.indexOf(n);
						return r === e.visitOrder && s === e.cursor ? e : Object.assign({}, e, {
							visitOrder: r,
							cursor: s
						})
					}
					case O.d:
						return pj(e, t.payload.id);
					case tj.F:
						return pj(e, t.payload);
					case _.f: {
						const n = Object.keys(t.payload).filter(e => t.payload[e].hidden);
						return mj(e, n)
					}
					case tj.U: {
						const {
							streamId: n,
							timestamp: r
						} = t.payload;
						return Object.assign({}, e, {
							timestamps: Object.assign({}, e.timestamps, {
								[n]: r
							})
						})
					}
					default:
						return e
				}
			};
			const pj = (e, t) => {
					const n = e.visitOrder.indexOf(t);
					if (-1 === n) return e;
					const r = n > e.cursor ? e.cursor : Math.max(e.cursor - 1, 0);
					return Object.assign({}, e, {
						visitOrder: e.visitOrder.filter(e => e !== t),
						cursor: r
					})
				},
				mj = (e, t) => {
					const n = e.visitOrder[e.cursor],
						r = new Set(t),
						s = e.visitOrder.filter(e => !r.has(e)),
						o = s.indexOf(n),
						i = o > -1 ? o : Math.max(e.cursor - 1, 0);
					return s.length !== e.visitOrder.length ? Object.assign({}, e, {
						cursor: i,
						visitOrder: s
					}) : e
				},
				fj = {
					ended: [],
					removed: []
				};

			function gj(e) {
				return [...new Set(e)]
			}
			var Oj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.u:
						return Object.assign({}, e, {
							ended: gj(e.ended.concat(t.payload))
						});
					case tj.v:
						return Object.assign({}, e, {
							removed: gj(e.removed.concat(t.payload))
						});
					default:
						return e
				}
			};
			const hj = {};
			var yj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.A:
						const {
							listingName: n, models: r
						} = t.payload;
						if (!n) return e;
						const s = r.map(e => e.post.id),
							o = e[n] || [],
							i = [...new Set([...s, ...o])];
						return Object.assign({}, e, {
							[n]: i
						});
					default:
						return e
				}
			};
			const jj = {},
				_j = (e, t) => {
					const n = Object.keys(e).reduce((t, n) => Object.assign({}, t, {
						[n]: Object.assign({}, e[n], {
							rank: tj.o
						})
					}), {});
					return t.reduce((e, t, n) => Object.assign({}, e, {
						[t.post.id]: Object.assign({}, t, {
							rank: tj.n - n
						})
					}), n)
				},
				Ej = (e, t) => {
					const n = t.post.id,
						r = e[n] ? e[n].rank : tj.o;
					return Object.assign({}, e, {
						[t.post.id]: Object.assign({}, t, {
							rank: r
						})
					})
				};
			var vj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.z:
						return Ej(e, t.payload.model);
					case tj.A:
						return _j(e, t.payload.models);
					case tj.E: {
						const n = t.payload.streamId,
							r = t.payload.isUnsetting ? -1 : 1,
							s = (t.payload.isUp ? 1 : 0) * r,
							o = (t.payload.isUp ? 0 : 1) * r;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								downvotes: e[n].downvotes + o,
								upvotes: e[n].upvotes + s
							})
						})
					}
					default:
						return e
				}
			};
			const Ij = {
				discoveryUnitThumbnails: {},
				streamPreviews: {}
			};
			var Sj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ij,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.t:
						return Object.assign({}, e, {
							discoveryUnitThumbnails: Object.assign({}, t.payload.reduce((e, t) => Object.assign({}, e, {
								[t.postId]: t.imageUrl
							}), {}))
						});
					case tj.B:
						return Object.assign({}, e, {
							streamPreviews: Object.assign({}, e.streamPreviews, t.payload.reduce((e, t) => Object.assign({}, e, {
								[t.postId]: t.imageUrl
							}), {}))
						});
					default:
						return e
				}
			};
			const Tj = {
				reported: []
			};
			var xj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.d:
						return Object.assign({}, e, {
							reported: [...e.reported, t.payload.id]
						});
					default:
						return e
				}
			};
			const Cj = {
				isIntroFinished: !1
			};
			var wj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tj.C:
						return Object.assign({}, e, t.payload);
					default:
						return e
				}
			};
			const Pj = {
				isMuted: !0,
				reportedStreams: [],
				shouldShowOnboardingModal: !0
			};
			var Dj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tj.D:
							return Object.assign({}, e, t.payload);
						case O.d: {
							const n = t.payload.id;
							return e.reportedStreams.includes(n) ? e : Object.assign({}, e, {
								reportedStreams: [...e.reportedStreams, n]
							})
						}
						default:
							return e
					}
				},
				Rj = Object(r.c)({
					api: uj,
					history: bj,
					hlsStreams: Oj,
					listings: yj,
					models: vj,
					preloads: Sj,
					reports: xj,
					theaterSettings: wj,
					userSettings: Dj
				});
			const Aj = {};
			var kj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Aj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case He.b:
							return Object.assign({}, e, t.payload);
						case He.a:
						default:
							return e
					}
				},
				Nj = n("./src/reddit/actions/removalReasons/constants.ts");
			var Lj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Nj.k:
					case Nj.l:
					case Nj.b:
					case Nj.c:
					case Nj.h:
					case Nj.i:
					case Nj.e:
					case Nj.f:
						return null;
					case Nj.j:
					case Nj.a:
					case Nj.g:
					case Nj.d:
						return t.payload;
					default:
						return e
				}
			};
			var Mj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Nj.k:
						case Nj.b:
						case Nj.h:
						case Nj.e:
							return !0;
						case Nj.l:
						case Nj.j:
						case Nj.c:
						case Nj.a:
						case Nj.i:
						case Nj.g:
						case Nj.f:
						case Nj.d:
							return !1;
						default:
							return e
					}
				},
				Uj = Object(r.c)({
					error: Lj,
					pending: Mj
				}),
				Fj = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const Bj = {};
			var Gj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Nj.l: {
						const {
							response: n
						} = t.payload, {
							data: r
						} = n;
						return Object.assign({}, e, r)
					}
					case Nj.c:
					case Nj.i: {
						const {
							reason: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.id]: n
						})
					}
					case Nj.f: {
						const {
							reasonId: n
						} = t.payload, r = n;
						e[r];
						return Fj(e, ["symbol" == typeof r ? r : r + ""])
					}
					default:
						return e
				}
			};
			const Vj = {};
			var qj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Nj.l: {
						const {
							subredditId: n,
							response: r
						} = t.payload, {
							order: s
						} = r;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					case Nj.c: {
						const {
							subredditId: n,
							reason: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: [...e[n], r.id]
						})
					}
					case Nj.f: {
						const {
							subredditId: n,
							reasonId: r
						} = t.payload, s = [...e[n]].filter(e => e !== r);
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			var Hj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Nj.t: {
							const {
								subredditId: e,
								itemIds: n
							} = t.payload;
							return {
								itemIds: n,
								subredditId: e
							}
						}
						default:
							return e
					}
				},
				Kj = Object(r.c)({
					api: Uj,
					models: Gj,
					reasonOrder: qj,
					removedItemIds: Hj
				});
			const Wj = {};
			var Yj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.e:
					case O.d: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case O.c: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case O.f: {
						const n = t.payload;
						return n ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					default:
						return e
				}
			};
			const zj = {};
			var Jj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.e: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case O.d:
					case O.c: {
						const {
							id: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					case O.f: {
						const n = t.payload;
						return n ? Object.assign({}, e, {
							[n]: !1
						}) : e
					}
					default:
						return e
				}
			};
			const Qj = {};
			var Xj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case O.d: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case O.e:
						case O.c: {
							const {
								id: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						case O.f: {
							const n = t.payload;
							return n ? Object.assign({}, e, {
								[n]: !1
							}) : e
						}
						default:
							return e
					}
				},
				Zj = Object(r.c)({
					error: Yj,
					pending: Jj,
					success: Xj
				});
			var $j = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.b:
						return t.payload;
					case s.c:
						return !t.payload && e;
					case m.a:
						return !1;
					case O.f:
						return !!t.payload && e;
					default:
						return e
				}
			};
			var e_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.f:
						return t.payload;
					case s.c:
						return t.payload ? null : e;
					case m.a:
						return null;
					default:
						return e
				}
			};
			var t_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case O.g:
							return t.payload;
						case O.f:
							return !1;
						default:
							return e
					}
				},
				n_ = Object(r.c)({
					api: Zj,
					openedFromModalPage: $j,
					postOrCommentId: e_,
					userIsMod: t_
				}),
				r_ = n("./src/reddit/actions/pages/report/constants.ts");
			var s_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r_.a:
						return t.payload;
					default:
						return e
				}
			};
			var o_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r_.b:
						return t.payload;
					case r_.c:
					case r_.d:
						return !1;
					default:
						return e
				}
			};
			var i_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r_.d:
						return !0;
					case r_.c:
					case r_.b:
						return !1;
					default:
						return e
				}
			};
			var c_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r_.c:
							return !0;
						case r_.b:
						case r_.d:
							return !1;
						default:
							return e
					}
				},
				a_ = Object(r.c)({
					error: o_,
					pending: i_,
					success: c_
				}),
				d_ = n("./src/reddit/actions/reportPageRules/constants.ts");
			const u_ = [];
			var l_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : u_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d_.a:
							return t.payload;
						default:
							return e
					}
				},
				b_ = Object(r.c)({
					reportPageApi: a_,
					reportPageRules: l_,
					initialReason: s_
				}),
				p_ = n("./src/reddit/actions/reportRules.ts");
			const m_ = {
				liveStreamingRules: [],
				sitewideRules: []
			};
			var f_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p_.b:
						return Object.assign({}, e, {
							sitewideRules: t.payload
						});
					case p_.a:
						return Object.assign({}, e, {
							liveStreamingRules: t.payload
						});
					default:
						return e
				}
			};
			Object(Ga.a)("REQUEST_HOST_SET");
			var g_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "REQUEST_HOST_SET":
						return t.payload;
					default:
						return e
				}
			};
			const O_ = "RUN_TIME_ENV_VARS__IS_STAGING",
				h_ = (Object(Ga.a)(O_), {
					staging: !1,
					startTimeInMillis: (new Date).getTime()
				});
			var y_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O_:
						return Object.assign({}, e, {
							staging: !0
						});
					default:
						return e
				}
			};
			const j_ = Object.create(null);
			var __ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (null !== Object.getPrototypeOf(e) && (e = Object.assign(Object.create(null), e)), t.type) {
					case Ke.d: {
						const {
							relatedQueries: n,
							query: r
						} = t.payload;
						if (n) {
							const t = r ? r.toLowerCase() : "";
							return Object.assign(Object.create(null), e, {
								[t]: n
							})
						}
						return e
					}
					default:
						return e
				}
			};
			var E_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case Ke.f: {
						const {
							searchQuery: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			const v_ = Object.create(null);
			var I_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (null !== Object.getPrototypeOf(e) && (e = Object.assign(Object.create(null), e)), t.type) {
						case Ke.e: {
							const {
								order: n,
								searchQuery: r
							} = t.payload;
							return Object.assign(Object.create(null), e, Object.assign({}, e, {
								[r.toLowerCase()]: n
							}))
						}
						default:
							return e
					}
				},
				S_ = n("./src/reddit/models/Search/index.ts");
			const T_ = {};
			var x_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ke.e: {
							const {
								typeaheadSuggestions: n
							} = t.payload, r = {};
							return Object.keys(n).forEach(e => {
								const t = n[e];
								return r[e] = Object(S_.d)(t)
							}), Object.assign({}, e, r)
						}
						default:
							return e
					}
				},
				C_ = Object(r.c)({
					idsByQuery: I_,
					models: x_
				});
			const w_ = {};
			var P_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c: {
							const {
								viewTreatment: n,
								key: r
							} = t.payload;
							return n ? Object.assign({}, e, {
								[r]: n
							}) : e
						}
						default:
							return e
					}
				},
				D_ = Object(r.c)({
					relatedQueries: __,
					searchQuery: E_,
					typeahead: C_,
					viewTreatment: P_
				}),
				R_ = n("./src/reddit/models/SearchDiscoveryUnit/index.ts");
			const A_ = {};
			var k_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : A_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c: {
						const {
							categoryName: n,
							key: r,
							listingOrder: s,
							postOrder: o,
							posts: i,
							searchQuery: c,
							subreddits: a,
							viewTreatment: d
						} = t.payload, u = {
							subredditIcons: [],
							displayText: null,
							subredditOccurrences: 0,
							searchQuery: c
						};
						if (d === R_.c.Trending || n) {
							const e = [];
							if (s && s.map(t => {
									!e.includes(t.id) && a[t.id] && (e.push(t.id), u.subredditIcons.push({
										url: a[t.id].icon.url,
										subredditName: a[t.id].name
									}), u.displayText || (u.displayText = a[t.id].displayText))
								}), o)
								for (let t = 0; t < o.length; t++) {
									const n = i[o[t]],
										r = n && n.belongsTo ? n.belongsTo.id : void 0;
									r && !e.includes(r) && a[r] && (e.push(r), u.subredditIcons.push({
										url: a[r].icon.url,
										subredditName: a[r].name
									}))
								}
							a && (u.subredditOccurrences = Object.keys(a).length - 1)
						}
						return Object.assign({}, e, {
							[r]: u
						})
					}
					default:
						return e
				}
			};
			const N_ = {};
			var L_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c: {
						const {
							key: n,
							searchDiscoveryUnits: r
						} = t.payload;
						return r && Object.keys(r).length ? Object.assign({}, e, {
							[n]: r
						}) : e
					}
					default:
						return e
				}
			};
			const M_ = {};
			var U_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c: {
							const {
								key: n,
								searchDiscoveryUnitOrder: r
							} = t.payload;
							return r ? Object.assign({}, e, {
								[n]: r
							}) : M_
						}
						default:
							return e
					}
				},
				F_ = Object(r.c)({
					headerContent: k_,
					models: L_,
					order: U_
				});
			Object(Ga.a)("SEO__CRAWLER_RECEIVED");
			var B_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "SEO__CRAWLER_RECEIVED":
							return t.payload;
						default:
							return e
					}
				},
				G_ = n("./src/reddit/actions/seo/linksModule.ts");
			const V_ = {};
			var q_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case G_.a:
							return Array.isArray(t.payload) && 0 !== t.payload.length ? Object.assign({}, e, {
								frontpage: t.payload
							}) : e;
						default:
							return e
					}
				},
				H_ = Object(r.c)({
					crawler: B_,
					linksModule: q_
				}),
				K_ = n("./src/reddit/actions/shortcuts.ts");
			var W_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case K_.a:
						return t.payload;
					case m.a:
						return null;
					default:
						return e
				}
			};
			var Y_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case K_.b:
							return t.payload || null;
						default:
							return e
					}
				},
				z_ = n("./src/reddit/constants/history.ts"),
				J_ = n("./src/reddit/constants/shortcuts.ts"),
				Q_ = n("./src/reddit/helpers/history/index.ts");
			const X_ = J_.d.Global,
				Z_ = e => {
					switch (e.name) {
						case "comments":
						case "duplicates":
						case "metaMembershipPaywallPage":
							return Object(Q_.b)(z_.a.IsOverlay) ? J_.d.Lightbox : J_.d.CommentPage;
						case "rpan":
						case "subredditCreation":
							return Object(Q_.b)(z_.a.IsOverlay) ? J_.d.Lightbox : X_;
						case "index":
						case "listing":
						case "multireddit":
						case "searchResults":
						case "subreddit":
							return J_.d.Listing;
						case "modQueuePages":
							return J_.d.Modqueue;
						default:
							return X_
					}
				};
			var $_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : X_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case m.a:
							const n = t.payload;
							if (n.routeMatch) {
								const e = n.routeMatch.route.meta;
								return Z_(e)
							}
							return X_;
						default:
							return e
					}
				},
				eE = Object(r.c)({
					activeCommentId: W_,
					activePostId: Y_,
					namespace: $_
				});
			var tE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					if (e) return e;
					switch (t.type) {
						case Zt.d:
						case Zt.e:
							return !0;
						default:
							return e
					}
				},
				nE = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				rE = Object(r.c)({
					firstFetch: tE,
					models: nE.b
				}),
				sE = n("./src/reddit/actions/streaming/constants.ts");
			const oE = {};
			var iE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case sE.a: {
							const {
								subredditId: n,
								modSettings: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				cE = Object(r.c)({
					modSettings: iE
				}),
				aE = n("./src/reddit/models/StructuredStyles/index.ts");
			const dE = {};
			var uE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case h.h:
						case h.b:
						case h.d:
							return t.payload.styles;
						case h.e:
							return dE;
						case h.c: {
							const n = t.payload;
							return Object.assign({}, e, n)
						}
						case h.k: {
							const e = t.payload;
							return Object(aE.h)(e.styles)
						}
						default:
							return e
					}
				},
				lE = n("./src/reddit/actions/exportImportStyles.ts");
			var bE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lE.c:
					case lE.b:
						return null;
					case lE.a:
						return t.payload;
					default:
						return e
				}
			};
			var pE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lE.c:
							return !0;
						case lE.b:
						case lE.a:
							return !1;
						default:
							return e
					}
				},
				mE = Object(r.c)({
					error: bE,
					pending: pE
				}),
				fE = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				gE = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const OE = {};
			var hE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b:
						case Fe.b:
						case re.b:
						case ce.c:
						case Ke.c:
						case Ge.b:
						case Co.a: {
							const {
								payload: n
							} = t;
							if (!n.structuredStyles || !n.structuredStyles.data) return e;
							const r = n.structuredStyles.data.flairTemplate;
							return Object.assign({}, e, r)
						}
						case fE.b: {
							const {
								flairId: n,
								template: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case fE.a: {
							const {
								flairId: n
							} = t.payload;
							return Object(Nu.a)(e, n)
						}
						case Kf.b: {
							const {
								templateId: n
							} = t.payload;
							return Object(Nu.a)(e, n)
						}
						case h.k:
							return OE;
						case gE.b: {
							const {
								templates: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				yE = Object(r.c)({
					models: hE
				});
			const jE = {};
			var _E = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case h.f: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.imageKey]: n.uploadId
						})
					}
					case h.k:
					case h.e:
						return jE;
					default:
						return e
				}
			};
			var EE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case h.n:
					case h.e:
						return !1;
					case h.a:
						return !0;
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			var vE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case h.d:
						return t.payload.subredditId;
					case h.e:
						return null;
					case m.a:
						return t.payload.location.search.indexOf("styling=true") > -1 ? e : null;
					case tl.f:
						return null;
					default:
						return e
				}
			};
			const IE = {};
			var SE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b:
						case Fe.b:
						case re.b:
						case Ge.b:
						case Co.a: {
							const {
								payload: n
							} = t;
							if (!n.structuredStyles || !n.structuredStyles.data) return e;
							const r = Object.keys(n.subredditAboutInfo || {});
							if (1 !== r.length) return e;
							const s = r[0],
								o = n.structuredStyles.data.style;
							return Object.assign({}, e, {
								[s]: o
							})
						}
						case Ke.c:
						case ce.c: {
							const {
								payload: n
							} = t;
							if (!n.structuredStyles || !n.structuredStyles.data) return e;
							if (!n.subredditName) return e;
							let r;
							if (En()(n.subreddits, (e, t) => {
									if (e.name.toLowerCase() === n.subredditName.toLowerCase()) return r = t, !1
								}), !r) return e;
							const s = n.structuredStyles.data.style;
							return Object.assign({}, e, {
								[r]: s
							})
						}
						case h.m: {
							const n = t.payload,
								r = e[n.subredditId];
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, r, n.styles)
							})
						}
						case h.h: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.subredditId]: n.styles
							})
						}
						case h.k: {
							const n = t.payload,
								r = Object(aE.h)(n.styles);
							return Object.assign({}, e, {
								[n.subredditId]: r
							})
						}
						case jm.k: {
							const n = t.payload,
								{
									banner: r,
									profile: s
								} = n;
							if (!r || !s) return e;
							const o = e[s.id];
							return Object.assign({}, e, {
								[s.id]: Object.assign({}, o, {
									bannerBackgroundImage: r.url
								})
							})
						}
						case tl.k: {
							const n = t.payload;
							if ("profileBanner" === n.key) {
								return Rg(e, {
									[n.subredditId]: {
										bannerBackgroundImage: n.imageUrl
									}
								})
							}
							return e
						}
						case tl.j: {
							const n = t.payload;
							if ("profileBanner" === n.key) {
								return Rg(e, {
									[n.subredditId]: {
										bannerBackgroundImage: void 0
									}
								})
							}
							return e
						}
						default:
							return e
					}
				},
				TE = Object(r.c)({
					draft: uE,
					exportStyles: mE,
					flairTemplate: yE,
					imagePreviews: _E,
					isBladeEditorDirty: EE,
					isEditing: vE,
					models: SE
				});
			Object(Ga.a)("STYLESHEETS__EXTRACTED_FROM_MANIFEST");
			var xE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "STYLESHEETS__EXTRACTED_FROM_MANIFEST":
							return t.payload;
						default:
							return e
					}
				},
				CE = n("./src/reddit/actions/subredditAutocomplete.ts");
			const wE = {};
			var PE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case CE.c:
					case CE.b: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: null
						})
					}
					case CE.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const DE = {};
			var RE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case CE.c: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case CE.b:
						case CE.a: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				AE = Object(r.c)({
					error: PE,
					pending: RE
				});
			const kE = {};
			var NE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case CE.b: {
							const {
								key: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: t.payload
							})
						}
						default:
							return e
					}
				},
				LE = Object(r.c)({
					api: AE,
					models: NE
				});
			const ME = {};
			var UE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ME,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case kn.c: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case kn.a:
					case kn.d: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					default:
						return e
				}
			};
			const FE = {};
			var BE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case kn.d: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !0
						})
					}
					case kn.a:
					case kn.c: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: !1
						})
					}
					default:
						return e
				}
			};
			const GE = {};
			var VE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case kn.d: {
							const {
								subredditId: n
							} = t.payload;
							return e[n] ? e : Object.assign({}, e, {
								[n]: !1
							})
						}
						case kn.a: {
							const {
								subredditId: n,
								isSubredditWhitelisted: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case kn.c: {
							const {
								subredditId: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				qE = Object(r.c)({
					error: UE,
					pending: BE,
					whitelist: VE
				}),
				HE = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const KE = {};
			var WE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : KE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case kn.a:
						return Object.assign({}, e, t.payload.collection);
					case kn.e: {
						const {
							channel: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.channelId]: Object.assign({}, n)
						})
					}
					case kn.f: {
						const {
							channel: n,
							editedSubredditChannelData: r
						} = t.payload;
						return n.name = r.room, n.description = r.description, n.minimumAcctAge = n.minimumAcctAge, n.newMemberAge = n.newMemberAge, Object.assign({}, e, {
							[n.channelId]: Object.assign({}, n)
						})
					}
					case kn.g: {
						const n = t.payload;
						e[n];
						return HE(e, ["symbol" == typeof n ? n : n + ""])
					}
					default:
						return e
				}
			};
			var YE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case kn.h:
							return t.payload.channelId;
						case kn.g:
							return e === t.payload ? null : e;
						default:
							return e
					}
				},
				zE = Object(r.c)({
					api: qE,
					models: WE,
					selected: YE
				}),
				JE = n("./src/reddit/actions/subredditDifficulty/constants.ts");
			const QE = {};
			var XE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case JE.b: {
							const {
								subredditId: n,
								subreddits: r
							} = t.payload;
							return r.length ? Object.assign({}, e, {
								[n]: Object.assign({
									id: n
								}, r[0])
							}) : e
						}
						default:
							return e
					}
				},
				ZE = n("./src/reddit/actions/monthsToMinutes/homeFeed.ts"),
				$E = n("./src/reddit/actions/subredditMention/constants.ts");
			const ev = {};
			var tv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ev,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $E.d:
					case Fe.b:
					case re.b:
					case ce.c:
					case ae.a:
					case ae.b:
					case Ge.b:
					case Co.a:
					case se.b:
					case se.e:
					case Ve.b:
					case Ve.a:
					case Ve.e:
					case Ve.d:
					case oe.e:
					case de.b:
					case de.e:
					case Ke.c:
					case Bu.e: {
						const n = t.payload.subredditAboutInfo;
						if (!n) return e;
						const r = Object.keys(n);
						return 0 === r.length ? e : r.reduce((e, t) => (n[t] && (e[t] ? e[t] = Object.assign({}, e[t], n[t]) : e[t] = n[t]), e), Object.assign({}, e))
					}
					case hc.a: {
						const {
							subredditId: n,
							emojisEnabled: r
						} = t.payload, s = e[n], o = Object.assign({}, s, {
							emojisEnabled: r
						});
						return Object.assign({}, e, {
							[n]: o
						})
					}
					case vm.h: {
						const {
							identifiers: n,
							userIsSubscriber: r
						} = t.payload, s = n.filter(e => e.type === gy.a.SUBREDDIT);
						return s.length ? s.reduce((e, t) => Object(F.setIn)(e, [t.id, "userIsSubscriber"], r), e) : e
					}
					case Pa.e:
					case tn.f:
					case ZE.b:
					case qu.e:
					case qu.m: {
						const {
							subredditsAboutInfo: n
						} = t.payload;
						if (!n) return e;
						const r = Object.keys(n);
						return 0 === r.length ? e : r.reduce((e, t) => (n[t] && (e[t] = e[t] ? Object.assign({}, e[t], n[t]) : n[t]), e), Object.assign({}, e))
					}
					case hc.b: {
						const n = t.payload,
							{
								emojiCustomSize: r,
								subredditId: s
							} = n,
							o = e[s];
						if (!o) return e;
						const i = Object.assign({}, o);
						if (r) {
							const {
								width: e,
								height: t
							} = r;
							i.emojisCustomSize = [e, t]
						} else delete i.emojisCustomSize;
						return Object.assign({}, e, {
							[s]: i
						})
					}
					case ue.c: {
						const {
							data: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					case Oe.q: {
						const {
							subredditId: n,
							subredditCoins: r
						} = t.payload;
						if (!n || !r) return e;
						const s = e[n];
						if (!s) return e;
						const o = Object.assign({}, s, {
							coins: r
						});
						return Object.assign({}, e, {
							[n]: o
						})
					}
					default:
						return e
				}
			};
			const nv = {};
			var rv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.b:
					case ue.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case ue.a: {
						const {
							subredditName: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: r
						})
					}
					default:
						return e
				}
			};
			var sv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.b:
							return !0;
						case ue.c:
						case ue.a:
							return !1;
						default:
							return e
					}
				},
				ov = Object(r.c)({
					error: rv,
					pending: sv
				}),
				iv = n("./src/reddit/actions/subredditCreation.ts");
			const cv = {
				apiError: null
			};
			var av = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case iv.b: {
						const {
							error: n
						} = t.payload;
						return Object.assign({}, e, {
							apiError: n
						})
					}
					case iv.a:
					case iv.c:
					case iv.d:
						return cv;
					default:
						return e
				}
			};
			var dv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case iv.d: {
						const {
							subredditName: e
						} = t.payload;
						return e || null
					}
					case iv.c:
					case iv.b:
						return null;
					default:
						return e
				}
			};
			var uv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case iv.c:
							return !0;
						case iv.d:
						case iv.b:
							return !1;
						default:
							return e
					}
				},
				lv = Object(r.c)({
					error: av,
					lastCreatedSubredditId: dv,
					pending: uv
				});
			var bv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qu.p:
							return !0;
						case qu.q:
						case qu.o:
							return !1;
						default:
							return e
					}
				},
				pv = Object(r.c)({
					pending: bv
				});
			const mv = {};
			var fv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.l:
					case ue.m: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case ue.k: {
						const {
							subredditName: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: r
						})
					}
					default:
						return e
				}
			};
			const gv = {};
			var Ov = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.l: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !0
							})
						}
						case ue.m:
						case ue.k: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				hv = Object(r.c)({
					error: fv,
					pending: Ov
				});
			const yv = {};
			var jv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qu.d:
						case qu.e:
							return Object.assign({}, e, {
								[t.payload.key]: !1
							});
						case qu.f:
							return Object.assign({}, e, {
								[t.payload.key]: !0
							});
						default:
							return e
					}
				},
				_v = Object(r.c)({
					pending: jv
				});
			var Ev = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qu.i: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case qu.k:
					case qu.j:
						return null;
					default:
						return e
				}
			};
			var vv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qu.k:
							return !0;
						case qu.j:
						case qu.i:
							return !1;
						default:
							return e
					}
				},
				Iv = Object(r.c)({
					error: Ev,
					pending: vv
				}),
				Sv = n("./src/reddit/actions/subredditRules/constants.ts");
			var Tv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Sv.c:
							return !0;
						case Sv.a:
						case Sv.b:
							return !1;
						default:
							return e
					}
				},
				xv = n("./src/reddit/actions/subredditSettings.ts");
			var Cv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xv.c:
							return !0;
						case xv.d:
						case xv.b:
							return !1;
						default:
							return e
					}
				},
				wv = Object(r.c)({
					pending: Cv
				});
			const Pv = {};
			var Dv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qu.l:
						case qu.m:
							return Object.assign({}, e, {
								[t.payload.key]: !1
							});
						case qu.n:
							return Object.assign({}, e, {
								[t.payload.key]: !0
							});
						default:
							return e
					}
				},
				Rv = Object(r.c)({
					pending: Dv
				}),
				Av = n("./src/reddit/actions/pages/subredditWiki/constants.ts");
			const kv = {};
			var Nv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Av.c:
					case Av.b: {
						const n = t.payload,
							{
								subredditName: r
							} = n.options;
						return Object.assign({}, e, {
							[r.toLowerCase()]: null
						})
					}
					case Av.a: {
						const n = t.payload,
							{
								options: r,
								error: s
							} = n,
							{
								subredditName: o
							} = r;
						return Object.assign({}, e, {
							[o.toLowerCase()]: s
						})
					}
					default:
						return e
				}
			};
			const Lv = {};
			var Mv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Av.c: {
							const n = t.payload,
								{
									subredditName: r
								} = n.options;
							return Object.assign({}, e, {
								[r.toLowerCase()]: !0
							})
						}
						case Av.b:
						case Av.a: {
							const n = t.payload,
								{
									subredditName: r
								} = n.options;
							return Object.assign({}, e, {
								[r.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Uv = Object(r.c)({
					error: Nv,
					pending: Mv
				});
			const Fv = {};
			var Bv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cg.c:
					case Cg.b: {
						const {
							subredditName: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case Cg.a: {
						const {
							subredditName: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: r
						})
					}
					default:
						return e
				}
			};
			const Gv = {};
			var Vv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cg.c: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !0
							})
						}
						case Cg.b:
						case Cg.a: {
							const {
								subredditName: n
							} = t.payload;
							return Object.assign({}, e, {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				qv = Object(r.c)({
					error: Bv,
					pending: Vv
				}),
				Hv = Object(r.c)({
					about: ov,
					create: lv,
					inlineEditing: pv,
					models: hv,
					onboarding: _v,
					rankings: Iv,
					rules: Tv,
					settings: wv,
					similar: Rv,
					topContent: qv,
					wiki: Uv
				}),
				Kv = n("./node_modules/lodash/isNil.js"),
				Wv = n.n(Kv);
			const Yv = {};
			var zv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.d: {
							const {
								subredditId: n,
								forceState: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: Wv()(r) ? !e[n] : r
							})
						}
						default:
							return e
					}
				},
				Jv = Object(r.c)({
					meta: zv
				});
			const Qv = {};
			var Xv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tn.f: {
						const {
							categoryId: n,
							subredditIds: r
						} = t.payload;
						return gn()(r) ? e : Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const Zv = {};
			var $v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.c: {
							const {
								communityInfo: n,
								id: r,
								type: s
							} = t.payload;
							return n && "subreddit" === s ? Object.assign({}, e, {
								[r]: n
							}) : e
						}
						default:
							return e
					}
				},
				eI = n("./src/reddit/actions/subredditCrosspostable.ts");
			var tI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case eI.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case eI.c:
					case eI.b:
						return null;
					default:
						return e
				}
			};
			var nI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case eI.c:
							return !0;
						case eI.b:
						case eI.a:
							return !1;
						default:
							return e
					}
				},
				rI = Object(r.c)({
					errors: tI,
					pending: nI
				});
			const sI = {};
			var oI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case eI.b: {
							const {
								subredditIds: n
							} = t.payload;
							return _r()(e, n) ? e : n
						}
						default:
							return e
					}
				},
				iI = Object(r.c)({
					api: rI,
					ids: oI
				});
			const cI = {};
			var aI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ng.a: {
							const n = t.payload,
								{
									subredditId: r,
									distinguishKey: s,
									postIds: o
								} = n;
							if (!(r in e)) return Object.assign({}, e, {
								[r]: {
									[s]: o
								}
							});
							const i = e[r];
							return Rg(i, {
								[s]: o
							}) === i ? e : Object.assign({}, e, {
								[r]: Object.assign({}, i, {
									[s]: o
								})
							})
						}
						default:
							return e
					}
				},
				dI = Object(r.c)({
					models: aI
				});
			const uI = {};
			var lI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							assets: n,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					case b.g:
					case b.j: {
						const {
							subredditId: n,
							mainHeader: r
						} = t.payload, s = e[n] || {};
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								mainHeader: r
							})
						})
					}
					default:
						return e
				}
			};
			const bI = {};
			var pI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							communityJar: n,
							subredditId: r
						} = t.payload;
						return Object.assign({}, e, {
							[r]: n
						})
					}
					default:
						return e
				}
			};
			const mI = {};
			var fI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							subredditId: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: t.payload
						})
					}
					case d.j: {
						const {
							communityRaw: n,
							subredditId: r
						} = t.payload;
						return n ? Object.assign({}, e, {
							[r]: n
						}) : e
					}
					default:
						return e
				}
			};
			const gI = {};
			var OI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							subredditId: n,
							distribution: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const hI = {};
			var yI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							subredditId: n,
							meta: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const jI = {};
			var _I = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.q: {
							const {
								subredditId: n,
								releaseNotes: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				EI = Object(r.c)({
					assets: lI,
					communityJar: pI,
					communityRaw: fI,
					distributions: OI,
					meta: yI,
					releaseNotes: _I
				}),
				vI = n("./node_modules/lodash/isEqualWith.js"),
				II = n.n(vI),
				SI = n("./src/lib/forceHttps/index.ts"),
				TI = n("./src/reddit/models/Subreddit/index.ts"),
				xI = (e, t) => ({
					displayText: "r/".concat(e),
					name: e,
					id: t,
					icon: {
						height: null,
						url: "",
						width: null
					},
					subscribers: 0,
					title: e,
					type: TI.c.Public,
					url: "/r/".concat(e, "/"),
					isNSFW: !1
				});
			const CI = {},
				wI = (e, t) => {
					const n = Object.keys(t);
					return n.length ? n.reduce((n, r) => {
						const s = e[r],
							o = t[r],
							i = s ? Object.assign({}, s, o) : Object.assign({}, o);
						return o.icon.url ? i.icon.url = Object(SI.a)(o.icon.url) : s && s.icon.url ? i.icon = s.icon : i.icon.url = "", s && s.allowChatPostCreation && (i.allowChatPostCreation = !0), Object(F.set)(n, r, i)
					}, e) : e
				},
				PI = (e, t) => {
					return !II()(e, t, (e, t, n) => {
						if ("subscribers" === n) return !0
					})
				},
				DI = (e, t) => {
					if (!t) return e;
					const n = Object.keys(t);
					if (!n.length) return e;
					const r = {};
					for (let s = 0; s < n.length; s++) {
						const o = n[s],
							i = e[o],
							c = t[o];
						i && !PI(i, c) || (r[o] = c)
					}
					return Object.keys(r).length ? Object.assign({}, e, r) : e
				};
			var RI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vm.c:
						return wI(e, t.payload.subreddits || {});
					case $E.d:
					case tn.f:
					case Me.b:
					case Pa.e:
					case Be.e:
					case Be.h:
					case ne.k:
					case Ue.r:
					case Ue.u:
					case jm.h:
					case Fu.b:
					case Fe.b:
					case ZE.b:
					case re.b:
					case re.g:
					case re.l:
					case se.b:
					case se.e:
					case ie.c:
					case ie.i:
					case ie.e:
					case ie.g:
					case Ve.b:
					case Ve.e:
					case oe.b:
					case oe.e:
					case jm.e:
					case ce.c:
					case ae.b:
					case Ge.b:
					case Fs.e:
					case Co.a:
					case jm.l:
					case de.b:
					case de.e:
					case qe.b:
					case He.b:
					case Ke.c:
					case ue.c:
					case ue.f:
					case ue.i:
					case qu.a:
					case qu.e:
					case qu.m:
					case Bu.e:
					case Bu.b:
						return DI(e, t.payload.subreddits || {});
					case ne.f:
					case ne.i:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							subreddits: r
						} = n;
						return DI(e, r)
					}
					case Ke.e: {
						const {
							typeaheadSuggestions: n
						} = t.payload;
						return DI(e, n.subreddits || {})
					}
					case xg.e: {
						const n = t.payload.subreddits,
							r = {};
						return Object.keys(n).map(e => {
							const t = n[e];
							r[e] = xI(t, e)
						}), Object.assign({}, r, e)
					}
					case Ue.B: {
						const {
							subreddits: n
						} = t.payload;
						return Object.assign({}, n, e)
					}
					case d.h: {
						const n = t.payload;
						return DI(e, n)
					}
					case h.m: {
						const n = t.payload,
							{
								subredditId: r,
								styles: s
							} = n;
						return "communityIcon" in s && e[r] && "string" == typeof s.communityIcon ? Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								communityIcon: s.communityIcon
							})
						}) : e
					}
					case xv.d: {
						const {
							settings: n
						} = t.payload, {
							subredditId: r,
							title: s
						} = n;
						return e[r] && void 0 !== s ? Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								title: s
							})
						}) : e
					}
					default:
						return e
				}
			};
			var AI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.e: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case ue.g:
					case ue.f:
						return null;
					default:
						return e
				}
			};
			var kI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ue.g:
					case ue.f:
						return !0;
					case ue.e:
						return !1;
					default:
						return e
				}
			};
			var NI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.g:
							return !0;
						case ue.f:
						case ue.e:
							return !1;
						default:
							return e
					}
				},
				LI = Object(r.c)({
					errors: AI,
					fetched: kI,
					pending: NI
				});
			var MI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ue.f: {
							const {
								subreddits: e
							} = t.payload, n = Object.keys(e);
							return n.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), n
						}
						default:
							return e
					}
				},
				UI = Object(r.c)({
					api: LI,
					order: MI
				});
			const FI = {};
			var BI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qu.e: {
						const {
							key: n,
							subredditIds: r
						} = t.payload;
						return 0 === r.length ? e : Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const GI = {};
			var VI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.g: {
						const {
							subredditId: n,
							products: r
						} = t.payload, s = Object.keys(r).reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const qI = {};
			var HI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qu.b: {
						const {
							categoryRankingsKey: n
						} = t.payload, r = e[n], s = r && r.length ? [...r, ...t.payload.rankings] : t.payload.rankings;
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const KI = {};
			var WI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : KI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qu.c: {
						const {
							categoryRankingsKey: n,
							pageInfo: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const YI = {};
			var zI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Sv.b: {
						const {
							rules: n,
							subredditId: r
						} = t.payload, s = {
							[r]: {
								rules: n.rules
							}
						};
						return Object.assign({}, e, s)
					}
					case Sv.e: {
						const {
							rules: n,
							subredditId: r
						} = t.payload, s = {
							[r]: {
								rules: [...e[r].rules, ...n.rules]
							}
						};
						return Object.assign({}, e, s)
					}
					case Sv.f: {
						const {
							rules: n,
							subredditId: r,
							oldName: s
						} = t.payload;
						n.rules.shortName !== s && (e[r].rules = e[r].rules.filter(e => e.shortName !== s));
						const o = {
							[r]: {
								rules: [...n.rules, ...e[r].rules]
							}
						};
						return o[r].rules.sort((e, t) => e.priority - t.priority), Object.assign({}, e, o)
					}
					case Sv.g:
					case Sv.d: {
						const {
							rules: n,
							subredditId: r
						} = t.payload, s = {
							[r]: {
								rules: n.rules
							}
						};
						return Object.assign({}, e, s)
					}
					default:
						return e
				}
			};
			const JI = {};
			var QI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xv.a: {
						const e = t.payload;
						return {
							[e.subredditId]: e
						}
					}
					case xv.d: {
						const n = t.payload.settings,
							r = e[n.subredditId] || {};
						return Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, r, n)
						})
					}
					case tl.m: {
						const n = t.payload,
							r = e[n.subredditId] || {},
							s = Object.assign({}, r, n.settings);
						return Object.assign({}, e, {
							[n.subredditId]: s
						})
					}
					default:
						return e
				}
			};
			const XI = {};
			var ZI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : XI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qu.m: {
							const {
								key: n,
								subredditIds: r
							} = t.payload;
							return 0 === r.length ? e : Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				$I = n("./src/reddit/actions/wiki/wikiDiff/constants.ts");
			const eS = {};
			var tS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $I.b: {
						const {
							key: n,
							htmlDiff: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: {
								htmlDiff: r
							}
						})
					}
					case $I.c: {
						const {
							key: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								pending: !0
							})
						})
					}
					case $I.a: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								pending: !1,
								error: r
							})
						})
					}
					default:
						return e
				}
			};
			const nS = {};
			var rS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Av.b:
							const n = t.payload,
								{
									subredditWiki: r,
									options: s
								} = n,
								o = r && r.directory;
							if (!o) return e;
							const {
								subredditName: i
							} = s;
							return Object.assign({}, e, {
								[i.toLowerCase()]: o
							});
						default:
							return e
					}
				},
				sS = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const oS = {};
			var iS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Av.b: {
							const {
								subredditWiki: n,
								pageKey: r
							} = t.payload, {
								page: s
							} = n;
							return r && s ? Object.assign({}, e, {
								[r]: s
							}) : e
						}
						case sS.a: {
							const {
								pageKey: n,
								page: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				cS = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const aS = {};
			var dS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case cS.c: {
						const {
							settings: n,
							pageKey: r
						} = t.payload;
						return n ? Object.assign({}, e, {
							[r]: n
						}) : e
					}
					case cS.d: {
						const {
							isVisible: n,
							editPermissions: r,
							pageKey: s
						} = t.payload, o = e[s];
						return o ? Object.assign({}, e, {
							[s]: Object.assign({}, o, {
								isVisible: n,
								editPermissions: r
							})
						}) : e
					}
					case cS.b: {
						const {
							editorsInfo: n,
							afterToken: r,
							pageKey: s
						} = t.payload, o = e[s];
						if (!o) return e;
						const i = [...o.editorsInfo, ...n];
						return Object.assign({}, e, {
							[s]: Object.assign({}, o, {
								editorsInfo: i,
								afterToken: r
							})
						})
					}
					case cS.a: {
						const {
							username: n,
							pageKey: r
						} = t.payload, s = e[r];
						if (!s) return e;
						const o = s.editorsInfo.filter(e => e.username !== n);
						return Object.assign({}, e, {
							[r]: Object.assign({}, s, {
								editorsInfo: o
							})
						})
					}
					default:
						return e
				}
			};
			const uS = {};
			var lS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sS.b: {
						const {
							key: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case sS.d:
					case sS.c: {
						const {
							key: n
						} = t.payload;
						return Object(Nu.a)(e, n)
					}
					default:
						return e
				}
			};
			const bS = {};
			var pS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case sS.d:
						case sS.b:
						case sS.c: {
							const {
								key: n
							} = t.payload, r = t.type === sS.d;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				mS = Object(r.c)({
					error: lS,
					pending: pS
				}),
				fS = n("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const gS = {};
			var OS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sS.c: {
						const {
							key: n,
							options: r,
							pageInfo: s,
							revisionsIds: o
						} = t.payload, i = e[n], c = r.after && i ? [...i.ids, ...o] : o;
						return Object.assign({}, e, {
							[n]: {
								ids: c,
								pageInfo: s
							}
						})
					}
					case sS.a: {
						const {
							page: {
								revision: n
							},
							pageRevisionsListingKey: r,
							recentRevisionsListingKey: s
						} = t.payload, o = e[r];
						return o && n ? Object.assign({}, Object(Nu.a)(e, s), {
							[r]: Object.assign({}, o, {
								ids: [n.id, ...o.ids]
							})
						}) : e
					}
					case fS.a: {
						const {
							pageRevisionsListingKey: n,
							recentRevisionsListingKey: r
						} = t.payload, s = Object.assign({}, e);
						return delete s[n], delete s[r], s
					}
					default:
						return e
				}
			};
			const hS = {};
			var yS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Av.b: {
							const {
								subredditWiki: {
									page: n
								}
							} = t.payload, r = n && n.revision;
							return r && !e[r.id] ? Object.assign({}, e, {
								[r.id]: r
							}) : e
						}
						case sS.c: {
							const {
								revisions: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						case sS.a: {
							const {
								page: n
							} = t.payload, r = n.revision;
							return r ? Object.assign({}, e, {
								[r.id]: r
							}) : e
						}
						case sS.e: {
							const {
								revisionId: n,
								isHidden: r
							} = t.payload, s = e[n];
							return s ? Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									isHidden: r
								})
							}) : e
						}
						default:
							return e
					}
				},
				jS = Object(r.c)({
					api: mS,
					listings: OS,
					models: yS
				}),
				_S = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const ES = {};
			var vS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ES,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _S.c:
					case _S.a: {
						const {
							subredditName: n,
							afterToken: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const IS = {};
			var SS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _S.b: {
						const {
							subredditName: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case _S.d:
					case _S.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(Nu.a)(e, n)
					}
					default:
						return e
				}
			};
			const TS = {};
			var xS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : TS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _S.d:
						case _S.c:
						case _S.b: {
							const {
								subredditName: n
							} = t.payload, r = t.type === _S.d;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				CS = Object(r.c)({
					error: SS,
					pending: xS
				});
			const wS = {};
			var PS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _S.c:
					case _S.a: {
						const {
							subredditName: n,
							bannedContributors: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], r)
						})
					}
					case _S.e: {
						const {
							subredditName: n,
							bannedContributor: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], r)
						})
					}
					case _S.f: {
						const {
							subredditName: n,
							userId: r
						} = t.payload, s = Object(Nu.a)(e[n], r);
						return Object.assign({}, e, {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const DS = {};
			var RS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _S.c:
						case _S.a: {
							const {
								subredditName: n,
								userOrder: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: iO()([...e[n] || [], ...r])
							})
						}
						case _S.e: {
							const {
								subredditName: n,
								userOrder: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: iO()([...r, ...e[n] || []])
							})
						}
						case _S.f: {
							const {
								subredditName: n,
								userId: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: (e[n] || []).filter(e => e !== r)
							})
						}
						default:
							return e
					}
				},
				AS = Object(r.c)({
					afterToken: vS,
					api: CS,
					models: PS,
					userOrder: RS
				});
			const kS = {};
			var NS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _S.g: {
							const {
								subredditName: n,
								bannedContributor: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				LS = Object(r.c)({
					listing: AS,
					search: NS
				}),
				MS = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const US = {};
			var FS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : US,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MS.c:
					case MS.a: {
						const {
							subredditName: n,
							afterToken: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					default:
						return e
				}
			};
			const BS = {};
			var GS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MS.b: {
						const {
							subredditName: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: r
						})
					}
					case MS.d:
					case MS.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(Nu.a)(e, n)
					}
					default:
						return e
				}
			};
			const VS = {};
			var qS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : VS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case MS.d:
						case MS.c:
						case MS.b: {
							const {
								subredditName: n
							} = t.payload, r = t.type === MS.d;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				HS = Object(r.c)({
					error: GS,
					pending: qS
				});
			const KS = {};
			var WS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : KS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MS.c:
					case MS.a: {
						const {
							subredditName: n,
							contributors: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], r)
						})
					}
					case MS.e: {
						const {
							subredditName: n,
							contributor: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], r)
						})
					}
					case MS.f: {
						const {
							subredditName: n,
							userId: r
						} = t.payload, s = Object(Nu.a)(e[n], r);
						return Object.assign({}, e, {
							newState: s
						})
					}
					default:
						return e
				}
			};
			const YS = {};
			var zS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case MS.c:
						case MS.a: {
							const {
								subredditName: n,
								userOrder: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: iO()([...e[n] || [], ...r])
							})
						}
						case MS.e: {
							const {
								subredditName: n,
								userOrder: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: [...r, ...e[n] || []]
							})
						}
						case MS.f: {
							const {
								subredditName: n,
								userId: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: (e[n] || []).filter(e => e !== r)
							})
						}
						default:
							return e
					}
				},
				JS = Object(r.c)({
					afterToken: FS,
					api: HS,
					models: WS,
					userOrder: zS
				});
			const QS = {};
			var XS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case MS.g: {
							const {
								subredditName: n,
								contributor: r
							} = t.payload;
							return Object.assign({}, e, {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				ZS = Object(r.c)({
					listing: JS,
					search: XS
				}),
				$S = Object(r.c)({
					diff: tS,
					directory: rS,
					pages: iS,
					pageSettings: dS,
					revisions: jS,
					wikiBannedContributors: LS,
					wikiContributors: ZS
				});
			const eT = {};
			var tT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Pa.e: {
						const {
							subredditTopContent: n
						} = t.payload;
						return Object.assign({}, e, n.subredditTopContent)
					}
					case Cg.b: {
						const {
							subredditTopContent: n
						} = t.payload;
						return Object.assign({}, e, n)
					}
					default:
						return e
				}
			};
			const nT = [];
			var rT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.g:
					case ae.b: {
						const {
							trendingSubredditIds: n
						} = t.payload;
						return n && n.length ? n : e
					}
					default:
						return e
				}
			};
			const sT = {};
			var oT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $E.d:
							const {
								unavailableSubreddits: n
							} = t.payload;
							return Object.assign({}, e, n);
						default:
							return e
					}
				},
				iT = Object(r.c)({
					about: tv,
					api: Hv,
					appliedFilters: Jv,
					byCategory: Xv,
					communityInfo: $v,
					crosspostable: iI,
					duplicates: dI,
					gov: EI,
					models: RI,
					moderated: UI,
					onboarding: BI,
					products: VI,
					rankings: HI,
					rankingsPageInfo: WI,
					rules: zI,
					settings: QI,
					similar: ZI,
					subredditWiki: $S,
					topContent: tT,
					trending: rT,
					unavailableModels: oT
				});
			const cT = {};
			var aT = Object(MO.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b: {
							const {
								postIds: n,
								posts: r
							} = t.payload, s = n.slice(0, 2).reduce((e, t) => {
								if (r[t].isStickied) {
									const n = r[t].belongsTo.id;
									e[n] ? e[n].push(t) : e[n] = [t]
								}
								return e
							}, {});
							return Re()(Object.assign({}, e), s)
						}
						case _.j: {
							const {
								newStickiedPostList: n,
								subredditId: r
							} = t.payload;
							return Object.assign({}, e, {
								[r]: n
							})
						}
						default:
							return e
					}
				}), cT),
				dT = Object(r.c)({
					data: aT
				});
			const uT = [];
			var lT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vm.d: {
						const {
							makeFavorite: n,
							multiredditsModelsState: r,
							multiredditPath: s
						} = t.payload;
						if (n) {
							const t = [...e],
								n = ym(t, s, (e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1);
							return t.splice(n, 0, s), t
						}
						return e.filter(e => e !== s)
					}
					case Ue.u: {
						const {
							multireddits: e
						} = t.payload;
						return us()(e).filter(e => e.isFavorited).sort((e, t) => e.displayText.toLowerCase() > t.displayText.toLowerCase() ? 1 : -1).map(e => e.url)
					}
					case vm.e: {
						const {
							follow: n,
							multiredditPath: r
						} = t.payload;
						return n ? e : e.filter(e => e !== r)
					}
					case Ue.j: {
						const n = t.payload;
						return e.filter(e => e !== n)
					}
					default:
						return e
				}
			};
			var bT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vm.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case vm.b:
					case vm.c:
						return null;
					default:
						return e
				}
			};
			var pT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vm.b:
					case vm.c:
					case xg.e:
						return !0;
					case vm.a:
						return !1;
					default:
						return e
				}
			};
			var mT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vm.b:
							return !0;
						case vm.c:
						case vm.a:
							return !1;
						default:
							return e
					}
				},
				fT = Object(r.c)({
					errors: bT,
					fetched: pT,
					pending: mT
				});
			const gT = [];
			var OT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vm.c: {
						const {
							profiles: e,
							favoriteProfileIds: n,
							favoriteSubredditIds: r
						} = t.payload;
						let s;
						return (s = n && n.length ? n : r ? r.filter(t => !!e[t]) : []).sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), s
					}
					case vm.f: {
						const {
							makeFavorite: n,
							identifier: r,
							profileModels: s
						} = t.payload, {
							id: o,
							type: i
						} = r;
						if (i !== gy.a.PROFILE) return e;
						const c = e ? e.slice() : [];
						if (n) {
							const e = ym(c, o, (e, t) => s[e].displayText.toLowerCase() > s[t].displayText.toLowerCase() ? 1 : -1);
							c.splice(e, 0, o)
						} else {
							const e = c.indexOf(o);
							c.splice(e, 1)
						}
						return c
					}
					case vm.h: {
						const {
							identifiers: n,
							userIsSubscriber: r
						} = t.payload, s = n.filter(t => t.type === gy.a.PROFILE && e.indexOf(t.id) > -1);
						return !s.length || r ? e : s.reduce((e, t) => {
							const n = e.indexOf(t.id);
							return e.splice(n, 1), e
						}, [...e])
					}
					default:
						return e
				}
			};
			const hT = [];
			var yT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vm.c: {
						const {
							subreddits: e,
							favoriteSubredditIds: n
						} = t.payload, r = n ? n.filter(t => !!e[t]) : [];
						return r.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), r
					}
					case vm.f: {
						const {
							makeFavorite: n,
							identifier: r,
							subredditModels: s
						} = t.payload, {
							id: o,
							type: i
						} = r;
						if (i !== gy.a.SUBREDDIT) return e;
						const c = e ? e.slice() : [];
						if (n) {
							const e = ym(c, o, (e, t) => s[e].displayText.toLowerCase() > s[t].displayText.toLowerCase() ? 1 : -1);
							c.splice(e, 0, o)
						} else {
							const e = c.indexOf(o);
							c.splice(e, 1)
						}
						return c
					}
					case vm.h: {
						const {
							identifiers: n,
							userIsSubscriber: r
						} = t.payload, s = n.filter(t => t.type === gy.a.SUBREDDIT && e.indexOf(t.id) > -1);
						return !s.length || r ? e : s.reduce((e, t) => {
							const n = e.indexOf(t.id);
							return e.splice(n, 1), e
						}, [...e])
					}
					default:
						return e
				}
			};
			const jT = [],
				_T = e => (t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1;
			var ET = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ue.u: {
							const {
								multireddits: n
							} = t.payload, r = us()(n).map(e => {
								let {
									url: t
								} = e;
								return t.toLowerCase()
							}).sort(_T(n));
							return _r()(e, r) ? e : r
						}
						case re.l: {
							const {
								account: n,
								multireddits: r,
								multiredditsByUser: s,
								multiredditsModelsState: o
							} = t.payload;
							if (!n) return e;
							const i = s[n.id];
							if (!i || !i.length) return e;
							const c = Object.assign({}, o, r),
								a = hm()(e, i).sort(_T(c));
							return _r()(e, a) ? e : a
						}
						case vm.e: {
							const {
								follow: n,
								multiredditPath: r,
								multiredditsModelsState: s
							} = t.payload;
							return n ? [...e, r].sort(_T(s)) : e.filter(e => e !== r)
						}
						case Ue.j: {
							const n = t.payload;
							return e.filter(e => e !== n)
						}
						case Ue.g:
						case Ue.m: {
							const {
								multireddit: n,
								multiredditsModelsState: r
							} = t.payload, s = Object.assign({}, r, {
								[n.url]: n
							});
							return [...e, n.url].sort(_T(s))
						}
						default:
							return e
					}
				},
				vT = n("./node_modules/lodash/difference.js"),
				IT = n.n(vT);
			const ST = [];
			var TT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ST,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jm.m: {
						const {
							profileOrder: n
						} = t.payload;
						return iO()([...e, ...n])
					}
					case vm.c: {
						const {
							profiles: e
						} = t.payload, n = Object.keys(e);
						return n.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), n
					}
					case vm.h: {
						const {
							identifiers: n,
							profileModels: r,
							userIsSubscriber: s
						} = t.payload, o = n.filter(e => e.type === gy.a.PROFILE);
						if (!o.length) return e;
						const i = o.map(e => e.id);
						return s ? iO()([...e, ...i]).sort((e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1) : IT()(e, i)
					}
					default:
						return e
				}
			};
			const xT = [];
			var CT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jm.m: {
							const {
								subredditOrder: n
							} = t.payload;
							return iO()([...e, ...n])
						}
						case vm.c: {
							const {
								subreddits: e
							} = t.payload, n = Object.keys(e);
							return n.sort((t, n) => e[t].displayText.toLowerCase() > e[n].displayText.toLowerCase() ? 1 : -1), n
						}
						case vm.h: {
							const {
								identifiers: n,
								subredditModels: r,
								userIsSubscriber: s
							} = t.payload, o = n.filter(e => e.type === gy.a.SUBREDDIT && !!e.id);
							if (!o.length) return e;
							const i = o.map(e => e.id);
							return s ? iO()([...e, ...i]).sort((e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1) : IT()(e, i)
						}
						case xg.e:
							return t.payload.subscriptions;
						default:
							return e
					}
				},
				wT = Object(r.c)({
					api: fT,
					favoriteMultiOrder: lT,
					favoriteProfileOrder: OT,
					favoriteSubredditOrder: yT,
					multiredditOrder: ET,
					profileOrder: TT,
					subredditOrder: CT
				}),
				PT = n("./src/reddit/actions/tabBadging.ts");
			var DT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case PT.a:
							const {
								hasUnreadMessages: n
							} = t.payload;
							return n;
						default:
							return e
					}
				},
				RT = n("./src/reddit/actions/tags/constants.ts");
			const AT = {
				pending: !1,
				error: !1
			};
			var kT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RT.g:
						return Object.assign({}, e, {
							pending: !0
						});
					case RT.h:
						return {
							error: !1, pending: !1
						};
					case RT.f:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const NT = {
				pending: !1,
				error: !1
			};
			var LT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RT.j:
						return Object.assign({}, e, {
							pending: !0
						});
					case RT.k:
						return {
							error: !1, pending: !1
						};
					case RT.i:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const MT = {
				pending: !1,
				error: !1
			};
			var UT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : MT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RT.o:
						return Object.assign({}, e, {
							pending: !0
						});
					case RT.n:
					case RT.m:
					case RT.d:
					case RT.e:
						return {
							error: !1, pending: !1
						};
					case RT.l:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const FT = {
				pending: !1,
				error: !1
			};
			var BT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case RT.q:
							return Object.assign({}, e, {
								pending: !0
							});
						case RT.r:
							return {
								error: !1, pending: !1
							};
						case RT.p:
							return {
								error: !0, pending: !1
							};
						default:
							return e
					}
				},
				GT = Object(r.c)({
					create: kT,
					deleteTag: LT,
					fetch: UT,
					update: BT
				});
			const VT = {
				global: [],
				recommendedGlobal: []
			};
			var qT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : VT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case RT.m:
						case RT.d:
						case RT.e: {
							const {
								globalSubredditTags: e
							} = t.payload, n = Object.keys(e).sort((t, n) => {
								const r = e[t].text.toLowerCase(),
									s = e[n].text.toLowerCase();
								return r < s ? -1 : r > s ? 1 : 0
							}), r = n.filter(t => e[t].isRecommended);
							return {
								global: n,
								recommendedGlobal: r
							}
						}
						default:
							return e
					}
				},
				HT = n("./node_modules/lodash/uniqWith.js"),
				KT = n.n(HT),
				WT = n("./src/reddit/models/Option/index.ts");
			const YT = {
				selectedOptions: [],
				tagInput: ""
			};
			var zT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case RT.c: {
							const {
								option: n
							} = t.payload;
							return Object.assign({}, e, {
								selectedOptions: KT()([...e.selectedOptions || [], Object.assign({}, n)], WT.a)
							})
						}
						case RT.b: {
							const {
								option: n
							} = t.payload, r = e.selectedOptions.findIndex(e => Object(WT.a)(e, n));
							return e.selectedOptions.splice(r, 1), Object.assign({}, e, {
								selectedOptions: e.selectedOptions
							})
						}
						case RT.a: {
							const {
								input: n
							} = t.payload;
							return Object.assign({}, e, {
								tagInput: n
							})
						}
						default:
							return e
					}
				},
				JT = n("./src/reddit/helpers/tags/index.ts");
			const QT = {
				globalSubredditTags: {},
				subredditScopedTags: {},
				itemTags: {},
				suggestedItemTags: {},
				sortedItemTags: {}
			};
			var XT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case RT.e: {
							const {
								globalSubredditTags: n,
								subredditScopedTags: r,
								subredditId: s
							} = t.payload;
							return Object.assign({}, e, {
								globalSubredditTags: Object.assign({}, e.globalSubredditTags, n),
								subredditScopedTags: Object.assign({}, e.subredditScopedTags, {
									[s]: Object.assign({}, e.subredditScopedTags[s] || {}, r[s] || {})
								})
							})
						}
						case RT.n:
						case RT.m: {
							const {
								globalSubredditTags: n,
								subredditScopedTags: r,
								itemTags: s,
								suggestedItemTags: o,
								subredditId: i
							} = t.payload;
							return {
								globalSubredditTags: Object.assign({}, e.globalSubredditTags, n),
								subredditScopedTags: Object.assign({}, e.subredditScopedTags, {
									[i]: Object.assign({}, e.subredditScopedTags[i] || {}, r[i] || {})
								}),
								itemTags: Object.assign({}, e.itemTags, {
									[i]: Object.assign({}, s[i] || {})
								}),
								suggestedItemTags: Object.assign({}, e.suggestedItemTags, {
									[i]: Object.assign({}, o[i] || {})
								}),
								sortedItemTags: Object.assign({}, e.sortedItemTags, {
									[i]: Object(JT.a)(s[i] || {})
								})
							}
						}
						case RT.k: {
							const {
								subredditId: n,
								tags: r
							} = t.payload, s = r.reduce((e, t) => {
								let {
									tagId: n
								} = t;
								return delete e[n], e
							}, Object.assign({}, e.subredditScopedTags[n] || {}));
							return Object.assign({}, e, {
								subredditScopedTags: Object.assign({}, e.subredditScopedTags, {
									[n]: s
								})
							})
						}
						case RT.d: {
							const {
								globalSubredditTags: n
							} = t.payload;
							return Object.assign({}, e, {
								globalSubredditTags: Object.assign({}, e.globalSubredditTags, n)
							})
						}
						default:
							return e
					}
				},
				ZT = n("./src/reddit/reducers/tags/selected/index.ts"),
				$T = Object(r.c)({
					api: GT,
					availableGlobalTagOrder: qT,
					models: XT,
					selected: ZT.b,
					creation: zT
				}),
				ex = n("./src/reddit/actions/redditEmbed.ts"),
				tx = n("./src/reddit/actions/theme.ts"),
				nx = n("./src/reddit/actions/users.ts"),
				rx = n("./src/reddit/models/Theme/index.ts");
			const sx = {
				current: rx.c,
				cached: {}
			};
			var ox = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tx.a: {
							const {
								nightmode: e
							} = t.payload;
							return {
								current: e ? rx.b : rx.c,
								cached: {}
							}
						}
						case Cs.a:
						case Cs.b:
						case Cs.g:
						case Cs.e:
						case Cs.h:
						case Be.e:
						case Be.h:
						case Fe.a:
						case re.a:
						case Fe.b:
						case re.b:
						case Fe.d:
						case re.d:
						case re.g:
						case ae.b:
						case re.l:
						case re.k:
						case Me.b:
						case ex.b:
						case ue.i:
						case Ke.c:
						case ce.c:
						case tl.i:
						case Ge.b:
						case Co.a:
						case nx.e:
							if (t.payload && t.payload.preferences && t.payload.preferences.nightmode) {
								const {
									nightmode: e
								} = t.payload.preferences;
								return e ? {
									current: rx.b,
									cached: {}
								} : {
									current: rx.c,
									cached: {}
								}
							}
							return e;
						case se.d:
						case se.e:
						case Ve.a:
						case Ve.b:
						case Ve.d:
						case Ve.e:
						case oe.d:
						case oe.e: {
							const {
								account: n
							} = t.payload;
							return n ? n.nightmode ? {
								current: rx.b,
								cached: {}
							} : {
								current: rx.c,
								cached: {}
							} : e
						}
						case ne.h:
						case ne.j:
						case ne.i:
						case ne.g:
						case ne.f:
						case ne.n:
						case ne.m:
						case ne.p:
						case ne.q:
						case ne.w:
						case ne.v:
							if (t.payload && t.payload.response && t.payload.response.preferences && t.payload.response.preferences.nightmode) {
								const {
									nightmode: e
								} = t.payload.response.preferences;
								return e ? {
									current: rx.b,
									cached: {}
								} : {
									current: rx.c,
									cached: {}
								}
							}
							return e;
						case tl.h: {
							if (!t.payload) return e;
							const {
								nightmode: n
							} = t.payload;
							return n ? {
								current: rx.b,
								cached: {}
							} : {
								current: rx.c,
								cached: {}
							}
						}
						case h.d:
							return {
								current: rx.c, cached: {}
							};
						case h.e:
							return t.payload.nightmodeTempUpdated ? {
								current: rx.b,
								cached: {}
							} : e;
						default:
							return e
					}
				},
				ix = n("./src/reddit/actions/toaster.ts");
			const cx = [];
			var ax = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ix.c: {
							const n = t.payload,
								r = [];
							let s = !1;
							for (const t of e) {
								const e = t.id === n.id ? n : t;
								r.push(e), s = s || e === n
							}
							return s || r.push(n), r
						}
						case ix.b: {
							const n = t.payload;
							return e.filter(e => e.id !== n)
						}
						default:
							return e
					}
				},
				dx = n("./src/reddit/actions/tooltip.ts");
			var ux = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case dx.c: {
						const {
							tooltipId: n
						} = t.payload;
						return e === n ? null : n
					}
					case dx.a: {
						const {
							tooltipId: n
						} = t.payload;
						return e === n ? e : n
					}
					case dx.b: {
						const {
							tooltipId: n
						} = t.payload;
						return null !== e ? e : n || null
					}
					case dx.e: {
						const {
							tooltipId: n
						} = t.payload;
						return e === n ? null : e
					}
					case Oe.G:
					case dx.d:
					case m.a:
					case Kd.b:
					case Kd.c:
					case Kd.a:
						return null;
					default:
						return e
				}
			};
			const lx = {};
			var bx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bu.e:
						case Bu.b:
							return Object.assign({}, e, t.payload.topics);
						default:
							return e
					}
				},
				px = Object(r.c)({
					models: bx
				}),
				mx = n("./src/reddit/actions/tracking.ts");
			const fx = {};
			var gx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mx.a: {
							const {
								routeKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !0
							})
						}
						case mx.b: {
							const {
								routeKey: n
							} = t.payload;
							return Object.assign({}, e, {
								[n]: !1
							})
						}
						default:
							return e
					}
				},
				Ox = Object(r.c)({
					viewportDataLoaded: gx
				}),
				hx = n("./src/reddit/actions/trafficStats/constants.ts");
			var yx = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hx.c:
						return !0;
					case hx.b:
					case hx.a:
						return !1;
					default:
						return e
				}
			};
			var jx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hx.b: {
							const {
								trafficStats: e
							} = t.payload;
							return e
						}
						case hx.c:
							return null;
						default:
							return e
					}
				},
				_x = Object(r.c)({
					pending: yx,
					trafficStats: jx
				});
			var Ex = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.t:
					case l.u:
						return null;
					case l.r: {
						const {
							error: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var vx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.t:
							return !0;
						case l.r:
						case l.u:
							return !1;
						default:
							return e
					}
				},
				Ix = Object(r.c)({
					error: Ex,
					pending: vx
				});
			var Sx = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.s:
						return (t.payload ? t.payload.contentId : null) || null;
					case s.b:
					case l.u:
						return null;
					default:
						return e
				}
			};
			var Tx = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.s:
						return (t.payload ? t.payload.recipient : "") || "";
					case l.u:
						return "";
					default:
						return e
				}
			};
			var xx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.s:
							return t.payload && t.payload.publicAddress || null;
						case s.b:
						case l.u:
							return null;
						default:
							return e
					}
				},
				Cx = Object(r.c)({
					api: Ix,
					contentId: Sx,
					initialRecipient: Tx,
					publicAddress: xx
				}),
				wx = Object(r.c)({
					communityPoints: Cx
				}),
				Px = n("./src/reddit/actions/search/trending.ts");
			const Dx = [];
			var Rx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b:
						case Px.a: {
							const {
								items: n
							} = t.payload;
							return n || e
						}
						default:
							return e
					}
				},
				Ax = Object(r.c)({
					models: Rx
				});
			const kx = {};
			var Nx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Hy.a: {
							const {
								trophies: n
							} = t.payload;
							return Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				Lx = n("./src/reddit/models/Upload/index.ts");
			const Mx = {};
			var Ux = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mx,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uo.d: {
						const {
							key: n,
							id: r,
							file: s
						} = t.payload, o = e[n], i = o && o.file === s ? Object.assign({}, o.metadata) : {};
						return Object.assign({}, e, {
							[n]: {
								key: n,
								id: r,
								file: s,
								metadata: i,
								url: void 0,
								status: Lx.a.PENDING
							}
						})
					}
					case Uo.h: {
						const {
							key: n
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								status: Lx.a.UPLOADING
							})
						})
					}
					case Uo.c: {
						const {
							key: n,
							metadata: r
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								metadata: r
							})
						})
					}
					case Uo.e: {
						const {
							key: n,
							progress: r
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								progress: r
							})
						})
					}
					case Uo.g: {
						const {
							key: n,
							url: r,
							websocketUrl: s
						} = t.payload, o = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, o, {
								status: Lx.a.SUCCESS,
								url: r,
								websocketUrl: s
							})
						})
					}
					case Uo.b: {
						const {
							key: n,
							error: r
						} = t.payload, s = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, s, {
								status: Lx.a.FAILED,
								error: r
							})
						})
					}
					case Uo.a: {
						const {
							key: n
						} = t.payload, r = e[n];
						return Object.assign({}, e, {
							[n]: Object.assign({}, r, {
								status: Lx.a.CANCELED
							})
						})
					}
					case Uo.f: {
						const {
							key: n
						} = t.payload, r = e[n];
						return r.metadata.localUrl && window.URL.revokeObjectURL(r.metadata.localUrl), Sr()(e, n)
					}
					case p.d:
					case p.c:
						return Mx;
					case f.C:
						return Sr()(e, ur.m);
					default:
						return e
				}
			};
			const Fx = {};
			var Bx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fx,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a: {
							const {
								subredditId: n,
								wallet: r
							} = t.payload;
							if (!r) return e;
							const s = e[n] || {};
							return Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									latest: r,
									byDate: Object.assign({}, s.byDate || {}, {
										[r.at]: r
									})
								})
							})
						}
						case l.x: {
							const n = t.payload,
								r = Object.assign({}, e);
							return Object.keys(n).forEach(t => {
								const s = n[t],
									o = e[t],
									i = {
										latest: o ? o.latest.at <= s.at ? s : o.latest : s,
										byDate: Object.assign({}, o ? o.byDate : {}, {
											[s.at]: s
										})
									};
								r[t] = i
							}), r
						}
						case g.d: {
							const {
								product: n,
								wallet: r
							} = t.payload, s = e[n.subredditId] || {};
							return Object.assign({}, e, {
								[n.subredditId]: Object.assign({}, s, {
									[r.at]: r,
									latest: r
								})
							})
						}
						case l.u: {
							const {
								subredditId: n,
								wallet: r
							} = t.payload, s = e[n] || {};
							return Object.assign({}, e, {
								[n]: Object.assign({}, s, {
									[r.at]: r,
									latest: r
								})
							})
						}
						default:
							return e
					}
				},
				Gx = n("./src/reddit/actions/inbox.ts"),
				Vx = n("./src/reddit/actions/pages/appeal/constants.ts"),
				qx = n("./src/reddit/actions/pages/userDataRequest/index.ts");
			const Hx = (e, t) => !t || _r()(e, t) ? e : t;
			var Kx = Object(MO.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Vx.a:
					case Vx.b:
					case r_.b:
					case r_.c:
					case Cs.a:
					case Cs.b:
					case Cs.e:
					case Cs.g:
					case Cs.h:
					case Be.e:
					case Be.h:
					case Be.g:
					case Ue.q:
					case Ue.r:
					case Fe.a:
					case re.a:
					case Fe.b:
					case re.b:
					case re.f:
					case re.g:
					case re.k:
					case re.l:
					case ae.a:
					case se.b:
					case se.a:
					case se.e:
					case se.d:
					case ie.c:
					case ie.i:
					case Ve.e:
					case Ve.d:
					case Ve.b:
					case Ve.a:
					case oe.e:
					case oe.d:
					case ae.b:
					case ce.a:
					case ce.c:
					case Ge.b:
					case Co.a:
					case Ke.a:
					case Ke.c:
					case ex.a:
					case ex.b:
					case tl.i:
					case qx.b:
					case nx.e:
						return Hx(e, t.payload.account);
					case nx.p:
						return e ? Object.assign({}, e, {
							email: t.payload
						}) : e;
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case ne.h:
					case ne.e:
					case ne.l:
					case ne.o:
					case ne.u: {
						const {
							response: n
						} = t.payload;
						return n ? Hx(e, n.account) : e
					}
					case nx.c:
						return e ? Object.assign({}, e, {
							seenLayoutSwitch: !0
						}) : e;
					case s.d:
						return e ? Object.assign({}, e, {
							seenRedesignModal: !0
						}) : e;
					case Oe.u:
						return e ? Object.assign({}, e, {
							seenGiveAwardTooltip: !0
						}) : e;
					case tl.k:
					case tl.j: {
						const n = t.payload;
						return e && "profileIcon" === n.key ? Object.assign({}, e, {
							accountIcon: n.imageUrl
						}) : e
					}
					case Oe.A:
					case Oe.q: {
						const {
							coins: n
						} = t.payload;
						return e ? Object.assign({}, e, {
							coins: n
						}) : e
					}
					case ud.f: {
						const {
							coins: n
						} = t.payload;
						return n && e ? Object.assign({}, e, {
							coins: n
						}) : e
					}
					case Gx.a: {
						const {
							inboxCount: n
						} = t.payload;
						return e ? Object.assign({}, e, {
							inboxCount: n
						}) : e
					}
					default:
						return e
				}
			}), null);
			var Wx = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nx.o:
					case nx.p:
						return null;
					case nx.n:
						return t.payload;
					default:
						return e
				}
			};
			var Yx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nx.o:
							return !0;
						case nx.p:
						case nx.n:
							return !1;
						default:
							return e
					}
				},
				zx = Object(r.c)({
					error: Wx,
					pending: Yx
				}),
				Jx = Object(r.c)({
					api: zx
				});
			var Qx = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nx.l:
						return !0;
					default:
						return e
				}
			};
			var Xx = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nx.k:
							return !0;
						case nx.l:
						case nx.j:
							return !1;
						default:
							return e
					}
				},
				Zx = Object(r.c)({
					pending: Xx,
					emailSent: Qx
				}),
				$x = Object(r.c)({
					api: Zx
				}),
				eC = Object(r.c)({
					changeEmail: Jx,
					sendResetEmail: $x
				}),
				tC = n("./src/reddit/models/WhitelistAndBlocked.ts");
			const nC = {};
			var rC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Kt.f:
						return Object.assign({}, e, {
							new: tC.a.pending
						});
					case Kt.d:
						return Object.assign({}, e, {
							new: tC.a.error
						});
					case Kt.e:
						return Object.assign({}, e, {
							new: tC.a.waitingForRequest
						});
					case Kt.b: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: tC.a.pending
						})
					}
					case Kt.a: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: tC.a.error
						})
					}
					case Kt.c: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: tC.a.waitingForRequest
						})
					}
					default:
						return e
				}
			};
			const sC = [];
			var oC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Kt.e:
							return [t.payload, ...e];
						case Kt.c: {
							const n = t.payload.name;
							return e.filter(e => e.name !== n)
						}
						case tl.i:
							return t.payload.blockedUsers;
						default:
							return e
					}
				},
				iC = Object(r.c)({
					api: rC,
					data: oC
				}),
				cC = n("./src/reddit/actions/chat/constants.ts"),
				aC = n("./src/reddit/actions/chat/userSettings.ts");
			const dC = cC.a.anybody;
			var uC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case aC.a:
							if (t.payload) {
								const {
									invitePolicy: e
								} = t.payload;
								return e
							}
							return e;
						default:
							return e
					}
				},
				lC = Object(r.c)({
					invitePolicy: uC
				});
			const bC = (e, t) => void 0 === t || e && t === e.count ? e : Object.assign({}, e, {
				count: t
			});
			var pC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.b: {
						const {
							drafts: n
						} = t.payload;
						return e && _r()(e, n) ? e : Object.assign({}, e, n)
					}
					case f.N: {
						const {
							response: {
								draftsCount: n
							}
						} = t.payload;
						return bC(e, n)
					}
					case Fs.e: {
						const {
							postDraftIds: n
						} = t.payload;
						return bC(e, n.length)
					}
					case Fs.c:
					case Fs.l: {
						const {
							draftsCount: n
						} = t.payload;
						return bC(e, n)
					}
					default:
						return e
				}
			};
			const mC = {};
			var fC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Tn.a: {
						const n = t.payload;
						return null === n.local_persisted_experiments_store || void 0 === n.local_persisted_experiments_store ? e : n.local_persisted_experiments_store
					}
					default:
						return e
				}
			};
			const gC = [];
			var OC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cc.a:
							return t.payload.experimentVariants.map(e => {
								let {
									id: t,
									experimentName: n,
									name: r,
									version: s
								} = e;
								return {
									id: parseInt(t),
									name: n,
									variant: r || void 0,
									version: s
								}
							});
						default:
							return e
					}
				},
				hC = Object(r.c)({
					models: OC,
					localPersisted: fC
				});

			function yC(e, t) {
				return t ? e && _r()(e, t) ? e : t : e
			}
			const jC = {};
			var _C = Object(MO.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cs.a:
					case Cs.b:
					case Cs.e:
					case Cs.g:
					case Cs.h:
					case Be.e:
					case Fe.a:
					case re.a:
					case Fe.b:
					case re.b:
					case re.f:
					case re.g:
					case re.k:
					case re.l:
					case ae.a:
					case jm.k:
					case se.e:
					case se.d:
					case Ve.e:
					case Ve.d:
					case Ve.b:
					case Ve.a:
					case oe.e:
					case oe.d:
					case ae.b:
					case ce.a:
					case ce.c:
					case Ge.b:
					case ex.a:
					case ex.b:
					case tl.i:
					case nx.e: {
						const n = t.payload.features;
						return n ? yC(e, n) : e
					}
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v:
					case ne.h:
					case ne.e:
					case ne.l:
					case ne.o:
					case ne.u: {
						const {
							response: n
						} = t.payload;
						return n && n.features ? yC(e, n.features) : e
					}
					default:
						return e
				}
			}), jC);
			var EC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case tl.e:
						return !0;
					case tl.d:
						return !1;
					default:
						return e
				}
			};
			var vC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "en",
						t = arguments.length > 1 ? arguments[1] : void 0;
					return t.type, e
				},
				IC = n("./src/reddit/actions/monthsToMinutes/reset.ts");
			var SC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xg.e:
							return t.payload.accountCompleteness.collapsed;
						case xg.c:
							return !1;
						case xg.b:
							return !0;
						case IC.a:
							return !1;
						default:
							return e
					}
				},
				TC = n("./src/reddit/actions/monthsToMinutes/accountCompleteness.ts"),
				xC = n("./src/reddit/models/MonthsToMinutes/index.ts");
			const CC = xC.a.Initial;
			var wC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xg.e: {
							const {
								accountCompleteness: n
							} = t.payload;
							return e !== CC ? e : n.step
						}
						case TC.a:
							return t.payload || e;
						case IC.a:
							return CC;
						default:
							return e
					}
				},
				PC = Object(r.c)({
					collapsed: SC,
					step: wC
				});
			var DC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xg.e:
						case xg.d:
							return !0;
						default:
							return e
					}
				},
				RC = n("./src/reddit/actions/monthsToMinutes/initHomeFeed.ts");
			const AC = [];
			var kC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RC.a:
					case xg.f: {
						const n = t.payload;
						return n.length ? n : e
					}
					case vm.h: {
						const {
							nameIdentifiers: n,
							shouldUpdateLoggedOutHomeFeed: r,
							userIsSubscriber: s
						} = t.payload;
						if (!r) return e;
						const o = n.map(e => Object(vn.f)(e.name));
						return s ? [...e, ...o] : e.filter(e => -1 === o.indexOf(e))
					}
					case IC.a:
						return AC;
					default:
						return e
				}
			};
			const NC = [];
			var LC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ZE.b: {
						const {
							subredditNames: e
						} = t.payload;
						return e || NC
					}
					case xg.e:
						return t.payload.homeFeed.similar;
					case IC.a:
						return NC;
					default:
						return e
				}
			};
			var MC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ZE.a:
						return !0;
					case xg.e:
						return t.payload.homeFeed.topBanner.isClosed;
					case IC.a:
						return !1;
					default:
						return e
				}
			};
			var UC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ZE.d:
							return e + 1;
						case xg.e:
							return t.payload.homeFeed.topBanner.viewsCount;
						case IC.a:
							return 0;
						default:
							return e
					}
				},
				FC = Object(r.c)({
					isClosed: MC,
					viewsCount: UC
				}),
				BC = n("./src/reddit/actions/monthsToMinutes/post.ts");
			const GC = [];
			var VC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case BC.a: {
						const n = Object(vn.f)(t.payload.subredditName);
						return [n, ...e.filter(e => e !== n)]
					}
					case re.b: {
						const {
							postId: n,
							posts: r,
							subreddits: s
						} = t.payload, o = r[n];
						if (!o) return e;
						const i = s[o.belongsTo.id];
						if (!i) return e;
						const c = Object(vn.f)(i.name);
						return [c, ...e.filter(e => e !== c)]
					}
					case xg.e:
						return iO()([...t.payload.homeFeed.views, ...e]);
					default:
						return e
				}
			};
			const qC = {};
			var HC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ZE.c: {
							const {
								id: n,
								subredditName: r
							} = t.payload, s = Object(vn.f)(r);
							return e[n] === s ? e : Object.assign({}, e, {
								[n]: s
							})
						}
						case xg.e:
							return t.payload.homeFeed.votes;
						case IC.a:
							return qC;
						default:
							return e
					}
				},
				KC = Object(r.c)({
					similar: LC,
					topBanner: FC,
					views: VC,
					votes: HC
				});
			var WC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RC.a:
					case xg.f:
						return t.payload.length >= 1 || e;
					case re.i:
						return !0;
					case vm.h: {
						const {
							subscriptionsCount: n,
							userIsSubscriber: r
						} = t.payload;
						return !(1 === n && !r) && e
					}
					case IC.a:
						return !1;
					default:
						return e
				}
			};
			var YC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case TC.a: {
						if (t.payload !== xC.a.BannerVisible) return e;
						const n = 20;
						return Math.ceil(n * Math.random()) + 20
					}
					case xg.e:
						return t.payload.postsCount || 0;
					default:
						return e
				}
			};
			const zC = {
				[xC.e.Home]: {},
				[xC.e.SubscribeFeed]: {},
				[xC.e.SubscribeIdCard]: {},
				[xC.e.SubscribeReminder]: {},
				[xC.e.Vote]: {},
				[xC.e.VoteReminder]: {},
				[xC.e.VoteSuccess]: {}
			};
			var JC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xg.e: {
						const n = t.payload,
							{
								homeTooltipTime: r,
								subscribeTooltipTime: s,
								subscribeIdCardTooltipTime: o,
								voteTooltipTime: i
							} = n.tooltip;
						return e[xC.e.Home].time = r, e[xC.e.SubscribeFeed].time = s, e[xC.e.Vote].time = i, e[xC.e.SubscribeIdCard] = {
							isDismissed: !0,
							time: o
						}, Object.assign({}, e)
					}
					case Cr.a: {
						const {
							id: n
						} = t.payload;
						let r = Object.assign({}, e[xC.e.VoteSuccess]);
						return r.isDismissed || r.postId || (r = {
							isDismissed: !1,
							postId: n
						}), Object.assign({}, e, {
							[xC.e.VoteSuccess]: r
						})
					}
					case re.i: {
						const t = Object.assign({}, e[xC.e.Home]);
						return t.isDismissed = !0, Object.assign({}, e, {
							[xC.e.Home]: t
						})
					}
					case m.a:
					case tl.g: {
						const t = Object.assign({}, e);
						return Object.keys(e).map(n => {
							const r = Object.assign({}, e[n]);
							(r.postId || r.time) && (r.isDismissed = !0), t[n] = r
						}), t
					}
					case Hd.d:
						return Object.assign({}, e, {
							[xC.e.Home]: Object.assign({}, e[xC.e.Home], {
								isDismissed: !0
							})
						});
					case IC.a:
						return zC;
					default:
						return e
				}
			};
			const QC = {
				beforeBanner: 0,
				total: 0
			};
			var XC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.c:
						return Object.assign({}, e, {
							total: e.total + 1
						});
					case TC.a:
						return t.payload !== xC.a.BannerVisible ? e : Object.assign({}, e, {
							beforeBanner: e.total
						});
					case xg.e: {
						const {
							beforeBanner: n,
							total: r
						} = t.payload.views.count;
						return {
							beforeBanner: n,
							total: r + e.total
						}
					}
					case IC.a:
						return Object.assign({}, e, {
							beforeBanner: 0
						});
					default:
						return e
				}
			};
			const ZC = [];
			var $C = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ZC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.b:
						case BC.a: {
							const {
								postId: n
							} = t.payload;
							return e.includes(n) ? e : [...e, n]
						}
						case xg.e: {
							const n = t.payload;
							return iO()([...n.views.posts, ...e])
						}
						case IC.a:
							return ZC;
						default:
							return e
					}
				},
				ew = Object(r.c)({
					count: XC,
					posts: $C
				}),
				tw = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const nw = {};
			var rw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cr.a: {
							const {
								id: n,
								vote: r
							} = t.payload;
							if (!Object(wr.a)(n)) return e;
							if (e[n] === r) {
								const t = n;
								e[t];
								return tw(e, ["symbol" == typeof t ? t : t + ""])
							}
							return Object.assign({}, e, {
								[n]: r
							})
						}
						case xg.e:
							return t.payload.votes.comments;
						case IC.a:
							return nw;
						default:
							return e
					}
				},
				sw = function(e, t) {
					var n = {};
					for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
					}
					return n
				};
			const ow = {};
			var iw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ow,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cr.a: {
							const {
								id: n,
								isInstance: r,
								vote: s
							} = t.payload;
							if (!Object(wg.a)(n) || r) return e;
							if (e[n] === s) {
								const t = n;
								e[t];
								return sw(e, ["symbol" == typeof t ? t : t + ""])
							}
							return Object.assign({}, e, {
								[n]: s
							})
						}
						case xg.e:
							return t.payload.votes.posts;
						case IC.a:
							return ow;
						default:
							return e
					}
				},
				cw = Object(r.c)({
					comments: rw,
					posts: iw
				}),
				aw = Object(r.c)({
					accountCompleteness: PC,
					dataLoaded: DC,
					feedMultiName: kC,
					homeFeed: KC,
					isFrontpageHome: WC,
					postsCount: YC,
					tooltips: JC,
					views: ew,
					votes: cw
				});
			const dw = {
				blob: "",
				loid: "",
				loidCreated: "",
				version: -1
			};
			var uw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nx.d:
							return t.payload;
						default:
							return e
					}
				},
				lw = n("./src/reddit/actions/notifications/constants.ts");
			var bw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lw.b: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case lw.d:
					case lw.c:
						return null;
					default:
						return e
				}
			};
			var pw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lw.d:
						return !1;
					case lw.c:
						return !0;
					default:
						return e
				}
			};
			var mw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lw.d:
							return !0;
						case lw.c:
						case lw.b:
							return !1;
						default:
							return e
					}
				},
				fw = Object(r.c)({
					error: bw,
					loaded: pw,
					pending: mw
				});
			var gw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lw.i: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case lw.k:
					case lw.j:
						return null;
					default:
						return e
				}
			};
			var Ow = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lw.k:
						return !1;
					case lw.j:
						return !0;
					default:
						return e
				}
			};
			var hw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lw.k:
							return !0;
						case lw.j:
						case lw.i:
							return !1;
						default:
							return e
					}
				},
				yw = Object(r.c)({
					error: gw,
					loaded: Ow,
					pending: hw
				}),
				jw = Object(r.c)({
					getPreferences: fw,
					setPreferences: yw
				});
			var _w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lw.l:
						return !0;
					case lw.e:
					case lw.g:
					case lw.h:
						return !1;
					default:
						return e
				}
			};
			const Ew = {
				chatMessages: !1,
				communityRecommendations: !1,
				liveEvent: !1,
				trendingPosts: !1,
				unreadMessages: !1,
				upvotedComments: !1,
				upvotedPosts: !1
			};
			var vw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ew,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lw.c:
						case lw.k:
						case lw.i: {
							const {
								preferences: n
							} = t.payload;
							return gn()(n) ? e : n
						}
						default:
							return e
					}
				},
				Iw = Object(r.c)({
					api: jw,
					isNotificationPromptVisible: _w,
					preferences: vw
				});
			const Sw = {};
			var Tw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.j:
						case a.i: {
							const {
								subredditId: n,
								userOwnedBadges: r
							} = t.payload, s = r.reduce((e, t) => (e[t] = !0, e), {});
							return Object.assign({}, e, {
								[n]: Object.assign({}, e[n] || {}, s)
							})
						}
						case g.d: {
							const {
								userOwnedBadges: n,
								product: r
							} = t.payload, s = n.reduce((e, t) => (e[t] = !0, e), {});
							return Object.assign({}, e, {
								[r.subredditId]: Object.assign({}, e[r.subredditId] || {}, s)
							})
						}
						default:
							return e
					}
				},
				xw = n("./src/reddit/reducers/user/prefs/index.ts");
			var Cw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nx.f:
							return t.payload;
						default:
							return e
					}
				},
				ww = n("./src/reddit/actions/session.ts");
			var Pw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ww.a:
					case ww.b:
					case ww.c:
					case ww.e:
						return t.payload;
					case ww.d:
						return null;
					default:
						return e
				}
			};
			var Dw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ww.f:
						return !0;
					default:
						return e
				}
			};
			var Rw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nx.m:
						return t.payload;
					default:
						return e
				}
			};
			var Aw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cc.a: {
						const e = t.payload;
						return e.identity && e.identity.isEmployee
					}
					default:
						return e
				}
			};
			var kw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cc.a:
							return t.payload.isLoggedIn;
						default:
							return e
					}
				},
				Nw = Object(r.c)({
					isEmployee: Aw,
					isLoggedIn: kw
				});
			var Lw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case tl.q: {
							const {
								topContentDismissal: n
							} = t.payload;
							return e && _r()(e, n) ? e : Object.assign({}, e, n)
						}
						default:
							return e
					}
				},
				Mw = n("./src/reddit/actions/userWhitelist.ts");
			const Uw = {};
			var Fw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Uw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Mw.e:
						return Object.assign({}, e, {
							new: tC.a.pending
						});
					case Mw.d:
						return Object.assign({}, e, {
							new: tC.a.error
						});
					case Mw.f:
						return Object.assign({}, e, {
							new: tC.a.waitingForRequest
						});
					case Mw.b: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: tC.a.pending
						})
					}
					case Mw.a: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: tC.a.error
						})
					}
					case Mw.c: {
						const n = t.payload.name;
						return Object.assign({}, e, {
							[n]: tC.a.waitingForRequest
						})
					}
					default:
						return e
				}
			};
			const Bw = [];
			var Gw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Mw.f:
							return [t.payload, ...e];
						case Mw.c: {
							const n = t.payload.name;
							return e.filter(e => e.name !== n)
						}
						case tl.i:
							return t.payload.whitelistedUsers;
						default:
							return e
					}
				},
				Vw = Object(r.c)({
					api: Fw,
					data: Gw
				}),
				qw = Object(r.c)({
					account: Kx,
					accountSettings: eC,
					blocked: iC,
					chatSettings: lC,
					drafts: pC,
					experiments: hC,
					features: _C,
					isCustomizeFlyoutShowing: EC,
					topContentDismissalPrefsSet: Lw,
					language: vC,
					loggedOutData: aw,
					loid: uw,
					notificationPrefs: Iw,
					ownedBadges: Tw,
					prefs: xw.b,
					reddaid: Cw,
					session: Pw,
					sessionRefreshFailed: Dw,
					sessionTracker: Rw,
					temporaryGQL: Nw,
					wallets: Bx,
					whitelist: Vw
				});
			var Hw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qx.a:
						return t.payload;
					case qx.b:
					case qx.c:
						return null;
					default:
						return e
				}
			};
			var Kw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qx.c:
						return !0;
					case qx.b:
					case qx.a:
						return !1;
					default:
						return e
				}
			};
			var Ww = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qx.b:
						return !0;
					case qx.a:
					case qx.c:
						return !1;
					default:
						return e
				}
			};
			var Yw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qx.b:
							return t.payload.userDataExportEligibility;
						case qx.a:
						case qx.c:
							return !1;
						default:
							return e
					}
				},
				zw = Object(r.c)({
					error: Hw,
					pending: Kw,
					success: Ww,
					userDataExportEligibility: Yw
				}),
				Jw = Object(r.c)({
					userDataRequestPageApi: zw
				});
			const Qw = {};
			var Xw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.b:
					case Ge.b:
					case Co.a:
					case Fe.b:
					case re.b:
					case le.e:
						return Object.assign({}, e, t.payload.userFlair);
					case ne.i:
					case ne.f:
					case ne.m:
					case ne.p:
					case ne.v: {
						const {
							response: n
						} = t.payload, {
							userFlair: r
						} = n, s = Object.assign({}, e);
						return Object.keys(r).forEach(e => {
							s[e] || (s[e] = r[e])
						}), s
					}
					case le.i: {
						const {
							subredditId: n,
							applied: r,
							displaySettings: s
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								applied: r,
								displaySettings: s
							})
						})
					}
					case te.h: {
						const {
							subredditId: n,
							applied: r
						} = t.payload;
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								applied: r
							})
						})
					}
					case le.d: {
						const {
							subredditId: n,
							isEnabled: r
						} = t.payload, s = e[n].displaySettings, o = Object.assign({}, s, {
							isEnabled: r
						});
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								displaySettings: o
							})
						})
					}
					case le.b: {
						const {
							subredditId: n,
							canAssignOwn: r
						} = t.payload, s = e[n].permissions, o = Object.assign({}, s, {
							canAssignOwn: r
						});
						return Object.assign({}, e, {
							[n]: Object.assign({}, e[n], {
								permissions: o
							})
						})
					}
					case le.h: {
						const n = t.payload,
							r = e[n.subredditId],
							s = e[n.subredditId].templates,
							o = e[n.subredditId].templateIds,
							i = Object.assign({}, s, {
								[n.template.id]: n.template
							}),
							c = [...o];
						return c.includes(n.template.id) || c.push(n.template.id), Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, r, {
								templates: i,
								templateIds: c
							})
						})
					}
					case le.c: {
						const n = t.payload,
							r = e[n.subredditId],
							s = e[n.subredditId].templates,
							o = e[n.subredditId].templateIds,
							i = Sr()(s, n.templateId),
							c = o.filter(e => e !== n.templateId);
						return Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, r, {
								templates: Object.assign({}, i),
								templateIds: c
							})
						})
					}
					case le.g:
					case le.f: {
						const n = t.payload,
							r = e[n.subredditId];
						return Object.assign({}, e, {
							[n.subredditId]: Object.assign({}, r, {
								templateIds: n.templateIds
							})
						})
					}
					default:
						return e
				}
			};
			const Zw = {};
			var $w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nx.i:
					case nx.h: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: null
						})
					}
					case nx.g: {
						const {
							username: n,
							error: r
						} = t.payload;
						return Object.assign({}, e, {
							[n.toLowerCase()]: r
						})
					}
					default:
						return e
				}
			};
			var eP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nx.i:
							return !0;
						case nx.h:
						case nx.g:
							return !1;
						default:
							return e
					}
				},
				tP = Object(r.c)({
					error: $w,
					pending: eP
				});
			const nP = {};
			var rP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nP,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.f: {
						const {
							subredditId: n,
							usersAppliedBadges: r
						} = t.payload, s = Object.keys(r).reduce((t, s) => {
							const o = r[s];
							return t[s] = Object.assign({}, e[s] || {}, {
								[n]: o
							}), t
						}, {});
						return Object.assign({}, e, s)
					}
					case a.b: {
						const {
							badgeIds: n,
							subredditId: r,
							userId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s] || {}, {
								[r]: n
							})
						})
					}
					case a.a: {
						const {
							previousBadgeIds: n,
							subredditId: r,
							userId: s
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s] || {}, {
								[r]: n
							})
						})
					}
					case d.b: {
						const {
							badge: n,
							currentAppliedBadges: r,
							placement: s,
							subredditId: o,
							userId: i
						} = t.payload, c = r.filter(e => e.placement !== s).concat(n).filter(Boolean).map(e => e.id);
						return Object.assign({}, e, {
							[i]: Object.assign({}, e[i] || {}, {
								[o]: c
							})
						})
					}
					default:
						return e
				}
			};
			const sP = {},
				oP = (e, t) => {
					const n = Object.keys(t);
					if (!n.length) return e;
					const r = {};
					return n.forEach(n => {
						const s = e[n],
							o = t[n];
						s && _r()(s, o) || (r[n.toLowerCase()] = o)
					}), Object.keys(r).length ? Object.assign({}, e, r) : e
				};
			var iP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sP,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nx.h: {
							const {
								data: n
							} = t.payload;
							return oP(e, n)
						}
						case jm.k: {
							const {
								user: n
							} = t.payload;
							return oP(e, {
								[n.username]: n
							})
						}
						case Oe.q: {
							const {
								gildee: n
							} = t.payload;
							if (!n) return e;
							const r = e[n.toLowerCase()];
							if (!r) return e;
							const s = r.awardedLastMonth,
								o = s ? s.totalCount + 1 : 1,
								i = s && s.topAward;
							return i ? oP(e, {
								[n.toLowerCase()]: Object.assign({}, r, {
									awardedLastMonth: {
										totalCount: o,
										topAward: i
									}
								})
							}) : e
						}
						case tl.k:
						case tl.j: {
							const {
								imageUrl: n,
								key: r,
								username: s
							} = t.payload;
							if ("profileIcon" !== r) return e;
							const o = s.toLowerCase(),
								i = e[o];
							return i ? oP(e, {
								[o]: Object.assign({}, i, {
									accountIcon: n
								})
							}) : e
						}
						default:
							return e
					}
				},
				cP = n("./src/reddit/actions/usernameAvailable.ts");
			const aP = {};
			var dP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aP,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case cP.a: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: cP.b.Available
						})
					}
					case cP.c: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: cP.b.Error
						})
					}
					case cP.d: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: cP.b.Pending
						})
					}
					case cP.e: {
						const {
							username: n
						} = t.payload;
						return Object.assign({}, e, {
							[n]: cP.b.Unavailable
						})
					}
					default:
						return e
				}
			};
			const uP = {};
			var lP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uP,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.o: {
							const {
								subredditId: n,
								wallets: r
							} = t.payload, s = Object.keys(r).reduce((t, s) => {
								const o = e[s] || {},
									i = Object.assign({}, o, {
										[n]: r[s]
									});
								return Object.assign({}, t, {
									[s]: i
								})
							}, {});
							return Object.assign({}, e, s)
						}
						default:
							return e
					}
				},
				bP = Object(r.c)({
					api: tP,
					appliedBadges: rP,
					models: iP,
					nameAvailable: dP,
					publicWallets: lP
				});
			const pP = {};
			var mP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pP,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case re.b:
						case ae.b:
						case ue.i:
						case ce.c:
						case Ge.b:
						case Co.a: {
							const {
								structuredStyles: n
							} = t.payload;
							if (!(n && n.data && n.data.content)) return e;
							const r = n.data.content.widgets.layout.idCardWidget,
								s = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== s.length) return e;
							const o = s[0];
							return Object.assign({}, e, {
								[o]: r
							})
						}
						default:
							return e
					}
				},
				fP = n("./src/reddit/actions/widgets/constants.ts");
			const gP = {};
			var OP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gP,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case re.b:
						case ce.c:
						case ue.i:
						case ae.b:
						case Ge.b: {
							const {
								structuredStyles: n
							} = t.payload;
							if (!(n && n.data && n.data.content)) return e;
							const r = n.data.content.widgets.items,
								s = n.data.content.widgets.layout.topbar.order.filter(e => r[e] && "menu" === r[e].kind);
							if (!s.length) return e;
							const o = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== o.length) return e;
							const i = o[0];
							return Object.assign({}, e, {
								[i]: s[0]
							})
						}
						case fP.g: {
							const n = t.payload;
							return "menu" !== n.widget.kind ? e : Object.assign({}, e, {
								[n.subredditId]: n.widgetId
							})
						}
						case fP.h: {
							const n = t.payload;
							return e[n.subredditId] === n.widgetId ? Object.assign({}, e, {
								[n.subredditId]: null
							}) : e
						}
						default:
							return e
					}
				},
				hP = n("./src/reddit/models/Widgets/index.ts");
			const yP = {};
			var jP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yP,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.b: {
						const n = t.payload,
							r = n.structuredStyles && n.structuredStyles.data && n.structuredStyles.data.content;
						if (!r) return e;
						const s = r.widgets;
						return Object.assign({}, e, s.items)
					}
					case fP.b: {
						const n = t.payload;
						return Object.assign({}, e, n.widgets.items)
					}
					case h.k: {
						const t = Object.assign({}, e);
						return Object.keys(t).forEach(e => {
							t[e] = Object.assign({}, t[e], {
								styles: Object(hP.m)()
							})
						}), t
					}
					case fP.e: {
						const n = t.payload;
						return Object.assign({}, e, n.widgets.items)
					}
					case fP.i:
					case fP.g: {
						const n = t.payload;
						return Object.assign({}, e, {
							[n.widget.id]: n.widget
						})
					}
					case fP.h: {
						const n = t.payload,
							r = Object.assign({}, e);
						return delete r[n.widgetId], r
					}
					case Fe.b:
					case re.b:
					case ae.b:
					case ue.i:
					case ce.c:
					case Ge.b:
					case Co.a: {
						const {
							structuredStyles: n
						} = t.payload;
						if (!(n && n.data && n.data.content)) return e;
						const r = n.data.content.widgets;
						return Object.assign({}, e, r.items)
					}
					case vm.h: {
						const {
							userIsSubscriber: n,
							nameIdentifiers: r,
							widgetId: s
						} = t.payload;
						if (!s || !e[s] || "community-list" !== e[s].kind) return Object.assign({}, e);
						const o = n,
							i = e[s],
							c = i.data.map(e => {
								const t = Object.assign({}, e);
								return r.some(e => e.name === t.name) && (t.isSubscribed = o), t
							});
						return Object.assign({}, e, {
							[s]: Object.assign({}, i, {
								data: c
							})
						})
					}
					case xv.d: {
						const {
							settings: n,
							idCardWidgetId: r
						} = t.payload;
						return r && e[r] && "publicDescription" in n && n.publicDescription !== e[r].description ? Object.assign({}, e, {
							[r]: Object.assign({}, e[r], {
								description: n.publicDescription || ""
							})
						}) : e
					}
					default:
						return e
				}
			};
			const _P = {};
			var EP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _P,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.b:
					case re.b:
					case ue.i:
					case Ge.b: {
						const {
							structuredStyles: n
						} = t.payload;
						if (!(n && n.data && n.data.content)) return e;
						const r = n.data.content.widgets.layout.moderatorWidget,
							s = Object.keys(t.payload.subredditAboutInfo || {});
						if (1 !== s.length) return e;
						const o = s[0];
						return Object.assign({}, e, {
							[o]: r
						})
					}
					default:
						return e
				}
			};
			const vP = {};
			var IP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vP,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.b:
						case Ge.b:
						case Co.a: {
							const n = t.payload,
								r = n.structuredStyles && n.structuredStyles.data && n.structuredStyles.data.content;
							if (!r) return e;
							const s = Object.keys(n.subredditAboutInfo || {});
							if (1 !== s.length) return e;
							const o = s[0],
								i = r.widgets.layout.sidebar.order;
							return Object.assign({}, e, {
								[o]: i
							})
						}
						case fP.e:
						case fP.b: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.subredditId]: n.widgets.layout.sidebar.order
							})
						}
						case fP.f: {
							const n = t.payload;
							return Object.assign({}, e, {
								[n.subredditId]: n.widgetIds
							})
						}
						case fP.g: {
							const n = t.payload;
							if ("menu" === n.widget.kind) return e;
							if (!e[n.subredditId]) return Object.assign({}, e, {
								[n.subredditId]: [n.widgetId]
							});
							const r = e[n.subredditId].concat(n.widgetId);
							return Object.assign({}, e, {
								[n.subredditId]: r
							})
						}
						case fP.h: {
							const n = t.payload;
							if (!e[n.subredditId]) return e;
							const r = e[n.subredditId].filter(e => e !== n.widgetId);
							return Object.assign({}, e, {
								[n.subredditId]: r
							})
						}
						case Fe.b:
						case re.b:
						case ae.b:
						case ce.c:
						case ue.i:
						case Ge.b:
						case Co.a: {
							const {
								structuredStyles: n
							} = t.payload;
							if (!(n && n.data && n.data.content)) return e;
							const r = n.data.content.widgets.layout.sidebar.order,
								s = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== s.length) return e;
							const o = s[0];
							return Object.assign({}, e, {
								[o]: r
							})
						}
						default:
							return e
					}
				},
				SP = Object(r.c)({
					idCardIds: mP,
					menuIds: OP,
					models: jP,
					moderatorIds: EP,
					sidebar: IP
				});
			t.a = Object(r.c)({
				accountManagerModalData: i,
				activeModalId: j,
				ads: S,
				apiRequestState: C,
				approvedSubmitters: J,
				authorFlair: ge,
				awards: nt,
				badges: gt,
				banned: Lt,
				blockedRedditors: Ht,
				blockUser: Xt,
				brandSafety: en,
				categories: Pn,
				chat: Qn,
				claimGold: sr,
				comments: Jr,
				commentsListTruncated: Xr,
				commentsPage: vs,
				communityFlairs: Ts,
				contentGate: Ps,
				continueThreads: As,
				creations: ki,
				dashboard: Mi,
				discoveryUnits: Yi,
				dismissedTruncationList: Qi,
				economics: Oc,
				emojis: xc,
				experimentOverrides: Rc,
				externalAccount: ca,
				featureFlags: ma,
				flairedUsers: wa,
				focusedVerticals: Ba,
				fontFiles: qa,
				gild: rd,
				goldPurchase: qd,
				header: Yd,
				imageUploads: Qd,
				isEmailVerificationTooltipShowing: Zd,
				isModeratorWithPostPerms: eu,
				jsApi: ru,
				layers: au,
				leaderboard: _u,
				listings: cl,
				live: ul,
				mediaPlayback: ml,
				meta: Ol,
				moderatingSubreddits: yl,
				moderationLog: kl,
				moderators: jb,
				modListingPage: xb,
				modModeEnabled: Cb,
				modQueue: wp,
				moreComments: Up,
				multireddits: wm,
				muted: zm,
				notificationBannerId: Qm,
				nps: $m,
				oldSiteRules: nf,
				page: cf,
				platform: pf,
				postCollection: Hf,
				postRequirements: ig,
				polls: Rf,
				postFlair: Qf,
				posts: LO,
				postStickiedComments: BO,
				givePremium: ad,
				products: th,
				profileCommentsPage: gh,
				profilePrivatePage: fy,
				profileModSettingsPage: jh,
				profileOverviewPage: ry,
				profilePostsPage: oy,
				profiles: Jy,
				promos: ej,
				publicAccessNetwork: Rj,
				recommendations: kj,
				removalReasons: Kj,
				reportFlow: n_,
				reportPage: b_,
				reportRules: f_,
				requestHost: g_,
				runTimeEnvVars: y_,
				search: D_,
				searchDiscoveryUnits: F_,
				seo: H_,
				shortcuts: eE,
				sidebarPromotedPosts: rE,
				streaming: cE,
				structuredStyles: TE,
				stylesheets: xE,
				subredditAutocomplete: LE,
				subredditChannels: zE,
				subreddits: iT,
				subredditDifficulty: XE,
				subredditStickyPosts: dT,
				subscriptions: wT,
				tabBadged: DT,
				tags: $T,
				themes: ox,
				toaster: ax,
				tooltipId: ux,
				topics: px,
				tracking: Ox,
				trafficStats: _x,
				transfers: wx,
				trending: Ax,
				trophies: Nx,
				uploads: Ux,
				user: qw,
				userDataRequestPage: Jw,
				userFlair: Xw,
				users: bP,
				widgets: SP
			})
		},
		"./src/reddit/reducers/sidebarPromotedPosts/models/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var r, s = n("./src/reddit/actions/ads/constants.ts");
			! function(e) {
				e[e.FRONTPAGE = 0] = "FRONTPAGE", e[e.COMMENTS_OVERLAY = 1] = "COMMENTS_OVERLAY", e[e.COMMENTS = 2] = "COMMENTS", e[e.SUBREDDIT = 3] = "SUBREDDIT", e[e.MULTIREDDIT = 4] = "MULTIREDDIT", e[e.SEARCH_RESULTS = 5] = "SEARCH_RESULTS"
			}(r || (r = {}));
			const o = {};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.f:
					case s.d: {
						const n = t.payload;
						return Object.assign({}, e, n)
					}
					case s.e:
					case s.f:
						return e;
					case s.h:
						return o;
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./node_modules/lodash/uniqWith.js"),
				o = n.n(s),
				i = n("./node_modules/lodash/values.js"),
				c = n.n(i),
				a = n("./src/reddit/actions/tags/constants.ts"),
				d = n("./src/reddit/models/Option/index.ts"),
				u = n("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(r || (r = {}));
			const l = {
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.m: {
						const {
							subredditId: n,
							itemTags: r,
							suggestedItemTags: s
						} = t.payload, i = o()([...(e.selectedOptions[n] || []).map(e => {
							if (!e.id) {
								const t = c()(r[n] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return Object.assign({}, Object(u.d)(t, !0), {
									action: null
								})
							}
							return e
						}), ...c()(r[n] || {}).map(e => Object.assign({}, Object(u.d)(e, !0), {
							action: null
						}))], d.a);
						return Object.assign({}, e, {
							selectedOptions: Object.assign({}, e.selectedOptions, {
								[n]: i.map(e => Object.assign({}, e, {
									action: e.id ? null : e.action
								}))
							}),
							selectedSuggestedOptions: Object.assign({}, e.selectedSuggestedOptions, {
								[n]: c()(s[n] || {}).map(e => Object.assign({}, Object(u.d)(e, !0), {
									action: null
								}))
							}),
							deselectedOptions: Object.assign({}, e.deselectedOptions, {
								[n]: []
							})
						})
					}
					case a.y:
					case a.u: {
						const {
							subredditId: n,
							option: s
						} = t.payload, i = t.type === a.u ? "selectedOptions" : "selectedSuggestedOptions", c = t.type === a.u ? "deselectedOptions" : "deselectedSuggestedOptions", u = (e[c][n] || []).slice(), l = u.findIndex(e => Object(d.a)(e, s));
						let b = r.ADD;
						return l > -1 && (b = null, u.splice(l, 1)), Object.assign({}, e, {
							[i]: Object.assign({}, e[i], {
								[n]: o()([...e[i][n] || [], Object.assign({}, s, {
									action: b
								})], d.a)
							}),
							[c]: Object.assign({}, e[c], {
								[n]: u
							})
						})
					}
					case a.x:
					case a.t: {
						const {
							subredditId: n,
							option: s
						} = t.payload, o = t.type === a.t ? "selectedOptions" : "selectedSuggestedOptions", i = t.type === a.t ? "deselectedOptions" : "deselectedSuggestedOptions", c = (e[i][n] || []).slice(), u = (e[o][n] || []).slice(), l = u.findIndex(e => Object(d.a)(e, s));
						return l > -1 && (null === u[l].action && c.push(Object.assign({}, u[l], {
							action: r.REMOVE
						})), u.splice(l, 1)), Object.assign({}, e, {
							[o]: Object.assign({}, e[o], {
								[n]: u
							}),
							[i]: Object.assign({}, e[i], {
								[n]: c
							})
						})
					}
					case a.v: {
						const {
							itemTagsState: n
						} = t.payload, r = Object.keys(n);
						if (!r.length) return e;
						const s = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							o = r.reduce((e, t) => (e.selectedOptions[t] = c()(n[t]).map(e => Object.assign({}, Object(u.d)(e, !0), {
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), s);
						return Object.assign({}, e, {
							inputByItemId: Object.assign({}, e.inputByItemId, o.inputByItemId),
							selectedOptions: Object.assign({}, e.selectedOptions, o.selectedOptions),
							deselectedOptions: Object.assign({}, e.deselectedOptions, o.deselectedOptions)
						})
					}
					case a.w:
					case a.s: {
						const {
							subredditId: n,
							input: r
						} = t.payload, s = t.type === a.s ? "inputByItemId" : "suggestedInputByItemId";
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], {
								[n]: r
							})
						})
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/user/prefs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r, s = n("./node_modules/lodash/isEqual.js"),
				o = n.n(s),
				i = n("./node_modules/lodash/merge.js"),
				c = n.n(i),
				a = n("./node_modules/lodash/pick.js"),
				d = n.n(a),
				u = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/comment/index.ts"),
				b = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/frontpage.ts"),
				m = n("./src/reddit/actions/header.ts"),
				f = n("./src/reddit/actions/modQueue/constants.ts"),
				g = n("./src/reddit/actions/page.ts"),
				O = n("./src/reddit/actions/pages/collectionCommentsPage.ts"),
				h = n("./src/reddit/actions/pages/modListing/constants.ts"),
				y = n("./src/reddit/actions/pages/postCreation.ts"),
				j = n("./src/reddit/actions/pages/postDraft.ts"),
				_ = n("./src/reddit/actions/pages/profileComments.ts"),
				E = n("./src/reddit/actions/pages/profileOverview.ts"),
				v = n("./src/reddit/actions/pages/profilePosts.ts"),
				I = n("./src/reddit/actions/pages/search.ts"),
				S = n("./src/reddit/actions/pages/subreddit.ts"),
				T = n("./src/reddit/actions/postCreation/constants.ts"),
				x = n("./src/reddit/actions/postDraft.ts"),
				C = n("./src/reddit/actions/preferences.ts"),
				w = n("./src/reddit/actions/redditEmbed.ts"),
				P = n("./src/reddit/actions/search.ts"),
				D = n("./src/reddit/actions/structuredStyles/constants.ts"),
				R = n("./src/reddit/actions/subreddit.ts"),
				A = n("./src/reddit/actions/users.ts"),
				k = n("./src/reddit/constants/postLayout.ts"),
				N = n("./src/reddit/constants/preferences.ts"),
				L = n("./src/reddit/constants/theme.ts"),
				M = n("./src/reddit/models/PostCreationForm/index.ts"),
				U = n("./src/reddit/models/PostDraft/index.ts"),
				F = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e.Whitelisted = "whitelisted", e.Everyone = "everyone"
			}(r || (r = {}));
			const B = ["acceptPrivateMessages", "allowClickTracking", "autoplayVideo", "collapseReadMessages", "defaultCommentSort", "emailDigests", "emailUnreadMessages", "emailUnsubscribe", "geopopular", "hideAds", "hideFromRobots", "hideNSFW", "highlightComments", "ignoreSuggestedSort", "inBeta", "labelNSFW", "markMessagesRead", "nightmode", "over18", "sendWelcomeMessages", "showMessagesInInbox", "showNotifications", "showTwitter", "showUsernameMentionNotifications", "showActiveCommunities", ...N.a, "loginOtpEnabled"],
				G = {
					acceptPrivateMessages: void 0,
					activityRelevantAds: !0,
					allowClickTracking: !1,
					autoplayVideo: !0,
					collapsedTraySections: F.a,
					commentMode: M.h.RICH_TEXT,
					layout: k.d.Card,
					rememberCommunityLayout: !1,
					defaultCommentSort: u.q.CONFIDENCE,
					editorMode: M.h.RICH_TEXT,
					featuresViewedHistory: F.b,
					geopopular: void 0,
					globalTheme: L.a,
					hamburgerTray: void 0,
					hasSeenCustomizeFlyout: !0,
					hideNSFW: !0,
					ignoreSuggestedSort: !1,
					labelNSFW: !0,
					loginOtpEnabled: !1,
					markMessagesRead: !0,
					nightmode: !1,
					openPostInNewTab: !1,
					over18: !1,
					profileLayout: void 0,
					rpanDuDismissalTime: void 0,
					showActiveCommunities: !0,
					showRpanDu: !0,
					showTwitter: !1,
					sort: u.P.Hot,
					stylesEnabled: !0,
					subreddit: {},
					subscriptionsPinned: void 0,
					thirdPartyDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedContent: !0,
					topContentDismissalTime: 0,
					topContentTimesDismissed: 0,
					rememberCommunitySort: !1,
					useMarkdown: !1
				},
				V = {
					isContributorRequestTimestamp: 0,
					stylesEnabled: !0,
					layout: void 0,
					sort: void 0
				},
				q = (e, t) => {
					if (!t) return e;
					const n = d()(Object.assign({}, t.account, t), B),
						r = t.subreddit,
						s = Object.assign({}, e.subreddit);
					Object.keys(r || {}).forEach(e => {
						s[e] = Object.assign({}, V, r && r[e])
					});
					const i = Object.assign({}, e, n, {
						subreddit: s
					});
					if (i.useMarkdown !== e.useMarkdown) {
						const e = i.useMarkdown ? M.h.MARKDOWN : M.h.RICH_TEXT;
						i.editorMode = e, i.commentMode = e
					}
					return o()(i, e) ? e : i
				},
				H = (e, t, n) => q(e, {
					subreddit: {
						[t]: Object.assign({}, V, e.subreddit[t], n)
					}
				});
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.l:
					case l.s: {
						const {
							editorMode: n
						} = t.payload;
						return Object.assign({}, e, {
							commentMode: n
						})
					}
					case T.t:
					case T.O: {
						const {
							editorMode: n
						} = t.payload;
						return Object.assign({}, e, {
							editorMode: n
						})
					}
					case m.d:
						return Object.assign({}, e, {
							subscriptionsPinned: !0
						});
					case m.e:
						return Object.assign({}, e, {
							subscriptionsPinned: !1
						});
					case x.g: {
						const {
							kind: n
						} = t.payload;
						return Object.assign({}, e, {
							editorMode: n === U.b.Markdown ? M.h.MARKDOWN : M.h.RICH_TEXT
						})
					}
					case C.g: {
						const {
							layout: n
						} = t.payload;
						return e.layout === n ? e : Object.assign({}, e, {
							layout: n
						})
					}
					case C.n:
						return void 0 !== t.payload ? Object.assign({}, e, {
							rpanDuDismissalTime: t.payload
						}) : e;
					case C.o: {
						const {
							layout: n,
							subredditId: r
						} = t.payload;
						return H(e, r, {
							layout: n
						})
					}
					case C.e:
						return Object.assign({}, e, {
							hasSeenCustomizeFlyout: !0
						});
					case C.l:
						return e.profileLayout === t.payload.profileLayout ? e : Object.assign({}, e, {
							profileLayout: t.payload.profileLayout
						});
					case b.f:
						return Object.assign({}, e, {
							over18: !0
						});
					case C.b:
						return void 0 !== t.payload ? Object.assign({}, e, {
							autoplayVideo: t.payload.autoplayVideo
						}) : e;
					case C.h:
						return void 0 !== t.payload ? Object.assign({}, e, {
							nightmode: t.payload.nightmode
						}) : e;
					case C.q:
						if (void 0 !== t.payload) {
							const {
								topContentDismissalTime: n,
								topContentTimesDismissed: r
							} = t.payload;
							return Object.assign({}, e, {
								topContentDismissalTime: n,
								topContentTimesDismissed: r
							})
						}
						return e;
					case D.d:
						return t.payload.isNightmodeOn ? Object.assign({}, e, {
							nightmode: !1,
							nightmodeTempUpdated: !0
						}) : e;
					case D.e:
						return t.payload.nightmodeTempUpdated ? Object.assign({}, e, {
							nightmode: !0,
							nightmodeTempUpdated: !1
						}) : e;
					case C.f:
						return void 0 !== t.payload ? Object.assign({}, e, {
							hamburgerTray: t.payload.set
						}) : Object.assign({}, e, {
							hamburgerTray: !e.hamburgerTray
						});
					case C.c:
						return void 0 !== t.payload ? Object.assign({}, e, {
							collapsedTraySections: c()({}, e.collapsedTraySections, t.payload)
						}) : e;
					case A.a:
					case A.b:
						return Object.assign({}, e, {
							featuresViewedHistory: c()({}, e.featuresViewedHistory, t.payload)
						});
					case b.a:
					case b.b:
					case b.g:
					case b.e:
					case b.h:
					case h.e:
					case h.h:
					case O.a:
					case g.a:
					case O.b:
					case g.b:
					case O.d:
					case g.d:
					case g.g:
					case S.b:
					case g.l:
					case g.k:
					case _.e:
					case E.e:
					case E.b:
					case v.e:
					case p.b:
					case R.i:
					case P.c:
					case w.b:
					case y.b:
					case j.a:
					case C.i:
					case I.c:
					case C.a:
					case A.e:
						return t.payload && t.payload.preferences ? q(e, t.payload.preferences) : e;
					case C.p: {
						const {
							subredditId: n,
							prefs: r
						} = t.payload;
						return H(e, n, r)
					}
					case _.d:
					case E.d:
					case E.a:
					case v.d:
						if (t.payload && t.payload.account) {
							const {
								nightmode: n
							} = t.payload.account;
							if (e.nightmode !== n) return Object.assign({}, e, {
								nightmode: n
							})
						}
						return e;
					case f.h:
					case f.j:
					case f.i:
					case f.g:
					case f.f:
					case f.n:
					case f.m:
					case f.p:
					case f.q:
					case f.w:
					case f.v:
						return t.payload && t.payload.response && t.payload.response.preferences ? q(e, t.payload.preferences) : e;
					case C.m: {
						const n = t.payload,
							{
								showActiveCommunities: r
							} = n.additional;
						return e.showActiveCommunities !== r ? Object.assign({}, e, {
							showActiveCommunities: r
						}) : e
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/routes/modListing/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			}));
			var r = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				s = n.n(r),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./node_modules/lodash/flatten.js"),
				c = n.n(i),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/actions/pages/modListing/index.ts");
			const u = Object(o.a)({
					resolved: {},
					chunkName: () => "ModListing",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~MembershipPaywallPage~ModListing~ModQueuePages~f56e25d5"), n.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModListing~ModQueuePages~Multireddit~ProfileCo~ae34fcbd"), n.e("ModListing~ModQueuePages~Multireddit~ProfilePosts~SearchResults~Topic"), n.e("ModListing~Multireddit~ProfilePosts"), n.e("ModListing~Reddit"), n.e("ModListing")]).then(n.bind(null, "./src/reddit/pages/ModListing/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/ModListing/index.tsx"
					}
				}),
				l = "/r/mod",
				b = "/me/f/mod",
				p = [l, b],
				m = c()(p.map(e => Object.keys(a.N).map(t => "".concat(e, "/:sort(").concat(a.N[t], ")?")))),
				f = e => e.startsWith(b),
				g = {
					action: d.b,
					chunk: a.o.MOD_LISTING,
					component: u,
					exact: !0,
					meta: {
						name: a.xb.MOD_LISTING
					},
					path: m,
					prefetches: [a.o.SUBREDDIT, a.o.COMMENTS_PAGE]
				};
			t.c = g
		},
		"./src/reddit/routes/postCreation/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const r = "/submit",
				s = "/r/:subredditName/submit",
				o = "/user/:profileName/submit"
		},
		"./src/reddit/routes/postCreation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var r = n("./node_modules/core-js/modules/es6.regexp.replace.js"),
				s = n.n(r),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/actions/pages/postCreation.ts"),
				a = n("./src/reddit/routes/postCreation/constants.ts");
			const d = [a.b, a.c, a.a],
				u = Object(o.a)({
					resolved: {},
					chunkName: () => "PostCreation",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PainterModalLoader~Pos~1d90e236"), n.e("vendors~EconomicsEntryPointsPostFlatlistSupportCTA~InFeedChaining~Poll~PostCreation~Reddit~Subreddit~2c16ee4a"), n.e("vendors~ChatMessageInput~FlairEdit~MembershipPaywallPage~PostCreation~RichTextEditor"), n.e("vendors~PostCreation~RichTextEditor"), n.e("vendors~PostCreation"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~Frontpage~ModQueuePages~ModerationPages~Poll~PostCreati~84248ed7"), n.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~GovernanceReleaseNotesModal~InFeedChaining~Mod~20a7252d"), n.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~PostDraft~Pr~17e24337"), n.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~ProfileComme~ccaebd21"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/pages/PostCreation/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/PostCreation/index.tsx"
					}
				}),
				l = e => a.c.replace(/:subredditName/, e),
				b = e => a.a.replace(/:profileName/, e),
				p = {
					action: c.e,
					component: u,
					chunk: i.o.POST_CREATION,
					exact: !0,
					meta: {
						name: i.xb.POST_CREATION
					},
					path: d,
					prefetches: [i.o.COMMENTS_PAGE]
				};
			t.a = p
		},
		"./src/reddit/selectors/PublicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "m", (function() {
				return p
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "p", (function() {
				return g
			})), n.d(t, "o", (function() {
				return O
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "k", (function() {
				return I
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/lib/objectSelector/index.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = n("./src/reddit/actions/publicAccessNetwork/streams.ts");
			const c = e => e.publicAccessNetwork.api.config,
				a = (e, t) => !!t && !!e.publicAccessNetwork.api.error[Object(i.k)(t)],
				d = e => a(e, o.b),
				u = (e, t) => !!t && !!e.publicAccessNetwork.api.pending[Object(i.k)(t)] && e.publicAccessNetwork.api.pending[Object(i.k)(t)].isPending,
				l = e => u(e, o.b),
				b = e => e.publicAccessNetwork.api.pending[o.b] && e.publicAccessNetwork.api.pending[o.b].fetchedUtcTimeStamp,
				p = Object(r.a)(c, e => e.global),
				m = Object(r.a)((e, t) => {
					let {
						subreddit: n
					} = t;
					return n
				}, c, (e, t) => t.subreddits[e]),
				f = Object(r.a)(c, e => e.global.rpan_intro_video_url),
				g = Object(r.a)(c, e => e.global.url_to_show_for_unavailable_video),
				O = Object(r.a)(c, e => !e.global.lastUpdated || !!e.global.rpan_intro_video_url),
				h = Object(r.a)(c, e => e.isError),
				y = Object(r.a)(c, e => e.global.max_chat_comment_length),
				j = Object(r.a)(p, e => e.dedicated_subreddit),
				_ = e => e.publicAccessNetwork.api.recommendedViewerSubreddits,
				E = (Object(r.a)(_, e => e.isError), Object(r.a)(_, e => e.isPending)),
				v = Object(s.a)(Object(r.a)(_, e => e.subreddits)),
				I = Object(r.a)(v, e => [{
					name: "All",
					prefixedName: "All",
					path: Object(i.f)()
				}, ...e.map(e => ({
					name: e,
					prefixedName: "r/".concat(e),
					path: Object(i.h)(e)
				}))])
		},
		"./src/reddit/selectors/activeModalId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = e => e.activeModalId,
				s = e => t => t.activeModalId === e
		},
		"./src/reddit/selectors/blockedRedditors.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const r = e => e.blockedRedditors.api.pending,
				s = e => e.blockedRedditors.list
		},
		"./src/reddit/selectors/brandSafety.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/isFakeSubreddit/index.ts"),
				o = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				i = n("./src/reddit/models/WhitelistStatus/index.ts"),
				c = n("./src/reddit/selectors/posts.ts"),
				a = n("./src/reddit/selectors/subreddit.ts");
			const d = new Set([r.N.NEW, r.N.RISING, r.N.CONTROVERSIAL]),
				u = e => e.brandSafety.hasBrandSafetyBeenAssessed,
				l = (e, t) => {
					let {
						postId: n
					} = t;
					const r = Object(c.I)(e, {
							postId: n
						}),
						s = Object(c.U)(e, {
							postId: n
						});
					return !(!r || !s) && (s.wls === i.a.ALL_ADS && !r.isNSFW)
				},
				b = e => e.brandSafety.isViewSafe,
				p = e => !e.brandSafety.isViewSafe,
				m = (e, t) => {
					const {
						listingName: n,
						pageLayer: r
					} = t, c = Object(a.B)(e, {
						subredditName: n
					}), u = Object(o.b)(e, {
						pageLayer: r
					});
					return (!u || !d.has(u)) && (!(c || !Object(s.a)(n)) || !!c && c.wls === i.a.ALL_ADS)
				}
		},
		"./src/reddit/selectors/category.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "p", (function() {
				return x
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "r", (function() {
				return w
			})), n.d(t, "f", (function() {
				return D
			})), n.d(t, "g", (function() {
				return R
			})), n.d(t, "l", (function() {
				return A
			})), n.d(t, "s", (function() {
				return L
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/pickBy.js"),
				s = n.n(r),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/lib/objectSelector/index.ts"),
				c = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/helpers/name/index.ts"),
				d = n("./src/reddit/models/Widgets/index.ts"),
				u = n("./src/reddit/selectors/experiments/categoriesPlacement.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			const b = [],
				p = e => e.categories.api.list.loaded,
				m = e => e.categories.api.list.pending,
				f = (e, t) => {
					let {
						id: n
					} = t;
					return n ? e.categories.api.subreddits.loaded[n] : void 0
				},
				g = (e, t) => {
					let {
						id: n
					} = t;
					return n ? e.categories.api.subreddits.pending[n] : void 0
				},
				O = (e, t) => {
					let {
						id: n
					} = t;
					return n ? e.categories.models[n] : void 0
				},
				h = e => e.categories.nameToId,
				y = (e, t) => {
					let {
						categoryName: n
					} = t;
					const r = e.categories.nameToId[Object(a.f)(n)];
					if (r) return O(e, {
						id: r
					})
				},
				j = new Set(["nba", "nfl"]),
				_ = Object(o.a)((e, t) => t.categoriesOrder || c.bb, (e, t) => t.excludedCategories || j, e => e.categories.ids, e => e.categories.models, (e, t, n, r) => {
					const s = {};
					let o = 1e3;
					const i = [];
					for (const c of n) {
						const n = r[c];
						t.has(Object(a.f)(n.name)) || (e[n.name] || (s[n.name] = o++), i.push(n))
					}
					return i.sort((t, n) => {
						return (e[t.name] || s[t.name]) - (e[n.name] || s[n.name])
					})
				}),
				E = (e, t) => {
					let {
						categoryName: n
					} = t;
					const r = y(e, {
						categoryName: n
					});
					return r && e.subreddits.byCategory[r.id] || b
				},
				v = Object(o.a)((e, t) => {
					let {
						id: n
					} = t;
					if (!n) return b;
					return e.subreddits.byCategory[n] || b
				}, l.Y, e => e.subreddits.about, (e, t, n) => e.map(e => Object(d.i)(t[e], n[e]))),
				I = () => Object(i.a)(Object(o.a)(E, l.Y, l.z, (e, t, n) => e.map(e => Object(d.i)(t[e], n[e])))),
				S = Object(o.a)(E, l.Y, (e, t) => 0 === e.length ? b : e.map(e => t[e])),
				T = () => Object(i.a)(Object(o.a)(E, l.Y, (e, t) => 0 === e.length ? b : e.map(e => {
					const n = t[e];
					return n ? n.name : ""
				}).filter(Boolean))),
				x = Object(o.a)((e, t) => e.listings.listingOrder.ids[t.listingKey] || b, e => e.categories.models, (e, t) => e.map(e => t[e])),
				C = Object(i.a)(Object(o.a)((e, t) => e.listings.listingOrder.ids[t.listingKey] || b, e => e.subreddits.models, (e, t) => e.map(e => t[e]))),
				w = (e, t) => {
					const n = t ? e.posts.models[t] : null;
					return n && n.postCategories ? n.postCategories : null
				},
				P = Object(o.a)(e => e.subreddits.byCategory, l.Y, (e, t) => Object.keys(e).reduce((n, r) => {
					const s = e[r];
					if (!s || 0 === s.length) return n;
					for (const e of s) {
						const s = t[e];
						if (s) {
							const e = Object(a.f)(s.name);
							n[e] || (n[e] = []), n[e].push(Object(a.f)(r))
						}
					}
					return n
				}, {})),
				D = Object(o.a)((e, t) => t.subredditName, P, (e, t) => t[Object(a.f)(e)] || b),
				R = e => e.categories.ranking,
				A = (e, t) => {
					let {
						id: n
					} = t;
					return n && e.categories.ranking[n] || 0
				},
				k = Object(o.a)(_, R, (e, t) => {
					const n = s()(t, e => e >= 3);
					return 0 === Object.keys(n).length ? e : [...e].sort((e, t) => {
						const r = n[e.id] || 0;
						return (n[t.id] || 0) - r
					})
				}),
				N = Object(o.a)(() => Object(u.b)(), e => {
					if (!e) return j;
					const t = new Set(j);
					return t.delete(e.name), t
				}),
				L = (e, t) => {
					const n = N(e);
					return k(e, Object.assign({}, t, {
						excludedCategories: n
					}))
				}
		},
		"./src/reddit/selectors/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var r = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				s = n("./src/reddit/selectors/moderatorPermissions.ts"),
				o = n("./src/reddit/selectors/platform.ts");
			const i = e => e.chat.unread.count,
				c = e => {
					return i(e).basicChannelCount
				},
				a = e => e.chat.promos,
				d = e => !!e.chat.isUserSubredditChatEnabled,
				u = e => !(e.chat.isInited || e.chat.unread.api.pending),
				l = (e, t) => {
					const {
						chatConfig: n
					} = r.c;
					return Object(s.a)(n)(e, t)
				},
				b = e => {
					const t = Object(o.d)(e);
					if (e.chat.subredditSettings.subredditId === t) return e.chat.subredditSettings
				}
		},
		"./src/reddit/selectors/claimgold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = e => e.claimGold.code,
				s = e => e.claimGold.showModal
		},
		"./src/reddit/selectors/comments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "v", (function() {
				return m
			})), n.d(t, "x", (function() {
				return f
			})), n.d(t, "y", (function() {
				return g
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "F", (function() {
				return j
			})), n.d(t, "o", (function() {
				return _
			})), n.d(t, "p", (function() {
				return E
			})), n.d(t, "j", (function() {
				return v
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "n", (function() {
				return S
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "r", (function() {
				return w
			})), n.d(t, "m", (function() {
				return P
			})), n.d(t, "u", (function() {
				return D
			})), n.d(t, "z", (function() {
				return R
			})), n.d(t, "H", (function() {
				return A
			})), n.d(t, "t", (function() {
				return k
			})), n.d(t, "B", (function() {
				return N
			})), n.d(t, "C", (function() {
				return L
			})), n.d(t, "D", (function() {
				return M
			})), n.d(t, "s", (function() {
				return U
			})), n.d(t, "e", (function() {
				return F
			})), n.d(t, "w", (function() {
				return B
			})), n.d(t, "I", (function() {
				return G
			})), n.d(t, "f", (function() {
				return V
			})), n.d(t, "i", (function() {
				return q
			})), n.d(t, "E", (function() {
				return H
			})), n.d(t, "A", (function() {
				return K
			})), n.d(t, "G", (function() {
				return W
			})), n.d(t, "q", (function() {
				return Y
			})), n.d(t, "J", (function() {
				return z
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/values.js"),
				s = n.n(r),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeCommentPermalink/index.ts"),
				c = n("./src/lib/objectSelector/index.ts"),
				a = n("./src/reddit/constants/comments.ts"),
				d = n("./src/reddit/models/Post/index.ts"),
				u = n("./src/reddit/selectors/posts.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			const b = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.commentsPage.api.error[n]
				},
				p = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.commentsPage.api.pending[n]
				},
				m = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.commentsPage.api.fullyLoaded[n]
				},
				f = (e, t) => e.commentsPage.keyToHeadCommentId[t.commentsPageKey],
				g = (e, t) => {
					const n = f(e, t);
					if (n) return S(e, {
						commentId: n
					})
				},
				O = [],
				h = Object(c.a)((e, t) => {
					const n = g(e, t),
						r = n && n.id;
					if (!r) return O;
					const {
						commentsPageKey: s
					} = t, o = e.commentsPage.keyToCommentThreadLinkSets[s], i = [];
					let c = {
						id: r,
						type: a.a.Comment
					};
					do {
						i.push(c), c = o[c.id].next
					} while (c);
					return i
				}),
				y = (e, t) => f(e, t) ? e.commentsPage.keyToChatCommentLinks[t.commentsPageKey] : [],
				j = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const r = e.commentsPage.keyToPostId[n];
					return r ? e.posts.models[r] : null
				},
				_ = (e, t) => {
					let {
						commentId: n,
						commentLink: r,
						commentsPageKey: s
					} = t;
					const o = e.commentsPage.keyToCommentThreadLinkSets[s];
					return o ? r ? o[r.id] : n ? o[n] : null : null
				},
				E = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.commentsPage.keyToCommentThreadLinkSets[n]
				},
				v = (e, t) => {
					const n = t.commentsPageKey ? _(e, t) : null;
					return n ? n.depth : null
				},
				I = (e, t) => {
					let {
						commentLink: n
					} = t;
					const {
						id: r,
						type: s
					} = n;
					switch (s) {
						case a.a.Comment:
							return e.comments.models[r];
						case a.a.MoreComments:
							return e.moreComments.models[r];
						case a.a.ContinueThread:
							return e.continueThreads.models[r];
						default:
							return null
					}
				},
				S = (e, t) => {
					let {
						commentId: n
					} = t;
					return n ? e.comments.models[n] : void 0
				},
				T = (e, t) => {
					if (e.platform.currentPage && e.platform.currentPage.urlParams && e.platform.currentPage.urlParams.partialPostId) {
						const {
							partialPostId: t
						} = e.platform.currentPage.urlParams, n = Object(d.m)(t);
						return Array.from(new Set(Object.keys(e.comments.models).filter(t => e.comments.models[t].postId === n && e.comments.models[t].author !== o.z).map(t => e.comments.models[t].author)))
					}
					return []
				},
				x = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.comments.collapsed[n]
				},
				C = e => e.moreComments.models,
				w = e => e.comments.models,
				P = (e, t) => {
					let {
						commentId: n
					} = t;
					const r = S(e, {
						commentId: n
					});
					return r ? Object(i.a)(Object(u.H)(e, r), n) : ""
				},
				D = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!(n && e.comments.focused && e.comments.focused[n])
				},
				R = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: r
					} = t;
					return !!(n && e.comments.isEditing[r] && e.comments.isEditing[r][n])
				},
				A = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: r
					} = t;
					return !!(n && e.comments.replyFormOpen[r] && e.comments.replyFormOpen[r][n])
				},
				k = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const r = n && e.comments.replyFormOpen[n] || {},
						s = Object.keys(r).find(e => r[e]),
						o = S(e, {
							commentId: s
						}),
						i = o && v(e, {
							commentId: o.id,
							commentLink: void 0,
							commentsPageKey: n
						});
					if (o && "number" == typeof i) return Object.assign({}, o, {
						depth: i
					})
				},
				N = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return e.moreComments.models[n]
				},
				L = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return !!e.moreComments.api.pending[n]
				},
				M = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const r = e.commentsPage.keyToPostId[n];
					if (r) {
						const t = s()(e.moreComments.models).find(t => t.postId === r && 0 === t.depth && !(void 0 !== e.moreComments.api.pending[t.id]));
						if (t) return {
							moreCommentId: t.id,
							pending: !!e.moreComments.api.pending[t.id]
						}
					}
					return null
				},
				U = (e, t) => {
					let {
						id: n
					} = t;
					return e.continueThreads.models[n]
				},
				F = (e, t) => {
					let {
						commentId: n
					} = t;
					const r = n ? e.comments.models[n] : void 0;
					if (!r) return null;
					const s = e.authorFlair.models[r.subredditId];
					return s ? s[r.author] : null
				},
				B = (e, t) => {
					let {
						draftKey: n
					} = t;
					return !!e.comments.submit.error[n]
				},
				G = (e, t) => {
					let {
						draftKey: n
					} = t;
					const r = e.comments.submit.error[n];
					return r && r.fields ? r.fields.map(e => e.msg) : []
				},
				V = (e, t) => {
					let {
						draftKey: n
					} = t;
					const r = e.comments.drafts[n];
					return !!r && r.autofocusDisabled
				},
				q = (e, t) => {
					let {
						draftKey: n
					} = t;
					return e.comments.drafts[n]
				},
				H = (e, t) => {
					let {
						commentId: n
					} = t;
					const r = n ? e.comments.submit.error[n] : void 0;
					return r && r.fields ? r.fields.map(e => e.msg) : void 0
				},
				K = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.comments.submit.pending[n]
				},
				W = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.comments.models[n].sendReplies
				},
				Y = e => e.comments.visitHighlightFilter,
				z = (e, t) => {
					const n = S(e, t);
					if (n) return Object(l.X)(e, n)
				}
		},
		"./src/reddit/selectors/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			}));
			var r = n("./src/lib/objectSelector/index.ts");
			const s = e => e.awards.create.api.pending,
				o = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.awards.manageable.order[n];
					return r ? r.map(t => e.awards.models[t]).filter(e => e.isEnabled) : []
				}),
				i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.awards.manageable.api.pending[n]
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.awards.blacklist[n]
				},
				a = (e, t) => e.awards.models[t],
				d = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.awards.usable.order[n];
					return r ? r.map(t => e.awards.models[t]).filter(e => e.isEnabled) : []
				}),
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.awards.usable.api.pending[n]
				}
		},
		"./src/reddit/selectors/communityFlairs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			}));
			var r = n("./node_modules/reselect/es/index.js");
			const s = (e, t) => {
					const n = e.communityFlairs[t];
					return n && n.sortedKeys
				},
				o = Object(r.a)(s, e => e),
				i = (e, t) => {
					const n = e.communityFlairs[t];
					return n && n.models
				},
				c = Object(r.a)(i, e => e),
				a = (Object(r.a)((e, t) => i(e, t), (e, t) => s(e, t), (e, t) => {
					if (t && e) return t.map(t => e[t])
				}), (e, t) => e.communityFlairs.hasOwnProperty(t))
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return m
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "j", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/lib/makeListingKey/index.ts"),
				o = n("./src/lib/objectSelector/index.ts"),
				i = n("./src/reddit/helpers/name/index.ts"),
				c = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				a = n("./src/reddit/selectors/category.ts"),
				d = n("./src/reddit/selectors/experiments/exploreV2.ts"),
				u = n("./src/reddit/selectors/listings.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/subreddit.ts");
			const p = [],
				m = e => e.discoveryUnits.api.list.loaded,
				f = e => e.discoveryUnits.api.list.pending,
				g = (e, t) => {
					let {
						unitName: n
					} = t;
					const r = e.discoveryUnits.nameToId[Object(i.f)(n)];
					return e.discoveryUnits.models[r]
				},
				O = () => Object(o.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = Object(l.L)(e);
					return Object(l.C)(e, {
						listingKey: n
					}).filter(e => {
						const t = r[e];
						return t && !t.isStickied && !t.isSponsored
					})
				}),
				h = () => Object(o.a)((e, t) => {
					let n, {
						categoryName: o,
						id: i,
						unitName: c
					} = t;
					if (o && !(n = Object(a.h)(e, {
							categoryName: o
						}))) return p;
					const d = i || n && n.id,
						u = Object(s.a)(c, r.N.HOT, {
							category: d
						});
					return O()(e, {
						listingKey: u
					})
				}),
				y = () => Object(o.a)((e, t) => {
					let {
						listingKey: n,
						unitName: o,
						subredditName: i
					} = t;
					if (!Object(b.B)(e, {
							subredditName: i
						})) return p;
					const c = n || Object(s.a)(o, r.N.HOT, {
						subredditName: i
					});
					return O()(e, {
						listingKey: c
					})
				}),
				j = e => {
					if (Object(d.a)(e)) return g(e, {
						unitName: c.i
					})
				},
				_ = e => {
					if (Object(d.a)(e)) return g(e, {
						unitName: c.k
					})
				},
				E = (e, t) => {
					let {
						listingKey: n,
						shouldLoadMore: r
					} = t;
					const s = Object(u.j)(e, {
							listingKey: n
						}),
						o = s ? s.token : void 0,
						i = Object(u.h)(e, {
							listingKey: n
						});
					if (s) {
						if (!r) return; {
							const t = Object(u.i)(e, {
								listingKey: n,
								token: s.token
							});
							if (i || t) return
						}
					} else {
						const t = Object(u.f)(e, {
							listingKey: n
						});
						if (i || t) return
					}
					return {
						fetchedToken: o
					}
				},
				v = e => g(e, {
					unitName: c.c
				}),
				I = new Set(["sequence"]),
				S = e => {
					const t = e.platform.currentPage;
					if (t) {
						const {
							meta: e,
							urlParams: n
						} = t, r = e && e.name || "", s = n && n.subredditName || "", o = "subreddit" === r, i = I.has(s.toLowerCase());
						return o && i
					}
					return !1
				}
		},
		"./src/reddit/selectors/dismissedTruncationList.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return c
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/selectors/experiments/listingBelowAll.ts");
			const o = e => e.dismissedTruncationList,
				i = Object(r.a)((e, t) => {
					let {
						subredditOrProfile: n
					} = t;
					return n
				}, o, (e, t) => {
					const n = e && e.id;
					return !!n && t.includes(n)
				}),
				c = (e, t) => {
					const n = Object(s.b)(e);
					if (!Object(s.a)(n)) return !1;
					const r = o(e);
					return !(t && r.includes(t))
				}
		},
		"./src/reddit/selectors/emailCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/helpers/localStorage/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = Object(r.a)(o.K, o.l, o.x, (e, t, n) => e && !t && !n),
				c = e => (() => 0 === Object(s.i)())() && i(e)
		},
		"./src/reddit/selectors/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "a", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/values.js"),
				s = n.n(r),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/models/Flair/index.ts"),
				c = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/selectors/subreddit.ts");
			const d = [],
				u = e => e.emojis.models,
				l = Object(o.a)(u, (e, t) => t.subredditId, (e, t) => {
					const n = e[t];
					return n ? [...s()(n.emojis), ...s()(n.snoomojis)] : d
				}),
				b = Object(o.a)(l, c.g, (e, t) => t.isFlairModOnly, (e, t) => t.flairTemplateType, (e, t, n, r) => e.filter(e => !(e.modFlairOnly && !t || e.modFlairOnly && !n) && (!(!e.userFlairAllowed && r === i.d.UserFlair) && !(!e.postFlairAllowed && r === i.d.LinkFlair)))),
				p = Object(o.a)(u, (e, t) => t.subredditId, (e, t) => Object.keys(e[t].snoomojis)),
				m = (e, t) => Object(a.y)(e, {
					subredditName: t
				}).emojisEnabled,
				f = {
					emojis: {},
					snoomojis: {}
				},
				g = (e, t) => {
					let {
						subredditId: n
					} = t;
					return u(e)[n] || f
				},
				O = (e, t) => !!e.emojis.api.list.pending[t]
		},
		"./src/reddit/selectors/experiments/categoriesPlacement.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return g
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "b", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/once.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/values.js"),
				i = n.n(o),
				c = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/constants/experiments.ts"),
				u = n("./src/reddit/constants/page.ts"),
				l = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/helpers/chooseVariant/index.ts"),
				p = n("./src/reddit/selectors/experiments/utils.ts"),
				m = n("./src/reddit/selectors/meta.ts"),
				f = n("./src/reddit/selectors/user.ts");
			const g = Object(c.a)(e => Object(b.c)(e, {
					experimentEligibilitySelector: e => !Object(f.J)(e),
					experimentName: d.A
				}), p.a),
				O = Object(c.a)(f.J, (e, t) => Object(l.N)(e, t), (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(l.z)(n)
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(l.L)(n)
				}, (e, t, n, r) => !e && (n || r || t === u.g)),
				h = Object(c.a)((e, t) => Object(b.c)(e, {
					experimentEligibilitySelector: e => O(e, t),
					experimentName: d.A
				}), p.a),
				y = e => e === d.j.Top || e === d.j.TopBlue,
				j = e => e === d.j.Left || e === d.j.LeftBlue,
				_ = e => e === d.j.TopBlue || e === d.j.LeftBlue,
				E = new Set(i()(a.v).filter(e => e !== a.v.Everywhere)),
				v = Object(c.a)(m.b, e => !!e && E.has(e)),
				I = [{
					endDate: +new Date(2019, 7, 9) - 1,
					name: "Summer Fun",
					subredditNames: ["BBQ", "Coachella", "EDM", "Moviesinthemaking", "Music", "Shoestring", "TravelHacks", "aves", "boxoffice", "electricdaisycarnival", "electronicmusic", "entertainment", "flicks", "grilling", "hiking", "indieheads", "listentothis", "movies", "solotravel", "trailers"]
				}, {
					endDate: +new Date(2019, 8, 16) - 1,
					name: "Premier League",
					subredditNames: ["avfc", "chelseafc", "coys", "crystalpalace", "everton", "hammers", "lcfc", "liverpoolfc", "mcfc", "premierleague", "reddevils", "saintsfc", "soccer"]
				}, {
					endDate: +new Date(2020, 0, 1) - 1,
					name: "NFL",
					subredditNames: []
				}].sort((e, t) => e.endDate - t.endDate),
				S = s()(() => {
					const e = Date.now();
					return I.find(t => e < t.endDate)
				})
		},
		"./src/reddit/selectors/experiments/chatPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "f", (function() {
				return O
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				c = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/selectors/posts.ts");
			const d = (e, t) => {
					const n = t && e.subreddits.models[t];
					return Boolean(n && n.isChatPostFeatureEnabled)
				},
				u = (e, t) => {
					const n = t && e.subreddits.models[t];
					return Boolean(n && n.allowChatPostCreation)
				},
				l = e => Object(o.c)(e, {
					experimentName: r.d,
					experimentEligibilitySelector: o.a
				}) === r.k.Holdout,
				b = e => Object(o.c)(e, {
					experimentName: r.e,
					experimentEligibilitySelector: o.a
				}) === r.k.Rollout,
				p = (e, t) => {
					let {
						postId: n
					} = t;
					const r = !!n && Object(a.I)(e, {
						postId: n
					});
					return !!r && r.discussionType === i.b.Chat
				},
				m = (e, t) => {
					let {
						postId: n
					} = t;
					const r = p(e, {
							postId: n
						}),
						s = !!n && !!Object(c.i)(e, {
							postId: n
						}),
						o = b(e),
						i = !l(e) || s;
					return r && o && i
				},
				f = (e, t) => {
					const n = t.subredditId || Object(s.m)(e, t),
						r = d(e, n),
						o = u(e, n),
						i = !!n && Object(c.g)(e, {
							subredditId: n
						});
					return !!b(e) && (!!r && (!!i || !l(e) && o))
				},
				g = (e, t, n) => {
					if (t && b(e)) {
						if (n && l(e)) return;
						Object(o.d)(e, {
							experimentName: r.d
						})
					}
				},
				O = e => r.l.Enabled === Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.f
				})
		},
		"./src/reddit/selectors/experiments/exploreV2.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => e === r.zb.ExploreOld,
				i = e => e === r.zb.ExploreStandardSearchCommunity || e === r.zb.ExploreTrendingDUCommunity || e === r.zb.ExploreTrendingDUCommunityPopular || e === r.zb.ExploreTrendingSearchCommunity,
				c = e => e === r.zb.ExploreTrendingDUCommunity || e === r.zb.ExploreTrendingDUCommunityPopular,
				a = e => e === r.zb.ExploreTrendingSearchCommunity,
				d = e => e === r.zb.ExploreTrendingDUCommunityPopular,
				u = (e, t) => {
					const n = Object(s.c)(e, {
						experimentEligibilitySelector: e => !e.user.temporaryGQL.isLoggedIn,
						experimentName: r.vb,
						expEventOverride: t ? t.expEventOverride : void 0
					});
					return Object(r.Wb)(n) ? void 0 : n
				}
		},
		"./src/reddit/selectors/experiments/frontpageSignup.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/experiments/utils.ts"),
				a = n("./src/reddit/selectors/meta.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = Object(r.a)(d.R, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return !n || Object(o.z)(n)
				}, a.c, (e, t, n) => !e && t && !n),
				l = Object(r.a)((e, t) => Object(i.c)(e, {
					experimentEligibilitySelector: e => u(e, t),
					experimentName: s.B,
					throttledVariants: {
						[s.I.CurrentThrottled]: s.B
					}
				}), c.a),
				b = e => e === s.I.CurrentThrottled,
				p = e => e === s.I.CurrentThrottled || e === s.I.CurrentUnthrottled || e === s.I.CurrentUnthrottledCopy || e === s.I.NewPopUnthrottledCopy,
				m = e => e === s.I.NewPopUnthrottledCopy,
				f = e => e === s.I.NewPageUnthrottledCopy || e === s.I.NewPageUnthrottledCopyFields,
				g = e => e === s.I.NewPageUnthrottledCopyFields
		},
		"./src/reddit/selectors/experiments/goldPaypalSdk.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => !!(e => {
				const t = Object(s.c)(e, {
					experimentEligibilitySelector: e => Object(o.K)(e),
					experimentName: r.L
				});
				return Object(r.Wb)(t) ? void 0 : t
			})(e)
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: r.o
				}) === r.v.Enabled,
				i = e => Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: r.n
				}) === r.u.Enabled
		},
		"./src/reddit/selectors/experiments/listingBelowAll.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => !Object(o.J)(e),
				c = e => Object(s.c)(e, {
					experimentEligibilitySelector: i,
					experimentName: r.p
				}),
				a = e => e === r.w.Active
		},
		"./src/reddit/selectors/experiments/m2mHomeRedirect.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return c
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/utils.ts");
			const c = Object(r.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: e => !e.user.temporaryGQL.isLoggedIn,
					experimentName: s.F
				}), i.a),
				a = Object(r.a)(c, e => !!e),
				d = e => e === s.ab.ListingCapped || e === s.ab.ListingInfinite || e === s.ab.ListingInfiniteLightbox,
				u = e => e === s.ab.RightRail || e === s.ab.RightRailLightbox,
				l = e => e === s.ab.ListingInfinite || e === s.ab.ListingInfiniteLightbox,
				b = e => e === s.ab.ListingInfiniteLightbox || e === s.ab.RightRailLightbox
		},
		"./src/reddit/selectors/experiments/postSeo.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/meta.ts");
			const c = e => !!e.page.experiments.canonicalUrl;
			var a = n("./src/reddit/selectors/user.ts");
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "k", (function() {
				return j
			}));
			const d = Object(r.a)(i.i, e => {
					return "reddit.com" !== e.split(".").splice(1).join(".")
				}),
				u = Object(r.a)(a.K, d, (e, t) => !e && t),
				l = e => {
					const t = d(e);
					return Object(o.c)(e, {
						experimentName: s.kb,
						experimentEligibilitySelector: e => !Object(a.K)(e) && t
					})
				},
				b = e => {
					const t = d(e);
					return Object(o.c)(e, {
						experimentName: s.hb,
						experimentEligibilitySelector: () => t
					})
				},
				p = e => {
					const t = d(e);
					return Object(o.c)(e, {
						experimentName: s.jb,
						experimentEligibilitySelector: () => t
					})
				},
				m = e => e === s.rb.IdCard,
				f = e => e === s.rb.RailSwap,
				g = e => Object(o.b)(e, {
					experimentEligibilitySelector: c,
					experimentName: s.O
				}) === s.V.Metadata,
				O = e => Object(o.b)(e, {
					experimentEligibilitySelector: c,
					experimentName: s.Q
				}) === s.X.SelfText,
				h = e => Object(o.b)(e, {
					experimentEligibilitySelector: c,
					experimentName: s.P
				}),
				y = e => Object(o.b)(e, {
					experimentEligibilitySelector: c,
					experimentName: s.N
				}),
				j = e => Object(o.b)(e, {
					experimentEligibilitySelector: c,
					experimentName: s.R
				})
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => Object(o.H)(e) || r.tb.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: r.lb
				}),
				c = e => r.Gb.Enabled === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: r.Bb
				})
		},
		"./src/reddit/selectors/experiments/railsWidgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/experiments/utils.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const d = Object(r.a)(a.R, (e, t) => Object(o.D)(e, t), (e, t) => !e && t),
				u = Object(r.a)(e => Object(i.c)(e, {
					experimentEligibilitySelector: e => !e.user.temporaryGQL.isLoggedIn,
					experimentName: s.G
				}), c.a),
				l = Object(r.a)((e, t) => Object(i.c)(e, {
					experimentEligibilitySelector: e => d(e, t),
					experimentName: s.G
				}), c.a),
				b = e => e === s.yb.TopMonth,
				p = e => e === s.yb.Trending,
				m = e => e === s.yb.Geo
		},
		"./src/reddit/selectors/experiments/searchFix.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "f", (function() {
				return O
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/contexts/PageLayer/index.tsx"),
				c = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/experiments/utils.ts");
			const d = {},
				u = Object(r.a)(e => Object(c.c)(e, {
					experimentEligibilitySelector: c.a,
					experimentName: o.wb
				}), a.a),
				l = e => e === o.Fb.Active,
				b = e => {
					let {
						pageLayer: t
					} = e;
					return t && t.locationState || d
				},
				p = Object(r.a)((e, t) => b(t), e => e.fromPage && e.fromPage.subredditName),
				m = Object(r.a)((e, t) => b(t), e => e.fromPage && e.fromPage.routeName),
				f = e => {
					let {
						pageLayer: t
					} = e;
					return t && t.locationState && t.locationState.searchSwitcherType
				},
				g = Object(r.a)(e => u(e), m, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(i.A)(n)
				}, (e, t, n) => l(e) && n && (t === s.xb.COMMENTS || t === s.xb.SUBREDDIT)),
				O = Object(r.a)(e => u(e), (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(i.K)(n)
				}, (e, t) => l(e) && t)
		},
		"./src/reddit/selectors/experiments/subredditDifficulty.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return b
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/utils.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const a = Object(r.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: e => Object(c.K)(e),
					experimentName: s.Cb
				}), i.a),
				d = e => e === s.Hb.Treatment1,
				u = e => e === s.Hb.Treatment2,
				l = e => e === s.Hb.Treatment3,
				b = e => e === s.Hb.Treatment4
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const a = Object(r.a)(c.K, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.z)(n)
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.J)(n)
				}, (e, t, n) => !e && !t && n),
				d = Object(r.a)((e, t) => Object(i.c)(e, {
					experimentName: s.E,
					experimentEligibilitySelector: e => a(e, t)
				}), e => e),
				u = e => e === s.Qb.NoCommunityWidgets,
				l = e => e === s.Qb.NoRulesModerators,
				b = e => e === s.Qb.RelatedPostsDu
		},
		"./src/reddit/selectors/experiments/upAndComingLeaderboard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => r.Ub.All === Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: r.Tb
				}),
				i = ["crm", "malifaux", "littlenightmares", "sketchcomedy", "davesofthunder", "souleater", "perfectworldmobile", "careerchange", "musicindia", "clash_royale", "wethefifth", "eloping", "chaosbane", "vegetarianketo", "titlecards", "photographyprotips", "seals", "dipcifica", "werewolfonline", "space_justice", "anemic", "tupac", "itcrowd", "carnivorediet", "leonieleague", "seasteading", "happyplanners", "petpeeve", "ladiesofscience", "vinyl_jazz", "microscopy", "lilycollins", "protogen", "archviz", "axolotl", "retrowave", "webarebears", "studytips", "casualkujo", "weeds", "lincolnmotorco", "publicfeetpics", "traveltrailers", "asoiafminiaturesgame", "trivium", "vietnamwar", "jeremyzucker", "jennalouisecoleman", "armajet", "eosinophilice", "zeropunctuation", "jessicaalba", "playingguitar", "lifeofnorman", "moviereviews", "pixiv", "ender", "anxiousattachment", "hainbach", "dragracing", "grimm", "sanandreas", "wolcen", "ushistory", "fit", "kingdomsandcastles", "gwsn", "thumbcats", "blahaj", "goodboys", "firstdayontheinternet", "hondaaccord", "pcbuildingsimulator", "astro_kpop", "defectivedetectives", "namemydog", "timesplitters", "imaginaryundead", "boombeachrecruit", "ar_mr_xr", "busking", "universe", "henrycavill", "cavalierkingcharles", "haskellquestions", "bape", "kingdomrush", "dogbreeds101", "smokingcessation", "moddedminecraft", "cultcinema", "bleachshirts", "policechases", "medicalquestions", "descenders", "comebacks", "huaweipics", "esfp", "voxel", "okko", "unheardof", "bluebloods", "dannybrown", "synchronicities", "ameer", "animalsbeingsleepy", "greeneggsandhamtv", "bfgarmada", "catvideos", "fleet_foxes", "gardenwild", "hippocampusband", "aspirebudgeting", "fivethirtyeight", "latteart", "1000daysofpractice", "tomholland", "tenminutepodcast", "octolism", "mrreddit", "neilyoung", "rumblemains", "day6", "dinosaurearth", "ketomeals", "boopablenosies", "watcherofsamsara", "pho", "foundationgame", "lovebirds", "purrito", "styleboards", "internationalbaseball", "chemistryhelp", "animal", "roguetech", "rocknocker", "charlixcx", "hardcorehistory", "ppeperomioides", "mustangtech", "xavierrenegadeangel", "storytime", "airedaleterrier", "keycapdesigners", "hammocks", "throneofglassseries", "rurounikenshin", "bloodhoundmains", "medicalscribe", "stnewhorizons", "pianocovers", "fistofthenorthstar", "reactionmemes", "samsungs10", "frenchrap", "tcgte", "drpepper", "worldwhisky", "carrotweather", "shootingfishinabarrel", "tornado", "onlinesoccermanager", "doge", "hands", "boats", "chevysonic", "sharpei", "darktower", "malware", "mvc3", "batch", "sloths", "tile", "alphalegion", "unexpectedfuturama", "duelyst", "ericandre", "learnsql", "cargobike", "askstampcollectors", "scifimodels", "bootedgeedge", "subaruoutback", "femininenotfeminist", "masakox", "gouache", "nintendomusic", "tankionline", "sum41", "epidemiology", "thermodynamics", "starwarscommander", "jacobcollier", "soup", "mlpdrawingschool", "bibigang", "mobkitchen", "tollers", "cacti", "vanossgaming", "hardofhearing", "sailboatcruising", "lofihouse", "maritime", "vegan_travel", "designdesign", "ancientgreece", "geometry", "uktrains", "kittensgame", "yemenicrisis", "patentlaw", "madlass", "countrymusic", "spectacularmemes", "camelotunchained", "viziotv", "halo_5_guardians", "sublime", "mindblowing", "pathology", "smartereveryday", "mybloodyvalentine", "comic_crits", "googleplay", "metalfoundry", "gameofsultans", "amateursatellites", "writersspotlight", "game", "crocheting", "cookingtonight", "bananasforscale", "selfsufficiency", "spectrummobile", "mobilesuitgundam", "kromcrushclassic", "50s_science_fiction", "houseofcards", "abductions", "anthro", "gumballmemes", "koi", "scrapmetal", "lordhuron", "extrafabulouscomics", "skincareflatlays", "comicwriting", "fighterjets", "newdads", "watsky", "opossums", "samsunggalaxy", "posturetipsguide", "wrestlemaniaplans", "crewscrew", "gooddesign", "btrfs", "scrapbooking", "turtleswithjobs", "teslatruck", "2panelgarfield", "caffeine", "drinking", "merchbyamazon", "whatisthisworth"]
		},
		"./src/reddit/selectors/experiments/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/reddit/constants/experiments.ts");
			const s = e => {
				if (!Object(r.Wb)(e)) return e || void 0
			}
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			}));
			var r = n("./src/reddit/models/ExternalAccount/index.ts"),
				s = n("./src/reddit/models/User/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = (e, t) => {
					let {
						username: n
					} = t;
					return !!e.externalAccount.api.user.pending[n]
				},
				c = (e, t) => {
					let {
						username: n
					} = t;
					return e.externalAccount.user[n]
				},
				a = e => {
					const t = Object(o.i)(e);
					if (!t) return;
					const n = Object(s.f)(t),
						r = c(e, {
							username: n
						});
					return r ? r.twitter : void 0
				},
				d = e => !!e.externalAccount.api.connect.pending[r.a.Twitter],
				u = (e, t) => {
					let {
						profileName: n
					} = t;
					if (!n) return null;
					const i = c(e, {
						username: n
					});
					if (!i) return null;
					const a = i[r.a.Twitter];
					if (!a) return null;
					const d = Object(o.i)(e);
					if (!(d && Object(s.f)(d).toLowerCase() === n.toLowerCase())) return a;
					const u = Object(o.ib)(e, {
						userName: n
					});
					return u ? u.prefShowTwitter ? a : null : a
				}
		},
		"./src/reddit/selectors/focusedVerticalSuggestion.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/reddit/selectors/posts.ts"),
				s = n("./src/reddit/selectors/subreddit.ts");
			const o = (e, t) => {
					const n = e.focusedVerticals.interactedSubredditIds && e.focusedVerticals.interactedSubredditIds[t];
					if (n) {
						const t = Object(s.S)(e, {
							subredditId: n
						});
						return t && t.displayText || ""
					}
					return ""
				},
				i = (e, t) => e.focusedVerticals.interactedSubredditIds && e.focusedVerticals.interactedSubredditIds[t] || "",
				c = e => e.focusedVerticals.components.dismissed,
				a = [],
				d = (e, t) => {
					const n = u(e, t);
					if (!n) return a;
					const r = Object(s.W)(e, {
						subredditName: n.name
					});
					return r && r.postIds && r.postIds.length ? r.postIds : a
				},
				u = (e, t) => {
					const n = e.focusedVerticals.recommendedSubredditIds && e.focusedVerticals.recommendedSubredditIds[t];
					return n ? Object(s.S)(e, {
						subredditId: n
					}) : null
				},
				l = (e, t, n, s, o) => {
					const i = o.find(e => e <= t) || -1,
						c = o.find(e => e > t) || 1 / 0;
					return t !== c && t !== i && (!(i + n > t) && (!(t + n > c) && !((e, t, n) => {
						const s = n[t - 1],
							o = n[t],
							i = o && Object(r.I)(e, {
								postId: s
							}) || null,
							c = o && Object(r.I)(e, {
								postId: o
							}) || null;
						return i && i.isSponsored || c && c.isSponsored
					})(e, t, s)))
				},
				b = [3, 7, 7],
				p = (e, t, n) => {
					let {
						listingKey: s
					} = n;
					const o = t.slice().sort();
					let i = -1;
					const c = Object(r.C)(e, {
							listingKey: s
						}),
						a = [];
					return b.forEach(t => {
						let n = i + t;
						if (!(n >= c.length)) {
							for (; n < c.length && !l(e, n, t, c, o);) n += 1;
							n < c.length && (a.push(n), i = n)
						}
					}), a
				},
				m = e => !!e.focusedVerticals.recommendedSubredditIds && !!e.focusedVerticals.recommendedSubredditIds.length,
				f = e => {
					return e.focusedVerticals.api.pending.focusedVerticalGqlPending
				},
				g = e => {
					return e.focusedVerticals.api.error.focusedVerticalGqlError
				}
		},
		"./src/reddit/selectors/frontpage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var r = n("./src/lib/constants/index.ts");
			const s = e => e.user && e.user.session && !e.user.session.unsafeLoggedOut ? r.N.BEST : r.N.HOT
		},
		"./src/reddit/selectors/gild.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "c", (function() {
				return s
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			}));
			const r = e => e.gild.gildModalThingId,
				s = (e, t) => e.gild.gildModalId === t,
				o = e => e.gild.isAnonymous,
				i = e => e.gild.isIframed,
				c = e => e.gild.message,
				a = e => e.gild.api.pending,
				d = e => e.gild.api.error,
				u = e => e.gild && e.gild.giveAwardTooltipThingId
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "p", (function() {
				return c
			})), n.d(t, "q", (function() {
				return a
			})), n.d(t, "u", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "s", (function() {
				return b
			})), n.d(t, "t", (function() {
				return p
			})), n.d(t, "r", (function() {
				return m
			})), n.d(t, "v", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "m", (function() {
				return y
			})), n.d(t, "n", (function() {
				return j
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "o", (function() {
				return E
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "f", (function() {
				return I
			}));
			const r = e => e.goldPurchase.coinPurchaseModal.activePage,
				s = e => e.goldPurchase.coinPurchaseModal.gildThingId || void 0,
				o = e => e.goldPurchase.coinPurchaseModal.showModal,
				i = e => e.goldPurchase.coinPurchaseModal.purchasePackage,
				c = e => e.goldPurchase.premiumPurchaseModal.activePage,
				a = e => e.goldPurchase.premiumPurchaseModal.showModal,
				d = e => e.goldPurchase.updateCardModal.pending,
				u = e => e.goldPurchase.payment.paymentMethod,
				l = e => e.goldPurchase.payment.cardName,
				b = e => e.goldPurchase.payment.savedCardsPending,
				p = e => e.goldPurchase.payment.savedCards,
				m = e => e.goldPurchase.payment.rememberCard,
				f = e => e.goldPurchase.payment.useSavedCard,
				g = e => e.goldPurchase.payment.cardValidation.cardCvc,
				O = e => e.goldPurchase.payment.cardValidation.cardExpiry,
				h = e => e.goldPurchase.payment.cardValidation.cardNumber,
				y = e => e.goldPurchase.payment.cardValidation.nameOnCard,
				j = e => e.goldPurchase.payment.cardValidation.postalCode,
				_ = e => e.goldPurchase.payment.stripeToken.errorMessage,
				E = e => e.goldPurchase.payment.stripeToken.pending,
				v = e => e.goldPurchase.payment.paypal.passthrough,
				I = e => e.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/imageUploads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var r = n("./src/reddit/models/Image/index.tsx");
			const s = e => e.imageUploads,
				o = (e, t) => {
					const n = s(e),
						o = [];
					for (const s in n) {
						const e = n[s];
						e.kind === r.b.TempUploaded && e.context === t && o.push(e)
					}
					return o
				}
		},
		"./src/reddit/selectors/inFeedChaining.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return m
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeListingKey/index.ts"),
				i = n("./src/reddit/actions/subreddit/similarSubreddit.ts"),
				c = n("./src/reddit/constants/inFeedChaining.ts"),
				a = n("./src/reddit/endpoints/subreddit/similar.ts"),
				d = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				u = n("./src/reddit/selectors/discoveryUnit.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				b = n("./src/reddit/selectors/subreddit.ts");
			const p = [],
				m = (e, t) => {
					const n = e.posts.chained.idToListingKey[t.postId];
					return t.listingKey === n
				},
				f = (e, t) => {
					const n = e.posts.chained.dismissedIdToListingKey[t.postId];
					return (e => e.posts.chained.dismissed)(e) || t.listingKey === n
				},
				g = Object(r.a)(e => e.posts.chained.idToListingKey, e => Object.keys(e).filter(t => e[t])),
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return g(e).some(t => {
						const r = Object(l.U)(e, {
							postId: t
						});
						return !!r && r.id === n
					})
				},
				h = (e, t) => {
					let {
						subredditName: n
					} = t;
					const r = s.Ob.DAY.toUpperCase(),
						i = Object(o.a)(n, s.N.TOP, {
							t: r
						}),
						c = Object(l.C)(e, {
							listingKey: i
						});
					if (0 !== c.length)
						for (const s of c) {
							const t = Object(l.I)(e, {
								postId: s
							});
							if (t && !t.hidden && !t.isSponsored) return t
						}
				},
				y = (e, t) => {
					let {
						postId: n
					} = t;
					const r = ((e, t) => {
							let {
								postId: n
							} = t;
							const r = Object(l.I)(e, {
								postId: n
							});
							if (!r) return p;
							const s = Object(i.a)({
								subredditIds: [r.belongsTo.id],
								count: c.b,
								variant: a.a.Factorization
							});
							return Object(b.x)(e, {
								key: s
							})
						})(e, {
							postId: n
						}),
						s = [];
					for (const {
							name: o
						} of r) {
						const t = h(e, {
							subredditName: o
						});
						t && s.push(t.id)
					}
					return s
				},
				j = (e, t) => {
					let {
						listingName: n
					} = t;
					const r = d.b;
					return Object(u.f)(e, {
						unitName: r
					})
				}
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var r = n("./src/reddit/featureFlags/index.ts"),
				s = n("./src/reddit/selectors/moderatorPermissions.ts");
			const o = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!r.d.subredditInlineEditing(e)) return !1;
					const o = n ? Object(s.j)(e, {
						subredditId: n
					}) : null;
					return !!o && (e => !!e && e.config)(o)
				},
				i = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/layers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			const r = e => e.layers.editorBackground,
				s = e => e.layers.draft,
				o = e => e.layers.layerBox,
				i = e => e.layers.startTime
		},
		"./src/reddit/selectors/listings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			}));
			var r = n("./src/lib/objectSelector/index.ts");
			const s = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.postOrder.api.error[n]
				},
				o = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.postOrder.api.pending[n]
				},
				i = (e, t) => e.listings.postOrder.loadMore[t.listingKey],
				c = (e, t) => {
					let {
						listingKey: n,
						token: r
					} = t;
					return e.listings.postOrder.fetchedTokens[n][r]
				},
				a = e => e.listings.activeKey,
				d = Object(r.a)((e, t) => {
					let {
						postId: n
					} = t;
					const r = a(e);
					if (!r) return;
					const s = e.listings.postOrder.ids[r];
					if (!s) return;
					const o = e.posts.models,
						i = u({
							listings: s,
							posts: o,
							postId: n,
							dir: "next"
						}),
						c = u({
							listings: s,
							posts: o,
							postId: n,
							dir: "prev"
						}),
						d = e.posts.models[c];
					return {
						nextPost: e.posts.models[i],
						prevPost: d
					}
				}),
				u = e => {
					let {
						listings: t,
						posts: n,
						postId: r,
						dir: s
					} = e;
					const o = t.indexOf(r);
					if (o < 0) return null;
					let i, c = o;
					do {
						i = t[c += "prev" === s ? -1 : 1]
					} while (n[i] && n[i].isBlank);
					return i
				},
				l = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.api.pending[n]
				},
				b = (e, t) => {
					let {
						listingKey: n,
						token: r
					} = t;
					return e.listings.listingOrder.fetchedTokens[n][r]
				},
				p = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.listings.listingOrder.fetchedTokens[n]
				},
				m = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.loadMore[n]
				}
		},
		"./src/reddit/selectors/media.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = e => e.mediaPlayback.isMuted,
				s = e => e.mediaPlayback.volume
		},
		"./src/reddit/selectors/meta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/lib/getParsedUserAgent/index.ts");
			const o = e => "".concat(e.meta.protocol, "://").concat(e.meta.domain),
				i = e => e.meta.city,
				c = e => e.meta.country,
				a = e => e.meta.region,
				d = e => e.meta.crawler,
				u = Object(r.a)(e => e.meta.userAgent, e => Object(s.b)(e)),
				l = Object(r.a)(e => e.meta.userAgent, e => Object(s.f)(e)),
				b = Object(r.a)(e => e.meta.userAgent, e => Object(s.d)(e)),
				p = e => e.meta && e.meta.sessionReferrerDomain
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return s
			}));
			const r = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: r
					} = t;
					if (!n) return !1;
					if (e.comments.collapsed[r] && n in e.comments.collapsed[r]) return !!e.comments.collapsed[r][n];
					const s = e.comments.models[n];
					return !!s && ("computedCollapsed" in s ? !!s.computedCollapsed : s.collapsedBecauseCrowdControl ? !e.modModeEnabled : s.collapsed)
				},
				s = (e, t) => {
					let {
						commentId: n
					} = t;
					if (!n) return !1;
					const r = e.comments.models[n];
					return !(!r || !r.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/moderatorPermissions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return d
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			}));
			var r = n("./node_modules/lodash/values.js"),
				s = n.n(r),
				o = n("./src/lib/objectSelector/index.ts"),
				i = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				c = n("./src/reddit/selectors/posts.ts");
			const a = e => !!(e.user && e.user.account && e.user.account.isAdmin),
				d = e => !!(e.user && e.user.account && e.user.account.isMod) || a(e),
				u = (e, t) => {
					if (a(e)) return i.b;
					const n = Object(c.I)(e, t);
					if (!n) return null;
					const r = n.belongsTo.id;
					return e.moderatingSubreddits[r]
				},
				l = (e, t) => a(e) ? i.b : e.moderatingSubreddits[t.subredditId],
				b = e => (t, n) => {
					if (a(t)) return !0;
					const r = l(t, n);
					return !(!r || !r[e])
				},
				p = Object(o.a)((e => t => {
					const n = a(t),
						r = [];
					for (const s in t.moderatingSubreddits) {
						const o = t.moderatingSubreddits[s];
						(n || o && o[e]) && (t.subreddits.models[s] ? r.push(t.subreddits.models[s]) : t.profiles.models[s] && r.push(t.profiles.models[s]))
					}
					return r
				})(i.c.posts)),
				m = e => t => {
					if (a(t)) return !0;
					for (const n in t.moderatingSubreddits) {
						const r = t.moderatingSubreddits[n];
						if (r && r[e]) return !0
					}
					return !1
				},
				f = b(i.c.flair),
				g = b(i.c.wiki),
				O = b(i.c.posts),
				h = (m(i.c.flair), m(i.c.posts)),
				y = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.moderatingSubreddits[n];
					return a(e) || !(!r || !s()(r).some(e => e))
				},
				j = (e, t) => {
					let {
						postId: n
					} = t;
					const r = u(e, {
						postId: n
					});
					return !!r && r.posts
				}
		},
		"./src/reddit/selectors/monthsToMinutes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "w", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "p", (function() {
				return y
			})), n.d(t, "k", (function() {
				return j
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "t", (function() {
				return v
			})), n.d(t, "v", (function() {
				return I
			})), n.d(t, "u", (function() {
				return S
			})), n.d(t, "q", (function() {
				return T
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "s", (function() {
				return C
			})), n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "D", (function() {
				return R
			})), n.d(t, "C", (function() {
				return A
			})), n.d(t, "j", (function() {
				return k
			})), n.d(t, "E", (function() {
				return N
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "g", (function() {
				return M
			})), n.d(t, "b", (function() {
				return U
			})), n.d(t, "o", (function() {
				return B
			})), n.d(t, "F", (function() {
				return H
			})), n.d(t, "A", (function() {
				return K
			})), n.d(t, "B", (function() {
				return Y
			})), n.d(t, "h", (function() {
				return z
			})), n.d(t, "i", (function() {
				return J
			})), n.d(t, "G", (function() {
				return Q
			})), n.d(t, "l", (function() {
				return X
			})), n.d(t, "z", (function() {
				return Z
			})), n.d(t, "y", (function() {
				return $
			})), n.d(t, "x", (function() {
				return ee
			})), n.d(t, "m", (function() {
				return te
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/uniq.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/values.js"),
				i = n.n(o),
				c = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/helpers/name/index.ts"),
				d = n("./src/reddit/models/DiscoveryUnit/index.ts"),
				u = n("./src/reddit/models/MonthsToMinutes/index.ts"),
				l = n("./src/reddit/models/Vote/index.ts"),
				b = n("./src/reddit/selectors/discoveryUnit.ts"),
				p = n("./src/reddit/selectors/experiments/m2mHomeRedirect.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				f = n("./src/reddit/selectors/subscriptions.ts"),
				g = n("./src/reddit/selectors/user.ts");
			const O = e => Object(p.c)(e),
				h = e => e.user.loggedOutData.accountCompleteness.step,
				y = e => h(e) === u.a.Initial,
				j = e => h(e) === u.a.BannerVisible,
				_ = e => {
					return h(e) === u.a.HomeVisited
				},
				E = e => e.user.loggedOutData.accountCompleteness.collapsed,
				v = e => e.user.loggedOutData.postsCount,
				I = e => e.user.loggedOutData.votes,
				S = e => e.user.loggedOutData.views,
				T = e => e.user.loggedOutData.homeFeed,
				x = e => e.user.loggedOutData.homeFeed.topBanner.isClosed,
				C = e => e.user.loggedOutData.homeFeed.topBanner.viewsCount,
				w = e => e.user.loggedOutData.feedMultiName,
				P = e => {
					const t = w(e);
					return t.length ? t.join("+") : null
				},
				D = (Object(c.a)(e => e.user.loggedOutData.votes.posts, e => e.user.loggedOutData.votes.comments, (e, t) => {
					return Object.keys(e).filter(t => 0 !== e[t]).length + Object.keys(t).filter(e => 0 !== t[e]).length
				}), e => e && !e.isDismissed && e.postId),
				R = e => {
					const t = e.user.loggedOutData.tooltips[u.e.SubscribeFeed];
					return !Object(f.c)(e) && D(t) ? t.postId : void 0
				},
				A = e => {
					const t = e.user.loggedOutData.tooltips[u.e.SubscribeReminder];
					return !Object(f.c)(e) && D(t) ? t.postId : void 0
				},
				k = e => {
					const t = e.user.loggedOutData.tooltips[u.e.Home];
					return O(e) && !1 === t.isDismissed && !_(e)
				},
				N = e => {
					const t = e.user.loggedOutData.tooltips;
					return {
						homeTooltipTime: t[u.e.Home].time,
						subscribeIdCardTooltipTime: t[u.e.SubscribeIdCard].time,
						subscribeTooltipTime: t[u.e.SubscribeFeed].time,
						voteTooltipTime: t[u.e.Vote].time
					}
				},
				L = (Object(c.a)(N, e => {
					const t = i()(e).filter(e => !!e);
					return t.sort(), t.length > 0 ? t[0] : void 0
				}), e => e.user.loggedOutData.dataLoaded),
				M = (e, t) => {
					if (Object(g.K)(e)) return !0;
					if (!O(e)) return !1;
					if (!_(e)) return !1;
					return w(e).length > 0
				},
				U = e => {
					return {
						collapsed: E(e),
						step: h(e)
					}
				},
				F = Object(c.a)(e => e.user.loggedOutData.views.posts, e => Object.keys(e).filter(t => e[t]).length),
				B = e => {
					return !!O(e) && F(e) >= u.d
				},
				G = e => T(e).views,
				V = Object(c.a)(I, e => T(e).votes, (e, t) => {
					return [...Object.keys(e.comments).filter(t => e.comments[t] !== l.a.notVoted), ...Object.keys(e.posts).filter(t => e.posts[t] !== l.a.notVoted)].map(e => t[e]).filter(Boolean)
				}),
				q = e => T(e).similar,
				H = Object(c.a)(f.f, G, V, (e, t, n) => {
					return s()([...e.filter(Boolean).map(e => {
						let {
							name: t
						} = e;
						return t
					}), ...n, ...t].map(a.f))
				}),
				K = Object(c.a)(f.f, H, q, (e, t, n) => {
					const r = s()([...t, ...n].map(a.f)),
						o = e.length === u.b ? u.b : u.c;
					return r.slice(0, o)
				}),
				W = Object(c.a)(G, f.f, V, q, (e, t, n, r) => {
					const o = s()([...e, ...t.filter(Boolean).map(e => {
							let {
								name: t
							} = e;
							return t
						}), ...n, ...r].map(a.f)),
						i = t.length === u.b ? u.b : u.c;
					return o.slice(0, i)
				}),
				Y = e => {
					return K(e).reduce((t, n) => {
						return t[Object(m.G)(e, n)] = n, t
					}, {})
				},
				z = e => _(e) ? w(e) : K(e),
				J = e => {
					return z(e).map(t => Object(m.B)(e, {
						subredditName: t
					})).filter(Boolean)
				},
				Q = e => {
					return W(e).map(t => Object(m.B)(e, {
						subredditName: t
					})).filter(Boolean)
				},
				X = e => {
					const t = y(e),
						n = (e => {
							const t = B(e),
								n = K(e);
							return t && n.length >= u.c
						})(e);
					return t && n
				},
				Z = Object(c.a)(p.c, X, j, (e, t, n) => !!e && (t || n)),
				$ = Object(c.a)(Z, p.f, (e, t) => e && Object(p.b)(t)),
				ee = e => {
					const t = Z(e) ? d.j : d.m;
					return Object(b.f)(e, {
						unitName: t
					})
				},
				te = Object(c.a)(O, M, j, _, (e, t, n, r) => e && (t || n || r))
		},
		"./src/reddit/selectors/multireddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "j", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return I
			})), n.d(t, "k", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var r = n("./node_modules/lodash/sortBy.js"),
				s = n.n(r),
				o = n("./src/app/strings/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/objectSelector/index.ts"),
				a = n("./src/reddit/models/Multireddit/index.ts"),
				d = n("./src/reddit/models/User/index.ts"),
				u = n("./src/reddit/models/Widgets/index.ts"),
				l = n("./src/reddit/selectors/profile.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const m = [],
				f = Object(c.a)((e, t) => {
					let {
						listingName: n
					} = t;
					const r = (e => e.replace(/\++/g, "+").replace(/^\+/, "").replace(/\+$/, ""))(n.toLowerCase()).split("+"),
						s = r.filter(e => !e.startsWith(i.Qb)).map(t => Object(b.G)(e, t)).filter(e => void 0 !== e),
						c = r.filter(e => e.startsWith(i.Qb)).map(t => Object(l.m)(e, t.slice(2))).filter(e => void 0 !== e),
						a = [...s.map(t => e.subreddits.models[t].name), ...c.map(t => e.profiles.models[t].name)].join(", ");
					return {
						displayText: Object(o.c)(Object(p.T)(e), "multireddit.adHocDescription", a.length, {
							subreddits: a
						}),
						profileIds: c,
						subredditIds: s
					}
				}),
				g = e => e.multireddits.api.forUser.fetched,
				O = e => e.multireddits.api.forUser.pending,
				h = (e, t) => {
					let {
						multiredditName: n,
						username: r
					} = t;
					if (!r) {
						if (!e.user.account) return null;
						const {
							displayText: t
						} = e.user.account;
						r = t
					}
					const s = Object(a.h)(r, n);
					return e.multireddits.models[s]
				},
				y = Object(c.a)(e => {
					const {
						account: t
					} = e.user;
					if (!t) return m;
					const {
						id: n
					} = t, r = e.multireddits.byUserId[n];
					return r ? r.map(t => e.multireddits.models[t]) : m
				}),
				j = (e, t) => {
					let {
						multiredditName: n,
						username: r
					} = t;
					if (r) {
						const t = h(e, {
							multiredditName: n,
							username: r
						});
						return t ? "/user/".concat(r, "/m/").concat(t.name) : ""
					}
					const {
						account: s
					} = e.user;
					if (!s) return "";
					const o = h(e, {
						multiredditName: n
					});
					return o ? "/me/m/".concat(o.name) : ""
				},
				_ = (e, t) => {
					let {
						multiredditName: n,
						username: r
					} = t;
					if (!r) {
						const {
							account: t
						} = e.user;
						if (!t) return "";
						r = Object(d.f)(t)
					}
					const s = Object(a.h)(r, n),
						i = e.multireddits.models[s];
					return i ? Object(o.a)(e.user.language, "multireddit.title", {
						displayText: i.displayText,
						username: r
					}) : ""
				},
				E = (e, t) => e.multireddits.models[t],
				v = Object(c.a)((e, t) => {
					let {
						subredditIds: n,
						profileIds: r
					} = t;
					const o = [];
					let i = [...n && n.reduce((t, n) => {
						const r = Object(b.S)(e, {
							subredditId: n
						});
						return r ? [...t, r] : (o.push(n), t)
					}, []) || [], ...r && r.map(t => Object(l.p)(e, {
						profileId: t
					})) || []].filter(e => !!e).map(t => {
						const n = Object(u.j)(t);
						return n.isSubscribed = Object(b.cb)(e, {
							identifier: {
								type: n.type,
								name: n.name
							}
						}), n
					});
					if (o) {
						const t = o.map(t => e.subreddits.communityInfo[t]).filter(e => !!e);
						i.push(...t), i = s()(i, e => e.name.toLowerCase())
					}
					return i
				}),
				I = (e, t) => {
					const n = Object(p.i)(e),
						r = Object(a.i)(t);
					return !!n && (n.displayText || "").toLowerCase() === r.toLowerCase()
				},
				S = Object(c.a)((e, t) => {
					let {
						multireddit: n
					} = t;
					return Object(a.f)(n) && e.multireddits.recommendations[n.url] && e.multireddits.recommendations[n.url].length ? e.multireddits.recommendations[n.url].map(t => Object(u.i)(e.subreddits.models[t])) : []
				})
		},
		"./src/reddit/selectors/notificationBanner.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = e => t => t.notificationBannerId === e
		},
		"./src/reddit/selectors/oldSiteRules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = e => e.oldSiteRules
		},
		"./src/reddit/selectors/platform.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "r", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "p", (function() {
				return l
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "q", (function() {
				return O
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "a", (function() {
				return E
			})), n.d(t, "s", (function() {
				return v
			})), n.d(t, "o", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./src/lib/constants/index.ts"),
				s = n("./src/reddit/models/Post/index.ts"),
				o = (n("./src/reddit/selectors/multireddit.ts"), n("./src/reddit/selectors/subreddit.ts"));
			const i = e => e.platform.currentPage,
				c = e => e.platform.lastPage,
				a = e => {
					if (!e.platform.currentPage || !e.platform.currentPage.routeMatch) return null;
					const {
						route: t
					} = e.platform.currentPage.routeMatch;
					return t.meta.name
				},
				d = e => e.platform.currentPage && e.platform.currentPage.routeMatch && e.platform.currentPage.routeMatch.route.chunk === r.o.FRONTPAGE,
				u = e => e.platform.currentPage && e.platform.currentPage.routeMatch && [r.o.FRONTPAGE, r.o.MULTIREDDIT, r.o.SUBREDDIT].includes(e.platform.currentPage.routeMatch.route.chunk),
				l = e => !!(e.platform.lastPage && e.platform.lastPage.locationState && e.platform.lastPage.locationState.isOverlay),
				b = e => !!(e.platform && e.platform.currentPage && e.platform.currentPage.locationState && e.platform.currentPage.locationState.isOverlay),
				p = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== r.xb.COMMENTS && e.platform.currentPage.meta.name !== r.xb.DUPLICATES),
				m = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== r.xb.POST_CREATION),
				f = e => !!(e.platform.currentPage && e.platform.currentPage.meta && e.platform.currentPage.meta.name === r.xb.COMMENTS && e.platform.currentPage.urlParams && e.platform.currentPage.urlParams.routePrefix && "user" === e.platform.currentPage.urlParams.routePrefix),
				g = e => e.platform && e.platform.currentPage && e.platform.currentPage.status,
				O = e => e.platform && e.platform.currentPage && e.platform.currentPage.queryParams,
				h = e => {
					const t = y(e);
					return t ? Object(o.G)(e, t) : null
				},
				y = e => {
					const t = e.platform.currentPage && e.platform.currentPage.urlParams;
					return t ? t.subredditName : null
				},
				j = e => {
					const t = y(e);
					return t ? Object(o.B)(e, {
						subredditName: t
					}) : null
				},
				_ = (e, t) => {
					let {
						page: n
					} = t;
					const r = n && n.routeMatch;
					if (!r) return;
					const {
						partialPostId: o
					} = r.match.params;
					return e.posts.models[Object(s.m)(o)]
				},
				E = e => e.platform.allowNavigationCallback,
				v = e => e.platform.currentPage ? e.platform.currentPage.url : "",
				I = e => {
					const t = e.platform.currentPage;
					if (t && t.routeMatch) {
						const {
							params: e
						} = t.routeMatch.match;
						if (e && e.partialPostId) return Object(s.m)(e.partialPostId)
					}
					return ""
				}
		},
		"./src/reddit/selectors/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return h
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "r", (function() {
				return j
			})), n.d(t, "s", (function() {
				return _
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "p", (function() {
				return S
			})), n.d(t, "o", (function() {
				return T
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "v", (function() {
				return w
			})), n.d(t, "u", (function() {
				return P
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "l", (function() {
				return A
			})), n.d(t, "h", (function() {
				return k
			})), n.d(t, "j", (function() {
				return N
			})), n.d(t, "f", (function() {
				return L
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "t", (function() {
				return F
			})), n.d(t, "e", (function() {
				return B
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/lib/eventTools/index.ts"),
				o = n("./src/reddit/constants/postCollection.ts"),
				i = n("./src/reddit/featureFlags/profileCollections.ts"),
				c = n("./src/reddit/helpers/media/index.ts"),
				a = n("./src/reddit/models/Media/index.ts"),
				d = n("./src/reddit/models/PostCollection/index.ts"),
				u = n("./src/reddit/models/Subreddit/index.ts"),
				l = n("./src/reddit/selectors/moderatorPermissions.ts"),
				b = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/structuredStyles.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/selectors/profile.ts");
			const O = [],
				h = (e, t) => {
					let {
						postId: n
					} = t;
					const r = Object(b.I)(e, {
						postId: n
					});
					let o = !1;
					if (r && r.eventInfo) {
						const {
							eventStart: e,
							eventEnd: t,
							eventIsLive: n
						} = r.eventInfo;
						if (!n) {
							o = Object(s.e)(e, t) === s.a.Future
						}
					}
					return o
				},
				y = (e, t) => {
					let {
						collectionId: n
					} = t;
					const r = E(e, {
						collectionId: n
					});
					if (!r || !r.id) return "";
					const s = Object(m.c)(e, r.subredditId);
					return s && n ? "".concat(s, "submit?collection=").concat(n) : ""
				},
				j = (e, t, n) => {
					if (n && !Object(i.a)(e)) return !1;
					if (!(n ? Object(f.N)(e, t) : Object(l.g)(e, {
							subredditId: Object(m.G)(e, t)
						}))) return !1;
					const r = n ? Object(m.s)(e, t) : Object(m.y)(e, {
						subredditName: t
					});
					return !(!r || !r.collectionsEnabled)
				},
				_ = (e, t) => {
					let {
						collectionId: n
					} = t;
					const r = E(e, {
						collectionId: n
					});
					if (!r) return !1;
					const s = Object(m.S)(e, {
						subredditId: r.subredditId
					}) || Object(g.p)(e, {
						profileId: r.subredditId
					});
					return j(e, s.name, s.type === u.c.User)
				},
				E = (e, t) => {
					let {
						collectionId: n
					} = t;
					return e.postCollection.models[n]
				},
				v = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n],
						{
							collectionIds: s
						} = r,
						o = s ? s[0] : null;
					return o && e.postCollection.models[o] || null
				},
				I = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n],
						{
							collectionIds: s
						} = r;
					return !!(s ? s[0] : null)
				},
				S = (e, t) => {
					let {
						collectionId: n
					} = t;
					const r = E(e, {
						collectionId: n
					});
					return r ? r.primaryPostId : null
				},
				T = (e, t) => {
					let {
						collectionId: n
					} = t;
					const r = E(e, {
						collectionId: n
					});
					if (!r) return null;
					const s = r.postIds || [];
					return Object(b.M)(e, {
						postIds: s
					})
				},
				x = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.postCollection.subredditToIds[n]
				},
				C = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = x(e, {
						subredditId: n
					});
					return !(!r || !r.length)
				},
				w = Object(r.a)(x, e => e.postCollection.models, (e, t) => e ? e.map(e => t[e]).filter(Boolean) : O),
				P = (e, t) => {
					const n = x(e, t);
					return n ? n.length : 0
				},
				D = e => e.creations.api.collection.createOrUpdate.pending,
				R = e => e.creations.api.collection.createOrUpdate.error,
				A = e => e.postCollection.api.pending.reorderPending,
				k = e => e.postCollection.api.pending.updateDescriptionPending,
				N = e => e.postCollection.api.pending.updateLayoutPending,
				L = e => e && e.displayLayout || d.a.TIMELINE,
				M = (e, t) => {
					let {
						collectionId: n
					} = t;
					return L(e.postCollection.models[n])
				},
				U = (e, t) => {
					let {
						postId: n
					} = t;
					return L(v(e, {
						postId: n
					}))
				},
				F = (e, t) => {
					let {
						collectionId: n
					} = t;
					return !(!((e, t) => {
						let {
							collectionId: n
						} = t;
						const r = E(e, {
							collectionId: n
						});
						if (!r || !r.id) return;
						const s = r.subredditId,
							o = Object(p.l)(e, {
								subredditId: s
							});
						return o && !!o.postPlaceholderImage
					})(e, {
						collectionId: n
					}) && !((e, t) => {
						let {
							collectionId: n
						} = t;
						const r = T(e, {
							collectionId: n
						});
						if (!r || !Object.keys(r).length) return;
						let s = 0;
						for (const o in r) {
							const e = r[o];
							e && e.thumbnail.width && e.thumbnail.height && (s += 1)
						}
						return s >= Object.keys(r).length - s
					})(e, {
						collectionId: n
					}))
				},
				B = (e, t) => {
					let {
						postId: n
					} = t;
					const r = Object(b.I)(e, {
						postId: n
					});
					let s = null;
					return r && (r.media && r.media.type !== a.n.GIFVIDEO && (s = Object(c.e)(r, 2 * o.b, 2 * o.a) || Object(c.e)(r, o.b, o.a)), !s && r.thumbnail && r.thumbnail.width && r.thumbnail.height && (s = r.thumbnail, (r.isNSFW || r.isSpoiler) && (s = (e => {
						if (!e || e.type === a.n.RTJSON || e.type === a.n.TEXT) return null;
						const t = e.obfuscated;
						return t ? {
							url: t,
							width: e.width,
							height: e.height
						} : null
					})(r.media)))), s
				}
		},
		"./src/reddit/selectors/postCreations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "r", (function() {
				return w
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "G", (function() {
				return D
			})), n.d(t, "n", (function() {
				return k
			})), n.d(t, "B", (function() {
				return N
			})), n.d(t, "Q", (function() {
				return L
			})), n.d(t, "cb", (function() {
				return M
			})), n.d(t, "L", (function() {
				return U
			})), n.d(t, "N", (function() {
				return F
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "ab", (function() {
				return V
			})), n.d(t, "d", (function() {
				return q
			})), n.d(t, "a", (function() {
				return H
			})), n.d(t, "C", (function() {
				return K
			})), n.d(t, "P", (function() {
				return W
			})), n.d(t, "j", (function() {
				return Y
			})), n.d(t, "h", (function() {
				return z
			})), n.d(t, "i", (function() {
				return J
			})), n.d(t, "k", (function() {
				return Q
			})), n.d(t, "l", (function() {
				return X
			})), n.d(t, "A", (function() {
				return Z
			})), n.d(t, "D", (function() {
				return $
			})), n.d(t, "H", (function() {
				return ee
			})), n.d(t, "E", (function() {
				return te
			})), n.d(t, "o", (function() {
				return ne
			})), n.d(t, "S", (function() {
				return re
			})), n.d(t, "Y", (function() {
				return se
			})), n.d(t, "q", (function() {
				return oe
			})), n.d(t, "m", (function() {
				return ie
			})), n.d(t, "eb", (function() {
				return ce
			})), n.d(t, "W", (function() {
				return ae
			})), n.d(t, "F", (function() {
				return de
			})), n.d(t, "z", (function() {
				return ue
			})), n.d(t, "bb", (function() {
				return le
			})), n.d(t, "db", (function() {
				return be
			})), n.d(t, "X", (function() {
				return pe
			})), n.d(t, "I", (function() {
				return me
			})), n.d(t, "J", (function() {
				return fe
			})), n.d(t, "K", (function() {
				return ge
			})), n.d(t, "V", (function() {
				return Oe
			})), n.d(t, "O", (function() {
				return he
			})), n.d(t, "y", (function() {
				return ye
			})), n.d(t, "x", (function() {
				return je
			})), n.d(t, "u", (function() {
				return _e
			})), n.d(t, "v", (function() {
				return Ee
			})), n.d(t, "t", (function() {
				return ve
			})), n.d(t, "w", (function() {
				return Ie
			})), n.d(t, "M", (function() {
				return Se
			})), n.d(t, "p", (function() {
				return Te
			})), n.d(t, "b", (function() {
				return xe
			})), n.d(t, "T", (function() {
				return Ce
			})), n.d(t, "Z", (function() {
				return we
			})), n.d(t, "e", (function() {
				return Pe
			})), n.d(t, "R", (function() {
				return De
			})), n.d(t, "U", (function() {
				return Re
			})), n.d(t, "c", (function() {
				return Ae
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/app/strings/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makePostCreationPageKey/index.ts"),
				c = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				a = n("./src/reddit/constants/posts.ts"),
				d = n("./src/reddit/contexts/PageLayer/index.tsx"),
				u = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = n("./src/reddit/featureFlags/index.ts"),
				b = n("./src/reddit/featureFlags/profileCollections.ts"),
				p = n("./src/reddit/helpers/getSubredditUrl/index.ts"),
				m = n("./src/reddit/helpers/media/index.ts"),
				f = n("./src/reddit/helpers/name/index.ts"),
				g = n("./src/reddit/helpers/path/index.ts"),
				O = n("./src/reddit/models/PostCreationForm/index.ts"),
				h = n("./src/reddit/models/PostRequirements/index.ts"),
				y = n("./src/reddit/models/Subreddit/index.ts"),
				j = n("./src/reddit/models/Upload/index.ts"),
				_ = n("./src/reddit/routes/postCreation/constants.ts"),
				E = n("./src/reddit/selectors/platform.ts"),
				v = n("./src/reddit/selectors/postFlair.ts"),
				I = n("./src/reddit/selectors/postRequirements.ts"),
				S = n("./src/reddit/selectors/posts.ts"),
				T = (n("./src/reddit/selectors/runTimeEnvVars.ts"), n("./src/reddit/selectors/subreddit.ts")),
				x = n("./src/reddit/selectors/subredditAutocomplete.ts"),
				C = n("./src/reddit/selectors/user.ts");
			const w = e => {
					const {
						api: t
					} = e.creations, {
						apiError: n,
						pollError: r,
						validationError: s
					} = t.post.submit.error;
					return !!(n || s || t.editor.mediaUpload.error || r)
				},
				P = e => {
					const {
						submitValidationError: t
					} = e.creations.api.post.submit.error;
					return !!t
				},
				D = e => null !== e.creations.formData.postSchedule,
				R = e => (e && e.fields || []).map(e => e.msg),
				A = e => e && "extra" in e ? Object.keys(e.extra).map(t => e.extra[t]) : [],
				k = Object(r.a)(e => e.creations.api.post.submit.error, e => e.creations.api.editor.mediaUpload.error, (e, t) => {
					const {
						apiError: n,
						validationError: r,
						pollError: s
					} = e;
					return [...R(n), ...R(r), ...R(t), ...A(s)]
				}),
				N = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (!n || !Object(d.E)(n)) return !1;
					const {
						subredditName: r,
						profileName: s
					} = n.urlParams, o = Object(i.a)({
						subredditName: r,
						profileName: s
					});
					return !!e.creations.api.page.pending[o]
				},
				L = e => M(e) || U(e),
				M = e => e.creations.api.post.submit.pending,
				U = e => e.creations.api.editor.mediaUpload.pending,
				F = e => e.creations.api.post.submit.error.needsCaptcha,
				B = Object(r.a)(C.i, E.f, e => {
					const t = Object(E.e)(e);
					if (t) {
						const n = Object(x.d)(e, {
							substring: t
						});
						if (n) return n.subreddits.find(e => Object(f.a)(e.name, t))
					}
				}, e => {
					const t = Object(E.f)(e);
					return t && Object(T.A)(e, {
						subredditName: t.name
					})
				}, e => e.platform.currentPage, (e, t, n, r, s) => {
					const {
						profileName: o = "",
						subredditName: i = ""
					} = s && s.urlParams || {};
					if (o) return {
						isProfile: !0,
						name: e && e.username || Object(f.f)(o),
						id: e && e.id || void 0
					}; {
						const {
							name: e = Object(f.f)(i),
							id: s = ""
						} = t || n || {};
						return {
							isProfile: !1,
							allowedPostTypes: r,
							id: s || void 0,
							name: e
						}
					}
				}),
				G = e => {
					const t = B(e);
					return t.name ? t.isProfile ? Object(b.a)(e) ? Object(T.s)(e, t.name) : null : Object(T.y)(e, {
						subredditName: t.name
					}) : null
				},
				V = e => e.creations.formData.submissionType,
				q = e => {
					const t = B(e),
						n = Object(E.f)(e),
						r = V(e),
						s = !!n && n.isNSFW;
					if (r === o.Fb.MEDIA && s) return !1;
					if (t.isProfile) return Object(C.N)(e, t.name);
					if (!t.id) return !1;
					const i = e.moderatingSubreddits[t.id];
					return !!i && (e => Object.keys(e).some(t => !0 === e[t]))(i)
				},
				H = Object(r.a)(V, E.f, B, q, (e, t, n, r) => {
					if (e === o.Fb.POLL) return e;
					const {
						allowedPostTypes: s
					} = n, i = !!t && t.isNSFW;
					if (r && (!i || e !== o.Fb.MEDIA) || !s) return e;
					const c = [s.text && o.Fb.POST, (s.images || s.videos) && !i && o.Fb.MEDIA, s.links && o.Fb.LINK_ONLY, o.Fb.CROSSPOST].filter(Boolean);
					return c.indexOf(e) >= 0 ? e : c[0]
				}),
				K = (e, t) => {
					let {
						postId: n
					} = t;
					return e.creations.postEditing.postId === n
				},
				W = e => e.creations.api.post.update.pending,
				Y = e => !!e.creations.api.post.update.error,
				z = e => e.creations.formState.editorMode || O.h.RICH_TEXT,
				J = Object(r.a)(e => e.creations.api.post.update.error, e => R(e)),
				Q = e => e.creations.postEditing.draft.markdown,
				X = e => e.creations.postEditing.draft.rte,
				Z = e => e.creations.formData.isChatPost,
				$ = e => e.creations.formData.isNSFW,
				ee = e => e.creations.formData.isSpoiler,
				te = e => {
					const {
						isOC: t
					} = e.creations.formData, n = G(e);
					if (n) {
						if (!Object(y.d)(n)) return !1;
						if (n.allOriginalContent) return !0
					}
					return t
				},
				ne = e => e.creations.formData.eventSchedule || void 0,
				re = e => e.creations.formData.postSchedule || void 0,
				se = e => l.d.scheduledPosts(e),
				oe = Object(r.a)(e => e.creations.formData.flair, e => {
					const t = Object(E.d)(e);
					return t ? Object(v.d)(e, {
						subredditId: t
					}) : null
				}, (e, t) => e && e.templateId && t && t.templateIds.includes(e.templateId) ? e : null),
				ie = e => e.creations.formState.editorMode || e.user.prefs.editorMode,
				ce = e => e.creations.formData.title,
				ae = e => e.creations.formData.sendReplies,
				de = e => e.creations.formData.isPublicLink,
				ue = e => e.creations.formState.isChanged,
				le = e => e.creations.formState.submitMode,
				be = e => {
					const {
						name: t
					} = B(e);
					return Object(I.b)(e, {
						subredditName: t
					})
				},
				pe = Object(r.a)(q, be, (e, t) => e || !t || t.bodyRestrictionPolicy !== h.a.NotAllowed),
				me = e => e.creations.formData.body.link,
				fe = e => e.creations.formData.body.markdown,
				ge = Object(r.a)(e => e.creations.formData.body.media, e => e.uploads[O.m], B, C.T, (e, t, n, r) => {
					if (!t) return;
					const o = Object(m.f)(t.metadata.mimetype),
						{
							allowedPostTypes: i
						} = n;
					let c, {
						isMakeGif: a = !1
					} = e && e.video || {};
					if (i) {
						const e = n.name;
						i.images ? i.videos || (c = Object(s.a)(r, "postCreation.mediaInput.makeGif.fixedToOnReason", {
							subredditName: e
						}), a = !0) : (c = Object(s.a)(r, "postCreation.mediaInput.makeGif.fixedToOffReason", {
							subredditName: e
						}), a = !1)
					}
					return {
						file: t.file,
						status: t.status,
						url: t.url,
						websocketUrl: t.websocketUrl,
						mediaType: o || void 0,
						video: "video" === o ? Object.assign({
							thumbnail: {
								time: 0,
								url: t.metadata.videoFirstFrameUrl
							}
						}, e && e.video || {}, {
							duration: t.metadata.videoDuration || 0,
							isMakeGif: a,
							makeGifDisableReason: c
						}) : void 0
					}
				}),
				Oe = e => e.creations.formData.body.rte,
				he = e => e.creations.formData.nextSubreddit,
				ye = e => {
					return !!ce(e).trim()
				},
				je = e => {
					const t = Oe(e);
					return c.a.hasContent(t)
				},
				_e = e => {
					return !!fe(e).trim()
				},
				Ee = e => {
					const t = ge(e);
					return !!t && !!t.file && t.status !== j.a.FAILED
				},
				ve = e => {
					return !!me(e).trim()
				},
				Ie = e => ye(e) || je(e) || _e(e) || Ee(e) || ve(e),
				Se = e => e.creations.formState.modalId || e.activeModalId,
				Te = (e, t) => {
					let {
						field: n
					} = t;
					switch (n) {
						case o.kb.TITLE:
							return {
								title: ce(e)
							};
						case o.kb.BODY:
							if (ie(e) === O.h.RICH_TEXT) {
								const t = Oe(e);
								return {
									rtjson: c.a.toRichTextJSON(t, e.uploads).document
								}
							}
							return {
								selftext: fe(e).trim()
							};
						case o.kb.LINK: {
							const t = me(e);
							if (!t) return;
							return {
								url: t
							}
						}
						case o.kb.FLAIR: {
							const t = oe(e);
							return {
								flairId: t ? t.templateId : void 0
							}
						}
						default:
							return
					}
				},
				xe = (e, t) => {
					const n = B(e),
						r = oe(e),
						s = Z(e),
						o = $(e),
						i = te(e),
						c = ee(e),
						a = ae(e),
						d = ce(e),
						u = de(e);
					return {
						collectionId: e.platform.currentPage.queryParams.collection,
						destSubreddit: n,
						draftId: t,
						flair: r,
						isChatPost: s,
						isNSFW: o,
						isOC: i,
						isSpoiler: c,
						sendReplies: a,
						title: d,
						isPublicLink: u
					}
				},
				Ce = (e, t) => {
					const n = xe(e, t.draftId);
					if (!n || !n.destSubreddit.name) return;
					const r = (e => e.creations.formData.recaptcha)(e),
						s = Re(e, t),
						i = ne(e),
						a = Object.assign({}, n, {
							eventSchedule: i,
							gRecaptchaResponse: r,
							postToTwitter: s,
							validate_on_submit: !0
						}),
						d = ie(e),
						u = me(e),
						l = fe(e),
						b = ge(e),
						p = Oe(e),
						m = pe(e),
						f = H(e),
						{
							uploads: g
						} = e,
						{
							sourcePostId: h
						} = t;
					if (f === o.Fb.LINK_ONLY && u) return Object.assign({}, a, {
						url: u,
						kind: O.p.LINK
					});
					if (f === o.Fb.MEDIA && b) {
						const {
							mediaType: e = "image",
							video: t
						} = b, n = g[O.n], r = "video" === e ? n.url : null;
						return Object.assign({}, a, {
							mediaType: e,
							videoThumbnailUrl: r,
							kind: O.p.MEDIA,
							url: b.url || "",
							makeGif: !!t && t.isMakeGif
						})
					}
					if ((f === o.Fb.POST || f === o.Fb.POLL) && d === O.h.MARKDOWN) return Object.assign({}, a, {
						kind: O.p.MARKDOWN,
						markdown: m ? l : ""
					});
					if ((f === o.Fb.POST || f === o.Fb.POLL) && d === O.h.RICH_TEXT) {
						const e = m && c.a.hasContent(p) ? c.a.toRichTextJSON(p, g).document : [];
						return Object.assign({}, a, {
							kind: O.p.RICH_TEXT,
							document: e
						})
					}
					return f === o.Fb.CROSSPOST && h ? Object.assign({}, a, {
						kind: O.p.CROSSPOST,
						sourcePostId: h
					}) : void 0
				},
				we = (e, t) => {
					let {
						sourcePostId: n
					} = t;
					return n ? Object(S.e)(e, {
						postId: n
					}) : void 0
				},
				Pe = e => {
					const t = ge(e);
					switch (H(e)) {
						case o.Fb.LINK_ONLY:
							return "link";
						case o.Fb.MEDIA:
							return t && "image" !== t.mediaType && t.video ? t.video.isMakeGif ? "videogif" : "video" : "image";
						default:
							return "self"
					}
				},
				De = (e, t) => {
					let {
						pageLayer: n
					} = t;
					if (!n) return _.b;
					const r = Object(d.q)(e, {
						pageLayer: n
					});
					if (r) return Object(g.a)(Object(p.a)(r), _.b);
					const s = Object(d.j)(e, {
						pageLayer: n
					});
					return s && Object(d.C)(e, {
						pageLayer: n
					}) && Object(C.g)(e) ? Object(g.a)(s.url, _.b) : _.b
				},
				Re = (e, t) => {
					const n = Object(u.o)(e, t);
					return (!n || !n.isQuarantined) && e.creations.formData.postToTwitter
				},
				Ae = e => {
					const t = B(e);
					if (!t.id || t.isProfile) return !1;
					const n = {
						id: t.id,
						type: a.a.SUBREDDIT
					};
					return Object(v.b)(e, n, !0, !0)
				}
		},
		"./src/reddit/selectors/postDraft.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "i", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./src/config.ts"),
				s = n("./node_modules/lodash/values.js"),
				o = n.n(s),
				i = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				u = n("./src/reddit/models/PostDraft/index.ts"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const m = Object(i.a)(e => e.creations.drafts, e => o()(e).sort((e, t) => {
					const n = e.modified || e.created;
					return (t.modified || t.created) - n
				})),
				f = (e, t) => {
					let {
						draftId: n
					} = t;
					return n ? e.creations.drafts[n] : null
				},
				g = (e, t) => {
					const n = f(e, t);
					if (n && n.subredditId) {
						const t = Object(b.S)(e, {
							subredditId: n.subredditId
						});
						return t ? t.name : void 0
					}
				},
				O = e => e.creations.api.draft.listing.pending,
				h = e => {
					const {
						api: t
					} = e.creations, {
						apiError: n,
						validationError: r
					} = t.draft.save.error;
					return !(!n && !r)
				},
				y = e => (e && e.fields || []).map(e => e.msg),
				j = (Object(i.a)(e => e.creations.api.draft.save.error, e => {
					const {
						apiError: t,
						validationError: n
					} = e;
					return [...y(t), ...y(n)]
				}), e => e.creations.api.draft.save.pending),
				_ = (e, t) => e.creations.api.draft.deleteDraft.pending[t] || !1,
				E = (e, t) => {
					const n = Object(l.b)(e, t);
					if (!n) return;
					const r = Object(l.m)(e),
						s = Object(l.I)(e),
						o = Object(l.J)(e),
						i = Object(l.V)(e),
						b = Object(l.X)(e),
						p = Object(l.a)(e),
						{
							uploads: m
						} = e;
					if (p === c.Fb.LINK_ONLY) return Object.assign({}, n, {
						body: s,
						kind: u.b.Link
					});
					if (p === c.Fb.POST && r === d.h.MARKDOWN) return Object.assign({}, n, {
						body: b ? o : "",
						kind: u.b.Markdown
					});
					if (p === c.Fb.POST && r === d.h.RICH_TEXT) {
						const e = b ? a.a.toRichTextJSON(i, m).document : [];
						return Object.assign({}, n, {
							body: e,
							kind: u.b.RichText
						})
					}
				},
				v = (e, t) => {
					let {
						draftId: n
					} = t;
					const s = Object(p.i)(e);
					return n && s ? "".concat(r.a.redditUrl, "/user/").concat(s.displayText, "/draft/").concat(n) : ""
				}
		},
		"./src/reddit/selectors/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			}));
			var r = n("./src/lib/objectSelector/index.ts"),
				s = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/flair.ts"),
				i = n("./src/reddit/models/Flair/index.ts"),
				c = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/selectors/posts.ts"),
				d = n("./src/reddit/selectors/user.ts");
			const u = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.postFlair[n]
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !e.postFlair[n] || e.postFlair[n].displaySettings.isEnabled
				},
				b = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = u(e, {
						subredditId: n
					});
					if (r) return {
						type: i.d.LinkFlair,
						displaySettings: r.displaySettings,
						permissions: r.permissions
					}
				}),
				p = function(e, t, n) {
					let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					if (t.type === s.a.PROFILE) return !1;
					const o = t.id,
						i = l(e, {
							subredditId: o
						});
					if (!i) return !1;
					const a = u(e, {
						subredditId: o
					});
					if (!a) return !1;
					if (r) {
						if (!!!(a.templateIds && a.templateIds.length > 0)) return !1
					}
					const d = Object(c.d)(e, {
						subredditId: o
					});
					if (d) return !0;
					const {
						canAssignOwn: b
					} = a.permissions;
					return b && n
				},
				m = (e, t) => {
					let {
						postId: n
					} = t;
					const r = Object(a.I)(e, {
						postId: n
					});
					if (!r) return !1;
					const s = r.flair.some(e => Object(o.p)(e.type)),
						i = Object(d.kb)(e, {
							post: r
						});
					return p(e, r.belongsTo, i, !s)
				}
		},
		"./src/reddit/selectors/postRequirements.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.postRequirements.api.fetch.pending[n.toLowerCase()] || !1
				},
				s = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.postRequirements.models[n.toLowerCase()]
				}
		},
		"./src/reddit/selectors/posts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return v
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "C", (function() {
				return S
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "O", (function() {
				return C
			})), n.d(t, "N", (function() {
				return w
			})), n.d(t, "g", (function() {
				return P
			})), n.d(t, "I", (function() {
				return D
			})), n.d(t, "E", (function() {
				return R
			})), n.d(t, "D", (function() {
				return A
			})), n.d(t, "c", (function() {
				return k
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "L", (function() {
				return L
			})), n.d(t, "M", (function() {
				return M
			})), n.d(t, "T", (function() {
				return F
			})), n.d(t, "U", (function() {
				return B
			})), n.d(t, "b", (function() {
				return G
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "j", (function() {
				return q
			})), n.d(t, "o", (function() {
				return H
			})), n.d(t, "A", (function() {
				return K
			})), n.d(t, "G", (function() {
				return W
			})), n.d(t, "H", (function() {
				return Y
			})), n.d(t, "K", (function() {
				return z
			})), n.d(t, "y", (function() {
				return J
			})), n.d(t, "R", (function() {
				return Q
			})), n.d(t, "J", (function() {
				return Z
			})), n.d(t, "z", (function() {
				return $
			})), n.d(t, "u", (function() {
				return ee
			})), n.d(t, "m", (function() {
				return te
			})), n.d(t, "w", (function() {
				return ne
			})), n.d(t, "S", (function() {
				return re
			})), n.d(t, "p", (function() {
				return se
			})), n.d(t, "q", (function() {
				return oe
			})), n.d(t, "v", (function() {
				return ie
			})), n.d(t, "t", (function() {
				return ce
			})), n.d(t, "n", (function() {
				return ae
			})), n.d(t, "s", (function() {
				return de
			})), n.d(t, "r", (function() {
				return ue
			})), n.d(t, "Q", (function() {
				return le
			})), n.d(t, "a", (function() {
				return be
			})), n.d(t, "B", (function() {
				return pe
			})), n.d(t, "P", (function() {
				return me
			})), n.d(t, "k", (function() {
				return fe
			})), n.d(t, "V", (function() {
				return ge
			})), n.d(t, "F", (function() {
				return Oe
			})), n.d(t, "h", (function() {
				return he
			})), n.d(t, "x", (function() {
				return je
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/camelCase.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/isEmpty.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/uniqBy.js"),
				a = n.n(c),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/isPinnedAdminPost/index.ts"),
				l = n("./src/lib/objectSelector/index.ts"),
				b = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				p = n("./src/reddit/constants/posts.ts"),
				m = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/models/Subreddit/index.ts"),
				g = n("./src/reddit/models/Widgets/index.ts"),
				O = (n("./src/reddit/models/Profile/mock.ts"), n("./src/reddit/models/Subreddit/mock.ts"), n("./src/reddit/helpers/flair.ts")),
				h = n("./src/reddit/models/Flair/index.ts"),
				y = n("./src/reddit/selectors/profile.ts"),
				j = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/selectors/user.ts");
			const E = [],
				v = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.models[n].media && (e.posts.models[n].media.type === m.n.EMBED || e.posts.models[n].media.type === m.n.IMAGE)
				},
				I = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.models[n].media && e.posts.models[n].media.type === m.n.GIFVIDEO
				},
				S = Object(l.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = e.posts.models;
					return x(e, {
						listingKey: n
					}).filter(e => {
						const t = r[e];
						return t && !t.hidden
					})
				}),
				T = Object(d.a)(e => e.posts.models, e => Object.keys(e).filter(t => e[t].hidden)),
				x = Object(l.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					return [...e.listings.postOrder.ids[n] || []]
				}),
				C = Object(l.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					return S(e, {
						listingKey: n
					}).map(t => e.posts.models[t])
				}),
				w = (e, t) => {
					let {
						listingKey: n
					} = t;
					const r = C(e, {
						listingKey: n
					});
					return r ? r.length : 0
				},
				P = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.shortcuts.activePostId && n === e.shortcuts.activePostId
				},
				D = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.models[n]
				},
				R = (e, t) => {
					let {
						postId: n
					} = t;
					return D(e, {
						postId: n
					}).isLocked
				},
				A = (e, t) => {
					let {
						postId: n
					} = t;
					return D(e, {
						postId: n
					}).isArchived
				},
				k = (e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
						postId: n
					});
					if (r && r.crosspostRootId) return D(e, {
						postId: r.crosspostRootId
					}) || void 0
				},
				N = (e, t) => {
					let {
						postId: n
					} = t;
					return k(e, {
						postId: n
					}) || D(e, {
						postId: n
					}) || void 0
				},
				L = e => e.posts.models,
				M = Object(l.a)((e, t) => {
					let {
						postIds: n
					} = t;
					const r = e.posts.models,
						s = {};
					return n.map(e => {
						s[e] = r[e]
					}), s
				}),
				U = Object(d.a)(e => e.posts.models, S, (e, t) => t.limit, (e, t, n) => {
					let r = t;
					return n && (r = t.slice(0, n)), r.reduce((t, n) => (t[n] = e[n], t), {})
				}),
				F = Object(l.a)((e, t) => {
					const n = U(e, t),
						r = {},
						s = e.posts.models;
					return Object.keys(n).forEach(e => {
						const {
							crosspostRootId: t
						} = n[e];
						t && (r[t] = s[t])
					}), Object.assign({}, n, r)
				}),
				B = (e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
						postId: n
					});
					if (!r) return;
					const {
						belongsTo: s
					} = r;
					return s.type === p.a.PROFILE ? e.profiles.models[s.id] || !1 : e.subreddits.models[s.id] || !1
				},
				G = (e, t) => {
					let {
						postId: n
					} = t;
					const r = B(e, {
						postId: n
					});
					if (r) return Object(f.e)(r) ? Object(g.h)(r) : Object(g.i)(r)
				},
				V = (e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
						postId: n
					});
					return r && r.crosspostRootId ? B(e, {
						postId: r.crosspostRootId
					}) : null
				},
				q = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.expanded[n]
				},
				H = (e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
						postId: n
					});
					return r && r.isMeta
				},
				K = (e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
						postId: n
					});
					return r && r.contestMode
				},
				W = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return "";
					const r = D(e, {
						postId: n
					});
					return r && r.liveCommentsWebsocket ? r.liveCommentsWebsocket : ""
				},
				Y = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return "";
					const r = D(e, {
						postId: n
					});
					return r ? r.permalink : ""
				},
				z = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return null;
					const r = Y(e, {
						postId: n
					});
					return Object(b.a)(r)
				},
				J = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return 0;
					return D(e, {
						postId: n
					}).numDuplicates || 0
				},
				Q = Object(l.a)(e => {
					return e.posts.recent.map(t => e.posts.models[t]).filter(e => !!e)
				}),
				X = e => (t, n) => {
					let {
						postId: r
					} = n;
					if (!r) return !1;
					const s = D(t, {
						postId: r
					});
					return !!s && !!s[e]
				},
				Z = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return null;
					const r = D(e, {
						postId: n
					});
					return r && r.belongsTo.type !== p.a.PROFILE ? Object(j.I)(e, {
						identifier: r.belongsTo
					}) : null
				},
				$ = (e, t) => t.postCategories,
				ee = X("saved"),
				te = X("hidden"),
				ne = X("isSponsored"),
				re = X("sendReplies"),
				se = X("isNSFW"),
				oe = X("isOriginalContent"),
				ie = X("isSpoiler"),
				ce = (e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
							postId: n
						}),
						s = Object(y.m)(e, r.author),
						o = e.profiles.pinnedPosts.data[s];
					return !!o && o.includes(n)
				},
				ae = (e, t, n) => {
					const r = Object(y.m)(e, n),
						s = e.profiles.pinnedPosts.initialData[r];
					return !!s && s.includes(t)
				},
				de = (e, t, n) => {
					const r = Object(y.m)(e, n),
						s = e.profiles.pinnedPosts.data[r];
					return !!s && s.includes(t)
				},
				ue = (e, t) => ce(e, t) !== ((e, t) => {
					let {
						postId: n
					} = t;
					const r = D(e, {
							postId: n
						}),
						s = Object(y.m)(e, r.author),
						o = e.profiles.pinnedPosts.pending[s];
					return !!o && o.includes(n)
				})(e, t),
				le = Object(l.a)((e, t) => {
					const n = Object(y.m)(e, t.profileName);
					return e.profiles.pinnedPosts.data[n] || []
				}),
				be = (e, t) => {
					const n = Object(y.m)(e, t.profileName);
					return !!e.profiles.pinnedPosts.data[n]
				},
				pe = (e, t) => {
					const n = D(e, {
							postId: t
						}),
						r = (new Date).getTime();
					return !!n && (r - n.created) / 1e3 / 60 / 60 < 24
				},
				me = Object(l.a)((e, t) => {
					const n = S(e, t);
					return t.excludePinnedPosts ? n.filter(t => !ce(e, {
						postId: t
					})) : n
				}),
				fe = (e, t) => {
					let {
						profileName: n
					} = t;
					const r = le(e, {
						profileName: n
					});
					if (!r.length) return !1;
					const [s] = r, o = D(e, {
						postId: s
					});
					return !!o && (!(n.toLowerCase() === o.author.toLowerCase()) && Object(u.a)(!0, o.distinguishType))
				},
				ge = Object(l.a)((e, t) => {
					const {
						models: n
					} = e.posts;
					return t.filter(e => {
						const t = n[e];
						return !!t && !t.isBlank && !t.hidden
					})
				}),
				Oe = (e, t, n, r) => {
					const s = S(e, {
						listingKey: t
					});
					if (r) {
						const t = Object(j.G)(e, n);
						if (t) {
							if (!!e.subreddits.appliedFilters.meta[t]) {
								const t = e.posts.metaMap;
								return s.filter(e => !!t[e])
							}
						}
					}
					return s
				},
				he = (e, t) => {
					const n = D(e, t);
					if (!n || n.belongsTo.type === p.a.SUBREDDIT) return !1;
					const r = B(e, t);
					return !!r && Object(_.N)(e, r.name)
				},
				ye = Object(d.a)((e, t) => t.postId, S, (e, t) => {
					const n = t.indexOf(e);
					return n >= 0 ? t[n + 1] : void 0
				}),
				je = Object(d.a)(ye, e => e.posts.models, (e, t) => e && t[e] || void 0);
			Object(d.a)((e, t) => C(e, t), (e, t) => Object(j.u)(e, t), (e, t) => {
				const n = (e => {
						const t = {};
						return e.map(e => {
							e.flair && e.flair.map(e => {
								const n = Object(O.g)(e),
									r = s()(n),
									o = r && t.hasOwnProperty(r);
								e.type !== h.f.Spoiler && e.type !== h.f.Nsfw && (o || (t[r] = Object.assign({}, e, {
									id: r
								})))
							})
						}), i()(t) ? E : Object.values(t)
					})(e),
					r = (e => {
						const t = e.find(e => "post-flair" === e.kind),
							n = t && t.templates,
							r = {};
						for (const o in n) {
							const e = n[o],
								t = Object(O.g)(e),
								i = s()(t);
							i && r.hasOwnProperty(i) || (r[i] = Object.assign({}, e, {
								id: i
							}))
						}
						return i()(r) ? E : Object.values(r)
					})(t);
				return a()([...n, ...r], "id")
			})
		},
		"./src/reddit/selectors/profile.ts": function(e, t, n) {
			"use strict";
			n.d(t, "p", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "q", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "n", (function() {
				return I
			})), n.d(t, "o", (function() {
				return S
			})), n.d(t, "r", (function() {
				return T
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "e", (function() {
				return w
			}));
			var r = n("./src/lib/objectSelector/index.ts"),
				s = n("./src/reddit/i18n/utils.ts"),
				o = n("./src/reddit/models/Multireddit/index.ts"),
				i = n("./src/reddit/models/User/index.ts"),
				c = n("./src/reddit/selectors/subreddit.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./node_modules/reselect/es/index.js");
			const u = [],
				l = (e, t) => {
					let {
						profileId: n
					} = t;
					return e.profiles.models[n]
				},
				b = (e, t) => {
					let {
						profileName: n
					} = t;
					return e.profiles.models[f(e, n)]
				},
				p = (e, t) => e.profiles.models[t],
				m = Object(d.a)(e => e.profiles.models, e => {
					const t = {};
					for (const n in e) {
						const r = e[n];
						t[r.name.toLowerCase()] = r.id
					}
					return t
				}),
				f = (e, t) => m(e)[t ? t.toLowerCase() : ""],
				g = (e, t) => {
					let {
						profileName: n
					} = t;
					const {
						pending: r
					} = e.profiles.moderated.api;
					return !!(n && n in r) && r[n.toLowerCase()]
				},
				O = (e, t) => {
					let {
						profileName: n
					} = t;
					const {
						pending: r
					} = e.profiles.multireddits.api;
					return !!(n && n in r) && r[n.toLowerCase()]
				},
				h = (e, t) => {
					let {
						profileName: n
					} = t;
					const r = Object(a.i)(e);
					if (!r || !n) return !1;
					const s = Object(i.f)(r);
					return I(e, {
						profileName: s
					}).some(e => e.name.toLowerCase() === n.toLowerCase())
				},
				y = (e, t) => {
					let {
						profileName: n
					} = t;
					const r = b(e, {
						profileName: n
					});
					return r && "".concat(r.title || r.name, " (").concat(r.displayText, ") - Reddit") || Object(s.c)("reddit: the front page of the internet")
				},
				j = (e, t) => {
					let {
						profileName: n
					} = t;
					const r = f(e, n);
					return e.profiles.about[r]
				},
				_ = (e, t) => e.profiles.about[t],
				E = Object(r.a)((e, t) => {
					let {
						profileName: n
					} = t;
					return void 0 !== e.profiles.moderated.models[n ? n.toLowerCase() : ""]
				}),
				v = (e, t) => {
					let {
						profileName: n
					} = t;
					return void 0 !== e.profiles.multireddits.pageInfo[n ? n.toLowerCase() : ""]
				},
				I = Object(r.a)((e, t) => {
					let {
						profileName: n
					} = t;
					const r = e.profiles.moderated.models[n ? n.toLowerCase() : ""];
					if (!r) return u;
					const s = [];
					return r.forEach(t => {
						Object(c.S)(e, {
							subredditId: t
						}) ? s.push(Object(c.S)(e, {
							subredditId: t
						})) : l(e, {
							profileId: t
						}) && s.push(l(e, {
							profileId: t
						}))
					}), s
				}),
				S = Object(d.a)((e, t) => {
					const n = Object(a.ib)(e, {
						userName: t.profileName
					});
					return n ? e.multireddits.byUserId[n.id] : null
				}, e => e.multireddits.models, (e, t) => e ? e.map(e => t[e]).filter(e => e.visibility === o.e.Public) : null),
				T = Object(d.a)(e => e.trophies, e => e.profiles.trophyCases, (e, t) => t, (e, t, n) => {
					const r = t[n];
					return r ? r.map(t => e[t]) : []
				}),
				x = (e, t) => {
					let {
						extraCommentsId: n
					} = t;
					return e.profileOverviewPage.conversations.extraComments.models[n]
				},
				C = (e, t) => {
					let {
						profileName: n
					} = t;
					return e.profiles.moderated.pageInfo[n] ? e.profiles.moderated.pageInfo[n].hasNextPage : void 0
				},
				w = (e, t) => {
					let {
						profileName: n
					} = t;
					return !!e.profiles.multireddits.pageInfo[n] && e.profiles.multireddits.pageInfo[n].hasNextPage
				}
		},
		"./src/reddit/selectors/profileComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return c
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var r = n("./node_modules/lodash/set.js"),
				s = n.n(r),
				o = n("./src/lib/objectSelector/index.ts"),
				i = n("./src/reddit/selectors/comments.ts");
			const c = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileCommentsPage.commentIds[n] || []
				},
				a = Object(o.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = Object(i.r)(e);
					return c(e, {
						listingKey: n
					}).reduce((e, t) => s()(e, t, r[t].postId), {})
				}),
				d = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileCommentsPage.api.error[n]
				},
				u = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileCommentsPage.api.pending[n]
				},
				l = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileCommentsPage.loadMore[n]
				},
				b = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileCommentsPage.fetchedTokens[n]
				}
		},
		"./src/reddit/selectors/profileOverviewChronoItems.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./src/lib/objectSelector/index.ts"),
				s = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/PostCreationForm/index.ts");
			s.f.Text, s.f.Spoiler, s.f.Text, s.f.Spoiler, o.h.RICH_TEXT, s.f.Text, s.f.Spoiler, o.h.RICH_TEXT, s.f.Text, s.f.Spoiler, o.h.RICH_TEXT;
			var i = n("./src/reddit/helpers/isComment.ts");
			n.d(t, "f", (function() {
				return c
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			}));
			const c = Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = e.posts.models;
					return a(e, {
						listingKey: n
					}).filter(e => {
						if (Object(i.a)(e)) return !0; {
							const t = r[e];
							return t && !t.hidden
						}
					})
				}),
				a = Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = e.profileOverviewPage.chrono.ids[n];
					return r ? [...r] : []
				}),
				d = Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					return c(e, {
						listingKey: n
					}).reduce((t, n) => {
						const r = Object(i.a)(n) ? e.comments.models[n].postId : n;
						return t[n] = r, t
					}, {})
				}),
				u = (Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = e.posts.models;
					return u(e, {
						listingKey: n
					}).filter(e => {
						const t = r[e];
						return t && !t.hidden
					})
				}), Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					return c(e, {
						listingKey: n
					}).map(t => Object(i.a)(t) ? e.comments.models[t].postId : t)
				})),
				l = Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = e.posts.models,
						s = u(e, {
							listingKey: n
						}),
						o = {};
					return s.forEach(e => o[e] = r[e]), o
				}),
				b = Object(r.a)((e, t) => {
					let {
						listingKey: n
					} = t;
					const r = e.comments.models,
						s = c(e, {
							listingKey: n
						}),
						o = {};
					return s.forEach(e => !!Object(i.a)(e) && (o[e] = r[e])), o
				}),
				p = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.api.error[n]
				},
				m = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.api.pending[n]
				},
				f = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.loadMore[n]
				},
				g = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.profileOverviewPage.chrono.fetchedTokens[n]
				}
		},
		"./src/reddit/selectors/runTimeEnvVars.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			n("./src/lib/constants/index.ts");
			const r = e => e.runTimeEnvVars.staging,
				s = e => r(e),
				o = e => e.runTimeEnvVars.startTimeInMillis
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			}));
			var r = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				s = n("./src/reddit/models/Flair/index.ts");
			const o = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.posts.scheduledPosts.standalonePosts.models[n]
				},
				i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.posts.scheduledPosts.standalonePosts.pageInfo[n] && e.posts.scheduledPosts.standalonePosts.pageInfo[n].hasNextPage
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.posts.scheduledPosts.standalonePosts.pageInfo[n] ? e.posts.scheduledPosts.standalonePosts.pageInfo[n].endCursor : null
				},
				a = e => e.posts.scheduledPosts.api.pending,
				d = e => e.posts.scheduledPosts.api.pendingUpdate,
				u = {},
				l = [],
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[n] || l).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[n] || u)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[n][t])
				},
				p = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: r
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.models[n] || u)[r] || void 0
				},
				m = e => e.creations.formData.scheduledPostId,
				f = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: n,
							isSpoiler: o,
							isOriginalContent: i
						} = e;
						const c = [];
						return i && c.push({
							text: "OC",
							type: s.f.Oc
						}), t && c.push(...Object(r.b)(t)), o && c.push({
							text: "spoiler",
							type: s.f.Spoiler
						}), n && c.push({
							text: "nsfw",
							type: s.f.Nsfw
						}), c
					})(t)
				},
				g = e => {
					let {
						scheduledPost: t
					} = e;
					const n = f({
							scheduledPost: t
						}),
						r = n.find(e => e.type === s.f.Richtext);
					return r || (n.find(e => e.type === s.f.Text) || null)
				}
		},
		"./src/reddit/selectors/searchResults.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "g", (function() {
				return b
			}));
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			const r = [],
				s = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.api.error[n]
				},
				o = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.api.pending[n]
				},
				i = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.identifiers[n] || []
				},
				c = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.listings.listingOrder.loadMore[n]
				},
				a = e => {
					const t = e.search.searchQuery;
					if (!t) return r;
					const n = e.search.typeahead.idsByQuery[t.toLowerCase()];
					if (!n) return r;
					const s = [];
					return n.forEach(t => {
						s.push(e.search.typeahead.models[t])
					}), s
				},
				d = e => e.search.typeahead.idsByQuery,
				u = e => {
					const t = e.listings.activeKey;
					return e.search.viewTreatment[t]
				},
				l = e => {
					const t = e.listings.activeKey;
					if (t) return e.searchDiscoveryUnits.headerContent[t]
				},
				b = (e, t) => t ? e.search.relatedQueries[t.toLowerCase()] : r
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/selectors/user.ts");
			const o = e => !Object(s.K)(e) && e.seo.linksModule.frontpage || null,
				i = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				c = Object(r.a)(o, e => e ? e.map(e => Object.assign({}, e, {
					links: e.links.map(e => Object.assign({}, e, {
						title: i(e.url)
					})).filter(e => e.title)
				})) : null),
				a = Object(r.a)(c, e => e ? e.map(e => Object.assign({}, e, {
					links: e.links.filter(e => e.visible)
				})) : null)
		},
		"./src/reddit/selectors/structuredStyles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return l
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "q", (function() {
				return O
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "o", (function() {
				return E
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "n", (function() {
				return I
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "i", (function() {
				return x
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "m", (function() {
				return P
			}));
			var r = n("./node_modules/lodash/isEqual.js"),
				s = n.n(r),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/lib/objectSelector/index.ts"),
				c = n("./src/reddit/models/StructuredStyles/index.ts"),
				a = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/subreddit.ts"),
				u = n("./src/reddit/selectors/user.ts");
			const l = e => e.structuredStyles.isEditing,
				b = (e, t) => e.structuredStyles.models[t.subredditId],
				p = Object(o.a)(b, e => Object(c.h)(e)),
				m = e => e.structuredStyles.draft,
				f = {},
				g = Object(i.a)((e, t) => {
					const n = ((e, t) => {
						const n = b(e, t);
						if (n) return {
							url: n.communityIcon,
							color: n.primaryColor
						}
					})(e, t);
					if (n && n.url) return n;
					const r = n ? n.color : void 0;
					return ((e, t) => e && e.icon ? {
						url: e.icon.url,
						color: t
					} : f)(Object(d.S)(e, t), r)
				}),
				O = (e, t) => {
					const n = Object(d.G)(e, t.subredditName);
					return n ? g(e, {
						subredditId: n
					}) : f
				},
				h = e => {
					const t = Object(a.d)(e);
					return t ? g(e, {
						subredditId: t
					}) : f
				},
				y = (e, t) => {
					const n = e.structuredStyles.imagePreviews[t.name];
					if (n && n in e.imageUploads) return e.imageUploads[n]
				},
				j = Object(i.a)(e => {
					const t = e.structuredStyles.imagePreviews,
						n = {};
					for (const r in t) {
						const t = y(e, {
							name: r
						});
						t && (n[r] = t.url)
					}
					return n
				}),
				_ = (e, t) => m(e)[t.name],
				E = e => e.structuredStyles.models,
				v = e => e.structuredStyles.flairTemplate.models,
				I = (e, t) => e.structuredStyles.models[t],
				S = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.structuredStyles.models[n];
					return r && r.communityIcon ? r.communityIcon : null
				},
				T = e => e.structuredStyles.exportStyles.pending,
				x = e => e.structuredStyles.isBladeEditorDirty,
				C = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.subreddits.about[n],
						s = r && r.quarantinePermissions;
					return !!s && !s.styles
				},
				w = Object(o.a)(l, x, m, (e, t) => t.subredditId && b(e, {
					subredditId: t.subredditId
				}), (e, t, n, r) => !(!e || !n) && (t || !s()(n, r))),
				P = (e, t) => {
					if (Object(u.gb)(e)) return !0;
					if (t) {
						const n = t.subredditId || t.subredditName && Object(d.G)(e, t.subredditName);
						if (n && Object(u.fb)(e, {
								subredditId: n
							})) return !0
					}
					return !1
				}
		},
		"./src/reddit/selectors/subreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "Z", (function() {
				return j
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "c", (function() {
				return I
			})), n.d(t, "I", (function() {
				return S
			})), n.d(t, "M", (function() {
				return T
			})), n.d(t, "L", (function() {
				return x
			})), n.d(t, "Y", (function() {
				return C
			})), n.d(t, "S", (function() {
				return w
			})), n.d(t, "X", (function() {
				return P
			})), n.d(t, "ab", (function() {
				return D
			})), n.d(t, "cb", (function() {
				return R
			})), n.d(t, "o", (function() {
				return k
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "t", (function() {
				return L
			})), n.d(t, "bb", (function() {
				return F
			})), n.d(t, "B", (function() {
				return B
			})), n.d(t, "a", (function() {
				return G
			})), n.d(t, "G", (function() {
				return V
			})), n.d(t, "H", (function() {
				return H
			})), n.d(t, "j", (function() {
				return K
			})), n.d(t, "y", (function() {
				return W
			})), n.d(t, "s", (function() {
				return Y
			})), n.d(t, "J", (function() {
				return z
			})), n.d(t, "K", (function() {
				return J
			})), n.d(t, "V", (function() {
				return Q
			})), n.d(t, "R", (function() {
				return X
			})), n.d(t, "O", (function() {
				return Z
			})), n.d(t, "P", (function() {
				return $
			})), n.d(t, "Q", (function() {
				return ee
			})), n.d(t, "F", (function() {
				return te
			})), n.d(t, "A", (function() {
				return ne
			})), n.d(t, "D", (function() {
				return re
			})), n.d(t, "C", (function() {
				return se
			})), n.d(t, "u", (function() {
				return oe
			})), n.d(t, "m", (function() {
				return ie
			})), n.d(t, "e", (function() {
				return ce
			})), n.d(t, "g", (function() {
				return ae
			})), n.d(t, "l", (function() {
				return de
			})), n.d(t, "i", (function() {
				return ue
			})), n.d(t, "n", (function() {
				return le
			})), n.d(t, "k", (function() {
				return be
			})), n.d(t, "z", (function() {
				return pe
			})), n.d(t, "f", (function() {
				return me
			})), n.d(t, "U", (function() {
				return fe
			})), n.d(t, "T", (function() {
				return ge
			})), n.d(t, "E", (function() {
				return Oe
			})), n.d(t, "W", (function() {
				return he
			})), n.d(t, "w", (function() {
				return ye
			})), n.d(t, "v", (function() {
				return je
			})), n.d(t, "x", (function() {
				return _e
			})), n.d(t, "N", (function() {
				return Ee
			})), n.d(t, "r", (function() {
				return ve
			})), n.d(t, "p", (function() {
				return Ie
			})), n.d(t, "q", (function() {
				return Te
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/isFakeSubreddit/index.ts"),
				i = n("./src/lib/objectSelector/index.ts"),
				c = n("./src/reddit/constants/posts.ts"),
				a = n("./src/reddit/helpers/isPost.ts"),
				d = n("./src/reddit/i18n/utils.ts"),
				u = (n("./src/reddit/models/Profile/mock.ts"), n("./src/reddit/models/Subreddit/index.ts")),
				l = (n("./src/reddit/models/Subreddit/mock.ts"), n("./src/reddit/models/SubredditRestrictions/index.ts")),
				b = n("./src/reddit/models/Widgets/index.ts"),
				p = n("./src/reddit/selectors/comments.ts"),
				m = n("./src/reddit/selectors/moderatorPermissions.ts"),
				f = n("./src/reddit/selectors/platform.ts"),
				g = n("./src/reddit/selectors/posts.ts"),
				O = n("./src/reddit/selectors/profile.ts"),
				h = n("./src/reddit/selectors/user.ts");
			const y = [],
				j = Object(i.a)((e, t) => {
					let {
						subredditIds: n
					} = t;
					if (0 === n.length) return y;
					const r = [];
					return n.forEach(t => {
						const n = e.subreddits.models[t];
						n && r.push(n)
					}), r
				}),
				_ = (e, t) => {
					let {
						profileName: n
					} = t;
					if (!n) return null;
					const r = Object(O.j)(e, n);
					return r ? r.url : "/user/".concat(n, "/")
				},
				E = (e, t) => {
					const n = t.toLowerCase();
					return e ? e.url : Object(o.a)(n) ? "/r/" + n + "/" : null
				},
				v = (e, t) => {
					let {
						subredditName: n
					} = t;
					if (!n) return null;
					const r = V(e, n),
						s = w(e, {
							subredditId: r
						});
					return E(s, n)
				},
				I = (e, t) => {
					const n = w(e, {
						subredditId: t
					});
					if (n) return E(n, n.name) || "";
					const r = Object(O.p)(e, {
						profileId: t
					});
					return r ? r.url : ""
				},
				S = (e, t) => {
					let {
						identifier: n
					} = t;
					return n.type === c.a.PROFILE ? e.profiles.about[n.id] || {} : e.subreddits.about[n.id]
				},
				T = (e, t) => {
					let {
						identifier: n
					} = t;
					return n.type === c.a.PROFILE ? e.profiles.models[n.id] || !1 : e.subreddits.models[n.id] || !1
				},
				x = (e, t) => {
					let {
						identifier: n
					} = t;
					return n.type === c.a.PROFILE ? Object(O.m)(e, n.name) || null : V(e, n.name) || null
				},
				C = e => e.subreddits.models,
				w = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.subreddits.models[n] || !1
				},
				P = (e, t) => {
					const n = w(e, t);
					if (n) return n.type
				},
				D = e => e.subreddits.trending,
				R = (e, t) => {
					let {
						identifier: n
					} = t;
					const r = x(e, {
						identifier: n
					});
					if (!r) return !1;
					const s = S(e, {
						identifier: {
							id: r,
							type: n.type
						}
					});
					return s && Object(h.K)(e) ? !!s.userIsSubscriber : n.type === c.a.SUBREDDIT ? e.subscriptions.subredditOrder.indexOf(r) > -1 : e.subscriptions.profileOrder.indexOf(r) > -1
				},
				A = (e, t) => {
					let {
						subredditName: n,
						action: r
					} = t;
					const s = W(e, {
						subredditName: n
					});
					return !!(s && r && (Object(m.g)(e, {
						subredditId: V(e, n)
					}) || s.userIsContributor || r === l.e.Post && !1 === s.restrictPosting || r === l.e.Comment && !1 === s.restrictCommenting))
				},
				k = e => {
					const t = Object(f.f)(e);
					if (t && "restricted" === t.type) {
						const n = pe(e)[t.id];
						if (n) return n.restrictCommenting && n.restrictPosting ? l.e.PostAndComment : n.restrictCommenting ? l.e.Comment : l.e.Post
					}
					return l.e.View
				},
				N = (e, t) => {
					const n = Object(f.f)(e),
						r = Object(h.K)(e),
						o = 3 * s.w,
						i = Date.now() - o;
					if (n && r && "restricted" === n.type) {
						if (A(e, {
								subredditName: n.name,
								action: t
							})) return !1;
						const r = Object(h.mb)(e).subreddit[n.id];
						if ((r ? r.isContributorRequestTimestamp : 0) > i) return !0
					}
					return !1
				},
				L = (e, t) => {
					const n = Object(f.f)(e);
					if (Object(h.K)(e) && n && "restricted" === n.type) {
						const r = !A(e, {
								subredditName: n.name,
								action: t
							}),
							s = !N(e);
						if (r && s) return !0
					}
					return !1
				},
				M = Object(r.a)(e => e.subreddits.models, e => {
					const t = {};
					for (const n in e) {
						const r = e[n];
						r.type !== u.c.User && (t[r.name.toLowerCase()] = r.id)
					}
					return t
				}),
				U = Object(r.a)(e => e.subreddits.unavailableModels, e => {
					const t = {};
					for (const n in e) {
						const r = e[n];
						t[r.name.toLowerCase()] = r.id
					}
					return t
				}),
				F = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.subreddits.unavailableModels[((e, t) => U(e)[t ? t.toLowerCase() : ""])(e, n)]
				},
				B = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.subreddits.models[V(e, n)]
				},
				G = (e, t) => {
					let {
						subredditName: n
					} = t;
					return B(e, {
						subredditName: n
					}) || F(e, {
						subredditName: n
					})
				},
				V = (e, t) => M(e)[t ? t.toLowerCase() : ""],
				q = Object(r.a)(e => e.subreddits.communityInfo, e => {
					const t = {};
					for (const n in e) {
						const r = e[n];
						r.id && (t[r.name.toLowerCase()] = r.id)
					}
					return t
				}),
				H = (e, t) => q(e)[t ? t.toLowerCase() : ""],
				K = e => {
					const t = Object(f.e)(e);
					return t ? W(e, {
						subredditName: t
					}) : null
				},
				W = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.subreddits.about[V(e, n)]
				},
				Y = (e, t) => {
					const n = Object(O.j)(e, {
						profileName: t
					});
					return n ? e.subreddits.about[n.id] : void 0
				},
				z = (e, t) => {
					let {
						commentId: n
					} = t;
					const r = Object(p.n)(e, {
						commentId: n
					});
					if (!r) return;
					const s = r.subredditId;
					return e.profiles.models[s] || e.subreddits.models[s]
				},
				J = (e, t) => {
					let {
						thingId: n
					} = t;
					if (Object(a.a)(n)) {
						const t = Object(g.I)(e, {
							postId: n
						});
						if (!t) return;
						return T(e, {
							identifier: t.belongsTo
						})
					}
					return z(e, {
						commentId: n
					})
				},
				Q = (e, t) => {
					let {
						subredditName: n
					} = t;
					const r = B(e, {
						subredditName: n
					});
					return r && r.title || Object(d.c)("reddit: the front page of the internet")
				},
				X = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.subreddits.rules[n] ? e.subreddits.rules[n].rules : y
				},
				Z = Object(i.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					return e.subreddits.rules[n] ? e.subreddits.rules[n].rules.map(e => e.shortName) : y
				}),
				$ = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.subreddits.rules[n]
				},
				ee = e => e.subreddits.api.rules,
				te = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.subreddits.models[n] && !!e.subreddits.models[n].freeFormReports
				},
				ne = (e, t) => {
					let {
						subredditName: n
					} = t;
					const r = W(e, {
						subredditName: n
					});
					return r && r.allowedPostTypes
				},
				re = (e, t) => {
					let {
						subredditName: n
					} = t;
					const r = W(e, {
						subredditName: n
					});
					return r && r.coins
				},
				se = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.subreddits.about[n];
					return r && r.coins
				},
				oe = (e, t) => {
					let {
						subredditName: n
					} = t;
					const r = V(e, n),
						s = e.widgets.sidebar[r],
						o = [],
						i = e.widgets.moderatorIds[r],
						c = e.widgets.models[i];
					let a = !1;
					return s && s.forEach((function(t) {
						e.widgets.models[t] && (o.push(e.widgets.models[t]), t === i && (a = !0))
					})), c && !a && o.push(c), o
				},
				ie = (e, t) => {
					return w(e, t).name === s.Eb
				},
				ce = (Object(i.a)(e => {
					const {
						order: t
					} = e.subreddits.moderated, n = e.subreddits.models;
					return t && t.length ? t.map(e => n[e]) : []
				}), (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.subredditChannels.api.whitelist[n]
				}),
				ae = Object(i.a)((e, t) => j(e, t).map(e => Object(b.i)(e))),
				de = e => e.subreddits.api.create.pending,
				ue = e => e.subreddits.api.create.error.apiError,
				le = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !(!e.subreddits.about[n] || !e.subreddits.about[n].usingNewModmail)
				},
				be = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n].belongsTo.id;
					return !!e.subreddits.rules[r]
				},
				pe = e => e.subreddits.about,
				me = Object(i.a)(Object(r.a)(j, pe, (e, t) => {
					const n = [];
					return e.forEach(e => {
						e.type === u.c.Public && n.push(Object(b.i)(e, t[e.id]))
					}), n
				})),
				fe = (e, t) => e.subreddits.settings[t],
				ge = e => e.subreddits.api.settings.pending,
				Oe = (e, t) => {
					let {
						subredditId: n
					} = t, r = e.user.prefs.sort;
					if (e.user.prefs.rememberCommunitySort) {
						const t = e.user.prefs.subreddit[n];
						t && t.sort && (r = t.sort)
					}
					return r
				},
				he = (e, t) => {
					let {
						subredditName: n
					} = t;
					return e.subreddits.topContent[n.toLowerCase()]
				},
				ye = (e, t) => e.subreddits.api.similar.pending[t.key] || !1,
				je = (e, t) => e.subreddits.similar[t.key] || y,
				_e = (e, t) => {
					const n = je(e, t);
					return j(e, {
						subredditIds: n
					})
				},
				Ee = (e, t) => e.subreddits.rankings[t],
				ve = (e, t) => e.subreddits.api.onboarding.pending[t.key] || !1,
				Ie = (e, t) => e.subreddits.onboarding[t.key] || y,
				Se = Object(r.a)(Ie, e => e.subreddits.models, (e, t) => e.map(e => t[e]).filter(Boolean)),
				Te = Object(r.a)(Se, e => e.map(e => e.name))
		},
		"./src/reddit/selectors/subredditAutocomplete.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var r = n("./node_modules/lodash/isNil.js"),
				s = n.n(r),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/helpers/name/index.ts"),
				c = n("./src/reddit/models/Subreddit/index.ts"),
				a = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				d = n("./src/reddit/models/User/index.ts"),
				u = n("./src/reddit/selectors/subscriptions.ts"),
				l = n("./src/reddit/selectors/user.ts");
			n.d(t, "d", (function() {
				return g
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "e", (function() {
				return S
			}));
			var b = function(e, t) {
				var n = {};
				for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]])
				}
				return n
			};
			const p = (e, t) => t.substring.toLowerCase(),
				m = (e, t) => {
					let {
						substring: n
					} = t;
					return Object(i.e)(n) ? "" : Object(i.f)(n)
				},
				f = (e, t) => {
					for (let n = e.length; n > 0; n--)
						if (!1 === t(e.slice(0, n))) return
				},
				g = Object(o.a)(m, e => e.subredditAutocomplete.models, (e, t) => {
					let n = null;
					return f(e, e => {
						if (t.hasOwnProperty(e)) return n = t[e], !1
					}), n
				}),
				O = Object(o.a)(m, g, (e, t) => !e || !s()(t) && 0 === t.subreddits.length),
				h = Object(o.a)(u.f, l.z, (e, t) => e.map(e => Object(a.c)(e, t))),
				y = Object(o.a)(m, g, O, e => e.subredditAutocomplete.api.pending, (e, t, n, r) => {
					if (n) return !1;
					let s = !1;
					return f(e, e => r.hasOwnProperty(e) ? (s = r[e], !1) : (!t || t.key !== e) && void 0), s
				}),
				j = Object(o.a)(m, u.f, (e, t) => t.filter(t => -1 !== t.name.toLowerCase().indexOf(e))),
				_ = Object(o.a)(p, (e, t) => t.includeUserProfile, l.i, (e, t, n) => {
					if (!t || s()(n) || Object(i.d)(e)) return null;
					const r = Object(i.f)(Object(d.f)(n)),
						o = Object(i.f)(e);
					return r.includes(o) ? Object(a.d)(n) : null
				}),
				E = Object(o.a)(p, (e, t) => t.allowCrosspostableOnly, _, g, j, e => e.subreddits.crosspostable.ids, l.z, (e, t, n, r, s, o, c) => {
					const d = [];
					if (n && d.push(n), Object(i.e)(e)) return d;
					const u = {};
					return s.forEach(e => {
						const n = Object(a.c)(e, c);
						t && !o[e.id] && (n.disabled = !0), u[n.name] = n, d.push(n)
					}), r && r.subreddits.forEach(e => {
						const {
							communityIcon: n,
							icon: r,
							isCrosspostDestination: s,
							name: o
						} = e, i = b(e, ["communityIcon", "icon", "isCrosspostDestination", "name"]), c = n || r, l = t && !1 === s;
						u[o] || d.push(Object.assign({}, i, {
							disabled: l,
							iconUrl: c,
							name: o,
							type: a.a.OTHER_SUBREDDIT
						}))
					}), d
				}),
				v = Object(o.a)(p, l.h, (e, t) => {
					const n = Object(i.f)(e);
					return t.filter(e => {
						let {
							name: t
						} = e;
						return t.toLowerCase().includes(n)
					})
				}),
				I = (Object(o.a)(p, _, v, (e, t) => t.partnerConnectionSafeOnly, l.z, (e, t, n, r, s) => {
					const o = [];
					if (t && o.push(t), Object(i.e)(e)) return o;
					let d = n;
					return r && (d = n.filter(e => (e.type === c.c.Public || e.type === c.c.Restricted) && !e.isQuarantined && !e.isNSFW && e.subscribers < 2e5)), o.push(...d.map(e => Object(a.b)(e, a.a.MODERATED_SUBREDDIT, s))), o
				}), Object(o.c)({
					suggestedItems: E,
					fallbackItems: h,
					isAllDataRetrieved: O,
					isPending: y
				})),
				S = Object(o.a)(g, j, (e, t) => t.multireddit.subredditIds || [], l.z, (e, t, n, r) => {
					const s = [],
						o = {};
					return t.forEach(e => {
						const t = Object(a.c)(e, r);
						o[t.name] = t, t.id && n.indexOf(t.id) < 0 && s.push(t)
					}), e && e.subreddits.forEach(e => {
						const {
							communityIcon: t,
							icon: r,
							name: i
						} = e, c = b(e, ["communityIcon", "icon", "name"]), d = t || r;
						!o[i] && n.indexOf(e.id) < 0 && s.push(Object.assign({}, c, {
							iconUrl: d,
							name: i,
							type: a.a.OTHER_SUBREDDIT
						}))
					}), s
				})
		},
		"./src/reddit/selectors/subredditChannel.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/values.js"),
				s = n.n(r),
				o = n("./src/reddit/selectors/user.ts");
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.subredditChannels.models;
					return Object.keys(r).map(e => r[e]).filter(e => e.subredditId === n)
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !(!1 !== e.subredditChannels.api.pending[n] || !1 !== e.subredditChannels.api.error[n])
				},
				a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return void 0 === e.subredditChannels.api.pending[n] && !c(e, {
						subredditId: n
					}) && Object(o.K)(e)
				},
				d = e => {
					const {
						models: t
					} = e.subredditChannels;
					return Object.keys(t).map(e => t[e] && t[e].name)
				},
				u = (e, t) => {
					const n = s()(e.subredditChannels.models);
					return n.length && n.find(e => {
						let {
							channelId: n
						} = e;
						return n === t
					}) || void 0
				},
				l = e => {
					const t = e.subredditChannels.selected;
					if (t) {
						return s()(e.subredditChannels.models).find(e => e.channelId === t)
					}
				}
		},
		"./src/reddit/selectors/subredditDifficulty.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			const r = (e, t) => {
				let {
					subredditId: n
				} = t;
				return e.subredditDifficulty[n]
			}
		},
		"./src/reddit/selectors/subredditLeaderboard.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var r = n("./src/reddit/constants/subredditLeaderboard.ts"),
				s = n("./src/reddit/selectors/category.ts"),
				o = n("./src/reddit/selectors/experiments/upAndComingLeaderboard.ts");
			const i = (e, t) => e.subreddits.rankingsPageInfo && e.subreddits.rankingsPageInfo[t] && e.subreddits.rankingsPageInfo[t].hasPreviousPage,
				c = (e, t) => e.subreddits.rankingsPageInfo && e.subreddits.rankingsPageInfo[t] && e.subreddits.rankingsPageInfo[t].hasNextPage,
				a = (e, t, n) => t ? r.g : n ? r.l : e || r.a,
				d = (e, t) => {
					const n = e.subreddits.rankings,
						i = t && Object(s.h)(e, {
							categoryName: t
						}),
						c = n[a(i && i.id || null, t === r.h, Object(o.b)(e) && t === r.m)];
					return !(!c || !c.length)
				}
		},
		"./src/reddit/selectors/subredditMention.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return b
			}));
			var r = n("./src/reddit/constants/experiments.ts"),
				s = n("./src/reddit/featureFlags/index.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			const c = e => s.d.subredditMentionD2xExperiment(e),
				a = e => {
					return Object(o.c)(e, {
						experimentEligibilitySelector: c,
						experimentName: r.Db
					}) || ""
				},
				d = e => {
					const t = a(e);
					return t === r.Ib.SmIcon || t === r.Ib.SmIconHc
				},
				u = (e, t) => {
					let {
						subredditName: n
					} = t;
					return !!e.subreddits.api.models.pending[n]
				},
				l = (e, t) => {
					let {
						subredditName: n
					} = t;
					return !!e.subreddits.api.models.error[n]
				},
				b = (e, t) => {
					let {
						subredditName: n
					} = t;
					const r = Object(i.W)(e, {
						subredditName: n
					});
					return (r && r.postIds || []).slice(0, 2)
				}
		},
		"./src/reddit/selectors/subredditModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return c
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "w", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "B", (function() {
				return h
			})), n.d(t, "z", (function() {
				return y
			})), n.d(t, "A", (function() {
				return j
			})), n.d(t, "u", (function() {
				return _
			})), n.d(t, "x", (function() {
				return E
			})), n.d(t, "y", (function() {
				return v
			})), n.d(t, "p", (function() {
				return I
			})), n.d(t, "q", (function() {
				return S
			})), n.d(t, "v", (function() {
				return T
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "s", (function() {
				return C
			})), n.d(t, "H", (function() {
				return w
			})), n.d(t, "D", (function() {
				return P
			})), n.d(t, "F", (function() {
				return D
			})), n.d(t, "G", (function() {
				return R
			})), n.d(t, "C", (function() {
				return A
			})), n.d(t, "E", (function() {
				return k
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "e", (function() {
				return M
			})), n.d(t, "b", (function() {
				return U
			})), n.d(t, "a", (function() {
				return F
			})), n.d(t, "t", (function() {
				return B
			}));
			n("./node_modules/core-js/modules/es6.regexp.search.js");
			var r = n("./src/lib/objectSelector/index.ts"),
				s = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = [],
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.banned.models[n]
				},
				a = (e, t) => {
					let {
						subredditId: n,
						username: r
					} = t;
					const s = Object(o.ib)(e, {
						userName: r
					});
					if (!s) return;
					const i = c(e, {
						subredditId: n
					});
					return i ? i[s.id] : void 0
				},
				d = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.banned.userOrder[n];
					return r ? r.map(t => e.banned.models[n][t]) : i
				}),
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = Object(s.d)(n);
					return e.banned.api.pending[r]
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.banned.loadMore[n]
				},
				b = e => e.banned.search.api.pending,
				p = e => e.banned.search.result,
				m = e => e.banned.inContext,
				f = Object(r.a)((e, t) => {
					let {
						subredditId: n,
						before: r,
						after: o
					} = t;
					const i = Object(s.d)(n, o, r),
						c = e.moderators.userOrder.data[n] && e.moderators.userOrder.data[n][i];
					return c ? c.map(t => e.moderators.models[n][t]) : []
				}),
				g = (e, t) => {
					let {
						subredditId: n,
						beforeEditable: r,
						afterEditable: o
					} = t;
					const i = Object(s.d)(n, o, r),
						c = e.moderators.editableUserOrder.data[n] && e.moderators.editableUserOrder.data[n][i];
					return c ? c.map(t => e.moderators.editableModerators[n][t]) : []
				},
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.editableModerators[n] || null
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.models[n] || null
				},
				y = e => e.moderators.search.api.pending,
				j = e => e.moderators.search.result,
				_ = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.invitePending[n]
				},
				E = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.loadMoreModerators[n] && e.moderators.loadMoreModerators[n].after
				},
				v = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.loadMoreModerators[n] && e.moderators.loadMoreModerators[n].before
				},
				I = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.loadMoreEditableModerators[n] && e.moderators.loadMoreEditableModerators[n].after
				},
				S = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.moderators.loadMoreEditableModerators[n] && e.moderators.loadMoreEditableModerators[n].before
				},
				T = (e, t) => {
					const n = Object(s.d)(t.subredditId, t.after, t.before);
					return e.moderators.userOrder.api.pending[n]
				},
				x = (e, t) => {
					const n = Object(s.d)(t.subredditId, t.afterEditable, t.beforeEditable);
					return e.moderators.editableUserOrder.api.pending[n]
				},
				C = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.moderators.invitedModerators.userOrder[n];
					return r ? r.map(t => e.moderators.invitedModerators.models[n][t]) : i
				}),
				w = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.muted.userOrder[n];
					return r ? r.map(t => e.muted.models[n][t]) : i
				}),
				P = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = Object(s.d)(n);
					return e.muted.api.pending[r]
				},
				D = e => e.muted.search.api.pending,
				R = e => e.muted.search.result,
				A = e => e.muted.inContext,
				k = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.muted.loadMore[n]
				},
				N = e => e.approvedSubmitters.search.api.pending,
				L = e => e.approvedSubmitters.search.result,
				M = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = e.approvedSubmitters.userOrder[n];
					return r ? r.map(t => e.approvedSubmitters.models[n][t]) : i
				}),
				U = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.approvedSubmitters.loadMore[n]
				},
				F = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = Object(s.d)(n);
					return e.approvedSubmitters.api.pending[r]
				},
				B = e => !!Object(o.K)(e) && e.modModeEnabled
		},
		"./src/reddit/selectors/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/selectors/user.ts");
			const o = Object(r.a)(s.i, e => e.subreddits.settings, (e, t) => {
				if (e && e.profileId) return t[e.profileId]
			})
		},
		"./src/reddit/selectors/subscriptions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return p
			}));
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/constants/posts.ts"),
				o = n("./src/lib/objectSelector/index.ts");
			const i = e => e.subscriptions.api.fetched,
				c = e => e.subscriptions.subredditOrder,
				a = Object(o.a)(e => {
					const {
						profileOrder: t,
						subredditOrder: n
					} = e.subscriptions;
					return [...n, ...t]
				}),
				d = (Object(o.a)(e => {
					const {
						profileOrder: t,
						subredditOrder: n
					} = e.subscriptions, r = t ? t.map(e => ({
						id: e,
						type: s.a.PROFILE
					})) : [];
					return (n ? n.map(e => ({
						id: e,
						type: s.a.SUBREDDIT
					})) : []).concat(r)
				}), Object(o.a)(Object(r.a)(e => e.subreddits.models, e => e.subscriptions.subredditOrder, (e, t) => {
					if (!t || !t.length) return [];
					const n = [];
					for (const r of t) e[r] && n.push(e[r]);
					return n
				}))),
				u = Object(o.a)(Object(r.a)(e => e.profiles.models, e => e.subscriptions.profileOrder, (e, t) => {
					if (!t || !t.length) return [];
					return t.map(t => e[t])
				})),
				l = e => e.subscriptions.favoriteSubredditOrder,
				b = (Object(o.a)(e => {
					const {
						favoriteSubredditOrder: t,
						favoriteProfileOrder: n
					} = e.subscriptions, r = e.subreddits.models, s = e.profiles.models, o = t ? t.map(e => r[e]) : [], i = n ? n.map(e => s[e]) : [];
					return o.concat(i)
				}), Object(r.a)(e => e.subscriptions.profileOrder, e => e.subscriptions.subredditOrder, (e, t) => e.length + t.length)),
				p = Object(r.a)(d, e => e.reduce((e, t) => (e[t.id] = t.name, e), {}))
		},
		"./src/reddit/selectors/tags.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "j", (function() {
				return b
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "w", (function() {
				return O
			})), n.d(t, "x", (function() {
				return h
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "s", (function() {
				return I
			})), n.d(t, "b", (function() {
				return w
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "p", (function() {
				return A
			})), n.d(t, "m", (function() {
				return k
			})), n.d(t, "v", (function() {
				return N
			})), n.d(t, "u", (function() {
				return L
			})), n.d(t, "t", (function() {
				return M
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "q", (function() {
				return F
			})), n.d(t, "y", (function() {
				return B
			})), n.d(t, "z", (function() {
				return G
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/lodash/some.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/values.js"),
				i = n.n(o),
				c = n("./src/lib/objectSelector/index.ts"),
				a = n("./src/reddit/helpers/tags/index.ts"),
				d = n("./src/reddit/models/Tags/index.ts");
			const u = e => i()((e => {
					const t = l(e) ? P(e) : C(e),
						n = b(e),
						r = t.reduce((e, t) => (e[t.id] = Object(d.e)(t), e), {});
					return n.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), r)
				})(e)).filter(e => !e.selected),
				l = e => e.tags.creation.tagInput || "",
				b = e => e.tags.creation.selectedOptions || [],
				p = e => {
					const t = [];
					for (let n = 0; n < b(e).length; n++) b(e)[n].id && t.push(b(e)[n].id);
					return t || []
				},
				m = e => (b(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				f = e => {
					const t = [];
					for (let n = 0; n < b(e).length; n++) b(e)[n].id || t.push(b(e)[n].displayText);
					return t || []
				},
				g = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				O = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				h = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				y = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.inputByItemId[n] || ""
				},
				j = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.suggestedInputByItemId[n] || ""
				},
				_ = [],
				E = (e, t) => {
					let {
						subredditId: n
					} = t;
					return s()(v(e, {
						subredditId: n
					}), e => !!e.action) || s()(S(e, {
						subredditId: n
					}), e => !!e.action)
				},
				v = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedOptions[n] || _
				},
				I = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedSuggestedOptions[n] || _
				},
				S = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.deselectedOptions[n] || _
				},
				T = {},
				x = {},
				C = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				w = e => e.tags.models.globalSubredditTags,
				P = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				D = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditScopedTags[n] || x
				},
				R = (e, t) => {
					const n = i()(t);
					for (let r = 0; r < n.length; r++)
						if (n[r].text.toLowerCase().trim() === e.toLowerCase().trim()) return n[r];
					return null
				},
				A = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.itemTags[n] || T
				},
				k = (e, t) => {
					let {
						itemId: n
					} = t;
					return !!e.tags.models.itemTags[n]
				},
				N = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.suggestedItemTags[n] || T
				},
				L = (e, t) => {
					let {
						itemId: n
					} = t;
					return i()(N(e, {
						itemId: n
					})).filter(e => e.isRelevant).map(e => Object(d.d)(e, !0))
				},
				M = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.sortedItemTags[n] || []
				},
				U = Object(c.a)((e, t) => {
					let {
						thingId: n,
						suggested: r = !1
					} = t;
					return i()(((e, t) => {
						let {
							thingId: n,
							suggested: r = !1
						} = t;
						const s = (r ? j(e, {
								subredditId: n
							}) : y(e, {
								subredditId: n
							})) ? P(e) : C(e),
							o = r ? I(e, {
								subredditId: n
							}) : v(e, {
								subredditId: n
							}),
							i = s.reduce((e, t) => (e[t.id] = Object(d.e)(t), e), {});
						return o.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), i)
					})(e, {
						thingId: n,
						suggested: r
					})).filter(e => !e.selected)
				}),
				F = (e, t) => {
					let {
						subredditId: n
					} = t;
					return v(e, {
						subredditId: n
					}).concat(S(e, {
						subredditId: n
					}))
				},
				B = (e, t) => {
					let {
						subredditId: n
					} = t;
					return v(e, {
						subredditId: n
					}).filter(a.b).map(e => ({
						text: e.displayText,
						type: d.c.CLASSIFICATION
					}))
				},
				G = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = D(e, {
							subredditId: n
						}),
						s = N(e, {
							itemId: n
						});
					return S(e, {
						subredditId: n
					}).filter(e => !!e.id && !!r[e.id] && !s[e.id]).map(e => ({
						tagId: e.id
					}))
				}
		},
		"./src/reddit/selectors/telemetry.ts": function(e, t, n) {
			"use strict";
			n.r(t);
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var r = n("./node_modules/js-cookie/src/js.cookie.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/trimStart.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/values.js"),
				a = n.n(c),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./node_modules/url/url.js"),
				l = n.n(u),
				b = n("./src/config.ts"),
				p = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/constants/cookie.ts"),
				f = n("./src/lib/eventTools/index.ts"),
				g = n("./src/lib/isAdHocMultireddit/index.ts"),
				O = n("./src/lib/isFakeSubreddit/index.ts"),
				h = n("./src/reddit/constants/adEvents.ts"),
				y = n("./src/reddit/constants/blade.ts"),
				j = n("./src/reddit/constants/chat.ts"),
				_ = n("./src/reddit/constants/wiki.ts"),
				E = n("./src/reddit/contexts/PageLayer/index.tsx"),
				v = n("./src/reddit/helpers/dom/index.ts");
			const I = () => !document.getElementById(b.a.adblockId);
			let S;
			(S = document.createElement("div")).className = "promotedlink", S.style.height = S.style.width = "1px", S.style.position = "absolute", S.style.left = "-1000000px", S.style.display = "block", document.body.appendChild(S);
			const T = () => I() ? !v.h(S) : null;
			var x = n("./src/reddit/helpers/correlationIdTracker.ts"),
				C = n("./src/reddit/constants/posts.ts"),
				w = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				P = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				D = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				R = n("./src/reddit/helpers/isPost.ts"),
				A = n("./src/reddit/helpers/postCollection.ts"),
				k = n("./src/reddit/helpers/postEvent.ts"),
				N = n("./src/reddit/models/Media/index.ts"),
				L = n("./src/reddit/models/Post/index.ts"),
				M = n("./src/reddit/models/Profile/index.ts"),
				U = n("./src/reddit/selectors/experiments/chatPost.ts"),
				F = n("./src/reddit/selectors/listings.ts"),
				B = n("./src/reddit/selectors/platform.ts"),
				G = n("./src/reddit/selectors/postCollection.ts"),
				V = n("./src/reddit/selectors/posts.ts"),
				q = n("./src/reddit/selectors/profile.ts"),
				H = n("./src/reddit/selectors/profileComments.ts"),
				K = n("./src/reddit/models/Multireddit/index.ts"),
				W = n("./src/reddit/models/User/index.ts"),
				Y = n("./src/reddit/selectors/multireddit.ts"),
				z = n("./src/reddit/selectors/structuredStyles.ts"),
				J = n("./src/reddit/selectors/subreddit.ts"),
				Q = n("./src/reddit/selectors/subredditChannel.ts"),
				X = n("./src/reddit/selectors/subredditSettings.ts"),
				Z = n("./src/reddit/selectors/user.ts"),
				$ = n("./src/server/helpers/seoMetadata.tsx"),
				ee = n("./src/telemetry/models/Timer.ts");
			n.d(t, "getPageTypeFromRouteMatch", (function() {
				return te
			})), n.d(t, "getRelativePostOrder", (function() {
				return se
			})), n.d(t, "getAbsoluteOrder", (function() {
				return oe
			})), n.d(t, "actionInfo", (function() {
				return ie
			})), n.d(t, "chatPostActionInfo", (function() {
				return ce
			})), n.d(t, "previousPageActionInfo", (function() {
				return ae
			})), n.d(t, "app", (function() {
				return de
			})), n.d(t, "comment", (function() {
				return le
			})), n.d(t, "userSubreddit", (function() {
				return pe
			})), n.d(t, "defaults", (function() {
				return me
			})), n.d(t, "mediaActionInfo", (function() {
				return fe
			})), n.d(t, "videoCorrelationId", (function() {
				return ge
			})), n.d(t, "poll", (function() {
				return ye
			})), n.d(t, "post", (function() {
				return je
			})), n.d(t, "currentPost", (function() {
				return _e
			})), n.d(t, "listing", (function() {
				return Ee
			})), n.d(t, "profileComments", (function() {
				return ve
			})), n.d(t, "media", (function() {
				return Ie
			})), n.d(t, "videoPlayerMaxTimeServed", (function() {
				return Se
			})), n.d(t, "videoPlayerFirstFrameTimer", (function() {
				return Te
			})), n.d(t, "profileById", (function() {
				return xe
			})), n.d(t, "profileByPostOrCommentId", (function() {
				return Ce
			})), n.d(t, "referrer", (function() {
				return we
			})), n.d(t, "screen", (function() {
				return Pe
			})), n.d(t, "session", (function() {
				return De
			})), n.d(t, "customFeed", (function() {
				return Re
			})), n.d(t, "customFeedByPath", (function() {
				return Ae
			})), n.d(t, "profile", (function() {
				return ke
			})), n.d(t, "subreddit", (function() {
				return Ne
			})), n.d(t, "subredditById", (function() {
				return Le
			})), n.d(t, "subredditByName", (function() {
				return Me
			})), n.d(t, "subredditByPostOrCommentId", (function() {
				return Ue
			})), n.d(t, "timer", (function() {
				return Fe
			})), n.d(t, "user", (function() {
				return Be
			})), n.d(t, "widget", (function() {
				return Ge
			})), n.d(t, "request", (function() {
				return Ve
			})), n.d(t, "requestWithParams", (function() {
				return qe
			})), n.d(t, "adblock", (function() {
				return He
			})), n.d(t, "domTimer", (function() {
				return Ke
			})), n.d(t, "oauth", (function() {
				return We
			})), n.d(t, "numberChannels", (function() {
				return Ye
			})), n.d(t, "channel", (function() {
				return ze
			})), n.d(t, "SearchDropdownNouns", (function() {
				return Je
			})), n.d(t, "StructureType", (function() {
				return Qe
			})), n.d(t, "OriginElement", (function() {
				return Xe
			})), n.d(t, "search", (function() {
				return Ze
			})), n.d(t, "discoveryUnit", (function() {
				return $e
			})), n.d(t, "smartSearch", (function() {
				return et
			})), n.d(t, "metaSearch", (function() {
				return tt
			})), n.d(t, "postFlairClickToSearch", (function() {
				return nt
			})), n.d(t, "currentProfileModelSelector", (function() {
				return rt
			})), n.d(t, "notification", (function() {
				return st
			})), n.d(t, "postEventI13nSelector", (function() {
				return ot
			})), n.d(t, "postCollectionI13nByCollectionIdSelector", (function() {
				return ct
			})), n.d(t, "postCollectionI13nSelector", (function() {
				return at
			}));
			const te = e => {
					switch (e.route && e.route.meta && e.route.meta.name) {
						case p.xb.INDEX:
							return "home";
						case p.xb.PROFILE_OVERVIEW:
							return "profile_overview";
						case p.xb.PROFILE_COMMENTS:
							return "profile_comments";
						case p.xb.PROFILE_POSTS:
							return "profile_posts";
						case p.xb.PROFILE:
						case p.xb.PROFILE_BETA_CONFIRMATION:
						case p.xb.PROFILE_MODERATION:
						case p.xb.PROFILE_POST_COMMENTS:
						case p.xb.PROFILE_PRIVACY:
						case p.xb.PROFILE_SETTINGS:
							return "profile";
						case p.xb.PROFILE_PRIVATE: {
							const {
								listingType: t
							} = e.match.params;
							switch (t) {
								case M.a.Downvoted:
									return "profile_downvoted";
								case M.a.Hidden:
									return "profile_hidden";
								case M.a.Upvoted:
									return "profile_upvoted";
								case M.a.Saved:
									return "profile_saved";
								case M.a.ReceivedGildings:
									return "profile_gilded";
								case M.a.GivenGildings:
									return "profile_gilded_given"
							}
							break
						}
						case p.xb.COMMENTS:
						case p.xb.DUPLICATES:
							return e.match.params.partialCommentId ? "single_comment_thread" : "post_detail";
						case p.xb.LISTING:
						case p.xb.SUBREDDIT: {
							const {
								subredditName: t
							} = e.match.params;
							if (!t) return "home";
							if (Object(O.a)(t) && Object(g.a)(t)) return "custom_feed";
							switch (t.toLowerCase()) {
								case "popular":
									return "popular";
								case "all":
									return "all";
								default:
									return "community"
							}
						}
						case p.xb.SUBREDDIT_SETTINGS:
							return "subreddit_settings";
						case p.xb.POST_CREATION:
							return e.match.queryParams && e.match.queryParams.source_id ? "crosspost_submit" : "post_submit";
						case p.xb.SEARCH_RESULTS:
							return "search_results";
						case p.xb.MODERATION_PAGES: {
							const t = e.match.params.pageName;
							return "content" === t ? "scheduled_posts" : "moderation_pages_".concat(t)
						}
						case p.xb.MODQUEUE_PAGES: {
							const t = e.match.params.pageName;
							return "modqueue" === t ? "modqueue_queue" : "modqueue_".concat(t)
						}
						case p.xb.MULTIREDDIT:
							return "custom_feed";
						case p.xb.POST_DRAFT:
							return "draft_detail";
						case p.xb.PUBLIC_ACCESS_NETWORK:
							return "stream_player";
						case p.xb.EXPLORE:
							return "explore";
						case p.xb.MOD_LISTING:
							return "r_mod";
						case p.xb.SUBREDDIT_CREATION:
							return "subreddit_creation";
						case p.xb.SUBREDDIT_WIKI:
							return "subreddit_wiki";
						case p.xb.SETTINGS: {
							const t = e.match.params.page;
							return t ? "settings_".concat(t) : "settings_account"
						}
						case p.xb.META_MEMBERSHIP_PAYWALL_PAGE:
							return "special_membership_paywall";
						case p.xb.SUBREDDIT_LEADERBOARD:
							return "leaderboard";
						case p.xb.TOPIC:
							return "topic";
						default:
							return ""
					}
				},
				ne = e => {
					const t = e.routeMatch;
					return te(t)
				},
				re = e => {
					if (e.isMeta) return "poll";
					if (!e.media) return "link";
					if (Object(L.i)(e)) return "stream";
					switch (e.media.type) {
						case "gifvideo":
							return "gif";
						case "embed":
							return "link";
						default:
							return e.media.type
					}
				},
				se = (e, t, n) => {
					const r = e.listings.postOrder.ids[n];
					return r.indexOf(t) >= 0 ? r.indexOf(t) : null
				},
				oe = (e, t, n) => {
					const r = e.listings.postOrder.ids[n];
					return r.indexOf(t) >= 0 ? r.indexOf(t) + p.gb : null
				},
				ie = (e, t) => Object.assign({
					pageType: e.platform.currentPage ? ne(e.platform.currentPage) : void 0
				}, t),
				ce = e => {
					const t = Object(B.f)(e),
						n = !!t && Object(U.a)(e, {
							subredditId: t.id
						});
					return ie(e, {
						type: n ? "chat_enabled" : void 0
					})
				},
				ae = (e, t) => Object.assign({
					pageType: e.platform.lastPage ? ne(e.platform.lastPage) : void 0
				}, t),
				de = () => ({
					name: b.a.telemetry.appName.redesign
				}),
				ue = (e, t) => {
					if (e.platform.currentPage) {
						const {
							sortToUse: n
						} = Object(w.a)(e, t);
						if (n === p.q.CHAT) return p.u.Chat
					}
					return p.u.Comment
				},
				le = (e, t) => {
					const n = e.comments.models[t];
					if (n) {
						const {
							awardCountsById: t
						} = n, r = t ? Object.keys(t).reduce((e, n) => e + t[n], 0) : null;
						return {
							id: n.id,
							postId: n.postId,
							parentId: n.parentId,
							bodyText: Object(D.a)(n),
							authorId: n.authorId,
							numberGildings: r,
							score: n.score,
							created: n.created,
							type: ue(e, n.postId)
						}
					}
					return null
				},
				be = e => {
					let t = !1;
					return Object.keys(e).forEach(n => {
						e[n] && (t = !0)
					}), t
				},
				pe = e => {
					const t = Object(B.f)(e),
						n = t && e.moderatingSubreddits[t.id];
					let r;
					if (Object(Z.K)(e) && t) {
						const n = e.subscriptions.subredditOrder.includes(t.id),
							s = e.subreddits.about[t.id] && e.subreddits.about[t.id].userIsSubscriber;
						r = n || s
					} else r = null;
					return {
						isMod: !!n,
						modAccess: n ? n.access : null,
						modConfig: n ? n.config : null,
						modFlair: n ? n.flair : null,
						modFull: n ? n.all : null,
						modMail: n ? n.mail : null,
						modNone: n ? !be(n) : null,
						modPost: n ? n.posts : null,
						modWiki: n ? n.wiki : null,
						isSubscriber: r
					}
				},
				me = e => ({
					actionInfo: ie(e),
					app: de(),
					referrer: we(e),
					request: Ve(e),
					session: De(e),
					screen: Pe(e),
					user: Be(e)
				}),
				fe = (e, t) => {
					const n = e.posts.video.fullscreen,
						r = e.platform.currentPage ? ne(e.platform.currentPage) : void 0;
					return {
						pageType: n === t ? "fullscreen" : r
					}
				},
				ge = () => Object(x.c)(x.a.VideoView),
				Oe = new Map,
				he = e => {
					let {
						state: t,
						post: n
					} = e;
					const r = Object(F.a)(t);
					if (!r) return;
					let s;
					Oe.has(r) ? s = Oe.get(r) : (Oe.set(r, new Map), (s = Oe.get(r)).set("postIdToDistanceFromAdMapping", new Map));
					const o = s.get("postIdToDistanceFromAdMapping");
					if (o.has(n.id)) return o.get(n.id);
					const i = t.listings.postOrder.ids[r];
					if (!i) return;
					const c = s.get("lastPostIndex");
					let a = s.get("lastAdIndex"),
						d = c ? c + 1 : 0;
					for (; d < i.length; d += 1) {
						const e = t.posts.models[i[d]];
						if (e && !e.hidden && !e.isBlank) {
							const t = a ? d - a - 1 : void 0;
							o.set(e.id, t), e.isSponsored && (a = d)
						}
					}
					return s.set("lastPostIndex", d), s.set("lastAdIndex", a), o.get(n.id)
				},
				ye = (e, t, n, r) => {
					const s = e.polls.models[t];
					if (s) return Object.assign({
						options: s.options.map(e => e.text.substring(0, 80)),
						optionsLength: s.options.length
					}, n && void 0 !== r ? {
						userVote: r
					} : void 0)
				},
				je = (e, t, n) => {
					const r = e.posts.models[t] || e.comments.models[t] && e.posts.models[e.comments.models[t].postId];
					if (r) {
						const {
							source: t
						} = r, s = ue(e, r.id), o = r.events.find(e => e.type === h.a.Impression), i = o && o.url.match(/\?q=([^&]+)/);
						return {
							commentType: s,
							contentDuration: n || void 0,
							createdTimestamp: r.created,
							domain: r.domain,
							id: r.postId,
							nsfw: r.isNSFW,
							score: r.score,
							spoiler: r.isSpoiler,
							title: r.title,
							type: re(r),
							upvoteRatio: r.upvoteRatio ? r.upvoteRatio : void 0,
							url: t ? t.url : void 0,
							promoted: r.isSponsored,
							impressionId: i ? i[1] : void 0,
							numberPostsFromAd: he({
								state: e,
								post: r
							})
						}
					}
					if (Object(R.a)(t)) {
						return {
							id: t,
							commentType: ue(e, t)
						}
					}
					return null
				},
				_e = e => {
					const t = Object(P.a)(e);
					return t ? je(e, t.id) : null
				},
				Ee = (e, t, n) => {
					const r = t && e.listings.postOrder.ids[t];
					return {
						depth: n && n.depth,
						length: r ? r.length : void 0,
						links: r ? r.map(t => e.posts.models[t].id) : void 0,
						oldSort: n && n.oldSort,
						sort: n && n.sort,
						sortTime: n && n.sortTime || void 0,
						source: n && n.source
					}
				},
				ve = (e, t) => {
					const n = Object(H.f)(e, {
						listingKey: t
					});
					return n ? {
						length: n.length,
						links: n.map(t => e.comments.models[t].id)
					} : null
				},
				Ie = (e, t, n, r) => {
					const s = e.posts.models[t];
					if (void 0 === s) return null;
					const o = {};
					if (o.id = s.postId, s.media && "v.redd.it" === s.domain) {
						const e = Object(N.z)(s.media);
						e && (o.id = e)
					}
					if (n) o.loadTime = n;
					else {
						const n = e.posts.video.loadTimes[t];
						n && n.start && n.playable && (o.loadTime = Math.round(n.playable - n.start))
					}
					const i = e.posts.video.metadata[t];
					i && i.id === t && (o.height = i.originalHeight, o.width = i.originalWidth, o.orientation = o.height > o.width ? "portrait" : "landscape", o.duration = i.length);
					const c = e.posts.video.time[t];
					return c && (o.time = Math.round(c.currentTime)), o.streamPublicId = r && r.stream.stream_id, o
				},
				Se = (e, t) => {
					if (void 0 === e.posts.models[t]) return null;
					const n = {},
						r = e.posts.video.time[t];
					return r && (n.maxTimeServed = Math.round(r.maxTimeServed)), n
				},
				Te = (e, t) => {
					if (void 0 === e.posts.models[t]) return;
					const n = {
							type: ee.TimerType.VideoFirstFrame
						},
						r = e.posts.video.loadTimes[t];
					return r && r.start && (r.playable ? n.millis = Math.round(r.playable - r.start) : n.millis = Math.round(performance.now() - r.start)), n
				},
				xe = (e, t) => {
					const n = e.profiles.models[t];
					return n && {
						id: n.id,
						name: n.name
					}
				},
				Ce = (e, t) => {
					const n = e.posts.models[t],
						r = e.comments.models[t];
					return n ? xe(e, n.belongsTo.id) : r ? xe(e, r.subredditId) : null
				},
				we = e => {
					let t = e.platform.currentPage ? e.platform.referrers[e.platform.currentPage.key] : null;
					if (t) {
						let {
							hostname: n
						} = l.a.parse(t);
						if (!n || t.startsWith("/")) {
							let r = e.meta.protocol;
							n = e.meta.domain, r && n || (r = window.location.protocol, n = window.location.hostname), r = r.endsWith(":") ? r : "".concat(r, ":"), t = "".concat(r, "//").concat(n).concat(t)
						}
						return {
							domain: n,
							url: t
						}
					}
					return null
				},
				Pe = (e, t) => {
					const n = Object(E.M)(e, {});
					let r;
					Object(B.g)(e) && (r = Object(B.i)(e) ? "lightbox" : "post_detail");
					let s = "default";
					return e.user && e.user.prefs && e.user.prefs.nightmode && (s = "nightmode"), {
						layout: n,
						viewType: r,
						scrollPosition: t,
						theme: s
					}
				},
				De = e => {
					const t = s.a.get(m.f),
						n = e.user.sessionTracker,
						r = (t || n).split("."),
						o = r[0],
						i = parseInt(r[2], 10);
					let c = {};
					const {
						sessionReferrer: a
					} = e.platform;
					if (a) {
						const {
							hostname: e
						} = l.a.parse(a);
						c = {
							referrerDomain: e,
							referrerUrl: a
						}
					}
					return Object.assign({
						id: o,
						createdTimestamp: i
					}, c)
				},
				Re = e => {
					const {
						pageType: t
					} = ie(e);
					if (!e.platform.currentPage) return null;
					if ("custom_feed" === t) {
						const {
							multiredditName: t,
							username: n
						} = e.platform.currentPage.urlParams;
						return Ae(e, Object(K.h)(n, t))
					}
					return null
				},
				Ae = (e, t) => {
					const n = Object(Y.e)(e, t);
					return n ? {
						id: "/user/".concat(n.ownerId, "/m/").concat(n.name, "/"),
						isNsfw: n.isNSFW,
						numberFollowers: n.followerCount,
						numberSubreddits: n.subredditCount,
						ownerId: n.ownerId,
						visibility: n.visibility
					} : null
				},
				ke = e => {
					const {
						pageType: t
					} = ie(e);
					if (!e.platform.currentPage) return null;
					if (t && t.includes("profile")) {
						const {
							profileName: t
						} = e.platform.currentPage.urlParams;
						if (t) {
							const n = t.toLowerCase(),
								r = Object(q.m)(e, n);
							return r ? {
								id: r,
								name: n,
								type: "default"
							} : null
						}
					} else if ("post_detail" === t) {
						const {
							subredditName: t
						} = e.platform.currentPage.urlParams;
						if (t) {
							const n = t.toLowerCase(),
								r = Object(q.m)(e, n),
								s = xe(e, r);
							return s && s.name && s.name.toLowerCase() === n ? {
								id: r,
								name: n,
								type: "default"
							} : null
						}
					}
					return null
				},
				Ne = e => {
					const {
						pageType: t
					} = ie(e);
					if (!e.platform.currentPage) return null;
					if ("post_submit" === t) {
						const t = e.platform.currentPage.urlParams.subredditName;
						if (t) {
							const n = t.toLowerCase(),
								r = Object(J.G)(e, n),
								s = Object(J.S)(e, {
									subredditId: r
								}),
								o = e.subreddits.about[r];
							return r && s ? {
								id: r,
								name: n,
								numberCoins: o ? o.coins : 0
							} : null
						}
						return null
					}
					if ("community" === t || "subreddit_settings" === t || "subreddit_wiki" === t || "special_membership_paywall" === t || t && t.includes("moderation_pages")) {
						let n = e.platform.currentPage.urlParams.subredditName;
						n || "subreddit_wiki" !== t || (n = _.e), n = n.toLowerCase();
						const r = Object(J.G)(e, n),
							s = Object(J.S)(e, {
								subredditId: r
							}),
							o = e.subreddits.about[r];
						return r && s ? {
							id: r,
							name: n,
							numberCoins: o ? o.coins : 0
						} : null
					}
					if ("post_detail" === t || "single_comment_thread" === t) {
						if (e.platform.currentPage.urlParams.subredditName) {
							const t = e.platform.currentPage.urlParams.subredditName.toLowerCase(),
								n = Object(J.G)(e, t),
								r = Object(J.S)(e, {
									subredditId: n
								}),
								s = e.subreddits.about[n];
							return n && r ? {
								id: n,
								name: t,
								numberCoins: s ? s.coins : 0
							} : null
						} {
							const {
								partialPostId: t
							} = e.platform.currentPage.urlParams, n = Object(L.m)(t), r = e.posts.models[n];
							if (!r) return null;
							const s = ((e, t) => {
								const {
									type: n,
									id: r
								} = t;
								return n === C.a.PROFILE ? e.profiles.models[r] : e.subreddits.models[r]
							})(e, r.belongsTo);
							if (!s) return null;
							const o = e.subreddits.about[s.id];
							return {
								id: s.id,
								name: s.name.toLowerCase(),
								numberCoins: o ? o.coins : 0
							}
						}
					}
					if ("search_results" === t) {
						if ("string" != typeof e.platform.currentPage.urlParams.subredditName) return null;
						const t = e.platform.currentPage.urlParams.subredditName.toLowerCase(),
							n = Object(J.G)(e, t),
							r = Object(J.S)(e, {
								subredditId: n
							}),
							s = e.subreddits.about[n];
						return n && r ? {
							id: n,
							name: t,
							numberCoins: s ? s.coins : 0
						} : null
					}
					return null
				},
				Le = (e, t) => {
					const n = e.subreddits.models[t],
						r = e.subreddits.about[t];
					return n && {
						id: n.id,
						name: n.name.toLowerCase(),
						numberCoins: r ? r.coins : 0
					}
				},
				Me = (e, t) => {
					const n = Object(J.G)(e, t),
						r = Object(J.S)(e, {
							subredditId: n
						}),
						s = e.subreddits.about[r.id];
					return r && {
						id: r.id,
						name: r.name.toLowerCase(),
						numberCoins: s ? s.coins : 0
					}
				},
				Ue = (e, t) => {
					const n = e.posts.models[t],
						r = e.comments.models[t];
					return n ? Le(e, n.belongsTo.id) : r ? Le(e, r.subredditId) : null
				},
				Fe = (e, t) => e && t ? {
					type: e,
					millis: t
				} : null,
				Be = Object(d.a)(Z.i, e => e.user.loid, Z.r, (e, t, n) => Object.assign({
					id: e ? e.id : t.loid ? "".concat(p.vb.Account, "_").concat(i()(t.loid, "0")) : null,
					isAdmin: !!e && e.isEmployee,
					isLoggedIn: !!e,
					cookieCreatedTimestamp: parseInt(t.loidCreated) || null,
					createdTimestamp: e ? 1e3 * e.created : null
				}, e ? {
					hasPremium: e.isGold,
					isPremiumSubscriber: n,
					numberCoins: e.coins || 0,
					numberPremiumDaysRemaining: e.goldExpiration ? Math.max(Math.ceil((1e3 * e.goldExpiration - Date.now()) / p.w), 0) : 0
				} : null)),
				Ge = (e, t) => {
					let {
						subredditId: n,
						widgetKind: r
					} = t;
					const s = {
							targetSubredditId: n
						},
						o = e.subreddits.models[n];
					o && o.name && (s.targetSubredditName = o.name);
					const i = r && y.i[r];
					return i && (s.type = i), s
				},
				Ve = e => {
					const t = e.meta.domain,
						n = e.platform.currentPage ? "".concat(e.meta.protocol, "://").concat(t).concat(e.platform.currentPage.url) : void 0,
						r = Object($.a)(e) || void 0,
						s = e.meta.userAgent ? e.meta.userAgent : void 0;
					return {
						base_url: n,
						canonical_url: r,
						domain: t,
						reddaid: e.user.reddaid,
						user_agent: s
					}
				},
				qe = e => {
					const t = e.platform.currentPage ? e.platform.currentPage.url.split("?") : [],
						[n, r] = t,
						{
							domain: s,
							protocol: o
						} = e.meta,
						i = o && s && n ? "".concat(o, "://").concat(s).concat(n) : void 0,
						c = Object($.a)(e) || void 0,
						a = e.meta.userAgent ? e.meta.userAgent : void 0;
					return {
						base_url: i,
						canonical_url: c,
						domain: s,
						reddaid: e.user.reddaid,
						user_agent: a,
						parameters: r
					}
				},
				He = e => ({
					enabled: I(),
					acceptableAds: T()
				}),
				Ke = e => ({}),
				We = e => ({}),
				Ye = e => {
					const t = a()(e.subredditChannels.models);
					return {
						number_channels: t && t.length
					}
				},
				ze = (e, t) => {
					const n = Object(Q.c)(e, t);
					if (!n) return null;
					const {
						type: r,
						membersCount: s,
						channelSendbirdUrl: o
					} = n;
					return {
						id: o,
						type: j.f[r],
						number_members: s
					}
				};
			var Je, Qe, Xe;
			! function(e) {
				e.Recent = "recent_search", e.Trending = "trending_search", e.TypeaheadSubreddit = "search_results_subreddit", e.TypeaheadProfile = "search_results_profile"
			}(Je || (Je = {})),
			function(e) {
				e.Recent = "history", e.Search = "search", e.Trending = "trending", e.PromotedTrend = "promoted_trend"
			}(Qe || (Qe = {})),
			function(e) {
				e.SearchBar = "search_bar"
			}(Xe || (Xe = {}));
			const Ze = (e, t) => {
					let n, r;
					if (t.eventType && t.id) {
						let s;
						switch (t.eventType) {
							case "subreddit":
								s = Le(e, t.id);
								break;
							case "post":
								s = Ue(e, t.id);
								break;
							case "profile":
								s = xe(e, t.id)
						}
						s && (n = s.name, r = s.id)
					}
					return {
						originPageType: e.platform.currentPage ? ne(e.platform.currentPage) : void 0,
						query: t.q ? decodeURIComponent(t.q) : t.q,
						range: t.t,
						sort: t.sort,
						structureType: t.structureType,
						subredditId: r,
						subredditName: n
					}
				},
				$e = e => ({
					id: e.name,
					name: e.name,
					type: e.type
				}),
				et = (e, t) => {
					const n = e.platform.currentPage ? ne(e.platform.currentPage) : void 0;
					return {
						originElement: Xe.SearchBar,
						originPageType: n,
						query: t.searchQuery,
						typeaheadActive: !0
					}
				},
				tt = e => ({
					displayQuery: e.displayQuery,
					rawQuery: e.rawQuery,
					structureType: e.structureType,
					sort: e.sort,
					range: e.t,
					subredditId: e.subredditId,
					subredditName: e.subredditName,
					postFlairName: e.postFlairName,
					metaFlairId: e.metaFlairId,
					metaFlairName: e.metaFlairName
				}),
				nt = (e, t) => {
					let n, r;
					if (t.eventType && t.id) {
						let s;
						switch (t.eventType) {
							case "subreddit":
								s = Le(e, t.id);
								break;
							case "post":
								s = Ue(e, t.id);
								break;
							case "profile":
								s = xe(e, t.id)
						}
						s && (n = s.name, r = s.id)
					}
					const s = e.platform.currentPage ? ne(e.platform.currentPage) : void 0,
						o = {
							originElement: t.originElement,
							originPageType: s,
							subredditName: n,
							subredditId: r
						};
					return t.postFlairName ? o.postFlairName = t.postFlairName : t.metaFlairName && (o.metaFlairName = t.metaFlairName), o
				},
				rt = Object(d.a)(Z.i, e => e, (e, t) => {
					if (!e || !e.profileId) return;
					const n = Object(q.i)(t, e.profileId),
						r = Object(q.g)(t, e.profileId),
						s = Object(z.n)(t, e.profileId),
						o = Object(X.a)(t),
						i = Object(Z.mb)(t),
						c = s && s.bannerBackgroundImage;
					return {
						id: e.id,
						name: Object(W.f)(e),
						type: "default",
						display_name: n ? n.title : void 0,
						about: r ? r.publicDescription : void 0,
						avatar_url: e.accountIcon,
						cover_url: "string" == typeof c ? c : void 0,
						nsfw: n ? n.isNSFW : void 0,
						content_visible: o ? o.contentVisible : void 0,
						communities_visible: i ? i.showActiveCommunities : void 0
					}
				}),
				st = (e, t, n) => {
					const r = {};
					return r.id = t, r.type = n ? n.toLowerCase() : void 0, r
				},
				ot = (e, t) => {
					let n, {
						postId: r
					} = t;
					const s = Object(V.I)(e, {
						postId: r
					});
					if (s && Object(k.a)(s) && s.eventInfo) {
						const {
							eventStart: e,
							eventEnd: t
						} = s.eventInfo;
						n = {
							eventState: Object(f.e)(e, t),
							eventStartTimestamp: e,
							eventEndTimestamp: t
						}
					} else n = void 0;
					return n
				},
				it = e => {
					if (!e) return;
					const {
						id: t,
						title: n,
						author: r,
						postIds: s
					} = e;
					return {
						id: t,
						title: n,
						authorId: r || "",
						postIds: s,
						displayLayout: Object(G.f)(e).toLowerCase()
					}
				},
				ct = (e, t) => {
					let {
						collectionId: n
					} = t;
					return it(Object(G.q)(e, {
						collectionId: n
					}))
				},
				at = (e, t) => {
					let {
						postId: n
					} = t;
					const r = Object(V.I)(e, {
						postId: n
					});
					if (r && Object(A.a)(r)) {
						const t = Object(G.n)(e, {
							postId: n
						});
						return t ? it(t) : void 0
					}
				}
		},
		"./src/reddit/selectors/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = e => e.tooltipId,
				s = e => t => t.tooltipId === e
		},
		"./src/reddit/selectors/topic.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var r = n("./node_modules/reselect/es/index.js"),
				s = n("./src/reddit/selectors/subreddit.ts");
			const o = Object(r.a)(e => e.topics.models, e => {
					const t = {};
					for (const n of Object.keys(e)) {
						const r = e[n];
						t[r.slug.toLowerCase()] = r.id
					}
					return t
				}),
				i = (e, t) => {
					let {
						topicSlug: n
					} = t;
					return e.topics.models[((e, t) => t ? o(e)[t.toLowerCase()] : void 0)(e, n)]
				},
				c = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const r = i(e, {
						topicSlug: t
					});
					if (!r) return "";
					const s = n ? r.name : r.namePlural;
					return s || ""
				},
				a = [],
				d = Object(r.a)(i, s.Y, (e, t) => e ? e.subredditIds.map(e => t[e]) : a),
				u = Object(r.a)(d, e => e.map(e => e && e.name))
		},
		"./src/reddit/selectors/user.ts": function(e, t, n) {
			"use strict";
			n.d(t, "o", (function() {
				return j
			})), n.d(t, "q", (function() {
				return _
			})), n.d(t, "p", (function() {
				return E
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "s", (function() {
				return I
			})), n.d(t, "w", (function() {
				return S
			})), n.d(t, "u", (function() {
				return T
			})), n.d(t, "T", (function() {
				return x
			})), n.d(t, "K", (function() {
				return C
			})), n.d(t, "R", (function() {
				return w
			})), n.d(t, "x", (function() {
				return P
			})), n.d(t, "l", (function() {
				return D
			})), n.d(t, "i", (function() {
				return R
			})), n.d(t, "d", (function() {
				return A
			})), n.d(t, "v", (function() {
				return N
			})), n.d(t, "mb", (function() {
				return L
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "V", (function() {
				return U
			})), n.d(t, "W", (function() {
				return F
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "b", (function() {
				return G
			})), n.d(t, "z", (function() {
				return V
			})), n.d(t, "A", (function() {
				return q
			})), n.d(t, "Y", (function() {
				return H
			})), n.d(t, "X", (function() {
				return K
			})), n.d(t, "k", (function() {
				return W
			})), n.d(t, "S", (function() {
				return Y
			})), n.d(t, "e", (function() {
				return z
			})), n.d(t, "O", (function() {
				return J
			})), n.d(t, "Q", (function() {
				return Q
			})), n.d(t, "bb", (function() {
				return X
			})), n.d(t, "gb", (function() {
				return Z
			})), n.d(t, "fb", (function() {
				return $
			})), n.d(t, "H", (function() {
				return ee
			})), n.d(t, "J", (function() {
				return te
			})), n.d(t, "L", (function() {
				return ne
			})), n.d(t, "y", (function() {
				return re
			})), n.d(t, "D", (function() {
				return se
			})), n.d(t, "B", (function() {
				return oe
			})), n.d(t, "n", (function() {
				return ie
			})), n.d(t, "E", (function() {
				return ce
			})), n.d(t, "C", (function() {
				return ae
			})), n.d(t, "db", (function() {
				return de
			})), n.d(t, "cb", (function() {
				return ue
			})), n.d(t, "ib", (function() {
				return le
			})), n.d(t, "Z", (function() {
				return be
			})), n.d(t, "ab", (function() {
				return pe
			})), n.d(t, "f", (function() {
				return me
			})), n.d(t, "kb", (function() {
				return fe
			})), n.d(t, "eb", (function() {
				return ge
			})), n.d(t, "t", (function() {
				return Oe
			})), n.d(t, "hb", (function() {
				return he
			})), n.d(t, "F", (function() {
				return ye
			})), n.d(t, "N", (function() {
				return je
			})), n.d(t, "j", (function() {
				return _e
			})), n.d(t, "U", (function() {
				return Ee
			})), n.d(t, "jb", (function() {
				return ve
			})), n.d(t, "g", (function() {
				return Ie
			})), n.d(t, "lb", (function() {
				return Se
			})), n.d(t, "M", (function() {
				return Te
			})), n.d(t, "h", (function() {
				return xe
			})), n.d(t, "P", (function() {
				return Ce
			})), n.d(t, "I", (function() {
				return we
			})), n.d(t, "G", (function() {
				return Pe
			})), n.d(t, "c", (function() {
				return De
			}));
			var r = n("./node_modules/lodash/find.js"),
				s = n.n(r),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				c = n("./node_modules/lodash/values.js"),
				a = n.n(c),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/objectSelector/index.ts"),
				b = n("./src/reddit/constants/chat.ts"),
				p = n("./src/reddit/models/User/index.ts"),
				m = n("./src/reddit/selectors/chat.ts"),
				f = n("./src/reddit/selectors/platform.ts"),
				g = n("./src/reddit/selectors/profile.ts"),
				O = n("./src/reddit/selectors/runTimeEnvVars.ts");
			const h = [],
				y = {},
				j = e => e.user.account ? e.user.account.goldExpiration : null,
				_ = e => !!e.user.account && e.user.account.isGold,
				E = e => !!e.user.account && e.user.account.hasAndroidSubscription,
				v = e => !!e.user.account && e.user.account.hasGoldSubscription,
				I = e => !!e.user.account && e.user.account.hasIOSSubscription,
				S = e => !!e.user.account && e.user.account.hasStripeSubscription,
				T = e => !!e.user.account && e.user.account.hasPaypalSubscription,
				x = e => e.user.language,
				C = e => !!e.user.account,
				w = e => !!e.user.session && !e.user.session.unsafeLoggedOut,
				P = e => !!e.user.account && e.user.account.hasVerifiedEmail,
				D = e => e.user.account ? e.user.account.email : null,
				R = e => e.user.account,
				A = e => {
					const t = R(e);
					return t && t.coins || 0
				},
				k = e => e.user.features,
				N = e => {
					const t = R(e);
					return !!t && t.seenRedesignModal
				},
				L = e => e.user.prefs,
				M = e => e.user.prefs.allowClickTracking || !C(e),
				U = e => e.user.prefs.nightmode,
				F = e => !!e.user.prefs.nightmodeTempUpdated,
				B = e => e.user.prefs.geopopular,
				G = e => e.user.prefs && e.user.prefs.autoplayVideo,
				V = e => e.user.prefs.hideNSFW,
				q = e => L(e).ignoreSuggestedSort,
				H = e => L(e).over18,
				K = e => L(e).openPostInNewTab,
				W = e => L(e).emailDigests,
				Y = e => e.user.prefs.labelNSFW,
				z = e => e.user.prefs.featuresViewedHistory.commentForm.markdownModeNotification,
				J = e => {
					if (e.user.prefs && e.user.prefs.rpanDuDismissalTime) {
						const t = Date.now() - u.w;
						return e.user.prefs.rpanDuDismissalTime > t
					}
					return !1
				},
				Q = e => {
					const t = e.user.prefs ? e.user.prefs.topContentTimesDismissed : 0;
					if (t < 1) return !1;
					if (t < 2) {
						const t = Date.now() - u.Vb;
						if ((e.user.prefs ? e.user.prefs.topContentDismissalTime : 0) < t) return !1
					} else if (t < 3) {
						const t = Date.now() - 2 * u.Vb;
						if ((e.user.prefs ? e.user.prefs.topContentDismissalTime : 0) < t) return !1
					}
					return !0
				},
				X = e => e.user.prefs.rememberCommunityLayout,
				Z = e => !L(e).stylesEnabled,
				$ = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = L(e).subreddit[n];
					return !!r && !r.stylesEnabled
				},
				ee = e => !!e.user.temporaryGQL.isEmployee,
				te = e => !!e.user.temporaryGQL.isLoggedIn,
				ne = e => {
					const t = R(e);
					return !!t && t.isMod
				},
				re = e => {
					const t = R(e);
					return !!t && !t.isEmployee && t.isGold
				},
				se = e => {
					const t = R(e);
					return !!t && t.inRedesignBeta
				},
				oe = e => {
					const t = R(e);
					return !!t && t.inChat
				},
				ie = e => {
					const t = k(e);
					return !(!t || !t[b.a.SubredditChatNotifcationFtux])
				},
				ce = e => {
					const t = k(e);
					return !!(t && t.chat_subreddit || Object(m.g)(e))
				},
				ae = e => {
					const t = k(e);
					return !(!t || !t.chat_user_settings)
				},
				de = e => {
					const t = R(e);
					return !!t && t.seenSubredditChatFtux
				},
				ue = e => {
					const t = R(e);
					return !!t && t.seenGiveAwardTooltip
				},
				le = (e, t) => {
					let {
						userName: n
					} = t;
					return e.users.models[n.toLowerCase()]
				},
				be = (e, t) => {
					let {
						userId: n
					} = t;
					const r = ((e, t) => {
						let {
							userId: n
						} = t;
						return s()(a()(e.users.models), e => e.id === n)
					})(e, {
						userId: n
					});
					return r ? r.profileId : void 0
				},
				pe = (e, t) => {
					let {
						userName: n
					} = t;
					const r = le(e, {
						userName: n
					});
					return r ? r.profileId : void 0
				},
				me = (e, t) => {
					const n = t ? t.toLowerCase() : "";
					return t && e.contentGate[n] ? e.contentGate[n] : null
				},
				fe = (e, t) => {
					const n = R(e),
						r = t.post || t.postId && e.posts.models[t.postId];
					return !(!n || !r) && Object(p.f)(n) === r.author
				},
				ge = e => {
					const t = R(e);
					if (t) {
						return (Object(p.e)(t) || (new Date).getTime()) < (new Date).getTime() - u.db && (t.postKarma >= 5 || t.commentKarma >= 10)
					}
					return !1
				},
				Oe = e => e.user.sessionRefreshFailed,
				he = Object(l.a)(e => {
					if (!e.user || !e.user.account) return;
					const t = i()(e.user.account, ["hasUnreadOldModmail", "hasUnreadMail", "hasUnreadModmail", "hasUnreadMessages", "hasUnreadNotifs", "inboxCount"]);
					return e.platform.currentPage && e.platform.currentPage.routeMatch && Object(f.r)(e) === u.xb.INBOX_PAGES && e.user.prefs.markMessagesRead && (t.inboxCount = 0), t
				}),
				ye = e => {
					const t = he(e, y);
					return t && t.inboxCount
				},
				je = (e, t) => {
					const n = R(e);
					if (n) {
						return Object(p.f)(n).toLowerCase() === t.toLowerCase()
					}
					return !1
				},
				_e = e => e.user.drafts && e.user.drafts.count || 0,
				Ee = e => e.user.drafts && e.user.drafts.limit || 20,
				ve = (e, t) => {
					let {
						userName: n
					} = t;
					const r = le(e, {
						userName: n
					});
					return !!r && !!r.hasUserProfile
				},
				Ie = e => {
					const t = R(e);
					return !!t && t.hasUserProfile
				},
				Se = Object(d.a)(e => e.user.account, e => e.users.models, (e, t) => t, (e, t, n) => {
					const r = n.toLowerCase();
					return e && Object(p.f)(e) === r ? e : t[r]
				}),
				Te = e => {
					return Object(O.a)(e) - parseInt(e.user.loid.loidCreated) < u.w
				},
				xe = e => {
					const t = R(e);
					if (!t) return h;
					const n = Object(p.f)(t);
					return Object(g.n)(e, {
						profileName: n
					})
				},
				Ce = e => {
					const t = R(e);
					return !!t && (t.isSuspended && !t.isFPR)
				},
				we = e => {
					const t = R(e);
					return !!t && t.isFPR
				},
				Pe = (e, t) => e.user.accountSettings["".concat(t)].api.pending,
				De = e => e.user.accountSettings.changeEmail.api.error
		},
		"./src/reddit/selectors/userDataRequest.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			}));
			const r = e => e.userDataRequestPage.userDataRequestPageApi.userDataExportEligibility,
				s = e => e.userDataRequestPage.userDataRequestPageApi
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			}));
			var r = n("./src/lib/objectSelector/index.ts"),
				s = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/selectors/moderatorPermissions.ts");
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.userFlair[n]
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !e.userFlair[n] || e.userFlair[n].displaySettings.isEnabled
				},
				a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.userFlair[n] ? e.userFlair[n].displaySettings.position : s.b.Right
				},
				d = Object(r.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const r = i(e, {
						subredditId: n
					});
					if (r) return {
						type: s.d.UserFlair,
						displaySettings: r.displaySettings,
						permissions: r.permissions
					}
				}),
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					const r = c(e, {
							subredditId: n
						}),
						s = d(e, {
							subredditId: n
						}),
						a = i(e, {
							subredditId: n
						});
					if (!r || !s || !a) return !1;
					if (a.applied) return !0;
					const u = Object(o.d)(e, {
							subredditId: n
						}),
						{
							canUserChange: l
						} = s.permissions;
					return !!a.templateIds.find(e => {
						return !a.templates[e].modOnly || u
					}) && l
				}
		},
		"./src/reddit/selectors/video.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "i", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			}));
			const r = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.buffering[n]
				},
				s = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.consumed[n]
				},
				o = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.playing[n]
				},
				i = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.video.loadTimes[n]
				},
				c = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.video.metadata[n]
				},
				a = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.loadable[n]
				},
				d = (e, t) => {
					let {
						postId: n
					} = t;
					return !!e.posts.video.started[n]
				},
				u = (e, t) => {
					let {
						postId: n
					} = t;
					if (!n) return null;
					const r = e.posts.video.time[n];
					return r ? r.currentTime / 1e3 : null
				},
				l = (e, t) => {
					let {
						postId: n
					} = t;
					return e.posts.video.continuousViewStartedAt[n] || 0
				}
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "b", (function() {
				return y
			}));
			var r = n("./src/lib/objectSelector/index.ts"),
				s = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/name/index.ts"),
				i = n("./src/reddit/models/Widgets/index.ts"),
				c = n("./src/reddit/selectors/profile.ts"),
				a = n("./src/reddit/selectors/subreddit.ts");
			const d = e => e.widgets.models,
				u = Object(r.a)((e, t) => Object(i.r)(t) ? e.widgets.models[t.widgetId] : Object(i.l)(t.widgetKind)),
				l = (e, t) => e.widgets.idCardIds[t.subredditId],
				b = (e, t) => {
					let n = t.subredditId;
					if (!n && t.subredditName && (n = Object(a.G)(e, t.subredditName)), n) {
						const t = l(e, {
							subredditId: n
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				p = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				m = (e, t) => e.widgets.menuIds[t.subredditId],
				f = (e, t) => {
					const n = m(e, t);
					return n ? e.widgets.models[n] : null
				},
				g = (e, t) => {
					return e.widgets.sidebar[t.subredditId].reduce((t, n) => {
						const r = e.widgets.models[n];
						return r && t.push(r.kind), t
					}, [])
				},
				O = (e, t) => {
					const n = p(e, t);
					for (const r of n) {
						const t = e.widgets.models[r];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				h = (e, t) => {
					const n = p(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return n.length ? n : null
				},
				y = Object(r.a)((e, t) => {
					if (t.type === s.a.PROFILE) {
						const n = Object(c.j)(e, {
							profileName: t.name
						});
						return n ? {
							profile: {
								id: n.id,
								name: Object(o.f)(n.name)
							}
						} : {}
					}
					const n = Object(a.B)(e, {
							subredditName: t.name
						}),
						r = Object(a.y)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: r ? r.contentCategory : null,
							id: n.id,
							name: Object(o.f)(n.name)
						}
					}
				})
		},
		"./src/server/helpers/seoMetadata.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/react/index.js");
			var r = n("./node_modules/url/url.js"),
				s = n.n(r),
				o = n("./src/config.ts"),
				i = n("./src/lib/constants/index.ts"),
				c = (n("./src/lib/addQueryParams/index.ts"), n("./src/lib/isAdHocMultireddit/index.ts")),
				a = n("./src/lib/isFakeSubreddit/index.ts");
			n("./src/lib/makeCommentsPageKey/index.ts"), n("./src/lib/truncateText/index.ts"), n("./src/reddit/constants/experiments.ts"), n("./src/reddit/constants/page.ts");
			var d = n("./src/reddit/contexts/PageLayer/index.tsx"),
				u = n("./src/reddit/helpers/canonicalUrls.ts"),
				l = (n("./src/reddit/helpers/getRichTextContent/index.ts"), n("./src/reddit/helpers/getSubredditErrorProps/index.ts")),
				b = (n("./src/reddit/i18n/utils.ts"), n("./src/reddit/models/Comment/index.ts"), n("./src/reddit/models/Post/index.ts")),
				p = (n("./src/reddit/selectors/comments.ts"), n("./src/reddit/selectors/experiments/postSeo.ts"), n("./src/reddit/selectors/multireddit.ts"), n("./src/reddit/selectors/platform.ts")),
				m = n("./src/reddit/selectors/postCollection.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				g = n("./src/reddit/selectors/profile.ts"),
				O = (n("./src/reddit/selectors/structuredStyles.ts"), n("./src/reddit/selectors/subreddit.ts")),
				h = n("./src/reddit/selectors/user.ts");
			n("./src/reddit/models/Media/index.ts"), n("./src/app/strings/index.ts");
			n.d(t, "a", (function() {
				return _
			})), n.d(t, "b", (function() {
				return E
			}));
			const y = new Set([302, 400, 401, 403, 404, 421, 429, 500, 502, 503, 504, 0, void 0, null]),
				j = e => e.endsWith("/") ? e : "".concat(e, "/"),
				_ = e => {
					const t = Object(p.b)(e);
					if (!t) return null;
					const n = Object(p.r)(e);
					switch (n) {
						case i.xb.INDEX:
						case i.xb.LISTING:
							return t.routeMatch && t.routeMatch.route.chunk === i.o.FRONTPAGE ? j(o.a.redditUrl) : null;
						case i.xb.SUBREDDIT:
							const {
								subredditName: r
							} = t.urlParams, d = r && Object(O.d)(e, {
								subredditName: r
							});
							if (Object(a.a)(r) && Object(c.a)(r)) {
								const t = Object(u.a)(e, r);
								return t ? o.a.redditUrl + t : null
							}
							return d ? "".concat(o.a.redditUrl).concat(d) : null;
						case i.xb.COMMENTS:
						case i.xb.DUPLICATES:
							const {
								partialPostId: l
							} = t.urlParams, p = l && Object(b.m)(l), h = p && Object(f.H)(e, {
								postId: p
							});
							return h ? "".concat(o.a.redditUrl).concat(s.a.parse(h).path) : null;
						case i.xb.PROFILE_OVERVIEW:
						case i.xb.PROFILE_POSTS:
						case i.xb.PROFILE_COMMENTS:
							const {
								profileName: y
							} = t.urlParams, _ = Object(g.j)(e, {
								profileName: y
							});
							let E = "";
							return n === i.xb.PROFILE_POSTS ? E = "posts/" : n === i.xb.PROFILE_COMMENTS && (E = "comments/"), _ && _.url ? "".concat(o.a.redditUrl).concat(s.a.parse(_.url).path).concat(E) : null;
						case i.xb.COLLECTION_COMMENTS:
							const {
								collectionId: v
							} = t.urlParams, I = v && Object(m.q)(e, {
								collectionId: v
							}), S = I && I.permalink;
							return S ? "".concat(o.a.redditUrl).concat(s.a.parse(j(S)).path) : null;
						case i.xb.SUBREDDIT_LEADERBOARD:
							return t.routeMatch && t.routeMatch.route.chunk === i.o.SUBREDDIT_LEADERBOARD ? "".concat(o.a.redditUrl, "/subreddits/leaderboard/") : null;
						default:
							return null
					}
				},
				E = (e, t) => {
					if (t.head) {
						let n = t.querySelector("meta[name='robots']");
						const r = v(e),
							{
								head: s
							} = t;
						r ? (n || ((n = t.createElement("meta")).name = "robots", s.appendChild(n)), n.content = r) : n && (n.remove ? n.remove() : n.parentNode ? n.parentNode.removeChild(n) : s.removeChild && s.removeChild(n))
					}
				},
				v = e => {
					const {
						currentPage: t
					} = e.platform, n = Object(p.r)(e), r = Object(p.c)(e), s = y.has(r), o = Object(d.k)(e, {
						pageLayer: t
					}), c = !(!o || !o.hideFromRobots), a = I(e), u = t && t.isRobotIndexable, l = n === i.xb.COMMENTS || n === i.xb.COLLECTION_COMMENTS, b = !(!t || !t.urlParams.partialCommentId), m = n === i.xb.SEARCH_RESULTS || n === i.xb.SUBREDDIT_LEADERBOARD || n === i.xb.TOPIC || l && b;
					return c || s || a || (!1 === u || m) ? m ? "noindex" : "noindex,nofollow" : null
				},
				I = e => {
					let t = !1;
					const n = Object(p.e)(e);
					if (n) {
						const r = Object(h.f)(e, n);
						t = !!Object(l.a)(r, !1, n)
					}
					return t
				}
		}
	}
]);
//# sourceMappingURL=Governance~Reddit.2fe500d6e1ad4dfaa861.js.map