// https://www.redditstatic.com/desktop2x/Governance~Reddit.10701c589819b91ef4c1.js
// Retrieved at 10/5/2020, 4:20:08 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~Reddit"], {
		"./assets/fonts/NotoMono/font.less": function(e, t, s) {},
		"./src/graphql/operations/AllUserMultireddits.json": function(e) {
			e.exports = JSON.parse('{"id":"5ea7b64bc8a4"}')
		},
		"./src/graphql/operations/AwardSheetInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"4fb406bbd0cf"}')
		},
		"./src/graphql/operations/AwardSheetInfoForProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"c4be07fb0202"}')
		},
		"./src/graphql/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/graphql/operations/CreateCommunityAward.json": function(e) {
			e.exports = JSON.parse('{"id":"38852e4f82b0"}')
		},
		"./src/graphql/operations/CreateGlobalAward.json": function(e) {
			e.exports = JSON.parse('{"id":"c11324579f8c"}')
		},
		"./src/graphql/operations/CreateModAward.json": function(e) {
			e.exports = JSON.parse('{"id":"a04c85b4e964"}')
		},
		"./src/graphql/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/graphql/operations/CrowdControlLevelInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"975a7920607d"}')
		},
		"./src/graphql/operations/DisableAwardInCommunity.json": function(e) {
			e.exports = JSON.parse('{"id":"689f37138ede"}')
		},
		"./src/graphql/operations/EnableAwardInCommunity.json": function(e) {
			e.exports = JSON.parse('{"id":"3c2210d8ba4b"}')
		},
		"./src/graphql/operations/ExperimentVariants.json": function(e) {
			e.exports = JSON.parse('{"id":"34910619f1e9"}')
		},
		"./src/graphql/operations/FetchActiveCoinSale.json": function(e) {
			e.exports = JSON.parse('{"id":"33ef128566b2"}')
		},
		"./src/graphql/operations/FetchBlockedRedditorsInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"1e9183c00f76"}')
		},
		"./src/graphql/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/graphql/operations/FetchSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"df4f7fe92d1f"}')
		},
		"./src/graphql/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"bac623887684"}')
		},
		"./src/graphql/operations/FetchSubredditsNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/graphql/operations/Frontpage.json": function(e) {
			e.exports = JSON.parse('{"id":"2a42d91744d4"}')
		},
		"./src/graphql/operations/GetPostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"4231b7734ef9"}')
		},
		"./src/graphql/operations/GetSubredditChatSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"63d6a697b823"}')
		},
		"./src/graphql/operations/GetSubredditQuestions.json": function(e) {
			e.exports = JSON.parse('{"id":"461753a8d2ae"}')
		},
		"./src/graphql/operations/GildComment.json": function(e) {
			e.exports = JSON.parse('{"id":"c25f21e6351f"}')
		},
		"./src/graphql/operations/GildPost.json": function(e) {
			e.exports = JSON.parse('{"id":"496275fd4bb6"}')
		},
		"./src/graphql/operations/GlobalAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"06dccfbe114b"}')
		},
		"./src/graphql/operations/ManageableAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"e8574be731d1"}')
		},
		"./src/graphql/operations/ManageableAwardsForProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"ff403e6dac2b"}')
		},
		"./src/graphql/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(e) {
			e.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/graphql/operations/ModeratedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"db5cbe68b636"}')
		},
		"./src/graphql/operations/MultiredditListing.json": function(e) {
			e.exports = JSON.parse('{"id":"24ab40e0f21d"}')
		},
		"./src/graphql/operations/OtherDiscussions.json": function(e) {
			e.exports = JSON.parse('{"id":"14297124d6e4"}')
		},
		"./src/graphql/operations/PostFeedAndOtherDiscussions.json": function(e) {
			e.exports = JSON.parse('{"id":"4460a50c7363"}')
		},
		"./src/graphql/operations/PostIsTrackingCrossposts.json": function(e) {
			e.exports = JSON.parse('{"id":"a362f62253e5"}')
		},
		"./src/graphql/operations/ProductOffers.json": function(e) {
			e.exports = JSON.parse('{"id":"ddb1f9f5717c"}')
		},
		"./src/graphql/operations/ProfileModHubPage.json": function(e) {
			e.exports = JSON.parse('{"id":"113272b7cbb2"}')
		},
		"./src/graphql/operations/ProfileTrophies.json": function(e) {
			e.exports = JSON.parse('{"id":"3c59e5ed6f14"}')
		},
		"./src/graphql/operations/ReallocatePowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"d02bf38ca840"}')
		},
		"./src/graphql/operations/RedditorKarma.json": function(e) {
			e.exports = JSON.parse('{"id":"db6eb1356b13"}')
		},
		"./src/graphql/operations/RedditorMultireddits.json": function(e) {
			e.exports = JSON.parse('{"id":"3d04e2bb92b5"}')
		},
		"./src/graphql/operations/RedditorPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"e2bcd0fbaace"}')
		},
		"./src/graphql/operations/RemoveCommunityAward.json": function(e) {
			e.exports = JSON.parse('{"id":"973872832463"}')
		},
		"./src/graphql/operations/RichTextPostContent.json": function(e) {
			e.exports = JSON.parse('{"id":"fc24b7b690ad"}')
		},
		"./src/graphql/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"b85af9fd9703"}')
		},
		"./src/graphql/operations/SubredditCoins.json": function(e) {
			e.exports = JSON.parse('{"id":"a82ef253ed10"}')
		},
		"./src/graphql/operations/SubredditGeoRecommendationViaFocusVertical.json": function(e) {
			e.exports = JSON.parse('{"id":"a9c3480dea2f"}')
		},
		"./src/graphql/operations/SubredditLinks.json": function(e) {
			e.exports = JSON.parse('{"id":"e74dba05ccd0"}')
		},
		"./src/graphql/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"3de09ab3740b"}')
		},
		"./src/graphql/operations/SubredditPostFlairStyleTemplates.json": function(e) {
			e.exports = JSON.parse('{"id":"9a87d9b91dc4"}')
		},
		"./src/graphql/operations/SubredditPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"0ea72f3caca5"}')
		},
		"./src/graphql/operations/SubredditPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"673c430fbc2a"}')
		},
		"./src/graphql/operations/SubredditPowerupsFull.json": function(e) {
			e.exports = JSON.parse('{"id":"4c0acc378909"}')
		},
		"./src/graphql/operations/SubredditRecommendations.json": function(e) {
			e.exports = JSON.parse('{"id":"3c4d88474140"}')
		},
		"./src/graphql/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"0df127946e72"}')
		},
		"./src/graphql/operations/SubredditStyles.json": function(e) {
			e.exports = JSON.parse('{"id":"8d0e34deaa32"}')
		},
		"./src/graphql/operations/SubredditTopContent.json": function(e) {
			e.exports = JSON.parse('{"id":"050ae396c8ed"}')
		},
		"./src/graphql/operations/SubredditTypeaheadSearch.json": function(e) {
			e.exports = JSON.parse('{"id":"20edc5ee12df"}')
		},
		"./src/graphql/operations/SubredditsPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"1e7a770e0bc7"}')
		},
		"./src/graphql/operations/SubscribedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"46c94140fba5"}')
		},
		"./src/graphql/operations/TopicBySlug.json": function(e) {
			e.exports = JSON.parse('{"id":"17eb494cb2c0"}')
		},
		"./src/graphql/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/graphql/operations/UpdateSubredditChatSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"bdb05b8c7a65"}')
		},
		"./src/graphql/operations/UpdateSubredditNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		},
		"./src/graphql/operations/UpdateSubredditPrimaryTag.json": function(e) {
			e.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/graphql/operations/UpdateSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"1f690708b8b1"}')
		},
		"./src/graphql/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/graphql/operations/UsableAwards.json": function(e) {
			e.exports = JSON.parse('{"id":"a67569476052"}')
		},
		"./src/graphql/operations/UsableAwardsForProfile.json": function(e) {
			e.exports = JSON.parse('{"id":"d45610c1d3a6"}')
		},
		"./src/graphql/operations/UserDataExportEligibility.json": function(e) {
			e.exports = JSON.parse('{"id":"3817c69d7a39"}')
		},
		"./src/graphql/operations/UserPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"556b2d511693"}')
		},
		"./src/graphql/operations/VerifyRecaptchaToken.json": function(e) {
			e.exports = JSON.parse('{"id":"c1242f999b6c"}')
		},
		"./src/lib/addAllowQuarantinedParam/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(n.a)(e, {
				allow_quarantined: !0
			})
		},
		"./src/lib/ads/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "m", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "k", (function() {
				return i
			})), s.d(t, "i", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "l", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "f", (function() {
				return g
			})), s.d(t, "q", (function() {
				return f
			})), s.d(t, "o", (function() {
				return m
			})), s.d(t, "t", (function() {
				return j
			})), s.d(t, "r", (function() {
				return _
			})), s.d(t, "p", (function() {
				return h
			})), s.d(t, "n", (function() {
				return y
			})), s.d(t, "s", (function() {
				return E
			}));
			var n;
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			! function(e) {
				e.muted = "muted"
			}(n || (n = {}));
			const r = .01,
				a = .3,
				i = .5,
				o = .8,
				c = 1,
				d = 0,
				u = 1e3,
				l = 100,
				b = 2e3,
				p = 3e3,
				O = 5e3,
				g = 15e3,
				f = [.01, .3, .5, 1],
				m = [.01, .5, .8, 1, {
					key: "TOTAL_MRC_VIEWABLE_TIME",
					playing: !0,
					threshold: i
				}, {
					key: "HALF_DURATION_80_IN_VIEW_AUDIBLE",
					playing: !0,
					withSound: !0,
					threshold: o
				}, {
					key: "FULL_IN_VIEW_AUDIBLE_TIME",
					playing: !0,
					threshold: c,
					withSound: !0
				}, {
					key: "FULL_IN_VIEW_TIME",
					playing: !0,
					threshold: c
				}, {
					key: "AUDIBLE_TIME",
					playing: !0,
					threshold: 0,
					withSound: !0
				}],
				j = function(e, t) {
					let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "value";
					const n = Object.entries(t).reduce((t, n) => {
						let [r, a] = n;
						return t[r] = a[e] ? a[e][s] : void 0, t
					}, {});
					return n
				},
				_ = e => e.map(e => e && "object" == typeof e ? e.key : Math.floor(100 * e)),
				h = _(f),
				y = _(m),
				E = (e, t) => {
					let s, n = e.source,
						r = e.callToAction;
					if (t) {
						n = {
							displayText: t.displayAddress || t.displayUrl || t.outboundUrl,
							outboundUrl: t.outboundUrl,
							url: t.outboundUrl
						}, s = t.caption, r = t.callToAction
					}
					return {
						source: n,
						caption: s,
						callToAction: r
					}
				}
		},
		"./src/lib/ads/store.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return a
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "d", (function() {
				return p
			}));
			var n = s("./src/lib/ads/index.ts");
			let r = {};
			const a = e => (() => r)()[e],
				i = e => e.reduce((e, t) => (e[t] = {
					maxContinuousTime: 0,
					totalTime: 0,
					timeEntered: null
				}, e), {}),
				o = () => ({
					thresholdData: i(n.p),
					videoThresholdData: i(n.n),
					videoAds: {
						muted: {}
					}
				}),
				c = Object.freeze(o()),
				d = (e, t, s, a) => {
					const i = Date.now(),
						o = s ? "videoThresholdData" : "thresholdData";
					Object(n.r)(t).forEach(t => {
						const s = r[e][o][t];
						if (a) s.timeEntered = s.timeEntered || i;
						else if (s.timeEntered) {
							const e = i - s.timeEntered;
							s.totalTime += e, s.maxContinuousTime = Math.max(s.maxContinuousTime, e), s.timeEntered = null
						}
					})
				},
				u = (e, t, s) => {
					const n = r[e].videoAds[s];
					n.value = t, n.timeUpdated = n.timeUpdated && n.value === t ? n.timeUpdated : Date.now()
				},
				l = e => (function(t) {
					r[t] || (r[t] = o());
					for (var s = arguments.length, n = new Array(s > 1 ? s - 1 : 0), a = 1; a < s; a++) n[a - 1] = arguments[a];
					e.apply(void 0, [t, ...n])
				}),
				b = l((e, t, s) => d(e, t, s, !0)),
				p = l((e, t, s) => d(e, t, s, !1))
		},
		"./src/lib/assertNever.ts": function(e, t, s) {
			"use strict";

			function n(e) {
				throw new Error("Unexpected object: ".concat(e))
			}
			s.d(t, "a", (function() {
				return n
			}))
		},
		"./src/lib/asyncActions/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "a", (function() {
				return c
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = e => "".concat(e, "_REQUESTED"),
				a = e => "".concat(e, "_SUCCEEDED"),
				i = e => "".concat(e, "_FAILED");

			function o(e) {
				const t = r(e),
					s = a(e),
					o = i(e);
				return {
					requestedActionType: t,
					requested: Object(n.a)(t),
					succeededActionType: s,
					succeeded: Object(n.a)(s),
					failedActionType: o,
					failed: Object(n.a)(o)
				}
			}
			var c;
			! function(e) {
				e[e.New = 0] = "New", e[e.Pending = 1] = "Pending", e[e.Succeeded = 2] = "Succeeded", e[e.Failed = 3] = "Failed"
			}(c || (c = {}));
			const d = (e, t, s) => (function() {
				let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c.New,
					r = arguments.length > 1 ? arguments[1] : void 0;
				switch (r.type) {
					case e:
						return n === c.New ? c.Pending : n;
					case t:
						return n === c.Pending ? c.Succeeded : n;
					case s:
						return n === c.Pending ? c.Failed : n;
					default:
						return n
				}
			})
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "custom"
		},
		"./src/lib/filterQueryParams/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./node_modules/lodash/omit.js"),
				r = s.n(n),
				a = s("./node_modules/node-libs-browser/node_modules/url/url.js"),
				i = s.n(a);
			t.a = (e, t) => {
				const s = i.a.parse(e, !0);
				return s.search = void 0, s.query = Object.assign({}, r()(s.query, t)), i.a.format(s)
			}
		},
		"./src/lib/forceHttps/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = function(e) {
				return e.startsWith("http") ? e.replace(/^http:\/\//i, "https://") : "https://".concat(e)
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/constants/index.ts");

			function a(e, t) {
				return e ? e.fields && e.fields.length ? e.fields.map(e => e.msg).join(", ") : e.type && i[e.type] ? i[e.type]() : 401 === t ? n.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : n.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const i = {
				[r.j]: () => n.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.H]: () => n.fbt._("GIF size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.R / r.ab).toString())], {
					hk: "1zzsdM"
				}),
				[r.K]: () => n.fbt._("Image size must be less than {max file size}MB", [n.fbt._param("max file size", Math.floor(r.T / r.ab).toString())], {
					hk: "3H6bF8"
				}),
				[r.M]: () => n.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.Yb]: () => n.fbt._("Video size must be less than {max file size}GB", [n.fbt._param("max file size", (r.Y / r.ab / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/isEqualWithoutKey/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/lodash/isEqual.js"),
				r = s.n(n),
				a = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			t.a = (e, t) => {
				const {
					key: s
				} = e, n = a(e, ["key"]), {
					key: i
				} = t, o = a(t, ["key"]);
				return r()(n, o)
			}
		},
		"./src/lib/makeCollectionCommentsPageKey/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.array.sort.js");
			t.a = function(e, t, s) {
				let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
					r = "collectionCommentsPage--[collection:'".concat(e, "']");
				return t && (r += "--[post:'".concat(t, "']")), s && (r += "--[rootComment:'".concat(s, "']")), n && (n.sort && n.hasSortParam && (r += "--[sort:'".concat(n.sort, "']")), n.context && (r += "--[context:".concat(n.context, "]")), n.depth && (r += "--[depth:".concat(n.depth, "]"))), r
			}
		},
		"./src/lib/makeCommentsPageKey/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.array.sort.js");
			t.a = function(e, t) {
				let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
					n = "commentsPage--[post:'".concat(e, "']");
				return t && (n += "--[rootComment:'".concat(t, "']")), s && (s.sort && s.hasSortParam && (n += "--[sort:'".concat(s.sort, "']")), s.context && (n += "--[context:".concat(s.context, "]")), s.depth && (n += "--[depth:".concat(s.depth, "]"))), n
			}
		},
		"./src/lib/makeDraftKey/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/reddit/models/PostDraft/index.ts");

			function r(e, t) {
				return "".concat(n.c[e], "_").concat(t)
			}
		},
		"./src/lib/makeLinkedPostsListingKey/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				return "linkedPosts--[post:'".concat(e, "']")
			}
		},
		"./src/lib/makeOverviewConversationsItemKey/index.ts": function(e, t, s) {
			"use strict";
			t.a = (e, t) => {
				return "overviewConversations--[profile:'".concat(t, "']--[post:'").concat(e, "']")
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, s) {
			"use strict";

			function n(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += "--[draftId:".concat(e.draftId, "]")), t
			}
			s.d(t, "a", (function() {
				return n
			}))
		},
		"./src/lib/makeProductOfferKey/index.ts": function(e, t, s) {
			"use strict";

			function n(e, t) {
				return "".concat(e, "_").concat(t)
			}
			s.d(t, "a", (function() {
				return n
			}))
		},
		"./src/lib/omitKey/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var r = 0;
					for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
				}
				return s
			};

			function r(e, t) {
				if (t in e) {
					const s = e,
						r = t;
					s[r];
					return n(s, ["symbol" == typeof r ? r : r + ""])
				}
				return e
			}
		},
		"./src/lib/reCaptchaEnterprise/ReCaptchaEnterpriseClient.ts": function(e, t) {},
		"./src/lib/reCaptchaEnterprise/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return O
			}));
			s("./src/lib/reCaptchaEnterprise/reCaptcha.css");
			var n = s("./src/config.ts"),
				r = s("./src/reddit/helpers/loadThirdPartyScript.ts");
			const a = e => "object" == typeof e && null !== e,
				i = () => "undefined" != typeof window && a(window) && a(window.grecaptcha) && a(window.grecaptcha.enterprise),
				o = () => i() ? window.grecaptcha.enterprise : void 0,
				c = e => "https://www.google.com/recaptcha/enterprise.js?render=".concat(e),
				d = e => Object(r.a)(c(e), i),
				u = e => new Promise(t => e.ready(t));
			var l, b = s("./node_modules/ts-error/lib/cjs.js"),
				p = s.n(b);
			class MissingReCaptchaEnterpriseSiteKeyError_MissingReCaptchaEnterpriseSiteKeyError extends p.a {
				constructor() {
					super("reCaptcha Enterprise site key is not set")
				}
			}
			class ReCaptchaEnterpriseClientIsNotReadyError_ReCaptchaEnterpriseClientIsNotReadyError extends p.a {
				constructor() {
					super("reCaptcha Enterprise client is not ready")
				}
			}
			class ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError extends p.a {
				constructor() {
					super("reCaptcha Enterprise client is not available")
				}
			}! function(e) {
				e.PageLoad = "PAGE_LOAD"
			}(l || (l = {}));
			var O = l;
			s("./src/lib/reCaptchaEnterprise/ReCaptchaEnterpriseClient.ts");
			const g = new class {
				constructor() {
					var e = this;
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n.a.reCaptchaEnterprise.siteKey,
						s = arguments.length > 1 ? arguments[1] : void 0;
					this.siteKey = t, this.isReady = !1, this.hasSiteKey = () => !!this.siteKey, this.hasClient = () => !!this.instance, this.setInstance = e => {
						e && (this.instance = e, this.isReady = !1)
					}, this.scriptUrl = () => c(this.siteKey), this.ensureSiteKey = () => {
						if (!this.hasSiteKey) throw new MissingReCaptchaEnterpriseSiteKeyError_MissingReCaptchaEnterpriseSiteKeyError
					}, this.ensureClient = () => {
						const e = this.instance;
						if (!e) throw new ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError;
						return e
					}, this.waitUntilClientIsReady = async () => {
						const e = this.ensureClient();
						return await u(e), this.isReady = !0, e
					}, this.ensureClientIsReady = () => {
						const e = this.ensureClient();
						if (!this.isReady) throw new ReCaptchaEnterpriseClientIsNotReadyError_ReCaptchaEnterpriseClientIsNotReadyError;
						return e
					}, this.loadScript = async function() {
						let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						if (!e.instance || t) {
							e.ensureSiteKey(), await d(e.siteKey);
							const t = o();
							if (!t) throw new ReCaptchaEnterpriseClientNotAvailableError_ReCaptchaEnterpriseClientNotAvailableError;
							e.setInstance(t)
						}
						e.isReady || await e.waitUntilClientIsReady()
					}, this.execute = async e => {
						this.ensureSiteKey();
						const t = this.ensureClientIsReady(),
							s = await t.execute(this.siteKey, e);
						if (e.fast) {
							return JSON.parse(s)[1]
						}
						return s
					}, this.setInstance(s || o())
				}
			};
			t.b = g
		},
		"./src/lib/reCaptchaEnterprise/reCaptcha.css": function(e, t, s) {},
		"./src/lib/stringInterpolate/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js");

			function n(e, t) {
				return e && t ? e.replace(/%\{(\w+)\}/g, (e, s) => {
					const n = t[s];
					return null == n ? s : String(n)
				}) : e
			}
		},
		"./src/lib/uploadToS3/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/loadWithRetries/index.ts"),
				a = s("./src/lib/makeRequest/index.ts");
			const i = (e, t) => {
				const s = new FormData;
				return t.fields.forEach(e => {
					e.value && s.append(e.name, e.value)
				}), s.append("file", e), s
			};
			t.a = async (e, t, o) => {
				const c = (() => Object(r.a)(() => s.e("vendors~xml2js").then(s.t.bind(null, "./node_modules/xml2js/lib/xml2js.js", 7))).then(e => e.default))(),
					d = await Object(a.b)({
						data: i(e, t),
						endpoint: t.action,
						method: n.db.POST,
						type: null,
						setup: o
					});
				if ("string" != typeof d.body) return d;
				try {
					(await c).parseString(d.body, (e, t) => {
						d.body = t
					})
				} catch (u) {
					d.body = u
				}
				return d
			}
		},
		"./src/reddit/actions/ads/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "n", (function() {
				return r
			})), s.d(t, "o", (function() {
				return a
			})), s.d(t, "p", (function() {
				return i
			})), s.d(t, "q", (function() {
				return o
			})), s.d(t, "s", (function() {
				return c
			})), s.d(t, "t", (function() {
				return d
			})), s.d(t, "u", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "m", (function() {
				return p
			})), s.d(t, "v", (function() {
				return O
			})), s.d(t, "x", (function() {
				return g
			})), s.d(t, "w", (function() {
				return f
			})), s.d(t, "r", (function() {
				return m
			})), s.d(t, "j", (function() {
				return j
			})), s.d(t, "d", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "e", (function() {
				return y
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "h", (function() {
				return I
			})), s.d(t, "g", (function() {
				return v
			})), s.d(t, "k", (function() {
				return S
			})), s.d(t, "l", (function() {
				return T
			}));
			const n = "AD_BRAND_SAFETY_STATUS_RECEIVED",
				r = "FETCH_COMMENTS_PAGE_ADS_COMPLETED",
				a = "FETCH_COMMENTS_PAGE_ADS_FAILED",
				i = "FETCH_SIDEBAR_PROMOTED_POSTS_COMPLETED",
				o = "FETCH_SIDEBAR_PROMOTED_POSTS_FAILED",
				c = "REFRESH_SIDEBAR_PROMOTED_POST_COMPLETED",
				d = "REFRESH_SIDEBAR_PROMOTED_POST_FAILED",
				u = "RESET_SIDEBAR_PROMOTED_POSTS",
				l = "AD__IMPRESSION",
				b = "AD__CLICK",
				p = "AD__VIEWABLE_IMPRESSION",
				O = "VENDOR_FULLY_IN_VIEW",
				g = "VENDOR_FULLY_IN_VIEW_5_SECS",
				f = "VENDOR_FULLY_IN_VIEW_15_SECS",
				m = "GROUPM_VIEWABLE",
				j = "AD__VIDEO_VIEWABLE",
				_ = "AD__VIDEO_FULLY_VIEWABLE",
				h = "AD__VIDEO_GROUP_M_VIEWABLE",
				y = "AD__VIDEO_FULLY_VIEWABLE_50",
				E = "AD__VIDEO_STARTED",
				I = "AD__VIDEO_PLAYED_WITH_SOUND",
				v = "AD__VIDEO_PLAYED_EXPANDED",
				S = "AD__VIDEO_WATCHED_PERCENT",
				T = "AD__VIDEO_WATCHED_SECONDS"
		},
		"./src/reddit/actions/ads/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return f
			})), s.d(t, "b", (function() {
				return E
			})), s.d(t, "c", (function() {
				return I
			})), s.d(t, "a", (function() {
				return v
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/constants/posts.ts"),
				a = s("./src/config.ts"),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeApiRequest/index.ts");
			const c = async e => {
				let {
					context: t,
					count: s,
					subreddit: n,
					forceAd: r
				} = e;
				const c = {
					count: s
				};
				return n && (c.subreddit = n), r && (c.sidebar_ad = r), Object(o.a)(t, {
					type: "json",
					endpoint: "".concat(a.a.gatewayUrl, "/desktopapi/v1/sidebar_ads"),
					method: i.db.POST,
					data: c
				})
			};
			var d = s("./src/reddit/helpers/adCount/index.ts"),
				u = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				l = s("./src/reddit/selectors/brandSafety.ts"),
				b = s("./src/reddit/selectors/platform.ts"),
				p = s("./src/reddit/selectors/posts.ts"),
				O = s("./src/reddit/actions/ads/constants.ts");
			const g = Object(n.a)(O.a),
				f = e => async (t, s) => {
					const n = s();
					Object(l.c)(n) && Object(l.d)(n) === e.isViewSafe || t(g(e))
				}, m = Object(n.a)(O.p), j = Object(n.a)(O.q), _ = Object(n.a)(O.s), h = Object(n.a)(O.t), y = (Object(n.a)(O.u), Object(n.a)(O.n)), E = (Object(n.a)(O.o), e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					var i;
					const o = s(),
						l = Object(b.q)(o),
						O = Object(d.b)(o, e),
						g = O.length;
					if (0 === g) return;
					switch (e) {
						case u.a.COMMENTS:
						case u.a.COMMENTS_OVERLAY: {
							const e = Object(b.n)(o, {
								page: o.platform.currentPage
							});
							if (!e || e.belongsTo.type === r.a.PROFILE) return;
							break
						}
						case u.a.FRONTPAGE:
						case u.a.MULTIREDDIT:
						case u.a.SEARCH_RESULTS:
						case u.a.SUBREDDIT: {
							const e = o.listings.activeKey,
								t = Object(p.T)(o, {
									listingKey: e
								});
							if (!t || !t.length) return;
							break
						}
						default:
							return void 0
					}
					const f = Object(b.e)(o);
					let _;
					if ((_ = await c({
							context: a(),
							count: g,
							subreddit: f || void 0,
							forceAd: null === (i = null == l ? void 0 : l.sidebar_ad) || void 0 === i ? void 0 : i.split(",")
						})).body && _.body.length) {
						const e = _.body,
							s = {};
						for (let t = 0; t < e.length; t++) s[O[t]] = e[t];
						t(m(s))
					} else t(j(_.error))
				}), I = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					var a;
					const i = s(),
						o = Object(b.q)(i),
						d = await c({
							context: r(),
							count: 1,
							forceAd: null === (a = null == o ? void 0 : o.sidebar_ad) || void 0 === a ? void 0 : a.split(",")
						});
					d.body && d.body.length ? t(_({
						[e]: d.body[0]
					})) : t(h(d.error))
				}, v = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const c = s(),
						d = Object(b.q)(c),
						u = Object(b.e)(c),
						l = await (async e => {
							let {
								context: t,
								count: s,
								postId: n,
								subredditName: r,
								forceAd: c
							} = e;
							const d = {
								count: s,
								subreddit: r,
								post_id: n,
								comments_ad: c
							};
							return Object(o.a)(t, {
								type: "json",
								endpoint: "".concat(a.a.gatewayUrl, "/desktopapi/v1/comments_page_ads"),
								method: i.db.POST,
								data: d
							})
						})({
							context: r(),
							count: 1,
							postId: e,
							subredditName: u,
							forceAd: d ? d.comments_ad : void 0
						});
					if (l.body && l.body.length) return t(y(l.body)), l.body[0].id;
					t(j(l.error))
				}
		},
		"./src/reddit/actions/apiRequestHeaders.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "API_REQUEST_HEADERS__set";
			Object(n.a)(r)
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "h", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "g", (function() {
				return b
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/models/ApiRequestState/index.ts");
			const a = "API_REQUEST_STATE__STARTED",
				i = "API_REQUEST_STATE__COMPLETED",
				o = "API_REQUEST_STATE__FAILED",
				c = "API_REQUEST_STATE__RELEASED";

			function d(e) {
				return {
					type: a,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: e
					}
				}
			}

			function u(e) {
				return {
					type: i,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: e
					}
				}
			}

			function l(e, t) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const b = Object(n.a)(c)
		},
		"./src/reddit/actions/authorFlair.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "IN_CONTEXT_AUTHOR_FLAIR_UPDATED",
				a = Object(n.a)(r)
		},
		"./src/reddit/actions/badge.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "i", (function() {
				return b
			})), s.d(t, "g", (function() {
				return p
			})), s.d(t, "h", (function() {
				return O
			})), s.d(t, "j", (function() {
				return g
			})), s.d(t, "k", (function() {
				return v
			})), s.d(t, "l", (function() {
				return S
			})), s.d(t, "m", (function() {
				return T
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/governance/errorToast.ts"),
				a = s("./src/reddit/endpoints/governance/badges.ts");
			const i = "BADGE__BADGE_MODAL_OPENED",
				o = "BADGE__BADGE_APPLICATION_SUCCESS",
				c = "BADGE__BADGE_APPLICATION_FAILURE",
				d = "BADGE__SUBREDDIT_BADGES_FETCH_SUCCESS",
				u = "BADGE__SUBREDDIT_BADGES_FETCH_FAILURE",
				l = "BADGE__SUBREDDIT_BADGES_FETCH_PENDING",
				b = "BADGE__USER_BADGES_FETCH_SUCCESS",
				p = "BADGE__USER_BADGES_FETCH_FAILURE",
				O = "BADGE__USER_BADGES_FETCH_PENDING",
				g = Object(n.a)(i),
				f = Object(n.a)(o),
				m = Object(n.a)(c),
				j = (Object(n.a)("BADGE__BADGE_APPLICATION_PENDING"), Object(n.a)(d)),
				_ = Object(n.a)(u),
				h = Object(n.a)(l),
				y = Object(n.a)(b),
				E = Object(n.a)(p),
				I = Object(n.a)(O),
				v = e => {
					let {
						badgeIds: t,
						subredditId: s
					} = e;
					return async (e, n, i) => {
						let {
							apiContext: o
						} = i;
						const c = n(),
							d = c.user.account;
						if (d) {
							const n = (c.users.appliedBadges[d.id] || {})[s] || [],
								i = t.length ? t[0] : n[0],
								u = !!t.length;
							e(f({
								badgeIds: t,
								subredditId: s,
								userId: d.id
							}));
							const l = await Object(a.a)(o(), s, i, u);
							l.ok || (e(m({
								badgeIds: t,
								subredditId: s,
								error: l.error,
								previousBadgeIds: n,
								userId: d.id
							})), Object(r.a)(e, l.error))
						}
					}
				},
				S = e => {
					let {
						subredditId: t,
						userIds: s
					} = e;
					return async (e, n, r) => {
						let {
							apiContext: i
						} = r;
						e(h({
							subredditId: t
						}));
						const o = await Object(a.b)(i(), t, s);
						o.ok ? e(j(Object.assign(Object.assign({}, o.body), {
							subredditId: t
						}))) : e(_({
							subredditId: t,
							error: o.error
						}))
					}
				},
				T = e => {
					let {
						subredditId: t
					} = e;
					return async (e, s, n) => {
						let {
							apiContext: r
						} = n;
						const i = s().user.account;
						if (i) {
							e(I({
								subredditId: t
							}));
							const s = await Object(a.c)(r(), t, i.id);
							s.ok ? e(y(Object.assign(Object.assign({}, s.body), {
								subredditId: t
							}))) : e(E({
								subredditId: t,
								error: s.error
							}))
						}
					}
				}
		},
		"./src/reddit/actions/blockedRedditors.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "h", (function() {
				return O
			})), s.d(t, "g", (function() {
				return j
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/graphql/operations/FetchBlockedRedditorsInfo.json"),
				a = s("./src/lib/makeGqlRequest/index.ts");
			const i = (e, t) => Object(a.a)(e, Object.assign(Object.assign({}, r), {
				variables: t
			}), {
				traceRequestName: "get_blocked_redditors_info"
			});
			var o = s("./src/reddit/selectors/blockedRedditors.ts");
			const c = "BLOCKED_REDDITORS_LIST__ADD",
				d = "BLOCKED_REDDITORS_LIST__REMOVE",
				u = "BLOCKED_REDDITORS_LIST__FAILED",
				l = "BLOCKED_REDDITORS_LIST__LOADED",
				b = "BLOCKED_REDDITORS_LIST__PENDING",
				p = Object(n.a)(c),
				O = Object(n.a)(d),
				g = Object(n.a)(u),
				f = Object(n.a)(l),
				m = Object(n.a)(b),
				j = () => async (e, t, s) => {
					let {
						gqlContext: n
					} = s;
					const r = t(),
						a = Object(o.a)(r);
					if (Object(o.b)(r) || a.timestamp && Date.now() - a.timestamp < 36e6) return;
					let c = !1,
						d = "";
					do {
						e(m());
						const t = {
								after: d,
								pageSize: 100
							},
							s = await i(n(), t);
						if (s && s.ok) {
							const {
								data: {
									identity: t
								}
							} = s.body;
							if (t && t.blockedRedditorsInfo) {
								const {
									pageInfo: s,
									edges: n
								} = t.blockedRedditorsInfo;
								if (e(f(n.map(e => e.node.id))), s) {
									const {
										hasNextPage: e,
										endCursor: t
									} = s;
									c = e, d = t || ""
								}
							} else c = !1
						} else {
							c = !1;
							const t = s.error ? s.error.type : "unknown error";
							e(g({
								message: t
							}))
						}
					} while (c)
				}
		},
		"./src/reddit/actions/bulkActions/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = "BULKACTION_PENDING",
				r = "BULKACTION_LOADED",
				a = "BULKACTION_FAILED"
		},
		"./src/reddit/actions/category/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "g", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			}));
			const n = "CATEGORY__LIST_PENDING",
				r = "CATEGORY__LIST_LOADED",
				a = "CATEGORY__LIST_FAILED",
				i = "CATEGORY__SUBREDDITS_PENDING",
				o = "CATEGORY__SUBREDDITS_LOADED",
				c = "CATEGORY__SUBREDDITS_FAILED",
				d = "CATEGORY__RANK_SET"
		},
		"./src/reddit/actions/category/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return j
			})), s.d(t, "b", (function() {
				return E
			})), s.d(t, "c", (function() {
				return v
			}));
			var n = s("./src/lib/initializeClient/installReducer.ts"),
				r = s("./src/reddit/reducers/features/categories/index.ts"),
				a = (s("./node_modules/lodash/isEmpty.js"), s("./node_modules/react-router-redux/es/index.js"), s("./src/lib/makeActionCreator/index.ts")),
				i = s("./src/reddit/constants/categories.tsx"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts");
			var l = s("./src/reddit/endpoints/category/subreddits.ts"),
				b = s("./src/reddit/helpers/localStorage/index.ts"),
				p = s("./src/reddit/selectors/category.ts"),
				O = s("./src/reddit/actions/category/constants.ts");
			Object(n.a)({
				features: {
					categories: r.a
				}
			});
			const g = Object(a.a)(O.c),
				f = Object(a.a)(O.b),
				m = Object(a.a)(O.a),
				j = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t(),
						a = Object(p.i)(r),
						l = Object(p.h)(r);
					if (a || l) return;
					e(g());
					const b = await (e => Object(c.a)(Object(d.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/available_subreddit_categories.json?use_extended_categories=true"),
						method: o.db.GET
					}))(n());
					if (b.ok) {
						const {
							categories: t,
							categoryIds: s
						} = (e => {
							const t = {},
								s = [];
							return e.forEach((e, n) => {
								const r = {
									attr: e.category_attr,
									color: e.category_color || i.a[n % i.a.length],
									icon: e.category_icon,
									id: e.category_id,
									name: e.category_name
								};
								s.push(r.id), t[r.id] = r
							}), {
								categories: t,
								categoryIds: s
							}
						})(b.body);
						e(f({
							categories: t,
							categoryIds: s
						}))
					} else e(m(b.error))
				}, _ = Object(a.a)(O.g), h = Object(a.a)(O.f), y = Object(a.a)(O.e), E = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(p.n)(i, {
							id: e
						}),
						c = Object(p.m)(i, {
							id: e
						});
					if (o || c) return;
					s(_({
						categoryId: e
					}));
					const d = await Object(l.a)(a(), e, t);
					if (d.ok) {
						const t = Object(l.b)(d.body);
						s(h(Object.assign({
							categoryId: e
						}, t)))
					} else s(y({
						categoryId: e,
						error: d.error
					}))
				}, I = Object(a.a)(O.d), v = e => async (t, s) => {
					const n = Object(p.k)(s(), {
						id: e
					});
					t(I({
						categoryId: e,
						rank: n + 1
					})), Object(b.P)(Object(p.e)(s()))
				}
		},
		"./src/reddit/actions/changeUsername.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "f", (function() {
				return O
			})), s.d(t, "e", (function() {
				return g
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/interceptedAction.ts"),
				a = s("./src/reddit/actions/modal.ts"),
				i = s("./src/reddit/components/Settings/modalIds.ts"),
				o = s("./src/reddit/constants/actions.ts"),
				c = s("./src/reddit/selectors/interceptedAction.ts");
			const d = "CHANGE_USERNAME_TOOLTIP_CLOSED",
				u = "CHANGE_USERNAME_TOOLTIP_OPENED",
				l = "SAVE_USERNAME_SUCCESS",
				b = Object(n.a)(d),
				p = (Object(n.a)(u), Object(n.a)(l)),
				O = e => async (t, s) => {
					e && t(Object(r.c)(e)), t(Object(a.h)(i.e))
				}, g = (e, t) => async (s, n) => {
					const a = Object(c.a)(n());
					if (s(p({
							username: e
						})), a) {
						s(((e, t, s) => {
							switch (e.type) {
								case o.a: {
									const {
										payload: {
											args: n
										}
									} = e;
									n && n[0] && "string" == typeof n[0] && (n[0] = n[0].split(s).join(t));
									break
								}
							}
							return e
						})(a, e, t)), s(Object(r.d)())
					}
				}
		},
		"./src/reddit/actions/chat/constants.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.anybody = "Everyone", e.account_age_30_days = "Accounts older than 30 days", e.nobody = "Nobody"
				}(n || (n = {}))
		},
		"./src/reddit/actions/chat/init.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "c", (function() {
				return l
			}));
			var n = s("./src/chat/customMiddleware/containerSize.ts"),
				r = s("./src/chat/reducers/subscribe.ts"),
				a = s("./src/lib/loadWithRetries/index.ts"),
				i = s("./src/lib/makeActionCreator/index.ts");
			let o;
			let c;
			const d = "CHAT__INITED",
				u = Object(i.a)(d),
				l = async (e, t, i) => c ? {
					chatStore: c,
					firstInit: !1
				} : (c = await (async (e, t, n) => {
					const r = Date.now(),
						i = await Object(a.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/chat/initializer.ts"))).then(e => e.default);
					return (await i(t(), r, n)).store
				})(0, t, i), Object(n.b)(c), await (async (e, t, n) => {
					if (!o) {
						const i = (await Object(a.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/reddit/actions/chat/proxy.ts"))).then(e => e.default))(t, n),
							c = Object(r.b)(e, i);
						o = e.subscribe(c)
					}
				})(c, e, t), e(u()), {
					chatStore: c,
					firstInit: !0
				})
		},
		"./src/reddit/actions/chat/subredditChannel.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "h", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "m", (function() {
				return g
			})), s.d(t, "l", (function() {
				return y
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "k", (function() {
				return I
			})), s.d(t, "j", (function() {
				return S
			})), s.d(t, "b", (function() {
				return w
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/endpoints/chat/index.ts"),
				a = s("./src/reddit/models/SubredditChannel/index.ts"),
				i = s("./src/reddit/selectors/chat.ts"),
				o = s("./src/reddit/selectors/user.ts");
			const c = "SUBREDDIT_CHANNELS__REQUESTED",
				d = "SUBREDDIT_CHANNELS__ADDED",
				u = "SUBREDDIT_CHANNELS__FAILED",
				l = "SUBREDDIT_CHANNEL__ADDED",
				b = "SUBREDDIT_CHANNEL__SELECTED",
				p = "SUBREDDIT_CHANNEL__EDITED",
				O = "SUBREDDIT_CHANNEL__REMOVED",
				g = Object(n.a)(b),
				f = Object(n.a)(c),
				m = Object(n.a)(u),
				j = Object(n.a)(d),
				_ = Object(n.a)(l),
				h = Object(n.a)("SUBREDDIT_CHANNEL__FAILED"),
				y = e => async (t, s, n) => {
					let {
						apiContext: o
					} = n;
					const {
						user: {
							account: c,
							session: d
						}
					} = s();
					if (!c || !d) return;
					t(f({
						subredditId: e
					}));
					const u = Object(i.e)(s(), {
							subredditId: e
						}),
						l = await Object(r.i)(o(), e, u);
					if (l.ok) {
						const {
							rooms: s,
							subreddit_chat_enabled: n,
							user_subreddit_chat_enabled: r
						} = l.body, i = Object(a.d)(s);
						t(j({
							collection: i,
							subredditId: e,
							isSubredditWhitelisted: !!n,
							isUserSubredditChatEnabled: !!r
						}))
					} else if (l.error) {
						const {
							error: s
						} = l;
						t(m({
							error: s,
							subredditId: e
						}))
					}
				}, E = (e, t) => async (s, n, i) => {
					let {
						apiContext: o
					} = i;
					const {
						user: {
							account: c,
							session: d
						}
					} = n();
					if (!c || !d) return;
					const u = await Object(r.d)(o(), d, t);
					if (u.ok) {
						const n = Object(a.e)(Object.assign(Object.assign({}, u.body), t));
						return await s(_({
							channel: n,
							subredditId: e
						})), n
					}
					s(h(u.error))
				}, I = (e, t) => async (s, n, a) => {
					let {
						apiContext: i
					} = a;
					const {
						channelSendbirdUrl: o
					} = e, {
						user: {
							session: c
						}
					} = n();
					if (!c) return;
					const d = await Object(r.f)(i(), o, c, t);
					d.ok ? s(v({
						channel: e,
						editedSubredditChannelData: t
					})) : s(h(d.error))
				}, v = Object(n.a)(p), S = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const {
						channelId: i,
						channelSendbirdUrl: c
					} = e, d = s();
					if (!Object(o.H)(d)) return;
					const u = await Object(r.e)(a(), c);
					u.ok ? t(T(i)) : t(h(u.error))
				}, T = Object(n.a)(O), w = "SUBREDDIT_CHANNELS__ENABLED";
			Object(n.a)(w)
		},
		"./src/reddit/actions/chat/subredditSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/endpoints/chat/index.ts"),
				a = s("./src/reddit/selectors/user.ts");
			const i = "CHAT_SUBREDDIT_SETTINGS__SET",
				o = Object(n.a)(i),
				c = Object(n.a)("CHAT_SUBREDDIT_SETTINGS__SET_FAILED"),
				d = async (e, t, s) => {
					try {
						if (s) return await e(o(Object.assign({
							subredditId: t
						}, s))), s
					} catch (n) {
						c(n)
					}
				}, u = e => async (t, s, n) => {
					let {
						apiContext: i
					} = n;
					try {
						const n = s();
						if (!Object(a.H)(n)) return;
						const o = await Object(r.g)(i(), e);
						return d(t, e, o)
					} catch (o) {
						c(o)
					}
				}, l = (e, t) => async (s, n, i) => {
					let {
						apiContext: o
					} = i;
					try {
						const i = n();
						if (!Object(a.H)(i)) return;
						const c = await Object(r.j)(o(), e, t);
						c.ok && d(s, e, c.body)
					} catch (u) {
						c(u)
					}
				}
		},
		"./src/reddit/actions/chat/toggle.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			})), s.d(t, "c", (function() {
				return g
			})), s.d(t, "f", (function() {
				return f
			})), s.d(t, "d", (function() {
				return m
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react-router-redux/es/index.js"),
				r = s("./src/lib/loadWithRetries/index.ts"),
				a = s("./src/chat/constants/container.ts"),
				i = s("./src/chat/customMiddleware/containerSize.ts"),
				o = s("./src/reddit/actions/chat/init.ts"),
				c = s("./src/reddit/helpers/trackers/authorHovercard.ts");
			const d = () => Object(r.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/chat/actions/meta.ts"))).then(e => e.setExternalData),
				u = () => Object(r.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/chat/actions/container.ts"))).then(e => e.sizeChanged);
			async function l(e, t, s, r) {
				const [{
					chatStore: i,
					firstInit: l
				}, b] = await Promise.all([Object(o.c)(e, t, s), u()]), p = t(), O = await d(), g = Object(c.h)(p, r);
				i.dispatch(O(g)), i.getState().container.size !== a.a.EMBED && i.dispatch(b(a.a.EMBED)), !l && i.dispatch(Object(n.c)(s))
			}
			const b = (e, t) => async (s, n) => {
				await l(s, n, e, t)
			}, p = () => async (e, t) => Promise.all([Object(o.c)(e, t), u()]).then(e => {
				let [{
					chatStore: t,
					firstInit: s
				}, n] = e;
				t.getState().container.size !== a.a.EMBED || s ? t.dispatch(n(a.a.EMBED)) : t.dispatch(n(a.a.HIDDEN))
			}), O = (e, t) => async (n, a) => {
				const i = (await (() => Object(r.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/chat/helpers/urls/index.ts"))).then(e => e.channelUserIdUrl))())(e);
				await l(n, a, i, t)
			}, g = e => {
				let {
					channelId: t,
					subredditName: n,
					channelUrl: a
				} = e;
				return async (e, i) => {
					if (!a && t) {
						const e = await (() => Object(r.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/chat/helpers/urls/index.ts"))).then(e => e.channelUrl))();
						a = e(t, n)
					}
					if (!a) throw new Error("Please specify channelUrl or channelId (subredditName is optional)");
					await l(e, i, a)
				}
			}, f = e => async (t, n) => {
				if (!o.b) return;
				const a = await (() => Object(r.a)(() => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~Chat~RedesignChat"), s.e("Chat~RedesignChat"), s.e("RedesignChat")]).then(s.bind(null, "./src/chat/actions/theme.ts"))).then(e => e.switchTheme))();
				o.b.dispatch(a(e))
			}, m = () => async (e, t) => {
				const s = t(),
					n = s.user.account && s.user.account.id || "unknown";
				Object(i.c)(n) && Object(o.c)(e, t)
			}
		},
		"./src/reddit/actions/chat/unreadCount.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return O
			})), s.d(t, "b", (function() {
				return m
			})), s.d(t, "d", (function() {
				return h
			}));
			var n, r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/chat/endpoints/sendbird/index.ts"),
				o = s("./src/reddit/actions/tabBadging.ts"),
				c = s("./src/reddit/selectors/chat.ts"),
				d = s("./src/reddit/selectors/user.ts");
			! function(e) {
				e.SYNC = "UNREAD_COUNT__SYNC", e.REQUEST_FAILED = "UNREAD_COUNT__REQUEST_FAILED", e.REQUEST_PENDING = "UNREAD_COUNT__REQUEST_PENDING", e.REQUEST_SUCCESS = "UNREAD_COUNT__REQUEST_SUCCESS"
			}(n || (n = {}));
			const {
				SYNC: u,
				REQUEST_FAILED: l,
				REQUEST_PENDING: b,
				REQUEST_SUCCESS: p
			} = n, O = Object(a.a)(u), g = Object(a.a)(l), f = Object(a.a)(b), m = Object(a.a)(p);
			let j;
			const _ = 5 * r.eb,
				h = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t();
					if (!Object(d.H)(r) || !Object(c.f)(r)) return clearTimeout(j);
					j || e((() => async (e, t, s) => {
						let {
							apiContext: n
						} = s;
						const r = t(),
							{
								session: a
							} = r.user;
						if (a && Object(d.H)(r) && Object(c.f)(r)) {
							e(f());
							const t = await Object(i.i)(n(), a);
							t && t.ok ? (e(m({
								basicChannelCount: t.body.unread_count || 0,
								subredditChannelCount: t.body.subreddit_unread_count || 0
							})), e(Object(o.c)())) : e(g({
								error: t.error
							}))
						}
					})()), j = setTimeout(() => {
						e(h())
					}, _)
				}
		},
		"./src/reddit/actions/chat/userSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			})), s.d(t, "b", (function() {
				return _
			})), s.d(t, "c", (function() {
				return E
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/config.ts"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts");
			var l = s("./src/reddit/helpers/trackers/chat.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				p = s("./src/telemetry/index.ts"),
				O = s("./src/reddit/actions/chat/constants.ts");
			const g = Object(r.a)("USER_SETTINGS__FETCH_PENDING"),
				f = Object(r.a)("USER_SETTINGS__FETCH_FAILURE"),
				m = "USER_SETTINGS__UPDATE_SUCCESS",
				j = Object(r.a)(m),
				_ = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					e(g());
					const r = await (e => Object(c.a)(Object(d.a)(e, [u.a]), {
						endpoint: "".concat(i.a.sendbirdServiceUrl, "/").concat("api/v1", "/chat/me/settings"),
						method: o.db.GET
					}))(n());
					if (r.ok) {
						const t = Object.assign({}, r.body);
						e(j({
							invitePolicy: O.a[t.invite_policy]
						}))
					} else e(f(r.error))
				}, h = Object(r.a)("USER_SETTINGS__SAVE_PENDING"), y = Object(r.a)("USER_SETTINGS__SAVE_FAILURE"), E = e => async (t, s, r) => {
					let {
						apiContext: g
					} = r;
					const f = s(),
						{
							invitePolicy: m
						} = e,
						_ = Object.keys(O.a).find(e => O.a[e] === m);
					if (_) {
						t(h());
						const e = await (async (e, t) => Object(c.a)(Object(d.a)(t, [u.a]), {
							endpoint: "".concat(i.a.sendbirdServiceUrl, "/").concat("api/v1", "/chat/me/settings"),
							method: o.db.PUT,
							data: JSON.stringify({
								invite_policy: e
							})
						}))(_, g());
						if (Object(p.a)(Object(l.f)(_)(f)), e.ok) {
							const e = O.a[_];
							t(j({
								invitePolicy: e
							})), t(Object(a.e)({
								kind: b.b.SuccessCommunity,
								text: n.fbt._("Changes saved", null, {
									hk: "4eTtdy"
								})
							}))
						} else t(y(e.error))
					}
				}
		},
		"./src/reddit/actions/claimgold.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "i", (function() {
				return _
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "j", (function() {
				return y
			})), s.d(t, "f", (function() {
				return E
			})), s.d(t, "b", (function() {
				return I
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "a", (function() {
				return S
			})), s.d(t, "h", (function() {
				return T
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/reddit/models/Toast/index.ts"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts"),
				l = s("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			var b = async (e, t) => {
				const {
					code: s
				} = t, n = {
					api_type: "json",
					code: s,
					raw_json: 1
				};
				return Object(c.a)(Object(d.a)(e, [u.a]), {
					method: o.db.POST,
					endpoint: "".concat(e.apiUrl, "/api/claimgold"),
					data: n
				}).then(e => e.ok ? Object.assign({}, e) : Object.assign(Object.assign({}, e), {
					error: Object(l.a)(e)
				}))
			}, p = s("./src/reddit/helpers/genericServerError/index.ts"), O = s("./src/reddit/selectors/claimgold.ts");
			const g = "CLAIMGOLD__OPEN_CLAIMGOLD_MODAL",
				f = "CLAIMGOLD__CLOSE_CLAIMGOLD_MODAL",
				m = Object(r.a)(g),
				j = Object(r.a)(f),
				_ = () => async (e, t) => {
					const s = t();
					Object(O.b)(s) ? e(j()) : e(m())
				}, h = "CLAIMGOLD_UPDATE_CODE", y = Object(r.a)(h), E = "CLAIM_GOLD__TRIGGER_LOADER", I = "CLAIM_GOLD__CLAIM_GOLD_PENDING", v = "CLAIM_GOLD__CLAIM_GOLD_SUCCESSFUL", S = "CLAIM_GOLD__CLAIM_GOLD_FAILED", T = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = {
						code: t().claimGold.code
					};
					e(A());
					try {
						const t = await b(n(), r);
						t.error ? e(P(t)) : e(k())
					} catch (a) {
						e(P(a))
					}
				}, w = Object(r.a)(E), C = Object(r.a)(I), A = () => async (e, t) => {
					e(C()), window.setTimeout(() => {
						t().claimGold.api.pending && e(w())
					}, 2e3)
				}, D = Object(r.a)(S), P = e => async (t, s) => {
					await t(D(Object.assign(Object.assign({}, e), {
						error: e.error || Object(p.a)()
					})));
					const n = s().claimGold.api.error;
					n && t(Object(a.e)({
						kind: i.b.Error,
						duration: a.a,
						text: n
					}))
				}, R = Object(r.a)(v), k = () => async (e, t) => {
					e(R()), e(Object(a.e)({
						kind: i.b.SuccessCommunity,
						text: n.fbt._("You have redeemed your gift code successfully", null, {
							hk: "18mkH2"
						})
					}))
				}
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "C", (function() {
				return le
			})), s.d(t, "ib", (function() {
				return pe
			})), s.d(t, "n", (function() {
				return Oe
			})), s.d(t, "R", (function() {
				return ge
			})), s.d(t, "gb", (function() {
				return fe
			})), s.d(t, "L", (function() {
				return _e
			})), s.d(t, "Q", (function() {
				return he
			})), s.d(t, "X", (function() {
				return ye
			})), s.d(t, "v", (function() {
				return Ee
			})), s.d(t, "u", (function() {
				return Ie
			})), s.d(t, "t", (function() {
				return ve
			})), s.d(t, "Z", (function() {
				return Ce
			})), s.d(t, "rb", (function() {
				return Ae
			})), s.d(t, "T", (function() {
				return De
			})), s.d(t, "i", (function() {
				return Pe
			})), s.d(t, "h", (function() {
				return Re
			})), s.d(t, "d", (function() {
				return ke
			})), s.d(t, "e", (function() {
				return xe
			})), s.d(t, "c", (function() {
				return Ne
			})), s.d(t, "b", (function() {
				return Le
			})), s.d(t, "j", (function() {
				return Ue
			})), s.d(t, "m", (function() {
				return Me
			})), s.d(t, "N", (function() {
				return Fe
			})), s.d(t, "M", (function() {
				return Ge
			})), s.d(t, "W", (function() {
				return Ke
			})), s.d(t, "nb", (function() {
				return We
			})), s.d(t, "K", (function() {
				return ze
			})), s.d(t, "H", (function() {
				return Je
			})), s.d(t, "cb", (function() {
				return Qe
			})), s.d(t, "pb", (function() {
				return Xe
			})), s.d(t, "S", (function() {
				return Ze
			})), s.d(t, "E", (function() {
				return $e
			})), s.d(t, "G", (function() {
				return et
			})), s.d(t, "F", (function() {
				return tt
			})), s.d(t, "D", (function() {
				return st
			})), s.d(t, "mb", (function() {
				return rt
			})), s.d(t, "kb", (function() {
				return at
			})), s.d(t, "qb", (function() {
				return ct
			})), s.d(t, "tb", (function() {
				return dt
			})), s.d(t, "lb", (function() {
				return lt
			})), s.d(t, "sb", (function() {
				return bt
			})), s.d(t, "jb", (function() {
				return pt
			})), s.d(t, "Y", (function() {
				return Ot
			})), s.d(t, "p", (function() {
				return gt
			})), s.d(t, "o", (function() {
				return ft
			})), s.d(t, "k", (function() {
				return mt
			})), s.d(t, "f", (function() {
				return jt
			})), s.d(t, "l", (function() {
				return _t
			})), s.d(t, "O", (function() {
				return yt
			})), s.d(t, "s", (function() {
				return vt
			})), s.d(t, "P", (function() {
				return St
			})), s.d(t, "ob", (function() {
				return Tt
			})), s.d(t, "ab", (function() {
				return wt
			})), s.d(t, "bb", (function() {
				return Ct
			})), s.d(t, "fb", (function() {
				return At
			})), s.d(t, "q", (function() {
				return Dt
			})), s.d(t, "I", (function() {
				return Rt
			})), s.d(t, "r", (function() {
				return kt
			})), s.d(t, "A", (function() {
				return xt
			})), s.d(t, "z", (function() {
				return Nt
			})), s.d(t, "B", (function() {
				return Lt
			})), s.d(t, "g", (function() {
				return Ut
			})), s.d(t, "V", (function() {
				return Ft
			})), s.d(t, "U", (function() {
				return Vt
			})), s.d(t, "eb", (function() {
				return Ht
			})), s.d(t, "x", (function() {
				return Kt
			})), s.d(t, "w", (function() {
				return Wt
			})), s.d(t, "y", (function() {
				return Yt
			})), s.d(t, "db", (function() {
				return Xt
			})), s.d(t, "hb", (function() {
				return Zt
			})), s.d(t, "a", (function() {
				return $t
			})), s.d(t, "J", (function() {
				return es
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./src/config.ts"),
				r = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./src/telemetry/index.ts"),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/makeCommentsPageKey/index.ts"),
				d = s("./src/lib/makeDraftKey/index.ts"),
				u = s("./src/reddit/actions/changeUsername.ts"),
				l = s("./src/reddit/actions/economics/helpers/async.ts"),
				b = s("./src/reddit/actions/login.ts"),
				p = s("./src/reddit/actions/modal.ts"),
				O = s("./src/reddit/actions/post.ts"),
				g = s("./src/reddit/actions/postCreation/editorContent.ts"),
				f = s("./src/reddit/actions/publicAccessNetwork/automute.ts"),
				m = s("./src/reddit/actions/shortcuts/utils.ts"),
				j = s("./src/reddit/actions/toaster.ts"),
				_ = s("./src/reddit/actions/vote.ts"),
				h = s("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				y = s("./src/reddit/constants/adEvents.ts"),
				E = s("./src/reddit/constants/modals.ts"),
				I = s("./src/lib/makeApiRequest/index.ts"),
				v = s("./src/lib/omitHeaders/index.ts"),
				S = s("./src/reddit/constants/headers.ts"),
				T = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				w = s("./src/reddit/models/Comment/addProfileImgParam.ts"),
				C = s("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				A = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const D = (e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
					endpoint: Object(T.a)("".concat(e.apiUrl, "/api/save")),
					method: i.db.POST,
					data: {
						id: t
					}
				}),
				P = (e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
					endpoint: Object(T.a)("".concat(e.apiUrl, "/api/unsave")),
					method: i.db.POST,
					data: {
						id: t
					}
				}),
				R = (e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
					endpoint: Object(T.a)("".concat(e.apiUrl, "/api/lock")),
					method: i.db.POST,
					data: {
						id: t
					}
				}),
				k = (e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
					endpoint: Object(T.a)("".concat(e.apiUrl, "/api/unlock")),
					method: i.db.POST,
					data: {
						id: t
					}
				}),
				x = (e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
					endpoint: "".concat(e.apiUrl, "/api/ignore_reports"),
					method: i.db.POST,
					data: {
						id: t
					}
				}),
				N = (e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
					endpoint: "".concat(e.apiUrl, "/api/unignore_reports"),
					method: i.db.POST,
					data: {
						id: t
					}
				});
			var L = s("./src/graphql/operations/CommentToxicity.json"),
				U = s("./src/lib/makeGqlRequest/index.ts"),
				M = s("./src/reddit/helpers/genericServerError/index.ts"),
				F = s("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				G = s("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				B = s("./src/reddit/models/PostCreationForm/index.ts");
			const q = (e, t, s, n) => {
					let r, a;
					if (n === B.h.MARKDOWN) r = s.text, a = null;
					else {
						r = null;
						let e = null;
						s.rteState && (e = h.a.toRichTextJSON(s.rteState).document), a = JSON.stringify({
							document: e
						})
					}
					return Object(U.a)(e, Object.assign(Object.assign({}, L), {
						variables: {
							subredditName: t,
							markdown: r,
							richText: a
						}
					})).then(e => !e.ok || e.body.data.isValidComment)
				},
				V = async (e, t, s, n, r) => {
					const a = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: t
					};
					if (r === B.h.MARKDOWN) a.text = s.text;
					else {
						a.text = null;
						let e = null;
						s.rteState && (e = h.a.toRichTextJSON(s.rteState).document), a.richtext_json = JSON.stringify({
							document: e
						})
					}
					return Object(I.a)(Object(v.a)(e, [S.a]), {
						method: i.db.POST,
						endpoint: Object(T.a)(Object(C.a)(Object(A.a)("".concat(e.apiUrl, "/api/comment.json")))),
						data: a
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? Object.assign(Object.assign({}, e), {
						ok: !1,
						error: Object(G.a)(e)
					}) : Object.assign(Object.assign({}, e), {
						body: {
							comment: Object(F.a)(e.body.json.data.things[0].data, n)
						}
					}) : Object.assign(Object.assign({}, e), {
						body: {
							comment: Object(F.a)(e.body, n)
						}
					}) : Object.assign(Object.assign({}, e), {
						error: e.error || Object(M.a)()
					}))
				};
			var H = s("./src/reddit/endpoints/post/index.tsx"),
				K = s("./src/reddit/endpoints/post/convert.ts"),
				W = s("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				Y = s("./src/reddit/featureFlags/index.ts"),
				z = s("./src/reddit/helpers/commentList/index.ts"),
				J = s("./src/reddit/helpers/dom/index.ts"),
				Q = s("./src/reddit/selectors/telemetry.ts");
			var X = s("./src/reddit/helpers/trackers/commentsPage.ts"),
				Z = s("./src/reddit/models/Comment/index.ts"),
				$ = s("./src/reddit/models/Post/index.ts"),
				ee = s("./src/reddit/models/PostDraft/index.ts"),
				te = s("./src/reddit/models/RichTextJson/index.ts"),
				se = s("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				ne = s("./src/reddit/models/Toast/index.ts"),
				re = s("./src/reddit/models/Vote/index.ts"),
				ae = s("./src/reddit/selectors/comments.ts"),
				ie = s("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				oe = s("./src/reddit/selectors/moderatingComments.ts"),
				ce = s("./src/reddit/selectors/platform.ts"),
				de = s("./src/reddit/selectors/posts.ts"),
				ue = s("./src/reddit/selectors/user.ts");
			const le = "COMMENT__STICKIED_COMMENT_SUCCESS",
				be = {},
				pe = Object(o.a)(le),
				Oe = "COMMENT__MUTATED",
				ge = Object(o.a)(Oe),
				fe = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					if (!Object(ue.H)(s())) return t(Object(b.i)()), void t(Object(p.k)({
						actionSource: p.a.Save,
						redirectUrl: Object(ae.m)(s(), {
							commentId: e
						})
					}));
					const i = s().comments.models[e];
					if (!i) return;
					const o = i.isSaved ? P : D;
					if (t(ge({
							[e]: {
								isSaved: !i.isSaved
							}
						})), (await o(a(), e)).ok) {
						const s = i.isSaved ? r.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : r.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							n = r.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						t(Object(j.e)({
							text: s,
							kind: ne.b.Undo,
							buttonText: n,
							buttonAction: fe(e)
						}))
					} else t(ge({
						[e]: {
							isSaved: i.isSaved
						}
					}))
				}, me = e => "viewing-comment-".concat(e), je = n.a.telemetry.commentConsumedThreshold, _e = e => async (t, s) => {
					const r = s();
					if (!Object(ae.n)(r, {
							commentId: e
						}) || Math.random() > n.a.telemetry.commentSampleRate) return;
					(e => {
						let {
							state: t,
							commentId: s
						} = e;
						Object(a.a)(Object.assign(Object.assign({
							source: "comment",
							action: "view",
							noun: "comment"
						}, Q.defaults(t)), {
							profile: Q.profile(t),
							post: Q.post(t, s),
							media: Q.media(t, s),
							subreddit: Q.subreddit(t),
							comment: Q.comment(t, s)
						}))
					})({
						state: r,
						commentId: e
					}), a.c.start(me(e));
					const i = setTimeout(() => (e => {
						let {
							state: t,
							commentId: s
						} = e;
						return Object(a.a)(Object.assign(Object.assign({
							source: "comment",
							action: "consume",
							noun: "comment"
						}, Q.defaults(t)), {
							profile: Q.profile(t),
							post: Q.post(t, s),
							media: Q.media(t, s),
							subreddit: Q.subreddit(t),
							comment: Q.comment(t, s)
						}))
					})({
						state: r,
						commentId: e
					}), je);
					be[e] = i
				}, he = (e, t) => async (s, n) => {
					const r = n(),
						i = me(e);
					if (Object(ae.n)(r, {
							commentId: e
						}) && a.c.has(i)) {
						const s = a.c.end(i);
						!t && s < je && (clearTimeout(be[e]), delete be[e])
					}
				}, ye = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					if (!Object(ue.H)(s())) return void t(Object(p.i)(E.a.LOGIN_MODAL_ID));
					const a = s().comments.models[e];
					if (!a) return;
					const i = a.isLocked ? k : R;
					t(ge({
						[e]: {
							isLocked: !a.isLocked
						}
					})), (await i(r(), e)).ok || t(ge({
						[e]: {
							isLocked: a.isLocked
						}
					}))
				}, Ee = "COMMENT__MORECOMMENTS_PENDING", Ie = "COMMENT__MORECOMMENTS_LOADED", ve = "COMMENT__MORECOMMENTS_FAILED", Se = Object(o.a)(Ee), Te = Object(o.a)(Ie), we = Object(o.a)(ve), Ce = (e, t) => async (s, r, a) => {
					let {
						apiContext: o
					} = a;
					const c = r(),
						d = c.moreComments.models[t],
						u = c.platform.currentPage,
						b = u && u.routeMatch,
						p = b && b.match,
						{
							partialPostId: O
						} = p ? p.params : null;
					if (!O) return;
					const g = Object($.m)(O);
					s(Se({
						moreCommentsId: d.id
					}));
					const f = await ((e, t, s, r) => {
						let a = Object(A.a)(Object(C.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/morecomments/").concat(t)));
						return r && (a = Object(w.a)(a)), Object(I.a)(e, {
							data: s,
							endpoint: a,
							method: i.db.POST,
							type: "json",
							traceRequestName: "more_comments"
						})
					})(o(), g, {
						token: d.token
					}, Object(ie.a)(c));
					if (f.ok) {
						const t = f.body,
							n = Object(z.a)(t, g, c);
						s(Te(Object.assign({
							key: e,
							moreCommentsItem: d,
							shouldCollapse: n
						}, t)));
						const r = c.posts.models[g];
						r && "subreddit" === r.belongsTo.type && t.comments && await s(Object(l.a)({
							commentIds: Object.keys(f.body.comments),
							postIds: [r.id],
							skip: ["communityDetails", "subscription"],
							subredditId: r.belongsTo.id
						}))
					} else s(we(Object.assign({
						moreCommentsItem: d
					}, f.error)))
				}, Ae = Object(_.b)(z.b, re.a.upvoted), De = Object(_.b)(z.b, re.a.downvoted), Pe = "COMMENT__FOCUSED_TOGGLED", Re = "COMMENT__FOCUSED_SET", ke = "COMMENT__COLLAPSED_TOGGLED", xe = "COMMENT__COLLAPSED_UNSET", Ne = "COMMENTS__HIDDEN_TOGGLED", Le = "COMMENTS__HIDDEN_SET", Ue = "COMMENT_FORM_FOCUS_CHANGED", Me = "COMMENT_MARKED_UNCOLLAPSED", Fe = Object(o.a)(Pe), Ge = Object(o.a)(Re), Be = Object(o.a)(ke), qe = Object(o.a)(xe), Ve = (Object(o.a)(Le), Object(o.a)(Ne), Object(o.a)(Ue)), He = Object(o.a)(Me), Ke = e => {
					let {
						hasFocus: t,
						draftKey: s
					} = e;
					return async (e, n) => {
						const r = n();
						if (!!r.comments.drafts[s])
							if (Object(ue.J)(r) && t) {
								const n = Ve({
									hasFocus: t,
									draftKey: s
								});
								e(Object(u.f)(n))
							} else e(Ve({
								hasFocus: t,
								draftKey: s
							}))
					}
				}, We = e => {
					let {
						commentId: t,
						commentsPageKey: s,
						scrollToAndRemeasure: n
					} = e;
					return async (e, r) => {
						const a = r(),
							i = Object(Z.f)(t),
							o = Object(ae.o)(a, {
								commentLink: i,
								commentsPageKey: s
							}),
							c = Object(oe.b)(a, {
								commentId: t,
								commentsPageKey: s
							}),
							d = o.depth;
						e(Be({
							commentId: t,
							commentsPageKey: s,
							isCollapsed: c
						})), c || 0 !== d || n(t, !0), Object(m.d)()
					}
				}, Ye = e => {
					let {
						commentId: t,
						commentsPageKey: s
					} = e;
					return async (e, n) => {
						e(qe({
							commentId: t,
							commentsPageKey: s
						}))
					}
				}, ze = e => {
					let {
						commentLink: t,
						commentsPageKey: s,
						lineDepth: n,
						scrollToAndRemeasure: r
					} = e;
					return async (e, a) => {
						const i = a(),
							o = Object(z.e)(s, t, n, i),
							c = Object(oe.b)(i, {
								commentId: t.id,
								commentsPageKey: s
							});
						e(Be({
							commentId: o,
							commentsPageKey: s,
							isCollapsed: c
						})), 0 === n && r(o, !0), Object(m.d)()
					}
				}, Je = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						o = a.comments.models[e],
						c = a.user.account ? a.user.account.displayText : null;
					o && c && (t(ge({
						[e]: {
							isApproved: !0,
							approvedBy: c,
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (await ((e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
						endpoint: Object(T.a)("".concat(e.apiUrl, "/api/approve")),
						method: i.db.POST,
						data: {
							id: t
						}
					}))(r(), e)).ok || t(ge({
						[e]: {
							isApproved: o.isApproved,
							approvedBy: null,
							bannedBy: o.bannedBy,
							isRemoved: o.isRemoved,
							isSpam: o.isSpam,
							modNote: o.modNote,
							modReasonBy: o.modReasonBy,
							modRemovalReason: o.modRemovalReason,
							numReports: o.numReports || null
						}
					})), Object(m.d)())
				}, Qe = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const o = n(),
						c = o.comments.models[e],
						d = o.user.account ? o.user.account.displayText : null;
					c && d && (s(ge({
						[e]: {
							approvedBy: null,
							bannedBy: d,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (await ((e, t, s) => Object(I.a)(Object(v.a)(e, [S.a]), {
						endpoint: Object(T.a)("".concat(e.apiUrl, "/api/remove")),
						method: i.db.POST,
						data: {
							id: t,
							spam: s
						}
					}))(a(), e, t)).ok || s(ge({
						[e]: {
							approvedBy: c.approvedBy,
							bannedBy: c.bannedBy,
							isApproved: c.isApproved,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam
						}
					})), Object(m.d)())
				}, Xe = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s().comments.models[e];
					if (!a) return;
					const i = a.ignoreReports ? N : x;
					t(ge({
						[e]: {
							ignoreReports: !a.ignoreReports
						}
					})), (await i(r(), e)).ok || t(ge({
						[e]: {
							ignoreReports: a.ignoreReports
						}
					}))
				}, Ze = (e, t, s) => async (n, r, a) => {
					let {
						apiContext: o
					} = a;
					const d = r(),
						u = d.comments.models[e];
					if (!u) return;
					const l = u.postId,
						b = d.postStickiedComments.data[l],
						p = i.g[t];
					n(ge({
						[e]: {
							distinguishType: t,
							isAdmin: t === i.C.ADMIN,
							isMod: t === i.C.MODERATOR,
							isStickied: !!s
						}
					})), s && b && b !== e && n(ge({
						[b]: {
							isStickied: !1
						}
					})), (await ((e, t, s, n) => Object(I.a)(Object(v.a)(e, [S.a]), {
						endpoint: Object(T.a)("".concat(e.apiUrl, "/api/distinguish/").concat(s)),
						method: i.db.POST,
						data: {
							id: t,
							sticky: n
						}
					}))(o(), e, p, s || null)).ok ? s && n(pe({
						id: e,
						postId: l,
						commentsPageKey: Object(c.a)(l, null, Object.assign({
							sort: i.r.CONFIDENCE
						}, d.platform.currentPage.queryParams))
					})) : (n(ge({
						[e]: {
							distinguishType: u.distinguishType,
							isAdmin: u.isAdmin,
							isMod: u.isMod,
							isStickied: u.isStickied
						}
					})), n(ge({
						[b]: {
							isStickied: d.comments.models[b].isStickied
						}
					})))
				}, $e = "COMMENT__SUBMIT_COMMENT_PENDING", et = "COMMENT__SUBMIT_REPLY_TO_POST_SUCCESS", tt = "COMMENT__SUBMIT_REPLY_TO_COMMENT_SUCCESS", st = "COMMENT__SUBMIT_COMMENT_FAILURE", nt = Object(o.a)($e), rt = Object(o.a)(et), at = Object(o.a)(tt), it = Object(o.a)(st), ot = (e, t, s, n) => {
					const r = n.ok && n.body,
						a = r && r.comment && r.comment.id;
					X.f(e, s, t, a)
				}, ct = "Toxicity_Warning__Modal", dt = (e, t, s, n, r, a) => async (i, o, c) => {
					let {
						gqlContext: d
					} = c;
					const u = o(),
						l = Object(ce.f)(u);
					let b = "";
					if (l && (b = l.name), Y.d.enableToxicityWarning(u)) {
						if (!(await q(d(), b, n, r))) return void i(Object(p.i)(ct))
					}
					i(lt(e, t, s, n, r, a))
				}, ut = e => e.rteState ? h.a.toRichTextJSON(e.rteState) : e.rtJson || e.text, lt = (e, t, s, n, a, o, c) => async (d, u, l) => {
					let {
						apiContext: b
					} = l;
					d(Object(p.g)(ct));
					const g = u(),
						_ = g.comments.submit.pending[s];
					if (!g.user.account || _) return;
					d(nt({
						draftKey: s,
						draft: n
					}));
					const h = g.user.account.displayText,
						E = n.commentMode;
					let I;
					if (c ? (I = await Object(W.j)(b(), e, n, h), d(Object(f.a)({
							streamId: e,
							level: I.body.automuteLevel
						}))) : I = await V(b(), e, n, h, E), I.ok) {
						let n;
						n = I.body, d(rt(Object.assign(Object.assign({}, n), {
							headCommentId: Object(ae.x)(g, {
								commentsPageKey: t
							}),
							commentsPageKey: t,
							draftKey: s
						})));
						const r = Object(de.N)(u(), {
							postId: e
						});
						d(Object(O.t)(r, y.a.CommentSubmitted))
					} else {
						I.error && I.error.type === i.zb && X.g(g, ut(n), e);
						const t = I.error && I.error.fields && I.error.fields[0] ? I.error.fields[0].msg : r.fbt._("Something went wrong", null, {
							hk: "LWFS0"
						});
						d(it({
							draftKey: s,
							error: I.error
						})), d(Object(j.e)({
							duration: j.a,
							kind: ne.b.Error,
							text: t
						}))
					}
					ot(u(), t, a, I), o || Object(m.d)()
				}, bt = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const {
						parentCommentId: a,
						commentsPageKey: i,
						parentCommentDepth: o,
						draftKey: c,
						formData: d,
						editorMode: u
					} = e, l = s(), b = Object(ce.f)(l);
					let O = "";
					if (b && (O = b.name), Y.d.enableToxicityWarning(l)) {
						if (!(await q(r(), O, d, u))) return void t(Object(p.i)(ct))
					}
					t(pt({
						commentsPageKey: i,
						draftKey: c,
						parentCommentDepth: o,
						parentCommentId: a,
						formData: d,
						editorMode: u
					}))
				}, pt = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const {
						parentCommentId: a,
						commentsPageKey: o,
						parentCommentDepth: c,
						draftKey: d,
						formData: u,
						editorMode: l
					} = e;
					t(Object(p.g)(ct));
					const b = s(),
						O = b.comments.submit.pending[d];
					if (!b.user.account || O) return;
					t(nt({
						draftKey: d,
						draft: u
					}));
					const g = b.user.account.displayText,
						f = u.commentMode,
						j = await V(r(), a, u, g, f);
					if (j.ok) t(at(Object.assign(Object.assign({}, j.body), {
						parentCommentId: a,
						commentsPageKey: o,
						draftKey: d,
						depth: c + 1
					})));
					else {
						if (j.error && j.error.type === i.zb) {
							const e = Object(ae.n)(b, {
								commentId: a
							});
							if (!e) return;
							X.g(b, ut(u), e.postId, a)
						}
						t(it({
							draftKey: d,
							error: j.error
						}))
					}
					ot(s(), o, l, j), Object(m.d)()
				}, Ot = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					s().comments.models[e] && (await ((e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
						endpoint: "".concat(e.apiUrl, "/api/show_comment"),
						method: i.db.POST,
						data: {
							id: t
						}
					}))(r(), e)).ok && t((e => async (t, s, n) => {
						let {
							apiContext: r
						} = n;
						t(He({
							commentId: e
						}))
					})(e))
				}, gt = "COMMENT__COMMENT_REPLY_FORM_OPENED", ft = "COMMENT__COMMENT_REPLY_FORM_CANCELLED", mt = "COMMENT__COMMENT_FORM_MUTATED", jt = "COMMENT__COMMENT_DRAFT_CLEARED", _t = "COMMENT__COMMENT_FORM_SWITCHED_MODE", ht = Object(o.a)(gt), yt = Object(o.a)(ft), Et = Object(o.a)(mt), It = (Object(o.a)(jt), Object(o.a)(_t)), vt = "INITIALIZE_COMMENT_EDITOR_MODE", St = (Object(o.a)(vt), (e, t, s) => async (n, a, i) => {
					let {
						apiContext: o
					} = i;
					const c = e === B.h.RICH_TEXT;
					if (!t || "object" == typeof t && Object(te.G)(t)) n(It({
						editorMode: e,
						draftKey: s,
						content: c ? te.i : ""
					})), n(Object(g.c)(e));
					else {
						n(Object(g.b)(s));
						const a = await Object(K.a)(o(), e, c ? t : JSON.stringify(t));
						if (a.ok) {
							const t = a.body.output;
							n(Object(g.a)(s)), n(It({
								editorMode: e,
								draftKey: s,
								content: t
							})), n(Object(g.c)(e))
						} else n(Object(g.a)(s)), n(Object(j.e)({
							duration: j.a,
							kind: ne.b.Error,
							text: r.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), Tt = e => {
					let {
						commentsPageKey: t,
						parentCommentId: s,
						singleOpen: n
					} = e;
					return async (e, r) => {
						const a = r(),
							i = Object(d.a)(ee.c.replyToComment, s);
						if (!Object(ue.H)(r())) return e(Object(b.i)()), void e(Object(p.k)({
							actionSource: p.a.Reply,
							redirectUrl: Object(ae.m)(r(), {
								commentId: s
							})
						}));
						const o = a.comments.replyFormOpen[t],
							c = o && o[s];
						if ((c || o && n) && (Object.keys(o).forEach(s => o[s] && e(yt({
								parentCommentId: s,
								commentsPageKey: t
							}))), c)) return;
						let l = "",
							O = null;
						const g = a.user.prefs.commentMode,
							f = Object(J.d)();
						if (f) {
							const e = f.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (g === B.h.MARKDOWN) l = e.map(e => "> ".concat(e, "\n")).join("");
							else {
								const t = e.map(e => se.s(e, null)).map(e => se.l([e])),
									s = se.s("", null),
									n = se.l([s]);
								O = {
									document: [se.c(t), n]
								}
							}
						}
						const m = a.comments.drafts[i];
						let j;
						if (j = f ? {
								commentMode: g,
								draftType: ee.c.replyToComment,
								rtJson: O,
								text: "".concat(l, "\n")
							} : m || {
								commentMode: g,
								draftType: ee.c.replyToComment,
								rtJson: O,
								text: ""
							}, Object(ue.J)(a)) {
							const n = ht({
								parentCommentId: s,
								commentsPageKey: t,
								draftKey: i,
								formData: j
							});
							e(Object(u.f)(n))
						} else e(ht({
							parentCommentId: s,
							commentsPageKey: t,
							draftKey: i,
							formData: j
						}))
					}
				}, wt = e => async (t, s) => {
					t(Ye(e)), t(Ft(e))
				}, Ct = e => {
					let {
						parentCommentId: t,
						commentsPageKey: s
					} = e;
					return async (e, n) => {
						e(yt({
							parentCommentId: t,
							commentsPageKey: s
						})), e(Tt({
							parentCommentId: t,
							commentsPageKey: s
						})), e(Ye({
							commentId: t,
							commentsPageKey: s
						}))
					}
				}, At = (e, t) => s => s(Et({
					draftKey: e,
					formData: t
				})), Dt = "COMMENT__DISABLE_AUTOFOCUS", Pt = Object(o.a)(Dt), Rt = e => t => t(Pt({
					draftKey: e
				})), kt = "COMMENT__EDIT_COMMENT_ENABLED", xt = "COMMENT__REQUEST_EDIT_PENDING", Nt = "COMMENT__REQUEST_EDIT_FAILURE", Lt = "COMMENT__REQUEST_EDIT_SUCCESS", Ut = "COMMENT__COMMENT_EDIT_FORM_CANCELLED", Mt = Object(o.a)(kt), Ft = e => {
					let {
						commentId: t,
						commentMode: s,
						commentsPageKey: n,
						draftKey: r,
						text: a
					} = e;
					return async (e, i) => {
						const o = i();
						o.user.account && (X.c(o), e(Mt({
							commentId: t,
							commentsPageKey: n,
							draftKey: r,
							formData: {
								text: a,
								commentMode: s,
								rteState: null,
								draftType: ee.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Gt = Object(o.a)(xt), Bt = Object(o.a)(Nt), qt = Object(o.a)(Lt), Vt = Object(o.a)(Ut), Ht = e => {
					let {
						id: t,
						commentsPageKey: s,
						depth: n,
						draftKey: r,
						formData: a
					} = e;
					return async (e, n, o) => {
						let {
							apiContext: c
						} = o;
						const d = n();
						if (!d.user.account) return;
						e(Gt({
							draftKey: r
						})), X.d(d);
						const u = d.user.account.displayText || "",
							l = a.commentMode,
							b = await (async (e, t, s, n, r, a) => {
								const o = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: t
								};
								if (a === B.h.MARKDOWN) o.text = n.text;
								else {
									o.text = null;
									let e = null;
									n.rteState && (e = h.a.toRichTextJSON(n.rteState).document), o.richtext_json = JSON.stringify({
										document: e
									})
								}
								return Object(I.a)(Object(v.a)(e, [S.a]), {
									endpoint: Object(T.a)(Object(A.a)(Object(C.a)("".concat(e.apiUrl, "/api/editusertext")))),
									method: i.db.POST,
									data: o
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? Object.assign(Object.assign({}, e), {
									ok: !1,
									error: Object(G.a)(e)
								}) : Object.assign(Object.assign({}, e), {
									body: {
										comment: Object(F.a)(e.body.json.data.things[0].data, r)
									}
								}) : Object.assign(Object.assign({}, e), {
									body: {
										comment: Object(F.a)(e.body, r)
									}
								}) : Object.assign(Object.assign({}, e), {
									error: e.error || Object(M.a)()
								}))
							})(c(), t, 0, a, u, l);
						if (b.ok) {
							const n = b.body;
							e(qt({
								commentId: t,
								commentsPageKey: s,
								draftKey: r
							})), e(ge({
								[t]: Object.assign({}, n.comment)
							}))
						} else e(Bt({
							draftKey: r,
							error: b.error
						}))
					}
				}, Kt = "COMMENT__REQUEST_DELETE_PENDING", Wt = "COMMENT__REQUEST_DELETE_FAILURE", Yt = "COMMENT__REQUEST_DELETE_SUCCESS", zt = Object(o.a)(Kt), Jt = Object(o.a)(Wt), Qt = Object(o.a)(Yt), Xt = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const o = n();
					s(zt({
						id: e
					})), X.a(e, o);
					const c = await ((e, t) => Object(I.a)(Object(v.a)(e, [S.a]), {
						endpoint: Object(T.a)("".concat(e.apiUrl, "/api/del")),
						method: i.db.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? Object.assign(Object.assign({}, e), {
						ok: !1,
						error: Object(G.a)(e)
					}) : Object.assign(Object.assign({}, e), {
						body: {}
					}) : Object.assign(Object.assign({}, e), {
						error: e.error || Object(M.a)()
					})))(a(), e);
					c.ok ? s(Qt({
						id: e,
						postId: t
					})) : s(Jt({
						id: e,
						error: c.error
					}))
				}, Zt = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = !s().comments.models[e].sendReplies;
					t(ge({
						[e]: {
							sendReplies: a
						}
					})), (await Object(H.q)(r(), e, a)).ok || t(ge({
						[e]: {
							sendReplies: !a
						}
					}))
				}, $t = "COMMENT__CHANGE_HIGHLIGHT_FILTER", es = Object(o.a)($t)
		},
		"./src/reddit/actions/comment/list.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "c", (function() {
				return d
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/helpers/trackers/commentList.ts");
			const a = "COMMENTLIST__MARKED_END",
				i = "COMMENTLIST__UNMARKED_END",
				o = Object(n.a)(a),
				c = Object(n.a)(i),
				d = (e, t) => async (s, n) => {
					const a = n();
					e in a.profileCommentsPage.fetchedTokens ? e in a.profileCommentsPage.commentIds ? s(c({
						listingKey: e
					})) : Object(r.a)(a, e) : s(o({
						listingKey: e,
						listingName: t
					}))
				}
		},
		"./src/reddit/actions/comment/websocket/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			}));
			const n = "COMMENT__LIVECOMMENTS__NEWCOMMENT",
				r = "COMMENT__LIVECOMMENTS__UPDATECOMMENT",
				a = "COMMENT__LIVECOMMENTS_DELETECOMMENT",
				i = "COMMENT__LIVECOMMENTS__USERJOIN"
		},
		"./src/reddit/actions/commentsListTruncated/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = "COMMENTS_LIST__EXPANDED",
				r = "COMMENTS_LIST__TRUNCATED"
		},
		"./src/reddit/actions/communityFlairs/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			}));
			const n = "TOP_COMMUNITY_FLAIR__FETCH_FAILURE",
				r = "TOP_COMMUNITY_FLAIR__FETCH_PENDING",
				a = "TOP_COMMUNITY_FLAIR__FETCH_SUCCESS",
				i = "COMMUNITY_FLAIR__ADD_FLAIRS"
		},
		"./src/reddit/actions/communityFlairs/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return y
			})), s.d(t, "e", (function() {
				return E
			})), s.d(t, "c", (function() {
				return I
			})), s.d(t, "b", (function() {
				return v
			})), s.d(t, "d", (function() {
				return S
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/camelCase.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/isEmpty.js"),
				i = s.n(a),
				o = s("./node_modules/lodash/omit.js"),
				c = s.n(o),
				d = s("./src/lib/makeActionCreator/index.ts"),
				u = s("./src/reddit/endpoints/flair/index.ts"),
				l = s("./src/reddit/helpers/flair.ts"),
				b = s("./src/reddit/models/Flair/index.ts"),
				p = s("./src/reddit/selectors/communityFlairs.ts"),
				O = s("./src/reddit/selectors/subreddit.ts"),
				g = s("./src/reddit/actions/communityFlairs/constants.ts");
			const f = Object(d.a)(g.c),
				m = Object(d.a)(g.d),
				j = Object(d.a)(g.b),
				_ = Object(d.a)(g.a),
				h = e => {
					const t = {};
					for (const s in e) {
						t[r()(s)] = e[s]
					}
					return t
				},
				y = (e, t) => async (s, n) => {
					const a = n(),
						o = Object(p.b)(a, t),
						d = Object(p.c)(a, t) || [],
						u = (e => {
							const t = {};
							return e.map(e => {
								const s = Object(l.g)(e),
									n = r()(s),
									a = n && t.hasOwnProperty(n);
								e.type !== b.f.Spoiler && e.type !== b.f.Nsfw && (a || (t[n] = Object.assign(Object.assign({}, e), {
									id: n
								})))
							}), t
						})(e),
						O = c()(u, d);
					if (i()(O)) return;
					const g = Object.keys(O),
						f = d ? d.concat(g) : g,
						m = o ? Object.assign(Object.assign({}, o), O) : O;
					s(_({
						models: m,
						sortedKeys: f,
						subredditId: t
					}))
				}, E = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = Object(O.G)(s(), e);
					t(f());
					const i = await Object(u.c)(r(), e);
					if (i.ok) {
						const e = i.body.map(h).map(e => Object(l.c)(e));
						t(y(e, a)), t(m())
					} else t(j())
				}, I = (e, t) => {
					const s = [];
					for (const n in e) {
						const r = e[n],
							a = r.belongsTo && r.belongsTo.id === t;
						r.flair && r.flair.length && a && s.push(...r.flair)
					}
					return s
				}, v = e => {
					const t = e && e.data && e.data.content && e.data.content.widgets;
					if (t) {
						const e = t.items;
						for (const t in e) {
							const s = e[t];
							if ("post-flair" === s.kind) return s
						}
					}
				}, S = e => {
					const t = [],
						{
							templates: s
						} = e;
					for (const n in s) {
						const e = s[n];
						e && t.push(e)
					}
					return t
				}
		},
		"./src/reddit/actions/contentGate.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "i", (function() {
				return O
			})), s.d(t, "j", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "c", (function() {
				return j
			})), s.d(t, "m", (function() {
				return h
			})), s.d(t, "n", (function() {
				return y
			})), s.d(t, "o", (function() {
				return E
			})), s.d(t, "q", (function() {
				return I
			})), s.d(t, "r", (function() {
				return v
			})), s.d(t, "t", (function() {
				return S
			})), s.d(t, "p", (function() {
				return T
			})), s.d(t, "u", (function() {
				return w
			})), s.d(t, "s", (function() {
				return C
			})), s.d(t, "k", (function() {
				return A
			})), s.d(t, "l", (function() {
				return D
			}));
			var n = s("./node_modules/@reddit/onetrust-integration/dist/esm/index.js"),
				r = s("./src/config.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/constants/cookie.ts"),
				o = s("./src/reddit/endpoints/user/preferences.ts"),
				c = s("./src/reddit/selectors/user.ts");
			const d = "CONTENTGATE__VISITED_GOLD_SUBREDDIT",
				u = "CONTENTGATE__VISITED_PRIVATE_SUBREDDIT",
				l = "CONTENTGATE__VISITED_QUARANTINED_SUBREDDIT",
				b = "CONTENTGATE__SET_OVER_18_PREF",
				p = "CONTENTGATE__VISITED_BANNED_SUBREDDIT",
				O = "CONTENTGATE__VISITED_SUBREDDIT_BLOCKED_FOR_LEGAL_REASON",
				g = "CONTENTGATE__VISITED_NONEXISTENT_SUBREDDIT",
				f = "CONTENTGATE__VISITED_DELETED_PROFILE",
				m = "CONTENTGATE__VISITED_SUSPENDED_PROFILE",
				j = "CONTENTGATE__VISITED_PROFILE_BLOCKED_FOR_LEGAL_REASON",
				_ = Object(a.a)(b),
				h = Object(a.a)(p),
				y = Object(a.a)(O),
				E = Object(a.a)(g),
				I = Object(a.a)(d),
				v = Object(a.a)(u),
				S = Object(a.a)(l),
				T = Object(a.a)(f),
				w = Object(a.a)(m),
				C = Object(a.a)(j),
				A = () => {
					const e = new Date;
					e.setFullYear(e.getFullYear() + 2), Object(n.b)(i.f, "1", {
						expires: e,
						domain: r.a.cookieDomain
					})
				},
				D = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t();
					Object(c.H)(r) && r.platform.currentPage && await Object(o.f)(n()), e(_({
						over18: !0
					}))
				}
		},
		"./src/reddit/actions/dashboard.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "DASHBOARD__COMPONENT_SELECTED",
				a = "DASHBOARD__SUBREDDIT_SELECTED",
				i = "DASHBOARD__SUBREDDIT_LOADED",
				o = Object(n.a)(r),
				c = Object(n.a)(a),
				d = Object(n.a)(i)
		},
		"./src/reddit/actions/discoveryUnit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "e", (function() {
				return y
			})), s.d(t, "d", (function() {
				return E
			})), s.d(t, "h", (function() {
				return T
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/makeListingKey/index.ts"),
				i = (s("./src/lib/addQueryParams/index.ts"), s("./src/lib/makeApiRequest/index.ts")),
				o = s("./src/lib/omitHeaders/index.ts"),
				c = (s("./src/lib/stringInterpolate/index.ts"), s("./src/reddit/constants/headers.ts")),
				d = s("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				u = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var l = s("./src/reddit/selectors/discoveryUnit.ts"),
				b = s("./src/reddit/selectors/listings.ts");
			const p = "DISCOVERY_UNIT__LIST_PENDING",
				O = "DISCOVERY_UNIT__LIST_LOADED",
				g = "DISCOVERY_UNIT__LIST_FAILED",
				f = Object(r.a)(p),
				m = Object(r.a)(O),
				j = Object(r.a)(g),
				_ = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t(),
						a = Object(l.e)(r),
						i = Object(l.d)(r);
					if (a || i) return;
					e(f());
					const o = await (e => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_88",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Similar communities to %{subredditName}",
										unit_name: "chaining_similar_subreddits_posts",
										unit_type: "listing"
									}, {
										id: "xd_89",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Mildy similar posts",
										unit_name: "chaining_similar_posts",
										unit_type: "listing"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(n());
					if (o.ok) {
						const {
							discoveryUnits: t
						} = (e => {
							return {
								discoveryUnits: e.global.discovery_config_v1.discovery_units.reduce((e, t) => {
									const s = {
										enabled: t.enabled,
										experiment: t.experiment,
										id: t.id,
										index: t.index,
										layout: t.layout,
										options: t.options,
										parameters: t.parameters,
										subtitle: t.subtitle,
										subtitleIcon: t.subtitle_icon,
										surface: t.surface,
										title: t.title,
										unitName: t.unit_name,
										unitType: t.unit_type,
										url: t.url
									};
									return e[s.id] = s, e
								}, {})
							}
						})(o.body);
						e(m({
							discoveryUnits: t
						}))
					} else e(j({
						error: o.error
					}))
				}, h = "DISCOVERY_UNIT__UNIT_DATA_PENDING", y = "DISCOVERY_UNIT__UNIT_DATA_LOADED", E = "DISCOVERY_UNIT__UNIT_DATA_FAILED", I = Object(r.a)(h), v = Object(r.a)(y), S = Object(r.a)(E), T = (e, t) => async (s, r, l) => {
					let {
						apiContext: p
					} = l;
					const O = r(),
						g = Object(a.a)(e, n.O.HOT, {
							category: t
						}),
						f = Object(b.h)(O, {
							listingKey: g
						}),
						m = !!O.listings.listingOrder.fetchedTokens[g];
					if (f || m) return;
					s(I({
						key: g
					}));
					const j = await ((e, t) => Object(i.a)(Object(o.a)(e, [c.a]), {
						endpoint: Object(u.a)("".concat(e.apiUrl, "/api/posts_in_category.json?category=").concat(t)),
						method: n.db.GET
					}))(p(), t);
					if (j.ok) {
						const {
							postIds: e,
							posts: t
						} = (e => {
							const t = [],
								s = {};
							return e.data.children.forEach(e => {
								const n = Object(d.a)(e.data);
								t.push(n.id), s[n.id] = n
							}), {
								postIds: t,
								posts: s
							}
						})(j.body), n = e.length > 0 ? e.length - 1 : 0;
						s(v({
							key: g,
							meta: O.meta,
							postIds: e,
							posts: t,
							token: e[n]
						}))
					} else s(S({
						key: g,
						error: j.error
					}))
				}
		},
		"./src/reddit/actions/dismissedTruncationList/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "DISMISSED_TRUNCATION_LIST__ADD_SUBREDDIT_ID"
		},
		"./src/reddit/actions/downToChat.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return y
			})), s.d(t, "g", (function() {
				return E
			})), s.d(t, "e", (function() {
				return I
			})), s.d(t, "b", (function() {
				return v
			})), s.d(t, "c", (function() {
				return S
			})), s.d(t, "a", (function() {
				return T
			})), s.d(t, "d", (function() {
				return w
			})), s.d(t, "j", (function() {
				return x
			})), s.d(t, "h", (function() {
				return N
			})), s.d(t, "i", (function() {
				return L
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/chat/toggle.ts"),
				a = s("./src/reddit/actions/modal.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				o = s("./src/reddit/constants/modals.ts"),
				c = s("./src/config.ts"),
				d = s("./src/lib/constants/index.ts"),
				u = s("./src/lib/makeApiRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				b = s("./src/reddit/constants/headers.ts");
			const p = "".concat("api/v1", "/sendbird");
			var O = s("./src/reddit/helpers/parseUrl.ts"),
				g = s("./src/reddit/selectors/telemetry.ts"),
				f = s("./src/telemetry/models/Event.ts");
			var m = s("./src/reddit/models/Toast/index.ts"),
				j = s("./src/reddit/selectors/downToChat.ts"),
				_ = s("./src/telemetry/index.ts");
			const {
				fbt: h
			} = s("./node_modules/fbt/lib/FbtPublic.js"), y = "FETCH_DOWN_TO_CHAT_AVAILABILITY__PENDING", E = "FETCH_DOWN_TO_CHAT_AVAILABILITY__SUCCESS", I = "FETCH_DOWN_TO_CHAT_AVAILABILITY__FAILED", v = "DISMISS_DOWN_TO_CHAT_BANNER__PENDING", S = "DISMISS_DOWN_TO_CHAT_BANNER__SUCCESS", T = "DISMISS_DOWN_TO_CHAT_BANNER__FAILED", w = "DISMISS_EACH_SUBREDDIT_BANNER", C = Object(n.a)(y), A = Object(n.a)(E), D = Object(n.a)(I), P = Object(n.a)(v), R = Object(n.a)(S), k = (Object(n.a)(T), Object(n.a)(w)), x = e => async (t, s, n) => {
				let {
					apiContext: r
				} = n;
				const a = s();
				if (Object(j.a)(a, e)) return;
				t(C({
					subredditId: e
				}));
				const i = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(c.a.sendbirdServiceUrl, "/").concat(p, "/down_to_chat/availability"),
					method: d.db.GET,
					type: "json",
					data: {
						subreddit_id: t
					}
				}))(r(), e);
				if (i.ok && i.body) {
					const {
						feature_enabled: s,
						experiment_enabled: n
					} = i.body;
					if (t(A({
							subredditId: e,
							bannerEnabled: s,
							buttonEnabled: n
						})), s) {
						const e = (e => Object.assign({
							source: f.b.Chat,
							action: f.a.View,
							noun: "down_to_chat_subreddit_entry",
							subreddit: Object(g.subreddit)(e)
						}, Object(g.defaults)(e)))(a);
						Object(_.a)(e)
					}
				} else t(D({
					subredditId: e,
					error: "Failed to fetch subreddit's down to chat availability data"
				}))
			}, N = e => async (t, s, n) => {
				let {
					apiContext: r
				} = n;
				t(P({
					subredditId: e
				}));
				const a = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(c.a.sendbirdServiceUrl, "/").concat(p, "/down_to_chat/availability"),
					method: d.db.DELETE,
					data: {
						subreddit_id: t
					}
				}))(r(), e);
				if (a.ok && a.body) {
					const {
						feature_enabled: s,
						experiment_enabled: n
					} = a.body;
					t(R({
						subredditId: e,
						bannerEnabled: s,
						buttonEnabled: n
					})), s || t(k())
				}
				const i = (e => Object.assign({
					source: f.b.Chat,
					action: f.a.Dismiss,
					noun: "down_to_chat_subreddit_entry",
					subreddit: Object(g.subreddit)(e)
				}, Object(g.defaults)(e)))(s());
				Object(_.a)(i)
			}, L = e => async (t, s, n) => {
				let {
					apiContext: j
				} = n;
				const y = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(c.a.sendbirdServiceUrl, "/").concat(p, "/down_to_chat/join"),
					method: d.db.POST,
					type: "json",
					data: {
						subreddit_id: t
					}
				}))(j(), e);
				if (y.ok && y.body) {
					t(Object(a.i)(o.a.DOWN_TO_CHAT_PENDING_MODAL));
					const {
						deeplink_url: e
					} = y.body, s = Object(O.a)(e);
					s && s.pathname && t(Object(r.c)({
						channelUrl: s.pathname
					}))
				} else t(Object(i.e)({
					kind: m.b.Error,
					duration: i.a,
					text: h._("Failed to join a subreddit channel", null, {
						hk: "mZam3"
					})
				}));
				setTimeout(() => t(Object(a.f)()), 1e3);
				const E = (e => Object.assign({
					source: f.b.Chat,
					action: f.a.Click,
					noun: "down_to_chat_subreddit_entry",
					subreddit: Object(g.subreddit)(e)
				}, Object(g.defaults)(e)))(s());
				Object(_.a)(E)
			}
		},
		"./src/reddit/actions/economics/banners/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "d", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			const n = "ECONOMICS__BANNERS__DISMISSED_BANNERS_PENDING",
				r = "ECONOMICS__BANNERS__DISMISSED_BANNERS_UPDATED",
				a = "ECONOMICS__BANNERS__BANNER_DISMISSED",
				i = "ECONOMICS__BANNERS__BANNER_UNDISMISSED"
		},
		"./src/reddit/actions/economics/claims/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = "ECONOMICS__CLAIMS__CLAIM_PENDING",
				r = "ECONOMICS__CLAIMS__CLAIM_COMPLETED"
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = e => async t => {
				const n = await (() => Promise.all([s.e("vendors~EconHelperActions~SubredditPremiumBadgeManagement"), s.e("EconHelperActions")]).then(s.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(n(e))
			}
		},
		"./src/reddit/actions/economics/me/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			}));
			const n = "ECONOMICS__ME__ME_DATA_SUCCESS",
				r = "ECONOMICS__ME__POINTS_COPY_REQUESTED",
				a = "ECONOMICS__ME__POINTS_COPY_SUCCESS"
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "e", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			}));
			const n = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				r = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				a = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "k", (function() {
				return p
			}));
			const n = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				r = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__ORDER_SUCCESS",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__PURCHASE_MODAL_OPENED",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				b = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS",
				p = "ECONOMICS__SUBREDDIT_PREMIUM__UPLOAD_MODAL_OPENED"
		},
		"./src/reddit/actions/emailVerificationTooltip.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "EMAIL_VERIFICATION_TOOLTIP_TOGGLED",
				a = Object(n.a)(r)
		},
		"./src/reddit/actions/embedAndImage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "EMBEDS__UNLOADABLE",
				a = "EMBEDS__LOADABLE",
				i = Object(n.a)(r),
				o = Object(n.a)(a)
		},
		"./src/reddit/actions/emoji.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return I
			})), s.d(t, "d", (function() {
				return S
			})), s.d(t, "c", (function() {
				return T
			})), s.d(t, "h", (function() {
				return A
			})), s.d(t, "g", (function() {
				return D
			})), s.d(t, "f", (function() {
				return P
			})), s.d(t, "a", (function() {
				return N
			})), s.d(t, "q", (function() {
				return M
			})), s.d(t, "p", (function() {
				return G
			})), s.d(t, "l", (function() {
				return B
			})), s.d(t, "m", (function() {
				return q
			})), s.d(t, "j", (function() {
				return V
			})), s.d(t, "k", (function() {
				return H
			})), s.d(t, "b", (function() {
				return K
			})), s.d(t, "n", (function() {
				return Y
			})), s.d(t, "e", (function() {
				return z
			})), s.d(t, "o", (function() {
				return Q
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/forEach.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeApiRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/lib/uploadToS3/index.ts"),
				u = s("./src/reddit/constants/headers.ts");
			const l = async (e, t) => Object(o.a)(Object(c.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emojis/all"),
				method: i.db.GET,
				type: "json"
			}).then(e => (e.ok && (e.body = (e => {
				let t;
				const s = a()(e, (e, s) => ("snoomojis" !== s && (t = s), a()(e, (t, s) => {
					e[s] = {
						name: s,
						userFlairAllowed: t.user_flair_allowed,
						postFlairAllowed: t.post_flair_allowed,
						modFlairOnly: t.mod_flair_only,
						url: t.url
					}
				})));
				return {
					[t]: {
						emojis: s[t],
						snoomojis: s.snoomojis
					}
				}
			})(e.body)), e));
			var b = s("./src/lib/makeActionCreator/index.ts"),
				p = s("./src/reddit/actions/imageUploads.ts"),
				O = s("./src/reddit/actions/toaster.ts"),
				g = s("./src/reddit/helpers/getGenericUploadError.ts"),
				f = s("./src/reddit/helpers/getS3KeyFromUrl/index.ts"),
				m = s("./src/reddit/helpers/media/index.ts"),
				j = s("./src/reddit/models/Emoji/index.ts"),
				_ = s("./src/reddit/models/Image/index.tsx"),
				h = s("./src/reddit/models/Toast/index.ts"),
				y = s("./src/reddit/selectors/emojis.ts"),
				E = s("./src/reddit/selectors/subreddit.ts");
			const I = "STRUCTURED_STYLES__NEW_EMOJI_ADDED",
				v = Object(b.a)(I),
				S = "STRUCTURED_STYLES__EMOJI_DELETE_LOADED",
				T = "STRUCTURED_STYLES__EMOJI_DELETE_FAILED",
				w = Object(b.a)(S),
				C = Object(b.a)(T),
				A = "GET_ALL_EMOJIS_PENDING",
				D = "GET_ALL_EMOJIS_LOADED",
				P = "GET_ALL_EMOJIS_FAILED",
				R = Object(b.a)(A),
				k = Object(b.a)(D),
				x = Object(b.a)(P),
				N = "STRUCTURED_STYLES__EMOJIS_ENABLED_SETTING_LOADED",
				L = Object(b.a)(N),
				U = e => ({
					text: n.fbt._("Failed to save emoji", null, {
						hk: "3i6FC2"
					}),
					buttonText: n.fbt._("Retry", null, {
						hk: "1XMjgA"
					}),
					buttonAction: G(e)
				}),
				M = e => {
					let {
						imageData: t,
						subredditId: s
					} = e;
					return async (e, n, r) => {
						const a = n(),
							l = Object(E.S)(a, {
								subredditId: s
							}).name;
						e(Object(p.k)(t));
						const b = t.file,
							O = await Object(m.g)(b),
							g = await (async (e, t, s, n) => Object(o.a)(Object(c.a)(e, [u.a]), {
								endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji_asset_upload_s3.json"),
								method: i.db.POST,
								data: {
									filepath: s,
									mimetype: n
								}
							}))(r.apiContext(), l, b.name, O);
						let f = !1;
						if (g.ok) {
							const s = await (async (e, t, s) => Object(d.a)(s, t))(r.apiContext(), g.body.s3UploadLease, b);
							if (s.ok) {
								if (!n().imageUploads[t.id]) return Object(_.d)(t), !1;
								const r = decodeURIComponent(s.body.PostResponse.Location),
									a = g.body.websocketUrl,
									i = Object(_.n)(t, r, a);
								e(Object(p.j)(i)), f = !0
							} else {
								const n = Object(_.k)(t, s.error);
								e(Object(p.i)(n))
							}
						} else {
							const s = Object(_.k)(t, g.error);
							e(Object(p.i)(s))
						}
						return f
					}
				},
				F = (e, t) => async (s, n, r) => {
					const {
						imageData: a,
						subredditId: d,
						emojiName: l,
						settings: b
					} = e, g = Object(f.a)(a.url), m = n(), j = Object(E.S)(m, {
						subredditId: d
					}).name, h = await (async (e, t, s, n, r) => Object(o.a)(Object(c.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji.json"),
						method: i.db.POST,
						data: {
							s3_key: s,
							name: n,
							mod_flair_only: r.modFlairOnly,
							post_flair_allowed: r.postFlairAllowed,
							user_flair_allowed: r.userFlairAllowed
						}
					}))(r.apiContext(), j, g, l, b);
					if (!h.ok) {
						const n = Object(_.k)(a, h.error);
						s(Object(p.i)(n)), s(Object(O.e)(U(e))), t && t.close()
					}
					return h.ok
				}, G = e => async (t, s, n) => {
					const {
						imageData: r,
						subredditId: a,
						emojiName: i,
						settings: o
					} = e;
					if (t(Object(p.k)(r)), !r.websocketUrl) return t(Object(O.e)({
						text: "Could not upload emoji"
					}));
					let c;
					const d = new WebSocket(r.websocketUrl);
					return d.onopen = async () => {
						c = await F(e, d)(t, s, n)
					}, d.onmessage = s => {
						const n = JSON.parse(s.data);
						if ("success" === n.type) {
							c = !0;
							const e = n.payload.emoji_url,
								s = Object(_.o)(r, e);
							t(Object(p.l)(s));
							const d = Object(j.e)(i, s.url, a, o);
							t(v(d)), t(B(a))
						} else {
							const s = Object(g.a)(i),
								n = Object(_.k)(r, s);
							t(Object(p.i)(n)), t(Object(O.e)(U(e)))
						}
						d.close()
					}, d.onerror = s => {
						c = !1;
						const n = Object(g.a)(i),
							a = Object(_.k)(r, n);
						t(Object(p.i)(a)), t(Object(O.e)(U(e))), d.close()
					}, c
				}, B = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s();
					if (Object(y.a)(a, e)) return;
					const i = Object(E.S)(a, {
						subredditId: e
					}).name;
					t(R(e));
					const o = await l(r(), i);
					if (o.ok) {
						const s = o.body;
						t(k({
							subredditId: e,
							data: s
						}))
					} else t(x({
						subredditId: e,
						error: o.error
					}))
				}, q = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					s().emojis[e] || await t(B(e))
				}, V = (e, t) => async (s, r, a) => {
					let {
						apiContext: d
					} = a;
					const l = r(),
						b = Object(E.S)(l, {
							subredditId: t
						}).name,
						p = await (async (e, t, s) => Object(o.a)(Object(c.a)(e, [u.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(s, "/emoji/").concat(t),
							method: i.db.DELETE,
							type: "json"
						}))(d(), e, b);
					if (p.ok) {
						s(w({
							emojiName: e,
							subredditId: t
						})), s(O.e({
							kind: h.b.SuccessCommunityGreen,
							text: n.fbt._("Emoji successfully deleted", null, {
								hk: "1zMXEe"
							})
						}))
					} else s(C(p.error)), s(O.e({
						kind: h.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, H = (e, t) => async (s, r, a) => {
					let {
						apiContext: d
					} = a;
					const l = r(),
						b = Object(E.S)(l, {
							subredditId: e
						}).name;
					if ((await (async (e, t, s) => Object(o.a)(Object(c.a)(e, [u.a]), {
							endpoint: "".concat(e.apiUrl, "/api/enable_emojis_in_sr.json"),
							method: i.db.POST,
							data: {
								subreddit: t,
								enable: s
							}
						}))(d(), b, t)).ok) {
						s(L({
							subredditId: e,
							emojisEnabled: t
						}))
					} else s(O.e({
						kind: h.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, K = "EMOJI_CUSTOM_SIZE_UPDATED", W = Object(b.a)(K), Y = (e, t) => async (s, r, a) => {
					let {
						apiContext: d
					} = a;
					const l = r(),
						b = Object(E.S)(l, {
							subredditId: e
						}).name;
					(await (async (e, t, s) => Object(o.a)(Object(c.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/emoji_custom_size"),
						method: i.db.POST,
						data: s
					}))(d(), b, t)).ok ? s(W({
						subredditId: e,
						emojiCustomSize: t
					})) : s(O.e({
						kind: h.b.Error,
						text: n.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}, z = "EMOJI_PERMISSIONS_UPDATED", J = Object(b.a)(z), Q = (e, t, s, r) => async (a, d, l) => {
					let {
						apiContext: b
					} = l;
					const p = d(),
						g = Object(E.S)(p, {
							subredditId: r
						}).name;
					(await (async (e, t, s, n) => Object(o.a)(Object(c.a)(e, [u.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(s, "/emoji_permissions.json"),
						method: i.db.POST,
						data: {
							name: t,
							post_flair_allowed: n.postFlairAllowed,
							user_flair_allowed: n.userFlairAllowed,
							mod_flair_only: n.modFlairOnly
						}
					}))(b(), e, g, s)).ok ? (a(J({
						emojiName: e,
						isSnoomoji: t,
						settings: s,
						subredditId: r
					})), a(O.e({
						kind: h.b.SuccessCommunityGreen,
						text: n.fbt._("Emoji permissions updated", null, {
							hk: "4b2RIU"
						})
					}))) : a(O.e({
						kind: h.b.Error,
						text: n.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}
		},
		"./src/reddit/actions/eventPosts/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "e", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			}));
			const n = "MOD_PAGE_EVENT_POSTS_LOADED",
				r = "MOD_PAGE_EVENT_POSTS_FAILED",
				a = "MOD_PAGE_EVENT_POSTS_PENDING",
				i = "MOD_PAGE_EVENT_POSTS_MORE_LOADED",
				o = "START_EVENT_NOW_SUCCESS",
				c = "EDIT_EVENT_TIME_SUCCESS"
		},
		"./src/reddit/actions/experiments.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./src/lib/makeActionCreator/index.ts");
			s("./src/reddit/endpoints/user/index.ts"), s("./src/reddit/models/Post/index.ts"), s("./src/reddit/selectors/telemetry.ts");
			const r = "EXPERIMENTS__REQUEST_LOADED",
				a = (Object(n.a)("EXPERIMENTS__REQUEST_PENDING"), Object(n.a)("EXPERIMENTS__REQUEST_FAILED"), Object(n.a)(r), "EXPERIMENTS__SET_EXPERIMENT_OVERRIDE"),
				i = Object(n.a)(a)
		},
		"./src/reddit/actions/exportImportStyles.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "a", (function() {
				return p
			})), s.d(t, "d", (function() {
				return h
			})), s.d(t, "e", (function() {
				return y
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/loadWithRetries/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/structuredStyles/index.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/reddit/models/StructuredStyles/index.ts"),
				d = s("./src/reddit/models/Toast/index.ts"),
				u = s("./src/reddit/selectors/subreddit.ts");
			const l = "STRUCTURED_STYLES__EXPORT_THEME_PENDING",
				b = "STRUCTURED_STYLES__EXPORT_THEME_LOADED",
				p = "STRUCTURED_STYLES__EXPORT_THEME_FAILED",
				O = Object(a.a)(l),
				g = Object(a.a)(b),
				f = Object(a.a)(p),
				m = Object(a.a)("STRUCTURED_STYLES__IMPORT_THEME_PENDING"),
				j = Object(a.a)("STRUCTURED_STYLES__IMPORT_THEME_LOADED"),
				_ = Object(a.a)("STRUCTURED_STYLES__IMPORT_THEME_FAILED"),
				h = e => async (t, a) => {
					t(O());
					const i = a(),
						c = Object(u.S)(i, {
							subredditId: e
						}).name,
						l = i.structuredStyles.models[e],
						b = await Object(r.a)(() => Promise.all([s.e("vendors~ExportTheme~ImportTheme"), s.e("ExportTheme")]).then(s.bind(null, "./src/reddit/helpers/exportTheme/index.ts"))).then(e => e.default),
						p = await b(l, c);
					p.ok ? (t(g()), t(Object(o.e)({
						kind: d.b.SuccessMod,
						text: n.fbt._("Theme successfully exported", null, {
							hk: "24KHqI"
						})
					}))) : (t(f(p.error)), t(Object(o.e)({
						kind: d.b.Error,
						text: n.fbt._("Sorry, theme failed to export", null, {
							hk: "2MC4jC"
						})
					})))
				}, y = e => async (t, a) => {
					t(m());
					const u = await Object(r.a)(() => Promise.all([s.e("vendors~ExportTheme~ImportTheme"), s.e("ImportTheme")]).then(s.bind(null, "./src/reddit/helpers/importTheme/index.ts"))).then(e => e.default),
						l = await u(e);
					l.ok ? (t(j()), t(Object(o.e)({
						kind: d.b.SuccessMod,
						text: n.fbt._("Theme successfully imported", null, {
							hk: "42FErS"
						})
					})), 0 !== Object.keys(l.attributes).length && t(Object(i.d)(Object(c.j)(l.attributes)))) : (t(_(l.error)), t(Object(o.e)({
						kind: d.b.Error,
						text: n.fbt._("Sorry, theme failed to import", null, {
							hk: "4BqW32"
						})
					})))
				}
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, s) {
			"use strict";
			s.d(t, "l", (function() {
				return h
			})), s.d(t, "k", (function() {
				return y
			})), s.d(t, "j", (function() {
				return E
			})), s.d(t, "i", (function() {
				return I
			})), s.d(t, "h", (function() {
				return v
			})), s.d(t, "g", (function() {
				return S
			})), s.d(t, "o", (function() {
				return R
			})), s.d(t, "p", (function() {
				return k
			})), s.d(t, "b", (function() {
				return x
			})), s.d(t, "c", (function() {
				return N
			})), s.d(t, "a", (function() {
				return L
			})), s.d(t, "n", (function() {
				return G
			})), s.d(t, "e", (function() {
				return B
			})), s.d(t, "f", (function() {
				return q
			})), s.d(t, "d", (function() {
				return V
			})), s.d(t, "m", (function() {
				return Y
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/addQueryParams/index.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				o = s("./src/reddit/constants/parameters.ts"),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/makeApiRequest/index.ts"),
				u = s("./src/lib/omitHeaders/index.ts"),
				l = s("./src/reddit/constants/headers.ts"),
				b = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var O = s("./src/reddit/models/Toast/index.ts"),
				g = s("./src/reddit/models/User/index.ts"),
				f = s("./src/reddit/selectors/externalAccount.ts"),
				m = s("./src/reddit/selectors/platform.ts"),
				j = s("./src/reddit/selectors/subreddit.ts"),
				_ = s("./src/reddit/selectors/user.ts");
			const h = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				y = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				I = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				v = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				S = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				T = Object(r.a)(h),
				w = Object(r.a)(y),
				C = Object(r.a)(E),
				A = Object(r.a)(I),
				D = Object(r.a)(v),
				P = Object(r.a)(S),
				R = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						i = Object(_.i)(a),
						o = e || i && Object(g.e)(i);
					if (!o) return;
					if (Object(f.d)(a, {
							username: o
						})) return;
					t(T(o));
					const O = await ((e, t) => Object(d.a)(Object(u.a)(e, [l.a]), {
						endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/user/").concat(t, ".json")),
						traceRequestName: "get_external_accounts",
						method: c.db.GET
					}))(r(), o);
					if (O.ok) {
						const e = p(O.body);
						t(w({
							username: o,
							accountsData: e
						}))
					} else t(C(O.error))
				}, k = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t(),
						a = Object(m.e)(r);
					if (!a) return;
					const i = r.externalAccount.api.subreddit.fetched[a],
						o = r.externalAccount.api.subreddit.pending[a];
					if (i || o) return;
					const O = Object(j.y)(r, {
						subredditName: a
					});
					if (!(O && O.hasExternalAccount)) return;
					e(A(a));
					const g = await ((e, t) => Object(d.a)(Object(u.a)(e, [l.a]), {
						endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/subreddit/").concat(t, ".json")),
						method: c.db.GET
					}))(n(), a);
					if (g.ok) {
						const t = p(g.body);
						e(D({
							subredditName: a,
							accountsData: t
						}))
					} else e(P(g.error))
				}, x = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", N = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", L = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", U = Object(r.a)(x), M = Object(r.a)(N), F = Object(r.a)(L), G = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					t(U({
						provider: e
					}));
					const a = Object(_.i)(s()),
						i = Object(g.e)(a),
						o = await ((e, t) => Object(d.a)(Object(u.a)(e, [l.a]), {
							endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/").concat(t, "/disconnect.json")),
							method: c.db.POST
						}))(r(), e);
					o.ok ? t(M({
						provider: e,
						username: i
					})) : t(F({
						provider: e,
						error: o.error
					}))
				}, B = "OAUTH_FLOW_URL_PENDING", q = "OAUTH_FLOW_URL_SUCCESS", V = "OAUTH_FLOW_URL_FAILED", H = Object(r.a)(B), K = Object(r.a)(q), W = Object(r.a)(V), Y = e => async (t, s, r) => {
					let {
						apiContext: p
					} = r;
					t(H({
						provider: e
					}));
					const g = Object(a.a)(window.location.href, {
							[o.d]: e
						}),
						f = await ((e, t, s) => Object(d.a)(Object(u.a)(e, [l.a]), {
							endpoint: Object(b.a)("".concat(e.apiUrl, "/api/v1/external_account/").concat(t, "/connect.json")),
							method: c.db.POST,
							data: {
								redirect_url: s
							}
						}))(p(), e, g);
					if (f.ok) {
						const {
							redirect_url: s
						} = f.body;
						t(K({
							provider: e
						})), window.location.href = s
					} else t(W({
						provider: e,
						error: f.error
					})), t(Object(i.e)({
						kind: O.b.Error,
						text: n.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/flairManagement/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = "FLAIR_PREVIEW_EXAMPLE_POST_CREATED",
				r = "FLAIR_PREVIEW_EXAMPLE_POST_DELETED"
		},
		"./src/reddit/actions/focusedVerticals/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "c", (function() {
				return _
			})), s.d(t, "b", (function() {
				return v
			}));
			var n, r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/focusedVerticals/constants.ts"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				o = s("./src/graphql/operations/SubredditGeoRecommendationViaFocusVertical.json");
			! function(e) {
				e.LoggedInGeo = "2.1", e.LoggedOutGeo = "2.1"
			}(n || (n = {}));
			var c, d = s("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				u = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			! function(e) {
				e.DEFAULT = "DEFAULT", e.GEO = "GEO"
			}(c || (c = {}));
			var l = s("./src/reddit/selectors/focusedVerticalSuggestion.ts"),
				b = s("./src/reddit/selectors/user.ts");
			const p = Object(r.a)(a.g),
				O = Object(r.a)(a.e),
				g = Object(r.a)(a.h),
				f = Object(r.a)(a.c),
				m = Object(r.a)(a.f),
				j = Object(r.a)(a.j),
				_ = Object(r.a)(a.i),
				h = () => async (e, t, s) => {
					let {
						gqlContext: r
					} = s;
					const a = t(),
						c = Object(l.e)(a),
						m = Object(l.d)(a),
						j = Object(b.G)(a);
					if (c || !m) return;
					e(g());
					let _ = !1;
					try {
						const t = j ? n.LoggedInGeo : n.LoggedOutGeo,
							s = await ((e, t, s) => Object(i.a)(e, Object.assign(Object.assign({}, o), {
								variables: {
									version: t,
									isNsfwIncluded: !1
								}
							})))(r(), t);
						if (s.ok && s.body) {
							const {
								data: t
							} = s.body;
							if (y(t)) {
								if (E(t)) {
									e(f({
										recommendedSubredditIds: [],
										interactedSubredditIds: [],
										category: "",
										lastLoadedEnv: "client"
									})), _ = !0
								} else if (I(t)) {
									const s = t.focusVerticalSubredditRecommendations,
										{
											recommendedSubreddit: n,
											interactedSubreddit: r,
											category: a
										} = s.focusRecommendations[0],
										i = [n, r],
										o = Object(u.d)(i),
										c = Object(d.b)(i),
										l = Object(u.c)(n),
										b = {
											recommendedSubredditIds: [n.id],
											interactedSubredditIds: [r.id],
											subreddits: o,
											subredditsAboutInfo: c,
											subredditTopContent: l,
											category: a,
											lastLoadedEnv: "client"
										};
									e(p(b)), _ = !0
								}
							} else _ = !1
						}
					} catch (h) {
						_ = !1
					}
					_ || e(O({
						error: {
							type: "Focused vertical experiment GQL API failed or caught by try and catch"
						}
					}))
				}, y = e => {
					const t = e.focusVerticalSubredditRecommendations;
					return !(!t || !t.focusRecommendations)
				}, E = e => {
					const t = e.focusVerticalSubredditRecommendations,
						s = t && t.focusRecommendations;
					return !(!s || 0 !== s.length)
				}, I = e => {
					const t = e.focusVerticalSubredditRecommendations,
						s = t && t.focusRecommendations,
						n = t && t.type;
					return !!(s && !E(e) && n === c.GEO && s[0] && s[0].recommendedSubreddit && s[0].interactedSubreddit)
				}, v = () => async (e, t, s) => {
					const n = t(),
						r = Object(l.g)(n);
					return Object(l.f)(n) || null === r || "client" === r ? e(h()) : "server" === r ? e(m({
						lastLoadedEnv: "client"
					})) : void 0
				}
		},
		"./src/reddit/actions/frontpage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return h
			})), s.d(t, "b", (function() {
				return y
			})), s.d(t, "a", (function() {
				return E
			})), s.d(t, "d", (function() {
				return T
			})), s.d(t, "e", (function() {
				return w
			}));
			var n = s("./node_modules/lodash/pick.js"),
				r = s.n(n),
				a = s("./src/lib/getParsedUserAgent/index.ts"),
				i = s("./src/reddit/actions/page.ts"),
				o = s("./src/reddit/constants/parameters.ts"),
				c = s("./src/reddit/endpoints/page/frontpage.ts"),
				d = s("./src/reddit/helpers/frontpageCardPostCountExperiment.ts"),
				u = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				l = s("./src/lib/makeActionCreator/index.ts"),
				b = s("./src/lib/makeListingKey/index.ts"),
				p = s("./src/lib/constants/index.ts"),
				O = s("./src/reddit/constants/page.ts"),
				g = s("./src/reddit/constants/postLayout.ts"),
				f = s("./src/reddit/contexts/PageLayer/index.tsx"),
				m = s("./src/reddit/helpers/filterListingResponse/index.ts"),
				j = s("./src/reddit/selectors/frontpage.ts"),
				_ = s("./src/reddit/selectors/user.ts");
			const h = "FRONTPAGE__MORE_POSTS_PENDING",
				y = "FRONTPAGE__MORE_POSTS_LOADED",
				E = "FRONTPAGE__MORE_POSTS_FAILED",
				I = Object(l.a)(h),
				v = Object(l.a)(y),
				S = Object(l.a)(E),
				T = e => async (t, s, n) => {
					let {
						apiContext: i,
						gqlContext: l
					} = n;
					const h = s(),
						y = Object(j.a)(h),
						{
							sort: E = y
						} = e,
						T = h.platform.currentPage ? h.platform.currentPage.queryParams : {},
						w = Object(b.a)(O.a, E, T),
						C = h.listings.postOrder.loadMore[w],
						A = T[o.x] ? T[o.x].toUpperCase() : "",
						D = A in p.Sb && p.Sb[A];
					if (C) {
						const e = h.listings.postOrder.api.pending[w],
							s = h.listings.postOrder.fetchedTokens,
							n = !(!s[w] || !s[w][C.token]);
						if (!e && !n) {
							t(I({
								key: w,
								fetchedToken: C.token
							}));
							const e = !!h.platform.currentPage && !!h.platform.currentPage.queryParams.useMockData,
								s = Object(d.a)(h),
								n = g.a,
								i = [Object(d.c)(s)],
								b = Object.assign(Object.assign({
									after: C.token,
									dist: C.dist
								}, r()(T, o.l)), {
									isMobile: Object(a.e)(h.meta.userAgent),
									limit: n,
									sort: E,
									t: Object(u.a)(E, D),
									layout: g.e[Object(f.N)(h, {})],
									useMockData: e
								}); {
								const e = h.platform.lastPage,
									t = e && e.url;
								t && (b.clickUrl = t)
							}
							const p = () => Object(c.a)(l(), Object(c.b)(h, b), Object(_.O)(h), i),
								O = await p(),
								j = Object.assign(Object.assign({}, O.body), Object(m.a)(h, w, O.body));
							O.ok ? t(v(Object.assign({
								key: w,
								fetchedToken: C.token,
								meta: h.meta
							}, j))) : t(S(Object.assign({
								key: w,
								error: O.error,
								fetchedToken: C.token
							}, j)))
						}
					}
				}, w = e => async (t, s) => {
					const n = s(),
						r = Object(j.a)(n),
						{
							sort: a = r
						} = e,
						c = n.platform.currentPage ? n.platform.currentPage.queryParams : {},
						l = Object(b.a)(O.a, a, c),
						g = c[o.x] ? c[o.x].toUpperCase() : "",
						f = g in p.Sb && p.Sb[g],
						m = Object(d.a)(n),
						_ = Object(d.b)(m);
					await t(Object(i.w)(l, {
						limit: _,
						sort: a,
						t: Object(u.a)(a, f)
					}))
				}
		},
		"./src/reddit/actions/global/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "LOCAL_STORAGE_LOADED"
		},
		"./src/reddit/actions/gold/communityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return y
			})), s.d(t, "f", (function() {
				return E
			})), s.d(t, "e", (function() {
				return I
			})), s.d(t, "b", (function() {
				return T
			})), s.d(t, "c", (function() {
				return C
			})), s.d(t, "i", (function() {
				return A
			})), s.d(t, "a", (function() {
				return F
			})), s.d(t, "j", (function() {
				return V
			})), s.d(t, "g", (function() {
				return z
			})), s.d(t, "h", (function() {
				return Z
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/sentry/index.ts"),
				i = s("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				o = s("./src/reddit/actions/modal.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/reddit/models/Toast/index.ts"),
				u = s("./src/reddit/selectors/activeModalId.ts"),
				l = s("./src/reddit/selectors/communityAwards.ts"),
				b = s("./src/reddit/selectors/experiments/econ/groupAwarding.ts"),
				p = s("./src/reddit/selectors/profile.ts"),
				O = s("./src/reddit/selectors/subreddit.ts"),
				g = s("./src/reddit/endpoints/gold/communityAwards.ts"),
				f = s("./src/reddit/constants/gold.ts"),
				m = s("./src/reddit/actions/gold/constants.ts");
			const j = () => n.fbt._("There was an error creating the award. Please try again.", null, {
					hk: "3UtrTD"
				}),
				_ = () => n.fbt._("There was an error loading awards list. Please try again.", null, {
					hk: "3fs6Y8"
				}),
				h = () => n.fbt._("There was an error removing the award. Please try again.", null, {
					hk: "1exAPF"
				}),
				y = (e, t, s, n, r, a, i, o) => async (c, d, u) => {
					let {
						gqlContext: l
					} = u;
					c(v());
					try {
						if ((await Object(g.a)(l(), e, t, s, n, r, a, i, o)).error) {
							const e = j();
							await c(T(e))
						}
					} catch (b) {
						const e = j();
						await c(T(e))
					}
				}, E = (e, t, s, n, r, a, i, o) => async (c, d, u) => {
					let {
						gqlContext: l
					} = u;
					c(v());
					try {
						if ((await Object(g.c)(l(), e, t, s, n, r, a, i, o)).error) {
							const e = j();
							await c(T(e))
						}
					} catch (b) {
						const e = j();
						await c(T(e))
					}
				}, I = e => {
					let {
						awardSubType: t,
						coinPrice: s,
						coinReward: n,
						daysOfDripExtension: r,
						daysOfPremium: a,
						description: i,
						endsAt: o,
						giverCoinReward: c,
						iconFormat: d,
						iconHeight: u,
						iconUrl: l,
						iconWidth: b,
						isNew: p,
						name: O,
						pennyPrice: f,
						pennyDonate: m,
						startsAt: _,
						subredditCoinReward: h
					} = e;
					return async (e, y, E) => {
						let {
							gqlContext: I
						} = E;
						e(v());
						try {
							if ((await Object(g.b)({
									awardSubType: t,
									coinPrice: s,
									coinReward: n,
									context: I(),
									daysOfDripExtension: r,
									daysOfPremium: a,
									description: i,
									endsAt: o,
									giverCoinReward: c,
									iconFormat: d,
									iconHeight: u,
									iconUrl: l,
									iconWidth: b,
									isNew: p,
									name: O,
									pennyPrice: f,
									pennyDonate: m,
									startsAt: _,
									subredditCoinReward: h
								})).error) {
								const t = j();
								await e(T(t))
							}
						} catch (S) {
							const t = j();
							await e(T(t))
						}
					}
				}, v = Object(r.a)(m.i), S = Object(r.a)(m.h), T = e => async (t, s) => {
					await t(S(e)), t(Object(c.e)({
						kind: d.b.Error,
						duration: c.a,
						text: e
					}))
				}, w = Object(r.a)(m.j), C = e => {
					let {
						award: t,
						subredditId: s
					} = e;
					return async (e, r) => {
						const a = r();
						e(w({
							award: t,
							subredditId: s
						})), Object(u.a)(a) === f.a && e(Object(o.i)(f.a));
						const i = n.fbt._("Community award successfully created!", null, {
							hk: "3UvmDa"
						});
						e(Object(c.e)({
							kind: d.b.SuccessCommunity,
							text: i
						}))
					}
				}, A = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = s(),
						o = !!a.awards.manageable.order[e];
					if (Object(l.b)(a, {
							subredditOrProfileId: e
						}) || o) return;
					t(D({
						subredditOrProfileId: e
					}));
					const c = Object(i.a)(e),
						d = !!Object(O.ab)(a, {
							subredditIds: [e]
						})[0];
					let u;
					if (c) u = Object(g.j)(r());
					else if (d) u = Object(g.k)(r(), e);
					else {
						const t = Object(p.p)(a, {
							profileId: e
						}).name;
						u = Object(g.l)(r(), t)
					}
					try {
						const s = await u;
						if (!s.ok) {
							const e = _();
							return void(await t(x(e)))
						}
						let n = [];
						if (c) n = s.body.data.globalAwards;
						else {
							const r = d ? s.body.data.subreddit : s.body.data.profileByName;
							n = r.manageableAwards || [], t(R({
								awards: r.optionalAwards || [],
								subredditOrProfileId: e
							})), t(N({
								subredditOrProfileId: e,
								disabled: !r.isAwardCreationAllowed
							}))
						}
						await t(P({
							awards: n,
							subredditOrProfileId: e
						}))
					} catch (b) {
						const e = _();
						t(x(e))
					}
				}, D = Object(r.a)(m.K), P = Object(r.a)(m.J), R = Object(r.a)(m.O), k = Object(r.a)(m.I), x = e => async (t, s) => {
					await t(k(e)), t(Object(c.e)({
						kind: d.b.Error,
						duration: c.a,
						text: e
					}))
				}, N = Object(r.a)(m.e), L = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const i = s();
					if (!!i.awards.usable.order[e]) return;
					const o = Object(b.a)(i);
					try {
						const s = Object(p.p)(i, {
							profileId: e
						});
						if (s) {
							const n = await Object(g.o)(r(), s.name, o);
							if (n.ok) {
								const s = n.body;
								return void(await t(U({
									awards: s.data.profile.usableAwards,
									subredditOrProfileId: e
								})))
							}
						} else {
							const s = await Object(g.n)(r(), e, o);
							if (s.ok) {
								const n = s.body;
								return void(await t(U({
									awards: n.data.subreddit.usableAwards,
									subredditOrProfileId: e
								})))
							}
						}
					} catch (c) {
						a.c.captureException(c)
					}
				}, U = Object(r.a)(m.ub), M = e => e.map(e => {
					let {
						tag: t,
						content: s
					} = e;
					return {
						tag: t,
						content: {
							richtext: JSON.parse(s.richtext),
							markdown: s.markdown
						}
					}
				}), F = (e, t) => async (s, n, r) => {
					let {
						gqlContext: i
					} = r;
					const o = n(),
						c = o.awards.sortedUsable.order[e];
					if (!!c && !!c[t]) return;
					const d = Object(b.a)(o);
					s(G({
						subredditOrProfileId: e,
						thingId: t
					}));
					try {
						const n = Object(p.p)(o, {
							profileId: e
						});
						if (n) {
							const r = await Object(g.g)(i(), n.name, t, d);
							if (r.ok) {
								const n = r.body,
									a = M(n.data.profileByName.awardingTray.sortedUsableTags);
								return void(await s(q({
									awards: n.data.profileByName.sortedUsableAwards,
									tags: a,
									subredditOrProfileId: e,
									thingId: t
								})))
							}
							s(L(e)), await s(B({
								subredditOrProfileId: e,
								thingId: t
							}))
						} else {
							const n = await Object(g.f)(i(), e, t, d);
							if (n.ok) {
								const r = n.body,
									a = M(r.data.subredditInfoById.awardingTray.sortedUsableTags);
								return void(await s(q({
									awards: r.data.subredditInfoById.sortedUsableAwards,
									tags: a,
									subredditOrProfileId: e,
									thingId: t
								})))
							}
							s(L(e)), await s(B({
								subredditOrProfileId: e,
								thingId: t
							}))
						}
					} catch (u) {
						a.c.captureException(u), s(L(e)), await s(B({
							subredditOrProfileId: e,
							thingId: t
						}))
					}
				}, G = Object(r.a)(m.d), B = Object(r.a)(m.b), q = Object(r.a)(m.c), V = (e, t) => async (s, r, i) => {
					let {
						gqlContext: o
					} = i;
					s(H());
					try {
						if ((await Object(g.m)(o(), t)).error) {
							const e = h();
							await s(Y(e))
						} else {
							await s(K({
								awardId: t,
								subredditId: e
							}));
							const a = Object(l.a)(r(), t);
							if (!a) return;
							const i = n.fbt._("{award name} Award successfully deleted!", [n.fbt._param("award name", a.name)], {
								hk: "3ZQs5u"
							});
							s(Object(c.e)({
								kind: d.b.SuccessCommunity,
								duration: c.a,
								text: i
							}))
						}
					} catch (u) {
						a.c.captureException(u);
						const e = h();
						await s(Y(e))
					}
				}, H = Object(r.a)(m.eb), K = Object(r.a)(m.fb), W = Object(r.a)(m.db), Y = e => async (t, s) => {
					await t(W(e)), t(Object(c.e)({
						kind: d.b.Error,
						duration: c.a,
						text: e
					}))
				}, z = (e, t) => async (s, r, i) => {
					let {
						gqlContext: o
					} = i;
					s(J());
					let u = n.fbt._("There was a problem disabling the {award name} Award. Please try again.", [n.fbt._param("award name", t.name)], {
							hk: "3KNLaD"
						}),
						l = X(u),
						b = d.b.Error;
					try {
						(await Object(g.h)(o(), t.id, e.id)).ok && (l = Q({
							awardId: t.id,
							subredditId: e.id
						}), u = n.fbt._("{award name} Award successfully disabled in {subreddit or profile prefixed name}!", [n.fbt._param("award name", t.name), n.fbt._param("subreddit or profile prefixed name", e.displayText)], {
							hk: "26i191"
						}), b = d.b.SuccessCommunity)
					} catch (p) {
						a.c.captureException(p)
					} finally {
						await s(l), await s(Object(c.e)({
							text: u,
							duration: c.a,
							kind: b
						}))
					}
				}, J = Object(r.a)(m.l), Q = Object(r.a)(m.m), X = Object(r.a)(m.k), Z = (e, t) => async (s, r, i) => {
					let {
						gqlContext: o
					} = i;
					s($());
					let u = n.fbt._("There was a problem enabling the {award name} Award. Please try again.", [n.fbt._param("award name", t.name)], {
							hk: "2jdxBY"
						}),
						l = te(u),
						b = d.b.Error;
					try {
						(await Object(g.i)(o(), t.id, e.id)).ok && (l = ee({
							awardId: t.id,
							subredditId: e.id
						}), u = n.fbt._("{award name} Award successfully enabled in {subreddit name}!", [n.fbt._param("award name", t.name), n.fbt._param("subreddit name", "r/" + e.name)], {
							hk: "zGXlU"
						}), b = d.b.SuccessCommunity)
					} catch (p) {
						a.c.captureException(p)
					} finally {
						await s(l), await s(Object(c.e)({
							text: u,
							duration: c.a,
							kind: b
						}))
					}
				}, $ = Object(r.a)(m.o), ee = Object(r.a)(m.p), te = Object(r.a)(m.n)
		},
		"./src/reddit/actions/gold/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "N", (function() {
				return n
			})), s.d(t, "g", (function() {
				return r
			})), s.d(t, "M", (function() {
				return a
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "L", (function() {
				return o
			})), s.d(t, "i", (function() {
				return c
			})), s.d(t, "j", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "eb", (function() {
				return l
			})), s.d(t, "fb", (function() {
				return b
			})), s.d(t, "db", (function() {
				return p
			})), s.d(t, "K", (function() {
				return O
			})), s.d(t, "J", (function() {
				return g
			})), s.d(t, "I", (function() {
				return f
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "O", (function() {
				return j
			})), s.d(t, "l", (function() {
				return _
			})), s.d(t, "m", (function() {
				return h
			})), s.d(t, "k", (function() {
				return y
			})), s.d(t, "o", (function() {
				return E
			})), s.d(t, "p", (function() {
				return I
			})), s.d(t, "n", (function() {
				return v
			})), s.d(t, "d", (function() {
				return S
			})), s.d(t, "c", (function() {
				return T
			})), s.d(t, "b", (function() {
				return w
			})), s.d(t, "ub", (function() {
				return C
			})), s.d(t, "ib", (function() {
				return A
			})), s.d(t, "A", (function() {
				return D
			})), s.d(t, "E", (function() {
				return P
			})), s.d(t, "z", (function() {
				return R
			})), s.d(t, "B", (function() {
				return k
			})), s.d(t, "D", (function() {
				return x
			})), s.d(t, "C", (function() {
				return N
			})), s.d(t, "F", (function() {
				return L
			})), s.d(t, "s", (function() {
				return U
			})), s.d(t, "w", (function() {
				return M
			})), s.d(t, "v", (function() {
				return F
			})), s.d(t, "r", (function() {
				return G
			})), s.d(t, "t", (function() {
				return B
			})), s.d(t, "q", (function() {
				return q
			})), s.d(t, "u", (function() {
				return V
			})), s.d(t, "hb", (function() {
				return H
			})), s.d(t, "gb", (function() {
				return K
			})), s.d(t, "x", (function() {
				return W
			})), s.d(t, "y", (function() {
				return Y
			})), s.d(t, "G", (function() {
				return z
			})), s.d(t, "mb", (function() {
				return J
			})), s.d(t, "lb", (function() {
				return Q
			})), s.d(t, "jb", (function() {
				return X
			})), s.d(t, "kb", (function() {
				return Z
			})), s.d(t, "xb", (function() {
				return $
			})), s.d(t, "wb", (function() {
				return ee
			})), s.d(t, "vb", (function() {
				return te
			})), s.d(t, "cb", (function() {
				return se
			})), s.d(t, "bb", (function() {
				return ne
			})), s.d(t, "ab", (function() {
				return re
			})), s.d(t, "V", (function() {
				return ae
			})), s.d(t, "W", (function() {
				return ie
			})), s.d(t, "U", (function() {
				return oe
			})), s.d(t, "Q", (function() {
				return ce
			})), s.d(t, "R", (function() {
				return de
			})), s.d(t, "P", (function() {
				return ue
			})), s.d(t, "T", (function() {
				return le
			})), s.d(t, "S", (function() {
				return be
			})), s.d(t, "H", (function() {
				return pe
			})), s.d(t, "Z", (function() {
				return Oe
			})), s.d(t, "Y", (function() {
				return ge
			})), s.d(t, "X", (function() {
				return fe
			})), s.d(t, "a", (function() {
				return me
			})), s.d(t, "nb", (function() {
				return je
			})), s.d(t, "ob", (function() {
				return _e
			})), s.d(t, "pb", (function() {
				return he
			})), s.d(t, "qb", (function() {
				return ye
			})), s.d(t, "rb", (function() {
				return Ee
			})), s.d(t, "sb", (function() {
				return Ie
			})), s.d(t, "tb", (function() {
				return ve
			}));
			const n = "GIVE_PREMIUM__OPEN_GIVE_PREMIUM_MODAL",
				r = "GIVE_PREMIUM__CLOSE_GIVE_PREMIUM_MODAL",
				a = "GILD__OPEN_GILD_MODAL",
				i = "GILD__CLOSE_GILD_MODAL",
				o = "GILD__OPEN_FRAMED_GILD",
				c = "COMMUNITY_AWARDS__CREATE_AWARD_PENDING",
				d = "COMMUNITY_AWARDS__CREATE_AWARD_SUCCESSFUL",
				u = "COMMUNITY_AWARDS__CREATE_AWARD_FAILED",
				l = "COMMUNITY_AWARDS__REMOVE_PENDING",
				b = "COMMUNITY_AWARDS__REMOVE_SUCCESSFUL",
				p = "COMMUNITY_AWARDS__REMOVE_FAILED",
				O = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_PENDING",
				g = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_LOADED",
				f = "COMMUNITY_AWARDS__MANAGEABLE_AWARDS_FAILED",
				m = "COMUNITY_AWARDS__BLACKLIST_STATUS_LOADED",
				j = "COMMUNITY_AWARDS__OPTIONAL_AWARDS_LOADED",
				_ = "COMMUNITY_AWARDS__DISABLE_PENDING",
				h = "COMMUNITY_AWARDS__DISABLE_SUCCESSFUL",
				y = "COMMUNITY_AWARDS__DISABLE_FAILED",
				E = "COMMUNITY_AWARDS__ENABLE_PENDING",
				I = "COMMUNITY_AWARDS__ENABLE_SUCCESSFUL",
				v = "COMMUNITY_AWARDS__ENABLE_FAILED",
				S = "AWARD_SHEET__INFO_PENDING",
				T = "AWARD_SHEET__INFO_LOADED",
				w = "AWARD_SHEET__INFO_FAILED",
				C = "COMMUNITY_AWARDS__USABLE_AWARDS_LOADED",
				A = "COINS__SUBREDDIT_LOCKED_COINS_LOADED",
				D = "GIVE_PREMIUM__GIVE_PREMIUM_PENDING",
				P = "GIVE_PREMIUM__GIVE_PREMIUM_SUCCESSFUL",
				R = "GIVE_PREMIUM__GIVE_PREMIUM_FAILED",
				k = "GIVE_PREMIUM__SELECT_PACKAGE",
				x = "GIVE_PREMIUM__SET_IS_ANONYMOUS",
				N = "GIVE_PREMIUM__SET_INCLUDE_MESSAGE",
				L = "GIVE_PREMIUM__UPDATE_MESSAGE",
				U = "GILD__SET_IS_ANONYMOUS",
				M = "GILD__UPDATE_MESSAGE",
				F = "GILD__TRIGGER_LOADER",
				G = "GILD__GILD_PENDING",
				B = "GILD__GILD_SUCCESSFUL",
				q = "GILD__GILD_FAILED",
				V = "GILD__GILD_THING",
				H = "GIVE_AWARD__SELECT_AWARD",
				K = "AWARDS__REPORT_AWARD",
				W = "AWARDS__GIVE_AWARD_TOOLTIP_CLOSED",
				Y = "AWARDS__GIVE_AWARD_TOOLTIP_OPENED",
				z = "AWARDS__HIDE_AWARD",
				J = "POWERUPS__SUBREDDIT_POWERUPS_PENDING",
				Q = "POWERUPS__SUBREDDIT_POWERUPS_LOADED",
				X = "POWERUPS__SUBREDDIT_POWERUPS_FAILED",
				Z = "POWERUPS__SUBREDDIT_POWERUPS_FULL_LOADED",
				$ = "POWERUPS__USER_POWERUPS_PENDING",
				ee = "POWERUPS__USER_POWERUPS_LOADED",
				te = "POWERUPS__USER_POWERUPS_FAILED",
				se = "POWERUPS__REDDITOR_POWERUPS_PENDING",
				ne = "POWERUPS__REDDITOR_POWERUPS_LOADED",
				re = "POWERUPS__REDDITOR_POWERUPS_FAILED",
				ae = "POWERUPS__REALLOCATE_PENDING",
				ie = "POWERUPS__REALLOCATE_SUCCESSFUL",
				oe = "POWERUPS__REALLOCATE_FAILED",
				ce = "POWERUPS__CANCEL_PAYMENT_PENDING",
				de = "POWERUPS__CANCEL_PAYMENT_SUCCESSFUL",
				ue = "POWERUPS__CANCEL_PAYMENT_FAILED",
				le = "POWERUPS__PAYMENT_COMPLETED",
				be = "POWERUPS_PURCHASE__POWERUPS_COUNT_CHANGED",
				pe = "POWERUPS_PURCHASE__IS_ANONYMOUS_CHANGED",
				Oe = "PRODUCT_OFFERS__OFFERS_PENDING",
				ge = "PRODUCT_OFFERS__OFFERS_LOADED",
				fe = "PRODUCT_OFFERS__OFFERS_FAILED",
				me = "GILD__AWARD_KARMA_UPDATED",
				je = "TOP_AWARDED__POSTS_FAILED",
				_e = "TOP_AWARDED__POSTS_LOADED",
				he = "TOP_AWARDED__POSTS_PENDING",
				ye = "TOP_AWARDERS__LEADERBOARD_FAILED",
				Ee = "TOP_AWARDERS__LEADERBOARD_LOADED",
				Ie = "TOP_AWARDERS__LEADERBOARD_PENDING",
				ve = "TOP_AWARDERS__MODAL_OPENED"
		},
		"./src/reddit/actions/gold/econPurchase.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			}));
			var n = s("./src/lib/initializeClient/installReducer.ts"),
				r = s("./src/reddit/reducers/features/econPurchase/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/graphql/operations/SubredditCoins.json"),
				o = s("./src/lib/makeGqlRequest/index.ts");
			var c = s("./src/reddit/featureFlags/subredditPoints.ts"),
				d = s("./src/reddit/actions/gold/constants.ts");
			Object(n.a)({
				features: {
					econPurchase: r.a
				}
			});
			const u = Object(a.a)(d.ib),
				l = (e, t, s) => async (n, r, a) => {
					let {
						gqlContext: d
					} = a;
					var l, b;
					if (!c.a.has(t.toLowerCase())) return;
					if (void 0 !== r().features.econPurchase.subredditLockedCoins[e] && !(null == s ? void 0 : s.force)) return;
					const p = await ((e, t) => Object(o.a)(e, Object.assign(Object.assign({}, i), {
						variables: {
							subreddit: t
						}
					})))(d(), e);
					if (p.ok) {
						const t = p.body;
						n(u({
							subredditId: e,
							amount: (null === (b = null === (l = t.data.subredditInfoById) || void 0 === l ? void 0 : l.userCoinsInSubreddit) || void 0 === b ? void 0 : b.amount) || 0
						}))
					}
				}
		},
		"./src/reddit/actions/gold/gild.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "setIsAnonymous", (function() {
				return W
			})), s.d(t, "updateMessage", (function() {
				return Y
			})), s.d(t, "gildGqlRequested", (function() {
				return z
			})), s.d(t, "triggerLoader", (function() {
				return J
			})), s.d(t, "gildPending", (function() {
				return X
			})), s.d(t, "gildFailed", (function() {
				return $
			})), s.d(t, "gildSuccessful", (function() {
				return se
			})), s.d(t, "awardKarmaUpdated", (function() {
				return ne
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/postParentMessage/index.ts"),
				i = s("./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts"),
				o = s("./src/reddit/actions/goldPurchaseModals/purchaseCatalog.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				u = s("./node_modules/react/index.js"),
				l = s.n(u),
				b = s("./src/reddit/models/Gold/Award.ts"),
				p = s("./src/reddit/components/Gold/AwardKarmaToastMessage/index.m.less"),
				O = s.n(p);
			const {
				fbt: g
			} = s("./node_modules/fbt/lib/FbtPublic.js"), f = e => g._("Sent! You earned {=awarder karma}", [g._param("=awarder karma", l.a.createElement("a", {
				className: O.a.karmaLink,
				href: b.a,
				target: "_blank",
				rel: "noopener noreferrer"
			}, g._({
				"*": "{awarder karma} awarder karma",
				_1: "1 awarder karma"
			}, [g._plural(e.awarderKarmaReceived, "awarder karma")], {
				hk: "2Llmz0"
			})))], {
				hk: "3ItXUT"
			});
			var m = s("./src/reddit/constants/modals.ts"),
				j = s("./src/reddit/models/Gold/Coins/index.ts"),
				_ = s("./src/reddit/models/Post/index.ts"),
				h = s("./src/reddit/models/Toast/index.ts"),
				y = s("./src/reddit/models/User/index.ts"),
				E = s("./src/reddit/selectors/comments.ts"),
				I = s("./src/reddit/selectors/communityAwards.ts"),
				v = s("./src/reddit/selectors/experiments/econAwardKarma.ts"),
				S = s("./src/reddit/selectors/gild.ts"),
				T = s("./src/reddit/selectors/gold/awardIcon.ts"),
				w = s("./src/reddit/selectors/gold/econPurchase.ts"),
				C = s("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				A = s("./src/reddit/selectors/posts.ts"),
				D = s("./src/reddit/selectors/subreddit.ts"),
				P = s("./src/reddit/selectors/user.ts"),
				R = s("./src/graphql/operations/GildComment.json"),
				k = s("./src/graphql/operations/GildPost.json"),
				x = s("./src/lib/makeGqlRequest/index.ts"),
				N = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const L = (e, t, s) => Object(x.a)(e, Object.assign(Object.assign({}, k), {
					variables: t
				}), {
					query: s ? {} : Object(N.b)()
				}),
				U = (e, t, s) => Object(x.a)(e, Object.assign(Object.assign({}, R), {
					variables: t
				}), {
					query: s ? {} : Object(N.b)()
				});
			var M = s("./src/reddit/helpers/awards/getAwardItemId.ts"),
				F = s("./src/reddit/helpers/awards/message.ts"),
				G = s("./src/reddit/helpers/correlationIdTracker.ts"),
				B = s("./src/reddit/helpers/isPost.ts"),
				q = s("./src/reddit/helpers/trackers/gild.ts"),
				V = s("./src/telemetry/index.ts"),
				H = s("./src/reddit/actions/gold/constants.ts"),
				K = s("./src/reddit/actions/gold/econPurchase.ts");
			const W = Object(r.a)(H.s),
				Y = Object(r.a)(H.w),
				z = (e, t) => async (s, r, a) => {
					let {
						gqlContext: i
					} = a;
					const o = r().gild,
						{
							isOldReddit: c,
							isLivestream: d
						} = t;
					s(X());
					try {
						const t = {
								gildingTypeId: o.selectedAward.id,
								isAnonymous: o.isAnonymous,
								isGildFunded: !1,
								message: Object(F.d)(o.message, o.selectedAward, d),
								nodeId: e
							},
							r = Object(B.a)(e) ? L : U,
							a = await r(i(), {
								input: t
							}, c);
						let u = !1,
							l = null,
							b = null;
						if (a.ok) {
							const e = a.body;
							u = e.data.gild.ok, l = e.data.gild.fieldErrors, b = e.data.gild.errors
						}
						if (u) {
							const t = a.body,
								{
									gild: n
								} = t.data,
								r = Object(B.a)(e) ? a.body.data.gild.postInfo : a.body.data.gild.comment,
								{
									awardings: i,
									treatmentTags: c
								} = r;
							await s(se({
								awardId: o.selectedAward.id,
								awardings: i,
								awardKarmaReceived: n.awardKarmaReceived,
								coins: n.coins,
								id: e,
								subredditCoins: n.subredditCoins,
								treatmentTags: c
							}))
						} else {
							const e = l && l[0] && l[0].message,
								t = b && b[0] && b[0].message,
								r = e || t || n.fbt._("An unknown error occurred", null, {
									hk: "2oAbwZ"
								});
							await s($(r))
						}
					} catch (u) {
						const e = u,
							t = e && e.message || n.fbt._("An unknown error occurred", null, {
								hk: "2oAbwZ"
							});
						await s($(t))
					} finally {
						Object(G.b)(G.a.GildingFlow)
					}
				}, J = Object(r.a)(H.v), Q = Object(r.a)(H.r), X = () => async (e, t) => {
					e(Q()), window.setTimeout(() => {
						t().gild.api.pending && e(J())
					}, 2e3)
				}, Z = Object(r.a)(H.q), $ = e => async (t, s) => {
					await t(Z(e)), t(Object(d.e)({
						kind: h.b.Error,
						duration: d.a,
						text: e
					}))
				}, ee = Object(r.a)(H.t), te = (e, t) => {
					const {
						id: s
					} = t, n = Object(B.a)(s) ? Object(A.N)(e, {
						postId: s
					}) : Object(E.n)(e, {
						commentId: s
					}), r = Object(P.i)(e), a = e.gild, {
						isAnonymous: i
					} = a, o = !i && r && (r.username || r.displayText) ? r.username || r.displayText : void 0, c = n ? n.author : void 0, d = Object(D.K)(e, {
						thingId: s
					});
					return ee(Object.assign(Object.assign({}, t), {
						gilder: o,
						gildee: c,
						subredditId: d && d.id
					}))
				}, se = e => async (t, s) => {
					const r = s(),
						{
							awardId: u,
							id: l
						} = e,
						p = Object(I.a)(r, u),
						O = Object(v.a)(r),
						g = e.awardKarmaReceived,
						E = Object(P.i)(r),
						R = Object(S.b)(r) || Object(G.d)(G.a.GildingFlow, !1);
					if (Object(S.h)(r)) {
						const e = "success.gild",
							t = {},
							s = Object(T.a)(r, {
								award: p,
								minSize: 32,
								postOrCommentId: l
							});
						t.awardId = u, t.awardIcon = s, Object(a.a)({
							type: e,
							data: t
						})
					}
					if (p.awardType === b.f.Moderator && void 0 === e.subredditCoins) {
						const t = Object(D.K)(r, {
								thingId: l
							}),
							s = t && Object(D.D)(r, {
								subredditName: t.name
							});
						s && (e.subredditCoins = s - p.coinPrice)
					}
					if (t(te(r, e)), E && O) {
						const e = E.awarderKarma + g,
							s = Object(y.e)(E);
						t(ne({
							userName: s,
							awarderKarma: e
						}))
					}(r.posts.instances[l] || []).forEach(s => {
						t(te(r, Object.assign(Object.assign({}, e), {
							id: s
						})))
					});
					const k = Object(B.a)(l) ? n.fbt._("Success! You have given this post the {awardName} Award", [n.fbt._param("awardName", p.name)], {
							hk: "1Ndi4Z"
						}) : n.fbt._("Success! You have given this comment the {awardName} Award", [n.fbt._param("awardName", p.name)], {
							hk: "2sIK9Y"
						}),
						x = p.coinPrice;
					O ? Object(V.a)(Object(q.viewKarmaSuccessEvent)({
						award: p,
						awarderKarmaEarned: g,
						awardeeKarmaEarned: 0,
						numberCoins: x,
						thingId: l
					})(r)) : Object(V.a)(Object(q.viewSuccessAwardEvent)(l, x, p)(r)), t(Object(c.g)(m.a.GOLD_GILD_MODAL));
					const N = Object(T.a)(r, {
						award: p,
						minSize: 64,
						postOrCommentId: l
					});
					t(Object(d.e)({
						customIconAsset: N,
						kind: h.b.SuccessAward,
						text: O && g > 0 ? f({
							awarderKarmaReceived: g
						}) : k
					})), setTimeout(() => {
						const e = Object(M.a)(u, l),
							t = document.getElementById(e);
						t && t.dispatchEvent(new Event("awardAdded"))
					}, 10);
					const L = Object(B.a)(l) && Object(_.i)(Object(A.N)(r, {
						postId: l
					}));
					await t(Object(o.b)(R));
					const U = Object(C.d)(s()).filter(e => j.a.has(e.dealInfo.type));
					U.length && setTimeout(() => t(Object(i.d)({
						correlationId: R,
						packageId: U[0].mobileId
					})), L ? 600 : 10);
					const F = Object(D.K)(r, {
						thingId: l
					});
					F && Object(w.a)(r, {
						subredditId: F.id
					}) && t(Object(K.a)(F.id, F.name, {
						force: !0
					}))
				}, ne = Object(r.a)(H.a)
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return f
			})), s.d(t, "b", (function() {
				return j
			})), s.d(t, "d", (function() {
				return h
			})), s.d(t, "c", (function() {
				return E
			})), s.d(t, "a", (function() {
				return I
			})), s.d(t, "f", (function() {
				return v
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/postParentMessage/index.ts"),
				a = s("./src/reddit/helpers/isPost.ts"),
				i = s("./src/reddit/constants/modals.ts"),
				o = s("./src/reddit/selectors/gild.ts"),
				c = s("./src/reddit/helpers/correlationIdTracker.ts"),
				d = s("./src/reddit/actions/gold/communityAwards.ts"),
				u = s("./src/reddit/actions/modal.ts"),
				l = s("./src/reddit/selectors/communityAwards.ts"),
				b = s("./src/reddit/selectors/posts.ts"),
				p = s("./src/reddit/selectors/subreddit.ts"),
				O = s("./src/telemetry/index.ts"),
				g = s("./src/reddit/actions/gold/constants.ts");
			const f = Object(n.a)(g.N),
				m = Object(n.a)(g.g),
				j = () => async (e, t) => {
					const n = t();
					e(m()), Object(c.b)(c.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: r
					} = await s.e("givePremiumTrackers").then(s.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(O.a)(r()(n))
				}, _ = Object(n.a)(g.M), h = e => {
					let {
						awardId: t,
						correlationId: s,
						thingId: n
					} = e;
					return async (e, r) => {
						const o = r(),
							c = t ? Object(l.a)(o, t) : void 0;
						e(_({
							award: c && c.isEnabled ? c : void 0,
							thingId: n,
							correlationId: s
						})), e(Object(u.h)(i.a.GOLD_GILD_MODAL));
						const O = Object(p.K)(o, {
							thingId: n
						});
						let g = null;
						if (O) g = O.id;
						else if (Object(a.a)(n)) {
							const e = Object(b.N)(o, {
								postId: n
							});
							e && (g = e.belongsTo.id)
						}
						g && Object(d.a)(g, n)
					}
				}, y = Object(n.a)(g.f), E = Object(n.a)(g.L), I = () => async (e, t) => {
					const n = t(),
						a = Object(o.d)(n);
					if (Object(o.h)(n)) {
						const e = "close.gild";
						Object(r.a)({
							type: e
						})
					}
					e(y()), e(Object(u.g)(i.a.GOLD_GILD_MODAL));
					const {
						clickCloseGildModalEvent: d
					} = await Promise.resolve().then(s.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(O.a)(d(a)(n)), Object(c.b)(c.a.GildingFlow)
				}, v = () => async () => {
					Object(r.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/gold/powerups.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return I
			})), s.d(t, "e", (function() {
				return C
			})), s.d(t, "f", (function() {
				return k
			})), s.d(t, "d", (function() {
				return V
			})), s.d(t, "a", (function() {
				return H
			})), s.d(t, "c", (function() {
				return K
			})), s.d(t, "b", (function() {
				return W
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/sentry/index.ts"),
				i = s("./src/reddit/constants/modals.ts"),
				o = s("./src/reddit/helpers/localStorage/index.ts"),
				c = s("./src/reddit/actions/login.ts"),
				d = s("./src/reddit/actions/modal.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/models/Toast/index.ts"),
				b = s("./src/graphql/operations/ReallocatePowerups.json"),
				p = s("./src/graphql/operations/RedditorPowerups.json"),
				O = s("./src/graphql/operations/SubredditPowerups.json"),
				g = s("./src/graphql/operations/SubredditPowerupsFull.json"),
				f = s("./src/graphql/operations/UserPowerups.json"),
				m = s("./src/lib/makeGqlRequest/index.ts");
			const j = (e, t) => Object(m.a)(e, Object.assign(Object.assign({}, O), {
					variables: {
						subredditId: t
					}
				})),
				_ = (e, t) => Object(m.a)(e, Object.assign(Object.assign({}, g), {
					variables: {
						subredditId: t
					}
				}));
			var h = s("./src/reddit/selectors/gold/powerups.ts"),
				y = s("./src/reddit/selectors/user.ts"),
				E = s("./src/reddit/actions/gold/constants.ts");
			const I = e => async (t, s, r) => {
				let {
					gqlContext: i
				} = r;
				if (!!s().user.powerups.fetched && !e) return;
				t(v());
				const o = n.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const e = await (e => Object(m.a)(e, f))(i());
					if (e.ok) {
						const s = e.body;
						if (s.errors && s.errors.length) return void(await t(w(o)));
						if (!s.data.identity) return void(await t(T(o)));
						await t(S({
							powerups: s.data.identity.powerups
						}))
					}
				} catch (c) {
					a.c.captureException(c), await t(w(o))
				}
			}, v = Object(r.a)(E.xb), S = Object(r.a)(E.wb), T = Object(r.a)(E.vb), w = e => async (t, s) => {
				await t(T(e)), t(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: e
				}))
			}, C = (e, t) => async (e, s, r) => {
				let {
					gqlContext: i
				} = r;
				var o;
				if (!!s().users.powerups.fetched) return;
				e(A());
				const c = n.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const s = await ((e, t) => Object(m.a)(e, Object.assign({
						variables: {
							id: t
						}
					}, p)))(i(), t);
					if (s.ok) {
						const n = s.body;
						if (n.errors && n.errors.length) return void(await e(R(c)));
						if (!n.data.redditorInfoById) return void(await e(P(c)));
						const r = (null === (o = n.data.redditorInfoById.powerups) || void 0 === o ? void 0 : o.supportedSubreddits) || [];
						await e(D({
							supportedSubreddits: r,
							userId: t
						}))
					}
				} catch (d) {
					a.c.captureException(d), await e(R(c))
				}
			}, A = Object(r.a)(E.cb), D = Object(r.a)(E.bb), P = Object(r.a)(E.ab), R = e => async (t, s) => {
				await t(P(e)), t(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: e
				}))
			}, k = (e, t) => async (s, r, i) => {
				let {
					gqlContext: o
				} = i;
				var c;
				const d = r();
				if (Object(h.f)(d, {
						subredditId: e
					}) && (!t.fullData || Object(h.g)(d, {
						subredditId: e
					})) && !t.forceLoad) return;
				s(x());
				const u = t.fullData ? _ : j;
				try {
					const n = await u(o(), e);
					if (n.ok) {
						const r = n.body;
						if (null === (c = r.errors) || void 0 === c ? void 0 : c.length) return void(await s(M(r.errors[0].message)));
						if (t.fullData) {
							const {
								powerups: t = null,
								supporters: n = null
							} = r.data.subredditInfoById || {};
							await s(L({
								powerups: t,
								recentSupporters: n ? n.recentSupporters : [],
								subredditId: e,
								topSupporters: n ? n.topSupporters : []
							}))
						} else {
							const {
								powerups: t = null
							} = r.data.subredditInfoById || {};
							await s(N({
								powerups: t,
								subredditId: e
							}))
						}
					}
				} catch (l) {
					a.c.captureException(l), await s(M(n.fbt._("Something went wrong", null, {
						hk: "1IJNeH"
					})))
				}
			}, x = Object(r.a)(E.mb), N = Object(r.a)(E.lb), L = Object(r.a)(E.kb), U = Object(r.a)(E.jb), M = e => async (t, s) => {
				await t(U(e)), t(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: e
				}))
			}, F = Object(r.a)(E.U), G = Object(r.a)(E.V), B = Object(r.a)(E.W), q = e => async (t, s) => {
				await t(F(e)), t(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: e
				}))
			}, V = (e, t, s, r) => async (o, c, p) => {
				let {
					gqlContext: O
				} = p;
				o(G({
					subredditId: e,
					powerupsCount: t,
					isAnonymous: s,
					allocatedAt: r
				}));
				try {
					const a = {
							subredditId: e,
							powerupsCount: t,
							isAnonymous: s
						},
						p = await ((e, t) => Object(m.a)(e, Object.assign(Object.assign({}, b), {
							variables: t
						})))(O(), {
							input: a
						});
					let g = !1,
						f = null;
					if (p.ok) {
						const e = p.body;
						g = e.data.reallocatePowerups.ok, f = e.data.reallocatePowerups.errors
					}
					const j = Object(y.i)(c());
					if (g && j) await o((e => async (t, s) => {
						t(B(e)), t(k(e.subredditId, {
							forceLoad: !0
						})), e.powerupsCount && (t(Object(d.g)(i.a.ECON_POWERUPS_PURCHASE)), t(Object(u.e)({
							kind: l.b.SuccessCommunityGreen,
							duration: u.a,
							text: n.fbt._("Your free Powerup is applied.", null, {
								hk: "3WY7KP"
							})
						})))
					})({
						subredditId: e,
						powerupsCount: t,
						isAnonymous: s,
						user: j,
						allocatedAt: r
					}));
					else {
						const e = f && f[0] && f[0].message || n.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
						await o(q(e))
					}
				} catch (g) {
					a.c.captureException(g);
					const e = g,
						t = e && e.message || n.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
					await o(q(t))
				}
			}, H = Object(r.a)(E.H), K = Object(r.a)(E.S), W = () => async (e, t) => Object(y.i)(t()) ? Object(o.s)(i.a.ECON_POWERUPS_MARKETING) ? e(Object(d.h)(i.a.ECON_POWERUPS_PURCHASE)) : e(Object(d.h)(i.a.ECON_POWERUPS_MARKETING)) : e(Object(c.h)())
		},
		"./src/reddit/actions/gold/productOffers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return g
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/reddit/models/Toast/index.ts"),
				o = s("./src/graphql/operations/ProductOffers.json"),
				c = s("./src/lib/makeGqlRequest/index.ts");
			var d = s("./src/reddit/selectors/gold/productOffers.ts"),
				u = s("./src/reddit/actions/gold/constants.ts");
			const l = Object(r.a)(u.Z),
				b = Object(r.a)(u.Y),
				p = Object(r.a)(u.X),
				O = e => async (t, s) => {
					await t(p(e)), t(Object(a.e)({
						kind: i.b.Error,
						duration: a.a,
						text: e
					}))
				}, g = (e, t) => async (s, r, a) => {
					let {
						gqlContext: i
					} = a;
					const u = r();
					if (!Object(d.c)(u, {
							subredditId: e,
							type: t
						})) {
						s(l());
						try {
							const n = await ((e, t, s, n) => Object(c.a)(e, Object.assign(Object.assign({}, o), {
								variables: {
									subredditId: t,
									types: s,
									includeGlobal: n
								}
							})))(i(), e, [t], !0);
							if (n.ok) {
								const r = n.body;
								if (r.errors && r.errors.length) return void(await s(O(r.errors[0].message)));
								const a = r.data.subredditInfoById.productOffers ? r.data.subredditInfoById.productOffers.offers : [];
								return void(await s(b({
									productOffers: a || [],
									subredditId: e,
									type: t
								})))
							}
						} catch (p) {
							await s(O(n.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})))
						}
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/coinPurchaseModal.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return T
			})), s.d(t, "a", (function() {
				return w
			})), s.d(t, "d", (function() {
				return A
			})), s.d(t, "c", (function() {
				return D
			})), s.d(t, "i", (function() {
				return P
			})), s.d(t, "h", (function() {
				return R
			})), s.d(t, "e", (function() {
				return k
			})), s.d(t, "f", (function() {
				return x
			})), s.d(t, "g", (function() {
				return N
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/formatApiError/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/lib/sentry/index.ts"),
				o = s("./src/reddit/constants/modals.ts"),
				c = s("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				d = s("./src/reddit/actions/goldPurchaseModals/purchaseCatalog.ts"),
				u = s("./src/reddit/actions/modal.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				b = s("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				p = s("./src/reddit/endpoints/gold/purchase.ts"),
				O = s("./src/reddit/helpers/correlationIdTracker.ts"),
				g = s("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				f = s("./src/reddit/models/Gold/Award.ts"),
				m = s("./src/reddit/models/Gold/ProductOffer.ts"),
				j = s("./src/reddit/models/Toast/index.ts"),
				_ = s("./src/reddit/constants/experiments.ts"),
				h = s("./src/reddit/helpers/chooseVariant/index.ts");
			var y = s("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				E = s("./src/reddit/selectors/goldPurchaseModals.ts"),
				I = s("./src/reddit/actions/goldPurchaseModals/constants.ts");
			const v = Object(a.a)(I.o),
				S = Object(a.a)(I.c),
				T = e => async (t, s) => {
					t(v(e)), t(Object(u.h)(o.a.ECON_COIN_PURCHASE))
				}, w = () => async (e, t) => {
					e(S()), e(Object(u.g)(o.a.ECON_COIN_PURCHASE))
				}, C = Object(a.a)(I.s), A = e => {
					let {
						correlationId: t,
						packageId: s
					} = e;
					return async (e, n) => {
						const r = n(),
							a = Object(y.c)(r, s);
						a ? ("new_purchaser" !== a.dealInfo.type || (e => {
							const t = Object(h.c)(e, {
								experimentEligibilitySelector: h.a,
								experimentName: _.bb
							});
							return !(!t || Object(_.zc)(t))
						})(r)) && ("repeat_purchaser" !== a.dealInfo.type || (e => {
							const t = Object(h.c)(e, {
								experimentEligibilitySelector: h.a,
								experimentName: _.Z
							});
							return !(!t || Object(_.zc)(t))
						})(r)) && (e(C({
							correlationId: t,
							packageId: s
						})), e(Object(u.i)(o.a.GOLD_TARGETED_OFFER_MODAL))) : i.c.captureMessage("Tried to show targeted offer, but could not find package id: ".concat(s))
					}
				}, D = (e, t, s) => async (r, a) => {
					await r(Object(d.c)(e, s));
					const i = a(),
						o = Object(y.i)(i);
					if (0 !== o.length) r(T({
						correlationId: s,
						packageId: o[0].mobileId,
						thingId: t
					}));
					else {
						const e = Object(y.f)(i),
							t = n.fbt._("Unable to create purchase request.", null, {
								hk: "lgfDj"
							});
						r(Object(l.e)({
							kind: j.b.Error,
							duration: l.a,
							text: e || t
						}))
					}
				}, P = (e, t) => async (s, a, i) => {
					let {
						apiContext: o
					} = i;
					const d = a(),
						{
							coins: u,
							pennies: l
						} = t,
						b = Object(E.o)(d) || Object(O.d)(O.a.GoldPayment, !1);
					let g, f;
					s(Object(c.stripeTokenPending)());
					const j = Object(E.v)(d);
					if (j || (g = await s(Object(c.validateAndCreateStripeToken)(e)), f = Object(E.s)(d), g)) try {
						const e = await Object(p.e)({
							coins: u,
							context: o(),
							correlationId: b,
							offerContext: Object(m.b)(t, !1),
							pennies: l,
							rememberCard: f,
							savedCardId: j || void 0,
							token: g
						});
						if (e.error) {
							const t = Object(r.a)(e.error, e.status);
							return void s(Object(c.stripeApiError)(t))
						}
						return s(Object(c.paymentCompleted)({
							coins: e.body.coins ? e.body.coins : 0,
							confirmed: !1
						})), void Object(O.b)(O.a.GoldPayment)
					} catch (_) {
						const e = Object(r.a)(_);
						s(Object(c.stripeApiError)(e))
					} else {
						const e = n.fbt._("Looks like something went wrong validating your credit card.", null, {
							hk: "2OvpVH"
						});
						s(Object(c.stripeApiError)(e))
					}
				}, R = (e, t, a) => async (i, o, d) => {
					let {
						apiContext: u
					} = d;
					const l = o(),
						{
							coins: b,
							pennies: j
						} = t,
						_ = Object(E.o)(l) || Object(O.d)(O.a.GoldPayment, !1);
					let h, y;
					i(Object(c.stripeTokenPending)());
					const I = Object(E.v)(l);
					if (I || (h = await i(Object(c.validateAndCreateStripeToken)(e)), y = Object(E.s)(l), h)) try {
						const {
							gildModalThingId: e,
							isAnonymous: o,
							message: d,
							selectedAward: E
						} = l.gild;
						if (!e || !E.id) {
							const e = n.fbt._("Gilding unknown thing", null, {
								hk: "2Jiujp"
							});
							return void i(Object(c.stripeApiError)(e))
						}
						const v = E.id,
							S = {
								gildType: v,
								isAnonymous: o,
								message: d
							},
							T = await Object(p.d)({
								coins: b,
								context: u(),
								correlationId: _,
								gildParams: S,
								isOldReddit: a,
								offerContext: Object(m.b)(t, !0),
								pennies: j,
								rememberCard: y,
								savedCardId: I || void 0,
								thingId: e,
								token: h
							});
						if (T.error) {
							const e = Object(r.a)(T.error, T.status);
							return void i(Object(c.stripeApiError)(e))
						} {
							const {
								gildSuccessful: t
							} = await Promise.resolve().then(s.bind(null, "./src/reddit/actions/gold/gild.ts"));
							i(w()), i(Object(c.paymentCompleted)({
								confirmed: !1
							}));
							const {
								awarder_karma_received: n,
								all_awardings: r,
								coins: a,
								treatment_tags: o
							} = T.body;
							return i(t({
								awardKarmaReceived: n || 0,
								awardId: v,
								awardings: r && r.length ? Object(g.a)(r).map(e => ({
									award: Object(f.h)(e),
									total: e.count
								})) : [],
								coins: a,
								id: e,
								treatmentTags: o
							})), void Object(O.b)(O.a.GoldPayment)
						}
					} catch (v) {
						const e = Object(r.a)(v);
						i(Object(c.stripeApiError)(e))
					} else {
						const e = n.fbt._("Looks like something went wrong validating your credit card.", null, {
							hk: "2OvpVH"
						});
						i(Object(c.stripeApiError)(e))
					}
				}, k = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const o = Object(O.c)(O.a.GoldPayment),
						{
							coins: d,
							pennies: u
						} = e;
					try {
						const e = await Object(b.a)({
							context: a(),
							coins: d,
							pennies: u,
							correlationId: o
						});
						if (e.error) {
							const s = Object(r.a)(e.error);
							return void t(Object(c.paypalApiError)(s))
						} {
							const {
								order_id: t
							} = e.body;
							return t
						}
					} catch (l) {
						i.c.captureException(l);
						const e = Object(r.a)(l);
						t(Object(c.paypalApiError)(e))
					}
				}, x = (e, t) => async (s, n, a) => {
					let {
						apiContext: o
					} = a;
					const d = n(),
						u = Object(E.o)(d) || Object(O.d)(O.a.GoldPayment, !1),
						{
							coins: l,
							pennies: p
						} = t;
					try {
						const n = await Object(b.c)({
							context: o(),
							offerContext: Object(m.b)(t, !1),
							orderId: e,
							coins: l,
							pennies: p,
							correlationId: u
						});
						if (n.error) {
							const e = Object(r.a)(n.error);
							return void s(Object(c.paypalApiError)(e))
						} {
							const {
								coins: e
							} = n.body;
							s(Object(c.paymentCompleted)({
								coins: e,
								confirmed: !0
							})), Object(O.b)(O.a.GoldPayment)
						}
					} catch (g) {
						i.c.captureException(g);
						const e = Object(r.a)(g);
						s(Object(c.paypalApiError)(e))
					}
				}, N = (e, t) => async (a, o, d) => {
					let {
						apiContext: u
					} = d;
					const l = o(),
						p = Object(E.o)(l) || Object(O.d)(O.a.GoldPayment, !1),
						{
							coins: j,
							pennies: _
						} = t;
					try {
						const {
							gildModalThingId: i,
							isAnonymous: o,
							message: d,
							selectedAward: h
						} = l.gild;
						if (!i || !h) return void a(Object(c.paypalApiError)(n.fbt._("Gilding unknown post or comment", null, {
							hk: "4DkIS3"
						})));
						const y = h.id,
							E = await Object(b.d)({
								context: u(),
								offerContext: Object(m.b)(t, !0),
								orderId: e,
								coins: j,
								pennies: _,
								thingId: i,
								awardId: y,
								message: d || "",
								isAnonymous: o,
								correlationId: p
							});
						if (E.error) {
							const e = Object(r.a)(E.error);
							a(Object(c.paypalApiError)(e))
						} else {
							a(w());
							const {
								all_awardings: e,
								awarder_karma_received: t,
								coins: n,
								subreddit_coins: r,
								treatment_tags: o
							} = E.body;
							a(Object(c.paymentCompleted)({
								coins: n,
								confirmed: !0
							}));
							const {
								gildSuccessful: d
							} = await Promise.resolve().then(s.bind(null, "./src/reddit/actions/gold/gild.ts"));
							a(d({
								awardId: y,
								awardKarmaReceived: t || 0,
								awardings: Object(g.a)(e).map(e => ({
									award: Object(f.h)(e),
									total: e.count
								})),
								coins: n,
								id: i,
								subredditCoins: r,
								treatmentTags: o
							})), Object(O.b)(O.a.GoldPayment)
						}
					} catch (h) {
						i.c.captureException(h);
						const e = Object(r.a)(h);
						a(Object(c.paypalApiError)(e))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "g", (function() {
				return a
			})), s.d(t, "t", (function() {
				return i
			})), s.d(t, "u", (function() {
				return o
			})), s.d(t, "v", (function() {
				return c
			})), s.d(t, "w", (function() {
				return d
			})), s.d(t, "x", (function() {
				return u
			})), s.d(t, "y", (function() {
				return l
			})), s.d(t, "z", (function() {
				return b
			})), s.d(t, "A", (function() {
				return p
			})), s.d(t, "B", (function() {
				return O
			})), s.d(t, "C", (function() {
				return g
			})), s.d(t, "D", (function() {
				return f
			})), s.d(t, "f", (function() {
				return m
			})), s.d(t, "E", (function() {
				return j
			})), s.d(t, "F", (function() {
				return _
			})), s.d(t, "G", (function() {
				return h
			})), s.d(t, "i", (function() {
				return y
			})), s.d(t, "j", (function() {
				return E
			})), s.d(t, "k", (function() {
				return I
			})), s.d(t, "l", (function() {
				return v
			})), s.d(t, "m", (function() {
				return S
			})), s.d(t, "n", (function() {
				return T
			})), s.d(t, "h", (function() {
				return w
			})), s.d(t, "o", (function() {
				return C
			})), s.d(t, "s", (function() {
				return A
			})), s.d(t, "c", (function() {
				return D
			})), s.d(t, "p", (function() {
				return P
			})), s.d(t, "d", (function() {
				return R
			})), s.d(t, "q", (function() {
				return k
			})), s.d(t, "r", (function() {
				return x
			})), s.d(t, "e", (function() {
				return N
			}));
			const n = "GOLD_PAYMENT__CARD_NAME_EMPTY",
				r = "GOLD_PAYMENT__CARD_NAME_INPUT",
				a = "GOLD_PAYMENT__DELETE_SAVED_CARD",
				i = "GOLD_PAYMENT__PAYMENT_COMPLETED",
				o = "GOLD_PAYMENT__PAYPAL_API_ERROR",
				c = "GOLD_PAYMENT__SAVED_CARDS_PENDING",
				d = "GOLD_PAYMENT__SAVED_CARDS_SUCCESS",
				u = "GOLD_PAYMENT__SELECT_PAYMENT_METHOD",
				l = "GOLD_PAYMENT__SELECT_SAVED_CARD",
				b = "GOLD_PAYMENT__STRIPE_API_ERROR",
				p = "GOLD_PAYMENT__STRIPE_ELEMENT_CHANGE",
				O = "GOLD_PAYMENT__CARD_ERROR",
				g = "GOLD_PAYMENT__STRIPE_TOKEN_PENDING",
				f = "GOLD_PAYMENT__TOGGLE_REMEMBER_CARD",
				m = "UPDATE_CARD_MODAL__CLOSE_UPDATE_CARD_MODAL",
				j = "UPDATE_CARD_MODAL__UPDATE_CARD_FAILED",
				_ = "UPDATE_CARD_MODAL__UPDATE_CARD_PENDING",
				h = "UPDATE_CARD_MODAL__UPDATE_CARD_SUCCESSFUL",
				y = "GOLD_PURCHASE__FETCH_PURCHASE_CATALOG_ERROR",
				E = "GOLD_PURCHASE__FETCH_PURCHASE_CATALOG_REQUESTED",
				I = "GOLD_PURCHASE__FETCH_PURCHASE_CATALOG_SUCCESS",
				v = "GOLD_PURCHASE__FETCH_RECOMMENDED_PACKAGE_ERROR",
				S = "GOLD_PURCHASE__FETCH_RECOMMENDED_PACKAGE_REQUESTED",
				T = "GOLD_PURCHASE__FETCH_RECOMMENDED_PACKAGE_SUCCESS",
				w = "COIN_SALE__FETCH_ACTIVE_SALE_SUCCESS",
				C = "COIN_PURCHASE_MODAL__OPEN_COIN_PURCHASE_MODAL",
				A = "COIN_PURCHASE_MODAL__OPEN_TARGETED_OFFER_MODAL",
				D = "COIN_PURCHASE_MODAL__CLOSE_COIN_PURCHASE_MODAL",
				P = "PENNY_PURCHASE_MODAL__OPEN_PENNY_PURCHASE_MODAL",
				R = "PENNY_PURCHASE_MODAL__CLOSE_PENNY_PURCHASE_MODAL",
				k = "PENNY_PURCHASE_MODAL__OPEN_PENNY_PURCHASE_MODAL_TO_GILD",
				x = "PREMIUM_PURCHASE_MODAL__OPEN_PREMIUM_PURCHASE_MODAL",
				N = "PREMIUM_PURCHASE_MODAL__CLOSE_PREMIUM_PURCHASE_MODAL"
		},
		"./src/reddit/actions/goldPurchaseModals/payment.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "selectPaymentMethod", (function() {
				return d
			})), s.d(t, "paymentCompleted", (function() {
				return u
			})), s.d(t, "cardNameInput", (function() {
				return l
			})), s.d(t, "cardNameEmpty", (function() {
				return b
			})), s.d(t, "cardElementChange", (function() {
				return p
			})), s.d(t, "stripeTokenPending", (function() {
				return O
			})), s.d(t, "stripeTokenError", (function() {
				return g
			})), s.d(t, "stripeApiError", (function() {
				return f
			})), s.d(t, "validateAndCreateStripeToken", (function() {
				return m
			})), s.d(t, "paypalApiError", (function() {
				return j
			})), s.d(t, "toggleRememberCard", (function() {
				return _
			})), s.d(t, "selectSavedCard", (function() {
				return h
			})), s.d(t, "_deleteSavedCard", (function() {
				return y
			})), s.d(t, "deleteSavedCard", (function() {
				return E
			})), s.d(t, "savedCardsPending", (function() {
				return I
			})), s.d(t, "savedCardsSuccess", (function() {
				return v
			})), s.d(t, "loadSavedCards", (function() {
				return S
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/sentry/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/endpoints/gold/purchase.ts"),
				o = s("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				c = s("./src/reddit/selectors/goldPurchaseModals.ts");
			const d = Object(a.a)(o.x),
				u = Object(a.a)(o.t),
				l = Object(a.a)(o.b),
				b = Object(a.a)(o.a),
				p = Object(a.a)(o.A),
				O = Object(a.a)(o.C),
				g = Object(a.a)(o.B),
				f = Object(a.a)(o.z),
				m = e => async (t, s) => {
					const r = s(),
						a = Object(c.f)(r),
						{
							token: i,
							error: o
						} = await e.createToken({
							name: a
						});
					if (a.trim()) {
						if (!o && i) return i;
						t(g(o || void 0))
					} else {
						const e = n.fbt._("Your card’s name field is incomplete", null, {
							hk: "VBdRU"
						});
						t(b({
							message: e
						}))
					}
				}, j = Object(a.a)(o.u), _ = Object(a.a)(o.D), h = Object(a.a)(o.y), y = Object(a.a)(o.g), E = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					t(y(e));
					try {
						const t = await Object(i.a)(a(), e);
						if (t.error) throw new Error(t.error.type)
					} catch (o) {
						r.c.captureException(o)
					}
				}, I = Object(a.a)(o.v), v = Object(a.a)(o.w), S = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					e(I());
					try {
						const t = await Object(i.b)(n());
						if (t.error) throw new Error(t.error.type);
						const s = t.body.map(e => ({
							brand: e.brand,
							cardId: e.card_id,
							expirationMonth: e.exp_month,
							expirationYear: e.exp_year,
							last4: e.last4
						}));
						e(v(s)), s[0] && e(h(s[0].cardId))
					} catch (a) {
						r.c.captureException(a), e(v([]))
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "e", (function() {
				return g
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "d", (function() {
				return j
			}));
			var n = s("./src/config.ts"),
				r = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/formatApiError/index.ts"),
				c = s("./src/reddit/actions/goldPurchaseModals/payment.ts"),
				d = s("./src/reddit/endpoints/gold/paypalPurchases.ts"),
				u = s("./src/reddit/endpoints/gold/purchase.ts"),
				l = s("./src/reddit/helpers/correlationIdTracker.ts"),
				b = s("./src/reddit/actions/goldPurchaseModals/constants.ts");
			const p = Object(a.a)(b.r),
				O = Object(a.a)(b.e),
				g = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const d = i.ob,
						b = Object(l.c)(l.a.GoldPayment);
					t(Object(c.stripeTokenPending)());
					const p = await t(Object(c.validateAndCreateStripeToken)(e));
					if (p) try {
						const e = await Object(u.g)({
							context: a(),
							correlationId: b,
							pennies: d,
							token: p
						});
						if (e.error) {
							const s = Object(o.a)(e.error);
							t(Object(c.stripeApiError)(s))
						} else t(Object(c.paymentCompleted)({
							confirmed: !1
						}))
					} catch (O) {
						const e = Object(o.a)(O);
						t(Object(c.stripeApiError)(e))
					} else {
						const e = r.fbt._("Looks like something went wrong validating your credit card.", null, {
							hk: "4eGqpL"
						});
						t(Object(c.stripeApiError)(e))
					}
				}, f = "PREMIUM_PURCHASE_MODAL__PAYMENT_BLOB_CREATED", m = Object(a.a)(f), j = e => {
					let {
						correlationId: t
					} = e;
					return async (e, s, r) => {
						let {
							apiContext: a
						} = r;
						e(p({
							correlationId: t
						}));
						const i = n.a.paypal.buttons.premium;
						try {
							const s = await Object(d.f)({
								buttonId: i,
								context: a(),
								correlationId: t
							});
							if (s.error) {
								const t = Object(o.a)(s.error);
								e(Object(c.paypalApiError)(t))
							} else e(m(s))
						} catch (u) {
							const t = Object(o.a)(u);
							e(Object(c.paypalApiError)(t))
						}
					}
				}
		},
		"./src/reddit/actions/goldPurchaseModals/purchaseCatalog.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return w
			})), s.d(t, "c", (function() {
				return P
			})), s.d(t, "a", (function() {
				return k
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/env/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/lib/sentry/index.ts"),
				o = s("./src/graphql/operations/FetchActiveCoinSale.json"),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/makeApiRequest/index.ts"),
				u = s("./src/lib/makeGqlRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				b = s("./src/reddit/constants/headers.ts"),
				p = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				O = s("./src/reddit/endpoints/gold/purchase.ts");
			const g = e => ({
					baselineCoins: e.baseline_coins || e.coins,
					baselinePennies: e.baseline_pennies || e.pennies,
					bonusPct: e.bonus_pct,
					coins: e.coins,
					description: e.description,
					featured: e.featured,
					featuredLabel: e.featured_label,
					images: {
						marketing: e.images.marketing,
						purchaseSuccess: e.images.purchase_success
					},
					mobileId: e.mobile_id,
					pennies: e.pennies
				}),
				f = e => e.map(g),
				m = e => e.map(e => {
					const t = g(e);
					return Object.assign(Object.assign({}, t), {
						dealInfo: {
							type: e.deal_info.type,
							title: e.deal_info.title,
							subtitle: e.deal_info.subtitle,
							displayDelay: e.deal_info.display_delay
						}
					})
				}),
				j = e => e.map(e => ({
					description: e.description,
					frequency: e.frequency,
					frequencyDays: e.frequency_days,
					images: {
						marketing: e.images.marketing,
						purchaseSuccess: e.images.purchase_success
					},
					mobileId: e.mobile_id,
					mobilePennies: e.mobile_pennies,
					pennies: e.pennies,
					periodicalCoins: e.periodical_coins,
					signupBonusCoins: e.signup_bonus_coins
				})),
				_ = e => e ? {
					ctaText: e.cta_text,
					dropdownHeaderText: e.dropdown_banner_text,
					dropdownHeaderBackgroundAsset: e.dropdown_banner_image_url,
					endsAt: e.ends_at,
					heroImageUrl: e.hero_image_url,
					heroSubtext: e.hero_subtext,
					heroText: e.hero_text
				} : null;

			function h(e) {
				if (!e.ok) return e;
				const {
					active_sale: t,
					coin_packages: s,
					deals: n,
					premium_packages: r
				} = e.body, a = {
					activeSaleConfig: _(t),
					coinPackages: f(s),
					dealCoinPackages: m(n),
					premiumPackages: j(r)
				};
				return Object.assign(Object.assign({}, e), {
					body: a
				})
			}

			function y(e) {
				if (!e.ok) return e;
				const t = e.body,
					s = {
						coinPackages: f([t])
					};
				return Object.assign(Object.assign({}, e), {
					body: s
				})
			}
			var E = s("./src/reddit/selectors/user.ts"),
				I = s("./src/reddit/actions/goldPurchaseModals/constants.ts");
			const v = Object(a.a)(I.j),
				S = Object(a.a)(I.k),
				T = Object(a.a)(I.i),
				w = e => async (t, s, a) => {
					let {
						apiContext: o
					} = a;
					t(v());
					const u = s(),
						g = Object(E.H)(u);
					try {
						const s = !g,
							n = await (async e => {
								let {
									context: t,
									correlationId: s,
									shouldUseCurrentOrigin: n
								} = e;
								const r = "/api/v2/gold/purchase_package_details",
									a = n && "undefined" != typeof window ? "".concat(window.location.origin).concat(r) : "".concat(t.apiUrl).concat(r),
									i = Object(p.a)(a);
								return Object(d.a)(Object(l.a)(t, [b.a]), {
									method: c.db.GET,
									endpoint: i,
									data: {
										correlation_id: s
									}
								}).then(O.c).then(h)
							})({
								context: o(),
								correlationId: e,
								shouldUseCurrentOrigin: s
							});
						if (!n.ok) throw new Error(n.error && n.error.type || "Unknown error");
						const r = n.body;
						t(S(r))
					} catch (f) {
						Object(r.b)() || console.error(f), i.c.captureException(f);
						const e = n.fbt._("There was an error fetching available products", null, {
							hk: "1Uvx37"
						});
						t(T(e))
					}
				}, C = Object(a.a)(I.m), A = Object(a.a)(I.n), D = Object(a.a)(I.l), P = (e, t) => async (s, a, o) => {
					let {
						apiContext: u
					} = o;
					s(C());
					try {
						const n = await (async e => {
							let {
								context: t,
								awardId: s,
								correlationId: n
							} = e;
							const r = "".concat(t.apiUrl, "/api/v2/gold/recommended_coin_package_details"),
								a = Object(p.a)(r);
							return Object(d.a)(Object(l.a)(t, [b.a]), {
								method: c.db.GET,
								endpoint: a,
								data: {
									correlation_id: n,
									intended_award: s
								}
							}).then(O.c).then(y)
						})({
							awardId: e,
							context: u(),
							correlationId: t
						});
						if (!n.ok) throw new Error(n.error && n.error.type || "Unknown error");
						const r = n.body;
						if (!r.coinPackages || !r.coinPackages.length) throw new Error("Recommended coin packages returned empty for award id ".concat(e));
						s(A(r))
					} catch (g) {
						Object(r.b)() || console.error(g), i.c.captureException(g);
						const e = n.fbt._("There was an error fetching purchasable coins package", null, {
							hk: "47Fxzt"
						});
						s(D(e))
					}
				}, R = Object(a.a)(I.h), k = () => async (e, t, s) => {
					let {
						gqlContext: n
					} = s;
					try {
						const t = await (e => Object(u.a)(e, Object.assign({}, o)))(n());
						if (t.ok) {
							const s = t.body.data.coinSale;
							await e(R({
								activeSaleConfig: s
							}))
						}
						if (!t.ok) throw new Error("Got bad response in GQL call for active coin sale: ".concat(t))
					} catch (a) {
						Object(r.b)() || console.error(a), i.c.captureException(a)
					}
				}
		},
		"./src/reddit/actions/googleOneTap/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "b", (function() {
				return p
			})), s.d(t, "d", (function() {
				return O
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/login.ts"),
				a = s("./src/reddit/constants/experiments.ts"),
				i = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/selectors/activeModalId.ts"),
				c = s("./src/reddit/selectors/experiments/googleOneTap.ts"),
				d = s("./src/reddit/selectors/user.ts");
			const u = "GOOGLE_ONE_TAP_ENABLED",
				l = Object(n.a)(u),
				b = () => async (e, t) => {
					const s = t(),
						n = Object(d.H)(s),
						r = Object(c.b)(s);
					n && Object(c.d)(r) && e(l())
				}, p = () => async (e, t) => {
					const s = t(),
						n = Object(d.H)(s),
						a = Object(c.b)(s),
						i = !!Object(o.a)(s);
					n || i || !Object(c.e)(a) && !Object(c.d)(a) || e(Object(r.e)())
				}, O = e => {
					Object(i.d)(e, {
						experimentName: a.F
					})
				}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "k", (function() {
				return p
			})), s.d(t, "l", (function() {
				return O
			})), s.d(t, "m", (function() {
				return g
			})), s.d(t, "n", (function() {
				return f
			})), s.d(t, "o", (function() {
				return m
			})), s.d(t, "p", (function() {
				return j
			})), s.d(t, "q", (function() {
				return _
			})), s.d(t, "r", (function() {
				return h
			})), s.d(t, "s", (function() {
				return y
			})), s.d(t, "t", (function() {
				return E
			})), s.d(t, "u", (function() {
				return I
			})), s.d(t, "v", (function() {
				return v
			})), s.d(t, "w", (function() {
				return S
			})), s.d(t, "x", (function() {
				return T
			}));
			const n = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				r = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				a = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				i = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				o = "POLL_VOTE_SUCCESS",
				c = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				d = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				u = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				l = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				b = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				O = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				g = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				f = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				m = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				j = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				_ = "GOVERNANCE__TRANSFER_FAILURE",
				h = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				y = "GOVERNANCE__TRANSFER_PENDING",
				E = "GOVERNANCE__TRANSFER_SUCCESS",
				I = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				v = "GOVERNANCE__WALLETS_FETCH_PENDING",
				S = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				T = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/reddit/actions/toaster.ts"),
				r = s("./src/reddit/helpers/governanceErrorText/index.ts"),
				a = s("./src/reddit/models/Toast/index.ts");

			function i(e, t) {
				e(Object(n.e)({
					duration: 5e3,
					kind: a.b.Error,
					text: Object(r.a)(t)
				}))
			}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return n
			})), s.d(t, "g", (function() {
				return r
			})), s.d(t, "f", (function() {
				return a
			})), s.d(t, "l", (function() {
				return i
			})), s.d(t, "k", (function() {
				return o
			})), s.d(t, "j", (function() {
				return c
			})), s.d(t, "h", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "d", (function() {
				return O
			}));
			const n = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				a = "SUBREDDIT__FLAIRED_USERS_FAILED",
				i = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				o = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				c = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				d = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				O = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/harbergerTax/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "e", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			}));
			const n = "HARBERGER_TAX__BANNER_MANAGE_MODAL_OPENED",
				r = "HARBERGER_TAX__BANNER_PURCHASE_MODAL_OPENED",
				a = "HARBERGER_TAX__BANNER_CRYPTO_MANAGE_MODAL_OPENED",
				i = "HARBERGER_TAX__BANNER_CRYPTO_PURCHASE_MODAL_OPENED",
				o = "HARBERGER_TAX__BANNER_PURCHASE_FAILURE",
				c = "HARBERGER_TAX__BANNER_PURCHASE_PENDING",
				d = "HARBERGER_TAX__BANNER_PURCHASE_SUCCESS",
				u = "HARBERGER_TAX__BANNER_UPDATE_FAILURE",
				l = "HARBERGER_TAX__BANNER_UPDATE_PENDING",
				b = "HARBERGER_TAX__BANNER_UPDATE_SUCCESS"
		},
		"./src/reddit/actions/header.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return r
			})), s.d(t, "e", (function() {
				return a
			})), s.d(t, "i", (function() {
				return i
			})), s.d(t, "j", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "h", (function() {
				return p
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "HEADER__SUBSCRIPTIONS_PINNED",
				a = "HEADER__SUBSCRIPTIONS_UNPINNED",
				i = Object(n.a)(r),
				o = Object(n.a)(a),
				c = "HEADER__DROPDOWN_CLOSED",
				d = "HEADER__DROPDOWN_OPENED",
				u = "HEADER__DROPDOWN_TOGGLED",
				l = Object(n.a)(c),
				b = Object(n.a)(d),
				p = Object(n.a)(u)
		},
		"./src/reddit/actions/imageOCRAltText/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = "IMAGE_OCR_ALT_TEXT__LOADED",
				r = "IMAGE_OCR_ALT_TEXT__FAILED"
		},
		"./src/reddit/actions/imageUploads.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "a", (function() {
				return p
			})), s.d(t, "k", (function() {
				return O
			})), s.d(t, "j", (function() {
				return g
			})), s.d(t, "l", (function() {
				return f
			})), s.d(t, "i", (function() {
				return m
			})), s.d(t, "h", (function() {
				return j
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "f", (function() {
				return y
			})), s.d(t, "m", (function() {
				return E
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/sentry/index.ts"),
				a = s("./src/lib/uploadToS3/index.ts"),
				i = s("./src/reddit/helpers/getGenericUploadError.ts"),
				o = s("./src/reddit/models/Image/index.tsx"),
				c = s("./src/reddit/selectors/imageUploads.ts");
			const d = "IMAGE_UPLOADS__IMAGE_UPLOAD_PENDING",
				u = "IMAGE_UPLOADS__IMAGE_UPLOAD_LOADED",
				l = "IMAGE_UPLOADS__IMAGE_UPLOAD_SAVED",
				b = "IMAGE_UPLOADS__IMAGE_UPLOAD_FAILED",
				p = "IMAGE_UPLOADS__IMAGE_UPLOAD_CANCELED",
				O = Object(n.a)(d),
				g = Object(n.a)(u),
				f = Object(n.a)(l),
				m = Object(n.a)(b),
				j = Object(n.a)(p),
				_ = async (e, t, s, n) => {
					if (!t.ok) throw Object(o.k)(s, t.error);
					let r, i = t.body;
					"s3UploadLease" in i && (i = i.s3UploadLease, r = t.body.websocketUrl);
					const c = await Object(a.a)(s.file, i);
					if (c.ok) {
						if (!e.imageUploads[s.id]) return void Object(o.d)(s);
						const t = decodeURIComponent(c.body.PostResponse.Location);
						return Object(o.n)(s, t, r, n)
					}
					throw Object(o.k)(s, c.error)
				};

			function h(e) {
				return e.split("/").pop()
			}
			const y = (e, t) => new Promise((s, n) => {
					const a = Object(c.c)(e, t);
					if (!a.length) return s(null);
					const i = a[0].websocketUrl;
					if (!i) return n(new Error("ImageUploads: No websocket URL found"));
					const o = {};
					for (let e = 0; e < a.length; e++) {
						const t = a[e],
							s = h(t.url);
						o[s] = t
					}
					const d = a.length,
						u = new WebSocket(i);
					u.onopen = e => {
						u.onerror = null, s({
							websocket: u,
							imagesByKey: o,
							imageCount: d
						})
					}, u.onerror = e => {
						u.close();
						const t = new Error("ImageUploads: Failed to connect to websocket");
						r.c.captureException(t), n()
					}
				}),
				E = e => (t, s, n) => {
					let {
						apiContext: a
					} = n;
					return new Promise((s, n) => {
						const {
							websocket: a
						} = e;
						let {
							imageCount: c,
							imagesByKey: d
						} = e;

						function u() {
							for (const e in d) {
								const s = d[e],
									n = Object(o.o)(s, s.url);
								t(f(n))
							}
							s(), a.close()
						}
						d = Object.assign({}, d);
						let l = setTimeout(u, 6e4);
						a.onmessage = e => {
							clearTimeout(l);
							const n = JSON.parse(e.data);
							if (n && "success" === n.type) {
								const e = n.payload.url,
									s = h(e),
									r = d[s];
								if (!r) return;
								c -= 1, delete r[s];
								const a = Object(o.o)(r, e);
								t(f(a))
							} else {
								const e = h(n.payload.image_key),
									s = d[e];
								if (!s) return;
								c -= 1, delete s[e];
								const r = Object(i.a)(n.payload.image_key),
									a = Object(o.k)(s, r);
								t(m(a))
							}
							c ? l = setTimeout(u, 6e4) : (a.close(), s())
						}, a.onerror = e => {
							clearTimeout(l);
							const s = Object(i.a)("websocket");
							for (const n in d) {
								const e = d[n],
									r = Object(o.k)(e, s);
								t(m(r))
							}
							a.close();
							const c = new Error("ImageUploads: WebSocket connection failed before all messages received");
							r.c.captureException(c), n()
						}
					})
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "INCONTEXT__BANNED",
				a = "INCONTEXT__MUTED",
				i = Object(n.a)(r),
				o = Object(n.a)(a)
		},
		"./src/reddit/actions/inFeedChaining.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return h
			})), s.d(t, "d", (function() {
				return I
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "a", (function() {
				return S
			})), s.d(t, "e", (function() {
				return w
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/telemetry/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/lib/makeListingKey/index.ts"),
				c = s("./src/reddit/actions/discoveryUnit.ts"),
				d = s("./src/reddit/actions/subreddit/similarSubreddit.ts"),
				u = s("./src/reddit/actions/subreddit/subredditPosts.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				b = s("./src/reddit/constants/inFeedChaining.ts"),
				p = s("./src/reddit/constants/page.ts"),
				O = s("./src/reddit/helpers/localStorage/index.ts"),
				g = s("./src/reddit/helpers/trackers/discoveryUnit.ts"),
				f = s("./src/reddit/models/Toast/index.ts"),
				m = s("./src/reddit/selectors/inFeedChaining.ts"),
				j = s("./src/reddit/selectors/posts.ts"),
				_ = s("./src/reddit/selectors/subreddit.ts");
			const h = "FEED_CHAINING__CHAIN_LOADED",
				y = Object(i.a)(h),
				E = e => {
					const t = Date.now() - e,
						s = Object(O.u)();
					return Object.keys(s).filter(e => s[e].when >= t).map(e => s[e])
				},
				I = e => {
					let {
						listingName: t,
						listingKey: s,
						postId: n
					} = e;
					return async (e, i, l) => {
						if (!n) return;
						const f = Object(j.ab)(i(), {
							postId: n
						});
						if (!f) return;
						const h = f.name.toLowerCase(),
							I = t === h;
						if (!(t === p.f || t === p.b || I)) return;
						if (I) return void C(f, s, n)(e, i, l);
						0 === E(a.fb).length && Object(O.eb)(!1);
						let v = i();
						if (Object(m.d)(v, {
								listingKey: s,
								postId: n
							}) || Object(m.a)(v).length >= b.a || Object(O.F)() || E(a.x).length >= b.a) return;
						const S = Object(j.C)(v, {
							listingKey: s,
							postId: n
						});
						if (S && S.isSponsored) return;
						await e(Object(c.g)()), v = i();
						const T = Object(m.b)(v, {
							listingName: t
						});
						if (!T) return;
						if (!f || Object(m.e)(v, {
								subredditId: f.id
							}) || (e => {
								return E(a.x).some(t => t.subredditId === e)
							})(f.id)) return;
						const w = {
							subredditIds: [f.id],
							count: b.b
						};
						await e(Object(d.b)(w));
						const A = Object(d.a)(w);
						v = i();
						const D = Object(_.w)(v, {
							key: A
						});
						0 !== D.length ? (await e((e => async (t, s) => {
							const n = a.Sb.DAY.toUpperCase(),
								r = e.filter(e => {
									const t = Object(o.a)(e, a.O.TOP, {
										t: n
									});
									return 0 === Object(j.H)(s(), {
										listingKey: t
									}).length
								});
							await t(Object(u.b)({
								first: 1,
								range: n,
								sort: a.I.TOP,
								subredditNames: r
							}))
						})(D.map(e => e.name))), v = i(), Object(m.f)(v, {
							postId: n
						}).length < b.c ? Object(r.a)(Object(g.c)(T, "other", f)(v)) : (Object(O.a)(n, f.id), Object(r.a)(Object(g.d)(T, f)(v)), e(y({
							listingKey: s,
							postId: n
						})))) : Object(r.a)(Object(g.c)(T, "no_chaining", f)(v))
					}
				},
				v = "FEED_CHAINING__CHAIN_TOGGLED",
				S = (Object(i.a)(v), "FEED_CHAINING__CHAINING_TOGGLED"),
				T = Object(i.a)(S),
				w = () => async e => {
					Object(O.eb)(!0), e(T({
						isDismissed: !0
					})), e(Object(l.e)(Object(l.d)(n.fbt._("You'll see this less often.", null, {
						hk: "38LGcQ"
					}), f.b.Undo, n.fbt._("Undo", null, {
						hk: "4zFGDk"
					}), async () => {
						Object(O.eb)(!1), e(T({
							isDismissed: !1
						}))
					})))
				}, C = (e, t, s) => async (e, t, s) => {}
		},
		"./src/reddit/actions/inbox.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "INBOX__COUNT_UPDATE",
				a = Object(n.a)(r)
		},
		"./src/reddit/actions/inboxNotifications/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = "INBOX_NOTIFICATIONS__PENDING",
				r = "INBOX_NOTIFICATIONS__LOADED",
				a = "INBOX_NOTIFICATIONS__FAILED"
		},
		"./src/reddit/actions/interceptedAction.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "INTERCEPTED_ACTION_SET",
				a = "INTERCEPTED_ACTION_UNSET",
				i = Object(n.a)(r),
				o = Object(n.a)(a)
		},
		"./src/reddit/actions/isTrackingCrossposts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return o
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/endpoints/post/index.tsx");
			const a = "TRACKING_CROSSPOSTS_LOADED",
				i = Object(n.a)(a),
				o = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					const o = await Object(r.e)(a(), {
						postId: e
					});
					if (o.ok) {
						const {
							isTrackingCrossposts: s
						} = o.body.data.postInfoById;
						t(i({
							[e]: s
						}))
					}
				}
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "JSAPI__CONSUMER_SUBSCRIBED",
				a = Object(n.a)(r)
		},
		"./src/reddit/actions/leaderboard/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			}));
			const n = "LEADERBOARD__LEADERBOARD_FETCH_FAILURE",
				r = "LEADERBOARD__LEADERBOARD_FETCH_PENDING",
				a = "LEADERBOARD__LEADERBOARD_FETCH_SUCCESS"
		},
		"./src/reddit/actions/linkedPosts/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = "LINKED_POSTS__POSTS_LOADED",
				r = "LINKED_POSTS__POSTS_FAILED"
		},
		"./src/reddit/actions/login.ts": function(e, t, s) {
			"use strict";
			s.d(t, "h", (function() {
				return c
			})), s.d(t, "i", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "a", (function() {
				return p
			})), s.d(t, "f", (function() {
				return O
			})), s.d(t, "j", (function() {
				return g
			})), s.d(t, "g", (function() {
				return f
			})), s.d(t, "k", (function() {
				return m
			})), s.d(t, "e", (function() {
				return j
			}));
			var n = s("./src/reddit/actions/modal.ts"),
				r = s("./src/reddit/actions/preferences.ts"),
				a = s("./src/reddit/constants/modals.ts"),
				i = s("./src/reddit/constants/postLayout.ts");
			const o = e => async (t, s) => {
				t(Object(n.i)(e)), !s().user.prefs.layout && t(Object(r.w)(i.d.Card))
			}, c = () => async (e, t) => {
				e(o(a.a.LOGIN_MODAL_ID))
			}, d = () => async e => {
				e(o(a.a.REGISTER_MODAL_ID))
			}, u = () => async e => {
				e(o(a.a.CHANGE_PASSWORD_MODAL_ID))
			}, l = () => async e => {
				e(o(a.a.ENABLE_TWO_FACTOR))
			}, b = () => async e => {
				e(o(a.a.DISABLE_TWO_FACTOR))
			}, p = () => async e => {
				e(o(a.a.TWO_FACTOR_BACKUP_CODES))
			}, O = () => async e => {
				e(o(a.a.LINK_APPLE_SSO))
			}, g = () => async e => {
				e(o(a.a.UNLINK_APPLE_SSO))
			}, f = () => async e => {
				e(o(a.a.LINK_GOOGLE_SSO))
			}, m = () => async e => {
				e(o(a.a.UNLINK_GOOGLE_SSO))
			}, j = () => async e => {
				e(o(a.a.GOOGLE_ONE_TAP_MODAL_ID))
			}
		},
		"./src/reddit/actions/media.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return p
			})), s.d(t, "d", (function() {
				return g
			})), s.d(t, "h", (function() {
				return f
			})), s.d(t, "b", (function() {
				return m
			})), s.d(t, "e", (function() {
				return j
			})), s.d(t, "i", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "g", (function() {
				return y
			})), s.d(t, "a", (function() {
				return E
			})), s.d(t, "j", (function() {
				return v
			}));
			var n = s("./src/lib/ads/index.ts"),
				r = s("./src/lib/ads/store.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeApiRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/reddit/constants/headers.ts"),
				u = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				l = s("./src/reddit/models/Media/index.ts"),
				b = s("./src/reddit/actions/video.ts");
			const p = "MEDIA__SET_MUTE",
				O = Object(a.a)(p),
				g = "MEDIA__SET_VOLUME",
				f = Object(a.a)(g),
				m = "MEDIA__SET_CURRENT_SLIDE_INDEX",
				j = "TOGGLE_GALLERY_LAYOUT",
				_ = Object(a.a)(j),
				h = Object(a.a)(m),
				y = (e, t, s) => async (a, i) => {
					a(O(e)), !e && s && (r.e(s, e, n.m.muted), a(Object(b.C)(t, s)))
				}, E = "MEDIA__EMBED_HEIGHT_MEASURED", I = Object(a.a)(E), v = e => {
					let {
						height: t,
						isDeleted: s,
						postId: n
					} = e;
					return async (e, r, a) => {
						let {
							apiContext: b
						} = a;
						const p = r(),
							{
								media: O
							} = p.posts.models[n];
						e(I({
							height: t,
							isDeleted: s,
							postId: n
						})), null !== O && O.type === l.o.EMBED && O.provider === l.v.Twitter && O.height !== t && await ((e, t, s) => Object(o.a)(Object(c.a)(e, [d.a]), {
							endpoint: Object(u.a)("".concat(e.apiUrl, "/api/set_twitter")),
							method: i.db.POST,
							data: {
								height: s,
								link: t
							}
						}))(b(), n.substr(3), t)
					}
				}
		},
		"./src/reddit/actions/meta.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "META__GEO_CHANGED",
				a = Object(n.a)(r),
				i = "META__META_RECEIVED";
			Object(n.a)(i)
		},
		"./src/reddit/actions/modMode.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			})), s.d(t, "b", (function() {
				return l
			}));
			s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/@reddit/onetrust-integration/dist/esm/index.js"),
				r = s("./node_modules/js-cookie/src/js.cookie.js"),
				a = s.n(r),
				i = s("./src/config.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/reddit/constants/cookie.ts");
			const d = "MOD_MODE_TOGGLED",
				u = Object(o.a)(d),
				l = e => async (t, s, r) => {
					let o, {
						apiContext: d
					} = r;
					if (void 0 !== e) o = e;
					else {
						o = "false" === a.a.get(c.c)
					}
					Object(n.b)(c.c, o, {
						domain: i.a.cookieDomain
					}), (document.cookie.match(/mod_mode_enabled=/g) || []).length > 1 && Object(n.b)(c.c, "", {
						expires: 0,
						path: "/"
					});
					t(u({
						enabled: o
					}))
				}
		},
		"./src/reddit/actions/modQueue/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "j", (function() {
				return n
			})), s.d(t, "i", (function() {
				return r
			})), s.d(t, "h", (function() {
				return a
			})), s.d(t, "g", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "n", (function() {
				return d
			})), s.d(t, "m", (function() {
				return u
			})), s.d(t, "l", (function() {
				return l
			})), s.d(t, "q", (function() {
				return b
			})), s.d(t, "p", (function() {
				return p
			})), s.d(t, "o", (function() {
				return O
			})), s.d(t, "w", (function() {
				return g
			})), s.d(t, "v", (function() {
				return f
			})), s.d(t, "u", (function() {
				return m
			})), s.d(t, "t", (function() {
				return j
			})), s.d(t, "s", (function() {
				return _
			})), s.d(t, "r", (function() {
				return h
			})), s.d(t, "k", (function() {
				return y
			})), s.d(t, "b", (function() {
				return E
			})), s.d(t, "a", (function() {
				return I
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "d", (function() {
				return S
			}));
			const n = "MODQUEUE_PENDING",
				r = "MODQUEUE_LOADED",
				a = "MODQUEUE_FAILED",
				i = "EDITED_PENDING",
				o = "EDITED_LOADED",
				c = "EDITED_FAILED",
				d = "REPORTS_PENDING",
				u = "REPORTS_LOADED",
				l = "REPORTS_FAILED",
				b = "SPAM_PENDING",
				p = "SPAM_LOADED",
				O = "SPAM_FAILED",
				g = "UNMODERATED_PENDING",
				f = "UNMODERATED_LOADED",
				m = "UNMODERATED_FAILED",
				j = "UNDOACTION_PENDING",
				_ = "UNDOACTION_LOADED",
				h = "UNDOACTION_FAILED",
				y = "MORE_MODERATED_SUBREDDITS_LOADED",
				E = "ALL_MODERATED_COMMUNITIES_LOADED",
				I = "ADD_SELECTED_ITEMS",
				v = "BULK_SELECT_ITEMS",
				S = "BULK_UNSELECT_ITEMS"
		},
		"./src/reddit/actions/modal.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return b
			})), s.d(t, "i", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "f", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "g", (function() {
				return m
			})), s.d(t, "h", (function() {
				return j
			})), s.d(t, "j", (function() {
				return _
			})), s.d(t, "e", (function() {
				return h
			})), s.d(t, "a", (function() {
				return y
			})), s.d(t, "k", (function() {
				return E
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/changeUsername.ts"),
				a = s("./src/reddit/actions/header.ts"),
				i = (s("./src/reddit/actions/media.ts"), s("./src/reddit/constants/modals.ts")),
				o = s("./src/reddit/endpoints/user/index.ts"),
				c = s("./src/reddit/helpers/localStorage/index.ts"),
				d = s("./src/reddit/selectors/activeModalId.ts"),
				u = s("./src/reddit/selectors/header.ts"),
				l = s("./src/reddit/selectors/user.ts");
			const b = "MODAL_TOGGLED",
				p = Object(n.a)(b),
				O = "CLOSE_ALL_MODALS",
				g = Object(n.a)(O),
				f = "REDESIGN_MODAL_CLOSED",
				m = (Object(n.a)(f), e => async (t, s, n) => {
					Object(d.b)(e)(s()) && t(p(e))
				}),
				j = e => async (t, s, n) => {
					const o = s();
					if (!Object(d.b)(e)(o)) {
						if ((e === i.a.MULTIREDDIT_CREATE || e === i.a.MULTIREDDIT_ADD_SUBREDDIT) && Object(l.J)(o)) {
							Object(u.a)(o) && t(Object(a.f)());
							const s = p(e);
							return void t(Object(r.f)(s))
						}
						t(p(e))
					}
				}, _ = () => async (e, t, s) => {
					Object(c.cb)(i.a.REDESIGN_MODAL, !0), Object(l.H)(t()) && Object(o.e)(s.apiContext())
				}, h = "SET_ACCOUNT_MANAGER_MODAL_DATA";
			var y;
			! function(e) {
				e.HeaderLogin = "header_login", e.HeaderSignup = "header_signup", e.Hide = "hide", e.IdCard = "id_card", e.NotificationsInbox = "notifications_inbox", e.Post = "post", e.PromoBanner = "promo", e.Reply = "reply", e.Report = "report", e.SubredditLeaderboard = "subreddit_leaderboard", e.Save = "save", e.Subscribe = "subscribe", e.Vote = "vote"
			}(y || (y = {}));
			const E = Object(n.a)(h)
		},
		"./src/reddit/actions/moderatingSubreddits.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return c
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/profile/index.ts"),
				a = (s("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"), s("./src/reddit/models/User/index.ts")),
				i = s("./src/reddit/selectors/user.ts");
			const o = "MOD_PERMS__REQUEST_LOADED",
				c = (Object(n.a)("MOD_PERMS__REQUEST_PENDING"), Object(n.a)(o), Object(n.a)("MOD_PERMS__REQUEST_FAILED"), () => async (e, t) => {
					const s = Object(i.i)(t());
					if (s) {
						const t = Object(a.e)(s);
						await e(Object(r.b)(t))
					}
				})
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = "SUBREDDIT__MODERATION_LOG_LOADED",
				r = "SUBREDDIT__ALL_MODERATORS_LOADED"
		},
		"./src/reddit/actions/multireddit/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "q", (function() {
				return n
			})), s.d(t, "r", (function() {
				return r
			})), s.d(t, "s", (function() {
				return a
			})), s.d(t, "t", (function() {
				return i
			})), s.d(t, "u", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "g", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "l", (function() {
				return O
			})), s.d(t, "m", (function() {
				return g
			})), s.d(t, "k", (function() {
				return f
			})), s.d(t, "n", (function() {
				return m
			})), s.d(t, "o", (function() {
				return j
			})), s.d(t, "p", (function() {
				return _
			})), s.d(t, "a", (function() {
				return h
			})), s.d(t, "b", (function() {
				return y
			})), s.d(t, "c", (function() {
				return E
			})), s.d(t, "A", (function() {
				return I
			})), s.d(t, "B", (function() {
				return v
			})), s.d(t, "z", (function() {
				return S
			})), s.d(t, "y", (function() {
				return T
			})), s.d(t, "v", (function() {
				return w
			})), s.d(t, "w", (function() {
				return C
			})), s.d(t, "x", (function() {
				return A
			})), s.d(t, "d", (function() {
				return D
			}));
			const n = "MULTIREDDIT__MORE_POSTS_FAILED",
				r = "MULTIREDDIT__MORE_POSTS_LOADED",
				a = "MULTIREDDIT__MORE_POSTS_PENDING",
				i = "MULTIREDDIT__MY_MULTIREDDITS_PENDING",
				o = "MULTIREDDIT__MY_MULTIREDDITS_RECEIVED",
				c = "MULTIREDDIT__CREATE_FAILURE",
				d = "MULTIREDDIT__CREATE_PENDING",
				u = "MULTIREDDIT__CREATE_SUCCESS",
				l = "MULTIREDDIT__DELETE_PENDING",
				b = "MULTIREDDIT__DELETE_SUCCESS",
				p = "MULTIREDDIT__DELETE_FAILURE",
				O = "MULTIREDDIT__DUPLICATE_PENDING",
				g = "MULTIREDDIT__DUPLICATE_SUCCESS",
				f = "MULTIREDDIT__DUPLICATE_FAILURE",
				m = "MULTIREDDIT__EDIT_FAILURE",
				j = "MULTIREDDIT__EDIT_PENDING",
				_ = "MULTIREDDIT__EDIT_SUCCESS",
				h = "MULTIREDDIT__ADD_SUBREDDIT_FAILURE",
				y = "MULTIREDDIT__ADD_SUBREDDIT_PENDING",
				E = "MULTIREDDIT__ADD_SUBREDDIT_SUCCESS",
				I = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_PENDING",
				v = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_SUCCESS",
				S = "MULTIREDDIT__SUBREDDIT_RECOMMENDATIONS_FAILURE",
				T = 10,
				w = "MULTIREDDIT__REMOVE_SUBREDDIT_FAILURE",
				C = "MULTIREDDIT__REMOVE_SUBREDDIT_PENDING",
				A = "MULTIREDDIT__REMOVE_SUBREDDIT_SUCCESS";
			var D;
			! function(e) {
				e.InvalidSrQuarantine = "INVALID_SR_QUARANTINE", e.TooManySubreddits = "MULTI_TOO_MANY_SUBREDDITS"
			}(D || (D = {}))
		},
		"./src/reddit/actions/multireddit/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return G
			})), s.d(t, "g", (function() {
				return V
			})), s.d(t, "b", (function() {
				return Y
			})), s.d(t, "d", (function() {
				return Z
			})), s.d(t, "a", (function() {
				return se
			})), s.d(t, "i", (function() {
				return ie
			})), s.d(t, "c", (function() {
				return ue
			})), s.d(t, "e", (function() {
				return Oe
			})), s.d(t, "h", (function() {
				return je
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./node_modules/react-router-redux/es/index.js"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/linkMatchers/customLinks.ts"),
				d = s("./src/lib/makeActionCreator/index.ts"),
				u = s("./src/lib/makeListingKey/index.ts"),
				l = s("./src/reddit/actions/modal.ts"),
				b = s("./src/reddit/actions/page.ts"),
				p = s("./src/reddit/actions/toaster.ts"),
				O = s("./src/reddit/constants/parameters.ts"),
				g = s("./src/lib/makeApiRequest/index.ts"),
				f = s("./src/lib/omitHeaders/index.ts"),
				m = s("./src/reddit/constants/headers.ts"),
				j = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				_ = s("./src/graphql/operations/AllUserMultireddits.json"),
				h = s("./src/lib/makeGqlRequest/index.ts"),
				y = (e, t) => Object(h.a)(e, Object.assign(Object.assign({}, _), {
					variables: t
				})),
				E = s("./src/reddit/endpoints/page/multiredditListing.ts"),
				I = s("./src/graphql/operations/SubredditRecommendations.json"),
				v = s("./src/reddit/helpers/filterListingResponse/index.ts"),
				S = s("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				T = s("./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts"),
				w = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				C = (s("./node_modules/core-js/modules/es6.regexp.split.js"), e => {
					let t = e.over_18 || !1;
					if (!t)
						for (const i of e.subreddits)
							if (i.data.over_18) {
								t = !0;
								break
							} let s = e.quarantine || !1;
					if (!s)
						for (const i of e.subreddits) {
							const e = (i.data.audience_target || "").split(",");
							if (i.data.quarantine || e.indexOf("unsafe") > -1) {
								s = !0;
								break
							}
						}
					const n = e.subreddits.map(e => {
							const t = e.data,
								{
									name: s,
									display_name: n
								} = t;
							return {
								id: s,
								displayName: n.toLowerCase()
							}
						}).sort((e, t) => e.displayName.localeCompare(t.displayName)),
						r = n.filter(e => !e.displayName.startsWith(o.Ub)).map(e => e.id),
						a = n.filter(e => e.displayName.startsWith(o.Ub)).map(e => e.id);
					return {
						created: e.created_utc,
						description: e.description_md,
						descriptionHtml: e.description_html,
						descriptionRtJson: null,
						displayText: e.display_name,
						followerCount: e.num_subscribers,
						icon: e.icon_url,
						isFavorited: !!e.is_favorited,
						isFollowed: !1,
						isNSFW: t,
						isQuarantined: s,
						name: e.name,
						ownerId: e.owner_id,
						profileIds: a,
						subredditCount: e.subreddits.length,
						subredditIds: r,
						url: e.path.toLowerCase(),
						visibility: e.visibility
					}
				}),
				A = s("./src/reddit/models/Multireddit/index.ts"),
				D = s("./src/reddit/models/Toast/index.ts"),
				P = s("./src/reddit/selectors/multireddit.ts"),
				R = s("./src/reddit/selectors/platform.ts"),
				k = s("./src/reddit/selectors/subreddit.ts"),
				x = s("./src/reddit/selectors/user.ts"),
				N = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				L = s("./src/reddit/actions/multireddit/constants.ts");
			const U = Object(d.a)(L.q),
				M = Object(d.a)(L.r),
				F = Object(d.a)(L.s),
				G = e => async (t, s, n) => {
					const {
						gqlContext: r
					} = n, {
						sort: a = o.O.HOT,
						multiredditName: i,
						username: c
					} = e, d = s(), l = d.platform.currentPage, b = l ? l.queryParams : {}, p = Object(P.d)(d, {
						multiredditName: i,
						username: c
					}), O = Object(u.a)(p.url, a, b), g = d.listings.postOrder.loadMore[O];
					if (!g) return;
					const f = d.listings.postOrder.api.pending[O],
						m = d.listings.postOrder.fetchedTokens,
						j = m[O] && m[O][g.token] || !1;
					if (f || j) return;
					t(F({
						key: O,
						fetchedToken: g.token
					}));
					const _ = p.url.replace(/\/$/, ""),
						h = b.t ? b.t.toUpperCase() : void 0,
						y = {
							after: g.token,
							includeIdentity: !1,
							includeSources: !1,
							path: _,
							range: h,
							sort: a.toUpperCase()
						},
						I = await Object(E.a)(r(), y),
						{
							data: S
						} = I.body,
						w = Object(T.a)(S);
					I.ok && S && S.multireddit ? t(M(Object.assign(Object.assign(Object.assign({
						fetchedToken: g.token,
						key: O,
						meta: d.meta
					}, w), Object(v.a)(d, O, w)), {
						multiredditsModelsState: d.multireddits.models
					}))) : t(U(Object.assign(Object.assign({
						error: {
							type: o.E.NOT_FOUND_ERROR
						},
						fetchedToken: g.token,
						key: O
					}, I.body), Object(v.a)(d, O, w))))
				}, B = Object(d.a)(L.t), q = Object(d.a)(L.u), V = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (s, n, r) => {
						let {
							apiContext: a,
							gqlContext: i
						} = r;
						const o = n();
						if (!Object(x.i)(o)) return;
						if (!e && Object(P.h)(o) || Object(P.i)(o)) return;
						s(B());
						const c = await y(i(), {
							includeSources: t
						});
						if (c.ok) {
							const e = c.body.data.identity.allMultireddits.edges.map(e => e.node),
								t = Object(S.b)(e);
							s(q(Object.assign(Object.assign({}, t), {
								multiredditsModelsState: o.multireddits.models
							})))
						}
					}
				}, H = Object(d.a)(L.e), K = Object(d.a)(L.f), W = Object(d.a)(L.g), Y = e => {
					let {
						description: t,
						displayName: s,
						shouldNavigate: r
					} = e;
					return async (e, a, c) => {
						let {
							apiContext: d
						} = c;
						const u = a(),
							b = Object(x.i)(u);
						if (!b) return;
						e(K());
						const O = await ((e, t, s) => Object(g.a)(Object(f.a)(e, [m.a]), {
							endpoint: Object(j.a)("".concat(e.apiUrl, "/api/multi")),
							data: {
								model: JSON.stringify({
									description_md: s,
									display_name: t,
									visibility: "private",
									subreddits: []
								})
							},
							method: o.db.POST
						}))(d(), s, t);
						if (O.ok) {
							const {
								id: t
							} = b;
							if (await e(W({
									multireddit: C(O.body.data),
									multiredditsModelsState: u.multireddits.models,
									userId: t
								})), r) {
								e(Object(l.f)());
								const t = O.body.data.path.toLowerCase();
								await e(Object(i.b)(t))
							}
							e(Object(p.e)({
								text: n.fbt._("Custom feed created!", null, {
									hk: "258cY9"
								})
							}))
						} else e(H(O.error))
					}
				}, z = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t(),
						i = Object(x.i)(r),
						c = Object(R.i)(r) ? Object(R.m)(r) : Object(R.b)(r),
						d = c && c.routeMatch && c.routeMatch.match;
					if (!d) return;
					const l = d.params,
						p = l.sort || o.O.HOT,
						{
							multiredditName: g,
							username: f
						} = l;
					if (!g) return;
					const m = Object(A.h)((f || i && i.displayText || "").toLowerCase(), g.toLowerCase()),
						{
							queryParams: j
						} = d,
						_ = Object(u.a)(m, p, j),
						h = O.x in j && j[O.x].toUpperCase() || "",
						y = o.Sb[h] || !1,
						E = Object(x.i)(r);
					(f || E && E.displayText) && await e(Object(b.B)(_, (f || E.displayText).toLowerCase(), g.toLowerCase(), Object.assign(Object.assign(Object.assign({}, a()(j, O.l)), a()(j, O.k)), {
						sort: p,
						t: Object(N.a)(p, y)
					})))
				}, J = Object(d.a)(L.k), Q = Object(d.a)(L.l), X = Object(d.a)(L.m), Z = e => {
					let {
						description: t,
						displayName: s,
						fromName: r,
						fromUsername: a
					} = e;
					return async (e, c, d) => {
						let {
							apiContext: u
						} = d;
						const b = c(),
							O = Object(x.i)(b);
						if (!O || !O.displayText) return;
						const _ = Object(A.h)((a || O.displayText).toLowerCase(), r.toLowerCase());
						e(Q());
						const h = await ((e, t) => Object(g.a)(Object(f.a)(e, [m.a]), {
							endpoint: Object(j.a)("".concat(e.apiUrl, "/api/multi/copy")),
							data: {
								description_md: t.description,
								display_name: t.displayName,
								expand_srs: !0,
								from: t.from
							},
							method: o.db.POST
						}))(u(), {
							from: _,
							displayName: s,
							description: t
						});
						if (h.ok) {
							const t = C(h.body.data);
							e(Object(l.f)()), e(X({
								multireddit: t,
								multiredditsModelsState: b.multireddits.models,
								userId: O.id
							})), e(Object(p.e)({
								text: n.fbt._("Custom feed duplicated!", null, {
									hk: "2u48X"
								}),
								buttonText: n.fbt._("Go there", null, {
									hk: "4sXZMm"
								}),
								buttonAction: Object(i.b)(t.url)
							}))
						} else e(J(h.error)), e(Object(p.e)({
							text: n.fbt._("Something went wrong duplicating {multiName}", [n.fbt._param("multiName", r)], {
								hk: "4bzN2D"
							})
						}))
					}
				}, $ = Object(d.a)(L.b), ee = Object(d.a)(L.c), te = Object(d.a)(L.a), se = e => {
					let {
						communityInfo: t,
						identifier: s,
						multiredditNames: r
					} = e;
					return async (e, a, i) => {
						let {
							apiContext: d
						} = i;
						const u = a(),
							b = Object(x.i)(u);
						if (!b || u.multireddits.api.addSubreddit.pending) return;
						e($({
							name: s.name
						}));
						const {
							displayText: O
						} = b;
						if (!O) return;
						const _ = r.map(e => "/user/".concat(O.toLowerCase(), "/m/").concat(e.toLowerCase())).join(","),
							h = "".concat("profile" === s.type ? o.Ub : "").concat(s.name),
							y = await ((e, t, s) => Object(g.a)(Object(f.a)(e, [m.a]), {
								endpoint: Object(j.a)("".concat(e.apiUrl, "/api/multi/bulk_add/r/").concat(t)),
								data: {
									paths: s
								},
								method: o.db.PUT
							}))(d(), h, _);
						if (y.ok) {
							const a = Object(k.L)(u, {
									identifier: s
								}) || t && t.id || "",
								i = r.map(e => Object(A.h)(O, e));
							e(Object(l.f)()), e(Object(p.e)({
								text: n.fbt._({
									"*": "Successfully added {communityName} to {number} custom feeds!",
									_1: "Successfully added {communityName} to 1 custom feed!"
								}, [n.fbt._param("communityName", "".concat("subreddit" === s.type ? c.d.subreddit : c.d.profile).concat(s.name)), n.fbt._plural(r.length, "number")], {
									hk: "9EXsM"
								})
							})), await e(ee({
								communityInfo: t,
								id: a,
								multipaths: i,
								type: s.type
							})), 1 === r.length && await e(z())
						} else {
							e(te(y.error));
							let t = n.fbt._("Sorry, something went wrong adding {subredditName}.", [n.fbt._param("subredditName", s.name)], {
								hk: "ERdWO"
							});
							y.body && (y.body.reason === L.d.TooManySubreddits ? t = n.fbt._("Maximum communities reached", null, {
								hk: "2eguyW"
							}) : y.body.reason === L.d.InvalidSrQuarantine && (t = n.fbt._("{communityname} is invalid because it is quarantined", [n.fbt._param("communityname", "".concat("subreddit" === s.type ? c.d.subreddit : c.d.profile).concat(s.name))], {
								hk: "407xmS"
							}))), e(Object(p.e)({
								text: t,
								kind: D.b.Error
							}))
						}
					}
				}, ne = Object(d.a)(L.w), re = Object(d.a)(L.x), ae = Object(d.a)(L.v), ie = e => {
					let {
						id: t,
						multiredditName: s,
						name: r,
						type: a
					} = e;
					return async (e, i, c) => {
						let {
							apiContext: d
						} = c;
						const u = i(),
							b = Object(x.i)(u);
						if (!b || !b.displayText || u.multireddits.api.removeSubreddit.pending) return;
						e(ne({
							id: t
						}));
						const {
							displayText: O
						} = b, _ = Object(A.h)(O, s), h = "".concat("profile" === a ? o.Ub : "").concat(r), y = await ((e, t, s) => Object(g.a)(Object(f.a)(e, [m.a]), {
							endpoint: Object(j.a)("".concat(e.apiUrl, "/api/multi").concat(s, "r/").concat(t)),
							method: o.db.DELETE
						}))(d(), h, _);
						y.ok ? (e(Object(l.f)()), e(re({
							id: t,
							multipath: _,
							type: a
						})), e(Object(p.e)({
							text: n.fbt._("{subredditname} removed from your custom feed!", [n.fbt._param("subredditname", r)], {
								hk: "uaWNe"
							}),
							buttonText: n.fbt._("undo", null, {
								hk: "3HH7IT"
							}),
							buttonAction: se({
								identifier: {
									name: r,
									type: a
								},
								multiredditNames: [s]
							})
						})), e(z())) : (e(ae(y.error)), e(Object(p.e)({
							text: n.fbt._("Sorry, something went wrong removing {subredditName}.", [n.fbt._param("subredditName", r)], {
								hk: "1E1rKm"
							})
						})))
					}
				}, oe = Object(d.a)(L.h), ce = Object(d.a)(L.i), de = Object(d.a)(L.j), ue = e => async (t, s, r) => {
					let {
						apiContext: a
					} = r;
					const c = s();
					if (!Object(x.i)(c)) return;
					t(ce());
					const d = await ((e, t) => Object(g.a)(Object(f.a)(e, [m.a]), {
						endpoint: Object(j.a)("".concat(e.apiUrl, "/api/multi").concat(t)),
						method: o.db.DELETE
					}))(a(), e);
					d.ok ? (await t(de(e)), t(Object(l.f)()), await t(Object(i.b)("/")), t(Object(p.e)({
						text: n.fbt._("Custom feed deleted!", null, {
							hk: "aWGMo"
						})
					}))) : t(oe(d.error))
				}, le = Object(d.a)(L.n), be = Object(d.a)(L.o), pe = Object(d.a)(L.p), Oe = e => {
					let {
						description: t,
						displayText: s,
						multipath: r,
						visibility: a
					} = e;
					return async (e, i, c) => {
						let {
							apiContext: d
						} = c;
						const u = i();
						if (!Object(x.H)(u)) return;
						e(be());
						const b = await (e => {
							let {
								context: t,
								description: s,
								displayText: n,
								multipath: r,
								visibility: a
							} = e;
							return Object(g.a)(Object(f.a)(t, [m.a]), {
								endpoint: Object(j.a)("".concat(t.apiUrl, "/api/multi").concat(r)),
								data: {
									model: JSON.stringify({
										description_md: s,
										display_name: n,
										visibility: a
									}),
									expand_srs: !0
								},
								method: o.db.PUT
							})
						})({
							context: d(),
							description: t,
							displayText: s,
							multipath: r,
							visibility: a
						});
						b.ok ? (await e(pe(C(b.body.data))), e(Object(l.f)()), e(Object(p.e)({
							text: n.fbt._("Custom feed updated!", null, {
								hk: "39R30f"
							})
						}))) : (e(le(b.error)), e(Object(p.e)({
							kind: D.b.Error,
							text: n.fbt._("Something went wrong", null, {
								hk: "1Y6lli"
							})
						})))
					}
				}, ge = Object(d.a)(L.z), fe = Object(d.a)(L.A), me = Object(d.a)(L.B), je = e => {
					let {
						multiredditName: t,
						username: s,
						toExcludeNames: n
					} = e;
					return async (e, r, a) => {
						let {
							gqlContext: i
						} = a;
						const o = r(),
							c = Object(x.i)(o);
						if (!(s || c && c.displayText)) return;
						const d = Object(A.h)(s || c.displayText, t),
							u = o.multireddits.models[d];
						if (!u || !u.subredditIds) return;
						e(fe());
						const l = n && n.reduce((e, t) => {
								const s = Object(k.G)(o, t) || Object(k.H)(o, t);
								return s ? [...e, s] : e
							}, []),
							b = await ((e, t) => Object(h.a)(e, Object.assign(Object.assign({}, I), {
								variables: t
							})))(i(), {
								count: L.y,
								subredditIds: u.subredditIds,
								toExclude: l
							});
						if (b.ok) {
							const {
								data: t
							} = b.body;
							e(me({
								multipath: d,
								subreddits: Object(w.b)(t)
							}))
						} else e(ge(b.error))
					}
				}
		},
		"./src/reddit/actions/notificationBanner.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "NOTIFICATION_BANNER_SET",
				a = "NOTIFICATION_BANNER_DISMISSED",
				i = Object(n.a)(r),
				o = Object(n.a)(a)
		},
		"./src/reddit/actions/notificationSettingsLayout/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			}));
			const n = "NOTIFICATION_SETTINGS_LAYOUT__PENDING",
				r = "NOTIFICATION_SETTINGS_LAYOUT__LOADED",
				a = "NOTIFICATION_SETTINGS_LAYOUT__FAILED",
				i = "NOTIFICATION_SETTINGS_LAYOUT_UPDATED"
		},
		"./src/reddit/actions/notifications/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			}));
			const n = "PUSH__GET_PREFERENCES_PENDING",
				r = "PUSH__GET_PREFERENCES_LOADED",
				a = "PUSH__GET_PREFERENCES_FAILED",
				i = "PUSH__SET_PREFERENCES_PENDING",
				o = "PUSH__SET_PREFERENCES_LOADED",
				c = "PUSH__SET_PREFERENCES_FAILED"
		},
		"./src/reddit/actions/nps.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "d", (function() {
				return h
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/config.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/reddit/constants/headers.ts");
			var d = s("./node_modules/@r/frames/compiled.js"),
				u = s("./node_modules/lodash/debounce.js"),
				l = s.n(u),
				b = function(e) {
					document.body.appendChild(function(e) {
						let t;
						const s = l()((function() {
							t && t.contentWindow && d.postMessage(t.contentWindow, "resize.asknicely")
						}), 500);
						return function() {
							return t = function() {
								const t = document.createElement("iframe");
								return t.src = e, t.setAttribute("allowTransparency", "true"), t.style.display = "block", t.style.width = "100%", t.style.height = "1px", t.style.background = "transparent", t.style.border = "none", t
							}(), d.listen("embedjail"), d.receiveMessage(t.contentWindow, "open.embedjail", (function(e) {
								var n;
								n = e.detail, t.style.width = n.dimensions.width, t.style.height = n.dimensions.height, t.style.display = "block", t.style.position = "fixed", t.style.bottom = 0, t.style.zIndex = 2147483647, window.addEventListener("resize", s)
							})), d.receiveMessage(t.contentWindow, "close.embedjail", (function(e) {
								t.parentElement.removeChild(t), d.stopListening("asknicely"), window.removeEventListener("resize", s), t = void 0
							})), window.addEventListener("message", (function(e) {
								"https://live.asknice.ly" !== e.origin && "https://reddit.asknice.ly" !== e.origin || e.data && t && t.contentWindow && d.postMessage(t.contentWindow, e.data + ".asknicely")
							})), t
						}
					}(e)())
				};
			const p = "NPS__URL_PENDING",
				O = "NPS__URL_LOADED",
				g = "NPS__URL_FAILED",
				f = Object(n.a)(p),
				m = Object(n.a)(O),
				j = Object(n.a)(g);
			let _ = !1;
			const h = () => async (e, t, s) => {
				const n = t();
				if (n.nps.pending) return;
				if (_) return;
				e(f());
				const d = n.platform.currentPage && n.platform.currentPage.queryParams.feature || "",
					u = !!n.user.account,
					l = await ((e, t, s) => Object(i.a)(Object(o.a)(e, [c.a]), {
						data: {
							feature: t,
							app_name: "web2x"
						},
						endpoint: "".concat(s ? r.a.oauthUrl : r.a.apiUrl, "/api/jail/asknicely").concat(s ? "" : ".json"),
						method: a.db.GET,
						traceRequestName: "get_nps_survey"
					}))(s.apiContext(), d, u);
				if (l.ok) {
					const t = l.body;
					t.dest ? (e(m(t)), b(t.dest), _ = !0) : e(j())
				} else e(j())
			}
		},
		"./src/reddit/actions/oldSiteRules.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			})), s.d(t, "b", (function() {
				return u
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts"),
				o = s("./src/reddit/constants/headers.ts");
			const c = "OLD_SITE_RULES_LOADED",
				d = Object(n.a)(c),
				u = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const c = await (e => Object(a.a)(Object(i.a)(e, [o.a]), {
						endpoint: "".concat(e.apiUrl, "/api/site_rules.json"),
						method: r.db.GET
					}))(n());
					if (c.ok) {
						const {
							site_rules: t
						} = c.body;
						e(d({
							oldSiteRules: t
						}))
					}
				}
		},
		"./src/reddit/actions/page.ts": function(e, t, s) {
			"use strict";
			s.d(t, "m", (function() {
				return ze
			})), s.d(t, "i", (function() {
				return Je
			})), s.d(t, "G", (function() {
				return Qe
			})), s.d(t, "h", (function() {
				return Xe
			})), s.d(t, "g", (function() {
				return Ze
			})), s.d(t, "f", (function() {
				return $e
			})), s.d(t, "w", (function() {
				return nt
			})), s.d(t, "y", (function() {
				return it
			})), s.d(t, "d", (function() {
				return ot
			})), s.d(t, "b", (function() {
				return ct
			})), s.d(t, "a", (function() {
				return dt
			})), s.d(t, "s", (function() {
				return lt
			})), s.d(t, "r", (function() {
				return bt
			})), s.d(t, "t", (function() {
				return pt
			})), s.d(t, "q", (function() {
				return Ot
			})), s.d(t, "c", (function() {
				return gt
			})), s.d(t, "z", (function() {
				return mt
			})), s.d(t, "A", (function() {
				return jt
			})), s.d(t, "n", (function() {
				return _t
			})), s.d(t, "F", (function() {
				return ht
			})), s.d(t, "x", (function() {
				return Et
			})), s.d(t, "l", (function() {
				return It
			})), s.d(t, "k", (function() {
				return vt
			})), s.d(t, "j", (function() {
				return St
			})), s.d(t, "B", (function() {
				return At
			})), s.d(t, "C", (function() {
				return Dt
			})), s.d(t, "e", (function() {
				return Pt
			})), s.d(t, "p", (function() {
				return Rt
			})), s.d(t, "o", (function() {
				return kt
			})), s.d(t, "D", (function() {
				return xt
			})), s.d(t, "E", (function() {
				return Nt
			})), s.d(t, "u", (function() {
				return Lt
			})), s.d(t, "v", (function() {
				return Ut
			})), s.d(t, "H", (function() {
				return Mt
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./node_modules/react-router-redux/es/index.js"),
				o = s("./src/lib/addQueryParams/index.ts"),
				c = s("./src/lib/getParsedUserAgent/index.ts"),
				d = s("./src/reddit/actions/category/index.ts"),
				u = s("./src/reddit/actions/discoveryUnit.ts"),
				l = s("./src/reddit/actions/focusedVerticals/index.ts"),
				b = s("./src/reddit/actions/multireddit/index.ts"),
				p = s("./src/reddit/actions/pages/subreddit.ts"),
				O = s("./src/reddit/actions/pages/userDataRequest/index.ts"),
				g = s("./src/reddit/actions/shortcuts/active.ts"),
				f = s("./src/reddit/actions/subredditSettings.ts"),
				m = s("./src/reddit/endpoints/governance/posts.ts"),
				j = s("./src/reddit/endpoints/page/commentsPage.ts"),
				_ = s("./src/reddit/endpoints/page/frontpage.ts"),
				h = s("./src/reddit/endpoints/page/multiredditListing.ts"),
				y = s("./src/reddit/endpoints/page/subredditPage.ts"),
				E = s("./src/reddit/endpoints/profile/info.ts"),
				I = s("./src/reddit/models/Gold/ProductOffer.ts"),
				v = s("./src/reddit/models/Post/index.ts"),
				S = s("./src/lib/constants/index.ts"),
				T = (s("./src/lib/makeDraftKey/index.ts"), s("./src/lib/opener/index.ts")),
				w = s("./src/lib/pageTitle.ts"),
				C = (s("./src/reddit/models/PostDraft/index.ts"), s("./src/reddit/actions/dashboard.ts"), s("./src/reddit/actions/economics/helpers/async.ts")),
				A = s("./src/reddit/actions/externalAccount.ts"),
				D = s("./src/reddit/actions/gold/modals.ts"),
				P = s("./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts"),
				R = s("./src/reddit/actions/login.ts"),
				k = s("./src/reddit/actions/otherDiscussions/constants.ts"),
				x = s("./src/config.ts"),
				N = s("./src/lib/makeActionCreator/index.ts"),
				L = s("./src/reddit/actions/platform.ts"),
				U = s("./src/reddit/endpoints/me/index.ts"),
				M = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				F = s("./src/reddit/actions/pages/appeal/constants.ts");
			const G = "".concat(x.a.redditHelpUrl, "/en/categories/rules-reporting/account-and-community-restrictions/my-account-was-suspended-or-locked"),
				B = Object(N.a)(F.b),
				q = Object(N.a)(F.a);
			var V = s("./src/reddit/actions/post.ts"),
				H = s("./src/reddit/actions/profile/index.ts"),
				K = s("./src/reddit/actions/redditEmbed.ts"),
				W = s("./src/reddit/actions/subreddit.ts"),
				Y = s("./src/reddit/actions/toaster.ts"),
				z = s("./src/reddit/actions/users.ts"),
				J = s("./src/reddit/constants/adEvents.ts"),
				Q = s("./src/reddit/constants/graphql.ts"),
				X = s("./src/reddit/constants/page.ts"),
				Z = s("./src/reddit/constants/parameters.ts"),
				$ = s("./src/reddit/constants/postLayout.ts"),
				ee = s("./src/reddit/constants/posts.ts"),
				te = s("./src/reddit/contexts/PageLayer/index.tsx"),
				se = s("./src/reddit/helpers/commentList/index.ts"),
				ne = s("./src/reddit/helpers/frontpageCardPostCountExperiment.ts"),
				re = s("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				ae = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				ie = s("./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts"),
				oe = s("./src/reddit/models/Comment/index.ts"),
				ce = s("./src/reddit/models/Media/index.ts"),
				de = s("./src/reddit/models/Multireddit/index.ts"),
				ue = s("./src/reddit/models/Subreddit/index.ts"),
				le = s("./src/reddit/models/Toast/index.ts"),
				be = s("./src/reddit/models/User/index.ts"),
				pe = s("./src/reddit/selectors/category.ts"),
				Oe = s("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				ge = s("./src/reddit/selectors/experiments/frontpageSignup.ts"),
				fe = s("./src/reddit/selectors/experiments/goldSubredditPowerups.ts"),
				me = s("./src/reddit/selectors/experiments/listingBelow.ts"),
				je = s("./src/reddit/selectors/experiments/postSeo.ts"),
				_e = s("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				he = s("./src/reddit/selectors/frontpage.ts"),
				ye = s("./src/reddit/selectors/goldPurchaseModals.ts"),
				Ee = s("./src/reddit/selectors/inlineSubredditEditing.ts"),
				Ie = s("./src/reddit/selectors/multireddit.ts"),
				ve = s("./src/reddit/selectors/platform.ts"),
				Se = s("./src/reddit/selectors/posts.ts"),
				Te = s("./src/reddit/selectors/runTimeEnvVars.ts"),
				we = s("./src/reddit/selectors/seo/index.ts"),
				Ce = s("./src/reddit/selectors/subreddit.ts"),
				Ae = s("./src/reddit/selectors/user.ts"),
				De = s("./src/lib/makeCommentsPageKey/index.ts"),
				Pe = s("./src/lib/makeListingKey/index.ts"),
				Re = s("./src/lib/matchRoute/index.ts"),
				ke = s("./src/reddit/actions/ads/index.ts"),
				xe = s("./src/reddit/helpers/canonicalUrls.ts"),
				Ne = s("./src/reddit/helpers/chooseVariant/index.ts"),
				Le = s("./src/reddit/helpers/correlationIdTracker.ts"),
				Ue = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				Me = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				Fe = s("./src/reddit/actions/gold/powerups.ts"),
				Ge = s("./src/reddit/actions/gold/productOffers.ts"),
				Be = s("./src/reddit/actions/seo/linksModule.ts"),
				qe = s("./src/reddit/actions/subreddit/subredditPosts.ts"),
				Ve = s("./src/reddit/selectors/chatPost.ts"),
				He = s("./src/reddit/selectors/realtimeComments.ts"),
				Ke = s("./src/reddit/selectors/seo/linksModule.ts"),
				We = s("./src/reddit/actions/publicAccessNetwork/api.ts"),
				Ye = s("./src/reddit/actions/publicAccessNetwork/constants.ts");
			s("./src/reddit/actions/publicAccessNetwork/streams.ts");
			const ze = 25,
				Je = 100,
				Qe = function(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					return async (s, n, r) => {
						let {
							routes: a
						} = r;
						const o = n();
						Object(Re.a)(e, a, o) ? s(Object(i.b)(e)) : t ? Object(T.d)(e, "_blank") : window.location.assign(e)
					}
				},
				Xe = "PAGE__FRONTPAGE_PENDING",
				Ze = "PAGE__FRONTPAGE_LOADED",
				$e = "PAGE__FRONTPAGE_FAILED",
				et = Object(N.a)(Xe),
				tt = Object(N.a)(Ze),
				st = Object(N.a)($e),
				nt = (e, t) => async (s, r, a) => {
					const i = r();
					if (i.listings.postOrder.api.pending[e]) return;
					const o = $.e[Object(te.N)(i, {})];
					t.isMobile = Object(c.e)(i.meta.userAgent), t.recentPostIds = i.posts.recent, t.layout = o, t.useMockData = !!i.platform.currentPage && (!!i.platform.currentPage.queryParams.useMockData && Object(Te.b)(i)), s(et({
						key: e
					})); {
						const e = i.platform.currentPage,
							s = e && e.url;
						s && (t.clickUrl = s)
					}
					const d = await Object(Ue.a)("index", () => Object(_.a)(a.gqlContext(), Object(_.b)(i, t), Object(Ae.O)(i), t.statsdPathsForExperiments));
					s(Object(L.m)(d.status));
					const u = "error-".concat(e);
					if (d.ok) {
						const t = d.body;
						s(tt(Object.assign({
							key: e,
							meta: i.meta
						}, t))), s(Y.f(u)), s(Object(ke.b)(Me.a.FRONTPAGE))
					} else s(st(Object.assign({
						error: d.error,
						key: e
					}, d.body))), s(Y.e({
						id: u,
						kind: le.b.Error,
						text: n.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "36ypKx"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: nt(e, t)
					}))
				}, rt = (e, t) => async (s, n) => {
					const r = n(),
						i = Object(he.a)(r),
						{
							sort: o = i
						} = e.params,
						c = Object(Pe.a)(X.a, o, e.queryParams),
						d = r.listings.postOrder.ids[c],
						u = r.listings.postOrder.api.error[c],
						l = r.listings.postOrder.api.pending[c],
						b = Z.x in e.queryParams && e.queryParams[Z.x].toUpperCase() || "",
						p = b in S.Sb && S.Sb[b];
					if (l || d && !u && !t) return void(d && (s(L.l({
						title: w.c()
					})), r.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						s(Object(ke.b)(Me.a.FRONTPAGE))
					})));
					const O = Object(ne.a)(r),
						g = Object(ne.b)(O),
						f = [Object(ne.c)(O)];
					await s(nt(c, Object.assign(Object.assign(Object.assign({}, a()(e.queryParams, Z.l)), a()(e.queryParams, Z.k)), {
						limit: g,
						sort: o,
						statsdPathsForExperiments: f,
						t: Object(ae.a)(o, p)
					}))), s(L.l({
						title: w.c()
					})), Object(Ne.c)(r, {
						experimentEligibilitySelector: Ne.a,
						experimentName: "redesign_aa"
					});
					const m = Object(ge.a)(r, {});
					Object(ge.e)(m) && s(Object(R.i)())
				}, at = () => async (e, t) => {
					const s = t();
					if (!Object(Ke.a)(s)) return e(Object(Be.c)())
				}, it = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					await Promise.all([s(Object(l.b)()), s(rt(e, t)), s(at()), s(Object(We.c)(Ye.R))])
				}, ot = "PAGE__COMMENTSPAGE_PENDING", ct = "PAGE__COMMENTSPAGE_LOADED", dt = "PAGE__COMMENTSPAGE_FAILED", ut = Object(N.a)(ot), lt = Object(N.a)(ct), bt = Object(N.a)(dt), pt = e => async (t, s) => {
					const {
						partialPostId: n,
						partialCommentId: r
					} = e.params, {
						subredditName: a
					} = e.params || "", o = n ? Object(v.m)(n) : "", c = r && Object(oe.e)(r), {
						path: u,
						queryParams: l
					} = e, b = Object(k.d)(u), p = s(), {
						instanceId: O
					} = l, {
						hasSortParam: f,
						sortToUse: m
					} = Object(re.a)(p, o), j = ["context", "depth", "limit", Z.f].reduce((e, t) => {
						const s = parseInt(l[t]);
						return isNaN(s) || (e[t] = s), e
					}, {
						subredditName: a,
						hasSortParam: f,
						instanceId: O,
						include_categories: !0
					});
					f && (j.sort = m), j.onOtherDiscussions = b, t(V.l(o)), await t(Ot(o, c, j, m));
					const _ = s().posts.models[o],
						h = Object(Ae.H)(s());
					if (_ && "subreddit" === _.belongsTo.type && Object(fe.a)(p)) {
						const e = _.belongsTo.id,
							s = [...h ? [t(Object(Fe.g)())] : [], t(Object(Fe.f)(e, {
								fullData: !0
							})), t(Object(Ge.a)(e, I.a.Powerups))];
						await Promise.all(s)
					}
					if (_) {
						const n = ((e, t) => {
								const s = Object(Se.ab)(e, {
										postId: t
									}),
									n = Object(Se.N)(e, {
										postId: t
									});
								if (!s || !n) return "";
								const r = e.posts.models[t].title;
								return "".concat(r, " : ").concat(s.name)
							})(s(), o),
							r = Object(Ce.M)(s(), {
								identifier: _.belongsTo
							});
						if ((_.media && _.media.type) === ce.o.LIVEVIDEO) {
							const e = Object(_e.d)(p),
								s = _.belongsTo.type === ee.a.SUBREDDIT,
								n = e && s ? r.url : "/",
								a = Object(v.n)(_.id),
								o = "/rpan".concat(n).concat(a);
							return void t(Object(i.c)(o))
						}
						if (_.belongsTo.type !== ee.a.SUBREDDIT || _.isSponsored) _.belongsTo.type === ee.a.PROFILE && await t(H.d(r.name));
						else {
							!!Object(Ce.R)(p, {
								subredditId: _.belongsTo.id
							}) || await t(W.o(r.name))
						}
						const a = Object(me.b)(p),
							c = !!Object(we.b)(p, {
								identifier: _.belongsTo
							}),
							u = !!a,
							l = b,
							O = !u && (c || !0) && (!Object(ue.g)(r) && !Object(Ve.d)(p, {
								postId: o
							}) && !!r || !Object(ve.i)(p) && Object(je.d)(p)),
							f = !!Object(je.b)(p, _, !1) && !1;
						if (l || O || u || f) {
							Object(Le.d)(Le.a.LinkedPosts);
							const e = Object(Le.c)(Le.a.LinkedPosts),
								s = {
									adContext: {
										layout: Q.a.Card,
										reddaid: p.user.reddaid,
										sourcePostId: o
									},
									range: S.Sb.WEEK.toUpperCase(),
									sort: S.I.TOP,
									subredditName: r.name
								},
								n = {
									postId: o
								},
								a = {
									correlationId: e
								},
								i = t(Object(qe.a)(Object.assign(Object.assign(Object.assign(Object.assign({}, n), s), a), {
									includePostImageOCRAltText: f,
									includeListingBelowExperiment: u,
									includeOtherDiscussions: l,
									includePostFeed: O
								})));
							(O && c || f) && await i
						}
						t(Object(A.p)()), t(L.l({
							title: n
						}));
						const m = s().posts.instances[o] ? e.queryParams.instanceId : _.postId;
						t(Object(g.b)(m)); {
							const e = Object(pe.d)(s(), {
								subredditName: r.name
							});
							await Promise.all(e.map(e => t(d.c(e))))
						}
					} else t(L.l({
						title: w.c()
					}));
					const {
						routePrefix: y
					} = e.params;
					ee.b[y] === ee.a.PROFILE ? Object(xe.d)(s(), t, e) : Object(xe.b)(s(), t, e)
				}, Ot = (e, t, s, n) => async (r, a, i) => {
					var o;
					const c = a(),
						d = Object(De.a)(e, t, s),
						{
							subredditName: l
						} = s,
						b = c.commentsPage.keyToHeadCommentId.hasOwnProperty(d),
						O = c.commentsPage.api.fullyLoaded[d],
						g = c.commentsPage.api.error[d],
						f = c.commentsPage.api.pending[d],
						_ = !Object(Ae.G)(c),
						h = Object(Ae.i)(c),
						I = n === S.r.CHAT,
						v = !!c.platform.lastPage;
					if ((f || b && !g) && !(I && v)) {
						if (b && !c.sidebarPromotedPosts.firstFetch) {
							const t = Object(ve.i)(c) ? Me.a.COMMENTS_OVERLAY : Me.a.COMMENTS;
							window.addEventListener("load", () => {
								r(Object(ke.b)(t)), Math.random() <= .01 && r(Object(ke.a)(e))
							})
						}
						return void(O || r(mt(e, t, s)))
					}
					r(u.g());
					const T = c.user.prefs.commentMode;
					r(ut({
						key: d,
						postId: e,
						commentMode: T
					}));
					const w = Object.assign(Object.assign({}, s), I ? {
						sort: S.r.LIVE
					} : _ ? {
						sort: s.sort,
						depth: 2
					} : {
						sort: s.sort
					}); {
						const t = Object(Se.N)(a(), {
							postId: e
						});
						t && t.numComments && t.numComments > Je && (w.truncate = ze)
					}
					const A = Object(Ue.a)("comments", () => Object(j.a)(i.apiContext(), e, t, w, Object(Oe.a)(a()), Object(He.a)(a()))),
						D = !_ && h && Object(E.d)(i.gqlContext(), Object(be.e)(h)) || null,
						[P, R] = await Promise.all([A, D]);
					let k;
					if (r(Object(L.m)(P.status)), P.ok) {
						const t = Object.keys(P.body.posts).filter(e => !!P.body.posts[e].isMeta),
							s = P.body.posts[e];
						if (t.length) {
							const e = await Object(m.a)(i.apiContext(), s.belongsTo.id, t);
							e.ok && (k = e.body)
						}
						if (R && R.ok) {
							const e = null === (o = R.body.data.redditorInfoByName) || void 0 === o ? void 0 : o.karma,
								t = e ? {
									awardeeKarma: e.fromAwardsReceived,
									awarderKarma: e.fromAwardsGiven,
									commentKarma: e.fromComments,
									postKarma: e.fromPosts,
									totalKarma: e.total
								} : E.a;
							P.body && P.body.account && Object.assign(P.body.account, t)
						}
						const n = Object(se.a)(P.body, e, c);
						r(lt(Object.assign({
							key: d,
							postId: e,
							meta: c.meta,
							governance: k,
							shouldCollapse: n
						}, P.body)))
					} {
						const n = Object(Se.N)(a(), {
							postId: e
						});
						n && P.body.comments && Object.keys(P.body.comments).length < n.numComments ? r(mt(e, t, s)) : P.ok && r(ft({
							key: d
						}));
						const i = Object(ve.i)(c) ? Me.a.COMMENTS_OVERLAY : Me.a.COMMENTS;
						r(Object(ke.b)(i)), Math.random() <= .01 && r(Object(ke.a)(e))
					}
					if (P.ok) {
						r(Y.f(d));
						const t = Object(Se.N)(a(), {
							postId: e
						});
						r(V.t(t, J.a.CommentsView)), t && "subreddit" === t.belongsTo.type && P.body.comments && await r(Object(C.a)({
							commentIds: Object.keys(P.body.comments),
							postIds: [t.id],
							subredditId: t.belongsTo.id
						}))
					} else {
						let e;
						l && (r(Object(p.k)({
							key: d
						})), e = await Object(Ue.a)("subreddit", () => Object(y.a)(i.apiContext(), l, {})), r(Object(L.m)(e.status)), r(Object(p.f)(e, l))), r(bt(Object.assign({
							error: P.error,
							key: d
						}, e ? e.body : P.body)))
					}
				}, gt = "PAGE__COMMENTSPAGE_LOADED_FULL", ft = Object(N.a)(gt), mt = (e, t, s) => async (n, r, a) => {
					var i;
					const o = Object(De.a)(e, t, s),
						c = r(),
						d = Object(Ae.H)(c),
						u = Object(Ae.i)(c),
						l = Object(j.a)(a.apiContext(), e, t, s, Object(Oe.a)(c), Object(He.a)(c)),
						b = d && u && Object(E.d)(a.gqlContext(), Object(be.e)(u)) || null,
						[p, O] = await Promise.all([l, b]);
					if (n(Object(L.m)(p.status)), p.ok) {
						if (O && O.ok) {
							const e = null === (i = O.body.data.redditorInfoByName) || void 0 === i ? void 0 : i.karma,
								t = e ? {
									awardeeKarma: e.fromAwardsReceived,
									awarderKarma: e.fromAwardsGiven,
									commentKarma: e.fromComments,
									postKarma: e.fromPosts,
									totalKarma: e.total
								} : E.a;
							p.body && p.body.account && Object.assign(p.body.account, t)
						}
						const t = Object(se.a)(p.body, e, c);
						n(lt(Object.assign({
							key: o,
							postId: e,
							meta: c.meta,
							shouldCollapse: t
						}, p.body))), n(ft({
							key: o
						}));
						const s = r().posts.models[e],
							a = s && Object(Se.ab)(r(), {
								postId: s.id
							});
						s && "subreddit" === s.belongsTo.type && a && Object(Ee.a)(c, {
							subredditId: a.id
						}) && n(Object(f.h)(a.name, a.id)), s && "subreddit" === s.belongsTo.type && p.body.comments && await n(Object(C.a)({
							commentIds: Object.keys(p.body.comments),
							postIds: [s.id],
							subredditId: s.belongsTo.id
						}))
					} else n(bt(Object.assign({
						error: p.error,
						key: o
					}, p.body)))
				}, jt = e => async (t, s, n) => {
					await t(Object(K.c)(e, !0))
				}, _t = () => async (e, t, s) => {
					await e((() => async (e, t, s) => {
						let {
							apiContext: n
						} = s;
						const r = t(),
							a = await Object(U.a)(n());
						if (a.ok && a.body)
							if (a.body.account)
								if (r.user.account && r.user.account.isFPR) {
									const e = G;
									window.location.href = e
								} else e(B(a.body));
						else Object(M.a)(e, r);
						else e(q(a.error))
					})())
				}, ht = (e, t, s) => async (n, r, a) => {
					let {
						routes: o
					} = a;
					const c = r(),
						d = (t || c.platform.currentPage).routeMatch.match,
						u = Object(Re.a)(d.url, o);
					if (!u) return;
					const l = e.metaKey || e.ctrlKey || 1 === e.button;
					if (u.route && u.route.meta && (u.route.meta.name === S.Bb.INDEX || u.route.meta.name === S.Bb.MULTIREDDIT || u.route.meta.name === S.Bb.SUBREDDIT)) l ? window.open(d.url) : s ? n(Object(i.b)(d.url)) : await n(u.route.action(d, !0));
					else if (u.match && u.match.params && u.match.params.subredditName) {
						const {
							subredditName: e
						} = u.match.params, t = "/r/".concat(e, "/");
						if (l) window.open(t);
						else if (s) n(Object(i.b)(t));
						else {
							const s = Object(Pe.a)(e, S.O.HOT);
							await n(Object(i.b)(t)), n(Object(p.i)(s, e, {}))
						}
					}
				}, yt = Object(N.a)("PAGE__FRONTPAGE_RELOADED"), Et = e => async (t, s, n) => {
					const r = s(),
						a = r.platform.currentPage.routeMatch.match;
					Object(ye.m)(r) || Object(ye.r)(r) || (e || t(yt()), await t(it(a, !0)))
				}, It = "PAGE__MULTIREDDIT_FEED_PENDING", vt = "PAGE__MULTIREDDIT_FEED_LOADED", St = "PAGE__MULTIREDDIT_FEED_FAILED", Tt = Object(N.a)(It), wt = Object(N.a)(vt), Ct = Object(N.a)(St), At = (e, t, s, r, a) => async (i, o, c) => {
					const {
						gqlContext: d
					} = c, u = o();
					if (u.listings.postOrder.api.pending[e]) return;
					i(Tt({
						key: e
					})), r.layout = $.e[Object(te.N)(u, {})];
					const l = {
							path: Object(de.h)(t, s).replace(/\/$/, ""),
							includeIdentity: !0,
							includeSources: !0,
							sort: r.sort ? r.sort.toUpperCase() : void 0,
							range: r.t ? r.t.toUpperCase() : void 0
						},
						p = await Object(Ue.a)("multireddit", () => Object(h.a)(d(), l)),
						{
							data: O
						} = p.body,
						g = "error-".concat(e);
					if (p.ok && O) {
						const n = Object(ie.a)(O);
						if (!O.multireddit) return a && i(Y.f(g)), void i(Ct(Object.assign(Object.assign({}, n), {
							error: {
								type: S.E.NOT_FOUND_ERROR
							},
							key: e
						})));
						i(wt(Object.assign(Object.assign({
							key: e,
							meta: u.meta
						}, n), {
							account: n.account || Object(Ae.i)(u),
							multiredditsModelsState: u.multireddits.models
						}))), a && i(Y.f(g)), i(Object(b.h)({
							multiredditName: s,
							username: t
						})), window.addEventListener("load", () => {
							i(Object(ke.b)(Me.a.MULTIREDDIT))
						})
					} else a && i(Y.e({
						id: g,
						kind: le.b.Error,
						text: n.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "36ypKx"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: At(e, t, s, r, a)
					}))
				}, Dt = (e, t) => async (s, n) => {
					const {
						multiredditName: r
					} = e.params;
					let {
						username: c
					} = e.params;
					if (!c) {
						let t = n();
						if (t.user.session && t.user.session.unsafeLoggedOut) return void s(Object(i.c)("/"));
						!t.user.account && t.user.session && await s(z.r()), t = n();
						const {
							account: a
						} = t.user;
						if (!a) return void s(Object(i.c)("/"));
						c = Object(be.e)(a);
						let d = "/user/".concat(c, "/m/").concat(r);
						const {
							sort: u
						} = e.params;
						return d += u ? "/".concat(u) : "", void s(Object(i.c)(Object(o.a)(d, e.queryParams)))
					}
					const {
						sort: d = S.O.HOT
					} = e.params, u = {
						multiredditName: r,
						username: c
					}, l = n();
					c || (c = l.user.account ? Object(be.e)(l.user.account) : "");
					const b = Object(de.h)(c, r),
						p = Object(Pe.a)(b, d, e.queryParams),
						O = l.listings.postOrder.ids[p],
						g = l.listings.postOrder.api.error[p],
						f = l.listings.postOrder.api.pending[p],
						m = Z.x in e.queryParams && e.queryParams[Z.x].toUpperCase() || "",
						j = m in S.Sb && S.Sb[m];
					if (f || O && !g && !t) return void(O && (s(L.l({
						title: Object(Ie.f)(n(), u)
					})), l.sidebarPromotedPosts.firstFetch || s(Object(ke.b)(Me.a.MULTIREDDIT))));
					await s(At(p, c, r, Object.assign(Object.assign(Object.assign({}, a()(e.queryParams, Z.l)), a()(e.queryParams, Z.k)), {
						sort: d,
						t: Object(ae.a)(d, j)
					}), !0));
					const _ = n();
					Object(Ie.d)(_, u) && s(L.l({
						title: Object(Ie.f)(n(), u)
					})), Object(xe.c)(_, s, e)
				}, Pt = "PAGE__DASHBOARD_PENDING", Rt = (Object(N.a)(Pt), e => async (e, t) => {
					const s = t();
					e(L.l({
						title: w.a()
					})), Object(Ae.H)(s) || await e(z.r())
				}), kt = e => async (e, t) => e(L.l({
					title: w.a()
				})), xt = e => async (t, n) => {
					const r = n();
					if (t(L.l({
							title: w.f()
						})), e.queryParams.thanks) {
						const e = await Promise.resolve().then(s.bind(null, "./src/reddit/actions/goldPurchaseModals/payment.ts")).then(e => e.paymentCompleted);
						setTimeout(() => {
							t(P.c()), t(e({
								confirmed: !1
							}))
						}, 1e3)
					}
					Object(Ae.H)(r) || await t(z.r())
				}, Nt = e => async (e, t) => {
					const s = t();
					e(L.l({
						title: w.g()
					})), Object(Ae.H)(s) || await e(z.r())
				}, Lt = e => async (t, s) => {
					const n = s(),
						r = e.params.thingId;
					t(Object(D.c)({
						correlationId: Object(Le.d)(Le.a.GildingFlow),
						thingId: r
					})), Object(Ae.H)(n) || await t(z.r());
					const a = s();
					if (!Object(Ae.H)(a)) return t(Object(D.f)())
				}, Ut = e => async (e, t) => {
					const s = t();
					Object(Ae.H)(s) || await e(z.r());
					const n = t();
					if (!Object(Ae.H)(n)) throw new Error("Failed to login")
				}, Mt = () => async (e, t, s) => await e(O.d())
		},
		"./src/reddit/actions/pages/appeal/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = "APPEAL_PAGE_LOADED",
				r = "APPEAL_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/chatSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return E
			})), s.d(t, "b", (function() {
				return I
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "d", (function() {
				return S
			})), s.d(t, "e", (function() {
				return P
			})), s.d(t, "f", (function() {
				return R
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/difference.js"),
				a = s.n(r),
				i = s("./src/telemetry/index.ts"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeActionCreator/index.ts"),
				d = s("./src/lib/sentry/index.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/graphql/operations/GetSubredditChatSettings.json"),
				b = s("./src/lib/makeGqlRequest/index.ts");
			var p = (e, t) => Object(b.a)(e, Object.assign(Object.assign({}, l), {
					variables: t
				})),
				O = s("./src/graphql/operations/UpdateSubredditChatSettings.json");
			var g = (e, t) => Object(b.a)(e, Object.assign(Object.assign({}, O), {
					variables: t
				})),
				f = s("./src/reddit/selectors/telemetry.ts"),
				m = s("./src/telemetry/models/Event.ts");
			var j = s("./src/reddit/models/ChatSettingsPage/index.ts"),
				_ = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/selectors/chat.ts"),
				y = s("./src/reddit/selectors/chatSettingsPage.ts");
			const E = "FETCH_CHAT_SETTINGS__LOADED",
				I = "FETCH_CHAT_SETTINGS__FAILED",
				v = "FETCH_CHAT_SETTINGS__PENDING",
				S = "UPDATE_CHAT_SETTINGS__LOADED",
				T = Object(c.a)(E),
				w = Object(c.a)(I),
				C = Object(c.a)(v),
				A = Object(c.a)(S),
				D = e => async (t, s) => {
					const n = {
						subredditId: e
					};
					return !!Object(y.b)(s(), n) || (t(C(n)), !1)
				}, P = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = {
						subredditId: e
					};
					if (await t(D(e))) return;
					let i = null;
					const c = await p(r(), a);
					if (c.ok) {
						const t = c.body || {},
							n = t.data && t.data.subredditInfoById,
							r = n && n.chatSettings,
							o = !Object(h.e)(s(), a),
							d = Object(j.c)(r, e, o);
						i = Object.assign(Object.assign({}, a), {
							chatSettings: d
						})
					}
					if (i) t(T(i));
					else {
						const s = c.error || {
							type: o.E.UNKNOWN_ERROR
						};
						t(w(Object.assign(Object.assign({}, a), {
							error: s
						}))), d.c.withScope(t => {
							t.setExtra("info", {
								subredditId: e,
								responseBody: c.body,
								responseOk: c.ok
							}), d.c.captureMessage("Missing subreddit chat settings!")
						})
					}
				}, R = (e, t, s) => async (r, i, c) => {
					let {
						gqlContext: d
					} = c;
					if (await r(D(e))) return [];
					let l, b = !1;
					const p = a()(s, t),
						O = Object(j.b)(p);
					if (O && O.length) {
						const t = {
								subredditId: e,
								subredditChatSettings: O
							},
							s = await g(d(), {
								input: t
							});
						if (s.ok) {
							const e = (s.body || {}).data.updateSubredditChatSettings;
							b = !!e && e.ok
						} else l = s && s.error || {
							type: o.E.UNKNOWN_ERROR
						}
					}
					return b ? (r(A({
						subredditId: e,
						chatSettings: s
					})), r(x(t, p)), s) : (l && r(w({
						subredditId: e,
						error: l
					})), r(A({
						subredditId: e,
						chatSettings: t
					})), r(Object(u.e)({
						duration: u.a,
						id: "CHAT_SETTING_UPDATE_ERROR",
						kind: _.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "3HpR6h"
						})
					})), t)
				}, k = {
					start_chatting_opt_out: (e, t, s) => Object.assign({
						source: m.b.Chat,
						action: m.a.OptOut,
						noun: "down_to_chat_subreddit",
						subreddit: Object(f.subreddit)(e),
						setting: {
							oldValue: t,
							value: s
						}
					}, Object(f.defaults)(e))
				}, x = (e, t) => async (s, n) => {
					t.forEach(t => {
						if (t && t.settingId) {
							const s = k[t.settingId],
								r = e.find(e => e.settingId === t.settingId);
							if (s && r) {
								const e = s(n(), r.state, t.state);
								Object(i.a)(e)
							}
						}
					})
				}
		},
		"./src/reddit/actions/pages/collectionCommentsPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return G
			})), s.d(t, "b", (function() {
				return B
			})), s.d(t, "a", (function() {
				return q
			})), s.d(t, "e", (function() {
				return W
			})), s.d(t, "c", (function() {
				return Y
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/makeCollectionCommentsPageKey/index.ts"),
				a = s("./src/lib/pageTitle.ts"),
				i = s("./src/lib/truncateText/index.ts"),
				o = s("./src/reddit/actions/ads/index.ts"),
				c = s("./src/reddit/actions/economics/helpers/async.ts"),
				d = s("./src/reddit/actions/page.ts"),
				u = s("./src/reddit/actions/pages/subreddit.ts"),
				l = s("./src/reddit/actions/platform.ts"),
				b = s("./src/reddit/actions/post.ts"),
				p = s("./src/reddit/actions/profile/index.ts"),
				O = s("./src/reddit/actions/shortcuts/active.ts"),
				g = s("./src/reddit/actions/subreddit.ts"),
				f = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/constants/adEvents.ts"),
				j = s("./src/reddit/constants/parameters.ts"),
				_ = s("./src/reddit/constants/postCollection.ts"),
				h = s("./src/reddit/constants/posts.ts"),
				y = s("./src/reddit/endpoints/governance/posts.ts"),
				E = s("./src/config.ts"),
				I = s("./src/lib/constants/index.ts"),
				v = s("./src/lib/makeApiRequest/index.ts"),
				S = s("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function T(e, t, s) {
				const n = "".concat(E.a.gatewayUrl, "/desktopapi/v1/collection_postcomments");
				return s ? Object(S.a)("".concat(n, "/").concat(e, "/").concat(t, "/").concat(s)) : t ? Object(S.a)("".concat(n, "/").concat(e, "/").concat(t)) : Object(S.a)("".concat(n, "/").concat(e))
			}
			var w = (e, t, s, n, r) => Object(v.a)(e, {
					data: r,
					endpoint: T(t, s, n),
					method: I.db.GET
				}),
				C = s("./src/reddit/endpoints/page/subredditPage.ts"),
				A = s("./src/reddit/helpers/canonicalUrls.ts"),
				D = s("./src/reddit/helpers/commentList/index.ts"),
				P = s("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				R = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				k = s("./src/reddit/models/Comment/index.ts"),
				x = s("./src/reddit/models/Post/index.ts"),
				N = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				L = s("./src/reddit/selectors/platform.ts"),
				U = s("./src/reddit/selectors/postCollection.ts"),
				M = s("./src/reddit/selectors/posts.ts"),
				F = s("./src/reddit/selectors/subreddit.ts");
			const G = "PAGE__COLLECTIONCOMMENTSPAGE_PENDING",
				B = "PAGE__COLLECTIONCOMMENTSPAGE_LOADED",
				q = "PAGE__COLLECTIONCOMMENTSPAGE_FAILED",
				V = Object(n.a)(G),
				H = Object(n.a)(B),
				K = Object(n.a)(q),
				W = e => async (t, s) => {
					const {
						collectionId: n,
						partialPostId: r,
						partialCommentId: o,
						subredditName: c = "",
						routePrefix: d
					} = e.params, u = r ? Object(x.m)(r) : "", f = o && Object(k.e)(o), {
						queryParams: m
					} = e, y = s(), {
						instanceId: E
					} = m, I = {
						id: n,
						type: h.b[d]
					}, v = h.b[d] === h.a.PROFILE, {
						hasSortParam: S,
						sortToUse: T
					} = Object(P.a)(y, u), w = ["context", "depth", "limit", j.f].reduce((e, t) => {
						const s = parseInt(m[t]);
						return isNaN(s) || (e[t] = s), e
					}, {
						subredditName: c,
						hasSortParam: S,
						instanceId: E
					});
					S && (w.sort = T), t(b.l(u)), await Promise.all([v ? t(p.d(c)) : Promise.resolve(), t(Q(n, u, f, w))]);
					const C = ((e, t) => {
						const s = Object(U.r)(e, {
							collectionId: t.id
						});
						if (!s) return "";
						const n = Object(F.M)(e, {
								identifier: t
							}),
							r = Object(a.b)(s.title, n.name).toString();
						return Object(i.a)(r, _.c, " …")
					})(s(), I) || Object(a.c)();
					t(l.l({
						title: C
					}));
					const D = s().posts.models[u];
					if (D) {
						const n = Object(F.M)(s(), {
							identifier: D.belongsTo
						});
						if (!D.isSponsored)
							if (D.belongsTo.type === h.a.SUBREDDIT) {
								!!Object(F.R)(y, {
									subredditId: D.belongsTo.id
								}) || await t(g.o(n.name))
							} else await t(p.d(n.name));
						const r = s().posts.instances[u] ? e.queryParams.instanceId : D.postId;
						t(Object(O.b)(r))
					}
					v ? Object(A.d)(s(), t, e) : Object(A.e)(s(), t, e)
				}, Y = "PAGE__COLLECTIONCOMMENTSPAGE_LOADED_FULL", z = Object(n.a)(Y), J = (e, t, s, n) => async (a, i, o) => {
					const c = Object(r.a)(e, t, s, n),
						d = i();
					t = t || Object(U.q)(d, {
						collectionId: e
					});
					const u = await w(o.apiContext(), e, t, s, n);
					if (a(Object(l.m)(u.status)), u.ok) {
						if (!(t = t || u.body.collections[e].primaryPostId)) return;
						const s = Object(D.a)(u.body, t, d);
						a(H(Object.assign({
							key: c,
							collectionId: e,
							meta: d.meta,
							postId: t,
							shouldCollapse: s
						}, u.body)));
						const n = d.user.prefs.commentMode;
						a(z({
							commentMode: n,
							key: c,
							postId: t
						}))
					} else a(K(Object.assign({
						error: u.error,
						key: c
					}, u.body)))
				}, Q = (e, t, s, n, a) => async (i, p, O) => {
					const g = Object(r.a)(e, t, s, n),
						j = p();
					t = t || Object(U.q)(j, {
						collectionId: e
					});
					const {
						subredditName: _
					} = n, h = j.commentsPage.keyToHeadCommentId.hasOwnProperty(g), E = j.commentsPage.api.fullyLoaded[g], I = j.commentsPage.api.error[g];
					if (j.commentsPage.api.pending[g] || h && !I) {
						if (h && !j.sidebarPromotedPosts.firstFetch) {
							const e = Object(L.i)(j) ? N.a.COMMENTS_OVERLAY : N.a.COMMENTS;
							window.addEventListener("load", () => {
								i(Object(o.b)(e))
							})
						}
						return void(E || a || i(J(e, t, s, n)))
					}
					const v = j.user.prefs.commentMode;
					i(V({
						key: g,
						collectionId: e,
						commentMode: v,
						postId: t
					}));
					const S = Object.assign({}, n); {
						const e = t && Object(M.N)(p(), {
							postId: t
						});
						e && e.numComments && e.numComments > d.i && (S.truncate = d.m)
					}
					let T, A = await Object(R.a)("comments", () => w(O.apiContext(), e, t, s, S));
					if (i(Object(l.m)(A.status)), A.ok && (t = t || A.body.collections[e].primaryPostId)) {
						const e = Object.keys(A.body.posts).filter(e => !!A.body.posts[e].isMeta),
							s = Object(M.N)(p(), {
								postId: t
							});
						if (e.length) {
							const t = await Object(y.a)(O.apiContext(), s.belongsTo.id, e);
							t.ok && (T = t.body)
						}
					}
					if (!a) {
						const r = t ? Object(M.N)(p(), {
							postId: t
						}) : null;
						r && A.body.comments && Object.keys(A.body.comments).length < r.numComments ? i(J(e, t, s, n)) : A.ok && i(z({
							commentMode: v,
							key: g,
							postId: t
						}));
						const a = Object(L.i)(j) ? N.a.COMMENTS_OVERLAY : N.a.COMMENTS;
						i(Object(o.b)(a))
					}
					if (A.ok) {
						if (!t) return;
						const e = Object(D.a)(A.body, t, j);
						i(Object(d.s)(Object.assign({
							commentMode: v,
							key: g,
							postId: t,
							meta: j.meta,
							governance: T,
							shouldCollapse: e
						}, A.body))), i(f.f(g));
						const s = Object(M.N)(j, {
							postId: t
						});
						i(b.t(s, m.a.CommentsView)), !a && s && "subreddit" === s.belongsTo.type && A.body.comments && await i(Object(c.a)({
							commentIds: Object.keys(A.body.comments),
							postIds: [s.id],
							subredditId: s.belongsTo.id
						}))
					} else _ && (i(Object(u.k)({
						key: g
					})), A = await Object(R.a)("subreddit", () => Object(C.a)(O.apiContext(), _, {})), i(Object(l.m)(A.status))), i(Object(u.f)(A, _)), i(K(Object.assign({
						error: A.error,
						key: g
					}, A.body)))
				}
		},
		"./src/reddit/actions/pages/modListing/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return n
			})), s.d(t, "e", (function() {
				return r
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "i", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			})), s.d(t, "l", (function() {
				return b
			})), s.d(t, "k", (function() {
				return p
			})), s.d(t, "j", (function() {
				return O
			}));
			const n = "PAGE__MOD_LISTING_PAGE_PENDING",
				r = "PAGE__MOD_LISTING_PAGE_LOADED",
				a = "PAGE__MOD_LISTING_PAGE_FAILED",
				i = "MOD_LISTING_MORE_POSTS_PENDING",
				o = "MOD_LISTING_MORE_POSTS_LOADED",
				c = "MOD_LISTING_MORE_POSTS_FAILED",
				d = "MOD_LISTING_HIDE_SUBREDDIT_SUCCESS",
				u = "MOD_LISTING_HIDE_SUBREDDIT_PENDING",
				l = "MOD_LISTING_HIDE_SUBREDDIT_FAILED",
				b = "MOD_LISTING_UNHIDE_SUBREDDIT_SUCCESS",
				p = "MOD_LISTING_UNHIDE_SUBREDDIT_PENDING",
				O = "MOD_LISTING_UNHIDE_SUBREDDIT_FAILED"
		},
		"./src/reddit/actions/pages/modListing/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return N
			})), s.d(t, "c", (function() {
				return F
			})), s.d(t, "a", (function() {
				return z
			})), s.d(t, "d", (function() {
				return J
			}));
			s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/makeListingKey/index.ts"),
				d = s("./src/reddit/actions/platform.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/constants/page.ts"),
				b = s("./src/reddit/constants/parameters.ts"),
				p = s("./src/config.ts"),
				O = s("./src/lib/makeApiRequest/index.ts"),
				g = s("./src/lib/omitHeaders/index.ts"),
				f = s("./src/reddit/constants/headers.ts"),
				m = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				j = s("./src/reddit/helpers/name/index.ts"),
				_ = s("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				h = (e, t) => Object(O.a)(e, {
					data: t,
					endpoint: Object(m.a)(Object(_.a)("".concat(p.a.gatewayUrl, "/desktopapi/v1/mod"))),
					method: i.db.GET
				});
			const y = (e, t, s, n) => Object(O.a)(Object(g.a)(e, [f.a]), {
					endpoint: "".concat(e.apiUrl, "/api/filter/user/").concat(t, "/f/mod/").concat(Object(j.b)(s)),
					method: n ? i.db.PUT : i.db.DELETE,
					data: {
						model: JSON.stringify({
							name: Object(j.g)(s)
						})
					}
				}),
				E = (e, t, s) => y(e, t, s, !0),
				I = (e, t, s) => y(e, t, s, !1);
			var v = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				S = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				T = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				w = s("./src/reddit/models/Toast/index.ts"),
				C = s("./src/reddit/routes/modListing/index.ts"),
				A = s("./src/reddit/selectors/user.ts"),
				D = s("./src/reddit/actions/pages/modListing/constants.ts");
			const P = Object(o.a)(D.f),
				R = Object(o.a)(D.e),
				k = Object(o.a)(D.d),
				x = (e, t) => async (s, r, a) => {
					const i = r();
					if (i.listings.postOrder.api.pending[e]) return;
					s(P({
						key: e
					}));
					const o = await Object(T.a)("modListing", () => h(a.apiContext(), t)),
						c = "error-".concat(e);
					o.ok ? (s(R(Object.assign({
						key: e,
						meta: i.meta
					}, o.body))), s(u.f(c))) : (s(k(Object.assign({
						error: o.error,
						key: e
					}, o.body))), 401 === o.status ? Object(S.a)(s, i) : s(u.e({
						id: c,
						kind: w.b.Error,
						text: n.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: x(e, t)
					})))
				}, N = (e, t) => async (s, r) => {
					const {
						sort: o = i.P
					} = e.params, u = Object(C.d)(e.path), p = u ? l.e : l.d, O = Object(c.a)(p, o, e.queryParams), g = r(), f = g.listings.postOrder.ids[O], m = g.listings.postOrder.api.error[O];
					if (g.listings.postOrder.api.pending[O] || f && !m && !t) return void(f && s(d.l({
						title: n.fbt._("Subreddits you moderate", null, {
							hk: "3RYtBz"
						})
					})));
					const j = G(e.queryParams);
					await s(x(O, Object.assign(Object.assign(Object.assign({}, a()(e.queryParams, b.l)), a()(e.queryParams, b.k)), {
						filtered: !!u || void 0,
						moderated_srs: !0,
						sort: o,
						t: Object(v.a)(o, j)
					}))), s(d.l({
						title: n.fbt._("Subreddits you moderate", null, {
							hk: "3RYtBz"
						})
					}))
				}, L = Object(o.a)(D.i), U = Object(o.a)(D.h), M = Object(o.a)(D.g), F = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const o = s(),
						d = o.platform.currentPage;
					if (!d) return;
					const {
						sort: u = i.P
					} = e, p = d.queryParams, O = Object(C.d)(d.url), g = O ? l.e : l.d, f = Object(c.a)(g, u, p), m = o.listings.postOrder.loadMore[f];
					if (!m) return;
					const j = o.listings.postOrder.api.pending[f],
						_ = o.listings.postOrder.fetchedTokens,
						y = !(!_[f] || !_[f][m.token]);
					if (j || y) return;
					const E = G(p);
					t(L({
						key: f,
						fetchedToken: m.token
					}));
					const I = await h(r(), Object.assign({
							after: m.token,
							dist: m.dist,
							filtered: !!O || void 0,
							sort: u,
							t: Object(v.a)(u, E)
						}, a()(p, b.l))),
						S = o.listings.postOrder.ids[f],
						T = Object.assign(Object.assign({}, I.body), {
							postIds: (I.body.postIds || []).filter(e => !S || !S.includes(e))
						});
					I.ok ? t(U(Object.assign({
						key: f,
						fetchedToken: m.token,
						meta: o.meta
					}, T))) : t(M(Object.assign({
						key: f,
						error: I.error,
						fetchedToken: m.token
					}, T)))
				};

			function G(e) {
				const t = b.x in e && e[b.x].toUpperCase() || "";
				return t in i.Sb && i.Sb[t]
			}
			const B = Object(o.a)(D.c),
				q = Object(o.a)(D.b),
				V = Object(o.a)(D.a),
				H = Object(o.a)(D.l),
				K = Object(o.a)(D.k),
				W = Object(o.a)(D.j),
				Y = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(A.i)(i),
						[c, d, u, l] = t ? [q, B, V, E] : [K, H, W, I];
					if (!o || !o.displayText) return;
					const {
						currentPage: b
					} = i.platform;
					if (!b || !b.routeMatch) return;
					s(c(e));
					const p = await l(a(), o.displayText, e);
					p.ok ? (await s(N(b.routeMatch.match, !0)), s(d(e))) : s(u(p.body))
				}, z = e => Y(e, !0), J = e => Y(e, !1)
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return L
			})), s.d(t, "b", (function() {
				return U
			})), s.d(t, "a", (function() {
				return M
			})), s.d(t, "d", (function() {
				return V
			})), s.d(t, "e", (function() {
				return H
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react-router-redux/es/index.js"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/filterQueryParams/index.ts"),
				i = s("./src/lib/isFakeSubreddit/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/makePostCreationPageKey/index.ts"),
				d = s("./src/lib/pageTitle.ts"),
				u = s("./src/reddit/actions/economics/helpers/async.ts"),
				l = s("./src/reddit/actions/externalAccount.ts"),
				b = s("./src/reddit/actions/gold/powerups.ts"),
				p = s("./src/reddit/actions/platform.ts"),
				O = s("./src/reddit/actions/post.ts"),
				g = s("./src/reddit/actions/postCreation/general.ts"),
				f = s("./src/reddit/actions/postRequirements/index.ts"),
				m = s("./src/reddit/actions/profile/index.ts"),
				j = s("./src/reddit/actions/subreddit.ts"),
				_ = s("./src/reddit/actions/subredditDuplicates.ts"),
				h = s("./src/config.ts"),
				y = s("./src/lib/makeApiRequest/index.ts"),
				E = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				I = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				v = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				S = s("./src/reddit/helpers/trackers/postComposer.ts"),
				T = s("./src/reddit/models/User/index.ts"),
				w = s("./src/reddit/selectors/experiments/goldSubredditPowerups.ts"),
				C = s("./src/reddit/selectors/postCollection.ts"),
				A = s("./src/reddit/selectors/postCreations.ts"),
				D = s("./src/reddit/selectors/postRequirements.ts"),
				P = s("./src/reddit/selectors/posts.ts"),
				R = s("./src/reddit/selectors/profile.ts"),
				k = s("./src/reddit/selectors/subreddit.ts"),
				x = s("./src/reddit/selectors/user.ts");
			const N = e => {
					const t = e.platform.currentPage;
					let s = "Reddit";
					if (t && t.urlParams.subredditName) {
						const {
							subredditName: n
						} = t.urlParams, r = Object(k.B)(e, {
							subredditName: n
						});
						r && (s = r.name)
					}
					return Object(d.i)(s)
				},
				L = "POST_CREATION__PAGE_PENDING",
				U = "POST_CREATION__PAGE_LOADED",
				M = "POST_CREATION__PAGE_FAILED",
				F = Object(o.a)(L),
				G = Object(o.a)(U),
				B = Object(o.a)(M),
				q = () => async (e, t) => {
					const s = t(),
						n = Object(A.a)(s);
					n !== Object(A.fb)(s) && e(Object(g.g)({
						submissionType: n
					}))
				}, V = e => async (t, s, n) => {
					const {
						collectionId: a,
						profileName: o,
						subredditName: d
					} = e, u = Object(c.a)(e), p = s(), O = p.creations.api.page.pending[u], g = p.creations.api.page.fetched[u], _ = p.creations.api.page.error[u];
					if (O) return;
					if (g && !_) return void t(q());
					const I = [];
					t(F({
						key: u
					}));
					let S = d;
					!d && o && (S = "u_".concat(o)), I.push(((e, t) => Object(y.a)(e, {
						method: r.db.GET,
						endpoint: Object(E.a)("".concat(h.a.gatewayUrl, "/desktopapi/v1/submitpage")),
						data: {
							subreddit: t.subredditName,
							collection_id: t.collectionId
						}
					}))(n.apiContext(), {
						subredditName: S,
						collectionId: a
					})), o && (I.push(t(m.d(o))), I.push(t(m.b(o))));
					const [C] = await Object(v.a)("postCreation", () => Promise.all(I));
					if (C.ok) {
						const e = C.body,
							{
								posts: n = {},
								subredditAboutInfo: r
							} = e;
						if (t(G(Object.assign(Object.assign({
								key: u,
								meta: p.meta
							}, e), {
								posts: n
							}))), !Object(x.H)(s())) return;
						if (r && Object(w.a)(p)) {
							const e = Object.keys(r)[0];
							await t(Object(b.f)(e, {
								fullData: !0
							}))
						}
						t(q());
						const a = [];
						a.push(t(l.o()));
						const o = Object(x.i)(s());
						if (o && o.hasUserProfile && a.push(t(m.d(Object(T.e)(o)))), d && !Object(i.a)(d)) {
							a.push(t(j.o(d))), !!Object(D.b)(s(), {
								subredditName: d
							}) || a.push(t(Object(f.a)(d)))
						}
						await Promise.all(a)
					} else t(B({
						error: C.error,
						key: u
					}))
				}, H = e => async (t, s) => {
					const {
						subredditName: i,
						profileName: o
					} = e.params, c = e.queryParams, d = c.collection;
					if (await t(V({
							collectionId: d,
							profileName: o,
							subredditName: i
						})), !Object(x.H)(s())) return void Object(I.a)(t, s());
					let l;
					if (i ? (l = Object(k.B)(s(), {
							subredditName: i
						}), await t(Object(u.a)({
							subredditName: i
						}))) : o && (l = Object(R.j)(s(), {
							profileName: o
						})), c.source_id) await t(((e, t) => async (s, n) => {
						const {
							subredditName: r,
							profileName: a
						} = e, i = [];
						let o;
						r ? o = Object(k.G)(n(), r) : a && (o = Object(x.Z)(n(), {
							userName: a
						})), o && i.push(s(Object(_.b)(o, t))), i.push(s(Object(O.I)(t))), await Promise.all(i);
						const c = Object(P.f)(n(), {
							postId: t
						});
						s(Object(g.k)({
							postId: t,
							postTitle: c ? c.title : ""
						}))
					})(e.params, c.source_id));
					else if (d) {
						const r = Object(C.r)(s(), {
							collectionId: d
						});
						l && r && r.subredditId === l.id || t(Object(n.c)(Object(a.a)(e.url, ["collection"])))
					}((e, t) => {
						const s = e.platform.lastPage;
						t && s && s.meta && s.meta.name === r.Bb.POST_CREATION && S.x(e)
					})(s(), i), t(p.l({
						title: N(s())
					}))
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return p
			})), s.d(t, "b", (function() {
				return m
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/makePostDraftPageKey/index.ts"),
				a = s("./src/reddit/actions/profile/index.ts"),
				i = s("./src/config.ts"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				u = s("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				l = s("./src/reddit/endpoints/post/draft/helpers.ts"),
				b = s("./src/reddit/helpers/timeApiRoute/index.ts");
			const p = "POST_DRAFT__PAGE_LOADED",
				O = (Object(n.a)("POST_DRAFT__PAGE_PENDING"), Object(n.a)(p)),
				g = Object(n.a)("POST_DRAFT__PAGE_FAILED"),
				f = e => async (t, s, n) => {
					const {
						draftId: p,
						profileName: f
					} = e, m = Object(r.a)(e), j = s(), _ = j.creations.api.page.pending[m], h = j.creations.api.page.fetched[m], y = j.creations.api.page.error[m];
					if (_ || h && !y || !p) return;
					t(a.d(f));
					const E = await Object(b.a)("postDraft", () => ((e, t, s) => Object(c.a)(e, {
						endpoint: Object(d.a)(Object(u.a)("".concat(i.a.gatewayUrl, "/desktopapi/v1/draftpreviewpage/").concat(s, "/").concat(t))),
						method: o.db.GET
					}))(n.apiContext(), p, f));
					if (E.ok) {
						const e = E.body;
						e.drafts[p].kind = Object(l.b)(e.drafts[p].kind), t(O(Object.assign(Object.assign({}, e), {
							key: m
						})))
					} else t(g({
						error: E.error,
						key: m
					}))
				}, m = e => async (t, s, n) => {
					await t(f(e.params))
				}
		},
		"./src/reddit/actions/pages/profileComments.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return P
			})), s.d(t, "e", (function() {
				return R
			})), s.d(t, "d", (function() {
				return k
			})), s.d(t, "h", (function() {
				return U
			})), s.d(t, "c", (function() {
				return M
			})), s.d(t, "b", (function() {
				return F
			})), s.d(t, "a", (function() {
				return G
			})), s.d(t, "g", (function() {
				return H
			}));
			s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/lodash/difference.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/pick.js"),
				i = s.n(a),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/makeListingKey/index.ts"),
				d = s("./src/reddit/actions/contentGate.ts"),
				u = s("./src/reddit/actions/externalAccount.ts"),
				l = s("./src/reddit/actions/moderatingSubreddits.ts"),
				b = s("./src/reddit/actions/pages/profileShared.ts"),
				p = s("./src/reddit/actions/platform.ts"),
				O = s("./src/reddit/actions/profile/index.ts"),
				g = s("./src/reddit/actions/subreddit.ts"),
				f = s("./src/reddit/constants/errors.ts"),
				m = s("./src/reddit/constants/parameters.ts"),
				j = s("./src/reddit/contexts/PageLayer/index.tsx"),
				_ = s("./src/config.ts"),
				h = s("./src/lib/addAllowQuarantinedParam/index.ts"),
				y = s("./src/lib/constants/index.ts"),
				E = s("./src/lib/makeApiRequest/index.ts"),
				I = s("./src/reddit/models/Comment/addProfileImgParam.ts"),
				v = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const S = (e, t, s, n) => {
				let r = Object(h.a)(Object(v.a)("".concat(_.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/comments")));
				return n && (r = Object(I.a)(r)), Object(E.a)(e, {
					data: s,
					endpoint: r,
					method: y.db.GET
				})
			};
			var T = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				w = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				C = s("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				A = s("./src/reddit/selectors/profile.ts"),
				D = s("./src/reddit/selectors/profileComments.ts");
			const P = "PAGE__PROFILE_COMMENTS_PENDING",
				R = "PAGE__PROFILE_COMMENTS_LOADED",
				k = "PAGE__PROFILE_COMMENTS_FAILED",
				x = Object(o.a)(P),
				N = Object(o.a)(R),
				L = Object(o.a)(k),
				U = e => async (t, s, n) => {
					const {
						queryParams: r,
						params: a
					} = e, {
						sort: o,
						t: j
					} = Object(b.b)(r), {
						profileName: _
					} = a, h = Object(c.a)("u_".concat(_), o, e.queryParams), {
						profileCommentsPage: y
					} = s(), E = y.commentIds[h], I = y.api.error[h], v = y.api.pending[h];
					if (await t(O.d(_)), v || E && !I) {
						if (E) {
							const e = Object(A.q)(s(), {
								profileName: _
							});
							t(p.l({
								title: e
							}))
						}
						return
					}
					const D = Object.assign(Object.assign({}, i()(e.queryParams, [...m.l, m.h])), {
						sort: o,
						t: Object(T.a)(o, j)
					});
					t(x({
						key: h
					}));
					const P = await Object(w.a)("profileComments", () => S(n.apiContext(), _, D, Object(C.a)(s())));
					if (!P.ok) return t(L({
						account: P.body.data ? P.body.data.account : null,
						error: P.body.reason ? {
							type: P.body.reason
						} : P.error,
						key: h
					})), P.body.reason === f.a.DeletedProfile && t(Object(d.p)({
						profileName: _
					})), void t(p.m(P.status));
					const R = P.body;
					t(N(Object.assign({
						key: h,
						meta: s().meta
					}, R))), await Promise.all([t(Object(b.c)(_)), t(Object(g.q)()), t(Object(l.b)()), t(u.o(_))])
				}, M = "PROFILE_COMMENTS__MORE_ITEMS_PENDING", F = "PROFILE_COMMENTS__MORE_ITEMS_LOADED", G = "PROFILE_COMMENTS__MORE_ITEMS_FAILED", B = Object(o.a)(M), q = Object(o.a)(F), V = Object(o.a)(G), H = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const a = t(),
						{
							currentPage: o
						} = a.platform;
					if (!o || !o.routeMatch) return;
					const {
						queryParams: d,
						params: u
					} = o.routeMatch.match, {
						sort: l,
						t: p
					} = Object(b.b)(d), {
						profileName: O
					} = u, g = Object(c.a)("u_".concat(O), l, d), f = Object(D.d)(a, {
						listingKey: g
					});
					if (!f) return;
					const _ = Object(D.b)(a, {
							listingKey: g
						}),
						h = Object(D.c)(a, {
							listingKey: g
						}),
						y = h && h[f.token];
					if (_ || y) return;
					e(B({
						key: g,
						fetchedToken: f.token
					}));
					const E = await S(n(), O, Object.assign(Object.assign({
						after: f.token,
						dist: f.dist,
						sort: l,
						t: p
					}, i()(d, m.l)), {
						layout: Object(j.N)(a, {}).toLowerCase()
					}), Object(C.a)(a));
					if (E.ok) {
						const t = Object(D.f)(a, {
								listingKey: g
							}),
							s = Object.assign(Object.assign({}, E.body), {
								commentIds: r()(E.body.commentIds, t)
							});
						e(q(Object.assign({
							fetchedToken: f.token,
							key: g,
							meta: a.meta
						}, s)))
					} else e(V({
						account: E.body.data ? E.body.data.account : null,
						error: E.error,
						fetchedToken: f.token,
						key: g
					}))
				}
		},
		"./src/reddit/actions/pages/profileModSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			})), s.d(t, "b", (function() {
				return l
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/preferences.ts"),
				a = s("./src/reddit/actions/profile/index.ts"),
				i = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				o = s("./src/reddit/models/User/index.ts"),
				c = s("./src/reddit/selectors/user.ts");
			const d = "PAGE__PROFILE_MOD_SETTINGS_LOADED",
				u = Object(n.a)(d),
				l = e => async (t, s) => {
					const n = [t(r.z()), t(Object(a.d)(e.params.profileName))];
					await Promise.all(n);
					const d = Object(c.i)(s());
					d ? (await t(Object(a.b)(Object(o.e)(d))), t(u())) : Object(i.a)(t, s())
				}
		},
		"./src/reddit/actions/pages/profileOverview.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return D
			})), s.d(t, "e", (function() {
				return P
			})), s.d(t, "d", (function() {
				return R
			})), s.d(t, "c", (function() {
				return k
			})), s.d(t, "b", (function() {
				return x
			})), s.d(t, "a", (function() {
				return N
			})), s.d(t, "g", (function() {
				return q
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/lodash/pick.js"),
				r = s.n(n),
				a = s("./src/reddit/actions/moderatingSubreddits.ts"),
				i = s("./src/reddit/actions/pages/profileShared.ts"),
				o = s("./src/reddit/actions/subreddit.ts"),
				c = s("./src/reddit/endpoints/page/profileOverviewPage.ts"),
				d = s("./src/lib/constants/index.ts"),
				u = s("./src/reddit/constants/postLayout.ts"),
				l = s("./src/reddit/constants/parameters.ts"),
				b = s("./src/reddit/contexts/PageLayer/index.tsx"),
				p = s("./src/reddit/selectors/experiments/goldSubredditPowerups.ts"),
				O = s("./src/reddit/selectors/listings.ts"),
				g = s("./src/reddit/selectors/profile.ts"),
				f = s("./src/reddit/selectors/profileOverviewChronoItems.ts"),
				m = s("./src/reddit/selectors/user.ts"),
				j = s("./src/lib/makeActionCreator/index.ts"),
				_ = s("./src/reddit/actions/changeUsername.ts"),
				h = s("./src/reddit/actions/contentGate.ts"),
				y = s("./src/reddit/actions/externalAccount.ts"),
				E = s("./src/reddit/actions/gold/powerups.ts"),
				I = s("./src/reddit/actions/pinnedPost.ts"),
				v = s("./src/reddit/actions/platform.ts"),
				S = s("./src/reddit/actions/profile/index.ts"),
				T = s("./src/reddit/actions/trophyCase.ts"),
				w = s("./src/reddit/constants/errors.ts"),
				C = s("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				A = s("./src/reddit/helpers/timeApiRoute/index.ts");
			const D = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_PENDING",
				P = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_LOADED",
				R = "PAGE__PROFILE_OVERVIEW_CONVERSATIONS_FAILED",
				k = "PAGE__PROFILE_OVERVIEW_CHRONO_PENDING",
				x = "PAGE__PROFILE_OVERVIEW_CHRONO_LOADED",
				N = "PAGE__PROFILE_OVERVIEW_CHRONO_FAILED",
				L = Object(j.a)(D),
				U = Object(j.a)(P),
				M = Object(j.a)(R),
				F = Object(j.a)(k),
				G = Object(j.a)(x),
				B = Object(j.a)(N),
				q = e => async (t, s, n) => {
					const {
						queryParams: j,
						params: D
					} = e, {
						sort: P,
						t: R
					} = Object(i.a)(s(), j), {
						profileName: k
					} = D;
					let x = !1;
					const N = u.e[Object(b.N)(s(), {})],
						q = k.toLowerCase(),
						H = Object.assign(Object.assign({}, r()(e.queryParams, l.l)), {
							sort: P,
							layout: N,
							t: R
						}),
						K = [t(S.d(q))];
					if (N === u.e[u.g.Compact]) {
						const n = Object(C.a)(q, d.kb, P, e.queryParams);
						s().profileOverviewPage.chrono.ids[n] ? x = !0 : K.push(t(((e, t, s, n) => async (n, r, a) => {
							const i = r(),
								o = !!Object(f.f)(i, {
									listingKey: e
								}).length,
								d = !!Object(f.a)(i, {
									listingKey: e
								});
							if (!!Object(f.b)(i, {
									listingKey: e
								}) || o && !d) return;
							n(F({
								key: e
							}));
							const u = await Object(A.a)("profile", () => Object(c.a)(a.apiContext(), t, s)),
								l = u.body,
								{
									pinned: b
								} = l;
							if (u.ok) {
								n(G(Object.assign({
									key: e,
									meta: i.meta
								}, l)));
								const s = Object(g.m)(i, t);
								n(Object(I.h)({
									profileId: s,
									pinned: b
								}))
							} else n(B({
								account: u.body.data ? u.body.data.account : null,
								error: u.body.reason ? {
									type: u.body.reason
								} : u.error,
								key: e
							})), u.body.reason === w.a.DeletedProfile && n(Object(h.p)({
								profileName: t
							})), n(Object(v.m)(u.status))
						})(n, q, H)))
					} else {
						const n = Object(C.a)(q, d.lb, P, e.queryParams);
						s().listings.postOrder.ids[n] && !s().listings.postOrder.api.error[n] ? x = !0 : K.push(t(((e, t, s, n) => async (n, r, a) => {
							const i = r(),
								o = !!i.listings.postOrder.ids[e],
								d = !!Object(O.c)(i, {
									listingKey: e
								});
							if (!!Object(O.d)(i, {
									listingKey: e
								}) || o && !d) return;
							n(L({
								key: e
							}));
							const u = await Object(A.a)("profile", () => Object(c.b)(a.apiContext(), t, s)),
								l = u.body,
								{
									pinned: b,
									postIds: p
								} = l;
							if (u.ok) {
								n(U(Object.assign(Object.assign({
									key: e,
									meta: i.meta,
									profileName: t
								}, l), {
									postIds: p
								})));
								const s = Object(g.m)(i, t);
								n(Object(I.h)({
									profileId: s,
									pinned: b
								}))
							} else n(M({
								account: u.body.data ? u.body.data.account : null,
								error: u.body.reason ? {
									type: u.body.reason
								} : u.error,
								key: e
							})), u.body.reason === w.a.DeletedProfile && n(Object(h.p)({
								profileName: t
							})), n(Object(v.m)(u.status))
						})(n, q, H)))
					}
					if (K.push(t(Object(a.b)())), await Promise.all(K), x) return;
					const W = s();
					if (!W.platform.currentPage) return;
					if (200 !== W.platform.currentPage.status) return;
					const Y = Object(g.m)(s(), q),
						z = Object(m.gb)(W, {
							userName: k
						}).id;
					t(v.l({
						title: V(s(), k)
					})), Object(m.J)(W) && Object(m.L)(W, k) && t(Object(_.f)());
					const J = Object(p.a)(W),
						Q = [t(Object(o.q)()), t(T.b(q, Y)), t(S.b(q)), t(y.o(k)), t(S.g(k))];
					J && Q.push(t(E.e(k, z))), await Promise.all(Q)
				}, V = (e, t) => Object(g.q)(e, {
					profileName: t
				})
		},
		"./src/reddit/actions/pages/profilePosts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return C
			})), s.d(t, "e", (function() {
				return A
			})), s.d(t, "d", (function() {
				return D
			})), s.d(t, "h", (function() {
				return x
			})), s.d(t, "c", (function() {
				return N
			})), s.d(t, "b", (function() {
				return L
			})), s.d(t, "a", (function() {
				return U
			})), s.d(t, "g", (function() {
				return B
			}));
			s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/lodash/pick.js"),
				r = s.n(n),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/lib/makeListingKey/index.ts"),
				o = s("./src/reddit/actions/contentGate.ts"),
				c = s("./src/reddit/actions/externalAccount.ts"),
				d = s("./src/reddit/actions/moderatingSubreddits.ts"),
				u = s("./src/reddit/actions/pages/profileShared.ts"),
				l = s("./src/reddit/actions/pinnedPost.ts"),
				b = s("./src/reddit/actions/platform.ts"),
				p = s("./src/reddit/actions/profile/index.ts"),
				O = s("./src/reddit/actions/subreddit.ts"),
				g = s("./src/reddit/constants/errors.ts"),
				f = s("./src/reddit/constants/parameters.ts"),
				m = s("./src/reddit/contexts/PageLayer/index.tsx"),
				j = s("./src/config.ts"),
				_ = s("./src/lib/addAllowQuarantinedParam/index.ts"),
				h = s("./src/lib/constants/index.ts"),
				y = s("./src/lib/makeApiRequest/index.ts"),
				E = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const I = (e, t, s) => Object(y.a)(e, {
				data: s,
				endpoint: Object(_.a)(Object(E.a)("".concat(j.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/posts"))),
				method: h.db.GET
			}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? Object.assign(Object.assign({}, e), {
				body: Object.assign(Object.assign({}, e.body), {
					pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
				})
			}) : e);
			var v = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				S = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				T = s("./src/reddit/selectors/listings.ts"),
				w = s("./src/reddit/selectors/profile.ts");
			const C = "PAGE__PROFILE_POSTS_PENDING",
				A = "PAGE__PROFILE_POSTS_LOADED",
				D = "PAGE__PROFILE_POSTS_FAILED",
				P = Object(a.a)(C),
				R = Object(a.a)(A),
				k = Object(a.a)(D),
				x = e => async (t, s, n) => {
					const {
						queryParams: a,
						params: j
					} = e, {
						sort: _,
						t: h
					} = Object(u.b)(a), {
						profileName: y
					} = j, E = Object(i.a)("u_".concat(y), _, a), C = s(), A = C.listings.postOrder.ids[E], D = Object(T.c)(C, {
						listingKey: E
					}), x = Object(T.d)(C, {
						listingKey: E
					});
					if (await t(p.d(y)), x || A && !D) {
						if (A) {
							const e = Object(w.q)(s(), {
								profileName: y
							});
							t(b.l({
								title: e
							}))
						}
						return
					}
					const N = Object.assign(Object.assign({}, r()(e.queryParams, [...f.l, ...f.k, f.h])), {
						layout: Object(m.N)(C, {}).toLowerCase(),
						sort: _,
						t: Object(v.a)(_, h)
					});
					t(P({
						key: E
					}));
					const L = await Object(S.a)("profilePosts", () => I(n.apiContext(), y, N));
					if (!L.ok) return t(k({
						account: L.body.data ? L.body.data.account : null,
						error: L.body.reason ? {
							type: L.body.reason
						} : L.error,
						key: E
					})), L.body.reason === g.a.DeletedProfile && t(Object(o.p)({
						profileName: y
					})), void t(b.m(L.status));
					const U = L.body;
					t(R(Object.assign({
						key: E,
						meta: s().meta
					}, U)));
					const M = Object(w.m)(s(), y),
						{
							pinned: F
						} = U;
					t(Object(l.h)({
						profileId: M,
						pinned: F
					})), await Promise.all([t(Object(u.c)(y)), t(Object(O.q)()), t(Object(d.b)()), t(c.o(y))])
				}, N = "PROFILE_POSTS__MORE_POSTS_PENDING", L = "PROFILE_POSTS__MORE_POSTS_LOADED", U = "PROFILE_POSTS__MORE_POSTS_FAILED", M = Object(a.a)(N), F = Object(a.a)(L), G = Object(a.a)(U), B = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const a = t(),
						{
							currentPage: o
						} = a.platform;
					if (!o || !o.routeMatch) return;
					const {
						queryParams: c,
						params: d
					} = o.routeMatch.match, {
						sort: l,
						t: b
					} = Object(u.b)(c), {
						profileName: p
					} = d, O = Object(i.a)("u_".concat(p), l, c), g = Object(T.g)(a, {
						listingKey: O
					});
					if (!g) return;
					const j = Object(T.d)(a, {
							listingKey: O
						}),
						_ = Object(T.e)(a, {
							listingKey: O,
							token: g.token
						});
					if (j || _) return;
					e(M({
						key: O,
						fetchedToken: g.token
					}));
					const h = Object.assign(Object.assign({
							after: g.token,
							dist: g.dist,
							sort: l,
							t: b
						}, r()(c, f.l)), {
							layout: Object(m.N)(a, {}).toLowerCase()
						}),
						y = await I(n(), p, h),
						E = a.listings.postOrder.ids[O],
						v = y.body.postIds || [],
						S = Object.assign(Object.assign({}, y.body), {
							postIds: v.filter(e => !E || !E.includes(e))
						});
					y.ok ? (e(F(Object.assign({
						fetchedToken: g.token,
						key: O,
						meta: a.meta
					}, S))), await e(Object(u.c)(p))) : e(G({
						account: y.body.data ? y.body.data.account : null,
						error: y.error,
						fetchedToken: g.token,
						key: O
					}))
				}
		},
		"./src/reddit/actions/pages/profilePrivate/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "h", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "i", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "g", (function() {
				return u
			})), s.d(t, "d", (function() {
				return l
			}));
			const n = 25,
				r = "PAGE__PROFILE_PRIVATE_PENDING",
				a = "PAGE__PROFILE_PRIVATE_MIXED_LOADED",
				i = "PAGE__PROFILE_PRIVATE_POSTS_LOADED",
				o = "PAGE__PROFILE_PRIVATE_FAILED",
				c = "MORE__PROFILE_PRIVATE_PENDING",
				d = "MORE__PROFILE_PRIVATE_MIXED_LOADED",
				u = "MORE__PROFILE_PRIVATE_POSTS_LOADED",
				l = "MORE__PROFILE_PRIVATE_FAILED"
		},
		"./src/reddit/actions/pages/profileShared.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			})), s.d(t, "c", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/defaults.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/pick.js"),
				i = s.n(a),
				o = s("./src/reddit/actions/platform.ts"),
				c = s("./src/reddit/actions/profile/index.ts"),
				d = s("./src/reddit/actions/trophyCase.ts"),
				u = s("./src/reddit/selectors/profile.ts"),
				l = s("./src/lib/constants/index.ts");
			const b = {
				sort: l.ub,
				t: l.vb
			};

			function p(e) {
				return r()(i()(e, ["t", "sort"]), b)
			}

			function O(e, t) {
				return p(t)
			}
			const g = e => async (t, s, n) => {
				const r = [t(f(e)), t(m(e)), t(Object(c.g)(e))];
				await Promise.all(r)
			}, f = e => async (t, s, n) => {
				const r = Object(u.m)(s(), e);
				await t(d.b(e, r))
			}, m = e => async (t, s, n) => {
				const r = Object(u.q)(s(), {
					profileName: e
				});
				t(o.l({
					title: r
				})), await t(c.b(e))
			}
		},
		"./src/reddit/actions/pages/report/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "d", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			}));
			const n = "REPORT_PAGE__FAILED",
				r = "REPORT_PAGE__PENDING",
				a = "REPORT_PAGE__LOADED",
				i = "REPORT_PAGE_INITIAL_REASON__SET"
		},
		"./src/reddit/actions/pages/search.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return v
			})), s.d(t, "c", (function() {
				return S
			})), s.d(t, "a", (function() {
				return T
			})), s.d(t, "d", (function() {
				return P
			})), s.d(t, "e", (function() {
				return R
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/makeSearchKey/index.ts"),
				d = s("./src/lib/pageTitle.ts"),
				u = s("./src/reddit/actions/ads/index.ts"),
				l = s("./src/reddit/actions/category/index.ts"),
				b = s("./src/reddit/actions/communityFlairs/index.ts"),
				p = s("./src/reddit/actions/discoveryUnit.ts"),
				O = s("./src/reddit/actions/platform.ts"),
				g = s("./src/reddit/actions/search.ts"),
				f = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/constants/parameters.ts"),
				j = s("./src/reddit/endpoints/page/search.ts"),
				_ = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				h = s("./src/reddit/models/DiscoveryUnit/index.ts"),
				y = s("./src/reddit/models/Toast/index.ts"),
				E = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				I = s("./src/reddit/selectors/subreddit.ts");
			const v = "SEARCH__SEARCH_PENDING",
				S = "SEARCH__SEARCH_RESULTS_RECEIVED",
				T = "SEARCH__SEARCH_FAILED",
				w = Object(o.a)(v),
				C = Object(o.a)(S),
				A = Object(o.a)(T),
				D = e => n.fbt._("reddit.com: search results - {query}", [n.fbt._param("query", e || "None")], {
					hk: "1XOKAg"
				}),
				P = (e, t, s, r) => async (a, o, c) => {
					let {
						apiContext: d
					} = c;
					const O = o(),
						v = t[m.c],
						S = t.category;
					(v || S) && (await Promise.all([a(p.g()), a(l.a())]), S && await Promise.all([a(l.b(S, 10)), a(p.h(h.g, S))]));
					const {
						q: T
					} = t, D = !!T && i.Cb.some(e => T.includes("".concat(e, ":")));
					let R = t.type.indexOf(i.Nb.Posts) > -1 || !(!s || !t.restrict_sr) || D;
					if (R) {
						const t = O.listings.postOrder.ids[e],
							s = O.listings.postOrder.api.error[e];
						R = !(O.listings.postOrder.api.pending[e] || t && !s)
					}
					let k = t.type.indexOf(i.Nb.Subreddits) > -1 || t.type.indexOf(i.Nb.Users) > -1;
					if (k) {
						const t = O.listings.listingOrder.identifiers[e],
							s = O.listings.listingOrder.api.error[e];
						k = !(O.listings.listingOrder.api.pending[e] || t && !s)
					}
					if (!R && !k) return void(O.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						a(Object(u.b)(E.a.SEARCH_RESULTS))
					}));
					t.q && a(Object(g.h)(t.q));
					const x = "error-".concat(e),
						{
							type: N
						} = t;
					a(w({
						key: e,
						type: N
					}));
					const L = await Object(_.a)("searchResults", () => Object(j.a)(d(), s, r, Object.assign(Object.assign({}, t), {
						type: (t.type || []).join(","),
						b: !D
					})));
					if (L.ok) {
						const n = {
								key: e,
								type: N,
								meta: O.meta,
								searchQuery: t.q,
								subredditName: s,
								username: r
							},
							i = L.body;
						if (a(C(Object.assign(Object.assign({
								categoryName: v
							}, n), i))), a(f.f(x)), a(Object(u.b)(E.a.SEARCH_RESULTS)), s) {
							const e = Object(I.G)(o(), s),
								t = Object(b.c)(i.posts, e),
								n = Object(b.b)(i.structuredStyles || {}),
								r = (n ? Object(b.d)(n) : []).concat(t);
							a(Object(b.a)(r, e))
						}
					} else a(A(Object.assign({
						key: e,
						error: L.error,
						type: N
					}, L.body))), a(f.e({
						id: x,
						kind: y.b.Error,
						text: n.fbt._("Sorry, we couldn't load search results.", null, {
							hk: "QgweL"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "jld4g"
						}),
						buttonAction: P(e, t, s, r)
					}))
				}, R = e => async (t, s, n) => {
					const r = Object(c.c)(a()(e.queryParams, m.t)),
						o = e.params.subredditName || e.params.multiredditName,
						{
							username: u
						} = e.params,
						l = Object(c.b)(o, u, r);
					await t(P(l, r, o, u));
					const b = s();
					let p = !1;
					const {
						type: g = []
					} = r, f = g.indexOf(i.Nb.Posts) > -1, j = g.indexOf(i.Nb.Subreddits) > -1 || g.indexOf(i.Nb.Users) > -1;
					f && b.listings.postOrder.api.error[l] && (p = !0), j && b.listings.listingOrder.api.error[l] && (p = !0), t(p ? O.l({
						title: Object(d.c)()
					}) : O.l({
						title: D(r.q)
					}))
				}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return fe
			})), s.d(t, "d", (function() {
				return me
			})), s.d(t, "c", (function() {
				return je
			})), s.d(t, "a", (function() {
				return _e
			})), s.d(t, "k", (function() {
				return he
			})), s.d(t, "i", (function() {
				return Ie
			})), s.d(t, "e", (function() {
				return Se
			})), s.d(t, "g", (function() {
				return Te
			})), s.d(t, "h", (function() {
				return we
			})), s.d(t, "l", (function() {
				return Ce
			})), s.d(t, "b", (function() {
				return Ae
			})), s.d(t, "j", (function() {
				return De
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./node_modules/lodash/some.js"),
				o = s.n(i),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/isAdHocMultireddit/index.ts"),
				u = s("./src/lib/isFakeSubreddit/index.ts"),
				l = s("./src/lib/makeActionCreator/index.ts"),
				b = s("./src/lib/makeListingKey/index.ts"),
				p = s("./src/lib/makeSearchKey/index.ts"),
				O = s("./src/reddit/actions/ads/index.ts"),
				g = s("./src/reddit/actions/communityFlairs/index.ts"),
				f = s("./src/reddit/actions/contentGate.ts"),
				m = s("./src/reddit/actions/discoveryUnit.ts"),
				j = s("./src/reddit/actions/economics/helpers/async.ts"),
				_ = s("./src/reddit/actions/externalAccount.ts"),
				h = s("./src/reddit/actions/gold/powerups.ts"),
				y = s("./src/reddit/actions/gold/productOffers.ts"),
				E = s("./src/reddit/actions/pages/search.ts"),
				I = s("./src/reddit/actions/platform.ts"),
				v = s("./src/reddit/actions/seo/linksModule.ts"),
				S = s("./src/reddit/actions/structuredStyles/index.ts"),
				T = s("./src/reddit/actions/subreddit.ts"),
				w = (s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/react-router-redux/es/index.js")),
				C = s("./src/reddit/actions/toaster.ts"),
				A = s("./src/reddit/helpers/localStorage/index.ts"),
				D = s("./src/reddit/models/Subreddit/index.ts"),
				P = s("./src/reddit/models/Toast/index.ts"),
				R = s("./src/reddit/routes/postCreation/constants.ts"),
				k = s("./src/reddit/selectors/moderatorPermissions.ts"),
				x = s("./src/reddit/selectors/platform.ts"),
				N = s("./src/reddit/selectors/subreddit.ts"),
				L = s("./src/reddit/selectors/user.ts"),
				U = s("./src/reddit/selectors/widgets.ts");
			const M = () => async (e, t, s) => {
				const n = t(),
					r = Object(x.f)(n);
				if (!r || r.type !== D.e.Public) return;
				const a = r.name,
					i = Object(x.m)(n),
					o = Object(N.y)(n, {
						subredditName: a
					});
				if (!o) return;
				const {
					activity7Day: c
				} = o, d = !!c && c >= 51 && c <= 100, l = !a || Object(u.a)(a), b = i && i.urlParams.subredditName === a, p = Object(L.H)(n), O = Object(k.g)(n, {
					subredditId: Object(N.G)(n, a)
				});
				if (l || b || Object(A.q)() || !d || !p || O) return;
				const g = Object(U.d)(t(), {
					subredditName: a
				});
				if (!g || !g.currentlyViewingCount) return;
				const f = (24 * g.currentlyViewingCount * 7).toString(),
					m = f[0].padEnd(f.length, "0");
				e(Object(C.e)({
					buttonAction: async () => e(Object(w.b)("/r/".concat(a).concat(R.b))),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: P.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(A.ab)(),
					secondButtonText: "Dismiss",
					text: "There have been over ".concat(m, " visits to r/").concat(a, " in the past week. Create a new post and start the next conversation.")
				}))
			};
			var F = s("./src/reddit/actions/subreddit/questions.ts"),
				G = s("./src/reddit/actions/subredditSettings.ts"),
				B = s("./src/reddit/actions/tags/index.ts"),
				q = s("./src/reddit/constants/page.ts"),
				V = s("./src/reddit/constants/parameters.ts"),
				H = s("./src/reddit/constants/postLayout.ts"),
				K = s("./src/reddit/contexts/PageLayer/index.tsx"),
				W = s("./src/reddit/endpoints/governance/posts.ts"),
				Y = s("./src/reddit/endpoints/page/subredditPage.ts"),
				z = s("./src/reddit/endpoints/profile/info.ts"),
				J = s("./src/reddit/helpers/canonicalUrls.ts"),
				Q = s("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				X = s("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				Z = s("./src/reddit/helpers/timeApiRoute/index.ts"),
				$ = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				ee = s("./src/reddit/models/Gold/ProductOffer.ts"),
				te = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				se = s("./src/reddit/models/RichTextJson/index.ts"),
				ne = s("./src/reddit/models/User/index.ts"),
				re = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				ae = s("./src/reddit/selectors/communityFlairs.ts"),
				ie = s("./src/reddit/selectors/experiments/goldSubredditPowerups.ts"),
				oe = s("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				ce = s("./node_modules/reselect/es/index.js"),
				de = s("./src/reddit/constants/experiments.ts"),
				ue = s("./src/reddit/helpers/chooseVariant/index.ts");
			const le = Object(ce.a)(e => {
				return !!Object(ue.c)(e, {
					experimentEligibilitySelector: ue.a,
					experimentName: de.kb,
					expEventOverride: !1
				})
			}, L.H, N.S, U.j, (e, t, s, n) => e && !t && !s.isNSFW && !n.some(e => "community-list" === e));
			var be = s("./src/reddit/selectors/experiments/topPosts.ts"),
				pe = s("./src/reddit/selectors/inlineSubredditEditing.ts"),
				Oe = s("./src/reddit/selectors/multireddit.ts"),
				ge = (s("./src/reddit/selectors/posts.ts"), s("./src/reddit/actions/publicAccessNetwork/api.ts"));
			const fe = (e, t) => async s => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: n,
							reason: r
						}
					} = e, a = n ? n.account : void 0, i = n && n.features || void 0, o = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (r === D.d.NotFoundSubreddit) s(f.o({
							account: a,
							features: i,
							subredditName: o
						}));
						else if (r === D.d.BannedSubreddit) {
						const e = n ? n.banMessage || n.ban_message : void 0;
						s(f.m({
							banMessage: e,
							account: a,
							features: i,
							subredditName: o
						}))
					}
					if (451 === e.status && s(f.n({
							account: a,
							features: i,
							subredditName: o
						})), 403 === e.status)
						if (r === D.d.GoldSubreddit) s(f.q({
							account: a,
							features: i,
							subredditName: o
						}));
						else if (r === D.d.PrivateSubreddit) s(f.r({
						account: a,
						features: i,
						subredditDescription: n.description || "",
						subredditName: o
					}));
					else if (r === D.d.QuarantinedSubreddit) {
						const e = !n || void 0 === n.quarantineRequiresEmailOptin || n.quarantineRequiresEmailOptin;
						s(f.t({
							account: a,
							features: i,
							subredditName: o,
							quarantineRequiresEmail: e,
							quarantineMessage: n.quarantineMessage,
							quarantineMessageHtml: n.quarantineMessageHtml || "",
							quarantineMessageRTJson: n.quarantineMessageRTJson || se.i
						}))
					}
				}
			}, me = "PAGE__SUBREDDIT_PENDING", je = "PAGE__SUBREDDIT_LOADED", _e = "PAGE__SUBREDDIT_FAILED", he = Object(l.a)(me), ye = Object(l.a)(je), Ee = Object(l.a)(_e), Ie = (e, t, s, r) => async (a, i, d) => {
				var l;
				const b = i(),
					p = Object(L.H)(b),
					f = b.listings.postOrder.api.pending[e],
					m = Object(L.i)(b);
				if (f) return;
				const E = t !== q.c.All && t !== q.c.Popular || !b.posts.recent.length ? s : Object.assign(Object.assign({}, s), {
					recentPostIds: b.posts.recent
				});
				E.layout = H.e[Object(K.N)(b, {})], a(he({
					key: e
				}));
				const S = Object(oe.b)(b),
					w = S ? () => Object(Y.b)(d.gqlContext(), Object(Y.c)(b, t, E), p) : () => Object(Y.a)(d.apiContext(), t, E),
					A = p && m && !S ? Object(z.d)(d.gqlContext(), Object(ne.e)(m)) : null,
					[D, R] = await Promise.all([Object(Z.a)("subreddit", w), A]),
					k = D.body;
				a(I.m(D.status));
				const x = "error-".concat(e),
					U = Object(u.a)(t) || o()(k.subreddits, e => e.name.toLowerCase() === t.toLowerCase());
				if (D.ok && U) {
					if (!Object(u.a)(t) && Object(ie.a)(b)) {
						const e = Object.keys(k.subredditAboutInfo)[0];
						await Promise.all([a(Object(h.g)()), a(Object(h.f)(e, {
							fullData: !0
						})), a(Object(y.a)(e, ee.a.Powerups))])
					}
					let s;
					const n = k.postIds.filter(e => !!k.posts[e].isMeta);
					if (n.length) {
						const e = Object.keys(k.subreddits).reduce((e, s) => {
							const n = k.subreddits[s];
							return n.name.toLowerCase() === t.toLowerCase() ? n.id : e
						}, null);
						if (e) {
							const t = await Object(W.a)(d.apiContext(), e, n);
							t.ok && (s = t.body)
						}
					}
					if (R && R.ok) {
						const e = null === (l = R.body.data.redditorInfoByName) || void 0 === l ? void 0 : l.karma,
							t = e ? {
								awardeeKarma: e.fromAwardsReceived,
								awarderKarma: e.fromAwardsGiven,
								commentKarma: e.fromComments,
								postKarma: e.fromPosts,
								totalKarma: e.total
							} : z.a;
						k.account && Object.assign(k.account, t)
					}
					if (a(ye(Object.assign(Object.assign({
							key: e,
							meta: b.meta,
							governance: s
						}, k), {
							postIds: k.postIds
						}))), !Object(u.a)(t)) {
						const e = Object(N.G)(i(), t);
						!!Object(N.R)(b, {
							subredditId: e
						}) || await T.o(t)(a, i, d);
						const s = Object(g.c)(k.posts, e),
							n = Object(g.b)(k.structuredStyles),
							r = (n ? Object(g.d)(n) : []).concat(s);
						a(Object(g.a)(r, e))
					}
					r && a(C.f(x)), a(Object(O.b)(re.a.SUBREDDIT)), a(Object(_.p)());
					const o = Object(N.G)(i(), t);
					if (o) {
						const e = [a(Object(j.a)({
							subredditId: o,
							postIds: k.postIds,
							skip: ["subscription"]
						}))];
						S || e.push(a(Object(F.c)(o))), le(i(), {
							subredditId: o
						}) && e.push(a(Object(v.d)(o))), Object(pe.a)(i(), {
							subredditId: o
						}) && e.push(a(Object(G.h)(t, o)), a(Object(B.k)(o, $.a.idCard))), await Promise.all(e)
					}
				} else {
					if (403 === D.status || 404 === D.status || 451 === D.status) return void a(fe(D, t));
					a(Ee(Object.assign({
						error: !D.ok && D.error || {
							type: c.E.NOT_FOUND_ERROR
						},
						key: e
					}, k))), r && a(C.e({
						id: x,
						kind: P.b.Error,
						text: n.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: Ie(e, t, s, r)
					}))
				}
			}, ve = (e, t) => {
				if (Object(u.a)(t)) {
					if (Object(d.a)(t)) {
						return Object(Oe.a)(e, {
							listingName: t
						}).displayText
					}
					switch (t.toLowerCase()) {
						case q.c.Popular:
							return "r/popular";
						case q.c.All:
							return "r/all"
					}
				}
				return Object(N.V)(e, {
					subredditName: t
				})
			}, Se = (e, t) => {
				const s = e.f;
				if (s) return {
					[V.p]: s,
					[V.s]: "1",
					[V.i]: t ? "1" : "",
					sort: c.Lb.New
				}
			}, Te = (e, t) => {
				const s = Se(e, t);
				return s && Object(p.c)(s)
			}, we = (e, t, s, n) => n ? Object(p.b)(e, void 0, n) : Object(b.a)(e, t, s), Ce = (e, t) => async (s, n, r) => {
				const {
					subredditName: i
				} = e.params, {
					styling: o
				} = e.queryParams, d = n(), l = Object(Q.a)(e.params, d), p = Te(e.queryParams, Object(L.X)(d)), f = we(i, l, e.queryParams, p), j = l, h = d.listings.postOrder.api.error[f], y = d.listings.postOrder.api.pending[f];
				let v = !!d.listings.postOrder.ids[f];
				const T = d.listings.postOrder.listingSort[f];
				T && T.hasChanged && (v = !1);
				let w = Object(N.G)(d, i);
				const C = (e, t) => "true" === o && ((e, t) => Object(k.a)(te.c.config)(e, {
						subredditId: t
					}) || Object(k.a)(te.c.flair)(e, {
						subredditId: t
					}))(e, t),
					A = V.x in e.queryParams && e.queryParams[V.x].toUpperCase() || "",
					D = A in c.Sb && c.Sb[A];
				if (y || v && !h && !t) {
					if (C(d, w) && s(S.i(w)), v) {
						const t = ve(n(), i);
						s(I.l({
							title: t
						})), Object(J.e)(n(), s, e), window.addEventListener("load", () => {
							s(Object(_.p)())
						}), d.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							s(Object(O.b)(re.a.SUBREDDIT))
						}), s(M())
					}
					return
				}
				s(m.g());
				const P = s(Object(ge.c)("r/".concat(i)));
				if (p) await s(Object(E.d)(f, p, i));
				else {
					const t = Object.assign(Object.assign({}, a()(e.queryParams, [...V.l, ...V.k, V.h])), {
							sort: j,
							t: Object(X.a)(j, D)
						}),
						n = d.user.prefs.geopopular || d.meta.country;
					!t[V.h] && n && (t[V.h] = n), await s(Ie(f, i, t, !0))
				}
				const R = d.platform.currentPage,
					x = Object(be.d)(d, {
						pageLayer: R
					});
				if (Object(be.a)(x) || Object(be.b)(x) || Object(be.c)(x)) {
					const e = Object(b.a)(i, c.O.TOP, {
							t: c.Sb.WEEK
						}),
						t = {
							sort: c.O.TOP,
							t: c.Sb.WEEK
						};
					await s(Ie(e, i, t, !1))
				}
				w = w || Object(N.G)(n(), i), Object(ae.a)(d, w) || Object(u.a)(i) || await s(Object(g.e)(i)), C(n(), w) && s(S.i(w)), Object(J.e)(n(), s, e);
				const U = ve(n(), i);
				s(I.l({
					title: U
				})), s(M()), await P
			}, Ae = "PAGE__SUBREDDIT_INVALIDATE_LISTING", De = Object(l.a)(Ae)
		},
		"./src/reddit/actions/pages/subredditWiki/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = "PAGE__SUBREDDIT_WIKI_PAGE_PENDING",
				r = "PAGE__SUBREDDIT_WIKI_PAGE_LOADED",
				a = "PAGE__SUBREDDIT_WIKI_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/topic.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return _
			})), s.d(t, "e", (function() {
				return h
			})), s.d(t, "d", (function() {
				return y
			})), s.d(t, "j", (function() {
				return I
			})), s.d(t, "i", (function() {
				return v
			})), s.d(t, "c", (function() {
				return S
			})), s.d(t, "b", (function() {
				return T
			})), s.d(t, "a", (function() {
				return w
			})), s.d(t, "g", (function() {
				return k
			})), s.d(t, "k", (function() {
				return x
			})), s.d(t, "h", (function() {
				return N
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/makeListingKey/index.ts"),
				a = s("./src/reddit/actions/platform.ts"),
				i = s("./src/reddit/constants/listings.ts"),
				o = s("./src/graphql/operations/TopicBySlug.json"),
				c = s("./src/lib/makeGqlRequest/index.ts");
			var d = s("./src/reddit/helpers/canonicalUrls.ts"),
				u = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				l = s("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				b = s("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				p = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				O = s("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				g = s("./src/reddit/models/Post/index.ts"),
				f = s("./src/reddit/selectors/listings.ts"),
				m = s("./src/reddit/selectors/topic.ts"),
				j = s("./src/reddit/selectors/user.ts");
			const _ = "TOPIC_PAGE__DATA_PENDING",
				h = "TOPIC_PAGE__DATA_LOADED",
				y = "TOPIC_PAGE__DATA_FAILED",
				E = Object(n.a)(_),
				I = Object(n.a)(h),
				v = Object(n.a)(y),
				S = "TOPIC_PAGE__MORE_POSTS_PENDING",
				T = "TOPIC_PAGE__MORE_POSTS_LOADED",
				w = "TOPIC_PAGE__MORE_POSTS_FAILED",
				C = Object(n.a)(S),
				A = Object(n.a)(T),
				D = Object(n.a)(w),
				P = e => {
					const t = [];
					if (e.relatedTopics && e.relatedTopics.edges)
						for (const {
								node: s
							} of e.relatedTopics.edges) t.push(R(s));
					return Object.assign(Object.assign({}, e), {
						relatedTopics: t
					})
				},
				R = e => {
					const {
						id: t,
						name: s,
						namePlural: n,
						slug: r,
						wikidataId: a
					} = e;
					return {
						id: t,
						name: s,
						namePlural: n,
						slug: r,
						url: "/t/".concat(e.slug, "/"),
						wikidataId: a
					}
				},
				k = async (e, t, s) => {
					const n = await ((e, t) => Object(c.a)(e, Object.assign(Object.assign({}, o), {
						variables: t
					})))(e, Object.assign({
						firstPosts: 20,
						firstRelatedTopics: 1e3,
						firstSubreddits: 30,
						includeIdentity: !1,
						includePosts: !0,
						includeRelationships: !0,
						includeSubreddits: !0,
						includeTopic: !0,
						topicSlug: t
					}, s));
					if (!n.ok) throw n;
					return (e => {
						const t = {},
							s = [],
							n = {},
							r = {};
						if (!e.topicBySlug) return;
						const a = e.topicBySlug.posts && e.topicBySlug.posts.edges || [];
						for (const l of a) {
							const e = l && l.node;
							if (e && (s.push(e.id), t[e.id] = Object(u.e)(e), e.__typename === g.f.SubredditPost && e.subreddit && e.subreddit.id)) {
								const {
									subreddit: t
								} = e;
								n[t.id] = Object(p.a)(t)
							}
						}
						const i = [],
							o = e.topicBySlug.subreddits && e.topicBySlug.subreddits.edges || [];
						for (const u of o) {
							const e = u && u.node;
							if (e && e.id) {
								n[e.id] = Object(p.a)(e);
								const t = Object(b.a)(e)[e.id];
								t && (r[e.id] = t, i.push(e.id))
							}
						}
						const c = (e.topicBySlug.parentRelationships || []).map(P),
							d = (e.topicBySlug.childRelationships || []).map(P),
							f = (e.topicBySlug.siblingRelationships || []).map(P),
							m = Object.assign({
								childRelationships: d,
								hasPosts: !!Object.keys(t).length,
								hasSubreddits: !!i.length,
								parentRelationships: c,
								siblingRelationships: f,
								subredditIds: i
							}, R(e.topicBySlug)),
							j = m.id ? {
								[m.id]: m
							} : void 0,
							_ = e.topicBySlug.posts && e.topicBySlug.posts.pageInfo,
							h = _ && _.hasNextPage ? _.endCursor : void 0;
						let y, E;
						return e.identity && (y = Object(O.a)(e.identity), E = Object(l.a)(e.identity.preferences, e.identity.interactions)), {
							account: y,
							preferences: E,
							postIds: s,
							posts: t,
							subredditAboutInfo: r,
							subreddits: n,
							token: h,
							topics: j
						}
					})(n.body.data)
				}, x = (e, t) => async (s, n, o) => {
					let {
						gqlContext: c
					} = o;
					const u = n();
					if (Object(d.f)(u, s, e)) return;
					const l = e.params.topicSlug,
						b = Object(r.a)(i.b.Topic, null, Object.assign(Object.assign({}, e.params), {
							topicSlug: l
						})),
						p = Object(f.c)(u, {
							listingKey: b
						}),
						O = Object(f.d)(u, {
							listingKey: b
						}),
						g = !!u.listings.postOrder.ids[b];
					if (O || g && !p && !t) {
						if (g) {
							const e = Object(m.f)(n(), {
								topicSlug: l
							});
							e && s(a.l({
								title: e
							}))
						}
						return
					}
					let _;
					s(E({
						key: b
					}));
					try {
						_ = await k(c(), l, {
							includeIdentity: Object(j.O)(u) && !u.user.account
						})
					} catch (y) {
						const e = y.error;
						if (!(e.fields && e.fields.some(e => "Topic not found" === e.msg))) throw s(v({
							key: b,
							error: e
						})), s(a.m(y.status || 500)), new Error("Topic page fetching failed: upstream service error")
					}
					if (!_ || !(e => !!(e && e.topics && Object.keys(e.topics).length > 0 && (Object.keys(e.posts).length > 0 || Object.keys(e.subreddits).length > 0)))(_)) return void s(a.m(404));
					s(I(Object.assign(Object.assign({}, _), {
						key: b,
						meta: u.meta
					})));
					const h = Object(m.f)(n(), {
						topicSlug: l
					});
					h && s(a.l({
						title: h
					}))
				}, N = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					const o = s(),
						c = e.topicSlug,
						d = Object(r.a)(i.b.Topic, null, e),
						u = Object(f.g)(o, {
							listingKey: d
						});
					if (!u) return;
					const l = Object(f.d)(o, {
							listingKey: d
						}),
						b = Object(f.e)(o, {
							listingKey: d,
							token: u.token
						});
					if (l || b) return;
					let p;
					t(C({
						key: d
					}));
					try {
						p = await k(a(), c, {
							afterPosts: u.token,
							includeRelationships: !1,
							includeSubreddits: !1,
							includeTopic: !1
						})
					} catch (O) {
						return void t(D({
							key: d,
							error: O
						}))
					}
					p && t(A(Object.assign(Object.assign({}, p), {
						key: d,
						fetchedToken: u.token,
						meta: o.meta
					})))
				}
		},
		"./src/reddit/actions/pages/userDataRequest/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "d", (function() {
				return f
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/endpoints/me/index.ts"),
				a = s("./src/graphql/operations/UserDataExportEligibility.json"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				o = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				c = s("./src/reddit/selectors/user.ts"),
				d = s("./src/reddit/selectors/userDataRequest.ts");
			const u = "USER_DATA_REQUEST_PAGE_LOADING",
				l = "USER_DATA_REQUEST_PAGE_LOADED",
				b = "USER_DATA_REQUEST_PAGE_FAILED",
				p = Object(n.a)(u),
				O = Object(n.a)(l),
				g = Object(n.a)(b),
				f = () => async (e, t, s) => {
					let {
						apiContext: n,
						gqlContext: u
					} = s;
					const l = t(),
						b = Object(c.i)(l),
						f = Object(d.b)(l);
					if (b && f.success) return;
					e(p());
					const m = await Object(r.a)(n());
					if (!m.ok || !m.body) return void e(g(m.error));
					if (!m.body.account) return void Object(o.a)(e, l);
					const j = await (e => Object(i.a)(e, Object.assign({}, a)))(u());
					if (!j.ok) return void e(g());
					const _ = m.body,
						h = j.body;
					e(O({
						account: _.account,
						userDataExportEligibility: h.data.identity.userDataExportEligibility.isUserEligibleForDataExport
					}))
				}
		},
		"./src/reddit/actions/pinnedPost.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return p
			})), s.d(t, "h", (function() {
				return O
			})), s.d(t, "d", (function() {
				return g
			})), s.d(t, "g", (function() {
				return f
			})), s.d(t, "c", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "b", (function() {
				return I
			})), s.d(t, "e", (function() {
				return v
			})), s.d(t, "i", (function() {
				return R
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/modal.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/reddit/constants/modals.ts"),
				d = s("./src/reddit/endpoints/post/index.tsx"),
				u = s("./src/reddit/models/Toast/index.ts"),
				l = s("./src/reddit/selectors/posts.ts"),
				b = s("./src/reddit/selectors/profile.ts");
			const p = "PINNEDPOST__PINNED_POSTS_LOADED",
				O = Object(a.a)(p),
				g = "PINNEDPOST__PIN_POST_SUCCESS",
				f = "PINNEDPOST__UNPIN_POST_SUCCESS",
				m = Object(a.a)(g),
				j = Object(a.a)(f),
				_ = "PINNEDPOST__PIN_POST_PENDING",
				h = "PINNEDPOST__UNPIN_POST_PENDING",
				y = Object(a.a)(_),
				E = Object(a.a)(h),
				I = "PINNEDPOST__PIN_POST_FAILURE",
				v = "PINNEDPOST__UNPIN_POST_FAILURE",
				S = Object(a.a)(I),
				T = Object(a.a)(v),
				w = e => Object(o.e)({
					buttonAction: R(e, !0),
					buttonText: n.fbt._("UNDO", null, {
						hk: "1O9LWh"
					}),
					kind: u.b.SuccessMod,
					text: n.fbt._("Post pinned to profile!", null, {
						hk: "1hbHLt"
					})
				}),
				C = (e, t) => Object(o.e)({
					buttonAction: R(e, !0),
					buttonText: n.fbt._("UNDO", null, {
						hk: "3YtcK2"
					}),
					kind: u.b.SuccessMod,
					text: t ? n.fbt._("Post unpinned, reload to see changes", null, {
						hk: "5FF1g"
					}) : n.fbt._("Post unpinned.", null, {
						hk: "2BgT0h"
					})
				}),
				A = () => Object(o.e)({
					kind: u.b.Error,
					text: n.fbt._("Could not pin post", null, {
						hk: "3uNHEh"
					})
				}),
				D = () => Object(o.e)({
					kind: u.b.Error,
					text: n.fbt._("You can't pin a removed post", null, {
						hk: "3bdn2y"
					})
				}),
				P = () => Object(o.e)({
					kind: u.b.Error,
					text: n.fbt._("Could not unpin post", null, {
						hk: "o8HG0"
					})
				}),
				R = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (s, n, a) => {
						let {
							apiContext: o
						} = a;
						const u = n(),
							p = u.posts.models[e];
						if (!p) return;
						const O = !Object(l.w)(u, {
							postId: e
						});
						if (O && p.isRemoved) return s(D());
						const g = p.author,
							f = Object(b.m)(u, g),
							[_, h, I, v, R] = O ? [y, m, S, w, A] : [E, j, T, C, P];
						if (O) {
							if (Object(l.V)(u, {
									profileName: g
								}).length >= r.V) return void s(Object(i.i)(c.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const k = Object(l.q)(u, e, g),
							x = !O && k;
						s(_({
							postId: e,
							profileId: f
						})), (await Object(d.t)(o(), e, O, !0)).ok ? (s(h({
							postId: e,
							profileId: f
						})), t || s(v(e, x))) : (s(I({
							postId: e,
							profileId: f
						})), s(R()))
					}
				}
		},
		"./src/reddit/actions/platform.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return f
			})), s.d(t, "b", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "c", (function() {
				return _
			})), s.d(t, "e", (function() {
				return h
			})), s.d(t, "f", (function() {
				return y
			})), s.d(t, "h", (function() {
				return E
			})), s.d(t, "i", (function() {
				return I
			})), s.d(t, "m", (function() {
				return T
			})), s.d(t, "l", (function() {
				return w
			})), s.d(t, "k", (function() {
				return C
			})), s.d(t, "j", (function() {
				return A
			})), s.d(t, "g", (function() {
				return D
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.search.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./src/lib/areUrlsEqual/index.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/logs/errors.ts"),
				i = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/lib/matchRoute/index.ts"),
				c = (s("./src/lib/addQueryParams/index.ts"), s("./src/lib/isEqualWithoutKey/index.ts")),
				d = s("./src/reddit/actions/tracing.ts"),
				u = s("./src/reddit/constants/experiments.ts"),
				l = s("./src/reddit/constants/listings.ts"),
				b = s("./src/reddit/helpers/routeKey/index.ts"),
				p = s("./src/reddit/selectors/experiments/postSeo.ts");
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/reddit/helpers/chooseVariant/index.ts");
			new Set([r.Bb.COMMENTS, r.Bb.INDEX, r.Bb.LISTING, r.Bb.PROFILE_COMMENTS, r.Bb.PROFILE_OVERVIEW, r.Bb.PROFILE_POSTS, r.Bb.SUBREDDIT]);
			var O = s("./src/reddit/selectors/platform.ts"),
				g = s("./src/reddit/singleton/tracing/index.ts");
			const f = "PLATFORM__HISTORY_LOCATION_SET",
				m = "PLATFORM__INITIAL_REFERRER_SET",
				j = "PLATFORM__NAVIGATION_CONFIRMATION_REQUESTED",
				_ = "PLATFORM__NAVIGATION_CONFIRMATION_DISCARDED",
				h = "PLATFORM__PAGE_META_SET",
				y = "PLATFORM__PAGE_STATUS_SET",
				E = e => async (t, s, n) => {
					const {
						currentPage: r
					} = s().platform;
					if (!r) return;
					const a = Object(o.a)(r.url, e);
					a && a.route.action(a.match)(t, s, n)
				}, I = (e, t, s) => async (a, i, o) => {
					const f = i().platform.currentPage;
					(!s || s.route.chunk === r.p.SUBREDDIT && l.a.has(s.match.params.subredditName.toLowerCase())) && window.location.replace("https://www.reddit.com".concat(e.pathname).concat(e.search));
					const m = s ? Object(b.c)(s, i()).listingKey : null,
						{
							user: j
						} = i(),
						_ = s && s.match && s.match.queryParams,
						h = _ && _["experiment_".concat(u.Cb)];
					Object(p.f)(i()), e.pathname.split("/").some(e => "comments" === e), Object(O.i)(i());
					if (a(v({
							action: t,
							listingKey: m,
							location: e,
							routeMatch: s,
							user: j
						})), f && Object(n.a)(f.url, e)) return;
					g.b.isEnabled;
					let y = !1;
					if (g.b.isEnabled) {
						if (f && f.locationState && Object(c.a)(f.locationState.closeLocation, e)) {
							const e = g.b.createRootSpanId();
							g.b.setParent(e), a(Object(d.b)(e.spanId))
						} else y = !0
					}
					if (s) {
						const {
							match: e
						} = s;
						if (y) {
							const t = g.b.createRootSpanId();
							g.b.setParent(t), a(Object(d.b)(t.spanId));
							const n = s && s.route.action.name,
								r = s && s.route ? "".concat(n, "_").concat(s.route.meta.name) : "",
								c = {
									[g.a.HttpUrl]: e.url
								};
							await g.b.recordRequest(r, c, async () => {
								await s.route.action(e)(a, i, o)
							})
						} else await s.route.action(e)(a, i, o)
					}
				}, v = Object(i.a)(f), S = (Object(i.a)(m), Object(i.a)(h)), T = Object(i.a)(y), w = e => async (t, s, n) => {
					const r = s(),
						{
							currentPage: a
						} = r.platform;
					if (!a) return;
					const {
						key: i
					} = a;
					await t(S({
						key: i,
						meta: e
					}))
				}, C = Object(i.a)(j), A = Object(i.a)(_), D = () => async (e, t, s) => {
					if (window !== window.parent) {
						Object(a.sendRavenError)(s.apiContext(), {
							extra: {
								errorType: r.q.NOT_ALLOWED_ACCESS,
								value: "Page was unexpectedly loaded inside iframe"
							}
						});
						try {
							window.top.location.href = window.location.href
						} catch (n) {}
					}
				}
		},
		"./src/reddit/actions/polls.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "POLLS__POLL_CREATION_UPDATED",
				a = Object(n.a)(r)
		},
		"./src/reddit/actions/post.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return ee
			})), s.d(t, "c", (function() {
				return te
			})), s.d(t, "h", (function() {
				return se
			})), s.d(t, "g", (function() {
				return ne
			})), s.d(t, "r", (function() {
				return re
			})), s.d(t, "k", (function() {
				return ie
			})), s.d(t, "J", (function() {
				return ce
			})), s.d(t, "e", (function() {
				return de
			})), s.d(t, "d", (function() {
				return ue
			})), s.d(t, "z", (function() {
				return le
			})), s.d(t, "y", (function() {
				return be
			})), s.d(t, "P", (function() {
				return pe
			})), s.d(t, "L", (function() {
				return Oe
			})), s.d(t, "S", (function() {
				return fe
			})), s.d(t, "q", (function() {
				return me
			})), s.d(t, "F", (function() {
				return _e
			})), s.d(t, "G", (function() {
				return he
			})), s.d(t, "t", (function() {
				return Ie
			})), s.d(t, "H", (function() {
				return ve
			})), s.d(t, "m", (function() {
				return Se
			})), s.d(t, "K", (function() {
				return Te
			})), s.d(t, "E", (function() {
				return we
			})), s.d(t, "w", (function() {
				return Ce
			})), s.d(t, "O", (function() {
				return Ae
			})), s.d(t, "B", (function() {
				return De
			})), s.d(t, "A", (function() {
				return Pe
			})), s.d(t, "p", (function() {
				return Re
			})), s.d(t, "Q", (function() {
				return ke
			})), s.d(t, "R", (function() {
				return xe
			})), s.d(t, "v", (function() {
				return Le
			})), s.d(t, "i", (function() {
				return Ue
			})), s.d(t, "n", (function() {
				return Fe
			})), s.d(t, "l", (function() {
				return Ge
			})), s.d(t, "M", (function() {
				return Be
			})), s.d(t, "D", (function() {
				return qe
			})), s.d(t, "I", (function() {
				return Ve
			})), s.d(t, "u", (function() {
				return He
			})), s.d(t, "C", (function() {
				return Ke
			})), s.d(t, "j", (function() {
				return We
			})), s.d(t, "s", (function() {
				return ze
			})), s.d(t, "N", (function() {
				return Je
			})), s.d(t, "f", (function() {
				return Qe
			})), s.d(t, "x", (function() {
				return Xe
			})), s.d(t, "a", (function() {
				return Ze
			})), s.d(t, "o", (function() {
				return $e
			}));
			var n = s("./node_modules/@reddit/onetrust-integration/dist/esm/index.js"),
				r = s("./src/config.ts"),
				a = s("./node_modules/fbt/lib/FbtPublic.js"),
				i = s("./node_modules/js-cookie/src/js.cookie.js"),
				o = s.n(i),
				c = s("./src/lib/addQueryParams/index.ts"),
				d = s("./src/lib/copyToClipboard/index.ts"),
				u = s("./src/lib/makeActionCreator/index.ts"),
				l = s("./src/reddit/actions/ads/constants.ts"),
				b = s("./src/reddit/actions/login.ts"),
				p = s("./src/reddit/actions/platform.ts"),
				O = s("./src/reddit/constants/adEvents.ts"),
				g = s("./src/reddit/helpers/getVendorMetadata.ts"),
				f = s("./src/lib/LRUCache/index.ts"),
				m = s("./node_modules/query-string/index.js"),
				j = s.n(m),
				_ = s("./src/lib/sentry/index.ts");
			const h = new f.a(1e3),
				y = (e, t, s) => {
					return e.events.filter(e => e.type === t).every(e => ((e, t) => {
						let {
							url: s,
							type: n
						} = e;
						if (!s) return _.c.captureMessage("Pixel of type ".concat(n, " has no url")), !1;
						if (!h.get(s)) {
							const e = /^(http|https):\/\/([a-z]+\.)?reddit.com/.test(s);
							let n;
							if (t && e) {
								const {
									url: e,
									query: r
								} = j.a.parseUrl(s);
								n = j.a.stringifyUrl({
									url: e,
									query: Object.assign(Object.assign({}, r), t)
								})
							}
							const r = new Image;
							return h.set(s, !0), n && (s = n), r.src = s, !0
						}
						return !1
					})(e, s))
				};
			var E = s("./src/reddit/selectors/posts.ts"),
				I = s("./src/reddit/actions/unload/constants.ts");
			let v = !1;
			Object(u.a)(I.b);
			const S = (e, t, s) => {
				if (window && !v && (window.addEventListener("beforeunload", () => (e => {
						I.a.forEach(t => {
							let {
								post: s
							} = t;
							const n = Object(E.b)(e(), s.id),
								r = Object(g.a)(s.id, n, O.a.Unload);
							y(s, O.a.Unload, r)
						})
					})(s)), v = !0), I.c.has(e.id) || e.isBlank) return;
				I.c.add(e.id);
				const n = {
					post: e,
					unloadTimer: window.setTimeout(() => {
						t(Ie(e, O.a.Unload))
					}, I.d)
				};
				if (I.a.push(n), I.a.length > 5) {
					const e = I.a.shift();
					t(Ie(e.post, O.a.Unload)), clearTimeout(e.unloadTimer)
				}
			};
			var T = s("./src/reddit/actions/video.ts"),
				w = s("./src/reddit/actions/vote.ts"),
				C = s("./src/reddit/constants/cookie.ts"),
				A = s("./src/reddit/constants/history.ts"),
				D = s("./src/reddit/constants/posts.ts"),
				P = s("./src/reddit/helpers/isPost.ts"),
				R = s("./src/reddit/helpers/overlay/index.ts"),
				k = s("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				x = s("./src/reddit/models/Media/index.ts"),
				N = s("./src/reddit/endpoints/post/index.tsx"),
				L = s("./src/lib/makeGqlRequest/index.ts"),
				U = s("./src/graphql/operations/RichTextPostContent.json");
			var M = s("./src/lib/constants/index.ts"),
				F = s("./src/lib/makeListingKey/index.ts"),
				G = s("./node_modules/react-router-redux/es/index.js"),
				B = s("./src/reddit/actions/modal.ts"),
				q = s("./src/reddit/actions/toaster.ts"),
				V = s("./src/reddit/constants/modals.ts"),
				H = s("./src/reddit/endpoints/page/commentsPage.ts"),
				K = s("./src/reddit/helpers/trackers/post.ts"),
				W = s("./src/reddit/models/Flair/index.ts"),
				Y = s("./src/reddit/models/Toast/index.ts"),
				z = s("./src/reddit/models/User/index.ts"),
				J = s("./src/reddit/models/Vote/index.ts"),
				Q = s("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				X = s("./src/reddit/selectors/platform.ts"),
				Z = s("./src/reddit/selectors/user.ts"),
				$ = s("./src/telemetry/index.ts");
			const ee = "POST__EXPANDED_TOGGLED",
				te = "POST__FOCUS_CHANGED",
				se = "POSTS__MUTATED",
				ne = "POSTS_LOADED",
				re = Object(u.a)(ee),
				ae = (Object(u.a)(te), Object(u.a)(ne)),
				ie = "POST__STICKY_POST_SUCCESS",
				oe = Object(u.a)(ie),
				ce = Object(u.a)(se),
				de = "POST__MODERATION_PROMPT_OPENED",
				ue = "POST__MODERATION_PROMPT_CLOSED",
				le = Object(u.a)(de),
				be = Object(u.a)(ue),
				pe = (e, t, s, n) => async (r, i, o) => {
					let {
						apiContext: c
					} = o;
					const d = i().posts.models[e];
					if (!d) return;
					if (!Object(Z.H)(i())) return r(Object(B.k)({
						actionSource: B.a.Hide,
						redirectUrl: d.permalink
					})), void r(Object(b.i)());
					let u;
					if (r(ce({
							[e]: {
								hidden: t
							}
						})), (u = t ? await Object(N.h)(c(), e) : await Object(N.u)(c(), e)).ok) {
						if (n) {
							const n = t ? a.fbt._("Post hidden successfully.", null, {
									hk: "a4K6a"
								}) : a.fbt._("Post unhidden successfully.", null, {
									hk: "xJgPP"
								}),
								i = Object(q.d)(n, Y.b.Undo, a.fbt._("Undo", null, {
									hk: "46OwLP"
								}), pe(e, !t, s, !1));
							r(Object(q.e)(i))
						}
					} else if (r(ce({
							[e]: {
								hidden: !t
							}
						})), n) {
						const e = Object(q.d)(a.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						}), Y.b.Error);
						r(Object(q.e)(e))
					}
				}, Oe = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const i = s().posts.models[e];
					if (!i) return;
					if (!Object(Z.H)(s())) return t(Object(b.i)()), void t(Object(B.k)({
						actionSource: B.a.Save,
						redirectUrl: i.permalink
					}));
					const o = i.saved ? N.y : N.p;
					if (t(ce({
							[e]: {
								saved: !i.saved
							}
						})), (await o(r(), e)).ok) {
						const s = i.saved ? a.fbt._("Post unsaved successfully", null, {
								hk: "rrnyE"
							}) : a.fbt._("Post saved successfully", null, {
								hk: "3fAuAl"
							}),
							n = Object(q.d)(s, Y.b.Undo, a.fbt._("Undo", null, {
								hk: "46OwLP"
							}), Oe(e));
						t(Object(q.e)(n))
					} else t(ce({
						[e]: {
							saved: i.saved
						}
					}))
				}, ge = (e, t) => t().posts.models[e], fe = Object(w.b)(ge, J.a.upvoted), me = Object(w.b)(ge, J.a.downvoted), je = e => "viewing-".concat(e), _e = (e, t) => async (s, n) => {
					const r = n();
					K.i(r, e, t), $.c.start(je(e))
				}, he = (e, t, s) => async (n, a) => {
					const i = a(),
						o = je(e);
					if ($.c.has(o)) {
						const n = $.c.end("viewing-".concat(e));
						!t && n > r.a.telemetry.postConsumedThreshold && K.a(i, e, n, s)
					}
				}, ye = {
					[O.a.Impression]: l.c,
					[O.a.Click]: l.b,
					[O.a.ViewableImpression]: l.m,
					[O.a.GroupMViewable]: l.r,
					[O.a.VideoViewableImpression]: l.j,
					[O.a.VideoFullyViewableImpression]: l.d,
					[O.a.VideoStarted]: l.i,
					[O.a.VideoPlayedWithSound]: l.h,
					[O.a.VideoGroupMViewable]: l.f,
					[O.a.VideoWatchedSeconds3]: l.l,
					[O.a.VideoWatchedSeconds5]: l.l,
					[O.a.VideoWatchedSeconds10]: l.l,
					[O.a.VideoWatched25]: l.k,
					[O.a.VideoWatched50]: l.k,
					[O.a.VideoWatched75]: l.k,
					[O.a.VideoWatched95]: l.k,
					[O.a.VideoWatched100]: l.k,
					[O.a.VideoVendorFullyViewable50]: l.e,
					[O.a.VideoPlayedExpanded]: l.g,
					[O.a.Unload]: I.b,
					[O.a.VendorFullyInView]: l.v,
					[O.a.VendorFullyInViewSeconds5]: l.x,
					[O.a.VendorFullyInViewSeconds15]: l.w
				}, Ee = Object(u.b)(ye), Ie = (e, t, s) => async (n, r) => {
					const a = Object(E.b)(r(), e.id),
						i = Object(g.a)(e.id, a, t);
					ye[t] && n(Ee(String(t), {
						postId: e.id,
						vendorMetadata: i,
						eventType: s
					})), y(e, t, i)
				}, ve = (e, t) => async (s, n) => {
					const r = e && e.media && "video" === e.media.type,
						a = [O.a.VendorFullyInView, O.a.VendorFullyInViewSeconds5, O.a.VendorFullyInViewSeconds15];
					if (r && t === O.a.VideoViewableImpression) s(Object(T.y)(e.id));
					else if (r && t === O.a.VideoFullyViewableImpression) s(Object(T.v)(e.id));
					else if (r && t === O.a.VideoGroupMViewable) s(Object(T.w)(e.id));
					else if (r && t === O.a.VideoVendorFullyViewable50) s(Object(T.x)(e.id));
					else if (e.isSponsored)
						if (a.includes(t)) s(((e, t) => async s => {
							s(Ie(e, t))
						})(e, t));
						else {
							if (t !== O.a.GroupMViewable) return t === O.a.Impression ? (s((e => async (t, s) => {
								e.isSponsored && (t(Ie(e, O.a.Impression)), S(e, t, s))
							})(e)), void(e.isBlank || K.h(n(), e.postId))) : void s((e => async t => {
								e.isSponsored && t(Ie(e, O.a.ViewableImpression))
							})(e));
							s(((e, t) => async s => {
								s(Ie(e, t))
							})(e, t))
						}
				}, Se = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						i = a.posts.models[e],
						o = a.user.account ? a.user.account.displayText : null;
					i && (t(ce({
						[e]: {
							approvedBy: o,
							bannedBy: null,
							isApproved: !0,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							numReports: 0,
							modRemovalReason: null,
							modReasonBy: null
						}
					})), (await Object(N.b)(r(), e)).ok || t(ce({
						[e]: {
							approvedBy: null,
							bannedBy: i.bannedBy,
							isApproved: i.isApproved,
							isRemoved: i.isRemoved,
							isSpam: i.isSpam,
							modNote: i.modNote,
							numReports: i.numReports || null,
							modRemovalReason: i.modRemovalReason,
							modReasonBy: i.modReasonBy
						}
					})))
				}, Te = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = i.posts.models[e],
						c = i.user.account ? i.user.account.displayText : null;
					return !(!o || !c) && (s(ce({
						[e]: {
							approvedBy: null,
							bannedBy: c,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), !!(await Object(N.m)(a(), e, t)).ok || (s(ce({
						[e]: {
							approvedBy: o.approvedBy,
							bannedBy: o.bannedBy,
							isApproved: o.isApproved,
							isRemoved: o.isRemoved,
							isSpam: o.isSpam
						}
					})), !1))
				}, we = (e, t, s) => async (n, r, i) => {
					let {
						apiContext: o
					} = i;
					const c = r();
					if (c.posts.models[e])
						if (n(ce({
								[e]: {
									hidden: !0
								}
							})), (await Object(N.c)(o(), e)).ok) {
							const e = Object(q.d)(a.fbt._("Post deleted successfully.", null, {
								hk: "1sQ4Xf"
							}), Y.b.SuccessMod);
							if (s) n(Object(G.b)(t.state[A.a.CloseLocation]));
							else {
								const e = Object(X.f)(c);
								e && n(Object(G.b)(e.url))
							}
							n(Object(q.e)(e))
						} else {
							n(ce({
								[e]: {
									hidden: !1
								}
							}));
							const t = Object(q.d)(a.fbt._("Something went wrong", null, {
								hk: "22u7ha"
							}), Y.b.Error);
							n(Object(q.e)(t))
						}
				}, Ce = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s().posts.models[e];
					if (!a) return;
					const i = a.isLocked ? N.w : N.j;
					t(ce({
						[e]: {
							isLocked: !a.isLocked
						}
					})), (await i(r(), e)).ok || t(ce({
						[e]: {
							isLocked: a.isLocked
						}
					}))
				}, Ae = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s().posts.models[e];
					if (!a) return;
					const i = a.isSpoiler ? N.z : N.s,
						o = a.isSpoiler ? a.flair.filter(e => e.type !== W.f.Spoiler) : [...a.flair, {
							text: "spoiler",
							type: W.f.Spoiler
						}];
					t(ce({
						[e]: {
							isSpoiler: !a.isSpoiler,
							flair: o
						}
					})), (await i(r(), e)).ok || t(ce({
						[e]: {
							isSpoiler: a.isSpoiler,
							flair: a.flair
						}
					}))
				}, De = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = Object(E.N)(s(), {
						postId: e
					});
					a && (t(ce({
						[e]: {
							isOriginalContent: !a.isOriginalContent
						}
					})), (await Object(N.l)(r(), e, !a.isOriginalContent)).ok || t(ce({
						[e]: {
							isOriginalContent: a.isOriginalContent
						}
					})))
				}, Pe = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s().posts.models[e];
					if (!a) return;
					const i = a.isNSFW ? N.x : N.k,
						o = a.isNSFW ? a.flair.filter(e => e.type !== W.f.Nsfw) : [...a.flair, {
							text: "nsfw",
							type: W.f.Nsfw
						}];
					t(ce({
						[e]: {
							isNSFW: !a.isNSFW,
							flair: o
						}
					})), (await i(r(), e)).ok ? await t(qe(e)) : t(ce({
						[e]: {
							isNSFW: a.isNSFW,
							flair: a.flair
						}
					}))
				}, Re = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n().posts.models[e];
					if (!i) return;
					const o = M.g[t];
					s(ce({
						[e]: {
							distinguishType: t
						}
					})), (await Object(N.d)(a(), e, o)).ok || s(ce({
						[e]: {
							distinguishType: i.distinguishType
						}
					}))
				}, ke = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s().posts.models[e];
					if (!a) return;
					const i = a.ignoreReports ? N.v : N.i;
					t(ce({
						[e]: {
							ignoreReports: !a.ignoreReports
						}
					})), (await i(r(), e)).ok || t(ce({
						[e]: {
							ignoreReports: a.ignoreReports
						}
					}))
				}, xe = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						i = a.posts.models[e];
					if (!i) return;
					const o = !i.isStickied;
					t(ce({
						[e]: {
							isStickied: o
						}
					}));
					const c = a.subredditStickyPosts.data[i.belongsTo.id];
					let d;
					if (o && c && c.length >= 2 && (d = c[1], t(ce({
							[d]: {
								isStickied: !1
							}
						}))), (await Object(N.t)(r(), e, o, !1)).ok) {
						const s = i.belongsTo.id,
							n = Ne(e, o, a.subredditStickyPosts.data[i.belongsTo.id]),
							r = a.subreddits.models[s].name,
							c = Object(F.a)(r, M.P, {});
						t(oe({
							newStickiedPostList: n,
							subredditId: s,
							listingKey: c
						}))
					} else t(ce({
						[e]: {
							isStickied: i.isStickied
						}
					})), d && t(ce({
						[d]: {
							isStickied: !0
						}
					}))
				}, Ne = (e, t, s) => {
					const n = s ? [...s] : [];
					return t ? (n.length >= 2 && n.splice(1, 1, e), n) : n.filter((function(t) {
						return t !== e
					}))
				}, Le = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					if (Object(d.a)(e)) {
						const e = Object(q.d)(a.fbt._("Copied link!", null, {
							hk: "4a4E1x"
						}), Y.b.SuccessCommunity);
						t(Object(q.e)(e))
					} else {
						const e = Object(q.d)(a.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						}), Y.b.Error);
						t(Object(q.e)(e))
					}
				}, Ue = "PREFERENCES__RECENT_POSTS_UPDATED", Me = Object(u.a)(Ue), Fe = () => async (e, t) => {
					const s = t();
					if (!s.user.account) return;
					const n = Object(z.e)(s.user.account);
					o.a.remove("".concat(n).concat(C.g), {
						domain: r.a.cookieDomain
					}), e(Me({
						postIds: []
					}))
				}, Ge = e => async (t, s) => {
					const a = s();
					if (!a.user.account || !a.user.account.showRecentPosts || a.posts.recent.indexOf(e) > -1) return;
					const i = Object(z.e)(a.user.account),
						o = a.posts.recent ? a.posts.recent.slice(0) : [];
					o.push(e), o.length > D.c && o.shift(), Object(n.b)("".concat(i).concat(C.g), "".concat(o.join(",")), {
						domain: r.a.cookieDomain
					}), t(Me({
						postIds: o
					}))
				}, Be = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = !s().posts.models[e].sendReplies;
					t(ce({
						[e]: {
							sendReplies: a
						}
					})), (await Object(N.q)(r(), e, a)).ok || t(ce({
						[e]: {
							sendReplies: !a
						}
					}))
				}, qe = e => async (t, s, n) => {
					if (Object(E.N)(s(), {
							postId: e
						})) return;
					const r = await Object(H.a)(n.apiContext(), e, void 0, {
						limit: 1,
						truncate: 0
					}, Object(Q.a)(s()));
					if (t(Object(p.m)(r.status)), r.ok) {
						const e = r.body;
						t(ae(e.posts))
					}
				}, Ve = e => async (t, s) => {
					await t(qe(e));
					const n = Object(E.N)(s(), {
						postId: e
					});
					n && n.crosspostRootId && await t(qe(n.crosspostRootId))
				}, He = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const i = s();
					if (!Object(Z.H)(i)) return void t(Object(B.i)(V.a.LOGIN_MODAL_ID));
					const o = Object(E.N)(i, {
						postId: e
					});
					if (!o) return;
					const c = o.isFollowed,
						d = i.posts.instances[e] || [],
						u = [e, ...d];
					t(ce(u.reduce((e, t) => Object.assign(Object.assign({}, e), {
						[t]: {
							isFollowed: !c
						}
					}), {}))), (await Object(N.g)(r(), e, !o.isFollowed)).ok ? t(Object(q.e)({
						kind: Y.b.SuccessMod,
						text: c ? a.fbt._("Event unfollowed", null, {
							hk: "3tkWMt"
						}) : a.fbt._("Success! You followed this event, that means we’ll remind you when it starts!", null, {
							hk: "4A9cwh"
						})
					})) : (t(ce(u.reduce((e, t) => Object.assign(Object.assign({}, e), {
						[t]: {
							isFollowed: c
						}
					}), {}))), t(Object(q.e)({
						kind: Y.b.Error,
						text: a.fbt._("Oops, something went wrong. Try again.", null, {
							hk: "2VQ3RW"
						})
					})))
				}, Ke = e => {
					let {
						postOrComment: t,
						queryParams: s,
						clickInfo: n
					} = e;
					return async (e, r) => {
						const a = r(),
							i = n && n.hasNewTabModifier;
						let o = t.permalink;
						if (Object(P.b)(t) && t.media && Object(x.H)(t.media)) {
							const {
								id: e,
								type: s
							} = t.belongsTo, n = "subreddit" === s ? a.subreddits.models[e] : null;
							o = n ? Object(k.c)(t.id, n.name) : Object(k.c)(t.id)
						}
						s && (o = Object(c.a)(o, s)), a.user.prefs.openPostInNewTab || i ? window.open(o) : e(Object(R.a)(o))
					}
				}, We = "RICH_TEXT_POST_CONTENT_LOADED", Ye = Object(u.a)(We), ze = e => async (t, s, n) => {
					const r = s(),
						i = Object(E.N)(r, {
							postId: e
						});
					if (!(i && i.media && Object(x.I)(i.media) && i.media.isRichtextPreview)) return;
					const o = await ((e, t) => Object(L.a)(e, Object.assign(Object.assign({}, U), {
						variables: t
					})))(n.gqlContext(), {
						postId: e
					});
					if (o.ok) {
						const {
							data: s
						} = o.body, n = s.post && s.post.content && s.post.content.richtext;
						n && t(Ye({
							postId: e,
							richtextContent: JSON.parse(n)
						}))
					} else t(Object(q.e)({
						kind: Y.b.Error,
						text: a.fbt._("Something went wrong loading this page. Try again?", null, {
							hk: "1GbrKz"
						})
					}))
				}, Je = (e, t) => async (s, n, r) => {
					let {
						apiContext: i
					} = r;
					(await Object(N.r)(i(), e, t)).ok ? s(ce({
						[t]: {
							contestMode: e
						}
					})) : s(Object(q.e)({
						kind: Y.b.Error,
						text: a.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, Qe = "MOD_TO_MEMBER_SHARE_OPENED", Xe = Object(u.a)(Qe), Ze = "CROWD_CONTROL_OPENED", $e = Object(u.a)(Ze)
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "d", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "g", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "t", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "r", (function() {
				return l
			})), s.d(t, "s", (function() {
				return b
			})), s.d(t, "n", (function() {
				return p
			})), s.d(t, "l", (function() {
				return O
			})), s.d(t, "m", (function() {
				return g
			})), s.d(t, "k", (function() {
				return f
			})), s.d(t, "i", (function() {
				return m
			})), s.d(t, "j", (function() {
				return j
			})), s.d(t, "h", (function() {
				return _
			})), s.d(t, "p", (function() {
				return h
			})), s.d(t, "q", (function() {
				return y
			})), s.d(t, "o", (function() {
				return E
			}));
			const n = "CREATE_COLLECTION_PENDING",
				r = "CREATE_COLLECTION_SUCCESS",
				a = "CREATE_COLLECTION_FAILED",
				i = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				o = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				c = "ADD_POST_TO_COLLECTION_SUCCESS",
				d = "UPDATE_POST_WITH_COLLECTION_ID",
				u = "DELETE_COLLECTION_SUCCESS",
				l = "UPDATE_COLLECTION_PENDING",
				b = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				O = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				g = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				f = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				m = "REORDER_COLLECTION_PENDING",
				j = "REORDER_COLLECTION_SUCCESS",
				_ = "REORDER_COLLECTION_FAILED",
				h = "UPDATE_COLLECTION_LAYOUT_PENDING",
				y = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				E = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "K", (function() {
				return n
			})), s.d(t, "L", (function() {
				return r
			})), s.d(t, "o", (function() {
				return a
			})), s.d(t, "p", (function() {
				return i
			})), s.d(t, "B", (function() {
				return o
			})), s.d(t, "H", (function() {
				return c
			})), s.d(t, "I", (function() {
				return d
			})), s.d(t, "n", (function() {
				return u
			})), s.d(t, "G", (function() {
				return l
			})), s.d(t, "s", (function() {
				return b
			})), s.d(t, "Q", (function() {
				return p
			})), s.d(t, "q", (function() {
				return O
			})), s.d(t, "D", (function() {
				return g
			})), s.d(t, "v", (function() {
				return f
			})), s.d(t, "c", (function() {
				return m
			})), s.d(t, "b", (function() {
				return j
			})), s.d(t, "d", (function() {
				return _
			})), s.d(t, "e", (function() {
				return h
			})), s.d(t, "f", (function() {
				return y
			})), s.d(t, "g", (function() {
				return E
			})), s.d(t, "h", (function() {
				return I
			})), s.d(t, "i", (function() {
				return v
			})), s.d(t, "j", (function() {
				return S
			})), s.d(t, "k", (function() {
				return T
			})), s.d(t, "l", (function() {
				return w
			})), s.d(t, "m", (function() {
				return C
			})), s.d(t, "t", (function() {
				return A
			})), s.d(t, "S", (function() {
				return D
			})), s.d(t, "R", (function() {
				return P
			})), s.d(t, "T", (function() {
				return R
			})), s.d(t, "U", (function() {
				return k
			})), s.d(t, "V", (function() {
				return x
			})), s.d(t, "W", (function() {
				return N
			})), s.d(t, "X", (function() {
				return L
			})), s.d(t, "Y", (function() {
				return U
			})), s.d(t, "Z", (function() {
				return M
			})), s.d(t, "ab", (function() {
				return F
			})), s.d(t, "u", (function() {
				return G
			})), s.d(t, "E", (function() {
				return B
			})), s.d(t, "z", (function() {
				return q
			})), s.d(t, "x", (function() {
				return V
			})), s.d(t, "y", (function() {
				return H
			})), s.d(t, "w", (function() {
				return K
			})), s.d(t, "A", (function() {
				return W
			})), s.d(t, "P", (function() {
				return Y
			})), s.d(t, "r", (function() {
				return z
			})), s.d(t, "C", (function() {
				return J
			})), s.d(t, "bb", (function() {
				return Q
			})), s.d(t, "J", (function() {
				return X
			})), s.d(t, "a", (function() {
				return Z
			})), s.d(t, "F", (function() {
				return $
			})), s.d(t, "N", (function() {
				return ee
			})), s.d(t, "O", (function() {
				return te
			})), s.d(t, "M", (function() {
				return se
			}));
			const n = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				r = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				a = "POST_CREATION_EDIT_COMPLETE",
				i = "POST_CREATION_EDIT_FAILED",
				o = "POST_CREATION_PENDING_EDIT",
				c = "POST_CREATION_START_EDITING_POST",
				d = "POST_CREATION_STOP_EDITING_POST",
				u = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				l = "STARTED_CONVERTING_EDITOR_CONTENT",
				b = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				O = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				g = "POST_TITLE_FETCHED",
				f = "INITIALIZE_EDITOR_MODE",
				m = "POST_CREATION__CHANGE_FLAIR",
				j = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				_ = "POST_CREATION__CHANGE_LINK_BODY",
				h = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				y = "POST_CREATION__CHANGE_MEDIA_BODY",
				E = "POST_CREATION__CHANGE_POST_SCHEDULE",
				I = "POST_CREATION__CHANGE_RECAPTCHA",
				v = "POST_CREATION__CHANGE_RTE_STATE",
				S = "POST_CREATION__CHANGE_STICKY_POSITION",
				T = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				w = "POST_CREATION__CHANGE_SUGGESTED_SORT",
				C = "POST_CREATION__CHANGE_TITLE",
				A = "POST_CREATION__GOV_TYPE_CHANGED",
				D = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				P = "POST_CREATION__TOGGLE_IS_CHANGED",
				R = "POST_CREATION__TOGGLE_IS_CONTEST_MODE",
				k = "POST_CREATION__TOGGLE_IS_GOV",
				x = "POST_CREATION__TOGGLE_IS_NSFW",
				N = "POST_CREATION__TOGGLE_IS_OC",
				L = "POST_CREATION__TOGGLE_IS_POLL",
				U = "POST_CREATION__TOGGLE_IS_SPOILER",
				M = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				F = "POST_CREATION__TOGGLE_SEND_REPLIES",
				G = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				B = "POST_CREATION__RESET_FORM",
				q = "POST_CREATION__MODAL_TOGGLED",
				V = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				H = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				K = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				W = "POST_CREATION__PENDING",
				Y = "POST_CREATION__SUCCEEDED",
				z = "POST_CREATION__FAILED",
				J = "POST_CREATION__POLL_FAILED",
				Q = "POST_CREATION__VALIDATION_FAILED",
				X = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				Z = "POST_CREATION__CAPTCHA_REQUIRED",
				$ = "POST_CREATION__SET_SUBMIT_MODE",
				ee = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				te = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				se = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED"
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "c", (function() {
				return m
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/reddit/endpoints/post/convert.ts"),
				o = s("./src/reddit/helpers/localStorage/index.ts"),
				c = s("./src/reddit/helpers/trackers/postComposer.ts"),
				d = s("./src/reddit/models/PostCreationForm/index.ts"),
				u = s("./src/reddit/models/RichTextJson/index.ts"),
				l = s("./src/reddit/models/Toast/index.ts"),
				b = s("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(r.a)(b.G),
				O = Object(r.a)(b.s),
				g = Object(r.a)(b.Q),
				f = (e, t, s) => async (r, o, f) => {
					let {
						apiContext: j
					} = f;
					c.i(o(), t);
					const _ = t === d.h.MARKDOWN,
						h = t === d.h.RICH_TEXT,
						y = b.n;
					if (_ && Object(u.G)(s)) return r(g({
						editorKey: e,
						editorMode: d.h.MARKDOWN,
						content: ""
					})), void r(m(t));
					if (h && !s) return r(g({
						editorKey: e,
						editorMode: d.h.RICH_TEXT,
						content: u.i
					})), void r(m(t));
					r(p(y));
					const E = await Object(i.a)(j(), t, _ ? JSON.stringify(s) : s);
					E.ok ? (r(O(y)), r(g({
						editorKey: e,
						editorMode: t,
						content: E.body.output
					})), r(m(t))) : (r(O(y)), r(Object(a.e)({
						duration: a.a,
						kind: l.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, m = e => async (t, s) => {
					const r = Object(o.i)();
					if (r >= 3) return;
					const i = s().user.prefs.useMarkdown ? d.h.MARKDOWN : d.h.RICH_TEXT;
					if (e === i) return;
					const c = e === d.h.MARKDOWN ? n.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : n.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					t(Object(a.e)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: n.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: l.b.SuccessCommunity,
						text: c
					})), Object(o.T)(r + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return O
			})), s.d(t, "n", (function() {
				return f
			})), s.d(t, "a", (function() {
				return m
			})), s.d(t, "b", (function() {
				return j
			})), s.d(t, "c", (function() {
				return h
			})), s.d(t, "d", (function() {
				return y
			})), s.d(t, "f", (function() {
				return I
			})), s.d(t, "e", (function() {
				return v
			})), s.d(t, "g", (function() {
				return T
			})), s.d(t, "h", (function() {
				return C
			})), s.d(t, "j", (function() {
				return A
			})), s.d(t, "s", (function() {
				return D
			})), s.d(t, "r", (function() {
				return P
			})), s.d(t, "t", (function() {
				return k
			})), s.d(t, "u", (function() {
				return x
			})), s.d(t, "v", (function() {
				return N
			})), s.d(t, "w", (function() {
				return L
			})), s.d(t, "y", (function() {
				return U
			})), s.d(t, "z", (function() {
				return M
			})), s.d(t, "A", (function() {
				return F
			})), s.d(t, "k", (function() {
				return G
			})), s.d(t, "q", (function() {
				return B
			})), s.d(t, "p", (function() {
				return V
			})), s.d(t, "l", (function() {
				return H
			})), s.d(t, "x", (function() {
				return K
			})), s.d(t, "o", (function() {
				return W
			})), s.d(t, "m", (function() {
				return Y
			}));
			var n = s("./node_modules/react-router-redux/es/index.js"),
				r = s("./src/lib/isUrl/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/modal.ts"),
				o = s("./src/reddit/contexts/PageLayer/index.tsx"),
				c = s("./src/reddit/endpoints/post/index.tsx"),
				d = s("./src/reddit/models/PostCreationForm/index.ts"),
				u = s("./src/reddit/routes/postCreation/constants.ts"),
				l = s("./src/reddit/selectors/postCollection.ts"),
				b = s("./src/reddit/selectors/postCreations.ts"),
				p = s("./src/reddit/actions/postCreation/constants.ts");
			const O = Object(a.a)(p.q),
				g = Object(a.a)(p.D),
				f = (Object(a.a)(p.v), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				m = Object(a.a)(p.b),
				j = Object(a.a)(p.c),
				_ = Object(a.a)(p.d),
				h = Object(a.a)(p.e),
				y = Object(a.a)(p.f),
				E = Object(a.a)(p.g),
				I = Object(a.a)(p.h),
				v = Object(a.a)(p.i),
				S = Object(a.a)(p.j),
				T = Object(a.a)(p.k),
				w = Object(a.a)(p.l),
				C = Object(a.a)(p.m),
				A = Object(a.a)(p.t),
				D = Object(a.a)(p.S),
				P = Object(a.a)(p.R),
				R = Object(a.a)(p.T),
				k = (Object(a.a)(p.U), Object(a.a)(p.V)),
				x = Object(a.a)(p.W),
				N = Object(a.a)(p.X),
				L = Object(a.a)(p.Y),
				U = Object(a.a)(p.Z),
				M = Object(a.a)(p.ab),
				F = e => {
					let {
						isContestMode: t,
						schedule: s,
						stickyPosition: n,
						suggestedSort: r
					} = e;
					return async e => {
						e(R(t)), e(E(s)), e(w(r)), e(S(n))
					}
				},
				G = Object(a.a)(p.u),
				B = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					t(_(e)), Object(r.a)(e) && t((e => async (t, s, n) => {
						let {
							apiContext: r
						} = n;
						const a = await Object(c.f)(r(), e);
						a.ok && a.body && a.body.json && a.body.json.data && t(g(a.body.json.data))
					})(e))
				}, q = Object(a.a)(p.E), V = (e, t) => async (s, r) => {
					s(q()), s(e ? Object(n.b)(u.b) : Object(n.b)(Object(b.V)(r(), {
						pageLayer: t
					})))
				}, H = Object(a.a)(i.c), K = e => async t => {
					e ? e === d.d ? t(H(e)) : t(i.i(e)) : (t(H(e)), t(i.i(e)))
				}, W = e => async (t, s) => {
					const n = s(),
						r = Object(o.D)(e),
						a = Object(b.B)(n);
					if (r && a) {
						Object(b.Q)(n) !== d.c && t(K(d.c))
					} else t(V(!1, e))
				}, Y = e => async (t, s) => {
					const n = s();
					Object(l.n)(n, {
						subredditId: e
					}) ? t(i.i(d.a)) : t(i.i(d.b))
				}
		},
		"./src/reddit/actions/postCreation/subredditChange.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return E
			})), s.d(t, "b", (function() {
				return I
			})), s.d(t, "a", (function() {
				return v
			})), s.d(t, "d", (function() {
				return S
			})), s.d(t, "c", (function() {
				return T
			}));
			var n = s("./node_modules/react-router-redux/es/index.js"),
				r = s("./src/lib/addQueryParams/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/filterQueryParams/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				d = s("./src/reddit/actions/pages/postCreation.ts"),
				u = s("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = s("./src/reddit/helpers/name/index.ts"),
				b = s("./src/reddit/models/PostCreationForm/index.ts"),
				p = s("./src/reddit/routes/postCreation/index.ts"),
				O = s("./src/reddit/routes/postCreation/constants.ts"),
				g = s("./src/reddit/selectors/postCreations.ts"),
				f = s("./src/reddit/selectors/platform.ts"),
				m = s("./src/reddit/selectors/subreddit.ts"),
				j = s("./src/reddit/actions/postCreation/constants.ts"),
				_ = s("./src/reddit/actions/postCreation/general.ts");
			const h = Object(o.a)(j.N),
				y = Object(o.a)(j.O),
				E = Object(o.a)(j.M),
				I = (e, t) => async (s, n, r) => {
					let {
						apiContext: i
					} = r, o = n();
					const {
						name: p,
						isProfile: O
					} = e, j = Object(f.f)(o), _ = j && !O && Object(l.a)(j.name, p), y = o.creations.api.subreddit.change.pending;
					if (_ || y) return;
					const E = Object(u.u)(t);
					if (!p) return void s(v(e, E));
					s(h(e));
					const I = O ? {
						profileName: p
					} : {
						subredditName: p
					};
					if (await s(Object(d.d)(I)), O || !Object(g.x)(o)) return s(v(e, E));
					const S = e.allowedPostTypes || Object(m.A)(n(), {
						subredditName: p
					});
					if (!S) return void s(v(e, E));
					let T;
					o = n();
					const w = Object(g.fb)(o),
						C = Object(g.x)(o);
					if (w === a.Jb.MEDIA && C) {
						const e = Object(g.O)(o),
							t = Object(b.v)(e),
							s = Object(g.G)(o) && e.items.length > 1,
							n = !t && !s;
						if (s && !S.galleries) T = b.p.GalleryWillBeRemovedGalleryNotAllowed;
						else if (n && !S.images) T = b.p.ImageWillBeRemoved;
						else if (t && !S.videos) {
							const t = o.uploads[e.items[0].uploadKey],
								s = t && t.metadata.videoDuration || 0;
							S.images ? s > a.Z && (T = b.p.VideoWillBeRemovedTooLongForGif) : T = b.p.VideoWillBeRemovedMediaNotAllowed
						}
					}
					s(T ? Object(c.i)(T) : v(Object.assign(Object.assign({}, e), {
						allowedPostTypes: S
					}), E))
				}, v = function(e, t) {
					let s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (a, i) => {
						const {
							name: o,
							isProfile: c
						} = e, d = i().platform.currentPage, u = d.queryParams, l = c ? p.b : p.c;
						let b = "";
						b = o ? l(o) : O.b, b = Object(r.a)(b, Object.assign(Object.assign({}, u), {
							draft: t || u.draft
						})), (t || d.url.toLowerCase() !== b.toLowerCase()) && (a(y(e)), s && a(Object(_.r)(!0)), a(Object(_.i)()), a(Object(n.c)(b)))
					}
				}, S = e => async (t, s) => {
					const a = s().platform.currentPage,
						i = a.queryParams,
						o = Object(r.a)(a.url, Object.assign(Object.assign({}, i), {
							collection: e
						}));
					t(Object(n.c)(o))
				}, T = () => async (e, t) => {
					const s = t().platform.currentPage,
						r = Object(i.a)(s.url, ["collection"]);
					e(Object(n.c)(r))
				}
		},
		"./src/reddit/actions/postDraft.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return D
			})), s.d(t, "e", (function() {
				return P
			})), s.d(t, "d", (function() {
				return R
			})), s.d(t, "p", (function() {
				return L
			})), s.d(t, "j", (function() {
				return U
			})), s.d(t, "l", (function() {
				return M
			})), s.d(t, "i", (function() {
				return F
			})), s.d(t, "m", (function() {
				return G
			})), s.d(t, "k", (function() {
				return B
			})), s.d(t, "h", (function() {
				return q
			})), s.d(t, "n", (function() {
				return V
			})), s.d(t, "s", (function() {
				return Q
			})), s.d(t, "r", (function() {
				return X
			})), s.d(t, "g", (function() {
				return Z
			})), s.d(t, "q", (function() {
				return ee
			})), s.d(t, "c", (function() {
				return te
			})), s.d(t, "a", (function() {
				return se
			})), s.d(t, "b", (function() {
				return ne
			})), s.d(t, "o", (function() {
				return oe
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/formatApiError/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/postCreation/general.ts"),
				o = s("./src/reddit/actions/postCreation/subredditChange.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/reddit/contexts/PageLayer/selectors.ts"),
				u = s("./src/lib/makeApiRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				b = s("./src/reddit/models/StructuredStyles/index.ts");
			var p = s("./src/reddit/constants/headers.ts"),
				O = s("./src/reddit/helpers/name/index.ts"),
				g = s("./src/reddit/models/PostDraft/index.ts"),
				f = s("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts"),
				m = s("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				j = s("./src/reddit/models/Subreddit/index.ts");
			const _ = e => {
				let t = e.drafts.reduce((e, t) => {
					const s = (e => {
						let t;
						return t = "link" === e.kind ? {
							kind: g.b.Link,
							body: e.body || void 0
						} : "markdown" === e.kind ? {
							kind: g.b.Markdown,
							body: e.body || void 0
						} : {
							kind: g.b.RichText,
							body: e.body || void 0
						}, Object.assign({
							subredditId: e.subreddit || void 0,
							contentCategory: e.content_category || void 0,
							created: e.created,
							flair: e.flair,
							id: e.id,
							isChatPost: !!e.discussion_type,
							isNSFW: !!e.nsfw,
							isOriginalContent: !!e.original_content,
							isSpoiler: !!e.spoiler,
							modified: e.modified || void 0,
							sendReplies: !!e.send_replies,
							isPublicLink: !!e.is_public_link,
							title: e.title || ""
						}, t)
					})(t);
					return e.postDraftIds.push(s.id), e.postDrafts[s.id] = s, e
				}, {
					postDraftIds: [],
					postDrafts: {},
					profiles: {},
					subreddits: {}
				});
				return t = e.subreddits.reduce((e, t) => {
					if (t.subreddit_type === j.e.User) {
						const s = Object(f.a)(t, Object(O.f)(t.display_name_prefixed));
						e.profiles[s.id] = s
					} else {
						const s = Object(m.a)(t);
						e.subreddits[s.id] = s
					}
					return e
				}, t)
			};
			var h = s("./src/reddit/endpoints/post/draft/helpers.ts"),
				y = s("./src/reddit/models/PostCreationForm/index.ts"),
				E = s("./src/reddit/helpers/trackers/postComposer.ts"),
				I = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/models/User/index.ts"),
				S = s("./src/reddit/selectors/postCreations.ts"),
				T = s("./src/reddit/selectors/postDraft.ts"),
				w = s("./src/reddit/selectors/profile.ts"),
				C = s("./src/reddit/selectors/subreddit.ts"),
				A = s("./src/reddit/selectors/user.ts");
			const D = "POST_DRAFT__LIST_PENDING",
				P = "POST_DRAFT__LIST_LOADED",
				R = "POST_DRAFT__LIST_FAILED",
				k = Object(a.a)(D),
				x = Object(a.a)(P),
				N = Object(a.a)(R),
				L = () => async (e, t, s) => {
					let {
						apiContext: r
					} = s;
					const a = t();
					if (!Object(A.i)(a) || Object(T.b)(a)) return;
					e(k());
					const i = await (e => Object(u.a)(Object(l.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/drafts.json"),
						method: n.db.GET
					}))(r());
					i.ok ? e(x(_(i.body))) : e(N(i.error))
				}, U = "POST_DRAFT__SAVE_DRAFT_PENDING", M = "POST_DRAFT__SAVE_DRAFT_SUCCEEDED", F = "POST_DRAFT__SAVE_DRAFT_FAILED", G = "POST_DRAFT__SAVE_DRAFT_VALIDATION_FAILED", B = "POST_DRAFT__SAVE_DRAFT_SUBMIT_VALIDATION_FAILED", q = "POST_DRAFT__SAVE_DRAFT_CAPTCHA_REQUIRED", V = "POST_CREATION__TOGGLE_DRAFT_IS_PUBLIC", H = Object(a.a)(U), K = Object(a.a)(M), W = Object(a.a)(F), Y = Object(a.a)(G), z = Object(a.a)(B), J = Object(a.a)(q), Q = Object(a.a)(V), X = e => async (t, s, a) => {
					let {
						apiContext: i
					} = a;
					const d = s(),
						b = Object(T.g)(d),
						O = Object(S.U)(d);
					if (b || O) return;
					const g = Object(T.h)(d, e);
					if (!g) return;
					t(H(g)), E.e(d, g);
					const f = await ((e, t, s) => Object(u.a)(Object(l.a)(e, [p.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/draft"),
						method: s ? n.db.PUT : n.db.POST,
						data: Object(h.a)(t)
					}).then(e => e.body.fields && Object(y.u)(e.body.fields[0]) ? Object.assign(Object.assign({}, e), {
						body: {},
						error: {
							type: n.E.SUBMIT_VALIDATION_ERROR,
							fields: [{
								field: e.body.fields[0],
								msg: e.body.explanation
							}]
						}
					}) : e))(i(), g, e);
					if (f.ok) {
						const {
							id: s,
							draftsCount: n
						} = Object(h.c)(f.body);
						t(K({
							draftId: s,
							draftsCount: n
						})), e || t(Object(o.a)(g.destSubreddit, s, !1))
					} else {
						const e = f.error;
						e.type === n.E.BAD_CAPTCHA_ERROR ? t(J()) : e.type === n.E.VALIDATION_ERROR ? t(Y(e)) : e.type === n.E.SUBMIT_VALIDATION_ERROR ? t(z(e)) : t(W(e)), t(Object(c.e)({
							duration: c.a,
							kind: I.b.Error,
							text: Object(r.a)(e)
						}))
					}
				}, Z = "POST_DRAFT__LOAD_DRAFT", $ = Object(a.a)(Z), ee = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					t($(e));
					let a = y.e;
					const i = s();
					if (e.subredditId) {
						const t = Object(C.S)(i, {
								subredditId: e.subredditId
							}),
							s = Object(w.p)(i, {
								profileId: e.subredditId
							}),
							n = Object(A.i)(i);
						t ? a = {
							isProfile: !1,
							name: t.name
						} : s && n && (a = {
							isProfile: !0,
							name: Object(v.e)(n)
						})
					}
					await t(Object(o.a)(a, e.id, !1));
					const c = Object(T.h)(s(), e.id);
					c && E.h(s(), c)
				}, te = "POST_DELETE_DRAFT_SUCCEEDED", se = "POST_DELETE_DRAFT_FAILED", ne = "POST_DELETE_DRAFT_PENDING", re = Object(a.a)(te), ae = Object(a.a)(se), ie = Object(a.a)(ne), oe = (e, t) => async (s, a, o) => {
					let {
						apiContext: p
					} = o;
					const O = a();
					if (Object(T.a)(O, e)) return;
					const g = Object(T.d)(O, {
						draftId: e
					});
					g && E.f(O, g), s(ie({
						draftId: e
					}));
					const f = await (async (e, t) => Object(u.a)(Object(l.a)(e, [b.g]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/draft?draft_id=").concat(t),
						method: n.db.DELETE
					}))(p(), e);
					if (f.ok) {
						const {
							draftsCount: n
						} = Object(h.c)(f.body);
						s(re({
							draftId: e,
							draftsCount: n
						}));
						const r = Object(d.u)(t);
						e === r && s(Object(i.p)(!0, t))
					} else {
						const t = f.error;
						s(ae({
							draftId: e,
							apiError: t
						})), s(Object(c.e)({
							duration: c.a,
							kind: I.b.Error,
							text: Object(r.a)(t)
						}))
					}
				}
		},
		"./src/reddit/actions/postFlair.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return O
			})), s.d(t, "a", (function() {
				return j
			})), s.d(t, "f", (function() {
				return E
			})), s.d(t, "b", (function() {
				return T
			})), s.d(t, "e", (function() {
				return D
			})), s.d(t, "d", (function() {
				return P
			})), s.d(t, "l", (function() {
				return N
			})), s.d(t, "k", (function() {
				return L
			})), s.d(t, "j", (function() {
				return U
			})), s.d(t, "g", (function() {
				return M
			})), s.d(t, "i", (function() {
				return F
			})), s.d(t, "h", (function() {
				return G
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/post.ts"),
				i = s("./src/reddit/actions/postFlairStyleTemplate.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/reddit/endpoints/flair/index.ts"),
				d = s("./src/reddit/helpers/flair.ts"),
				u = s("./src/reddit/models/Flair/index.ts"),
				l = s("./src/reddit/models/Toast/index.ts"),
				b = s("./src/reddit/selectors/postFlair.ts"),
				p = s("./src/reddit/selectors/subreddit.ts");
			const O = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				g = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				f = Object(r.a)(O),
				m = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				j = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				_ = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				h = Object(r.a)(j),
				y = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				E = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				I = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				v = Object(r.a)(E),
				S = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				T = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				w = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				C = Object(r.a)(T),
				A = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				D = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				P = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				R = Object(r.a)(D),
				k = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				x = Object(r.a)(P),
				N = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(p.S)(i, {
							subredditId: e
						}).name;
					s(g());
					const d = await Object(c.k)(a(), o, t);
					if (d.ok) {
						s(f({
							subredditId: e,
							isEnabled: t
						}))
					} else s(m());
					return d.ok
				}, L = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(p.S)(i, {
							subredditId: e
						}).name;
					s(_());
					const d = await Object(c.j)(a(), t, u.d.LinkFlair, o);
					if (d.ok) {
						s(h({
							subredditId: e,
							canAssignOwn: t
						}))
					} else s(y());
					return d.ok
				}, U = (e, t) => async (s, r, a) => {
					let {
						apiContext: d
					} = a;
					const b = r(),
						O = Object(p.S)(b, {
							subredditId: t
						}).name;
					s(I());
					const g = await Object(c.f)(d(), e, O, u.d.LinkFlair);
					let f = g.ok && !(g.body && !1 === g.body.success);
					if (f) {
						const n = g.body;
						if (s(v({
								subredditId: t,
								template: n
							})), n.id) {
							const r = e.styleTemplate,
								a = b.structuredStyles.flairTemplate.models[n.id];
							r ? f = await s(Object(i.d)(t, n.id, r)) : a && (f = await s(Object(i.c)(t, n.id)))
						}
					}
					if (f) {
						const e = Object(o.d)(n.fbt._("Flair saved!", null, {
							hk: "3MQuUt"
						}), l.b.SuccessMod);
						s(Object(o.e)(e))
					} else {
						s(S());
						const r = Object(o.d)(n.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "1yf1Ne"
						}), l.b.Error, n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), U(e, t));
						s(Object(o.e)(r))
					}
					return f
				}, M = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					const d = r(),
						u = Object(p.S)(d, {
							subredditId: t
						}).name;
					if (s(w()), (await Object(c.b)(i(), e, u)).ok) {
						s(C({
							subredditId: t,
							templateId: e
						}));
						const r = Object(o.d)(n.fbt._("Flair deleted!", null, {
							hk: "44T1il"
						}), l.b.SuccessMod);
						s(Object(o.e)(r))
					} else {
						s(A());
						const r = Object(o.d)(n.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "1nwT0G"
						}), l.b.Error, n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), M(e, t));
						s(Object(o.e)(r))
					}
				}, F = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					const d = r(),
						O = Object(b.d)(d, {
							subredditId: t
						}).templateIds,
						g = Object(p.S)(d, {
							subredditId: t
						}).name;
					if (s(R({
							subredditId: t,
							templateIds: e
						})), (await Object(c.e)(i(), g, u.d.LinkFlair, e)).ok) {
						s(k());
						const e = Object(o.d)(n.fbt._("Flair reorder saved.", null, {
							hk: "1Xbuan"
						}), l.b.SuccessMod);
						s(Object(o.e)(e))
					} else {
						s(x({
							subredditId: t,
							templateIds: O
						}));
						const r = Object(o.d)(n.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "4ohwNd"
						}), l.b.Error, n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), F(e, t));
						s(Object(o.e)(r))
					}
				}, G = e => {
					let {
						post: t,
						previewFlair: s,
						selectedTemplateId: n
					} = e;
					return async (e, r, i) => {
						let {
							apiContext: o
						} = i;
						const u = t.flair.filter(e => !Object(d.p)(e.type));
						if (s && u.unshift(s), e(Object(a.J)({
								[t.id]: {
									flair: u
								}
							})), s) {
							const e = Object(d.g)(s);
							Object(c.h)(o(), t.id, n, e)
						} else Object(c.h)(o(), t.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return E
			})), s.d(t, "d", (function() {
				return v
			})), s.d(t, "a", (function() {
				return S
			})), s.d(t, "c", (function() {
				return w
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/lodash/forEach.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/isEqual.js"),
				i = s.n(a),
				o = s("./node_modules/lodash/values.js"),
				c = s.n(o),
				d = s("./src/lib/makeActionCreator/index.ts"),
				u = s("./src/reddit/actions/imageUploads.ts"),
				l = s("./src/reddit/helpers/media/index.ts"),
				b = s("./src/lib/constants/index.ts"),
				p = s("./src/lib/makeApiRequest/index.ts"),
				O = s("./src/lib/omitHeaders/index.ts"),
				g = s("./src/reddit/constants/headers.ts");
			var f = s("./src/reddit/helpers/trackers/blade.ts"),
				m = s("./src/reddit/models/Image/index.tsx"),
				j = s("./src/reddit/selectors/subreddit.ts"),
				_ = s("./src/telemetry/index.ts"),
				h = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const y = e => {
					let {
						subredditId: t,
						flairId: s,
						imageKey: n,
						imageData: r
					} = e;
					return async (e, a, i) => {
						const o = a(),
							c = Object(j.S)(o, {
								subredditId: t
							});
						if (!c) return !1;
						e(Object(u.k)(r));
						const d = await (async (e, t, s, n, r, a) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_style_asset_upload_s3/").concat(s),
							method: b.db.POST,
							data: {
								filepath: n,
								imagetype: r,
								mimetype: a
							}
						}))(i.apiContext(), c.name, s, r.file.name, n, await Object(l.g)(r.file));
						let f = !1;
						try {
							const t = await Object(u.g)(a(), d, r, m.a.FlairTemplates);
							t && e(Object(u.j)(t)), f = !0
						} catch (_) {
							if (_ instanceof Error) throw _;
							e(Object(u.i)(_))
						}
						return f
					}
				},
				E = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				I = Object(d.a)(E),
				v = (e, t, s) => async (n, a, o) => {
					const {
						apiContext: d
					} = o;
					let l = a();
					const {
						pendingImages: E
					} = s;
					let v = h(s, ["pendingImages"]);
					const S = Object(j.S)(l, {
						subredditId: e
					});
					if (!S) return !1;
					const T = l.structuredStyles.flairTemplate.models[t];
					if (T && i()(T, v)) return !0;
					if (E) {
						const s = [];
						if (r()(E, (r, a) => {
								r && s.push(n(y({
									flairId: t,
									imageData: Object(m.m)(r),
									imageKey: a,
									subredditId: e
								})))
							}), !(await Promise.all(s)).every(e => e)) return !1;
						v = ((e, t, s) => {
							const n = Object.assign({}, e);
							return r()(t, (e, t) => {
								const r = e && s.imageUploads[e.id];
								r && r.kind === m.b.TempUploaded && (n[t] = r.url)
							}), n
						})(v, E, a())
					}
					l = a();
					let w = null,
						C = null;
					const A = [];
					try {
						(w = await Object(u.f)(l, m.a.FlairTemplates)) && (C = Object(u.m)(w)(n, a, o), A.push(...c()(w.imagesByKey)))
					} catch (k) {
						return !1
					}
					const D = await (async (e, t, s, n) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_styles/").concat(s),
							method: b.db.PUT,
							data: n
						}))(d(), S.name, t, v),
						P = T ? "edit_post_flair_template" : "save_post_flair_template",
						R = Object(f.e)(l, P);
					if (D.ok) {
						let e;
						if (C) try {
							await C, e = ((e, t, s) => {
								const n = Object.assign({}, e);
								return t.forEach(e => {
									const t = s.imageUploads[e.id];
									t && t.kind === m.b.Uploaded && (e.url === n.postBackgroundImage ? n.postBackgroundImage = t.url : e.url === n.postPlaceholderImage && (n.postPlaceholderImage = t.url))
								}), n
							})(v, A, a())
						} catch (k) {
							e = null
						} else e = v;
						n(I({
							flairId: t,
							template: e || v
						}))
					} else w && w.websocket.close();
					return Object(_.a)(Object.assign(Object.assign({}, R), {
						actionInfo: Object.assign(Object.assign({}, R.actionInfo), {
							success: D.ok
						})
					})), D.ok
				}, S = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", T = Object(d.a)(S), w = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(j.S)(i, {
							subredditId: e
						});
					if (!o) return !1;
					const c = await (async (e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_styles/").concat(s),
							method: b.db.DELETE
						}))(a(), o.name, t),
						d = Object(f.e)(i, "delete_flair_template");
					return c.ok && s(T({
						flairId: t
					})), Object(_.a)(Object.assign(Object.assign({}, d), {
						actionInfo: Object.assign(Object.assign({}, d.actionInfo), {
							success: c.ok
						})
					})), c.ok
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				a = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/postLevelCrowdControl.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return o
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/endpoints/crowdControl/index.ts");
			const a = "POST_LEVEL_CC_LOADED",
				i = Object(n.a)(a),
				o = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					const o = await Object(r.b)(a(), e);
					if (o.ok) {
						const s = o.body.data.postInfoById.crowdControlLevel;
						t(i({
							[e]: s
						}))
					}
				}
		},
		"./src/reddit/actions/postList.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "c", (function() {
				return d
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = (s("./src/reddit/actions/embedAndImage.ts"), s("./src/reddit/actions/video.ts"), s("./src/reddit/helpers/trackers/postList.ts"));
			s("./src/reddit/constants/postLayout.ts"), s("./src/reddit/selectors/platform.ts"), s("./src/reddit/selectors/posts.ts");
			s("./src/reddit/selectors/video.ts");
			const a = "POSTLIST__MARKED_END",
				i = "POSTLIST__UNMARKED_END",
				o = Object(n.a)(a),
				c = Object(n.a)(i),
				d = (e, t) => async (s, n) => {
					const a = n();
					e in a.listings.postOrder.fetchedTokens ? e in a.listings.postOrder.ids ? s(c({
						listingKey: e
					})) : r.j(a, e) : s(o({
						listingKey: e,
						listingName: t
					}))
				}
		},
		"./src/reddit/actions/postRequirements/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			}));
			const n = "POST_REQUIREMENTS_FAILED",
				r = "POST_REQUIREMENTS_LOADED",
				a = "POST_REQUIREMENTS_PENDING",
				i = "POST_REQUIREMENTS_UPDATED"
		},
		"./src/reddit/actions/postRequirements/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return y
			})), s.d(t, "b", (function() {
				return I
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/camelCase.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/sentry/index.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				u = s("./src/graphql/operations/GetPostRequirements.json"),
				l = s("./src/lib/makeGqlRequest/index.ts"),
				b = s("./src/graphql/operations/UpdatePostRequirements.json"),
				p = s("./src/reddit/endpoints/subreddit/about.ts"),
				O = s("./src/reddit/models/Toast/index.ts"),
				g = s("./src/reddit/selectors/postRequirements.ts"),
				f = s("./src/reddit/selectors/subreddit.ts"),
				m = s("./src/reddit/actions/postRequirements/constants.ts");
			const j = Object(o.a)(m.b),
				_ = Object(o.a)(m.c),
				h = Object(o.a)(m.a),
				y = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = {
						subredditName: e.toLowerCase()
					};
					if (Object(g.a)(s(), a)) return;
					t(_(a));
					let o = Object(f.G)(s(), e);
					if (!o) {
						const s = await Object(p.a)(r(), e, !1);
						if (s.ok) {
							o = s.body.data.subreddit.id
						}
						if (!o) {
							const e = s.error || {
								type: i.E.NOT_FOUND_ERROR
							};
							return void t(h(Object.assign(Object.assign({}, a), {
								error: e
							})))
						}
					}
					let d = null;
					const b = await ((e, t) => Object(l.a)(e, Object.assign(Object.assign({}, u), {
						variables: t
					})))(r(), {
						subredditId: o
					});
					if (b.ok) {
						const e = b.body;
						d = e.data.subreddit && e.data.subreddit.postRequirements
					}
					if (d) t(j(Object.assign(Object.assign({}, a), {
						requirements: d
					})));
					else {
						const s = b.error || {
							type: i.E.UNKNOWN_ERROR
						};
						t(h(Object.assign(Object.assign({}, a), {
							error: s
						}))), c.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: b.body,
								responseOk: b.ok
							}), c.c.captureMessage("Missing post requirements data!")
						})
					}
				}, E = Object(o.a)(m.d), I = (e, t) => async (s, r, a) => {
					let {
						gqlContext: i
					} = a;
					const o = e.toLowerCase(),
						c = Object(f.G)(r(), e);
					if (!c) return {
						success: !1
					};
					const u = Object.assign({
							subredditId: c
						}, t),
						p = await ((e, t) => Object(l.a)(e, Object.assign(Object.assign({}, b), {
							variables: t
						})))(i(), {
							input: u
						});
					let g = !1,
						m = null;
					if (p.ok) {
						const e = p.body;
						g = e.data.updatePostRequirements.ok, m = v(e.data.updatePostRequirements.fieldErrors)
					}
					return g ? (s(E({
						subredditName: o,
						partialRequirements: t
					})), {
						success: !0
					}) : (s(Object(d.e)({
						duration: d.a,
						id: "REQUIREMENTS_SAVE_ERROR",
						kind: O.b.Error,
						text: m && m.length ? m[0].message : n.fbt._("Something went wrong", null, {
							hk: "3i6szH"
						})
					})), {
						success: !1,
						errors: m || void 0
					})
				}, v = e => e && e.map(e => Object.assign(Object.assign({}, e), {
					field: a()(e.field)
				}))
		},
		"./src/reddit/actions/preferences.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return G
			})), s.d(t, "i", (function() {
				return B
			})), s.d(t, "g", (function() {
				return q
			})), s.d(t, "h", (function() {
				return V
			})), s.d(t, "p", (function() {
				return H
			})), s.d(t, "e", (function() {
				return K
			})), s.d(t, "d", (function() {
				return W
			})), s.d(t, "m", (function() {
				return Y
			})), s.d(t, "f", (function() {
				return z
			})), s.d(t, "o", (function() {
				return J
			})), s.d(t, "r", (function() {
				return Q
			})), s.d(t, "t", (function() {
				return te
			})), s.d(t, "c", (function() {
				return ie
			})), s.d(t, "v", (function() {
				return oe
			})), s.d(t, "w", (function() {
				return ce
			})), s.d(t, "x", (function() {
				return de
			})), s.d(t, "u", (function() {
				return ue
			})), s.d(t, "y", (function() {
				return le
			})), s.d(t, "F", (function() {
				return be
			})), s.d(t, "D", (function() {
				return pe
			})), s.d(t, "a", (function() {
				return Oe
			})), s.d(t, "q", (function() {
				return ge
			})), s.d(t, "E", (function() {
				return _e
			})), s.d(t, "H", (function() {
				return he
			})), s.d(t, "j", (function() {
				return ye
			})), s.d(t, "l", (function() {
				return Se
			})), s.d(t, "k", (function() {
				return we
			})), s.d(t, "z", (function() {
				return Ae
			})), s.d(t, "C", (function() {
				return De
			})), s.d(t, "s", (function() {
				return Pe
			})), s.d(t, "B", (function() {
				return Re
			})), s.d(t, "A", (function() {
				return xe
			})), s.d(t, "n", (function() {
				return Ne
			})), s.d(t, "G", (function() {
				return Me
			})), s.d(t, "J", (function() {
				return Fe
			})), s.d(t, "I", (function() {
				return Ge
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./node_modules/@reddit/onetrust-integration/dist/esm/index.js"),
				r = s("./node_modules/Base64/base64.js"),
				a = s("./src/config.ts"),
				i = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/js-cookie/src/js.cookie.js"),
				c = s.n(o),
				d = s("./node_modules/lodash/isEmpty.js"),
				u = s.n(d),
				l = s("./node_modules/lodash/omit.js"),
				b = s.n(l),
				p = s("./node_modules/lodash/pick.js"),
				O = s.n(p),
				g = s("./src/lib/constants/index.ts"),
				f = s("./src/lib/makeActionCreator/index.ts"),
				m = s("./src/lib/omitHeaders/index.ts"),
				j = s("./src/reddit/actions/chat/toggle.ts"),
				_ = s("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				h = s("./src/reddit/actions/users.ts"),
				y = s("./src/reddit/constants/cookie.ts"),
				E = s("./src/reddit/constants/headers.ts"),
				I = s("./src/reddit/endpoints/user/preferences.ts"),
				v = s("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				S = s("./src/lib/makeApiRequest/index.ts"),
				T = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				w = s("./src/reddit/actions/imageUploads.ts"),
				C = s("./src/reddit/actions/toaster.ts"),
				A = s("./src/reddit/constants/preferences.ts"),
				D = s("./src/reddit/endpoints/subreddit/settings.ts"),
				P = s("./src/reddit/helpers/media/index.ts"),
				R = s("./src/reddit/helpers/trackers/profileSettings.ts"),
				k = s("./src/reddit/models/Image/index.tsx"),
				x = s("./src/reddit/models/Toast/index.ts"),
				N = s("./src/reddit/models/User/index.ts"),
				L = s("./src/reddit/selectors/imageUploads.ts"),
				U = s("./src/reddit/selectors/structuredStyles.ts"),
				M = s("./src/reddit/selectors/subreddit.ts"),
				F = s("./src/reddit/selectors/user.ts");
			const G = "PREFERENCES__AUTOPLAY_TOGGLED",
				B = "PREFERENCES__NIGHTMODE_TOGGLED",
				q = "PREFERENCES__LANGUAGE_CHANGED",
				V = "PREFERENCES__LAYOUT_CHANGED",
				H = "PREFERENCES__SUBREDDIT_LAYOUT_CHANGED",
				K = "PREFERENCES__CUSTOMIZE_FLYOUT_SHOWN",
				W = "PREFERENCES__CUSTOMIZE_FLYOUT_DISMISSED",
				Y = "PREFERENCES__PROFILE_LAYOUT_CHANGED",
				z = "PREFERENCES__HAMBURGER_TRAY_TOGGLED",
				J = "PREFERENCES__RPAN_DU_DISMISSED",
				Q = "PREFERENCES__TOP_CONTENT_DISMISSAL_PREF_SET",
				X = Object(f.a)(q),
				Z = Object(f.a)(V),
				$ = Object(f.a)(H),
				ee = Object(f.a)(K),
				te = Object(f.a)(W),
				se = Object(f.a)(J),
				ne = Object(f.a)(Q),
				re = (Object(f.a)(Y), Object(f.a)(G)),
				ae = Object(f.a)(B),
				ie = (Object(f.a)(z), "PREFERENCES__COLLAPSED_TRAY_TOGGLED"),
				oe = (Object(f.a)(ie), e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = r(),
						i = await Object(S.a)(Object(m.a)(a, [E.a]), {
							data: {
								lang: e.replace("-", "_")
							},
							endpoint: "".concat(a.apiUrl, "/api/v1/me/prefs"),
							method: g.db.PATCH,
							type: "json"
						});
					if (i.ok) {
						const e = i.body.lang;
						t(X(e))
					}
				}),
				ce = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					t(Z({
						layout: e
					})), t(Object(h.o)())
				}, de = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(F.ab)(i),
						{
							hasSeenCustomizeFlyout: c
						} = i.user.prefs;
					c || s(ee()), t && o ? (s($({
						subredditId: t,
						layout: e
					})), s(Fe(t, {
						layout: e
					}, !1)), c || s(he({
						hasSeenCustomizeFlyout: !0
					}, !1))) : (s(ce(e)), s(he(c ? {
						layout: e
					} : {
						layout: e,
						hasSeenCustomizeFlyout: !0
					}, !1)))
				}, ue = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					s().user.account && await Object(I.d)(e, r())
				}, le = e => async (t, s, o) => {
					let {
						apiContext: d
					} = o;
					const u = s();
					if (Object(U.j)(u)) t(Object(C.e)({
						kind: x.b.Error,
						text: i.fbt._("In order to continue styling your community, Night Mode must be turned off.", null, {
							hk: "1yZidT"
						})
					}));
					else {
						if (u.user.account) await Object(I.e)(e, d());
						else {
							const t = c.a.get(y.j);
							if (t) {
								const s = JSON.parse(Object(r.atob)(t));
								s.prefs.nightmode = e, Object(n.b)(y.j, btoa(JSON.stringify(s)), {
									domain: a.a.cookieDomain
								})
							}
						}
						t(ae({
							nightmode: e
						})), t(Object(j.f)(e)), c.a.remove(y.d, {
							domain: a.a.cookieDomain
						})
					}
				}, be = () => async (e, t, s) => {
					let {
						apiContext: o
					} = s;
					const d = t(),
						u = d.user.prefs.topContentTimesDismissed + 1,
						l = Date.now();
					if (d.user.account) e(he({
						topContentDismissalTime: l,
						topContentTimesDismissed: u
					}, !1));
					else {
						const e = c.a.get(y.j);
						if (e) {
							const t = JSON.parse(Object(r.atob)(e));
							t.prefs[A.d] = l, t.prefs[A.e] = u, Object(n.b)(y.j, btoa(JSON.stringify(t)), {
								domain: a.a.cookieDomain
							})
						}
					}
					e(ne({
						topContentDismissalTime: l,
						topContentTimesDismissed: u
					})), e(Object(C.e)({
						kind: x.b.SuccessCommunity,
						text: i.fbt._("Got it! We will show you less of this", null, {
							hk: "4op5Wa"
						})
					}))
				}, pe = e => async (t, s, o) => {
					let {
						apiContext: d
					} = o;
					const u = -1 === [_.R, "r/popular"].indexOf(e),
						l = Date.now(),
						b = s(),
						p = i.fbt._("Got it! We will show you less of this", null, {
							hk: "4op5Wa"
						});
					if (b.user.account)
						if (u) {
							const s = e.replace(/^r\//, ""),
								n = Object(M.G)(b, s);
							t(Fe(n, {
								rpanDuDismissalTime: l
							}, !1))
						} else t(he({
							rpanDuDismissalTime: l
						}, !1));
					else {
						const e = c.a.get(y.j);
						if (e) {
							const t = JSON.parse(Object(r.atob)(e));
							t.prefs[A.b] = l, Object(n.b)(y.j, btoa(JSON.stringify(t)), {
								domain: a.a.cookieDomain
							})
						}
					}
					t(Object(C.e)({
						kind: x.b.SuccessCommunity,
						text: p
					})), t(se(l))
				}, Oe = "SETTINGS__ACCOUNT_PREFS_UPDATE_SUCCESS", ge = "SETTINGS__SUBREDDIT_PREFS_UPDATED", fe = Object(f.a)("SETTINGS__UPDATE_PENDING"), me = Object(f.a)("SETTINGS__UPDATE_FAILURE"), je = Object(f.a)(Oe), _e = Object(f.a)(ge), he = function(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
						s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
					return async (n, r, a) => {
						let {
							apiContext: o
						} = a;
						n(fe());
						const c = b()(e, A.a),
							d = O()(e, A.a),
							l = [];
						u()(c) || l.push(Object(I.g)(c, o())), u()(d) || l.push(Object(I.b)(d, o())), (await Promise.all(l)).every(e => e.ok) ? (n(je({
							preferences: e
						})), t && n(Object(C.e)({
							kind: x.b.SuccessCommunity,
							text: s || i.fbt._("Changes saved", null, {
								hk: "2isjrZ"
							})
						}))) : (n(me()), t && n(Object(C.e)({
							kind: x.b.Error,
							text: i.fbt._("Changes failed to save", null, {
								hk: "XrtIq"
							})
						})))
					}
				}, ye = "SETTINGS__SUCCESS", Ee = Object(f.a)("SETTINGS__PENDING"), Ie = Object(f.a)("SETTINGS__FAILURE"), ve = Object(f.a)(ye), Se = "SETTINGS__PROFILE_IMAGE_UPDATE_SUCCESS", Te = Object(f.a)(Se), we = "SETTINGS__PROFILE_IMAGE_DELETE_SUCCESS", Ce = Object(f.a)(we), Ae = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					t(Ee());
					const i = await ((e, t) => Object(S.a)(e, {
						endpoint: Object(T.a)("".concat(a.a.gatewayUrl, "/desktopapi/v1/prefs")),
						method: g.db.GET,
						data: {
							timestamp: t ? Date.now() : void 0
						}
					}))(r(), e);
					i.ok ? t(ve(i.body)) : t(Ie())
				}, De = e => async (t, s, r) => {
					let {
						apiContext: a
					} = r;
					if (s().user.account) await Object(I.a)(e, a());
					else {
						const e = c.a.get(y.e);
						if (e) {
							const t = JSON.parse(decodeURIComponent(e));
							t.pref_quarantine_optin = !0, Object(n.b)(y.e, JSON.stringify(encodeURIComponent(t)), g.y)
						} else {
							const e = JSON.stringify({
								pref_quarantine_optin: !0
							});
							Object(n.b)(y.e, e, g.y)
						}
					}
				}, Pe = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					s().user.account && await Object(I.c)(e, r()), t(re({
						autoplayVideo: e
					}))
				}, Re = (e, t) => async (s, n, r) => {
					await ke(e, t)(s, n, r)
				}, ke = (e, t) => async (s, n, r) => {
					const {
						apiContext: a
					} = r, o = Object(F.i)(n());
					if (!o || !o.profileId) return;
					s(Object(w.k)(e));
					const c = Object(N.e)(o),
						d = g.Ub + c,
						u = await Object(v.d)(a(), d, e.file.name, t, await Object(P.g)(e.file));
					if (u.ok) {
						let p;
						try {
							if (!(p = await Object(w.g)(n(), u, e, k.a.Profiles))) return void s(Object(C.e)({
								kind: x.b.Error,
								text: i.fbt._("Changes failed to save", null, {
									hk: "3QlXrl"
								})
							}));
							s(Object(w.j)(p))
						} catch (l) {
							return void s(Object(w.i)(l))
						}
						let O = null,
							g = null;
						try {
							(O = await Object(w.f)(n(), k.a.Profiles)) && (g = Object(w.m)(O)(s, n, r))
						} catch (b) {
							return void s(Object(C.e)({
								kind: x.b.Error,
								text: i.fbt._("Changes failed to save", null, {
									hk: "3QlXrl"
								})
							}))
						}
						const f = decodeURIComponent(p.url);
						if (s(Te({
								imageUrl: f,
								key: t,
								subredditId: o.profileId,
								username: c
							})), (await Object(v.e)(a(), d, {
								[t]: f
							})).ok) {
							if (g) try {
								await g
							} catch (b) {}
							s(Object(C.e)({
								kind: x.b.SuccessCommunity,
								text: i.fbt._("Changes saved", null, {
									hk: "xEVHp"
								})
							})), Object(R.g)(n(), t);
							const r = Object(L.a)(n(), e);
							s(Te({
								imageUrl: r ? r.url : p.url,
								key: t,
								subredditId: o.profileId,
								username: c
							}))
						} else s(Object(C.e)({
							kind: x.b.Error,
							text: i.fbt._("Changes failed to save", null, {
								hk: "1y1wAY"
							})
						}))
					} else {
						const e = "profileBanner" === t ? "1280x384" : "256x256";
						s(Object(C.e)({
							kind: x.b.Error,
							text: i.fbt._("There was an error uploading your image. Please verify that the size of your image is {maxImageSize} and less than 500KB.", [i.fbt._param("maxImageSize", e)], {
								hk: "I6lfz"
							})
						}))
					}
				}, xe = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = Object(F.i)(s());
					if (!a || !a.profileId) return;
					const o = Object(N.e)(a),
						c = g.Ub + o,
						d = {
							profileIcon: "icon",
							profileBanner: "banner"
						} [e],
						u = await Object(D.b)(r(), c, d);
					if (u.ok) {
						const n = u.body[d + "_img"];
						t(Ce({
							imageUrl: n,
							key: e,
							subredditId: a.profileId,
							username: o
						})), t(Object(C.e)({
							kind: x.b.SuccessCommunity,
							text: i.fbt._("Changes saved", null, {
								hk: "xEVHp"
							})
						})), Object(R.f)(s(), e)
					} else t(Object(C.e)({
						kind: x.b.Error,
						text: i.fbt._("Changes failed to save", null, {
							hk: "1y1wAY"
						})
					}))
				}, Ne = "SETTINGS__PROFILE_SETTINGS_UPDATE_SUCCESS", Le = Object(f.a)(Ne), Ue = Object(f.a)("SETTINGS__PROFILE_SETTINGS_UPDATE_FAILED"), Me = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const o = Object(F.i)(n());
					if (!o || !o.profileId) return !1;
					const c = [],
						d = n().subreddits.settings[o.profileId],
						u = Object.assign(Object.assign({}, d), e);
					c.push(Object(D.f)(a(), o.profileId, u));
					const {
						showActiveCommunities: l,
						prevShowActiveCommunities: b
					} = t;
					return l !== b && c.push(Object(I.g)({
						showActiveCommunities: l
					}, a())), (await Promise.all(c)).every(e => e.ok) ? (s(Le({
						settings: e,
						additional: t,
						subredditId: o.profileId
					})), Object(R.i)(n()), s(Object(C.e)({
						kind: x.b.SuccessCommunity,
						text: i.fbt._("Changes saved", null, {
							hk: "xEVHp"
						})
					})), !0) : (s(Ue()), s(Object(C.e)({
						kind: x.b.Error,
						text: i.fbt._("Changes failed to save", null, {
							hk: "1y1wAY"
						})
					})), !1)
				}, Fe = function(e, t) {
					let s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (n, r, a) => {
						let {
							apiContext: o
						} = a;
						const c = r().user.prefs.subreddit[e];
						n(_e({
							subredditId: e,
							prefs: t
						})), (await Object(I.h)(e, t, o())).ok ? s && n(Object(C.e)({
							kind: x.b.SuccessCommunity,
							text: i.fbt._("Changes saved", null, {
								hk: "xEVHp"
							})
						})) : (c && n(_e({
							subredditId: e,
							prefs: c
						})), s && n(Object(C.e)({
							kind: x.b.Error,
							text: i.fbt._("Changes failed to save", null, {
								hk: "1y1wAY"
							})
						})))
					}
				}, Ge = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n();
					Object(M.S)(i, {
						subredditId: e
					}) && i.user.prefs.rememberCommunitySort && s(Fe(e, {
						sort: t
					}, !1))
				}
		},
		"./src/reddit/actions/product.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "h", (function() {
				return O
			})), s.d(t, "i", (function() {
				return y
			})), s.d(t, "j", (function() {
				return E
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/governance/errorToast.ts"),
				a = s("./src/reddit/endpoints/governance/badges.ts"),
				i = s("./src/reddit/endpoints/governance/products/badges.ts");
			const o = "PRODUCT__BADGE_PURCHASE_OPENED",
				c = "PRODUCT__BADGE_PURCHASE_SUCCESS",
				d = "PRODUCT__BADGE_PURCHASE_FAILURE",
				u = "PRODUCT__BADGE_PURCHASE_PENDING",
				l = "PRODUCT__FETCH_SUCCESS",
				b = "PRODUCT__FETCH_FAILURE",
				p = "PRODUCT__FETCH_PENDING",
				O = Object(n.a)(o),
				g = Object(n.a)(c),
				f = Object(n.a)(d),
				m = Object(n.a)(u),
				j = Object(n.a)(l),
				_ = Object(n.a)(b),
				h = Object(n.a)(p),
				y = e => {
					let {
						productId: t
					} = e;
					return async (e, s, n) => {
						let {
							apiContext: o
						} = n;
						const c = s(),
							d = c.products.models[t],
							u = c.user.account,
							l = !!c.products.api.purchase.pending[t];
						if (d && d.price && !l) {
							e(m({
								productId: t
							}));
							const s = await Object(i.c)(o(), {
								price: d.price,
								products: [{
									productId: t,
									quantity: "1"
								}],
								subredditId: d.subredditId
							});
							let n;
							if (s.ok && u && (n = await Object(a.c)(o(), d.subredditId, u.id)), s.ok) {
								if (n && n.ok) {
									const {
										badges: t,
										userOwnedBadges: r
									} = n.body;
									e(g({
										product: d,
										badges: t,
										userOwnedBadges: r,
										wallet: s.body.wallet
									}))
								}
							} else e(f({
								productId: t,
								error: s.error
							})), Object(r.a)(e, s.error)
						}
					}
				},
				E = e => {
					let {
						subredditId: t
					} = e;
					return async (e, s, n) => {
						let {
							apiContext: r
						} = n;
						e(h({
							subredditId: t
						}));
						const a = await Object(i.a)(r(), t);
						a.ok ? e(j({
							subredditId: t,
							products: a.body
						})) : e(_({
							subredditId: t,
							error: a.error
						}))
					}
				}
		},
		"./src/reddit/actions/profile/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "k", (function() {
				return n
			})), s.d(t, "j", (function() {
				return r
			})), s.d(t, "l", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "m", (function() {
				return d
			})), s.d(t, "n", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "i", (function() {
				return O
			})), s.d(t, "h", (function() {
				return g
			})), s.d(t, "g", (function() {
				return f
			}));
			const n = "PROFILE__PROFILE_INFO_LOADED",
				r = "PROFILE__PROFILE_INFO_FAILED",
				a = "PROFILE__PROFILE_MOD_HUB_PAGE_LOADED",
				i = "PROFILE__MODERATED_SUBREDDITS_PENDING",
				o = "PROFILE__MODERATED_SUBREDDITS_LOADED",
				c = "PROFILE__MODERATED_SUBREDDITS_FAILED",
				d = "PROFILE__RECEIVED_MODERATED_SUBREDDITS_MODELS",
				u = "PROFILE__RECEIVED_MODERATED_SUBREDDITS_SUBSCRIPTIONS",
				l = "MORE__PROFILE_GQL_MODERATED_PENDING",
				b = "MORE__PROFILE_GQL_MODERATED_LOADED",
				p = "MORE__PROFILE_GQL_MODERATED_FAILED",
				O = "PROFILE__MULTIREDDITS_PENDING",
				g = "PROFILE__MULTIREDDITS_LOADED",
				f = "PROFILE__MULTIREDDITS_FAILED"
		},
		"./src/reddit/actions/profile/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return M
			})), s.d(t, "e", (function() {
				return F
			})), s.d(t, "d", (function() {
				return G
			})), s.d(t, "b", (function() {
				return B
			})), s.d(t, "c", (function() {
				return K
			})), s.d(t, "g", (function() {
				return J
			})), s.d(t, "f", (function() {
				return Q
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/reddit/actions/contentGate.ts"),
				i = s("./src/reddit/actions/gold/gild.ts"),
				o = s("./src/reddit/actions/pages/profilePrivate/constants.ts"),
				c = s("./src/reddit/actions/subredditModeration.ts"),
				d = s("./src/reddit/constants/profiles.ts"),
				u = s("./src/reddit/endpoints/profile/info.ts"),
				l = s("./src/graphql/operations/ModeratedSubreddits.json"),
				b = s("./src/lib/makeApiRequest/index.ts"),
				p = s("./src/lib/makeGqlRequest/index.ts"),
				O = s("./src/lib/omitHeaders/index.ts"),
				g = s("./src/reddit/constants/headers.ts");
			var f = s("./src/graphql/operations/RedditorMultireddits.json");
			var m = s("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				j = s("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				_ = s("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				h = s("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts");
			var y = s("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				E = e => {
					const t = e.awardee_karma || 0,
						s = e.awarder_karma || 0,
						n = e.comment_karma,
						a = e.link_karma,
						i = t + s + n + a;
					return Object.assign({
						accountIcon: e.icon_img,
						awardedLastMonth: e.awarded_last_month ? Object(y.c)(e.awarded_last_month) : null,
						awardeeKarma: t,
						awarderKarma: s,
						commentKarma: n,
						created: e.created,
						createdUtc: e.created_utc,
						displayName: e.name,
						displayNamePrefixed: e.subreddit && e.subreddit.display_name_prefixed,
						displayText: e.name,
						hasUserProfile: !!e.subreddit,
						hideFromRobots: !!e.hide_from_robots,
						id: "".concat(r.yb.Account, "_").concat(e.id),
						isEmployee: e.is_employee,
						isFollowing: e.has_subscribed,
						isGold: e.is_gold,
						isAdmin: e.is_admin,
						isMod: e.is_mod,
						isNSFW: !(!e.subreddit || !e.subreddit.over_18),
						prefShowSnoovatar: e.pref_show_snoovatar,
						prefShowTwitter: e.pref_show_twitter,
						postKarma: a,
						totalKarma: i,
						url: "/user/".concat(e.name, "/"),
						username: e.name
					}, e.subreddit ? {
						profileId: e.subreddit.name
					} : null)
				},
				I = e => {
					const t = e.awardee_karma || 0,
						s = e.awarder_karma || 0,
						n = e.comment_karma,
						r = e.link_karma,
						a = t + s + n + r;
					return {
						acceptChats: !1 !== e.accept_chats,
						acceptPms: !1 !== e.accept_pms,
						awardeeKarma: t,
						awarderKarma: s,
						commentKarma: n,
						hasExternalAccount: e.has_external_account,
						postKarma: r,
						prefShowTwitter: e.pref_show_twitter,
						publicDescription: e.subreddit ? e.subreddit.public_description : "",
						totalKarma: a,
						userIsSubscriber: e.subreddit && e.subreddit.user_is_subscriber || !1
					}
				},
				v = s("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts");
			var S = s("./src/reddit/models/User/index.ts"),
				T = s("./src/reddit/selectors/profile.ts"),
				w = s("./src/reddit/selectors/subscriptions.ts"),
				C = s("./src/reddit/selectors/user.ts"),
				A = s("./src/reddit/actions/profile/constants.ts");
			const D = Object(n.a)(A.k),
				P = Object(n.a)(A.j),
				R = Object(n.a)(A.l),
				k = Object(n.a)(A.c),
				x = Object(n.a)(A.b),
				N = Object(n.a)(A.a),
				L = Object(n.a)(A.m),
				U = Object(n.a)(A.n),
				M = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = Object(C.i)(t());
					r && r.profileId && await e(G(Object(S.e)(r)))
				}, F = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = await Object(u.b)(r(), e);
					if (a.ok) {
						const s = a.body.data;
						let n = Object(_.a)(s.profileByName.modPermissions || {});
						const r = Object(h.a)(s.identity),
							i = Object(j.a)(s.profileByName);
						r.profileId === i.id && (n = d.a), t(Object(c.kb)({
							[i.id]: n
						})), t(R({
							account: r,
							profile: i,
							profileName: e
						}))
					}
				}, G = (e, t) => async (s, n, i) => {
					let {
						apiContext: o,
						gqlContext: c
					} = i;
					var d, l;
					const b = n();
					if (!!(Object(T.j)(b, {
							profileName: e
						}) && Object(T.h)(b, {
							profileName: e
						}) && Object(C.gb)(b, {
							userName: e
						})) && !t) return;
					const [p, O] = await Promise.all([Object(u.c)(o(), e), Object(u.d)(c(), e)]);
					if (p.ok) {
						p.body && p.body.data && p.body.data.is_suspended && s(Object(a.u)({
							profileName: e
						}));
						const t = function(e) {
							const {
								data: t
							} = e;
							return Object.assign({
								about: I(t),
								banner: t.subreddit && t.subreddit.banner_img && {
									height: t.subreddit.banner_size && t.subreddit.banner_size[1],
									url: t.subreddit.banner_img,
									width: t.subreddit.banner_size && t.subreddit.banner_size[0]
								},
								user: E(t),
								features: t.features
							}, t.subreddit ? {
								profile: Object(v.a)(t.subreddit, t.name)
							} : null)
						}(p.body);
						if (O.ok && (null === (d = O.body.data.redditorInfoByName) || void 0 === d ? void 0 : d.karma)) {
							const e = null === (l = O.body.data.redditorInfoByName) || void 0 === l ? void 0 : l.karma,
								s = e ? {
									awardeeKarma: e.fromAwardsReceived,
									awarderKarma: e.fromAwardsGiven,
									commentKarma: e.fromComments,
									postKarma: e.fromPosts,
									totalKarma: e.total
								} : u.a;
							Object.assign(t.about, s), Object.assign(t.user, s)
						}
						s(D(t))
					} else p.error && p.error.type === r.m && s(Object(a.s)({
						profileName: e
					})), s(P(p.body))
				}, B = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const i = {
						profileName: e
					};
					if (Object(T.a)(s(), i)) return;
					if (Object(T.k)(s(), i)) return;
					t(k(i));
					const o = await ((e, t) => Object(b.a)(Object(O.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/moderated_subreddits.json"),
						method: r.db.GET,
						traceRequestName: "get_profile_moderated_subreddits",
						data: {
							raw_json: 1
						}
					}))(a(), e);
					if (o.ok) {
						const n = function(e) {
							return e ? e.map(e => ({
								communityIcon: e.community_icon,
								displayText: e.sr_display_name_prefixed,
								icon: {
									height: e.icon_size ? e.icon_size[1] : 0,
									url: e.icon_img ? e.icon_img : "",
									width: e.icon_size ? e.icon_size[0] : 0
								},
								id: e.name,
								isNSFW: e.over_18,
								isQuarantined: !!e.quarantine,
								name: "user" === e.subreddit_type ? e.sr.slice(r.Ub.length) : e.sr,
								primaryColor: e.primary_color,
								subscribers: e.subscribers,
								title: e.title,
								type: e.subreddit_type,
								url: e.url,
								wls: e.wls
							})) : []
						}(o.body.data);
						t(x({
							profileName: e,
							data: n
						}));
						const a = {},
							i = {};
						if (n.forEach(e => {
								("user" === e.type ? i : a)[e.id] = e
							}), t(L({
								subreddits: a,
								profiles: i
							})), !Object(w.e)(s())) {
							const e = (e => {
								const t = e.filter(e => e.user_is_subscriber);
								return {
									subredditOrder: t.filter(e => "user" !== e.subreddit_type).map(e => e.name),
									profileOrder: t.filter(e => "user" === e.subreddit_type).map(e => e.name)
								}
							})(o.body.data || []);
							t(U(e))
						}
					} else t(N(o.body))
				}, q = Object(n.a)(A.f), V = Object(n.a)(A.e), H = Object(n.a)(A.d), K = e => async (t, s, n) => {
					const r = s(),
						a = e.toLowerCase(),
						{
							pageInfo: i
						} = r.profiles.moderated;
					if (!i[a] || !i[a].hasNextPage || !i[a].endCursor) return;
					t(q({
						profileName: a
					}));
					const c = await ((e, t) => Object(p.a)(e, Object.assign(Object.assign({}, l), {
							variables: t
						})))(n.gqlContext(), {
							name: a,
							after: i[a].endCursor,
							first: o.h
						}),
						d = c.body.data;
					if (c.ok) {
						const e = Object(j.b)(d.redditor.moderatedSubreddits);
						t(V(Object.assign({
							profileName: a
						}, e)))
					} else t(H(c.error))
				}, W = Object(n.a)(A.i), Y = Object(n.a)(A.h), z = Object(n.a)(A.g), J = (e, t) => async (s, n, a) => {
					const i = n(),
						c = e.toLowerCase(),
						d = {
							profileName: c
						};
					if (Object(T.b)(i, d)) return;
					if (!t && Object(T.l)(i, d)) return;
					const {
						pageInfo: u
					} = i.profiles.multireddits;
					if (t && (!u[c] || !u[c].hasNextPage || !u[c].endCursor)) return;
					s(W(d));
					const l = await ((e, t) => Object(p.a)(e, Object.assign(Object.assign({}, f), {
							variables: t
						}), {
							traceRequestName: "get_profile_multireddits"
						}))(a.gqlContext(), {
							name: c,
							first: t ? o.h : r.Gb,
							after: t ? u[c].endCursor : void 0
						}),
						b = l.body.data;
					if (l.ok && b.redditorInfoByName) {
						const e = b.redditorInfoByName.multireddits.edges.map(e => e.node),
							t = Object(m.b)(e);
						s(Y(Object.assign(Object.assign(Object.assign({}, d), t), {
							pageInfo: b.redditorInfoByName.multireddits.pageInfo,
							multiredditsModelsState: i.multireddits.models
						})))
					} else s(z(Object.assign(Object.assign({}, d), {
						error: l.error
					})))
				}, Q = e => async (t, s, n) => {
					var r;
					const a = e.toLowerCase(),
						o = await Object(u.d)(n.gqlContext(), a);
					if (o.ok && o.body) {
						const e = null === (r = o.body.data.redditorInfoByName) || void 0 === r ? void 0 : r.karma;
						t(Object(i.awardKarmaUpdated)({
							awardeeKarma: (null == e ? void 0 : e.fromAwardsReceived) || 0,
							awarderKarma: (null == e ? void 0 : e.fromAwardsGiven) || 0,
							userName: a
						}))
					}
				}
		},
		"./src/reddit/actions/profileConversations.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return j
			})), s.d(t, "e", (function() {
				return _
			})), s.d(t, "d", (function() {
				return h
			})), s.d(t, "c", (function() {
				return y
			})), s.d(t, "b", (function() {
				return E
			})), s.d(t, "a", (function() {
				return I
			})), s.d(t, "h", (function() {
				return D
			})), s.d(t, "g", (function() {
				return P
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/lodash/difference.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/pick.js"),
				i = s.n(a),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeActionCreator/index.ts"),
				d = s("./src/reddit/actions/pages/profileShared.ts"),
				u = s("./src/reddit/constants/parameters.ts"),
				l = s("./src/reddit/constants/things.ts"),
				b = s("./src/config.ts"),
				p = s("./src/lib/makeApiRequest/index.ts"),
				O = s("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				g = s("./src/reddit/models/Comment/addProfileImgParam.ts");
			var f = s("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				m = s("./src/reddit/selectors/experiments/avatarsInComments.ts");
			const j = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_PENDING",
				_ = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_LOADED",
				h = "PROFILE_OVERVIEW_CONVERSATIONS__MORE_POSTS_FAILED",
				y = "PROFILE__EXTRACOMMENTS_PENDING",
				E = "PROFILE__EXTRACOMMENTS_LOADED",
				I = "PROFILE__EXTRACOMMENTS_FAILED",
				v = Object(c.a)(j),
				S = Object(c.a)(_),
				T = Object(c.a)(h),
				w = Object(c.a)(E),
				C = Object(c.a)(y),
				A = Object(c.a)(I),
				D = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const a = t(),
						{
							currentPage: c
						} = a.platform;
					if (!c || !c.routeMatch) return;
					const {
						queryParams: l,
						params: g
					} = c.routeMatch.match, {
						sort: m,
						t: j
					} = Object(d.a)(a, l), {
						profileName: _
					} = g, h = _.toLowerCase(), y = Object(f.a)(h, o.lb, m, l), E = a.listings.postOrder.loadMore[y];
					if (!E) return;
					const I = a.listings.postOrder.api.pending[y],
						{
							fetchedTokens: w
						} = a.listings.postOrder,
						C = !(!w[y] || !w[y][E.token]);
					if (I || C) return;
					e(v({
						key: y,
						fetchedToken: E.token
					}));
					const A = await ((e, t, s) => Object(p.a)(e, {
						data: s,
						endpoint: Object(O.a)("".concat(b.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/conversations")),
						method: o.db.GET,
						traceRequestName: "get_profile_page"
					}))(n(), _, Object.assign({
						after: E.token,
						dist: E.dist,
						sort: m,
						t: j
					}, i()(l, u.l)));
					if (A.ok) {
						const t = a.listings.postOrder.ids[y],
							s = Object.assign(Object.assign({}, A.body), {
								postIds: r()(A.body.postIds, t)
							});
						e(S(Object.assign({
							fetchedToken: E.token,
							key: y,
							meta: a.meta,
							profileName: _
						}, s)))
					} else e(T({
						error: A.error,
						fetchedToken: E.token,
						key: y,
						account: A.body.data ? A.body.data.account : null
					}))
				}, P = (e, t, s) => async (n, r, a) => {
					let {
						apiContext: i
					} = a;
					const c = r();
					if (c.profileOverviewPage.conversations.extraComments.api.pending[s]) return;
					n(C({
						extraCommentsId: s
					}));
					let d = t;
					t.startsWith(l.b) && (d = t.slice(l.b.length));
					const u = s.split("-")[1],
						f = await ((e, t, s, n, r) => {
							let a = Object(O.a)("".concat(b.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/morecomments/").concat(s));
							return r && (a = Object(g.a)(a)), Object(p.a)(e, {
								endpoint: a,
								method: o.db.GET,
								type: "json",
								data: {
									after: n,
									limit: 14
								}
							})
						})(i(), e, d, u, Object(m.a)(c));
					f.ok ? n(w(Object.assign({
						profileName: e,
						extraCommentsId: s
					}, f.body))) : n(A(f.body))
				}
		},
		"./src/reddit/actions/profileOverviewChrono.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return O
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "d", (function() {
				return h
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/lodash/difference.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/pick.js"),
				i = s.n(a),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				d = s("./src/reddit/selectors/profileOverviewChronoItems.ts"),
				u = s("./src/lib/constants/index.ts"),
				l = s("./src/reddit/constants/parameters.ts"),
				b = s("./src/reddit/actions/pages/profileShared.ts"),
				p = s("./src/reddit/endpoints/page/profileOverviewPage.ts");
			const O = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_PENDING",
				g = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_LOADED",
				f = "PROFILE_OVERVIEW_CHRONO__MORE_ITEMS_FAILED",
				m = Object(o.a)(O),
				j = Object(o.a)(g),
				_ = Object(o.a)(f),
				h = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const a = t(),
						{
							currentPage: o
						} = a.platform;
					if (!o || !o.routeMatch) return;
					const {
						queryParams: O,
						params: g
					} = o.routeMatch.match, {
						sort: f,
						t: h
					} = Object(b.a)(a, O), {
						profileName: y
					} = g, E = Object(c.a)(y, u.kb, f, O), I = Object(d.d)(a, {
						listingKey: E
					});
					if (!I) return;
					const v = Object(d.b)(a, {
							listingKey: E
						}),
						S = Object(d.c)(a, {
							listingKey: E
						}),
						T = S && S[I.token];
					if (v || T) return;
					e(m({
						key: E,
						fetchedToken: I.token
					}));
					const w = await Object(p.a)(n(), y, Object.assign({
						after: I.token,
						dist: I.dist,
						sort: f,
						t: h
					}, i()(O, l.l)));
					if (w.ok) {
						const t = Object(d.f)(a, {
								listingKey: E
							}),
							s = Object.assign(Object.assign({}, w.body), {
								overviewIds: r()(w.body.overviewIds, t)
							});
						e(j(Object.assign({
							fetchedToken: I.token,
							key: E,
							meta: a.meta
						}, s)))
					} else e(_({
						error: w.error,
						fetchedToken: I.token,
						key: E,
						account: w.body.data ? w.body.data.account : null
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return O
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "a", (function() {
				return m
			})), s.d(t, "b", (function() {
				return y
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/post.ts"),
				a = s("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = s("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				o = s("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				c = s("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const d = Object(n.a)(a.w),
				u = Object(n.a)(a.x),
				l = Object(n.a)(a.G),
				b = (Object(n.a)(a.H), Object(n.a)(a.I)),
				p = Object(n.a)(a.T),
				O = e => async (t, s) => {
					if (Object(o.a)(s())) return Object(o.d)(s()) ? t(g(e)) : t((() => async (e, t, s) => {
						let {
							gqlContext: n
						} = s;
						const r = Object(c.k)(t()),
							a = r.global.lastUpdated || 0,
							o = 1e3 * r.global.rpan_config_refresh_rate;
						if (r.isPending || Date.now() < a + o) return;
						e(l());
						const u = await Object(i.b)(n());
						u.ok && u.body ? e(d(Object.assign(Object.assign({}, u.body), {
							lastUpdated: Date.now()
						}))) : e(b())
					})())
				}, g = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = Object(c.k)(s()),
						o = Object(c.m)(s(), {
							subreddit: e
						}),
						p = o && o.lastUpdated || 0,
						O = 1e3 * a.global.rpan_config_refresh_rate;
					if (a.isPending || a.isPermanentlyCanceled || Date.now() < p + O) return;
					t(l());
					const g = await Object(i.c)(r(), e);
					if (!g.ok) return void t(b());
					const f = g.body;
					t(d(Object.assign(Object.assign({}, f.global), {
						lastUpdated: Date.now()
					}))), t(u({
						name: e,
						config: Object.assign(Object.assign({}, f.listing_info), {
							lastUpdated: Date.now()
						})
					}))
				}, f = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					t(p()), await Object(i.i)(r(), e)
				}, m = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					s().posts.models[e] || await t(Object(r.D)(e))
				}, j = Object(n.a)(a.v), _ = Object(n.a)(a.J), h = Object(n.a)(a.K), y = () => async (e, t, s) => {
					let {
						gqlContext: n
					} = s;
					const r = t();
					if (!Object(o.d)(r) || Object(c.h)(r)) return;
					e(_());
					const a = await Object(i.d)(n());
					a.ok && a.body && a.body.data ? e(j({
						subreddits: a.body.data
					})) : e(h({
						error: a.error
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/automute.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			})), s.d(t, "b", (function() {
				return c
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				a = s("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const i = Object(n.a)(a.r),
				o = Object(n.a)(a.F),
				c = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const c = await Object(r.a)(a(), e);
					c && c.ok ? t(i({
						streamId: e,
						level: c.body.data.auto_mute_status.level
					})) : t(o(e))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "E", (function() {
				return r
			})), s.d(t, "X", (function() {
				return a
			})), s.d(t, "W", (function() {
				return i
			})), s.d(t, "P", (function() {
				return o
			})), s.d(t, "w", (function() {
				return c
			})), s.d(t, "x", (function() {
				return d
			})), s.d(t, "G", (function() {
				return u
			})), s.d(t, "I", (function() {
				return l
			})), s.d(t, "H", (function() {
				return b
			})), s.d(t, "t", (function() {
				return p
			})), s.d(t, "u", (function() {
				return O
			})), s.d(t, "y", (function() {
				return g
			})), s.d(t, "N", (function() {
				return f
			})), s.d(t, "M", (function() {
				return m
			})), s.d(t, "O", (function() {
				return j
			})), s.d(t, "z", (function() {
				return _
			})), s.d(t, "L", (function() {
				return h
			})), s.d(t, "r", (function() {
				return y
			})), s.d(t, "F", (function() {
				return E
			})), s.d(t, "v", (function() {
				return I
			})), s.d(t, "J", (function() {
				return v
			})), s.d(t, "K", (function() {
				return S
			})), s.d(t, "D", (function() {
				return T
			})), s.d(t, "B", (function() {
				return w
			})), s.d(t, "V", (function() {
				return C
			})), s.d(t, "C", (function() {
				return A
			})), s.d(t, "b", (function() {
				return D
			})), s.d(t, "s", (function() {
				return P
			})), s.d(t, "A", (function() {
				return R
			})), s.d(t, "T", (function() {
				return k
			})), s.d(t, "m", (function() {
				return x
			})), s.d(t, "l", (function() {
				return N
			})), s.d(t, "d", (function() {
				return L
			})), s.d(t, "e", (function() {
				return U
			})), s.d(t, "f", (function() {
				return M
			})), s.d(t, "g", (function() {
				return F
			})), s.d(t, "j", (function() {
				return G
			})), s.d(t, "c", (function() {
				return B
			})), s.d(t, "h", (function() {
				return q
			})), s.d(t, "k", (function() {
				return V
			})), s.d(t, "p", (function() {
				return H
			})), s.d(t, "q", (function() {
				return K
			})), s.d(t, "Y", (function() {
				return W
			})), s.d(t, "a", (function() {
				return Y
			})), s.d(t, "R", (function() {
				return z
			})), s.d(t, "i", (function() {
				return J
			})), s.d(t, "o", (function() {
				return Q
			})), s.d(t, "n", (function() {
				return X
			})), s.d(t, "Q", (function() {
				return Z
			})), s.d(t, "S", (function() {
				return $
			})), s.d(t, "U", (function() {
				return ee
			}));
			var n = s("./src/config.ts");
			const r = "RPAN__REMOVE_STREAM_FROM_HISTORY",
				a = "RPAN__VISIT_STREAM",
				i = -1,
				o = "RPAN__RESET_HISTORY",
				c = "RPAN__RECEIVE_GLOBAL_CONFIG",
				d = "RPAN__RECEIVE_SUBREDDIT_CONFIG",
				u = "RPAN__REQUEST_CONFIG",
				l = "RPAN__REQUEST_CONFIG_FAILED",
				b = "RPAN__REQUEST_CONFIG_CANCELED",
				p = "RPAN__RECEIVE_HLS_STREAM_ENDED",
				O = "RPAN__RECEIVE_HLS_STREAM_REMOVED",
				g = "RPAN__RECEIVE_STREAM_MODEL",
				f = "RPAN__REQUEST_STREAM_MODEL",
				m = "RPAN__REQUEST_STREAM_FAILED",
				j = "RPAN__REQUEST_STREAM_MODEL_BATCH",
				_ = "RPAN__RECEIVE_STREAM_MODEL_BATCH",
				h = "RPAN__REQUEST_STREAM_BATCH_FAILED",
				y = "RPAN__RECEIVE_AUTO_MUTE_LEVEL",
				E = "RPAN__REQUEST_AUTO_MUTE_LEVEL",
				I = "RPAN__RECEIVE_RECOMMENDED_VIEWER_SUBREDDITS",
				v = "RPAN__REQUEST_RECOMMENDED_VIEWER_SUBREDDITS",
				S = "RPAN__REQUEST_RECOMMENDED_VIEWER_SUBREDDITS_FAILED",
				T = "RPAN__RECEIVE_VOTE",
				w = "RPAN__RECEIVE_THEATER_SETTINGS",
				C = "RPAN__UPDATE_VIDEO_TIMESTAMP",
				A = "RPAN__RECEIVE_USER_SETTINGS",
				D = "RPAN__BATCH_OP",
				P = "RPAN__RECEIVE_DISCOVERY_UNIT_THUMBNAILS",
				R = "RPAN__RECEIVE_STREAM_PREVIEWS",
				k = "RPAN__SEND_HEARTBEAT",
				x = 0,
				N = 9999,
				L = 30,
				U = 6,
				M = 5,
				F = 15,
				G = 5,
				B = 57,
				q = 60,
				V = 7e3,
				H = 1e3,
				K = 400,
				W = 1e3,
				Y = 3e4,
				z = ("".concat(n.a.assetPath, "/img/trending-placeholder.png"), "home"),
				J = 3,
				Q = 500,
				X = 2e3,
				Z = "".concat(n.a.redditUrl, "/r/").concat("pan"),
				$ = "https://www.redditinc.com/policies/broadcasting-content-policy",
				ee = ("".concat(n.a.assetPath, "/img/rpan-broadcast-over.png"), "".concat(n.a.assetPath, "/img/rpan-broadcast-over-thumbnail.png"))
		},
		"./src/reddit/actions/publicAccessNetwork/streams.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return b
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "b", (function() {
				return h
			})), s.d(t, "d", (function() {
				return y
			})), s.d(t, "e", (function() {
				return E
			}));
			s("./node_modules/core-js/modules/es6.regexp.search.js"), s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/query-string/index.js"),
				r = s.n(n),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = s("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				c = s("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				d = s("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				u = s("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const l = new Set(["home", "r/popular"]),
				b = e => {
					const t = location && location.search || "",
						s = r.a.parse(t);
					l.has(e) && (s.related = e);
					const n = r.a.stringify(s);
					return n ? "?".concat(n) : ""
				},
				p = Object(a.a)(i.N),
				O = Object(a.a)(i.y),
				g = Object(a.a)(i.O),
				f = Object(a.a)(i.z),
				m = Object(a.a)(i.M),
				j = Object(a.a)(i.L),
				_ = Object(a.a)(i.t),
				h = Object(a.a)(i.u),
				y = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = Object(c.h)(e),
						i = s();
					if (Object(u.d)(i, a)) return;
					t(p(a));
					const d = await Object(o.e)(r(), a),
						l = Date.now();
					if (d.ok && d.body && d.body.data) {
						const e = d.body.data;
						t(O({
							model: e,
							utcTimeStamp: l
						}))
					} else t(S({
						streamId: a,
						error: d.error,
						utcTimeStamp: l
					}))
				}, E = (e, t) => async (s, n) => Object(d.d)(n()) ? s(v(e, t)) : s(I()), I = () => async (e, t, s) => {
					let {
						gqlContext: n
					} = s;
					const r = t();
					if (Object(u.f)(r)) return;
					e(g());
					const a = await Object(o.g)(n()),
						i = Date.now();
					if (a.ok && a.body && a.body.data) {
						const t = a.body.data;
						e(f({
							models: t,
							utcTimeStamp: i
						}))
					} else e(T({
						error: a.error,
						utcTimeStamp: i
					}))
				}, v = (e, t) => async (s, n, r) => {
					let {
						gqlContext: a
					} = r;
					const i = n();
					if (Object(u.f)(i)) return;
					s(g());
					const c = await Object(o.f)(a(), e, t),
						d = Date.now();
					if (c.ok && c.body && c.body.data) {
						const t = c.body.data;
						s(f({
							listingName: e,
							models: t,
							utcTimeStamp: d
						}))
					} else s(T({
						error: c.error,
						utcTimeStamp: d
					}))
				}, S = e => async t => {
					t(m(e))
				}, T = e => async t => {
					t(j(e))
				}
		},
		"./src/reddit/actions/reCaptchaEnterprise.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return C
			})), s.d(t, "a", (function() {
				return D
			})), s.d(t, "d", (function() {
				return R
			})), s.d(t, "b", (function() {
				return N
			}));
			var n = s("./src/lib/asyncActions/index.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/constants/euCookiePolicy.ts"),
				i = s("./node_modules/ts-error/lib/cjs.js"),
				o = s.n(i);
			class GraphQLRequestError_GraphQLRequestError extends o.a {
				constructor(e) {
					super("An error occurred during a GraphQL request. The following response was received:\n\n".concat(JSON.stringify(e, void 0, 2))), this.response = e
				}
			}
			var c = s("./src/lib/reCaptchaEnterprise/index.ts"),
				d = s("./src/lib/sentry/index.ts");

			function u(e) {
				return t => async (s, n, r) => {
					const a = n();
					if (e(a)) return t(s, n, r)
				}
			}
			var l = s("./node_modules/lodash/every.js"),
				b = s.n(l),
				p = s("./src/reddit/constants/experiments.ts"),
				O = s("./src/graphql/operations/VerifyRecaptchaToken.json"),
				g = (s("./node_modules/core-js/modules/es7.symbol.async-iterator.js"), s("./node_modules/core-js/modules/es6.symbol.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/os-browserify/browser.js")),
				f = s.n(g);
			const m = /\s+at.*(?:\(|\s)(.*)\)?/,
				j = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/,
				_ = void 0 === f.a.homedir ? "" : f.a.homedir();
			const h = e => e.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
			class AggregateError_AggregateError extends Error {
				constructor(e) {
					if (!Array.isArray(e)) throw new TypeError("Expected input to be an Array, got ".concat(typeof e));
					let t = (e = [...e].map(e => e instanceof Error ? e : null !== e && "object" == typeof e ? Object.assign(new Error(e.message), e) : new Error(e))).map(e => "string" == typeof e.stack ? h(function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
						return t = Object.assign({
							pretty: !1
						}, t), e.replace(/\\/g, "/").split("\n").filter(e => {
							const t = e.match(m);
							if (null === t || !t[1]) return !0;
							const s = t[1];
							return !s.includes(".app/Contents/Resources/electron.asar") && !s.includes(".app/Contents/Resources/default_app.asar") && !j.test(s)
						}).filter(e => "" !== e.trim()).map(e => t.pretty ? e.replace(m, (e, t) => e.replace(t, t.replace(_, "~"))) : e).join("\n")
					}(e.stack)) : String(e)).join("\n");
					super(t = "\n" + function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
							s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
						const n = Object.assign({
							indent: " ",
							includeEmptyLines: !1
						}, s);
						if ("string" != typeof e) throw new TypeError("Expected `input` to be a `string`, got `".concat(typeof e, "`"));
						if ("number" != typeof t) throw new TypeError("Expected `count` to be a `number`, got `".concat(typeof t, "`"));
						if ("string" != typeof n.indent) throw new TypeError("Expected `options.indent` to be a `string`, got `".concat(typeof n.indent, "`"));
						if (0 === t) return e;
						const r = n.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
						return e.replace(r, n.indent.repeat(t))
					}(t, 4)), this.name = "AggregateError", Object.defineProperty(this, "_errors", {
						value: e
					})
				}*[Symbol.iterator]() {
					for (const e of this._errors) yield e
				}
			}
			var y = s("./src/lib/makeGqlRequest/index.ts");
			class MissingDataError_MissingDataError extends o.a {
				constructor() {
					super("Missing data in GraphQL response")
				}
			}
			class RequestFailedWithoutErrorsError_RequestFailedWithoutErrorsError extends o.a {
				constructor() {
					super("GraphQL request failed without errors")
				}
			}
			var E = s("./src/reddit/featureFlags/index.ts"),
				I = s("./src/reddit/featureFlags/utils.ts"),
				v = s("./src/reddit/helpers/chooseVariant/index.ts"),
				S = s("./src/reddit/selectors/meta.ts");
			const T = e => E.d.reCaptchaEnterprise(e) && !Object(S.d)(e),
				w = e => !!Object(v.c)(e, {
					experimentEligibilitySelector: Object(I.d)(Object(I.b)(...a.b)),
					experimentName: p.Qb
				}),
				C = Object(n.b)("LOAD_RECAPTCHA_ENTERPRISE"),
				A = () => u(e => b()([T, w, e => e.tracking.reCaptchaEnterprise.load === n.a.New], t => t(e)))(async e => {
					e(C.requested());
					try {
						await c.b.loadScript(), e(C.succeeded())
					} catch (t) {
						throw e(C.failed()), t
					}
				}),
				D = Object(n.b)("EXECUTE_RECAPTCHA_ENTERPRISE"),
				P = e => u(e => b()([T, w, e => e.tracking.reCaptchaEnterprise.load === n.a.Succeeded && e.tracking.reCaptchaEnterprise.execute === n.a.New], t => t(e)))(async t => {
					t(D.requested());
					try {
						const s = await c.b.execute(e);
						return t(D.succeeded({
							token: s
						})), s
					} catch (s) {
						throw t(D.failed()), s
					}
				}),
				R = Object(n.b)("SEND_RECAPTCHA_TOKEN"),
				k = e => u(e => b()([T, w, e => e.tracking.reCaptchaEnterprise.send === n.a.New && e.tracking.reCaptchaEnterprise.execute === n.a.Succeeded && e.tracking.reCaptchaEnterprise.load === n.a.Succeeded], t => t(e)))(async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					t(R.requested());
					try {
						await (async (e, t) => {
							const s = await Object(y.a)(e, Object.assign(Object.assign({}, O), {
								variables: {
									input: {
										token: t
									}
								}
							}));
							if (!s.ok) throw new GraphQLRequestError_GraphQLRequestError(s);
							if (!("data" in s.body)) throw new MissingDataError_MissingDataError;
							const {
								ok: n,
								errors: r
							} = s.body.data.verifyRecaptchaToken;
							if (r && r.length > 0) throw new AggregateError_AggregateError(r);
							if (!n) throw new RequestFailedWithoutErrorsError_RequestFailedWithoutErrorsError
						})(r(), e), t(R.succeeded())
					} catch (a) {
						throw t(R.failed()), a
					}
				}),
				x = (e, t) => Object(I.g)(t) ? (e => "".concat("STAGING__").concat(e))(e) : e,
				N = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c.a.PageLoad;
					return u(e => b()([T, w, e => e.tracking.reCaptchaEnterprise.load === n.a.New], t => t(e)))(async (t, s) => {
						const n = s();
						try {
							await t(A());
							const s = await t(P({
								action: x(e, n)
							}));
							s && await t(k(s))
						} catch (a) {
							if (a instanceof GraphQLRequestError_GraphQLRequestError && "object" == typeof a.response.error && null !== a.response.error && a.response.error.type === r.i) return;
							d.c.withScope(e => {
								Object(d.a)(e, {
									serverLogging: !1
								}), d.c.captureException(a)
							})
						}
					})
				}
		},
		"./src/reddit/actions/redditEmbed.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "c", (function() {
				return b
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/tabBadging.ts"),
				a = s("./src/reddit/endpoints/me/index.ts"),
				i = s("./src/reddit/helpers/pageActionLoginRedirect.ts");
			const o = "REDDIT_EMBED_LOADED",
				c = "REDDIT_EMBED_FAILED",
				d = Object(n.a)("REDDIT_EMBED_PENDING"),
				u = Object(n.a)(o),
				l = Object(n.a)(c),
				b = (e, t) => async (e, s, n) => {
					let {
						apiContext: o
					} = n;
					const c = s();
					e(d());
					const b = await Object(a.a)(o());
					b.ok && b.body ? !t || b.body.account ? (e(u(b.body)), e(Object(r.c)())) : Object(i.a)(e, c) : e(l(b.error))
				}
		},
		"./src/reddit/actions/removalReasons/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "k", (function() {
				return n
			})), s.d(t, "l", (function() {
				return r
			})), s.d(t, "j", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "h", (function() {
				return d
			})), s.d(t, "i", (function() {
				return u
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "d", (function() {
				return O
			})), s.d(t, "r", (function() {
				return g
			})), s.d(t, "s", (function() {
				return f
			})), s.d(t, "q", (function() {
				return m
			})), s.d(t, "n", (function() {
				return j
			})), s.d(t, "o", (function() {
				return _
			})), s.d(t, "p", (function() {
				return h
			})), s.d(t, "m", (function() {
				return y
			})), s.d(t, "t", (function() {
				return E
			}));
			const n = "REMOVALREASONS__LOAD_PENDING",
				r = "REMOVALREASONS__LOAD_SUCCESS",
				a = "REMOVALREASONS__LOAD_FAILED",
				i = "REMOVALREASONS__ADD_PENDING",
				o = "REMOVALREASONS__ADD_SUCCESS",
				c = "REMOVALREASONS__ADD_FAILED",
				d = "REMOVALREASONS__EDIT_PENDING",
				u = "REMOVALREASONS__EDIT_SUCCESS",
				l = "REMOVALREASONS__EDIT_FAILED",
				b = "REMOVALREASONS__DELETE_PENDING",
				p = "REMOVALREASONS__DELETE_SUCCESS",
				O = "REMOVALREASONS__DELETE_FAILED",
				g = "REMOVALREASONS__SUBMIT_PENDING",
				f = "REMOVALREASONS__SUBMIT_SUCCESS",
				m = "REMOVALREASONS__SUBMIT_FAILED",
				j = "REMOVALREASONS__MESSAGE_PENDING",
				_ = "REMOVALREASONS__MESSAGE_PRIVATE_SUCCESS",
				h = "REMOVALREASONS__MESSAGE_PUBLIC_SUCCESS",
				y = "REMOVALREASONS__MESSAGE_FAILED",
				E = "REMOVALREASONS__REMOVEDITEMS_SELECTED"
		},
		"./src/reddit/actions/reportFlow.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return _
			})), s.d(t, "d", (function() {
				return h
			})), s.d(t, "c", (function() {
				return y
			})), s.d(t, "h", (function() {
				return S
			})), s.d(t, "f", (function() {
				return T
			})), s.d(t, "a", (function() {
				return w
			})), s.d(t, "b", (function() {
				return C
			})), s.d(t, "j", (function() {
				return R
			})), s.d(t, "g", (function() {
				return k
			})), s.d(t, "i", (function() {
				return L
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/login.ts"),
				i = s("./src/reddit/actions/modal.ts"),
				o = s("./src/reddit/actions/reportRules.ts"),
				c = s("./src/reddit/actions/subreddit.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				u = s("./src/reddit/actions/users.ts"),
				l = s("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"),
				b = s("./src/reddit/endpoints/post/index.tsx"),
				p = s("./src/reddit/helpers/isComment.ts"),
				O = s("./src/reddit/helpers/isPost.ts"),
				g = s("./src/reddit/models/Post/index.ts"),
				f = s("./src/reddit/models/Toast/index.ts"),
				m = s("./src/reddit/selectors/posts.ts"),
				j = s("./src/reddit/selectors/user.ts");
			const _ = "REPORT__PENDING",
				h = "REPORT__LOADED",
				y = "REPORT__FAILED",
				E = Object(r.a)(_),
				I = Object(r.a)(h),
				v = Object(r.a)(y),
				S = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					const o = e.id,
						c = r(),
						u = c.reportFlow.api.pending[o],
						l = c.reportFlow.userIsMod;
					if (u) return;
					s(E({
						id: o
					}));
					const p = await Object(b.n)(i(), e),
						O = "error-report-".concat(o);
					if (p.ok) s(I({
						id: o
					})), s(d.f(O)), !t.isAbuseOfReportButton && l && s(L());
					else {
						s(v({
							id: o
						}));
						const r = p.error && p.error.fields && p.error.fields.length ? p.error.fields[0].msg : "";
						s(d.e({
							id: O,
							kind: f.b.Error,
							text: r || n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: S(e, t)
						}))
					}
				}, T = "REPORT_FLOW__TARGET_SET", w = "REPORT_FLOW__OPENED_FROM_MODAL_PAGE", C = "REPORT_FLOW__OPEN_CATEGORY", A = Object(r.a)(T), D = Object(r.a)(w), P = Object(r.a)(C), R = (e, t, s) => async (n, r, d) => {
					let {
						apiContext: l
					} = d;
					const b = r(),
						f = Object(p.a)(e),
						_ = Object(O.a)(e);
					if (!_ && !f) return;
					const h = f ? b.comments.models[e] : b.posts.models[e];
					if (!h) return;
					if (!Object(j.H)(r())) return n(Object(a.i)()), void n(Object(i.k)({
						actionSource: i.a.Report,
						redirectUrl: h.permalink
					}));
					n(Object(u.y)(h.author));
					const y = Object(m.ab)(b, {
							postId: f ? b.comments.models[e].postId : b.posts.models[e].id
						}),
						E = _ && Object(g.i)(h) || f && U(h, b);
					E || b.reportRules.sitewideRules && b.reportRules.sitewideRules.length || n(Object(o.d)()), !E || b.reportRules.liveStreamingRules && b.reportRules.liveStreamingRules.length || n(Object(o.c)()), y && n(Object(c.o)(y.name, y.type)), n(A(e)), n(D(!!t)), s && n(P(s)), y && n(N(y.name))
				}, k = "REPORT_FLOW__USER_IS_MOD_SET", x = Object(r.a)(k), N = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = await Object(l.a)(r());
					t(x(a.ok && !!a.body[e]))
				}, L = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					e(A(null))
				}, U = (e, t) => {
					const s = e.postId,
						n = s && t.posts.models[s];
					return !!n && Object(g.i)(n)
				}
		},
		"./src/reddit/actions/reportPageRules/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "REPORT_PAGE_RULES__LOADED"
		},
		"./src/reddit/actions/reportRules.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "c", (function() {
				return O
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/reddit/constants/headers.ts");
			const d = "SITEWIDE_RULES_LOADED",
				u = "LIVESTREAMING_RULES_LOADED",
				l = Object(r.a)(d),
				b = Object(r.a)(u),
				p = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					if (!t().user) return;
					const r = await (e => Object(i.a)(Object(o.a)(e, [c.a]), {
						endpoint: "".concat(e.apiUrl, "/api/sitewide_rules.json"),
						method: a.db.GET
					}))(n());
					if (r.ok) {
						const t = r.body,
							s = g(t.sitewide_rules);
						e(l(s))
					}
				}, O = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					if (!t().user) return;
					const r = await (e => Object(i.a)(Object(o.a)(e, [c.a]), {
						endpoint: "".concat(e.apiUrl, "/api/livestream_rules.json"),
						method: a.db.GET
					}))(n());
					if (r.ok) {
						const t = r.body,
							s = g(t.livestream_rules);
						e(b(s))
					}
				}, g = e => {
					let t = [];
					if (e && e.length > 2) {
						const s = {
							reasonTextToShow: n.fbt._("It's spam or abuse", null, {
								hk: "21rHqk"
							}),
							nextStepReasons: [e[0], e[1], e[2]]
						};
						4 === e.length && s.nextStepReasons && s.nextStepReasons.push(e[3]), t.push(s), t = t.concat(e.slice(e.length - 1))
					}
					return t
				}
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return r
			})), s.d(t, "f", (function() {
				return a
			})), s.d(t, "m", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "h", (function() {
				return d
			})), s.d(t, "l", (function() {
				return u
			})), s.d(t, "k", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "o", (function() {
				return p
			})), s.d(t, "d", (function() {
				return O
			})), s.d(t, "c", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "n", (function() {
				return m
			})), s.d(t, "i", (function() {
				return j
			})), s.d(t, "r", (function() {
				return _
			})), s.d(t, "u", (function() {
				return h
			})), s.d(t, "p", (function() {
				return y
			})), s.d(t, "q", (function() {
				return E
			})), s.d(t, "v", (function() {
				return I
			})), s.d(t, "s", (function() {
				return v
			})), s.d(t, "x", (function() {
				return S
			})), s.d(t, "w", (function() {
				return T
			})), s.d(t, "t", (function() {
				return w
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js");
			const r = "SCHEDULED_POSTS_REQUESTED",
				a = "SCHEDULED_POSTS_LOADED",
				i = "STANDALONE_SCHEDULED_POSTS_LOADED",
				o = "RECURRING_SCHEDULED_POSTS_LOADED",
				c = "SCHEDULED_POSTS_FAILED",
				d = "SCHEDULED_POST_CREATION_SUCCEEDED",
				u = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				l = "SCHEDULED_POST_MUTATE_REQUESTED",
				b = "SCHEDULED_POST_MUTATE_FAILED",
				p = "STANDALONE_POST_MUTATE_SUCCESS",
				O = "RECURRING_POST_MUTATE_SUCCESS",
				g = "RECURRING_POST__EDIT_MODAL_LOAD",
				f = "RECURRING_POST__EDIT_LOAD",
				m = "STANDALONE_POST__EDIT_LOAD",
				j = "SCHEDULED_POST__DELETE_SUCCESS",
				_ = () => n.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				h = () => n.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				y = () => n.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				E = () => n.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				I = () => n.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				v = () => n.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				S = () => n.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				}),
				T = () => n.fbt._("Successfully edited scheduled post!", null, {
					hk: "HfGcT"
				}),
				w = () => n.fbt._("Failed to update scheduled post", null, {
					hk: "2zBuRu"
				})
		},
		"./src/reddit/actions/search.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return h
			})), s.d(t, "c", (function() {
				return y
			})), s.d(t, "a", (function() {
				return E
			})), s.d(t, "d", (function() {
				return I
			})), s.d(t, "f", (function() {
				return v
			})), s.d(t, "j", (function() {
				return S
			})), s.d(t, "h", (function() {
				return D
			})), s.d(t, "g", (function() {
				return P
			})), s.d(t, "e", (function() {
				return R
			})), s.d(t, "i", (function() {
				return k
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/makeSearchKey/index.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				u = s("./src/reddit/constants/parameters.ts"),
				l = s("./src/reddit/actions/pages/subreddit.ts"),
				b = s("./src/reddit/endpoints/page/search.ts"),
				p = s("./src/lib/makeApiRequest/index.ts"),
				O = s("./src/lib/omitHeaders/index.ts"),
				g = s("./src/reddit/constants/headers.ts");
			var f = async (e, t) => Object(p.a)(Object(O.a)(e, [g.a]), {
				endpoint: "".concat(e.apiUrl, "/api/related_queries_v1.json?query=").concat(t),
				method: i.db.GET
			}), m = s("./src/reddit/models/Toast/index.ts"), j = s("./src/reddit/selectors/searchResults.ts"), _ = s("./src/reddit/selectors/user.ts");
			const h = "SEARCH__MORE_RESULTS_PENDING",
				y = "SEARCH__MORE_RESULTS_RECEIVED",
				E = "SEARCH__MORE_RESULTS_FAILED",
				I = "SEARCH__RELATED_QUERIES_RECEIVED",
				v = "SEARCH__UPDATE_SEARCH_QUERY",
				S = Object(o.a)(v),
				T = Object(o.a)(h),
				w = Object(o.a)(y),
				C = Object(o.a)(E),
				A = Object(o.a)(I),
				D = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						i = Object(j.g)(a, e);
					if (i && i.length > 0) return;
					const o = await f(r(), e);
					if (o.ok) {
						const s = (e => ({
							relatedQueries: e.body.related_queries
						}))(o);
						t(A({
							query: e,
							relatedQueries: s.relatedQueries
						}))
					}
				}, P = e => async (t, s, r) => {
					let {
						apiContext: o
					} = r;
					const p = s(),
						{
							queryParams: O
						} = p.platform.currentPage,
						g = Object(l.e)(O, Object(_.X)(p)),
						f = p.platform.currentPage.urlParams.subredditName || p.platform.currentPage.urlParams.multiredditName,
						{
							username: j
						} = p.platform.currentPage.urlParams,
						h = g || a()(O, u.t),
						y = Object(c.c)(h),
						E = Object.assign(Object.assign({}, y), {
							sort: y.category ? i.Lb.Relevance : y.sort,
							t: y.category ? i.Sb.DAY : y.t
						}),
						I = Object(c.b)(f, j, E);
					let v;
					if (e.indexOf(i.Nb.Posts) > -1) {
						const e = p.listings.postOrder.loadMore[I];
						if (!e) return;
						const t = p.listings.postOrder.api.pending[I],
							s = p.listings.postOrder.fetchedTokens,
							n = s[I] && s[I][e.token];
						if (t || n) return;
						v = e.token
					} else {
						if (!(e.indexOf(i.Nb.Subreddits) > -1 || e.indexOf(i.Nb.Users) > -1)) throw new Error("Should not attempt to fetch more results without a search type"); {
							const e = p.listings.listingOrder.loadMore[I];
							if (!e) return;
							const t = p.listings.listingOrder.api.pending[I],
								s = p.listings.listingOrder.fetchedTokens,
								n = s[I] && s[I][e.token];
							if (t || n) return;
							v = e.token
						}
					}
					const S = "error-".concat(I);
					t(T({
						fetchedToken: v,
						key: I,
						type: e
					}));
					const A = await Object(b.a)(o(), f, j, Object.assign(Object.assign({}, E), {
						after: v,
						type: (y.type || []).join(","),
						b: !0
					}));
					A.ok ? (t(w(Object.assign({
						key: I,
						fetchedToken: v,
						meta: p.meta,
						subredditOrMultiName: f,
						type: e
					}, A.body))), t(d.f(S))) : (t(C(Object.assign({
						key: I,
						error: A.error,
						fetchedToken: v,
						meta: p.meta,
						type: e
					}, A.body))), t(d.e({
						id: S,
						kind: m.b.Error,
						text: n.fbt._("Sorry, we couldn't load more search results.", null, {
							hk: "3IDePs"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: P(e)
					})))
				}, R = "SEARCH__TYPEAHEAD_SUCCESS", k = Object(o.a)(R)
		},
		"./src/reddit/actions/search/trending.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return O
			})), s.d(t, "b", (function() {
				return f
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./node_modules/uuid/v4.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/lib/extractQueryParams/index.ts"));
			var c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts"),
				l = s("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				b = s("./src/reddit/models/Search/index.ts");
			var p = e => {
				const t = {
					withAds: 1,
					ad: Object(o.a)(window.location.href).get("ad")
				};
				return Object(c.a)(Object(d.a)(e, [u.a]), {
					endpoint: "".concat(e.apiUrl, "/api/trending_searches_v1.json"),
					method: i.db.GET,
					data: t
				})
			};
			const O = "PAGE__TRENDING_SEARCHES_LOADED",
				g = Object(n.a)(O),
				f = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = await p(n());
					if (r.ok) {
						const t = (e => {
							const t = [];
							if (e.body && e.body.trending_searches) {
								const s = e.body.trending_searches.length;
								for (let n = 0; n < s; n++) {
									const s = e.body.trending_searches[n],
										r = s.results.data.children.length > 0 ? s.results.data.children[0].data : null,
										i = {
											id: a()(),
											post: r ? Object(l.a)(r) : null,
											rawQuery: s.query_string,
											searchQuery: s.display_string,
											section: b.c.trending,
											isWhitelisted: s.is_subreddit_whitelisted,
											subredditInfo: r ? {
												icon: r.sr_detail.community_icon || r.sr_detail.icon_img,
												displayText: r.sr_detail.display_name_prefixed
											} : null,
											subredditOccurrences: s.subreddit_occurences - 1,
											type: b.b.text
										};
									t.push(i)
								}
							}
							return t
						})(r);
						return e(g({
							items: t
						})), t
					}
					return null
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "c", (function() {
				return f
			})), s.d(t, "d", (function() {
				return m
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/loadWithRetries/index.ts");
			var a = s("./src/lib/makeGqlRequest/index.ts"),
				i = s("./src/graphql/operations/SubredditLinks.json");
			const o = e => ({
				communityIcon: e.styles && e.styles.icon || void 0,
				iconUrl: e.styles && e.styles.legacyIcon && e.styles.legacyIcon.url || void 0,
				id: e.id,
				isNSFW: e.isNSFW || !1,
				isSubscribed: e.isSubscribed,
				name: e.name,
				primaryColor: e.styles && e.styles.primaryColor || void 0,
				subscribers: e.subscribers,
				type: "subreddit"
			});
			var c = e => ({
					subreddits: e.data.subredditInfoById.linkedSubreddits ? e.data.subredditInfoById.linkedSubreddits.map(o) : []
				}),
				d = s("./src/reddit/selectors/seo/linksModule.ts");
			const u = "FRONTPAGE_LINKS__REQUEST_LOADED",
				l = "SUBREDDIT_LINKS_LOADED",
				b = Object(n.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				p = Object(n.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				O = Object(n.a)(u),
				g = Object(n.a)(l),
				f = () => async e => {
					e(b());
					const t = await (async () => (await Object(r.a)(() => s.e("FrontpageLinks").then(s.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default)();
					e(t ? O(t) : p())
				}, m = (e, t) => async (s, n, r) => {
					let {
						gqlContext: o
					} = r;
					if (e) {
						if (Object(d.c)(n(), {
								subredditId: e
							})) return;
						const r = await ((e, t) => Object(a.a)(e, Object.assign(Object.assign({}, i), {
							variables: t
						})))(o(), {
							subredditId: e,
							includeSubreddits: !0,
							subredditsLimit: t || 10
						});
						if (r.ok) {
							const t = c(r.body);
							t && s(g({
								id: e,
								data: t
							}))
						}
					}
				}
		},
		"./src/reddit/actions/shortcuts/active.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/shortcuts/constants.ts");
			const a = Object(n.a)(r.a),
				i = Object(n.a)(r.b)
		},
		"./src/reddit/actions/shortcuts/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = "SHORTCUTS__ACTIVE_COMMENT_SET",
				r = "SHORTCUTS__ACTIVE_POST_SET"
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			}));
			var n = s("./src/reddit/constants/shortcuts.ts"),
				r = s("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				a = s("./src/reddit/helpers/routeKey/index.ts");
			const i = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const s = t.routeMatch,
						n = Object(r.a)(e);
					return Object(a.b)(s, e, n)
				},
				o = e => {
					const t = document.getElementById(e);
					t && t.focus()
				},
				c = e => {
					const t = document.getElementById(e),
						s = window.scrollX,
						n = window.scrollY;
					t && (t.focus(), window.scrollTo(s, n))
				},
				d = () => {
					c(n.b)
				}
		},
		"./src/reddit/actions/sso/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = "LINKED_IDENTITY__ADD",
				r = "LINKED_IDENTITY__REMOVE"
		},
		"./src/reddit/actions/streaming/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "SUBREDDIT__STREAMING_MOD_SETTINGS_LOADED"
		},
		"./src/reddit/actions/streaming/modSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return p
			})), s.d(t, "c", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "d", (function() {
				return E
			})), s.d(t, "e", (function() {
				return I
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/streaming/constants.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				o = s("./src/graphql/operations/FetchSubredditStreamingModSettings.json"),
				c = s("./src/lib/makeGqlRequest/index.ts"),
				d = s("./src/graphql/operations/UpdateSubredditStreamingModSettings.json"),
				u = s("./src/reddit/models/Toast/index.ts"),
				l = s("./src/reddit/selectors/subreddit.ts");
			const b = Object(r.a)(a.a),
				p = "STREAMING_MOD_SETTINGS__UPDATE_PENDING",
				O = "STREAMING_MOD_SETTINGS__UPDATE_LOADED",
				g = "STREAMING_MOD_SETTINGS__UPDATE_FAILED",
				f = Object(r.a)(p),
				m = Object(r.a)(O),
				j = Object(r.a)(g),
				_ = e => async (t, s, r) => {
					let {
						gqlContext: a
					} = r;
					const d = Object(l.S)(s(), {
						subredditId: e
					});
					if (void 0 === d) {
						const e = n.fbt._("Invalid subreddit", null, {
								hk: "2iUXvs"
							}),
							s = Object(i.d)(e, u.b.Error);
						return await t(Object(i.e)(Object.assign(Object.assign({}, s), {
							duration: i.a
						}))), {
							reason: e
						}
					}
					const p = await ((e, t) => Object(c.a)(e, Object.assign(Object.assign({}, o), {
						variables: {
							subredditId: t
						}
					})))(a(), e);
					if (!p.ok) {
						const e = n.fbt._("Could not fetch settings for {subredditName}", [n.fbt._param("subredditName", d.name)], {
								hk: "2G8rnU"
							}),
							s = Object(i.d)(e, u.b.Error);
						return await t(Object(i.e)(Object.assign(Object.assign({}, s), {
							duration: i.a
						}))), {
							reason: e
						}
					}
					const O = p.body.data.subredditInfoById;
					return await t(b({
						subredditId: e,
						modSettings: O.liveStreamingInfo
					})), {}
				}, h = (e, t) => async (s, n, r) => {
					let {
						gqlContext: a
					} = r;
					await s(y(t, e, a())), s(_(t))
				}, y = (e, t, s) => async (s, r, a) => {
					let {
						gqlContext: o
					} = a;
					s(f({
						subredditId: e
					}));
					const l = await ((e, t) => Object(c.a)(e, Object.assign(Object.assign({}, d), {
						variables: t
					})))(o(), {
						input: {
							subredditId: e,
							liveStreamingModeratorSettings: t
						}
					});
					if (!l.ok || !l.body.data.updateSubredditLiveStreamingModeratorSettings.ok) {
						const t = l.error && l.error.fields ? l.error.fields[0].msg : n.fbt._("Could not update community broadcasting settings", null, {
								hk: "3Uw7zu"
							}),
							r = Object(i.d)(t, u.b.Error);
						await s(Object(i.e)(Object.assign(Object.assign({}, r), {
							duration: i.a
						}))), s(j({
							subredditId: e
						}))
					}
					const b = n.fbt._("Community broadcasting settings saved", null, {
							hk: "GTwrg"
						}),
						p = Object(i.d)(b, u.b.SuccessCommunity);
					await s(Object(i.e)(Object.assign(Object.assign({}, p), {
						duration: i.a
					}))), s(m({
						subredditId: e
					}))
				}, E = (e, t, s) => async (n, r, a) => {
					let {
						gqlContext: i
					} = a;
					const o = [...s.whitelistedUsers.map(e => ({
						redditorName: e.name
					})), {
						redditorName: t
					}];
					await n(y(e, {
						whitelistedRedditors: o
					}, i())), await n(_(e))
				}, I = (e, t, s) => async (n, r, a) => {
					let {
						gqlContext: i
					} = a;
					const o = s.whitelistedUsers.filter(e => e.name !== t).map(e => ({
						redditorName: e.name
					}));
					await n(y(e, {
						whitelistedRedditors: o
					}, i())), await n(_(e))
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "l", (function() {
				return n
			})), s.d(t, "k", (function() {
				return r
			})), s.d(t, "j", (function() {
				return a
			})), s.d(t, "i", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			})), s.d(t, "n", (function() {
				return g
			})), s.d(t, "m", (function() {
				return f
			}));
			const n = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				a = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				i = "SUBREDDIT__STYLES_PENDING",
				o = "SUBREDDIT__STYLES_LOADED",
				c = "SUBREDDIT__STYLES_FAILED",
				d = "STRUCTURED_STYLES__DRAFT_REPLACED",
				u = "STRUCTURED_STYLES__DRAFT_UPDATED",
				l = "STRUCTURED_STYLES__EDITING_STOPPED",
				b = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				O = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				g = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				f = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "l", (function() {
				return M
			})), s.d(t, "k", (function() {
				return B
			})), s.d(t, "j", (function() {
				return K
			})), s.d(t, "e", (function() {
				return Y
			})), s.d(t, "d", (function() {
				return J
			})), s.d(t, "g", (function() {
				return X
			})), s.d(t, "c", (function() {
				return $
			})), s.d(t, "f", (function() {
				return te
			})), s.d(t, "b", (function() {
				return se
			})), s.d(t, "m", (function() {
				return ne
			})), s.d(t, "a", (function() {
				return re
			})), s.d(t, "h", (function() {
				return ae
			})), s.d(t, "i", (function() {
				return ie
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/omit.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/pick.js"),
				i = s.n(a),
				o = s("./node_modules/react-router-redux/es/index.js"),
				c = s("./src/lib/filterQueryParams/index.ts"),
				d = s("./src/lib/formatApiError/index.ts"),
				u = s("./src/lib/makeActionCreator/index.ts"),
				l = s("./src/reddit/actions/apiRequestState.ts"),
				b = s("./src/reddit/actions/imageUploads.ts"),
				p = s("./src/reddit/actions/modal.ts"),
				O = s("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				g = e => Object.assign(Object.assign(Object.assign(Object.assign({}, e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				}), e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				}), e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				}), e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}),
				f = s("./src/reddit/selectors/postFlair.ts"),
				m = s("./src/reddit/selectors/subreddit.ts"),
				j = s("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const _ = Object(u.a)(j.c),
				h = Object(u.a)(j.b),
				y = Object(u.a)(j.a);
			var E = s("./src/reddit/actions/toaster.ts"),
				I = s("./src/reddit/actions/widgets/index.ts"),
				v = s("./src/reddit/constants/modals.ts"),
				S = s("./src/reddit/helpers/getGenericUploadError.ts"),
				T = s("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				w = s("./src/reddit/helpers/media/index.ts"),
				C = s("./src/reddit/models/Image/index.tsx"),
				A = s("./src/reddit/models/StructuredStyles/index.ts"),
				D = s("./src/reddit/models/Toast/index.ts"),
				P = s("./src/reddit/selectors/activeModalId.ts"),
				R = s("./src/reddit/selectors/platform.ts"),
				k = s("./src/reddit/selectors/structuredStyles.ts"),
				x = s("./src/reddit/selectors/user.ts"),
				N = s("./src/reddit/helpers/trackers/blade.ts"),
				L = s("./src/telemetry/index.ts"),
				U = s("./src/reddit/actions/structuredStyles/constants.ts");
			const M = Object(u.a)(U.m),
				F = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				G = e => {
					const t = Object.assign({}, e);
					return Object.keys(e).forEach(s => {
						F[s] && !e[s] && F[s].forEach(e => t[e] = null)
					}), t
				},
				B = (e, t, s, n) => async (r, a, i) => {
					const {
						apiContext: o
					} = i, c = a(), u = G(t), p = c.structuredStyles.models[e];
					let g;
					for (const e in u)
						if (u[e] !== p[e]) {
							g = !0;
							break
						} if (!g) return;
					r(Object(l.h)(n));
					const f = Object(N.i)(s)(c);
					let j = null,
						_ = null;
					try {
						(j = await Object(b.f)(a(), C.a.StructuredStyles)) && (_ = Object(b.m)(j)(r, a, i))
					} catch (v) {
						const e = Object(S.a)("webSocket");
						return void r(Object(l.f)(n, e))
					}
					const h = Object(m.S)(c, {
							subredditId: e
						}).name,
						y = await O.e(o(), h, u),
						I = {};
					if (y.ok) {
						if (_) try {
							await _
						} catch (v) {}
						const s = Object(k.g)(a(), {
							apiRequestId: n
						});
						for (const e in s)
							if (e in t) {
								const t = Object(k.h)(a(), {
									name: e
								});
								t && Object(C.j)(t) && (I[e] = s[e])
							} Object.keys(I).length && r(z(I)), r(Object(l.e)(n)), r(M({
							subredditId: e,
							styles: Object.assign(Object.assign({}, u), I)
						}))
					} else j && j.websocket.close(), r(Object(l.f)(n, y.error)), y.body && r(E.e({
						kind: D.b.Error,
						text: Object(d.a)(y.error, y.status)
					}));
					Object(L.a)(Object.assign(Object.assign({}, f), {
						actionInfo: Object.assign(Object.assign({}, f.actionInfo), {
							success: y.ok
						})
					}))
				}, q = Object(u.a)(U.l), V = Object(u.a)(U.k), H = Object(u.a)(U.j), K = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					t(q({
						subredditId: e
					}));
					const a = Object(m.S)(s(), {
							subredditId: e
						}).name,
						i = await O.f(r(), a);
					if (i.ok) {
						const n = s().structuredStyles.models[e],
							r = n ? n.mobileKeyColor : null;
						t(V({
							subredditId: e,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else t(H(Object.assign({
						subredditId: e
					}, i.error)))
				}, W = Object(u.a)(U.d), Y = e => async (t, s, n) => {
					const r = s(),
						a = r.structuredStyles.models[e] || {},
						i = Object(x.S)(r);
					t(W({
						isNightmodeOn: i,
						styles: a,
						subredditId: e
					})), ue(e, !1)(t, s, n), (e => async (t, s, n) => {
						let {
							gqlContext: r
						} = n;
						const a = s(),
							i = Object(m.S)(a, {
								subredditId: e
							});
						if (!i) return;
						const o = Object(f.d)(a, {
								subredditId: e
							}),
							c = o && o.templateIds;
						if (!c || !c.length) return;
						t(_({
							subredditId: e
						}));
						const d = await Object(O.a)(r(), i.name, c);
						if (d.ok) {
							const s = {};
							if (d.body) {
								const {
									data: e
								} = d.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) s[t.id] = g(t)
							}
							t(h({
								subredditId: e,
								templates: s
							}))
						} else t(y({
							subredditId: e,
							error: d.error
						}))
					})(e)(t, s, n), Object(I.g)(e, !1)(t, s, n)
				}, z = Object(u.a)(U.c), J = e => async (t, s, n) => {
					const r = G(e),
						a = s();
					for (const e in r)
						if (Object(A.l)(e))
							if (r[e]) {
								if ("string" != typeof r[e]) {
									const a = r[e],
										i = await Object(C.e)(a);
									X(e, i)(t, s, n), r[e] = ""
								}
							} else {
								const s = Object(k.h)(a, {
									name: e
								});
								s && t(Object(b.h)(s))
							} t(z(r))
				}, Q = Object(u.a)(U.f), X = (e, t, s) => async (n, r, a) => {
					const i = r(),
						o = s || i.structuredStyles.isEditing,
						c = Object(m.S)(i, {
							subredditId: o
						}).name;
					n(Q({
						imageKey: e,
						uploadId: t.id
					})), n(Object(b.k)(t));
					const d = await O.d(a.apiContext(), c, t.file.name, e, await Object(w.g)(t.file));
					try {
						const s = await Object(b.g)(r(), d, t, C.a.StructuredStyles);
						if (s) {
							const t = s.url;
							n(Object(b.j)(s)), n(z({
								[e]: t
							}))
						}
					} catch (u) {
						if (u instanceof Error) throw u;
						n(Object(b.i)(u))
					}
				}, Z = Object(u.a)(U.b), $ = (e, t, s) => async (n, a, o) => {
					const c = a(),
						d = c.structuredStyles.models[e] || {},
						u = c.structuredStyles.draft,
						l = Object(N.h)(t)(c);
					if (s) {
						const t = i()(d, s),
							a = r()(u, s),
							o = Object.assign(Object.assign({}, a), t);
						n(Z({
							subredditId: e,
							styles: o
						}))
					} else {
						n(Z({
							subredditId: e,
							styles: d
						}))
					}
					Object(L.a)(l)
				}, ee = Object(u.a)(U.e), te = () => async (e, t, s) => {
					const n = t(),
						r = Object(x.T)(n),
						a = !!Object(R.a)(n);
					if (e(ee({
							nightmodeTempUpdated: r
						})), a) return;
					const {
						url: i
					} = n.platform.currentPage;
					i && e(Object(o.c)(Object(c.a)(i, ["styling", "route"])))
				}, se = Object(u.a)(U.a), ne = Object(u.a)(U.n), re = () => async e => e(te()), ae = e => async (t, s) => {
					const n = s(),
						r = Object(k.j)(n);
					!Object(P.b)(v.a.BLADE_UNSAVED_CHANGES)(n) && r && (Object(k.a)(n, {
						subredditId: e
					}) ? t(Object(p.i)(v.a.BLADE_UNSAVED_CHANGES)) : t(re()))
				}, ie = e => async (t, s) => {
					const n = s();
					Object(k.j)(n) || t(Object(x.S)(n) ? Object(p.i)(v.a.BLADE_NIGHTMODE) : Y(e))
				}, oe = Object(u.a)(U.i), ce = Object(u.a)(U.h), de = Object(u.a)(U.g), ue = (e, t) => async (s, n, r) => {
					let {
						gqlContext: a,
						apiContext: i
					} = r;
					s(oe({
						subredditId: e
					}));
					const o = Object(m.S)(n(), {
						subredditId: e
					});
					if (!o) return;
					if (!t) {
						const n = await O.c(i(), o.name, t);
						if (n.ok) {
							const t = n.body,
								r = t.data ? t.data.style : {};
							s(ce({
								subredditId: e,
								styles: r
							}))
						} else s(de(Object.assign({
							subredditId: e
						}, n.error)));
						return
					}
					const c = await O.b(a(), o.name);
					if (c.ok) {
						let t = {};
						if (c.body) {
							const {
								data: e
							} = c.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(T.a)(e.subreddit.styles))
						}
						s(ce({
							subredditId: e,
							styles: t
						}))
					} else s(de(Object.assign({
						subredditId: e
					}, c.error)))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "m", (function() {
				return H
			})), s.d(t, "l", (function() {
				return K
			})), s.d(t, "k", (function() {
				return W
			})), s.d(t, "j", (function() {
				return Y
			})), s.d(t, "i", (function() {
				return z
			})), s.d(t, "h", (function() {
				return J
			})), s.d(t, "d", (function() {
				return Q
			})), s.d(t, "p", (function() {
				return ee
			})), s.d(t, "o", (function() {
				return re
			})), s.d(t, "r", (function() {
				return oe
			})), s.d(t, "g", (function() {
				return ce
			})), s.d(t, "f", (function() {
				return de
			})), s.d(t, "e", (function() {
				return ue
			})), s.d(t, "q", (function() {
				return Oe
			})), s.d(t, "b", (function() {
				return ge
			})), s.d(t, "c", (function() {
				return fe
			})), s.d(t, "a", (function() {
				return me
			})), s.d(t, "t", (function() {
				return ye
			})), s.d(t, "n", (function() {
				return Ee
			})), s.d(t, "s", (function() {
				return Ie
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/pick.js"),
				a = s.n(r),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/listingSort/index.ts"),
				c = s("./src/lib/makeActionCreator/index.ts"),
				d = s("./src/lib/makeListingKey/index.ts"),
				u = s("./src/reddit/actions/economics/helpers/async.ts"),
				l = s("./src/reddit/actions/modal.ts"),
				b = s("./src/reddit/actions/oldSiteRules.ts"),
				p = s("./src/reddit/actions/pages/subreddit.ts"),
				O = s("./src/reddit/actions/preferences.ts"),
				g = s("./src/reddit/actions/subredditRules/constants.ts"),
				f = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/constants/modals.ts"),
				j = s("./src/reddit/constants/parameters.ts"),
				_ = s("./src/reddit/constants/postLayout.ts"),
				h = s("./src/reddit/contexts/PageLayer/index.tsx"),
				y = s("./src/reddit/endpoints/governance/posts.ts"),
				E = s("./src/lib/makeApiRequest/index.ts"),
				I = s("./src/lib/omitHeaders/index.ts"),
				v = s("./src/reddit/constants/headers.ts"),
				S = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var T = s("./src/reddit/endpoints/modQueue/index.ts"),
				w = s("./src/reddit/endpoints/page/subredditPage.ts"),
				C = s("./src/reddit/endpoints/subreddit/about.ts"),
				A = s("./src/reddit/endpoints/subreddit/rules.ts"),
				D = s("./src/reddit/endpoints/user/preferences.ts"),
				P = s("./src/reddit/helpers/filterListingResponse/index.ts"),
				R = s("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				k = s("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				x = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				N = s("./src/reddit/models/Subreddit/index.ts"),
				L = s("./src/reddit/models/Toast/index.ts"),
				U = s("./src/reddit/models/User/index.ts"),
				M = s("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				F = s("./src/reddit/selectors/oldSiteRules.ts"),
				G = s("./src/reddit/selectors/profile.ts"),
				B = s("./src/reddit/selectors/subreddit.ts"),
				q = s("./src/reddit/selectors/user.ts");
			const V = {},
				H = "SUBREDDIT__MODEL_SUCCEEDED",
				K = "SUBREDDIT__MODEL_PENDING",
				W = "SUBREDDIT__MODEL_FAILED",
				Y = "SUBREDDIT__MORE_POSTS_PENDING",
				z = "SUBREDDIT__MORE_POSTS_LOADED",
				J = "SUBREDDIT__MORE_POSTS_FAILED",
				Q = "SUBREDDIT__META_FILTER_TOGGLED",
				X = Object(c.a)(Y),
				Z = Object(c.a)(z),
				$ = Object(c.a)(J),
				ee = Object(c.a)(Q),
				te = Object(c.a)(g.b),
				se = Object(c.a)(g.c),
				ne = Object(c.a)(g.a),
				re = (e, t) => async (s, n) => {
					await (t === N.e.User ? s(ae(e)) : s(ie(e))), 0 === Object(F.a)(n()).length && s(Object(b.b)())
				}, ae = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = Object(G.m)(s(), e),
						i = await Object(A.c)(r(), e);
					if (i.ok) {
						const e = i.body;
						t(te({
							rules: e,
							subredditId: a
						}))
					}
				}, ie = e => async (t, s, r) => {
					let {
						gqlContext: a
					} = r;
					const i = Object(B.G)(s(), e);
					t(se());
					const o = await Object(A.b)(a(), e);
					if (o.ok) {
						const e = o.body;
						t(te({
							rules: e,
							subredditId: i
						}))
					} else {
						t(ne());
						const s = "error-block-".concat(e);
						t(f.e({
							id: s,
							kind: L.b.Error,
							text: n.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, oe = e => async (t, s, n) => {
					let {
						apiContext: r,
						gqlContext: i
					} = n;
					const {
						subredditName: c
					} = e;
					let l = e.t;
					const b = s(),
						p = Object(R.a)(e, b),
						O = b.platform.currentPage ? b.platform.currentPage.queryParams : {},
						g = Object(d.a)(c, p, Object.assign({
							t: l
						}, O)),
						f = b.listings.postOrder.loadMore[g],
						m = b.listings.postOrder.listingSort[g];
					let E = p;
					if (m && !E) {
						const e = Object(o.d)(m.sort);
						E = e.sort, l = e.timeSort
					}
					const I = b.listings.postOrder.api.pending[g],
						{
							fetchedTokens: v
						} = b.listings.postOrder,
						S = !(!v[g] || !v[g][f.token]);
					if (I || S) return;
					t(X({
						key: g,
						fetchedToken: f.token
					}));
					const T = Object.assign({
						after: f.token,
						dist: f.dist,
						layout: _.e[Object(h.N)(b, {})],
						sort: E,
						t: l
					}, a()(O, [...j.l, j.h]));
					T[j.h] || (T[j.h] = b.user.prefs.geopopular || b.meta.country);
					const C = Object(M.a)(b) ? () => Object(w.b)(i(), Object(w.c)(b, c, Object.assign(Object.assign({}, T), {
							limit: _.a
						})), Object(q.O)(b)) : () => Object(w.a)(r(), c, T),
						A = await C(),
						D = Object.assign(Object.assign({}, A.body), Object(P.a)(b, g, A.body));
					if (A.ok) {
						let e;
						const n = D.postIds.filter(e => !!D.posts[e].isMeta),
							a = Object(B.G)(s(), c);
						if (n.length) {
							const t = await Object(y.a)(r(), a, n);
							t.ok && (e = t.body)
						}
						t(Z(Object.assign({
							fetchedToken: f.token,
							key: g,
							meta: b.meta,
							governance: e
						}, D))), await t(Object(u.a)({
							subredditId: a,
							postIds: D.postIds,
							skip: ["communityDetails", "subscription"]
						}))
					} else t($(Object.assign({
						error: A.error,
						fetchedToken: f.token,
						key: g
					}, D)))
				}, ce = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", de = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", ue = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", le = Object(c.a)(ce), be = Object(c.a)(de), pe = Object(c.a)(ue), Oe = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t();
					if (!r.user.account || r.subreddits.moderated.api.fetched) return;
					e(le());
					const a = await Object(T.b)(n(), i.hb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					a.ok ? e(be(a.body)) : e(pe({
						error: a.error
					}))
				}, ge = "SUBREDDIT__ABOUT_PENDING", fe = "SUBREDDIT__ABOUT_SUCCEEDED", me = "SUBREDDIT__ABOUT_FAILED", je = Object(c.a)(ge), _e = Object(c.a)(fe), he = Object(c.a)(me), ye = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = s();
					if (Object(B.y)(a, {
							subredditName: e
						}) || a.subreddits.api.about.error[e.toLowerCase()] || a.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(je({
						subredditName: e
					}));
					const i = !Object(B.G)(a, e),
						o = await Object(C.a)(r(), e, i);
					if (o.ok) {
						const s = o.body.data.subreddit,
							n = Object(k.a)(s),
							r = i ? Object(x.a)(s) : void 0;
						t(_e({
							subredditName: e,
							subreddits: r ? {
								[r.id]: r
							} : void 0,
							data: n
						}))
					} else t(he({
						subredditName: e,
						error: o.error
					}))
				}, Ee = (e, t, s) => async (n, r, a) => {
					let {
						apiContext: o
					} = a;
					const c = Object(B.G)(r(), e.substring(2)),
						d = Object(q.i)(r());
					if (d) {
						const r = Object(U.e)(d),
							a = t + "\n\n   *To approve this user*, visit [the approved users page for " + e + "](https://www.reddit.com/" + e + "/about/contributors?user=" + r + ') and click "ADD USER".\n    Approving this user gives them permission to ' + s + ". You can change these community restrictions from the [community settings](/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + r + "](/u/" + r + ") or reply to this message to start a conversation.",
							u = {
								to: "/".concat(e),
								subject: "I would like to join ".concat(e),
								text: a
							};
						if ((await ((e, t) => Object(E.a)(Object(I.a)(e, [v.a]), {
								endpoint: Object(S.a)("".concat(e.apiUrl, "/api/compose")),
								method: i.db.POST,
								data: t
							}))(o(), u)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							n(Object(O.E)({
								subredditId: c,
								prefs: t
							})), Object(D.h)(c, t, o()), n(Object(l.i)(m.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, Ie = e => async (t, s) => {
					const n = s(),
						{
							subredditName: r
						} = e,
						a = e.t,
						i = Object(R.a)(e, n),
						o = n.platform.currentPage ? n.platform.currentPage.queryParams : V,
						c = Object(d.a)(r, i, Object.assign({
							t: a
						}, o)),
						u = Object.assign({
							t: a,
							sort: i
						}, o);
					await t(Object(p.i)(c, r, u, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "h", (function() {
				return i
			})), s.d(t, "g", (function() {
				return o
			})), s.d(t, "p", (function() {
				return c
			})), s.d(t, "o", (function() {
				return d
			})), s.d(t, "k", (function() {
				return u
			})), s.d(t, "j", (function() {
				return l
			})), s.d(t, "i", (function() {
				return b
			})), s.d(t, "n", (function() {
				return p
			})), s.d(t, "m", (function() {
				return O
			})), s.d(t, "l", (function() {
				return g
			})), s.d(t, "f", (function() {
				return f
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "r", (function() {
				return _
			})), s.d(t, "q", (function() {
				return h
			})), s.d(t, "s", (function() {
				return y
			}));
			const n = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				a = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				i = "SUBREDDIT__POSTS_LOADED",
				o = "SUBREDDIT__POSTS_SET_FAILED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				d = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				u = "SUBREDDIT__RANKINGS_PENDING",
				l = "SUBREDDIT__RANKINGS_LOADED",
				b = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				O = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				g = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				f = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				m = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				j = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				_ = "SUBREDDIT__EDIT_REQUESTED",
				h = "SUBREDDIT__EDIT_FAILED",
				y = "SUBREDDIT__EDIT_SUCCESS"
		},
		"./src/reddit/actions/subreddit/questions.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			}));
			var n = s("./src/graphql/operations/GetSubredditQuestions.json"),
				r = s("./src/lib/makeGqlRequest/index.ts");
			const a = "SUBREDDIT_QUESTIONS_LOADED",
				i = "SUBREDDIT_SURVEY_ANSWERED",
				o = e => async (t, s, i) => {
					let {
						gqlContext: o
					} = i;
					var c, d, u, l;
					const b = (await ((e, t) => Object(r.a)(e, Object.assign(Object.assign({}, n), {
							variables: t
						})))(o(), {
							id: e
						})).body,
						p = null === (d = null === (c = b.data) || void 0 === c ? void 0 : c.subredditInfoById) || void 0 === d ? void 0 : d.answerableQuestions,
						O = null === (l = null === (u = b.data) || void 0 === u ? void 0 : u.subredditInfoById) || void 0 === l ? void 0 : l.contentRatingSurvey;
					(p || O) && t({
						type: a,
						payload: {
							id: e,
							questions: p,
							survey: O
						}
					})
				}
		},
		"./src/reddit/actions/subreddit/similarSubreddit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			})), s.d(t, "b", (function() {
				return f
			}));
			var n, r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/subreddit/constants.ts"),
				i = s("./src/reddit/endpoints/category/subreddits.ts"),
				o = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts");
			! function(e) {
				e.Factorization = "factorization", e.CustomModRelevant = "custom_mod_relevant"
			}(n || (n = {}));
			var l = s("./src/reddit/selectors/subreddit.ts");
			const b = e => {
					let t = e.subredditIds.join(",");
					return e.count && (t += "--[count:'".concat(e.count, "']")), e.variant && (t += "--[variant:'".concat(e.variant, "']")), t.toLowerCase()
				},
				p = Object(r.a)(a.n),
				O = Object(r.a)(a.m),
				g = Object(r.a)(a.l),
				f = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						f = b(e),
						m = Object(l.v)(a, {
							key: f
						}),
						j = Object(l.u)(a, {
							key: f
						});
					if (m || j.length > 0) return;
					t(p({
						key: f
					}));
					const _ = await ((e, t) => Object(c.a)(Object(d.a)(e, [u.a]), {
						data: {
							sr_fullnames: t.subredditIds.join(","),
							limit: t.count,
							variant: t.variant
						},
						endpoint: "".concat(e.apiUrl, "/api/similar_subreddits.json"),
						method: o.db.GET
					}))(r(), e);
					if (_.ok) {
						const e = Object(i.b)(_.body);
						t(O(Object.assign({
							key: f
						}, e)))
					} else {
						const e = _.error;
						t(g({
							key: f,
							error: e
						}))
					}
				}
		},
		"./src/reddit/actions/subreddit/subredditPosts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return F
			})), s.d(t, "a", (function() {
				return G
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/makeLinkedPostsListingKey/index.ts"),
				i = s("./src/lib/makeListingKey/index.ts"),
				o = s("./src/reddit/actions/linkedPosts/constants.ts");
			const c = Object(r.a)(o.b),
				d = Object(r.a)(o.a);
			var u = s("./src/reddit/actions/otherDiscussions/constants.ts"),
				l = s("./src/lib/makeGqlRequest/index.ts"),
				b = (s("./src/graphql/operations/OtherDiscussions.json"), s("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts")),
				p = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				O = s("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				g = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				f = s("./src/reddit/models/Post/index.ts");
			var m = e => {
				let {
					getState: t,
					onFailure: s,
					onSuccess: n,
					postId: r,
					response: a
				} = e;
				if (!a.ok) return void s(a.error);
				const o = a.body,
					{
						post: c
					} = o && o.data,
					d = t(),
					u = Object(i.a)(r, null, {
						isOtherDiscussions: !0
					});
				if (c) {
					if (c.otherDiscussions && c.otherDiscussionsCount) {
						const {
							otherDiscussions: e,
							otherDiscussionsCount: t
						} = c, {
							postFlair: s,
							postIds: a,
							posts: i,
							profiles: o,
							subreddits: l
						} = (e => {
							const t = {
									postFlair: {},
									postIds: [],
									posts: {},
									profiles: {},
									subreddits: {}
								},
								s = e => {
									const s = Object(p.e)(e);
									t.posts[s.id] = s;
									const {
										crosspostRoot: n
									} = e;
									if (n && n.type === f.a.Post && n.postInfo) {
										const e = Object(p.e)(n.postInfo);
										t.posts[e.id] = e
									}
									switch (e.__typename) {
										case f.f.ProfilePost:
											t.profiles[e.profile.id] || (t.profiles[e.profile.id] = Object(O.a)(e.profile));
											break;
										case f.f.SubredditPost:
											t.subreddits[e.subreddit.id] || (t.subreddits[e.subreddit.id] = Object(g.a)(e.subreddit)), t.postFlair[e.subreddit.id] || (t.postFlair[e.subreddit.id] = Object(b.a)(e.subreddit))
									}
									return s.id
								};
							if (e && e.edges)
								for (const {
										node: n
									} of e.edges) {
									const e = s(n);
									e && t.postIds.push(e)
								}
							return t
						})(e);
						n({
							count: t,
							key: u,
							meta: d.meta,
							postFlair: s,
							postId: r,
							postIds: a,
							posts: i,
							profiles: o,
							subreddits: l
						})
					}
				} else n({
					count: 0,
					key: u,
					meta: d.meta,
					postFlair: {},
					postId: r,
					postIds: [],
					posts: {},
					profiles: {},
					subreddits: {}
				})
			};
			const j = Object(r.a)(u.a),
				_ = Object(r.a)(u.b),
				h = Object(r.a)(u.c);
			var y = s("./src/reddit/actions/subreddit/constants.ts"),
				E = s("./src/graphql/operations/PostFeedAndOtherDiscussions.json"),
				I = (s("./src/graphql/operations/SubredditPosts.json"), s("./src/graphql/operations/SubredditsPosts.json"));
			var v = e => {
				let {
					getState: t,
					onSuccess: s,
					onFailure: n,
					postId: r,
					post: a
				} = e;
				try {
					s({
						altText: a && a.media && (a.media.still && a.media.still.altText || a.media.obfuscated && a.media.obfuscated.altText) || null,
						postId: r
					})
				} catch (i) {
					n(i)
				}
			};
			var S = e => {
					let {
						getState: t,
						onSuccess: s,
						onFailure: n,
						postId: r,
						post: i
					} = e;
					try {
						const e = [],
							n = {},
							o = {};
						if (!i || !i.linked) return;
						const c = t(),
							d = c.posts && c.posts.models,
							u = Object(a.a)(r),
							l = i.linked.posts && i.linked.posts.edges || [];
						for (const {
								node: t
							} of l) {
							if (!t) break;
							if (t.id && !d.hasOwnProperty(t.id) && (e.push(t.id), n[t.id] = Object(p.e)(t)), t.__typename === f.f.SubredditPost && t.subreddit && t.subreddit.id) {
								const {
									subreddit: e
								} = t;
								o[e.id] = Object(g.a)(e)
							}
						}
						s({
							dist: i.linked.posts && i.linked.posts.dist || null,
							key: u,
							meta: c.meta,
							posts: n,
							postIds: e,
							subreddits: o
						})
					} catch (o) {
						n(o)
					}
				},
				T = s("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts");
			var w = e => e.reduce((e, t) => (e[t.id] = t, e), {});
			var C = e => {
					let {
						getState: t,
						onSuccess: s,
						onFailure: r,
						options: a,
						subreddit: o
					} = e;
					try {
						if (!o) return;
						const {
							posts: e
						} = o, r = t(), c = ((e, t) => {
							const {
								edges: s
							} = e, n = s.filter(e => (e => !e.node.crosspostRoot)(e) && ((e, t) => !t.hasOwnProperty(e.node.id))(e, t));
							return Object.assign(Object.assign({}, e), {
								edges: n
							})
						})(e, r.posts && r.posts.models);
						if (!c.edges.length) return;
						const d = Object(T.a)(c),
							{
								range: u,
								sort: l,
								subredditName: b
							} = a,
							p = Object(i.a)(b, n.O[l], {
								t: u
							}),
							O = w(d),
							g = d.map(e => e.id);
						s({
							dist: e.dist,
							key: p,
							meta: r.meta,
							postIds: g,
							posts: O
						})
					} catch (c) {
						r(c)
					}
				},
				A = s("./src/reddit/models/Media/index.ts"),
				D = s("./src/reddit/selectors/posts.ts"),
				P = s("./src/reddit/actions/imageOCRAltText/constants.ts");
			const R = Object(r.a)(P.b),
				k = Object(r.a)(P.a);
			var x = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var r = 0;
					for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
				}
				return s
			};
			const N = Object(r.a)(y.h),
				L = Object(r.a)(y.g),
				U = Object(r.a)(y.p),
				M = Object(r.a)(y.o),
				F = e => async (t, s, n) => {
					let {
						gqlContext: r
					} = n;
					const a = (await ((e, t) => Object(l.a)(e, Object.assign(Object.assign({}, I), {
							variables: t
						})))(r(), e)).body,
						{
							subredditNames: i
						} = e,
						o = x(e, ["subredditNames"]),
						c = [];
					try {
						for (const e of a.data.subredditsInfoByNames) {
							const t = e.posts.edges[0];
							t && t.node.__typename === f.f.SubredditPost && C({
								getState: s,
								onFailure: e => {
									throw e
								},
								onSuccess: e => c.push(e),
								options: Object.assign(Object.assign({}, o), {
									subredditName: t.node.subreddit.name
								}),
								subreddit: e
							})
						}
						t(U(c))
					} catch (d) {
						t(M(d))
					}
				}, G = e => async (t, s, r) => {
					let {
						gqlContext: o
					} = r;
					const {
						includePostImageOCRAltText: u,
						includeListingBelowExperiment: b,
						includeOtherDiscussions: p,
						includePostFeed: O,
						postId: g,
						range: f,
						sort: y,
						subredditName: I
					} = e, T = Object(i.a)(g, null, {
						isOtherDiscussions: !0
					}), w = Object(D.H)(s(), {
						listingKey: T
					}), P = p && (!w || 0 === w.length), x = Object(i.a)(I, n.O[y], {
						t: f
					}), U = Object(D.H)(s(), {
						listingKey: x
					}), M = O && (!U || 0 === U.length), F = Object(a.a)(g), G = Object(D.H)(s(), {
						listingKey: F
					}), B = b && (!G || 0 === G.length), q = Object(D.N)(s(), {
						postId: g
					}), V = u && !!q && !!q.media && (Object(A.I)(q.media) || Object(A.G)(q.media)) && !q.media.altText;
					if (!(P || M || B || V)) return;
					P && t(h({
						key: T
					}));
					const H = await ((e, t) => Object(l.a)(e, Object.assign(Object.assign({}, E), {
							variables: t
						})))(o(), e),
						K = H.body;
					P && m({
						getState: s,
						onFailure: e => t(j(e)),
						onSuccess: e => t(_(e)),
						postId: g,
						response: H
					}), M && (H.ok ? K.data && C({
						getState: s,
						onFailure: e => t(L(e)),
						onSuccess: e => t(N(e)),
						options: e,
						subreddit: K.data.subreddit
					}) : t(L(H.error))), B && H.ok && S({
						getState: s,
						onFailure: e => t(d(e)),
						onSuccess: e => t(c(e)),
						postId: g,
						post: K.data.post
					}), V && H.ok && v({
						getState: s,
						onFailure: e => t(k(e)),
						onSuccess: e => t(R(e)),
						postId: g,
						post: K.data.post
					})
				}
		},
		"./src/reddit/actions/subredditAutocomplete.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "a", (function() {
				return p
			})), s.d(t, "d", (function() {
				return m
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/graphql/operations/SubredditTypeaheadSearch.json"),
				a = s("./src/lib/makeGqlRequest/index.ts"),
				i = (e, t) => Object(a.a)(e, Object.assign(Object.assign({}, r), {
					variables: t
				})),
				o = s("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts"),
				c = e => {
					let {
						allowedPostTypes: t,
						id: s,
						isCrosspostDestination: n,
						isNsfw: r,
						name: a,
						styles: i,
						subscribersCount: c
					} = e;
					return {
						allowedPostTypes: Object(o.a)(t),
						communityIcon: i && i.icon || "",
						icon: i && i.legacyIcon && i.legacyIcon.url || "",
						id: s,
						isCrosspostDestination: n,
						isNsfw: r,
						name: a,
						primaryColor: i && i.primaryColor || "",
						subscribers: c
					}
				},
				d = s("./src/reddit/helpers/name/index.ts"),
				u = s("./src/reddit/selectors/subredditAutocomplete.ts");
			const l = "SUBREDDIT_AUTOCOMPLETE__PENDING",
				b = "SUBREDDIT_AUTOCOMPLETE__LOADED",
				p = "SUBREDDIT_AUTOCOMPLETE__FAILED",
				O = Object(n.a)(l),
				g = Object(n.a)(b),
				f = Object(n.a)(p),
				m = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (s, n, r) => {
						let {
							gqlContext: a
						} = r;
						const o = Object(d.f)(e);
						if (!o) return;
						const l = n(),
							b = l.subredditAutocomplete;
						if (b.api.pending[o] || b.models[o]) return;
						if (Object(u.b)(l, {
								substring: o
							})) return;
						s(O({
							key: o
						}));
						const p = await i(a(), {
							query: o,
							includeNsfw: t
						});
						if (p.ok) {
							const e = p.body.data.subredditTypeahead.subreddits.edges.map(e => c(e.node));
							s(g({
								key: o,
								subreddits: e
							}))
						} else s(f({
							key: o,
							error: p.error
						}))
					}
				}
		},
		"./src/reddit/actions/subredditCreation.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return O
			})), s.d(t, "d", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "a", (function() {
				return m
			})), s.d(t, "e", (function() {
				return y
			})), s.d(t, "f", (function() {
				return E
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/reddit/constants/headers.ts"),
				d = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const u = e => ({
				public_description: e.publicDescription,
				name: e.name,
				type: e.type,
				over_18: e.over18,
				restrict_commenting: e.restrictCommenting,
				restrict_posting: e.restrictPosting,
				existing_tags: e.existingTags.join(","),
				new_tags: e.newTags.join(","),
				primary_tag: e.primaryTagId
			});
			var l = s("./src/reddit/helpers/trackers/subredditCreation.ts"),
				b = s("./src/reddit/selectors/subreddit.ts"),
				p = s("./src/telemetry/index.ts");
			const O = "SUBREDDIT__CREATE_PENDING",
				g = "SUBREDDIT__CREATE_SUCCEEDED",
				f = "SUBREDDIT__CREATE_FAILED",
				m = "SUBREDDIT__CREATE_CLEARED",
				j = Object(r.a)(O),
				_ = Object(r.a)(g),
				h = Object(r.a)(f),
				y = Object(r.a)(m),
				E = e => async (t, s, r) => {
					let {
						apiContext: O
					} = r;
					const g = s(),
						{
							name: f,
							type: m
						} = e;
					if (Object(b.l)(g)) return;
					t(j({
						subredditName: f
					}));
					const y = await ((e, t) => Object(i.a)(Object(o.a)(e, [c.a]), {
						endpoint: Object(d.a)("".concat(e.apiUrl, "/api/v1/subreddit/create_subreddit")),
						method: a.db.POST,
						data: u(t)
					}))(O(), e);
					if (y.ok) {
						const s = y.body,
							r = s.fullname;
						Object(p.a)(Object(l.c)(m, e, r)(g)), t(_({
							subredditName: f
						})), window.location.href = "".concat(n.a.redditUrl).concat(s.path, "new")
					} else y.error && Object(p.a)(Object(l.d)(y.error.type)(g)), t(h({
						subredditName: f,
						error: y.error
					}))
				}
		},
		"./src/reddit/actions/subredditCrosspostable.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "d", (function() {
				return g
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/subscription/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/reddit/constants/headers.ts"),
				d = s("./src/reddit/selectors/subreddit.ts");
			const u = "SUBREDDIT_CROSSPOSTABLE__PENDING",
				l = "SUBREDDIT_CROSSPOSTABLE__LOADED",
				b = "SUBREDDIT_CROSSPOSTABLE__FAILED",
				p = (Object(n.a)(u), Object(n.a)(l)),
				O = Object(n.a)(b),
				g = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					await e(r.e());
					const {
						api: u,
						ids: l
					} = t().subreddits.crosspostable;
					if (u.pending || Object.keys(l).length) return;
					const b = await ((e, t) => Object(i.a)(Object(o.a)(e, [c.a]), {
						data: t,
						endpoint: "".concat(e.apiUrl, "/api/crosspostable_subreddits.json"),
						method: a.db.GET
					}))(n(), {
						sr_detail: !1
					});
					if (b.ok) {
						const s = t(),
							n = b.body && b.body.length ? b.body.map(e => Object(d.G)(s, e)).filter(e => !!e).reduce((e, t) => (e[t] = !0, e), {}) : {};
						e(p({
							subredditIds: n
						}))
					} else e(O({
						error: b.error
					}))
				}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			})), s.d(t, "b", (function() {
				return O
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/config.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/reddit/models/Post/index.ts");
			var c = s("./src/reddit/models/Duplicates/index.ts"),
				d = s("./src/reddit/models/Subreddit/index.ts"),
				u = s("./src/reddit/selectors/profile.ts"),
				l = s("./src/reddit/selectors/subreddit.ts");
			const b = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(n.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(n.a)(b)),
				O = (e, t) => async (s, n, b) => {
					let {
						apiContext: O
					} = b;
					const g = Object(l.S)(n(), {
						subredditId: e
					}) || Object(u.p)(n(), {
						profileId: e
					});
					if (!g) return;
					const f = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(d.g)(g) ? r.Ub + g.name : g.name
						},
						m = await ((e, t, s) => Object(i.a)(e, {
							data: s,
							endpoint: "".concat(a.a.gatewayUrl, "/desktopapi/v1/duplicates/").concat(Object(o.n)(t)),
							method: r.db.GET
						}))(O(), t, f);
					if (m.ok) {
						const n = m.body;
						s(p({
							distinguishKey: Object(c.a)(t, f),
							postIds: n.postIds,
							posts: n.posts,
							profiles: n.profiles,
							subreddits: n.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditMention/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			}));
			const n = "SUBREDDIT_MENTION_LOADED",
				r = "SUBREDDIT__MODEL_SUCCEEDED",
				a = "SUBREDDIT__MODEL_PENDING",
				i = "SUBREDDIT__MODEL_FAILED"
		},
		"./src/reddit/actions/subredditModeration.ts": function(e, t, s) {
			"use strict";
			s.d(t, "J", (function() {
				return P
			})), s.d(t, "H", (function() {
				return R
			})), s.d(t, "G", (function() {
				return k
			})), s.d(t, "ib", (function() {
				return U
			})), s.d(t, "M", (function() {
				return M
			})), s.d(t, "L", (function() {
				return F
			})), s.d(t, "K", (function() {
				return G
			})), s.d(t, "jb", (function() {
				return H
			})), s.d(t, "I", (function() {
				return K
			})), s.d(t, "N", (function() {
				return W
			})), s.d(t, "pb", (function() {
				return J
			})), s.d(t, "hb", (function() {
				return Q
			})), s.d(t, "e", (function() {
				return X
			})), s.d(t, "d", (function() {
				return Z
			})), s.d(t, "c", (function() {
				return $
			})), s.d(t, "V", (function() {
				return ne
			})), s.d(t, "h", (function() {
				return re
			})), s.d(t, "g", (function() {
				return ae
			})), s.d(t, "f", (function() {
				return ie
			})), s.d(t, "W", (function() {
				return ue
			})), s.d(t, "b", (function() {
				return le
			})), s.d(t, "i", (function() {
				return be
			})), s.d(t, "U", (function() {
				return ge
			})), s.d(t, "nb", (function() {
				return fe
			})), s.d(t, "m", (function() {
				return me
			})), s.d(t, "l", (function() {
				return je
			})), s.d(t, "k", (function() {
				return _e
			})), s.d(t, "Z", (function() {
				return Ie
			})), s.d(t, "p", (function() {
				return ve
			})), s.d(t, "o", (function() {
				return Se
			})), s.d(t, "n", (function() {
				return Te
			})), s.d(t, "ab", (function() {
				return De
			})), s.d(t, "j", (function() {
				return Pe
			})), s.d(t, "q", (function() {
				return Re
			})), s.d(t, "Y", (function() {
				return Ne
			})), s.d(t, "ob", (function() {
				return Le
			})), s.d(t, "C", (function() {
				return Ue
			})), s.d(t, "B", (function() {
				return Me
			})), s.d(t, "A", (function() {
				return Fe
			})), s.d(t, "t", (function() {
				return Ve
			})), s.d(t, "s", (function() {
				return He
			})), s.d(t, "r", (function() {
				return Ke
			})), s.d(t, "fb", (function() {
				return Je
			})), s.d(t, "db", (function() {
				return Qe
			})), s.d(t, "x", (function() {
				return Xe
			})), s.d(t, "w", (function() {
				return Ze
			})), s.d(t, "v", (function() {
				return $e
			})), s.d(t, "eb", (function() {
				return nt
			})), s.d(t, "a", (function() {
				return rt
			})), s.d(t, "T", (function() {
				return ct
			})), s.d(t, "Q", (function() {
				return dt
			})), s.d(t, "R", (function() {
				return pt
			})), s.d(t, "mb", (function() {
				return gt
			})), s.d(t, "u", (function() {
				return ft
			})), s.d(t, "cb", (function() {
				return ht
			})), s.d(t, "F", (function() {
				return yt
			})), s.d(t, "E", (function() {
				return Et
			})), s.d(t, "D", (function() {
				return It
			})), s.d(t, "gb", (function() {
				return wt
			})), s.d(t, "y", (function() {
				return Ct
			})), s.d(t, "O", (function() {
				return Dt
			})), s.d(t, "kb", (function() {
				return Pt
			})), s.d(t, "S", (function() {
				return Rt
			})), s.d(t, "z", (function() {
				return kt
			})), s.d(t, "bb", (function() {
				return Nt
			})), s.d(t, "P", (function() {
				return Lt
			})), s.d(t, "lb", (function() {
				return Gt
			})), s.d(t, "X", (function() {
				return Bt
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/get.js"),
				a = s.n(r),
				i = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/apiRequestState.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				d = s("./src/reddit/actions/subreddit.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/constants/modals.ts"),
				b = s("./src/lib/constants/index.ts"),
				p = s("./src/lib/makeApiRequest/index.ts"),
				O = s("./src/lib/omitHeaders/index.ts"),
				g = s("./src/reddit/constants/headers.ts");
			const f = (e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/contributors"),
				method: b.db.GET,
				data: s
			});
			var m = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const j = (e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
					endpoint: Object(m.a)("".concat(e.apiUrl, "/api/v1/").concat(t, "/banned")),
					method: b.db.GET,
					data: s
				}),
				_ = (e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators"),
					method: b.db.GET,
					data: Object.assign(Object.assign({}, s), {
						count: 10
					})
				}),
				h = (e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators_invited"),
					method: b.db.GET,
					data: Object.assign(Object.assign({}, s), {
						count: 50
					})
				}),
				y = (e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/muted"),
					method: b.db.GET,
					data: s
				});
			var E = s("./src/reddit/helpers/normalizeUsername/index.tsx"),
				I = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				v = s("./src/reddit/models/SubredditModeration/index.ts"),
				S = s("./src/reddit/models/Toast/index.ts"),
				T = s("./src/reddit/models/User/index.ts"),
				w = s("./src/reddit/selectors/activeModalId.ts"),
				C = s("./src/reddit/selectors/subreddit.ts"),
				A = s("./src/reddit/selectors/subredditModeration.ts"),
				D = s("./src/reddit/selectors/user.ts");
			const P = "SUBREDDIT__MUTEDUSERS_PENDING",
				R = "SUBREDDIT__MUTEDUSERS_LOADED",
				k = "SUBREDDIT__MUTEDUSERS_FAILED",
				x = Object(i.a)(P),
				N = Object(i.a)(R),
				L = Object(i.a)(k),
				U = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (s, n, r) => {
						let {
							apiContext: a
						} = r;
						const i = n(),
							o = t.after || "",
							c = Object(v.d)(e, o),
							d = i.muted.fetchedTokens[c];
						if (i.muted.api.pending[c] || d) return;
						s(x({
							subredditId: e,
							fetchedToken: o
						}));
						const u = i.subreddits.models[e].name,
							l = await y(a(), u, t);
						l.ok ? s(N(Object.assign(Object.assign({}, l.body), {
							fetchedToken: o
						}))) : s(L({
							subredditId: e,
							fetchedToken: o
						}))
					}
				},
				M = "SUBREDDIT_MUTEDUSERS_SEARCH_PENDING",
				F = "SUBREDDIT_MUTEDUSERS_SEARCH_LOADED",
				G = "SUBREDDIT_MUTEDUSERS_SEARCH_FAILED",
				B = Object(i.a)(M),
				q = Object(i.a)(F),
				V = Object(i.a)(G),
				H = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n().subreddits.models[e].name,
						o = {
							username: Object(E.a)(t)
						};
					s(B());
					const c = await y(a(), i, o);
					c.ok ? s(q(c.body)) : s(V(c.error))
				}, K = "SUBREDDIT_MUTEDUSERS_MUTED_SUCCESS", W = "SUBREDDIT_MUTEDUSERS_UNMUTED_SUCCESS", Y = Object(i.a)(K), z = Object(i.a)(W), J = (e, t) => async (s, r, i) => {
					let {
						apiContext: o
					} = i;
					const c = r().subreddits.models[e].url,
						d = await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: b.db.POST,
							data: {
								api_type: "json",
								id: s,
								type: "muted"
							}
						}))(o(), c, t);
					if (d.ok) s(z({
						subredditId: e,
						userId: t
					}));
					else {
						const e = a()(d, "body.json.errors[0][1]", n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						s(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Q = (e, t, s) => async (r, i, o) => {
					let {
						apiContext: c
					} = o;
					const d = i(),
						l = d.subreddits.models[e].url,
						f = d.subreddits.models[e].name;
					t = Object(E.a)(t);
					const m = await ((e, t, s, n) => Object(p.a)(Object(O.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: b.db.POST,
						data: {
							api_type: "json",
							name: s,
							note: n,
							type: "muted"
						}
					}))(c(), l, t, s);
					if (m.ok) {
						const e = {
							username: t
						};
						r(Object(u.e)({
							kind: S.b.SuccessMod,
							text: n.fbt._("Successfully muted a user", null, {
								hk: "2ypyuL"
							})
						}));
						const s = await y(c(), f, e);
						s.ok && r(Y(s.body))
					} else {
						const e = a()(m, "body.json.errors[0][1]", n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, X = "SUBREDDIT__APPROVEDSUBMITTERS_PENDING", Z = "SUBREDDIT__APPROVEDSUBMITTERS_LOADED", $ = "SUBREDDIT__APPROVEDSUBMITTERS_FAILED", ee = Object(i.a)(X), te = Object(i.a)(Z), se = Object(i.a)($), ne = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (s, n, r) => {
						let {
							apiContext: a
						} = r;
						const i = n(),
							o = t.after || "",
							c = Object(v.d)(e, o),
							d = i.approvedSubmitters.fetchedTokens[c];
						if (i.approvedSubmitters.api.pending[c] || d) return;
						s(ee({
							subredditId: e,
							fetchedToken: o
						}));
						const u = i.subreddits.models[e].name,
							l = await f(a(), u, t);
						l.ok ? s(te(Object.assign(Object.assign({}, l.body), {
							fetchedToken: o
						}))) : s(se({
							subredditId: e,
							fetchedToken: o
						}))
					}
				}, re = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_PENDING", ae = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_LOADED", ie = "SUBREDDIT_APPROVEDSUBMITTERS_SEARCH_FAILED", oe = Object(i.a)(re), ce = Object(i.a)(ae), de = Object(i.a)(ie), ue = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n().subreddits.models[e].name,
						o = {
							username: Object(E.a)(t)
						};
					s(oe());
					const c = await f(a(), i, o);
					c.ok ? s(ce(c.body)) : s(de(c.error))
				}, le = "SUBREDDIT_APPROVEDSUBMITTERS_APPROVED_SUCCESS", be = "SUBREDDIT_APPROVEDSUBMITTERS_UNAPPROVED_SUCCESS", pe = Object(i.a)(le), Oe = Object(i.a)(be), ge = (e, t) => async (s, r, i) => {
					let {
						apiContext: o
					} = i;
					const c = r(),
						d = c.subreddits.models[e].url,
						l = c.subreddits.models[e].name;
					t = Object(E.a)(t);
					const m = await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: b.db.POST,
						data: {
							api_type: "json",
							name: s,
							type: "contributor"
						}
					}))(o(), d, t);
					if (m.ok) {
						const e = {
							username: t
						};
						s(Object(u.e)({
							kind: S.b.SuccessMod,
							text: n.fbt._("Successfully added an approved submitter", null, {
								hk: "4gruK7"
							})
						}));
						const r = await f(o(), l, e);
						r.ok && s(pe(r.body))
					} else {
						const e = a()(m, "body.json.errors[0][1]", n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						s(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, fe = (e, t) => async (s, r, i) => {
					let {
						apiContext: o
					} = i;
					const c = r().subreddits.models[e].url,
						d = await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: b.db.POST,
							data: {
								api_type: "json",
								id: s,
								type: "contributor"
							}
						}))(o(), c, t);
					if (d.ok) s(Oe({
						subredditId: e,
						userId: t
					}));
					else {
						const e = a()(d, "body.json.errors[0][1]", n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						s(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, me = "SUBREDDIT__BANNEDUSERS_PENDING", je = "SUBREDDIT__BANNEDUSERS_LOADED", _e = "SUBREDDIT__BANNEDUSERS_FAILED", he = Object(i.a)(me), ye = Object(i.a)(je), Ee = Object(i.a)(_e), Ie = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (s, n, r) => {
						let {
							apiContext: a
						} = r;
						const i = n(),
							o = t.after || "",
							c = Object(v.d)(e, o),
							d = i.banned.fetchedTokens[c];
						if (i.banned.api.pending[c] || d) return;
						s(he({
							subredditId: e,
							fetchedToken: o
						}));
						const u = i.subreddits.models[e].name,
							l = await j(a(), u, t);
						l.ok ? s(ye(Object.assign(Object.assign({}, l.body), {
							fetchedToken: o
						}))) : s(Ee({
							subredditId: e,
							fetchedToken: o
						}))
					}
				}, ve = "SUBREDDIT_BANNEDUSERS_SEARCH_PENDING", Se = "SUBREDDIT_BANNEDUSERS_SEARCH_LOADED", Te = "SUBREDDIT_BANNEDUSERS_SEARCH_FAILED", we = Object(i.a)(ve), Ce = Object(i.a)(Se), Ae = Object(i.a)(Te), De = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n().subreddits.models[e].name,
						o = {
							username: Object(E.a)(t)
						};
					s(we());
					const c = await j(a(), i, o);
					c.ok ? s(Ce(c.body)) : s(Ae(c.error))
				}, Pe = "SUBREDDIT_BANNEDUSERS_BAN_SUCCESS", Re = "SUBREDDIT_BANNEDUSERS_UNBAN_SUCCESS", ke = Object(i.a)(Pe), xe = Object(i.a)(Re), Ne = (e, t, s) => async (r, i, c) => {
					let {
						apiContext: d
					} = c;
					const l = i(),
						f = l.subreddits.models[e].url,
						m = l.subreddits.models[e].name;
					t.username = Object(E.a)(t.username), r(Object(o.h)(s));
					const _ = await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
						method: b.db.POST,
						data: {
							api_type: "json",
							ban_reason: s.reason,
							ban_message: s.banMessage,
							duration: s.duration,
							name: s.username,
							note: s.modNote,
							ban_context: s.contextId,
							type: "banned"
						}
					}))(d(), f, t);
					if (_.ok) {
						r(Object(o.e)(s));
						const e = {
							username: t.username
						};
						r(Object(u.e)({
							kind: S.b.SuccessMod,
							text: n.fbt._("Successfully banned a user", null, {
								hk: "1kORpS"
							})
						}));
						const a = await j(d(), m, e);
						a.ok && r(ke(a.body))
					} else {
						r(Object(o.f)(s, _.error));
						const e = a()(_, "body.json.errors[0][1]", n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Le = (e, t) => async (s, r, i) => {
					let {
						apiContext: o
					} = i;
					const c = r().subreddits.models[e].url,
						d = await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/unfriend"),
							method: b.db.POST,
							data: {
								api_type: "json",
								id: s,
								type: "banned"
							}
						}))(o(), c, t);
					if (d.ok) s(xe({
						subredditId: e,
						userId: t
					})), s(Object(u.e)({
						kind: S.b.SuccessMod,
						text: n.fbt._("Successfully unbanned a user", null, {
							hk: "OgqK6"
						})
					}));
					else {
						const e = a()(d, "body.json.errors[0][1]", n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						s(Object(u.e)({
							kind: S.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, Ue = "SUBREDDIT__MODERATORS_PENDING", Me = "SUBREDDIT__MODERATORS_LOADED", Fe = "SUBREDDIT__MODERATORS_FAILED", Ge = Object(i.a)(Ue), Be = Object(i.a)(Me), qe = Object(i.a)(Fe), Ve = "SUBREDDIT__EDITABLEMODERATORS_PENDING", He = "SUBREDDIT__EDITABLEMODERATORS_LOADED", Ke = "SUBREDDIT__EDITABLEMODERATORS_FAILED", We = Object(i.a)(Ve), Ye = Object(i.a)(He), ze = Object(i.a)(Ke), Je = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(C.S)(i, {
							subredditId: e
						}).name,
						c = t && t.after ? t.after : "",
						d = t && t.before ? t.before : "",
						u = Object(v.d)(e, c, d),
						l = i.moderators.userOrder.data[u],
						b = i.moderators.userOrder.api.error[u];
					if (i.moderators.userOrder.api.pending[u] || l && !b) return;
					s(Ge({
						subredditId: e,
						key: u
					}));
					const p = await _(a(), o, t);
					if (p.ok) {
						const t = {
							key: u,
							response: p.body,
							subredditId: e
						};
						s(Be(t))
					} else {
						const t = {
							error: p.error,
							subredditId: e,
							key: u
						};
						s(qe(t))
					}
				}, Qe = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(C.S)(i, {
							subredditId: e
						}).name,
						c = t && t.afterEditable ? t.afterEditable : "",
						d = t && t.beforeEditable ? t.beforeEditable : "",
						u = Object(v.d)(e, c, d),
						l = i.moderators.editableUserOrder.data[u],
						f = i.moderators.editableUserOrder.api.error[u];
					if (i.moderators.editableUserOrder.api.pending[u] || l && !f) return;
					s(We({
						subredditId: e,
						key: u
					}));
					const m = Object.assign(Object.assign({}, t), {
							after: c,
							before: d
						}),
						j = await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/moderators_editable"),
							method: b.db.GET,
							data: Object.assign(Object.assign({}, s), {
								count: 10
							})
						}))(a(), o, m);
					if (j.ok) {
						const t = {
							key: u,
							response: j.body,
							subredditId: e
						};
						s(Ye(t))
					} else {
						const t = {
							key: u,
							error: j.error,
							subredditId: e
						};
						s(ze(t))
					}
				}, Xe = "SUBREDDIT__INVITEDMODERATORS_PENDING", Ze = "SUBREDDIT__INVITEDMODERATORS_LOADED", $e = "SUBREDDIT__INVITEDMODERATORS_FAILED", et = Object(i.a)(Xe), tt = Object(i.a)(Ze), st = Object(i.a)($e), nt = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						i = Object(C.S)(a, {
							subredditId: e
						}).name;
					if (a.moderators.invitedModerators.api.pending) return;
					t(et());
					const o = await h(r(), i);
					if (o.ok) {
						const e = o.body;
						t(tt(e))
					} else t(st(o.error))
				}, rt = "SUBREDDIT__ADDMODERATOR__SUCCESS", at = Object(i.a)("SUBREDDIT__ADDMODERATOR_PENDING"), it = Object(i.a)(rt), ot = Object(i.a)("SUBREDDIT__ADDMODERATOR__FAILED"), ct = (e, t, s) => async (r, a, i) => {
					let {
						apiContext: o
					} = i;
					const c = a(),
						d = Object(C.S)(c, {
							subredditId: e
						}),
						l = d.name,
						f = d.url;
					t = Object(E.a)(t), r(at());
					const m = Object(I.d)(s),
						j = await ((e, t, s, n) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/friend"),
							method: b.db.POST,
							data: {
								name: s,
								type: "moderator_invite",
								permissions: n,
								api_type: "json"
							}
						}))(o(), f, t, m);
					if (j.ok) {
						const s = await h(o(), l, {
							username: t
						});
						if (j.ok) {
							const t = s.body,
								a = t.moderatorIds[0];
							c.moderators.invitedModerators.models[e][a] ? r(Object(u.e)({
								kind: S.b.SuccessCommunity,
								text: n.fbt._("That user is already invited", null, {
									hk: "R8YPV"
								})
							})) : (r(Object(u.e)({
								kind: S.b.SuccessMod,
								text: n.fbt._("Successfully added a moderator", null, {
									hk: "2ZdoIZ"
								})
							})), r(it(t)))
						}
					} else {
						const e = j.body.json && j.body.json.errors;
						e && e[0] && e[0][1] && r(Object(u.e)({
							kind: S.b.Error,
							text: e[0][1],
							duration: 3e3
						})), r(ot())
					}
				}, dt = "SUBREDDIT__REMOVEMODERATOR__SUCCESS", ut = Object(i.a)("SUBREDDIT__REMOVEMODERATOR_PENDING"), lt = Object(i.a)(dt), bt = Object(i.a)("SUBREDDIT__REMOVEMODERATOR__FAILED"), pt = "SUBREDDIT__RESIGNMODERATOR__SUCCESS", Ot = Object(i.a)(pt), gt = (e, t, s, n) => async (r, a, i) => {
					let {
						apiContext: o
					} = i;
					const c = a(),
						d = c.subreddits.models[e].name,
						u = Object(v.d)(e, s, n);
					if (r(ut()), (await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl, "/api/unfriend"),
							method: b.db.POST,
							data: {
								id: s,
								type: "moderator",
								r: t,
								api_type: "json"
							}
						}))(o(), d, t)).ok) {
						r(lt({
							subredditId: e,
							userId: t,
							key: u
						}));
						const s = Object(D.i)(c);
						s && s.id === t && r(Ot({
							subredditId: e,
							userId: t
						}))
					} else r(bt())
				}, ft = "SUBREDDIT__EDITMODERATOR__SUCCESS", mt = Object(i.a)("SUBREDDIT__EDITMODERATOR_PENDING"), jt = Object(i.a)(ft), _t = Object(i.a)("SUBREDDIT__EDITMODERATOR__FAILED"), ht = (e, t, s, n) => async (r, a, i) => {
					let {
						apiContext: o
					} = i;
					const c = a().subreddits.models[e].url;
					r(mt());
					const d = Object(I.d)(s);
					if ((await ((e, t, s, n) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/setpermissions"),
							method: b.db.POST,
							data: {
								name: s,
								type: "moderator",
								permissions: n,
								api_type: "json"
							}
						}))(o(), c, t, d)).ok) {
						r(jt({
							permissions: s,
							subredditId: e,
							userId: n
						}))
					} else r(_t())
				}, yt = "SUBREDDIT_MODERATORS_SEARCH_PENDING", Et = "SUBREDDIT_MODERATORS_SEARCH_LOADED", It = "SUBREDDIT_MODERATORS_SEARCH_FAILED", vt = Object(i.a)(yt), St = Object(i.a)(Et), Tt = Object(i.a)(It), wt = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n().subreddits.models[e].name,
						o = {
							username: Object(E.a)(t)
						};
					s(vt());
					const c = await _(a(), i, o);
					c.ok ? s(St(c.body)) : s(Tt(c.error))
				}, Ct = "SUBREDDIT_MODERATORS_ACCEPT_INVITE_SUCCESS", At = Object(i.a)(Ct), Dt = "SUBREDDIT_NEWMODERATORPERMISSIONS_LOADED", Pt = Object(i.a)(Dt), Rt = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s(),
						i = a.user.account;
					if (!i) return;
					const o = a.subreddits.models[e],
						c = o.url,
						d = o.name;
					if ((await ((e, t) => Object(p.a)(Object(O.a)(e, [g.a]), {
							endpoint: "".concat(e.apiUrl).concat(t, "api/accept_moderator_invite"),
							method: b.db.POST,
							data: {
								api_type: "json"
							}
						}))(r(), c)).ok) {
						t(At({
							subredditId: e
						})), t(Qe(e)), t(nt(e)), t(Je(e));
						const s = {
								username: Object(T.e)(i)
							},
							n = await _(r(), d, s);
						if (n.ok) {
							const s = n.body.moderators[i.id];
							s && t(Pt({
								[e]: s.modPermissions
							}))
						}
					}
				}, kt = "SUBREDDIT_MODERATORS_DECLINE_INVITE_SUCCESS", xt = Object(i.a)(kt), Nt = e => async (t, s, n) => {
					let {
						apiContext: r
					} = n;
					const a = s().subreddits.models[e].name;
					(await ((e, t) => Object(p.a)(Object(O.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/decline_mod_invite"),
						method: b.db.POST,
						data: {
							api_type: "json"
						}
					}))(r(), a)).ok && t(xt({
						subredditId: e
					}))
				}, Lt = "SUBREDDIT__REMOVEINVITEDMODERATOR__SUCCESS", Ut = Object(i.a)("SUBREDDIT__REMOVEINVITEDMODERATOR_PENDING"), Mt = Object(i.a)(Lt), Ft = Object(i.a)("SUBREDDIT__REMOVEINVITEDMODERATOR__FAILED"), Gt = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(C.S)(i, {
							subredditId: e
						}).name;
					s(Ut()), (await ((e, t, s) => Object(p.a)(Object(O.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/unfriend"),
						method: b.db.POST,
						data: {
							id: s,
							type: "moderator_invite",
							r: t,
							api_type: "json"
						}
					}))(a(), o, t)).ok ? s(Mt({
						subredditId: e,
						userId: t
					})) : s(Ft())
				}, Bt = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n();
					await Promise.all([(async () => {
						if (!Object(w.b)(l.a.BAN_USER)(i) && !Object(C.P)(i, {
								subredditId: e
							})) {
							const t = Object(C.S)(i, {
								subredditId: e
							});
							await s(Object(d.o)(t.name))
						}
					})(), (async () => {
						const n = Object(D.gb)(i, {
							userName: t
						});
						if (!n) return;
						const r = Object(A.m)(i, {
							subredditId: e
						});
						r && r[n.id] || await s(Ie(e, {
							username: t
						}))
					})()]), s(Object(c.i)(l.a.BAN_USER))
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			}));
			const n = "SUBREDDIT__RULES_LOADED",
				r = "SUBREDDIT__RULES_PENDING",
				a = "SUBREDDIT__RULES_FAILED",
				i = "SUBREDDIT__RULE_ADDED",
				o = "SUBREDDIT__RULE_EDITED",
				c = "SUBREDDIT__RULE_REMOVED",
				d = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return w
			})), s.d(t, "a", (function() {
				return A
			})), s.d(t, "b", (function() {
				return P
			})), s.d(t, "h", (function() {
				return k
			})), s.d(t, "g", (function() {
				return x
			})), s.d(t, "e", (function() {
				return N
			})), s.d(t, "f", (function() {
				return L
			})), s.d(t, "d", (function() {
				return U
			})), s.d(t, "j", (function() {
				return B
			})), s.d(t, "i", (function() {
				return q
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/invert.js"),
				a = s.n(r),
				i = s("./node_modules/lodash/pick.js"),
				o = s.n(i),
				c = s("./node_modules/lodash/xor.js"),
				d = s.n(c),
				u = s("./src/lib/constants/index.ts"),
				l = s("./src/lib/makeActionCreator/index.ts"),
				b = s("./src/reddit/endpoints/subreddit/settings.ts"),
				p = s("./src/telemetry/index.ts"),
				O = s("./src/reddit/actions/toaster.ts"),
				g = s("./src/graphql/operations/FetchSubredditsNotificationSettings.json"),
				f = s("./src/graphql/operations/UpdateSubredditNotificationSettings.json"),
				m = s("./src/lib/makeGqlRequest/index.ts");
			const j = (e, t, s) => Object(m.a)(e, Object.assign(Object.assign({}, f), {
				variables: {
					input: Object.assign(Object.assign({}, s), {
						subredditId: t
					})
				}
			}));
			var _ = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				h = s("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				y = s("./src/reddit/models/Toast/index.ts"),
				E = s("./src/reddit/models/User/index.ts"),
				I = s("./src/reddit/selectors/subreddit.ts"),
				v = s("./src/reddit/selectors/subredditSettings.ts"),
				S = s("./src/reddit/selectors/user.ts"),
				T = s("./src/reddit/selectors/widgets.ts");
			const w = "SUBREDDIT_SETTINGS_LOADED",
				C = Object(l.a)(w),
				A = "SUBREDDIT_NOTIFICATION_SETTINGS_LOADED",
				D = Object(l.a)(A),
				P = "SUBREDDIT_NOTIFICATION_SETTINGS_UPDATED",
				R = Object(l.a)(P),
				k = (e, t) => async (s, n, r) => {
					let {
						apiContext: a,
						gqlContext: i
					} = r;
					if (!t || !Object(I.U)(n(), t)) {
						const t = await Object(b.c)(a(), e);
						t && t.ok && s(C(t.body))
					}
					if (t && !Object(v.b)(n(), {
							subredditId: t
						})) {
						const e = await ((e, t) => Object(m.a)(e, Object.assign(Object.assign({}, g), {
							variables: {
								subredditIds: [t]
							}
						})))(i(), t);
						if (e && e.ok) {
							const t = e.body,
								n = Object(_.e)(t.data);
							s(D(n))
						}
					}
				}, x = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = Object(S.i)(t());
					r && await e(k(u.Ub + Object(E.e)(r)))
				}, N = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", L = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", U = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", M = Object(l.a)(N), F = Object(l.a)(L), G = Object(l.a)(U), B = function e(t, s) {
					let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
						i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (c, u, l) => {
						let {
							apiContext: g,
							gqlContext: f
						} = l;
						c(M());
						const m = u(),
							_ = o()(Object(I.U)(m, t), ...Object.keys(s)),
							E = o()(Object(v.b)(m, {
								subredditId: t
							}), ...Object.keys(r)),
							S = await Object(b.g)(g(), t, s),
							w = Object.keys(r).length > 0;
						let C = !0;
						if (w) {
							C = (await j(f(), t, r)).ok
						}
						if (!S.ok || w && !C) c(G()), c(Object(O.e)({
							kind: y.b.Error,
							text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: e(t, s, E)
						})), i && Object(p.a)(Object(h.c)(m, "BE returned an error:"));
						else {
							const o = Object(b.d)(S.body, a()(b.a));
							c(F({
								settings: Object.assign(Object.assign({}, o), {
									subredditId: t
								}),
								idCardWidgetId: Object(T.c)(m, {
									subredditId: t
								})
							})), w && c(R({
								notificationSettings: r,
								subredditId: t
							}));
							const u = {};
							i && 0 === d()(Object.keys(s), Object.keys(_)).length && (u.buttonText = n.fbt._("Undo", null, {
								hk: "1Gskii"
							}), u.buttonAction = e(t, _, E, i)), c(Object(O.e)(Object.assign({
								kind: y.b.SuccessCommunity,
								text: n.fbt._("Subreddit settings updated successfully", null, {
									hk: "2fmdlZ"
								})
							}, u)))
						}
					}
				}, q = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					(await Object(b.e)(i(), e, t)).ok ? s(Object(O.e)({
						kind: y.b.SuccessCommunity,
						text: n.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : s(Object(O.e)({
						kind: y.b.Error,
						text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/subredditTopContent.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "d", (function() {
				return O
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/preferences.ts"),
				a = s("./src/graphql/operations/SubredditTopContent.json"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				o = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			const c = "SUBREDDIT_TOP_CONTENT__PENDING",
				d = "SUBREDDIT_TOP_CONTENT__LOADED",
				u = "SUBREDDIT_TOP_CONTENT__FAILED",
				l = Object(n.a)(c),
				b = Object(n.a)(d),
				p = Object(n.a)(u),
				O = e => async (t, s, n) => {
					const c = e.toLowerCase(),
						d = s(),
						{
							api: u,
							topContent: O
						} = d.subreddits;
					if (u.topContent.pending[c] || O[c]) return;
					t(l({
						subredditName: c
					})), t(Object(r.z)());
					const g = await ((e, t) => Object(i.a)(e, Object.assign(Object.assign({}, a), {
						variables: t
					})))(n.gqlContext(), {
						subredditName: c
					});
					if (g.ok) {
						const e = g.body.data.subreddit;
						if (e) {
							const s = Object(o.c)(e);
							s && t(b(Object.assign(Object.assign({}, s), {
								subredditName: c
							})))
						}
					} else t(p({
						subredditName: c,
						error: g.error
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "h", (function() {
				return i
			})), s.d(t, "i", (function() {
				return o
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			}));
			const n = "SUBSCRIPTION__FETCH_DATA_PENDING",
				r = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				a = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				i = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				o = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				c = "SUBSCRIPTION__ORDER_LOADED",
				d = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return k
			})), s.d(t, "d", (function() {
				return x
			})), s.d(t, "c", (function() {
				return L
			})), s.d(t, "a", (function() {
				return M
			})), s.d(t, "b", (function() {
				return G
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/lib/linkMatchers/customLinks.ts"),
				o = s("./src/reddit/actions/login.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				d = s("./src/reddit/actions/subscription/constants.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/constants/posts.ts"),
				b = s("./src/lib/makeApiRequest/index.ts"),
				p = s("./src/lib/omitHeaders/index.ts"),
				O = s("./src/reddit/constants/headers.ts");
			var g = s("./src/graphql/operations/SubscribedSubreddits.json"),
				f = s("./src/lib/makeGqlRequest/index.ts"),
				m = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var j = s("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				_ = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				h = s("./src/reddit/models/GqlTopLevelField.ts"),
				y = s("./src/reddit/models/User/index.ts");

			function E(e) {
				const t = [],
					s = [],
					n = {},
					r = {},
					{
						followedRedditorsInfo: a
					} = e.identity;
				for (const o of a.edges) {
					if (o.node.__typename !== y.c.AvailableRedditor) continue;
					const e = Object(j.a)(o.node.profile);
					n[e.id] = e;
					const {
						isFavorite: s
					} = o.node.profile;
					s && t.push(e.id)
				}
				const {
					subscribedSubreddits: i
				} = e.identity;
				for (const o of i.edges) {
					if (o.node.__typename !== h.a.Subreddit) continue;
					const e = Object(_.a)(o.node);
					r[e.id] = e;
					const {
						isFavorite: t
					} = o.node;
					t && s.push(e.id)
				}
				return {
					favoriteProfileIds: t,
					favoriteSubredditIds: s,
					profiles: n,
					subreddits: r
				}
			}
			var I = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/selectors/profile.ts"),
				S = s("./src/reddit/selectors/subreddit.ts"),
				T = s("./src/reddit/selectors/subscriptions.ts"),
				w = s("./src/reddit/selectors/user.ts");
			const C = () => n.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				A = Object(a.a)(d.c),
				D = Object(a.a)(d.b),
				P = Object(a.a)(d.a),
				R = Object(a.a)(d.h),
				k = (Object(a.a)(d.i), Object(a.a)(d.g), () => async (e, t, s) => {
					let {
						gqlContext: n
					} = s;
					const r = t();
					if (!r.user.account || r.subscriptions.api.fetched) return;
					e(D());
					const a = await (e => Object(f.a)(e, g))(n());
					if (a.ok) {
						const t = E(a.body.data);
						e(A(t))
					} else e(P({
						error: a.error
					}))
				}),
				x = (e, t, s) => async (a, d, g) => {
					let {
						apiContext: f
					} = g;
					const j = e.map(e => e.type === l.a.SUBREDDIT ? {
						id: Object(S.G)(d(), e.name),
						name: e.name,
						type: e.type
					} : {
						id: Object(v.m)(d(), e.name),
						name: "".concat(r.Ub).concat(e.name),
						type: e.type
					});
					if (!Object(w.H)(d())) return a(Object(c.k)({
						actionSource: c.a.Subscribe
					})), void a(Object(o.i)());
					if (a(R({
							identifiers: j,
							nameIdentifiers: e,
							profileModels: d().profiles.models,
							subredditModels: d().subreddits.models,
							subscriptionsCount: Object(T.b)(d()),
							userIsSubscriber: t,
							widgetId: s
						})), (await ((e, t) => {
							let {
								subredditIds: s,
								subredditNames: n,
								subscribe: a
							} = t;
							return Object(b.a)(Object(p.a)(e, [O.a]), {
								method: r.db.POST,
								endpoint: Object(m.a)("".concat(e.apiUrl, "/api/subscribe")),
								data: {
									action: a ? "sub" : "unsub",
									sr: s && s.join(",") || void 0,
									sr_name: n && n.join(",") || void 0,
									api_type: "json"
								}
							})
						})(f(), {
							subredditNames: j.map(e => {
								let {
									name: t
								} = e;
								return t
							}),
							subscribe: t
						})).ok) {
						const s = 1 === e.length ? "".concat("subreddit" === e[0].type ? i.d.subreddit : i.d.profile).concat(e[0].name) : "".concat(n.fbt.plural("community", e.length, {
							many: "communities",
							name: "communities",
							showCount: "yes"
						}));
						a(Object(u.e)({
							text: 1 === e.length && "profile" === e[0].type ? n.fbt._("Sucсessfully {verb} {communityname}", [n.fbt._param("verb", t ? "followed" : "unfollowed"), n.fbt._param("communityname", s)], {
								hk: "1hY5KX"
							}) : n.fbt._("Sucсessfully {verb} {communityname}", [n.fbt._param("verb", t ? "joined" : "left"), n.fbt._param("communityname", s)], {
								hk: "1hY5KX"
							})
						}))
					} else {
						a(R({
							identifiers: j,
							nameIdentifiers: e,
							profileModels: d().profiles.models,
							subredditModels: d().subreddits.models,
							subscriptionsCount: Object(T.b)(d()),
							userIsSubscriber: !t,
							widgetId: s
						}));
						const r = n.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						a(Object(u.e)(Object(u.d)(r, I.b.Error)))
					}
				}, N = Object(a.a)(d.f), L = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const i = s(),
						o = Object(S.M)(i, {
							identifier: e
						});
					if (!o) throw new Error("actions.subscription -- No subreddit or profile found with id ".concat(e.id));
					const c = e.type === l.a.SUBREDDIT ? o.name : "u_".concat(o.name),
						d = i.subscriptions.favoriteSubredditOrder || [],
						g = i.subscriptions.favoriteProfileOrder || [],
						f = d.indexOf(e.id),
						m = g.indexOf(e.id),
						j = -1 === f && -1 === m,
						_ = i.subreddits.models,
						h = i.profiles.models;
					t(N({
						makeFavorite: j,
						identifier: e,
						subredditModels: _,
						profileModels: h
					}));
					const y = {
							type: e.type,
							name: o.name
						},
						E = () => Object(S.fb)(s(), {
							identifier: y
						});
					(E() || (await t(x([y], !0)), E())) && ((await ((e, t, s) => Object(b.a)(Object(p.a)(e, [O.a]), {
						method: r.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/favorite"),
						data: {
							make_favorite: s ? "true" : "false",
							sr_name: t,
							api_type: "json"
						}
					}))(a(), c, j)).ok || (t(N({
						makeFavorite: !j,
						identifier: e,
						subredditModels: _,
						profileModels: h
					})), t(Object(u.e)({
						text: C(),
						kind: I.b.Error
					}))))
				}, U = Object(a.a)(d.d), M = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const i = s().multireddits.models,
						o = () => {
							t(Object(u.e)({
								text: C(),
								kind: I.b.Error
							}))
						},
						c = i[e];
					if (!c) return void o();
					const d = !c.isFavorited;
					t(U({
						makeFavorite: d,
						multiredditPath: e,
						multiredditsModelsState: i
					})), (await ((e, t, s) => Object(b.a)(Object(p.a)(e, [O.a]), {
						method: r.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/multi/favorite"),
						data: {
							make_favorite: s ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(a(), e, d)).ok || (t(U({
						makeFavorite: !d,
						multiredditPath: e,
						multiredditsModelsState: i
					})), o())
				}, F = Object(a.a)(d.e), G = e => async (t, s, a) => {
					let {
						apiContext: i
					} = a;
					const o = s(),
						c = o.multireddits.models;
					if (!Object(w.H)(o)) return;
					const d = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(u.e)({
								text: n.fbt._("Sorry, failed to {followAction}", [n.fbt._param("followAction", e ? n.fbt._("follow", null, {
									hk: "2I4uia"
								}) : n.fbt._("unfollow", null, {
									hk: "1ZDqgR"
								}))], {
									hk: "1ufRSl"
								}),
								kind: I.b.Error
							}))
						},
						l = c[e];
					if (!l) return void d();
					const g = !l.isFollowed;
					t(F({
						follow: g,
						multiredditPath: e,
						multiredditsModelsState: c
					})), (await ((e, t, s) => Object(b.a)(Object(p.a)(e, [O.a]), {
						method: r.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/multi/subscribe"),
						data: {
							action: s ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(i(), e, g)).ok || (t(F({
						follow: !g,
						multiredditPath: e,
						multiredditsModelsState: c
					})), d(g))
				}
		},
		"./src/reddit/actions/tabBadging.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "c", (function() {
				return m
			}));
			var n = s("./src/lib/fastdom/index.ts"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/chat/unreadCount.ts"),
				i = s("./src/reddit/actions/inbox.ts"),
				o = s("./src/reddit/contexts/PageLayer/selectors.ts"),
				c = s("./src/reddit/helpers/tabBadging/index.ts"),
				d = s("./src/reddit/selectors/chat.ts"),
				u = s("./src/reddit/selectors/user.ts");
			const l = "TAB__UPDATE_HAS_UNREAD_MESSAGES_BADGE",
				b = Object(r.a)(l),
				p = e => async (t, s) => {
					const n = s(),
						r = Object(d.a)(n),
						o = Object(d.d)(n),
						c = Object(u.C)(n),
						{
							basicChannelCount: l,
							inboxCount: b
						} = e;
					r !== l && t(Object(a.b)(Object.assign(Object.assign({}, o), {
						basicChannelCount: l
					}))), b && b !== c && t(Object(i.b)({
						inboxCount: b
					})), (r !== l || b && b !== c) && t(f())
				}, O = (e, t) => {
					e <= 0 ? n.a.write(() => {
						Object(c.b)(!1), window.document.title = t
					}) : n.a.write(() => {
						Object(c.b)(), window.document.title = "(".concat(e, ") ").concat(t)
					})
				}, g = e => {
					return {
						inboxCount: Object(u.C)(e) || 0,
						basicChannelCount: Object(d.a)(e) || 0
					}
				}, f = () => async (e, t) => {
					const s = t(),
						n = Object(o.e)(s, {});
					if (!(Object(u.G)(s) || Object(u.H)(s)) || !n) return;
					const r = (e => {
						const {
							inboxCount: t,
							basicChannelCount: s
						} = g(e);
						return t + s
					})(s);
					O(r, n), e(b({
						hasUnreadMessages: !!r
					}))
				}, m = () => async (e, t) => {
					{
						e(f());
						const s = g(t());
						Object(c.c)(s)
					}
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "t", (function() {
				return n
			})), s.d(t, "j", (function() {
				return r
			})), s.d(t, "r", (function() {
				return a
			})), s.d(t, "q", (function() {
				return i
			})), s.d(t, "s", (function() {
				return o
			})), s.d(t, "l", (function() {
				return c
			})), s.d(t, "m", (function() {
				return d
			})), s.d(t, "k", (function() {
				return u
			})), s.d(t, "o", (function() {
				return l
			})), s.d(t, "p", (function() {
				return b
			})), s.d(t, "n", (function() {
				return p
			})), s.d(t, "v", (function() {
				return O
			})), s.d(t, "w", (function() {
				return g
			})), s.d(t, "u", (function() {
				return f
			})), s.d(t, "g", (function() {
				return m
			})), s.d(t, "h", (function() {
				return j
			})), s.d(t, "f", (function() {
				return _
			})), s.d(t, "A", (function() {
				return h
			})), s.d(t, "z", (function() {
				return y
			})), s.d(t, "D", (function() {
				return E
			})), s.d(t, "y", (function() {
				return I
			})), s.d(t, "C", (function() {
				return v
			})), s.d(t, "x", (function() {
				return S
			})), s.d(t, "B", (function() {
				return T
			})), s.d(t, "e", (function() {
				return w
			})), s.d(t, "b", (function() {
				return C
			})), s.d(t, "d", (function() {
				return A
			})), s.d(t, "c", (function() {
				return D
			})), s.d(t, "a", (function() {
				return P
			})), s.d(t, "i", (function() {
				return R
			}));
			const n = "TAGS__REQUESTED",
				r = "TAGS__AVAILABLE_LOADED",
				a = "TAGS__LOADED",
				i = "TAGS__FAILURE",
				o = "TAGS__RELEVANCE_LOADED",
				c = "TAGS__CREATE_REQUESTED",
				d = "TAGS__CREATE_SUCCESS",
				u = "TAGS__CREATE_FAILURE",
				l = "TAGS__DELETE_REQUESTED",
				b = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				O = "TAGS__UPDATE_STATE_REQUESTED",
				g = "TAGS__UPDATE_STATE_SUCCESS",
				f = "TAGS__UPDATE_STATE_FAILURE",
				m = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				j = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				_ = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				h = "TAGS__OPTIONS_CANCELLED",
				y = "TAGS__OPTION_SELECTED",
				E = "TAGS__SUGGESTED_OPTION_SELECTED",
				I = "TAGS__OPTION_DESELECTED",
				v = "TAGS__SUGGESTED_OPTION_DESELECTED",
				S = "TAGS__INPUT_CHANGED",
				T = "TAGS__SUGGESTED_INPUT_CHANGED",
				w = "GLOBAL__TAGS__LOADED",
				C = "CREATION__TAGS_INPUT_CHANGED",
				A = "CREATION__TAGS_OPTION_SELECTED",
				D = "CREATION__TAGS_OPTION_DESELECTED",
				P = "CREATION__PRIMARY_TAG_SELECTED",
				R = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "n", (function() {
				return M
			})), s.d(t, "q", (function() {
				return F
			})), s.d(t, "m", (function() {
				return G
			})), s.d(t, "p", (function() {
				return B
			})), s.d(t, "l", (function() {
				return q
			})), s.d(t, "o", (function() {
				return V
			})), s.d(t, "c", (function() {
				return H
			})), s.d(t, "b", (function() {
				return K
			})), s.d(t, "a", (function() {
				return W
			})), s.d(t, "d", (function() {
				return Q
			})), s.d(t, "j", (function() {
				return X
			})), s.d(t, "k", (function() {
				return $
			})), s.d(t, "f", (function() {
				return te
			})), s.d(t, "i", (function() {
				return re
			})), s.d(t, "h", (function() {
				return ae
			})), s.d(t, "e", (function() {
				return ie
			})), s.d(t, "r", (function() {
				return oe
			})), s.d(t, "g", (function() {
				return ce
			})), s.d(t, "s", (function() {
				return de
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/tags/constants.ts"),
				i = s("./src/reddit/actions/toaster.ts");
			const o = e => {
				const {
					subredditInfoById: t
				} = e, s = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, t) => {
					let {
						node: s
					} = t;
					return e[s.subreddit && s.subreddit.id || "global"][s.id] = s, e
				}, s);
				const n = {
					[t.id]: {}
				};
				t.secondaryTags && t.secondaryTags.edges.reduce((e, s) => {
					let {
						node: n
					} = s;
					return e[t.id][n.tag.id] = n, e
				}, n);
				const r = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, s) => {
					let {
						node: n
					} = s;
					return e[t.id][n.tag.id] = n, e
				}, r), {
					primaryTag: t.primaryTag,
					globalSubredditTags: s.global,
					subredditScopedTags: {
						[t.id]: s[t.id]
					},
					subredditId: t.id,
					itemTags: n,
					suggestedItemTags: r,
					geoPlace: t.geoPlace
				}
			};
			var c = s("./src/graphql/operations/CreateSubredditTags.json"),
				d = s("./src/lib/makeGqlRequest/index.ts");
			var u = s("./src/graphql/operations/FetchGlobalTags.json"),
				l = s("./src/graphql/operations/FetchSubredditTags.json");
			const b = 1050,
				p = (e, t) => {
					let {
						subredditId: s,
						pageSize: n = b,
						after: r,
						includeAvailableTags: a
					} = t;
					return Object(d.a)(e, Object.assign(Object.assign({}, l), {
						variables: {
							subredditId: s,
							pageSize: n,
							after: r,
							includeAvailableTags: a
						}
					}))
				};
			var O = s("./src/graphql/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			const g = (e, t) => Object(d.a)(e, Object.assign(Object.assign({}, O), {
				variables: Object.assign(Object.assign({}, t), {
					deleteTags: 0 !== t.deleteTagsInput.length,
					pageSize: b
				})
			}));
			var f = s("./src/graphql/operations/UpdateSubredditTagStatesRelevance.json");
			const m = (e, t) => Object(d.a)(e, Object.assign(Object.assign({}, f), {
				variables: t
			}));
			var j = s("./src/graphql/operations/UpdateSubredditPrimaryTag.json");
			const _ = e => {
					const {
						secondaryTags: t,
						id: s,
						primaryTag: n
					} = e.updateSubredditTagStates.subreddit, r = t && t.edges || [];
					return {
						subredditId: s,
						primaryTagId: n && n.tag.id || null,
						secondaryTags: r.reduce((e, t) => {
							let {
								node: s
							} = t;
							return e[s.tag.id] = s, e
						}, {})
					}
				},
				h = (e, t) => Object(d.a)(e, Object.assign(Object.assign({}, j), {
					variables: t
				}));
			var y = s("./src/reddit/helpers/tags/index.ts"),
				E = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				I = s("./src/reddit/models/Tags/index.ts"),
				v = s("./src/reddit/models/Toast/index.ts"),
				S = s("./src/reddit/reducers/tags/selected/index.ts"),
				T = s("./src/reddit/selectors/tags.ts");
			const w = Object(r.a)(a.e),
				C = Object(r.a)(a.t),
				A = Object(r.a)(a.r),
				D = Object(r.a)(a.s),
				P = Object(r.a)(a.q),
				R = Object(r.a)(a.l),
				k = Object(r.a)(a.m),
				x = Object(r.a)(a.k),
				N = Object(r.a)(a.v),
				L = Object(r.a)(a.w),
				U = Object(r.a)(a.u),
				M = Object(r.a)(a.z),
				F = Object(r.a)(a.D),
				G = Object(r.a)(a.y),
				B = Object(r.a)(a.C),
				q = Object(r.a)(a.x),
				V = Object(r.a)(a.B),
				H = Object(r.a)(a.d),
				K = Object(r.a)(a.c),
				W = Object(r.a)(a.b),
				Y = Object(r.a)(a.g),
				z = Object(r.a)(a.h),
				J = Object(r.a)(a.f),
				Q = Object(r.a)(a.a),
				X = Object(r.a)(a.i),
				Z = Object(r.a)(a.A),
				$ = function e(t, s) {
					let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (a, c, d) => {
						let {
							gqlContext: u
						} = d;
						const l = c();
						a(C());
						const b = await p(u(), {
								subredditId: t
							}),
							O = b.body;
						if (b.ok && O.data.subredditInfoById.secondaryTags && O.data.subredditInfoById.availableTags && O.data.subredditInfoById.suggestedTags) a(A(o(O.data))), r && E.h(c(), t, {
							context: s
						});
						else {
							a(P());
							const o = r ? "topics_save" : "topics_load";
							E.g(l, t, o, {
								context: s
							}), a(Object(i.e)(Object(i.d)(n.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
								hk: "2DUkWX"
							}), v.b.Error, n.fbt._("Retry", null, {
								hk: "1c2xrJ"
							}), e(t, s, r))))
						}
					}
				},
				ee = e => async (t, s, r) => {
					let {
						gqlContext: a
					} = r;
					t(C());
					const c = await p(a(), {
						subredditId: e
					});
					if (c.ok) {
						const e = c.body;
						t(D(o(e.data)))
					} else t(P()), t(Object(i.e)(Object(i.d)(n.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), v.b.Error, n.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), D(e))))
				}, te = () => async (e, t, s) => {
					let {
						gqlContext: n
					} = s;
					const r = t();
					if (Object(T.r)(r)) return;
					e(C());
					const a = await ((e, t) => {
						let {
							pageSize: s = b,
							after: n
						} = t;
						return Object(d.a)(e, Object.assign(Object.assign({}, u), {
							variables: {
								pageSize: s,
								after: n
							}
						}))
					})(n(), {});
					if (a.ok) {
						const t = a.body;
						e(w((e => {
							return {
								globalSubredditTags: e.globalTags.edges.reduce((e, t) => (e[t.node.id] = t.node, e), {})
							}
						})(t.data)))
					}
				}, se = (e, t) => async (s, n, r) => {
					let {
						gqlContext: a
					} = r;
					if (!t.length) return null;
					s(R());
					const i = t.map(t => Object.assign({
							subredditId: e
						}, t)),
						o = await ((e, t) => Object(d.a)(e, Object.assign(Object.assign({}, c), {
							variables: t
						})))(a(), {
							input: i
						}),
						u = o.body && o.body.data || null;
					return o.ok && u && u.createSubredditTags && u.createSubredditTags.ok ? (s(k()), u.createSubredditTags.createdTags || []) : (s(x()), null)
				}, ne = function(e, t) {
					let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (n, r, a) => {
						let {
							gqlContext: i
						} = a;
						if (!t.length && !s.length) return;
						n(N());
						const c = r(),
							d = Object(T.d)(c, {
								subredditId: e
							}),
							u = Object(T.s)(c, {
								itemId: e
							}),
							l = Object(T.C)(c, {
								itemId: e
							}),
							b = new Set;
						for (const e of t)
							if (e.state === I.d.NONE && d[e.tagId] && !l[e.tagId]) {
								!!s.find(t => t.state === I.d.TAGGED && t.tagId === e.tagId) || b.add(e.tagId)
							} for (const e of s)
							if (e.state === I.d.NONE && d[e.tagId] && !u[e.tagId]) {
								!!t.find(t => t.state === I.d.TAGGED && t.tagId === e.tagId) || b.add(e.tagId)
							} const p = await g(i(), {
								deleteTagsInput: [...b].map(e => ({
									tagId: e
								})),
								updateTagStatesInput: {
									subredditId: e,
									suggestedTagStates: s,
									tagStates: t
								}
							}),
							O = p.body && p.body.data || null;
						p.ok && O && O.updateSubredditTagStates && O.updateSubredditTagStates.ok && O.updateSubredditTagStates.subreddit ? n(L(o({
							subredditInfoById: O.updateSubredditTagStates.subreddit
						}))) : n(U())
					}
				}, re = function e(t, s) {
					let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (a, o, c) => {
						const d = o(),
							u = Object(T.u)(d, {
								subredditId: t
							}),
							l = Object(T.F)(d, {
								subredditId: t
							});
						let b = u.filter(e => !!e.id && !!e.action).map(e => ({
							tagId: e.id,
							state: e.action === S.a.ADD ? I.d.TAGGED : I.d.NONE
						}));
						if (l.length > 0) {
							const e = await se(t, l)(a, o, c);
							b = b.concat((e || []).map(e => ({
								tagId: e.id,
								state: I.d.TAGGED
							})))
						}
						await ne(t, b)(a, o, c), Object(T.D)(o()) ? a(Object(i.e)(Object(i.d)(n.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
							hk: "2Jbh5V"
						}), v.b.Error, n.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), e(t, s, r)))) : r && a(Object(i.e)(Object(i.d)(n.fbt._("Community topics saved!", null, {
							hk: "3wtajT"
						}), v.b.SuccessCommunity)))
					}
				}, ae = (e, t, s) => async (s, r, a) => {
					const o = {
						state: I.d.TAGGED
					};
					if (Object(y.b)(t)) {
						const n = await se(e, [{
							text: t.displayText,
							type: I.c.CLASSIFICATION
						}])(s, r, a);
						n && 1 === n.length && (o.tagId = n[0].id)
					} else {
						if (!t.id) return void s(Object(i.e)(Object(i.d)(n.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), v.b.Error)));
						o.tagId = t.id
					}(e => !!e.tagId && !!e.state)(o) ? await ne(e, [], [o])(s, r, a): s(Object(i.e)(Object(i.d)(n.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), v.b.Error)))
				}, ie = (e, t, s) => async (n, r, a) => {
					t.id ? await ne(e, [], [{
						state: I.d.NONE,
						tagId: t.id
					}])(n, r, a) : n($(e, s, !1))
				}, oe = function e(t, s, r, a) {
					let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (c, d, u) => {
						let {
							gqlContext: l
						} = u;
						if (!(await m(l(), {
								input: {
									tagStatesRelevance: s,
									suggestedTagStatesRelevance: r
								}
							})).ok) return c(Object(i.e)(Object(i.d)(n.fbt._("Whoops! Unable to update topics relevance status", null, {
							hk: "17akdT"
						}), v.b.Error, n.fbt._("Retry", null, {
							hk: "1wqK2v"
						}), e(t, s, r, a, o)))), void c(ee(t));
						if (o)
							for (const e of r) E.f(d(), e, {
								context: a
							});
						c(Object(i.e)(Object(i.d)(n.fbt._("Successfully updated topics relevance!", null, {
							hk: "3KIYlz"
						}), v.b.SuccessCommunity, n.fbt._("Undo", null, {
							hk: "34apPL"
						}), e(t, s.map(e => Object.assign(Object.assign({}, e), {
							isRelevant: !e.isRelevant
						})), r.map(e => Object.assign(Object.assign({}, e), {
							isRelevant: !e.isRelevant
						})), a, o)))), c(ee(t))
					}
				}, ce = e => async (t, s) => {
					t(Z({
						itemTagsState: {
							[e]: Object(T.s)(s(), {
								itemId: e
							})
						}
					}))
				}, de = function e(t, s) {
					let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (a, o, c) => {
						let {
							gqlContext: d
						} = c;
						a(Y());
						const u = await h(d(), {
								input: {
									subredditId: t,
									primaryTagState: s
								}
							}),
							l = u.body && u.body.data || null;
						u.ok && l && l.updateSubredditTagStates && l.updateSubredditTagStates.ok ? (a(z(_(l))), r && a(Object(i.e)(Object(i.d)(n.fbt._("Successfully updated primary topic!", null, {
							hk: "1NL90v"
						}), v.b.SuccessCommunity)))) : (a(J()), a(Object(i.e)(Object(i.d)(n.fbt._("Whoops! Unable to update primary topic", null, {
							hk: "3ilZqp"
						}), v.b.Error, n.fbt._("Retry", null, {
							hk: "1dRYXW"
						}), e(t, s)))))
					}
				}
		},
		"./src/reddit/actions/theme.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "THEME_CHANGED",
				a = (Object(n.a)(r), "BOOTUP_THEME"),
				i = Object(n.a)(a)
		},
		"./src/reddit/actions/toaster.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "b", (function() {
				return c
			})), s.d(t, "f", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "d", (function() {
				return O
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/models/Toast/index.ts");
			const a = 5e3,
				i = r.b.SuccessCommunity,
				o = "TOAST__DISPLAYED",
				c = "TOAST__DISMISSED",
				d = Object(n.a)(o),
				u = Object(n.a)(c),
				l = e => async (t, s) => {
					const n = b(e);
					t(d(n)), n.duration > 0 && window.setTimeout(() => t(u(n.id)), n.duration)
				}, b = e => Object.assign(Object.assign({}, e), {
					duration: e.duration || p(e.kind),
					id: e.id || Date.now().toString(),
					kind: e.kind || i
				}), p = e => {
					switch (e) {
						case r.b.Error:
							return -1;
						case r.b.Undo:
						case r.b.SuccessLockComment:
						case r.b.SuccessUnlockComment:
							return 1e4;
						case r.b.SuccessCommunity:
						case r.b.SuccessMod:
						default:
							return a
					}
				}, O = (e, t, s, n, r, a) => ({
					text: e,
					kind: t,
					buttonText: s,
					buttonAction: n,
					secondButtonText: r,
					secondButtonAction: a
				})
		},
		"./src/reddit/actions/tooltip.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "j", (function() {
				return p
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "TOOLTIP__DROPDOWN_TOGGLED",
				a = "TOOLTIP__DROPDOWN_SET",
				i = "TOOLTIP__DROPDOWN_UNSET",
				o = "TOOLTIP__DROPDOWN_SET_IF_NONE",
				c = "TOOLTIP__DROPDOWN_UNSET_IF_ACTIVE",
				d = Object(n.a)(a),
				u = Object(n.a)(r),
				l = Object(n.a)(i),
				b = Object(n.a)(o),
				p = Object(n.a)(c)
		},
		"./src/reddit/actions/tracing.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "PARENT_SPAN_RECEIVED",
				a = Object(n.a)(r)
		},
		"./src/reddit/actions/tracking.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			}));
			var n = s("./src/lib/makeActionCreator/index.ts");
			const r = "TRACKING__VIEWPORT_DATA_LOADED",
				a = "TRACKING__VIEWPORT_DATA_UNLOADED",
				i = Object(n.a)(r);
			Object(n.a)(a)
		},
		"./src/reddit/actions/trafficStats/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = "SUBREDDIT__TRAFFIC_STATS_LOADED",
				r = "SUBREDDIT__TRAFFIC_STATS_PENDING",
				a = "SUBREDDIT__TRAFFIC_STATS_FAILED"
		},
		"./src/reddit/actions/trophyCase.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return u
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/graphql/operations/ProfileTrophies.json"),
				a = s("./src/lib/makeGqlRequest/index.ts");
			s("./node_modules/core-js/modules/es6.symbol.js");
			var i = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var r = 0;
					for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
				}
				return s
			};
			const o = "TROPHYCASE__FETCH_SUCCESS",
				c = Object(n.a)(o),
				d = Object(n.a)("TROPHYCASE__FETCH_FAILED"),
				u = (e, t) => async (s, n, o) => {
					let {
						gqlContext: u
					} = o;
					const l = await ((e, t) => Object(a.a)(e, Object.assign(Object.assign({}, r), {
							variables: t
						}), {
							traceRequestName: "get_profile_trophies"
						}))(u(), {
							profileName: e
						}),
						b = l.body.data;
					if (l.ok && b) {
						const n = {},
							r = [];
						b.redditor && b.redditor.trophies && b.redditor.trophies.map(e => {
							const t = (e => {
									var {
										icon40Url: t,
										trophyId: s
									} = e, n = i(e, ["icon40Url", "trophyId"]);
									return Object.assign({
										icon: t,
										id: s
									}, n)
								})(e),
								{
									id: s
								} = t;
							n[s] = t, r.push(s)
						}), s(c({
							profileId: t,
							profileName: e,
							trophies: n,
							trophyIds: r
						}))
					} else s(d({
						profileId: t,
						error: l.error
					}))
				}
		},
		"./src/reddit/actions/unload/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = new Set,
				r = [],
				a = "AD_UNLOAD",
				i = 6e5
		},
		"./src/reddit/actions/upload.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return u
			})), s.d(t, "h", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "f", (function() {
				return m
			})), s.d(t, "m", (function() {
				return h
			})), s.d(t, "k", (function() {
				return w
			})), s.d(t, "l", (function() {
				return A
			})), s.d(t, "i", (function() {
				return D
			})), s.d(t, "j", (function() {
				return P
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/get.js"),
				r = s.n(n),
				a = s("./node_modules/uuid/v4.js"),
				i = s.n(a),
				o = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/lib/uploadToS3/index.ts"),
				d = s("./src/reddit/models/Upload/index.ts");
			const u = "UPLOAD_PENDING",
				l = "UPLOAD_UPLOADING",
				b = "UPLOAD_METADATA_CHANGED",
				p = "UPLOAD_PROGRESS",
				O = "UPLOAD_SUCCESS",
				g = "UPLOAD_FAILED",
				f = "UPLOAD_CANCELED",
				m = "UPLOAD_REMOVED",
				j = Object(o.a)(u),
				_ = Object(o.a)(l),
				h = Object(o.a)(b),
				y = Object(o.a)(p),
				E = Object(o.a)(O),
				I = Object(o.a)(g),
				v = Object(o.a)(f),
				S = Object(o.a)(m),
				T = new Map,
				w = (e, t) => {
					const s = T.get(e) || [];
					s.push(t), T.set(e, s)
				},
				C = (e, t) => {
					const s = T.get(e);
					s && s.forEach(s => s(e, t)), T.delete(e)
				},
				A = function(e, t, s) {
					let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (a, o, u) => {
						let {
							apiContext: l
						} = u;
						const b = t;
						if (o().uploads[b] && Object(d.c)(o().uploads[b])) return;
						const p = i()(),
							O = () => {
								const e = o().uploads[b];
								return !e || e.id !== p || e.status === d.a.CANCELED
							};
						a(j({
							key: b,
							id: p,
							file: e
						}));
						const {
							uploadLease: g,
							error: f
						} = await s(o().uploads[b]);
						if (O()) return;
						if (f || !g) return void a(I({
							key: b,
							error: f
						}));
						let m;
						w(p, () => {
							m && m.abort()
						}), a(_({
							key: b
						}));
						const h = await Object(c.a)(e, g, e => (m = e, n && e.on("progress", e => {
							if (!O() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								a(y({
									key: b,
									progress: t
								}))
							}
						}), e));
						if (m = null, !O())
							if (h.ok) {
								const e = decodeURIComponent(h.body.PostResponse.Location);
								a(E({
									key: b,
									url: e
								}))
							} else {
								const e = r()(h, "body.Error.Message.0"),
									t = Object.assign({
										type: "ERROR"
									}, e ? {
										fields: [{
											field: "0",
											msg: e
										}]
									} : {});
								a(I({
									key: b,
									error: t
								}))
							}
					}
				},
				D = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (s, n) => {
						const r = n().uploads[e];
						r && (C(r.id, t), s(t ? S({
							key: e
						}) : v({
							key: e
						})))
					}
				},
				P = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (s, n) => {
						Object.keys(n().uploads).forEach(n => {
							n.startsWith(e) && s(D(n, t))
						})
					}
				}
		},
		"./src/reddit/actions/userBlocks.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "h", (function() {
				return f
			})), s.d(t, "b", (function() {
				return m
			})), s.d(t, "c", (function() {
				return j
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "g", (function() {
				return I
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/blockedRedditors.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				o = s("./src/reddit/endpoints/accounts/index.ts"),
				c = s("./src/reddit/models/Toast/index.ts"),
				d = s("./src/reddit/selectors/user.ts");
			const u = "USER_BLOCK__PENDING",
				l = "USER_BLOCK__LOADED",
				b = "USER_BLOCK__FAILED",
				p = Object(r.a)(u),
				O = Object(r.a)(l),
				g = Object(r.a)(b),
				f = e => async (t, s, r) => {
					let {
						apiContext: d
					} = r;
					if (s().blockUser.api.pending[e]) return;
					t(p({
						username: e
					}));
					const u = await Object(o.a)(d(), e),
						l = "error-block-".concat(e);
					if (u.ok) u.body.name && t(O(u.body)), u.body.id && t(Object(a.f)(u.body.id)), t(i.f(l)), t(i.e({
						kind: c.b.SuccessCommunity,
						text: n.fbt._("{username} is now blocked", [n.fbt._param("username", e)], {
							hk: "MI2y8"
						})
					}));
					else {
						const s = {
							type: u.error ? u.error.type : "Unknown error",
							username: e
						};
						t(g(s)), t(i.e({
							id: l,
							kind: c.b.Error,
							text: n.fbt._("An error has occured. Please try again later", null, {
								hk: "2FpsLy"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "36rgQw"
							}),
							buttonAction: f(e)
						}))
					}
				}, m = "USER_UNBLOCK__PENDING", j = "USER_UNBLOCK__SUCCESS", _ = "USER_UNBLOCK__FAILED", h = Object(r.a)(m), y = Object(r.a)(j), E = Object(r.a)(_), I = e => async (t, s, r) => {
					let {
						apiContext: u
					} = r;
					const l = s(),
						b = Object(d.i)(l),
						p = b ? b.id : void 0,
						O = l.user.blocked.data.filter(t => t.name === e)[0];
					p && (t(h({
						name: e
					})), (await Object(o.c)(u(), p, e)).ok ? (t(y({
						name: e
					})), O && O.id && t(Object(a.h)(O.id)), t(i.e({
						kind: c.b.SuccessCommunity,
						text: n.fbt._("{username} is now unblocked", [n.fbt._param("username", e)], {
							hk: "4CEi6N"
						})
					}))) : (t(i.e({
						kind: c.b.Error,
						text: n.fbt._("An error has occured. Please try again later", null, {
							hk: "2FpsLy"
						})
					})), t(E({
						name: e
					}))))
				}
		},
		"./src/reddit/actions/userFlair.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return f
			})), s.d(t, "a", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "b", (function() {
				return E
			})), s.d(t, "h", (function() {
				return T
			})), s.d(t, "c", (function() {
				return D
			})), s.d(t, "g", (function() {
				return x
			})), s.d(t, "f", (function() {
				return N
			})), s.d(t, "e", (function() {
				return F
			})), s.d(t, "o", (function() {
				return V
			})), s.d(t, "n", (function() {
				return H
			})), s.d(t, "m", (function() {
				return K
			})), s.d(t, "l", (function() {
				return W
			})), s.d(t, "j", (function() {
				return Y
			})), s.d(t, "k", (function() {
				return z
			})), s.d(t, "p", (function() {
				return J
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./node_modules/lodash/isEmpty.js"),
				i = s.n(a),
				o = s("./src/reddit/actions/authorFlair.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/reddit/endpoints/flair/index.ts"),
				u = s("./src/reddit/helpers/flair.ts"),
				l = s("./src/reddit/models/Flair/index.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				p = s("./src/reddit/models/User/index.ts"),
				O = s("./src/reddit/selectors/subreddit.ts"),
				g = s("./src/reddit/selectors/userFlair.ts");
			const f = "USER_FLAIR_DATA__MUTATED",
				m = "AUTHOR_FLAIR_DATA__MUTATED",
				j = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				_ = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING"),
				h = Object(r.a)(j),
				y = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED"),
				E = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				I = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				v = Object(r.a)(E),
				S = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				T = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				w = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING"),
				C = Object(r.a)(T),
				A = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED"),
				D = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				P = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING"),
				R = Object(r.a)(D),
				k = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED"),
				x = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				N = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				L = Object(r.a)(x),
				U = Object(r.a)("STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS"),
				M = Object(r.a)(N),
				F = "USERFLAIR_FETCH_SUCCESS",
				G = Object(r.a)(F),
				B = Object(r.a)(f),
				q = Object(r.a)(m),
				V = (e, t, s, n, r) => async (a, i, o) => {
					let {
						apiContext: c
					} = o;
					const l = i(),
						b = l.user.account,
						f = b ? Object(p.e)(b) : void 0,
						m = Object(g.c)(l, {
							subredditId: r
						}),
						j = Object.assign(Object.assign({}, m.displaySettings), {
							isUserEnabled: s
						}),
						_ = {
							userName: n,
							subredditId: r,
							applied: e,
							displaySettings: j
						};
					a(n === f ? B(_) : q(_));
					const h = Object(O.S)(l, {
							subredditId: r
						}),
						y = t && e ? Object(u.g)(e) : void 0;
					Object(d.g)(c(), n, h.name, t, y), Object(d.i)(c(), s, h.name)
				}, H = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(O.S)(i, {
							subredditId: e
						}).name;
					s(_());
					const c = await Object(d.l)(a(), o, t);
					if (c.ok) {
						s(h({
							subredditId: e,
							isEnabled: t
						}))
					} else s(y());
					return c.ok
				}, K = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = n(),
						o = Object(O.S)(i, {
							subredditId: e
						}).name;
					s(I());
					const c = await Object(d.j)(a(), t, l.d.UserFlair, o);
					if (c.ok) {
						s(v({
							subredditId: e,
							canAssignOwn: t
						}))
					} else s(S());
					return c.ok
				}, W = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					const o = r(),
						u = Object(O.S)(o, {
							subredditId: t
						}).name;
					s(w());
					const p = await Object(d.f)(i(), e, u, l.d.UserFlair),
						g = p.ok && !(p.body && !1 === p.body.success);
					if (g) {
						const e = {
							subredditId: t,
							template: p.body
						};
						s(C(e));
						const r = Object(c.d)(n.fbt._("Flair saved!", null, {
							hk: "354KI0"
						}), b.b.SuccessMod);
						s(Object(c.e)(r))
					} else {
						s(A());
						const r = Object(c.d)(n.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4tkRNl"
						}), b.b.Error, n.fbt._("Retry", null, {
							hk: "4zNHTm"
						}), W(e, t));
						s(Object(c.e)(r))
					}
					return g
				}, Y = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					const o = r(),
						u = Object(O.S)(o, {
							subredditId: t
						}).name;
					if (s(P()), (await Object(d.b)(i(), e, u)).ok) {
						s(R({
							subredditId: t,
							templateId: e
						}));
						const r = Object(c.d)(n.fbt._("Flair deleted!", null, {
							hk: "1mNdn0"
						}), b.b.SuccessMod);
						s(Object(c.e)(r))
					} else {
						s(k());
						const r = Object(c.d)(n.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "2QrdJr"
						}), b.b.Error, n.fbt._("Retry", null, {
							hk: "1buF3Y"
						}), Y(e, t));
						s(Object(c.e)(r))
					}
				}, z = (e, t) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					const o = r(),
						u = Object(O.S)(o, {
							subredditId: t
						}).name,
						p = Object(g.c)(o, {
							subredditId: t
						}).templateIds;
					if (s(L({
							subredditId: t,
							templateIds: e
						})), (await Object(d.e)(i(), u, l.d.UserFlair, e)).ok) {
						s(U());
						const e = Object(c.d)(n.fbt._("Flair reorder saved.", null, {
							hk: "1zrDON"
						}), b.b.SuccessMod);
						s(Object(c.e)(e))
					} else {
						s(M({
							subredditId: t,
							templateIds: p
						}));
						const r = Object(c.d)(n.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "3gAbwk"
						}), b.b.Error, n.fbt._("Retry", null, {
							hk: "2nPnNw"
						}), z(e, t));
						s(Object(c.e)(r))
					}
				}, J = (e, t) => async (s, r, a) => {
					let {
						apiContext: u
					} = a;
					const l = r(),
						p = l.userFlair;
					if (p && p[e] && p[e].displaySettings.isEnabled && i()(p[e].templateIds)) {
						const r = Object(O.S)(l, {
								subredditId: e
							}).name,
							a = await Object(d.d)(u(), r);
						if (a.ok) s(G(a.body)), s(Object(o.b)({
							username: t,
							subredditId: e
						}));
						else {
							const e = Object(c.d)(n.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							}), b.b.Error);
							s(Object(c.e)(e))
						}
					} else s(Object(o.b)({
						username: t,
						subredditId: e
					}))
				}
		},
		"./src/reddit/actions/userWhitelist.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "c", (function() {
				return f
			})), s.d(t, "a", (function() {
				return m
			})), s.d(t, "h", (function() {
				return y
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/reddit/endpoints/accounts/index.ts"),
				o = s("./src/reddit/models/Toast/index.ts");
			const c = "USER_WHITELIST__PENDING",
				d = "USER_WHITELIST__SUCCESS",
				u = "USER_WHITELIST__FAILED",
				l = Object(r.a)(c),
				b = Object(r.a)(d),
				p = Object(r.a)(u),
				O = e => async (t, s, r) => {
					let {
						apiContext: c
					} = r;
					t(l());
					const d = await Object(i.e)(c(), e);
					d.ok ? d.body.name && (t(b(d.body)), t(a.e({
						kind: o.b.SuccessCommunity,
						text: n.fbt._("Changes saved", null, {
							hk: "3cOmlv"
						})
					}))) : (t(p()), t(a.e({
						kind: o.b.Error,
						text: n.fbt._("An error has occured. Please try again later", null, {
							hk: "3Dszn7"
						})
					})))
				}, g = "USER_UNWHITELIST__PENDING", f = "USER_UNWHITELIST__SUCCESS", m = "USER_UNWHITELIST__FAILED", j = Object(r.a)(g), _ = Object(r.a)(f), h = Object(r.a)(m), y = e => async (t, s, r) => {
					let {
						apiContext: c
					} = r;
					t(j({
						name: e
					})), (await Object(i.d)(c(), e)).ok ? (t(_({
						name: e
					})), t(a.e({
						kind: o.b.SuccessCommunity,
						text: n.fbt._("Changes saved", null, {
							hk: "2o6UcC"
						})
					}))) : (t(h({
						name: e
					})), t(a.e({
						kind: o.b.Error,
						text: n.fbt._("An error has occured. Please try again later", null, {
							hk: "3Dszn7"
						})
					})))
				}
		},
		"./src/reddit/actions/usernameAvailable.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "f", (function() {
				return O
			}));
			var n, r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/endpoints/usernameAvailable/index.ts");
			! function(e) {
				e[e.Available = 0] = "Available", e[e.Error = 1] = "Error", e[e.Pending = 2] = "Pending", e[e.Unavailable = 3] = "Unavailable"
			}(n || (n = {}));
			const i = "USERNAME_AVAILABLE__AVAILABLE",
				o = "USERNAME_AVAILABLE__FAILURE",
				c = "USERNAME_AVAILABLE__PENDING",
				d = "USERNAME_AVAILABLE__UNAVAILABLE",
				u = Object(r.a)(i),
				l = Object(r.a)(o),
				b = Object(r.a)(c),
				p = Object(r.a)(d),
				O = e => {
					let {
						username: t
					} = e;
					return async (e, s, r) => {
						let {
							apiContext: i
						} = r;
						const o = s().users.nameAvailable;
						if (!o[t] || o[t] === n.Error) {
							e(b({
								username: t
							}));
							const s = await Object(a.a)(i(), {
								username: t
							});
							s.ok ? s.body ? e(u({
								username: t
							})) : e(p({
								username: t
							})) : e(l({
								username: t
							}))
						}
					}
				}
		},
		"./src/reddit/actions/users.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return q
			})), s.d(t, "q", (function() {
				return V
			})), s.d(t, "g", (function() {
				return H
			})), s.d(t, "f", (function() {
				return K
			})), s.d(t, "e", (function() {
				return W
			})), s.d(t, "k", (function() {
				return Y
			})), s.d(t, "d", (function() {
				return z
			})), s.d(t, "y", (function() {
				return Z
			})), s.d(t, "c", (function() {
				return $
			})), s.d(t, "r", (function() {
				return te
			})), s.d(t, "p", (function() {
				return se
			})), s.d(t, "x", (function() {
				return ne
			})), s.d(t, "s", (function() {
				return re
			})), s.d(t, "a", (function() {
				return ae
			})), s.d(t, "o", (function() {
				return oe
			})), s.d(t, "u", (function() {
				return ce
			})), s.d(t, "m", (function() {
				return de
			})), s.d(t, "n", (function() {
				return ue
			})), s.d(t, "l", (function() {
				return le
			})), s.d(t, "t", (function() {
				return fe
			})), s.d(t, "v", (function() {
				return me
			})), s.d(t, "i", (function() {
				return je
			})), s.d(t, "j", (function() {
				return _e
			})), s.d(t, "h", (function() {
				return he
			})), s.d(t, "w", (function() {
				return ve
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/emailVerificationTooltip.ts"),
				o = s("./src/reddit/actions/modal.ts"),
				c = s("./src/reddit/actions/notificationBanner.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				u = s("./src/reddit/components/NotificationBanners/bannerIds.ts"),
				l = s("./src/reddit/components/Settings/modalIds.ts"),
				b = s("./src/reddit/endpoints/user/index.ts"),
				p = s("./src/lib/makeApiRequest/index.ts"),
				O = s("./src/lib/omitHeaders/index.ts"),
				g = s("./src/reddit/constants/headers.ts"),
				f = s("./src/config.ts"),
				m = s("./src/reddit/helpers/getErrorMsgFromR2JQueryResponse.ts"),
				j = (s("./node_modules/core-js/modules/es7.promise.finally.js"), s("./node_modules/promise-retry/index.js")),
				_ = s.n(j),
				h = s("./src/lib/makeRequest/index.ts");
			var y = s("./src/reddit/constants/history.ts"),
				E = s("./src/reddit/endpoints/session/index.ts"),
				I = s("./node_modules/js-cookie/src/js.cookie.js"),
				v = s.n(I),
				S = s("./src/lib/constants/cookie.ts");
			const T = e => {
				v.a.remove(e, {
					domain: f.a.cookieDomain
				})
			};
			var w = s("./src/reddit/helpers/history/index.ts");
			const C = 2 * r.eb;
			var A = e => Date.now() + C < new Date(e.expires).getTime(),
				D = s("./src/reddit/helpers/localStorage/index.ts"),
				P = async (e, t, s) => {
					let n = t.accessToken;
					await _()(async (a, i) => {
						if (!A(t) || !n) {
							const r = await Object(E.b)(e, t, s);
							if (r.ok) {
								const e = r.body;
								n = e.accessToken
							} else if (1 === i) return a()
						}
						const o = await Object(p.a)(e, {
							endpoint: "/logoutproxy",
							method: r.db.POST,
							data: {
								access_token: n
							}
						});
						if (await async function(e, t) {
								return await Object(h.b)({
									method: r.db.POST,
									endpoint: "/timings/logoutrequest",
									data: {
										appName: e.statsAppName,
										successful: t
									},
									type: "json"
								})
							}(e, o && o.ok), !o.ok) return a()
					}, {
						retries: 1
					}).catch(() => {}).finally(() => {
						[S.d, S.e, S.h, S.i].forEach(T), Object(D.H)(null), Object(w.a)(y.a.JustLoggedOut, !0), window.location.reload()
					})
				}, R = s("./src/reddit/helpers/redesignOptoutCookie/index.ts"), k = s("./src/reddit/helpers/trackers/emailCollection.ts"), x = s("./src/reddit/helpers/trackers/emailVerification.ts"), N = s("./src/reddit/models/Toast/index.ts"), L = s("./src/reddit/selectors/activeModalId.ts"), U = s("./src/reddit/selectors/emailCollection.ts"), M = s("./src/reddit/selectors/notificationBanner.ts"), F = s("./src/reddit/selectors/user.ts"), G = s("./src/telemetry/index.ts"), B = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const q = "USER__LOID_RECEIVED",
				V = Object(a.a)(q),
				H = "USER__REQUEST_PENDING",
				K = "USER__REQUEST_LOADED",
				W = "USER__REQUEST_FAILED",
				Y = "USER__SESSION_TRACKER_RECEIVED",
				z = "USER__REDDAID_RECEIVED",
				J = Object(a.a)(H),
				Q = Object(a.a)(K),
				X = Object(a.a)(W),
				Z = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					if (s().users.models[e.toLowerCase()] || e === r.A) return;
					t(J({
						username: e
					}));
					const i = await Object(b.b)(a(), e);
					if (i.ok) {
						const s = {
							data: i.body
						};
						s.username = e, t(Q(s))
					} else {
						const s = i.error;
						s.username = e, t(X(s))
					}
				}, $ = "USER__MYSELF_LOADED", ee = Object(a.a)($), te = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const a = t();
					if (a.user.account || !a.user.session || a.user.session.unsafeLoggedOut) return;
					const i = await (e => Object(p.a)(e, {
						endpoint: "".concat(f.a.gatewayUrl, "/desktopapi/v1/me"),
						method: r.db.GET,
						data: {
							api_type: "json",
							gilding_detail: 1,
							awarded_detail: 1
						}
					}))(n());
					i.ok && e(ee(i.body))
				}, se = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t().user.session;
					Object(R.a)(), r && P(n(), r)
				}, ne = Object(a.a)(Y), re = Object(a.a)(z), ae = "USER__LAYOUT_SWITCH_VIEWED", ie = Object(a.a)(ae), oe = () => async (e, t, s) => {
					let {
						apiContext: n
					} = s;
					const r = t();
					r.user.account && !r.user.account.seenLayoutSwitch && (e(ie()), Object(b.d)(n()))
				}, ce = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const i = await ((e, t) => Object(p.a)(Object(O.a)(e, [g.a]), {
							method: r.db.POST,
							endpoint: "".concat(e.apiUrl, "/api/deactivate_user"),
							data: {
								user: t.username,
								passwd: t.password,
								confirm: t.checkbox,
								deactivate_message: t.feedback
							}
						}))(a(), e),
						o = s().user.session;
					i.ok && i.body && i.body.success ? o && P(a(), o) : t(Object(d.e)({
						kind: N.b.Error,
						text: "Something went wrong deactivating your account. Try again later."
					}))
				}, de = "USER__UPDATE_EMAIL_PENDING", ue = "USER__UPDATE_EMAIL_SUCCESS", le = "USER__UPDATE_EMAIL_FAILURE", be = Object(a.a)(de), pe = Object(a.a)(ue), Oe = Object(a.a)(le), ge = (e, t) => {
					t.isEmailVerificationTooltipShowing && e(Object(i.b)())
				}, fe = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const i = B(e, []);
					if (Object(F.D)(s(), "changeEmail")) return;
					t(be());
					const o = await ((e, t) => {
							let {
								newEmail: s,
								password: n
							} = t;
							return Object(p.a)(Object(O.a)(e, [g.a]), {
								method: r.db.POST,
								endpoint: "".concat(e.apiUrl, "/api/update_email"),
								data: Object.assign(Object.assign({}, n && {
									curpass: n
								}), {
									email: s
								})
							})
						})(a(), i),
						d = s();
					if (o.ok && o.body && o.body.success) {
						Object(M.a)(u.a.EmailCollectionBannerId)(d) && t(Object(c.c)(u.a.EmailCollectionBannerId)), Object(U.a)(d) && Object(G.a)(Object(k.c)(d));
						const e = Object(F.F)(d);
						e || await t(me()), t(pe(i.newEmail)), e && t(Ee()), ge(t, d)
					} else {
						const e = Object(m.b)(o, "Something went wrong updating your email. Try again later.");
						t(Oe(e))
					}
				}, me = e => async (t, s, a) => {
					let {
						apiContext: i
					} = a;
					const c = await ((e, t) => Object(p.a)(Object(O.a)(e, [g.a]), Object.assign({
							method: r.db.GET,
							endpoint: "".concat(e.apiUrl, "/api/send_verification_email")
						}, t.source && {
							data: t
						})))(i(), {
							source: e
						}),
						u = s();
					if (c.ok && c.body && c.body.success) {
						e && (Object(G.a)(Object(x.f)(e)(u)), ge(t, u));
						const s = Object(L.a)(u),
							n = s === l.g || s === l.o ? l.o : l.c;
						t(Object(o.i)(n))
					} else t(Object(d.e)({
						duration: d.a,
						kind: N.b.Error,
						text: n.fbt._("Something went wrong sending verification email. Try again later.", null, {
							hk: "2yTdAw"
						})
					}))
				}, je = "USER__SEND_RESET_EMAIL_PENDING", _e = "USER__SEND_RESET_EMAIL_SUCCESS", he = "USER__SEND_RESET_EMAIL_FAILURE", ye = Object(a.a)(je), Ee = Object(a.a)(_e), Ie = Object(a.a)(he), ve = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					if (Object(F.D)(s(), "sendResetEmail")) return;
					t(ye());
					const i = await ((e, t) => Object(p.a)(Object(O.a)(e, [g.a]), {
						method: r.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/password"),
						data: {
							email: t.curEmail,
							name: t.name
						}
					}))(a(), e);
					if (!i.ok || !i.body || !i.body.success) {
						const e = Object(m.b)(i, "Something went wrong sending the reset email. Please try again.");
						return t(Ie()), void t(Object(d.e)({
							duration: d.a,
							kind: N.b.Error,
							text: e
						}))
					}
					t(Ee())
				}
		},
		"./src/reddit/actions/video.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return O
			})), s.d(t, "k", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "f", (function() {
				return j
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "h", (function() {
				return h
			})), s.d(t, "j", (function() {
				return y
			})), s.d(t, "m", (function() {
				return E
			})), s.d(t, "o", (function() {
				return I
			})), s.d(t, "p", (function() {
				return v
			})), s.d(t, "n", (function() {
				return S
			})), s.d(t, "a", (function() {
				return T
			})), s.d(t, "i", (function() {
				return w
			})), s.d(t, "c", (function() {
				return C
			})), s.d(t, "l", (function() {
				return A
			})), s.d(t, "t", (function() {
				return P
			})), s.d(t, "y", (function() {
				return R
			})), s.d(t, "w", (function() {
				return k
			})), s.d(t, "x", (function() {
				return x
			})), s.d(t, "v", (function() {
				return N
			})), s.d(t, "L", (function() {
				return L
			})), s.d(t, "C", (function() {
				return U
			})), s.d(t, "M", (function() {
				return M
			})), s.d(t, "N", (function() {
				return F
			})), s.d(t, "z", (function() {
				return B
			})), s.d(t, "A", (function() {
				return V
			})), s.d(t, "E", (function() {
				return W
			})), s.d(t, "J", (function() {
				return Y
			})), s.d(t, "u", (function() {
				return z
			})), s.d(t, "K", (function() {
				return Q
			})), s.d(t, "I", (function() {
				return $
			})), s.d(t, "G", (function() {
				return ee
			})), s.d(t, "r", (function() {
				return te
			})), s.d(t, "F", (function() {
				return se
			})), s.d(t, "q", (function() {
				return ne
			})), s.d(t, "B", (function() {
				return re
			})), s.d(t, "D", (function() {
				return ae
			})), s.d(t, "s", (function() {
				return ie
			})), s.d(t, "H", (function() {
				return oe
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/constants/adEvents.ts"),
				a = s("./src/reddit/constants/video.ts"),
				i = s("./src/reddit/helpers/correlationIdTracker.ts"),
				o = s("./src/reddit/actions/post.ts"),
				c = s("./src/reddit/helpers/trackers/media.ts"),
				d = s("./src/reddit/helpers/trackers/postList.ts"),
				u = s("./src/reddit/selectors/platform.ts"),
				l = s("./src/reddit/selectors/posts.ts"),
				b = s("./src/reddit/selectors/telemetry.ts"),
				p = (s("./src/reddit/selectors/video.ts"), s("./src/telemetry/index.ts"));
			const O = "VIDEO__CONSUMED",
				g = "VIDEO__SET_FULLSCREEN",
				f = "VIDEO__EXIT_FULLSCREEN",
				m = "VIDEO__LOADABLE",
				j = "VIDEO__LOADING",
				_ = "VIDEO__PAUSED",
				h = "VIDEO__PLAYABLE",
				y = "VIDEO__METADATA_RECEIVED",
				E = "VIDEO__STARTED",
				I = "VIDEO__UNLOADABLE",
				v = "VIDEO__UNPAUSED",
				S = "VIDEO__TIME_UPDATED",
				T = "VIDEO__BUFFERING",
				w = "VIDEO__PLAYING",
				C = "VIDEO__CONTINUOUS_VIEW_STARTED_AT",
				A = "VIDEO__SET_MUTED_IN_FEED",
				D = (() => {
					let e = "";
					return (t, s, n, r) => async (a, o) => {
						if (null != t) {
							e !== t && (e = t, Object(i.d)(i.a.VideoView));
							const a = o(),
								d = r ? c.b(t, s, n) : c.a(t, s, n);
							Object(p.a)(Object.assign(Object.assign({}, b.defaults(a)), d(a)))
						}
					}
				})(),
				P = Object(n.a)(C),
				R = e => async (t, s) => {
					const n = s(),
						a = Object(l.N)(n, {
							postId: e
						});
					t(D(e, "is_viewable", "video", !1)), a.isSponsored && t(Object(o.t)(a, r.a.VideoViewableImpression))
				}, k = e => async (t, s) => {
					const n = s(),
						a = Object(l.N)(n, {
							postId: e
						});
					a.isSponsored && t(Object(o.t)(a, r.a.VideoGroupMViewable))
				}, x = e => async (t, s) => {
					const n = s(),
						a = Object(l.N)(n, {
							postId: e
						});
					a.isSponsored && t(Object(o.t)(a, r.a.VideoVendorFullyViewable50))
				}, N = e => async (t, s) => {
					const n = s(),
						a = Object(l.N)(n, {
							postId: e
						});
					t(D(e, "is_fully_viewable", "video", !1)), a.isSponsored && t(Object(o.t)(a, r.a.VideoFullyViewableImpression))
				}, L = e => async (t, s) => {
					const n = Object(l.N)(s(), {
						postId: e
					});
					t(D(e, "start", "video", !1)), n.isSponsored && t(Object(o.t)(n, r.a.VideoStarted))
				}, U = (e, t) => async (s, n) => {
					const a = Object(l.N)(n(), {
						postId: t
					});
					s(D(t, "play_with_sound", "video", !1)), s(D(t, "is_viewable", "video", !1)), s(D(t, "is_fully_viewable", "video", !1)), a.isSponsored && (s(Object(o.t)(a, r.a.VideoPlayedWithSound)), e && (s(Object(o.t)(a, r.a.VideoViewableImpression)), s(Object(o.t)(a, r.a.VideoFullyViewableImpression))))
				}, M = (e, t) => async (s, n) => {
					const i = Object(l.N)(n(), {
						postId: t
					});
					let c, d;
					switch (e) {
						case a.b:
							c = "watch_25_percent", d = r.a.VideoWatched25;
							break;
						case a.c:
							c = "watch_50_percent", d = r.a.VideoWatched50;
							break;
						case a.d:
							c = "watch_75_percent", d = r.a.VideoWatched75;
							break;
						case a.e:
							c = "watch_95_percent", d = r.a.VideoWatched95;
							break;
						default:
							c = "watch_100_percent", d = r.a.VideoWatched100
					}
					s(D(t, c, "video", !1)), i.isSponsored && s(Object(o.t)(i, d, c))
				}, F = (e, t) => async (s, n) => {
					const i = Object(l.N)(n(), {
						postId: t
					});
					let c, d;
					switch (e) {
						case a.g:
							c = "watch_3_seconds", d = r.a.VideoWatchedSeconds3;
							break;
						case a.h:
							c = "watch_5_seconds", d = r.a.VideoWatchedSeconds5;
							break;
						default:
							c = "watch_10_seconds", d = r.a.VideoWatchedSeconds10
					}
					s(D(t, c, "video", !1)), i.isSponsored && s(Object(o.t)(i, d, c))
				}, G = Object(n.a)(O), B = Object(n.a)(m), q = Object(n.a)(j), V = Object(n.a)(_), H = Object(n.a)(h), K = Object(n.a)(g), W = Object(n.a)(y), Y = Object(n.a)(S), z = Object(n.a)(f), J = Object(n.a)(E), Q = Object(n.a)(I), X = Object(n.a)(v), Z = Object(n.a)(T), $ = Object(n.a)(w), ee = e => async (t, s) => {
					const n = Object(l.N)(s(), {
						postId: e
					});
					t(K({
						postId: e
					})), ((e, t, s) => {
						s(D(t, "play_expanded", "video", !1)), s(D(t, "is_viewable", "video", !1)), s(D(t, "is_fully_viewable", "video", !1)), e.isSponsored && (s(Object(o.t)(e, r.a.VideoPlayedExpanded)), s(Object(o.t)(e, r.a.VideoViewableImpression)), s(Object(o.t)(e, r.a.VideoFullyViewableImpression)))
					})(n, e, t)
				}, te = (e, t) => async (s, n) => {
					const r = n();
					r.posts.video.autoPlayed[e] && Object(u.k)(r) && (d.d(r, e), void 0 !== t && s(Z({
						postId: e,
						isBuffering: t
					})))
				}, se = e => async (t, s) => {
					const n = s();
					n.posts.video.autoPlayed[e] && Object(u.k)(n) && d.h(n, e)
				}, ne = (e, t) => async (s, n) => {
					s(q({
						postId: e,
						time: t
					}));
					const r = n();
					Object(u.k)(r) && d.f(r, e)
				}, re = (e, t) => async (s, n) => {
					s(H({
						postId: e,
						time: t
					}));
					const r = n();
					Object(u.k)(r) && d.a(r, e)
				}, ae = e => async (t, s) => {
					const n = s(),
						r = n.posts.video.autoPlayed[e],
						a = n.posts.video.started[e];
					t(J({
						postId: e
					})), t(X({
						postId: e
					})), !a && r && Object(u.k)(n) && d.c(n, e)
				}, ie = e => async (t, s) => {
					const n = s(),
						r = n.posts.video.autoPlayed[e],
						a = n.posts.video.consumed[e];
					t(G({
						postId: e
					})), r && Object(u.k)(n) && !a && d.b(n, e)
				}, oe = Object(n.a)(A)
		},
		"./src/reddit/actions/vote.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return N
			})), s.d(t, "b", (function() {
				return U
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/telemetry/index.ts"),
				a = s("./src/reddit/actions/tooltip.ts"),
				i = s("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				o = s("./src/reddit/endpoints/user/index.ts"),
				c = s("./src/reddit/actions/gold/constants.ts");
			const d = Object(n.a)(c.x),
				u = Object(n.a)(c.y);
			var l = s("./src/reddit/actions/login.ts"),
				b = s("./src/reddit/actions/modal.ts"),
				p = s("./src/reddit/actions/post.ts"),
				O = s("./src/reddit/components/ModerationPrompts/useActivePromptId.ts"),
				g = s("./src/reddit/constants/adEvents.ts"),
				f = s("./src/reddit/constants/experiments.ts"),
				m = s("./src/reddit/contexts/PageLayer/selectors.ts"),
				j = s("./src/lib/constants/index.ts"),
				_ = s("./src/lib/makeApiRequest/index.ts"),
				h = s("./src/lib/omitHeaders/index.ts"),
				y = s("./src/reddit/constants/headers.ts"),
				E = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var I = s("./src/reddit/helpers/isComment.ts"),
				v = s("./src/reddit/helpers/isPost.ts"),
				S = s("./src/reddit/helpers/trackers/gild.ts"),
				T = s("./src/reddit/models/Vote/index.ts"),
				w = s("./src/reddit/selectors/comments.ts"),
				C = s("./src/reddit/helpers/chooseVariant/index.ts"),
				A = s("./src/reddit/selectors/user.ts");
			var D = s("./src/reddit/selectors/gild.ts"),
				P = s("./src/reddit/selectors/moderatorPermissions.ts"),
				R = s("./src/reddit/selectors/modQueue.ts"),
				k = s("./src/reddit/selectors/platform.ts"),
				x = s("./src/reddit/selectors/posts.ts");
			const N = "VOTE__VOTE_CAST",
				L = Object(n.a)(N),
				U = (e, t) => s => async (n, c, N) => {
					let {
						apiContext: U
					} = N;
					if (!Object(A.H)(c())) return n(Object(b.k)({
						actionSource: b.a.Vote
					})), void n(Object(l.i)());
					const M = e(s, c),
						F = T.b(M, t),
						G = Object(v.a)(s) ? M.postId : s;
					if (n(L({
							id: G,
							isInstance: !1,
							vote: t
						})), (c().posts.instances[G] || []).forEach(e => {
							n(L({
								id: e,
								isInstance: !0,
								vote: t
							}))
						}), F)
						if (Object(v.a)(s)) {
							const e = Object(x.N)(c(), {
									postId: s
								}),
								r = t > 0 ? g.a.Upvote : g.a.Downvote;
							n(Object(p.t)(e, r))
						} else if (Object(I.a)(s)) {
						const e = Object(w.n)(c(), {
							commentId: s
						});
						if (e) {
							const s = Object(x.N)(c(), {
									postId: e.postId
								}),
								r = t > 0 ? g.a.CommentUpvote : g.a.CommentDownvote;
							n(Object(p.t)(s, r))
						}
					}
					const B = c(),
						q = Object(k.i)(B),
						V = !!Object(D.f)(B),
						H = Object(A.bb)(B);
					if (V ? n((() => async (e, t, s) => {
							let {
								apiContext: n
							} = s;
							e(d()), e(Object(a.i)())
						})()) : Object(v.a)(G) && F === T.a.upvoted && !H && (e => {
							const t = Object(C.c)(e, {
								experimentEligibilitySelector: e => Object(A.H)(e),
								experimentName: f.hb
							});
							return Object(f.zc)(t) ? void 0 : t
						})(B) && (n(((e, t) => async (s, n, r) => {
							let {
								apiContext: c
							} = r;
							s(u(e)), s(Object(a.h)({
								tooltipId: Object(i.a)("View--GiveAward", e, t ? "lightbox" : void 0)
							})), Object(o.c)(c())
						})(G, q)), Object(r.a)(Object(S.viewGiveAwardTooltipEvent)(G)(B))), Object(A.H)(B)) {
						const e = await ((e, t, s) => Object(_.a)(Object(h.a)(e, [y.a]), {
							endpoint: Object(E.a)("".concat(e.apiUrl, "/api/vote")),
							method: j.db.POST,
							data: {
								id: t,
								dir: s,
								api_type: "json"
							}
						}))(U(), G, F);
						e.ok || n(L({
								id: G,
								isInstance: !1,
								vote: t
							})),
							function(e) {
								const {
									moderationPrompt: t
								} = e.body;
								if (!t) return;
								if (!Object(v.a)(s)) return;
								const r = Object(x.N)(B, {
									postId: s
								});
								if (Object(P.g)(B, {
										subredditId: r.belongsTo.id
									})) return;
								if (Object(R.b)(B)) return;
								if (Object(m.F)(B.platform && B.platform.currentPage)) return;
								if (r.isSponsored) return;
								if ("profile" === r.belongsTo.type) return;
								const a = B.experimentOverrides[f.Q],
									i = Object(k.i)(B);
								("none" !== t || a && F === T.a.downvoted) && (n(Object(p.J)({
									[s]: {
										moderationPrompt: a || t
									}
								})), n(Object(p.z)(Object(O.b)(s, i))))
							}(e)
					}
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return n
			})), s.d(t, "i", (function() {
				return r
			})), s.d(t, "h", (function() {
				return a
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			}));
			const n = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				a = "WIDGET_DELETED",
				i = "WIDGETS_SORTED",
				o = "WIDGETS__STARTED_EDITING_WIDGET",
				c = "WIDGETS__LOADED",
				d = "SUBREDDIT__WIDGETS_PENDING",
				u = "SUBREDDIT__WIDGETS_LOADED",
				l = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return E
			})), s.d(t, "e", (function() {
				return v
			})), s.d(t, "d", (function() {
				return T
			})), s.d(t, "h", (function() {
				return C
			})), s.d(t, "a", (function() {
				return A
			})), s.d(t, "b", (function() {
				return D
			})), s.d(t, "f", (function() {
				return R
			})), s.d(t, "g", (function() {
				return L
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/apiRequestState.ts"),
				i = s("./src/reddit/actions/imageUploads.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/makeApiRequest/index.ts"),
				u = s("./src/lib/omitHeaders/index.ts"),
				l = s("./src/reddit/constants/headers.ts");
			const b = async (e, t, s) => Object(d.a)(Object(u.a)(e, [l.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widgets"),
				method: c.db.GET,
				type: "json",
				data: {
					progressive_images: s
				}
			});
			var p = s("./src/reddit/helpers/getGenericUploadError.ts"),
				O = s("./src/reddit/helpers/media/index.ts"),
				g = s("./src/lib/assertNever.ts"),
				f = s("./src/reddit/selectors/subreddit.ts"),
				m = s("./src/reddit/models/Image/index.tsx"),
				j = s("./src/reddit/models/Toast/index.ts"),
				_ = s("./src/reddit/models/Widgets/index.ts"),
				h = s("./src/reddit/actions/widgets/constants.ts");
			const y = Object(r.a)(h.g),
				E = (e, t, s) => async (r, b, O) => {
					const {
						apiContext: g
					} = O;
					r(Object(a.h)(s));
					const h = b(),
						E = Object(f.S)(h, {
							subredditId: e
						}).name,
						I = Object(_.k)(t);
					let v = null,
						S = null;
					try {
						(v = await Object(i.f)(h, m.a.Widgets)) && (S = Object(i.m)(v)(r, b, O))
					} catch (w) {
						const e = Object(p.a)("webSocket");
						return void r(Object(a.f)(s, e))
					}
					const T = await (async (e, t, s) => Object(d.a)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget"),
						method: c.db.POST,
						type: "json",
						data: s
					}))(g(), E, I);
					if (T.ok) {
						let i = T.body;
						const c = i.id;
						if ("calendar" === t.kind && r(Object(o.e)({
								kind: j.b.SuccessMod,
								text: n.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), v) {
							try {
								await S
							} catch (w) {}
							i = await r(U(e, c)) || i
						}
						r(y({
							subredditId: e,
							widget: i,
							widgetId: c
						})), r(Object(a.e)(s))
					} else v && v.websocket.close(), r(Object(a.f)(s, T.error))
				}, I = Object(r.a)(h.i), v = (e, t, s) => async (r, b, O) => {
					const {
						apiContext: h
					} = O;
					r(Object(a.h)(s));
					const y = t.id,
						E = b(),
						v = Object(f.S)(E, {
							subredditId: e
						}).name,
						S = Object(_.k)(t);
					let T = null,
						w = null;
					try {
						(T = await Object(i.f)(E, m.a.Widgets)) && (w = Object(i.m)(T)(r, b, O))
					} catch (A) {
						const e = Object(p.a)("webSocket");
						return void r(Object(a.f)(s, e))
					}
					const C = await (async (e, t, s) => Object(d.a)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget/").concat(s.id),
						method: c.db.PUT,
						type: "json",
						data: s
					}))(h(), v, S);
					if (C.ok) {
						let i = function(e, t, s) {
							switch (e.kind) {
								case "calendar":
								case "id-card":
								case "subreddit-rules":
									return Object.assign(Object.assign({}, e), t);
								case "community-list": {
									const n = {};
									for (const t of e.data) n[t.name] = t;
									return Object.assign(Object.assign({}, t), {
										data: t.data.map(e => {
											if (!("subscribers" in n[e])) {
												const t = {
														subredditName: e
													},
													n = Object(f.B)(s, t),
													r = Object(f.y)(s, t);
												return {
													name: n.name,
													subscribers: n ? n.subscribers : void 0,
													iconUrl: n ? n.communityIcon : void 0,
													isNSFW: n ? n.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return n[e]
										})
									})
								}
								case "button":
								case "custom":
								case "image":
								case "menu":
								case "moderators":
								case "textarea":
								case "post-flair":
									return t;
								default:
									return Object(g.a)(e)
							}
						}(t, C.body, E);
						if (w) {
							try {
								await w
							} catch (A) {}
							i = await r(U(e, y)) || i
						}
						r(I({
							subredditId: e,
							widgetId: y,
							widget: i
						})), "calendar" === t.kind && r(Object(o.e)({
							kind: j.b.SuccessMod,
							text: n.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(a.e)(s))
					} else T && T.websocket.close(), r(Object(a.f)(s, C.error))
				}, S = Object(r.a)(h.h), T = (e, t, s) => async (n, r, i) => {
					let {
						apiContext: o
					} = i;
					n(Object(a.h)(s));
					const b = t.id,
						p = Object(f.S)(r(), {
							subredditId: e
						}).name,
						O = await (async (e, t, s) => Object(d.a)(Object(u.a)(e, [l.a]), {
							endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget/").concat(s.id),
							method: c.db.DELETE,
							type: "json"
						}))(o(), p, t);
					O.ok ? (n(Object(a.e)(s)), n(S({
						subredditId: e,
						widgetId: b
					}))) : n(Object(a.f)(s, O.error))
				}, w = Object(r.a)(h.f), C = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = Object(f.S)(n(), {
						subredditId: e
					}).name;
					(await (async (e, t, s) => Object(d.a)(Object(u.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget_order/sidebar"),
						method: c.db.PATCH,
						type: "json",
						data: s
					}))(a(), i, t)).ok && s(w({
						subredditId: e,
						widgetIds: t
					}))
				}, A = e => {
					let {
						imageData: t
					} = e;
					return async (e, s, n) => {
						const r = s(),
							a = r.structuredStyles.isEditing,
							o = Object(f.S)(r, {
								subredditId: a
							}).name;
						e(Object(i.k)(t));
						const b = await (async (e, t, s, n) => Object(d.a)(Object(u.a)(e, [l.a]), {
							endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/widget_image_upload_s3"),
							method: c.db.POST,
							data: {
								filepath: s,
								mimetype: n
							}
						}))(n.apiContext(), o, t.file.name, await Object(O.g)(t.file));
						let p = !1;
						try {
							const n = await Object(i.g)(s(), b, t, m.a.Widgets);
							n && (e(Object(i.j)(n)), p = !0)
						} catch (g) {
							if (g instanceof Error) throw g;
							e(Object(i.i)(g))
						}
						return p
					}
				}, D = Object(r.a)(h.d), P = Object(r.a)(h.e), R = (e, t) => async (s, n, r) => {
					let {
						apiContext: i
					} = r;
					s(Object(a.h)(t));
					const o = Object(f.S)(n(), {
							subredditId: e
						}).name,
						c = await b(i(), o);
					if (c.ok) {
						const n = c.body;
						s(P({
							subredditId: e,
							widgets: n
						})), s(Object(a.e)(t))
					} else s(Object(a.f)(t, c.error))
				}, k = Object(r.a)(h.c), x = Object(r.a)(h.b), N = Object(r.a)(h.a), L = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					s(k({
						subredditId: e
					}));
					const i = Object(f.S)(n(), {
							subredditId: e
						}).name,
						o = await b(a(), i, t);
					if (o.ok) {
						const t = o.body;
						s(x({
							subredditId: e,
							widgets: t
						}))
					} else s(N({
						subredditId: e,
						error: o.error
					}))
				}, U = (e, t) => async (s, n, r) => {
					let {
						apiContext: a
					} = r;
					const i = Object(f.S)(n(), {
							subredditId: e
						}).name,
						o = await b(a(), i, !0);
					if (o.ok) return o.body.items[t]
				}
		},
		"./src/reddit/components/Flatlist/getFlatlistTooltipId.ts": function(e, t, s) {
			"use strict";
			t.a = (e, t, s) => {
				const n = "".concat(e, "--").concat(t);
				return s ? "".concat(n, "--").concat(s) : n
			}
		},
		"./src/reddit/components/Gold/AwardKarmaToastMessage/index.m.less": function(e, t, s) {
			e.exports = {
				karmaLink: "_33-F8KNeBDS4RS9mUMQdxH"
			}
		},
		"./src/reddit/components/ModerationPrompts/useActivePromptId.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./node_modules/react-redux/es/index.js");
			const r = e => e.moderationPromptId;

			function a(e, t) {
				return Object(n.d)(r) === i(e.id, t)
			}

			function i(e, t) {
				return "prompt-".concat(e).concat(t ? "-overlay" : "")
			}
		},
		"./src/reddit/components/NotificationBanners/bannerIds.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.EmailCollectionBannerId = "email-collection-banner-id"
				}(n || (n = {}))
		},
		"./src/reddit/components/Settings/modalIds.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "g", (function() {
				return a
			})), s.d(t, "o", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "l", (function() {
				return c
			})), s.d(t, "m", (function() {
				return d
			})), s.d(t, "n", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "k", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "d", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "f", (function() {
				return m
			}));
			const n = "change_email_modal_id",
				r = "check_email_modal_id",
				a = "set_email_modal_id",
				i = "verify_email_modal_id",
				o = "reset_pw_sso_2fa_modal_id",
				c = "reset_pw_sso_email_modal_id",
				d = "reset_pw_sso_google_link_modal_id",
				u = "reset_pw_sso_google_unlink_modal_id",
				l = "reset_pw_sso_apple_link_modal_id",
				b = "reset_pw_sso_apple_unlink_modal_id",
				p = "reset_pw_sso_deactivate_account_modal_id",
				O = "change_username_modal_id",
				g = "confirm_save_username_modal_id",
				f = "intercept_action_modal_id",
				m = "second_confirm_keep_username_modal_id"
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			}));
			var n = s("./node_modules/react/index.js"),
				r = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				i = s("./src/reddit/selectors/telemetry.ts"),
				o = s("./src/telemetry/index.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const d = r.a.createContext(() => {});

			function u(e) {
				let {
					children: t
				} = e;
				const s = Object(a.e)(),
					c = Object(n.useCallback)(e => {
						{
							const t = s.getState(),
								n = e(t);
							Object(o.a)(Object.assign(Object.assign({}, i.defaults(t)), n))
						}
					}, [s]);
				return r.a.createElement(d.Provider, {
					value: c
				}, t ? r.a.Children.only(t) : null)
			}

			function l() {
				return Object(n.useContext)(d)
			}

			function b(e) {
				function t(t) {
					const s = l();
					return r.a.createElement(e, c({}, t, {
						sendEvent: s
					}))
				}
				return t.displayName = "Tracked", t.WrappedComponent = e, t
			}
		},
		"./src/reddit/constants/actions.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "@@router/CALL_HISTORY_METHOD"
		},
		"./src/reddit/constants/cookie.ts": function(e, t, s) {
			"use strict";
			s.d(t, "j", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "f", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "i", (function() {
				return u
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "e", (function() {
				return b
			}));
			const n = "USER",
				r = "alphaModal",
				a = "over18",
				i = "mod_mode_enabled",
				o = "recent_srs",
				c = "_recentclicks2",
				d = "eu_cookie_v2",
				u = "uapp_cookie",
				l = "nightmode",
				b = "_options"
		},
		"./src/reddit/constants/errors.ts": function(e, t, s) {
			"use strict";
			var n, r;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.BannedProfile = "BANNED", e.DeletedProfile = "DELETED", e.NotFoundProfile = "NOT_FOUND", e.ForbiddenProfile = "FORBIDDEN"
				}(n || (n = {})),
				function(e) {
					e.Unknown = "Unknown"
				}(r || (r = {}))
		},
		"./src/reddit/constants/gold.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "i", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "g", (function() {
				return l
			}));
			const n = "ModerationPage--Modal--AddAward",
				r = "ModerationPage--Modal--DeleteAwardConfirmation",
				a = 20,
				i = 4,
				o = 1e4,
				c = .2,
				d = .1,
				u = .1,
				l = 500
		},
		"./src/reddit/constants/graphql.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(n || (n = {}))
		},
		"./src/reddit/constants/inFeedChaining.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			}));
			const n = 3,
				r = 5,
				a = 10
		},
		"./src/reddit/constants/modals.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})), s.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.ADD_REMOVAL_REASON = "add_removal_reason", e.ALPHA_CONSUMER = "alpha_consumer", e.BADGE_PICKER = "badge_picker", e.BADGE_PURCHASE = "badge_purchase", e.BAN_USER = "ban_user", e.BLADE_NIGHTMODE = "blade_nightmode", e.BLADE_UNSAVED_CHANGES = "blade_unsaved_changes", e.CHANGE_PASSWORD_MODAL_ID = "account_manager_change_password", e.CONFIRM_CLOSE_COIN_MODAL_ID = "confirm_close_coin_modal_id", e.CONFIRM_CLOSE_PREMIUM_MODAL_ID = "confirm_close_premium_modal_id", e.CONTRIBUTOR_REQUEST = "contributor_request", e.CONTRIBUTOR_REQUEST_PENDING = "contributor_request_pending", e.CONVERT_TO_COINS = "convert_to_coins", e.CREATE_SUBREDDIT_CHAT = "create_subreddit_chat", e.DELETE_SUBREDDIT_CHAT = "delete_subreddit_chat", e.DISABLE_TWO_FACTOR = "disable_2fa_modal", e.DOWN_TO_CHAT_PENDING_MODAL = "down_to_chat_pending_modal", e.ECON_COIN_PURCHASE = "econ_coin_purchase", e.ECON_POWERUPS_MARKETING = "econ_powerups_marketing", e.ECON_POWERUPS_PURCHASE = "econ_powerups_purchase", e.ECON_TOP_AWARDERS = "econ_top_awarders", e.EDIT_SUBREDDIT_CHAT = "edit_subreddit_chat", e.ENABLE_TWO_FACTOR = "enable_2fa_modal", e.GOLD_GILD_ANIMATION_OVERLAY = "gold_gild_animation_overlay", e.GOLD_GILD_MODAL = "gold_gild_modal", e.GOLD_TARGETED_OFFER_MODAL = "gold_targeted_offer", e.GOOGLE_ONE_TAP_MODAL_ID = "google_one_tap_modal_id", e.GOVERNANCE_OPT_OUT = "governance_opt_out", e.GOVERNANCE_RELEASE_NOTES = "governance_release_notes", e.HARBERGER_TAX_CRYPTO_BANNER_MANAGE = "harberger_tax_crypto_banner_manage", e.HARBERGER_TAX_CRYPTO_BANNER_PURCHASE = "hargerger_tax_crypto_banner_purchase", e.HARBERGER_TAX_BANNER_MANAGE = "harberger_tax_banner_manage", e.HARBERGER_TAX_BANNER_PURCHASE = "harberger_tax_banner_purchase", e.KEYBOARD_SHORTCUTS = "keyboard_shortcuts", e.LINK_APPLE_SSO = "link_apple_sso", e.LINK_GOOGLE_SSO = "link_google_sso", e.LOGIN_MODAL_ID = "account_manager_login", e.MANAGE_SUBREDDIT_CHAT = "manage_subreddit_chat", e.MOD_TO_MEMBER_SHARE = "mod_to_member_share", e.CROWD_CONTROL = "crowd_control", e.MULTIREDDIT_ADD_SUBREDDIT = "multireddit_add_subreddit", e.MULTIREDDIT_CREATE = "multireddit_create", e.MULTIREDDIT_DUPLICATE = "multireddit_duplicate", e.MULTIREDDIT_EDIT = "multireddit_edit", e.MUTE_USER = "mute_user", e.PINNED_POSTS_LIMIT_REACHED = "pinned_posts_limit_reached", e.REDESIGN_MODAL = "redesign_modal", e.REGISTER_MODAL_ID = "account_manager_register", e.SPEZ_MODAL = "spez_modal", e.SUBREDDIT_CHAT_SETTINGS = "subreddit_chat_settings", e.SUBREDDIT_PREMIUM_BADGE_MANAGEMENT = "subreddit_premium_badge_management", e.SUBREDDIT_PREMIUM_GIFT_MODAL = "subreddit_premium_gift", e.SUBREDDIT_PREMIUM_PURCHASE_MODAL = "subreddit_premium_purchase", e.SUBREDDIT_PREMIUM_UPLOAD_MODAL = "subreddit_premium_upload", e.TRANSFER_POINTS = "community_points_transfer", e.TWO_FACTOR_BACKUP_CODES = "two_factor_backup_codes", e.UNLINK_APPLE_SSO = "unlink_apple_sso", e.UNLINK_GOOGLE_SSO = "unlink_google_sso", e.USER_FLAIR_MODAL_ID = "user_flair_modal", e.WALLET_REGISTRATION_MODAL = "wallet_registration_modal"
				}(n || (n = {}));
			const r = [n.GOOGLE_ONE_TAP_MODAL_ID]
		},
		"./src/reddit/constants/preferences.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			}));
			const n = "rpanDuDismissalTime",
				r = "showRpanDu",
				a = "topContentDismissalTime",
				i = "topContentTimesDismissed",
				o = [...["openPostInNewTab", "rememberCommunitySort", "sort", "stylesEnabled", "useMarkdown", "layout", "rememberCommunityLayout", "hasSeenCustomizeFlyout", "reduceAnimationsFromAwards", n, r, a, i, "surveyLastSeenTime"], "activityRelevantAds", "thirdPartyDataPersonalizedAds", "thirdPartySiteDataPersonalizedAds", "thirdPartySiteDataPersonalizedContent", "showLocationBasedRecommendations"]
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, s) {
			"use strict";
			var n, r;
			s.d(t, "d", (function() {
					return n
				})), s.d(t, "c", (function() {
					return r
				})), s.d(t, "b", (function() {
					return a
				})), s.d(t, "a", (function() {
					return i
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue"
				}(n || (n = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(r || (r = {}));
			const a = "SHORTCUT_FOCUSABLE_DIV",
				i = [9, 13, 32]
		},
		"./src/reddit/constants/thumbnails.ts": function(e, t, s) {
			"use strict";
			var n;
			! function(e) {
				e.NSFW = "nsfw", e.SELF = "self", e.IMAGE = "image", e.DEFAULT = "default", e.SPOILER = "spoiler"
			}(n || (n = {})), t.a = n
		},
		"./src/reddit/constants/tracking.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = {
					CLICK: "click",
					CLOSE: "close",
					COMPLETE: "complete",
					DISABLE: "disable",
					DRAG: "drag",
					ENABLE: "enable",
					REJECT: "reject",
					SELECT: "select",
					START: "start",
					STOP: "stop",
					VIEW: "view"
				},
				r = {
					POST: "post",
					SCREEN: "screen"
				},
				a = "media-element"
		},
		"./src/reddit/constants/video.ts": function(e, t, s) {
			"use strict";
			s.d(t, "k", (function() {
				return n
			})), s.d(t, "l", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "i", (function() {
				return u
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "h", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "j", (function() {
				return O
			}));
			const n = 250,
				r = 500,
				a = 25,
				i = 50,
				o = 75,
				c = 95,
				d = 100,
				u = [a, i, o, c, d],
				l = 3,
				b = 5,
				p = 10,
				O = [l, b, p]
		},
		"./src/reddit/endpoints/accounts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts"),
				o = s("./src/reddit/constants/headers.ts");
			const c = async (e, t) => Object(a.a)(Object(i.a)(e, [o.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/block_user"),
				method: r.db.POST
			}), d = async (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
				data: {
					name: s,
					container: t,
					type: "enemy"
				},
				endpoint: "".concat(e.apiUrl, "/api/unfriend"),
				method: r.db.POST
			}), u = async (e, t) => Object(a.a)(Object(i.a)(e, [o.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/add_whitelisted?include_model"),
				method: r.db.POST
			}), l = async (e, t) => Object(a.a)(Object(i.a)(e, [o.a]), {
				data: {
					name: t
				},
				endpoint: "".concat(e.apiUrl, "/api/remove_whitelisted"),
				method: r.db.POST
			}), b = async (e, t) => Object(a.a)(Object(i.a)(e, [o.a]), {
				endpoint: "".concat(n.a.oauthUrl, "/user/").concat(t, "/about"),
				method: r.db.GET,
				data: {
					raw_json: 1
				}
			})
		},
		"./src/reddit/endpoints/category/subreddits.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return d
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/constants/headers.ts"),
				o = s("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				c = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = e => {
				const t = [],
					s = [],
					n = {},
					r = {};
				return e.data.children.forEach(e => {
					let {
						data: a
					} = e;
					const i = Object(o.a)(a);
					t.push(i.id), s.push(i.name), n[i.id] = i, r[i.id] = {
						accountsActive: a.accounts_active,
						allOriginalContent: a.all_original_content,
						bannerBackgroundColor: a.banner_background_color,
						bannerBackgroundImage: a.banner_background_image,
						contentCategory: a.content_category,
						allowChatPostCreation: a.allow_chat_post_creation,
						keyColor: a.key_color,
						originalContentTagEnabled: a.original_content_tag_enabled,
						publicDescription: a.public_description,
						subscribers: a.subscribers,
						userIsSubscriber: a.user_is_subscriber
					}
				}), {
					subredditIds: t,
					subredditNames: s,
					subreddits: n,
					subredditsAboutInfo: r
				}
			};
			t.a = function(e, t) {
				let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
				return Object(r.a)(Object(a.a)(e, [i.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/subreddits_in_category.json?category_id=").concat(t, "&limit=").concat(s)),
					method: n.db.GET
				})
			}
		},
		"./src/reddit/endpoints/chat/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "i", (function() {
				return p
			})), s.d(t, "d", (function() {
				return O
			})), s.d(t, "f", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "h", (function() {
				return m
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "g", (function() {
				return E
			})), s.d(t, "j", (function() {
				return I
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts"),
				o = s("./src/reddit/constants/headers.ts");
			const c = "api/v1",
				d = "".concat(c, "/sendbird");
			var u;
			! function(e) {
				e.PUBLIC = "all"
			}(u || (u = {}));
			const l = 10,
				b = 10;
			class ChatEndpointError extends Error {
				constructor(e, t) {
					super(e), this.response = t
				}
			}
			const p = async (e, t, s) => {
				const d = {};
				return s && (d.public_mode = u.PUBLIC), Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(c, "/subreddit/").concat(t, "/channels"),
					method: r.db.GET,
					data: d
				})
			}, O = async (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
				endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(c, "/subreddit/channels/create"),
				method: r.db.POST,
				data: JSON.stringify({
					room: s.room,
					room_type: s.roomType,
					description: s.description,
					subreddit: s.subreddit,
					automute_account_age_threshold: s.minimumAcctAge,
					automute_on_join_duration: s.newMemberAge
				})
			}), g = async (e, t, s, d) => Object(a.a)(Object(i.a)(e, [o.a]), {
				endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(c, "/subreddit/channels/").concat(t),
				method: r.db.PUT,
				data: JSON.stringify({
					room: d.room,
					description: d.description,
					automute_account_age_threshold: d.minimumAcctAge,
					automute_on_join_duration: d.newMemberAge
				})
			}), f = async (e, t) => Object(a.a)(Object(i.a)(e, [o.a]), {
				endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(c, "/subreddit/channels/").concat(t),
				method: r.db.DELETE
			}), m = async e => Object(a.a)(Object(i.a)(e, [o.a]), {
				endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(d, "/config"),
				method: r.db.GET
			});
			var j, _;

			function h(e) {
				const t = {
					bannedWords: e.profanity_filter && e.profanity_filter.keywords,
					regexes: e.profanity_filter && e.profanity_filter.regex_filters,
					rateLimit: e.user_messages_per_channel,
					domains: e.domain_filter && e.domain_filter.domains && e.domain_filter.domains.join(", "),
					useDefaultProfanityFilter: e.profanity_filter && e.profanity_filter.should_check_global,
					domainFilterOption: void 0
				};
				if (!1 === e.allow_links) t.domainFilterOption = _.BLOCK_ALL_DOMAINS;
				else {
					const {
						domain_filter: {
							type: s
						} = {
							type: void 0
						}
					} = e;
					s === j.BLOCK_MODE ? t.domainFilterOption = _.BLOCK_BANNED_DOMAINS : s === j.ALLOW_MODE ? t.domainFilterOption = _.ALLOW_APPROVED_DOMAINS : t.domainFilterOption = _.ALLOW_ALL_DOMAINS
				}
				return t
			}

			function y(e) {
				const t = {};
				return e.rateLimit && e.rateLimit > 0 && (t.user_messages_per_channel = e.rateLimit, t.user_messages_per_channel_duration = b), void 0 === e.bannedWords && void 0 === e.regexes && void 0 === e.useDefaultProfanityFilter || (t.profanity_filter = {
					keywords: e.bannedWords,
					regex_filters: e.regexes,
					should_check_global: e.useDefaultProfanityFilter
				}), e.domainFilterOption === _.BLOCK_ALL_DOMAINS ? (t.allow_links = !1, t.domain_filter = {
					type: j.DISABLE
				}) : e.domainFilterOption === _.ALLOW_ALL_DOMAINS ? (t.allow_links = !0, t.domain_filter = {
					type: j.DISABLE
				}) : e.domainFilterOption === _.ALLOW_APPROVED_DOMAINS && e.domains ? (t.allow_links = !0, t.domain_filter = {
					type: j.ALLOW_MODE,
					domains: e.domains.split(",")
				}) : e.domainFilterOption === _.BLOCK_BANNED_DOMAINS && e.domains && (t.allow_links = !0, t.domain_filter = {
					type: j.BLOCK_MODE,
					domains: e.domains.split(",")
				}), t
			}
			async function E(e, t) {
				const s = await Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(c, "/chat/subreddit/").concat(t, "/settings"),
					method: r.db.GET
				});
				if (s.ok && s.body) return h(s.body)
			}
			async function I(e, t, s) {
					const d = await Object(a.a)(Object(i.a)(e, [o.a]), {
						endpoint: "".concat(n.a.sendbirdServiceUrl, "/").concat(c, "/chat/subreddit/").concat(t, "/settings"),
						method: r.db.PUT,
						data: JSON.stringify(y(s))
					});
					if (d.ok && d.body) return Object.assign(Object.assign({}, d), {
						body: h(d.body)
					});
					throw new ChatEndpointError("Failed to update subreddit chat settings", d)
				}! function(e) {
					e[e.BLOCK_MODE = 2] = "BLOCK_MODE", e[e.ALLOW_MODE = 1] = "ALLOW_MODE", e[e.DISABLE = 0] = "DISABLE"
				}(j || (j = {})),
				function(e) {
					e.ALLOW_ALL_DOMAINS = "Allow all domains", e.ALLOW_APPROVED_DOMAINS = "Allow links to approved domains", e.BLOCK_BANNED_DOMAINS = "Block links to banned domains", e.BLOCK_ALL_DOMAINS = "Block all domains"
				}(_ || (_ = {}))
		},
		"./src/reddit/endpoints/crowdControl/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return i
			}));
			var n, r = s("./src/graphql/operations/CrowdControlLevelInfo.json"),
				a = s("./src/lib/makeGqlRequest/index.ts");
			! function(e) {
				e.Off = "OFF", e.Lenient = "LENIENT", e.Medium = "MEDIUM", e.Strict = "STRICT"
			}(n || (n = {}));
			const i = (e, t) => Object(a.a)(e, Object.assign(Object.assign({}, r), {
				variables: {
					postId: t
				}
			}))
		},
		"./src/reddit/endpoints/flair/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "i", (function() {
				return l
			})), s.d(t, "l", (function() {
				return b
			})), s.d(t, "k", (function() {
				return p
			})), s.d(t, "j", (function() {
				return O
			})), s.d(t, "f", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "c", (function() {
				return h
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts"),
				o = s("./src/reddit/constants/headers.ts"),
				c = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t, s, n, c, d) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(s, "/api/selectflair"),
					method: r.db.POST,
					data: {
						api_type: "json",
						flair_template_id: n,
						name: t,
						text: c,
						css_class: d
					}
				}),
				u = (e, t, s, n) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/selectflair"),
					method: r.db.POST,
					data: {
						api_type: "json",
						flair_template_id: s,
						link: t,
						text: n
					}
				}),
				l = (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(s, "/api/setflairenabled"),
					method: r.db.POST,
					data: {
						api_type: "json",
						flair_enabled: t
					}
				}),
				b = async (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_user_flair.json"),
					method: r.db.POST,
					data: {
						subreddit: t,
						enabled: s
					}
				}), p = async (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_link_flair.json"),
					method: r.db.POST,
					data: {
						subreddit: t,
						enabled: s
					}
				}), O = async (e, t, s, n) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/enable_sr_user_flair_self_assign.json"),
					method: r.db.POST,
					data: {
						subreddit: n,
						flair_type: s,
						enabled: t
					}
				}), g = async (e, t, s, n) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/flairtemplate_v2"),
					method: r.db.POST,
					data: {
						allowable_content: t.allowableContent,
						css_class: t.cssClass,
						flair_template_id: t.id,
						text: t.text,
						text_editable: t.textEditable,
						flair_type: n,
						text_color: t.textColor,
						background_color: t.backgroundColor,
						max_emojis: t.maxEmojis,
						mod_only: t.modOnly,
						r: s
					}
				}), f = async (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/deleteflairtemplate"),
					method: r.db.POST,
					data: {
						flair_template_id: t,
						r: s
					}
				}), m = async (e, t, s, n) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/flair_template_order/").concat(s),
					method: r.db.PATCH,
					type: "json",
					data: n
				}), j = async (e, t) => Object(a.a)(e, {
					endpoint: "".concat(n.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t, "/userFlair"),
					method: r.db.GET,
					headers: {
						[o.a]: o.a
					}
				}), _ = async (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/r/").concat(s, "/api/deleteflair"),
					method: r.db.POST,
					data: {
						api_type: "json",
						name: t
					}
				}), h = async (e, t) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: Object(c.a)("".concat(e.apiUrl, "/api/top_flair_in_subreddit.json?subreddit=").concat(t)),
					method: r.db.GET
				})
		},
		"./src/reddit/endpoints/gold/communityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return I
			})), s.d(t, "p", (function() {
				return v
			})), s.d(t, "a", (function() {
				return S
			})), s.d(t, "c", (function() {
				return T
			})), s.d(t, "b", (function() {
				return w
			})), s.d(t, "k", (function() {
				return C
			})), s.d(t, "l", (function() {
				return A
			})), s.d(t, "j", (function() {
				return D
			})), s.d(t, "n", (function() {
				return P
			})), s.d(t, "o", (function() {
				return R
			})), s.d(t, "f", (function() {
				return k
			})), s.d(t, "g", (function() {
				return x
			})), s.d(t, "m", (function() {
				return N
			})), s.d(t, "h", (function() {
				return L
			})), s.d(t, "i", (function() {
				return U
			})), s.d(t, "e", (function() {
				return M
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/makeGqlRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts"),
				o = s("./src/lib/uploadToS3/index.ts"),
				c = s("./src/graphql/operations/AwardSheetInfo.json"),
				d = s("./src/graphql/operations/AwardSheetInfoForProfile.json"),
				u = s("./src/graphql/operations/CreateCommunityAward.json"),
				l = s("./src/graphql/operations/CreateGlobalAward.json"),
				b = s("./src/graphql/operations/CreateModAward.json"),
				p = s("./src/graphql/operations/DisableAwardInCommunity.json"),
				O = s("./src/graphql/operations/EnableAwardInCommunity.json"),
				g = s("./src/graphql/operations/GlobalAwards.json"),
				f = s("./src/graphql/operations/ManageableAwards.json"),
				m = s("./src/graphql/operations/ManageableAwardsForProfile.json"),
				j = s("./src/graphql/operations/RemoveCommunityAward.json"),
				_ = s("./src/graphql/operations/UsableAwards.json"),
				h = s("./src/graphql/operations/UsableAwardsForProfile.json"),
				y = s("./src/reddit/constants/headers.ts"),
				E = s("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const I = (e, t, s, a) => {
					const o = {
						subreddit: t,
						filepath: s,
						mimetype: a
					};
					return Object(r.a)(Object(i.a)(e, [y.a]), {
						method: n.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/v1/community_awards/award_asset_upload_s3"),
						data: o
					})
				},
				v = async (e, t) => Object(o.a)(t, e), S = (e, t, s, n, r, i, o, c, d) => Object(a.a)(e, Object.assign(Object.assign({}, u), {
					variables: {
						coinPrice: o,
						iconHeight: i,
						iconWidth: r,
						iconUrl: n,
						name: s,
						subredditId: t,
						startsAt: c,
						endsAt: d
					}
				})), T = (e, t, s, n, r, i, o, c, d) => Object(a.a)(e, Object.assign(Object.assign({}, b), {
					variables: {
						iconHeight: i,
						iconWidth: r,
						iconUrl: n,
						monthsOfPremium: o,
						name: s,
						subredditId: t,
						startsAt: c,
						endsAt: d
					}
				})), w = e => {
					let {
						awardSubType: t,
						coinPrice: s,
						coinReward: n,
						context: r,
						daysOfDripExtension: i,
						daysOfPremium: o,
						description: c,
						endsAt: d,
						giverCoinReward: u,
						iconFormat: b,
						iconHeight: p,
						iconUrl: O,
						iconWidth: g,
						isNew: f,
						name: m,
						pennyPrice: j,
						pennyDonate: _,
						startsAt: h,
						subredditCoinReward: y
					} = e;
					return Object(a.a)(r, Object.assign(Object.assign({}, l), {
						variables: {
							awardSubType: t,
							iconFormat: b,
							iconHeight: p,
							iconWidth: g,
							iconUrl: O,
							isNew: f,
							daysOfPremium: o,
							daysOfDripExtension: i,
							description: c,
							coinPrice: s,
							coinReward: n,
							name: m,
							pennyPrice: j,
							pennyDonate: _,
							giverCoinReward: u,
							startsAt: h,
							endsAt: d,
							subredditCoinReward: y
						}
					}))
				}, C = (e, t) => Object(a.a)(e, Object.assign(Object.assign({}, f), {
					variables: {
						subredditId: t
					}
				})), A = (e, t) => Object(a.a)(e, Object.assign(Object.assign({}, m), {
					variables: {
						profileName: t
					}
				})), D = e => Object(a.a)(e, Object.assign({}, g)), P = (e, t, s) => Object(a.a)(e, Object.assign(Object.assign({}, _), {
					variables: {
						subredditId: t,
						includeAppreciation: !0,
						includePremium: !0,
						includeGroup: s
					}
				})), R = (e, t, s) => Object(a.a)(e, Object.assign(Object.assign({}, h), {
					variables: {
						profileName: t,
						includeAppreciation: !0,
						includePremium: !0,
						includeGroup: s
					}
				})), k = (e, t, s, n) => Object(a.a)(e, Object.assign(Object.assign({}, c), {
					variables: {
						subredditId: t,
						thingId: s,
						includeGroup: n
					}
				})), x = (e, t, s, n) => Object(a.a)(e, Object.assign(Object.assign({}, d), {
					variables: {
						profileName: t,
						thingId: s,
						includeGroup: n
					}
				})), N = (e, t) => Object(a.a)(e, Object.assign(Object.assign({}, j), {
					variables: {
						awardId: t
					}
				})), L = (e, t, s) => Object(a.a)(e, Object.assign(Object.assign({}, p), {
					variables: {
						awardId: t,
						subredditId: s
					}
				})), U = (e, t, s) => Object(a.a)(e, Object.assign(Object.assign({}, O), {
					variables: {
						awardId: t,
						subredditId: s
					}
				})), M = async (e, t, s) => {
					const a = {
						api_type: "json",
						award_id: t,
						raw_json: 1
					};
					return Object(r.a)(Object(i.a)(e, [y.a]), {
						method: n.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/report_award"),
						data: a
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign(Object.assign({}, e), {
						error: Object(E.a)(e)
					}))
				}
		},
		"./src/reddit/endpoints/gold/paypalPurchases.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "e", (function() {
				return O
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/constants/headers.ts"),
				o = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = s("./src/reddit/endpoints/gold/purchase.ts");
			const d = async e => {
				let {
					buttonId: t,
					context: s,
					correlationId: d
				} = e;
				const u = {
						button_id: t,
						correlation_id: d
					},
					l = "".concat(s.apiUrl, "/api/v2/gold/paypal/initiate_premium_payment"),
					b = Object(o.a)(l);
				return Object(r.a)(Object(a.a)(s, [i.a]), {
					method: n.db.POST,
					endpoint: b,
					data: u
				}).then(c.c)
			}, u = async e => {
				let {
					context: t,
					coins: s,
					pennies: o,
					correlationId: d
				} = e;
				const u = {
					coins: s,
					pennies: o,
					correlation_id: d
				};
				return Object(r.a)(Object(a.a)(t, [i.a]), {
					method: n.db.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/create_coin_purchase_order"),
					data: u
				}).then(c.c)
			}, l = async e => {
				let {
					context: t,
					awardId: s,
					pennies: o,
					thingId: d,
					correlationId: u
				} = e;
				const l = {
					award_id: s,
					correlation_id: u,
					pennies: o,
					thing_id: d
				};
				return Object(r.a)(Object(a.a)(t, [i.a]), {
					method: n.db.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/create_award_purchase_order"),
					data: l
				}).then(c.c)
			}, b = async e => {
				let {
					context: t,
					offerContext: s,
					orderId: o,
					coins: d,
					pennies: u,
					correlationId: l
				} = e;
				const b = {
					offer_context: s,
					order_id: o,
					coins: d,
					pennies: u,
					correlation_id: l
				};
				return Object(r.a)(Object(a.a)(t, [i.a]), {
					method: n.db.POST,
					endpoint: "".concat(t.apiUrl, "/api/v2/gold/paypal/execute_coin_order"),
					data: b
				}).then(c.c)
			}, p = async e => {
				let {
					awardId: t,
					context: s,
					coins: o,
					correlationId: d,
					isAnonymous: u,
					message: l,
					offerContext: b,
					orderId: p,
					pennies: O,
					thingId: g
				} = e;
				const f = {
					award_id: t,
					coins: o,
					correlation_id: d,
					is_anonymous: u,
					message: l,
					offer_context: b,
					order_id: p,
					pennies: O,
					thing_id: g
				};
				return Object(r.a)(Object(a.a)(s, [i.a]), {
					method: n.db.POST,
					endpoint: "".concat(s.apiUrl, "/api/v2/gold/paypal/execute_coin_with_gild_order"),
					data: f
				}).then(c.c)
			}, O = async e => {
				let {
					awardId: t,
					context: s,
					correlationId: o,
					isAnonymous: d,
					message: u,
					orderId: l,
					thingId: b
				} = e;
				const p = {
					award_id: t,
					correlation_id: o,
					is_anonymous: d,
					message: u,
					order_id: l,
					thing_id: b
				};
				return Object(r.a)(Object(a.a)(s, [i.a]), {
					method: n.db.POST,
					endpoint: "".concat(s.apiUrl, "/api/v2/gold/paypal/execute_award_purchase_order"),
					data: p
				}).then(c.c)
			}
		},
		"./src/reddit/endpoints/gold/purchase.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "h", (function() {
				return g
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "b", (function() {
				return m
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/constants/headers.ts"),
				o = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = s("./src/reddit/helpers/genericServerError/index.ts"),
				d = s("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const u = e => e.ok ? e.body.json && e.body.json.errors.length ? Object.assign(Object.assign({}, e), {
					ok: !1,
					error: Object(d.a)(e)
				}) : Object.assign({}, e) : Object.assign(Object.assign({}, e), {
					error: e.error || Object(c.a)()
				}),
				l = async e => {
					let {
						coins: t,
						context: s,
						correlationId: c,
						offerContext: d,
						pennies: l,
						rememberCard: b,
						token: p,
						savedCardId: O
					} = e;
					const g = {
							token: p ? p.id : void 0,
							coins: t,
							offer_context: d,
							pennies: l,
							remember_card: b,
							card_id: O,
							correlation_id: c
						},
						f = "".concat(s.apiUrl, "/api/v2/gold/stripe/buy_coins"),
						m = Object(o.a)(f);
					return Object(r.a)(Object(a.a)(s, [i.a]), {
						method: n.db.POST,
						endpoint: m,
						data: g
					}).then(u)
				}, b = async e => {
					let {
						coins: t,
						context: s,
						correlationId: c,
						gildParams: d,
						isOldReddit: l,
						offerContext: b,
						pennies: p,
						rememberCard: O,
						thingId: g,
						token: f,
						savedCardId: m
					} = e;
					const {
						gildType: j,
						isAnonymous: _,
						message: h
					} = d, y = {
						token: f ? f.id : void 0,
						coins: t,
						offer_context: b,
						pennies: p,
						thing_id: g,
						gild_type: j,
						message: h ? h.trim() : "",
						is_anonymous: _,
						remember_card: O,
						card_id: m,
						correlation_id: c
					}, E = "".concat(s.apiUrl, "/api/v2/gold/stripe/buy_coins_and_gild"), I = l ? E : Object(o.a)(E);
					return Object(r.a)(Object(a.a)(s, [i.a]), {
						method: n.db.POST,
						endpoint: I,
						data: y
					}).then(u)
				}, p = async e => {
					let {
						context: t,
						correlationId: s,
						gildParams: c,
						isOldReddit: d,
						pennies: l,
						rememberCard: b,
						thingId: p,
						token: O,
						savedCardId: g
					} = e;
					const {
						gildType: f,
						isAnonymous: m,
						message: j
					} = c, _ = {
						token: O ? O.id : void 0,
						thing_id: p,
						award_id: f,
						message: j ? j.trim() : "",
						is_anonymous: m,
						pennies: l,
						remember_card: b,
						card_id: g,
						correlation_id: s
					}, h = "".concat(t.apiUrl, "/api/v2/gold/stripe/buy_award"), y = d ? h : Object(o.a)(h);
					return Object(r.a)(Object(a.a)(t, [i.a]), {
						method: n.db.POST,
						endpoint: y,
						data: _
					}).then(u)
				}, O = async e => {
					let {
						context: t,
						correlationId: s,
						pennies: c,
						token: d
					} = e;
					const l = {
							token: d.id,
							pennies: c,
							correlation_id: s
						},
						b = "".concat(t.apiUrl, "/api/v2/gold/stripe/buy_premium_subscription"),
						p = Object(o.a)(b);
					return Object(r.a)(Object(a.a)(t, [i.a]), {
						method: n.db.POST,
						endpoint: p,
						data: l
					}).then(u)
				}, g = async (e, t) => {
					const s = {
						token: t.id
					};
					return Object(r.a)(Object(a.a)(e, [i.a]), {
						method: n.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/update_creditcard"),
						data: s
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign(Object.assign({}, e), {
						error: Object(d.a)(e)
					}))
				}, f = async (e, t) => {
					const s = {
						card_id: t
					};
					return Object(r.a)(Object(a.a)(e, [i.a]), {
						method: n.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/delete_creditcard"),
						data: s
					}).then(e => e.ok ? Object.assign({}, e) : Object.assign(Object.assign({}, e), {
						error: Object(d.a)(e)
					}))
				}, m = async e => Object(r.a)(Object(a.a)(e, [i.a]), {
					method: n.db.GET,
					endpoint: "".concat(e.apiUrl, "/api/v2/gold/stripe/creditcards")
				}).then(e => e.ok ? Object.assign({}, e) : Object.assign(Object.assign({}, e), {
					error: Object(d.a)(e)
				}))
		},
		"./src/reddit/endpoints/governance/badges.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/config.ts"),
				r = s("./src/reddit/endpoints/governance/requester.ts");
			async function a(e, t, s) {
				const a = Object(r.a)(e, {
						headers: {
							"X-HTTP-Method-Override": "GET"
						},
						method: "post",
						endpoint: "".concat(n.a.metaUrl, "/badges/").concat(t),
						data: {
							selected: !0,
							users: s
						}
					}),
					i = await a;
				if (i.ok) {
					const e = {},
						t = {},
						s = i.body;
					return Object.keys(s).forEach(n => {
						const r = s[n];
						t[n] = r, e[r.userId] || (e[r.userId] = []), e[r.userId].push(r.id)
					}), Object.assign(Object.assign({}, i), {
						body: {
							badges: t,
							usersAppliedBadges: e
						}
					})
				}
				return i
			}
			async function i(e, t, s) {
				const a = await Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(n.a.metaUrl, "/badges/").concat(t, "?users=").concat(s)
				});
				if (a.ok) {
					const e = {},
						t = [],
						s = a.body;
					return Object.keys(s).forEach(n => {
						const r = s[n];
						e[n] = r, t.push(r.id)
					}), Object.assign(Object.assign({}, a), {
						body: {
							badges: e,
							userOwnedBadges: t
						}
					})
				}
				return a
			}

			function o(e, t, s) {
				let a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
				return Object(r.a)(e, {
					method: "patch",
					endpoint: "".concat(n.a.metaUrl, "/badges/").concat(t, "/").concat(s),
					data: {
						selected: a
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/community.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(a.a)(e, {
					endpoint: "".concat(n.a.metaUrl, "/communities/").concat(t.subredditId, "/me"),
					method: r.db.GET
				})
			}
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/config.ts"),
				r = (s("./src/reddit/models/Poll/index.ts"), s("./src/reddit/endpoints/governance/requester.ts"));

			function a(e, t, s) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(n.a.metaUrl, "/polls/").concat(t, "?postIds=").concat(s.join(","))
				})
			}
		},
		"./src/reddit/endpoints/governance/products/badges.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			}));
			var n = s("./src/config.ts"),
				r = s("./src/reddit/endpoints/governance/requester.ts");

			function a(e, t) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(n.a.metaUrl, "/products/").concat(t, "?types=badge")
				})
			}

			function i(e, t) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(n.a.metaUrl, "/products/").concat(t, "?types=badge,membership")
				})
			}

			function o(e, t) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: "".concat(n.a.metaUrl, "/orders"),
					data: t
				})
			}

			function c(e, t) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: "".concat(n.a.metaUrl, "/orders"),
					data: {
						currency: "usd",
						price: t.price,
						products: t.products,
						providerArgs: {
							paymentNonce: t.nonce
						},
						providerName: "braintree",
						subredditId: t.subredditId
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/lib/makeApiRequest/index.ts");

			function r(e, t) {
				return Object(n.a)(e, Object.assign({
					type: "json"
				}, t)).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : Object.assign(Object.assign({}, e.body), {
							code: e.status
						}),
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/me/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts");
			const i = e => Object(a.a)(e, {
				endpoint: "".concat(n.a.gatewayUrl, "/desktopapi/v1/me"),
				method: r.db.GET
			})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts"),
				o = s("./src/reddit/constants/headers.ts"),
				c = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t, s) => Object(a.a)(e, {
					endpoint: Object(c.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/").concat(t)),
					method: r.db.GET,
					data: Object.assign({
						moderated_limit: 25
					}, s)
				}),
				u = (e, t, s) => Object(a.a)(Object(i.a)(e, [o.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/modactions/").concat(t),
					method: r.db.POST,
					type: "json",
					data: s
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/constants/headers.ts");
			t.a = async e => Object(r.a)(Object(a.a)(e, [i.a]), {
				endpoint: "".concat(e.apiUrl, "/subreddit_permissions"),
				method: n.db.GET,
				traceRequestName: "get_subreddit_permissions"
			})
		},
		"./src/reddit/endpoints/moderator/structuredStyles.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "f", (function() {
				return b
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			}));
			var n = s("./src/graphql/operations/SubredditPostFlairStyleTemplates.json"),
				r = s("./src/graphql/operations/SubredditStyles.json"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = (s("./src/lib/uploadToS3/index.ts"), s("./src/reddit/constants/headers.ts"));
			s("./src/reddit/helpers/media/index.ts");
			const u = async (e, t, s) => Object(i.a)(Object(c.a)(e, [d.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: a.db.GET,
				data: {
					progressive_images: s
				}
			}), l = async (e, t, s) => Object(i.a)(Object(c.a)(e, [d.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: a.db.PATCH,
				data: s
			}), b = async (e, t) => Object(i.a)(Object(c.a)(e, [d.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/structured_styles/").concat(t),
				method: a.db.DELETE
			}), p = async (e, t, s, n, r) => Object(i.a)(Object(c.a)(e, [d.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/style_asset_upload_s3/").concat(t),
				method: a.db.POST,
				data: {
					filepath: s,
					imagetype: n,
					mimetype: r
				}
			}), O = (e, t) => Object(o.a)(e, Object.assign(Object.assign({}, r), {
				variables: {
					subredditName: t
				}
			})), g = (e, t, s) => Object(o.a)(e, Object.assign(Object.assign({}, n), {
				variables: {
					subredditName: t,
					templateIds: s
				}
			}))
		},
		"./src/reddit/endpoints/page/commentsPage.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				r = s("./src/lib/addQueryParams/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/reddit/models/Comment/addProfileImgParam.ts"),
				c = s("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				d = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			t.a = (e, t, s, u, l, b) => {
				let p = s ? "".concat(n.a.gatewayUrl, "/desktopapi/v1/postcomments/").concat(t, "/").concat(s) : "".concat(n.a.gatewayUrl, "/desktopapi/v1/postcomments/").concat(t);
				return p = Object(c.a)(Object(d.a)(p)), l && (p = Object(o.a)(p)), b && (p = Object(r.a)(p, {
					realtime_comments: !0
				})), Object(i.a)(e, {
					data: u,
					endpoint: p,
					method: a.db.GET,
					traceRequestName: "get_comments_page"
				})
			}
		},
		"./src/reddit/endpoints/page/frontpage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return _
			})), s.d(t, "a", (function() {
				return h
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./src/graphql/operations/Frontpage.json"),
				r = s("./src/lib/base64/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				o = s("./src/lib/performanceTimings/index.tsx"),
				c = s("./src/reddit/constants/graphql.ts"),
				d = s("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				u = s("./src/reddit/models/Post/index.ts"),
				l = s("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				b = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				p = s("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				O = s("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				g = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				f = s("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				m = s("./src/reddit/selectors/platform.ts"),
				j = s("./src/reddit/selectors/user.ts");
			const _ = (e, t) => {
					const {
						after: s,
						dist: n,
						isMobile: a,
						layout: i,
						limit: o,
						sort: u,
						t: l
					} = t, b = Object(j.O)(e), p = Object(m.q)(e), O = {
						recentPostIds: e.posts.recent,
						includeIdentity: b && !e.user.account,
						includeFeatured: !0,
						adContext: {
							layout: i ? i.toUpperCase() : c.a.Card,
							reddaid: e.user.reddaid,
							distance: n
						}
					};
					return u && (O.sort = u.toUpperCase()), l && (O.range = l.toUpperCase()), a ? O.pageSize = Object(d.a)(i) : o && (O.pageSize = o), p && p.ad && (O.forceAds = {
						ad: p.ad
					}), s && (O.after = Object(r.a)(s)), O
				},
				h = async (e, t, s, r) => {
					const c = Date.now(),
						d = await ((e, t) => Object(i.a)(e, Object.assign(Object.assign({}, n), {
							variables: t
						}), {
							traceRequestName: "get_frontpage"
						}))(e, t),
						m = Date.now();
					let j;
					try {
						const e = Date.now();
						j = (e => {
							let {
								trendingSubreddits: t = [],
								identity: s,
								home: n,
								featuredAnnouncements: r,
								featuredLiveEvent: a,
								recentPosts: i = []
							} = e;
							const o = [],
								c = [],
								d = {
									postIds: [],
									postInstances: {},
									posts: {},
									postFlair: {},
									profiles: {},
									subreddits: {}
								},
								m = e => {
									if (d.posts[e.id]) return e.id;
									const t = Object(b.e)(e);
									d.posts[t.id] = t;
									const {
										crosspostRoot: s
									} = e;
									s && s.type === u.a.Post && s.postInfo && m(s.postInfo);
									let n = t.id;
									switch (e.__typename) {
										case u.f.ProfilePost:
											d.profiles[e.profile.id] || (d.profiles[e.profile.id] = Object(O.a)(e.profile));
											break;
										case u.f.SubredditPost:
											d.subreddits[e.subreddit.id] || (d.subreddits[e.subreddit.id] = Object(g.a)(e.subreddit)), d.postFlair[e.subreddit.id] || (d.postFlair[e.subreddit.id] = Object(l.a)(e.subreddit));
											break;
										case u.f.AdPost:
											const s = Object(b.b)(e);
											if (!s) {
												n = null;
												break
											}
											n = s, d.posts[s] = Object.assign(Object.assign({}, t), {
												id: s,
												permalink: "".concat(t.permalink, "?instanceId=").concat(encodeURIComponent(s))
											}), d.posts[t.id] || (d.posts[t.id] = Object.assign(Object.assign({}, t), {
												events: []
											})), d.postInstances[e.id] || (d.postInstances[e.id] = []), d.postInstances[e.id].push(s)
									}
									return n
								};
							for (const u of t) {
								const e = Object(g.a)(u);
								d.subreddits[e.id] = e, o.push(e.id)
							}
							for (const {
									node: u
								} of n.posts.edges) {
								const e = m(u);
								e && d.postIds.push(e)
							}
							for (const u of i) {
								if (!u) continue;
								const e = m(u);
								e && c.push(e)
							}
							const j = d.postIds.length - 1,
								_ = j >= 0 ? d.postIds[j] : "",
								h = n.posts.dist;
							return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, d), {
								account: s && Object(f.a)(s) || null,
								featuredLiveThread: a,
								announcements: r,
								preferences: s && s.preferences && Object(p.a)(s.preferences, s.interactions) || null
							}), 0 !== o.length && {
								trendingSubredditIds: o
							}), 0 !== c.length && {
								recentPostIds: c
							}), {
								token: _
							}), null !== h && {
								dist: h
							})
						})(d.body.data);
						const t = Date.now(),
							n = [{
								duration: m - c,
								logKeyType: o.a.gqlFetchTiming
							}, {
								duration: t - e,
								logKeyType: o.a.gqlNormalizationTiming
							}];
						Object(o.h)({
							name: a.p.FRONTPAGE,
							isLoggedIn: s,
							metrics: n,
							statsdPathsForExperiments: r
						})
					} catch (_) {}
					return Object.assign(Object.assign({}, d), {
						body: j
					})
				}
		},
		"./src/reddit/endpoints/page/multiredditListing.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/graphql/operations/MultiredditListing.json"),
				r = s("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t) => Object(r.a)(e, Object.assign(Object.assign({}, n), {
				variables: t
			}))
		},
		"./src/reddit/endpoints/page/profileOverviewPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/addAllowQuarantinedParam/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const c = (e, t, s) => Object(i.a)(e, {
					data: s,
					endpoint: Object(r.a)(Object(o.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/conversations"))),
					traceRequestName: "get_profile_conversations",
					method: a.db.GET
				}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? Object.assign(Object.assign({}, e), {
					body: Object.assign(Object.assign({}, e.body), {
						pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
					})
				}) : e),
				d = (e, t, s) => Object(i.a)(e, {
					data: s,
					endpoint: Object(r.a)(Object(o.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/overview"))),
					method: a.db.GET
				}).then(e => "pinned" in e.body ? e : "overviewIds" in e.body ? Object.assign(Object.assign({}, e), {
					body: Object.assign(Object.assign({}, e.body), {
						pinned: e.body.overviewIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
					})
				}) : e)
		},
		"./src/reddit/endpoints/page/search.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/search/index.ts"),
				o = s("./src/reddit/helpers/correlationIdTracker.ts"),
				c = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const d = (e, t) => {
				let s = t ? Object.assign(Object.assign({}, e), {
					type: e.restrict_sr ? "link" : e.type
				}) : e;
				(s = s.type ? s : Object.assign(Object.assign({}, s), {
					type: "link,sr,user"
				})).q = Object(i.a)(e.q);
				const n = Object(o.c)(o.a.SearchResults);
				return n && (s.search_correlation_id = n), s
			};
			t.a = (e, t, s, i) => Object(a.a)(e, {
				data: d(i || {}, t),
				endpoint: Object(c.a)(s ? "".concat(n.a.gatewayUrl, "/desktopapi/v1/multireddits/").concat(s, "/").concat(t, "/search") : t ? "".concat(n.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t, "/search") : "".concat(n.a.gatewayUrl, "/desktopapi/v1/search")),
				method: r.db.GET
			})
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return x
			})), s.d(t, "b", (function() {
				return N
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/config.ts"),
				r = s("./src/graphql/operations/SubredditPage.json"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/isAdHocMultireddit/index.ts"),
				o = s("./src/lib/isFakeSubreddit/index.ts"),
				c = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/makeGqlRequest/index.ts"),
				u = s("./src/lib/performanceTimings/index.tsx"),
				l = s("./src/reddit/constants/graphql.ts"),
				b = s("./src/reddit/constants/page.ts"),
				p = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				O = s("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				g = s("./src/reddit/models/Post/index.ts"),
				f = s("./src/reddit/models/RichTextJson/index.ts"),
				m = s("./src/reddit/models/Subreddit/index.ts"),
				j = s("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				_ = s("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				h = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				y = s("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				E = s("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				I = s("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				v = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				S = s("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				T = s("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				w = s("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				C = s("./src/reddit/helpers/graphql/helpers.ts");
			const A = e => {
				switch (e) {
					case m.b.Banned:
						return m.d.BannedSubreddit;
					case m.b.GoldOnly:
						return m.d.GoldSubreddit;
					case m.b.Private:
						return m.d.PrivateSubreddit;
					case m.b.Quarantined:
						return m.d.QuarantinedSubreddit;
					case m.b.Unknown:
						return m.d.ForbiddenSubreddit
				}
			};
			var D = s("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				P = s("./src/reddit/selectors/platform.ts"),
				R = s("./src/reddit/selectors/user.ts"),
				k = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const x = (e, t, s) => {
					const {
						after: n,
						geo_filter: r,
						isMobile: a,
						layout: c,
						limit: d,
						recentPostIds: u,
						sort: p,
						t: g
					} = s, f = Object(R.O)(e), m = Object(P.q)(e), j = Object(i.a)(t), _ = Object(o.a)(t), h = {
						name: t,
						includeIdentity: f && !e.user.account,
						adContext: {
							layout: c ? c.toUpperCase() : l.a.Card,
							reddaid: e.user.reddaid
						},
						isFake: _,
						includeRecents: _ && u && u.length > 0 || !1,
						includeTrending: _,
						isAdHocMulti: j,
						isAll: t === b.c.All,
						isPopular: t === b.c.Popular,
						recentPostIds: u || [],
						subredditNames: j ? t.split("+") : []
					};
					return p && (h.sort = p.toUpperCase()), g && (h.range = g.toUpperCase()), a ? h.pageSize = Object(O.a)(c) : d && (h.pageSize = d), m && m.ad && (h.forceAds = {
						ad: m.ad
					}), (m && m.geo_filter || r) && (h.region = m && m.geo_filter || r), n && (h.after = btoa(n)), h
				},
				N = async (e, t, s) => {
					const n = Date.now(),
						i = await ((e, t) => Object(d.a)(e, Object.assign(Object.assign({}, r), {
							variables: t
						})))(e, t),
						o = Date.now();
					if (!i.ok || !i.body) return i;
					const c = i.body,
						l = Date.now(),
						b = (e => {
							let {
								adhocMultiredditByNames: t,
								all: s,
								identity: n,
								popular: r,
								recentPosts: a,
								subredditInfoByName: i,
								trendingSubreddits: o
							} = e;
							const c = {
								authorFlair: {},
								postIds: [],
								postInstances: {},
								posts: {},
								postFlair: {},
								profiles: {},
								recentPostIds: [],
								structuredStyles: {},
								subredditAboutInfo: {},
								subredditPermissions: {},
								subreddits: {},
								trendingSubredditIds: []
							};
							if (!i) return {
								reason: m.d.NotFoundSubreddit,
								data: {
									account: n && Object(w.a)(n) || null
								}
							};
							if (Object(m.h)(i)) {
								const {
									banMessage: e,
									publicDescriptionText: t,
									quarantineMessage: s,
									isEmailRequiredForQuarantineOptin: r
								} = i;
								return {
									reason: A(i.forbiddenReason),
									data: Object.assign({
										account: n && Object(w.a)(n) || null,
										banMessage: e || void 0,
										description: t,
										quarantineRequiresEmailOptin: r
									}, s ? {
										quarantineMessage: s.markdown,
										quarantineMessageRTJson: Object(C.e)(s.richtext, f.i)
									} : {})
								}
							}
							const d = e => {
									if (e.__typename === g.f.DeletedProfilePost || e.__typename === g.f.DeletedSubredditPost) return null;
									if (c.posts[e.id]) return e.id;
									const t = Object(h.e)(e);
									c.posts[t.id] = t;
									const {
										crosspostRoot: s
									} = e;
									s && s.type === g.a.Post && s.postInfo && d(s.postInfo);
									let n = t.id;
									switch (e.authorFlair && (c.authorFlair[t.belongsTo.id] || (c.authorFlair[t.belongsTo.id] = {}), c.authorFlair[t.belongsTo.id][t.author] = Object(j.a)(e.authorFlair)[0]), e.__typename) {
										case g.f.ProfilePost:
											c.profiles[e.profile.id] || (c.profiles[e.profile.id] = Object(E.a)(e.profile));
											break;
										case g.f.SubredditPost:
											c.subreddits[e.subreddit.id] || (c.subreddits[e.subreddit.id] = Object(v.a)(e.subreddit)), c.postFlair[e.subreddit.id] || (c.postFlair[e.subreddit.id] = Object(_.a)(e.subreddit));
											break;
										case g.f.AdPost:
											const s = Object(h.b)(e);
											if (!s) {
												n = null;
												break
											}
											n = s, c.posts[s] = Object.assign(Object.assign({}, t), {
												id: s,
												permalink: "".concat(t.permalink, "?instanceId=").concat(encodeURIComponent(s))
											}), c.posts[t.id] || (c.posts[t.id] = Object.assign(Object.assign({}, t), {
												events: []
											})), c.postInstances[e.id] || (c.postInstances[e.id] = []), c.postInstances[e.id].push(s)
									}
									return n
								},
								u = i || r || s || t;
							for (const {
									node: O
								} of u.posts.edges) {
								const e = d(O);
								e && c.postIds.push(e)
							}
							i && i.styles && (c.structuredStyles = {
								data: {
									style: Object(T.a)(i.styles)
								}
							});
							const l = c.postIds.length - 1,
								b = l >= 0 ? c.postIds[l] : "",
								p = u.posts.dist;
							if (o) {
								c.trendingSubredditIds = o.map(e => e.id);
								for (const e of o) c.subreddits[e.id] = Object(v.a)(e)
							}
							if (a)
								for (const O of a) {
									const e = d(O);
									e && c.recentPostIds.push(e)
								}
							return Object.assign(Object.assign(Object.assign({}, c), {
								account: n && Object(w.a)(n) || null,
								preferences: n && n.preferences && Object(y.a)(n.preferences, n.interactions) || null,
								subredditAboutInfo: i && Object(I.a)(i),
								subredditPermissions: i && i.modPermissions && Object(S.a)(i.modPermissions),
								token: b
							}), null !== p && {
								dist: p
							})
						})(c.data),
						p = Date.now(),
						O = [{
							duration: o - n,
							logKeyType: u.a.gqlFetchTiming
						}, {
							duration: p - l,
							logKeyType: u.a.gqlNormalizationTiming
						}];
					return Object(u.h)({
						name: a.p.SUBREDDIT,
						isLoggedIn: s,
						metrics: O
					}), Object.assign(Object.assign({}, i), {
						ok: !!c.data.subredditInfoByName && !Object(m.h)(c.data.subredditInfoByName),
						status: L(c.data),
						body: b
					})
				}, L = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(m.h)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === m.b.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === m.b.GoldOnly || e.subredditInfoByName.forbiddenReason === m.b.Private || e.subredditInfoByName.forbiddenReason === m.b.Quarantined) return 403
					}
					return 200
				}, U = e => {
					var {
						recentPostIds: t
					} = e, s = k(e, ["recentPostIds"]);
					return t && t.length ? Object.assign(Object.assign({}, s), {
						recentPostIds: t.join(",")
					}) : s
				};
			t.a = (e, t, s) => Object(c.a)(e, {
				endpoint: Object(p.a)(Object(D.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(t))),
				method: a.db.GET,
				data: s && U(s) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/constants/headers.ts"),
				o = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = s("./src/reddit/models/PostCreationForm/index.ts");
			t.a = (e, t, s) => {
				const d = {
					output_mode: "markdown" === t ? t : "rtjson"
				};
				return t === c.h.MARKDOWN ? d.richtext_json = s : d.markdown_text = s, Object(r.a)(Object(a.a)(e, [i.a]), {
					endpoint: Object(o.a)("".concat(e.apiUrl, "/api/convert_rte_body_format")),
					method: n.db.POST,
					data: d
				})
			}
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return u
			}));
			var n = s("./src/reddit/helpers/flair.ts"),
				r = s("./src/reddit/models/PostDraft/index.ts");
			const a = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				i = e => {
					switch (e.kind) {
						case r.b.Link:
							return "link";
						case r.b.Markdown:
							return "markdown";
						case r.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				o = e => {
					switch (e) {
						case "link":
							return r.b.Link;
						case "markdown":
							return r.b.Markdown;
						case "richtext":
							return r.b.RichText;
						default:
							return "self"
					}
				},
				c = e => e.title.substring(0, 300),
				d = e => {
					switch (e.kind) {
						case r.b.Link:
						case r.b.Markdown:
							return e.body;
						case r.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				u = e => Object.assign(Object.assign(Object.assign(Object.assign({
					id: e.draftId || void 0
				}, (e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {})(e)), {
					kind: i(e),
					title: c(e),
					body: d(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC
				}), (e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(n.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				})(e.flair)), {
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/post/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "h", (function() {
				return g
			})), s.d(t, "u", (function() {
				return f
			})), s.d(t, "j", (function() {
				return m
			})), s.d(t, "w", (function() {
				return j
			})), s.d(t, "l", (function() {
				return _
			})), s.d(t, "k", (function() {
				return h
			})), s.d(t, "x", (function() {
				return y
			})), s.d(t, "q", (function() {
				return E
			})), s.d(t, "m", (function() {
				return I
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "p", (function() {
				return S
			})), s.d(t, "y", (function() {
				return T
			})), s.d(t, "s", (function() {
				return w
			})), s.d(t, "z", (function() {
				return C
			})), s.d(t, "i", (function() {
				return A
			})), s.d(t, "v", (function() {
				return D
			})), s.d(t, "t", (function() {
				return P
			})), s.d(t, "a", (function() {
				return R
			})), s.d(t, "n", (function() {
				return k
			})), s.d(t, "o", (function() {
				return N
			})), s.d(t, "r", (function() {
				return U
			})), s.d(t, "e", (function() {
				return M
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./src/graphql/operations/PostIsTrackingCrossposts.json"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				o = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/reddit/constants/headers.ts"),
				d = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var u = s("./src/reddit/helpers/reportPage/index.ts");
			const l = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/approve")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				b = (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/distinguish/").concat(s)),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				p = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/fetch_title")),
					method: r.db.POST,
					data: {
						url: t,
						api_type: "json"
					}
				}),
				O = (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/follow_post")),
					method: r.db.POST,
					data: {
						follow: s,
						fullname: t
					}
				}),
				g = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/hide")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				f = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/unhide")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				m = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/lock")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				j = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/unlock")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				_ = (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/set_original_content")),
					method: r.db.POST,
					data: {
						fullname: t,
						should_set_oc: s
					}
				}),
				h = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/marknsfw")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/unmarknsfw")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				E = (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/sendreplies"),
					method: r.db.POST,
					data: {
						id: t,
						state: s
					}
				}),
				I = (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/remove")),
					method: r.db.POST,
					data: {
						id: t,
						spam: s
					}
				}),
				v = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/del")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				S = (e, t) => ((e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/save")),
					method: r.db.POST,
					data: {
						id: t
					}
				}))(e, t),
				T = (e, t) => ((e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/unsave")),
					method: r.db.POST,
					data: {
						id: t
					}
				}))(e, t),
				w = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/spoiler")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				C = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/unspoiler")),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				A = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/ignore_reports"),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				D = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/unignore_reports"),
					method: r.db.POST,
					data: {
						id: t
					}
				}),
				P = (e, t, s, n) => Object(a.a)(Object(o.a)(e, [c.a]), {
					endpoint: "".concat(e.apiUrl, "/api/set_subreddit_sticky"),
					method: r.db.POST,
					data: {
						id: t,
						state: s,
						to_profile: n
					}
				});
			var R;
			! function(e) {
				e.Rule = "rule", e.SiteRule = "siteRule", e.Other = "other", e.FileComplaint = "fileComplaint", e.CrisisTextLine = "crisisTextLine"
			}(R || (R = {}));
			const k = (e, t) => Object(a.a)(Object(o.a)(e, [c.a]), {
					method: r.db.POST,
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/report")),
					data: x(t)
				}),
				x = e => {
					const t = Object.assign({
							thing_id: e.id,
							api_type: "json"
						}, e.timestamp && {
							live_stream_relative_report_time_sec: e.timestamp.toString()
						}),
						{
							reportFlowPayload: s
						} = e;
					switch (s.customText && (t.custom_text = s.customText), s.kind) {
						case R.Other:
							return Object.assign(Object.assign({}, t), {
								reason: "other",
								other_reason: s.rule
							});
						case R.Rule:
							return Object.assign(Object.assign({}, t), {
								reason: s.rule,
								rule_reason: s.rule
							});
						case R.SiteRule:
						case R.CrisisTextLine:
						default:
							return Object.assign(Object.assign({}, t), {
								reason: "site_reason_selected",
								site_reason: s.rule
							})
					}
				},
				N = (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					method: r.db.POST,
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/report")),
					data: L(t, s)
				}),
				L = (e, t) => {
					const s = Object(u.b)(e),
						n = Object.assign(Object.assign({}, s), {
							api_type: "json"
						});
					return t && (n.from_help_desk = !0), n
				},
				U = async (e, t, s) => Object(a.a)(Object(o.a)(e, [c.a]), {
					method: r.db.POST,
					endpoint: Object(d.a)("".concat(e.apiUrl, "/api/set_contest_mode/")),
					data: {
						api_type: "json",
						id: s,
						state: t
					}
				}), M = (e, t) => Object(i.a)(e, Object.assign(Object.assign({}, n), {
					variables: t
				}))
		},
		"./src/reddit/endpoints/profile/info.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "b", (function() {
				return p
			}));
			var n = s("./src/graphql/operations/ProfileModHubPage.json"),
				r = s("./src/graphql/operations/RedditorKarma.json"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/reddit/constants/headers.ts");
			const u = (e, t) => Object(i.a)(Object(c.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/about.json"),
					method: a.db.GET,
					data: {
						gilding_detail: 1,
						awarded_detail: 1,
						raw_json: 1
					}
				}),
				l = {
					awardeeKarma: 0,
					awarderKarma: 0,
					commentKarma: 0,
					postKarma: 0,
					totalKarma: 0
				},
				b = (e, t) => Object(o.a)(e, Object.assign(Object.assign({}, r), {
					variables: {
						name: t
					}
				})),
				p = (e, t) => Object(o.a)(e, Object.assign(Object.assign({}, n), {
					variables: {
						name: t
					}
				}))
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return f
			})), s.d(t, "c", (function() {
				return m
			})), s.d(t, "e", (function() {
				return j
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "d", (function() {
				return y
			})), s.d(t, "h", (function() {
				return E
			})), s.d(t, "i", (function() {
				return I
			})), s.d(t, "j", (function() {
				return v
			})), s.d(t, "k", (function() {
				return A
			})), s.d(t, "a", (function() {
				return D
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./node_modules/lodash/omit.js"),
				a = s.n(r),
				i = s("./src/config.ts"),
				o = s("./src/lib/addQueryParams/index.ts"),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/constants/headers.ts"),
				u = s("./src/lib/makeRequest/index.ts"),
				l = s("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				b = s("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				p = s("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				O = s("./src/reddit/models/PostCreationForm/index.ts"),
				g = s("./src/reddit/models/Vote/index.ts");
			const f = async e => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/rpan_config_v1"),
				method: c.db.GET,
				headers: a()(e.headers(), [d.c, d.b]),
				timeoutMs: void 0
			}).then(w), m = async (e, t) => {
				let s;
				return s = t === l.R ? "/config" : "/".concat(t, "/config"), Object(u.b)({
					endpoint: "".concat(i.a.streamingApiUrl).concat(s),
					method: c.db.GET,
					headers: a()(e.headers(), [d.c, d.b]),
					timeoutMs: void 0
				}).then(w)
			}, j = async (e, t) => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/videos/").concat(t),
				method: c.db.GET,
				headers: a()(e.headers(), [d.c, d.b])
			}).then(w), _ = async e => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/videos"),
				method: c.db.GET,
				headers: a()(e.headers(), [d.c, d.b])
			}).then(w), h = async (e, t, s) => {
				let n;
				n = t === l.R ? "/broadcasts" : "/".concat(t, "/broadcasts");
				const r = Object(o.a)(n, {
					cursor: null == s ? void 0 : s.cursor,
					page_size: null == s ? void 0 : s.pageSize
				});
				return Object(u.b)({
					endpoint: "".concat(i.a.streamingApiUrl).concat(r),
					method: c.db.GET,
					headers: a()(e.headers(), [d.c, d.b])
				}).then(w)
			}, y = async e => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/recommended_viewer_subreddits"),
				method: c.db.GET,
				headers: a()(e.headers(), [d.c, d.b])
			}).then(w), E = async (e, t, s) => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/videos/").concat(t, "/vote/").concat(C(s)),
				method: c.db.POST,
				headers: a()(e.headers, [d.c, d.b])
			}).then(w), I = async (e, t) => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/videos/").concat(t, "/heartbeat"),
				method: c.db.POST,
				headers: a()(e.headers(), [d.c, d.b])
			}).then(w), v = async (e, t, s, n) => {
				const r = s.rteState;
				if (!r) return Promise.reject(new Error("Editor state is undefined"));
				const a = b.a.getRawText(r);
				return a ? S(e, t, a).then(e => e.ok && e.body && e.body.data ? Object.assign(Object.assign({}, e), {
					body: {
						parentId: t,
						comment: Object.assign(Object.assign({}, Object(p.a)(e.body.data.r2_comment, n)), {
							media: T(r)
						}),
						automuteLevel: e.body.data.auto_mute_status.level
					},
					error: void 0
				}) : e) : Promise.reject(new Error("Cannot send empty message"))
			}, S = async (e, t, s) => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/broadcasts/").concat(t, "/comment_v2"),
				method: c.db.POST,
				headers: a()(e.headers, [d.c, d.b]),
				data: {
					text: s
				},
				type: "json"
			}).then(w), T = e => ({
				type: "rtjson",
				richtextContent: {
					document: b.a.toRichTextJSON(e).document
				},
				rteMode: O.h.RICH_TEXT
			}), w = e => {
				if (e.ok) return Object.assign(Object.assign({}, e), {
					error: void 0
				}); {
					const t = {
						type: 404 === e.status ? c.E.NOT_FOUND_ERROR : c.E.SERVER_ERROR
					};
					return 429 === e.status && (t.fields = [{
						field: "",
						msg: n.fbt._("Try again later", null, {
							hk: "3BBLIU"
						})
					}]), Object.assign(Object.assign({}, e), {
						error: t
					})
				}
			}, C = e => e === g.a.upvoted ? "up" : e === g.a.downvoted ? "down" : "unset", A = async (e, t, s) => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/broadcasts/").concat(t),
				method: c.db.PUT,
				headers: a()(e.headers, [d.c, d.b]),
				data: {
					data: {
						chat_disabled: s
					}
				},
				type: "json"
			}).then(w), D = async (e, t) => Object(u.b)({
				endpoint: "".concat(i.a.streamingApiUrl, "/broadcasts/").concat(t, "/auto_mute_status"),
				method: c.db.GET,
				headers: a()(e.headers, [d.c, d.b])
			}).then(w)
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/graphql/operations/SubredditAbout.json"),
				r = s("./src/lib/makeGqlRequest/index.ts");
			t.a = (e, t, s) => Object(r.a)(e, Object.assign(Object.assign({}, n), {
				variables: {
					subredditName: t,
					includeSubreddit: s
				}
			}))
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return f
			})), s.d(t, "c", (function() {
				return m
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "d", (function() {
				return y
			})), s.d(t, "e", (function() {
				return I
			}));
			var n = s("./node_modules/lodash/camelCase.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/mapKeys.js"),
				i = s.n(a),
				o = s("./src/graphql/operations/SubredditRules.json"),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/makeApiRequest/index.ts"),
				u = s("./src/lib/makeGqlRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				b = s("./src/reddit/constants/headers.ts"),
				p = s("./src/reddit/helpers/graphql/helpers.ts"),
				O = s("./src/reddit/models/Rule/index.ts");
			const g = e => {
					let {
						rules: t
					} = e;
					return {
						rules: t.map(e => Object.assign(Object.assign({}, i()(e, (e, t) => r()(t))), {
							kind: "link" === e.kind ? "post" : e.kind
						}))
					}
				},
				f = (e, t) => Object(u.a)(e, Object.assign(Object.assign({}, o), {
					variables: {
						subredditName: t
					}
				})).then(e => (e.ok && e.body && (e.body = (e => {
					return {
						rules: (e.data.subreddit && e.data.subreddit.rules || []).map(e => ({
							kind: O.c[e.kind],
							description: e.content.markdown,
							descriptionRichText: e.content.richtext,
							shortName: e.name,
							violationReason: e.violationReason || "",
							createdUtc: Object(p.d)(e.createdAt, p.a.Millis),
							priority: e.priority
						}))
					}
				})(e.body)), e)),
				m = (e, t) => Object(d.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/user/").concat(t, "/about/rules.json"),
					method: c.db.GET
				}).then(e => (e.ok && e.body.rules && (e.body = g(e.body)), e)),
				j = e => e.ok ? (e.body = Object(O.h)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				_ = async (e, t, s) => Object(d.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/add_subreddit_rule"),
					method: c.db.POST,
					data: {
						r: t,
						short_name: s.rule,
						kind: s.kind === O.b.post ? "link" : s.kind,
						violation_reason: s.reason,
						description: s.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e)), h = async (e, t, s, n) => Object(d.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/update_subreddit_rule"),
					method: c.db.POST,
					data: {
						r: t,
						short_name: s.rule,
						kind: s.kind === O.b.post ? "link" : s.kind,
						violation_reason: s.reason,
						description: s.description,
						old_short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e)), y = async (e, t, s) => Object(d.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/remove_subreddit_rule"),
					method: c.db.POST,
					data: {
						r: t,
						short_name: s,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e)), E = e => e.map(e => encodeURIComponent(e)).join(), I = async (e, t, s) => Object(d.a)(Object(l.a)(e, [b.a]), {
					endpoint: "".concat(e.apiUrl, "/api/reorder_subreddit_rules"),
					method: c.db.POST,
					data: {
						r: t,
						new_rule_order: E(s),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => j(e))
		},
		"./src/reddit/endpoints/subreddit/settings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "g", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				o = s("./src/reddit/constants/headers.ts");
			const c = (e, t, s) => Object(r.a)(Object(a.a)(e, [o.a]), {
					method: n.db.POST,
					endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/delete_sr_").concat(s),
					data: {
						raw_json: 1
					}
				}),
				d = (e, t) => Object(r.a)(Object(a.a)(e, [o.a]), {
					method: n.db.GET,
					endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/about/edit.json"),
					data: {
						raw_json: 1
					}
				}).then(e => e.ok ? Object.assign(Object.assign({}, e), {
					body: Object.assign({}, b(e.body.data))
				}) : e),
				u = (e, t, s) => Object(r.a)(Object(a.a)(e, [o.a]), {
					method: n.db.PATCH,
					endpoint: Object(i.a)("".concat(e.apiUrl, "/api/v1/subreddit/update_settings")),
					type: "json",
					data: Object.assign(Object.assign({}, p(s, g)), {
						sr: t
					})
				}),
				l = (e, t, s) => {
					const i = Object.assign(Object.assign({}, O(s)), {
						sr: t
					});
					return Object(r.a)(Object(a.a)(e, [o.a]), {
						method: n.db.POST,
						endpoint: "".concat(e.apiUrl, "/api/site_admin"),
						data: i
					})
				},
				b = e => ({
					allowChatPostCreation: e.allow_chat_post_creation,
					allowDiscovery: e.allow_discovery,
					allowGalleries: e.allow_galleries,
					allowImages: e.allow_images,
					allowPolls: e.allow_polls,
					allowPostCrossposts: e.allow_post_crossposts,
					collapseDeletedComments: e.collapse_deleted_comments,
					commentScoreHideMins: e.comment_score_hide_mins,
					contentOptions: e.content_options,
					contentVisible: e.default_set,
					crowdControlMode: e.crowd_control_mode,
					crowdControlChatLevel: e.crowd_control_chat_level,
					crowdControlLevel: e.crowd_control_level,
					description: e.description,
					disableContributorRequests: e.disable_contributor_requests,
					domain: e.domain,
					excludeBannedModqueue: e.exclude_banned_modqueue,
					headerHoverText: e.header_hover_text,
					hideAds: e.hide_ads,
					isChatPostFeatureEnabled: e.is_chat_post_feature_enabled,
					keyColor: e.key_color,
					language: e.language,
					liveStreamingIsEnabled: e.live_streaming_is_enabled,
					newPinnedPostPNsEnabled: e.new_pinned_post_pns_enabled,
					over18: e.over_18,
					publicDescription: e.public_description,
					publicTraffic: e.public_traffic,
					restrictCommenting: e.restrict_commenting,
					restrictPosting: e.restrict_posting,
					showMedia: e.show_media,
					showMediaPreview: e.show_media_preview,
					spamComments: e.spam_comments,
					spamLinks: e.spam_links,
					spamSelfposts: e.spam_selfposts,
					spoilersEnabled: e.spoilers_enabled,
					submitLinkLabel: e.submit_link_label,
					submitText: e.submit_text,
					submitTextLabel: e.submit_text_label,
					subredditId: e.subreddit_id,
					subredditType: e.subreddit_type,
					suggestedCommentSort: e.suggested_comment_sort,
					title: e.title,
					toxicityThresholdChatLevel: e.toxicity_threshold_chat_level,
					userFlairPNsEnabled: e.user_flair_pns_enabled,
					welcomeMessageEnabled: e.welcome_message_enabled,
					welcomeMessageText: e.welcome_message_text,
					wikiEditAge: e.wiki_edit_age,
					wikiEditKarma: e.wiki_edit_karma,
					wikimode: e.wikimode
				}),
				p = (e, t) => {
					const s = {};
					for (const n in e) s[t[n]] = e[n];
					return s
				},
				O = e => ({
					allow_polls: e.allowPolls,
					allow_galleries: e.allowGalleries,
					allow_post_crossposts: e.allowPostCrossposts,
					allow_chat_post_creation: e.allowChatPostCreation,
					allow_images: e.allowImages,
					allow_discovery: e.allowDiscovery,
					allow_top: e.contentVisible,
					api_type: "json",
					collapse_deleted_comments: e.collapseDeletedComments,
					comment_score_hide_mins: e.commentScoreHideMins,
					crowd_control_mode: e.crowdControlMode,
					crowd_control_level: e.crowdControlLevel,
					crowd_control_chat_level: e.crowdControlChatLevel,
					disable_contributor_requests: e.disableContributorRequests,
					description: e.description,
					domain: e.domain,
					exclude_banned_modqueue: e.excludeBannedModqueue,
					"header-title": e.headerHoverText,
					hide_ads: e.hideAds,
					is_chat_post_feature_enabled: e.isChatPostFeatureEnabled,
					key_color: e.keyColor,
					lang: e.language,
					link_type: e.contentOptions,
					live_streaming_is_enabled: e.liveStreamingIsEnabled,
					new_pinned_post_pns_enabled: e.newPinnedPostPNsEnabled,
					over_18: e.over18,
					public_description: e.publicDescription,
					public_traffic: e.publicTraffic,
					restrict_commenting: e.restrictCommenting,
					restrict_posting: e.restrictPosting,
					show_media: e.showMedia,
					show_media_preview: e.showMediaPreview,
					spam_comments: e.spamComments,
					spam_links: e.spamLinks,
					spam_selfposts: e.spamSelfposts,
					spoilers_enabled: e.spoilersEnabled,
					sr: e.subredditId,
					submit_link_label: e.submitLinkLabel,
					submit_text: e.submitText,
					submit_text_label: e.submitTextLabel,
					suggested_comment_sort: e.suggestedCommentSort,
					title: e.title,
					toxicity_threshold_chat_level: e.toxicityThresholdChatLevel,
					type: e.subredditType,
					user_flair_pns_enabled: e.userFlairPNsEnabled,
					welcome_message_enabled: e.welcomeMessageEnabled,
					welcome_message_text: e.welcomeMessageText,
					wiki_edit_age: e.wikiEditAge,
					wiki_edit_karma: e.wikiEditKarma,
					wikimode: e.wikimode
				}),
				g = {
					allowPostCrossposts: "allow_post_crossposts",
					allowImages: "allow_images",
					allowChatPostCreation: "allow_chat_post_creation",
					allowDiscovery: "allow_discovery",
					allowPolls: "allow_polls",
					allowGalleries: "allow_galleries",
					contentVisible: "allow_top",
					collapseDeletedComments: "collapse_deleted_comments",
					commentScoreHideMins: "comment_score_hide_mins",
					crowdControlMode: "crowd_control_mode",
					crowdControlLevel: "crowd_control_level",
					crowdControlChatLevel: "crowd_control_chat_level",
					description: "description",
					disableContributorRequests: "disable_contributor_requests",
					domain: "domain",
					excludeBannedModqueue: "exclude_banned_modqueue",
					headerHoverText: "header-title",
					hideAds: "hide_ads",
					isChatPostFeatureEnabled: "is_chat_post_feature_enabled",
					keyColor: "key_color",
					language: "lang",
					liveStreamingIsEnabled: "live_streaming_is_enabled",
					contentOptions: "link_type",
					newPinnedPostPNsEnabled: "new_pinned_post_pns_enabled",
					over18: "over_18",
					publicDescription: "public_description",
					publicTraffic: "public_traffic",
					restrictCommenting: "restrict_commenting",
					restrictPosting: "restrict_posting",
					showMedia: "show_media",
					showMediaPreview: "show_media_preview",
					spamComments: "spam_comments",
					spamLinks: "spam_links",
					spamSelfposts: "spam_selfposts",
					spoilersEnabled: "spoilers_enabled",
					submitLinkLabel: "submit_link_label",
					submitText: "submit_text",
					submitTextLabel: "submit_text_label",
					subredditType: "type",
					suggestedCommentSort: "suggested_comment_sort",
					title: "title",
					toxicityThresholdChatLevel: "toxicity_threshold_chat_level",
					userFlairPNsEnabled: "user_flair_pns_enabled",
					welcomeMessageEnabled: "welcome_message_enabled",
					welcomeMessageText: "welcome_message_text",
					wikiEditAge: "wiki_edit_age",
					wikiEditKarma: "wiki_edit_karma",
					wikimode: "wikimode"
				},
				f = (e, t, s) => Object(r.a)(Object(a.a)(e, [o.a]), {
					method: n.db.POST,
					endpoint: Object(i.a)("".concat(e.apiUrl, "/api/v1/subreddit/test_welcome_message")),
					data: {
						sr: t,
						test_message_text: s
					}
				})
		},
		"./src/reddit/endpoints/user/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "e", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			}));
			var n = s("./src/config.ts"),
				r = s("./src/graphql/operations/ExperimentVariants.json"),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				o = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/reddit/constants/headers.ts"),
				u = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const l = (e, t) => Object(i.a)(e, {
					endpoint: Object(u.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/user/").concat(t, "/about")),
					method: a.db.GET,
					data: {
						api_type: "json",
						gilding_detail: 1,
						awarded_detail: 1
					}
				}),
				b = e => Object(i.a)(Object(c.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_layout_switch"),
					method: a.db.POST
				}),
				p = e => Object(i.a)(Object(c.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_give_award_tooltip"),
					method: a.db.POST
				}),
				O = e => Object(i.a)(Object(c.a)(e, [d.a]), {
					endpoint: "".concat(e.apiUrl, "/api/seen_modal"),
					method: a.db.POST
				}),
				g = (e, t) => Object(o.a)(e, Object.assign(Object.assign({}, r), {
					variables: t
				}), {
					traceRequestName: "get_experiments"
				})
		},
		"./src/reddit/endpoints/user/preferences.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return p
			})), s.d(t, "c", (function() {
				return O
			})), s.d(t, "e", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "g", (function() {
				return m
			})), s.d(t, "a", (function() {
				return j
			})), s.d(t, "b", (function() {
				return _
			})), s.d(t, "h", (function() {
				return h
			}));
			var n = s("./src/config.ts"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/omitHeaders/index.ts");
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const o = {
				activityRelevantAds: "activity_relevant_ads",
				acceptPrivateMessages: "accept_pms",
				allowClickTracking: "allow_clicktracking",
				collapseReadMessages: "collapse_read_messages",
				defaultCommentSort: "default_comment_sort",
				emailDigests: "email_digests",
				emailUnreadMessages: "email_messages",
				emailUnsubscribe: "email_unsubscribe_all",
				geopopular: "geopopular",
				hasSeenCustomizeFlyout: "has_seen_customize_flyout",
				hideAds: "hide_ads",
				hideFromRobots: "hide_from_robots",
				hideNSFW: "no_profanity",
				highlightComments: "highlight_new_comments",
				ignoreSuggestedSort: "ignore_suggested_sort",
				inBeta: "beta",
				labelNSFW: "label_nsfw",
				markMessagesRead: "mark_messages_read",
				nightmode: "nightmode",
				over18: "over_18",
				sendWelcomeMessages: "send_welcome_messages",
				showMessagesInInbox: "threaded_messages",
				showNotifications: "live_orangereds",
				showUsernameMentionNotifications: "monitor_mentions",
				privateFeeds: "private_feeds",
				autoplayVideo: "video_autoplay",
				reduceAnimationsFromAwards: "reduce_animations_from_awards",
				rpanDuDismissalTime: "rpan_du_dismissal_time",
				showActiveCommunities: "top_karma_subreddits",
				showRpanDu: s("./src/reddit/constants/preferences.ts").c,
				showTwitter: "show_twitter",
				stylesEnabled: "styles_enabled",
				openPostInNewTab: "open_post_in_new_tab",
				rememberCommunitySort: "remember_community_sort",
				useMarkdown: "use_markdown",
				sort: "sort",
				layout: "layout",
				rememberCommunityLayout: "remember_community_layout",
				topContentDismissalTime: "top_content_dismissal_time",
				topContentTimesDismissed: "top_content_times_dismissed",
				thirdPartyDataPersonalizedAds: "third_party_data_personalized_ads",
				thirdPartySiteDataPersonalizedAds: "third_party_site_data_personalized_ads",
				thirdPartySiteDataPersonalizedContent: "third_party_site_data_personalized_content",
				showLocationBasedRecommendations: "show_location_based_recommendations",
				surveyLastSeenTime: "survey_last_seen_time"
			};
			var c = e => {
					const t = {};
					return Object.keys(e).map(s => {
						o.hasOwnProperty(s) && (t[o[s]] = e[s])
					}), t
				},
				d = s("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const u = {
				rpanDuDismissalTime: "rpan_du_dismissal_time",
				isContributorRequestTimestamp: "is_contributor_request_timestamp",
				sort: "sort",
				stylesEnabled: "styles_enabled",
				layout: "layout"
			};
			var l = e => {
					const t = {};
					return Object.keys(e).map(s => {
						t[u[s]] = e[s]
					}), t
				},
				b = s("./src/reddit/constants/headers.ts");
			const p = e => Object(a.a)(Object(i.a)(e, [b.a]), {
					method: r.db.PATCH,
					endpoint: "".concat(e.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						over_18: "true"
					}
				}),
				O = (e, t) => Object(a.a)(Object(i.a)(t, [b.a]), {
					method: r.db.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						video_autoplay: e
					}
				}),
				g = (e, t) => Object(a.a)(Object(i.a)(t, [b.a]), {
					method: r.db.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						nightmode: e
					}
				}),
				f = (e, t) => Object(a.a)(Object(i.a)(t, [b.a]), {
					method: r.db.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: {
						geopopular: e
					}
				}),
				m = (e, t) => Object(a.a)(Object(i.a)(t, [b.a]), {
					method: r.db.PATCH,
					endpoint: "".concat(t.apiUrl, "/api/v1/me/prefs"),
					type: "json",
					data: c(e)
				}),
				j = (e, t) => Object(a.a)(Object(i.a)(t, [b.a]), {
					method: r.db.POST,
					endpoint: "".concat(t.apiUrl, "/api/quarantine_optin"),
					data: {
						sr_name: e,
						api_type: "json",
						accept: !0
					}
				}),
				_ = (e, t) => Object(a.a)(t, {
					method: r.db.POST,
					endpoint: Object(d.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/set_preferences")),
					type: "json",
					data: {
						type: "account",
						preferences: c(e)
					}
				}),
				h = (e, t, s) => Object(a.a)(s, {
					method: r.db.POST,
					endpoint: "".concat(n.a.gatewayUrl, "/desktopapi/v1/set_preferences"),
					type: "json",
					data: {
						type: "subreddit",
						subreddit_id: e,
						preferences: l(t)
					}
				})
		},
		"./src/reddit/endpoints/usernameAvailable/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				a = s("./src/lib/omitHeaders/index.ts"),
				i = s("./src/reddit/constants/headers.ts");
			const o = (e, t) => Object(r.a)(Object(a.a)(e, [i.a]), {
				method: n.db.GET,
				endpoint: "".concat(e.apiUrl, "/api/username_available.json?user=").concat(t.username),
				type: "json"
			})
		},
		"./src/reddit/helpers/adCount/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				a = s("./src/reddit/selectors/platform.ts");
			const i = (e, t, s) => [e, t, s].join("/"),
				o = (e, t) => {
					switch (t) {
						case r.a.SUBREDDIT:
						case r.a.COMMENTS_OVERLAY:
						case r.a.COMMENTS: {
							const t = Object(a.i)(e);
							return [i(n.c.ABOVE_THE_FOLD, t, 0), i(n.c.BELOW_THE_FOLD, t, 1)]
						}
						case r.a.FRONTPAGE:
							return [i(n.c.ABOVE_THE_FOLD, !1, 0), i(n.c.BELOW_THE_FOLD, !1, 1)];
						case r.a.MULTIREDDIT:
						case r.a.SEARCH_RESULTS:
							return [i(n.c.BELOW_THE_FOLD, !1, 0)];
						default:
							return [i(n.c.ABOVE_THE_FOLD, !1, 0), i(n.c.BELOW_THE_FOLD, !1, 1)]
					}
				}
		},
		"./src/reddit/helpers/addRedesignIdentifier/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return c
			}));
			var n = s("./src/config.ts"),
				r = s("./node_modules/node-libs-browser/node_modules/url/url.js"),
				a = s.n(r),
				i = s("./src/lib/addQueryParams/index.ts");

			function o(e) {
				const {
					protocol: t,
					host: s
				} = a.a.parse(e), r = "".concat(t, "//").concat(s) === n.a.oauthUrl ? n.a.telemetry.appName.redesignR2 : n.a.telemetry.appName.redesign, o = {
					redditWebClient: r,
					app: "".concat(r, "-").concat("client", "-").concat("production")
				};
				return Object(i.a)(e, o)
			}
			const c = () => {
				const e = n.a.telemetry.appName.redesignR2;
				return {
					redditWebClient: e,
					app: "".concat(e, "-").concat("client", "-").concat("production")
				}
			}
		},
		"./src/reddit/helpers/awards/getAwardItemId.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = (e, t) => "awardItem__".concat(t, "-").concat(e)
		},
		"./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = new Set(["t5_22cerq"]),
				r = e => n.has(e);
			t.a = r
		},
		"./src/reddit/helpers/awards/message.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			}));
			const n = 500,
				r = 1800,
				a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return t ? e.coinPrice < n ? 0 : e.coinPrice < r ? 50 : 100 : 2048
				},
				i = function(e, t) {
					let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const n = a(t, s);
					return e.slice(0, n)
				}
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/reddit/constants/comments.ts"),
				r = s("./src/reddit/selectors/comments.ts"),
				a = s("./src/reddit/constants/experiments.ts"),
				i = s("./src/reddit/helpers/chooseVariant/index.ts");
			const o = (e, t) => t().comments.models[e],
				c = e => {
					switch (e.commentLink.type) {
						case n.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case n.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case n.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				d = (e, t) => e.type === n.a.MoreComments ? t[e.id].numComments : 1,
				u = (e, t, s, n) => {
					let a = Object(r.o)(n, {
							commentLink: t,
							commentsPageKey: e
						}),
						i = t;
					for (; a && a.depth > s && a.prev && (i = a.prev, (a = Object(r.o)(n, {
							commentLink: i,
							commentsPageKey: e
						})) && !(a.depth <= s)););
					return i.id
				},
				l = (e, t, s) => {
					const {
						commentLists: n,
						comments: r
					} = e, {
						head: o
					} = n[t];
					if (o) return Object.keys(r).filter(e => {
						const t = r[e];
						return !(!t.isStickied || !((e, t) => {
							const s = Object(i.c)(e, {
								experimentEligibilitySelector: i.a,
								experimentName: a.p,
								expEventOverride: t
							});
							return !!(Object(a.zc)(s) ? void 0 : s)
						})(s)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");

			function n(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let s = 0;
				return e.placement && t.placement && (s = e.placement.localeCompare(t.placement)), 0 === s && e.position && t.position && (s = e.position - t.position), 0 === s && (s = e.title.localeCompare(t.title)), s
			}

			function r(e) {
				return [...e].sort(n)
			}
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/lodash/findLastIndex.js"),
				r = s.n(n),
				a = s("./src/reddit/models/WhitelistStatus/index.ts"),
				i = s("./src/reddit/selectors/telemetry.ts"),
				o = s("./src/telemetry/index.ts"),
				c = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const d = (e, t) => {
				let {
					subreddits: s,
					profiles: n
				} = t;
				const r = s[e.belongsTo.id] || n[e.belongsTo.id];
				return !e.isNSFW && r && a.a.has(r.wls || a.b.NO_ADS)
			};
			t.a = (e, t, s) => {
				var {
					postIds: n,
					posts: a,
					subreddits: u,
					profiles: l
				} = s, b = c(s, ["postIds", "posts", "subreddits", "profiles"]);
				const p = e.listings.postOrder.ids[t],
					O = (n || []).filter(e => !p || !p.includes(e)),
					g = p.map(t => e.posts.models[t]),
					f = g.length - (r()(g, e => e.isSponsored) + 1),
					m = O.map(e => a[e]);
				let j;
				const _ = [],
					h = {
						subreddits: u,
						profiles: l
					};
				for (let r = 0; r < m.length; r++) {
					const s = m[r];
					let n = !1;
					if (s.isSponsored) {
						const e = r > 0 && m[r - 1],
							t = r < m.length - 1 && m[r + 1];
						e && d(e, h) && t && d(t, h) && (n = !0)
					}
					s.isSponsored && n && (null == j && f + r >= 3 || r - j >= 3) ? (j = r, _.push(s.id)) : s.isSponsored ? s.isSponsored && Object(o.a)(Object.assign(Object.assign({
						source: "feed",
						action: "remove",
						noun: "ad"
					}, i.defaults(e)), {
						listing: i.listing(e, t)
					})) : _.push(s.id)
				}
				return Object.assign(Object.assign({}, b), {
					subreddits: u,
					profiles: l,
					posts: a,
					postIds: _
				})
			}
		},
		"./src/reddit/helpers/frontpageCardPostCountExperiment.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "c", (function() {
				return p
			}));
			var n, r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/constants/postLayout.ts"),
				i = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/contexts/PageLayer/index.tsx"),
				c = s("./src/reddit/selectors/meta.ts"),
				d = s("./src/reddit/selectors/user.ts");

			function u(e) {
				return Object(o.N)(e, {}) === a.g.Large && !Object(d.G)(e) && !Object(c.d)(e)
			}

			function l(e) {
				return Object(i.c)(e, {
					expEventOverride: !1,
					experimentEligibilitySelector: u,
					experimentName: r.eb
				})
			}

			function b(e) {
				switch (e) {
					case r.fb.Enabled:
						return 18;
					default:
						return
				}
			}! function(e) {
				e.Enabled = "frontpage-card-posts-3.enabled", e.NoBucket = "frontpage-card-posts-3.no_bucket"
			}(n || (n = {}));
			const p = e => {
				switch (e) {
					case r.fb.Enabled:
						return n.Enabled;
					default:
						return n.NoBucket
				}
			}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				r = s("./src/lib/constants/index.ts");
			t.a = () => ({
				type: r.E.SERVER_ERROR,
				fields: [{
					field: "",
					msg: n.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getErrorMsgFromR2JQueryResponse.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return a
			}));
			const n = {
					INVALID_EMAIL: "You entered an invalid email. Please try again.",
					RATELIMITED: "You are doing that too much. Please try later.",
					WRONG_PASSWORD: "You entered an incorrect password. Please try again."
				},
				r = (e, t) => -1 !== e.indexOf(t);

			function a(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Something went wrong. Please try again.";
				const s = e && e.body && e.body.jquery && e.body.jquery[14] && e.body.jquery[14][3] && e.body.jquery[14][3][0];
				return "string" != typeof s ? t : r(s, "the following emails are invalid") ? n.INVALID_EMAIL : r(s, "wrong password") ? n.WRONG_PASSWORD : r(s, "you are doing that too much") ? n.RATELIMITED : t
			}
		},
		"./src/reddit/helpers/getGenericUploadError.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/lib/constants/index.ts");

			function r(e) {
				return {
					type: n.E.UNKNOWN_ERROR,
					fields: [{
						field: e,
						msg: "Image failed to upload"
					}]
				}
			}
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/reddit/constants/postLayout.ts");

			function r(e) {
				return e ? n.c[e] : n.f
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(r.a)(e) ? t || n.Tb : void 0
			}
		},
		"./src/reddit/helpers/getVendorMetadata.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/ads/index.ts"),
				r = s("./src/lib/ads/store.ts"),
				a = s("./src/reddit/constants/adEvents.ts");
			const i = (e, t) => {
					return Object.keys(e).reduce((s, n) => (s[n] = t - (e[n].timeEntered || t), s), {})
				},
				o = (e, t, s, n, r) => t === s ? n : !(!r || !r[e]) && r[e],
				c = function(e, t, s) {
					let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
					if (s) {
						if (e && t) return 4;
						if (!t && e) return 3;
						if (t && !e) return 2;
						if (!t && !e) return 1
					}
					return n
				},
				d = (e, t, s) => {
					let d = null,
						u = null;
					if ("undefined" == typeof document || "undefined" == typeof window) return null;
					const l = Date.now(),
						{
							thresholdData: b,
							videoThresholdData: p,
							videoAds: O
						} = r.c(e) || r.a,
						g = Object(n.t)(e, O, "timeUpdated"),
						{
							videoData: f
						} = t,
						m = i(b, l),
						j = i(p, l),
						_ = !!t.videoData.videoVolume && t.videoData.videoVolume <= 0,
						h = f.videoStartTime ? f.videoStartTime + 200 : 0,
						y = {
							inView50: h >= (p[50].timeEntered || Number.MAX_SAFE_INTEGER),
							inView80: h >= (p[80].timeEntered || Number.MAX_SAFE_INTEGER),
							inView100: h >= (p[100].timeEntered || Number.MAX_SAFE_INTEGER),
							audible: !_ && h >= (g.muted || 0),
							muted: _ && h >= (g.muted || 0)
						},
						E = b[1].totalTime + m[1],
						I = b[50].totalTime + m[50],
						v = b[100].totalTime + m[100],
						S = Math.max(b[1].maxContinuousTime, m[1]),
						T = Math.max(b[30].maxContinuousTime, m[30]),
						w = Math.max(b[50].maxContinuousTime, m[50]),
						C = Math.max(b[100].maxContinuousTime, m[100]),
						A = w > n.l,
						D = document.getElementById(e);
					if (!D) return null;
					const P = D.getElementsByTagName("video");
					let R = null;
					P && P[0] && (R = P[0].getBoundingClientRect());
					const k = D.getBoundingClientRect(),
						x = (d = Math.floor(k.width)) * (u = Math.floor(k.height)),
						N = x > 242499 && w >= 1e3 || C >= 1e3 || s === a.a.GroupMViewable ? 1 : 0,
						L = x > 242499 && T >= 1e3 || C >= 1e3 ? 1 : 0,
						U = Math.max(p[100].maxContinuousTime, j[100]) > 1,
						M = p.HALF_DURATION_80_IN_VIEW_AUDIBLE,
						F = {
							w: d,
							h: u,
							sw: window.screen.width,
							sh: window.screen.height,
							t: l,
							a: E,
							b: I,
							c: v,
							d: S,
							e: w,
							f: C,
							g: N ? 1 : 0,
							i: s === a.a.Impression ? l : t.timeImpressionViewed || 0,
							o: A ? 1 : 0,
							q: L ? 1 : 0,
							r: t.eventGlobalCount ? t.eventGlobalCount : 0
						};
					return f.isVideo && (F.va = f.isVideo ? 1 : 0, F.vh = R ? Math.floor(R.height) : 0, F.vw = R ? Math.floor(R.width) : 0, F.ve = f.videoVolume || 0, F.vc = Math.floor(f.videoDuration || 0), F.vd = Math.floor(f.cumulativeViewedTime) || 0, F.vq = f.wasFullScreen || 0, F.vg = p[1].timeEntered ? 1 : 0, F.vb = p[50].totalTime + j[50], F.vs = c(f.videoVolume, p[1].timeEntered, s === a.a.VideoStarted, f.videoStarted), F.vt = c(f.videoVolume, p[1].timeEntered, s === a.a.VideoWatched25, f.watched25), F.vu = c(f.videoVolume, p[1].timeEntered, s === a.a.VideoWatched50, f.watched50), F.vv = c(f.videoVolume, p[1].timeEntered, s === a.a.VideoWatched75, f.watched75), F.vx = c(f.videoVolume, p[1].timeEntered, s === a.a.VideoWatched100, f.watched100), F.vo = o("vo", s, a.a.VideoWatched50, y.inView100, f.watched50State) ? 1 : 0, F.vr = o("vr", s, a.a.VideoWatched50, y.inView80 && y.audible, f.watched50State) || M.totalTime + j.HALF_DURATION_80_IN_VIEW_AUDIBLE >= 15e3 ? 1 : 0, F.vj = o("vj", s, a.a.VideoWatched50, y.inView100 && y.audible, f.watched50State) ? 1 : 0, F.vl = o("vl", s, a.a.VideoWatched100, y.inView100, f.watched100State) ? 1 : 0, F.vk = o("vk", s, a.a.VideoWatched100, y.audible, f.watched100State) ? 1 : 0, F.vp = o("vp", s, a.a.VideoWatched100, y.inView100 && y.audible, f.watched100State) ? 1 : 0, F.vm = o("vm", s, a.a.VideoWatched100, y.inView50 && y.audible, f.watched100State) ? 1 : 0, F.vn = o("vn", s, a.a.VideoWatched100, y.inView50 && y.muted, f.watched100State) ? 1 : 0, F.vy = p.FULL_IN_VIEW_AUDIBLE_TIME.totalTime + j.FULL_IN_VIEW_AUDIBLE_TIME, F.vz = p[100].totalTime + j[100], F.xa = U ? 1 : 0, F.xb = Math.max(p[50].maxContinuousTime, j[50])), F
				}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function a(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : n.fbt._("Something went wrong. Please try again later.", null, {
					hk: "16ibYk"
				})
			}

			function i(e) {
				const t = "".concat(e.type, " (").concat(e.code, ")");
				return "message" in e ? "".concat(t, ": ").concat(e.message) : t
			}
		},
		"./src/reddit/helpers/graphql/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./src/reddit/models/Gold/Award.ts");
			const r = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					try {
						return JSON.parse(e)
					} catch (s) {
						return t
					}
				},
				a = e => {
					switch (e) {
						case "UP":
							return 1;
						case "DOWN":
							return -1;
						default:
							return 0
					}
				},
				i = e => e.reduce((e, t) => {
					let {
						award: s,
						total: r
					} = t;
					if (void 0 !== s.icon) {
						const t = Object(n.i)(s, r);
						e.push(t)
					}
					return e
				}, []);
			var o;
			! function(e) {
				e[e.Seconds = 3] = "Seconds", e[e.Millis = 0] = "Millis"
			}(o || (o = {}));
			const c = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.Seconds;
				if (!e) return 0;
				let s = Date.parse(e);
				return Number.isNaN(s) && (s = Date.parse(e.replace("+0000", "Z"))), Number.isNaN(s) || s <= 0 ? 0 : s - s % Math.pow(10, t)
			};
			window.URL
		},
		"./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/models/Subreddit/index.ts");
			const r = {
				[n.a.Image]: "images",
				[n.a.Link]: "links",
				[n.a.Spoiler]: "spoilers",
				[n.a.Text]: "text",
				[n.a.Video]: "videos",
				[n.a.Poll]: "polls",
				[n.a.Gallery]: "galleries"
			};
			t.a = e => {
				return Object.assign(Object.assign({}, {
					images: !1,
					links: !1,
					spoilers: !1,
					text: !1,
					videos: !1,
					polls: !1,
					galleries: !1
				}), e.reduce((e, t) => (e[r[t]] = !0, e), {}))
			}
		},
		"./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			}));
			var n = s("./src/reddit/models/Flair/index.ts"),
				r = s("./src/reddit/helpers/graphql/helpers.ts");
			const a = e => {
					switch (e) {
						case n.h.Dark:
							return n.e.Dark;
						case n.h.Light:
							return n.e.Light
					}
				},
				i = (e, t, s, a, i) => {
					const o = [];
					return i === n.f.Richtext ? (o.push(Object.assign({
						type: i,
						richtext: Object(r.e)(a, []) || []
					}, e)), t && o.push(Object.assign({
						type: n.f.Text,
						text: t
					}, e))) : o.push(Object.assign({
						type: i,
						text: s
					}, e)), o
				},
				o = e => {
					const {
						text: t,
						richtext: s
					} = e, {
						id: n,
						textColor: r,
						type: o,
						text: c,
						backgroundColor: d,
						cssClass: u
					} = e.template, l = Object.assign(Object.assign({
						backgroundColor: d || "",
						cssClass: u
					}, n && {
						templateId: n
					}), r && {
						textColor: a(r)
					});
					return i(l, c || "", t, s, o)
				},
				c = e => {
					const {
						text: t,
						richtext: s,
						cssClass: n
					} = e, {
						id: r,
						textColor: o,
						type: c,
						text: d,
						backgroundColor: u,
						cssClass: l,
						richtext: b
					} = e.template, p = Object.assign(Object.assign({
						backgroundColor: u || "",
						cssClass: n || l
					}, r && {
						templateId: r
					}), o && {
						textColor: a(o)
					});
					return i(p, d || "", t || "", s || b, c)
				}
		},
		"./src/reddit/helpers/graphql/normalizeModeratorPartFromGql/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/helpers/graphql/helpers.ts");
			const r = (e, t) => !!e && (e.verdict === "MOD_".concat(t.toUpperCase()) || e.verdict === "ADMIN_".concat(t.toUpperCase())),
				a = e => e && e.length ? e.map(e => [e.reason || "", e.author && e.author.name || ""]) : null,
				i = e => e && e.length ? e.map(e => [e.reason || "", e.count || 0]) : null;
			t.a = e => {
				let {
					moderationInfo: t
				} = e;
				if (!t) return;
				const s = (e => e && e.verdictBy && e.verdictBy.name || null)(t),
					o = (e => e && Object(n.d)(e.verdictAt) || null)(t),
					c = r(t, "spammed"),
					d = r(t, "approved"),
					u = r(t, "removed"),
					{
						approvedBy: l = null,
						approvedAtUTC: b = null,
						bannedBy: p = null,
						bannedAtUTC: O = null
					} = d ? {
						approvedBy: s,
						approvedAtUTC: o
					} : {
						bannedBy: s,
						bannedAtUTC: o
					};
				return Object.assign(Object.assign({
					isSpam: c,
					isApproved: d,
					isRemoved: u,
					ignoreReports: t.isReportingIgnored,
					numReports: t.reportCount || null,
					modNote: t.modNote,
					approvedBy: l,
					approvedAtUTC: b,
					bannedBy: p,
					bannedAtUTC: O
				}, u && {
					modReasonBy: s
				}), {
					modReports: a(t.modReports) || [],
					userReports: i(t.userReports) || [],
					modReportsDismissed: a(t.dismissedModReports) || [],
					userReportsDismissed: i(t.dismissedUserReports) || []
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return g
			}));
			var n = s("./node_modules/lodash/forEach.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/merge.js"),
				i = s.n(a),
				o = s("./src/lib/env/index.ts"),
				c = s("./src/lib/sentry/index.ts"),
				d = s("./src/reddit/helpers/graphql/helpers.ts"),
				u = s("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				l = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				b = s("./src/reddit/models/GqlTopLevelField.ts"),
				p = s("./src/reddit/models/Multireddit/index.ts");

			function O(e) {
				const t = {
					multireddits: {},
					multiredditsByUser: {},
					subreddits: {},
					profiles: {}
				};
				if (!e) return t;
				const {
					path: s
				} = e, n = s.toLowerCase(), r = n.endsWith("/") ? n : n + "/", a = {
					created: 0,
					description: e.descriptionContent ? e.descriptionContent.markdown : "",
					descriptionHtml: null,
					descriptionRtJson: e.descriptionContent ? JSON.parse(e.descriptionContent.richtext) : null,
					displayText: e.displayName,
					followerCount: e.followerCount,
					name: e.name,
					icon: e.icon,
					isFavorited: e.isFavorited,
					isFollowed: e.isFollowed,
					isNSFW: e.isNsfw || !1,
					isQuarantined: e.isQuarantined || !1,
					subredditCount: e.subredditCount,
					ownerId: e.ownerInfo.id,
					url: r,
					visibility: e.visibility && e.visibility.toLowerCase() || p.e.Private
				};
				if (a.created = Object(d.d)(e.createdAt) / 1e3, e.sources) {
					a.subredditIds = [], a.profileIds = [];
					for (const {
							node: s
						} of e.sources.edges) {
						if (s.__typename === b.a.Subreddit) a.subredditIds.push(s.id), t.subreddits[s.id] = t.subreddits[s.id] || Object(l.a)(s);
						else if (s.__typename === b.a.Profile) a.profileIds.push(s.id), t.profiles[s.id] = t.profiles[s.id] || Object(u.a)(s);
						else {
							const e = 'Unexpected Multireddit.sources node with type "'.concat(s.__typename, '"');
							Object(o.b)() ? c.c.captureMessage(e) : console.error(e)
						}
						s.isNSFW && (a.isNSFW = !0), s.isQuarantined && (a.isQuarantined = !0)
					}
				}
				return t.multireddits[r] = a, t.multiredditsByUser[e.ownerInfo.id] = [r], t
			}

			function g(e) {
				const t = {},
					s = {},
					n = {},
					a = {},
					o = e.map(O);
				for (const c of o) r()(c.multiredditsByUser, (e, t) => {
					s[t] = [...s[t] || [], ...e]
				}), i()(t, c.multireddits), i()(n, c.profiles), i()(a, c.subreddits);
				return {
					multireddits: t,
					multiredditsByUser: s,
					profiles: n,
					subreddits: a
				}
			}
			t.a = O
		},
		"./src/reddit/helpers/graphql/normalizeMultiredditListingFromGql/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = s("./src/reddit/helpers/graphql/normalizeMultiredditDataFromGql/index.ts"),
				a = s("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				i = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				o = s("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				c = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				d = s("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				u = s("./src/reddit/models/Post/index.ts");
			t.a = e => {
				const t = {
					account: null,
					dist: 0,
					features: null,
					multireddits: {},
					multiredditsByUser: {},
					pageInfo: null,
					postFlair: {},
					postIds: [],
					postInstances: {},
					posts: {},
					preferences: null,
					profiles: {},
					subreddits: {},
					token: void 0
				};
				if (!e) return t;
				const {
					identity: s,
					multireddit: l
				} = e;
				if (s && (t.account = Object(d.a)(s) || null, t.preferences = Object(o.a)(s.preferences, s.interactions) || null), !l) return t;
				const {
					posts: b
				} = l;
				if (b) {
					t.pageInfo = b.pageInfo;
					for (const {
							node: e
						} of b.edges) {
						const s = e;
						t.postIds.push(s.id);
						const {
							post: r,
							crosspost: o
						} = s && Object(i.a)(s);
						t.posts[r.id] = r, o && (t.posts[o.id] = o), s.__typename !== u.f.DeletedProfilePost && s.__typename !== u.f.DeletedSubredditPost && (s.authorFlair && (t.postFlair[r.belongsTo.id] || (t.postFlair[r.belongsTo.id] = {}), t.postFlair[r.belongsTo.id][r.author] = Object(n.a)(s.authorFlair)[0]), s.__typename === u.f.SubredditPost && (t.subreddits[s.subreddit.id] || (t.subreddits[s.subreddit.id] = Object(c.a)(s.subreddit)), t.postFlair[s.subreddit.id] || (t.postFlair[s.subreddit.id] = Object(a.a)(s.subreddit))))
					}
				} else t.pageInfo = {
					endCursor: null,
					hasNextPage: !1,
					hasPreviousPage: !1,
					startCursor: null
				};
				t.postIds.length && (t.dist = t.postIds.length), t.pageInfo.hasNextPage && (t.token = t.pageInfo.endCursor || "");
				const {
					multireddits: p,
					multiredditsByUser: O,
					profiles: g,
					subreddits: f
				} = Object(r.a)(l);
				return Object.assign(Object.assign({}, t), {
					multireddits: p,
					multiredditsByUser: O,
					profiles: Object.assign(Object.assign({}, t.profiles), g),
					subreddits: Object.assign(Object.assign({}, t.subreddits), f)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/models/Flair/index.ts");

			function r(e) {
				switch (e) {
					case n.g.LEFT:
						return n.b.Left;
					case n.g.RIGHT:
						return n.b.Right;
					default:
						return null
				}
			}

			function a(e) {
				let {
					isEnabled: t = !1,
					position: s
				} = e;
				return {
					isEnabled: t,
					position: r(s)
				}
			}
			t.a = e => {
				let {
					postFlairSettings: t
				} = e;
				return Object.assign({}, t && {
					displaySettings: t && a(t)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return y
			})), s.d(t, "b", (function() {
				return G
			})), s.d(t, "c", (function() {
				return W
			})), s.d(t, "e", (function() {
				return J
			}));
			s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/sentry/index.ts"),
				a = s("./src/reddit/constants/adEvents.ts"),
				i = s("./src/reddit/constants/thumbnails.ts"),
				o = s("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				c = s("./src/reddit/helpers/graphql/normalizeModeratorPartFromGql/index.ts"),
				d = s("./src/reddit/helpers/graphql/helpers.ts"),
				u = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				},
				l = e => {
					let {
						isPrediction: t,
						options: s,
						selectedOptionId: n,
						totalVoteCount: r,
						votingEndsAt: a,
						totalStakeAmount: i,
						wonAmount: o,
						resolvedOptionId: c
					} = e;
					return {
						isPrediction: t,
						options: s.map(e => {
							var {
								redditorStakeAmount: t
							} = e, s = u(e, ["redditorStakeAmount"]);
							return Object.assign({
								userStakeAmount: t
							}, s)
						}),
						totalVoteCount: r,
						userSelection: n,
						votingEndTimestamp: Object(d.d)(a),
						totalStakeAmount: i,
						userWonAmount: o,
						resolvedOptionId: c
					}
				};
			const b = /i\.redd\.it|v\.redd\.it|i\.reddituploads\.com/;
			var p = s("./src/reddit/models/Flair/index.ts"),
				O = s("./src/reddit/models/Media/index.ts");
			const g = e => {
				switch (e) {
					case "IMPRESSION":
						return a.a.Impression;
					case "CLICK":
						return a.a.Click;
					case "COMMENTS_VIEW":
						return a.a.CommentsView;
					case "UPVOTE":
						return a.a.Upvote;
					case "DOWNVOTE":
						return a.a.Downvote;
					case "COMMENT_SUBMITTED":
						return a.a.CommentSubmitted;
					case "VIEWABLE_IMPRESSION":
						return a.a.ViewableImpression;
					case "COMMENT_UPVOTE":
						return a.a.CommentUpvote;
					case "COMMENT_DOWNVOTE":
						return a.a.CommentDownvote;
					case "VIDEO_VIEWABLE_IMPRESSION":
						return a.a.VideoViewableImpression;
					case "VIDEO_FULLY_VIEWABLE_IMPRESSION":
						return a.a.VideoFullyViewableImpression;
					case "VIDEO_PLAYED_WITH_SOUND":
						return a.a.VideoPlayedWithSound;
					case "VIDEO_PLAYED_EXPANDED":
						return a.a.VideoPlayedExpanded;
					case "VIDEO_WATCHED_25":
						return a.a.VideoWatched25;
					case "VIDEO_WATCHED_50":
						return a.a.VideoWatched50;
					case "VIDEO_WATCHED_75":
						return a.a.VideoWatched75;
					case "VIDEO_WATCHED_95":
						return a.a.VideoWatched95;
					case "VIDEO_WATCHED_100":
						return a.a.VideoWatched100;
					case "VIDEO_STARTED":
						return a.a.VideoStarted;
					case "VIDEO_WATCHED_3_SECS":
						return a.a.VideoWatchedSeconds3;
					case "VIDEO_WATCHED_5_SECS":
						return a.a.VideoWatchedSeconds5;
					case "VIDEO_WATCHED_10_SECS":
						return a.a.VideoWatchedSeconds10;
					case "VENDOR_FULLY_IN_VIEW":
						return a.a.VendorFullyInView;
					case "VENDOR_FULLY_IN_VIEW_5_SECS":
						return a.a.VendorFullyInViewSeconds5;
					case "VENDOR_FULLY_IN_VIEW_15_SECS":
						return a.a.VendorFullyInViewSeconds15;
					case "UNLOAD":
						return a.a.Unload;
					case "GROUP_M_VIEWABLE":
						return a.a.GroupMViewable;
					case "MRC_VIDEO_VIEWABLE_IMPRESSION":
						return a.a.DEPRECATED_MRCVideoViewableImpression;
					case "VIDEO_VENDOR_FULLY_VIEWABLE_50":
						return a.a.VideoVendorFullyViewable50;
					case "VIDEO_GROUP_M_VIEWABLE":
						return a.a.VideoGroupMViewable
				}
			};
			var f = s("./src/reddit/models/Post/index.ts"),
				m = s("./src/reddit/models/PostCreationForm/index.ts"),
				j = s("./src/reddit/models/RichTextJson/index.ts"),
				_ = s("./src/reddit/models/User/index.ts"),
				h = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const y = e => e.__typename === f.f.DeletedProfilePost || e.__typename === f.f.DeletedSubredditPost,
				E = [f.e.Embed, f.e.Image, f.e.Video, f.e.Gifvideo],
				I = e => {
					const t = e.thumbnail ? Object.assign({
						url: e.thumbnail.url
					}, e.thumbnail.dimensions) : {
						url: i.a.DEFAULT,
						width: null,
						height: null
					};
					return e.__typename === f.f.AdPost && e.authorOnlyInfo && t.url ? t : e.__typename !== f.f.SubredditPost || e.subreddit.isThumbnailsEnabled ? t : e.isSelfPost ? Object.assign(Object.assign({}, t), {
						url: i.a.SELF
					}) : e.media && e.media.typeHint && E.includes(e.media.typeHint) ? Object.assign(Object.assign({}, t), {
						url: i.a.IMAGE
					}) : Object.assign(Object.assign({}, t), {
						url: i.a.DEFAULT
					})
				},
				v = e => {
					switch (e.__typename) {
						case f.f.SubredditPost:
							return {
								id: e.subreddit.id, type: "subreddit"
							};
						default:
							return {
								id: e.profile.id, type: "profile"
							}
					}
				},
				S = e => {
					var {
						flair: t,
						isNsfw: s,
						isSpoiler: n
					} = e, r = h(e, ["flair", "isNsfw", "isSpoiler"]);
					const a = [];
					t && a.push(...Object(o.b)(t)), n && a.push({
						text: "spoiler",
						type: p.f.Spoiler
					}), s && a.push({
						text: "nsfw",
						type: p.f.Nsfw
					});
					let i = !1;
					return r.__typename === f.f.ProfilePost ? i = r.profile.isQuarantined : r.__typename === f.f.SubredditPost && (i = r.subreddit.isQuarantined), i && a.push({
						text: "quarantined",
						type: p.f.Quarantined
					}), a
				},
				T = e => e.map(e => {
					let {
						type: t,
						url: s
					} = e;
					return {
						url: s || "",
						type: g(t)
					}
				}),
				w = e => {
					var {
						domain: t,
						url: s
					} = e, n = h(e, ["domain", "url"]);
					if (n.__typename === f.f.AdPost || !n.isSelfPost && !(e => b.test(e))(t || "")) {
						const e = n.outboundLink && n.outboundLink.expiresAt && Object(d.d)(n.outboundLink.expiresAt);
						return Object.assign({
							displayText: t || "",
							url: s || ""
						}, n.outboundLink && {
							outboundUrl: n.outboundLink.url || void 0,
							outboundUrlCreated: e && e - 36e5 || void 0,
							outboundUrlExpiration: e || void 0
						})
					}
					return null
				},
				C = {
					small: 108,
					medium: 216,
					large: 320,
					xlarge: 640,
					xxlarge: 960,
					xxxlarge: 1080
				},
				A = {
					originalObfuscated: "dynamic",
					smallObfuscated: 108,
					mediumObfuscated: 216,
					largeObfuscated: 320,
					xlargeObfuscated: 640,
					xxlargeObfuscated: 960,
					xxxlargeObfuscated: 1080
				},
				D = (e, t) => {
					const s = e && (t ? e.animated : e.still);
					if (!s) return [];
					const n = e && e.still && e.still.source ? e.still.source.dimensions.width : 0;
					return Object.keys(C).reduce((e, r) => {
						const a = s[t ? "".concat(t, "_").concat(r) : r];
						if (!a || C[r] > n) return e;
						const i = Object.assign({
							url: a.url
						}, a.dimensions);
						return i ? [...e, i] : e
					}, [])
				},
				P = (e, t, s) => {
					const n = s[t];
					return n && n.url && n.dimensions && n.dimensions.width && n.dimensions.height && e.push({
						x: n.dimensions.width,
						y: n.dimensions.height,
						u: n.url
					}), e
				},
				R = e => Object.keys(C).reduce((t, s) => P(t, s, e), []),
				k = e => Object.keys(A).reduce((t, s) => P(t, s, e), []),
				x = e => {
					const {
						media: t,
						isSelfPost: s
					} = e;
					if (s) return e.content && e.content.richtext ? O.o.RTJSON : O.o.TEXT;
					if (e.gallery) return O.o.GALLERY;
					switch (t && t.typeHint) {
						case f.e.Image:
							return O.o.IMAGE;
						case f.e.Gifvideo:
							return O.o.GIFVIDEO;
						case f.e.Video:
							return O.o.VIDEO;
						case f.e.Embed:
							return O.o.EMBED;
						case f.e.RPAN:
							return O.o.LIVEVIDEO;
						default:
							return null
					}
				},
				N = e => e.authorOnlyInfo && e.authorOnlyInfo.contentMode === f.d.Markdown ? m.h.MARKDOWN : m.h.RICH_TEXT,
				L = e => Math.min(e.height, e.width),
				U = (e, t) => {
					const {
						media: s,
						content: n
					} = e, r = (e => e.isSpoiler || e.isNsfw)(e) ? s && s.obfuscatedStill && s.obfuscatedStill.source && s.obfuscatedStill.source.url : null;
					switch (t) {
						case O.o.VIDEO: {
							const e = 400,
								n = D(s),
								a = s && s.still && s.still.source && Object.assign({
									url: s.still.source.url
								}, s.still.source.dimensions);
							let i;
							if (n.length) {
								i = n.reduce((e, t) => e.width > t.width ? e : t);
								const t = n.reduce((t, s) => L(s) > e && a && L(s) < L(a) ? [...t, s] : t, []);
								t.length && (i = t.reduce((e, t) => L(e) < L(t) ? e : t))
							} else i = a;
							return {
								type: t,
								obfuscated: r,
								hlsUrl: s && s.streaming && s.streaming.hlsUrl || "",
								dashUrl: s && s.streaming && s.streaming.dashUrl || "",
								isGif: !!s && !!s.streaming && s.streaming.isGif,
								scrubberThumbSource: s && s.streaming && s.streaming.scrubberMediaUrl || "",
								width: s && s.streaming ? s.streaming.dimensions.width : 0,
								height: s && s.streaming ? s.streaming.dimensions.height : 0,
								posterUrl: i && i.url || void 0
							}
						}
						case O.o.LIVEVIDEO:
							return {
								type: t, obfuscated: null, hlsUrl: s && s.RPAN && s.RPAN.hlsUrl || "", scrubberThumbSource: s && s.RPAN && s.RPAN.scrubberMediaUrl || ""
							};
						case O.o.TEXT:
							return {
								type: t, obfuscated: null, markdownContent: e.content ? e.content.markdown : "", content: "", rteMode: N(e)
							};
						case O.o.RTJSON:
							return {
								type: t, obfuscated: null, markdownContent: e.content ? e.content.markdown : "", richtextContent: Object(d.e)(n.richtext, j.i), content: "", rteMode: N(e), mediaMetadata: K(e)
							};
						case O.o.IMAGE: {
							const n = s && s.animated && s.animated.gif_source ? "gif" : null;
							let a = "";
							return "i.redd.it" === e.domain && e.url ? a = e.url : s && s.still && s.still.source && (a = s.still.source.url), {
								type: t,
								obfuscated: r,
								resolutions: D(s, n),
								width: s && s.still && s.still.source ? s.still.source.dimensions.width : 0,
								height: s && s.still && s.still.source ? s.still.source.dimensions.height : 0,
								content: a
							}
						}
						case O.o.EMBED:
							return {
								type: t, obfuscated: r, width: s && s.video && s.video.dimensions && s.video.dimensions.width || 0, height: s && s.video && s.video.dimensions && s.video.dimensions.height || 0, provider: s && s.video && s.video.attribution && s.video.attribution.providerName || "", content: s && s.video && s.video.embedUrl ? s.video.embedUrl : ""
							};
						case O.o.GIFVIDEO:
							return {
								type: t, obfuscated: r, resolutions: D(s, "mp4"), width: s && s.still && s.still.source ? s.still.source.dimensions.width : 0, height: s && s.still && s.still.source ? s.still.source.dimensions.height : 0, gifBackgroundImage: s && s.still && s.still.source ? s.still.source.url : "", content: s && s.animated && s.animated.mp4_source ? s.animated.mp4_source.url : ""
							};
						case O.o.GALLERY: {
							const s = Y(e.gallery);
							return {
								type: t,
								obfuscated: null,
								gallery: s ? s.gallery : null,
								mediaMetadata: s ? s.mediaMetadata : void 0,
								crossPostRootId: z(e.crosspostRoot),
								crossPostParentId: z(e.crosspostRoot),
								numCrossposts: e.crosspostCount || 0,
								isCrosspostable: e.isCrosspostable
							}
						}
						default:
							return null
					}
				},
				M = {
					events: [],
					isBlank: !1,
					isSponsored: !1
				},
				F = /\.gif\?(.*$)/,
				G = e => {
					const t = e.adEvents.find(e => g(e.type) === a.a.Impression),
						s = t && t.url && t.url.match(F);
					return s && s[1] ? "t3_".concat(s[1]) : null
				},
				B = e => e ? e.toLowerCase() : null,
				q = e => {
					let {
						isLive: t,
						startsAt: s,
						endsAt: n
					} = e;
					return {
						eventIsLive: t,
						eventStart: Math.round(Date.parse(s) / 1e3),
						eventEnd: Math.round(Date.parse(n) / 1e3)
					}
				};
			t.a = e => {
				const t = {
						post: J(e)
					},
					{
						crosspostRoot: s
					} = e;
				return s && s.type === f.a.Post && s.postInfo && (t.crosspost = J(s.postInfo)), t
			};
			const V = e => e && e.__typename !== _.c.DeletedRedditor ? "name" in e && e.name || "" : n.A,
				H = e => !(!e || e.__typename !== _.c.AvailableRedditor) && !!e.isPremiumMember,
				K = e => e.content && e.content.richtextMedia && e.content.richtextMedia.length ? W(e.content.richtextMedia) : null,
				W = (e, t) => e.length ? e.reduce((e, t) => {
					switch (t.__typename) {
						case f.c.ImageAsset:
							"image/gif" === t.mimetype ? e[t.id] = {
								e: j.r,
								id: t.id,
								s: {
									gif: t.url,
									x: t.height,
									y: t.width
								}
							} : e[t.id] = {
								e: j.s,
								id: t.id,
								s: {
									u: t.url,
									x: t.height,
									y: t.width
								}
							};
							break;
						case f.c.VideoAsset:
							e[t.id] = {
								dashUrl: t.dashUrl,
								e: j.t,
								hlsUrl: t.hlsUrl,
								id: t.id,
								x: t.height,
								y: t.width
							}
					}
					return e
				}, {}) : null,
				Y = e => {
					if (!(e && "items" in e)) return null;
					const t = e.items,
						s = {},
						n = {
							items: []
						};
					return t.map(e => {
						if (!e.media) return;
						const t = e.media.id;
						if (n.items.push({
								caption: e.caption || void 0,
								id: parseInt(e.id),
								mediaId: t,
								outboundUrl: e.outboundUrl || void 0,
								callToAction: e.callToAction || void 0,
								displayAddress: e.displayAddress || void 0
							}), t && e.media) {
							const n = (e => e.length ? e.reduce((e, t) => {
								const s = !!t.url && t.url.endsWith(".gif");
								return e[t.id] = {
									e: j.s,
									id: t.id,
									m: t.mimetype || "",
									o: k(t),
									p: R(t),
									s: {
										x: t.width || 0,
										y: t.height || 0,
										gif: s && t.url || "",
										u: !s && t.url || ""
									}
								}, e
							}, {}) : null)([e.media]);
							n && (s[t] = n[t])
						}
					}), {
						gallery: n.items.length > 0 ? n : null,
						mediaMetadata: Object.keys(s).length > 0 ? s : null
					}
				},
				z = e => e ? e.type === f.a.Post ? e.postInfo && e.postInfo.id : e.comment && e.comment.id : null,
				J = e => {
					const {
						awardings: t,
						commentCount: s,
						createdAt: a,
						crosspostCount: i,
						crosspostRoot: o,
						discussionType: u,
						domain: b,
						id: p,
						isArchived: O,
						isContestMode: g,
						isFollowed: m,
						isGildable: j,
						isHidden: _,
						isLocked: h,
						isNsfw: y,
						isOriginalContent: E,
						isSaved: C,
						isSpoiler: A,
						isStickied: D,
						liveCommentsWebsocket: P,
						permalink: R,
						removedBy: k,
						removedByCategory: N,
						poll: L,
						score: F,
						suggestedCommentSort: G,
						title: K,
						topAwardedType: W,
						upvoteRatio: Y,
						viewCount: J,
						voteState: Q
					} = e, X = N && "NONE" !== N ? N.toLowerCase() : null, Z = z(o);
					o && !Z && r.c.withScope(e => {
						e.setExtra("postId", p), Object(r.a)(e, {
							serverLogging: !1
						}), r.c.captureMessage("Lack of post or comment in crosspostRoot")
					});
					const $ = t ? Object(d.b)(t) : void 0,
						ee = Object.assign(Object.assign({
							allAwardings: $,
							author: n.A,
							authorId: "",
							approvedAtUTC: null,
							approvedBy: null,
							bannedAtUTC: null,
							bannedBy: null,
							belongsTo: {
								id: "",
								type: "subreddit"
							},
							contestMode: g,
							created: Object(d.d)(a),
							crosspostParentId: Z,
							crosspostRootId: Z,
							discussionType: u,
							distinguishType: null,
							domain: b || "",
							flair: S(e),
							hidden: _,
							id: p,
							ignoreReports: !1,
							isApproved: !1,
							isArchived: O,
							isAuthorPremium: !1,
							isCrosspostable: !1,
							isFollowed: m,
							isGildable: j,
							isLocked: h,
							isMediaOnly: !1,
							isMeta: !1,
							isNSFW: y,
							isOriginalContent: E,
							isPinned: !1,
							isRemoved: !1,
							isScoreHidden: null === F,
							isSpam: !1,
							isSpoiler: A,
							isStickied: D,
							liveCommentsWebsocket: P,
							media: null,
							modReports: [],
							numComments: s || 0,
							numCrossposts: i || 0,
							numReports: null,
							permalink: "https://www.reddit.com".concat(R),
							pollData: L && l(L) || void 0,
							postCategories: null,
							postId: p,
							previewComments: [],
							removedBy: k && k.name ? k.name : null,
							removedByCategory: X,
							saved: C,
							score: null !== F && F > 0 ? F : 0,
							sendReplies: !1,
							source: w(e),
							suggestedSort: G && n.r[G] || null,
							thumbnail: {
								height: null,
								url: "",
								width: null
							},
							title: K || "",
							topAwardedType: W || void 0,
							upvoteRatio: Y,
							userReports: [],
							viewCount: J || 0,
							voteState: Q ? Object(d.c)(Q) : 0
						}, e.__typename === f.f.AdPost ? (e => {
							const {
								adEvents: t,
								callToAction: s,
								domain: n,
								isBlank: r
							} = e;
							return {
								callToAction: s,
								domainOverride: n,
								events: T(t),
								isBlank: r,
								isSponsored: !0
							}
						})(e) : M), Object(c.a)(e));
					if (e.__typename === f.f.DeletedProfilePost || e.__typename === f.f.DeletedSubredditPost) return ee;
					const {
						authorInfo: te,
						authorOnlyInfo: se,
						distinguishedAs: ne,
						isCrosspostable: re,
						isMediaOnly: ae,
						isPollIncluded: ie,
						media: oe,
						postEventInfo: ce
					} = e, de = (e => e && e.still && e.still.source ? Object.assign({
						url: e.still.source.url
					}, e.still.source.dimensions) : void 0)(oe);
					return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ee), {
						author: te && V(te) || n.A,
						authorId: te && te.id || "",
						belongsTo: v(e),
						distinguishType: B(ne),
						isCrosspostable: re,
						isMediaOnly: ae,
						isMeta: ie,
						isAuthorPremium: H(te),
						media: U(e, x(e)),
						thumbnail: I(e)
					}), de && {
						preview: de
					}), se && {
						sendReplies: se.isReceivingPostReplies
					}), ce && {
						eventInfo: q(ce)
					})
				}
		},
		"./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const r = e => {
				let {
					edges: t
				} = e;
				const s = [];
				for (const {
						node: r
					} of t) s.push(Object(n.e)(r));
				return s
			}
		},
		"./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/models/User/index.ts");
			s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var a = function(e) {
				return e.replace(/(\+\d{2})(\d{2})$/, "$1:$2")
			};
			t.a = (e, t) => ({
				allowClickTracking: e.isClickTrackingEnabled,
				autoplayVideo: !e.isVideoAutoplayDisabled,
				defaultCommentSort: e.defaultCommentSort && r.b[e.defaultCommentSort] ? n.r[e.defaultCommentSort] : n.r.CONFIDENCE,
				geopopular: e.geopopular,
				hideNSFW: e.isNsfwMediaBlocked,
				ignoreSuggestedSort: e.isSuggestedSortIgnored,
				labelNSFW: e.isNsfwLabelShown,
				markMessagesRead: e.isMessageAutoReadEnabled,
				nightmode: e.isNightModeEnabled,
				over18: e.isNsfwContentShown,
				reduceAnimationsFromAwards: e.isReduceAnimationsFromAwardsEnabled,
				showLocationBasedRecommendations: e.isLocationBasedRecommendationEnabled,
				account: {
					openPostInNewTab: e.isNewTabOpenedForPostView,
					rpanDuDismissalTime: e.rpanDuDismissedAt && a(e.rpanDuDismissedAt),
					sort: e.globalCommunityPostFeedSort.range ? "".concat(e.globalCommunityPostFeedSort.sort.toLowerCase(), "_").concat(e.globalCommunityPostFeedSort.range.toLowerCase()) : e.globalCommunityPostFeedSort.sort.toLowerCase(),
					showRpanDu: e.isRpanDuShown,
					stylesEnabled: e.isCommunityStylingEnabled,
					rememberCommunitySort: e.isCommunityPostFeedSortingPreserved,
					useMarkdown: e.isMarkdownDefaultEditorMode,
					rememberCommunityLayout: e.isCommunityLayoutPreserved,
					layout: e.postFeedLayout.toLowerCase(),
					hasSeenCustomizeFlyout: t && t.isDefaultPostLayoutAware,
					surveyLastSeenTime: e.surveyLastSeenAt ? new Date(e.surveyLastSeenAt).getTime() : void 0
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			}));
			var n = s("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				r = s("./src/reddit/models/Subreddit/index.ts"),
				a = s("./src/reddit/models/User/index.ts"),
				i = s("./src/reddit/models/WhitelistStatus/index.ts");
			const o = e => {
				let {
					pageInfo: t,
					edges: s
				} = e;
				const r = {
					moderatedSubredditIds: [],
					pageInfo: t,
					subreddits: {}
				};
				for (const {
						node: a
					} of s) {
					const e = Object(n.a)(a);
					r.subreddits[e.id] = e, r.moderatedSubredditIds.push(e.id)
				}
				return r
			};
			t.a = e => {
				let {
					name: t,
					path: s,
					redditorInfo: n,
					styles: o,
					wls: c,
					id: d,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				} = e;
				const {
					height: O,
					icon: g,
					width: f
				} = o && o.legacyIcon && {
					height: o.legacyIcon.dimensions.height,
					icon: o.legacyIcon.url,
					width: o.legacyIcon.dimensions.width
				} || {
					height: null,
					icon: o && o.icon || "",
					width: null
				}, m = o && o.legacyPrimaryColor, j = n && n.__typename === a.c.AvailableRedditor && n.prefixedName || "";
				return Object.assign(Object.assign(Object.assign({
					url: s,
					displayText: j,
					icon: {
						url: g,
						width: f,
						height: O
					},
					communityIcon: g,
					type: r.e.User,
					name: t.substr(2)
				}, m && {
					primaryColor: m
				}), c && {
					whitelistStatus: c.toLowerCase(),
					wls: i.b[c]
				}), {
					id: d,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/reddit/helpers/graphql/helpers.ts"),
				r = s("./src/reddit/helpers/graphql/normalizeAllowedPostTypesFromGql/index.ts");
			const a = e => {
					const t = Object(r.a)(e.allowedPostTypes),
						s = e.moderation ? e.moderation.coins : void 0;
					return {
						[e.id]: {
							accountsActive: e.activeCount,
							activity7Day: e.activity7Day,
							allOriginalContent: !1,
							allowedPostTypes: t,
							allowChatPostCreation: e.isChatPostCreationAllowed,
							coins: s,
							created: Object(n.d)(e.createdAt),
							disableContributorRequests: !1,
							emojisEnabled: !0,
							isChatPostFeatureEnabled: e.isChatPostFeatureEnabled,
							isCrosspostableSubreddit: e.isCrosspostDestination,
							isLiveStreamingEnabled: e.liveStreamingInfo.isLiveStreamingEnabled,
							originalContentTagEnabled: !0,
							powerups: e.powerups,
							publicDescription: e.publicDescription.markdown,
							restrictCommenting: !1,
							restrictPosting: !0,
							showMedia: !0,
							subscribers: e.subscribersCount,
							userIsBanned: e.isUserBanned,
							userIsContributor: e.isContributor,
							userIsSubscriber: e.isSubscribed,
							usingNewModmail: !0
						}
					}
				},
				i = e => e.reduce((e, t) => Object.assign(Object.assign({}, e), a(t)), {});
			t.a = a
		},
		"./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "f", (function() {
				return O
			})), s.d(t, "e", (function() {
				return g
			}));
			var n = s("./node_modules/lodash/some.js"),
				r = s.n(n),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				o = s("./src/reddit/models/GqlTopLevelField.ts"),
				c = s("./src/reddit/models/WhitelistStatus/index.ts");
			const d = e => e.subredditRecommendations.recommendations.map(l).reduce((e, t) => (e[t.id] = t, e), {}),
				u = e => {
					const t = {
							posts: {},
							subredditTopContent: {}
						},
						s = [],
						{
							__typename: n
						} = e;
					if (n !== o.a.Subreddit) return null;
					const {
						id: r,
						isSubscribed: c,
						name: d,
						topContent: u
					} = e, {
						posts: l,
						range: b
					} = u;
					return l.forEach(e => {
						const {
							post: n,
							crosspost: r
						} = Object(i.a)(e), a = n.id;
						if (t.posts[a] = n, s.push(a), r) {
							const e = r.id;
							t.posts[e] = r
						}
					}), t.subredditTopContent[d.toLowerCase()] = {
						id: r,
						isSubscribed: c,
						name: d,
						postIds: s,
						range: a.Sb[b]
					}, t
				},
				l = e => {
					const {
						path: t,
						prefixedName: s,
						type: n,
						styles: r,
						wls: a,
						id: i,
						isQuarantined: o,
						isNSFW: d,
						name: u,
						subscribers: l,
						title: b,
						isFreeFormReportingAllowed: p
					} = e, {
						height: O,
						icon: g,
						width: f
					} = r && r.legacyIcon && {
						height: r.legacyIcon.dimensions.height,
						icon: r.legacyIcon.url,
						width: r.legacyIcon.dimensions.width
					} || {
						height: null,
						icon: r && r.icon || "",
						width: null
					}, m = r && r.primaryColor, j = r && r.icon;
					return Object.assign(Object.assign(Object.assign(Object.assign({
						url: t,
						displayText: s,
						icon: {
							url: g,
							width: f,
							height: O
						}
					}, j && {
						communityIcon: j
					}), {
						type: n.toLowerCase(),
						primaryColor: m || ""
					}), a && {
						whitelistStatus: a.toLowerCase(),
						wls: c.b[a]
					}), {
						freeFormReports: p,
						id: i,
						isQuarantined: o,
						isNSFW: d,
						name: u,
						subscribers: l,
						title: b
					})
				},
				b = (e, t) => ({
					isMod: r()(e),
					modAccess: e.isAccessEnabled,
					modConfig: e.isConfigEditingAllowed,
					modFlair: e.isFlairEditingAllowed,
					modFull: e.isAllAllowed,
					modMail: e.isMailEditingAllowed,
					modNone: !r()(e),
					modPost: e.isPostEditingAllowed,
					modWiki: e.isWikiEditingAllowed,
					isSubscriber: t
				}),
				p = e => e.reduce((e, t) => {
					const s = l(t);
					return e[s.id] = s, e
				}, {}),
				O = e => e,
				g = e => e.subredditsInfoByIds.reduce((e, t) => {
					let {
						id: s,
						notificationSettings: n
					} = t;
					return e[s] = n, e
				}, {});
			t.a = l
		},
		"./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				let {
					isAccessEnabled: t,
					isAllAllowed: s,
					isChatConfigEditingAllowed: n,
					isChatOperator: r,
					isConfigEditingAllowed: a,
					isFlairEditingAllowed: i,
					isMailEditingAllowed: o,
					isPostEditingAllowed: c,
					isWikiEditingAllowed: d
				} = e;
				return {
					access: !!t,
					all: !!s,
					chatConfig: !!n,
					chatOperator: !!r,
					config: !!a,
					flair: !!i,
					mail: !!o,
					posts: !!c,
					wiki: !!d
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			t.a = e => {
				const t = {
					menuPosition: e.menuPosition ? e.menuPosition.toLowerCase() : void 0,
					bannerCommunityNameFormat: e.bannerCommunityNameFormat ? e.bannerCommunityNameFormat.toLowerCase() : void 0,
					bannerShowCommunityIcon: e.bannerShowCommunityIcon ? e.bannerShowCommunityIcon.toLowerCase() : void 0,
					bannerHeight: e.bannerHeight ? e.bannerHeight.toLowerCase() : void 0,
					postVoteIcons: e.postVoteIcons ? e.postVoteIcons.toLowerCase() : void 0,
					submenuBackgroundStyle: e.submenuBackgroundStyle ? e.submenuBackgroundStyle.toLowerCase() : void 0,
					backgroundImagePosition: e.backgroundImagePosition ? e.backgroundImagePosition.toLowerCase() : void 0,
					bannerBackgroundImagePosition: e.bannerBackgroundImagePosition ? e.bannerBackgroundImagePosition.toLowerCase() : void 0,
					bannerPositionedImagePosition: e.bannerPositionedImagePosition ? e.bannerPositionedImagePosition.toLowerCase() : void 0,
					postBackgroundImagePosition: e.postBackgroundImagePosition ? e.postBackgroundImagePosition.toLowerCase() : void 0,
					postPlaceholderImagePosition: e.postPlaceholderImagePosition ? e.postPlaceholderImagePosition.toLowerCase() : void 0,
					menuBackgroundOpacity: e.menuBackgroundOpacity || void 0,
					backgroundImage: e.backgroundImage || void 0,
					bannerBackgroundImage: e.bannerBackgroundImage || void 0,
					bannerPositionedImage: e.bannerPositionedImage || void 0,
					communityIcon: e.icon || void 0,
					menuBackgroundImage: e.menuBackgroundImage || void 0,
					postBackgroundImage: e.postBackgroundImage || void 0,
					postDownvoteIconActive: e.postDownvoteIconActive || void 0,
					postDownvoteIconInactive: e.postDownvoteIconInactive || void 0,
					postPlaceholderImage: e.postPlaceholderImage || void 0,
					postUpvoteIconActive: e.postUpvoteIconActive || void 0,
					postUpvoteIconInactive: e.postUpvoteIconInactive || void 0,
					bannerBackgroundColor: e.bannerBackgroundColor || void 0,
					bannerOverlayColor: e.bannerOverlayColor || void 0,
					menuBackgroundColor: e.menuBackgroundColor || void 0,
					menuLinkColorActive: e.menuLinkColorActive || void 0,
					menuLinkColorInactive: e.menuLinkColorInactive || void 0,
					menuLinkColorHover: e.menuLinkColorHover || void 0,
					submenuBackgroundColor: e.submenuBackgroundColor || void 0,
					primaryColor: e.primaryColor || void 0,
					highlightColor: e.highlightColor || void 0,
					postTitleColor: e.postTitleColor || void 0,
					backgroundColor: e.backgroundColor || void 0,
					postBackgroundColor: e.postBackgroundColor || void 0,
					postDownvoteCountColor: e.postDownvoteCountColor || void 0,
					postUpvoteCountColor: e.postUpvoteCountColor || void 0,
					mobileKeyColor: e.mobileKeyColor || void 0,
					mobileBannerImage: e.mobileBannerImage || void 0,
					sidebarWidgetHeaderColor: e.sidebarWidgetHeaderColor || void 0,
					sidebarWidgetBackgroundColor: e.sidebarWidgetBackgroundColor || void 0,
					secondaryBannerPositionedImage: e.secondaryBannerPositionedImage || void 0
				};
				return Object.keys(t).forEach(e => {
					void 0 === t[e] && delete t[e]
				}), t
			}
		},
		"./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return u
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/reddit/models/User/index.ts"),
				r = s("./src/reddit/helpers/graphql/helpers.ts"),
				a = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const i = e => e && e.expiresAt && Object(r.d)(e.expiresAt, r.a.Seconds) / 1e3 || null,
				o = e => e && e.unreadCount ? e.unreadCount : 0,
				c = /^u\//,
				d = e => e.replace(c, "/user/"),
				u = e => e.__typename === n.c.DeletedRedditor ? null : "name" in e && e.name || null;
			t.a = e => {
				var {
					redditor: t,
					inbox: s,
					premium: c,
					preferences: u,
					coins: l
				} = e, b = a(e, ["redditor", "inbox", "premium", "preferences", "coins"]);
				let p = {
					awardeeKarma: 0,
					awarderKarma: 0,
					commentKarma: 0,
					hasUserProfile: !1,
					id: t.id,
					isGold: !1,
					postKarma: 0,
					totalKarma: 0,
					url: ""
				};
				if (t.__typename === n.c.AvailableRedditor) {
					const {
						karma: e,
						profile: s
					} = t, n = s && s.styles && s.styles.legacyIcon && s.styles.legacyIcon.url;
					p = Object.assign(Object.assign(Object.assign({}, p), n && {
						accountIcon: n
					}), {
						awardeeKarma: e ? e.fromAwardsReceived : 0,
						awarderKarma: e ? e.fromAwardsGiven : 0,
						commentKarma: e ? e.fromComments : 0,
						displayText: t.name,
						hasExternalAccount: t.isLinkedToExternalAccount,
						hasUserProfile: !!s,
						isGold: !!t.isGilded,
						postKarma: e ? e.fromPosts : 0,
						totalKarma: e ? e.total : 0,
						profileId: s && s.id || void 0,
						url: t.prefixedName && d(t.prefixedName) || void 0
					})
				}
				const {
					interactions: O,
					modMail: g
				} = b;
				return Object.assign(Object.assign(Object.assign({}, p), {
					coins: l,
					created: Object(r.d)(b.createdAt, r.a.Seconds) / 1e3,
					goldExpiration: i(c),
					hasUnreadMail: o(s) > 0,
					hasUnreadModmail: !!g && g.isUnread,
					hasUnreadOldModmail: !!g && g.isUnread,
					hasVerifiedEmail: !!b.isEmailVerified,
					inboxCount: o(s),
					inRedesignBeta: u.isInRedesignBeta,
					isEmployee: !!b.isEmployee,
					isFPR: !!b.isForcePasswordReset,
					isNameEditable: !!b.isNameEditable,
					isMod: !!b.isModerator,
					isPasswordSet: !!b.isPasswordSet,
					isSuspended: b.isSuspended,
					nightmode: u.isNightModeEnabled,
					seenLayoutSwitch: !!O && O.isLayoutSwitchAware,
					seenRedesignModal: !!O && O.isRedesignModalAware,
					seenSubredditChatFtux: !!O && O.isSubredditChatAware,
					showRecentPosts: u.isRecentPostsShown,
					showTrending: u.isTrendingSubredditsShown
				}), c && c.subscription && {
					hasAndroidSubscription: c.subscription.isAndroidAvailable,
					hasGoldSubscription: c.subscription.isGoldAvailable,
					hasIOSSubscription: c.subscription.isIOSAvailable,
					hasPaypalSubscription: c.subscription.isPaypalAvailable,
					hasStripeSubscription: c.subscription.isStripeAvailable
				})
			}
		},
		"./src/reddit/helpers/history/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			}));
			var n = s("./node_modules/lodash/omit.js"),
				r = s.n(n);
			const a = (e, t) => {
					const s = history.state ? history.state.state : {},
						n = Object.assign(Object.assign({}, history.state), {
							state: Object.assign(Object.assign({}, s), {
								[e]: t
							})
						});
					history.replaceState(n, window.document.title)
				},
				i = e => {
					const t = Object.assign(Object.assign({}, history.state), {
						state: Object.assign({}, r()(history.state.state, e))
					});
					history.replaceState(t, window.document.title)
				},
				o = e => history && history.state && history.state.state && history.state.state[e]
		},
		"./src/reddit/helpers/isArrayEqual.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/isEqual.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/xorWith.js"),
				i = s.n(a);
			t.a = (e, t) => {
				const s = i()(e, t, r.a);
				return !(!s || 0 !== s.length)
			}
		},
		"./src/reddit/helpers/loadThirdPartyScript.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/config.ts"),
				r = s("./src/lib/fastdom/index.ts");
			const a = "https://js.stripe.com/v3/",
				i = "https://www.paypalobjects.com/api/checkout.js",
				o = {
					checkout: "https://js.braintreegateway.com/web/3.44.2/js/paypal-checkout.min.js",
					client: "https://js.braintreegateway.com/web/3.44.2/js/client.min.js",
					paypal: "https://www.paypal.com/sdk/js?client-id=".concat(n.a.paypal.braintreeApiKey) + "&currency=USD&vault=true"
				};

			function c(e, t) {
				return t() ? Promise.resolve() : new Promise((s, n) => r.a.write(() => {
					t() && s();
					const n = document.head;
					let r = n.querySelector("script[src='".concat(e, "']"));
					r || ((r = document.createElement("script")).src = e, n.appendChild(r)), r.addEventListener("load", (function e() {
						this.removeEventListener("load", e), s()
					}))
				}))
			}

			function d() {
				return c(a, () => "undefined" != typeof Stripe)
			}

			function u() {
				return c(i, () => "undefined" != typeof paypalCheckout).then(() => {
					"undefined" == typeof paypalCheckout && "undefined" != typeof window && (window.paypalCheckout = paypal), paypal = void 0
				})
			}

			function l() {
				return Promise.all(Object.keys(o).map(e => {
					const t = "__" + e;
					return c(o[e], () => void 0 !== window[t]).then(() => {
						window[t] = !0
					})
				}))
			}
		},
		"./src/reddit/helpers/makeModQueueListingKey/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				const {
					profile: t,
					subreddit: s
				} = e;
				let n = s && "r/".concat(s) || t && "u/".concat(t) || "all";
				return "comments" !== e.onlyOfType && "links" !== e.onlyOfType || (n += "--[".concat(e.onlyOfType, "]")), n
			}
		},
		"./src/reddit/helpers/makeProfileListingKey/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeListingKey/index.ts");
			const a = (e, t) => "".concat(n.Ub).concat(e.toLowerCase(), "--private--").concat(t);
			t.a = function(e, t, s) {
				let a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
				const i = "".concat(n.Ub).concat(e, "--").concat(t);
				return Object(r.a)(i, s, a)
			}
		},
		"./src/reddit/helpers/normalizeUsername/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = e => {
				const t = /^((\/u\/)|(u\/))/;
				return /^((\/u\/)|(u\/))(.+)/.test(e) ? e.replace(t, "") : e
			}
		},
		"./src/reddit/helpers/onBeforeRequestFactory/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = s.n(n),
				a = s("./src/config.ts"),
				i = s("./src/lib/addQueryParams/index.ts"),
				o = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.regexp.constructor.js"), s("./src/reddit/selectors/subreddit.ts"));
			const c = new RegExp("^/desktopapi/v1/(duplicates/[^/]+|frontpage|news|search|subreddits/(all|popular))(/|$)"),
				d = new RegExp("^/desktopapi/v1/(search|subreddits|postcomments|collection_postcomments|submitpage)(/|$)"),
				u = new RegExp("^/desktopapi/v1/(subreddits|postcomments|collection_postcomments)/?$"),
				l = (new RegExp("^/desktopapi/v1/(postcomments)(/+|$)"), new RegExp("^/desktopapi/v1/frontpage/?$")),
				b = new RegExp("^/desktopapi/v1/submitpage(/|$)");
			var p = (e, t, s) => {
					const n = new Set;
					e.user.session && !e.user.session.unsafeLoggedOut && (e.user.account || (n.add("identity"), n.add("prefs"), n.add("prefsAccount")), (e => !c.test(e.pathname || ""))(t) && n.add("identity")), !e.live.isFrontpageLoaded && (e => l.test(e.pathname || ""))(t) && n.add("featuredLiveThread");
					const r = t.pathname || "";
					if (d.test(r) || u.test(r)) {
						const r = ((e, t) => {
								if (b.test(e.pathname || "")) {
									const {
										subreddit: e
									} = t.data;
									return e
								}
							})(t, s),
							a = e.platform.currentPage,
							i = a && a.urlParams.subredditName,
							c = r || i || "",
							d = Object(o.G)(e, c);
						d && e.structuredStyles.models[d] || n.add("structuredStyles"), e.user.prefs.subreddit[d] || n.add("prefsSubreddit")
					}
					return [...n].join(",")
				},
				O = s("./src/reddit/selectors/user.ts");
			t.a = e => t => {
				const s = r.a.parse(t.endpoint, !0),
					{
						host: n,
						protocol: o
					} = s;
				if ("".concat(o, "//").concat(n) === a.a.gatewayUrl) {
					const n = {},
						r = Object(O.X)(e.getState()) ? "1" : "";
					n.allow_over18 = r, n.include = p(e.getState(), s, t), t.endpoint = Object(i.a)(t.endpoint, n)
				}
			}
		},
		"./src/reddit/helpers/ordinal/index.ts": function(e, t, s) {
			"use strict";
			t.a = function(e) {
				const t = ["th", "st", "nd", "rd"],
					s = e % 100;
				return e + (t[(s - 20) % 10] || t[s] || t[0])
			}
		},
		"./src/reddit/helpers/overlay/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			}));
			var n = s("./node_modules/history/esm/history.js"),
				r = s("./node_modules/react-router-redux/es/index.js"),
				a = s("./src/reddit/helpers/path/index.ts");
			const i = e => {
					if ("string" == typeof e) return Object(n.c)(Object(a.b)(e), {
						isOverlay: !0
					}); {
						const t = Object(n.c)(e);
						return t.state = Object.assign(Object.assign({}, t.state || {}), {
							isOverlay: !0
						}), t
					}
				},
				o = e => Object(r.b)(i(e))
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/history/esm/history.js"), s("./src/reddit/actions/platform.ts");
			var n = s("./src/config.ts");
			t.a = (e, t) => {
				const s = t.platform.currentPage && t.platform.currentPage.url;
				let r = "".concat(n.a.accountManagerOrigin, "/login/");
				const a = window.location.origin;
				s && (r += "?dest=".concat(encodeURIComponent("".concat(a).concat(s)))), window.location.href = r
			}
		},
		"./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			}));
			var n = s("./src/reddit/models/Gold/Award.ts");
			t.a = e => e.map(e => ({
				awardType: e.award_type,
				awardSubType: e.award_sub_type ? e.award_sub_type : n.b.Global,
				coinPrice: e.coin_price,
				coinReward: e.coin_reward,
				count: e.count,
				daysOfDripExtension: e.days_of_drip_extension,
				daysOfPremium: e.days_of_premium,
				description: e.description,
				iconUrl: e.icon_url,
				resizedIcons: e.resized_icons,
				resizedStaticIcons: e.resized_static_icons,
				id: e.id,
				isEnabled: e.is_enabled,
				isNew: !!e.is_new,
				name: e.name,
				staticIconUrl: e.static_icon_url,
				subredditCoinReward: e.subreddit_coin_reward,
				tags: e.tags,
				tiers: Object(n.n)(e.tiersByRequiredAwardings)
			}));
			const r = e => {
					const {
						icon_url: t,
						resized_icons: s,
						resized_static_icons: r,
						static_icon_url: a
					} = e;
					let i, o, c, d, u, l;
					for (const {
							url: n,
							width: b
						} of s || []) 32 === b && (i = {
						url: n
					}), 64 === b && (o = {
						url: n
					}), 128 === b && (c = {
						url: n
					});
					for (const {
							url: n,
							width: b
						} of r || []) 32 === b && (d = {
						url: n
					}), 64 === b && (u = {
						url: n
					}), 128 === b && (l = {
						url: n
					});
					return {
						awardType: e.award_type.toUpperCase(),
						awardSubType: e.award_sub_type ? e.award_sub_type.toUpperCase() : n.d.Global,
						coinPrice: e.coin_price,
						coinReward: e.coin_reward,
						daysOfDripExtension: e.days_of_drip_extension,
						daysOfPremium: e.days_of_premium,
						description: e.description,
						id: e.id,
						isEnabled: e.is_enabled,
						isNew: !!e.is_new,
						name: e.name,
						icon: {
							url: t
						},
						icon32: i,
						icon64: o,
						icon128: c,
						staticIcon: {
							url: a
						},
						staticIcon32: d,
						staticIcon64: u,
						staticIcon128: l,
						subredditCoinReward: e.subreddit_coin_reward,
						tags: e.tags,
						tiers: Object(n.n)(e.tiersByRequiredAwardings)
					}
				},
				a = e => {
					const {
						top_award: t,
						total_count: s
					} = e;
					return {
						topAward: t && r(t),
						totalCount: s
					}
				}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return d
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/helpers/isComment.ts"),
				a = s("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				i = s("./src/reddit/models/Vote/index.ts"),
				o = e => !0 === e ? i.a.upvoted : !1 === e ? i.a.downvoted : i.a.notVoted,
				c = s("./src/reddit/models/Comment/index.ts");
			t.a = (e, t) => {
				const s = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					created: e.created_utc,
					deletedBy: u(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === n.A,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					isSystem: !1,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: d(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(r.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: o(e.likes)
				};
				return e.all_awardings && (s.allAwardings = Object(a.a)(e.all_awardings)), e.awarders && (s.awarders = e.awarders), e.associated_award && (s.associatedAwardId = e.associated_award.id, s.associatedAward = Object(a.b)(e.associated_award)), s
			};
			const d = e => "string" == typeof e ? JSON.parse(e) : e,
				u = e => e.author !== n.A ? null : e.body === n.B ? c.a.User : e.body === n.Ab ? c.a.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				r = s("./src/reddit/models/Flair/index.ts"),
				a = s("./src/reddit/models/Media/index.ts"),
				i = s("./src/reddit/models/PostCreationForm/index.ts"),
				o = s("./src/reddit/models/Vote/index.ts");
			const c = e => {
					const t = [];
					return e.link_flair_richtext && e.link_flair_richtext.length && t.push({
						richtext: e.link_flair_richtext,
						type: r.f.Richtext,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.link_flair_text && t.push({
						text: e.link_flair_text,
						type: r.f.Text,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.spoiler && t.push({
						text: "spoiler",
						type: r.f.Spoiler
					}), e.over_18 && t.push({
						text: "nsfw",
						type: r.f.Nsfw
					}), t
				},
				d = e => e ? e.map(e => ({
					categoryId: e.category_id,
					categoryName: e.category_name
				})) : [],
				u = e => {
					const t = e.preview && e.preview.enabled;
					let s = !1,
						n = null,
						r = {},
						o = {};
					const c = e.over_18 || e.spoiler;
					if (e.preview && (s = !!(o = e.preview.images[0].variants).mp4, r = e.preview.images[0].source, c && (n = o.obfuscated.source.url)), e.is_self) return Object.assign({
						content: e.selftext_html,
						type: a.o.TEXT,
						markdownContent: e.selftext,
						obfuscated: n,
						rteMode: e.rte_mode || i.h.RICH_TEXT
					}, e.rtjson && {
						richtextContent: e.rtjson,
						type: a.o.RTJSON,
						mediaMetadata: e.media_metadata
					});
					if (e.media && e.media.reddit_video) {
						const t = e.media.reddit_video;
						return {
							hlsUrl: t.hls_url,
							dashUrl: t.dash_url,
							isGif: t.is_gif,
							scrubberThumbSource: t.scrubber_media_url,
							obfuscated: n,
							posterUrl: t.url,
							width: t.width,
							height: t.height,
							type: a.o.VIDEO
						}
					}
					if (e.media && e.media.rpan_video) {
						const t = e.media.rpan_video;
						return {
							hlsUrl: t.hls_url,
							scrubberThumbSource: t.scrubber_media_url,
							type: a.o.LIVEVIDEO
						}
					}
					if (e.secure_media && e.secure_media.oembed) {
						return {
							content: e.secure_media_embed.media_domain_url,
							type: a.o.EMBED,
							width: e.secure_media.oembed.width,
							height: e.secure_media.oembed.height,
							obfuscated: n,
							provider: e.secure_media.oembed.provider_name
						}
					}
					if (t && s) return {
						content: o.mp4.source.url,
						type: a.o.GIFVIDEO,
						width: o.mp4.source.width,
						height: o.mp4.source.height,
						gifBackgroundImage: r.url,
						gifBackgroundResolutions: e.preview.images[0].resolutions,
						obfuscated: n,
						resolutions: o.mp4.resolutions
					};
					if (t) {
						const t = o.gif ? o.gif.resolutions : e.preview.images[0].resolutions;
						return {
							content: r.url,
							type: a.o.IMAGE,
							width: r.width,
							height: r.height,
							obfuscated: n,
							resolutions: t
						}
					}
					return null
				},
				l = e => {
					const t = {};
					if (e.promoted && e.outbound_link || !e.is_self && !e.is_reddit_media_domain) {
						if (t.displayText = e.domain, t.url = e.url, e.outbound_link) {
							const s = e.outbound_link;
							t.outboundUrl = s.url, t.outboundUrlExpiration = s.expiration, t.outboundUrlCreated = s.created
						}
						return t
					}
					return null
				};
			t.a = e => {
				return {
					allAwardings: e.all_awardings ? Object(n.a)(e.all_awardings) : [],
					awarders: e.awarders,
					author: e.author,
					authorId: e.author_fullname,
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					belongsTo: {
						type: "user" === e.subreddit_type ? "profile" : "subreddit",
						id: e.subreddit_id || ""
					},
					callToAction: e.call_to_action || null,
					contestMode: e.contest_mode,
					created: 1e3 * e.created,
					crosspostParentId: e.cross_post_parent_id || null,
					crosspostRootId: e.cross_post_root_id || null,
					discussionType: e.discussion_type || null,
					distinguishType: e.distinguish_type || null,
					domain: e.domain,
					domainOverride: e.domain_override || null,
					events: e.events || [],
					flair: c(e),
					hidden: e.hidden,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isApproved: e.approved,
					isArchived: e.archived,
					isAuthorPremium: e.author_premium,
					isBlank: e.is_blank,
					isCrosspostable: e.is_crosspostable,
					isFollowed: e.is_followed || !1,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMediaOnly: e.media_only,
					isMeta: e.is_meta,
					isNSFW: e.over_18,
					isOriginalContent: e.is_original_content,
					isPinned: e.pinned,
					isRemoved: e.removed,
					isSpam: e.spam,
					isSpoiler: e.spoiler,
					isSponsored: e.promoted,
					isStickied: e.stickied,
					liveCommentsWebsocket: e.liveCommentsWebsocket || e.websocket_url,
					media: u(e),
					modNote: e.mod_note || null,
					modReports: e.mod_reports,
					numComments: e.num_comments,
					numCrossposts: e.num_crossposts || 0,
					numDuplicates: e.num_duplicates,
					numReports: e.num_reports || 0,
					permalink: "https://www.reddit.com".concat(e.permalink),
					postCategories: d(e.post_categories),
					preview: e.preview && e.preview.images && e.preview.images[0] && e.preview.images[0].source ? {
						url: e.preview.images[0].source.url,
						width: e.preview.images[0].source.width,
						height: e.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: e.previous_visits,
					postId: e.name,
					modRemovalReason: e.mod_reason_title,
					modReasonBy: e.mod_reason_by,
					removedBy: e.removed_by,
					removedByCategory: e.removed_by_category,
					saved: e.saved,
					score: e.score,
					topAwardedType: e.top_awarded_type && e.top_awarded_type.toUpperCase(),
					treatmentTags: e.treatment_tags,
					isScoreHidden: !!e.hide_score,
					sendReplies: e.send_replies,
					source: l(e),
					suggestedSort: e.suggested_sort,
					thumbnail: {
						url: e.thumbnail,
						width: e.thumbnail_width,
						height: e.thumbnail_height
					},
					title: e.title,
					userReports: e.user_reports,
					upvoteRatio: e.upvote_ratio,
					viewCount: e.view_count || 0,
					voteState: Object(o.d)(e.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				r = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			t.a = (e, t) => {
				const s = Object(n.a)(e),
					{
						wls: a
					} = s,
					i = r(s, ["wls"]);
				return Object.assign(Object.assign({}, i), {
					name: t
				})
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/lib/constants/index.ts");
			const r = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case n.E.NO_STRIPE_SUBSCRIPTION:
							case n.E.USER_DOESNT_EXIST:
							case n.E.USER_REQUIRED_ERROR:
							case n.E.VALIDATION_ERROR:
								return e;
							case n.E.NO_USER:
							case n.E.NO_TEXT:
							case n.E.NO_URL:
								return n.E.VALIDATION_ERROR;
							case n.E.CREDIT_CARD_FAILURE:
							case n.E.CREDIT_CARD_FAILURE_GENERIC:
								return n.E.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return n.E.SUBMIT_VALIDATION_ERROR
						}
					}
					return n.E.VALIDATION_ERROR
				},
				a = e => {
					const t = e.body;
					return {
						type: r(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				i = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? Object.assign(Object.assign({}, e), {
						error: a(e)
					}) : e
				};
			t.a = a
		},
		"./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => ({
				allowContractors: e.allow_contractors,
				communityIcon: e.community_icon,
				displayText: e.display_name_prefixed,
				icon: {
					height: e.icon_size ? e.icon_size[1] : 0,
					url: e.community_icon || e.icon_img || "",
					width: e.icon_size ? e.icon_size[0] : 0
				},
				id: e.name,
				isNSFW: e.over_18 || e.over18,
				isQuarantined: !!e.quarantine,
				name: e.display_name,
				primaryColor: e.primary_color,
				subscribers: e.subscribers,
				title: e.title,
				type: e.subreddit_type,
				url: e.url,
				wls: e.wls
			})
		},
		"./src/reddit/helpers/redesignOptoutCookie/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			}));
			var n = s("./src/config.ts"),
				r = s("./node_modules/js-cookie/src/js.cookie.js"),
				a = s.n(r);
			const i = "redesign_optout";

			function o() {
				const e = new Date;
				return e.setFullYear(e.getFullYear() + 3), e
			}

			function c() {
				a.a.get(i) || a.a.set(i, "true", {
					domain: n.a.cookieDomain,
					expires: o()
				})
			}

			function d() {
				a.a.get(i) && a.a.remove(i, {
					domain: n.a.cookieDomain
				})
			}
		},
		"./src/reddit/helpers/reportPage/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "c", (function() {
				return O
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "a", (function() {
				return f
			}));
			s("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var n = s("./src/reddit/models/RulesSequence/index.ts");
			const r = "(?:old\\.reddit\\.".concat("(?:com|local)", "|new\\.reddit\\.").concat("(?:com|local)", "|reddit\\.").concat("(?:com|local)", "|www\\.reddit\\.").concat("(?:com|local)", ")"),
				a = "(?:".concat("(?:r)", "|").concat("(?:user|u)", ")"),
				i = "(?:https?://)",
				o = "^".concat(i).concat(r, "/").concat(a, "/").concat("(?:[^/]+)", "/comments/").concat("(?:\\w+)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "(?:/.*)?"),
				c = "^".concat(i).concat(r, "/").concat(a, "/").concat("(?:[^/]+)", "/comments/").concat("(\\w+)", "(?:/.*)?"),
				d = "^".concat(i).concat(r, "/message/messages/").concat("(\\w+)", "(?:/.*)?"),
				u = "^".concat(i, "?").concat("(?:mod.reddit.com/mail)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "(?:/)?$"),
				l = "^".concat(i, "?").concat("(?:mod.reddit.com/mail)", "/").concat("(?:[^/]+)", "/").concat("(\\w+)", "/").concat("(\\w+)", "(?:/)?$"),
				b = "(?:".concat(c, "|").concat(o, "|").concat(d, "|").concat(u, "|").concat(l, ")"),
				p = "(?:(?:".concat(i, "?").concat(r, "/)?").concat("(?:user|u)", "/)?").concat("([\\w-]+)", "(?:/)?"),
				O = "(?:(?:".concat(i, "?").concat(r, "/)?").concat("(?:r)", "/)?").concat("([\\w-]+)", "(?:/)?"),
				g = e => {
					const t = new RegExp(o),
						s = new RegExp(c),
						n = new RegExp(d),
						r = new RegExp(u),
						a = new RegExp(l);
					let i, b, g;
					if (e.thingUrl) {
						const o = e.thingUrl.trim();
						if (t.test(o)) {
							const e = t.exec(o);
							e && e.length > 1 && (i = "t1_" + e[1])
						} else if (s.test(o)) {
							const e = s.exec(o);
							e && e.length > 1 && (i = "t3_" + e[1])
						} else if (n.test(o)) {
							const e = n.exec(o);
							e && e.length > 1 && (i = "t4_" + e[1])
						} else if (a.test(o)) {
							const e = a.exec(o);
							e && e.length > 2 && (b = e[1], g = e[2])
						} else if (r.test(o)) {
							const e = r.exec(o);
							e && e.length > 1 && (b = e[1])
						}
					}
					const f = new RegExp(p),
						m = new RegExp(O),
						j = [];
					let _;
					if (e.subredditName) {
						const t = e.subredditName.trim();
						if (m.test(t)) {
							const e = m.exec(t);
							e && e.length > 1 && (_ = e[1])
						}
					}
					if (e.usernames && e.usernames.length)
						for (let o = 0; o < e.usernames.length; o++) {
							const t = e.usernames[o].trim();
							if (f.test(t)) {
								const e = f.exec(t);
								e && e.length > 1 && j.push(e[1])
							}
						}
					const {
						reason: h
					} = e;
					return {
						reason: "site_reason_selected",
						site_reason: h.reasonText,
						additional_info: e.additionalInfo ? e.additionalInfo.join(",") : void 0,
						custom_text: e.customText,
						modmail_conv_id: b,
						modmail_msg_id: g,
						sr_name: _,
						thing_id: i,
						usernames: j.length ? j.join(",") : void 0
					}
				},
				f = (e, t) => {
					const s = new n.a;
					return m(s, e, t, 0), s
				},
				m = (e, t, s, n) => {
					for (let r = 0; r < t.length; r++) {
						const a = t[r];
						e.update(r, n);
						const i = e.getSequence().length;
						if (a.reasonAsParam === s) return;
						if (a.nextStepReasons && a.nextStepReasons.length && (m(e, a.nextStepReasons, s, n + 1), e.getSequence().length > i)) return;
						e.cut(n - 1)
					}
				}
		},
		"./src/reddit/helpers/routeKey/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return v
			})), s.d(t, "c", (function() {
				return T
			})), s.d(t, "d", (function() {
				return w
			})), s.d(t, "a", (function() {
				return D
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/lodash/pick.js"),
				r = s.n(n),
				a = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/makeCommentsPageKey/index.ts"),
				o = s("./src/lib/makeListingKey/index.ts"),
				c = s("./src/lib/makePostCreationPageKey/index.ts"),
				d = s("./src/lib/makeSearchKey/index.ts"),
				u = s("./src/reddit/constants/postLayout.ts"),
				l = s("./src/reddit/helpers/makeProfileListingKey/index.ts"),
				b = s("./src/reddit/constants/listings.ts"),
				p = s("./src/reddit/constants/page.ts"),
				O = s("./src/reddit/constants/parameters.ts"),
				g = s("./src/reddit/constants/wiki.ts"),
				f = s("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				m = s("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				j = s("./src/reddit/models/Comment/index.ts"),
				_ = s("./src/reddit/models/Multireddit/index.ts"),
				h = s("./src/reddit/models/Post/index.ts"),
				y = s("./src/reddit/models/User/index.ts"),
				E = s("./src/reddit/routes/modListing/index.ts"),
				I = s("./src/reddit/selectors/frontpage.ts");
			const v = (e, t, s) => {
					const {
						route: n
					} = e, {
						name: r
					} = n.meta;
					if (!r || !a.N.has(r) && r !== a.Bb.COINS && r !== a.Bb.COMMENTS && r !== a.Bb.POST_CREATION && r !== a.Bb.PREMIUM && r !== a.Bb.PUBLIC_ACCESS_NETWORK && r !== a.Bb.SEARCH_RESULTS && r !== a.Bb.EXPLORE && r !== a.Bb.SETTINGS && r !== a.Bb.SUBREDDIT_WIKI || !s && (r === a.Bb.COMMENTS || r === a.Bb.DUPLICATES)) return null;
					switch (r) {
						case a.Bb.POST_CREATION:
							return Object(c.a)(e.match.params);
						case a.Bb.INDEX:
						case a.Bb.LISTING:
						case a.Bb.SUBREDDIT:
						case a.Bb.TOPIC:
							return T(e, t).listingKey;
						case a.Bb.PROFILE_COMMENTS:
						case a.Bb.PROFILE_POSTS:
						case a.Bb.PROFILE_OVERVIEW:
						case a.Bb.PROFILE_PRIVATE:
							return w(e, t);
						case a.Bb.MULTIREDDIT:
							return C(e, t);
						case a.Bb.COMMENTS:
							return D(e, t, s);
						case a.Bb.SEARCH_RESULTS:
							return A(e);
						case a.Bb.SUBREDDIT_WIKI:
							return R(e);
						case a.Bb.COINS:
						case a.Bb.PREMIUM:
						case a.Bb.PUBLIC_ACCESS_NETWORK:
							return r;
						case a.Bb.SETTINGS:
							return P(e);
						default:
							return null
					}
				},
				S = {
					listingKey: null
				},
				T = (e, t) => {
					const {
						route: s,
						match: n
					} = e, {
						name: r
					} = s.meta;
					if (!a.N.has(r) && r !== a.Bb.POST_CREATION && r !== a.Bb.SUBREDDIT_WIKI) return S;
					const {
						queryParams: i
					} = n;
					switch (r) {
						case a.Bb.INDEX:
						case a.Bb.LISTING: {
							const e = Object(I.a)(t),
								s = n.params,
								r = s.sort ? s.sort : e;
							return {
								listingKey: Object(o.a)(p.a, r, i),
								sort: r
							}
						}
						case a.Bb.PROFILE_COMMENTS:
						case a.Bb.PROFILE_POSTS: {
							const {
								profileName: e
							} = n.params, {
								sort: t
							} = i;
							return {
								listingKey: Object(o.a)("u_".concat(e), t, i),
								sort: t
							}
						}
						case a.Bb.POST_CREATION:
						case a.Bb.SUBREDDIT: {
							const e = n.params,
								{
									subredditName: s
								} = e,
								r = i.f,
								a = Object(m.a)(e, t);
							if (r) {
								const e = {
										[O.p]: r,
										[O.s]: "1"
									},
									t = Object(d.c)(e);
								return {
									listingKey: Object(d.b)(s, void 0, t),
									sort: a
								}
							}
							return {
								listingKey: Object(o.a)(s, a, i),
								sort: a
							}
						}
						case a.Bb.TOPIC: {
							const e = n.params,
								t = e.sort || a.P,
								s = e.topicSlug;
							return {
								listingKey: Object(o.a)(b.b.Topic, t, Object.assign(Object.assign({}, e), {
									topicSlug: s
								})),
								sort: t
							}
						}
						case a.Bb.MOD_LISTING: {
							const e = n.params,
								{
									sort: t = a.P
								} = e,
								s = Object(E.d)(n.path) ? p.e : p.d;
							return {
								listingKey: Object(o.a)(s, t, i),
								sort: t
							}
						}
						case a.Bb.MULTIREDDIT:
							return {
								listingKey: C(e, t)
							};
						case a.Bb.SEARCH_RESULTS:
							return {
								listingKey: v(e, t, null)
							};
						default:
							return S
					}
				},
				w = (e, t) => {
					const {
						route: s,
						match: n
					} = e, {
						name: r
					} = s.meta;
					if (!a.N.has(r) && r !== a.Bb.POST_CREATION) return null;
					const {
						params: i,
						queryParams: c
					} = n, {
						profileName: d
					} = i, {
						sort: b = a.ub
					} = c;
					switch (r) {
						case a.Bb.PROFILE_OVERVIEW:
							const e = (t.user.prefs && t.user.prefs.profileLayout ? t.user.prefs.profileLayout : u.g.Large) === u.g.Compact ? a.kb : a.lb;
							return Object(l.a)((d || "").toLowerCase(), e, b, c);
						case a.Bb.PROFILE_COMMENTS:
						case a.Bb.PROFILE_POSTS:
							return Object(o.a)("u_".concat(d), b, c);
						case a.Bb.PROFILE_PRIVATE:
							const {
								listingType: s
							} = i;
							return Object(l.b)(d.toLowerCase(), s);
						default:
							return null
					}
				},
				C = (e, t) => {
					const {
						route: s,
						match: n
					} = e, {
						name: r
					} = s.meta;
					if (r !== a.Bb.MULTIREDDIT) return null;
					const {
						params: i,
						queryParams: c
					} = n, {
						multiredditName: d,
						sort: u = a.O.HOT
					} = i;
					let {
						username: l
					} = i;
					l || (l = t.user.account ? Object(y.e)(t.user.account) : "me");
					const b = Object(_.h)(l, d);
					return Object(o.a)(b, u, c)
				},
				A = e => {
					const {
						route: t,
						match: s
					} = e, {
						name: n
					} = t.meta;
					if (n !== a.Bb.SEARCH_RESULTS) return null;
					const {
						subredditName: i
					} = s.params, {
						username: o
					} = s.params, c = Object(d.c)(r()(s.queryParams, O.t));
					return Object(d.b)(i, o, c)
				},
				D = (e, t, s) => {
					const {
						route: n,
						match: r
					} = e, {
						name: o
					} = n.meta;
					if (!o || o !== a.Bb.COMMENTS) return null;
					const {
						partialCommentId: c,
						partialPostId: d
					} = r.params, u = Object(h.m)(d), l = c && Object(j.e)(c), {
						hasSortParam: b,
						sortToUse: p
					} = Object(f.a)(t, u);
					return Object(i.a)(u, l, {
						sort: p,
						hasSortParam: b
					})
				},
				P = e => "SettingsPage-" + e.match.params.page,
				R = e => {
					const {
						route: t,
						match: s
					} = e;
					if (t.meta.name !== a.Bb.SUBREDDIT_WIKI) return;
					const {
						subredditName: n = g.e,
						wikiPageName: r,
						wikiSubRoute: i
					} = s.params;
					return ["Wiki", n, i, r].join("--")
				}
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return O
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "i", (function() {
				return m
			})), s.d(t, "c", (function() {
				return j
			})), s.d(t, "d", (function() {
				return _
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "e", (function() {
				return E
			})), s.d(t, "h", (function() {
				return I
			})), s.d(t, "g", (function() {
				return v
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js");
			s("./node_modules/react/index.js");
			const r = function(e) {
				if (void 0 === e) throw new Error("invariant(...): Second argument must be a string.")
			};

			function a(e, t) {
				for (var s = arguments.length, n = new Array(s > 2 ? s - 2 : 0), a = 2; a < s; a++) n[a - 2] = arguments[a];
				if (r(t), !e) {
					let e;
					if (void 0 === t) e = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
					else {
						let s = 0;
						(e = new Error(t.replace(/%s/g, () => String(n[s++])))).name = "Invariant Violation"
					}
					throw e.framesToPop = 1, e
				}
			}
			const i = {
					AND: "AND",
					NONE: "NONE",
					OR: "OR"
				},
				o = {
					COMMA: "COMMA",
					SEMICOLON: "SEMICOLON"
				};
			var c = function(e, t, s) {
					const r = e.length;
					if (0 === r) return "";
					if (1 === r) return e[0];
					const c = e[r - 1];
					let d = e[0];
					for (let a = 1; a < r - 1; ++a) switch (s) {
						case o.SEMICOLON:
							d = n.fbt._("{previous items}; {following items}", [n.fbt._param("previous items", d), n.fbt._param("following items", e[a])], {
								hk: "4hs4xq"
							});
							break;
						default:
							d = n.fbt._("{previous items}, {following items}", [n.fbt._param("previous items", d), n.fbt._param("following items", e[a])], {
								hk: "2z8RMb"
							})
					}
					return function(e, t, s, r) {
						switch (s) {
							case i.AND:
								return n.fbt._("{list of items} and {last item }", [n.fbt._param("list of items", e), n.fbt._param("last item ", t)], {
									hk: "1ylan1"
								});
							case i.OR:
								return n.fbt._("{list of items} or {last item}", [n.fbt._param("list of items", e), n.fbt._param("last item", t)], {
									hk: "3q8AmB"
								});
							case i.NONE:
								switch (r) {
									case o.SEMICOLON:
										return n.fbt._("{previous item}; {last item}", [n.fbt._param("previous item", e), n.fbt._param("last item", t)], {
											hk: "1h77rJ"
										});
									default:
										return n.fbt._("{list of items}, {last item}", [n.fbt._param("list of items", e), n.fbt._param("last item", t)], {
											hk: "3Q0iaX"
										})
								}
								default:
									a(!1, "Invalid conjunction %s provided to intlList", s)
						}
					}(d, c, t || i.AND, s || o.COMMA)
				},
				d = s("./src/lib/timezone/index.ts"),
				u = s("./src/reddit/helpers/isArrayEqual.ts"),
				l = s("./src/reddit/helpers/ordinal/index.ts"),
				b = s("./src/reddit/models/ScheduledPost/index.ts");
			const p = e => {
					const t = e.toLocaleDateString(void 0, {
							month: "numeric",
							day: "numeric"
						}),
						s = e.toLocaleTimeString(void 0, {
							hour: "numeric",
							minute: "numeric"
						});
					return "".concat(t, " @ ").concat(s.replace(" ", "").toLowerCase())
				},
				O = (e, t) => {
					if (e && t) {
						const s = Object(d.f)(f(e, t)),
							r = p(s);
						return n.fbt._("Submit post at {time}", [n.fbt._param("time", r)], {
							hk: "IZ3L"
						})
					}
					return n.fbt._("Submit post at scheduled event time", null, {
						hk: "lYsoU"
					})
				},
				g = e => e.slice(0, 5),
				f = (e, t) => "".concat(e, "T").concat(g(t), ":00"),
				m = e => {
					const [t, s] = e.split("T");
					return [t, g(s)]
				},
				j = e => {
					const [t, s] = m(e);
					if (t && s) {
						const e = Object(d.f)(f(t, s));
						return p(e)
					}
					return ""
				},
				_ = e => {
					const t = Object(d.d)(e);
					let s, n = e;
					if (t) {
						s = t.offset;
						const r = Object(d.e)(t.offset),
							a = e.replace("/", " - ").replace(/_/g, " ");
						n = "(GMT".concat(r, ") ").concat(a)
					}
					return {
						name: e,
						displayText: n,
						offset: s
					}
				},
				h = e => "string" == typeof e,
				y = e => {
					const t = new Date,
						s = e - t.getDay();
					return t.setDate(t.getDate() + s), t.toLocaleDateString(void 0, {
						weekday: "long"
					})
				},
				E = e => {
					const t = (e => {
						const [t, s] = m(e);
						if (t && s) {
							return Object(d.f)(f(t, s)).toLocaleTimeString(void 0, {
								hour: "numeric",
								minute: "numeric"
							})
						}
						return ""
					})(e.publishAt);
					if (e.frequency === b.d.Hourly) return 2 === e.interval ? n.fbt._("Every other hour", null, {
						hk: "64vzK"
					}) : e.interval > 1 ? n.fbt._("Every {hour interval} hours", [n.fbt._param("hour interval", e.interval.toString())], {
						hk: "3x8zaD"
					}) : n.fbt._("Every hour", null, {
						hk: "1VzCs"
					});
					if (e.frequency === b.d.Daily) return 2 === e.interval ? n.fbt._("Every other day at {start time}", [n.fbt._param("start time", t)], {
						hk: "yTynp"
					}) : e.interval > 1 ? n.fbt._("Every {day interval} days at {start time}", [n.fbt._param("day interval", e.interval.toString()), n.fbt._param("start time", t)], {
						hk: "2OoGlG"
					}) : n.fbt._("Every day at {start time}", [n.fbt._param("start time", t)], {
						hk: "1cvwm2"
					});
					if (e.frequency === b.d.Weekly) {
						const s = (e => c(e.map(b.k).sort((e, t) => e - t).map(y), i.AND, o.COMMA))(e.byWeekDays);
						return 2 === e.interval ? n.fbt._("Every other week on {days of week } at {start time}", [n.fbt._param("days of week ", s), n.fbt._param("start time", t)], {
							hk: "43xwaa"
						}) : e.interval > 1 ? n.fbt._("Every {interval} weeks on {days of week} at {start time}", [n.fbt._param("interval", e.interval.toString()), n.fbt._param("days of week", s), n.fbt._param("start time", t)], {
							hk: "2IVbH"
						}) : n.fbt._("Every week on {days of week} at {start time}", [n.fbt._param("days of week", s), n.fbt._param("start time", t)], {
							hk: "2Zl0L"
						})
					}
					const s = (e => c(e.sort((e, t) => e - t).map(l.a), i.AND, o.COMMA))(e.byMonthDays);
					return 2 === e.interval ? n.fbt._({
						"*": "Every other month on the {days of month} days at {start time}",
						_1: "Every other month on the {days of month} day at {start time}"
					}, [n.fbt._param("days of month", s), n.fbt._plural(e.byMonthDays.length), n.fbt._param("start time", t)], {
						hk: "okH9o"
					}) : e.interval > 1 ? n.fbt._({
						"*": "Every {interval} months on the {days of month} days at {start time}",
						_1: "Every {interval} months on the {days of month} day at {start time}"
					}, [n.fbt._param("interval", e.interval.toString()), n.fbt._param("days of month", s), n.fbt._plural(e.byMonthDays.length), n.fbt._param("start time", t)], {
						hk: "KqN3x"
					}) : n.fbt._({
						"*": "Every month on the {days of month} days at {start time}",
						_1: "Every month on the {days of month} day at {start time}"
					}, [n.fbt._param("days of month", s), n.fbt._plural(e.byMonthDays.length), n.fbt._param("start time", t)], {
						hk: "1jBuYc"
					})
				},
				I = e => {
					let t = null;
					e.frequency && (t = e.frequency), (e.byWeekDays.length > 1 || e.byMonthDays.length > 1 || e.interval > 1) && (t = b.b);
					const s = Object(d.f)(e.publishAt),
						n = Object(b.p)(s.getDay()),
						r = s.getDate();
					return 1 === e.byWeekDays.length && e.byWeekDays[0] !== n && (t = b.b), 1 === e.byMonthDays.length && e.byMonthDays[0] !== r && (t = b.b), {
						recurrenceInfo: e.frequency ? {
							frequency: e.frequency,
							byMonthDays: e.byMonthDays,
							byWeekDays: e.byWeekDays,
							interval: e.interval
						} : null,
						frequencyOption: t,
						submitDate: e.publishAt,
						timezoneName: e.clientTimezone
					}
				},
				v = (e, t) => {
					if (!e && t || e && !t) return !1;
					if (!e && !t) return !0;
					for (const s in e) {
						if (!t) return !1;
						if (e.hasOwnProperty(s)) {
							if (Array.isArray(e[s]) && (!Array.isArray(t[s]) || !Object(u.a)(e[s], t[s]))) return !1;
							if (e[s] !== t[s]) return !1
						}
					}
					return !0
				}
		},
		"./src/reddit/helpers/tabBadging/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			}));
			var n = s("./src/config.ts");
			const r = "".concat(n.a.assetPath, "/img/favicon/badged-favicon-32x32.png"),
				a = "".concat(n.a.assetPath, "/img/favicon/badged-favicon-16x16.png"),
				i = "".concat(n.a.assetPath, "/img/favicon/favicon-32x32.png"),
				o = "".concat(n.a.assetPath, "/img/favicon/favicon-16x16.png"),
				c = "badgeCountSync",
				d = e => window.document.querySelector('link[href="'.concat(e, '"]')),
				u = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					const t = d(e ? i : r),
						s = d(e ? o : a);
					t && s && (t.href = e ? r : i, s.href = e ? a : o)
				},
				l = e => {
					navigator && navigator.serviceWorker && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
						command: c,
						badgeCounts: e
					})
				}
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/lodash/values.js"),
				r = s.n(n);
			const a = e => r()(e).sort((t, s) => {
					const n = e[t.tag.id].tag.text.toLowerCase(),
						r = e[s.tag.id].tag.text.toLowerCase();
					return n < r ? -1 : n > r ? 1 : 0
				}),
				i = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/timeApiRoute/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/telemetry/index.ts");
			async function a(e, t) {
				const s = r.c.start();
				try {
					const a = await t();
					return Object(r.b)(n.l.Redesign, {
						page: e,
						type: "route",
						duration: r.c.end(s)
					}), a
				} finally {
					r.c.cancel(s)
				}
			}
		},
		"./src/reddit/helpers/trackers/authorHovercard.ts": function(e, t, s) {
			"use strict";
			s.d(t, "h", (function() {
				return a
			})), s.d(t, "g", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			}));
			var n = s("./src/reddit/helpers/isComment.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const a = (e, t) => ({
					comment: t && Object(n.a)(t) ? r.comment(e, t) : null,
					post: t ? r.post(e, t) : null,
					profile: r.profile(e),
					screen: r.screen(e)
				}),
				i = (e, t) => s => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: e
				}, a(s, t)),
				o = e => t => Object.assign({
					source: "user_hovercard",
					action: "view",
					noun: "hover_user_hovercard"
				}, a(t, e)),
				c = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "mute_dialog_in_context"
				}, a(t, e)),
				d = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "ban_dialog_in_context"
				}, a(t, e)),
				u = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "unban_user_in_context"
				}, a(t, e)),
				l = e => t => Object.assign({
					source: "user_hovercard",
					action: "click",
					noun: "change_user_flair_in_context",
					userSubreddit: r.userSubreddit(t)
				}, a(t, e)),
				b = e => t => Object.assign({
					source: r.profile(t) ? "user_profile" : "user_hovercard",
					action: "click",
					noun: "create_chat"
				}, e && a(t, e))
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "j", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "k", (function() {
				return m
			}));
			var n = s("./src/reddit/constants/blade.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const a = (e, t) => s => Object.assign(Object.assign({}, r.defaults(s)), {
					source: n.d.Appearance,
					action: "click",
					noun: e,
					actionInfo: r.actionInfo(s, {
						paneName: t
					}),
					subreddit: r.subreddit(s)
				}),
				i = e => a("save_style", e),
				o = e => a("cancel_style", e),
				c = e => t => ({
					source: n.d.Structure,
					action: "click",
					noun: e,
					screen: r.screen(t),
					subreddit: r.subreddit(t)
				}),
				d = e => t => ({
					source: n.d.Appearance,
					action: "click",
					noun: e,
					screen: r.screen(t),
					subreddit: r.subreddit(t)
				}),
				u = (e, t) => s => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: r.actionInfo(s, {
						paneName: n.g[t]
					}),
					screen: r.screen(s),
					subreddit: r.subreddit(s)
				}),
				l = e => t => ({
					source: n.h[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.actionInfo(t, {
						paneName: n.g[e]
					}),
					screen: r.screen(t),
					subreddit: r.subreddit(t)
				}),
				b = e => ({
					screen: r.screen(e),
					subreddit: r.subreddit(e)
				}),
				p = () => e => Object.assign({
					source: n.d.Appearance,
					action: "view",
					noun: "blade"
				}, b(e)),
				O = e => t => Object.assign({
					source: n.a[e],
					action: "click",
					noun: n.b[e]
				}, b(t)),
				g = () => e => Object.assign({
					source: n.d.Appearance,
					action: "click",
					noun: "back"
				}, b(e)),
				f = (e, t) => Object.assign(Object.assign({}, r.defaults(e)), (e => t => Object.assign({
					source: n.d.PostFlairManagement,
					action: "click",
					noun: e
				}, b(t)))(t)(e)),
				m = e => t => ({
					source: n.d.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: r.screen(t),
					subreddit: r.subreddit(t),
					userSubreddit: r.userSubreddit(t)
				})
		},
		"./src/reddit/helpers/trackers/chat.ts": function(e, t, s) {
			"use strict";
			s.d(t, "m", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "k", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "l", (function() {
				return g
			})), s.d(t, "i", (function() {
				return f
			})), s.d(t, "h", (function() {
				return m
			})), s.d(t, "j", (function() {
				return j
			})), s.d(t, "f", (function() {
				return _
			}));
			var n = s("./src/reddit/constants/chat.ts"),
				r = s("./src/reddit/selectors/telemetry.ts"),
				a = s("./src/telemetry/models/Event.ts");
			const i = e => ({
					screen: Object(r.screen)(e),
					subreddit: Object(r.subreddit)(e)
				}),
				o = () => e => Object.assign({
					source: a.b.ChatSidebarWidget,
					action: "view",
					noun: "chat_rooms",
					chat: Object(r.numberChannels)(e)
				}, i(e)),
				c = e => t => Object.assign({
					source: a.b.ChatSidebarWidget,
					action: "click",
					noun: "view_room",
					chat: Object(r.channel)(t, e)
				}, i(t)),
				d = e => t => Object.assign({
					source: a.b.ChatSidebarWidget,
					action: "click",
					noun: "join_room",
					chat: Object(r.channel)(t, e)
				}, i(t)),
				u = () => e => Object.assign({
					source: a.b.ChatSidebarWidget,
					action: "click",
					noun: "view_all_rooms",
					chat: Object(r.numberChannels)(e)
				}, i(e)),
				l = e => t => Object.assign({
					source: a.b.ChatSidebarModal,
					action: "click",
					noun: "view_room",
					chat: Object(r.channel)(t, e)
				}, i(t)),
				b = e => t => Object.assign({
					source: a.b.ChatSidebarModal,
					action: "click",
					noun: "join_room",
					chat: Object(r.channel)(t, e)
				}, i(t)),
				p = () => e => Object.assign({
					source: a.b.ChatSetup,
					action: "view",
					noun: "create_chat_room"
				}, i(e)),
				O = e => t => {
					const {
						channelSendbirdUrl: s,
						type: r
					} = e;
					return Object.assign({
						source: a.b.ChatSetup,
						action: "submit",
						noun: "create_chat_room",
						chat: {
							id: s,
							type: n.e[r]
						}
					}, i(t))
				},
				g = () => e => Object.assign({
					source: a.b.ChatSetup,
					action: "view",
					noun: "edit_chat_room"
				}, i(e)),
				f = e => t => {
					const {
						channelSendbirdUrl: s,
						type: r
					} = e;
					return Object.assign({
						source: a.b.ChatSetup,
						action: "submit",
						noun: "edit_chat_room",
						chat: {
							id: s,
							type: n.e[r]
						}
					}, i(t))
				},
				m = e => t => {
					const {
						channelSendbirdUrl: s,
						type: r
					} = e;
					return Object.assign({
						source: a.b.ChatSetup,
						action: "submit",
						noun: "delete_chat_room",
						chat: {
							id: s,
							type: n.e[r]
						}
					}, i(t))
				},
				j = () => e => Object.assign({
					source: a.b.Nav,
					action: "view",
					noun: "orangered_06"
				}, i(e)),
				_ = e => t => Object.assign({
					source: "settings_privacy",
					action: "save",
					noun: "receive_chat_invites",
					setting: {
						value: e,
						oldValue: e
					}
				}, Object(r.defaults)(t))
		},
		"./src/reddit/helpers/trackers/commentList.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/telemetry/index.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const a = (e, t) => {
				Object(n.a)(Object.assign(Object.assign({
					action: "view",
					source: "commentlist",
					noun: "bottom"
				}, r.defaults(e)), {
					listing: r.listing(e, t),
					subreddit: r.subreddit(e)
				}))
			}
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return u
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			})), s.d(t, "c", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			}));
			var n = s("./src/telemetry/index.ts"),
				r = s("./src/reddit/constants/tracking.ts"),
				a = s("./src/reddit/models/PostDraft/index.ts"),
				i = s("./src/reddit/selectors/comments.ts"),
				o = s("./src/reddit/selectors/platform.ts"),
				c = s("./src/reddit/selectors/telemetry.ts");
			const d = e => {
					const t = Object(o.o)(e);
					return Object.assign(Object.assign({
						source: "comment_composer",
						action: r.c.CLICK
					}, Object(c.defaults)(e)), {
						screen: Object(c.screen)(e),
						subreddit: Object(c.subreddit)(e),
						post: t ? Object(c.post)(e, t) : null,
						profile: Object(c.profile)(e)
					})
				},
				u = (e, t, s, r) => {
					const a = {
							commentId: r,
							commentsPageKey: s
						},
						o = r && Object(i.j)(e, a) || 0;
					return Object(n.a)(Object.assign(Object.assign({
						noun: "comment"
					}, d(e)), {
						comment: r ? Object(c.comment)(e, r) : null,
						listing: Object(c.listing)(e, void 0, {
							depth: o
						}),
						commentComposer: {
							editorMode: t
						}
					}))
				},
				l = (e, t, s, r) => {
					const a = d(e);
					return Object(n.a)(Object.assign(Object.assign({}, a), {
						actionInfo: Object.assign(Object.assign({}, a.actionInfo), {
							reason: "karma_rate_limit"
						}),
						source: "backend",
						action: "error",
						noun: "comment",
						comment: {
							bodyText: t,
							parentId: r,
							postId: s
						}
					}))
				},
				b = e => Object(n.a)(Object.assign({
					noun: "cancel"
				}, d(e))),
				p = (e, t) => {
					t === a.c.replyToPost && Object(n.a)(Object.assign({
						noun: "input"
					}, d(e)))
				},
				O = (e, t) => Object(n.a)(Object.assign(Object.assign({
					source: "comment",
					noun: "delete",
					action: "click"
				}, Object(c.defaults)(t)), {
					screen: Object(c.screen)(t),
					subreddit: Object(c.subreddit)(t),
					post: Object(c.post)(t, e)
				})),
				g = e => Object(n.a)(Object.assign({
					noun: "edit"
				}, d(e))),
				f = e => Object(n.a)(Object.assign({
					noun: "save_edit"
				}, d(e)))
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "f", (function() {
				return b
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "e", (function() {
				return O
			})), s.d(t, "d", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "h", (function() {
				return m
			})), s.d(t, "g", (function() {
				return j
			}));
			var n, r = s("./src/reddit/selectors/tags.ts"),
				a = s("./src/reddit/selectors/telemetry.ts"),
				i = s("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(n || (n = {}));
			const o = (e, t, s) => {
					const n = Object(r.A)(e, {
						subredditId: t
					});
					return !!n && n.id === s
				},
				c = (e, t) => Object(r.x)(e, {
					itemId: t
				}).reduce((e, t) => {
					let {
						topicTagIds: s,
						topicTagContents: n,
						topicTagTypes: r
					} = e;
					return s.push(t.tag.id), n.push(t.tag.text), r.push(t.tag.type), {
						topicTagIds: s,
						topicTagContents: n,
						topicTagTypes: r
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				d = (e, t, s) => {
					if (!s.id) return {
						content: s.displayText
					};
					const n = Object(r.b)(e)[s.id] || Object(r.d)(e, {
						subredditId: t
					})[s.id];
					return n ? {
						id: n.id,
						content: n.text,
						type: n.type,
						isPrimary: o(e, t, n.id)
					} : null
				},
				u = (e, t, s) => {
					if (!s) return null;
					const n = Object(r.b)(e)[s] || Object(r.d)(e, {
						subredditId: t
					})[s];
					return n ? {
						id: n.id,
						content: n.text,
						type: n.type,
						isPrimary: o(e, t, n.id)
					} : null
				},
				l = (e, t, s) => Object.assign(Object.assign({}, a.defaults(e)), {
					subreddit: Object.assign(Object.assign(Object.assign({}, a.subreddit(e) || {}), {
						id: t
					}), c(e, t)),
					source: s.context,
					action: "click"
				}),
				b = (e, t, s) => {
					Object(i.a)(((e, t, s) => Object.assign(Object.assign({}, l(e, t.subredditId, s)), {
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: u(e, t.subredditId, t.tagId)
					}))(e, t, s))
				},
				p = (e, t, s, n) => {
					Object(i.a)(Object.assign(Object.assign({}, l(e, t, n)), {
						topicTag: d(e, t, s),
						noun: "add_related_topic"
					}))
				},
				O = (e, t, s, n) => {
					return !Object(r.l)(e, {
						subredditId: t
					}) && s.id ? Object(i.a)(((e, t, s, n) => Object.assign(Object.assign({}, l(e, t, n)), {
						topicTag: d(e, t, s),
						noun: "topic_auto_suggest"
					}))(e, t, s, n)) : s.id ? Object(i.a)(((e, t, s, n) => Object.assign(Object.assign({}, l(e, t, n)), {
						topicTag: d(e, t, s),
						noun: "topic_auto_complete"
					}))(e, t, s, n)) : Object(i.a)(((e, t, s, n) => Object.assign(Object.assign({}, l(e, t, n)), {
						topicTag: d(e, t, s),
						noun: "topic_add_new"
					}))(e, t, s, n))
				},
				g = (e, t, s, n) => Object(i.a)(Object.assign(Object.assign({}, l(e, t, n)), {
					topicTag: d(e, t, s),
					noun: "topic_remove"
				})),
				f = (e, t, s) => Object(i.a)(Object.assign(Object.assign({}, l(e, t, s)), {
					noun: "topic_tag_field"
				})),
				m = (e, t, s) => Object(i.a)(Object.assign(Object.assign({}, l(e, t, s)), {
					noun: s.context === n.communitySettings ? "save" : "save_community_topics"
				})),
				j = (e, t, s, n) => {
					const r = l(e, t, n);
					Object(i.a)(Object.assign(Object.assign({}, r), {
						action: "view",
						noun: "error",
						actionInfo: Object.assign(Object.assign({}, r.actionInfo), {
							reason: s
						})
					}))
				}
		},
		"./src/reddit/helpers/trackers/discoveryUnit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return j
			})), s.d(t, "h", (function() {
				return _
			})), s.d(t, "a", (function() {
				return I
			})), s.d(t, "E", (function() {
				return v
			})), s.d(t, "F", (function() {
				return S
			})), s.d(t, "M", (function() {
				return w
			})), s.d(t, "B", (function() {
				return C
			})), s.d(t, "C", (function() {
				return A
			})), s.d(t, "D", (function() {
				return D
			})), s.d(t, "i", (function() {
				return P
			})), s.d(t, "w", (function() {
				return R
			})), s.d(t, "x", (function() {
				return k
			})), s.d(t, "L", (function() {
				return x
			})), s.d(t, "K", (function() {
				return N
			})), s.d(t, "I", (function() {
				return L
			})), s.d(t, "v", (function() {
				return U
			})), s.d(t, "y", (function() {
				return M
			})), s.d(t, "z", (function() {
				return F
			})), s.d(t, "A", (function() {
				return G
			})), s.d(t, "N", (function() {
				return B
			})), s.d(t, "J", (function() {
				return q
			})), s.d(t, "t", (function() {
				return V
			})), s.d(t, "H", (function() {
				return H
			})), s.d(t, "d", (function() {
				return K
			})), s.d(t, "c", (function() {
				return W
			})), s.d(t, "b", (function() {
				return Y
			})), s.d(t, "f", (function() {
				return z
			})), s.d(t, "e", (function() {
				return J
			})), s.d(t, "s", (function() {
				return Z
			})), s.d(t, "m", (function() {
				return $
			})), s.d(t, "r", (function() {
				return ee
			})), s.d(t, "k", (function() {
				return te
			})), s.d(t, "l", (function() {
				return se
			})), s.d(t, "n", (function() {
				return ne
			})), s.d(t, "p", (function() {
				return re
			})), s.d(t, "q", (function() {
				return ae
			})), s.d(t, "o", (function() {
				return ie
			})), s.d(t, "j", (function() {
				return oe
			})), s.d(t, "u", (function() {
				return ce
			})), s.d(t, "G", (function() {
				return de
			}));
			var n, r = s("./src/lib/stringInterpolate/index.ts"),
				a = s("./src/reddit/actions/focusedVerticals/constants.ts"),
				i = (s("./src/reddit/constants/categories.tsx"), s("./src/reddit/constants/tracking.ts")),
				o = s("./src/reddit/helpers/correlationIdTracker.ts"),
				c = s("./src/reddit/helpers/trackers/searchResults.ts"),
				d = s("./src/reddit/models/DiscoveryUnit/index.ts"),
				u = s("./src/reddit/models/Widgets/index.ts"),
				l = s("./src/reddit/selectors/posts.ts"),
				b = s("./src/reddit/selectors/telemetry.ts"),
				p = s("./src/reddit/selectors/widgets.ts"),
				O = s("./src/telemetry/index.ts");
			! function(e) {
				e.HEADER_SUBREDDIT = "header_subreddit", e.ITEM_POST = "item_post", e.ITEM_POST_SUBREDDIT = "item_post_subreddit", e.ITEM_SUBREDDIT = "item_subreddit", e.ITEM_SUBREDDIT_HIDE = "item_subreddit_hide", e.ITEM_SUBREDDIT_SUBSCRIBE = "item_subreddit_subscribe", e.ITEM_SUBREDDIT_UNSUBSCRIBE = "item_subreddit_unsubscribe"
			}(n || (n = {}));
			const g = "discovery_unit",
				f = (e, t, s) => Object.assign(Object.assign({}, b.defaults(e)), {
					source: g,
					screen: b.screen(e),
					discoveryUnit: {
						id: t.id,
						type: t.unitType,
						title: t.title && s ? Object(r.a)(t.title, {
							subredditName: s.name
						}) : t.title,
						name: t.unitName
					}
				}),
				m = (e, t, s) => Object.assign(Object.assign({}, f(e, t, s)), {
					source: "global",
					action: "view",
					noun: "discovery_unit"
				}),
				j = (e, t) => {
					Object(O.a)(_(t)(e))
				},
				_ = (e, t) => s => m(s, e, t),
				h = (e, t, s, n) => "unitName" in t ? f(e, t, n) : ((e, t, s) => Object.assign(Object.assign({}, b.defaults(e)), {
					source: "search",
					screen: b.screen(e),
					search: s ? Object.assign(Object.assign({}, b.search(e, s)), {
						structureType: b.StructureType.Trending
					}) : null,
					discoveryUnit: {
						id: t.name,
						type: "listing",
						title: t.layout.title,
						name: t.name
					}
				}))(e, t, s),
				y = (e, t, s, r, a) => Object.assign(Object.assign({}, h(e, t, r, a)), {
					action: "view",
					noun: n.ITEM_POST,
					post: b.post(e, s)
				}),
				E = e => {
					let {
						post: t,
						rawQuery: s,
						searchQuery: n
					} = e;
					return {
						displayQuery: decodeURIComponent(n),
						rawQuery: s ? decodeURIComponent(s) : void 0,
						structureType: t && t.isSponsored ? b.StructureType.PromotedTrend : b.StructureType.Trending
					}
				};
			var I;
			! function(e) {
				e.POPULAR_CAROUSEL = "popular_carousel", e.SEARCH_DROPDOWN = "search_dropdown"
			}(I || (I = {}));
			const v = (e, t, s) => {
					Object(O.a)(T(e, t, s, i.c.CLICK))
				},
				S = (e, t, s) => {
					Object(O.a)(T(e, t, s, i.c.VIEW))
				},
				T = (e, t, s, n) => {
					const r = e.trending.models.filter(e => !e.post || !e.post.isSponsored).findIndex(e => e.id === t.id) + 1;
					return Object.assign(Object.assign({}, b.defaults(e)), {
						source: "search",
						action: n,
						noun: "trending",
						metaSearch: E(t),
						discoveryUnit: s === I.POPULAR_CAROUSEL ? {
							name: d.l,
							id: d.l,
							title: d.l,
							type: "query"
						} : void 0,
						actionInfo: b.actionInfo(e, {
							paneName: s,
							position: r
						}),
						search: {
							originPageType: e.platform.currentPage ? b.getPageTypeFromCurrentPage(e.platform.currentPage) : void 0,
							query: t.rawQuery,
							structureType: b.StructureType.Trending,
							queryId: n === i.c.CLICK ? Object(o.c)(o.a.SearchResults) : void 0
						}
					})
				},
				w = (e, t, s, n, r, a, o) => {
					Object(O.a)(Object.assign(Object.assign(Object.assign({}, b.defaults(e)), Object(c.e)(e, s, n, r, a, t)), {
						action: i.c.VIEW,
						noun: o ? "ad" : "post"
					}))
				},
				C = (e, t, s, n) => {
					Object(O.a)(y(e, t, s, n))
				},
				A = (e, t, s, n) => r => y(r, e, t, s, n),
				D = (e, t, s, r) => {
					const a = h(e, t, r);
					Object(O.a)(Object.assign(Object.assign(Object.assign({}, a), Object(p.b)(e, s)), {
						action: "view",
						noun: n.ITEM_SUBREDDIT
					}))
				},
				P = (e, t) => {
					Object(O.a)(Object.assign(Object.assign({}, f(e, t)), {
						source: g,
						action: i.c.CLICK,
						noun: "show_less_often"
					}))
				},
				R = (e, t, s, n) => {
					Object(O.a)(k(t, s, n)(e))
				},
				k = (e, t, s, r) => a => {
					const o = h(a, e, s, r);
					return Object.assign(Object.assign({}, o), {
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_POST,
						post: b.post(a, t)
					})
				},
				x = (e, t, s, n) => r => a => Object(c.e)(a, r, e, t, s, n),
				N = (e, t, s, n) => r => a => Object(c.d)(a, e, t, void 0, s, r, n),
				L = (e, t, s, n) => r => a => Object.assign(Object.assign({}, Object(c.e)(a, r, e, t, s, n)), {
					noun: "ad"
				}),
				U = (e, t) => s => r => Object.assign(Object.assign({}, e ? f(r, e, t) : {}), {
					source: g,
					action: i.c.CLICK,
					noun: n.ITEM_POST,
					post: b.post(r, s)
				}),
				M = (e, t, s, n) => {
					Object(O.a)(F(t, s, n)(e))
				},
				F = (e, t, s, n) => r => {
					const a = Object(l.c)(r, {
							postId: t
						}),
						o = a ? Object(p.b)(r, a) : void 0,
						c = h(r, e, s, n);
					return Object.assign(Object.assign(Object.assign({}, c), o), {
						source: g,
						action: i.c.CLICK,
						noun: "item_post_subreddit",
						post: b.post(r, t)
					})
				},
				G = (e, t, s) => n => r => {
					const a = Object(l.c)(r, {
							postId: t
						}),
						o = a ? Object(p.b)(r, a) : void 0,
						c = h(r, e, void 0, s);
					return Object.assign(Object.assign(Object.assign({}, c), o), {
						source: g,
						action: i.c.CLICK,
						noun: n ? "item_post_subreddit_unsubscribe" : "item_post_subreddit_subscribe",
						post: b.post(r, t)
					})
				},
				B = (e, t, s) => {
					const n = h(e, t);
					Object(O.a)(Object.assign(Object.assign(Object.assign({}, n), Object(p.b)(e, s)), {
						source: "search",
						action: i.c.CLICK,
						noun: "search_result_discovery_unit_subreddit"
					}))
				},
				q = (e, t, s, n, r, a) => {
					Object(O.a)(Object.assign(Object.assign({}, b.defaults(e)), Object(c.d)(e, t, s, n, r, void 0, a)))
				},
				V = (e, t, s) => {
					const n = h(e, t);
					Object(O.a)(Object.assign(Object.assign(Object.assign({}, n), Object(p.b)(e, s)), {
						source: g,
						action: i.c.CLICK,
						noun: "footer_subreddit"
					}))
				},
				H = (e, t) => s => {
					const n = Object(u.j)(t);
					return Object.assign(Object.assign(Object.assign({}, f(s, e, t)), Object(p.b)(s, n)), {
						source: g,
						action: i.c.CLICK,
						noun: "title_subreddit"
					})
				},
				K = (e, t) => s => Object.assign(Object.assign({}, f(s, e, t)), {
					action: "status",
					actionInfo: b.actionInfo(s, {
						success: !0
					}),
					noun: "loading"
				}),
				W = (e, t, s) => n => Object.assign(Object.assign({}, f(n, e, s)), {
					action: "status",
					actionInfo: b.actionInfo(n, {
						reason: t,
						success: !1
					}),
					noun: "loading"
				}),
				Y = (e, t) => s => Object.assign(Object.assign({}, f(s, e, t)), {
					action: "click",
					noun: "close"
				}),
				z = (e, t, s) => n => Object.assign(Object.assign({}, h(n, e, t, s)), {
					action: "click",
					noun: "scroll"
				}),
				J = (e, t) => s => Object.assign(Object.assign({}, f(s, e, t)), {
					action: "click",
					noun: "overflow_menu"
				}),
				Q = () => ({
					id: "xd_focus_verticals",
					unitType: d.f.Listing,
					experiment: "",
					title: a.a,
					unitName: "focused_vertical_suggestion",
					enabled: !1,
					layout: d.d.Large,
					surface: d.e.Frontpage,
					url: "gql.reddit.com"
				}),
				X = (e, t, s) => b.actionInfo(e, {
					position: s
				}),
				Z = (e, t, s) => {
					const n = Q();
					return e => Object.assign(Object.assign({}, m(e, n)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t)
					})
				},
				$ = (e, t, s) => {
					const n = Q();
					return e => Object.assign(Object.assign({}, y(e, n, t)), {
						actionInfo: X(e, 0, s)
					})
				},
				ee = (e, t, s) => {
					const r = Q();
					return e => Object.assign(Object.assign({}, f(e, r)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t) || null,
						source: g,
						action: i.c.VIEW,
						noun: n.ITEM_SUBREDDIT
					})
				},
				te = (e, t, s) => {
					const r = Q();
					return e => Object.assign(Object.assign({}, f(e, r)), {
						actionInfo: X(e, 0, s),
						post: b.post(e, t) || null,
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_POST
					})
				},
				se = (e, t, s, r) => {
					const a = Q();
					return e => Object.assign(Object.assign({}, f(e, a)), {
						actionInfo: X(e, 0, r),
						subreddit: b.subredditById(e, s) || null,
						post: b.post(e, t) || null,
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_POST_SUBREDDIT
					})
				},
				ne = (e, t, s) => {
					const r = Q();
					return e => Object.assign(Object.assign({}, f(e, r)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t) || null,
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_SUBREDDIT
					})
				},
				re = (e, t, s, r) => {
					const a = Q();
					return e => Object.assign(Object.assign({}, f(e, a)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t) || null,
						post: r ? b.post(e, r) : null,
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_SUBREDDIT_SUBSCRIBE
					})
				},
				ae = (e, t, s, r) => {
					const a = Q();
					return e => Object.assign(Object.assign({}, f(e, a)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t) || null,
						post: r ? b.post(e, r) : null,
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_SUBREDDIT_UNSUBSCRIBE
					})
				},
				ie = (e, t, s) => {
					const r = Q();
					return e => Object.assign(Object.assign({}, f(e, r)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t) || null,
						source: g,
						action: i.c.CLICK,
						noun: n.ITEM_SUBREDDIT_HIDE
					})
				},
				oe = (e, t, s) => {
					const r = Q();
					return e => Object.assign(Object.assign({}, f(e, r)), {
						actionInfo: X(e, 0, s),
						subreddit: b.subredditById(e, t) || null,
						source: g,
						action: i.c.CLICK,
						noun: n.HEADER_SUBREDDIT
					})
				},
				ce = (e, t) => s => Object.assign(Object.assign(Object.assign({}, f(s, e)), t && Object(p.b)(s, t)), {
					source: g,
					action: i.c.CLICK,
					noun: "item"
				}),
				de = e => t => Object.assign(Object.assign({}, f(t, e)), {
					source: g,
					action: i.c.CLICK,
					noun: "see_all"
				})
		},
		"./src/reddit/helpers/trackers/emailCollection.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			}));
			var n = s("./src/reddit/constants/tracking.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const a = e => t => ({
					source: e,
					action: n.c.VIEW,
					actionInfo: r.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "email_collection"
				}),
				i = e => t => ({
					source: e,
					action: n.c.CLICK,
					actionInfo: r.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "add_email_collection"
				}),
				o = e => t => ({
					source: e,
					action: "close",
					actionInfo: r.actionInfo(t, {
						settingValue: "footer_2"
					}),
					noun: "email_collection"
				}),
				c = e => Object.assign(Object.assign({}, r.defaults(e)), {
					source: "popup",
					action: n.c.CLICK,
					actionInfo: r.actionInfo(e, {
						settingValue: "footer_2"
					}),
					noun: "save_email_collection"
				}),
				d = e => t => Object.assign(Object.assign({}, r.defaults(t)), {
					source: "popup",
					action: n.c.CLICK,
					actionInfo: r.actionInfo(t, {
						reason: e ? "1" : "0",
						settingValue: "footer_2"
					}),
					noun: "email_digest_check"
				}),
				u = e => Object.assign(Object.assign({}, r.defaults(e)), {
					source: "popup",
					action: n.c.CLICK,
					actionInfo: r.actionInfo(e, {
						settingValue: "footer_2"
					}),
					noun: "email_settings_link"
				})
		},
		"./src/reddit/helpers/trackers/emailVerification.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "g", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			}));
			var n = s("./src/reddit/selectors/telemetry.ts");
			const r = "tooltip",
				a = e => t => Object.assign(Object.assign({}, Object(n.defaults)(t)), {
					action: "view",
					noun: "verification",
					source: e
				}),
				i = e => t => Object.assign(Object.assign({}, Object(n.defaults)(t)), {
					action: "close",
					noun: "verification",
					source: e
				}),
				o = (e, t) => s => Object.assign(Object.assign({}, Object(n.defaults)(s)), {
					action: "click",
					noun: "verification_".concat(t),
					source: e
				}),
				c = e => t => Object.assign(Object.assign({}, Object(n.defaults)(t)), {
					action: "send",
					noun: "verification_email_".concat(e),
					source: "email"
				}),
				d = e => t => Object.assign(Object.assign({}, Object(n.defaults)(t)), {
					action: "click",
					noun: "verification_email_".concat(e),
					source: "email"
				}),
				u = () => e => Object.assign(Object.assign({}, Object(n.defaults)(e)), {
					action: "confirm",
					noun: "verification_email",
					source: "email"
				})
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "getAwardTypeFromAward", (function() {
				return c
			})), s.d(t, "clickGildEvent", (function() {
				return l
			})), s.d(t, "clickRpanGiveAward", (function() {
				return b
			})), s.d(t, "clickAddAward", (function() {
				return p
			})), s.d(t, "clickHideAward", (function() {
				return O
			})), s.d(t, "clickConfirmHideAward", (function() {
				return g
			})), s.d(t, "clickCancelHideAward", (function() {
				return f
			})), s.d(t, "clickAwardReportFlow", (function() {
				return j
			})), s.d(t, "clickCancelAwardReportFlow", (function() {
				return _
			})), s.d(t, "clickFlagAwardUsage", (function() {
				return h
			})), s.d(t, "clickCancelFlagAwardUsage", (function() {
				return y
			})), s.d(t, "clickConfirmFlagAwardUsage", (function() {
				return E
			})), s.d(t, "clickReportAward", (function() {
				return I
			})), s.d(t, "clickCancelReportAward", (function() {
				return v
			})), s.d(t, "clickConfirmReportAward", (function() {
				return S
			})), s.d(t, "viewGildModalEvent", (function() {
				return T
			})), s.d(t, "clickSelectAwardEvent", (function() {
				return w
			})), s.d(t, "viewGiveAwardTooltipEvent", (function() {
				return C
			})), s.d(t, "triggerAnonymousEvent", (function() {
				return A
			})), s.d(t, "clickMessageInputEvent", (function() {
				return D
			})), s.d(t, "typeMessageInputEvent", (function() {
				return P
			})), s.d(t, "clickLearnMoreLinkEvent", (function() {
				return R
			})), s.d(t, "clickQuestionMarkEvent", (function() {
				return k
			})), s.d(t, "clickConfirmAwardEvent", (function() {
				return x
			})), s.d(t, "clickGetPremiumEvent", (function() {
				return N
			})), s.d(t, "clickAddCoinsButtonEvent", (function() {
				return L
			})), s.d(t, "clickNextButtonEvent", (function() {
				return U
			})), s.d(t, "clickCloseGildModalEvent", (function() {
				return M
			})), s.d(t, "viewSuccessAwardEvent", (function() {
				return F
			})), s.d(t, "viewKarmaSuccessEvent", (function() {
				return G
			})), s.d(t, "clickFilterEvent", (function() {
				return B
			})), s.d(t, "clickNextFiltersEvent", (function() {
				return q
			})), s.d(t, "clickPreviousFiltersEvent", (function() {
				return V
			}));
			var n = s("./src/reddit/models/Gold/Award.ts"),
				r = s("./src/reddit/selectors/telemetry.ts"),
				a = s("./src/reddit/helpers/correlationIdTracker.ts"),
				i = s("./src/reddit/helpers/isComment.ts"),
				o = s("./src/reddit/selectors/gild.ts");
			const c = e => e.awardType === n.f.Global && e.awardSubType === n.d.Appreciation ? "gid_appreciation" : e.awardType === n.f.Global && e.awardSubType === n.d.Premium ? "gid_premium" : e.awardSubType === n.d.Group ? "gid_group" : e.awardType === n.f.Community ? "gid_community" : e.awardType === n.f.Moderator ? "gid_mod" : e.id,
				d = (e, t) => Object.assign({
					awardId: e.id,
					awardName: e.name,
					numberCoinsToRecipient: e.coinReward,
					type: c(e)
				}, t),
				u = (e, t) => Object.assign(Object.assign({}, r.defaults(e)), {
					comment: t ? r.comment(e, t) : void 0,
					correlationId: Object(o.b)(e) || Object(a.d)(a.a.GildingFlow, !1),
					post: t ? r.post(e, t) : void 0,
					screen: r.screen(e),
					subreddit: r.subreddit(e),
					userSubreddit: r.userSubreddit(e)
				}),
				l = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: Object(i.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold"
				}),
				b = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "stream_player",
					action: "click",
					noun: "give_gold"
				}),
				p = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: Object(i.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award"
				}),
				O = (e, t) => s => Object.assign(Object.assign({}, u(s, t)), {
					source: Object(i.a)(t) ? "comment" : "post",
					action: "click",
					noun: "hide_award",
					goldPurchase: d(e)
				}),
				g = (e, t) => s => Object.assign(Object.assign({}, u(s, t)), {
					source: Object(i.a)(t) ? "comment" : "post",
					action: "click",
					noun: "confirm_hide_award",
					goldPurchase: d(e)
				}),
				f = (e, t) => s => Object.assign(Object.assign({}, u(s, t)), {
					source: Object(i.a)(t) ? "comment" : "post",
					action: "click",
					noun: "cancel_hide_award",
					goldPurchase: d(e)
				}),
				m = e => (t, s) => n => Object.assign(Object.assign({}, u(n, s)), {
					source: Object(i.a)(s) ? "comment" : "post",
					action: "click",
					noun: e,
					goldPurchase: d(t)
				}),
				j = m("award_hovercard_report"),
				_ = m("cancel_award_hovercard_report"),
				h = m("flag_award"),
				y = m("cancel_flag_award"),
				E = m("confirm_flag_award"),
				I = m("report_community_award"),
				v = m("cancel_report_community_award"),
				S = m("confirm_report_community_award"),
				T = (e, t, s) => n => Object.assign(Object.assign({}, u(n, s)), {
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				w = (e, t, s) => n => Object.assign(Object.assign({}, u(n, t)), {
					source: "give_gold",
					action: "click",
					noun: "award",
					goldPurchase: d(e, s)
				}),
				C = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "view",
					noun: "tooltip"
				}),
				A = (e, t) => s => Object.assign(Object.assign({}, u(s, t)), {
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				D = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				P = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				R = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				k = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				x = (e, t) => s => Object.assign(Object.assign({}, u(s, e)), {
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: Object.assign({
						contentType: Object(i.a)(e) ? "comment" : "post"
					}, d(t))
				}),
				N = (e, t) => s => Object.assign(Object.assign({}, u(s, e)), {
					source: "give_gold",
					action: "click",
					noun: "get_premium",
					goldPurchase: Object.assign({
						contentType: Object(i.a)(e) ? "comment" : "post"
					}, d(t))
				}),
				L = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "click",
					noun: "add_coins"
				}),
				U = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				M = e => t => Object.assign(Object.assign({}, u(t, e)), {
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				F = (e, t, s) => n => Object.assign(Object.assign({}, u(n, e)), {
					source: "give_gold",
					action: "view",
					noun: "success",
					goldPurchase: Object.assign({
						contentType: Object(i.a)(e) ? "comment" : "post",
						numberCoins: t
					}, d(s))
				}),
				G = e => {
					let {
						award: t,
						awardeeKarmaEarned: s,
						awarderKarmaEarned: n,
						numberCoins: r,
						thingId: a
					} = e;
					return e => Object.assign(Object.assign({}, u(e, a)), {
						source: "give_gold",
						action: "view",
						noun: "karma_success",
						goldPurchase: Object.assign({
							contentType: Object(i.a)(a) ? "comment" : "post",
							awardeeKarmaEarned: s,
							awarderKarmaEarned: n,
							numberCoins: r
						}, d(t))
					})
				},
				B = e => t => Object.assign(Object.assign({}, u(t)), {
					source: "give_gold",
					action: "click",
					noun: "filter",
					goldPurchase: {
						filterId: e.tag,
						filterName: e.content.markdown
					}
				}),
				q = () => e => Object.assign(Object.assign({}, u(e)), {
					source: "give_gold",
					action: "click",
					noun: "next_filters"
				}),
				V = () => e => Object.assign(Object.assign({}, u(e)), {
					source: "give_gold",
					action: "click",
					noun: "previous_filters"
				})
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return o
			})), s.d(t, "b", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			}));
			var n, r = s("./src/reddit/constants/tracking.ts"),
				a = s("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(n || (n = {}));
			const i = e => ({
					subreddit: a.subreddit(e),
					userSubreddit: a.userSubreddit(e)
				}),
				o = e => Object.assign({
					source: "subreddit_tooltip",
					noun: n.SubredditInlineTooltip,
					action: r.c.VIEW
				}, i(e)),
				c = e => Object.assign({
					source: "id_card",
					noun: n.EditSubredditIcon,
					action: r.c.CLICK
				}, i(e)),
				d = e => Object.assign({
					source: "id_card",
					noun: n.EditSubredditDescription,
					action: r.c.CLICK
				}, i(e)),
				u = (e, t) => s => Object.assign({
					source: "id_card",
					noun: n.SaveDescription,
					action: r.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					}
				}, i(s)),
				l = (e, t) => Object.assign(Object.assign(Object.assign({
					source: "id_card",
					noun: n.Error,
					action: r.c.VIEW
				}, i(e)), a.defaults(e)), {
					actionInfo: a.actionInfo(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/media.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "b", (function() {
				return o
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const a = (e, t, s) => a => ({
					source: "videoplayer",
					action: t,
					noun: s,
					experiment: r.experiment(a, n.qc),
					post: r.post(a, e),
					media: r.media(a, e),
					profile: r.profile(a),
					subreddit: r.subreddit(a),
					actionInfo: r.mediaActionInfo(a, e),
					correlationId: r.videoCorrelationId()
				}),
				i = e => t => ({
					source: "videoplayer",
					action: "underrun",
					noun: "playback",
					experiment: r.experiment(t, n.qc),
					post: r.post(t, e),
					profile: r.profile(t),
					subreddit: r.subreddit(t),
					actionInfo: r.mediaActionInfo(t, e),
					media: r.media(t, e)
				}),
				o = (e, t, s) => n => Object.assign(Object.assign({}, a(e, t, s)(n)), {
					timer: r.videoPlayerFirstFrameTimer(n, e),
					media: Object.assign(Object.assign({}, r.media(n, e)), r.videoPlayerMaxTimeServed(n, e))
				})
		},
		"./src/reddit/helpers/trackers/post.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return b
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			})), s.d(t, "f", (function() {
				return m
			})), s.d(t, "b", (function() {
				return j
			})), s.d(t, "c", (function() {
				return h
			})), s.d(t, "g", (function() {
				return y
			})), s.d(t, "e", (function() {
				return E
			})), s.d(t, "d", (function() {
				return I
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/helpers/correlationIdTracker.ts"),
				a = s("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				i = s("./src/reddit/helpers/localStorage/index.ts"),
				o = s("./src/reddit/models/Post/index.ts"),
				c = s("./src/reddit/selectors/experiments/listingBelow.ts"),
				d = s("./src/reddit/selectors/telemetry.ts"),
				u = s("./src/telemetry/index.ts");
			const l = e => e && e.meta && e.meta.name && e.meta.name === n.Bb.DUPLICATES,
				b = (e, t, s) => {
					const {
						currentPage: n
					} = e.platform, i = l(n) ? "other_discussions" : "post", o = Object(c.b)(e);
					if (o) {
						const n = Object(a.a)(e),
							i = n ? n.id : void 0;
						return Object(u.a)(Object.assign(Object.assign({}, d.defaults(e)), {
							action: "view",
							actionInfo: d.actionInfo(e, {
								position: "number" == typeof s ? s + 1 : void 0
							}),
							correlationId: Object(r.c)(r.a.LinkedPosts),
							media: d.media(e, t),
							mlModel: d.listingBelowMlModel(o, i),
							noun: "post",
							post: d.post(e, t),
							profile: d.profile(e),
							source: "post_detail",
							subreddit: d.subreddit(e)
						}))
					}
					return Object(u.a)(Object.assign(Object.assign({
						source: i,
						action: "view",
						noun: "post"
					}, d.defaults(e)), {
						actionInfo: d.actionInfo(e, {
							position: s
						}),
						post: d.post(e, t),
						profile: d.profile(e),
						media: d.media(e, t),
						screen: d.screen(e),
						subreddit: d.subreddit(e)
					}))
				},
				p = (e, t) => Object(u.a)(Object.assign(Object.assign({
					source: "post",
					action: "view",
					noun: "ad"
				}, d.defaults(e)), {
					post: d.post(e, t),
					media: d.media(e, t),
					screen: d.screen(e),
					subreddit: d.subreddit(e)
				})),
				O = (e, t, s, n) => Object(u.a)(Object.assign(Object.assign({
					source: "post",
					action: "consume",
					noun: "post"
				}, d.defaults(e)), {
					actionInfo: d.actionInfo(e, {
						position: n
					}),
					post: d.post(e, t, s),
					media: d.media(e, t),
					screen: d.screen(e),
					subreddit: d.subreddit(e)
				})),
				g = (e, t, s, n) => ({
					noun: n,
					post: d.post(e, t),
					source: s
				}),
				f = (e, t, s, n) => {
					const {
						currentPage: r
					} = e.platform;
					if (l(r)) {
						const s = Object(o.m)(r && r.urlParams.partialPostId || "");
						return {
							noun: "post",
							post: d.post(e, s),
							source: "other_discussions",
							targetPost: d.post(e, t)
						}
					}
					return g(e, t, s, n)
				},
				m = function(e, t) {
					let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "post",
						n = arguments.length > 3 ? arguments[3] : void 0,
						a = arguments.length > 4 ? arguments[4] : void 0,
						o = arguments.length > 5 ? arguments[5] : void 0,
						u = arguments.length > 6 ? arguments[6] : void 0;
					return b => {
						const p = d.post(b, e);
						(null == p ? void 0 : p.promoted) && Object(i.Y)(e);
						const {
							currentPage: O
						} = b.platform, m = l(O) ? f(b, e, s, t) : g(b, e, s, t), j = Object(c.b)(b) || o, _ = d.defaults(b);
						if (j) {
							const s = n ? d.getRelativePostOrder(b, e, n) : null;
							return Object.assign(Object.assign({}, _), {
								action: "click",
								actionInfo: Object.assign(Object.assign({}, _.actionInfo), {
									position: "number" == typeof s ? s + 1 : void 0,
									referralId: u
								}),
								correlationId: Object(r.c)(r.a.LinkedPosts),
								media: d.media(b, e),
								mlModel: d.listingBelowMlModel(j, a),
								noun: t,
								post: p,
								profile: d.profile(b),
								source: "post_detail",
								subreddit: d.subreddit(b)
							})
						}
						return Object.assign(Object.assign(Object.assign({}, m), _), {
							action: "click",
							actionInfo: Object.assign(Object.assign({}, _.actionInfo), {
								referralId: u
							}),
							media: d.media(b, e),
							subreddit: d.subreddit(b) || d.subredditByPostOrCommentId(b, e)
						})
					}
				},
				j = (e, t) => s => Object(u.a)(Object.assign(Object.assign({
					source: "post",
					action: "click",
					noun: t
				}, d.defaults(s)), {
					post: d.post(s, e),
					media: d.media(s, e),
					screen: d.screen(s),
					session: d.session(s),
					subreddit: d.subreddit(s)
				})),
				_ = (e, t) => ({
					post: d.post(e, t),
					profile: d.profile(e)
				}),
				h = e => t => Object.assign(Object.assign({
					action: "pin",
					noun: "post",
					source: "profile"
				}, _(t, e)), d.defaults(t)),
				y = e => t => Object.assign(Object.assign({
					action: "unpin",
					noun: "post",
					source: "profile"
				}, _(t, e)), d.defaults(t)),
				E = (e, t, s) => n => Object.assign(Object.assign({
					action: "click",
					noun: "vote",
					source: "poll"
				}, d.defaults(n)), {
					poll: d.poll(n, e, !0, s),
					post: d.post(n, t),
					subreddit: d.subreddit(n),
					userSubreddit: d.userSubreddit(n)
				}),
				I = (e, t) => s => Object.assign(Object.assign({
					action: "view",
					noun: "results",
					source: "poll"
				}, d.defaults(s)), {
					poll: d.poll(s, e, !1),
					post: d.post(s, t),
					subreddit: d.subreddit(s),
					userSubreddit: d.userSubreddit(s)
				})
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			})), s.d(t, "c", (function() {
				return j
			})), s.d(t, "x", (function() {
				return _
			})), s.d(t, "w", (function() {
				return h
			})), s.d(t, "s", (function() {
				return y
			})), s.d(t, "p", (function() {
				return E
			})), s.d(t, "q", (function() {
				return I
			})), s.d(t, "z", (function() {
				return v
			})), s.d(t, "r", (function() {
				return S
			})), s.d(t, "i", (function() {
				return T
			})), s.d(t, "u", (function() {
				return w
			})), s.d(t, "t", (function() {
				return C
			})), s.d(t, "o", (function() {
				return A
			})), s.d(t, "n", (function() {
				return D
			})), s.d(t, "y", (function() {
				return P
			})), s.d(t, "k", (function() {
				return R
			})), s.d(t, "j", (function() {
				return k
			})), s.d(t, "l", (function() {
				return x
			})), s.d(t, "d", (function() {
				return L
			})), s.d(t, "m", (function() {
				return M
			})), s.d(t, "h", (function() {
				return F
			})), s.d(t, "e", (function() {
				return G
			})), s.d(t, "f", (function() {
				return B
			})), s.d(t, "b", (function() {
				return q
			})), s.d(t, "v", (function() {
				return V
			})), s.d(t, "g", (function() {
				return H
			}));
			var n = s("./src/reddit/constants/tracking.ts"),
				r = s("./src/reddit/helpers/correlationIdTracker.ts"),
				a = s("./src/reddit/helpers/media/index.ts"),
				i = s("./src/reddit/models/PostCreationForm/index.ts"),
				o = s("./src/reddit/models/PostDraft/index.ts"),
				c = s("./src/reddit/selectors/postDraft.ts"),
				d = s("./src/reddit/selectors/telemetry.ts"),
				u = s("./src/reddit/selectors/user.ts"),
				l = s("./src/telemetry/index.ts"),
				b = s("./src/telemetry/models/PostComposer.ts"),
				p = s("./src/telemetry/models/PostDraft.ts");
			const O = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					crosspost: "crosspost"
				},
				g = e => Object.assign(Object.assign({
					source: "post_composer",
					action: n.c.CLICK
				}, d.defaults(e)), {
					screen: d.screen(e),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				f = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === i.h.MARKDOWN ? "markdown" : "rte"
				},
				m = e => {
					Object(l.a)(Object.assign({
						noun: "cancel"
					}, g(e)))
				},
				j = e => {
					Object(l.a)(Object.assign({
						noun: "discard"
					}, g(e)))
				},
				_ = e => {
					Object(l.a)(Object.assign(Object.assign({
						noun: "subreddit_choice",
						subreddit: d.subreddit(e)
					}, g(e)), {
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				h = e => {
					Object(l.a)(Object.assign({
						noun: "subreddit_selector"
					}, g(e)))
				},
				y = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "post_type_selector",
						postComposer: {
							type: O[t]
						}
					}, g(e)))
				},
				E = () => e => Object.assign({
					noun: "add_option"
				}, g(e)),
				I = () => e => Object.assign({
					noun: "voting_length"
				}, g(e)),
				v = (e, t, s) => {
					"image_upload" === t || "video_upload" === t ? Object(l.a)(Object.assign({
						noun: t
					}, g(e))) : Object(l.a)(Object.assign({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: s ? "on" : "off"
						}
					}, g(e)))
				},
				S = (e, t, s) => {
					Object(l.a)(Object.assign({
						noun: "post",
						subreddit: d.subreddit(e),
						postComposer: Object.assign({
							type: t
						}, f(e, t)),
						post: s ? d.post(e, s) : null
					}, g(e)))
				},
				T = (e, t) => {
					const s = t === i.h.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(l.a)(Object.assign({
						noun: s
					}, g(e)))
				},
				w = (e, t) => {
					Object(l.a)(Object.assign({
						noun: "save",
						subreddit: d.subreddit(e),
						postComposer: Object.assign({
							type: t
						}, f(e, t))
					}, g(e)))
				},
				C = (e, t) => {
					const s = e.uploads[t];
					s.error && Object(l.a)(Object.assign(Object.assign({}, g(e)), {
						noun: "media",
						action: n.c.REJECT,
						actionInfo: Object.assign(Object.assign({}, d.actionInfo(e)), {
							reason: JSON.stringify(s.error)
						})
					}))
				},
				A = (e, t) => {
					t.forEach(t => {
						const s = Object(a.f)(t.type);
						s && Object(l.a)(Object.assign(Object.assign({}, g(e)), {
							action: n.c.DRAG,
							noun: s
						}))
					})
				},
				D = (e, t, s) => {
					Object(l.a)(Object.assign(Object.assign({}, g(e)), {
						noun: "input",
						postComposer: {
							inputType: s
						},
						action: t,
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				P = (e, t, s) => {
					Object(l.a)(Object.assign(Object.assign({}, g(e)), {
						noun: s,
						action: Object(b.getToggleAction)(t),
						actionInfo: d.chatPostActionInfo(e)
					}))
				},
				R = e => N("input", e),
				k = () => N("add"),
				x = () => N("remove"),
				N = (e, t) => s => Object.assign(Object.assign({}, g(s)), {
					noun: e,
					postComposer: {
						inputType: t,
						type: O.imageOnly
					},
					action: n.c.CLICK
				}),
				L = e => {
					Object(l.a)(Object.assign(Object.assign({}, g(e)), {
						noun: "hide_oc_description",
						action: n.c.CLICK
					}))
				},
				U = (e, t) => {
					if (t) {
						const s = d.subredditById(e, t);
						if (s) return {
							subreddit: s
						};
						const n = d.profileById(e, t);
						if (n) return {
							profile: n
						}
					}
				},
				M = (e, t) => {
					const {
						draftId: s,
						destSubreddit: n
					} = t, r = Object(u.i)(e), a = Object(c.d)(e, {
						draftId: s
					}), i = {
						authorId: r ? r.id : void 0,
						createdTimestamp: a ? a.created : void 0,
						id: s || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case o.b.Link:
							i.type = p.DraftType.Link, i.urlLength = t.body.length;
							break;
						case o.b.Markdown:
							i.type = p.DraftType.Self, i.bodyTextLength = t.body.length;
							break;
						case o.b.RichText:
							i.type = p.DraftType.RichText, t.documentStats && (i.bodyTextLength = t.documentStats.textLength, i.numberRteImages = t.documentStats.rteImagesCount, i.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case o.b.Image:
							i.type = p.DraftType.Image;
							break;
						case o.b.Video:
							i.type = p.DraftType.Video
					}
					return Object.assign({
						postDraft: i
					}, U(e, n.id))
				},
				F = (e, t) => {
					Object(l.a)(Object.assign(Object.assign({
						noun: "draft_load"
					}, g(e)), M(e, t)))
				},
				G = (e, t) => {
					Object(l.a)(Object.assign(Object.assign({
						noun: t.draftId ? "draft_update" : "draft_create"
					}, g(e)), M(e, t)))
				},
				B = (e, t) => {
					Object(l.a)(Object.assign(Object.assign({
						noun: "draft_delete"
					}, g(e)), ((e, t) => {
						const s = Object(u.i)(e),
							n = {
								authorId: s ? s.id : void 0,
								createdTimestamp: t.created,
								id: t.id,
								nsfw: t.isNSFW,
								originalContent: t.isOriginalContent,
								spoiler: t.isSpoiler,
								titleLength: t.title.length
							};
						switch (t.kind) {
							case o.b.Link:
								n.type = p.DraftType.Link, n.urlLength = (t.body || "").length;
								break;
							case o.b.Markdown:
								n.type = p.DraftType.Self, n.bodyTextLength = (t.body || "").length;
								break;
							case o.b.RichText:
								n.type = p.DraftType.RichText
						}
						return Object.assign({
							postDraft: n
						}, U(e, t.subredditId))
					})(e, t)))
				},
				q = e => {
					Object(l.a)(Object.assign(Object.assign({}, g(e)), {
						noun: "social_connect_link",
						action: n.c.CLICK
					}))
				},
				V = (e, t) => {
					Object(l.a)(Object.assign(Object.assign({}, g(e)), {
						noun: "twitter_share_checkbox",
						action: Object(b.getToggleAction)(t)
					}))
				},
				H = (e, t, s) => {
					Object(l.a)(Object.assign(Object.assign(Object.assign({}, g(e)), M(e, t)), {
						noun: "draft_share",
						action: s ? n.c.ENABLE : n.c.DISABLE
					}))
				}
		},
		"./src/reddit/helpers/trackers/postList.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "g", (function() {
				return p
			})), s.d(t, "h", (function() {
				return O
			})), s.d(t, "j", (function() {
				return g
			}));
			var n = s("./src/telemetry/index.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const a = (e, t) => Object.assign(Object.assign({}, r.defaults(e)), {
					media: r.media(e, t),
					post: r.post(e, t),
					profile: r.profile(e),
					subreddit: r.subreddit(e)
				}),
				i = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "stop",
						noun: "autoplay_initial_load"
					}))
				},
				o = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "complete",
						noun: "autoplay_initial_load"
					}))
				},
				c = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "start",
						noun: "autoplay_initial_load"
					}))
				},
				d = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "start",
						noun: "autoplay_network_load"
					}))
				},
				u = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "consume",
						noun: "autoplay"
					}))
				},
				l = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "start",
						noun: "autoplay"
					}))
				},
				b = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "start",
						noun: "autoplay_buffering"
					}))
				},
				p = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "stop",
						noun: "autoplay"
					}))
				},
				O = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({}, a(e, t)), {
						source: "postlist",
						action: "stop",
						noun: "autoplay_buffering"
					}))
				},
				g = (e, t) => {
					Object(n.a)(Object.assign(Object.assign({
						action: "view",
						source: "postlist",
						noun: "bottom"
					}, r.defaults(e)), {
						listing: r.listing(e, t),
						subreddit: r.subreddit(e)
					}))
				}
		},
		"./src/reddit/helpers/trackers/profileSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "k", (function() {
				return O
			})), s.d(t, "j", (function() {
				return g
			})), s.d(t, "g", (function() {
				return m
			})), s.d(t, "f", (function() {
				return j
			})), s.d(t, "i", (function() {
				return _
			})), s.d(t, "c", (function() {
				return h
			})), s.d(t, "h", (function() {
				return y
			})), s.d(t, "a", (function() {
				return E
			}));
			var n = s("./node_modules/lodash/pick.js"),
				r = s.n(n),
				a = s("./src/reddit/constants/tracking.ts"),
				i = s("./src/reddit/selectors/telemetry.ts"),
				o = s("./src/telemetry/index.ts"),
				c = s("./src/telemetry/models/PostComposer.ts");
			const d = e => Object.assign({
					source: "profile_settings"
				}, Object(i.defaults)(e)),
				u = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
					const s = Object(i.currentProfileModelSelector)(e);
					if (s) return r()(s, ["id", "name", "type", ...t])
				},
				l = e => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						noun: "twitter_connect_link",
						action: a.c.CLICK
					}))
				},
				b = e => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						noun: "twitter_disconnect_link",
						action: a.c.CLICK
					}))
				},
				p = (e, t) => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						noun: "display_twitter_checkbox",
						action: Object(c.getToggleAction)(t)
					}))
				},
				O = (e, t) => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						noun: "twitter_account",
						action: a.c.CLICK,
						profile: {
							id: t.id,
							name: t.username
						}
					}))
				},
				g = e => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						profile: u(e, ["display_name", "about", "avatar_url", "cover_url", "nsfw", "content_visible", "communities_visible"]),
						action: a.c.VIEW,
						noun: "settings_page"
					}))
				},
				f = {
					profileIcon: "avatar",
					profileBanner: "cover"
				},
				m = (e, t) => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						profile: u(e, ["avatar_url", "cover_url"]),
						action: "upload",
						noun: f[t]
					}))
				},
				j = (e, t) => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						profile: u(e, []),
						action: "remove",
						noun: f[t]
					}))
				},
				_ = e => {
					Object(o.a)(Object.assign(Object.assign({}, d(e)), {
						profile: u(e, ["display_name", "about", "nsfw", "content_visible", "communities_visible"]),
						action: "click",
						noun: "save_settings"
					}))
				},
				h = e => t => Object.assign(Object.assign({}, d(t)), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "content_visible"
				}),
				y = e => t => Object.assign(Object.assign({}, d(t)), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "nsfw"
				}),
				E = e => t => Object.assign(Object.assign({}, d(t)), {
					profile: u(t, []),
					action: e ? "select" : "deselect",
					noun: "active_in_communities"
				})
		},
		"./src/reddit/helpers/trackers/searchResults.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return l
			})), s.d(t, "q", (function() {
				return b
			})), s.d(t, "p", (function() {
				return p
			})), s.d(t, "r", (function() {
				return O
			})), s.d(t, "g", (function() {
				return g
			})), s.d(t, "t", (function() {
				return f
			})), s.d(t, "s", (function() {
				return m
			})), s.d(t, "u", (function() {
				return j
			})), s.d(t, "w", (function() {
				return _
			})), s.d(t, "f", (function() {
				return y
			})), s.d(t, "a", (function() {
				return E
			})), s.d(t, "h", (function() {
				return I
			})), s.d(t, "x", (function() {
				return v
			})), s.d(t, "v", (function() {
				return S
			})), s.d(t, "i", (function() {
				return T
			})), s.d(t, "k", (function() {
				return w
			})), s.d(t, "e", (function() {
				return C
			})), s.d(t, "j", (function() {
				return A
			})), s.d(t, "d", (function() {
				return D
			})), s.d(t, "o", (function() {
				return P
			})), s.d(t, "n", (function() {
				return R
			})), s.d(t, "l", (function() {
				return k
			})), s.d(t, "m", (function() {
				return x
			})), s.d(t, "b", (function() {
				return N
			}));
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/constants/posts.ts"),
				a = s("./src/reddit/constants/tracking.ts"),
				i = s("./src/reddit/helpers/correlationIdTracker.ts"),
				o = s("./src/reddit/selectors/posts.ts"),
				c = s("./src/reddit/selectors/telemetry.ts");
			const d = "search",
				u = "search_results_best",
				l = (e, t) => {
					const s = c.subreddit(e);
					return {
						screen: c.screen(e),
						subreddit: s && t && t.restrict_sr ? s : null
					}
				},
				b = (e, t) => s => {
					const n = t;
					return n.structureType = "related", Object.assign({
						action: e,
						correlationId: Object(i.c)(i.a.SearchResults),
						noun: "related_search",
						source: d,
						search: c.search(s, n)
					}, l(s))
				},
				p = (e, t, s, n) => r => Object.assign(Object.assign({}, l(r, s)), {
					source: d,
					action: "click",
					noun: t,
					actionInfo: c.actionInfo(r, n ? {
						pageType: "search_results_best",
						position: 0
					} : void 0),
					discoveryUnit: n ? c.discoveryUnit(n) : null,
					search: c.search(r, s),
					post: c.post(r, e),
					media: c.media(r, e)
				}),
				O = (e, t, s, n, r) => a => Object.assign(Object.assign({}, C(a, e, t, r, n, s)), {
					noun: "ad"
				}),
				g = (e, t, s) => r => {
					let a = !0;
					if (t.type.indexOf(n.Nb.Posts) > -1) {
						const {
							api: t
						} = r.listings.listingOrder;
						a = a && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(n.Nb.Subreddits) > -1 || t.type.indexOf(n.Nb.Users) > -1) {
						const {
							api: t
						} = r.listings.postOrder;
						a = a && !t.error[e] && !t.pending[e]
					}
					return Object.assign(Object.assign({}, l(r, t)), {
						source: d,
						action: "view",
						noun: "search_results_post",
						actionInfo: c.actionInfo(r, {
							success: a,
							pageType: "search_results_best",
							position: 0
						}),
						discoveryUnit: c.discoveryUnit(s),
						search: c.search(r, t)
					})
				},
				f = (e, t) => s => ({
					action: "view",
					actionInfo: c.actionInfo(s),
					metaSearch: c.metaSearch(t),
					noun: e,
					screen: c.screen(s),
					search: c.smartSearch(s, t),
					source: d
				}),
				m = (e, t) => s => ({
					action: "click",
					actionInfo: c.actionInfo(s),
					noun: e,
					metaSearch: c.metaSearch(t),
					screen: c.screen(s),
					search: c.smartSearch(s, t),
					source: d
				}),
				j = (e, t, s) => n => Object.assign({
					source: d,
					action: "click",
					noun: c.SearchDropdownNouns.Recent,
					actionInfo: c.actionInfo(n, {
						paneName: "subreddit_dropdown",
						position: s + 1
					}),
					search: {
						query: e,
						originPageType: n.platform.currentPage ? c.getPageTypeFromCurrentPage(n.platform.currentPage) : void 0,
						queryId: Object(i.c)(i.a.SearchResults)
					}
				}, h(n, t)),
				_ = (e, t, s, n) => r => {
					const a = n.filter(e => e.id);
					return Object.assign({
						source: d,
						action: "click",
						noun: c.SearchDropdownNouns.Typeahead,
						actionInfo: c.actionInfo(r, {
							position: s + 1
						}),
						search: {
							query: t.displayInfo && t.displayInfo.subredditOrProfileName ? t.displayInfo.subredditOrProfileName : e,
							originPageType: r.platform.currentPage ? c.getPageTypeFromCurrentPage(r.platform.currentPage) : void 0,
							queryId: Object(i.c)(i.a.SearchResults),
							typeaheadActive: !0,
							subredditIds: a.map(e => e.id),
							numberSubreddits: a.length
						}
					}, h(r, t))
				},
				h = (e, t) => {
					const s = t.isSubreddit && t.id ? c.subredditForSearch(e, t.id) : void 0,
						n = t.isProfile && t.id ? c.profileForSearch(e, t.id) : void 0,
						r = {
							id: t.id,
							name: t.displayInfo ? t.displayInfo.subredditOrProfileName : void 0
						};
					return {
						subreddit: t.isSubreddit ? s || r : void 0,
						profile: t.isProfile ? n || r : void 0
					}
				},
				y = (e, t, s) => n => ({
					action: t,
					actionInfo: c.actionInfo(n),
					noun: e,
					screen: c.screen(n),
					search: c.search(n, s),
					source: u
				});
			var E;
			! function(e) {
				e.TopResults = "tab_top_results", e.Posts = "tab_posts", e.CommunitiesAndUsers = "tab_communities"
			}(E || (E = {}));
			const I = (e, t) => s => Object.assign(Object.assign({}, l(s, t)), {
					source: d,
					action: "click",
					noun: e,
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(s),
					search: c.search(s, t)
				}),
				v = (e, t) => s => Object.assign(Object.assign({}, l(s, t)), {
					source: d,
					action: "click",
					noun: e,
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(s),
					search: c.search(s, t)
				}),
				S = (e, t) => s => ({
					action: "click",
					correlationId: Object(i.c)(i.a.SearchResults),
					noun: e ? n.Mb.ToSubreddit : n.Mb.ToGlobal,
					search: c.search(s, t),
					source: d
				}),
				T = (e, t, s, n) => r => Object.assign(Object.assign({}, l(r, s)), {
					source: d,
					action: "click",
					noun: "search_result_post",
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(r, {
						relativePosition: c.getRelativePostOrder(r, t, e)
					}),
					search: Object.assign(Object.assign({}, c.search(r, s)), !!n && {
						originElement: n
					}),
					post: c.post(r, t)
				}),
				w = (e, t, s, n, r) => a => C(a, e, t, s, n, r),
				C = (e, t, s, n, r, o) => {
					const u = c.paneName(e, n),
						l = c.postRelativePosition(e, t, r, o),
						b = c.amountOfElementsBeforePost(e, s, r, o, u),
						p = null !== l ? b + l : null,
						O = c.structureType(e, n),
						g = Object.assign(Object.assign({}, c.search(e, s, !0, n || void 0)), {
							structureType: O,
							queryId: Object(i.c)(i.a.SearchResults)
						});
					return {
						source: d,
						action: a.c.CLICK,
						noun: "post",
						actionInfo: n ? {
							pageType: c.getPageTypeFromCurrentPage(n),
							paneName: u,
							position: p,
							relativePosition: l
						} : c.actionInfo(e, {
							paneName: u,
							position: p,
							relativePosition: l
						}),
						search: g,
						post: c.post(e, t),
						userPreferences: {
							hideNsfw: !e.user.prefs.over18
						},
						discoveryUnit: o ? c.discoveryUnit(o) : null
					}
				},
				A = (e, t, s, n, r, a) => i => D(i, e, t, s, n, r, a),
				D = (e, t, s, n, u, l, b) => {
					if (!n) {
						n = Object(o.N)(e, {
							postId: l
						}).belongsTo
					}
					const p = c.paneName(e, s);
					let O, g;
					if (l) {
						O = c.postRelativePosition(e, l, u, b);
						const s = c.amountOfElementsBeforePost(e, t, u, b, p);
						g = null !== O ? s + O : null
					} else {
						O = c.communityRelativePosition(e, n.id, u, b);
						const t = c.amountOfElementsBeforeCommunity(e, u, b);
						g = null !== O ? t + O : null
					}
					const f = c.structureType(e, s),
						m = Object.assign(Object.assign({}, c.search(e, t, !0, s || void 0)), {
							structureType: f,
							queryId: Object(i.c)(i.a.SearchResults)
						});
					return {
						source: d,
						action: a.c.CLICK,
						noun: n.type,
						search: m,
						subreddit: n.type === r.a.SUBREDDIT ? c.subredditForSearch(e, n.id) : void 0,
						profile: n.type === r.a.PROFILE ? c.profileForSearch(e, n.id) : void 0,
						userPreferences: {
							hideNsfw: !e.user.prefs.over18
						},
						discoveryUnit: b ? c.discoveryUnit(b) : null,
						actionInfo: s ? {
							pageType: c.getPageTypeFromCurrentPage(s),
							paneName: p,
							position: g,
							relativePosition: O
						} : c.actionInfo(e, {
							paneName: p,
							position: g,
							relativePosition: O
						}),
						post: l ? c.post(e, l) : void 0
					}
				},
				P = (e, t) => s => Object.assign(Object.assign({}, l(s, e)), {
					source: d,
					action: "click",
					noun: "search_result_subreddit",
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(s),
					search: Object.assign(Object.assign({}, c.search(s, e)), !!t && {
						originElement: t
					}),
					subreddit: c.subreddit(s)
				}),
				R = (e, t, s, n, r) => i => Object.assign(Object.assign({}, C(i, t, s, n, e, r)), {
					action: a.c.VIEW
				}),
				k = (e, t, s, n) => r => Object.assign(Object.assign({}, l(r, s)), {
					source: d,
					action: "view",
					noun: "search_results_post",
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(r, {
						relativePosition: c.getRelativePostOrder(r, t, e),
						position: c.getAbsoluteOrder(r, t, e)
					}),
					search: Object.assign(Object.assign({}, c.search(r, s)), !!n && {
						originElement: n
					}),
					post: c.post(r, t)
				}),
				x = (e, t, s) => n => Object.assign(Object.assign({}, l(n)), {
					source: d,
					action: "click",
					noun: "search_result_".concat(e),
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(n),
					search: Object.assign(Object.assign({}, c.search(n, t)), !!s && {
						originElement: s
					}),
					[e]: c[e](n)
				}),
				N = (e, t) => s => Object.assign(Object.assign({}, l(s, t)), {
					source: d,
					action: e,
					noun: "covid_banner",
					correlationId: Object(i.c)(i.a.SearchResults),
					actionInfo: c.actionInfo(s),
					search: c.search(s, t)
				})
		},
		"./src/reddit/helpers/trackers/subredditCreation.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			}));
			var n = s("./src/reddit/selectors/telemetry.ts");
			const r = e => t => Object.assign(Object.assign({
					source: e,
					noun: "create_community_button",
					action: "click"
				}, n.defaults(t)), {
					actionInfo: n.actionInfo(t, {
						settingValue: t.user.account && t.user.account.isMod ? "existing_mod" : "new_mod"
					})
				}),
				a = (e, t, s) => r => Object.assign(Object.assign({
					source: "community_form",
					noun: "save_community_button",
					action: "click"
				}, n.defaults(r)), {
					actionInfo: n.actionInfo(r, {
						settingValue: e
					}),
					subreddit: {
						id: s,
						name: t.name,
						publicDescription: t.publicDescription,
						nsfw: t.over18,
						accessType: t.type,
						topicTagContents: t.allTags,
						topicTagPrimaryId: t.primaryTagId
					}
				}),
				i = () => e => Object.assign(Object.assign({
					source: "community_form",
					noun: "cancel",
					action: "click"
				}, n.defaults(e)), {
					actionInfo: n.actionInfo(e)
				}),
				o = e => t => Object.assign(Object.assign({
					source: "community_form",
					noun: "error_message",
					action: "view"
				}, n.defaults(t)), {
					actionInfo: n.actionInfo(t, {
						reason: e
					})
				})
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return i
			}));
			var n, r = s("./node_modules/uuid/v4.js"),
				a = s.n(r);
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(n || (n = {}));
			const i = () => a()()
		},
		"./src/reddit/models/Badge/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "b", (function() {
				return d
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, r = s("./src/config.ts");

			function a(e) {
				return "userId" in e
			}

			function i(e) {
				return !(!e.extra || !e.extra.membership) && !!e.extra.membership.included
			}

			function o(e, t, s) {
				const n = s.media[0],
					r = Object.keys(n);
				if (n["0x0"]) return n["0x0"];
				let a = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (r.forEach(s => {
						const r = n[s],
							[i, o] = s.split("x").map(e => parseInt(e));
						(i < a.width && i >= e || o < a.height && o >= t) && (a = {
							height: o,
							width: i,
							url: r
						})
					}), !a.url && r.length) {
					const e = Object.keys(n)[0],
						t = n[e],
						[s, r] = e.split("x").map(e => parseInt(e));
					a = {
						height: r,
						width: s,
						url: t
					}
				}
				return a.url
			}

			function c(e) {
				return e.startsWith("https") ? e : "".concat(r.a.assetPath, "/").concat(e)
			}

			function d(e, t, s) {
				const n = o(e, t, s),
					r = o(2 * e, 2 * t, s);
				return {
					url: c(n),
					url2x: c(r)
				}
			}! function(e) {
				e.First = "p1", e.Second = "p2"
			}(n || (n = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			}));
			var n, r, a = s("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(n || (n = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(r || (r = {}));
			const i = {
					[n.Loyalty]: a.a.First,
					[n.Achievement]: a.a.Second,
					[n.Cosmetic]: void 0
				},
				o = e => e === a.a.First ? n.Loyalty : e === a.a.Second ? n.Achievement : n.Cosmetic
		},
		"./src/reddit/models/ChatSettingsPage/index.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})), s.d(t, "c", (function() {
					return r
				})), s.d(t, "b", (function() {
					return a
				})),
				function(e) {
					e.Unknown = "unknown", e.Toggle = "BOOLEAN"
				}(n || (n = {}));
			const r = function(e, t) {
					let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return e && Array.isArray(e) && e.length ? e.reduce((e, r) => {
						if (r && r.id && r.type && r.title && r.hasOwnProperty("state")) switch (r.type) {
							case n.Toggle:
								e.push({
									settingType: n.Toggle,
									settingId: r.id,
									subredditId: t,
									description: r.description,
									descriptionUrl: r.descriptionUrl,
									groupName: r.groupName,
									isEditable: !s && r.isEditable,
									state: "true" === String(r.state).toLowerCase(),
									title: r.title
								});
								break;
							default:
								e.push({
									settingType: n.Unknown,
									settingId: r.id,
									subredditId: t,
									description: r.description,
									descriptionUrl: r.descriptionUrl,
									groupName: r.groupName,
									isEditable: !s && r.isEditable,
									state: r.state,
									title: r.title
								})
						}
						return e
					}, []) : []
				},
				a = e => e.reduce((e, t) => (t.isEditable && e.push({
					id: t.settingId,
					state: String(t.state)
				}), e), [])
		},
		"./src/reddit/models/Comment/addProfileImgParam.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(n.a)(e, {
				profile_img: !0
			})
		},
		"./src/reddit/models/DiscoveryUnit/index.ts": function(e, t, s) {
			"use strict";
			var n, r, a, i;
			s.d(t, "f", (function() {
					return n
				})), s.d(t, "e", (function() {
					return r
				})), s.d(t, "d", (function() {
					return a
				})), s.d(t, "c", (function() {
					return o
				})), s.d(t, "g", (function() {
					return c
				})), s.d(t, "h", (function() {
					return d
				})), s.d(t, "l", (function() {
					return u
				})), s.d(t, "a", (function() {
					return l
				})), s.d(t, "b", (function() {
					return b
				})), s.d(t, "j", (function() {
					return p
				})), s.d(t, "k", (function() {
					return O
				})), s.d(t, "i", (function() {
					return g
				})),
				function(e) {
					e.Community = "community", e.CommunityCategory = "community_category", e.FavoriteSubreddits = "favorite_subreddits", e.Listing = "listing", e.RecentlyVisitedSubreddits = "recently_visited_subreddits", e.SubredditListing = "subreddit_listing"
				}(n || (n = {})),
				function(e) {
					e.Comments = "comments", e.Communities = "communities", e.Explore = "explore", e.Frontpage = "front_page", e.Popular = "popular", e.SubredditListing = "subreddit_listing", e.Topic = "topic"
				}(r || (r = {})),
				function(e) {
					e.Large = "large", e.Small = "small"
				}(a || (a = {})),
				function(e) {
					e.Wide = "wide", e.Description = "description", e.ActionButton = "action_button", e.SeeMore = "see_more", e.HideItems = "hide_items", e.HideUnit = "hide_unit", e.ShowLess = "show_less", e.PostShowSubredditHeader = "post_show_subreddit_header", e.UnitShowSubredditHeader = "unit_show_subreddit_header", e.PreviewMode = "preview_mode"
				}(i || (i = {}));
			const o = "community_banner_posts",
				c = "search_posts",
				d = "search_subreddits",
				u = "trending_on_popular",
				l = "best_of_community",
				b = "chaining_similar_subreddits_posts",
				p = "top_week_posts",
				O = "top_week_posts_large",
				g = "top_topic_communities_rails"
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");

			function n(e, t) {
				return "".concat(e, "-sort[").concat(t.sort, "]-crossposts_only[").concat(t.crossposts_only, "]")
			}
		},
		"./src/reddit/models/Emoji/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			}));
			const n = 24,
				r = 64e3,
				a = 128,
				i = 128,
				o = (e, t, s, n) => Object.assign({
					name: e,
					url: t,
					subredditId: s
				}, n)
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.Twitter = "twitter"
				}(n || (n = {}))
		},
		"./src/reddit/models/Gold/Award.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "p", (function() {
				return u
			})), s.d(t, "m", (function() {
				return l
			})), s.d(t, "o", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "l", (function() {
				return O
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "j", (function() {
				return j
			})), s.d(t, "k", (function() {
				return _
			})), s.d(t, "q", (function() {
				return h
			})), s.d(t, "h", (function() {
				return y
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "n", (function() {
				return v
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/config.ts"),
				r = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const a = "https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/what-karma";
			var i, o, c;
			! function(e) {
				e.Global = "GLOBAL", e.Moderator = "MODERATOR", e.Community = "COMMUNITY"
			}(i || (i = {})),
			function(e) {
				e.Global = "GLOBAL", e.Moderator = "MODERATOR", e.Community = "COMMUNITY", e.Appreciation = "APPRECIATION", e.Premium = "PREMIUM", e.Group = "GROUP"
			}(o || (o = {})),
			function(e) {
				e.png = "PNG", e.apng = "APNG", e.jpg = "JPG", e.gif = "GIF"
			}(c || (c = {}));
			const d = "award_deleted",
				u = {
					awardType: i.Global,
					awardSubType: o.Global,
					coinPrice: 100,
					coinReward: 0,
					description: "Shows the Silver Award... and that's it.",
					daysOfDripExtension: 0,
					icon: {
						url: "".concat(n.a.assetPath, "/img/gold/badges/award-silver-medium.png?v=2")
					},
					staticIcon: {
						url: "".concat(n.a.assetPath, "/img/gold/badges/award-silver-medium.png?v=2")
					},
					id: "gid_1",
					isEnabled: !0,
					isNew: !1,
					name: "Silver",
					daysOfPremium: 0,
					tiers: null
				},
				l = {
					awardType: i.Global,
					awardSubType: o.Global,
					coinPrice: 500,
					coinReward: 100,
					description: "Gives the author a week of Reddit Premium, %{coin_symbol}100 Coins to do with as they please, and shows a Gold Award.",
					daysOfDripExtension: 0,
					icon: {
						url: "".concat(n.a.assetPath, "/img/gold/badges/award-gold-medium.png?v=2")
					},
					staticIcon: {
						url: "".concat(n.a.assetPath, "/img/gold/badges/award-gold-medium.png?v=2")
					},
					id: "gid_2",
					isEnabled: !0,
					isNew: !1,
					name: "Gold",
					daysOfPremium: 7,
					tiers: null
				},
				b = {
					awardType: i.Global,
					awardSubType: o.Global,
					coinPrice: 1800,
					coinReward: 0,
					description: "Gives the author a month of Reddit Premium, which includes %{coin_symbol}700 Coins for that month, and shows a Platinum Award.",
					daysOfDripExtension: 31,
					icon: {
						url: "".concat(n.a.assetPath, "/img/gold/badges/award-platinum-medium.png?v=2")
					},
					staticIcon: {
						url: "".concat(n.a.assetPath, "/img/gold/badges/award-platinum-medium.png?v=2")
					},
					id: "gid_3",
					isEnabled: !0,
					isNew: !1,
					name: "Platinum",
					daysOfPremium: 31,
					tiers: null
				};
			var p;
			! function(e) {
				e.Silver = "silver", e.Gold = "gold", e.Platinum = "platinum"
			}(p || (p = {}));
			const O = [u, l, b];
			O.reduce((e, t) => (e[t.id] = t, e), {});
			var g, f;
			! function(e) {
				e.Global = "global", e.Community = "community", e.Moderator = "moderator"
			}(g || (g = {})),
			function(e) {
				e.Global = "global", e.Community = "community", e.Moderator = "moderator", e.Appreciation = "appreciation", e.Premium = "premium"
			}(f || (f = {}));
			const m = {
					500: 8,
					1e3: 4,
					2e3: 1,
					5e3: 1,
					1e4: 1,
					4e4: 1
				},
				j = e => {
					const t = e.reduce((e, t) => t.awardType !== i.Community ? e : (e[t.coinPrice] = (e[t.coinPrice] || 0) + 1, e), {}),
						s = e.map(e => ({
							price: e.coinPrice,
							filled: !0,
							award: e
						}));
					return Object.keys(m).forEach(e => {
						const n = t[e] || 0,
							r = Math.max(m[e] - n, 0);
						r > 0 && s.push({
							filled: !1,
							price: parseInt(e),
							quantity: r
						})
					}), s
				},
				_ = e => {
					const t = e.reduce((e, t) => t.awardType !== i.Community ? e : (e[t.coinPrice] = (e[t.coinPrice] || 0) + 1, e), {});
					return Object.keys(m).reduce((e, s) => {
						const n = t[s] || 0;
						return m[s] - n > 0 ? [...e, parseInt(s)] : e
					}, [])
				};

			function h(e) {
				return e.sort((e, t) => e.awardType === i.Moderator && t.awardType !== i.Moderator ? -1 : t.awardType === i.Moderator && e.awardType !== i.Moderator ? 1 : t.coinPrice - e.coinPrice)
			}

			function y(e) {
				const {
					count: t,
					iconUrl: s,
					resizedIcons: n,
					resizedStaticIcons: a,
					staticIconUrl: i
				} = e, o = r(e, ["count", "iconUrl", "resizedIcons", "resizedStaticIcons", "staticIconUrl"]);
				let c, d, u, l, b, p;
				for (const {
						url: r,
						width: g
					} of n || []) 32 === g && (c = {
					url: r
				}), 64 === g && (d = {
					url: r
				}), 128 === g && (u = {
					url: r
				});
				for (const {
						url: r,
						width: g
					} of a || []) 32 === g && (l = {
					url: r
				}), 64 === g && (b = {
					url: r
				}), 128 === g && (p = {
					url: r
				});
				let O = e.tiers;
				return e.tiersByRequiredAwardings && (O = v(e.tiersByRequiredAwardings)), Object.assign(Object.assign({}, o), {
					icon: {
						url: s
					},
					icon32: c,
					icon64: d,
					icon128: u,
					staticIcon: {
						url: i
					},
					staticIcon32: l,
					staticIcon64: b,
					staticIcon128: p,
					tiers: O,
					awardType: o.awardType.toUpperCase(),
					awardSubType: o.awardSubType.toUpperCase()
				})
			}

			function E(e, t) {
				const {
					awardType: s,
					awardSubType: n,
					icon: a,
					icon32: i,
					icon64: o,
					icon128: c,
					staticIcon: d,
					staticIcon32: u,
					staticIcon64: l,
					staticIcon128: b
				} = e, p = r(e, ["awardType", "awardSubType", "icon", "icon32", "icon64", "icon128", "staticIcon", "staticIcon32", "staticIcon64", "staticIcon128"]), O = [], g = [];
				return i && O.push({
					height: 32,
					url: i.url,
					width: 32
				}), o && O.push({
					height: 64,
					url: o.url,
					width: 64
				}), c && O.push({
					height: 128,
					url: c.url,
					width: 128
				}), u && g.push({
					height: 32,
					url: u.url,
					width: 32
				}), l && g.push({
					height: 64,
					url: l.url,
					width: 64
				}), b && g.push({
					height: 128,
					url: b.url,
					width: 128
				}), Object.assign({
					awardType: s.toLowerCase(),
					awardSubType: n ? n.toLowerCase() : f.Global,
					count: t,
					iconUrl: a.url,
					resizedIcons: O,
					resizedStaticIcons: g,
					staticIconUrl: d.url
				}, p)
			}

			function I(e) {
				return (e || []).reduce((e, t) => (e[t.width] = {
					url: t.url
				}, e), {})
			}

			function v(e) {
				if (e) return Object.values(e).map(e => {
					const t = {
							url: e.icon.url
						},
						s = {
							url: e.static_icon.url
						},
						n = I(e.resized_icons);
					n[e.icon.width] = t;
					const r = I(e.resized_static_icons);
					return r[e.static_icon.width] = s, {
						awardingsRequired: e.awardings_required,
						icon: t,
						icon32: n[32] || null,
						icon64: n[64] || null,
						icon128: n[128] || null,
						staticIcon: s,
						staticIcon32: r[32] || null,
						staticIcon64: r[64] || null,
						staticIcon128: r[128] || null
					}
				}).sort((e, t) => e.awardingsRequired - t.awardingsRequired)
			}
		},
		"./src/reddit/models/Gold/Coins/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js");
			const r = new Set(["low_coin_upsell"]),
				a = new Set(["new_purchaser", "repeat_purchaser"]),
				i = [{
					prompt: () => n.fbt._("What are coins?", null, {
						hk: "bD2cQ"
					}),
					answer: () => n.fbt._("Coins are our virtual good, and you can use them to award exceptional posts or comments, giving them Silver, Gold, or Platinum. We'll be adding cool new ways to spend your coins in the future.", null, {
						hk: "2RS7Fb"
					})
				}, {
					prompt: () => n.fbt._('What is "Give Award"?', null, {
						hk: "Q08fJ"
					}),
					answer: () => n.fbt._('Giving an Award, or "gilding", is a way to show appreciation for an exceptional contribution to Reddit. You can award someone by clicking on "Give Award" below their post or comment. This distinguishes it with an Award for all to see, and some even grant the honoree special bonus benefits.', null, {
						hk: "4fZWQ3"
					})
				}, {
					prompt: () => n.fbt._("What are these new Award types?", null, {
						hk: "2ysK1l"
					}),
					answer: () => n.fbt._("There are now several ways to Give Awards. A Silver Award requires 100 coins, which simply marks a post or comment with a Silver Award icon. A classic Gold Award requires 500 coins and gives the recipient a week of Reddit Premium membership and 100 coins. Finally, the ultra rare Platinum Award costs 1800 coins, and gives the recipient with one month of Reddit Premium membership, which includes 700 coins for that month.", null, {
						hk: "Mvg07"
					})
				}, {
					prompt: () => n.fbt._("I bought coins, how can I tell how many I have?", null, {
						hk: "4a4pGf"
					}),
					answer: () => n.fbt._("If you buy coins you will always have a balance associated with your Reddit account. You can view your balance on the top navigation bar by your username.", null, {
						hk: "2VWZ2s"
					})
				}, {
					prompt: () => n.fbt._("Can I transfer coins between Reddit accounts?", null, {
						hk: "1jLVez"
					}),
					answer: () => n.fbt._("You cannot transfer your Reddit coin balance across usernames, sorry. You can offer a Gold Award to other users which will grant them 100 coins.", null, {
						hk: "435l4g"
					})
				}, {
					prompt: () => n.fbt._("Can I get coins for free?", null, {
						hk: "1fhxmd"
					}),
					answer: () => n.fbt._("We may give away coins on special occasions. Stay tuned!", null, {
						hk: "3qKa11"
					})
				}, {
					prompt: () => n.fbt._("What happened to Creddits? Do those still exist?", null, {
						hk: "qTu5W"
					}),
					answer: () => n.fbt._("Yes, Creddits are simply called \"coins\" now, and we've converted any existing balance at a generous exchange rate of one Creddit to 2000 coins. That's double their original monetary value as a thank you for supporting us early. Use them to award exceptional posts and comments you come across. Thanks again for your contribution to the Reddit community.", null, {
						hk: "3bz9Wy"
					})
				}, {
					prompt: () => n.fbt._("I thought Gold was the name of Reddit's subscription membership?", null, {
						hk: "26YDse"
					}),
					answer: () => n.fbt._('You\'re correct, it used to also be the name of the subscription membership. However, many people confused the subscription "Reddit Gold" membership with a virtual good or coin. To make things easier to understand, we\'ve renamed the membership to "Reddit Premium", while our virtual good is called "coins".', null, {
						hk: "aFpGc"
					})
				}]
		},
		"./src/reddit/models/Gold/ProductOffer.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})), s.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.CoinConversion = "user-coins-in-subreddit", e.Powerups = "powerups"
				}(n || (n = {}));
			const r = (e, t) => {
				const s = e && e.dealInfo && e.dealInfo.type;
				return t ? "gild_flow" : "low_coin_upsell" === s ? "low_coin_balance" : "new_purchaser" === s ? "new_user_targeted_offer" : "repeat_purchaser" === s ? "repeat_user_targeted_offer" : void 0
			}
		},
		"./src/reddit/models/ModQueue/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			}));
			var n = s("./src/reddit/helpers/isPost.ts"),
				r = s("./src/reddit/models/Flair/index.ts");
			const a = 1;
			var i;
			! function(e) {
				e.Approve = "approve", e.Flair = "flair", e.IgnoreReports = "ignore_reports", e.Lock = "lock", e.MarkNSFW = "mark_nsfw", e.RemovalReason = "removal_reason", e.Remove = "remove", e.Spam = "spam", e.Spoiler = "spoiler", e.UnignoreReports = "unignore_reports", e.Unlock = "unlock", e.UnmarkNSFW = "unmark_nsfw", e.Unspoiler = "unspoiler"
			}(i || (i = {}));
			const o = {},
				c = {
					ignore_reports: i.UnignoreReports,
					lock: i.Unlock,
					mark_nsfw: i.UnmarkNSFW,
					remove: i.Approve,
					spam: i.Approve,
					spoiler: i.Unspoiler,
					unignore_reports: i.IgnoreReports,
					unlock: i.Lock,
					unmark_nsfw: i.MarkNSFW,
					unspoiler: i.Spoiler
				},
				d = (e, t, s, a, c) => {
					switch (t) {
						case "approve": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									approvedBy: a,
									isApproved: !0,
									isRemoved: !1,
									isSpam: !1,
									bannedBy: null,
									modNote: null,
									modReasonBy: null,
									modRemovalReason: null,
									numReports: 0
								}
							}), e
						}
						case "flair": {
							const t = {};
							return s.forEach(s => {
								if (Object(n.a)(s)) {
									const n = e[s].flair.filter(e => e.type === r.f.Nsfw || e.type === r.f.Spoiler);
									c && c.flair && n.push(c.flair), t[s] = {
										flair: n
									}
								}
							}), t
						}
						case "ignore_reports": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									ignoreReports: !0
								}
							}), e
						}
						case "lock": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									isLocked: !0
								}
							}), e
						}
						case "mark_nsfw": {
							const t = {},
								a = {
									text: "nsfw",
									type: r.f.Nsfw
								};
							return s.forEach(s => {
								if (Object(n.a)(s)) {
									const n = e[s],
										r = n.isNSFW ? n.flair : n.flair ? [...n.flair, a] : {
											[s]: a
										};
									t[s] = {
										isNSFW: !0,
										flair: r
									}
								}
							}), t
						}
						case "remove": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									approvedBy: null,
									isApproved: !1,
									isRemoved: !0,
									isSpam: !1,
									bannedBy: a
								}
							}), e
						}
						case "spam": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									approvedBy: null,
									isApproved: !1,
									isRemoved: !1,
									isSpam: !0,
									bannedBy: a
								}
							}), e
						}
						case "spoiler": {
							const t = {},
								a = {
									text: "spoiler",
									type: r.f.Spoiler
								};
							return s.forEach(s => {
								if (Object(n.a)(s)) {
									const n = e[s],
										r = n.isSpoiler ? n.flair : n.flair ? [...n.flair, a] : {
											[s]: a
										};
									t[s] = {
										isSpoiler: !0,
										flair: r
									}
								}
							}), t
						}
						case "unignore_reports": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									ignoreReports: !1
								}
							}), e
						}
						case "unlock": {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									isLocked: !1
								}
							}), e
						}
						case "unmark_nsfw": {
							const t = {};
							return s.forEach(s => {
								if (Object(n.a)(s)) {
									const n = e[s],
										a = n.flair ? n.flair.filter(e => e.type !== r.f.Nsfw) : null;
									t[s] = {
										isNSFW: !1,
										flair: a
									}
								}
							}), t
						}
						case "unspoiler": {
							const t = {};
							return s.forEach(s => {
								if (Object(n.a)(s)) {
									const n = e[s],
										a = n.flair ? n.flair.filter(e => e.type !== r.f.Spoiler) : null;
									t[s] = {
										isSpoiler: !1,
										flair: a
									}
								}
							}), t
						}
						case i.RemovalReason: {
							const e = {};
							return s.forEach(t => {
								e[t] = {
									modNote: c && c.modNote,
									modReasonBy: a,
									modRemovalReason: c && c.removalReason
								}
							}), e
						}
						default:
							return o
					}
				}
		},
		"./src/reddit/models/Option/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			const n = e => !e.id,
				r = e => !!e.id,
				a = (e, t) => n(e) && n(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!r(e) || !r(t)) && e.id === t.id
		},
		"./src/reddit/models/Poll/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "g", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "e", (function() {
				return l
			}));
			var n, r, a = s("./node_modules/bignumber.js/bignumber.js");
			! function(e) {
				e.GovGeneric = "governance:generic", e.ReplaceTopMod = "governance:replace-top-mod", e.Spinoff = "governance:spin-off", e.GA = "ga"
			}(n || (n = {})),
			function(e) {
				e.ByVoters = "byVoters", e.ByVotingPower = "byVotingPower"
			}(r || (r = {}));
			const i = {
				[n.ReplaceTopMod]: () => [{
					text: "Yes"
				}, {
					text: "No"
				}],
				[n.Spinoff]: e => [{
					text: e ? "Yes, I'd like to join r/".concat(e) : "Yes, I'd like to join the new community"
				}, {
					text: "No"
				}]
			};

			function o(e, t) {
				return !!e.options.filter(e => t.options[e.id].userSelected).length
			}

			function c(e, t) {
				return new Date(e.endsAt).getTime() < Date.now() || o(e, t)
			}

			function d(e, t) {
				let s = e.options[0],
					n = new a.BigNumber(t.options[s.id].votes);
				for (const r of e.options) {
					const e = new a.BigNumber(t.options[r.id].votes);
					e.isGreaterThan(n) && (s = r, n = e)
				}
				return s
			}

			function u(e) {
				switch (e.type) {
					case n.GovGeneric:
					case n.ReplaceTopMod:
					case n.Spinoff:
						return !0;
					default:
						return !1
				}
			}

			function l(e) {
				return !0 === e.isPrediction
			}
		},
		"./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(n.a)(e, {
				emotes_as_images: !0
			})
		},
		"./src/reddit/models/RichTextJson/addRTJParam.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(n.a)(e, {
				rtj: "only"
			})
		},
		"./src/reddit/models/Rule/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "g", (function() {
				return o
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "h", (function() {
				return l
			}));
			const n = {
					all: "all",
					post: "post",
					comment: "comment"
				},
				r = {
					all: "all",
					link: "post",
					comment: "comment"
				},
				a = {
					LINK_AND_COMMENT: "all",
					LINK: "post",
					COMMENT: "comment"
				},
				i = 15,
				o = 100,
				c = 100,
				d = 500,
				u = 2e3,
				l = e => ({
					rules: e.map(e => ({
						kind: r[e.kind],
						description: e.description,
						descriptionHtml: e.description_html,
						shortName: e.short_name,
						violationReason: e.violation_reason,
						createdUtc: e.created_utc,
						priority: e.priority
					}))
				})
		},
		"./src/reddit/models/RulesSequence/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			class n {
				constructor() {
					this.sequence = []
				}
				getSequence() {
					return this.sequence
				}
				update(e, t) {
					const s = this.sequence.slice(0, t);
					s.push(e), this.sequence = s
				}
				cut(e) {
					const t = this.sequence.slice(0, e + 1);
					this.sequence = t
				}
			}
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "q", (function() {
				return i
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "g", (function() {
				return u
			})), s.d(t, "m", (function() {
				return l
			})), s.d(t, "n", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "c", (function() {
				return g
			})), s.d(t, "p", (function() {
				return m
			})), s.d(t, "k", (function() {
				return j
			})), s.d(t, "j", (function() {
				return _
			})), s.d(t, "h", (function() {
				return h
			})), s.d(t, "i", (function() {
				return y
			})), s.d(t, "d", (function() {
				return E
			})), s.d(t, "b", (function() {
				return I
			})), s.d(t, "l", (function() {
				return v
			})), s.d(t, "o", (function() {
				return S
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/assertNever.ts"),
				r = s("./src/reddit/models/GqlTopLevelField.ts"),
				a = s("./src/reddit/models/User/index.ts");
			const i = "scheduledposts";
			var o, c, d;
			! function(e) {
				e.LINK = "LINK", e.POLL = "POLL", e.SELF = "SELF"
			}(o || (o = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(c || (c = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(d || (d = {}));
			const u = (e, t) => {
					return (t ? new Set(["links", "text"]) : new Set(["links", "text", "polls"])).has(e)
				},
				l = e => e.__typename === a.c.AvailableRedditor,
				b = e => e.__typename === r.a.Subreddit;
			var p, O, g, f;
			! function(e) {
				e.standalonePosts = "standalonePosts", e.recurringPosts = "recurringPosts"
			}(p || (p = {})),
			function(e) {
				e.MONDAY = "MONDAY", e.TUESDAY = "TUESDAY", e.WEDNESDAY = "WEDNESDAY", e.THURSDAY = "THURSDAY", e.FRIDAY = "FRIDAY", e.SATURDAY = "SATURDAY", e.SUNDAY = "SUNDAY"
			}(O || (O = {})),
			function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(g || (g = {})),
			function(e) {
				e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY"
			}(f || (f = {}));
			const m = e => O[f[e]],
				j = e => f[O[e]],
				_ = e => g[O[e]],
				h = e => O[g[e]],
				y = e => f[g[e]];
			var E;
			! function(e) {
				e.Hourly = "HOURLY", e.Daily = "DAILY", e.Weekly = "WEEKLY", e.Monthly = "MONTHLY"
			}(E || (E = {}));
			const I = "custom",
				v = e => {
					switch (e) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						case "isContestMode":
							return "mark_as_contest_mode";
						default:
							return Object(n.a)(e)
					}
				},
				S = e => "frequency" in e && !!e.frequency
		},
		"./src/reddit/models/SubredditChannel/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			}));
			var n, r, a = s("./src/chat/models/Channel/utils/removeSendbirdPrefix.ts");
			! function(e) {
				e.Public = "public", e.Private = "private"
			}(n || (n = {})),
			function(e) {
				e.Joined = "joined", e.Invited = "invited", e.Unsorted = "none"
			}(r || (r = {}));
			const i = {
					channelId: "",
					channelSendbirdUrl: "",
					subredditId: "",
					name: "",
					description: "",
					membersCount: 0,
					type: n.Public,
					channelState: r.Unsorted,
					minimumAcctAge: 0,
					newMemberAge: 0,
					isModQueue: !1
				},
				o = e => {
					const t = {};
					return e.length && e.forEach(e => {
						const s = (e => ({
							channelId: Object(a.a)(e.url),
							channelSendbirdUrl: e.url,
							channelState: e.member_state,
							subredditId: e.subreddit.id,
							isModQueue: e.is_modqueue,
							name: e.name,
							type: e.type,
							description: e.description,
							membersCount: e.member_count,
							minimumAcctAge: e.automute_account_age_threshold || 0,
							newMemberAge: e.automute_on_join_duration || 0
						}))(e);
						t[s.channelId] = s
					}), t
				},
				c = e => ({
					channelId: Object(a.a)(e.channel_url),
					channelSendbirdUrl: e.channel_url,
					channelState: r.Joined,
					subredditId: e.subreddit_id,
					isModQueue: !1,
					name: e.room,
					type: e.roomType,
					description: e.description,
					membersCount: 1,
					minimumAcctAge: e.automute_account_age_threshold,
					newMemberAge: e.automute_on_join_duration
				})
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			}));
			const n = 25,
				r = 64;
			var a;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(a || (a = {}));
			const i = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: e.id,
						displayText: e.text,
						selected: t
					}
				},
				o = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return i(e.tag, t)
				};
			var c;
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(c || (c = {}))
		},
		"./src/reddit/models/Toast/index.ts": function(e, t, s) {
			"use strict";
			var n, r, a;
			s.d(t, "b", (function() {
					return r
				})), s.d(t, "a", (function() {
					return a
				})),
				function(e) {
					e.AuthError = "auth-error"
				}(n || (n = {})),
				function(e) {
					e[e.SuccessAward = 0] = "SuccessAward", e[e.SuccessCommunity = 1] = "SuccessCommunity", e[e.SuccessCommunityGreen = 2] = "SuccessCommunityGreen", e[e.SuccessMod = 3] = "SuccessMod", e[e.Error = 4] = "Error", e[e.Undo = 5] = "Undo", e[e.EuCookiePolicy = 6] = "EuCookiePolicy", e[e.UappBanner = 7] = "UappBanner", e[e.AuthError = 8] = "AuthError", e[e.Custom = 9] = "Custom", e[e.Modal = 10] = "Modal", e[e.SuccessLockComment = 11] = "SuccessLockComment", e[e.SuccessUnlockComment = 12] = "SuccessUnlockComment", e[e.SuccessEndBroadcast = 13] = "SuccessEndBroadcast"
				}(r || (r = {})),
				function(e) {
					e[e.subscribeMilestone = 0] = "subscribeMilestone", e[e.subscribeCap = 1] = "subscribeCap", e[e.voteMilestone = 2] = "voteMilestone"
				}(a || (a = {}))
		},
		"./src/reddit/models/Vote/index.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})), s.d(t, "b", (function() {
					return r
				})), s.d(t, "d", (function() {
					return a
				})), s.d(t, "c", (function() {
					return i
				})), s.d(t, "e", (function() {
					return o
				})),
				function(e) {
					e[e.downvoted = -1] = "downvoted", e[e.notVoted = 0] = "notVoted", e[e.upvoted = 1] = "upvoted"
				}(n || (n = {}));
			const r = (e, t) => e.voteState === t ? n.notVoted : t,
				a = e => {
					switch (e) {
						case !0:
							return n.upvoted;
						case !1:
							return n.downvoted;
						default:
							return n.notVoted
					}
				},
				i = (e, t) => {
					const s = e.voteState === t,
						n = s ? 0 : t,
						r = s ? e.score - t : e.score - e.voteState + t;
					return Object.assign(Object.assign({}, e), {
						voteState: n,
						score: r
					})
				},
				o = e => "UP" === e ? n.upvoted : "DOWN" === e ? n.downvoted : n.notVoted
		},
		"./src/reddit/models/WhitelistAndBlocked.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.pending = "pending", e.error = "error", e.waitingForRequest = "waitingForRequest"
				}(n || (n = {}))
		},
		"./src/reddit/reducers/comments/visitHighlightingFilter/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n, r = s("./src/reddit/actions/comment/index.ts"),
				a = s("./src/reddit/actions/platform.ts");
			! function(e) {
				e.First = "First", e.Last = "Last", e.None = "None"
			}(n || (n = {}));
			const i = n.Last;
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.a:
						return i;
					case r.a:
						return t.payload.sort;
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n, r = s("./src/reddit/actions/economics/paymentSystems/constants.ts"),
				a = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(n || (n = {}));
			const i = {
				status: n.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						if (e.status === n.Fetched && e.data.stripe && e.data.stripe.sources) {
							const s = t.payload.cardId,
								n = e.data.stripe.sources,
								r = s,
								i = (n[r], a(n, ["symbol" == typeof r ? r : r + ""]));
							return Object.assign(Object.assign({}, e), {
								data: Object.assign(Object.assign({}, e.data), {
									stripe: Object.assign(Object.assign({}, e.data.stripe), {
										sources: i
									})
								})
							})
						}
						return e;
					case r.e:
						if (e.status === n.Fetched && e.data.braintree && e.data.braintree.sources) {
							const s = t.payload.sourceId,
								n = e.data.braintree.sources,
								r = s,
								i = (n[r], a(n, ["symbol" == typeof r ? r : r + ""]));
							return Object.assign(Object.assign({}, e), {
								data: Object.assign(Object.assign({}, e.data), {
									braintree: Object.assign(Object.assign({}, e.data.braintree), {
										sources: i
									})
								})
							})
						}
						return e;
					case r.b:
						return {
							error: t.payload.error, status: n.Failure
						};
					case r.c:
						return {
							data: t.payload, status: n.Fetched
						};
					case r.d:
						return {
							status: n.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, r = s("./src/lib/constants/specialMembership.ts"),
				a = s("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				i = s("./src/reddit/helpers/economics/sortBadges.ts"),
				o = s("./src/reddit/models/Badge/index.ts"),
				c = s("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(n || (n = {}));
			const d = {};

			function u(e) {
				return "userId" in e
			}

			function l(e, t, s, n) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(r => {
						let a;
						(a = e.placement ? e.placement === o.a.First ? n[c.a.Loyalty][r] : n[c.a.Achievement][r] : u(e) ? n[c.a.Cosmetic][c.c.MyBadges][r] : n[c.a.Cosmetic][c.c.Gallery][r]) && (u(e) ? s.has(e.id) && a.unlocked.push(e) : t.has(e.id) || a.locked.push(e))
					})
				})
			}

			function b(e) {
				const t = (e, t) => {
					const s = parseInt(e.price || "0"),
						n = parseInt(t.price || "0");
					return s === n ? Object(i.b)(e, t) : s - n
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === r.a).map(b).sort((e, s) => {
					const n = t[e.id],
						r = t[s.id];
					return Object(i.b)(n, r)
				})
			}

			function O(e) {
				const t = {
					[c.a.Loyalty]: {},
					[c.a.Achievement]: {},
					[c.a.Cosmetic]: {
						[c.c.Gallery]: {},
						[c.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(s => {
					const n = e.collections[s],
						r = {
							description: n.description,
							highlight: n.extra && n.extra.style && n.extra.style.color,
							id: n.id,
							locked: [],
							title: n.title,
							unlocked: []
						};
					t[c.a.Loyalty][s] = Object.assign(Object.assign({}, r), {
						locked: [],
						unlocked: []
					}), t[c.a.Achievement][s] = Object.assign(Object.assign({}, r), {
						locked: [],
						unlocked: []
					}), t[c.a.Cosmetic][c.c.Gallery][s] = Object.assign(Object.assign({}, r), {
						locked: [],
						unlocked: []
					}), t[c.a.Cosmetic][c.c.MyBadges][s] = Object.assign(Object.assign({}, r), {
						locked: [],
						unlocked: []
					})
				});
				const s = new Set;
				e.userOwnedBadges.forEach(t => {
					const n = e.badges[t];
					n && s.add(n.type)
				});
				const n = new Set(e.userOwnedBadges);
				return l(Object.keys(e.badges).map(t => e.badges[t]), s, n, t), l(Object.keys(e.products).map(t => e.products[t]), s, n, t), {
					collections: {
						[c.a.Loyalty]: p(t[c.a.Loyalty], e.collections),
						[c.a.Achievement]: p(t[c.a.Achievement], e.collections),
						[c.a.Cosmetic]: {
							[c.c.Gallery]: p(t[c.a.Cosmetic][c.c.Gallery], e.collections),
							[c.c.MyBadges]: p(t[c.a.Cosmetic][c.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.a: {
						const {
							subredditId: s
						} = t.payload, r = e[s];
						return r && r.status === n.Fetched ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								data: Object.assign({}, r.data),
								raw: Object.assign({}, r.raw)
							})
						}) : e
					}
					case a.i: {
						const {
							subredditId: s
						} = t.payload, r = e[s];
						return r && r.status === n.Fetched ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								data: Object.assign(Object.assign({}, r.data), {
									subscription: Object.assign(Object.assign({}, r.data.subscription || {}), {
										settings: {
											renew: !1
										}
									})
								}),
								raw: Object.assign(Object.assign({}, r.raw), {
									subscription: Object.assign(Object.assign({}, r.raw.subscription || {}), {
										settings: {
											renew: !1
										}
									})
								})
							})
						}) : e
					}
					case a.j: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: {
								raw: s,
								data: O(s),
								status: n.Fetched
							}
						})
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/categories/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/redux/es/redux.js"),
				r = s("./src/reddit/actions/category/constants.ts");
			var a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.b:
					case r.c:
						return null;
					case r.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			var i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.c:
						return !1;
					case r.b:
						return !0;
					default:
						return e
				}
			};
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.c:
							return !0;
						case r.b:
						case r.a:
							return !1;
						default:
							return e
					}
				},
				c = Object(n.c)({
					error: a,
					loaded: i,
					pending: o
				});
			const d = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.g:
					case r.f: {
						const {
							categoryId: s
						} = t.payload, n = Object.assign({}, e);
						return delete n[s], n
					}
					case r.e: {
						const {
							categoryId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const l = {};
			var b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.g: {
						const {
							categoryId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !1
						})
					}
					case r.f: {
						const {
							categoryId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			const p = {};
			var O = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g: {
							const {
								categoryId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case r.f:
						case r.e: {
							const {
								categoryId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				g = Object(n.c)({
					error: u,
					loaded: b,
					pending: O
				}),
				f = Object(n.c)({
					list: c,
					subreddits: g
				}),
				m = s("./node_modules/lodash/isEmpty.js"),
				j = s.n(m);
			const _ = [];
			var h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.b: {
						const {
							categoryIds: s
						} = t.payload;
						return j()(s) ? e : s
					}
					default:
						return e
				}
			};
			const y = {};
			var E = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.b: {
							const {
								categories: s
							} = t.payload;
							return j()(s) ? e : Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				I = s("./node_modules/lodash/forOwn.js"),
				v = s.n(I),
				S = s("./src/reddit/helpers/name/index.ts");
			const T = {};
			var w = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.b: {
							const {
								categories: s
							} = t.payload;
							if (j()(s)) return e;
							const n = {};
							return v()(s, e => {
								n[Object(S.f)(e.name)] = e.id
							}), Object.assign(Object.assign({}, e), n)
						}
						default:
							return e
					}
				},
				C = s("./src/reddit/actions/global/constants.ts"),
				A = s("./src/reddit/constants/localStorage.ts");
			const D = {};
			var P = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : D,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case C.a:
						return t.payload[A.e] || e;
					case r.d: {
						const {
							categoryId: s,
							rank: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			t.a = Object(n.c)({
				api: f,
				ids: h,
				models: E,
				nameToId: w,
				ranking: P
			})
		},
		"./src/reddit/reducers/features/econPurchase/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/redux/es/redux.js"),
				r = s("./src/reddit/actions/gold/constants.ts");
			const a = {};
			var i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.ib: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: s.amount
						})
					}
					default:
						return e
				}
			};
			t.a = Object(n.c)({
				subredditLockedCoins: i
			})
		},
		"./src/reddit/reducers/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return dP
			}));
			var n = s("./src/reddit/actions/modal.ts");
			const r = {};
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case n.e:
							if (!t.payload.actionSource && !t.payload.redirectUrl) return r;
							return Object.assign(Object.assign({}, e), t.payload);
						default:
							return e
					}
				},
				i = s("./src/reddit/actions/authorFlair.ts"),
				o = s("./src/reddit/actions/badge.ts"),
				c = s("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				d = s("./src/reddit/actions/governance/constants.ts"),
				u = s("./src/reddit/actions/harbergerTax/constants.ts"),
				l = s("./src/reddit/actions/platform.ts"),
				b = s("./src/reddit/actions/postCreation/constants.ts"),
				p = s("./src/reddit/actions/product.ts"),
				O = s("./src/reddit/actions/reportFlow.ts"),
				g = s("./src/reddit/actions/structuredStyles/constants.ts"),
				f = s("./src/reddit/constants/modals.ts");
			var m = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case n.c: {
							const s = t.payload;
							return e === s ? null : s
						}
						case n.b:
						case b.z:
						case n.d:
						case l.a:
						case O.f:
							return null;
						case g.e:
							return e === f.a.BLADE_UNSAVED_CHANGES ? null : e;
						case g.d:
							return e === f.a.BLADE_NIGHTMODE ? null : e;
						case i.a:
							return e === f.a.USER_FLAIR_MODAL_ID ? null : f.a.USER_FLAIR_MODAL_ID;
						case o.c:
							return f.a.BADGE_PICKER;
						case p.b:
							return f.a.BADGE_PURCHASE;
						case d.d:
							return f.a.GOVERNANCE_OPT_OUT;
						case d.r:
							return f.a.TRANSFER_POINTS;
						case d.o:
							return f.a.GOVERNANCE_RELEASE_NOTES;
						case u.e:
							return f.a.HARBERGER_TAX_BANNER_PURCHASE;
						case u.c:
							return f.a.HARBERGER_TAX_BANNER_MANAGE;
						case u.b:
							return f.a.HARBERGER_TAX_CRYPTO_BANNER_PURCHASE;
						case u.a:
							return f.a.HARBERGER_TAX_CRYPTO_BANNER_MANAGE;
						case d.x:
							return f.a.WALLET_REGISTRATION_MODAL;
						case c.g:
							return f.a.SUBREDDIT_PREMIUM_PURCHASE_MODAL;
						case c.c:
							return f.a.SUBREDDIT_PREMIUM_BADGE_MANAGEMENT;
						case c.k:
							return f.a.SUBREDDIT_PREMIUM_UPLOAD_MODAL;
						default:
							return e
					}
				},
				j = s("./src/reddit/actions/ads/constants.ts"),
				_ = s("./src/reddit/actions/unload/constants.ts");
			const h = {};

			function y(e, t, s, n) {
				const r = e[t];
				return Object.assign(Object.assign({}, e), {
					[t]: Object.assign(Object.assign({}, r), {
						[n]: s
					})
				})
			}
			var E = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h,
						t = arguments.length > 1 ? arguments[1] : void 0;
					if (!t.payload) return e;
					switch (t.type) {
						case j.c:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adImpression");
						case j.b:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adClick");
						case j.m:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adViewableImpression");
						case j.j:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoViewable");
						case j.d:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoFullyViewable");
						case j.i:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoStarted");
						case j.h:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoPlayedWithSound");
						case j.f:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoGroupMViewable");
						case j.e:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoFullyViewable50");
						case j.g:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adVideoPlayedExpanded");
						case j.k: {
							const {
								postId: s,
								eventType: n,
								vendorMetadata: r
							} = t.payload;
							return y(e, s, r, "adVideoWatchedPercent".concat(n))
						}
						case j.l: {
							const {
								postId: s,
								eventType: n,
								vendorMetadata: r
							} = t.payload;
							return y(e, s, r, "adVideoWatchedSeconds".concat(n))
						}
						case j.v:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "vendorFullyViewable");
						case j.x:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "vendorFullyViewableSeconds5");
						case j.w:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "vendorFullyViewableSeconds15");
						case _.b:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "adUnloaded");
						case j.r:
							return y(e, t.payload.postId, t.payload.vendorMetadata, "groupMViewable");
						default:
							return e
					}
				},
				I = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/reddit/actions/apiRequestState.ts"));
			const v = {};
			var S = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case I.d:
						case I.a:
						case I.b: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.apiRequestId]: s
							})
						}
						case I.c: {
							const s = t.payload;
							if (!(s in e)) return e;
							if (1 === Object.keys(e).length) return v;
							const n = Object.assign({}, e);
							return delete n[s], n
						}
						default:
							return e
					}
				},
				T = s("./node_modules/redux/es/redux.js"),
				w = s("./src/reddit/actions/subredditModeration.ts");
			var C = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.e:
						case w.d:
							return null;
						case w.c:
							return t.payload;
						default:
							return e
					}
				},
				A = s("./src/reddit/models/SubredditModeration/index.ts");
			const D = {};
			var P = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : D,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.e: {
							const {
								subredditId: s,
								fetchedToken: n
							} = t.payload, r = Object(A.d)(s, n);
							return Object.assign(Object.assign({}, e), {
								[r]: !0
							})
						}
						case w.d:
						case w.c: {
							const {
								subredditId: s,
								fetchedToken: n
							} = t.payload, r = Object(A.d)(s, n);
							return Object.assign(Object.assign({}, e), {
								[r]: !1
							})
						}
						default:
							return e
					}
				},
				R = Object(T.c)({
					error: C,
					pending: P
				});
			const k = {};
			var x = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.d: {
						const {
							fetchedToken: s,
							subredditId: n
						} = t.payload, r = Object(A.d)(n, s);
						return Object.assign(Object.assign({}, e), {
							[r]: !0
						})
					}
					default:
						return e
				}
			};
			const N = {};
			var L = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.d: {
							const {
								subredditId: e,
								after: s
							} = t.payload;
							return {
								[e]: s
							}
						}
						default:
							return e
					}
				},
				U = s("./node_modules/icepick/icepick.js");
			const M = {};
			var F = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.b:
					case w.d: {
						const {
							subredditId: s,
							approvedSubmitters: n
						} = t.payload, r = {
							[s]: n
						};
						return Object(U.merge)(e, r)
					}
					case w.i: {
						const {
							subredditId: s,
							userId: n
						} = t.payload;
						return Object(U.unsetIn)(e, [s, n])
					}
					default:
						return e
				}
			};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.h:
					case w.g:
						return null;
					case w.f:
						return t.payload;
					default:
						return e
				}
			};
			var B = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.h:
							return !0;
						case w.g:
						case w.f:
							return !1;
						default:
							return e
					}
				},
				q = Object(T.c)({
					error: G,
					pending: B
				});
			var V = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.h:
							return null;
						case w.g: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				H = Object(T.c)({
					api: q,
					result: V
				});
			const K = {};
			var W = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : K,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.d: {
							const {
								subredditId: s,
								approvedSubmitterIds: n
							} = t.payload;
							return e[s] ? Object.assign(Object.assign({}, e), {
								[s]: [...e[s], ...n]
							}) : Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case w.i: {
							const {
								subredditId: s,
								userId: n
							} = t.payload;
							return {
								[s]: e[s].filter(e => e !== n)
							}
						}
						case w.b: {
							const {
								subredditId: s,
								approvedSubmitterIds: n
							} = t.payload, r = n[0];
							return r && e[s] && -1 === e[s].indexOf(r) ? {
								[s]: [r, ...e[s]]
							} : e
						}
						default:
							return e
					}
				},
				Y = Object(T.c)({
					api: R,
					fetchedTokens: x,
					loadMore: L,
					models: F,
					search: H,
					userOrder: W
				});
			var z = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case i.a:
							return t.payload;
						default:
							return e
					}
				},
				J = s("./node_modules/lodash/mergeWith.js"),
				Q = s.n(J),
				X = s("./src/reddit/actions/comment/index.ts"),
				Z = s("./src/reddit/actions/comment/websocket/constants.ts"),
				$ = s("./src/reddit/actions/grantUserFlair/constants.ts"),
				ee = s("./src/reddit/actions/modQueue/constants.ts"),
				te = s("./src/reddit/actions/page.ts"),
				se = s("./src/reddit/actions/pages/profileComments.ts"),
				ne = s("./src/reddit/actions/pages/profilePosts.ts"),
				re = s("./src/reddit/actions/pages/profilePrivate/constants.ts"),
				ae = s("./src/reddit/actions/pages/search.ts"),
				ie = s("./src/reddit/actions/pages/subreddit.ts"),
				oe = s("./src/reddit/actions/profileConversations.ts"),
				ce = s("./src/reddit/actions/subreddit.ts"),
				de = s("./src/reddit/actions/userFlair.ts"),
				ue = s("./src/reddit/models/User/index.ts");
			const le = {};
			var be = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : le,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Z.b:
					case Z.c: {
						const s = t.payload,
							{
								authorFlair: n,
								isChatSort: r
							} = s;
						if (n && r) {
							return Q()(Object.assign({}, e), n, (e, t, s) => {
								if ("richtext" === s) return t
							})
						}
						return e
					}
					case re.c:
					case re.i:
					case re.e:
					case re.g:
					case ae.c: {
						const {
							authorFlair: s
						} = t.payload;
						if (s) {
							return Object(U.merge)(e, s)
						}
						return e
					}
					case X.u:
					case ie.c:
					case te.b:
					case se.b:
					case se.e:
					case ne.e:
					case ne.b:
					case oe.e:
					case ce.i:
						return pe(e, t.payload);
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v:
						return pe(e, t.payload.response);
					case de.i: {
						const {
							subredditId: s,
							userName: n,
							applied: r,
							displaySettings: {
								isUserEnabled: a
							}
						} = t.payload;
						return Object(U.setIn)(e, [s, n], a ? r : null)
					}
					case $.h:
					case $.b: {
						const {
							subredditId: s,
							userName: n,
							applied: r
						} = t.payload;
						return e[s] && e[s][n] ? Object(U.setIn)(e, [s, n], r) : e
					}
					case de.a: {
						const {
							subredditId: s,
							userName: n,
							applied: r,
							displaySettings: {
								isEnabled: a
							}
						} = t.payload;
						return Object(U.setIn)(e, [s, n], a ? r : null)
					}
					default:
						return e
				}
			};
			const pe = (e, t) => {
				let {
					account: s,
					authorFlair: n,
					userFlair: r
				} = t;
				const a = Object(U.merge)(e, n);
				if (!r || !s) return a;
				const i = Object.keys(r)[0];
				if (!i) return a;
				const o = r[i],
					c = Object(ue.e)(s),
					d = o.applied,
					u = o.displaySettings && o.displaySettings.isUserEnabled;
				return c && d && u ? Object(U.merge)(a, {
					[i]: {
						[c]: d
					}
				}) : a
			};
			var Oe = Object(T.c)({
					inContext: z,
					models: be
				}),
				ge = s("./src/reddit/actions/gold/constants.ts");
			const fe = {};
			var me = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.e: {
						const {
							disabled: s,
							subredditOrProfileId: n
						} = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[n]: s
						}) : e
					}
					default:
						return e
				}
			};
			var je = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.i:
					case ge.j:
						return null;
					case ge.h:
						return t.payload;
					default:
						return e
				}
			};
			var _e = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a:
						case ge.j:
						case ge.h:
							return !1;
						case ge.i:
							return !0;
						default:
							return e
					}
				},
				he = Object(T.c)({
					error: je,
					pending: _e
				}),
				ye = Object(T.c)({
					api: he
				});
			var Ee = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.K:
					case ge.J:
						return null;
					case ge.I:
						return t.payload;
					default:
						return e
				}
			};
			const Ie = {};
			var ve = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ie,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.K: {
							const {
								subredditOrProfileId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case ge.e:
						case ge.J:
						case ge.O:
						case ge.I: {
							const {
								subredditOrProfileId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Se = Object(T.c)({
					error: Ee,
					pending: ve
				});
			const Te = {};
			var we = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Te,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.O: {
						const {
							awards: s,
							subredditOrProfileId: n
						} = t.payload, r = {};
						return s.forEach(e => {
							r[e.id] = e.isEnabled
						}), Object.assign(Object.assign({}, e), {
							[n]: r
						})
					}
					case ge.m: {
						const {
							awardId: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								[s]: !1
							})
						})
					}
					case ge.p: {
						const {
							awardId: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								[s]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const Ce = {};
			var Ae = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ce,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.J: {
							const {
								awards: s,
								subredditOrProfileId: n
							} = t.payload, r = s.map(e => e.id);
							return Object.assign(Object.assign({}, e), {
								[n]: r
							})
						}
						case ge.j: {
							const {
								award: s,
								subredditId: n
							} = t.payload;
							if (s && s.id) {
								if (!e[n]) return Object.assign(Object.assign({}, e), {
									[n]: [s.id]
								});
								if (-1 === e[n].indexOf(s.id)) return Object.assign(Object.assign({}, e), {
									[n]: [s.id, ...e[n]]
								})
							}
							return e
						}
						default:
							return e
					}
				},
				De = Object(T.c)({
					api: Se,
					availability: we,
					order: Ae
				}),
				Pe = s("./node_modules/lodash/merge.js"),
				Re = s.n(Pe);
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			const ke = e => {
				const t = e.split("+");
				if (1 === t.length) return e;
				const s = "".concat(t[1].substring(0, 2), ":").concat(t[1].substring(2));
				return "".concat(t[0], "+").concat(s)
			};
			var xe = e => (e.startsAt && (e.startsAt = "number" == typeof e.startsAt ? new Date(e.startsAt).toISOString() : ke(e.startsAt)), e.endsAt && (e.endsAt = "number" == typeof e.endsAt ? new Date(e.endsAt).toISOString() : ke(e.endsAt)), e),
				Ne = s("./src/reddit/models/Gold/Award.ts"),
				Le = s("./src/reddit/actions/discoveryUnit.ts"),
				Ue = s("./src/reddit/actions/frontpage.ts"),
				Me = s("./src/reddit/actions/multireddit/constants.ts"),
				Fe = s("./src/reddit/actions/pages/collectionCommentsPage.ts"),
				Ge = s("./src/reddit/actions/pages/modListing/constants.ts"),
				Be = s("./src/reddit/actions/pages/postCreation.ts"),
				qe = s("./src/reddit/actions/pages/profileOverview.ts"),
				Ve = s("./src/reddit/actions/profileOverviewChrono.ts"),
				He = (s("./node_modules/core-js/modules/es6.symbol.js"), s("./src/lib/makeActionCreator/index.ts")),
				Ke = (s("./src/config.ts"), s("./src/lib/constants/index.ts"));
			s("./src/lib/makeApiRequest/index.ts"), s("./src/reddit/helpers/addRedesignIdentifier/index.ts"), s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			Object(He.a)("RECOMMENDED_POSTS_LOADED"), Object(He.a)("RECOMMENDED_POSTS_FAILED");
			var We = s("./src/reddit/actions/search.ts");
			const Ye = {},
				ze = (e => t => {
					for (let s = 0; s < e.length; s++) t = e[s](t);
					return t
				})([xe]);
			var Je = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ye,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.J:
					case ge.ub: {
						const {
							awards: s
						} = t.payload, n = s.reduce((e, t) => (e[t.id] = ze(t), e), {});
						return Re()(Object.assign({}, e), n)
					}
					case ge.O: {
						const s = t.payload.awards.reduce((e, t) => (e[t.id] = Object.assign(Object.assign({}, ze(t)), {
							isEnabled: !0
						}), e), {});
						return Re()(Object.assign({}, e), s)
					}
					case ge.c: {
						const {
							awards: s
						} = t.payload, n = s.reduce((e, t) => (e[t.award.id] = ze(t.award), e), {});
						return Re()(Object.assign({}, e), n)
					}
					case ge.j: {
						const {
							award: s
						} = t.payload;
						return s && s.id ? e[s.id] ? Re()(Object.assign({}, e), {
							[s.id]: ze(s)
						}) : Object.assign(Object.assign({}, e), {
							[s.id]: ze(s)
						}) : e
					}
					case ge.fb: {
						const {
							awardId: s
						} = t.payload;
						return e[s] ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								isEnabled: !1
							})
						}) : e
					}
					case Fe.b:
					case X.u:
					case Z.b:
					case Be.b:
					case Le.e:
					case Ue.b:
					case Ge.e:
					case Ge.h:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v:
					case Me.r:
					case te.b:
					case te.g:
					case te.k:
					case ae.c:
					case se.b:
					case se.e:
					case oe.b:
					case oe.e:
					case qe.b:
					case qe.e:
					case Ve.b:
					case ne.b:
					case ne.e:
					case re.c:
					case re.e:
					case re.i:
					case re.g:
					case "RECOMMENDED_POSTS_LOADED":
					case We.c:
					case ce.i:
					case ie.c: {
						const s = {},
							n = t.payload.posts || [],
							r = t.payload.comments || [];
						for (const e in n) {
							const t = n[e].allAwardings || [];
							for (const e of t) s[e.id] = ze(Object(Ne.h)(e))
						}
						for (const e in r) {
							const t = r[e],
								{
									associatedAward: n,
									allAwardings: a = []
								} = t;
							for (const e of a) s[e.id] = ze(Object(Ne.h)(e));
							n && (s[n.id] = ze(n))
						}
						return Re()(Object.assign({}, e), s)
					}
					case ge.ob: {
						const s = {},
							{
								topAwardedPosts: n
							} = t.payload;
						return n.map(e => {
							const {
								post: t
							} = e, n = t.awardings || [];
							for (const r of n) {
								const e = r.award;
								s[e.id] = e
							}
						}), Re()(Object.assign({}, e), s)
					}
					default:
						return e
				}
			};
			const Qe = {};
			var Xe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.d: {
							const {
								subredditOrProfileId: s,
								thingId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									[n]: !0
								})
							})
						}
						case ge.c:
						case ge.b: {
							const {
								subredditOrProfileId: s,
								thingId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									[n]: !1
								})
							})
						}
						default:
							return e
					}
				},
				Ze = Object(T.c)({
					pending: Xe
				});
			const $e = {};
			var et = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $e,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.c: {
							const {
								awards: s,
								subredditOrProfileId: n,
								thingId: r
							} = t.payload, a = s.map(e => {
								let {
									award: t,
									total: s
								} = e;
								return {
									award: {
										id: t.id
									},
									total: s
								}
							});
							return Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign({}, e[n]), {
									[r]: a
								})
							})
						}
						default:
							return e
					}
				},
				tt = Object(T.c)({
					api: Ze,
					order: et
				});
			const st = {};
			var nt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : st,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.c: {
							const {
								tags: s,
								subredditOrProfileId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				rt = Object(T.c)({
					order: nt
				});
			const at = {};
			var it = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : at,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.ub: {
							const {
								awards: s,
								subredditOrProfileId: n
							} = t.payload, r = s.map(e => e.id);
							return Object.assign(Object.assign({}, e), {
								[n]: r
							})
						}
						default:
							return e
					}
				},
				ot = Object(T.c)({
					order: it
				}),
				ct = Object(T.c)({
					blacklist: me,
					create: ye,
					manageable: De,
					models: Je,
					sortedUsable: tt,
					tags: rt,
					usable: ot
				});
			const dt = {};
			var ut = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.e:
					case o.f: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: void 0
						})
					}
					case o.d: {
						const {
							subredditId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const lt = {};
			var bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case o.e: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case o.f:
						case o.d: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				pt = Object(T.c)({
					error: ut,
					pending: bt
				});
			const Ot = {};
			var gt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ot,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.h:
					case o.i: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: void 0
						})
					}
					case o.g: {
						const {
							subredditId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const ft = {};
			var mt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ft,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case o.h: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case o.i:
						case o.g: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				jt = Object(T.c)({
					error: gt,
					pending: mt
				}),
				_t = Object(T.c)({
					subreddit: pt,
					user: jt
				});
			const ht = {};
			var yt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ht,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.j:
						case o.f:
						case o.i:
						case p.d: {
							const {
								badges: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				Et = Object(T.c)({
					api: _t,
					models: yt
				});
			var It = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.m:
					case w.l:
						return null;
					case w.k:
						return t.payload;
					default:
						return e
				}
			};
			const vt = {};
			var St = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.m: {
							const {
								subredditId: s,
								fetchedToken: n
							} = t.payload, r = Object(A.d)(s, n);
							return Object.assign(Object.assign({}, e), {
								[r]: !0
							})
						}
						case w.l:
						case w.k: {
							const {
								subredditId: s,
								fetchedToken: n
							} = t.payload, r = Object(A.d)(s, n);
							return Object.assign(Object.assign({}, e), {
								[r]: !1
							})
						}
						default:
							return e
					}
				},
				Tt = Object(T.c)({
					error: It,
					pending: St
				});
			const wt = {};
			var Ct = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.l: {
							const {
								fetchedToken: s,
								subredditId: n
							} = t.payload, r = Object(A.d)(n, s);
							return Object.assign(Object.assign({}, e), {
								[r]: !0
							})
						}
						default:
							return e
					}
				},
				At = s("./src/reddit/actions/inContextModeration.ts");
			var Dt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case At.a:
						return t.payload;
					default:
						return e
				}
			};
			const Pt = {};
			var Rt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.l: {
						const {
							subredditId: e,
							after: s
						} = t.payload;
						return {
							[e]: s
						}
					}
					default:
						return e
				}
			};
			const kt = {};
			var xt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.j:
					case w.l: {
						const {
							subredditId: s,
							bannedUsers: n
						} = t.payload;
						return Object(U.merge)(e, {
							[s]: n
						})
					}
					case w.q: {
						const {
							subredditId: s,
							userId: n
						} = t.payload;
						return Object(U.unsetIn)(e, [s, n])
					}
					default:
						return e
				}
			};
			var Nt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.p:
					case w.o:
						return null;
					case w.n:
						return t.payload;
					default:
						return e
				}
			};
			var Lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.p:
							return !0;
						case w.o:
						case w.n:
							return !1;
						default:
							return e
					}
				},
				Ut = Object(T.c)({
					error: Nt,
					pending: Lt
				});
			var Mt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.p:
						case w.n:
							return null;
						case w.o: {
							const e = t.payload.bannedUserIds[0];
							return e ? t.payload.bannedUsers[e] : null
						}
						default:
							return e
					}
				},
				Ft = Object(T.c)({
					api: Ut,
					result: Mt
				});
			const Gt = {};
			var Bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.l: {
							const {
								subredditId: s,
								bannedUserIds: n
							} = t.payload;
							return e[s] ? Object.assign(Object.assign({}, e), {
								[s]: [...e[s], ...n]
							}) : Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case w.q: {
							const {
								subredditId: s,
								userId: n
							} = t.payload;
							return {
								[s]: e[s].filter(e => e !== n)
							}
						}
						case w.j: {
							const {
								subredditId: s,
								bannedUserIds: n
							} = t.payload, r = n[0];
							return r && e[s] && -1 === e[s].indexOf(r) ? {
								[s]: [r, ...e[s]]
							} : e
						}
						default:
							return e
					}
				},
				qt = Object(T.c)({
					api: Tt,
					fetchedTokens: Ct,
					inContext: Dt,
					loadMore: Rt,
					models: xt,
					search: Ft,
					userOrder: Bt
				}),
				Vt = s("./src/reddit/actions/blockedRedditors.ts");
			const Ht = {
				message: ""
			};
			var Kt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ht,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Vt.c:
					case Vt.d:
						return e;
					case Vt.b:
						return t.payload;
					default:
						return e
				}
			};
			var Wt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Vt.d:
							return !0;
						case Vt.c:
						case Vt.b:
							return !1;
						default:
							return e
					}
				},
				Yt = Object(T.c)({
					error: Kt,
					pending: Wt
				});
			const zt = {
				ids: []
			};
			var Jt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Vt.a:
							return {
								ids: [...e.ids, t.payload], timestamp: e.timestamp
							};
						case Vt.e:
							const s = e.ids.slice();
							return s.splice(e.ids.indexOf(t.payload), 1), Object.assign(Object.assign({}, e), {
								ids: s
							});
						case Vt.c:
							return {
								ids: [...e.ids, ...t.payload], timestamp: Date.now()
							};
						default:
							return e
					}
				},
				Qt = Object(T.c)({
					api: Yt,
					list: Jt
				}),
				Xt = s("./src/reddit/actions/userBlocks.ts");
			const Zt = {};
			var $t = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xt.f:
					case Xt.e: {
						const {
							userId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Xt.d: {
						const {
							userId: s,
							type: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const es = {};
			var ts = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : es,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xt.f: {
							const {
								userId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Xt.e:
						case Xt.d: {
							const {
								userId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				ss = Object(T.c)({
					error: $t,
					pending: ts
				}),
				ns = Object(T.c)({
					api: ss
				});
			const rs = {
				isViewSafe: !0,
				hasBrandSafetyBeenAssessed: !1
			};
			var as = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rs,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case j.a:
							return e.isViewSafe === t.payload.isViewSafe && e.hasBrandSafetyBeenAssessed ? e : Object.assign(Object.assign({}, e), {
								isViewSafe: t.payload.isViewSafe,
								hasBrandSafetyBeenAssessed: !0
							});
						case ie.d:
						case te.l:
						case te.h:
							return e.hasBrandSafetyBeenAssessed ? Object.assign(Object.assign({}, e), {
								hasBrandSafetyBeenAssessed: !1
							}) : e;
						default:
							return e
					}
				},
				is = s("./src/reddit/actions/downToChat.ts");
			var os = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case is.f:
					case is.g:
						return null;
					case is.e: {
						const {
							error: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var cs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case is.b:
						case is.f:
							return !0;
						case is.a:
						case is.c:
						case is.e:
						case is.g:
							return !1;
						default:
							return e
					}
				},
				ds = Object(T.c)({
					error: os,
					pending: cs
				}),
				us = s("./node_modules/lodash/mapValues.js"),
				ls = s.n(us);
			const bs = {};
			var ps = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bs,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case is.f:
						case is.e:
						case is.g: {
							const {
								subredditId: s,
								bannerEnabled: n,
								buttonEnabled: r
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: {
									bannerEnabled: n,
									buttonEnabled: r
								}
							})
						}
						case is.c: {
							const {
								subredditId: s,
								bannerEnabled: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									bannerEnabled: n
								})
							})
						}
						case is.d:
							return Object.assign({}, ls()(e, e => ({
								bannerEnabled: !1,
								buttonEnabled: e.buttonEnabled
							})));
						case is.a:
						case is.b:
						default:
							return e
					}
				},
				Os = Object(T.c)({
					api: ds,
					subreddits: ps
				}),
				gs = s("./src/reddit/actions/chat/init.ts");
			var fs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gs.a:
						return !0;
					default:
						return e
				}
			};
			s("./src/reddit/endpoints/chat/index.ts");
			Object(He.a)("SENDBIRD_PROXY__SET_CONFIG");
			var ms = s("./src/reddit/actions/chat/subredditChannel.ts");
			var js = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ms.b:
						case ms.a:
							return !!t.payload.isUserSubredditChatEnabled;
						case "SENDBIRD_PROXY__SET_CONFIG":
							const {
								user_subreddit_chat_enabled: s
							} = t.payload;
							return s;
						default:
							return e
					}
				},
				_s = s("./src/chat/actions/promo/constants.ts");
			const hs = {
				displaySubredditChatFtux: !1
			};
			var ys = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hs,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _s.a: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case _s.b: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Es = s("./src/reddit/actions/chat/subredditSettings.ts");
			const Is = {
				subredditId: null,
				bannedWords: "",
				domains: "",
				rateLimit: -1,
				regexes: []
			};
			var vs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Is,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Es.a:
							return Object.assign({}, t.payload);
						default:
							return e
					}
				},
				Ss = s("./src/lib/omitKey/index.ts"),
				Ts = s("./src/reddit/actions/pages/chatSettings.ts");
			const ws = {};
			var Cs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ws,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ts.b: {
						const {
							subredditId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case Ts.a:
					case Ts.c:
					case Ts.d: {
						const {
							subredditId: s
						} = t.payload;
						return Object(Ss.a)(e, s)
					}
					default:
						return e
				}
			};
			const As = {};
			var Ds = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : As,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ts.a:
						case Ts.b:
						case Ts.c:
						case Ts.d: {
							const {
								subredditId: s
							} = t.payload, n = t.type === Ts.c;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				Ps = Object(T.c)({
					error: Cs,
					pending: Ds
				}),
				Rs = Object(T.c)({
					fetch: Ps
				});
			const ks = {};
			var xs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ks,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ts.a:
						case Ts.d: {
							const {
								subredditId: s,
								chatSettings: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				Ns = Object(T.c)({
					api: Rs,
					models: xs
				}),
				Ls = s("./src/reddit/actions/chat/unreadCount.ts");
			const Us = {
				apiError: null
			};
			var Ms = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Us,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ls.a.REQUEST_FAILED: {
						const e = t.payload;
						return Object.assign(Object.assign({}, Us), {
							apiError: e
						})
					}
					case Ls.a.REQUEST_SUCCESS:
					case Ls.a.REQUEST_PENDING:
						return Us;
					default:
						return e
				}
			};
			var Fs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ls.a.REQUEST_PENDING:
							return !0;
						case Ls.a.REQUEST_FAILED:
						case Ls.a.REQUEST_SUCCESS:
							return !1;
						default:
							return e
					}
				},
				Gs = Object(T.c)({
					error: Ms,
					pending: Fs
				});
			const Bs = {
				basicChannelCount: 0,
				subredditChannelCount: 0
			};
			var qs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bs,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ls.a.SYNC:
						case Ls.a.REQUEST_SUCCESS: {
							const e = t.payload;
							return Object.assign({}, e)
						}
						default:
							return e
					}
				},
				Vs = Object(T.c)({
					api: Gs,
					count: qs
				}),
				Hs = Object(T.c)({
					downToChat: Os,
					isInited: fs,
					isUserSubredditChatEnabled: js,
					promos: ys,
					subredditSettings: vs,
					subredditSettingsPage: Ns,
					unread: Vs
				}),
				Ks = s("./src/reddit/actions/claimgold.ts");
			var Ws = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ks.a:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg;
					case Ks.d:
					case Ks.e:
					case Ks.c:
						return null;
					default:
						return e
				}
			};
			var Ys = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ks.d:
					case Ks.c:
					case Ks.a:
						return !1;
					case Ks.b:
						return !0;
					default:
						return e
				}
			};
			var zs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ks.b:
						case Ks.d:
						case Ks.c:
						case Ks.a:
							return !1;
						case Ks.f:
							return !0;
						default:
							return e
					}
				},
				Js = Object(T.c)({
					error: Ws,
					pending: Ys,
					showLoader: zs
				});
			var Qs = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ks.g:
						return t.payload;
					case Ks.e:
						return "";
					default:
						return e
				}
			};
			var Xs = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ks.e:
							return !0;
						case Ks.c:
						case Ks.d:
							return !1;
						default:
							return e
					}
				},
				Zs = Object(T.c)({
					api: Js,
					code: Qs,
					showModal: Xs
				}),
				$s = s("./node_modules/lodash/get.js"),
				en = s.n($s);
			const tn = {};
			var sn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case X.d: {
							const {
								commentsPageKey: s,
								commentId: n,
								isCollapsed: r
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									[n]: !en()(e, [s, n], r)
								})
							})
						}
						case X.e: {
							const {
								commentsPageKey: s,
								commentId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									[n]: !1
								})
							})
						}
						case X.u:
						case Fe.b:
						case te.b: {
							const {
								key: s,
								shouldCollapse: n
							} = t.payload;
							if (!n) return e;
							const r = n.reduce((e, t) => Object.assign(Object.assign({}, e), {
								[t]: !0
							}), {});
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), r)
							})
						}
						default:
							return e
					}
				},
				nn = s("./src/lib/makeDraftKey/index.ts"),
				rn = s("./src/reddit/models/PostCreationForm/index.ts"),
				an = s("./src/reddit/models/PostDraft/index.ts");
			const on = {};
			var cn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : on,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.q: {
						const {
							draftKey: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								autofocusDisabled: !0
							})
						})
					}
					case X.j: {
						const {
							draftKey: s,
							hasFocus: n
						} = t.payload;
						return e[s] ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								hasFocus: n
							})
						}) : e
					}
					case te.e: {
						const {
							draftKey: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: {
								rteState: null,
								draftType: an.c.replyToPost
							}
						})
					}
					case Fe.b:
					case Fe.c:
					case te.d: {
						const {
							postId: s,
							commentMode: n
						} = t.payload, r = Object(nn.a)(an.c.replyToPost, s);
						return Object.assign(Object.assign({}, e), {
							[r]: {
								commentMode: n,
								draftType: an.c.replyToPost,
								hasFocus: !1,
								rteState: null,
								text: ""
							}
						})
					}
					case te.b: {
						const {
							postId: s,
							preferences: n
						} = t.payload;
						if (!n || void 0 === n.useMarkdown) return e;
						const r = Object(nn.a)(an.c.replyToPost, s),
							a = n.useMarkdown ? rn.h.MARKDOWN : rn.h.RICH_TEXT;
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, e[r]), {
								commentMode: a
							})
						})
					}
					case X.l:
						const {
							draftKey: s, content: n, editorMode: r
						} = t.payload;
						return e[s] ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								commentMode: r,
								rteState: null,
								text: r === rn.h.MARKDOWN ? n : "",
								rtJson: r === rn.h.RICH_TEXT ? n : null
							})
						}) : e;
					case X.r:
					case X.p: {
						const {
							draftKey: s,
							formData: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								hasFocus: !0
							})
						})
					}
					case X.k: {
						const {
							draftKey: s,
							formData: n
						} = t.payload;
						return null === e[s] ? e : Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), n)
						})
					}
					case X.f: {
						const {
							draftKey: s
						} = t.payload, n = e[s];
						return n && n.draftType === an.c.replyToPost ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								rteState: null,
								text: ""
							})
						}) : Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case X.G: {
						const {
							draftKey: s
						} = t.payload, n = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								rteState: null,
								text: ""
							})
						})
					}
					case X.F:
					case X.B: {
						const {
							draftKey: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case X.E: {
						const {
							draftKey: s,
							draft: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const dn = {};
			var un = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.h: {
						const {
							commentListNodeId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					case X.i: {
						const {
							commentListNodeId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !e[s]
						})
					}
					default:
						return e
				}
			};
			const ln = {};
			var bn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ln,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.c: {
						const {
							commentListNodeIds: s,
							commentsPageKey: n
						} = t.payload, r = s.reduce((t, s) => (t[s] = !en()(e, [n, s], !1), t), {});
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), r)
						})
					}
					case X.b: {
						const {
							commentListNodeIds: s,
							commentsPageKey: n
						} = t.payload, r = s.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), r)
						})
					}
					case X.u:
					case Fe.b:
					case te.b: {
						const {
							key: s,
							shouldHide: n
						} = t.payload;
						if (!n) return e;
						const r = n.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), r)
						})
					}
					default:
						return e
				}
			};
			const pn = {};
			var On = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case X.r: {
							const {
								commentId: s,
								commentsPageKey: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign({}, e[n]), {
									[s]: !0
								})
							})
						}
						case X.g:
						case X.z:
						case X.B: {
							const {
								commentId: s,
								commentsPageKey: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign({}, e[n]), {
									[s]: !1
								})
							})
						}
						default:
							return e
					}
				},
				gn = s("./node_modules/lodash/isEqual.js"),
				fn = s.n(gn),
				mn = s("./node_modules/lodash/omit.js"),
				jn = s.n(mn),
				_n = s("./src/reddit/actions/bulkActions/constants.ts"),
				hn = s("./src/reddit/actions/modMode.ts"),
				yn = s("./src/reddit/actions/vote.ts"),
				En = s("./src/reddit/helpers/isComment.ts"),
				In = s("./src/reddit/models/Comment/index.ts");
			const vn = (e, t, s) => {
					const n = {};
					for (const a of t) n[a.award.id] = a.total;
					const r = s ? e.awarders && e.awarders.length ? e.awarders.includes(s) ? e.awarders : [s, ...e.awarders] : [s] : e.awarders;
					return Object.assign(Object.assign({}, e), {
						awarders: r,
						awardCountsById: n
					})
				},
				Sn = (e, t) => Object.assign(Object.assign({}, e), {
					awardCountsById: Object.assign(Object.assign({}, e.awardCountsById), {
						[t]: 0
					})
				});
			var Tn = s("./src/reddit/models/ModQueue/index.ts"),
				wn = s("./src/reddit/models/Vote/index.ts"),
				Cn = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const An = {},
				Dn = e => t => {
					for (let s = 0; s < e.length; s++) t = e[s](t);
					return t
				},
				Pn = ["next", "prev", "depth"],
				Rn = e => jn()(e, Pn),
				kn = e => {
					const {
						allAwardings: t,
						associatedAward: s
					} = e, n = Cn(e, ["allAwardings", "associatedAward"]), r = Object.assign({}, n);
					if (t) {
						const e = {};
						for (const s of t) e[s.id] = s.count;
						r.awardCountsById = e
					}
					return s && (r.associatedAwardId = s.id), r
				};
			var xn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : An,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Z.b:
					case Z.c:
					case Z.d:
					case X.F:
					case X.G: {
						const {
							comment: s,
							originId: n,
							isChatSort: r
						} = t.payload, a = Dn([kn]);
						return !1 === r ? n ? Object.assign(Object.assign({}, e), {
							[s.id]: Object.assign(Object.assign({}, a(s)), {
								originId: n
							})
						}) : e : Object.assign(Object.assign({}, e), {
							[s.id]: a(s)
						})
					}
					case X.u:
					case Fe.b:
					case te.b:
					case se.b:
					case se.e:
					case qe.b:
					case qe.e:
					case oe.b:
					case oe.e:
					case Ve.b:
					case re.i:
					case re.g:
					case re.c:
					case re.e: {
						const s = Object.assign({}, e),
							n = Dn([Rn, kn]);
						for (const r in t.payload.comments) {
							const a = e[r],
								i = t.payload.comments[r];
							a ? fn()(a, i) || (i.postAuthor || (i.postAuthor = a.postAuthor), i.postTitle || (i.postTitle = a.postTitle), s[r] = n(i)) : s[r] = n(i)
						}
						return s
					}
					case Z.a:
					case X.y: {
						const {
							id: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								isDeleted: !0,
								deletedBy: In.a.User
							})
						})
					}
					case X.n: {
						const s = t.payload;
						return Q()(Object.assign({}, e), s, (e, t) => Object.assign(Object.assign({}, e), t))
					}
					case yn.a: {
						const {
							id: s,
							vote: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object(wn.c)(r, n)
						}) : e
					}
					case ge.t: {
						const {
							awardings: s,
							id: n,
							gilder: r,
							treatmentTags: a
						} = t.payload, i = e[n];
						return i ? Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, vn(i, s, r)), {
								treatmentTags: a
							})
						}) : e
					}
					case ge.G: {
						const {
							awardId: s,
							thingId: n
						} = t.payload, r = e[n];
						return r ? Object.assign(Object.assign({}, e), {
							[n]: Sn(r, s)
						}) : e
					}
					case w.l: {
						const {
							comments: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v: {
						const {
							response: s
						} = t.payload, {
							comments: n
						} = s, r = Dn([kn]);
						return Object.assign(Object.assign({}, e), ls()(n, r))
					}
					case _n.b:
					case ee.s: {
						const {
							operation: s,
							ids: n,
							username: r,
							options: a
						} = t.payload, i = n.filter(e => Object(En.a)(e)), o = Object(Tn.d)(e, s, i, r, a);
						return Q()(Object.assign({}, e), o, (e, t) => Object.assign(Object.assign({}, e), t))
					}
					case ae.c: {
						const {
							comments: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					case hn.a: {
						const s = Object.assign({}, e);
						for (const n in e)
							if (e.hasOwnProperty(n)) {
								const r = e[n];
								s[n].computedCollapsed = r.collapsedBecauseCrowdControl ? !t.payload.enabled : r.collapsed
							} return s
					}
					case X.m: {
						const {
							commentId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								collapsedBecauseCrowdControl: !1
							})
						})
					}
					default:
						return e
				}
			};
			const Nn = {};
			var Ln = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Z.b: {
						const {
							comment: s,
							depth: n,
							originId: r,
							isChatSort: a
						} = t.payload;
						if (!a && !n && !r) {
							const t = s.postId;
							return Object.assign(Object.assign({}, e), {
								[t]: e[t] ? e[t] + 1 : 1
							})
						}
						return e
					}
					case te.b: {
						const {
							postId: s
						} = t.payload;
						return e[s] ? Object.assign(Object.assign({}, e), {
							[s]: 0
						}) : e
					}
					default:
						return e
				}
			};
			const Un = {};
			var Mn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Un,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.p: {
						const {
							parentCommentId: s,
							commentsPageKey: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								[s]: !0
							})
						})
					}
					case X.o:
					case X.F: {
						const {
							parentCommentId: s,
							commentsPageKey: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								[s]: !1
							})
						})
					}
					default:
						return e
				}
			};
			const Fn = {};
			var Gn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.o:
					case X.E:
					case X.A:
					case X.G:
					case X.F:
					case X.B: {
						const {
							draftKey: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case X.D:
					case X.z: {
						const {
							draftKey: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case X.w: {
						const {
							id: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case X.x:
					case X.y: {
						const {
							id: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					default:
						return e
				}
			};
			const Bn = {};
			var qn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case X.E:
						case X.A: {
							const {
								draftKey: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case X.F:
						case X.G:
						case X.B:
						case X.D:
						case X.z: {
							const {
								draftKey: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case X.x: {
							const {
								id: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case X.y:
						case X.w: {
							const {
								id: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Vn = Object(T.c)({
					error: Gn,
					pending: qn
				}),
				Hn = s("./src/reddit/reducers/comments/visitHighlightingFilter/index.ts"),
				Kn = Object(T.c)({
					collapsed: sn,
					drafts: cn,
					focused: un,
					hidden: bn,
					isEditing: On,
					models: xn,
					replyFormOpen: Mn,
					submit: Vn,
					visitHighlightFilter: Hn.b,
					newCommentsCount: Ln
				}),
				Wn = s("./src/reddit/actions/commentsListTruncated/constants.ts");
			var Yn = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Wn.a:
						return !1;
					case Wn.b:
						return !0;
					default:
						return e
				}
			};
			const zn = [];
			var Jn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case j.n:
						return t.payload;
					case j.o:
					default:
						return e
				}
			};
			const Qn = {};
			var Xn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fe.d:
					case Fe.b:
					case te.d:
					case te.b: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Fe.a:
					case te.a: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n || {}
						})
					}
					default:
						return e
				}
			};
			const Zn = {};
			var $n = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Fe.c:
					case te.c: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			const er = {};
			var tr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : er,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.d:
						case te.d: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Fe.b:
						case Fe.a:
						case te.b:
						case te.a: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				sr = Object(T.c)({
					error: Xn,
					fullyLoaded: $n,
					pending: tr
				}),
				nr = (s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/lodash/uniqBy.js")),
				rr = s.n(nr),
				ar = s("./node_modules/lodash/values.js"),
				ir = s.n(ar);
			const or = {};

			function cr(e, t) {
				return ir()(e).map(e => {
					const s = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
					return {
						id: e.id,
						created: s,
						stickied: e.isStickied,
						authorId: e.authorId
					}
				})
			}

			function dr(e) {
				return rr()(e, "id").sort((e, t) => e.created - t.created)
			}
			var ur = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : or,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.b:
						case X.u:
						case Fe.b: {
							const {
								comments: s,
								key: n
							} = t.payload, r = e[n] ? e[n] : [], a = cr(s, r.find(e => e.stickied)), i = dr([...r, ...a]);
							return Object.assign(Object.assign({}, e), {
								[n]: [...i]
							})
						}
						case Z.b:
						case Z.c:
						case Z.d:
						case X.G:
						case X.F: {
							const {
								comment: {
									id: s,
									created: n,
									isStickied: r,
									authorId: a
								},
								commentsPageKey: i,
								isChatSort: o
							} = t.payload;
							return !1 === o ? e : Object.assign(Object.assign({}, e), {
								[i]: [...dr([...e[i] ? e[i] : [], {
									id: s,
									created: n,
									stickied: r,
									authorId: a
								}])]
							})
						}
						default:
							return e
					}
				},
				lr = s("./src/reddit/helpers/commentList/index.ts");
			const br = {};

			function pr(e) {
				const t = e;
				return ls()(t, e => {
					let {
						depth: t,
						next: s,
						prev: n
					} = e;
					return {
						depth: t,
						next: s,
						prev: n
					}
				})
			}
			var Or = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : br,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.u: {
						const {
							comments: s,
							commentLists: n,
							continueThreads: r,
							key: a,
							moreCommentsItem: i,
							moreComments: o
						} = t.payload, c = n[i.postId], d = e[a], u = {}, l = d[i.id];
						if (l && l.prev) {
							const {
								id: e
							} = l.prev;
							u[e] = Object.assign(Object.assign({}, d[e]), {
								next: c.head || l.next
							})
						}
						if (l && l.next) {
							const {
								id: e
							} = l.next;
							u[e] = Object.assign(Object.assign({}, d[e]), {
								prev: c.tail || l.prev
							})
						}
						if (c.head && c.tail) {
							const e = Object(lr.c)({
									commentLink: c.head,
									commentsDict: s,
									moreCommentsDict: o,
									continueThreadDict: r
								}),
								t = Object(lr.c)({
									commentLink: c.tail,
									commentsDict: s,
									moreCommentsDict: o,
									continueThreadDict: r
								});
							l && (e.prev = l.prev, t.next = l.next)
						}
						return Object.assign(Object.assign({}, e), {
							[a]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, e[a]), pr(s)), pr(r)), pr(o)), u)
						})
					}
					case Fe.b:
					case te.b: {
						const {
							comments: s,
							continueThreads: n,
							key: r,
							moreComments: a
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign(Object.assign(Object.assign({}, e[r]), pr(s)), pr(n)), pr(a))
						})
					}
					case Z.b:
						const {
							comment: s, commentsPageKey: n, depth: r, headCommentId: a, originId: i, isChatSort: o
						} = t.payload, c = e[n], d = {};
						let u = null;
						if (o) return a && (d[a] = Object.assign(Object.assign({}, c[a]), {
							prev: Object(In.f)(s.id)
						}), u = Object(In.f)(a)), Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign(Object.assign({}, e[n]), d), {
								[s.id]: {
									depth: 0,
									next: u,
									prev: null
								}
							})
						}); {
							let t = null;
							const a = s.parentId;
							if (i && a) {
								const s = "moreComments-" + i;
								if (c[a] && !c[s]) {
									const i = c[a].next;
									return i && (d[i.id] = Object.assign(Object.assign({}, c[i.id]), {
										prev: Object(In.g)(s)
									}), u = i), d[a] = Object.assign(Object.assign({}, c[a]), {
										next: Object(In.g)(s)
									}), t = Object(In.f)(a), Object.assign(Object.assign({}, e), {
										[n]: Object.assign(Object.assign(Object.assign({}, e[n]), d), {
											[s]: {
												depth: r || 0,
												next: u,
												prev: t
											}
										})
									})
								}
							}
							return e
						}
						case X.G: {
							const {
								comment: s,
								commentsPageKey: n,
								headCommentId: r
							} = t.payload, a = e[n], i = {};
							let o = null;
							return r && (i[r] = Object.assign(Object.assign({}, a[r]), {
								prev: Object(In.f)(s.id)
							}), o = Object(In.f)(r)), Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign(Object.assign({}, e[n]), i), {
									[s.id]: {
										depth: 0,
										next: o,
										prev: null
									}
								})
							})
						}
						case X.F: {
							const {
								comment: s,
								commentsPageKey: n,
								parentCommentId: r,
								depth: a
							} = t.payload, i = e[n], o = {};
							let c = null;
							if (!i[r]) return e;
							const d = i[r].next;
							return d && (o[d.id] = Object.assign(Object.assign({}, i[d.id]), {
								prev: Object(In.f)(s.id)
							}), c = d), o[r] = Object.assign(Object.assign({}, i[r]), {
								next: Object(In.f)(s.id)
							}), Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign(Object.assign({}, e[n]), o), {
									[s.id]: {
										depth: a,
										next: c,
										prev: Object(In.f)(r)
									}
								})
							})
						}
						default:
							return e
				}
			};
			const gr = {};
			var fr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Z.b:
					case Z.c:
					case X.G: {
						const {
							comment: s,
							commentsPageKey: n,
							isChatSort: r
						} = t.payload;
						return !1 === r ? e : Object.assign(Object.assign({}, e), {
							[n]: s.id
						})
					}
					case Fe.b:
					case te.b: {
						const {
							commentLists: s,
							key: n,
							postId: r
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s[r] && s[r].head ? s[r].head.id : null
						})
					}
					default:
						return e
				}
			};
			const mr = {};
			var jr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.d:
						case Fe.b:
						case Fe.c:
						case te.d: {
							const {
								key: s,
								postId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case X.G: {
							const {
								parentId: s,
								commentsPageKey: n
							} = t.payload;
							return e[n] ? e : Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				_r = Object(T.c)({
					api: sr,
					keyToChatCommentLinks: ur,
					keyToCommentThreadLinkSets: Or,
					keyToHeadCommentId: fr,
					keyToPostId: jr,
					ads: Jn
				}),
				hr = s("./src/reddit/actions/communityFlairs/constants.ts");
			const yr = {};
			var Er = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hr.a: {
							const {
								models: s,
								sortedKeys: n,
								subredditId: r
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[r]: {
									sortedKeys: n,
									models: s
								}
							})
						}
						default:
							return e
					}
				},
				Ir = s("./src/reddit/actions/contentGate.ts");
			const vr = {};
			var Sr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ir.a: {
						const {
							subredditName: s
						} = t.payload;
						if (s) {
							if (e[s]) {
								const t = {
									[s]: {
										goldSubreddit: !0
									}
								};
								return Q()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign(Object.assign({}, e), {
								[s]: {
									goldSubreddit: !0
								}
							})
						}
						return e
					}
					case Ir.b: {
						const {
							subredditDescription: s,
							subredditName: n
						} = t.payload;
						if (n) {
							if (e[n]) {
								const t = {
									[n]: {
										privateSubreddit: !0,
										subredditDescription: s
									}
								};
								return Q()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign(Object.assign({}, e), {
								[n]: {
									privateSubreddit: !0,
									subredditDescription: s
								}
							})
						}
						return e
					}
					case Ir.f: {
						const {
							subredditName: s,
							quarantineRequiresEmail: n,
							quarantineMessage: r,
							quarantineMessageHtml: a,
							quarantineMessageRTJson: i
						} = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								quarantinedSubreddit: !0,
								quarantineRequiresEmail: n,
								quarantineMessage: r,
								quarantineMessageHtml: a,
								quarantineMessageRTJson: i
							})
						}) : e
					}
					case Ir.h: {
						const {
							subredditName: s,
							banMessage: n
						} = t.payload;
						if (s) {
							if (e[s]) {
								const t = {
									[s]: {
										subredditBanned: !0,
										subredditBanMessage: n
									}
								};
								return Q()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign(Object.assign({}, e), {
								[s]: {
									subredditBanned: !0,
									subredditBanMessage: n
								}
							})
						}
						return e
					}
					case Ir.i: {
						const {
							subredditName: s
						} = t.payload;
						if (s) {
							if (e[s]) {
								const t = {
									[s]: {
										subredditBlockedForLegalReason: !0
									}
								};
								return Q()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign(Object.assign({}, e), {
								[s]: {
									subredditBlockedForLegalReason: !0
								}
							})
						}
						return e
					}
					case Ir.j: {
						const {
							subredditName: s
						} = t.payload;
						if (s) {
							if (e[s]) {
								const t = {
									[s]: {
										subredditDoesNotExist: !0
									}
								};
								return Q()(Object.assign({}, e), Object.assign({}, t))
							}
							return Object.assign(Object.assign({}, e), {
								[s]: {
									subredditDoesNotExist: !0
								}
							})
						}
						return e
					}
					case Ir.c:
					case Ir.d:
					case Ir.e: {
						const {
							profileName: s
						} = t.payload, n = Ke.Ub + s.toLocaleLowerCase(), r = e[n] || {}, a = {
							profileDeleted: t.type === Ir.d,
							profileSuspended: t.type === Ir.e,
							profileBlockedForLegalReason: t.type === Ir.c
						};
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, r), a)
						})
					}
					default:
						return e
				}
			};
			const Tr = {};
			var wr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case X.u:
						case Fe.b:
						case te.b:
							return Object.assign(Object.assign({}, e), t.payload.continueThreads);
						default:
							return e
					}
				},
				Cr = Object(T.c)({
					models: wr
				}),
				Ar = s("./src/reddit/actions/postCollection/constants.ts");
			var Dr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case n.c:
					case Ar.d:
					case Ar.c:
					case Ar.s:
					case Ar.r:
						return null;
					case Ar.b:
					case Ar.n:
						return t.payload;
					default:
						return e
				}
			};
			var Pr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ar.c:
						case Ar.r:
							return !0;
						case Ar.d:
						case Ar.b:
						case Ar.s:
						case Ar.n:
							return !1;
						default:
							return e
					}
				},
				Rr = Object(T.c)({
					error: Dr,
					pending: Pr
				}),
				kr = Object(T.c)({
					createOrUpdate: Rr
				}),
				xr = s("./src/reddit/actions/postDraft.ts");
			const Nr = {};
			var Lr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xr.c:
					case xr.b: {
						const {
							draftId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case xr.a: {
						const {
							apiError: s,
							draftId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Ur = {};
			var Mr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ur,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xr.b: {
							const {
								draftId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case xr.c:
						case xr.a: {
							const {
								draftId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Fr = Object(T.c)({
					error: Lr,
					pending: Mr
				});
			var Gr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xr.d:
						return t.payload;
					case xr.f:
					case xr.e:
						return null;
					default:
						return e
				}
			};
			var Br = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xr.f:
							return !0;
						case xr.e:
						case xr.d:
							return !1;
						default:
							return e
					}
				},
				qr = Object(T.c)({
					error: Gr,
					pending: Br
				});
			const Vr = {
				apiError: null,
				needsCaptcha: !1,
				validationError: null,
				submitValidationError: null
			};
			var Hr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vr,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xr.l:
					case xr.j:
						return Vr;
					case xr.i: {
						const e = t.payload;
						return Object.assign(Object.assign({}, Vr), {
							apiError: e
						})
					}
					case xr.m: {
						const e = t.payload;
						return Object.assign(Object.assign({}, Vr), {
							validationError: e
						})
					}
					case xr.k: {
						const e = t.payload;
						return Object.assign(Object.assign({}, Vr), {
							submitValidationError: e
						})
					}
					case xr.h:
						return Object.assign(Object.assign({}, Vr), {
							needsCaptcha: !0
						});
					default:
						return e
				}
			};
			var Kr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xr.j:
							return !0;
						case xr.l:
						case xr.i:
						case xr.m:
						case xr.k:
						case xr.h:
							return !1;
						default:
							return e
					}
				},
				Wr = Object(T.c)({
					error: Hr,
					pending: Kr
				}),
				Yr = Object(T.c)({
					deleteDraft: Fr,
					listing: qr,
					save: Wr
				});
			const zr = {};
			var Jr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zr,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.G: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case b.s: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Qr = Object(T.c)({
					pending: Jr
				});
			var Xr = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.x:
					case b.y:
					case b.d:
					case b.e:
					case b.f:
					case b.k:
					case b.m:
					case b.q:
					case b.O:
						return null;
					case b.w:
						return t.payload;
					default:
						return e
				}
			};
			var Zr = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.x:
							return !0;
						case b.y:
						case b.w:
							return !1;
						default:
							return e
					}
				},
				$r = Object(T.c)({
					error: Xr,
					pending: Zr
				}),
				ea = Object(T.c)({
					converting: Qr,
					mediaUpload: $r
				});
			const ta = {};
			var sa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ta,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b:
					case Be.c: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Be.a: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const na = {};
			var ra = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : na,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.c: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !1
						})
					}
					case Be.b: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			const aa = {};
			var ia = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aa,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.c: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Be.b:
						case Be.a: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				oa = Object(T.c)({
					error: sa,
					fetched: ra,
					pending: ia
				}),
				ca = s("./src/reddit/actions/scheduledPosts/constants.ts");
			const da = {
				apiError: null,
				needsCaptcha: !1,
				pollError: void 0,
				validationError: null,
				submitValidationError: null
			};
			var ua = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : da,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.P:
					case ca.h:
					case b.A:
					case b.c:
					case b.d:
					case b.e:
					case b.f:
					case b.k:
					case b.m:
					case b.q:
					case b.O:
					case b.E:
						return da;
					case b.i: {
						const {
							isContentChanged: s
						} = t.payload;
						return s ? da : e
					}
					case b.r: {
						const e = t.payload;
						return Object.assign(Object.assign({}, da), {
							apiError: e
						})
					}
					case b.bb: {
						const e = t.payload;
						return Object.assign(Object.assign({}, da), {
							validationError: e
						})
					}
					case b.K:
					case b.J: {
						const e = t.payload;
						return Object.assign(Object.assign({}, da), {
							submitValidationError: e
						})
					}
					case b.a:
						return Object.assign(Object.assign({}, da), {
							needsCaptcha: !0
						});
					case b.C:
						return Object.assign(Object.assign({}, da), {
							pollError: t.payload
						});
					default:
						return e
				}
			};
			var la = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.A:
							return !0;
						case b.P:
						case ca.h:
						case b.r:
						case b.bb:
						case b.J:
						case b.K:
						case b.C:
						case b.a:
							return !1;
						default:
							return e
					}
				},
				ba = Object(T.c)({
					error: ua,
					pending: la
				});
			var pa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.B:
					case b.H:
						return null;
					case b.p:
						return t.payload;
					default:
						return e
				}
			};
			var Oa = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.B:
							return !0;
						case b.p:
						case b.o:
							return !1;
						default:
							return e
					}
				},
				ga = Object(T.c)({
					error: pa,
					pending: Oa
				}),
				fa = Object(T.c)({
					submit: ba,
					update: ga
				});
			var ma = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.O:
					case b.M:
					case b.N:
						return null;
					default:
						return e
				}
			};
			var ja = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.N:
							return !0;
						case b.M:
						case b.O:
							return !1;
						default:
							return e
					}
				},
				_a = Object(T.c)({
					error: ma,
					pending: ja
				}),
				ha = Object(T.c)({
					change: _a
				}),
				ya = Object(T.c)({
					collection: kr,
					draft: Yr,
					editor: ea,
					page: oa,
					post: fa,
					subreddit: ha
				}),
				Ea = s("./src/reddit/actions/pages/postDraft.ts");
			const Ia = {};
			var va = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ia,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xr.e: {
						const {
							postDrafts: e
						} = t.payload;
						return e || Ia
					}
					case xr.c: {
						const s = e,
							{
								draftId: n
							} = t.payload;
						return jn()(s, n)
					}
					case b.P: {
						const {
							draftId: s
						} = t.payload;
						return s ? jn()(e, s) : e
					}
					case Ea.a: {
						const {
							drafts: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			s("./node_modules/core-js/modules/es6.regexp.match.js");
			const Sa = e => {
					if (e.payload && e.payload.routeMatch) return e.payload.routeMatch.route.meta.name
				},
				Ta = e => {
					if (e.payload && e.payload.routeMatch && e.payload.routeMatch.match) return e.payload.routeMatch.match.queryParams
				},
				wa = e => {
					if (e.payload && e.payload.routeMatch && e.payload.routeMatch.match) return e.payload.routeMatch.match.params
				};
			var Ca = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.d:
							return t.payload || "";
						case b.E:
							return "";
						case l.a: {
							if (Sa(t) !== Ke.Bb.POST_CREATION) return "";
							const s = Ta(t);
							return s && s.url ? s.url || "" : e
						}
						case xr.g: {
							const e = t.payload;
							return e.kind === an.b.Link && e.body || ""
						}
						case ca.b:
						case ca.n:
							return t.payload.url || "";
						default:
							return e
					}
				},
				Aa = (s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./src/reddit/models/ScheduledPost/index.ts"));
			const Da = e => e ? e.replace(/\+/g, " ") : "";
			var Pa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.e:
						return t.payload || "";
					case b.E:
					case b.I:
						return "";
					case b.Q:
						return t.payload.editorMode === rn.h.MARKDOWN ? t.payload.content || "" : e;
					case l.a: {
						if (Sa(t) !== Ke.Bb.POST_CREATION) return "";
						const s = Ta(t);
						return s && s.text ? Da(s.text) : e
					}
					case xr.g: {
						const e = t.payload;
						return e.kind === an.b.Markdown && e.body || ""
					}
					case ca.b:
					case ca.n: {
						const e = t.payload;
						return e.contentType === Aa.a.TEXT ? e.body : ""
					}
					default:
						return e
				}
			};
			const Ra = {
				items: [],
				selectedKey: null
			};
			var ka = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ra,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.f:
							return t.payload || Ra;
						case b.E:
							return Ra;
						case l.a:
							return Sa(t) !== Ke.Bb.POST_CREATION ? Ra : e;
						case xr.g:
							return Ra;
						case ca.b:
						case ca.n:
							return Ra;
						default:
							return e
					}
				},
				xa = s("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				Na = s("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				La = s("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts");
			const Ua = xa.a.createInitial;
			var Ma = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ua(),
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.i: {
							const {
								rteState: e
							} = t.payload;
							return e
						}
						case b.E:
							return xa.a.createInitial();
						case b.Q: {
							const s = t.payload;
							return s.editorMode === rn.h.RICH_TEXT && s.editorKey === rn.g.POST_CREATION ? xa.a.createInitial(s.content) : e
						}
						case l.a:
							return Sa(t) !== Ke.Bb.POST_CREATION ? xa.a.createInitial() : e;
						case xr.g: {
							const e = t.payload;
							return e.kind === an.b.RichText ? xa.a.createInitial(e.body) : xa.a.createInitial()
						}
						case ca.b:
						case ca.n: {
							const e = t.payload,
								s = Object(Na.c)(e.mediaAssets);
							return xa.a.createInitial(e.contentType === Aa.a.RTJSON ? Object(La.b)(e.body) : void 0, s || void 0)
						}
						default:
							return e
					}
				},
				Fa = Object(T.c)({
					link: Ca,
					markdown: Pa,
					media: ka,
					rte: Ma
				});
			var Ga = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.b:
							return t.payload || null;
						case b.E:
						case xr.g:
						case ca.b:
						case ca.n:
						case b.O:
							return null;
						case l.a:
							return Sa(t) === Ke.Bb.POST_CREATION ? e : null;
						default:
							return e
					}
				},
				Ba = s("./src/reddit/selectors/scheduledPosts/index.ts");
			var qa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.c:
						return t.payload || null;
					case ca.b:
					case ca.n: {
						const e = t.payload;
						return Object(Ba.n)({
							scheduledPost: e
						}) || null
					}
					case b.E:
						return null;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION ? e : null;
					case xr.g:
						return t.payload.flair || null;
					default:
						return e
				}
			};
			var Va = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.t:
						return t.payload.type || null;
					case ca.b:
					case ca.n:
					case b.k:
					case b.E:
					case l.a:
						return null;
					default:
						return e
				}
			};
			var Ha = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.S:
						return t.payload || !1;
					case ca.b:
					case ca.n:
						return "CHAT" === t.payload.discussionType;
					case b.E:
						return !1;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case xr.g:
						return t.payload.isChatPost || !1;
					default:
						return e
				}
			};
			var Ka = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.T:
						return t.payload || !1;
					case b.E:
						return !1;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case ca.b:
					case ca.n:
						return t.payload.isContestMode;
					default:
						return e
				}
			};
			var Wa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.V:
						return t.payload || !1;
					case b.E:
						return !1;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case xr.g:
						return t.payload.isNSFW || !1;
					case ca.b:
					case ca.n:
						return t.payload.isNsfw;
					default:
						return e
				}
			};
			var Ya = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.W:
						return t.payload || !1;
					case b.E:
						return !1;
					case b.O: {
						const {
							name: s
						} = t.payload;
						return !!s && e
					}
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case xr.g:
						return t.payload.isOriginalContent || !1;
					case ca.b:
					case ca.n:
						return t.payload.isOriginalContent;
					default:
						return e
				}
			};
			var za = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.X:
						return t.payload || !1;
					case ca.b:
					case ca.n:
						return !!t.payload.poll;
					case b.E:
						return !1;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					default:
						return e
				}
			};
			var Ja = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ca.b:
					case ca.n:
					case b.E:
						return !1;
					case xr.n:
						return t.payload;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case xr.g:
						return t.payload.isPublicLink;
					default:
						return e
				}
			};
			var Qa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.Y:
						return t.payload || !1;
					case b.E:
						return !1;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case xr.g:
						return t.payload.isSpoiler || !1;
					case ca.b:
					case ca.n:
						return t.payload.isSpoiler;
					default:
						return e
				}
			};
			var Xa = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.b: {
						const {
							subredditName: e
						} = t.payload;
						return e
					}
					case l.a:
					case b.k:
					case b.t:
					case b.E:
					case d.h:
						return "";
					default:
						return e
				}
			};
			var Za = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.c: {
						const {
							username: e
						} = t.payload;
						return e
					}
					case l.a:
					case b.k:
					case b.t:
					case b.E:
					case d.h:
						return "";
					default:
						return e
				}
			};
			var $a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.N:
						case b.O:
							return t.payload;
						case b.M:
						case l.a:
							return null;
						default:
							return e
					}
				},
				ei = s("./src/reddit/actions/polls.ts");
			var ti = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ei.a:
							return Object.assign({}, t.payload);
						case ca.b:
						case ca.n: {
							const e = t.payload;
							return e.poll ? {
								options: e.poll.options,
								duration: 864e5 * e.poll.duration
							} : null
						}
						case d.h:
						case b.E:
							return null;
						case l.a:
							return Sa(t) !== Ke.Bb.POST_CREATION ? null : e;
						default:
							return e
					}
				},
				si = s("./src/reddit/helpers/scheduledPosts/index.ts");
			var ni = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.g:
						return t.payload || null;
					case b.E:
					case xr.g:
					case b.O:
						return null;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION ? e : null;
					case ca.n: {
						const e = t.payload;
						return {
							submitDate: e.publishAt,
							timezoneName: e.clientTimezone,
							frequencyOption: null,
							recurrenceInfo: null
						}
					}
					case ca.b: {
						const e = t.payload;
						return Object.assign({}, Object(si.h)(e))
					}
					default:
						return e
				}
			};
			var ri = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				const {
					type: s,
					payload: n
				} = t;
				switch (s) {
					case b.Z:
						return n || !1;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case ca.b:
					case ca.n:
					case xr.g:
						return !1;
					default:
						return e
				}
			};
			var ai = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.h:
						return t.payload || "";
					case l.a:
						return Sa(t) !== Ke.Bb.POST_CREATION ? "" : e;
					default:
						return e
				}
			};
			var ii = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a:
						return Sa(t) !== Ke.Bb.POST_CREATION ? null : e;
					case b.E:
						return null;
					case ca.b:
					case ca.n:
						return t.payload.id;
					default:
						return e
				}
			};
			var oi = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.E:
						return !0;
					case b.ab:
						return t.payload;
					case l.a:
						return Sa(t) !== Ke.Bb.POST_CREATION || e;
					case xr.g:
						return t.payload.sendReplies;
					case ca.b:
					case ca.n:
						return t.payload.isSendReplies;
					default:
						return e
				}
			};
			var ci = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				const {
					type: s,
					payload: n
				} = t;
				switch (s) {
					case b.j:
						return n || null;
					case b.E:
					case xr.g:
					case b.O:
						return null;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION ? e : null;
					case ca.b:
					case ca.n:
						return t.payload.sticky || null;
					default:
						return e
				}
			};
			const di = Ke.Jb.POST;
			var ui = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : di,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.E:
						return di;
					case b.u:
						return Ke.Jb.CROSSPOST;
					case b.k:
						return t.payload.submissionType || di;
					case l.a: {
						if (Sa(t) !== Ke.Bb.POST_CREATION) return di;
						const s = Ta(t);
						if (!s) return e;
						const {
							title: n = "",
							url: r,
							text: a = "",
							media: i = !1,
							selftext: o = !1
						} = s, c = n && !a && !o;
						return i ? Ke.Jb.MEDIA : void 0 !== r || c ? Ke.Jb.LINK_ONLY : a || o ? Ke.Jb.POST : e
					}
					case xr.g: {
						const e = t.payload;
						return an.a[e.kind]
					}
					case ca.b:
					case ca.n: {
						const e = t.payload;
						return e.poll ? Ke.Jb.POLL : e.url ? Ke.Jb.LINK_ONLY : Ke.Jb.POST
					}
					default:
						return e
				}
			};
			var li = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					const {
						type: s,
						payload: n
					} = t;
					switch (s) {
						case b.l:
							return n || null;
						case b.E:
						case xr.g:
						case b.O:
							return null;
						case l.a:
							return Sa(t) === Ke.Bb.POST_CREATION ? e : null;
						case ca.b:
						case ca.n:
							return t.payload.suggestedCommentSort || null;
						default:
							return e
					}
				},
				bi = s("./src/reddit/models/Poll/index.ts");
			const pi = e => e ? e.replace(/\+/g, " ") : "",
				Oi = e => "Should ".concat(e || "username", " become the top moderator?"),
				gi = e => e ? "Should we spin-off to r/".concat(e, "?") : "Should we spin-off to a new community?";
			var fi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.u:
							return t.payload.postTitle || "";
						case b.m:
							return t.payload || "";
						case b.D: {
							const {
								title: s
							} = t.payload;
							return e || (s || "")
						}
						case b.E:
							return "";
						case l.a: {
							if (Sa(t) !== Ke.Bb.POST_CREATION) return "";
							const s = Ta(t);
							return s && s.title ? pi(s.title) : e
						}
						case xr.g:
							return t.payload.title;
						case b.t: {
							const {
								oldType: s,
								type: n
							} = t.payload;
							return n === bi.a.ReplaceTopMod ? Oi("") : n === bi.a.Spinoff ? gi("") : s === bi.a.ReplaceTopMod || s === bi.a.Spinoff ? "" : e
						}
						case d.c: {
							const {
								username: e
							} = t.payload;
							return Oi(e)
						}
						case d.b: {
							const {
								subredditName: e
							} = t.payload;
							return gi(e)
						}
						case b.k: {
							const {
								extra: s
							} = t.payload;
							return !s || s.govType !== bi.a.ReplaceTopMod && s.govType !== bi.a.Spinoff ? e : ""
						}
						case ca.b:
						case ca.n:
							return t.payload.title;
						default:
							return e
					}
				},
				mi = Object(T.c)({
					body: Fa,
					eventSchedule: Ga,
					flair: qa,
					govType: Va,
					isChatPost: Ha,
					isContestMode: Ka,
					isNSFW: Wa,
					isOC: Ya,
					isPoll: za,
					isPublicLink: Ja,
					isSpoiler: Qa,
					newSubreddit: Xa,
					newTopMod: Za,
					nextSubreddit: $a,
					polls: ti,
					postSchedule: ni,
					postToTwitter: ri,
					recaptcha: ai,
					scheduledPostId: ii,
					sendReplies: oi,
					stickyPosition: ci,
					submissionType: ui,
					suggestedSort: li,
					title: fi
				});
			const ji = e => e ? e.replace(/\+/g, " ") : "";
			var _i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						if (Sa(t) !== Ke.Bb.POST_CREATION) return null;
						const s = Ta(t);
						return s && s.text && ji(s.text) ? rn.h.MARKDOWN : e
					}
					case b.H: {
						const {
							editorMode: e
						} = t.payload;
						return e
					}
					case b.I:
						return null;
					case b.Q: {
						const {
							editorMode: e
						} = t.payload;
						return e
					}
					case ca.b:
					case ca.n:
						return t.payload.contentType === Aa.a.RTJSON ? rn.h.RICH_TEXT : rn.h.MARKDOWN;
					default:
						return e
				}
			};
			const hi = {
					title: [],
					body: [],
					link: [],
					flair: []
				},
				yi = (e, t) => {
					const s = (t.fields || []).filter(e => {
						let {
							field: t
						} = e;
						return Object(rn.u)(t)
					});
					if (!s.length) return e;
					const n = s.reduce((e, t) => (e[t.field] || (e[t.field] = []), e[t.field].push(t.msg), e), {});
					return Object.assign(Object.assign({}, e), n)
				};
			var Ei = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hi,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.c:
					case b.d:
					case b.e:
						return e[Ke.nb.BODY] ? Object.assign(Object.assign({}, e), {
							[Ke.nb.BODY]: []
						}) : e;
					case b.i: {
						const {
							isContentChanged: s
						} = t.payload;
						return e[Ke.nb.BODY] && s ? Object.assign(Object.assign({}, e), {
							[Ke.nb.BODY]: []
						}) : e
					}
					case b.m:
						return e[Ke.nb.TITLE] ? Object.assign(Object.assign({}, e), {
							[Ke.nb.TITLE]: []
						}) : e;
					case b.L: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: []
						})
					}
					case b.q: {
						const s = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[s]: []
						}) : hi
					}
					case b.K:
					case b.J: {
						const s = t.payload;
						return yi(e, s)
					}
					case l.a:
						return Sa(t) !== Ke.Bb.POST_CREATION ? hi : e;
					default:
						return e
				}
			};
			var Ii = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.b:
					case b.c:
					case b.d:
					case b.e:
					case b.f:
					case b.g:
					case b.j:
					case b.l:
					case b.m:
					case b.k:
					case b.T:
					case b.V:
					case b.W:
					case b.Y:
					case xr.n:
					case b.ab:
						return !0;
					case b.i: {
						const {
							isContentChanged: s
						} = t.payload;
						return !!s || e
					}
					case b.P:
					case ca.h:
						return !1;
					case b.R:
						return t.payload;
					case l.a:
						return Sa(t) === Ke.Bb.POST_CREATION && e;
					case b.E:
					case xr.l:
					case xr.g:
						return !1;
					default:
						return e
				}
			};
			var vi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.z:
						return e === t.payload ? null : t.payload || null;
					case n.c:
						return t.payload ? null : e;
					case l.a:
						return Sa(t) !== Ke.Bb.POST_CREATION ? null : e;
					default:
						return e
				}
			};
			const Si = rn.q.Post;
			var Ti = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Si,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.A:
							return rn.q.Post;
						case b.F:
							return t.payload;
						case xr.j:
							return rn.q.Draft;
						case l.a:
							return Sa(t) !== Ke.Bb.POST_CREATION ? Si : e;
						default:
							return e
					}
				},
				wi = Object(T.c)({
					editorMode: _i,
					fieldValidation: Ei,
					isChanged: Ii,
					modalId: vi,
					submitMode: Ti
				});
			var Ci = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.H:
						return t.payload.editorMode === rn.h.MARKDOWN ? t.payload.postContent || "" : e;
					case b.I:
						return "";
					case b.Q:
						return t.payload.editorMode === rn.h.MARKDOWN ? t.payload.content || "" : e;
					default:
						return e
				}
			};
			const Ai = xa.a.createInitial;
			var Di = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ai(),
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.I:
							return xa.a.createInitial();
						case b.H: {
							const s = t.payload;
							return s.editorMode === rn.h.RICH_TEXT && "object" == typeof s.postContent ? xa.a.createInitial(s.postContent, s.mediaMetadata) : e
						}
						case b.Q: {
							const s = t.payload;
							return s.editorMode === rn.h.RICH_TEXT && s.editorKey === rn.g.POST_EDITING ? xa.a.createInitial(s.content) : e
						}
						default:
							return e
					}
				},
				Pi = Object(T.c)({
					markdown: Ci,
					rte: Di
				});
			var Ri = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case b.H: {
							const {
								postId: e
							} = t.payload;
							return e
						}
						case b.I:
							return null;
						default:
							return e
					}
				},
				ki = Object(T.c)({
					draft: Pi,
					postId: Ri
				}),
				xi = Object(T.c)({
					api: ya,
					drafts: va,
					formData: mi,
					formState: wi,
					postEditing: ki
				}),
				Ni = s("./src/reddit/actions/dashboard.ts");
			const Li = {
				selectedComponent: null,
				subredditPending: !1,
				subredditLoaded: {}
			};
			var Ui = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Li,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ni.a:
						return Object.assign(Object.assign({}, e), {
							selectedComponent: t.payload
						});
					case Ni.c: {
						const s = t.payload,
							n = e.subredditLoaded[s];
						return Object.assign(Object.assign({}, e), {
							subredditPending: !n,
							subredditLoaded: Object.assign(Object.assign({}, e.subredditLoaded), {
								[s]: n || !1
							})
						})
					}
					case Ni.b: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							subredditPending: !1,
							subredditLoaded: Object.assign(Object.assign({}, e.subredditLoaded), {
								[s]: !0
							})
						})
					}
					default:
						return e
				}
			};
			var Mi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.b:
					case Le.c:
						return null;
					case Le.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			var Fi = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Le.c:
						return !1;
					case Le.b:
						return !0;
					default:
						return e
				}
			};
			var Gi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.c:
							return !0;
						case Le.b:
						case Le.a:
							return !1;
						default:
							return e
					}
				},
				Bi = Object(T.c)({
					error: Mi,
					loaded: Fi,
					pending: Gi
				}),
				qi = Object(T.c)({
					list: Bi
				}),
				Vi = s("./node_modules/lodash/isEmpty.js"),
				Hi = s.n(Vi);
			const Ki = {};
			var Wi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ki,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.b: {
							const {
								discoveryUnits: s
							} = t.payload;
							return Hi()(s) ? e : Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				Yi = s("./node_modules/lodash/forOwn.js"),
				zi = s.n(Yi),
				Ji = s("./src/reddit/helpers/name/index.ts");
			const Qi = {};
			var Xi = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qi,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Le.b: {
							const {
								discoveryUnits: s
							} = t.payload;
							if (Hi()(s)) return e;
							const n = {};
							return zi()(s, e => {
								n[Object(Ji.f)(e.unitName)] = e.id
							}), Object.assign(Object.assign({}, e), n)
						}
						default:
							return e
					}
				},
				Zi = Object(T.c)({
					api: qi,
					models: Wi,
					nameToId: Xi
				}),
				$i = s("./src/reddit/actions/dismissedTruncationList/constants.ts");
			const eo = [];
			var to = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $i.a: {
							const {
								subredditId: s
							} = t.payload;
							return [...e, s]
						}
						default:
							return e
					}
				},
				so = s("./src/reddit/actions/economics/banners/constants.ts");
			const no = {
				dismissedBanners: {}
			};
			var ro = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : no,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case so.c: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								dismissedBanners: Object.assign(Object.assign({}, e.dismissedBanners), {
									[s]: Object.assign(Object.assign({}, e.dismissedBanners[s]), {
										pending: !0
									})
								})
							})
						}
						case so.d: {
							const {
								subredditId: s,
								data: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								dismissedBanners: Object.assign(Object.assign({}, e.dismissedBanners), {
									[s]: Object.assign(Object.assign({}, e.dismissedBanners[s]), {
										pending: !1,
										data: n
									})
								})
							})
						}
						case so.a:
						case so.b: {
							const {
								subredditId: s,
								bannerType: n
							} = t.payload, r = e.dismissedBanners[s] || {}, a = t.type === so.a;
							return Object.assign(Object.assign({}, e), {
								dismissedBanners: Object.assign(Object.assign({}, e.dismissedBanners), {
									[s]: Object.assign(Object.assign({}, r), {
										data: Object.assign(Object.assign({}, r.data), {
											[n]: a
										})
									})
								})
							})
						}
						default:
							return e
					}
				},
				ao = s("./src/reddit/actions/economics/claims/constants.ts");
			const io = {};
			var oo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : io,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ao.b:
						case ao.a:
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									isClaiming: t.type === ao.b
								})
							});
						default:
							return e
					}
				},
				co = s("./src/reddit/models/Badge/managementPage.ts");
			const uo = {
				badgeType: co.a.Cosmetic,
				view: co.c.Gallery
			};
			var lo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.c: {
						const {
							badge: s,
							initialView: n
						} = t.payload;
						return s || n ? Object.assign(Object.assign({}, e), {
							badgeType: s ? Object(co.d)(s.placement) : e.badgeType,
							view: n
						}) : e
					}
					case c.b: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							badgeType: s
						})
					}
					case c.d: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							view: s
						})
					}
					case n.b:
						return uo;
					default:
						return e
				}
			};
			var bo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.c:
						return {
							badge: t.payload.badge
						};
					case n.b:
						return null;
					case c.g:
						return t.payload;
					case c.k:
						return t.payload || null;
					default:
						return e
				}
			};
			const po = {};
			var Oo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : po,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.e: {
						const {
							emotes: s,
							emoteCollections: n
						} = t.payload.products, r = {};
						return s.forEach(e => {
							const t = e.extra && e.extra.assets,
								s = Object.keys(e.collections || {})[0] || e.title,
								a = n[s];
							r[s] || (r[s] = {
								emotes: {},
								position: a ? a.position : 0,
								title: a ? a.title : e.title
							}), t && Object.keys(t).forEach(n => {
								const a = t[n];
								r[s].emotes[n] = {
									id: n,
									emoji: a.emoji,
									extra: {
										rtDescription: e.extra && e.extra.rtDescription
									},
									fullId: "emote|".concat(e.id, "|").concat(n),
									imageType: a.emoji.type,
									sticker: a.sticker
								}
							})
						}), Object.assign(Object.assign({}, e), {
							[t.payload.subredditId]: Object.keys(r).map(e => r[e]).sort((e, t) => e.position - t.position)
						})
					}
					case ge.kb: {
						const {
							powerups: s,
							subredditId: n
						} = t.payload;
						if (s && s.mediaPacks) {
							const t = s.mediaPacks.map(e => ({
								title: e.name,
								emotes: e.emotes.reduce((t, s) => Object.assign(Object.assign({}, t), {
									[s.name]: {
										id: s.name,
										fullId: "emote|".concat(e.id, "|").concat(s.name),
										imageType: s.emojiIcon.mimeType,
										emoji: {
											x: s.emojiIcon.x,
											y: s.emojiIcon.y,
											path: s.emojiIcon.url,
											type: s.emojiIcon.mimeType
										},
										sticker: {
											x: s.stickerIcon.x,
											y: s.stickerIcon.y,
											path: s.stickerIcon.url,
											type: s.stickerIcon.mimeType
										}
									}
								}), {})
							}));
							return Object.assign(Object.assign({}, e), {
								[n]: e[n] ? [...e[n], ...t] : t
							})
						}
						return e
					}
					default:
						return e
				}
			};
			const go = {};
			var fo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : go,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.e: {
							const s = t.payload.products.giphy.length > 0;
							return Object.assign(Object.assign({}, e), {
								[t.payload.subredditId]: {
									hasGifProduct: s
								}
							})
						}
						default:
							return e
					}
				},
				mo = s("./src/reddit/actions/economics/me/constants.ts");
			const jo = {
				fetched: !1,
				data: {}
			};
			var _o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mo.a:
							return {
								fetched: !0, data: t.payload
							};
						case c.i: {
							const {
								subredditId: s
							} = t.payload;
							return e.data.specialMemberships && e.data.specialMemberships[s] ? Object.assign(Object.assign({}, e), {
								data: Object.assign(Object.assign({}, e.data), {
									specialMemberships: Object.assign(Object.assign({}, e.data.specialMemberships), {
										[s]: Object.assign(Object.assign({}, e.data[s]), {
											settings: {
												renew: !1
											}
										})
									})
								})
							}) : e
						}
						default:
							return e
					}
				},
				ho = s("./src/reddit/reducers/economics/paymentSystems/index.ts");
			const yo = {
				fetched: !1,
				data: null
			};
			var Eo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mo.b:
							return {
								fetched: !0, data: e.data
							};
						case mo.c:
							return {
								fetched: !0, data: t.payload
							};
						default:
							return e
					}
				},
				Io = s("./src/reddit/reducers/economics/subredditPremium/index.ts"),
				vo = Object(T.c)({
					banners: ro,
					claims: oo,
					currentBadgeManagementScreen: lo,
					currentModalArgs: bo,
					emotes: Oo,
					gifs: fo,
					me: _o,
					paymentSystems: ho.b,
					pointsCopy: Eo,
					subredditPremium: Io.b
				}),
				So = s("./src/reddit/actions/emoji.ts"),
				To = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const wo = {};
			var Co = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case So.h: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case So.g: {
							const {
								subredditId: s
							} = t.payload, n = e, r = s;
							n[r];
							return To(n, ["symbol" == typeof r ? r : r + ""])
						}
						case So.f: {
							const {
								subredditId: s
							} = t.payload, n = e, r = s;
							n[r];
							return To(n, ["symbol" == typeof r ? r : r + ""])
						}
						default:
							return e
					}
				},
				Ao = Object(T.c)({
					pending: Co
				}),
				Do = Object(T.c)({
					list: Ao
				}),
				Po = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const Ro = {};
			var ko = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ro,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case So.f:
						case So.c:
							return e;
						case So.g: {
							const {
								data: e
							} = t.payload;
							return e
						}
						case So.d: {
							const {
								emojiName: s,
								subredditId: n
							} = t.payload, r = e[n].emojis, a = s, i = (r[a], Po(r, ["symbol" == typeof a ? a : a + ""]));
							return Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign({}, e[n]), {
									emojis: i
								})
							})
						}
						case So.i: {
							const s = t.payload,
								n = e[s.subredditId].emojis,
								r = {
									url: s.url,
									name: s.name,
									userFlairAllowed: s.userFlairAllowed,
									postFlairAllowed: s.postFlairAllowed,
									modFlairOnly: s.modFlairOnly
								},
								a = Object.assign(Object.assign({}, n), {
									[s.name]: r
								});
							return Object.assign(Object.assign({}, e), {
								[s.subredditId]: Object.assign(Object.assign({}, e[s.subredditId]), {
									emojis: a
								})
							})
						}
						case So.e: {
							const {
								emojiName: s,
								isSnoomoji: n,
								settings: r,
								subredditId: a
							} = t.payload, i = n ? "snoomojis" : "emojis", o = e[a][i], c = Object.assign(Object.assign({}, o), {
								[s]: Object.assign(Object.assign({}, o[s]), r)
							});
							return Object.assign(Object.assign({}, e), {
								[a]: Object.assign(Object.assign({}, e[a]), {
									[i]: c
								})
							})
						}
						default:
							return e
					}
				},
				xo = Object(T.c)({
					api: Do,
					models: ko
				}),
				No = s("./src/reddit/actions/experiments.ts");
			const Lo = /^experiment_(.*)$/i,
				Uo = e => {
					const t = e.match(Lo);
					if (null !== t) return t[1]
				},
				Mo = {};
			var Fo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a: {
							const s = Ta(t);
							if (!s) return e;
							const n = {};
							for (const e in s) {
								const t = Uo(e);
								t && (n[t.toLowerCase()] = s[e] || "")
							}
							return Hi()(n) ? e : Object.assign(Object.assign({}, e), n)
						}
						case No.b: {
							const {
								experimentName: s,
								override: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[s]: n || ""
							}) : e
						}
						default:
							return e
					}
				},
				Go = s("./src/reddit/actions/externalAccount.ts");
			const Bo = {};
			var qo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Go.e:
					case Go.f: {
						const {
							provider: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Go.d: {
						const {
							provider: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Vo = {};
			var Ho = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Go.e: {
							const {
								provider: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Go.f:
						case Go.d: {
							const {
								provider: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Ko = Object(T.c)({
					error: qo,
					pending: Ho
				});
			const Wo = {};
			var Yo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Go.l:
					case Go.k: {
						const {
							provider: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Go.j: {
						const {
							provider: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const zo = {};
			var Jo = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zo,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Go.b: {
							const {
								provider: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Go.c:
						case Go.a: {
							const {
								provider: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Qo = Object(T.c)({
					error: Yo,
					pending: Jo
				});
			const Xo = {};
			var Zo = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xo,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Go.i:
					case Go.h: {
						const {
							subredditName: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Go.g: {
						const {
							subredditName: s,
							apiError: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const $o = {};
			var ec = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Go.h: {
						const {
							subredditName: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			const tc = {};
			var sc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Go.i: {
							const {
								subredditName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Go.h:
						case Go.g: {
							const {
								subredditName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				nc = Object(T.c)({
					error: Zo,
					fetched: ec,
					pending: sc
				});
			const rc = {};
			var ac = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Go.l:
					case Go.k: {
						const {
							username: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Go.j: {
						const {
							username: s,
							apiError: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const ic = {};
			var oc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ic,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Go.l: {
							const {
								username: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Go.k:
						case Go.j: {
							const {
								username: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				cc = Object(T.c)({
					error: ac,
					pending: oc
				}),
				dc = Object(T.c)({
					connect: Ko,
					disconnect: Qo,
					user: cc,
					subreddit: nc
				});
			const uc = {};
			var lc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Go.h: {
						const {
							subredditName: s,
							accountsData: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const bc = {};
			var pc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Go.k: {
							const {
								username: s,
								accountsData: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case Go.c: {
							const {
								username: s,
								provider: n
							} = t.payload, r = e[s];
							return r && r[n] ? Object.assign(Object.assign({}, e), {
								[s]: jn()(r, n)
							}) : e
						}
						default:
							return e
					}
				},
				Oc = Object(T.c)({
					api: dc,
					user: pc,
					subreddit: lc
				}),
				gc = s("./src/reddit/featureFlags/index.ts");
			const fc = new Set(["0", "disabled", "false", "off", ""]);
			var mc = e => !fc.has(e.toLowerCase());
			const jc = gc.a.reduce((e, t) => (e[t.toLowerCase()] = t, e), {}),
				_c = gc.a.reduce((e, t) => (e[t] = null, e), {});
			var hc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _c,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a: {
							const s = Ta(t);
							if (void 0 !== s) {
								const t = {};
								for (const e in s) {
									const n = Object(gc.g)(e);
									if (n) {
										const r = jc[n.toLowerCase()];
										if (r) {
											const n = s[e],
												a = "string" != typeof n || mc(n);
											t[r] = a
										}
									}
								}
								if (Object.keys(t).length > 0) return Object.assign(Object.assign({}, e), t)
							}
							return e
						}
						case gc.b: {
							const {
								featureName: s,
								currentValue: n
							} = t.payload;
							return n === e[s] ? e : Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case gc.c: {
							const {
								featureName: s,
								currentValue: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !n
							})
						}
						default:
							return e
					}
				},
				yc = Object(T.c)({
					overrides: hc
				});
			var Ec = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.g:
					case $.i:
						return null;
					case $.f:
						return t.payload;
					default:
						return e
				}
			};
			var Ic = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.i:
							return !0;
						case $.g:
						case $.f:
							return !1;
						default:
							return e
					}
				},
				vc = Object(T.c)({
					error: Ec,
					pending: Ic
				});
			const Sc = {};
			var Tc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.g:
					case $.k: {
						const {
							subredditId: s,
							flairedUsers: n
						} = t.payload;
						return Re()(Object.assign({}, e), {
							[s]: n
						})
					}
					case $.c: {
						const {
							subredditId: s,
							userName: n
						} = t.payload, r = jn()(e[s], n);
						return Object.assign(Object.assign({}, e), {
							[s]: r
						})
					}
					case $.a:
					case $.b:
					case $.h:
						const {
							subredditId: s, userName: n, applied: r
						} = t.payload;
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								[n]: r
							})
						}) : e;
					default:
						return e
				}
			};
			const wc = {};
			var Cc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.g: {
						const {
							key: s,
							pageInfo: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			var Ac = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $.l:
					case $.k:
						return null;
					case $.j:
						return t.payload;
					default:
						return e
				}
			};
			var Dc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.l:
							return !0;
						case $.k:
						case $.j:
							return !1;
						default:
							return e
					}
				},
				Pc = Object(T.c)({
					error: Ac,
					pending: Dc
				});
			var Rc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case $.c: {
							const {
								userName: s
							} = t.payload;
							return e === s ? null : e
						}
						default:
							return e
					}
				},
				kc = Object(T.c)({
					api: Pc,
					result: Rc
				});
			const xc = {};
			var Nc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $.g: {
							const {
								key: s,
								userOrder: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case $.a: {
							const {
								key: s,
								userName: n
							} = t.payload;
							if (!s) return e;
							if (!e[s].includes(n)) {
								const t = [...e[s], n];
								return Object.assign(Object.assign({}, e), {
									[s]: t
								})
							}
							return e
						}
						case $.c: {
							const {
								userName: s
							} = t.payload, n = {};
							for (const t in e) n[t] = e[t].filter(e => e !== s);
							return n
						}
						default:
							return e
					}
				},
				Lc = Object(T.c)({
					api: vc,
					models: Tc,
					pageInfo: Cc,
					search: kc,
					userOrder: Nc
				}),
				Uc = s("./src/reddit/actions/focusedVerticals/constants.ts");
			const Mc = {
				focusedVerticalGqlError: null
			};
			var Fc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uc.h:
					case Uc.g:
					case Uc.c:
						return Object.assign(Object.assign({}, e), {
							focusedVerticalGqlError: null
						});
					case Uc.e:
						return Object.assign(Object.assign({}, e), {
							focusedVerticalGqlError: t.payload
						});
					default:
						return e
				}
			};
			const Gc = {
				focusedVerticalGqlPending: !1
			};
			var Bc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gc,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Uc.h:
							return Object.assign(Object.assign({}, e), {
								focusedVerticalGqlPending: !0
							});
						case Uc.e:
						case Uc.g:
						case Uc.c:
							return Object.assign(Object.assign({}, e), {
								focusedVerticalGqlPending: !1
							});
						default:
							return e
					}
				},
				qc = Object(T.c)({
					error: Fc,
					pending: Bc
				});
			var Vc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uc.g:
					case Uc.c:
						return t.payload.category || "";
					default:
						return e
				}
			};
			const Hc = {
				dismissed: !0
			};
			var Kc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uc.j:
						return {
							dismissed: !1
						};
					case Uc.i:
						return {
							dismissed: !0
						};
					default:
						return e
				}
			};
			var Wc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uc.g:
					case Uc.c:
						return t.payload.interactedSubredditIds || null;
					default:
						return e
				}
			};
			var Yc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uc.g:
					case Uc.c:
					case Uc.f:
						return t.payload.lastLoadedEnv || null;
					default:
						return e
				}
			};
			var zc = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Uc.g:
						case Uc.c:
							return t.payload.recommendedSubredditIds || null;
						default:
							return e
					}
				},
				Jc = Object(T.c)({
					api: qc,
					components: Kc,
					interactedSubredditIds: Wc,
					recommendedSubredditIds: zc,
					category: Vc,
					lastLoadedEnv: Yc
				});
			Object(He.a)("FONTS_FONT_FILES_PARSED");
			const Qc = [];
			var Xc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qc,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "FONTS_FONT_FILES_PARSED":
						return t.payload.fonts;
					default:
						return e
				}
			};
			var Zc = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.q:
						return t.payload;
					case ge.f:
					case l.a:
					case ge.M:
					case ge.t:
						return null;
					default:
						return e
				}
			};
			var $c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.f:
					case l.a:
					case ge.t:
					case ge.q:
						return !1;
					case ge.r:
						return !0;
					default:
						return e
				}
			};
			var ed = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.r:
						case ge.f:
						case l.a:
						case ge.t:
						case ge.q:
							return !1;
						case ge.v:
							return !0;
						default:
							return e
					}
				},
				td = Object(T.c)({
					error: Zc,
					pending: $c,
					showLoader: ed
				});
			var sd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.N:
					case ge.M: {
						if (!t.payload) return null;
						const {
							correlationId: e
						} = t.payload;
						return e
					}
					case ge.g:
					case ge.f:
						return null;
					default:
						return e
				}
			};
			var nd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.u: {
						const {
							id: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var rd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				const s = t.payload;
				switch (t.type) {
					case ge.L:
					case ge.M:
						return s.thingId;
					case ge.t:
					case l.a:
					case ge.f:
						return null;
					default:
						return e
				}
			};
			var ad = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.y:
						return t.payload;
					case ge.x:
					case ge.M:
						return null;
					default:
						return e
				}
			};
			var id = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.s:
						return t.payload;
					case ge.M:
						return !1;
					default:
						return e
				}
			};
			var od = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.L:
						return !0;
					default:
						return e
				}
			};
			var cd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.w:
						return t.payload;
					case ge.M:
						return "";
					default:
						return e
				}
			};
			const dd = Ne.m;
			var ud = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dd,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.hb:
							return t.payload;
						case ge.M: {
							const {
								award: e
							} = t.payload;
							return e || dd
						}
						default:
							return e
					}
				},
				ld = Object(T.c)({
					api: td,
					correlationId: sd,
					gildModalThingId: rd,
					isAnonymous: id,
					isIframed: od,
					message: cd,
					gildedThing: nd,
					giveAwardTooltipThingId: ad,
					selectedAward: ud
				});
			var bd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.z:
						return t.payload.error && t.payload.error.fields && t.payload.error.fields[0] && t.payload.error.fields[0].msg || "An unknown error occurred";
					case ge.g:
					case l.a:
					case ge.N:
					case ge.E:
						return null;
					default:
						return e
				}
			};
			var pd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.g:
						case l.a:
						case ge.E:
						case ge.z:
							return !1;
						case ge.A:
							return !0;
						default:
							return e
					}
				},
				Od = Object(T.c)({
					error: bd,
					pending: pd
				});
			var gd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.N: {
							const {
								profileName: e
							} = t.payload;
							return e
						}
						case l.a:
						case ge.g:
						case ge.E:
							return "";
						default:
							return e
					}
				},
				fd = Object(T.c)({
					api: Od,
					givePremiumModalAccountName: gd
				}),
				md = s("./src/reddit/actions/goldPurchaseModals/constants.ts");
			var jd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.b: {
						const {
							cardName: e
						} = t.payload;
						return e
					}
					case md.x:
						return t.payload !== Ke.wb ? "" : e;
					case md.c:
					case md.d:
					case md.e:
					case md.f:
					case l.a:
						return "";
					default:
						return e
				}
			};
			var _d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.A: {
						const {
							error: s,
							elementType: n
						} = t.payload;
						return "cardCvc" === n ? s && s.message || "" : e
					}
					case md.x:
						return t.payload !== Ke.wb ? "" : e;
					case md.c:
					case md.d:
					case md.e:
					case md.f:
					case l.a:
						return "";
					default:
						return e
				}
			};
			var hd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.A: {
						const {
							error: s,
							elementType: n
						} = t.payload;
						return "cardExpiry" === n ? s && s.message || "" : e
					}
					case md.x:
						return t.payload !== Ke.wb ? "" : e;
					case md.c:
					case md.d:
					case md.e:
					case md.f:
					case l.a:
						return "";
					default:
						return e
				}
			};
			var yd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.A: {
						const {
							error: s,
							elementType: n
						} = t.payload;
						return "cardNumber" === n ? s && s.message || "" : e
					}
					case md.x:
						return t.payload !== Ke.wb ? "" : e;
					case md.c:
					case md.d:
					case md.e:
					case md.f:
					case l.a:
						return "";
					default:
						return e
				}
			};
			var Ed = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.a:
						return t.payload.message || e;
					case md.b:
						return "";
					case md.x:
						return t.payload !== Ke.wb ? "" : e;
					case md.c:
					case md.d:
					case md.e:
					case md.f:
					case l.a:
						return "";
					default:
						return e
				}
			};
			var Id = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.A: {
							const {
								error: s,
								elementType: n
							} = t.payload;
							return "postalCode" === n ? s && s.message || "" : e
						}
						case md.x:
							return t.payload !== Ke.wb ? "" : e;
						case md.c:
						case md.d:
						case md.e:
						case md.f:
						case l.a:
							return "";
						default:
							return e
					}
				},
				vd = Object(T.c)({
					cardCvc: _d,
					cardExpiry: hd,
					cardNumber: yd,
					nameOnCard: Ed,
					postalCode: Id
				});
			const Sd = Ke.xb;
			var Td = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.o:
					case md.p:
					case md.r:
						return Sd;
					case md.x:
						return t.payload;
					default:
						return e
				}
			};
			var wd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.u:
							return t.payload || e;
						case md.x: {
							const {
								method: s
							} = t.payload;
							return s === Ke.xb ? null : e
						}
						case md.o:
						case md.p:
						case md.r:
						case ge.M:
							return null;
						default:
							return e
					}
				},
				Cd = s("./src/reddit/actions/goldPurchaseModals/premiumPurchaseModal.ts");
			var Ad = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.r:
							return "";
						case Cd.a: {
							const e = t.payload;
							return e.body && e.body.passthrough ? e.body.passthrough : ""
						}
						default:
							return e
					}
				},
				Dd = Object(T.c)({
					errorMessage: wd,
					passthrough: Ad
				});
			var Pd = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.D:
						return !e;
					case md.x:
						return t.payload !== Ke.wb || e;
					case md.c:
					case md.d:
					case md.e:
					case l.a:
						return !0;
					default:
						return e
				}
			};
			const Rd = [];
			var kd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.w:
						return t.payload;
					case md.g: {
						const s = t.payload;
						return e.filter(e => e.cardId !== s)
					}
					default:
						return e
				}
			};
			var xd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.v:
						return !0;
					case md.w:
						return !1;
					default:
						return e
				}
			};
			var Nd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.a:
					case md.B:
						return t.payload.message || e;
					case md.z:
						return t.payload;
					case md.A:
					case md.b:
					case md.C:
						return null;
					case md.x:
						return t.payload === Ke.wb ? null : e;
					default:
						return e
				}
			};
			var Ld = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case n.c:
						case md.a:
						case md.z:
						case md.B:
							return !1;
						case md.x:
							return t.payload !== Ke.wb && e;
						case md.C:
							return !0;
						default:
							return e
					}
				},
				Ud = Object(T.c)({
					errorMessage: Nd,
					pending: Ld
				});
			var Md = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.y:
							return t.payload;
						case md.g:
							return t.payload === e ? null : e;
						default:
							return e
					}
				},
				Fd = Object(T.c)({
					cardName: jd,
					cardValidation: vd,
					paymentMethod: Td,
					paypal: Dd,
					rememberCard: Pd,
					savedCards: kd,
					savedCardsPending: xd,
					stripeToken: Ud,
					useSavedCard: Md
				});
			const Gd = {
				pending: !1,
				successful: !1,
				error: !1
			};
			var Bd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gd,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.V:
						return {
							pending: !0, successful: !1, error: !1
						};
					case ge.W:
						return {
							pending: !1, successful: !0, error: !1
						};
					case ge.U:
						return {
							pending: !1, successful: !1, error: !0
						};
					case n.c:
						return Gd;
					default:
						return e
				}
			};
			var qd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.H:
						return t.payload || !1;
					case n.c:
						return !1;
					default:
						return e
				}
			};
			var Vd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.S:
						return t.payload || 1;
					case n.c:
						return 1;
					default:
						return e
				}
			};
			var Hd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case n.c:
							return !1;
						case ge.W:
						case ge.T:
							return !0;
						default:
							return e
					}
				},
				Kd = Object(T.c)({
					freeReallocation: Bd,
					powerupsCount: Vd,
					isAnonymous: qd,
					purchaseCompleted: Hd
				});
			var Wd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "selectPayment",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.r:
						return "selectPayment";
					case md.t:
						return "paymentCompleted";
					default:
						return e
				}
			};
			var Yd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.r:
							return !0;
						case l.a:
						case md.e:
							return !1;
						default:
							return e
					}
				},
				zd = Object(T.c)({
					activePage: Wd,
					showModal: Yd
				});
			var Jd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.h:
					case md.k: {
						const {
							activeSaleConfig: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var Qd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.n:
					case md.m:
					case md.k:
					case md.j:
						return null;
					case md.l:
					case md.i:
						return t.payload;
					default:
						return e
				}
			};
			var Xd = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.l:
					case md.n:
						return !1;
					case md.m:
						return !0;
					default:
						return e
				}
			};
			var Zd = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.i:
						case md.k:
							return !1;
						case md.j:
							return !0;
						default:
							return e
					}
				},
				$d = Object(T.c)({
					errorMessage: Qd,
					recommendedPending: Xd,
					storefrontPending: Zd
				});
			const eu = [];
			var tu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eu,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.k: {
						const {
							dealCoinPackages: e
						} = t.payload;
						return e.map(e => e.mobileId)
					}
					default:
						return e
				}
			};
			const su = {};
			var nu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : su,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.n: {
						const {
							coinPackages: s
						} = t.payload, n = s.reduce((e, t) => (e[t.mobileId] = t, e), {});
						return Object.assign(Object.assign({}, e), n)
					}
					case md.k: {
						const {
							coinPackages: s,
							dealCoinPackages: n
						} = t.payload, r = [...s, ...n].reduce((e, t) => (e[t.mobileId] = t, e), {});
						return Object.assign(Object.assign({}, e), r)
					}
					default:
						return e
				}
			};
			const ru = [];
			var au = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ru,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.n: {
						const {
							coinPackages: e
						} = t.payload;
						return e.map(e => e.mobileId)
					}
					case md.m:
						return ru;
					default:
						return e
				}
			};
			const iu = [];
			var ou = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.k: {
							const {
								coinPackages: e
							} = t.payload;
							return e.map(e => e.mobileId)
						}
						default:
							return e
					}
				},
				cu = Object(T.c)({
					models: nu,
					dealPackageIds: tu,
					recommendedPackageIds: au,
					storefrontPackageIds: ou
				});
			const du = [];
			var uu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : du,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.k:
							return t.payload.premiumPackages;
						default:
							return e
					}
				},
				lu = Object(T.c)({
					activeSaleConfig: Jd,
					api: $d,
					coinPackages: cu,
					premiumPackages: uu
				});
			var bu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "selectPayment",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.o:
					case md.p:
						return "selectPayment";
					case md.t:
						return "paymentCompleted";
					default:
						return e
				}
			};
			var pu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.r:
					case md.s:
					case md.o:
					case md.p: {
						if (!t.payload) return null;
						const {
							correlationId: e
						} = t.payload;
						return e
					}
					case md.e:
					case md.c:
					case md.d:
					case md.t:
						return null;
					default:
						return e
				}
			};
			var Ou = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.c:
					case md.d:
					case ge.f:
					case ge.t:
						return null;
					case md.o: {
						const {
							thingId: e
						} = t.payload;
						return e || null
					}
					case md.q:
						return t.payload && t.payload.thingId ? t.payload.thingId : e;
					default:
						return e
				}
			};
			var gu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case md.o: {
						const {
							packageId: e
						} = t.payload;
						return e
					}
					case md.t:
					case md.c:
						return null;
					default:
						return e
				}
			};
			var fu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.o:
						case md.p:
							return !0;
						case ge.M:
						case l.a:
						case md.c:
						case md.d:
							return !1;
						default:
							return e
					}
				},
				mu = Object(T.c)({
					activePage: bu,
					correlationId: pu,
					gildThingId: Ou,
					packageId: gu,
					showModal: fu
				});
			var ju = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.s: {
							const {
								packageId: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				_u = Object(T.c)({
					packageId: ju
				});
			var hu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case md.E:
						case md.G:
							return !1;
						case md.F:
							return !0;
						default:
							return e
					}
				},
				yu = Object(T.c)({
					pending: hu
				}),
				Eu = Object(T.c)({
					payment: Fd,
					powerupsPurchaseModal: Kd,
					premiumPurchaseModal: zd,
					purchaseCatalog: lu,
					purchaseModal: mu,
					targetedOffer: _u,
					updateCardModal: yu
				}),
				Iu = s("./src/reddit/actions/header.ts"),
				vu = s("./src/reddit/actions/overlayEvents.ts");
			var Su = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Iu.a:
							return !1;
						case Iu.b:
							return !0;
						case Iu.c:
							return !e;
						case vu.b:
							return !1;
						default:
							return e
					}
				},
				Tu = Object(T.c)({
					isSubscriptionsDropdownOpen: Su
				}),
				wu = s("./src/reddit/actions/imageUploads.ts");
			const Cu = {};
			var Au = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wu.d: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.id]: s
							})
						}
						case wu.c:
						case wu.e:
						case wu.b: {
							const s = t.payload;
							return e[s.id] ? Object.assign(Object.assign({}, e), {
								[s.id]: s
							}) : e
						}
						case wu.a: {
							const s = t.payload;
							if (!e[s.id]) return e;
							const n = Object.assign({}, e);
							return delete n[s.id], n
						}
						default:
							return e
					}
				},
				Du = s("./src/reddit/actions/inboxNotifications/constants.ts");
			var Pu = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Du.a: {
						const {
							data: e
						} = t.payload;
						return e
					}
					case Du.c:
					case Du.b:
						return !1;
					default:
						return e
				}
			};
			var Ru = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Du.c:
							return !0;
						case Du.a:
						case Du.b:
							return !1;
						default:
							return e
					}
				},
				ku = Object(T.c)({
					error: Pu,
					pending: Ru
				});
			const xu = [];
			var Nu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Du.b:
							return t.payload;
						default:
							return e
					}
				},
				Lu = Object(T.c)({
					api: ku,
					notifications: Nu
				}),
				Uu = s("./src/reddit/actions/interceptedAction.ts");
			var Mu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Uu.a:
							return t.payload;
						case Uu.b:
							return null;
						default:
							return e
					}
				},
				Fu = s("./src/reddit/actions/changeUsername.ts");
			var Gu = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fu.a:
							return !1;
						case Fu.b:
							return !0;
						default:
							return e
					}
				},
				Bu = s("./src/reddit/actions/emailVerificationTooltip.ts");
			var qu = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bu.a:
							return !e;
						default:
							return e
					}
				},
				Vu = s("./src/reddit/actions/moderatingSubreddits.ts");
			var Hu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Vu.a: {
							if (e) return e;
							const s = t.payload;
							return Object.keys(s).some(e => !0 === s[e].posts)
						}
						case ie.c:
						case Fe.b:
						case te.b:
						case Be.b: {
							if (e) return e;
							const {
								payload: s
							} = t;
							return s.subredditPermissions && s.subreddits ? s.subredditPermissions.posts : e
						}
						case ee.i:
						case ee.f:
						case ee.m:
						case ee.p:
						case ee.v: {
							if (e) return e;
							const {
								response: s
							} = t.payload, {
								moderatingSubreddits: n,
								moderatingProfiles: r
							} = s;
							let a = Object.keys(n).some(e => !0 === n[e].posts);
							if (!a) {
								a = Object.keys(r).some(e => !0 === n[e].posts)
							}
							return a
						}
						default:
							return e
					}
				},
				Ku = s("./src/reddit/actions/jsApi.ts");
			const Wu = [];
			var Yu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ku.a: {
							const s = t.payload;
							return -1 === e.indexOf(s) && (e = [...e, s]).sort(), e
						}
						default:
							return e
					}
				},
				zu = s("./src/reddit/actions/leaderboard/constants.ts"),
				Ju = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const Qu = {};
			var Xu = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qu,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case zu.a: {
							const {
								subredditId: s,
								data: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case zu.b:
						case zu.c: {
							const {
								subredditId: s
							} = t.payload, n = e, r = s;
							n[r];
							return Ju(n, ["symbol" == typeof r ? r : r + ""])
						}
						default:
							return e
					}
				},
				Zu = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const $u = {};
			var el = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $u,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case zu.a:
						case zu.c: {
							const {
								subredditId: s
							} = t.payload, n = e, r = s;
							n[r];
							return Zu(n, ["symbol" == typeof r ? r : r + ""])
						}
						case zu.b: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						default:
							return e
					}
				},
				tl = Object(T.c)({
					error: Xu,
					pending: el
				});
			const sl = {};
			var nl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case zu.c: {
							const {
								subredditId: s,
								data: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				rl = Object(T.c)({
					api: tl,
					models: nl
				});
			var al = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a: {
						const {
							listingKey: s
						} = t.payload;
						return s || e
					}
					default:
						return e
				}
			};
			const il = {};
			var ol = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : il,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case We.b:
					case We.c:
					case ae.b:
					case ae.c: {
						const {
							key: s,
							type: n
						} = t.payload;
						return -1 === n.indexOf(Ke.Nb.Subreddits) && -1 === n.indexOf(Ke.Nb.Users) ? e : Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case We.a:
					case ae.a: {
						const {
							key: s,
							error: n,
							type: r
						} = t.payload;
						return -1 === r.indexOf(Ke.Nb.Subreddits) && -1 === r.indexOf(Ke.Nb.Users) ? e : Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case Le.f:
					case Le.e: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case Le.d: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const cl = {};
			var dl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.b:
						case ae.b: {
							const {
								key: s,
								type: n
							} = t.payload;
							return -1 === n.indexOf(Ke.Nb.Subreddits) && -1 === n.indexOf(Ke.Nb.Users) ? e : Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case We.c:
						case We.a:
						case ae.c:
						case ae.a: {
							const {
								key: s,
								type: n
							} = t.payload;
							return -1 === n.indexOf(Ke.Nb.Subreddits) && -1 === n.indexOf(Ke.Nb.Users) ? e : Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case Le.f: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case Le.e:
						case Le.d: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				ul = Object(T.c)({
					error: ol,
					pending: dl
				});
			const ll = {};
			var bl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ll,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case We.c: {
						const {
							fetchedToken: s,
							key: n,
							type: r
						} = t.payload;
						if (-1 === r.indexOf(Ke.Nb.Subreddits) && -1 === r.indexOf(Ke.Nb.Users)) return e;
						const a = e[n];
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, a), {
								[s]: !0
							})
						})
					}
					case Le.e: {
						const {
							fetchedToken: s,
							key: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								[s]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const pl = {};
			var Ol = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case We.c: {
						const {
							key: s,
							listingOrder: n,
							type: r
						} = t.payload;
						return -1 === r.indexOf(Ke.Nb.Subreddits) && -1 === r.indexOf(Ke.Nb.Users) ? e : Object.assign(Object.assign({}, e), {
							[s]: e[s].concat(n)
						})
					}
					case ae.c: {
						const {
							key: s,
							listingOrder: n,
							type: r
						} = t.payload;
						return -1 === r.indexOf(Ke.Nb.Subreddits) && -1 === r.indexOf(Ke.Nb.Users) ? e : Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const gl = {};
			var fl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.c:
						case ae.c: {
							const {
								key: s,
								tokens: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(Ke.Nb.Subreddits) && -1 === r.indexOf(Ke.Nb.Users) ? e : n.listings ? Object.assign(Object.assign({}, e), {
								[s]: {
									token: n.listings
								}
							}) : Object(Ss.a)(e, s)
						}
						case Le.e: {
							const {
								key: s,
								token: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: {
									token: n
								}
							})
						}
						default:
							return e
					}
				},
				ml = Object(T.c)({
					api: ul,
					identifiers: Ol,
					fetchedTokens: bl,
					loadMore: fl
				}),
				jl = s("./src/reddit/actions/eventPosts/constants.ts"),
				_l = s("./src/reddit/actions/otherDiscussions/constants.ts"),
				hl = s("./src/reddit/actions/pages/topic.ts");
			const yl = {};
			var El = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.h:
						case te.g:
						case te.l:
						case te.k:
						case ie.d:
						case ie.c:
						case Ue.c:
						case Ue.b:
						case Ge.e:
						case Ge.f:
						case Ge.i:
						case Ge.h:
						case Me.s:
						case Me.r:
						case _l.b:
						case _l.c:
						case ne.f:
						case ne.e:
						case ne.c:
						case ne.b:
						case oe.f:
						case oe.e:
						case qe.f:
						case qe.e:
						case ce.j:
						case hl.f:
						case hl.e:
						case hl.c:
						case hl.b:
						case ce.i:
						case jl.e:
						case jl.c:
						case jl.d: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: null
							})
						}
						case ae.b:
						case ae.c:
						case We.b:
						case We.c: {
							const {
								key: s,
								type: n
							} = t.payload;
							return -1 === n.indexOf(Ke.Nb.Posts) ? e : Object.assign(Object.assign({}, e), {
								[s]: null
							})
						}
						case te.f:
						case te.j:
						case ie.a:
						case Ue.a:
						case Ge.g:
						case Me.q:
						case _l.a:
						case ce.h:
						case oe.d:
						case qe.d:
						case ne.d:
						case ne.a:
						case hl.d:
						case hl.a:
						case jl.b: {
							const {
								key: s,
								error: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case ae.a:
						case We.a: {
							const {
								error: s,
								key: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(Ke.Nb.Posts) ? e : Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				Il = s("./src/reddit/actions/linkedPosts/constants.ts"),
				vl = s("./src/reddit/actions/subreddit/constants.ts");
			const Sl = {};
			var Tl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.h:
						case te.l:
						case ne.f:
						case qe.f:
						case ie.d:
						case Ue.c:
						case Ge.f:
						case Ge.i:
						case Me.s:
						case _l.c:
						case oe.f:
						case ne.c:
						case ce.j:
						case hl.c:
						case jl.e: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case ae.b:
						case We.b: {
							const {
								key: s,
								type: n
							} = t.payload;
							return -1 === n.indexOf(Ke.Nb.Posts) ? e : Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case te.g:
						case te.f:
						case te.j:
						case te.k:
						case qe.d:
						case qe.e:
						case ne.d:
						case ne.e:
						case ie.c:
						case ie.a:
						case Ue.b:
						case Ue.a:
						case Il.a:
						case Il.b:
						case Ge.e:
						case Ge.d:
						case Ge.h:
						case Ge.g:
						case Me.r:
						case Me.q:
						case oe.d:
						case oe.e:
						case ne.a:
						case ne.b:
						case vl.h:
						case _l.b:
						case _l.a:
						case ce.i:
						case ce.h:
						case hl.b:
						case hl.a:
						case jl.c:
						case jl.b:
						case jl.d: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case vl.p: {
							if (!t.payload || !t.payload.length) return e;
							const s = {};
							for (const e of t.payload) {
								s[e.key] = !1
							}
							return Object.assign(Object.assign({}, e), s)
						}
						case ae.c:
						case ae.a:
						case We.c:
						case We.a: {
							const {
								key: s,
								type: n
							} = t.payload;
							return -1 === n.indexOf(Ke.Nb.Posts) ? e : Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				wl = Object(T.c)({
					error: El,
					pending: Tl
				}),
				Cl = s("./src/reddit/actions/postList.ts"),
				Al = s("./node_modules/lodash/omitBy.js"),
				Dl = s.n(Al);

			function Pl(e, t) {
				return t = t.toLowerCase(), Dl()(e, (e, s) => s === t || s.startsWith("".concat(t, "--[")))
			}
			const Rl = {};
			var kl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cl.a: {
						const {
							listingKey: s,
							listingName: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case Cl.b: {
						const {
							listingKey: s
						} = t.payload;
						return s in e ? jn()(e, [s]) : e
					}
					case ie.b:
						return Pl(e, t.payload);
					default:
						return e
				}
			};
			const xl = {};
			var Nl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.e:
						case te.g:
						case te.k:
						case ie.c:
						case ne.e:
						case hl.e: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: {}
							})
						}
						case Ue.b:
						case Ge.h:
						case Me.r:
						case oe.e:
						case ne.b:
						case ce.i:
						case hl.b: {
							const {
								key: s,
								fetchedToken: n
							} = t.payload, r = e[s];
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, r), {
									[n]: !0
								})
							})
						}
						case We.c: {
							const {
								fetchedToken: s,
								key: n,
								type: r
							} = t.payload;
							if (r.indexOf(Ke.Nb.Posts) > -1) {
								const t = e[n];
								return Object.assign(Object.assign({}, e), {
									[n]: Object.assign(Object.assign({}, t), {
										[s]: !0
									})
								})
							}
							return e
						}
						case ie.b:
							return Pl(e, t.payload);
						default:
							return e
					}
				},
				Ll = s("./src/reddit/actions/post.ts");
			const Ul = {};
			var Ml = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ul,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.h:
						case Ge.f:
						case te.l:
						case ne.f:
						case ie.d:
						case qe.f:
						case ne.f:
						case hl.f: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: []
							})
						}
						case Le.e:
						case Il.b:
						case Ge.e:
						case te.g:
						case te.k:
						case ie.c:
						case vl.h:
						case _l.b:
						case qe.e:
						case ne.e:
						case "RECOMMENDED_POSTS_LOADED":
						case hl.e:
						case jl.c: {
							const {
								key: s,
								postIds: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case vl.p: {
							if (!t.payload || !t.payload.length) return e;
							const s = {};
							for (const e of t.payload) {
								const t = e;
								s[t.key] = t.postIds
							}
							return Object.assign(Object.assign({}, e), s)
						}
						case Ue.b:
						case Ge.h:
						case Me.r:
						case ne.b:
						case oe.e:
						case ce.i:
						case hl.b:
						case jl.d: {
							const {
								key: s,
								postIds: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: e[s].concat(n)
							})
						}
						case ae.c: {
							const {
								key: s,
								postOrder: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(Ke.Nb.Posts) ? e : Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case We.c: {
							const {
								key: s,
								postOrder: n,
								type: r
							} = t.payload;
							return -1 === r.indexOf(Ke.Nb.Posts) ? e : Object.assign(Object.assign({}, e), {
								[s]: e[s].concat(n)
							})
						}
						case Ll.k: {
							const {
								newStickiedPostList: s,
								listingKey: n
							} = t.payload;
							if (!e[n]) return e;
							const r = [...e[n]].filter(e => !s.includes(e));
							return r.unshift(...s), Object.assign(Object.assign({}, e), {
								[n]: r
							})
						}
						case ie.b:
							return Pl(e, t.payload);
						default:
							return e
					}
				},
				Fl = s("./src/lib/makeListingKey/index.ts"),
				Gl = s("./src/reddit/actions/preferences.ts");
			const Bl = {};
			var ql = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c: {
						const {
							key: s,
							listingSort: n
						} = t.payload;
						return n && !Object(Fl.b)(s) ? Object.assign(Object.assign({}, e), {
							[s]: {
								sort: n,
								hasChanged: !1
							}
						}) : e
					}
					case Gl.a:
					case Gl.q: {
						const t = {};
						return Object.keys(e).forEach(s => {
							t[s] = Object.assign(Object.assign({}, e[s]), {
								hasChanged: !0
							})
						}), t
					}
					default:
						return e
				}
			};
			const Vl = {};
			var Hl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vl,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g:
					case te.k:
					case ie.c:
					case qe.e:
					case ne.e:
					case Ue.b:
					case Ge.e:
					case Ge.h:
					case Me.r:
					case oe.e:
					case ne.b:
					case ce.i:
					case hl.e:
					case hl.b: {
						const {
							key: s,
							token: n,
							dist: r
						} = t.payload;
						return n ? Object.assign(Object.assign({}, e), {
							[s]: {
								token: n,
								dist: r
							}
						}) : Object(Ss.a)(e, s)
					}
					case We.c:
					case ae.c: {
						const {
							key: s,
							tokens: n,
							type: r
						} = t.payload;
						return -1 === r.indexOf(Ke.Nb.Posts) ? e : n.posts ? Object.assign(Object.assign({}, e), {
							[s]: {
								token: n.posts
							}
						}) : Object(Ss.a)(e, s)
					}
					case ie.b:
						return Pl(e, t.payload);
					default:
						return e
				}
			};
			const Kl = {};
			var Wl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kl,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case jl.c:
						case jl.d: {
							const {
								pageInfo: s,
								key: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				Yl = Object(T.c)({
					api: wl,
					endMarkers: kl,
					fetchedTokens: Nl,
					ids: Ml,
					listingSort: ql,
					loadMore: Hl,
					pageInfo: Wl
				}),
				zl = Object(T.c)({
					activeKey: al,
					listingOrder: ml,
					postOrder: Yl
				});
			var Jl = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g: {
						const s = t.payload;
						return Hi()(s.announcements) ? e : s.announcements || null
					}
					default:
						return e
				}
			};
			var Ql = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g: {
						const s = t.payload;
						return Hi()(s.featuredLiveThread) ? e : s.featuredLiveThread || null
					}
					default:
						return e
				}
			};
			var Xl = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.g:
							return !0;
						default:
							return e
					}
				},
				Zl = Object(T.c)({
					announcements: Jl,
					featured: Ql,
					isFrontpageLoaded: Xl
				}),
				$l = s("./src/reddit/actions/media.ts");
			const eb = {};
			var tb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $l.b: {
						const {
							postId: s,
							index: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const sb = {};
			var nb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $l.e: {
							const {
								postId: s,
								isTileLayout: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				rb = Object(T.c)({
					currentSlideIndex: tb,
					isGalleryTileLayout: nb
				});
			var ab = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $l.c:
						return t.payload;
					default:
						return e
				}
			};
			var ib = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $l.d:
							return t.payload;
						default:
							return e
					}
				},
				ob = Object(T.c)({
					isMuted: ab,
					volume: ib
				}),
				cb = s("./src/reddit/actions/meta.ts");
			const db = {
				ampCid: void 0,
				city: "",
				country: "",
				crawler: void 0,
				domain: "",
				isBot: !1,
				isSessionSeo: !1,
				method: "",
				platform: void 0,
				protocol: "",
				region: "",
				sessionReferrerDomain: "",
				userAgent: "",
				pageloadServerTime: 0
			};
			var ub = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : db,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case cb.b:
						return t.payload;
					case cb.a:
						return Object.assign(Object.assign({}, e), t.payload);
					default:
						return e
				}
			};
			const lb = {};
			var bb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Fe.b:
						case te.b:
						case Be.b: {
							const {
								payload: s
							} = t;
							if (!s.subredditPermissions || !s.subreddits) return e;
							const n = Object.keys(s.subredditAboutInfo || {});
							if (1 !== n.length) return e;
							const r = n[0];
							return Object.assign(Object.assign({}, e), {
								[r]: s.subredditPermissions
							})
						}
						case ee.i:
						case ee.f:
						case ee.m:
						case ee.p:
						case ee.v: {
							const {
								response: s
							} = t.payload, {
								moderatingSubreddits: n,
								moderatingProfiles: r
							} = s;
							return Object.assign(Object.assign(Object.assign({}, e), n), r)
						}
						case ce.f:
						case Ge.e:
						case ee.k: {
							const s = t.payload,
								{
									moderatingSubreddits: n,
									moderatingProfiles: r
								} = s;
							return Object.assign(Object.assign(Object.assign({}, e), n), r)
						}
						case w.R: {
							const {
								subredditId: s
							} = t.payload;
							return Object(Ss.a)(e, s)
						}
						case w.O: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				pb = s("./src/reddit/actions/moderationLog/constants.ts");
			const Ob = {};
			var gb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ob,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pb.b: {
						const {
							actionIds: s,
							key: n,
							subredditId: r
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, e[r] || {}), {
								[n]: s
							})
						})
					}
					default:
						return e
				}
			};
			const fb = {};
			var mb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pb.b: {
							const {
								normalizedModerationLog: s,
								subredditId: n
							} = t.payload, r = {};
							s.forEach(e => {
								r[e.id] = e
							});
							const a = {
								[n]: r
							};
							return Re()(Object.assign({}, e), a)
						}
						default:
							return e
					}
				},
				jb = Object(T.c)({
					itemOrder: gb,
					models: mb
				});
			var _b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pb.b: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const hb = {};
			var yb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pb.b: {
						const {
							hasNextPage: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Eb = {};
			var Ib = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Eb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pb.b: {
						const {
							hasPreviousPage: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const vb = [];
			var Sb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case pb.a: {
						const {
							normalizedModerators: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			var Tb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pb.b: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				wb = Object(T.c)({
					actions: jb,
					endCursor: _b,
					hasNextPage: yb,
					hasPreviousPage: Ib,
					moderators: Sb,
					startCursor: Tb
				});
			var Cb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ll.e:
						return t.payload;
					case Ll.d:
						return null
				}
				return e
			};
			const Ab = {};
			var Db = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ab,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.E:
					case w.s: {
						const {
							subredditId: s,
							moderators: n
						} = t.payload.response || t.payload, r = {
							[s]: n
						};
						return Object(U.merge)(e, r)
					}
					case w.u: {
						const {
							subredditId: s,
							userId: n,
							permissions: r
						} = t.payload;
						return Object(U.setIn)(e, [s, n, "modPermissions"], r)
					}
					case w.Q: {
						const {
							subredditId: s,
							userId: n
						} = t.payload;
						return Object(U.unsetIn)(e, [s, n])
					}
					default:
						return e
				}
			};
			const Pb = {};
			var Rb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.t:
					case w.s: {
						const {
							key: s,
							subredditId: n
						} = t.payload;
						return n ? Object.assign(Object.assign({}, e), {
							[s]: null
						}) : e
					}
					case w.r: {
						const {
							error: s,
							key: n,
							subredditId: r
						} = t.payload;
						return r ? Object.assign(Object.assign({}, e), {
							[n]: s
						}) : e
					}
					default:
						return e
				}
			};
			const kb = {};
			var xb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.r:
						case w.s: {
							const {
								subredditId: s,
								key: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[n]: !1
							}) : e
						}
						case w.t: {
							const {
								subredditId: s,
								key: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[n]: !0
							}) : e
						}
						default:
							return e
					}
				},
				Nb = Object(T.c)({
					error: Rb,
					pending: xb
				});
			const Lb = {};
			var Ub = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.s: {
							const {
								subredditId: s,
								response: n,
								key: r
							} = t.payload;
							return Object(U.setIn)(e, [s, r], n.moderatorIds)
						}
						case w.Q: {
							const {
								subredditId: s,
								userId: n,
								key: r
							} = t.payload, a = e[s][r].filter(e => e !== n);
							return Object(U.setIn)(e, [s, r], a)
						}
						default:
							return e
					}
				},
				Mb = Object(T.c)({
					data: Ub,
					api: Nb
				});
			var Fb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.x:
					case w.w:
						return null;
					case w.v:
						return t.payload;
					default:
						return e
				}
			};
			var Gb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.w:
						case w.v:
							return !1;
						case w.x:
							return !0;
						default:
							return e
					}
				},
				Bb = Object(T.c)({
					error: Fb,
					pending: Gb
				});
			const qb = {};
			var Vb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.w: {
						const {
							subredditId: s,
							moderators: n
						} = t.payload;
						return Object(U.set)(e, s, n)
					}
					case w.P: {
						const {
							subredditId: s,
							userId: n
						} = t.payload;
						return Object(U.unsetIn)(e, [s, n])
					}
					case w.a: {
						const s = t.payload,
							{
								subredditId: n,
								moderators: r
							} = s,
							a = {
								[n]: r
							};
						return Object(U.merge)(e, a)
					}
					default:
						return e
				}
			};
			const Hb = {};
			var Kb = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hb,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.w: {
							const {
								subredditId: s,
								moderatorIds: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case w.P: {
							const {
								subredditId: s,
								userId: n
							} = t.payload, r = e[s].filter(e => e !== n);
							return Object.assign(Object.assign({}, e), {
								[s]: r
							})
						}
						case w.a: {
							const s = t.payload,
								{
									subredditId: n,
									moderatorIds: r
								} = s,
								a = [...e[n] || [], ...r];
							return Object.assign(Object.assign({}, e), {
								[n]: a
							})
						}
						default:
							return e
					}
				},
				Wb = Object(T.c)({
					api: Bb,
					models: Vb,
					userOrder: Kb
				});
			const Yb = {};
			var zb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							subredditId: s,
							response: n
						} = t.payload, {
							invitePending: r
						} = n, a = {
							[s]: r
						};
						return Object(U.merge)(e, a)
					}
					case w.y:
					case w.z: {
						const {
							subredditId: s
						} = t.payload;
						return Object(U.unset)(e, s)
					}
					default:
						return e
				}
			};
			const Jb = {};
			var Qb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.s: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Xb = {};
			var Zb = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xb,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const $b = {};
			var ep = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $b,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.B: {
						const {
							response: s
						} = t.payload, n = {
							[s.subredditId]: s.moderators
						};
						return Object(U.merge)(Object.assign({}, e), n)
					}
					case w.u: {
						const s = t.payload,
							{
								subredditId: n,
								userId: r,
								permissions: a
							} = s;
						return e[n] && e[n][r] ? Object(U.setIn)(e, [n, r, "modPermissions"], a) : e
					}
					default:
						return e
				}
			};
			var tp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.F:
					case w.E:
						return null;
					case w.D:
						return t.payload;
					default:
						return e
				}
			};
			var sp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.F:
							return !0;
						case w.E:
						case w.D:
							return !1;
						default:
							return e
					}
				},
				np = Object(T.c)({
					error: tp,
					pending: sp
				});
			var rp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.F:
						case w.D:
						case w.Q:
							return null;
						case w.E: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case w.u: {
							const {
								userId: s,
								permissions: n
							} = t.payload;
							return e && e.id === s && !fn()(e.modPermissions, n) ? Object.assign(Object.assign({}, e), {
								modPermissions: n
							}) : e
						}
						default:
							return e
					}
				},
				ap = Object(T.c)({
					api: np,
					result: rp
				});
			const ip = {};
			var op = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ip,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.C:
					case w.B: {
						const {
							subredditId: s,
							key: n
						} = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[n]: null
						}) : e
					}
					case w.A: {
						const {
							error: s,
							subredditId: n,
							key: r
						} = t.payload;
						return n ? Object.assign(Object.assign({}, e), {
							[r]: s
						}) : e
					}
					default:
						return e
				}
			};
			const cp = {};
			var dp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.A:
						case w.B: {
							const {
								subredditId: s,
								key: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[n]: !1
							}) : e
						}
						case w.C: {
							const {
								subredditId: s,
								key: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[n]: !0
							}) : e
						}
						default:
							return e
					}
				},
				up = Object(T.c)({
					error: op,
					pending: dp
				});
			const lp = {};
			var bp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.B: {
							const {
								response: s,
								subredditId: n,
								key: r
							} = t.payload, {
								moderatorIds: a
							} = s;
							return Object(U.merge)(e, {
								[n]: {
									[r]: a
								}
							})
						}
						case w.Q: {
							const {
								subredditId: s,
								userId: n
							} = t.payload, r = Object.assign({}, e[s]);
							return Object.keys(e[s]).forEach(t => {
								const a = e[s][t].filter(e => e !== n);
								r[t] = a
							}), Object(U.set)(e, s, r)
						}
						default:
							return e
					}
				},
				pp = Object(T.c)({
					data: bp,
					api: up
				}),
				Op = Object(T.c)({
					editableModerators: Db,
					editableUserOrder: Mb,
					invitedModerators: Wb,
					invitePending: zb,
					loadMoreModerators: Zb,
					loadMoreEditableModerators: Qb,
					models: ep,
					search: ap,
					userOrder: pp
				});
			var gp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.b:
					case Ge.k:
						return null;
					case Ge.a:
					case Ge.j:
						return t.payload;
					default:
						return e
				}
			};
			var fp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.b:
						case Ge.k:
							return !0;
						case Ge.c:
						case Ge.a:
						case Ge.l:
						case Ge.j:
							return !1;
						default:
							return e
					}
				},
				mp = Object(T.c)({
					error: gp,
					pending: fp
				});
			const jp = [];
			var _p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.e: {
							const s = t.payload,
								{
									filteredSubreddits: n
								} = s;
							return n || e
						}
						case Ge.j: {
							const s = t.payload;
							return [...e, s]
						}
						case Ge.k:
						case Ge.a: {
							const s = t.payload;
							return e.filter(e => e !== s)
						}
						default:
							return e
					}
				},
				hp = Object(T.c)({
					api: mp,
					names: _p
				}),
				yp = Object(T.c)({
					filteredSubreddits: hp
				});
			var Ep = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hn.a:
						return t.payload.enabled;
					default:
						return e
				}
			};
			var Ip = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _n.c:
					case _n.b:
						return null;
					case _n.a:
						return t.payload;
					default:
						return e
				}
			};
			var vp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _n.c:
							return !0;
						case _n.b:
						case _n.a:
						case ee.s:
						case ee.r:
							return !1;
						default:
							return e
					}
				},
				Sp = Object(T.c)({
					error: Ip,
					pending: vp
				});
			const Tp = {};
			var wp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.a: {
						const {
							ids: s
						} = t.payload, n = {};
						return s.forEach(e => n[e] = !0), Object.assign(Object.assign({}, e), n)
					}
					case ee.d: {
						const {
							ids: s
						} = t.payload;
						return jn()(e, s)
					}
					case ee.c: {
						const {
							ids: e
						} = t.payload, s = {};
						return e.forEach(e => s[e] = !0), s
					}
					default:
						return e
				}
			};
			const Cp = {};
			var Ap = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case _n.b: {
							const {
								operation: e,
								ids: s
							} = t.payload;
							return "approve" === e ? Cp : {
								[Tn.c[e]]: s
							}
						}
						default:
							return e
					}
				},
				Dp = Object(T.c)({
					api: Sp,
					selectedItems: wp,
					undoLastAction: Ap
				});
			var Pp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.g:
					case ee.f:
						return null;
					case ee.e:
						return t.payload;
					default:
						return e
				}
			};
			var Rp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.g:
							return !0;
						case ee.f:
						case ee.e:
							return !1;
						default:
							return e
					}
				},
				kp = Object(T.c)({
					error: Pp,
					pending: Rp
				});
			const xp = {};
			var Np = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.f: {
						const {
							listingKey: s,
							page: n,
							response: r
						} = t.payload, {
							modqueue: a
						} = r;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s] || {}), {
								[n]: a
							})
						})
					}
					default:
						return e
				}
			};
			const Lp = {};
			var Up = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.f: {
							const {
								listingKey: s,
								response: n
							} = t.payload, {
								modqueue: r
							} = n, a = r[r.length - 1] || null;
							return Object.assign(Object.assign({}, e), {
								[s]: a
							})
						}
						default:
							return e
					}
				},
				Mp = Object(T.c)({
					api: kp,
					itemOrder: Np,
					loadMore: Up
				});
			var Fp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ge.e: {
						const s = t.payload,
							{
								moderatingSubreddits: n
							} = s;
						return n ? null : e
					}
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: s
						} = e;
						return s
					}
					case ee.k: {
						const e = t.payload,
							{
								moderatedAfter: s
							} = e;
						return s
					}
					default:
						return e
				}
			};
			const Gp = [];
			var Bp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v: {
						const {
							response: e
						} = t.payload, {
							listingOrder: s
						} = e;
						return s
					}
					case ee.k: {
						const s = t.payload,
							{
								listingOrder: n
							} = s;
						return [...e, ...n]
					}
					case Ge.e: {
						const s = t.payload,
							{
								listingOrder: n
							} = s;
						return n || e
					}
					default:
						return e
				}
			};
			var qp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.b:
						return !0;
					default:
						return e
				}
			};
			var Vp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.k:
							return !0;
						case ee.b:
							return !1;
						default:
							return e
					}
				},
				Hp = Object(T.c)({
					after: Fp,
					data: Bp,
					loaded: qp,
					pending: Vp
				});
			var Kp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.j:
					case ee.i:
						return null;
					case ee.h:
						return t.payload;
					default:
						return e
				}
			};
			var Wp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.j:
							return !0;
						case ee.i:
						case ee.h:
							return !1;
						default:
							return e
					}
				},
				Yp = Object(T.c)({
					error: Kp,
					pending: Wp
				});
			const zp = {};
			var Jp = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zp,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.i: {
						const {
							listingKey: s,
							page: n,
							response: r
						} = t.payload, {
							modqueue: a
						} = r;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s] || {}), {
								[n]: a
							})
						})
					}
					default:
						return e
				}
			};
			const Qp = {};
			var Xp = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qp,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.i: {
							const {
								listingKey: s,
								response: n
							} = t.payload, {
								modqueue: r
							} = n, a = r[r.length - 1] || null;
							return Object.assign(Object.assign({}, e), {
								[s]: a
							})
						}
						default:
							return e
					}
				},
				Zp = Object(T.c)({
					api: Yp,
					itemOrder: Jp,
					loadMore: Xp
				});
			var $p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.n:
					case ee.m:
						return null;
					case ee.l:
						return t.payload;
					default:
						return e
				}
			};
			var eO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.n:
							return !0;
						case ee.m:
						case ee.l:
							return !1;
						default:
							return e
					}
				},
				tO = Object(T.c)({
					error: $p,
					pending: eO
				});
			const sO = {};
			var nO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.m: {
						const {
							listingKey: s,
							page: n,
							response: r
						} = t.payload, {
							modqueue: a
						} = r;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s] || {}), {
								[n]: a
							})
						})
					}
					default:
						return e
				}
			};
			const rO = {};
			var aO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.m: {
							const {
								listingKey: s,
								response: n
							} = t.payload, {
								modqueue: r
							} = n, a = r[r.length - 1] || null;
							return Object.assign(Object.assign({}, e), {
								[s]: a
							})
						}
						default:
							return e
					}
				},
				iO = Object(T.c)({
					api: tO,
					itemOrder: nO,
					loadMore: aO
				});
			var oO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.q:
					case ee.p:
						return null;
					case ee.o:
						return t.payload;
					default:
						return e
				}
			};
			var cO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.q:
							return !0;
						case ee.p:
						case ee.o:
							return !1;
						default:
							return e
					}
				},
				dO = Object(T.c)({
					error: oO,
					pending: cO
				});
			const uO = {};
			var lO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.p: {
						const {
							listingKey: s,
							page: n,
							response: r
						} = t.payload, {
							modqueue: a
						} = r;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s] || {}), {
								[n]: a
							})
						})
					}
					default:
						return e
				}
			};
			const bO = {};
			var pO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.p: {
							const {
								listingKey: s,
								response: n
							} = t.payload, {
								modqueue: r
							} = n, a = r[r.length - 1] || null;
							return Object.assign(Object.assign({}, e), {
								[s]: a
							})
						}
						default:
							return e
					}
				},
				OO = Object(T.c)({
					api: dO,
					itemOrder: lO,
					loadMore: pO
				});
			var gO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.w:
					case ee.v:
						return null;
					case ee.u:
						return t.payload;
					default:
						return e
				}
			};
			var fO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.w:
							return !0;
						case ee.v:
						case ee.u:
							return !1;
						default:
							return e
					}
				},
				mO = Object(T.c)({
					error: gO,
					pending: fO
				});
			const jO = {};
			var _O = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ee.v: {
						const {
							listingKey: s,
							page: n,
							response: r
						} = t.payload, {
							modqueue: a
						} = r;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s] || {}), {
								[n]: a
							})
						})
					}
					default:
						return e
				}
			};
			const hO = {};
			var yO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ee.v: {
							const {
								listingKey: s,
								response: n
							} = t.payload, {
								modqueue: r
							} = n, a = r[r.length - 1] || null;
							return Object.assign(Object.assign({}, e), {
								[s]: a
							})
						}
						default:
							return e
					}
				},
				EO = Object(T.c)({
					api: mO,
					itemOrder: _O,
					loadMore: yO
				}),
				IO = Object(T.c)({
					bulkAction: Dp,
					edited: Mp,
					moderatedCommunitiesOrder: Hp,
					modqueue: Zp,
					reports: iO,
					spam: OO,
					unmoderated: EO
				}),
				vO = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const SO = {};
			var TO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SO,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case X.v: {
						const {
							moreCommentsId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case X.u: {
						const {
							moreCommentsItem: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.id]: null
						})
					}
					case X.t: {
						const s = t.payload,
							{
								moreCommentsItem: n
							} = s,
							r = vO(s, ["moreCommentsItem"]);
						return Object.assign(Object.assign({}, e), {
							[n.id]: r || {}
						})
					}
					default:
						return e
				}
			};
			const wO = {};
			var CO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case X.v: {
							const {
								moreCommentsId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case X.t:
						case X.u: {
							const {
								moreCommentsItem: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.id]: !1
							})
						}
						default:
							return e
					}
				},
				AO = Object(T.c)({
					error: TO,
					pending: CO
				});
			const DO = {};
			var PO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DO,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Z.b:
							const {
								comment: s, parentCommentId: n, depth: r, originId: a, isChatSort: i
							} = t.payload;
							if (!i) {
								if (a) {
									const t = "moreComments-" + a,
										i = e[t],
										o = s.id.split("_")[1];
									if (i) {
										const s = i.numComments + 1;
										if (i.depth && r === i.depth) {
											const n = atob(i.token).concat(", ", o);
											return Object.assign(Object.assign({}, e), {
												[t]: Object.assign(Object.assign({}, i), {
													numComments: s,
													token: btoa(n)
												})
											})
										}
										return Object.assign(Object.assign({}, e), {
											[t]: Object.assign(Object.assign({}, i), {
												numComments: s
											})
										})
									}
									return Object.assign(Object.assign({}, e), {
										[t]: {
											id: t,
											depth: r,
											parentId: n,
											token: btoa(o),
											numComments: 1,
											next: null,
											prev: Object(In.f)(n),
											postId: s.postId,
											isFromLiveWebSocket: !0
										}
									})
								}
								return e
							}
							return Object.assign(Object.assign({}, e), t.payload.moreComments);
						case X.u:
						case Fe.b:
						case te.b:
							return Object.assign(Object.assign({}, e), t.payload.moreComments);
						default:
							return e
					}
				},
				RO = Object(T.c)({
					api: AO,
					models: PO
				});
			var kO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.b:
					case Me.c:
						return null;
					case Me.a:
						return t.payload;
					default:
						return e
				}
			};
			var xO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.a:
					case Me.c:
						return !0;
					case Me.b:
						return !1;
					default:
						return e
				}
			};
			var NO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.k:
						case Me.a:
						case Me.c:
							return null;
						case Me.b: {
							const {
								name: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				LO = Object(T.c)({
					error: kO,
					fetched: xO,
					pending: NO
				});
			var UO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.f:
					case Me.g:
						return null;
					case Me.e:
						return t.payload;
					default:
						return e
				}
			};
			var MO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.e:
					case Me.g:
						return !0;
					case Me.f:
						return !1;
					default:
						return e
				}
			};
			var FO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.e:
						case Me.g:
							return !1;
						case Me.f:
							return !0;
						default:
							return e
					}
				},
				GO = Object(T.c)({
					error: UO,
					fetched: MO,
					pending: FO
				});
			var BO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.i:
					case Me.j:
						return null;
					case Me.h:
						return t.payload;
					default:
						return e
				}
			};
			var qO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.h:
					case Me.j:
						return !0;
					case Me.i:
						return !1;
					default:
						return e
				}
			};
			var VO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.h:
						case Me.j:
							return !1;
						case Me.i:
							return !0;
						default:
							return e
					}
				},
				HO = Object(T.c)({
					error: BO,
					fetched: qO,
					pending: VO
				});
			var KO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.l:
					case Me.m:
						return null;
					case Me.k:
						return t.payload;
					default:
						return e
				}
			};
			var WO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.k:
					case Me.m:
						return !0;
					case Me.l:
						return !1;
					default:
						return e
				}
			};
			var YO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.k:
						case Me.m:
							return !1;
						case Me.l:
							return !0;
						default:
							return e
					}
				},
				zO = Object(T.c)({
					error: KO,
					fetched: WO,
					pending: YO
				});
			var JO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.o:
					case Me.p:
						return null;
					case Me.n:
						return t.payload;
					default:
						return e
				}
			};
			var QO = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.n:
					case Me.p:
						return !0;
					case Me.o:
						return !1;
					default:
						return e
				}
			};
			var XO = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.n:
						case Me.p:
							return !1;
						case Me.o:
							return !0;
						default:
							return e
					}
				},
				ZO = Object(T.c)({
					error: JO,
					fetched: QO,
					pending: XO
				});
			var $O = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.t:
						return !1;
					case Me.u:
						return !0;
					default:
						return e
				}
			};
			var eg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.t:
							return !0;
						case Me.u:
							return !1;
						default:
							return e
					}
				},
				tg = Object(T.c)({
					fetched: $O,
					pending: eg
				});
			var sg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.A:
					case Me.B:
						return null;
					case Me.z:
						return t.payload;
					default:
						return e
				}
			};
			var ng = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.A:
					case Me.z:
						return !1;
					case Me.B:
						return !0;
					default:
						return e
				}
			};
			var rg = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.A:
							return !0;
						case Me.B:
						case Me.z:
							return !1;
						default:
							return e
					}
				},
				ag = Object(T.c)({
					error: sg,
					fetched: ng,
					pending: rg
				});
			var ig = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.w:
					case Me.x:
						return null;
					case Me.v:
						return t.payload;
					default:
						return e
				}
			};
			var og = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Me.v:
					case Me.x:
						return !0;
					case Me.w:
						return !1;
					default:
						return e
				}
			};
			var cg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.v:
						case Me.x:
							return null;
						case Me.w:
							const {
								id: s
							} = t.payload;
							return s;
						default:
							return e
					}
				},
				dg = Object(T.c)({
					error: ig,
					fetched: og,
					pending: cg
				}),
				ug = Object(T.c)({
					addSubreddit: LO,
					create: GO,
					deleteMulti: HO,
					duplicate: zO,
					edit: ZO,
					forUser: tg,
					recommendations: ag,
					removeSubreddit: dg
				}),
				lg = s("./node_modules/lodash/union.js"),
				bg = s.n(lg);

			function pg(e, t, s) {
				let n, r, a = e.length - 1,
					i = 0;
				for (; i <= a;) {
					const o = s(n = e[r = (i + a) / 2 | 0], t);
					if (o < 0) {
						if ((i = r + 1) > a) return i
					} else {
						if (!(o > 0)) return r;
						if ((a = r - 1) < i) return a + 1
					}
				}
				return (i + a) / 2 | 0
			}
			var Og = s("./src/reddit/actions/profile/constants.ts");
			const gg = {};
			var fg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case te.k:
						case Me.r:
						case Me.u:
						case Og.h: {
							const {
								multireddits: s,
								multiredditsByUser: n,
								multiredditsModelsState: r
							} = t.payload, a = Object.assign({}, e), i = Object.assign(Object.assign({}, s), r);
							for (const t in n) {
								const s = n[t],
									r = e[t];
								a[t] = bg()(r, s).sort((e, t) => i[e].displayText.toLowerCase() > i[t].displayText.toLowerCase() ? 1 : -1)
							}
							return fn()(e, a) ? e : a
						}
						case Me.g:
						case Me.m: {
							const {
								userId: s,
								multireddit: n
							} = t.payload, r = e[s] ? e[s].slice() : [], a = pg(r, n.url, (e, t) => e > t ? 1 : -1);
							return r.splice(a, 0, n.url), Object.assign(Object.assign({}, e), {
								[s]: r
							})
						}
						case Me.j: {
							const s = t.payload;
							for (const t in e) {
								const n = e[t];
								if (n.indexOf(s) > -1) return Object.assign(Object.assign({}, e), {
									[t]: n.filter(e => e !== s)
								})
							}
							return e
						}
						default:
							return e
					}
				},
				mg = s("./src/reddit/actions/subscription/constants.ts"),
				jg = s("./src/reddit/models/Multireddit/index.ts");
			const _g = {};
			var hg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _g,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.k:
					case Me.r:
					case Me.u:
					case Og.h: {
						let s = {};
						for (const n in t.payload.multireddits) {
							const r = Object.assign({}, t.payload.multireddits[n]),
								a = e[n];
							a && !Object(jg.g)(r) && (r.subredditIds = a.subredditIds, r.profileIds = a.profileIds), n in e && fn()(e[r.url], r) || (s = Object.assign(Object.assign({}, s), {
								[n]: r
							}))
						}
						return Hi()(s) ? e : Object.assign(Object.assign({}, e), s)
					}
					case Me.g:
					case Me.m: {
						const {
							multireddit: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.url]: s
						})
					}
					case Me.j: {
						const s = t.payload,
							n = Object.assign({}, e);
						return delete n[s], n
					}
					case Me.p: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.url]: s
						})
					}
					case Me.x: {
						const {
							id: s,
							multipath: n,
							type: r
						} = t.payload, a = e[n], i = "subreddit" === r ? (a.subredditIds || []).filter(e => e !== s) : a.subredditIds, o = "profile" === r ? (a.profileIds || []).filter(e => e !== s) : a.profileIds;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, a), {
								profileIds: o,
								subredditIds: i
							})
						})
					}
					case mg.d: {
						const {
							makeFavorite: s,
							multiredditPath: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								isFavorited: s
							})
						})
					}
					case mg.e: {
						const {
							follow: s,
							multiredditPath: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								isFollowed: s,
								isFavorited: !1
							})
						})
					}
					case Me.c: {
						const {
							id: s,
							multipaths: n,
							type: r
						} = t.payload, a = n.reduce((t, n) => {
							const a = e[n],
								i = "subreddit" === r ? [...a.subredditIds || [], s] : a.subredditIds,
								o = "profile" === r ? [...a.profileIds || [], s] : a.profileIds;
							return Object.assign(Object.assign({}, t), {
								[n]: Object.assign(Object.assign({}, a), {
									subredditIds: i,
									profileIds: o
								})
							})
						}, {});
						return Object.assign(Object.assign({}, e), a)
					}
					default:
						return e
				}
			};
			const yg = {};
			var Eg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.B: {
							const {
								multipath: s,
								subreddits: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.keys(n)
							})
						}
						default:
							return e
					}
				},
				Ig = Object(T.c)({
					api: ug,
					byUserId: fg,
					models: hg,
					recommendations: Eg
				});
			var vg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.J:
					case w.H:
						return null;
					case w.G:
						return t.payload;
					default:
						return e
				}
			};
			const Sg = {};
			var Tg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.J: {
							const {
								subredditId: s,
								fetchedToken: n
							} = t.payload, r = Object(A.d)(s, n);
							return Object.assign(Object.assign({}, e), {
								[r]: !0
							})
						}
						case w.H:
						case w.G: {
							const {
								subredditId: s,
								fetchedToken: n
							} = t.payload, r = Object(A.d)(s, n);
							return Object.assign(Object.assign({}, e), {
								[r]: !1
							})
						}
						default:
							return e
					}
				},
				wg = Object(T.c)({
					error: vg,
					pending: Tg
				});
			const Cg = {};
			var Ag = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.H: {
						const {
							fetchedToken: s,
							subredditId: n
						} = t.payload, r = Object(A.d)(n, s);
						return Object.assign(Object.assign({}, e), {
							[r]: !0
						})
					}
					default:
						return e
				}
			};
			var Dg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case At.b:
						return t.payload;
					default:
						return e
				}
			};
			const Pg = {};
			var Rg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.H: {
						const {
							subredditId: e,
							after: s
						} = t.payload;
						return {
							[e]: s
						}
					}
					default:
						return e
				}
			};
			const kg = {};
			var xg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.I:
					case w.H: {
						const {
							subredditId: s,
							mutedUsers: n
						} = t.payload, r = {
							[s]: n
						};
						return Object(U.merge)(e, r)
					}
					case w.N: {
						const {
							subredditId: s,
							userId: n
						} = t.payload;
						return Object(U.unsetIn)(e, [s, n])
					}
					default:
						return e
				}
			};
			var Ng = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case w.M:
					case w.L:
						return null;
					case w.K:
						return t.payload;
					default:
						return e
				}
			};
			var Lg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.M:
							return !0;
						case w.L:
						case w.K:
							return !1;
						default:
							return e
					}
				},
				Ug = Object(T.c)({
					error: Ng,
					pending: Lg
				});
			var Mg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.M:
						case w.K:
							return null;
						case w.L: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				Fg = Object(T.c)({
					api: Ug,
					result: Mg
				});
			const Gg = {};
			var Bg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case w.H: {
							const {
								subredditId: s,
								mutedUserIds: n
							} = t.payload;
							return e[s] ? Object.assign(Object.assign({}, e), {
								[s]: [...e[s], ...n]
							}) : Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case w.N: {
							const {
								subredditId: s,
								userId: n
							} = t.payload;
							return {
								[s]: e[s].filter(e => e !== n)
							}
						}
						case w.I: {
							const {
								subredditId: s,
								mutedUserIds: n
							} = t.payload, r = n[0];
							return r && e[s] && -1 === e[s].indexOf(r) ? {
								[s]: [r, ...e[s]]
							} : e
						}
						default:
							return e
					}
				},
				qg = Object(T.c)({
					api: wg,
					fetchedTokens: Ag,
					inContext: Dg,
					loadMore: Rg,
					models: xg,
					search: Fg,
					userOrder: Bg
				}),
				Vg = s("./src/reddit/actions/notificationBanner.ts");
			var Hg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Vg.b:
							return t.payload.notificationBannerId;
						case Vg.a:
							return null;
						default:
							return e
					}
				},
				Kg = s("./src/reddit/actions/nps.ts");
			const Wg = {
				pending: !1,
				success: !1,
				dest: void 0
			};
			var Yg = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wg,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Kg.c:
							return Object.assign(Object.assign({}, Wg), {
								pending: !0
							});
						case Kg.a:
							return Wg;
						case Kg.b: {
							const {
								dest: e
							} = t.payload;
							return Object.assign(Object.assign({}, Wg), {
								success: !0,
								dest: e
							})
						}
						default:
							return e
					}
				},
				zg = s("./src/reddit/actions/oldSiteRules.ts");
			const Jg = [];
			var Qg = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jg,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case zg.a:
						return t.payload.oldSiteRules;
					default:
						return e
				}
			};
			const Xg = e => {
				const {
					id: t,
					experimentName: s,
					name: n,
					version: r
				} = e;
				return {
					id: parseInt(t),
					name: s,
					variant: n || void 0,
					version: r
				}
			};
			const Zg = e => {
					const t = {};
					for (const s of e) t[s.experimentName.toLowerCase()] = Xg(s);
					return t
				},
				$g = {};
			var ef = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $g,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case No.a: {
						const {
							pageExperimentVariants: e
						} = t.payload, s = e ? e.experiments : [];
						return Zg(s)
					}
					default:
						return e
				}
			};
			var tf = Object(T.c)({
					byName: ef,
					canonicalUrl: function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 ? arguments[1] : void 0;
						switch (t.type) {
							case No.a: {
								const {
									pageExperimentVariants: e
								} = t.payload;
								return e && e.canonicalUrl ? e.canonicalUrl : null
							}
							default:
								return e
						}
					}
				}),
				sf = Object(T.c)({
					experiments: tf
				}),
				nf = s("./node_modules/history/esm/history.js"),
				rf = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const af = {
					allowNavigationCallback: null,
					currentPage: null,
					lastPage: null,
					referrers: {},
					sessionReferrer: null,
					metas: {}
				},
				of = (e, t) => ({
					key: e,
					locationState: {},
					meta: null,
					queryParams: {},
					routeMatch: null,
					status: 404,
					url: t,
					urlParams: {}
				}),
				cf = (e, t, s, n) => {
					const r = s.route,
						{
							action: a
						} = r,
						i = rf(r, ["action"]);
					return {
						key: e,
						locationState: n.state,
						meta: s.route.meta,
						queryParams: s.match.queryParams,
						routeMatch: Object.assign(Object.assign({}, s), {
							route: i
						}),
						status: 200,
						url: t,
						urlParams: s.match.params
					}
				};
			var df = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : af,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a: {
							const s = e.currentPage,
								n = t.payload,
								{
									routeMatch: r,
									location: a
								} = n,
								{
									key: i
								} = a;
							if (void 0 === i) return e;
							const o = Object(nf.e)(a),
								c = r ? cf(i, o, r, a) : of (i, o);
							let {
								referrers: d
							} = e;
							if ("PUSH" === n.action) {
								const e = s && s.url || "";
								d = Object.assign(Object.assign({}, d), {
									[i]: e
								})
							} else if ("REPLACE" === n.action && s && d[s.key]) {
								const e = d,
									t = s.key,
									n = e[t],
									r = rf(e, ["symbol" == typeof t ? t : t + ""]);
								d = Object.assign(Object.assign({}, r), {
									[i]: n
								})
							}
							return Object.assign(Object.assign({}, e), {
								referrers: d,
								currentPage: c,
								lastPage: s
							})
						}
						case l.e: {
							const s = t.payload,
								{
									key: n,
									meta: r
								} = s;
							return Object.assign(Object.assign({}, e), {
								metas: Object.assign(Object.assign({}, e.metas), {
									[n]: r
								})
							})
						}
						case l.f: {
							if (!e.currentPage) return e;
							const s = t.payload,
								n = Object.assign(Object.assign({}, e.currentPage), {
									status: s
								});
							return Object.assign(Object.assign({}, e), {
								currentPage: n
							})
						}
						case Fe.b:
						case te.b:
							return !e.currentPage || t.payload.postMeta, e;
						case l.b:
							return e;
						case l.d: {
							const {
								allowNavigationCallback: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								allowNavigationCallback: s
							})
						}
						case l.c:
							return Object.assign(Object.assign({}, e), {
								allowNavigationCallback: null
							});
						default:
							return e
					}
				},
				uf = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const lf = {};
			var bf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.k: {
						const {
							pollId: s
						} = t.payload.pollResults, n = e, r = s;
						n[r];
						return uf(n, ["symbol" == typeof r ? r : r + ""])
					}
					case d.j: {
						const {
							pollId: s
						} = t.payload, n = e, r = s;
						n[r];
						return uf(n, ["symbol" == typeof r ? r : r + ""])
					}
					case d.i: {
						const {
							pollId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const pf = {};
			var Of = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.k: {
							const {
								pollId: s
							} = t.payload.pollResults;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case d.i: {
							const {
								pollId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case d.j: {
							const {
								pollId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						default:
							return e
					}
				},
				gf = Object(T.c)({
					error: bf,
					pending: Of
				}),
				ff = Object(T.c)({
					voting: gf
				});
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			const mf = e => {
				const {
					options: t,
					totalVoteCount: s,
					userSelection: n
				} = e;
				return {
					options: t.reduce((e, t) => {
						let {
							id: s,
							voteCount: r
						} = t;
						return Object.assign(Object.assign({}, e), {
							[s.toString()]: {
								id: s,
								votes: (r || 0).toString(),
								userSelected: s === n
							}
						})
					}, {}),
					totalVotes: s.toString()
				}
			};
			var jf = e => {
				if (!e.pollData) return null;
				const {
					id: t,
					authorId: s,
					belongsTo: n,
					created: r,
					pollData: {
						isPrediction: a,
						options: i,
						resolvedOptionId: o,
						totalStakeAmount: c,
						totalVoteCount: d,
						userSelection: u,
						userWonAmount: l,
						votingEndTimestamp: b
					}
				} = e;
				return {
					id: t,
					createdAt: r,
					creatorId: s,
					subredditId: n.id,
					endsAt: b,
					postId: t,
					options: i,
					totalVoters: d,
					type: bi.a.GA,
					isPrediction: a,
					totalStakeAmount: c,
					userSelection: u,
					userWonAmount: l,
					resolvedOptionId: o
				}
			};
			const _f = {};
			var hf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _f,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.h: {
						const {
							poll: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.id]: s
						})
					}
					case te.g:
					case ie.c:
					case ce.i:
					case Ue.b:
					case Fe.b:
					case te.b: {
						const {
							governance: s,
							posts: n
						} = t.payload;
						if (s) {
							const t = Object.keys(s).reduce((e, t) => {
								const n = s[t].poll;
								return e[n.id] = n, e
							}, {});
							return Object.assign(Object.assign({}, e), t)
						}
						const r = {};
						return Object.keys(n).forEach(e => {
							n[e].pollData && (r[e] = jf(n[e]))
						}), Object.assign(Object.assign({}, e), r)
					}
					default:
						return e
				}
			};
			const yf = {};
			var Ef = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.k: {
						const {
							[bi.b.ByVoters]: s, pollId: n
						} = t.payload.pollResults;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					case d.e: {
						const {
							pollId: s,
							optionId: n,
							options: r
						} = t.payload;
						let a = 0;
						const i = {};
						for (const e of r) a += e.voteCount, i[e.id] = {
							id: "number" == typeof e.id ? e.id : parseInt(e.id),
							userSelected: e.id === n,
							votes: e.voteCount.toString()
						};
						return Object.assign(Object.assign({}, e), {
							[s]: {
								options: i,
								totalVotes: a.toString()
							}
						})
					}
					case te.g:
					case ie.c:
					case ce.i:
					case Ue.b:
					case Fe.b:
					case te.b: {
						const {
							governance: s,
							posts: n
						} = t.payload;
						if (s) {
							const t = Object.keys(s).reduce((e, t) => {
								const n = s[t],
									{
										[bi.b.ByVoters]: r,
										pollId: a
									} = n.pollResults;
								return e[a] = r, e
							}, {});
							return Object.assign(Object.assign({}, e), t)
						}
						const r = Object.keys(n).reduce((e, t) => {
							if (!n[t].pollData) return e;
							const s = mf(n[t].pollData);
							return s ? (e[t] = s, e) : e
						}, {});
						return Object.keys(r).length ? Object.assign(Object.assign({}, e), r) : e
					}
					default:
						return e
				}
			};
			const If = {};
			var vf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : If,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.k: {
							const {
								[bi.b.ByVotingPower]: s, pollId: n
							} = t.payload.pollResults;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						case te.g:
						case ie.c:
						case ce.i:
						case Ue.b:
						case Fe.b:
						case te.b: {
							const {
								governance: s
							} = t.payload;
							if (s) {
								const t = Object.keys(s).reduce((e, t) => {
									const n = s[t],
										{
											[bi.b.ByVotingPower]: r,
											pollId: a
										} = n.pollResults;
									return e[a] = r, e
								}, {});
								return Object.assign(Object.assign({}, e), t)
							}
							return e
						}
						default:
							return e
					}
				},
				Sf = Object(T.c)({
					byVoters: Ef,
					byVotingPower: vf
				});
			const Tf = {};
			var wf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.k: {
							const {
								pollId: s,
								rewardPoints: n
							} = t.payload.pollResults;
							return n ? Object.assign(Object.assign({}, e), {
								[s]: n
							}) : e
						}
						default:
							return e
					}
				},
				Cf = Object(T.c)({
					api: ff,
					models: hf,
					results: Sf,
					rewards: wf
				});
			const Af = {
				reorderError: null,
				updateDescriptionError: null,
				updateLayoutError: null
			};
			var Df = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Af,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ar.i:
					case Ar.j:
						return Object.assign(Object.assign({}, e), {
							reorderError: null
						});
					case Ar.h:
						return Object.assign(Object.assign({}, e), {
							reorderError: t.payload
						});
					case Ar.l:
					case Ar.m:
						return Object.assign(Object.assign({}, e), {
							updateDescriptionError: null
						});
					case Ar.k:
						return Object.assign(Object.assign({}, e), {
							updateDescriptionError: t.payload
						});
					case Ar.p:
					case Ar.q:
						return Object.assign(Object.assign({}, e), {
							updateLayoutError: null
						});
					case Ar.o:
						return Object.assign(Object.assign({}, e), {
							updateLayoutError: t.payload
						});
					default:
						return e
				}
			};
			const Pf = {
				reorderPending: !1,
				updateDescriptionPending: !1,
				updateLayoutPending: !1
			};
			var Rf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ar.i:
							return Object.assign(Object.assign({}, e), {
								reorderPending: !0
							});
						case Ar.h:
						case Ar.j:
							return Object.assign(Object.assign({}, e), {
								reorderPending: !1
							});
						case Ar.l:
							return Object.assign(Object.assign({}, e), {
								updateDescriptionPending: !0
							});
						case Ar.k:
						case Ar.m:
							return Object.assign(Object.assign({}, e), {
								updateDescriptionPending: !1
							});
						case Ar.p:
							return Object.assign(Object.assign({}, e), {
								updateLayoutPending: !0
							});
						case Ar.o:
						case Ar.q:
							return Object.assign(Object.assign({}, e), {
								updateLayoutPending: !1
							});
						default:
							return e
					}
				},
				kf = Object(T.c)({
					error: Df,
					pending: Rf
				}),
				xf = s("./src/reddit/helpers/path/index.ts");
			const Nf = {},
				Lf = e => {
					const {
						protocol: t,
						domain: s
					} = e;
					return e => {
						const n = Object(xf.b)(e.permalink);
						return Object.assign(Object.assign({}, e), {
							permalink: "".concat(t, "://").concat(s).concat(n)
						})
					}
				};
			var Uf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b:
					case Ge.e:
					case Ge.h:
					case se.b:
					case se.e:
					case qe.e:
					case qe.b:
					case ne.e:
					case ne.b:
					case ie.c:
					case te.g:
					case te.k:
					case ie.c:
					case Fe.b:
					case te.b:
					case Ll.g:
					case Me.r:
					case Ue.b:
					case oe.e:
					case "RECOMMENDED_POSTS_LOADED":
					case ce.i:
					case We.c:
					case Ve.b:
					case ae.c:
					case Ar.f: {
						const {
							collections: s,
							meta: n
						} = t.payload;
						if (!s) return e;
						let r = s;
						if (n) {
							const e = Lf(n);
							r = ls()(s, e)
						}
						return Object.assign(Object.assign({}, e), r)
					}
					case Ar.d: {
						const {
							collection: s,
							meta: n
						} = t.payload;
						if (!s) return e;
						const r = s.id;
						let a = s;
						if (n) {
							a = Lf(n)(s)
						}
						return Object.assign(Object.assign({}, e), {
							[r]: a
						})
					}
					case Ar.g: {
						const {
							collectionId: s,
							postId: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								postIds: r.postIds.filter(e => e !== n)
							})
						}) : e
					}
					case Ar.a: {
						const {
							collectionId: s,
							postId: n
						} = t.payload, r = e[s];
						return r && n ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								postIds: [...r.postIds, n]
							})
						}) : e
					}
					case Ar.e: {
						const {
							collectionId: s
						} = t.payload, n = Object.assign({}, e);
						return delete n[s], n
					}
					case Ar.s: {
						const {
							collectionId: s,
							newTitle: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								title: n
							})
						}) : e
					}
					case Ar.j: {
						const {
							collectionId: s,
							postIds: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								postIds: [...n]
							})
						}) : e
					}
					case Ar.m: {
						const {
							collectionId: s,
							newDescription: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								description: n
							})
						}) : e
					}
					case Ar.q: {
						const {
							collectionId: s,
							newLayout: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								displayLayout: n
							})
						}) : e
					}
					default:
						return e
				}
			};
			const Mf = {};
			var Ff = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.b:
						case Ar.f: {
							const {
								collections: s
							} = t.payload;
							if (!s) return e;
							const n = Object.keys(s);
							if (!n.length) return e;
							const {
								subredditId: r
							} = s[n[0]];
							return Object.assign(Object.assign({}, e), {
								[r]: n
							})
						}
						case Ar.d: {
							const {
								collection: s
							} = t.payload, {
								subredditId: n
							} = s, r = e[n] || [];
							return Object.assign(Object.assign({}, e), {
								[n]: [...r, s.id]
							})
						}
						case Ar.e: {
							const {
								collectionId: s,
								collection: n
							} = t.payload;
							if (!n) return e;
							const r = n && e[n.subredditId];
							return r ? Object.assign(Object.assign({}, e), {
								[n.subredditId]: r.filter(e => e !== s)
							}) : e
						}
						default:
							return e
					}
				},
				Gf = Object(T.c)({
					models: Uf,
					subredditToIds: Ff,
					api: kf
				}),
				Bf = s("./src/reddit/actions/postFlair.ts"),
				qf = s("./src/reddit/models/Flair/index.ts");
			const Vf = {},
				Hf = {
					displaySettings: {
						isEnabled: !1,
						position: qf.b.Left
					},
					permissions: {
						canAssignOwn: !1
					},
					templateIds: [],
					templates: {}
				},
				Kf = (e, t) => {
					if (!t) return e;
					const s = Object.keys(t);
					return 0 === s.length ? e : s.reduce((e, s) => (e[s] = Object.assign(Object.assign(Object.assign({}, Hf), e[s]), t[s]), e), Object.assign({}, e))
				};
			var Wf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Be.b:
						case Ue.b:
						case Ge.e:
						case Ge.h:
						case Me.r:
						case _l.b:
						case Fe.b:
						case te.b:
						case te.g:
						case te.k:
						case ae.c:
						case ie.c:
						case se.b:
						case se.e:
						case re.c:
						case re.i:
						case re.e:
						case re.g:
						case oe.e:
						case Ve.b:
						case Ve.b:
						case qe.b:
						case qe.e:
						case ne.b:
						case ne.e:
						case "RECOMMENDED_POSTS_LOADED":
						case We.c:
						case We.c:
						case ce.i:
							return Kf(e, t.payload.postFlair);
						case Bf.c: {
							const {
								subredditId: s,
								isEnabled: n
							} = t.payload, r = e[s].displaySettings, a = Object.assign(Object.assign({}, r), {
								isEnabled: n
							});
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									displaySettings: a
								})
							})
						}
						case Bf.a: {
							const {
								subredditId: s,
								canAssignOwn: n
							} = t.payload, r = e[s].permissions, a = Object.assign(Object.assign({}, r), {
								canAssignOwn: n
							});
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, e[s]), {
									permissions: a
								})
							})
						}
						case Bf.f: {
							const {
								subredditId: s,
								template: n
							} = t.payload, r = e[s], {
								templates: a,
								templateIds: i
							} = r, o = Object.assign(Object.assign({}, a), {
								[n.id]: n
							}), c = [...i];
							return c.includes(n.id) || c.push(n.id), Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, r), {
									templates: o,
									templateIds: c
								})
							})
						}
						case Bf.b: {
							const {
								subredditId: s,
								templateId: n
							} = t.payload, r = e[s], {
								templates: a,
								templateIds: i
							} = r, o = jn()(a, n), c = i.filter(e => e !== n);
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, r), {
									templates: o,
									templateIds: c
								})
							})
						}
						case Bf.e:
						case Bf.d: {
							const s = t.payload,
								n = e[s.subredditId];
							return Object.assign(Object.assign({}, e), {
								[s.subredditId]: Object.assign(Object.assign({}, n), {
									templateIds: s.templateIds
								})
							})
						}
						case ee.i:
						case ee.f:
						case ee.m:
						case ee.p:
						case ee.v: {
							const {
								response: s
							} = t.payload;
							return Kf(e, s.postFlair)
						}
						default:
							return e
					}
				},
				Yf = s("./src/reddit/actions/postRequirements/constants.ts");
			const zf = {};
			var Jf = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : zf,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Yf.a: {
						const {
							subredditName: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case Yf.c:
					case Yf.b: {
						const {
							subredditName: s
						} = t.payload;
						return Object(Ss.a)(e, s)
					}
					default:
						return e
				}
			};
			const Qf = {};
			var Xf = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qf,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yf.c:
						case Yf.a:
						case Yf.b: {
							const {
								subredditName: s
							} = t.payload, n = t.type === Yf.c;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				Zf = Object(T.c)({
					error: Jf,
					pending: Xf
				}),
				$f = Object(T.c)({
					fetch: Zf
				});
			const em = {};
			var tm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : em,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Yf.b: {
							const {
								subredditName: s,
								requirements: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case Yf.d: {
							const {
								subredditName: s,
								partialRequirements: n
							} = t.payload, r = e[s];
							return r ? Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, r), n)
							}) : e
						}
						default:
							return e
					}
				},
				sm = Object(T.c)({
					api: $f,
					models: tm
				}),
				nm = s("./src/reddit/actions/inFeedChaining.ts");
			var rm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nm.a:
						return t.payload.isDismissed;
					default:
						return e
				}
			};
			const am = {};
			var im = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : am,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case nm.c: {
						const {
							isDismissed: s,
							listingKey: n,
							postId: r
						} = t.payload;
						if (s) return Object.assign(Object.assign({}, e), {
							[r]: n
						});
						const a = Object.assign({}, e);
						return delete a[r], a
					}
					default:
						return e
				}
			};
			const om = {};
			var cm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : om,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case nm.b:
							return Object.assign(Object.assign({}, e), {
								[t.payload.postId]: t.payload.listingKey
							});
						default:
							return e
					}
				},
				dm = Object(T.c)({
					dismissed: rm,
					dismissedIdToListingKey: im,
					idToListingKey: cm
				});
			var um = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ll.a:
							return t.payload;
						default:
							return e
					}
				},
				lm = s("./src/reddit/actions/embedAndImage.ts");
			const bm = {};
			var pm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lm.b: {
							const {
								postId: s
							} = t.payload;
							return e[s] ? Object.assign(Object.assign({}, e), {
								[s]: !1
							}) : e
						}
						case lm.a: {
							const {
								postId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
					}
					return e
				},
				Om = Object(T.c)({
					loadable: pm
				});
			const gm = {};
			var fm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ll.b: {
						const {
							postId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !e[s]
						})
					}
					default:
						return e
				}
			};
			var mm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ll.c: {
						const {
							postId: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const jm = {};
			var _m = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ge.e:
						case Ge.h:
						case te.g:
						case ie.c:
						case Ue.b:
						case oe.e:
						case "RECOMMENDED_POSTS_LOADED":
						case ce.i:
						case We.c:
						case ae.c:
							return Q()(Object.assign({}, e), t.payload.postInstances, (e, t) => {
								if (e) return e.concat(t)
							});
						default:
							return e
					}
				},
				hm = s("./src/reddit/actions/isTrackingCrossposts.ts");
			const ym = {};
			var Em = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ym,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hm.a: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					default:
						return e
				}
			};
			const Im = {};
			var vm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Im,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.h: {
							const {
								poll: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.postId]: s.id
							})
						}
						case te.g:
						case ie.c:
						case ce.i:
						case Ue.b:
						case Fe.b:
						case te.b: {
							const {
								governance: s,
								posts: n
							} = t.payload;
							if (s) {
								const t = Object.keys(s).reduce((e, t) => {
									const n = s[t];
									return e[t] = n.poll.id, e
								}, {});
								return Object.assign(Object.assign({}, e), t)
							}
							const r = Object.keys(n).reduce((e, t) => n[t].pollData ? (e[t] = t, e) : e, {});
							return Object.assign(Object.assign({}, e), r)
						}
						default:
							return e
					}
				},
				Sm = s("./src/reddit/actions/flairManagement/constants.ts"),
				Tm = s("./src/reddit/actions/imageOCRAltText/constants.ts"),
				wm = s("./src/reddit/actions/subredditTopContent.ts"),
				Cm = s("./src/reddit/helpers/isPost.ts"),
				Am = s("./node_modules/lodash/pickBy.js"),
				Dm = s.n(Am);

			function Pm(e, t) {
				const s = Dm()(t, (function(t) {
					let s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
					return !e[s] || !fn()(e[s], t)
				}));
				return Object.keys(s).length > 0 ? Object.assign(Object.assign({}, e), s) : e
			}
			var Rm = s("./src/reddit/models/Media/index.ts"),
				km = s("./src/reddit/models/Post/index.ts"),
				xm = s("./src/reddit/actions/subredditDuplicates.ts"),
				Nm = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const Lm = {},
				Um = e => {
					const {
						protocol: t,
						domain: s
					} = e;
					return e => {
						const n = Object(xf.b)(e.permalink);
						return Object.assign(Object.assign({}, e), {
							permalink: "".concat(t, "://").concat(s).concat(n)
						})
					}
				},
				Mm = e => t => {
					const s = e[t.id];
					return s && s.events && (t.events = s.events, t.source = s.source), t
				},
				Fm = e => t => {
					const s = e[t.id];
					return s && s.isSponsored && (t.isSponsored = s.isSponsored), t
				},
				Gm = e => e.media && Object(Rm.F)(e.media) ? Object.assign({}, Object(U.unsetIn)(e, ["source"])) : e,
				Bm = e => t => {
					const s = e[t.id];
					return t && t.media && s && s.media && Object(Rm.I)(t.media) && t.media.isRichtextPreview && Object(Rm.I)(s.media) && !s.media.isRichtextPreview && (t.media.richtextContent = s.media.richtextContent, t.media.isRichtextPreview = !1), t
				},
				qm = e => t => {
					const s = e[t.id];
					return s && s.numDuplicates && (t.numDuplicates = s.numDuplicates), t
				},
				Vm = e => {
					let t = e.source;
					return t && t.outboundUrlCreated && (t = Object.assign(Object.assign({}, t), {
						outboundUrlReceived: Date.now()
					}), e.source = t), e
				},
				Hm = e => {
					const {
						allAwardings: t
					} = e, s = Nm(e, ["allAwardings"]), n = {};
					return t && t.forEach(e => {
						n[e.id] = e.count
					}), Object.assign(Object.assign({}, s), {
						awardCountsById: n
					})
				},
				Km = e => t => {
					for (let s = 0; s < e.length; s++) t = e[s](t);
					return t
				},
				Wm = (e, t) => Object.assign(Object.assign({}, e), {
					events: t.events,
					source: t.source
				});
			var Ym = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case l.a:
						if (Sa(t) === (Ke.Bb.COMMENTS || Ke.Bb.DUPLICATES)) {
							const s = Ta(t),
								n = wa(t);
							if (s && s.instanceId && n && n.partialPostId) {
								const t = s.instanceId,
									r = Object(km.m)(n.partialPostId);
								if (e[r] && e[t]) return Object.assign(Object.assign({}, e), {
									[r]: Wm(e[r], e[t])
								})
							}
						}
						return e;
					case Fe.b:
					case te.b: {
						const s = Um(t.payload.meta);
						return Object.assign(Object.assign({}, e), ls()(t.payload.posts, Km([s, Vm, Hm, Gm, Mm(e), Fm(e), qm(e)])))
					}
					case Ll.g:
						return Pm(e, t.payload);
					case xm.a:
						return Pm(e, t.payload.posts);
					case Be.b:
					case Il.b:
					case Ge.e:
					case Ge.h:
					case se.b:
					case se.e:
					case qe.e:
					case qe.b:
					case ne.e:
					case ne.b:
					case ie.c:
					case te.g:
					case te.k:
					case ie.c:
					case _l.b:
					case Me.r:
					case Ue.b:
					case oe.e:
					case "RECOMMENDED_POSTS_LOADED":
					case vl.h:
					case ce.i:
					case Ve.b:
					case hl.e:
					case hl.b:
					case jl.c:
					case jl.d: {
						const s = Um(t.payload.meta);
						return Object.assign(Object.assign({}, e), ls()(t.payload.posts, Km([s, Vm, Hm, Gm, Bm(e), qm(e)])))
					}
					case vl.p: {
						if (!t.payload || !t.payload.length) return e;
						const s = {};
						for (const n of t.payload) {
							const t = n,
								r = Um(t.meta);
							Object.assign(s, ls()(t.posts, Km([r, Vm, Hm, Gm, Bm(e), qm(e)])))
						}
						return Object.assign(Object.assign({}, e), s)
					}
					case _l.b: {
						const s = Um(t.payload.meta),
							n = e[t.payload.postId];
						return Object.assign(Object.assign(Object.assign({}, e), ls()(t.payload.posts, Km([s, Vm, Hm, Gm, Bm(e), qm(e)]))), {
							[t.payload.postId]: Object.assign(Object.assign({}, n), {
								numDuplicates: t.payload.count
							})
						})
					}
					case Le.e:
					case We.c:
					case ae.c: {
						const s = Um(t.payload.meta),
							n = ls()(t.payload.posts, Km([s, Hm, Vm, Gm]));
						return Q()(Object.assign({}, e), n, (e, t) => Object.assign(Object.assign({}, t), e))
					}
					case Ll.h: {
						const s = t.payload;
						return Q()(Object.assign({}, e), s, (e, t) => Object.assign(Object.assign({}, e), t))
					}
					case yn.a: {
						const {
							id: s,
							vote: n
						} = t.payload, r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object(wn.c)(r, n)
						}) : e
					}
					case Z.b:
					case X.G: {
						const s = t.payload.comment.postId,
							n = e[s];
						if (n) {
							const r = void 0 !== t.payload.numComments ? t.payload.numComments : n.numComments + 1;
							return Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, n), {
									numComments: r
								})
							})
						}
						return e
					}
					case X.y: {
						const s = t.payload.postId,
							n = e[s];
						return n ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								numComments: n.numComments - 1
							})
						}) : e
					}
					case ge.ob: {
						const {
							topAwardedPosts: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s.reduce((e, t) => (e[t.post.id] = Km([Hm])(Object(Na.e)(t.post)), e), {}))
					}
					case ge.t: {
						const {
							id: s,
							awardings: n,
							gilder: r,
							treatmentTags: a
						} = t.payload, i = e[s];
						return i ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, vn(i, n, r)), {
								treatmentTags: a
							})
						}) : e
					}
					case ge.G: {
						const {
							awardId: s,
							thingId: n
						} = t.payload, r = e[n];
						return r ? Object.assign(Object.assign({}, e), {
							[n]: Sn(r, s)
						}) : e
					}
					case w.l: {
						const {
							posts: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v: {
						const {
							response: s
						} = t.payload, {
							posts: n
						} = s;
						return Object.assign(Object.assign({}, e), ls()(n, Km([Hm, Gm])))
					}
					case _n.b:
					case ee.s: {
						const {
							operation: s,
							ids: n,
							username: r,
							options: a
						} = t.payload, i = n.filter(e => Object(Cm.a)(e)), o = Object(Tn.d)(e, s, i, r, a);
						return Q()(Object.assign({}, e), o, (e, t) => Object.assign(Object.assign({}, e), t))
					}
					case Ar.t: {
						const {
							postId: s,
							collectionId: n
						} = t.payload, r = e[s];
						if (r && n) {
							const t = r.collectionIds || [];
							return t.push(n), Object.assign(Object.assign({}, e), {
								[s]: Object.assign(Object.assign({}, r), {
									collectionIds: [...t]
								})
							})
						}
						return e
					}
					case Ar.e: {
						const {
							collectionId: s,
							collection: n
						} = t.payload, r = n && n.postIds || [], a = {};
						return r.forEach(t => {
							const n = e[t],
								r = n && n.collectionIds;
							if (r) {
								const e = r.filter(e => e !== s);
								a[t] = Object.assign(Object.assign({}, n), {
									collectionIds: e
								})
							}
						}), Object.assign(Object.assign({}, e), a)
					}
					case Ar.g: {
						const {
							collectionId: s,
							postId: n
						} = t.payload;
						if (!s || !n) return e;
						const r = e[n],
							a = r && r.collectionIds;
						if (!a) return e;
						const i = a.filter(e => e !== s);
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, r), {
								collectionIds: i
							})
						})
					}
					case jl.f: {
						const {
							postId: s
						} = t.payload;
						if (!s) return e;
						const n = e[s];
						if (!n || !n.eventInfo) return e;
						const r = n.eventInfo;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								eventInfo: Object.assign(Object.assign({}, r), {
									eventIsLive: !0
								})
							})
						})
					}
					case jl.a: {
						const {
							postId: s,
							eventInfo: n
						} = t.payload;
						if (!s || !n) return e;
						const r = e[s];
						return r ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								eventInfo: Object.assign({}, n)
							})
						}) : e
					}
					case Uc.g: {
						const s = t.payload.subredditTopContent;
						return s && s.posts && Object.keys(s.posts) ? Object.assign(Object.assign({}, ls()(s.posts, Km([Hm, Gm]))), e) : e
					}
					case re.c:
					case re.i:
					case re.e:
					case re.g:
					case wm.b:
						return Object.assign(Object.assign({}, ls()(t.payload.posts, Km([Hm, Gm]))), e);
					case Ll.j: {
						const {
							postId: s,
							richtextContent: n
						} = t.payload, r = e[s];
						return r && r.media && Object(Rm.I)(r.media) ? Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								media: Object.assign(Object.assign({}, r.media), {
									richtextContent: n,
									isRichtextPreview: !1
								})
							})
						}) : e
					}
					case Sm.a: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.id]: s
						})
					}
					case Sm.b: {
						const s = t.payload;
						return Object(Ss.a)(e, s)
					}
					case $l.a: {
						const {
							isDeleted: s,
							height: n,
							postId: r
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, e[r]), {
								media: Object.assign(Object.assign({}, e[r].media), {
									height: n,
									isDeleted: s
								})
							})
						})
					}
					case j.n: {
						const s = t.payload.reduce((e, t) => (e[t.id] = t, e), {});
						return Object.assign(Object.assign({}, e), s)
					}
					case Tm.b: {
						const {
							altText: s,
							postId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								media: Object.assign(Object.assign({}, e[n].media), {
									altText: s
								})
							})
						})
					}
					case Tm.a:
						return Object.assign({}, e);
					default:
						return e
				}
			};
			var zm = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ll.f:
							return t.payload;
						default:
							return e
					}
				},
				Jm = s("./src/reddit/actions/postLevelCrowdControl.ts");
			const Qm = {};
			var Xm = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qm,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Jm.a: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					default:
						return e
				}
			};
			const Zm = [];
			var $m = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zm,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ll.i: {
							const {
								postIds: e
							} = t.payload;
							return e
						}
						case te.g:
						case ie.c: {
							const {
								recentPostIds: s
							} = t.payload;
							return s && s.length ? s : e
						}
						default:
							return e
					}
				},
				ej = s("./node_modules/uuid/v4.js"),
				tj = s.n(ej);
			const sj = tj()();
			var nj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b:
					case ca.h:
					case ca.a:
					case ca.m:
					case ca.f:
						return tj()();
					default:
						return e
				}
			};
			var rj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ca.d:
					case ca.o:
					case ca.k:
					case ca.g:
					case ca.a:
					case ca.m:
					case ca.f:
						return null;
					case ca.j: {
						const {
							message: e
						} = t.payload;
						return e
					}
					case ca.e:
						return "error";
					default:
						return e
				}
			};
			var aj = function() {
				let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ca.g:
						return !0;
					case ca.m:
					case ca.a:
					case ca.f:
					case ca.e:
						return !1;
					default:
						return e
				}
			};
			var ij = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ca.k:
							return !0;
						case ca.j:
						case ca.e:
						case ca.o:
						case ca.d:
							return !1;
						default:
							return e
					}
				},
				oj = Object(T.c)({
					creationToken: nj,
					error: rj,
					pending: aj,
					pendingUpdate: ij
				});
			const cj = {};
			var dj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ca.c: {
						const {
							subredditId: e,
							id: s
						} = t.payload;
						return {
							subredditId: e,
							scheduledPostId: s
						}
					}
					default:
						return e
				}
			};
			const uj = {
				standalonePosts: {
					POSTS_LOADED: ca.m,
					postIdsKey: "standalonePostsIds",
					MUTATION_SUCCEEDED: ca.o
				},
				recurringPosts: {
					POSTS_LOADED: ca.a,
					postIdsKey: "recurringPostsIds",
					MUTATION_SUCCEEDED: ca.d
				}
			};

			function lj(e) {
				const t = {};
				return function() {
					let s = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t,
						n = arguments.length > 1 ? arguments[1] : void 0;
					switch (n.type) {
						case uj[e].POSTS_LOADED:
						case ca.f: {
							const {
								subredditInfoById: t
							} = n.payload, {
								id: r
							} = t, a = t.scheduledPosts[e].models.reduce((e, t) => (e[t.id] = t, e), {});
							return Object.assign(Object.assign({}, s), {
								[r]: Object.assign(Object.assign({}, s[r] || {}), a)
							})
						}
						case ca.i:
						case ca.l: {
							const {
								subredditId: e,
								scheduledPostId: t
							} = n.payload, r = s[e] || {};
							return Object.assign(Object.assign({}, s), {
								[e]: Object.assign({}, Object.keys(r).filter(e => e !== t).reduce((e, t) => (e[t] = r[t], e), {}))
							})
						}
						case ca.h: {
							const {
								subredditId: e
							} = n.payload;
							return Object.keys(s).reduce((t, n) => (n !== e && (t[n] = s[n]), t), {})
						}
						case uj[e].MUTATION_SUCCEEDED: {
							let t;
							switch (e) {
								case "recurringPosts":
									t = n.payload.scheduledPost;
									break;
								case "standalonePosts":
								default:
									t = n.payload.scheduledPost
							}
							const r = t.subreddit.id,
								a = s[r][t.id],
								i = {
									[t.id]: Object.assign(Object.assign({}, a), t)
								};
							return Object.assign(Object.assign({}, s), {
								[r]: Object.assign(Object.assign({}, s[r] || {}), i)
							})
						}
						default:
							return s
					}
				}
			}
			const bj = {};

			function pj(e) {
				return function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bj,
						s = arguments.length > 1 ? arguments[1] : void 0;
					switch (s.type) {
						case uj[e].POSTS_LOADED:
						case ca.f: {
							const {
								subredditInfoById: n
							} = s.payload, r = n.id, {
								pageInfo: a
							} = n.scheduledPosts[e];
							return Object.assign(Object.assign({}, t), {
								[r]: Object.assign({}, a)
							})
						}
						case ca.h: {
							const {
								subredditId: e
							} = s.payload;
							return Object.keys(t).reduce((s, n) => (n !== e && (s[n] = t[n]), s), {})
						}
						default:
							return t
					}
				}
			}
			var Oj = s("./node_modules/lodash/uniq.js"),
				gj = s.n(Oj);
			const fj = {};

			function mj(e) {
				return function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fj,
						s = arguments.length > 1 ? arguments[1] : void 0;
					switch (s.type) {
						case uj[e].POSTS_LOADED:
						case ca.f: {
							const {
								subredditInfoById: n
							} = s.payload, r = n.id, a = n.scheduledPosts[uj[e].postIdsKey];
							return Object.assign(Object.assign({}, t), {
								[r]: gj()([...t[r] || [], ...a])
							})
						}
						case ca.i:
						case ca.l: {
							const {
								subredditId: e,
								scheduledPostId: n
							} = s.payload, r = t[e] || [];
							return Object.assign(Object.assign({}, t), {
								[e]: r.filter(e => e !== n)
							})
						}
						case ca.h: {
							const {
								subredditId: e
							} = s.payload;
							return Object.assign(Object.assign({}, t), {
								[e]: []
							})
						}
						default:
							return t
					}
				}
			}
			var jj = Object(T.c)({
					models: lj("recurringPosts"),
					pageInfo: pj("recurringPosts"),
					postOrder: mj("recurringPosts"),
					editModal: dj
				}),
				_j = Object(T.c)({
					models: lj("standalonePosts"),
					pageInfo: pj("standalonePosts"),
					postOrder: mj("standalonePosts")
				}),
				hj = Object(T.c)({
					api: oj,
					standalonePosts: _j,
					recurringPosts: jj
				});
			var yj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.nb:
						return t.payload;
					case ge.pb:
					case ge.ob:
						return null;
					default:
						return e
				}
			};
			var Ej = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.ob:
						case ge.nb:
							return !1;
						case ge.pb:
							return !0;
						default:
							return e
					}
				},
				Ij = Object(T.c)({
					error: yj,
					pending: Ej
				});
			const vj = [];
			var Sj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.ob: {
							const {
								topAwardedPosts: e
							} = t.payload;
							return e.filter(e => !(e.post.isNsfw || e.post.isArchived || e.post.isHidden || e.post.removedBy || e.post.removedByCategory && "NONE" !== e.post.removedByCategory)).map(e => ({
								postId: e.post.id,
								rank: e.rank,
								score: e.score
							}))
						}
						case ge.nb:
						case ge.pb:
							return vj;
						default:
							return e
					}
				},
				Tj = Object(T.c)({
					api: Ij,
					list: Sj
				}),
				wj = s("./src/reddit/actions/video.ts");
			const Cj = {};
			var Aj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.e: {
						const {
							auto: s,
							postId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					default:
						return e
				}
			};
			const Dj = {};
			var Pj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.a: {
						const {
							postId: s,
							isBuffering: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Rj = {};
			var kj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.b: {
						const {
							postId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					default:
						return e
				}
			};
			const xj = {};
			var Nj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.c: {
						const {
							postId: s,
							time: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Lj = {
				mutedInFeed: !0
			};
			var Uj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.l:
						return Object.assign(Object.assign({}, e), {
							mutedInFeed: t.payload
						});
					default:
						return e
				}
			};
			var Mj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.k: {
						const {
							postId: e
						} = t.payload;
						return e
					}
					case wj.d:
						return null;
					default:
						return e
				}
			};
			const Fj = {};
			var Gj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.o: {
						const {
							postId: s
						} = t.payload;
						return e[s] ? Object.assign(Object.assign({}, e), {
							[s]: !1
						}) : e
					}
					case wj.e: {
						const {
							postId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
				}
				return e
			};
			const Bj = {};
			var qj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.h: {
						const {
							postId: s,
							time: n
						} = t.payload, r = e[s] || {
							cached: !0,
							start: n
						};
						return n < r.start ? e : Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								playable: n
							})
						})
					}
					case wj.f: {
						const {
							postId: s,
							time: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: {
								cached: !1,
								start: n
							}
						})
					}
					default:
						return e
				}
			};
			const Vj = {};
			var Hj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.j: {
						const {
							postId: s,
							metadata: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Kj = {};
			var Wj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.p: {
						const {
							postId: s
						} = t.payload;
						return e[s] ? Object.assign(Object.assign({}, e), {
							[s]: !1
						}) : e
					}
					case wj.g: {
						const {
							postId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
				}
				return e
			};
			const Yj = {};
			var zj = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yj,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wj.i: {
						const {
							postId: s,
							isPlaying: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Jj = {};
			var Qj = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wj.m: {
							const {
								postId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						default:
							return e
					}
				},
				Xj = s("./src/reddit/constants/video.ts");
			const Zj = {};
			var $j = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zj,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wj.n: {
							const {
								postId: s,
								time: n
							} = t.payload;
							return e[s] && Math.abs(Math.floor(n.currentTime) - Math.floor(e[s].currentTime)) < Xj.k ? e : Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				e_ = Object(T.c)({
					autoPlayed: Aj,
					buffering: Pj,
					consumed: kj,
					continuousViewStartedAt: Nj,
					feed: Uj,
					fullscreen: Mj,
					loadable: Gj,
					loadTimes: qj,
					metadata: Hj,
					paused: Wj,
					playing: zj,
					started: Qj,
					time: $j
				}),
				t_ = Object(T.c)({
					chained: dm,
					embedAndImage: Om,
					expanded: fm,
					focus: mm,
					instances: _m,
					isTrackingCrossposts: Em,
					metaMap: vm,
					models: Ym,
					modToMemberShare: zm,
					crowdControl: um,
					postLevelCrowdControl: Xm,
					recent: $m,
					scheduledPosts: hj,
					topAwarded: Tj,
					video: e_
				}),
				s_ = s("./src/lib/reducers/addAuthentication/index.ts");
			const n_ = {};
			var r_ = Object(s_.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case te.b: {
							const {
								postId: s,
								commentLists: n,
								comments: r
							} = t.payload, a = n[s] && n[s].head;
							return a && r[a.id] && r[a.id].isStickied ? Object.assign(Object.assign({}, e), {
								[s]: a.id
							}) : e
						}
						case X.C: {
							const {
								id: e,
								postId: s
							} = t.payload;
							return {
								[s]: e
							}
						}
						default:
							return e
					}
				}), n_),
				a_ = Object(T.c)({
					data: r_
				});
			const i_ = {};
			var o_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.f:
					case p.g: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: void 0
						})
					}
					case p.e: {
						const {
							subredditId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const c_ = {};
			var d_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.f: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case p.g:
						case p.e: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				u_ = Object(T.c)({
					error: o_,
					pending: d_
				});
			const l_ = {};
			var b_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.d: {
						const {
							product: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.id]: void 0
						})
					}
					case p.c:
					case u.f:
					case u.g:
					case u.i:
					case u.j: {
						const {
							productId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: void 0
						})
					}
					case p.a:
					case u.d:
					case u.h: {
						const {
							productId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const p_ = {};
			var O_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.c:
						case u.f: {
							const {
								productId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case p.d: {
							const {
								product: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.id]: !1
							})
						}
						case p.a:
						case u.d:
						case u.g: {
							const {
								productId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				g_ = Object(T.c)({
					error: b_,
					pending: O_
				}),
				f_ = Object(T.c)({
					fetch: u_,
					purchase: g_
				});
			var m_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.b:
						return t.payload.productId;
					case n.b:
						return null;
					default:
						return e
				}
			};
			const j_ = {};
			var __ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.j:
						case p.g: {
							const {
								products: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				h_ = Object(T.c)({
					api: f_,
					currentlyPurchasing: m_,
					models: __
				});
			const y_ = {};
			var E_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : y_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.f:
					case se.e:
					case se.c:
					case se.b: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case se.d:
					case se.a: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const I_ = {};
			var v_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : I_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.f:
						case se.c: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case se.e:
						case se.d:
						case se.b:
						case se.a: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				S_ = Object(T.c)({
					error: E_,
					pending: v_
				});
			const T_ = {};
			var w_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.e: {
							const {
								key: s,
								commentIds: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case se.b: {
							const {
								key: s,
								commentIds: n
							} = t.payload, r = e[s] || [];
							return Object.assign(Object.assign({}, e), {
								[s]: r.concat(n)
							})
						}
						default:
							return e
					}
				},
				C_ = s("./src/reddit/actions/comment/list.ts");
			const A_ = {};
			var D_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : A_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case C_.a: {
						const {
							listingKey: s,
							listingName: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case C_.b: {
						const {
							listingKey: s
						} = t.payload;
						return s in e ? jn()(e, s) : e
					}
					default:
						return e
				}
			};
			const P_ = {};
			var R_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case se.e: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: {}
						})
					}
					case se.b: {
						const {
							key: s,
							fetchedToken: n
						} = t.payload, r = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								[n]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const k_ = {};
			var x_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case se.e:
						case se.b: {
							const {
								key: s,
								dist: n,
								token: r
							} = t.payload;
							return r ? Object.assign(Object.assign({}, e), {
								[s]: {
									dist: n,
									token: r
								}
							}) : Object(Ss.a)(e, s)
						}
						default:
							return e
					}
				},
				N_ = Object(T.c)({
					api: S_,
					endMarkers: D_,
					fetchedTokens: R_,
					commentIds: w_,
					loadMore: x_
				}),
				L_ = s("./src/reddit/actions/pages/profileModSettings.ts");
			var U_ = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L_.a:
							return !1;
						default:
							return e
					}
				},
				M_ = Object(T.c)({
					pending: U_
				}),
				F_ = Object(T.c)({
					api: M_
				});
			const G_ = {};
			var B_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.c:
					case qe.b:
					case Ve.c:
					case Ve.b: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case qe.a:
					case Ve.a: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const q_ = {};
			var V_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : q_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.c:
						case Ve.c: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case qe.b:
						case qe.a:
						case Ve.b:
						case Ve.a: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				H_ = Object(T.c)({
					error: B_,
					pending: V_
				});
			const K_ = {};
			var W_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : K_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.b: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: {}
						})
					}
					case Ve.b: {
						const {
							key: s,
							fetchedToken: n
						} = t.payload, r = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								[n]: !0
							})
						})
					}
					default:
						return e
				}
			};
			const Y_ = {};
			var z_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.b:
					case Ve.b: {
						const {
							key: s,
							overviewIds: n
						} = t.payload, r = e[s] || [];
						return Object.assign(Object.assign({}, e), {
							[s]: [...r, ...n]
						})
					}
					default:
						return e
				}
			};
			const J_ = {};
			var Q_ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : J_,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.b:
						case Ve.b: {
							const {
								key: s,
								dist: n,
								token: r
							} = t.payload;
							return r ? Object.assign(Object.assign({}, e), {
								[s]: {
									dist: n,
									token: r
								}
							}) : Object(Ss.a)(e, s)
						}
						default:
							return e
					}
				},
				X_ = Object(T.c)({
					api: H_,
					fetchedTokens: W_,
					ids: z_,
					loadMore: Q_
				});
			const Z_ = {};
			var $_ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Z_,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.f:
					case qe.e: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case qe.d: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n || {}
						})
					}
					default:
						return e
				}
			};
			const eh = {};
			var th = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.f: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case qe.e:
						case qe.d: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				sh = Object(T.c)({
					error: $_,
					pending: th
				});
			const nh = {};
			var rh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case oe.c:
					case oe.b: {
						const {
							extraCommentsId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case oe.a: {
						const {
							extraCommentsId: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n || {}
						})
					}
					default:
						return e
				}
			};
			const ah = {};
			var ih = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ah,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case oe.c: {
							const {
								extraCommentsId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case oe.b:
						case oe.a: {
							const {
								extraCommentsId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				oh = Object(T.c)({
					error: rh,
					pending: ih
				});
			const ch = {};
			var dh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ch,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.e:
						case oe.b:
						case oe.e:
							return Object.assign(Object.assign({}, e), t.payload.extraComments);
						default:
							return e
					}
				},
				uh = Object(T.c)({
					api: oh,
					models: dh
				}),
				lh = s("./src/lib/makeOverviewConversationsItemKey/index.ts"),
				bh = s("./src/reddit/constants/comments.ts");
			const ph = {};

			function Oh(e) {
				const t = e;
				return ls()(t, e => {
					let {
						depth: t,
						next: s,
						prev: n
					} = e;
					return {
						depth: t,
						next: s,
						prev: n
					}
				})
			}
			const gh = (e, t, s) => {
				const n = {};
				for (const r in t) {
					const e = t[r],
						s = e.postId;
					n.hasOwnProperty(s) ? n[s] = Object.assign(Object.assign({}, n[s]), {
						[r]: e
					}) : n[s] = {
						[r]: e
					}
				}
				for (const r in s) {
					const e = s[r],
						t = e.postId;
					n.hasOwnProperty(t) ? n[t] = Object.assign(Object.assign({}, n[t]), {
						[r]: e
					}) : n[t] = {
						[t]: e
					}
				}
				return n
			};
			var fh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ph,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.e:
					case oe.e: {
						const {
							comments: s,
							extraComments: n,
							postIds: r,
							profileName: a
						} = t.payload, i = gh(r, s, n), o = {};
						for (const e of r) {
							o[Object(lh.a)(e, a)] = i.hasOwnProperty(e) ? Oh(i[e]) : {}
						}
						return Object.assign(Object.assign({}, e), o)
					}
					case oe.b: {
						const {
							comments: s,
							commentLists: n,
							extraComments: r,
							extraCommentsId: a,
							postIds: i,
							profileName: o
						} = t.payload;
						if (0 === i.length) {
							const t = Object.keys(e).find(t => void 0 !== e[t][a]);
							if (!t) return e;
							const s = Object.assign({}, e[t])[a].prev,
								n = s && s.id || "";
							return Object.assign(Object.assign({}, e), {
								[t]: Object.assign(Object.assign({}, e[t]), {
									[n]: Object.assign(Object.assign({}, e[t][n]), {
										next: null
									})
								})
							})
						}
						const c = i[0],
							d = Oh(gh(i, s, r)[c]),
							u = Object(lh.a)(c, o),
							l = Object.assign({}, e[u]),
							b = l[a].prev,
							p = b && b.id || "",
							O = n[c].head,
							g = O && O.id || "",
							f = {
								id: g,
								type: bh.a.Comment
							},
							m = Object.assign(Object.assign(Object.assign(Object.assign({}, l), {
								[p]: Object.assign(Object.assign({}, l[p]), {
									next: f
								})
							}), d), {
								[g]: Object.assign(Object.assign({}, d[g]), {
									prev: b
								})
							});
						return Object.assign(Object.assign({}, e), {
							[u]: m
						})
					}
					default:
						return e
				}
			};
			const mh = {};
			var jh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case qe.e:
					case oe.e: {
						const {
							commentLists: s,
							postIds: n,
							profileName: r
						} = t.payload, a = {};
						for (const e of n) {
							a[Object(lh.a)(e, r)] = s[e] && s[e].head ? s[e].head.id : null
						}
						return Object.assign(Object.assign({}, e), a)
					}
					default:
						return e
				}
			};
			const _h = {};
			var hh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _h,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case qe.e:
						case oe.e: {
							const {
								postIds: s,
								profileName: n
							} = t.payload, r = {};
							for (const e of s) {
								r[Object(lh.a)(e, n)] = e
							}
							return Object.assign(Object.assign({}, e), r)
						}
						default:
							return e
					}
				},
				yh = Object(T.c)({
					api: sh,
					extraComments: uh,
					keyToCommentThreadLinkSets: fh,
					keyToHeadCommentId: jh,
					keyToPostId: hh
				}),
				Eh = Object(T.c)({
					chrono: X_,
					conversations: yh
				});
			const Ih = {};
			var vh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ih,
					t = arguments.length > 1 ? arguments[1] : void 0;
				return t.type, e
			};
			const Sh = {};
			var Th = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.a:
					case re.d: {
						const {
							listingKey: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case re.b:
					case re.c:
					case re.i:
					case re.f:
					case re.e:
					case re.g: {
						const {
							listingKey: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					default:
						return e
				}
			};
			const wh = {};
			var Ch = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.b:
						case re.f: {
							const {
								listingKey: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case re.a:
						case re.d:
						case re.c:
						case re.i:
						case re.e:
						case re.g: {
							const {
								listingKey: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Ah = Object(T.c)({
					error: Th,
					pending: Ch
				});
			const Dh = {};
			var Ph = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case re.c:
					case re.i:
					case re.e:
					case re.g: {
						const {
							listingKey: s,
							itemIds: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: [...e[s] || [], ...n]
						})
					}
					default:
						return e
				}
			};
			const Rh = {};
			var kh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case re.i:
						case re.c:
						case re.e:
						case re.g: {
							const {
								pageInfo: s,
								listingKey: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[n]: s
							}) : Rh
						}
						default:
							return e
					}
				},
				xh = Object(T.c)({
					api: Ah,
					ids: Ph,
					pageInfo: kh
				}),
				Nh = s("./src/reddit/constants/posts.ts");
			const Lh = {};
			var Uh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.c:
					case We.c:
						return Object.assign(Object.assign({}, e), t.payload.profileAboutInfo);
					case Og.k: {
						const s = t.payload;
						return s.profile ? Object.assign(Object.assign({}, e), {
							[s.profile.id]: s.about
						}) : e
					}
					case mg.h: {
						const {
							identifiers: s,
							userIsSubscriber: n
						} = t.payload, r = s.filter(e => e.type === Nh.a.PROFILE);
						return r.length ? r.reduce((e, t) => (e[t.id] = Object.assign(Object.assign({}, e[t.id]), {
							userIsSubscriber: n
						}), e), Object.assign({}, e)) : e
					}
					case Gl.n: {
						const s = t.payload,
							n = e[s.subredditId];
						if (!n) return e;
						if (n.publicDescription === s.settings.publicDescription) return e;
						const r = Object.assign(Object.assign({}, n), {
							publicDescription: s.settings.publicDescription
						});
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: r
						})
					}
					default:
						return e
				}
			};
			const Mh = {},
				Fh = (e, t) => {
					if (!t) return e;
					const s = Object.keys(t);
					if (!s.length) return e;
					const n = {};
					return s.forEach(s => {
						const r = e[s],
							a = Object.assign({}, t[s]);
						r && fn()(r, a) || (n[s] = a)
					}), Object.keys(n).length ? Object.assign(Object.assign({}, e), n) : e
				};
			var Gh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ue.b:
					case Fe.b:
					case te.b:
					case te.g:
					case se.b:
					case se.e:
					case re.c:
					case re.i:
					case re.e:
					case re.g:
					case qe.b:
					case qe.e:
					case ne.e:
					case Ve.b:
					case Ue.b:
					case Ge.e:
					case Ge.h:
					case Me.u:
					case Og.h:
					case _l.b:
					case We.c:
					case ce.i:
					case Og.m:
					case oe.b:
					case oe.e:
					case ae.c:
					case Be.b:
					case xr.e:
					case Ea.a:
					case ie.c:
					case te.k:
					case "RECOMMENDED_POSTS_LOADED":
					case mg.c:
						return Fh(e, t.payload.profiles);
					case We.e: {
						const {
							typeaheadSuggestions: s
						} = t.payload;
						return Object.keys(s).length ? Fh(e, s.profiles) : e
					}
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v:
					case ee.k: {
						const {
							response: s
						} = t.payload, n = s && s.profiles;
						return Fh(e, n)
					}
					case Og.l:
					case Og.k: {
						const {
							profile: s
						} = t.payload;
						return s ? Fh(e, {
							[s.id]: s
						}) : e
					}
					case Gl.n: {
						const s = t.payload,
							{
								title: n,
								over18: r
							} = s.settings,
							a = e[s.subredditId];
						return !a || a.title === n && a.isNSFW === r ? e : Object.assign(Object.assign({}, e), {
							[s.subredditId]: Object.assign(Object.assign({}, a), {
								id: s.subredditId,
								title: n,
								isNSFW: r
							})
						})
					}
					case Gl.l:
					case Gl.k: {
						const {
							imageUrl: s,
							key: n,
							subredditId: r
						} = t.payload;
						if ("profileIcon" !== n) return e;
						const a = e[r];
						return a ? Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, a), {
								icon: {
									height: null,
									url: s,
									width: null
								}
							})
						}) : e
					}
					default:
						return e
				}
			};
			const Bh = {};
			var qh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Og.c:
						case Og.f: {
							const {
								profileName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[(s || "").toLowerCase()]: !0
							})
						}
						case Og.a:
						case Og.b:
						case Og.d:
						case Og.e: {
							const {
								profileName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[(s || "").toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Vh = Object(T.c)({
					pending: qh
				});
			const Hh = {};
			var Kh = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Hh,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Og.b: {
						const {
							profileName: s,
							data: n
						} = t.payload, r = n.map(e => e.id);
						return Object.assign(Object.assign({}, e), {
							[(s || "").toLowerCase()]: r
						})
					}
					case Og.e:
					case re.c:
					case re.i:
					case re.e:
					case re.g: {
						const {
							profileName: s,
							moderatedSubredditIds: n
						} = t.payload;
						return n ? Object.assign(Object.assign({}, e), {
							[s]: [...e[s] || [], ...n]
						}) : e
					}
					default:
						return e
				}
			};
			const Wh = {};
			var Yh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Wh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Og.e: {
							const {
								pageInfo: s,
								profileName: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						case re.c:
						case re.i: {
							const {
								moderatedPageInfo: s,
								profileName: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				zh = Object(T.c)({
					api: Vh,
					models: Kh,
					pageInfo: Yh
				});
			const Jh = {};
			var Qh = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Og.i: {
							const {
								profileName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.toLowerCase()]: !0
							})
						}
						case Og.g:
						case Og.h: {
							const {
								profileName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Xh = Object(T.c)({
					pending: Qh
				});
			const Zh = {};
			var $h = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zh,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Og.h: {
							const {
								pageInfo: s,
								profileName: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				},
				ey = Object(T.c)({
					api: Xh,
					pageInfo: $h
				}),
				ty = s("./src/reddit/actions/pinnedPost.ts");
			const sy = {};
			var ny = Object(s_.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ty.a: {
						const {
							pinned: s,
							profileId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					case ty.d: {
						const {
							postId: s,
							profileId: n
						} = t.payload, r = e[n] || [];
						return Object.assign(Object.assign({}, e), {
							[n]: [...r, s].slice(-Ke.V)
						})
					}
					case ty.g: {
						const {
							postId: s,
							profileId: n
						} = t.payload, r = e[n] || [];
						return Object.assign(Object.assign({}, e), {
							[n]: r.filter(e => e !== s)
						})
					}
					default:
						return e
				}
			}), sy);
			const ry = {};
			var ay = Object(s_.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ry,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ty.a: {
						const {
							pinned: s,
							profileId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					default:
						return e
				}
			}), ry);
			const iy = {};
			var oy = Object(s_.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ty.c:
						case ty.f: {
							const {
								postId: s,
								profileId: n
							} = t.payload, r = e[n] || [];
							return Object.assign(Object.assign({}, e), {
								[n]: [...r, s]
							})
						}
						case ty.b:
						case ty.e:
						case ty.d:
						case ty.g: {
							const {
								postId: s,
								profileId: n
							} = t.payload, r = e[n] || [];
							return Object.assign(Object.assign({}, e), {
								[n]: r.filter(e => e !== s)
							})
						}
						default:
							return e
					}
				}), iy),
				cy = Object(T.c)({
					data: ny,
					initialData: ay,
					pending: oy
				}),
				dy = s("./src/reddit/actions/trophyCase.ts");
			const uy = {};
			var ly, by, py = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dy.a: {
							const {
								profileId: s,
								trophyIds: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				Oy = Object(T.c)({
					about: Uh,
					models: Gh,
					moderated: zh,
					multireddits: ey,
					pinnedPosts: cy,
					trophyCases: py
				});
			s("./src/lib/cache/index.ts");
			! function(e) {
				e.MobilePromoBanner = "mobilePromoBanner", e.UpsellSignUpBannerLarge = "upsellSignUpBannerLarge", e.UpsellSignUpBannerMedium = "upsellSignUpBannerMedium", e.UpsellSignUpBannerSmall = "upsellSignUpBannerSmall"
			}(ly || (ly = {})),
			function(e) {
				e[e.FrontPage = 0] = "FrontPage", e[e.SubredditPage = 1] = "SubredditPage", e[e.CommentsPage = 2] = "CommentsPage"
			}(by || (by = {}));
			var gy, fy, my;
			! function(e) {
				e.mobilePromoBanner = "desktop_xpromo_banner"
			}(gy || (gy = {})),
			function(e) {
				e.Test1 = "test_1", e.Test2 = "test_2"
			}(fy || (fy = {})),
			function(e) {
				e.Test1 = "test_1", e.Test2 = "test_2"
			}(my || (my = {}));
			! function(e) {
				e.welcome = "signup_upsell_banner_welcome", e.join = "signup_upsell_banner_redditor", e.vote = "signup_upsell_banner_discuss", e.personalize = "signup_upsell_banner_personalize"
			}(gy || (gy = {}));
			Object(He.a)("PROMO__SHOW_PROMO"), Object(He.a)("PROMO__HIDE_PROMO");
			const jy = {
				mobilePromoBanner: !1,
				upsellSignUpBannerLarge: !1,
				upsellSignUpBannerMedium: !1,
				upsellSignUpBannerSmall: null
			};
			var _y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "PROMO__SHOW_PROMO": {
							const {
								promoType: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case "PROMO__HIDE_PROMO": {
							const {
								promoType: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				hy = s("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const yy = {
				isError: !1,
				isPending: !1,
				global: {
					rpan_config_refresh_rate: hy.d,
					viewer_streams_refresh: hy.c,
					viewer_streams_refresh_slop: hy.e
				},
				subreddits: {},
				isPermanentlyCanceled: !1
			};
			var Ey = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hy.w:
							return Object.assign(Object.assign({}, e), {
								isError: !1,
								isPending: !1,
								global: Object.assign({}, t.payload)
							});
						case hy.x: {
							const s = t.payload.name.toLowerCase();
							return Object.assign(Object.assign({}, e), {
								isError: !1,
								isPending: !1,
								subreddits: Object.assign(Object.assign({}, e.subreddits), {
									[s]: Object.assign({}, t.payload.config)
								})
							})
						}
						case hy.G:
							return Object.assign(Object.assign({}, e), {
								isPending: !0
							});
						case hy.I:
							return Object.assign(Object.assign({}, e), {
								isError: !0,
								isPending: !1
							});
						case hy.H:
							return Object.assign(Object.assign({}, e), {
								isPermanentlyCanceled: !0,
								isPending: !1
							});
						default:
							return e
					}
				},
				Iy = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			var vy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.L:
						return Object.assign(Object.assign({}, e), {
							[hy.b]: t.payload.error
						});
					case hy.M:
						return Object.assign(Object.assign({}, e), {
							[t.payload.streamId]: t.payload.error
						});
					case hy.z: {
						const t = e,
							s = hy.b;
						t[s];
						return Iy(t, ["symbol" == typeof s ? s : s + ""])
					}
					case hy.y: {
						const s = e,
							n = t.payload.model.post.id;
						s[n];
						return Iy(s, ["symbol" == typeof n ? n : n + ""])
					}
					default:
						return e
				}
			};
			const Sy = (e, t, s, n) => Object.assign(Object.assign({}, e), {
				[t]: Object.assign(Object.assign(Object.assign({}, e[t]), {
					isPending: s
				}), n && {
					utcTimeStamp: n
				})
			});
			var Ty = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.N:
						return Sy(e, t.payload, !0);
					case hy.O:
						return Sy(e, hy.b, !0);
					case hy.y:
						return Sy(e, t.payload.model.post.id, !1, t.payload.utcTimeStamp);
					case hy.z:
						return Sy(e, hy.b, !1, t.payload.utcTimeStamp);
					case hy.M:
						return Sy(e, t.payload.streamId, !1);
					case hy.L:
						return Sy(e, hy.b, !1);
					default:
						return e
				}
			};
			const wy = {
				isError: !1,
				isPending: !1,
				subreddits: []
			};
			var Cy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hy.v:
							return Object.assign(Object.assign({}, e), {
								isError: !1,
								isPending: !1,
								subreddits: t.payload.subreddits
							});
						case hy.J:
							return Object.assign(Object.assign({}, e), {
								isError: !1,
								isPending: !0
							});
						case hy.K:
							return Object.assign(Object.assign({}, e), {
								isError: !0,
								isPending: !1
							});
						default:
							return e
					}
				},
				Ay = Object(T.c)({
					config: Ey,
					error: vy,
					pending: Ty,
					recommendedViewerSubreddits: Cy
				});
			const Dy = {};
			var Py = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.r:
						return Object.assign(Object.assign({}, e), {
							[t.payload.streamId]: {
								level: t.payload.level,
								error: !1
							}
						});
					case hy.F:
						return Object.assign(Object.assign({}, e), {
							[t.payload]: {
								level: 0,
								error: !0
							}
						});
					default:
						return e
				}
			};
			const Ry = {
				cursor: hy.W,
				timestamps: {},
				visitOrder: []
			};
			var ky = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ry,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.P:
						return Ry;
					case hy.X: {
						const s = t.payload,
							n = e.visitOrder.includes(s) ? e.visitOrder : [...e.visitOrder, s],
							r = n.indexOf(s);
						return n === e.visitOrder && r === e.cursor ? e : Object.assign(Object.assign({}, e), {
							visitOrder: n,
							cursor: r
						})
					}
					case O.d:
						return xy(e, t.payload.id);
					case hy.E:
						return xy(e, t.payload);
					case Ll.h: {
						const s = Object.keys(t.payload).filter(e => t.payload[e].hidden);
						return Ny(e, s)
					}
					case hy.V: {
						const {
							streamId: s,
							timestamp: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							timestamps: Object.assign(Object.assign({}, e.timestamps), {
								[s]: n
							})
						})
					}
					default:
						return e
				}
			};
			const xy = (e, t) => {
					const s = e.visitOrder.indexOf(t);
					if (-1 === s) return e;
					const n = s > e.cursor ? e.cursor : Math.max(e.cursor - 1, 0);
					return Object.assign(Object.assign({}, e), {
						visitOrder: e.visitOrder.filter(e => e !== t),
						cursor: n
					})
				},
				Ny = (e, t) => {
					const s = e.visitOrder[e.cursor],
						n = new Set(t),
						r = e.visitOrder.filter(e => !n.has(e)),
						a = r.indexOf(s),
						i = a > -1 ? a : Math.max(e.cursor - 1, 0);
					return r.length !== e.visitOrder.length ? Object.assign(Object.assign({}, e), {
						cursor: i,
						visitOrder: r
					}) : e
				},
				Ly = {
					ended: [],
					removed: []
				};

			function Uy(e) {
				return [...new Set(e)]
			}
			var My = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ly,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.t:
						return Object.assign(Object.assign({}, e), {
							ended: Uy(e.ended.concat(t.payload))
						});
					case hy.u:
						return Object.assign(Object.assign({}, e), {
							removed: Uy(e.removed.concat(t.payload))
						});
					default:
						return e
				}
			};
			const Fy = {};
			var Gy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.z:
						const {
							listingName: s, models: n
						} = t.payload;
						if (!s) return e;
						const r = n.map(e => e.post.id),
							a = e[s] || [],
							i = [...new Set([...r, ...a])];
						return Object.assign(Object.assign({}, e), {
							[s]: i
						});
					default:
						return e
				}
			};
			const By = {},
				qy = (e, t) => {
					const s = Object.keys(e).reduce((t, s) => Object.assign(Object.assign({}, t), {
						[s]: Object.assign(Object.assign({}, e[s]), {
							rank: hy.m
						})
					}), {});
					return t.reduce((e, t, s) => Object.assign(Object.assign({}, e), {
						[t.post.id]: Object.assign(Object.assign({}, t), {
							rank: hy.l - s
						})
					}), s)
				},
				Vy = (e, t) => {
					const s = t.post.id,
						n = e[s] ? e[s].rank : hy.m;
					return Object.assign(Object.assign({}, e), {
						[t.post.id]: Object.assign(Object.assign({}, t), {
							rank: n
						})
					})
				};
			var Hy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : By,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.y:
						return Vy(e, t.payload.model);
					case hy.z:
						return qy(e, t.payload.models);
					case hy.D: {
						const s = t.payload.streamId,
							n = t.payload.isUnsetting ? -1 : 1,
							r = (t.payload.isUp ? 1 : 0) * n,
							a = (t.payload.isUp ? 0 : 1) * n;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								downvotes: e[s].downvotes + a,
								upvotes: e[s].upvotes + r
							})
						})
					}
					default:
						return e
				}
			};
			const Ky = {
				discoveryUnitThumbnails: {},
				streamPreviews: {}
			};
			var Wy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ky,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.s:
						return Object.assign(Object.assign({}, e), {
							discoveryUnitThumbnails: Object.assign({}, t.payload.reduce((e, t) => Object.assign(Object.assign({}, e), {
								[t.postId]: t.imageUrl
							}), {}))
						});
					case hy.A:
						return Object.assign(Object.assign({}, e), {
							streamPreviews: Object.assign(Object.assign({}, e.streamPreviews), t.payload.reduce((e, t) => Object.assign(Object.assign({}, e), {
								[t.postId]: t.imageUrl
							}), {}))
						});
					default:
						return e
				}
			};
			const Yy = {
				reported: []
			};
			var zy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.d:
						return Object.assign(Object.assign({}, e), {
							reported: [...e.reported, t.payload.id]
						});
					default:
						return e
				}
			};
			const Jy = {
				isIntroFinished: !1
			};
			var Qy = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jy,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hy.B:
						return Object.assign(Object.assign({}, e), t.payload);
					default:
						return e
				}
			};
			const Xy = {
				isMuted: !0,
				reportedStreams: [],
				shouldShowOnboardingModal: !0
			};
			var Zy = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Xy,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hy.C:
							return Object.assign(Object.assign({}, e), t.payload);
						case O.d: {
							const s = t.payload.id;
							return e.reportedStreams.includes(s) ? e : Object.assign(Object.assign({}, e), {
								reportedStreams: [...e.reportedStreams, s]
							})
						}
						default:
							return e
					}
				},
				$y = Object(T.c)({
					api: Ay,
					history: ky,
					hlsStreams: My,
					listings: Gy,
					models: Hy,
					preloads: Wy,
					reports: zy,
					theaterSettings: Qy,
					userSettings: Zy,
					automuteLevels: Py
				});
			const eE = {};
			var tE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "RECOMMENDED_POSTS_LOADED":
							return Object.assign(Object.assign({}, e), t.payload);
						case "RECOMMENDED_POSTS_FAILED":
						default:
							return e
					}
				},
				sE = s("./src/reddit/actions/removalReasons/constants.ts");
			var nE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sE.k:
					case sE.l:
					case sE.b:
					case sE.c:
					case sE.h:
					case sE.i:
					case sE.e:
					case sE.f:
						return null;
					case sE.j:
					case sE.a:
					case sE.g:
					case sE.d:
						return t.payload;
					default:
						return e
				}
			};
			var rE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case sE.k:
						case sE.b:
						case sE.h:
						case sE.e:
							return !0;
						case sE.l:
						case sE.j:
						case sE.c:
						case sE.a:
						case sE.i:
						case sE.g:
						case sE.f:
						case sE.d:
							return !1;
						default:
							return e
					}
				},
				aE = Object(T.c)({
					error: nE,
					pending: rE
				}),
				iE = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const oE = {};
			var cE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sE.l: {
						const {
							response: s
						} = t.payload, {
							data: n
						} = s;
						return Object.assign(Object.assign({}, e), n)
					}
					case sE.c:
					case sE.i: {
						const {
							reason: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.id]: s
						})
					}
					case sE.f: {
						const {
							reasonId: s
						} = t.payload, n = e, r = s;
						n[r];
						return iE(n, ["symbol" == typeof r ? r : r + ""])
					}
					default:
						return e
				}
			};
			const dE = {};
			var uE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case sE.l: {
						const {
							subredditId: s,
							response: n
						} = t.payload, {
							order: r
						} = n;
						return Object.assign(Object.assign({}, e), {
							[s]: r
						})
					}
					case sE.c: {
						const {
							subredditId: s,
							reason: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: [...e[s], n.id]
						})
					}
					case sE.f: {
						const {
							subredditId: s,
							reasonId: n
						} = t.payload, r = [...e[s]].filter(e => e !== n);
						return Object.assign(Object.assign({}, e), {
							[s]: r
						})
					}
					default:
						return e
				}
			};
			var lE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case sE.t: {
							const {
								subredditId: e,
								itemIds: s
							} = t.payload;
							return {
								itemIds: s,
								subredditId: e
							}
						}
						default:
							return e
					}
				},
				bE = Object(T.c)({
					api: aE,
					models: cE,
					reasonOrder: uE,
					removedItemIds: lE
				});
			const pE = {};
			var OE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.e:
					case O.d: {
						const {
							id: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !1
						})
					}
					case O.c: {
						const {
							id: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					case O.f: {
						const s = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[s]: !1
						}) : e
					}
					default:
						return e
				}
			};
			const gE = {};
			var fE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.e: {
						const {
							id: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					case O.d:
					case O.c: {
						const {
							id: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !1
						})
					}
					case O.f: {
						const s = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[s]: !1
						}) : e
					}
					default:
						return e
				}
			};
			const mE = {};
			var jE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case O.d: {
							const {
								id: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case O.e:
						case O.c: {
							const {
								id: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case O.f: {
							const s = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[s]: !1
							}) : e
						}
						default:
							return e
					}
				},
				_E = Object(T.c)({
					error: OE,
					pending: fE,
					success: jE
				});
			var hE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.a:
						return t.payload;
					case n.c:
						return !t.payload && e;
					case l.a:
						return !1;
					case O.f:
						return !!t.payload && e;
					default:
						return e
				}
			};
			var yE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.f:
						return t.payload;
					case n.c:
						return t.payload ? null : e;
					case l.a:
						return null;
					default:
						return e
				}
			};
			var EE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case O.g:
						return t.payload;
					case O.f:
						return !1;
					default:
						return e
				}
			};
			var IE = Object(T.c)({
					api: _E,
					openedFromModalPage: hE,
					postOrCommentId: yE,
					userIsMod: EE,
					rulesCategory: function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 ? arguments[1] : void 0;
						switch (t.type) {
							case O.b:
								return t.payload
						}
						return e
					}
				}),
				vE = s("./src/reddit/actions/pages/report/constants.ts");
			var SE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vE.a:
						return t.payload;
					default:
						return e
				}
			};
			var TE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vE.b:
						return t.payload;
					case vE.c:
					case vE.d:
						return !1;
					default:
						return e
				}
			};
			var wE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vE.d:
						return !0;
					case vE.c:
					case vE.b:
						return !1;
					default:
						return e
				}
			};
			var CE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vE.c:
							return !0;
						case vE.b:
						case vE.d:
							return !1;
						default:
							return e
					}
				},
				AE = Object(T.c)({
					error: TE,
					pending: wE,
					success: CE
				}),
				DE = s("./src/reddit/actions/reportPageRules/constants.ts");
			const PE = [];
			var RE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case DE.a:
							return t.payload;
						default:
							return e
					}
				},
				kE = Object(T.c)({
					reportPageApi: AE,
					reportPageRules: RE,
					initialReason: SE
				}),
				xE = s("./src/reddit/actions/reportRules.ts");
			const NE = {
				liveStreamingRules: [],
				sitewideRules: []
			};
			var LE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xE.b:
						return Object.assign(Object.assign({}, e), {
							sitewideRules: t.payload
						});
					case xE.a:
						return Object.assign(Object.assign({}, e), {
							liveStreamingRules: t.payload
						});
					default:
						return e
				}
			};
			Object(He.a)("REQUEST_HOST_SET");
			var UE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "REQUEST_HOST_SET":
						return t.payload;
					default:
						return e
				}
			};
			const ME = "RUN_TIME_ENV_VARS__IS_STAGING",
				FE = (Object(He.a)(ME), {
					staging: !1,
					startTimeInMillis: (new Date).getTime()
				});
			var GE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ME:
						return Object.assign(Object.assign({}, e), {
							staging: !0
						});
					default:
						return e
				}
			};
			const BE = Object.create(null);
			var qE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BE,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (null !== Object.getPrototypeOf(e) && (e = Object.assign(Object.create(null), e)), t.type) {
					case We.d: {
						const {
							relatedQueries: s,
							query: n
						} = t.payload;
						if (s) {
							const t = n ? n.toLowerCase() : "";
							return Object.assign(Object.create(null), e, {
								[t]: s
							})
						}
						return e
					}
					default:
						return e
				}
			};
			var VE = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.c:
					case We.f: {
						const {
							searchQuery: e
						} = t.payload;
						return e || null
					}
					default:
						return e
				}
			};
			const HE = Object.create(null);
			var KE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : HE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (null !== Object.getPrototypeOf(e) && (e = Object.assign(Object.create(null), e)), t.type) {
						case We.e: {
							const {
								order: s,
								searchQuery: n
							} = t.payload;
							return Object.assign(Object.create(null), e, Object.assign(Object.assign({}, e), {
								[n.toLowerCase()]: s
							}))
						}
						default:
							return e
					}
				},
				WE = s("./src/reddit/models/Search/index.ts");
			const YE = {};
			var zE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case We.e: {
							const {
								typeaheadSuggestions: s
							} = t.payload, n = {};
							return Object.keys(s).forEach(e => {
								const t = s[e];
								return n[e] = Object(WE.d)(t)
							}), Object.assign(Object.assign({}, e), n)
						}
						default:
							return e
					}
				},
				JE = Object(T.c)({
					idsByQuery: KE,
					models: zE
				});
			const QE = {};
			var XE = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : QE,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.c: {
							const {
								viewTreatment: s,
								key: n
							} = t.payload;
							return s ? Object.assign(Object.assign({}, e), {
								[n]: s
							}) : e
						}
						default:
							return e
					}
				},
				ZE = Object(T.c)({
					relatedQueries: qE,
					searchQuery: VE,
					typeahead: JE,
					viewTreatment: XE
				}),
				$E = s("./src/reddit/models/SearchDiscoveryUnit/index.ts");
			const eI = {};
			var tI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.c: {
						const {
							categoryName: s,
							key: n,
							listingOrder: r,
							postOrder: a,
							posts: i,
							searchQuery: o,
							subreddits: c,
							viewTreatment: d
						} = t.payload, u = {
							subredditIcons: [],
							displayText: null,
							subredditOccurrences: 0,
							searchQuery: o
						};
						if (d === $E.c.Trending || s) {
							const e = [];
							if (r && r.map(t => {
									!e.includes(t.id) && c[t.id] && (e.push(t.id), u.subredditIcons.push({
										url: c[t.id].icon.url,
										subredditName: c[t.id].name
									}), u.displayText || (u.displayText = c[t.id].displayText))
								}), a)
								for (let t = 0; t < a.length; t++) {
									const s = i[a[t]],
										n = s && s.belongsTo ? s.belongsTo.id : void 0;
									n && !e.includes(n) && c[n] && (e.push(n), u.subredditIcons.push({
										url: c[n].icon.url,
										subredditName: c[n].name
									}))
								}
							c && (u.subredditOccurrences = Object.keys(c).length - 1)
						}
						return Object.assign(Object.assign({}, e), {
							[n]: u
						})
					}
					default:
						return e
				}
			};
			const sI = {};
			var nI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ae.c: {
						const {
							key: s,
							searchDiscoveryUnits: n
						} = t.payload;
						return n && Object.keys(n).length ? Object.assign(Object.assign({}, e), {
							[s]: n
						}) : e
					}
					default:
						return e
				}
			};
			const rI = {};
			var aI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ae.c: {
							const {
								key: s,
								searchDiscoveryUnitOrder: n
							} = t.payload;
							return n ? Object.assign(Object.assign({}, e), {
								[s]: n
							}) : rI
						}
						default:
							return e
					}
				},
				iI = Object(T.c)({
					headerContent: tI,
					models: nI,
					order: aI
				});
			Object(He.a)("SEO__CRAWLER_RECEIVED");
			var oI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "SEO__CRAWLER_RECEIVED":
							return t.payload;
						default:
							return e
					}
				},
				cI = s("./src/reddit/actions/seo/linksModule.ts");
			const dI = {};
			var uI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case cI.a:
							return Array.isArray(t.payload) && 0 !== t.payload.length ? Object.assign(Object.assign({}, e), {
								frontpage: t.payload
							}) : e;
						case cI.b:
							return t.payload && t.payload.id && t.payload.data ? Object.assign(Object.assign({}, e), {
								subreddits: Object.assign(Object.assign({}, e.subreddits), {
									[t.payload.id]: t.payload.data
								})
							}) : e;
						default:
							return e
					}
				},
				lI = Object(T.c)({
					crawler: oI,
					linksModule: uI
				}),
				bI = s("./src/reddit/actions/shortcuts/constants.ts");
			var pI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case bI.a:
						return t.payload;
					case l.a:
						return null;
					default:
						return e
				}
			};
			var OI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case bI.b:
							return t.payload || null;
						default:
							return e
					}
				},
				gI = s("./src/reddit/constants/history.ts"),
				fI = s("./src/reddit/constants/shortcuts.ts"),
				mI = s("./src/reddit/helpers/history/index.ts");
			const jI = fI.d.Global,
				_I = e => {
					switch (e.name) {
						case "comments":
						case "duplicates":
						case "metaMembershipPaywallPage":
							return Object(mI.b)(gI.a.IsOverlay) ? fI.d.Lightbox : fI.d.CommentPage;
						case "rpan":
						case "subredditCreation":
							return Object(mI.b)(gI.a.IsOverlay) ? fI.d.Lightbox : jI;
						case "index":
						case "listing":
						case "multireddit":
						case "searchResults":
						case "subreddit":
							return fI.d.Listing;
						case "modQueuePages":
							return fI.d.Modqueue;
						default:
							return jI
					}
				};
			var hI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case l.a:
							const s = t.payload;
							if (s.routeMatch) {
								const e = s.routeMatch.route.meta;
								return _I(e)
							}
							return jI;
						default:
							return e
					}
				},
				yI = Object(T.c)({
					activeCommentId: pI,
					activePostId: OI,
					namespace: hI
				});
			var EI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					if (e) return e;
					switch (t.type) {
						case j.p:
						case j.q:
							return !0;
						default:
							return e
					}
				},
				II = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				vI = Object(T.c)({
					firstFetch: EI,
					models: II.b
				}),
				SI = s("./src/reddit/actions/streaming/modSettings.ts");
			var TI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case SI.b:
					case SI.c:
						return null;
					case SI.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var wI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case SI.b:
							return !0;
						case SI.c:
						case SI.a:
							return !1;
						default:
							return e
					}
				},
				CI = Object(T.c)({
					error: TI,
					pending: wI
				}),
				AI = s("./src/reddit/actions/streaming/constants.ts");
			const DI = {};
			var PI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case AI.a: {
							const {
								subredditId: s,
								modSettings: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				RI = Object(T.c)({
					api: CI,
					modSettings: PI
				}),
				kI = s("./src/reddit/models/StructuredStyles/index.ts");
			const xI = {};
			var NI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case g.h:
						case g.b:
						case g.d:
							return t.payload.styles;
						case g.e:
							return xI;
						case g.c: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						case g.k: {
							const e = t.payload;
							return Object(kI.h)(e.styles)
						}
						default:
							return e
					}
				},
				LI = s("./src/reddit/actions/exportImportStyles.ts");
			var UI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case LI.c:
					case LI.b:
						return null;
					case LI.a:
						return t.payload;
					default:
						return e
				}
			};
			var MI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case LI.c:
							return !0;
						case LI.b:
						case LI.a:
							return !1;
						default:
							return e
					}
				},
				FI = Object(T.c)({
					error: UI,
					pending: MI
				}),
				GI = s("./src/reddit/actions/postFlairStyleTemplate.ts"),
				BI = s("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const qI = {};
			var VI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Fe.b:
						case te.b:
						case ae.c:
						case We.c:
						case Be.b:
						case Ea.a: {
							const {
								payload: s
							} = t;
							if (!s.structuredStyles || !s.structuredStyles.data) return e;
							const n = s.structuredStyles.data.flairTemplate;
							return Object.assign(Object.assign({}, e), n)
						}
						case GI.b: {
							const {
								flairId: s,
								template: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case GI.a: {
							const {
								flairId: s
							} = t.payload;
							return Object(Ss.a)(e, s)
						}
						case Bf.b: {
							const {
								templateId: s
							} = t.payload;
							return Object(Ss.a)(e, s)
						}
						case g.k:
							return qI;
						case BI.b: {
							const {
								templates: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				HI = Object(T.c)({
					models: VI
				});
			const KI = {};
			var WI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : KI,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.f: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.imageKey]: s.uploadId
						})
					}
					case g.k:
					case g.e:
						return KI;
					default:
						return e
				}
			};
			var YI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.n:
					case g.e:
						return !1;
					case g.a:
						return !0;
					default:
						return e
				}
			};
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			var zI = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.d:
						return t.payload.subredditId;
					case g.e:
						return null;
					case l.a:
						return t.payload.location.search.indexOf("styling=true") > -1 ? e : null;
					case Gl.f:
						return null;
					default:
						return e
				}
			};
			const JI = {};
			var QI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JI,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case Fe.b:
						case te.b:
						case Be.b:
						case Ea.a: {
							const {
								payload: s
							} = t;
							if (!s.structuredStyles || !s.structuredStyles.data) return e;
							const n = Object.keys(s.subredditAboutInfo || {});
							if (1 !== n.length) return e;
							const r = n[0],
								a = s.structuredStyles.data.style;
							return Object.assign(Object.assign({}, e), {
								[r]: a
							})
						}
						case We.c:
						case ae.c: {
							const {
								payload: s
							} = t;
							if (!s.structuredStyles || !s.structuredStyles.data) return e;
							if (!s.subredditName) return e;
							let n;
							if (zi()(s.subreddits, (e, t) => {
									if (e.name.toLowerCase() === s.subredditName.toLowerCase()) return n = t, !1
								}), !n) return e;
							const r = s.structuredStyles.data.style;
							return Object.assign(Object.assign({}, e), {
								[n]: r
							})
						}
						case g.m: {
							const s = t.payload,
								n = e[s.subredditId];
							return Object.assign(Object.assign({}, e), {
								[s.subredditId]: Object.assign(Object.assign({}, n), s.styles)
							})
						}
						case g.h: {
							const s = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.subredditId]: s.styles
							})
						}
						case g.k: {
							const s = t.payload,
								n = Object(kI.h)(s.styles);
							return Object.assign(Object.assign({}, e), {
								[s.subredditId]: n
							})
						}
						case Og.k: {
							const s = t.payload,
								{
									banner: n,
									profile: r
								} = s;
							if (!n || !r) return e;
							const a = e[r.id];
							return Object.assign(Object.assign({}, e), {
								[r.id]: Object.assign(Object.assign({}, a), {
									bannerBackgroundImage: n.url
								})
							})
						}
						case Gl.l: {
							const s = t.payload;
							if ("profileBanner" === s.key) {
								return Pm(e, {
									[s.subredditId]: {
										bannerBackgroundImage: s.imageUrl
									}
								})
							}
							return e
						}
						case Gl.k: {
							const s = t.payload;
							if ("profileBanner" === s.key) {
								return Pm(e, {
									[s.subredditId]: {
										bannerBackgroundImage: void 0
									}
								})
							}
							return e
						}
						default:
							return e
					}
				},
				XI = Object(T.c)({
					draft: NI,
					exportStyles: FI,
					flairTemplate: HI,
					imagePreviews: WI,
					isBladeEditorDirty: YI,
					isEditing: zI,
					models: QI
				});
			Object(He.a)("STYLESHEETS__EXTRACTED_FROM_MANIFEST");
			var ZI = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "STYLESHEETS__EXTRACTED_FROM_MANIFEST":
							return t.payload;
						default:
							return e
					}
				},
				$I = s("./src/reddit/actions/subredditAutocomplete.ts");
			const ev = {};
			var tv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ev,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case $I.c:
					case $I.b: {
						const {
							key: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: null
						})
					}
					case $I.a: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const sv = {};
			var nv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $I.c: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case $I.b:
						case $I.a: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				rv = Object(T.c)({
					error: tv,
					pending: nv
				});
			const av = {};
			var iv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : av,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $I.b: {
							const {
								key: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: t.payload
							})
						}
						default:
							return e
					}
				},
				ov = Object(T.c)({
					api: rv,
					models: iv
				});
			const cv = {};
			var dv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ms.c: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					case ms.a:
					case ms.d: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !1
						})
					}
					default:
						return e
				}
			};
			const uv = {};
			var lv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ms.d: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !0
						})
					}
					case ms.a:
					case ms.c: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: !1
						})
					}
					default:
						return e
				}
			};
			const bv = {};
			var pv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ms.d: {
							const {
								subredditId: s
							} = t.payload;
							return e[s] ? e : Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						case ms.a: {
							const {
								subredditId: s,
								isSubredditWhitelisted: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						case ms.c: {
							const {
								subredditId: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				Ov = Object(T.c)({
					error: dv,
					pending: lv,
					whitelist: pv
				}),
				gv = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var r = 0;
						for (n = Object.getOwnPropertySymbols(e); r < n.length; r++) t.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[r]) && (s[n[r]] = e[n[r]])
					}
					return s
				};
			const fv = {};
			var mv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ms.a:
						return Object.assign(Object.assign({}, e), t.payload.collection);
					case ms.e: {
						const {
							channel: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.channelId]: Object.assign({}, s)
						})
					}
					case ms.f: {
						const {
							channel: s,
							editedSubredditChannelData: n
						} = t.payload;
						return s.name = n.room, s.description = n.description, s.minimumAcctAge = s.minimumAcctAge, s.newMemberAge = s.newMemberAge, Object.assign(Object.assign({}, e), {
							[s.channelId]: Object.assign({}, s)
						})
					}
					case ms.g: {
						const s = e,
							n = t.payload;
						s[n];
						return gv(s, ["symbol" == typeof n ? n : n + ""])
					}
					default:
						return e
				}
			};
			var jv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ms.h:
							return t.payload.channelId;
						case ms.g:
							return e === t.payload ? null : e;
						default:
							return e
					}
				},
				_v = Object(T.c)({
					api: Ov,
					models: mv,
					selected: jv
				}),
				hv = s("./src/reddit/actions/category/constants.ts"),
				yv = s("./src/reddit/actions/subredditMention/constants.ts");
			const Ev = {};
			var Iv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ev,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case yv.d:
					case Fe.b:
					case te.b:
					case ae.c:
					case ie.a:
					case ie.c:
					case Be.b:
					case Ea.a:
					case se.b:
					case se.e:
					case qe.b:
					case qe.a:
					case qe.e:
					case qe.d:
					case ne.e:
					case oe.b:
					case oe.e:
					case We.c:
					case hl.e: {
						const s = t.payload.subredditAboutInfo;
						if (!s) return e;
						const n = Object.keys(s);
						return 0 === n.length ? e : n.reduce((e, t) => (s[t] && (e[t] ? e[t] = Object.assign(Object.assign({}, e[t]), s[t]) : e[t] = s[t]), e), Object.assign({}, e))
					}
					case So.a: {
						const {
							subredditId: s,
							emojisEnabled: n
						} = t.payload, r = e[s], a = Object.assign(Object.assign({}, r), {
							emojisEnabled: n
						});
						return Object.assign(Object.assign({}, e), {
							[s]: a
						})
					}
					case mg.h: {
						const {
							identifiers: s,
							userIsSubscriber: n
						} = t.payload, r = s.filter(e => e.type === Nh.a.SUBREDDIT);
						return r.length ? r.reduce((e, t) => Object(U.setIn)(e, [t.id, "userIsSubscriber"], n), e) : e
					}
					case Uc.g:
					case hv.f:
					case vl.e:
					case vl.m: {
						const {
							subredditsAboutInfo: s
						} = t.payload;
						if (!s) return e;
						const n = Object.keys(s);
						return 0 === n.length ? e : n.reduce((e, t) => (s[t] && (e[t] = e[t] ? Object.assign(Object.assign({}, e[t]), s[t]) : s[t]), e), Object.assign({}, e))
					}
					case So.b: {
						const s = t.payload,
							{
								emojiCustomSize: n,
								subredditId: r
							} = s,
							a = e[r];
						if (!a) return e;
						const i = Object.assign({}, a);
						if (n) {
							const {
								width: e,
								height: t
							} = n;
							i.emojisCustomSize = [e, t]
						} else delete i.emojisCustomSize;
						return Object.assign(Object.assign({}, e), {
							[r]: i
						})
					}
					case ce.c: {
						const {
							data: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					case ge.t: {
						const {
							subredditId: s,
							subredditCoins: n
						} = t.payload;
						if (!s || !n) return e;
						const r = e[s];
						if (!r) return e;
						const a = Object.assign(Object.assign({}, r), {
							coins: n
						});
						return Object.assign(Object.assign({}, e), {
							[s]: a
						})
					}
					default:
						return e
				}
			};
			const vv = {};
			var Sv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.b:
					case ce.c: {
						const {
							subredditName: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: null
						})
					}
					case ce.a: {
						const {
							subredditName: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: n
						})
					}
					default:
						return e
				}
			};
			var Tv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.b:
							return !0;
						case ce.c:
						case ce.a:
							return !1;
						default:
							return e
					}
				},
				wv = Object(T.c)({
					error: Sv,
					pending: Tv
				}),
				Cv = s("./src/reddit/actions/subredditCreation.ts");
			const Av = {
				apiError: null
			};
			var Dv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Av,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cv.b: {
						const {
							error: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							apiError: s
						})
					}
					case Cv.a:
					case Cv.c:
					case Cv.d:
						return Av;
					default:
						return e
				}
			};
			var Pv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Cv.d: {
						const {
							subredditName: e
						} = t.payload;
						return e || null
					}
					case Cv.c:
					case Cv.b:
						return null;
					default:
						return e
				}
			};
			var Rv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Cv.c:
							return !0;
						case Cv.d:
						case Cv.b:
							return !1;
						default:
							return e
					}
				},
				kv = Object(T.c)({
					error: Dv,
					lastCreatedSubredditId: Pv,
					pending: Rv
				});
			var xv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vl.r:
							return !0;
						case vl.s:
						case vl.q:
							return !1;
						default:
							return e
					}
				},
				Nv = Object(T.c)({
					pending: xv
				});
			const Lv = {};
			var Uv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lv,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.l:
					case ce.m: {
						const {
							subredditName: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: null
						})
					}
					case ce.k: {
						const {
							subredditName: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: n
						})
					}
					default:
						return e
				}
			};
			const Mv = {};
			var Fv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Mv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.l: {
							const {
								subredditName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.toLowerCase()]: !0
							})
						}
						case ce.m:
						case ce.k: {
							const {
								subredditName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				Gv = Object(T.c)({
					error: Uv,
					pending: Fv
				});
			const Bv = {};
			var qv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Bv,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vl.d:
						case vl.e:
							return Object.assign(Object.assign({}, e), {
								[t.payload.key]: !1
							});
						case vl.f:
							return Object.assign(Object.assign({}, e), {
								[t.payload.key]: !0
							});
						default:
							return e
					}
				},
				Vv = Object(T.c)({
					pending: qv
				});
			var Hv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.X:
						return t.payload || null;
					case ge.Z:
					case ge.Y:
						return null;
					default:
						return e
				}
			};
			var Kv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.Z:
							return !0;
						case ge.Y:
						case ge.X:
							return !1;
						default:
							return e
					}
				},
				Wv = Object(T.c)({
					error: Hv,
					pending: Kv
				});
			var Yv = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vl.i: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case vl.k:
					case vl.j:
						return null;
					default:
						return e
				}
			};
			var zv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vl.k:
							return !0;
						case vl.j:
						case vl.i:
							return !1;
						default:
							return e
					}
				},
				Jv = Object(T.c)({
					error: Yv,
					pending: zv
				}),
				Qv = s("./src/reddit/actions/subredditRules/constants.ts");
			var Xv = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Qv.c:
							return !0;
						case Qv.a:
						case Qv.b:
							return !1;
						default:
							return e
					}
				},
				Zv = s("./src/reddit/actions/subredditSettings.ts");
			var $v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Zv.e:
							return !0;
						case Zv.f:
						case Zv.d:
							return !1;
						default:
							return e
					}
				},
				eS = Object(T.c)({
					pending: $v
				});
			const tS = {};
			var sS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vl.l:
						case vl.m:
							return Object.assign(Object.assign({}, e), {
								[t.payload.key]: !1
							});
						case vl.n:
							return Object.assign(Object.assign({}, e), {
								[t.payload.key]: !0
							});
						default:
							return e
					}
				},
				nS = Object(T.c)({
					pending: sS
				}),
				rS = s("./src/reddit/actions/pages/subredditWiki/constants.ts");
			const aS = {};
			var iS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case rS.c:
					case rS.b: {
						const s = t.payload,
							{
								subredditName: n
							} = s.options;
						return Object.assign(Object.assign({}, e), {
							[n.toLowerCase()]: null
						})
					}
					case rS.a: {
						const s = t.payload,
							{
								options: n,
								error: r
							} = s,
							{
								subredditName: a
							} = n;
						return Object.assign(Object.assign({}, e), {
							[a.toLowerCase()]: r
						})
					}
					default:
						return e
				}
			};
			const oS = {};
			var cS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case rS.c: {
							const s = t.payload,
								{
									subredditName: n
								} = s.options;
							return Object.assign(Object.assign({}, e), {
								[n.toLowerCase()]: !0
							})
						}
						case rS.b:
						case rS.a: {
							const s = t.payload,
								{
									subredditName: n
								} = s.options;
							return Object.assign(Object.assign({}, e), {
								[n.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				dS = Object(T.c)({
					error: iS,
					pending: cS
				});
			const uS = {};
			var lS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case wm.c:
					case wm.b: {
						const {
							subredditName: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: null
						})
					}
					case wm.a: {
						const {
							subredditName: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: n
						})
					}
					default:
						return e
				}
			};
			const bS = {};
			var pS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case wm.c: {
							const {
								subredditName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.toLowerCase()]: !0
							})
						}
						case wm.b:
						case wm.a: {
							const {
								subredditName: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s.toLowerCase()]: !1
							})
						}
						default:
							return e
					}
				},
				OS = Object(T.c)({
					error: lS,
					pending: pS
				}),
				gS = Object(T.c)({
					about: wv,
					create: kv,
					inlineEditing: Nv,
					models: Gv,
					onboarding: Vv,
					productOffers: Wv,
					rankings: Jv,
					rules: Xv,
					settings: eS,
					similar: nS,
					topContent: OS,
					wiki: dS
				}),
				fS = s("./node_modules/lodash/isNil.js"),
				mS = s.n(fS);
			const jS = {};
			var _S = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.d: {
							const {
								subredditId: s,
								forceState: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: mS()(n) ? !e[s] : n
							})
						}
						default:
							return e
					}
				},
				hS = Object(T.c)({
					meta: _S
				});
			const yS = {};
			var ES = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case hv.f: {
						const {
							categoryId: s,
							subredditIds: n
						} = t.payload;
						return Hi()(n) ? e : Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const IS = {};
			var vS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.c: {
							const {
								communityInfo: s,
								id: n,
								type: r
							} = t.payload;
							return s && "subreddit" === r ? Object.assign(Object.assign({}, e), {
								[n]: s
							}) : e
						}
						default:
							return e
					}
				},
				SS = s("./src/reddit/actions/subredditCrosspostable.ts");
			var TS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case SS.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case SS.c:
					case SS.b:
						return null;
					default:
						return e
				}
			};
			var wS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case SS.c:
							return !0;
						case SS.b:
						case SS.a:
							return !1;
						default:
							return e
					}
				},
				CS = Object(T.c)({
					errors: TS,
					pending: wS
				});
			const AS = {};
			var DS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case SS.b: {
							const {
								subredditIds: s
							} = t.payload;
							return fn()(e, s) ? e : s
						}
						default:
							return e
					}
				},
				PS = Object(T.c)({
					api: CS,
					ids: DS
				});
			const RS = {};
			var kS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : RS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case xm.a: {
							const s = t.payload,
								{
									subredditId: n,
									distinguishKey: r,
									postIds: a
								} = s;
							if (!(n in e)) return Object.assign(Object.assign({}, e), {
								[n]: {
									[r]: a
								}
							});
							const i = e[n];
							return Pm(i, {
								[r]: a
							}) === i ? e : Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign({}, i), {
									[r]: a
								})
							})
						}
						default:
							return e
					}
				},
				xS = Object(T.c)({
					models: kS
				});
			const NS = {};
			var LS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							assets: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					case u.g:
					case u.j: {
						const {
							subredditId: s,
							mainHeader: n
						} = t.payload, r = e[s] || {};
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								mainHeader: n
							})
						})
					}
					default:
						return e
				}
			};
			const US = {};
			var MS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : US,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							subredditId: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: t.payload
						})
					}
					case c.j: {
						const {
							communityRaw: s,
							subredditId: n
						} = t.payload;
						return s ? Object.assign(Object.assign({}, e), {
							[n]: s
						}) : e
					}
					default:
						return e
				}
			};
			const FS = {};
			var GS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							subredditId: s,
							distribution: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const BS = {};
			var qS = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							subredditId: s,
							meta: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const VS = {};
			var HS = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : VS,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.p: {
							const {
								subredditId: s,
								releaseNotes: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				KS = Object(T.c)({
					assets: LS,
					communityRaw: MS,
					distributions: GS,
					meta: qS,
					releaseNotes: HS
				}),
				WS = s("./node_modules/lodash/isEqualWith.js"),
				YS = s.n(WS),
				zS = s("./src/lib/forceHttps/index.ts");
			const JS = {},
				QS = (e, t) => {
					const s = Object.keys(t);
					return s.length ? s.reduce((s, n) => {
						const r = e[n],
							a = t[n],
							i = r ? Object.assign(Object.assign({}, r), a) : Object.assign({}, a);
						return a.icon.url ? i.icon.url = Object(zS.a)(a.icon.url) : r && r.icon.url ? i.icon = r.icon : i.icon.url = "", r && r.allowChatPostCreation && (i.allowChatPostCreation = !0), Object(U.set)(s, n, i)
					}, e) : e
				},
				XS = (e, t) => {
					return !YS()(e, t, (e, t, s) => {
						if ("subscribers" === s) return !0
					})
				},
				ZS = (e, t) => {
					if (!t) return e;
					const s = Object.keys(t);
					if (!s.length) return e;
					const n = {};
					for (let r = 0; r < s.length; r++) {
						const a = s[r],
							i = e[a],
							o = t[a];
						i && !XS(i, o) || (n[a] = o)
					}
					return Object.keys(n).length ? Object.assign(Object.assign({}, e), n) : e
				};
			var $S = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JS,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mg.c:
						return QS(e, t.payload.subreddits || {});
					case yv.d:
					case hv.f:
					case Ue.b:
					case Uc.g:
					case Il.b:
					case Ge.e:
					case Ge.h:
					case ee.k:
					case Me.r:
					case Me.u:
					case Og.h:
					case _l.b:
					case Fe.b:
					case te.b:
					case te.g:
					case te.k:
					case se.b:
					case se.e:
					case re.c:
					case re.i:
					case re.e:
					case re.g:
					case qe.b:
					case qe.e:
					case ne.b:
					case ne.e:
					case Og.e:
					case ae.c:
					case ie.c:
					case Be.b:
					case xr.e:
					case Ea.a:
					case Og.m:
					case oe.b:
					case oe.e:
					case Ve.b:
					case "RECOMMENDED_POSTS_LOADED":
					case We.c:
					case ce.c:
					case ce.f:
					case ce.i:
					case vl.a:
					case vl.e:
					case vl.m:
					case hl.e:
					case hl.b:
						return ZS(e, t.payload.subreddits || {});
					case ee.f:
					case ee.i:
					case ee.m:
					case ee.p:
					case ee.v: {
						const {
							response: s
						} = t.payload, {
							subreddits: n
						} = s;
						return ZS(e, n)
					}
					case We.e: {
						const {
							typeaheadSuggestions: s
						} = t.payload;
						return ZS(e, s.subreddits || {})
					}
					case Me.B: {
						const {
							subreddits: s
						} = t.payload;
						return Object.assign(Object.assign({}, s), e)
					}
					case c.h: {
						const s = t.payload;
						return ZS(e, s)
					}
					case g.m: {
						const s = t.payload,
							{
								subredditId: n,
								styles: r
							} = s;
						return "communityIcon" in r && e[n] && "string" == typeof r.communityIcon ? Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								communityIcon: r.communityIcon
							})
						}) : e
					}
					case Zv.f: {
						const {
							settings: s
						} = t.payload, {
							subredditId: n,
							title: r
						} = s;
						return e[n] && void 0 !== r ? Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								title: r
							})
						}) : e
					}
					default:
						return e
				}
			};
			var eT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.e: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case ce.g:
					case ce.f:
						return null;
					default:
						return e
				}
			};
			var tT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.g:
					case ce.f:
						return !0;
					case ce.e:
						return !1;
					default:
						return e
				}
			};
			var sT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.g:
							return !0;
						case ce.f:
						case ce.e:
							return !1;
						default:
							return e
					}
				},
				nT = Object(T.c)({
					errors: eT,
					fetched: tT,
					pending: sT
				});
			var rT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.f: {
							const {
								subreddits: e
							} = t.payload, s = Object.keys(e);
							return s.sort((t, s) => e[t].displayText.toLowerCase() > e[s].displayText.toLowerCase() ? 1 : -1), s
						}
						default:
							return e
					}
				},
				aT = Object(T.c)({
					api: nT,
					order: rT
				});
			const iT = {};
			var oT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Zv.a: {
						const s = t.payload;
						return Object(U.merge)(e, s)
					}
					case Zv.b: {
						const {
							subredditId: s,
							notificationSettings: n
						} = t.payload;
						return Object(U.merge)(e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const cT = {};
			var dT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vl.e: {
						const {
							key: s,
							subredditIds: n
						} = t.payload;
						return 0 === n.length ? e : Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const uT = {};
			var lT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.kb: {
						const {
							recentSupporters: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					case ge.T:
					case ge.W: {
						const {
							subredditId: s,
							powerupsCount: n,
							user: r
						} = t.payload;
						if (n > 0) {
							const t = {
								score: n,
								lastSupportedAt: (new Date).toString(),
								supporterInfo: {
									id: r.id,
									name: Object(ue.e)(r),
									icon: {
										url: r.accountIcon
									},
									profile: {
										isNsfw: r.isNSFW
									}
								}
							};
							return Object.assign(Object.assign({}, e), {
								[s]: [t, ...e[s]]
							})
						}
						return e
					}
					default:
						return e
				}
			};
			const bT = {};
			var pT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var s;
				switch (t.type) {
					case ge.lb:
					case ge.kb: {
						const {
							powerups: s,
							subredditId: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[n]: s
						})
					}
					case ge.T:
					case ge.W: {
						const {
							subredditId: n,
							powerupsCount: r
						} = t.payload;
						if (e[n] && r > 0) {
							const t = e[n],
								a = t.tier + 1,
								i = t.tiersInfo[a - 1],
								o = i && i.benefits;
							return Object.assign(Object.assign({}, e), {
								[n]: Object.assign(Object.assign({}, e[n]), {
									benefits: o || (null === (s = e[n]) || void 0 === s ? void 0 : s.benefits),
									count: t.count + r,
									supportersCount: t.supportersCount + 1
								})
							})
						}
						return e
					}
					default:
						return e
				}
			};
			const OT = {},
				gT = (e, t) => t.supporterInfo && e.supporterInfo ? 1e15 * t.score + new Date(t.lastSupportedAt).valueOf() - 1e15 * e.score - new Date(e.lastSupportedAt).valueOf() : t.supporterInfo ? 1 : e.supporterInfo ? -1 : 0;
			var fT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.kb: {
							const {
								topSupporters: s,
								subredditId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s.sort(gT)
							})
						}
						case ge.T:
						case ge.W: {
							const {
								subredditId: s,
								powerupsCount: n,
								user: r,
								isAnonymous: a
							} = t.payload;
							if (n > 0) {
								let t = !1;
								const i = e[s].map(e => {
									var s;
									return a && !e.supporterInfo || !a && (null === (s = e.supporterInfo) || void 0 === s ? void 0 : s.id) === r.id ? (t = !0, Object.assign(Object.assign({}, e), {
										lastSupportedAt: (new Date).toString(),
										score: e.score + n
									})) : e
								});
								if (t) return Object.assign(Object.assign({}, e), {
									[s]: i.sort(gT)
								});
								const o = {
									score: n,
									lastSupportedAt: (new Date).toString(),
									supporterInfo: a ? null : {
										id: r.id,
										name: Object(ue.e)(r),
										icon: {
											url: r.accountIcon
										},
										profile: {
											isNsfw: r.isNSFW
										}
									}
								};
								return Object.assign(Object.assign({}, e), {
									[s]: [o, ...e[s]].sort(gT)
								})
							}
							return e
						}
						default:
							return e
					}
				},
				mT = s("./src/lib/makeProductOfferKey/index.ts");
			const jT = {};
			var _T = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.Y: {
						const {
							type: s,
							subredditId: n,
							productOffers: r
						} = t.payload, a = Object(mT.a)(n, s);
						return r && 0 !== r.length ? Object.assign(Object.assign({}, e), {
							[a]: r
						}) : e
					}
					default:
						return e
				}
			};
			const hT = {};
			var yT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.g: {
							const {
								subredditId: s,
								products: n
							} = t.payload, r = Object.keys(n).reduce((e, t) => (e[t] = !0, e), {});
							return Object.assign(Object.assign({}, e), {
								[s]: r
							})
						}
						default:
							return e
					}
				},
				ET = s("./src/reddit/actions/subreddit/questions.ts");
			const IT = {};
			var vT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ET.a: {
						const {
							id: s,
							questions: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const ST = {};
			var TT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ST,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vl.b: {
						const {
							categoryRankingsKey: s
						} = t.payload, n = e[s], r = n && n.length ? [...n, ...t.payload.rankings] : t.payload.rankings;
						return Object.assign(Object.assign({}, e), {
							[s]: r
						})
					}
					default:
						return e
				}
			};
			const wT = {};
			var CT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vl.c: {
						const {
							categoryRankingsKey: s,
							pageInfo: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const AT = {};
			var DT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Qv.b: {
						const {
							rules: s,
							subredditId: n
						} = t.payload, r = {
							[n]: {
								rules: s.rules
							}
						};
						return Object.assign(Object.assign({}, e), r)
					}
					case Qv.e: {
						const {
							rules: s,
							subredditId: n
						} = t.payload, r = {
							[n]: {
								rules: [...e[n].rules, ...s.rules]
							}
						};
						return Object.assign(Object.assign({}, e), r)
					}
					case Qv.f: {
						const {
							rules: s,
							subredditId: n,
							oldName: r
						} = t.payload;
						s.rules.shortName !== r && (e[n].rules = e[n].rules.filter(e => e.shortName !== r));
						const a = {
							[n]: {
								rules: [...s.rules, ...e[n].rules]
							}
						};
						return a[n].rules.sort((e, t) => e.priority - t.priority), Object.assign(Object.assign({}, e), a)
					}
					case Qv.g:
					case Qv.d: {
						const {
							rules: s,
							subredditId: n
						} = t.payload, r = {
							[n]: {
								rules: s.rules
							}
						};
						return Object.assign(Object.assign({}, e), r)
					}
					default:
						return e
				}
			};
			const PT = {};
			var RT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Zv.c: {
						const e = t.payload;
						return {
							[e.subredditId]: e
						}
					}
					case Zv.f: {
						const s = t.payload.settings,
							n = e[s.subredditId] || {};
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: Object.assign(Object.assign({}, n), s)
						})
					}
					case Gl.n: {
						const s = t.payload,
							n = e[s.subredditId] || {},
							r = Object.assign(Object.assign({}, n), s.settings);
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: r
						})
					}
					default:
						return e
				}
			};
			const kT = {};
			var xT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vl.m: {
						const {
							key: s,
							subredditIds: n
						} = t.payload;
						return 0 === n.length ? e : Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const NT = {};
			var LT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : NT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ET.a: {
						const {
							id: s,
							survey: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: n
						})
					}
					case ET.b: {
						const {
							id: s,
							response: n
						} = t.payload, r = Object(U.setIn)(e, [s, "response"], n);
						return Object(U.setIn)(r, [s, "isEligible"], !1)
					}
					default:
						return e
				}
			};
			const UT = {};
			var MT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : UT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Uc.g: {
						const {
							subredditTopContent: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s.subredditTopContent)
					}
					case wm.b: {
						const {
							subredditTopContent: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					default:
						return e
				}
			};
			const FT = [];
			var GT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case te.g:
					case ie.c: {
						const {
							trendingSubredditIds: s
						} = t.payload;
						return s && s.length ? s : e
					}
					default:
						return e
				}
			};
			const BT = {};
			var qT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case yv.d:
							const {
								unavailableSubreddits: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), s);
						default:
							return e
					}
				},
				VT = Object(T.c)({
					about: Iv,
					api: gS,
					appliedFilters: hS,
					byCategory: ES,
					communityInfo: vS,
					crosspostable: PS,
					duplicates: xS,
					gov: KS,
					models: $S,
					moderated: aT,
					notificationSettings: oT,
					onboarding: dT,
					powerupRecentSupporters: lT,
					powerups: pT,
					powerupTopSupporters: fT,
					productOffers: _T,
					products: yT,
					questions: vT,
					rankings: TT,
					rankingsPageInfo: CT,
					rules: DT,
					settings: RT,
					similar: xT,
					survey: LT,
					topContent: MT,
					trending: GT,
					unavailableModels: qT
				});
			const HT = {};
			var KT = Object(s_.a)((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : HT,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c: {
							const {
								postIds: s,
								posts: n
							} = t.payload, r = s.slice(0, 2).reduce((e, t) => {
								if (n[t].isStickied) {
									const s = n[t].belongsTo.id;
									e[s] ? e[s].push(t) : e[s] = [t]
								}
								return e
							}, {});
							return Re()(Object.assign({}, e), r)
						}
						case Ll.k: {
							const {
								newStickiedPostList: s,
								subredditId: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[n]: s
							})
						}
						default:
							return e
					}
				}), HT),
				WT = Object(T.c)({
					data: KT
				});
			const YT = [];
			var zT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YT,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mg.d: {
						const {
							makeFavorite: s,
							multiredditsModelsState: n,
							multiredditPath: r
						} = t.payload;
						if (s) {
							const t = [...e],
								s = pg(t, r, (e, t) => n[e].displayText.toLowerCase() > n[t].displayText.toLowerCase() ? 1 : -1);
							return t.splice(s, 0, r), t
						}
						return e.filter(e => e !== r)
					}
					case Me.u: {
						const {
							multireddits: e
						} = t.payload;
						return ir()(e).filter(e => e.isFavorited).sort((e, t) => e.displayText.toLowerCase() > t.displayText.toLowerCase() ? 1 : -1).map(e => e.url)
					}
					case mg.e: {
						const {
							follow: s,
							multiredditPath: n
						} = t.payload;
						return s ? e : e.filter(e => e !== n)
					}
					case Me.j: {
						const s = t.payload;
						return e.filter(e => e !== s)
					}
					default:
						return e
				}
			};
			var JT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mg.a: {
						const {
							error: e
						} = t.payload;
						return e
					}
					case mg.b:
					case mg.c:
						return null;
					default:
						return e
				}
			};
			var QT = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mg.b:
					case mg.c:
						return !0;
					case mg.a:
						return !1;
					default:
						return e
				}
			};
			var XT = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case mg.b:
							return !0;
						case mg.c:
						case mg.a:
							return !1;
						default:
							return e
					}
				},
				ZT = Object(T.c)({
					errors: JT,
					fetched: QT,
					pending: XT
				});
			const $T = [];
			var ew = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $T,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mg.c: {
						const {
							profiles: e,
							favoriteProfileIds: s,
							favoriteSubredditIds: n
						} = t.payload;
						let r;
						return (r = s && s.length ? s : n ? n.filter(t => !!e[t]) : []).sort((t, s) => e[t].displayText.toLowerCase() > e[s].displayText.toLowerCase() ? 1 : -1), r
					}
					case mg.f: {
						const {
							makeFavorite: s,
							identifier: n,
							profileModels: r
						} = t.payload, {
							id: a,
							type: i
						} = n;
						if (i !== Nh.a.PROFILE) return e;
						const o = e ? e.slice() : [];
						if (s) {
							const e = pg(o, a, (e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1);
							o.splice(e, 0, a)
						} else {
							const e = o.indexOf(a);
							o.splice(e, 1)
						}
						return o
					}
					case mg.h: {
						const {
							identifiers: s,
							userIsSubscriber: n
						} = t.payload, r = s.filter(t => t.type === Nh.a.PROFILE && e.indexOf(t.id) > -1);
						return !r.length || n ? e : r.reduce((e, t) => {
							const s = e.indexOf(t.id);
							return e.splice(s, 1), e
						}, [...e])
					}
					default:
						return e
				}
			};
			const tw = [];
			var sw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mg.c: {
						const {
							subreddits: e,
							favoriteSubredditIds: s
						} = t.payload, n = s ? s.filter(t => !!e[t]) : [];
						return n.sort((t, s) => e[t].displayText.toLowerCase() > e[s].displayText.toLowerCase() ? 1 : -1), n
					}
					case mg.f: {
						const {
							makeFavorite: s,
							identifier: n,
							subredditModels: r
						} = t.payload, {
							id: a,
							type: i
						} = n;
						if (i !== Nh.a.SUBREDDIT) return e;
						const o = e ? e.slice() : [];
						if (s) {
							const e = pg(o, a, (e, t) => r[e].displayText.toLowerCase() > r[t].displayText.toLowerCase() ? 1 : -1);
							o.splice(e, 0, a)
						} else {
							const e = o.indexOf(a);
							o.splice(e, 1)
						}
						return o
					}
					case mg.h: {
						const {
							identifiers: s,
							userIsSubscriber: n
						} = t.payload, r = s.filter(t => t.type === Nh.a.SUBREDDIT && e.indexOf(t.id) > -1);
						return !r.length || n ? e : r.reduce((e, t) => {
							const s = e.indexOf(t.id);
							return e.splice(s, 1), e
						}, [...e])
					}
					default:
						return e
				}
			};
			const nw = [],
				rw = e => (t, s) => e[t].displayText.toLowerCase() > e[s].displayText.toLowerCase() ? 1 : -1;
			var aw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Me.u: {
							const {
								multireddits: s
							} = t.payload, n = ir()(s).map(e => {
								let {
									url: t
								} = e;
								return t.toLowerCase()
							}).sort(rw(s));
							return fn()(e, n) ? e : n
						}
						case te.k: {
							const {
								account: s,
								multireddits: n,
								multiredditsByUser: r,
								multiredditsModelsState: a
							} = t.payload;
							if (!s) return e;
							const i = r[s.id];
							if (!i || !i.length) return e;
							const o = Object.assign(Object.assign({}, a), n),
								c = bg()(e, i).sort(rw(o));
							return fn()(e, c) ? e : c
						}
						case mg.e: {
							const {
								follow: s,
								multiredditPath: n,
								multiredditsModelsState: r
							} = t.payload;
							return s ? [...e, n].sort(rw(r)) : e.filter(e => e !== n)
						}
						case Me.j: {
							const s = t.payload;
							return e.filter(e => e !== s)
						}
						case Me.g:
						case Me.m: {
							const {
								multireddit: s,
								multiredditsModelsState: n
							} = t.payload, r = Object.assign(Object.assign({}, n), {
								[s.url]: s
							});
							return [...e, s.url].sort(rw(r))
						}
						default:
							return e
					}
				},
				iw = s("./node_modules/lodash/difference.js"),
				ow = s.n(iw);
			const cw = [];
			var dw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : cw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Og.n: {
						const {
							profileOrder: s
						} = t.payload;
						return gj()([...e, ...s])
					}
					case mg.c: {
						const {
							profiles: e
						} = t.payload, s = Object.keys(e);
						return s.sort((t, s) => e[t].displayText.toLowerCase() > e[s].displayText.toLowerCase() ? 1 : -1), s
					}
					case mg.h: {
						const {
							identifiers: s,
							profileModels: n,
							userIsSubscriber: r
						} = t.payload, a = s.filter(e => e.type === Nh.a.PROFILE);
						if (!a.length) return e;
						const i = a.map(e => e.id);
						return r ? gj()([...e, ...i]).sort((e, t) => n[e].displayText.toLowerCase() > n[t].displayText.toLowerCase() ? 1 : -1) : ow()(e, i)
					}
					default:
						return e
				}
			};
			const uw = [];
			var lw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : uw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Og.n: {
							const {
								subredditOrder: s
							} = t.payload;
							return gj()([...e, ...s])
						}
						case mg.c: {
							const {
								subreddits: e
							} = t.payload, s = Object.keys(e);
							return s.sort((t, s) => e[t].displayText.toLowerCase() > e[s].displayText.toLowerCase() ? 1 : -1), s
						}
						case mg.h: {
							const {
								identifiers: s,
								subredditModels: n,
								userIsSubscriber: r
							} = t.payload, a = s.filter(e => e.type === Nh.a.SUBREDDIT && !!e.id);
							if (!a.length) return e;
							const i = a.map(e => e.id);
							return r ? gj()([...e, ...i]).sort((e, t) => n[e].displayText.toLowerCase() > n[t].displayText.toLowerCase() ? 1 : -1) : ow()(e, i)
						}
						default:
							return e
					}
				},
				bw = Object(T.c)({
					api: ZT,
					favoriteMultiOrder: zT,
					favoriteProfileOrder: ew,
					favoriteSubredditOrder: sw,
					multiredditOrder: aw,
					profileOrder: dw,
					subredditOrder: lw
				}),
				pw = s("./src/reddit/actions/tabBadging.ts");
			var Ow = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pw.a:
							const {
								hasUnreadMessages: s
							} = t.payload;
							return s;
						default:
							return e
					}
				},
				gw = s("./src/reddit/actions/tags/constants.ts");
			const fw = {
				pending: !1,
				error: !1
			};
			var mw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gw.l:
						return Object.assign(Object.assign({}, e), {
							pending: !0
						});
					case gw.m:
						return {
							error: !1, pending: !1
						};
					case gw.k:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const jw = {
				pending: !1,
				error: !1
			};
			var _w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gw.o:
						return Object.assign(Object.assign({}, e), {
							pending: !0
						});
					case gw.p:
						return {
							error: !1, pending: !1
						};
					case gw.n:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const hw = {
				pending: !1,
				error: !1
			};
			var yw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hw,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gw.t:
						return Object.assign(Object.assign({}, e), {
							pending: !0
						});
					case gw.s:
					case gw.r:
					case gw.e:
					case gw.j:
						return {
							error: !1, pending: !1
						};
					case gw.q:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const Ew = {
				pending: !1,
				error: !1
			};
			var Iw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ew,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gw.v:
						return Object.assign(Object.assign({}, e), {
							pending: !0
						});
					case gw.w:
						return {
							error: !1, pending: !1
						};
					case gw.u:
						return {
							error: !0, pending: !1
						};
					default:
						return e
				}
			};
			const vw = {
				pending: !1,
				error: !1
			};
			var Sw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gw.g:
							return Object.assign(Object.assign({}, e), {
								pending: !0
							});
						case gw.h:
							return {
								error: !1, pending: !1
							};
						case gw.f:
							return {
								error: !0, pending: !1
							};
						default:
							return e
					}
				},
				Tw = Object(T.c)({
					create: mw,
					deleteTag: _w,
					fetch: yw,
					update: Iw,
					updatePrimaryTag: Sw
				});
			const ww = {
				global: [],
				recommendedGlobal: []
			};
			var Cw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ww,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gw.w:
						case gw.r:
						case gw.e:
						case gw.j: {
							const {
								globalSubredditTags: e
							} = t.payload, s = Object.keys(e), n = s.filter(t => e[t].isRecommended);
							return {
								global: s,
								recommendedGlobal: n
							}
						}
						default:
							return e
					}
				},
				Aw = s("./node_modules/lodash/uniqWith.js"),
				Dw = s.n(Aw),
				Pw = s("./src/reddit/models/Option/index.ts");
			const Rw = {
				selectedOptions: [],
				tagInput: "",
				selectedPrimaryTagId: null
			};
			var kw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Rw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gw.d: {
							const {
								option: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								selectedOptions: Dw()([...e.selectedOptions || [], Object.assign({}, s)], Pw.a)
							})
						}
						case gw.c: {
							const {
								option: s
							} = t.payload, n = e.selectedOptions.findIndex(e => Object(Pw.a)(e, s));
							return e.selectedOptions.splice(n, 1), Object.assign(Object.assign({}, e), {
								selectedOptions: e.selectedOptions
							})
						}
						case gw.b: {
							const {
								input: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								tagInput: s
							})
						}
						case gw.a: {
							const {
								primaryTagId: s
							} = t.payload, n = e.selectedOptions.findIndex(e => e.id === s), r = [...e.selectedOptions];
							return n >= 0 && r.splice(n, 1), Object.assign(Object.assign({}, e), {
								selectedPrimaryTagId: s,
								selectedOptions: r
							})
						}
						default:
							return e
					}
				},
				xw = s("./src/reddit/helpers/tags/index.ts");
			const Nw = {
				globalSubredditTags: {},
				subredditScopedTags: {},
				itemTags: {},
				geoPlaces: {},
				suggestedItemTags: {},
				sortedItemTags: {},
				subredditPrimaryTagId: {}
			};
			var Lw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case gw.j: {
							const {
								globalSubredditTags: s,
								subredditScopedTags: n,
								subredditId: r
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								globalSubredditTags: Object.assign(Object.assign({}, e.globalSubredditTags), s),
								subredditScopedTags: Object.assign(Object.assign({}, e.subredditScopedTags), {
									[r]: Object.assign(Object.assign({}, e.subredditScopedTags[r] || {}), n[r] || {})
								})
							})
						}
						case gw.w:
						case gw.s:
						case gw.r: {
							const {
								primaryTag: s,
								globalSubredditTags: n,
								subredditScopedTags: r,
								itemTags: a,
								suggestedItemTags: i,
								subredditId: o,
								geoPlace: c
							} = t.payload, d = Object.assign({}, e.subredditPrimaryTagId);
							return s ? d[o] = s.tag.id : delete d[o], {
								subredditPrimaryTagId: d,
								globalSubredditTags: Object.assign(Object.assign({}, e.globalSubredditTags), n),
								subredditScopedTags: Object.assign(Object.assign({}, e.subredditScopedTags), {
									[o]: Object.assign(Object.assign({}, e.subredditScopedTags[o] || {}), r[o] || {})
								}),
								itemTags: Object.assign(Object.assign({}, e.itemTags), {
									[o]: Object.assign({}, a[o] || {})
								}),
								geoPlaces: c ? Object(U.set)(e.geoPlaces, o, c) : e.geoPlaces,
								suggestedItemTags: Object.assign(Object.assign({}, e.suggestedItemTags), {
									[o]: Object.assign({}, i[o] || {})
								}),
								sortedItemTags: Object.assign(Object.assign({}, e.sortedItemTags), {
									[o]: Object(xw.a)(a[o] || {})
								})
							}
						}
						case gw.p: {
							const {
								subredditId: s,
								tags: n
							} = t.payload, r = n.reduce((e, t) => {
								let {
									tagId: s
								} = t;
								return delete e[s], e
							}, Object.assign({}, e.subredditScopedTags[s] || {}));
							return Object.assign(Object.assign({}, e), {
								subredditScopedTags: Object.assign(Object.assign({}, e.subredditScopedTags), {
									[s]: r
								})
							})
						}
						case gw.e: {
							const {
								globalSubredditTags: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								globalSubredditTags: Object.assign(Object.assign({}, e.globalSubredditTags), s)
							})
						}
						case gw.h: {
							const {
								subredditId: s,
								primaryTagId: n,
								secondaryTags: r
							} = t.payload;
							return n && s ? Object.assign(Object.assign({}, e), {
								subredditPrimaryTagId: Object.assign(Object.assign({}, e.subredditPrimaryTagId), {
									[s]: n
								}),
								itemTags: Object.assign(Object.assign({}, e.itemTags), {
									[s]: Object.assign({}, r || {})
								})
							}) : e
						}
						case gw.i: {
							const {
								subredditId: s,
								primaryTagId: n
							} = t.payload;
							return n && s ? Object.assign(Object.assign({}, e), {
								subredditPrimaryTagId: Object.assign(Object.assign({}, e.subredditPrimaryTagId), {
									[s]: n
								})
							}) : e
						}
						default:
							return e
					}
				},
				Uw = s("./src/reddit/reducers/tags/selected/index.ts"),
				Mw = Object(T.c)({
					api: Tw,
					availableGlobalTagOrder: Cw,
					models: Lw,
					selected: Uw.b,
					creation: kw
				}),
				Fw = s("./src/reddit/actions/redditEmbed.ts"),
				Gw = s("./src/reddit/actions/theme.ts"),
				Bw = s("./src/reddit/actions/users.ts"),
				qw = s("./src/reddit/models/Theme/index.ts");
			const Vw = {
				current: qw.c,
				cached: {}
			};
			var Hw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Gw.a: {
							const {
								nightmode: e
							} = t.payload;
							return {
								current: e ? qw.b : qw.c,
								cached: {}
							}
						}
						case Ir.a:
						case Ir.b:
						case Ir.h:
						case Ir.i:
						case Ir.f:
						case Ir.j:
						case Ge.e:
						case Ge.h:
						case Fe.a:
						case te.a:
						case Fe.b:
						case te.b:
						case Fe.d:
						case te.d:
						case te.g:
						case ie.c:
						case te.k:
						case te.j:
						case Ue.b:
						case Fw.b:
						case ce.i:
						case We.c:
						case ae.c:
						case Gl.j:
						case Be.b:
						case Ea.a:
						case Bw.c:
							if (t.payload && t.payload.preferences && "nightmode" in t.payload.preferences) {
								const {
									nightmode: e
								} = t.payload.preferences;
								return e ? {
									current: qw.b,
									cached: {}
								} : {
									current: qw.c,
									cached: {}
								}
							}
							return e;
						case se.d:
						case se.e:
						case qe.a:
						case qe.b:
						case qe.d:
						case qe.e:
						case ne.d:
						case ne.e: {
							const {
								account: s
							} = t.payload;
							return s ? s.nightmode ? {
								current: qw.b,
								cached: {}
							} : {
								current: qw.c,
								cached: {}
							} : e
						}
						case ee.h:
						case ee.j:
						case ee.i:
						case ee.g:
						case ee.f:
						case ee.n:
						case ee.m:
						case ee.p:
						case ee.q:
						case ee.w:
						case ee.v:
							if (t.payload && t.payload.response && t.payload.response.preferences && "nightmode" in t.payload.response.preferences) {
								const {
									nightmode: e
								} = t.payload.response.preferences;
								return e ? {
									current: qw.b,
									cached: {}
								} : {
									current: qw.c,
									cached: {}
								}
							}
							return e;
						case Gl.i: {
							if (!t.payload) return e;
							const {
								nightmode: s
							} = t.payload;
							return s ? {
								current: qw.b,
								cached: {}
							} : {
								current: qw.c,
								cached: {}
							}
						}
						case g.d:
							return {
								current: qw.c, cached: {}
							};
						case g.e:
							return t.payload.nightmodeTempUpdated ? {
								current: qw.b,
								cached: {}
							} : e;
						default:
							return e
					}
				},
				Kw = s("./src/reddit/actions/toaster.ts");
			const Ww = [];
			var Yw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ww,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Kw.c: {
							const s = t.payload,
								n = [];
							let r = !1;
							for (const t of e) {
								const e = t.id === s.id ? s : t;
								n.push(e), r = r || e === s
							}
							return r || n.push(s), n
						}
						case Kw.b: {
							const s = t.payload;
							return e.filter(e => e.id !== s)
						}
						default:
							return e
					}
				},
				zw = s("./src/reddit/actions/tooltip.ts");
			var Jw = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case zw.c: {
						const {
							tooltipId: s
						} = t.payload;
						return e === s ? null : s
					}
					case zw.a: {
						const {
							tooltipId: s
						} = t.payload;
						return e === s ? e : s
					}
					case zw.b: {
						const {
							tooltipId: s
						} = t.payload;
						return null !== e ? e : s || null
					}
					case zw.e: {
						const {
							tooltipId: s
						} = t.payload;
						return e === s ? null : e
					}
					case ge.M:
					case zw.d:
					case l.a:
					case vu.b:
					case vu.c:
					case vu.a:
						return null;
					default:
						return e
				}
			};
			const Qw = {};
			var Xw = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Qw,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case hl.e:
						case hl.b:
							return Object.assign(Object.assign({}, e), t.payload.topics);
						default:
							return e
					}
				},
				Zw = Object(T.c)({
					models: Xw
				}),
				$w = s("./src/reddit/actions/tracing.ts");
			const eC = {
				traceId: void 0
			};
			var tC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case $w.a:
							return t.payload ? {
								traceId: t.payload
							} : e;
						default:
							return e
					}
				},
				sC = s("./src/lib/asyncActions/index.ts"),
				nC = s("./src/reddit/actions/reCaptchaEnterprise.ts");
			const rC = Object(sC.c)(nC.c.requestedActionType, nC.c.succeededActionType, nC.c.failedActionType),
				aC = Object(sC.c)(nC.a.requestedActionType, nC.a.succeededActionType, nC.a.failedActionType),
				iC = Object(sC.c)(nC.d.requestedActionType, nC.d.succeededActionType, nC.d.failedActionType);
			var oC = Object(T.c)({
					load: rC,
					execute: aC,
					send: iC
				}),
				cC = s("./src/reddit/actions/tracking.ts");
			const dC = {};
			var uC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case cC.a: {
							const {
								routeKey: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !0
							})
						}
						case cC.b: {
							const {
								routeKey: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: !1
							})
						}
						default:
							return e
					}
				},
				lC = Object(T.c)({
					reCaptchaEnterprise: oC,
					viewportDataLoaded: uC
				}),
				bC = s("./src/reddit/actions/trafficStats/constants.ts");
			var pC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case bC.c:
						return !0;
					case bC.b:
					case bC.a:
						return !1;
					default:
						return e
				}
			};
			var OC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case bC.b: {
							const {
								trafficStats: e
							} = t.payload;
							return e
						}
						case bC.c:
							return null;
						default:
							return e
					}
				},
				gC = Object(T.c)({
					pending: pC,
					trafficStats: OC
				});
			var fC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.s:
					case d.t:
						return null;
					case d.q: {
						const {
							error: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var mC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.s:
							return !0;
						case d.q:
						case d.t:
							return !1;
						default:
							return e
					}
				},
				jC = Object(T.c)({
					error: fC,
					pending: mC
				});
			var _C = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.r:
						return (t.payload ? t.payload.contentId : null) || null;
					case n.b:
					case d.t:
						return null;
					default:
						return e
				}
			};
			var hC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.r:
						return (t.payload ? t.payload.recipient : "") || "";
					case d.t:
						return "";
					default:
						return e
				}
			};
			var yC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.r:
							return t.payload && t.payload.publicAddress || null;
						case n.b:
						case d.t:
							return null;
						default:
							return e
					}
				},
				EC = Object(T.c)({
					api: jC,
					contentId: _C,
					initialRecipient: hC,
					publicAddress: yC
				}),
				IC = Object(T.c)({
					communityPoints: EC
				}),
				vC = s("./src/reddit/actions/search/trending.ts");
			const SC = [];
			var TC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ie.c:
						case vC.a: {
							const {
								items: s
							} = t.payload;
							return s || e
						}
						default:
							return e
					}
				},
				wC = Object(T.c)({
					models: TC
				});
			const CC = {};
			var AC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dy.a: {
							const {
								trophies: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				DC = s("./src/reddit/actions/upload.ts"),
				PC = s("./src/reddit/models/Upload/index.ts");
			const RC = {};
			var kC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : RC,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case DC.d: {
						const {
							key: s,
							id: n,
							file: r
						} = t.payload, a = e[s], i = a && a.file === r ? Object.assign({}, a.metadata) : {};
						return Object.assign(Object.assign({}, e), {
							[s]: {
								key: s,
								id: n,
								file: r,
								metadata: i,
								url: void 0,
								status: PC.a.PENDING
							}
						})
					}
					case DC.h: {
						const {
							key: s
						} = t.payload, n = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								status: PC.a.UPLOADING
							})
						})
					}
					case DC.c: {
						const {
							key: s,
							metadata: n
						} = t.payload, r = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								metadata: n
							})
						})
					}
					case DC.e: {
						const {
							key: s,
							progress: n
						} = t.payload, r = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								progress: n
							})
						})
					}
					case DC.g: {
						const {
							key: s,
							url: n
						} = t.payload, r = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								status: PC.a.SUCCESS,
								url: n
							})
						})
					}
					case DC.b: {
						const {
							key: s,
							error: n
						} = t.payload, r = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, r), {
								status: PC.a.FAILED,
								error: n
							})
						})
					}
					case DC.a: {
						const {
							key: s
						} = t.payload, n = e[s];
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, n), {
								status: PC.a.CANCELED
							})
						})
					}
					case DC.f: {
						const {
							key: s
						} = t.payload, n = e[s];
						return n.metadata.localUrl && window.URL.revokeObjectURL(n.metadata.localUrl), jn()(e, s)
					}
					default:
						return e
				}
			};
			const xC = {};

			function NC(e, t) {
				if (!t) return e;
				const {
					subredditId: s
				} = t, n = e[s] || {};
				return Object.assign(Object.assign({}, e), {
					[s]: {
						latest: t,
						byDate: Object.assign(Object.assign({}, n.byDate || {}), {
							[t.at]: t
						})
					}
				})
			}
			var LC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xC,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.d:
						case d.a:
						case c.f:
						case d.t: {
							const {
								wallet: s
							} = t.payload;
							return NC(e, s)
						}
						case d.w: {
							const s = t.payload,
								n = Object.assign({}, e);
							return Object.keys(s).forEach(t => {
								const r = s[t],
									a = e[t],
									i = {
										latest: a ? a.latest.at <= r.at ? r : a.latest : r,
										byDate: Object.assign(Object.assign({}, a ? a.byDate : {}), {
											[r.at]: r
										})
									};
								n[t] = i
							}), n
						}
						default:
							return e
					}
				},
				UC = s("./src/reddit/actions/inbox.ts"),
				MC = s("./src/reddit/actions/pages/appeal/constants.ts"),
				FC = s("./src/reddit/actions/pages/userDataRequest/index.ts"),
				GC = s("./src/reddit/actions/sso/constants.ts");
			const BC = (e, t) => {
				if (!t || fn()(e, t)) return e;
				const {
					awardeeKarma: s,
					awarderKarma: n,
					commentKarma: r,
					postKarma: a,
					totalKarma: i
				} = t, o = e ? e.awardeeKarma : 0, c = e ? e.awarderKarma : 0, d = s || o, u = n || c, l = i || d + u + a + r;
				return Object.assign(Object.assign({}, t), {
					awardeeKarma: d,
					awarderKarma: u,
					totalKarma: l
				})
			};
			var qC = Object(s_.a)((function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case MC.a:
					case MC.b:
					case vE.b:
					case vE.c:
					case Ir.a:
					case Ir.b:
					case Ir.f:
					case Ir.h:
					case Ir.i:
					case Ir.j:
					case Ge.e:
					case Ge.h:
					case Ge.g:
					case Me.q:
					case Me.r:
					case Fe.a:
					case te.a:
					case Fe.b:
					case te.b:
					case te.f:
					case te.g:
					case te.j:
					case te.k:
					case ie.a:
					case Og.l:
					case se.b:
					case se.a:
					case se.e:
					case se.d:
					case re.c:
					case re.i:
					case qe.e:
					case qe.d:
					case qe.b:
					case qe.a:
					case ne.e:
					case ne.d:
					case ie.c:
					case ae.a:
					case ae.c:
					case Be.b:
					case Ea.a:
					case We.a:
					case We.c:
					case Fw.a:
					case Fw.b:
					case Gl.j:
					case FC.b:
					case Bw.c:
					case hl.e:
						return BC(e, t.payload.account);
					case Bw.n:
						return e ? Object.assign(Object.assign({}, e), {
							email: t.payload
						}) : e;
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v:
					case ee.h:
					case ee.e:
					case ee.l:
					case ee.o:
					case ee.u: {
						const {
							response: s
						} = t.payload;
						return s ? BC(e, s.account) : e
					}
					case Bw.a:
						return e ? Object.assign(Object.assign({}, e), {
							seenLayoutSwitch: !0
						}) : e;
					case n.d:
						return e ? Object.assign(Object.assign({}, e), {
							seenRedesignModal: !0
						}) : e;
					case ge.y:
						return e ? Object.assign(Object.assign({}, e), {
							seenGiveAwardTooltip: !0
						}) : e;
					case Gl.l:
					case Gl.k: {
						const s = t.payload;
						return e && "profileIcon" === s.key ? Object.assign(Object.assign({}, e), {
							accountIcon: s.imageUrl
						}) : e
					}
					case ge.E:
					case ge.t: {
						const {
							coins: s
						} = t.payload;
						return e ? Object.assign(Object.assign({}, e), {
							coins: s
						}) : e
					}
					case ge.a: {
						const {
							userName: s,
							awarderKarma: n,
							awardeeKarma: r
						} = t.payload;
						if (s.toLowerCase() !== (e && Object(ue.e)(e).toLowerCase())) return e;
						const a = r || (e ? e.awardeeKarma : 0) || 0,
							i = n || (e ? e.awarderKarma : 0) || 0,
							o = a + i + (e ? e.postKarma : 0) + (e ? e.commentKarma : 0);
						return e && Object.assign(Object.assign({}, e), {
							awardeeKarma: a,
							awarderKarma: i,
							totalKarma: o
						})
					}
					case md.t: {
						const {
							coins: s
						} = t.payload;
						return s && e ? Object.assign(Object.assign({}, e), {
							coins: s
						}) : e
					}
					case UC.a: {
						const {
							inboxCount: s
						} = t.payload;
						return e ? Object.assign(Object.assign({}, e), {
							inboxCount: s
						}) : e
					}
					case GC.a: {
						const {
							linkedIdentity: s
						} = t.payload, n = e && e.linkedIdentities || [];
						return e ? Object.assign(Object.assign({}, e), {
							linkedIdentities: [...n, s]
						}) : e
					}
					case GC.b: {
						const {
							linkedIdentity: s
						} = t.payload, n = e && e.linkedIdentities || [];
						return e ? Object.assign(Object.assign({}, e), {
							linkedIdentities: n.filter(e => e !== s)
						}) : e
					}
					case Fu.c: {
						const {
							username: s
						} = t.payload;
						return e ? Object.assign(Object.assign({}, e), {
							displayText: s,
							isNameEditable: !1,
							url: "/user/".concat(s),
							username: s
						}) : e
					}
					default:
						return e
				}
			}), null);
			var VC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Bw.m:
					case Bw.n:
						return null;
					case Bw.l:
						return t.payload;
					default:
						return e
				}
			};
			var HC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bw.m:
							return !0;
						case Bw.n:
						case Bw.l:
							return !1;
						default:
							return e
					}
				},
				KC = Object(T.c)({
					error: VC,
					pending: HC
				}),
				WC = Object(T.c)({
					api: KC
				});
			var YC = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Bw.j:
						return !0;
					default:
						return e
				}
			};
			var zC = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bw.i:
							return !0;
						case Bw.j:
						case Bw.h:
							return !1;
						default:
							return e
					}
				},
				JC = Object(T.c)({
					pending: zC,
					emailSent: YC
				}),
				QC = Object(T.c)({
					api: JC
				}),
				XC = Object(T.c)({
					changeEmail: WC,
					sendResetEmail: QC
				}),
				ZC = s("./src/reddit/models/WhitelistAndBlocked.ts");
			const $C = {};
			var eA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $C,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Xt.f:
						return Object.assign(Object.assign({}, e), {
							new: ZC.a.pending
						});
					case Xt.d:
						return Object.assign(Object.assign({}, e), {
							new: ZC.a.error
						});
					case Xt.e:
						return Object.assign(Object.assign({}, e), {
							new: ZC.a.waitingForRequest
						});
					case Xt.b: {
						const s = t.payload.name;
						return Object.assign(Object.assign({}, e), {
							[s]: ZC.a.pending
						})
					}
					case Xt.a: {
						const s = t.payload.name;
						return Object.assign(Object.assign({}, e), {
							[s]: ZC.a.error
						})
					}
					case Xt.c: {
						const s = t.payload.name;
						return Object.assign(Object.assign({}, e), {
							[s]: ZC.a.waitingForRequest
						})
					}
					default:
						return e
				}
			};
			const tA = [];
			var sA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Xt.e:
							return [t.payload, ...e];
						case Xt.c: {
							const s = t.payload.name;
							return e.filter(e => e.name !== s)
						}
						case Gl.j:
							return t.payload.blockedUsers;
						default:
							return e
					}
				},
				nA = Object(T.c)({
					api: eA,
					data: sA
				}),
				rA = s("./src/reddit/actions/chat/constants.ts"),
				aA = s("./src/reddit/actions/chat/userSettings.ts");
			const iA = rA.a.anybody;
			var oA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case aA.a:
							if (t.payload) {
								const {
									invitePolicy: e
								} = t.payload;
								return e
							}
							return e;
						default:
							return e
					}
				},
				cA = Object(T.c)({
					invitePolicy: oA
				});
			const dA = (e, t) => void 0 === t || e && t === e.count ? e : Object.assign(Object.assign({}, e), {
				count: t
			});
			var uA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Be.b: {
						const {
							drafts: s
						} = t.payload;
						return e && fn()(e, s) ? e : Object.assign(Object.assign({}, e), s)
					}
					case b.P: {
						const {
							response: {
								draftsCount: s
							}
						} = t.payload;
						return dA(e, s)
					}
					case xr.e: {
						const {
							postDraftIds: s
						} = t.payload;
						return dA(e, s.length)
					}
					case xr.c:
					case xr.l: {
						const {
							draftsCount: s
						} = t.payload;
						return dA(e, s)
					}
					default:
						return e
				}
			};
			const lA = {};
			var bA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case No.a: {
							const e = t.payload.experimentVariants;
							return Zg(e)
						}
						default:
							return e
					}
				},
				pA = s("./src/reddit/actions/global/constants.ts");
			const OA = {};
			var gA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : OA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case pA.a: {
							const s = t.payload;
							return null === s.local_persisted_experiments_store || void 0 === s.local_persisted_experiments_store ? e : s.local_persisted_experiments_store
						}
						default:
							return e
					}
				},
				fA = Object(T.c)({
					byName: bA,
					localPersisted: gA
				}),
				mA = s("./src/reddit/actions/googleOneTap/index.ts");
			var jA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case mA.a:
						return !0;
					default:
						return e
				}
			};
			var _A = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Gl.e:
						return !0;
					case Gl.d:
						return !1;
					default:
						return e
				}
			};
			var hA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "en",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Gl.g:
						return t.payload;
					case Gl.j:
						return "string" == typeof t.payload.language ? t.payload.language : e;
					default:
						return e
				}
			};
			const yA = {
				blob: "",
				loid: "",
				loidCreated: "",
				version: -1
			};
			var EA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bw.b:
							return t.payload;
						default:
							return e
					}
				},
				IA = s("./src/reddit/actions/notifications/constants.ts"),
				vA = s("./src/reddit/actions/notificationSettingsLayout/constants.ts");
			var SA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vA.a:
					case IA.a: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case vA.c:
					case vA.a:
					case IA.c:
					case IA.b:
						return null;
					default:
						return e
				}
			};
			var TA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case IA.c:
						return !1;
					case IA.b:
						return !0;
					default:
						return e
				}
			};
			var wA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case IA.c:
							return !0;
						case IA.b:
						case IA.a:
							return !1;
						default:
							return e
					}
				},
				CA = Object(T.c)({
					error: SA,
					loaded: TA,
					pending: wA
				});
			var AA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case IA.d: {
						const {
							error: e
						} = t.payload;
						return e || null
					}
					case IA.f:
					case IA.e:
						return null;
					default:
						return e
				}
			};
			var DA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case IA.f:
						return !1;
					case IA.e:
						return !0;
					default:
						return e
				}
			};
			var PA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case IA.f:
							return !0;
						case IA.e:
						case IA.d:
							return !1;
						default:
							return e
					}
				},
				RA = Object(T.c)({
					error: AA,
					loaded: DA,
					pending: PA
				}),
				kA = Object(T.c)({
					getPreferences: CA,
					setPreferences: RA
				}),
				xA = s("./src/lib/notifications/constants.ts");
			var NA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xA.j:
						return !0;
					case xA.b:
					case xA.d:
					case xA.e:
						return !1;
					default:
						return e
				}
			};
			const LA = {
				broadcastFollower: !1,
				broadcastRecommendation: !1,
				chatMessages: !1,
				chatRequests: !1,
				commentReplies: !1,
				communityRecommendations: !1,
				liveEvent: !1,
				newPinnedPost: !1,
				postFlairAdded: !1,
				postReplies: !1,
				privateMessages: !1,
				threadReplies: !1,
				topLevelComment: !1,
				trendingPosts: !1,
				upvotedComments: !1,
				upvotedPosts: !1,
				userFlairAdded: !1,
				usernameMentions: !1,
				userNewFollowers: !1
			};
			var UA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : LA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case IA.b:
					case IA.f:
					case IA.d: {
						const {
							preferences: s
						} = t.payload;
						return Hi()(s) ? e : s
					}
					default:
						return e
				}
			};
			const MA = {
				byId: {},
				allIds: []
			};
			var FA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : MA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case vA.b: {
						const {
							rows: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					case vA.d: {
						const s = t.payload && t.payload.messageType;
						return Object.assign(Object.assign({}, e), {
							byId: Object.assign(Object.assign({}, e.byId), {
								[s]: Object.assign(Object.assign({}, e.byId[s]), t.payload)
							})
						})
					}
					default:
						return e
				}
			};
			const GA = {
				byId: {},
				allIds: []
			};
			var BA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : GA,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case vA.b: {
							const {
								sections: s
							} = t.payload;
							return Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				qA = Object(T.c)({
					sections: BA,
					rows: FA
				}),
				VA = Object(T.c)({
					api: kA,
					isNotificationPromptVisible: NA,
					preferences: UA,
					preferencesLayout: qA
				});
			const HA = {};
			var KA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : HA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.j:
					case o.i: {
						const {
							subredditId: s,
							userOwnedBadges: n
						} = t.payload, r = n.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s] || {}), r)
						})
					}
					case p.d: {
						const {
							userOwnedBadges: s,
							product: n
						} = t.payload, r = s.reduce((e, t) => (e[t] = !0, e), {});
						return Object.assign(Object.assign({}, e), {
							[n.subredditId]: Object.assign(Object.assign({}, e[n.subredditId] || {}), r)
						})
					}
					default:
						return e
				}
			};
			const WA = {},
				YA = (e, t) => "".concat(e, "_").concat(t || new Date, "}");
			var zA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : WA,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.wb: {
						const s = t.payload.powerups,
							{
								allocation: n
							} = s,
							r = (n || []).filter(e => !!e.subredditInfo).reduce((e, t) => Object.assign(Object.assign({}, e), {
								[YA(t.subredditInfo.id, t.allocatedAt)]: t
							}), {});
						return Object.assign(Object.assign({}, e), r)
					}
					case ge.V: {
						const {
							subredditId: s,
							powerupsCount: n,
							allocatedAt: r
						} = t.payload;
						if (n < 0) {
							const t = YA(s, r),
								a = e[t];
							if (a && a.isPremium) return Object.assign(Object.assign({}, e), {
								[t]: Object.assign(Object.assign({}, a), {
									powerups: a.powerups + n,
									isActive: !1,
									isDeallocationAllowed: !1
								})
							})
						}
						return e
					}
					case ge.Q: {
						const {
							subredditId: s,
							allocatedAt: n
						} = t.payload, r = YA(s, n), a = e[r];
						return a && !a.isPremium ? Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, a), {
								isActive: !1,
								isDeallocationAllowed: !1
							})
						}) : e
					}
					default:
						return e
				}
			};
			var JA = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.wb: {
						const s = t.payload.powerups;
						return jn()(Object.assign(Object.assign({}, e), s), "allocation")
					}
					case ge.V: {
						const {
							powerupsCount: s
						} = t.payload;
						if (s < 0) {
							const t = Math.max((e.freeCount || 0) - s, 0);
							if (e) return Object.assign(Object.assign({}, e), {
								freeCount: t
							})
						}
						return e
					}
					case ge.W: {
						const {
							powerupsCount: s
						} = t.payload;
						if (s > 0) {
							const t = Math.max((e.freeCount || 0) - s, 0);
							if (e) return Object.assign(Object.assign({}, e), {
								freeCount: t
							})
						}
						return e
					}
					default:
						return e
				}
			};
			var QA = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.vb:
						case ge.xb:
							return !1;
						case ge.wb:
							return !0;
						default:
							return e
					}
				},
				XA = Object(T.c)({
					allocationByKey: zA,
					data: JA,
					fetched: QA
				}),
				ZA = s("./src/reddit/reducers/user/prefs/index.ts");
			var $A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bw.d:
							return t.payload;
						default:
							return e
					}
				},
				eD = s("./src/reddit/actions/session.ts");
			var tD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case eD.a:
					case eD.b:
					case eD.c:
					case eD.e:
						return t.payload;
					case eD.d:
						return null;
					default:
						return e
				}
			};
			var sD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case eD.f:
						return !0;
					default:
						return e
				}
			};
			var nD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Bw.k:
						return t.payload;
					default:
						return e
				}
			};
			var rD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case No.a: {
						const e = t.payload;
						return e.identity && e.identity.isEmployee
					}
					default:
						return e
				}
			};
			var aD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case No.a:
							return t.payload.isLoggedIn;
						default:
							return e
					}
				},
				iD = Object(T.c)({
					isEmployee: rD,
					isLoggedIn: aD
				});
			var oD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Gl.r: {
							const {
								topContentDismissal: s
							} = t.payload;
							return e && fn()(e, s) ? e : Object.assign(Object.assign({}, e), s)
						}
						default:
							return e
					}
				},
				cD = s("./src/reddit/actions/userWhitelist.ts");
			const dD = {};
			var uD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case cD.e:
						return Object.assign(Object.assign({}, e), {
							new: ZC.a.pending
						});
					case cD.d:
						return Object.assign(Object.assign({}, e), {
							new: ZC.a.error
						});
					case cD.f:
						return Object.assign(Object.assign({}, e), {
							new: ZC.a.waitingForRequest
						});
					case cD.b: {
						const s = t.payload.name;
						return Object.assign(Object.assign({}, e), {
							[s]: ZC.a.pending
						})
					}
					case cD.a: {
						const s = t.payload.name;
						return Object.assign(Object.assign({}, e), {
							[s]: ZC.a.error
						})
					}
					case cD.c: {
						const s = t.payload.name;
						return Object.assign(Object.assign({}, e), {
							[s]: ZC.a.waitingForRequest
						})
					}
					default:
						return e
				}
			};
			const lD = [];
			var bD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case cD.f:
							return [t.payload, ...e];
						case cD.c: {
							const s = t.payload.name;
							return e.filter(e => e.name !== s)
						}
						case Gl.j:
							return t.payload.whitelistedUsers;
						default:
							return e
					}
				},
				pD = Object(T.c)({
					api: uD,
					data: bD
				}),
				OD = Object(T.c)({
					account: qC,
					accountSettings: XC,
					blocked: nA,
					chatSettings: cA,
					drafts: uA,
					experiments: fA,
					googleOneTapEnabled: jA,
					isCustomizeFlyoutShowing: _A,
					topContentDismissalPrefsSet: oD,
					language: hA,
					loid: EA,
					notificationPrefs: VA,
					ownedBadges: KA,
					powerups: XA,
					prefs: ZA.c,
					reddaid: $A,
					session: tD,
					sessionRefreshFailed: sD,
					sessionTracker: nD,
					temporaryGQL: iD,
					wallets: LC,
					whitelist: pD
				});
			var gD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case FC.a:
						return t.payload || null;
					case FC.b:
					case FC.c:
						return null;
					default:
						return e
				}
			};
			var fD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case FC.c:
						return !0;
					case FC.b:
					case FC.a:
						return !1;
					default:
						return e
				}
			};
			var mD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case FC.b:
						return !0;
					case FC.a:
					case FC.c:
						return !1;
					default:
						return e
				}
			};
			var jD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case FC.b:
							return t.payload.userDataExportEligibility;
						case FC.a:
						case FC.c:
							return !1;
						default:
							return e
					}
				},
				_D = Object(T.c)({
					error: gD,
					pending: fD,
					success: mD,
					userDataExportEligibility: jD
				}),
				hD = Object(T.c)({
					userDataRequestPageApi: _D
				});
			const yD = {};
			var ED = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : yD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c:
					case Be.b:
					case Ea.a:
					case Fe.b:
					case te.b:
					case de.e:
						return Object.assign(Object.assign({}, e), t.payload.userFlair);
					case ee.i:
					case ee.f:
					case ee.m:
					case ee.p:
					case ee.v: {
						const {
							response: s
						} = t.payload, {
							userFlair: n
						} = s, r = Object.assign({}, e);
						return Object.keys(n).forEach(e => {
							r[e] || (r[e] = n[e])
						}), r
					}
					case de.i: {
						const {
							subredditId: s,
							applied: n,
							displaySettings: r
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								applied: n,
								displaySettings: r
							})
						})
					}
					case $.h: {
						const {
							subredditId: s,
							applied: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								applied: n
							})
						})
					}
					case de.d: {
						const {
							subredditId: s,
							isEnabled: n
						} = t.payload, r = e[s].displaySettings, a = Object.assign(Object.assign({}, r), {
							isEnabled: n
						});
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								displaySettings: a
							})
						})
					}
					case de.b: {
						const {
							subredditId: s,
							canAssignOwn: n
						} = t.payload, r = e[s].permissions, a = Object.assign(Object.assign({}, r), {
							canAssignOwn: n
						});
						return Object.assign(Object.assign({}, e), {
							[s]: Object.assign(Object.assign({}, e[s]), {
								permissions: a
							})
						})
					}
					case de.h: {
						const s = t.payload,
							n = e[s.subredditId],
							r = e[s.subredditId].templates,
							a = e[s.subredditId].templateIds,
							i = Object.assign(Object.assign({}, r), {
								[s.template.id]: s.template
							}),
							o = [...a];
						return o.includes(s.template.id) || o.push(s.template.id), Object.assign(Object.assign({}, e), {
							[s.subredditId]: Object.assign(Object.assign({}, n), {
								templates: i,
								templateIds: o
							})
						})
					}
					case de.c: {
						const s = t.payload,
							n = e[s.subredditId],
							r = e[s.subredditId].templates,
							a = e[s.subredditId].templateIds,
							i = jn()(r, s.templateId),
							o = a.filter(e => e !== s.templateId);
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: Object.assign(Object.assign({}, n), {
								templates: Object.assign({}, i),
								templateIds: o
							})
						})
					}
					case de.g:
					case de.f: {
						const s = t.payload,
							n = e[s.subredditId];
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: Object.assign(Object.assign({}, n), {
								templateIds: s.templateIds
							})
						})
					}
					default:
						return e
				}
			};
			const ID = {};
			var vD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ID,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Bw.g:
					case Bw.f: {
						const {
							username: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: null
						})
					}
					case Bw.e: {
						const {
							username: s,
							error: n
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.toLowerCase()]: n
						})
					}
					default:
						return e
				}
			};
			var SD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bw.g:
							return !0;
						case Bw.f:
						case Bw.e:
							return !1;
						default:
							return e
					}
				},
				TD = Object(T.c)({
					error: vD,
					pending: SD
				});
			const wD = {};
			var CD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.f: {
						const {
							subredditId: s,
							usersAppliedBadges: n
						} = t.payload, r = Object.keys(n).reduce((t, r) => {
							const a = n[r];
							return t[r] = Object.assign(Object.assign({}, e[r] || {}), {
								[s]: a
							}), t
						}, {});
						return Object.assign(Object.assign({}, e), r)
					}
					case o.b: {
						const {
							badgeIds: s,
							subredditId: n,
							userId: r
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, e[r] || {}), {
								[n]: s
							})
						})
					}
					case o.a: {
						const {
							previousBadgeIds: s,
							subredditId: n,
							userId: r
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, e[r] || {}), {
								[n]: s
							})
						})
					}
					case c.a: {
						const {
							badge: s,
							currentAppliedBadges: n,
							placement: r,
							subredditId: a,
							userId: i
						} = t.payload, o = n.filter(e => e.placement !== r).concat(s).filter(Boolean).map(e => e.id);
						return Object.assign(Object.assign({}, e), {
							[i]: Object.assign(Object.assign({}, e[i] || {}), {
								[a]: o
							})
						})
					}
					default:
						return e
				}
			};
			const AD = {},
				DD = (e, t) => {
					const s = Object.keys(t);
					if (!s.length) return e;
					const n = {};
					return s.forEach(s => {
						const r = e[s],
							a = t[s];
						r && fn()(r, a) || (n[s.toLowerCase()] = a)
					}), Object.keys(n).length ? Object.assign(Object.assign({}, e), n) : e
				};
			var PD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Bw.f: {
							const {
								data: s
							} = t.payload;
							return DD(e, s)
						}
						case Og.k: {
							const {
								user: s
							} = t.payload;
							return DD(e, {
								[s.username]: s
							})
						}
						case ge.t: {
							const {
								gildee: s
							} = t.payload;
							if (!s) return e;
							const n = e[s.toLowerCase()];
							if (!n) return e;
							const r = n.awardedLastMonth,
								a = r ? r.totalCount + 1 : 1,
								i = r && r.topAward;
							return i ? DD(e, {
								[s.toLowerCase()]: Object.assign(Object.assign({}, n), {
									awardedLastMonth: {
										totalCount: a,
										topAward: i
									}
								})
							}) : e
						}
						case ge.a: {
							const {
								userName: s,
								awardeeKarma: n,
								awarderKarma: r
							} = t.payload, a = e[s.toLowerCase()];
							if (!a) return e;
							const i = n || a.awardeeKarma,
								o = r || a.awarderKarma;
							return DD(e, {
								[s.toLowerCase()]: Object.assign(Object.assign({}, a), {
									awardeeKarma: i,
									awarderKarma: o,
									totalKarma: i + o + a.postKarma + a.commentKarma
								})
							})
						}
						case Gl.l:
						case Gl.k: {
							const {
								imageUrl: s,
								key: n,
								username: r
							} = t.payload;
							if ("profileIcon" !== n) return e;
							const a = r.toLowerCase(),
								i = e[a];
							return i ? DD(e, {
								[a]: Object.assign(Object.assign({}, i), {
									accountIcon: s
								})
							}) : e
						}
						default:
							return e
					}
				},
				RD = s("./src/reddit/actions/usernameAvailable.ts");
			const kD = {};
			var xD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case RD.a: {
						const {
							username: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: RD.b.Available
						})
					}
					case RD.c: {
						const {
							username: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: RD.b.Error
						})
					}
					case RD.d: {
						const {
							username: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: RD.b.Pending
						})
					}
					case RD.e: {
						const {
							username: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s]: RD.b.Unavailable
						})
					}
					default:
						return e
				}
			};
			const ND = {};
			var LD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ND,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.bb: {
						const {
							userId: s,
							supportedSubreddits: n
						} = t.payload, r = {
							[s]: n
						};
						return Object.assign(Object.assign({}, e), r)
					}
					default:
						return e
				}
			};
			var UD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.ab:
						case ge.cb:
							return !1;
						case ge.bb:
							return !0;
						default:
							return e
					}
				},
				MD = Object(T.c)({
					allocationByKey: LD,
					fetched: UD
				});
			const FD = {};
			var GD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : FD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.n: {
						const {
							subredditId: s,
							wallets: n
						} = t.payload, r = Object.keys(n).reduce((t, r) => {
							const a = e[r] || {},
								i = Object.assign(Object.assign({}, a), {
									[s]: n[r]
								});
							return Object.assign(Object.assign({}, t), {
								[r]: i
							})
						}, {});
						return Object.assign(Object.assign({}, e), r)
					}
					default:
						return e
				}
			};
			var BD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.qb:
						return t.payload;
					case ge.sb:
					case ge.rb:
						return null;
					default:
						return e
				}
			};
			var qD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.rb:
						case ge.qb:
							return !1;
						case ge.sb:
							return !0;
						default:
							return e
					}
				},
				VD = Object(T.c)({
					error: BD,
					pending: qD
				});
			var HD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.tb:
						return t.payload.postId;
					default:
						return e
				}
			};
			const KD = {};
			var WD = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : KD,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ge.rb: {
						const {
							postId: s,
							currentRank: n
						} = t.payload;
						return n ? Object.assign(Object.assign({}, e), {
							[s]: n
						}) : e
					}
					default:
						return e
				}
			};
			const YD = {};
			var zD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : YD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ge.rb: {
							const {
								postId: s,
								topAwardersRank: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								[s]: (n || []).sort((e, t) => e.rank - t.rank)
							})
						}
						case ge.t: {
							const {
								id: s
							} = t.payload;
							return jn()(e, [s])
						}
						default:
							return e
					}
				},
				JD = Object(T.c)({
					api: VD,
					currentPostId: HD,
					currentRank: WD,
					list: zD
				}),
				QD = Object(T.c)({
					api: TD,
					appliedBadges: CD,
					models: PD,
					nameAvailable: xD,
					publicWallets: GD,
					topAwarders: JD,
					powerups: MD
				});
			const XD = {};
			var ZD = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : XD,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case te.b:
						case ie.c:
						case ce.i:
						case ae.c:
						case Be.b:
						case Ea.a: {
							const {
								structuredStyles: s
							} = t.payload;
							if (!(s && s.data && s.data.content)) return e;
							const n = s.data.content.widgets.layout.idCardWidget,
								r = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== r.length) return e;
							const a = r[0];
							return Object.assign(Object.assign({}, e), {
								[a]: n
							})
						}
						default:
							return e
					}
				},
				$D = s("./src/reddit/actions/widgets/constants.ts");
			const eP = {};
			var tP = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eP,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Fe.b:
						case te.b:
						case ae.c:
						case ce.i:
						case ie.c:
						case Be.b: {
							const {
								structuredStyles: s
							} = t.payload;
							if (!(s && s.data && s.data.content)) return e;
							const n = s.data.content.widgets.items,
								r = s.data.content.widgets.layout.topbar.order.filter(e => n[e] && "menu" === n[e].kind);
							if (!r.length) return e;
							const a = Object.keys(t.payload.subredditAboutInfo || {});
							if (1 !== a.length) return e;
							const i = a[0];
							return Object.assign(Object.assign({}, e), {
								[i]: r[0]
							})
						}
						case $D.g: {
							const s = t.payload;
							return "menu" !== s.widget.kind ? e : Object.assign(Object.assign({}, e), {
								[s.subredditId]: s.widgetId
							})
						}
						case $D.h: {
							const s = t.payload;
							return e[s.subredditId] === s.widgetId ? Object.assign(Object.assign({}, e), {
								[s.subredditId]: null
							}) : e
						}
						default:
							return e
					}
				},
				sP = s("./src/reddit/models/Widgets/index.ts");
			const nP = {};
			var rP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : nP,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c: {
						const s = t.payload,
							n = s.structuredStyles && s.structuredStyles.data && s.structuredStyles.data.content;
						if (!n) return e;
						const r = n.widgets;
						return Object.assign(Object.assign({}, e), r.items)
					}
					case $D.b: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), s.widgets.items)
					}
					case g.k: {
						const t = Object.assign({}, e);
						return Object.keys(t).forEach(e => {
							t[e] = Object.assign(Object.assign({}, t[e]), {
								styles: Object(sP.m)()
							})
						}), t
					}
					case $D.e: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), s.widgets.items)
					}
					case $D.i:
					case $D.g: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.widget.id]: s.widget
						})
					}
					case $D.h: {
						const s = t.payload,
							n = Object.assign({}, e);
						return delete n[s.widgetId], n
					}
					case Fe.b:
					case te.b:
					case ie.c:
					case ce.i:
					case ae.c:
					case Be.b:
					case Ea.a: {
						const {
							structuredStyles: s
						} = t.payload;
						if (!(s && s.data && s.data.content)) return e;
						const n = s.data.content.widgets;
						return Object.assign(Object.assign({}, e), n.items)
					}
					case mg.h: {
						const {
							userIsSubscriber: s,
							nameIdentifiers: n,
							widgetId: r
						} = t.payload;
						if (!r || !e[r] || "community-list" !== e[r].kind) return Object.assign({}, e);
						const a = s,
							i = e[r],
							o = i.data.map(e => {
								const t = Object.assign({}, e);
								return n.some(e => e.name === t.name) && (t.isSubscribed = a), t
							});
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, i), {
								data: o
							})
						})
					}
					case Zv.f: {
						const {
							settings: s,
							idCardWidgetId: n
						} = t.payload;
						return n && e[n] && "publicDescription" in s && s.publicDescription !== e[n].description ? Object.assign(Object.assign({}, e), {
							[n]: Object.assign(Object.assign({}, e[n]), {
								description: s.publicDescription || ""
							})
						}) : e
					}
					default:
						return e
				}
			};
			const aP = {};
			var iP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : aP,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c:
					case te.b:
					case ce.i:
					case Be.b: {
						const {
							structuredStyles: s
						} = t.payload;
						if (!(s && s.data && s.data.content)) return e;
						const n = s.data.content.widgets.layout.moderatorWidget,
							r = Object.keys(t.payload.subredditAboutInfo || {});
						if (1 !== r.length) return e;
						const a = r[0];
						return Object.assign(Object.assign({}, e), {
							[a]: n
						})
					}
					default:
						return e
				}
			};
			const oP = {};
			var cP = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oP,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ie.c:
					case Be.b:
					case Ea.a: {
						const s = t.payload,
							n = s.structuredStyles && s.structuredStyles.data && s.structuredStyles.data.content;
						if (!n) return e;
						const r = Object.keys(s.subredditAboutInfo || {});
						if (1 !== r.length) return e;
						const a = r[0],
							i = n.widgets.layout.sidebar.order;
						return Object.assign(Object.assign({}, e), {
							[a]: i
						})
					}
					case $D.e:
					case $D.b: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: s.widgets.layout.sidebar.order
						})
					}
					case $D.f: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: s.widgetIds
						})
					}
					case $D.g: {
						const s = t.payload;
						if ("menu" === s.widget.kind) return e;
						if (!e[s.subredditId]) return Object.assign(Object.assign({}, e), {
							[s.subredditId]: [s.widgetId]
						});
						const n = e[s.subredditId].concat(s.widgetId);
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: n
						})
					}
					case $D.h: {
						const s = t.payload;
						if (!e[s.subredditId]) return e;
						const n = e[s.subredditId].filter(e => e !== s.widgetId);
						return Object.assign(Object.assign({}, e), {
							[s.subredditId]: n
						})
					}
					case Fe.b:
					case te.b:
					case ie.c:
					case ae.c:
					case ce.i:
					case Be.b:
					case Ea.a: {
						const {
							structuredStyles: s
						} = t.payload;
						if (!(s && s.data && s.data.content)) return e;
						const n = s.data.content.widgets.layout.sidebar.order,
							r = Object.keys(t.payload.subredditAboutInfo || {});
						if (1 !== r.length) return e;
						const a = r[0];
						return Object.assign(Object.assign({}, e), {
							[a]: n
						})
					}
					default:
						return e
				}
			};
			const dP = {
				accountManagerModalData: a,
				activeModalId: m,
				ads: E,
				apiRequestState: S,
				approvedSubmitters: Y,
				authorFlair: Oe,
				awards: ct,
				badges: Et,
				banned: qt,
				blockedRedditors: Qt,
				blockUser: ns,
				brandSafety: as,
				chat: Hs,
				claimGold: Zs,
				comments: Kn,
				commentsListTruncated: Yn,
				commentsPage: _r,
				communityFlairs: Er,
				contentGate: Sr,
				continueThreads: Cr,
				creations: xi,
				dashboard: Ui,
				discoveryUnits: Zi,
				dismissedTruncationList: to,
				economics: vo,
				emojis: xo,
				experimentOverrides: Fo,
				externalAccount: Oc,
				featureFlags: yc,
				flairedUsers: Lc,
				focusedVerticals: Jc,
				fontFiles: Xc,
				gild: ld,
				goldPurchase: Eu,
				header: Tu,
				imageUploads: Au,
				inboxNotifications: Lu,
				interceptedAction: Mu,
				isChangeUsernameTooltipShowing: Gu,
				isEmailVerificationTooltipShowing: qu,
				isModeratorWithPostPerms: Hu,
				jsApi: Yu,
				leaderboard: rl,
				listings: zl,
				live: Zl,
				mediaGalleries: rb,
				mediaPlayback: ob,
				meta: ub,
				moderatingSubreddits: bb,
				moderationLog: wb,
				moderationPromptId: Cb,
				moderators: Op,
				modListingPage: yp,
				modModeEnabled: Ep,
				modQueue: IO,
				moreComments: RO,
				multireddits: Ig,
				muted: qg,
				notificationBannerId: Hg,
				nps: Yg,
				oldSiteRules: Qg,
				page: sf,
				platform: df,
				postCollection: Gf,
				postRequirements: sm,
				polls: Cf,
				postFlair: Wf,
				posts: t_,
				postStickiedComments: a_,
				givePremium: fd,
				products: h_,
				profileCommentsPage: N_,
				profilePrivatePage: xh,
				profileModSettingsPage: F_,
				profileOverviewPage: Eh,
				profilePostsPage: vh,
				profiles: Oy,
				promos: _y,
				publicAccessNetwork: $y,
				recommendations: tE,
				removalReasons: bE,
				reportFlow: IE,
				reportPage: kE,
				reportRules: LE,
				requestHost: UE,
				runTimeEnvVars: GE,
				search: ZE,
				searchDiscoveryUnits: iI,
				seo: lI,
				shortcuts: yI,
				sidebarPromotedPosts: vI,
				streaming: RI,
				structuredStyles: XI,
				stylesheets: ZI,
				subredditAutocomplete: ov,
				subredditChannels: _v,
				subreddits: VT,
				subredditStickyPosts: WT,
				subscriptions: bw,
				tabBadged: Ow,
				tags: Mw,
				themes: Hw,
				toaster: Yw,
				tooltipId: Jw,
				topics: Zw,
				tracing: tC,
				tracking: lC,
				trafficStats: gC,
				transfers: IC,
				trending: wC,
				trophies: AC,
				uploads: kC,
				user: OD,
				userDataRequestPage: hD,
				userFlair: ED,
				users: QD,
				widgets: Object(T.c)({
					idCardIds: ZD,
					menuIds: tP,
					models: rP,
					moderatorIds: iP,
					sidebar: cP
				})
			}
		},
		"./src/reddit/reducers/sidebarPromotedPosts/models/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			var n, r = s("./src/reddit/actions/ads/constants.ts");
			! function(e) {
				e[e.FRONTPAGE = 0] = "FRONTPAGE", e[e.COMMENTS_OVERLAY = 1] = "COMMENTS_OVERLAY", e[e.COMMENTS = 2] = "COMMENTS", e[e.SUBREDDIT = 3] = "SUBREDDIT", e[e.MULTIREDDIT = 4] = "MULTIREDDIT", e[e.SEARCH_RESULTS = 5] = "SEARCH_RESULTS"
			}(n || (n = {}));
			const a = {};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.s:
					case r.p: {
						const s = t.payload;
						return Object.assign(Object.assign({}, e), s)
					}
					case r.q:
					case r.s:
						return e;
					case r.u:
						return a;
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, r = s("./node_modules/lodash/uniqWith.js"),
				a = s.n(r),
				i = s("./node_modules/lodash/values.js"),
				o = s.n(i),
				c = s("./src/reddit/actions/tags/constants.ts"),
				d = s("./src/reddit/models/Option/index.ts"),
				u = s("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(n || (n = {}));
			const l = {
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case c.w:
					case c.r: {
						const {
							subredditId: s,
							itemTags: n,
							suggestedItemTags: r
						} = t.payload, i = a()([...(e.selectedOptions[s] || []).map(e => {
							if (!e.id) {
								const t = o()(n[s] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return Object.assign(Object.assign({}, Object(u.e)(t, !0)), {
									action: null
								})
							}
							return e
						}), ...o()(n[s] || {}).map(e => Object.assign(Object.assign({}, Object(u.e)(e, !0)), {
							action: null
						}))], d.a);
						return Object.assign(Object.assign({}, e), {
							selectedOptions: Object.assign(Object.assign({}, e.selectedOptions), {
								[s]: i.map(e => Object.assign(Object.assign({}, e), {
									action: e.id ? null : e.action
								}))
							}),
							selectedSuggestedOptions: Object.assign(Object.assign({}, e.selectedSuggestedOptions), {
								[s]: o()(r[s] || {}).map(e => Object.assign(Object.assign({}, Object(u.e)(e, !0)), {
									action: null
								}))
							}),
							deselectedOptions: Object.assign(Object.assign({}, e.deselectedOptions), {
								[s]: []
							})
						})
					}
					case c.D:
					case c.z: {
						const {
							subredditId: s,
							option: r
						} = t.payload, i = t.type === c.z ? "selectedOptions" : "selectedSuggestedOptions", o = t.type === c.z ? "deselectedOptions" : "deselectedSuggestedOptions", u = (e[o][s] || []).slice(), l = u.findIndex(e => Object(d.a)(e, r));
						let b = n.ADD;
						return l > -1 && (b = null, u.splice(l, 1)), Object.assign(Object.assign({}, e), {
							[i]: Object.assign(Object.assign({}, e[i]), {
								[s]: a()([...e[i][s] || [], Object.assign(Object.assign({}, r), {
									action: b
								})], d.a)
							}),
							[o]: Object.assign(Object.assign({}, e[o]), {
								[s]: u
							})
						})
					}
					case c.C:
					case c.y: {
						const {
							subredditId: s,
							option: r
						} = t.payload, a = t.type === c.y ? "selectedOptions" : "selectedSuggestedOptions", i = t.type === c.y ? "deselectedOptions" : "deselectedSuggestedOptions", o = (e[i][s] || []).slice(), u = (e[a][s] || []).slice(), l = u.findIndex(e => Object(d.a)(e, r));
						return l > -1 && (null === u[l].action && o.push(Object.assign(Object.assign({}, u[l]), {
							action: n.REMOVE
						})), u.splice(l, 1)), Object.assign(Object.assign({}, e), {
							[a]: Object.assign(Object.assign({}, e[a]), {
								[s]: u
							}),
							[i]: Object.assign(Object.assign({}, e[i]), {
								[s]: o
							})
						})
					}
					case c.A: {
						const {
							itemTagsState: s
						} = t.payload, n = Object.keys(s);
						if (!n.length) return e;
						const r = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							a = n.reduce((e, t) => (e.selectedOptions[t] = o()(s[t]).map(e => Object.assign(Object.assign({}, Object(u.e)(e, !0)), {
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), r);
						return Object.assign(Object.assign({}, e), {
							inputByItemId: Object.assign(Object.assign({}, e.inputByItemId), a.inputByItemId),
							selectedOptions: Object.assign(Object.assign({}, e.selectedOptions), a.selectedOptions),
							deselectedOptions: Object.assign(Object.assign({}, e.deselectedOptions), a.deselectedOptions)
						})
					}
					case c.B:
					case c.x: {
						const {
							subredditId: s,
							input: n
						} = t.payload, r = t.type === c.x ? "inputByItemId" : "suggestedInputByItemId";
						return Object.assign(Object.assign({}, e), {
							[r]: Object.assign(Object.assign({}, e[r]), {
								[s]: n
							})
						})
					}
					case c.i:
					case c.h: {
						const {
							subredditId: s,
							primaryTagId: n
						} = t.payload;
						if (!n || !s) return e;
						const r = e.selectedOptions[s];
						if (r) {
							const t = r.findIndex(e => e.id === n),
								a = [...r];
							return t >= 0 && a.splice(t, 1), Object.assign(Object.assign({}, e), {
								selectedOptions: Object.assign(Object.assign({}, e.selectedOptions), {
									[s]: a
								})
							})
						}
						return e
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/user/prefs/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, r, a = s("./node_modules/lodash/isEqual.js"),
				i = s.n(a),
				o = s("./node_modules/lodash/merge.js"),
				c = s.n(o),
				d = s("./node_modules/lodash/pick.js"),
				u = s.n(d),
				l = s("./src/lib/constants/index.ts"),
				b = s("./src/reddit/actions/comment/index.ts"),
				p = s("./src/reddit/actions/contentGate.ts"),
				O = s("./src/reddit/actions/frontpage.ts"),
				g = s("./src/reddit/actions/header.ts"),
				f = s("./src/reddit/actions/modQueue/constants.ts"),
				m = s("./src/reddit/actions/page.ts"),
				j = s("./src/reddit/actions/pages/collectionCommentsPage.ts"),
				_ = s("./src/reddit/actions/pages/modListing/constants.ts"),
				h = s("./src/reddit/actions/pages/postCreation.ts"),
				y = s("./src/reddit/actions/pages/postDraft.ts"),
				E = s("./src/reddit/actions/pages/profileComments.ts"),
				I = s("./src/reddit/actions/pages/profileOverview.ts"),
				v = s("./src/reddit/actions/pages/profilePosts.ts"),
				S = s("./src/reddit/actions/pages/search.ts"),
				T = s("./src/reddit/actions/pages/subreddit.ts"),
				w = s("./src/reddit/actions/pages/topic.ts"),
				C = s("./src/reddit/actions/postCreation/constants.ts"),
				A = s("./src/reddit/actions/postDraft.ts"),
				D = s("./src/reddit/actions/preferences.ts"),
				P = s("./src/reddit/actions/redditEmbed.ts"),
				R = s("./src/reddit/actions/search.ts"),
				k = s("./src/reddit/actions/structuredStyles/constants.ts"),
				x = s("./src/reddit/actions/subreddit.ts"),
				N = s("./src/reddit/actions/users.ts"),
				L = s("./src/reddit/constants/postLayout.ts"),
				U = s("./src/reddit/constants/preferences.ts"),
				M = s("./src/reddit/constants/theme.ts"),
				F = s("./src/reddit/models/PostCreationForm/index.ts"),
				G = s("./src/reddit/models/PostDraft/index.ts"),
				B = s("./src/reddit/models/User/index.ts");
			! function(e) {
				e.Whitelisted = "whitelisted", e.Everyone = "everyone"
			}(n || (n = {})),
			function(e) {
				e.Whitelisted = "nobody", e.Everyone = "everyone"
			}(r || (r = {}));
			const q = ["acceptPrivateMessages", "allowClickTracking", "autoplayVideo", "collapseReadMessages", "defaultCommentSort", "emailDigests", "emailUnreadMessages", "emailUnsubscribe", "geopopular", "hideAds", "hideFromRobots", "hideNSFW", "highlightComments", "ignoreSuggestedSort", "inBeta", "labelNSFW", "markMessagesRead", "nightmode", "over18", "sendWelcomeMessages", "showMessagesInInbox", "showNotifications", "showTwitter", "showUsernameMentionNotifications", "showActiveCommunities", ...U.a, "loginOtpEnabled"],
				V = {
					acceptPrivateMessages: void 0,
					activityRelevantAds: !0,
					allowClickTracking: !1,
					autoplayVideo: !0,
					collapsedTraySections: B.a,
					commentMode: F.h.RICH_TEXT,
					layout: L.d.Card,
					rememberCommunityLayout: !1,
					defaultCommentSort: l.r.CONFIDENCE,
					editorMode: F.h.RICH_TEXT,
					geopopular: void 0,
					globalTheme: M.a,
					hamburgerTray: void 0,
					hasSeenCustomizeFlyout: !0,
					hideNSFW: !0,
					ignoreSuggestedSort: !1,
					labelNSFW: !0,
					loginOtpEnabled: !1,
					markMessagesRead: !0,
					nightmode: !1,
					openPostInNewTab: !1,
					over18: !1,
					profileLayout: void 0,
					reduceAnimationsFromAwards: !1,
					rpanDuDismissalTime: void 0,
					showActiveCommunities: !0,
					showRpanDu: !0,
					showTwitter: !1,
					sort: l.Q.Hot,
					stylesEnabled: !0,
					subreddit: {},
					subscriptionsPinned: void 0,
					surveyLastSeenTime: void 0,
					thirdPartyDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedContent: !0,
					showLocationBasedRecommendations: !0,
					topContentDismissalTime: 0,
					topContentTimesDismissed: 0,
					rememberCommunitySort: !1,
					useMarkdown: !1
				},
				H = {
					rpanDuDismissalTime: void 0,
					isContributorRequestTimestamp: 0,
					stylesEnabled: !0,
					layout: void 0,
					sort: void 0
				},
				K = (e, t) => {
					if (!t) return e;
					const s = u()(Object.assign(Object.assign({}, t.account), t), q),
						n = t.subreddit,
						r = Object.assign({}, e.subreddit);
					Object.keys(n || {}).forEach(e => {
						r[e] = Object.assign(Object.assign({}, H), n && n[e])
					});
					const a = Object.assign(Object.assign(Object.assign({}, e), s), {
						subreddit: r
					});
					if (a.useMarkdown !== e.useMarkdown) {
						const e = a.useMarkdown ? F.h.MARKDOWN : F.h.RICH_TEXT;
						a.editorMode = e, a.commentMode = e
					}
					return i()(a, e) ? e : a
				},
				W = (e, t, s) => K(e, {
					subreddit: {
						[t]: Object.assign(Object.assign(Object.assign({}, H), e.subreddit[t]), s)
					}
				});
			t.c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case b.l:
					case b.s: {
						const {
							editorMode: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							commentMode: s
						})
					}
					case C.v:
					case C.Q: {
						const {
							editorMode: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							editorMode: s
						})
					}
					case g.d:
						return Object.assign(Object.assign({}, e), {
							subscriptionsPinned: !0
						});
					case g.e:
						return Object.assign(Object.assign({}, e), {
							subscriptionsPinned: !1
						});
					case A.g: {
						const {
							kind: s
						} = t.payload;
						return Object.assign(Object.assign({}, e), {
							editorMode: s === G.b.Markdown ? F.h.MARKDOWN : F.h.RICH_TEXT
						})
					}
					case D.h: {
						const {
							layout: s
						} = t.payload;
						return e.layout === s ? e : Object.assign(Object.assign({}, e), {
							layout: s
						})
					}
					case D.o:
						return void 0 !== t.payload ? Object.assign(Object.assign({}, e), {
							rpanDuDismissalTime: t.payload
						}) : e;
					case D.p: {
						const {
							layout: s,
							subredditId: n
						} = t.payload;
						return W(e, n, {
							layout: s
						})
					}
					case D.e:
						return Object.assign(Object.assign({}, e), {
							hasSeenCustomizeFlyout: !0
						});
					case D.m:
						return e.profileLayout === t.payload.profileLayout ? e : Object.assign(Object.assign({}, e), {
							profileLayout: t.payload.profileLayout
						});
					case p.g:
						return Object.assign(Object.assign({}, e), {
							over18: !0
						});
					case D.b:
						return void 0 !== t.payload ? Object.assign(Object.assign({}, e), {
							autoplayVideo: t.payload.autoplayVideo
						}) : e;
					case D.i:
						return void 0 !== t.payload ? Object.assign(Object.assign({}, e), {
							nightmode: t.payload.nightmode
						}) : e;
					case D.r:
						if (void 0 !== t.payload) {
							const {
								topContentDismissalTime: s,
								topContentTimesDismissed: n
							} = t.payload;
							return Object.assign(Object.assign({}, e), {
								topContentDismissalTime: s,
								topContentTimesDismissed: n
							})
						}
						return e;
					case k.d:
						return t.payload.isNightmodeOn ? Object.assign(Object.assign({}, e), {
							nightmode: !1,
							nightmodeTempUpdated: !0
						}) : e;
					case k.e:
						return t.payload.nightmodeTempUpdated ? Object.assign(Object.assign({}, e), {
							nightmode: !0,
							nightmodeTempUpdated: !1
						}) : e;
					case D.f:
						return void 0 !== t.payload ? Object.assign(Object.assign({}, e), {
							hamburgerTray: t.payload.set
						}) : Object.assign(Object.assign({}, e), {
							hamburgerTray: !e.hamburgerTray
						});
					case D.c:
						return void 0 !== t.payload ? Object.assign(Object.assign({}, e), {
							collapsedTraySections: c()({}, e.collapsedTraySections, t.payload)
						}) : e;
					case p.a:
					case p.b:
					case p.h:
					case p.i:
					case p.f:
					case p.j:
					case _.e:
					case _.h:
					case j.a:
					case m.a:
					case j.b:
					case m.b:
					case j.d:
					case m.d:
					case m.g:
					case T.c:
					case m.k:
					case m.j:
					case E.e:
					case I.e:
					case I.b:
					case v.e:
					case O.b:
					case x.i:
					case R.c:
					case P.b:
					case h.b:
					case y.a:
					case D.j:
					case S.c:
					case D.a:
					case N.c:
					case w.e:
						return t.payload && t.payload.preferences ? K(e, t.payload.preferences) : e;
					case D.q: {
						const {
							subredditId: s,
							prefs: n
						} = t.payload;
						return W(e, s, n)
					}
					case E.d:
					case I.d:
					case I.a:
					case v.d:
						if (t.payload && t.payload.account) {
							const {
								nightmode: s
							} = t.payload.account;
							if (e.nightmode !== s) return Object.assign(Object.assign({}, e), {
								nightmode: s
							})
						}
						return e;
					case f.h:
					case f.j:
					case f.i:
					case f.g:
					case f.f:
					case f.n:
					case f.m:
					case f.p:
					case f.q:
					case f.w:
					case f.v:
						return t.payload && t.payload.response && t.payload.response.preferences ? K(e, t.payload.preferences) : e;
					case D.n: {
						const s = t.payload,
							{
								showActiveCommunities: n
							} = s.additional;
						return e.showActiveCommunities !== n ? Object.assign(Object.assign({}, e), {
							showActiveCommunities: n
						}) : e
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/routes/modListing/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "d", (function() {
				return g
			}));
			var n = s("./node_modules/core-js/modules/web.dom.iterable.js"),
				r = s.n(n),
				a = s("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = s("./node_modules/lodash/flatten.js"),
				o = s.n(i),
				c = s("./src/lib/constants/index.ts"),
				d = s("./src/reddit/actions/pages/modListing/index.ts");
			const u = Object(a.a)({
					resolved: {},
					chunkName: () => "ModListing",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("vendors~ModListing"), s.e("CollectionCommentsPage~CommentsPage~Frontpage~MembershipPaywallPage~ModListing~ModQueuePages~Moderat~83e43315"), s.e("CollectionCommentsPage~CommentsPage~Frontpage~ModListing~ModQueuePages~Multireddit~ProfileOverview~P~edc6d07c"), s.e("Frontpage~ModListing~Multireddit~ProfileComments~ProfilePosts~ProfilePrivate~SearchResults~Subreddit~Topic"), s.e("Frontpage~ModListing~Multireddit~ProfilePosts~Subreddit"), s.e("ModListing~Reddit"), s.e("ModListing")]).then(s.bind(null, "./src/reddit/pages/ModListing/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/pages/ModListing/index.tsx"
					}
				}),
				l = "/r/mod",
				b = "/me/f/mod",
				p = [l, b],
				O = o()(p.map(e => Object.keys(c.O).map(t => "".concat(e, "/:sort(").concat(c.O[t], ")?")))),
				g = e => e.startsWith(b),
				f = {
					action: d.b,
					chunk: c.p.MOD_LISTING,
					component: u,
					exact: !0,
					meta: {
						name: c.Bb.MOD_LISTING
					},
					path: O,
					prefetches: [c.p.SUBREDDIT, c.p.COMMENTS_PAGE]
				};
			t.c = f
		},
		"./src/reddit/routes/postCreation/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return b
			})), s.d(t, "b", (function() {
				return p
			}));
			var n = s("./node_modules/core-js/modules/es6.regexp.replace.js"),
				r = s.n(n),
				a = s("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = s("./src/lib/constants/index.ts"),
				o = s("./src/reddit/actions/pages/postCreation.ts"),
				c = s("./src/reddit/routes/postCreation/constants.ts");
			const d = [c.b, c.c, c.a],
				u = Object(a.a)({
					resolved: {},
					chunkName: () => "PostCreation",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("vendors~Chat~ChatMessageInput~CollectionCommentsPage~CommentsPage~MembershipPaywallPage~ModerationPa~e7ce6754"), s.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), s.e("vendors~PostCreation~Reddit~StandalonePostPage~reddit-components-ClassicPost~reddit-components-Compa~16c34322"), s.e("vendors~CollectionCommentsPage~CommentsPage~ModerationPages~PostCreation~StandalonePostPage~Subreddit"), s.e("vendors~ChatMessageInput~FlairEdit~MembershipPaywallPage~PostCreation~RichTextEditor"), s.e("vendors~InFeedChaining~PostCreation~Reddit~StandalonePostPage~SubredditPremiumBadgeHovercardTooltip"), s.e("vendors~PostCreation~RichTextEditor"), s.e("CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~InFeedChaining~~a66c4d66"), s.e("ChatMessageInput~ChatPost~CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceRelease~05e09478"), s.e("PostCreation")]).then(s.bind(null, "./src/reddit/pages/PostCreation/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/pages/PostCreation/index.tsx"
					}
				}),
				l = e => "/".concat(e, "/submit"),
				b = (e, t) => {
					return c.c.replace(/:subredditName/, e) + (t ? "?collection=".concat(t) : "")
				},
				p = e => c.a.replace(/:profileName/, e),
				O = {
					action: o.e,
					component: u,
					chunk: i.p.POST_CREATION,
					exact: !0,
					meta: {
						name: i.Bb.POST_CREATION
					},
					path: d,
					prefetches: [i.p.COMMENTS_PAGE]
				};
			t.a = O
		},
		"./src/reddit/selectors/PublicAccessNetwork/api.ts": function(e, t, s) {
			"use strict";
			s.d(t, "k", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "i", (function() {
				return b
			})), s.d(t, "l", (function() {
				return p
			})), s.d(t, "m", (function() {
				return O
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "o", (function() {
				return f
			})), s.d(t, "n", (function() {
				return m
			})), s.d(t, "g", (function() {
				return j
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "h", (function() {
				return y
			})), s.d(t, "j", (function() {
				return I
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/lib/objectSelector/index.ts"),
				a = s("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = s("./src/reddit/helpers/publicAccessNetwork/index.ts");
			const o = e => e.publicAccessNetwork.api.config,
				c = (e, t) => !!t && !!e.publicAccessNetwork.api.error[Object(i.h)(t)],
				d = e => c(e, a.b),
				u = (e, t) => !!t && !!e.publicAccessNetwork.api.pending[Object(i.h)(t)] && e.publicAccessNetwork.api.pending[Object(i.h)(t)].isPending,
				l = e => u(e, a.b),
				b = e => e.publicAccessNetwork.api.pending[a.b] && e.publicAccessNetwork.api.pending[a.b].fetchedUtcTimeStamp,
				p = Object(n.a)(o, e => e.global),
				O = Object(n.a)((e, t) => {
					let {
						subreddit: s
					} = t;
					return s
				}, o, (e, t) => {
					const s = e.toLowerCase();
					return t.subreddits[s]
				}),
				g = Object(n.a)(o, e => e.global.rpan_intro_video_url),
				f = Object(n.a)(o, e => e.global.url_to_show_for_unavailable_video),
				m = Object(n.a)(o, e => !1),
				j = Object(n.a)(o, e => e.isError),
				_ = Object(n.a)(o, e => e.global.max_chat_comment_length),
				h = e => e.publicAccessNetwork.api.recommendedViewerSubreddits,
				y = (Object(n.a)(h, e => e.isError), Object(n.a)(h, e => e.isPending)),
				E = Object(r.a)(Object(n.a)(h, e => e.subreddits)),
				I = Object(n.a)(E, e => [{
					name: "All",
					prefixedName: "All",
					path: Object(i.e)()
				}, ...e.map(e => ({
					name: e,
					prefixedName: "r/".concat(e),
					path: Object(i.g)(e)
				}))])
		},
		"./src/reddit/selectors/activeModalId.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = e => e.activeModalId,
				r = e => t => t.activeModalId === e
		},
		"./src/reddit/selectors/blockedRedditors.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "c", (function() {
				return a
			}));
			const n = e => e.blockedRedditors.api.pending,
				r = e => e.blockedRedditors.list,
				a = (e, t) => {
					const s = (e => {
						const t = r(e);
						return t && t.ids
					})(e);
					return !!s && s.includes(t)
				}
		},
		"./src/reddit/selectors/brandSafety.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/isFakeSubreddit/index.ts"),
				a = s("./src/reddit/contexts/PageLayer/selectors.ts"),
				i = s("./src/reddit/models/WhitelistStatus/index.ts"),
				o = s("./src/reddit/selectors/posts.ts"),
				c = s("./src/reddit/selectors/subreddit.ts");
			const d = new Set([n.O.NEW, n.O.RISING, n.O.CONTROVERSIAL]),
				u = e => e.brandSafety.hasBrandSafetyBeenAssessed,
				l = (e, t) => {
					let {
						postId: s
					} = t;
					const n = Object(o.N)(e, {
							postId: s
						}),
						r = Object(o.ab)(e, {
							postId: s
						});
					return !(!n || !r) && (r.wls === i.b.ALL_ADS && !n.isNSFW)
				},
				b = e => e.brandSafety.isViewSafe,
				p = e => !e.brandSafety.isViewSafe,
				O = (e, t) => {
					const {
						listingName: s,
						pageLayer: n
					} = t, o = Object(c.B)(e, {
						subredditName: s
					}), u = Object(a.b)(e, {
						pageLayer: n
					});
					return (!u || !d.has(u)) && (!(o || !Object(r.a)(s)) || !!o && o.wls === i.b.ALL_ADS)
				}
		},
		"./src/reddit/selectors/chat.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "c", (function() {
				return l
			}));
			var n = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				r = s("./src/reddit/selectors/moderatorPermissions.ts"),
				a = s("./src/reddit/selectors/platform.ts");
			const i = e => e.chat.unread.count,
				o = e => {
					return i(e).basicChannelCount
				},
				c = e => e.chat.promos,
				d = e => !(e.chat.isInited || e.chat.unread.api.pending),
				u = (e, t) => {
					const {
						chatConfig: s
					} = n.c;
					return Object(r.a)(s)(e, t)
				},
				l = e => {
					const t = Object(a.d)(e);
					if (e.chat.subredditSettings.subredditId === t) return e.chat.subredditSettings
				}
		},
		"./src/reddit/selectors/chatSettingsPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/reddit/models/ChatSettingsPage/index.ts");
			const r = (e, t) => {
					let {
						subredditId: s
					} = t;
					return !!e.chat.subredditSettingsPage.api.fetch.pending[s]
				},
				a = (e, t) => {
					let {
						subredditId: s
					} = t;
					return (e.chat.subredditSettingsPage.models[s] || []).filter(e => e && e.settingType !== n.a.Unknown)
				}
		},
		"./src/reddit/selectors/claimgold.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = e => e.claimGold.code,
				r = e => e.claimGold.showModal
		},
		"./src/reddit/selectors/communityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return a
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "g", (function() {
				return O
			})), s.d(t, "i", (function() {
				return g
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./src/lib/objectSelector/index.ts"),
				r = s("./src/reddit/models/Gold/Award.ts");
			const a = e => e.awards.create.api.pending,
				i = Object(n.a)((e, t) => {
					let {
						subredditOrProfileId: s
					} = t;
					const n = e.awards.manageable.order[s];
					return n ? n.map(t => e.awards.models[t]).filter(e => e.isEnabled) : []
				}),
				o = Object(n.a)((e, t) => {
					let {
						subredditOrProfileId: s
					} = t;
					return Object.entries(e.awards.manageable.availability[s] || {}).map(t => {
						let [s, n] = t;
						return Object.assign(Object.assign({}, e.awards.models[s]), {
							isEnabled: n
						})
					}).sort((e, t) => e.name.localeCompare(t.name))
				}),
				c = (e, t) => {
					let {
						subredditOrProfileId: s
					} = t;
					return e.awards.manageable.api.pending[s]
				},
				d = (e, t) => {
					let {
						subredditOrProfileId: s
					} = t;
					return !!e.awards.blacklist[s]
				},
				u = (e, t) => e.awards.models[t],
				l = r.l.map(e => ({
					award: e,
					total: 0
				})),
				b = Object(n.a)((e, t) => {
					let {
						subredditId: s
					} = t;
					const n = e.awards.usable.order[s];
					return n ? n.map(t => ({
						award: e.awards.models[t],
						total: 0
					})).filter(e => e.award.isEnabled) : l
				}),
				p = Object(n.a)((e, t) => {
					let {
						subredditId: s,
						thingId: n
					} = t;
					const r = e.awards.sortedUsable.order[s];
					if (!r) return b(e, {
						subredditId: s
					});
					const a = r[n];
					return a ? a.map(t => {
						let {
							award: s,
							total: n
						} = t;
						return {
							total: n,
							award: e.awards.models[s.id]
						}
					}).filter(e => {
						let {
							award: t
						} = e;
						return t.isEnabled
					}) : l
				}),
				O = (e, t) => {
					let {
						subredditId: s,
						thingId: n
					} = t;
					const r = e.awards.sortedUsable.api.pending[s];
					return !!r && r[n]
				},
				g = Object(n.a)((e, t) => {
					let {
						subredditId: s
					} = t;
					return e.awards.tags.order[s] || []
				})
		},
		"./src/reddit/selectors/communityFlairs.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			}));
			var n = s("./node_modules/reselect/es/index.js");
			const r = (e, t) => {
					const s = e.communityFlairs[t];
					return s && s.sortedKeys
				},
				a = Object(n.a)(r, e => e),
				i = (e, t) => {
					const s = e.communityFlairs[t];
					return s && s.models
				},
				o = Object(n.a)(i, e => e),
				c = (Object(n.a)((e, t) => i(e, t), (e, t) => r(e, t), (e, t) => {
					if (t && e) return t.map(t => e[t])
				}), (e, t) => e.communityFlairs.hasOwnProperty(t))
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return l
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "f", (function() {
				return j
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeListingKey/index.ts"),
				a = s("./src/lib/objectSelector/index.ts"),
				i = s("./src/reddit/helpers/name/index.ts"),
				o = s("./src/reddit/models/DiscoveryUnit/index.ts"),
				c = s("./src/reddit/selectors/category.ts"),
				d = (s("./src/reddit/selectors/listings.ts"), s("./src/reddit/selectors/posts.ts"));
			s("./src/reddit/selectors/subreddit.ts");
			const u = [],
				l = e => e.discoveryUnits.api.list.loaded,
				b = e => e.discoveryUnits.api.list.pending,
				p = (e, t) => {
					let {
						unitName: s
					} = t;
					const n = e.discoveryUnits.nameToId[Object(i.f)(s)];
					return e.discoveryUnits.models[n]
				},
				O = (e, t) => {
					let {
						listingKey: s
					} = t;
					const n = Object(d.Q)(e);
					return Object(d.H)(e, {
						listingKey: s
					}).filter(e => {
						const t = n[e];
						return t && !t.isStickied && !t.isSponsored
					})
				},
				g = () => Object(a.a)((e, t) => {
					let s, {
						categoryName: a,
						id: i,
						unitName: o
					} = t;
					if (a && !(s = Object(c.f)(e, {
							categoryName: a
						}))) return u;
					const d = i || s && s.id,
						l = Object(r.a)(o, n.O.HOT, {
							category: d
						});
					return O(e, {
						listingKey: l
					})
				}),
				f = e => p(e, {
					unitName: o.c
				}),
				m = new Set(["sequence"]),
				j = e => {
					const t = e.platform.currentPage;
					if (t) {
						const {
							meta: e,
							urlParams: s
						} = t, n = e && e.name || "", r = s && s.subredditName || "", a = "subreddit" === n, i = m.has(r.toLowerCase());
						return a && i
					}
					return !1
				}
		},
		"./src/reddit/selectors/downToChat.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = (e, t) => e.chat.downToChat.subreddits[t] && e.chat.downToChat.subreddits[t].bannerEnabled,
				r = (e, t) => e.chat.downToChat.subreddits[t] && e.chat.downToChat.subreddits[t].buttonEnabled,
				a = (e, t) => !!e.chat.downToChat.subreddits[t]
		},
		"./src/reddit/selectors/emailCollection.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/helpers/localStorage/index.ts"),
				a = s("./src/reddit/selectors/user.ts");
			const i = Object(n.a)(a.H, a.l, a.x, (e, t, s) => e && !t && !s),
				o = e => (() => 0 === Object(r.j)())() && i(e)
		},
		"./src/reddit/selectors/emojis.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return u
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "f", (function() {
				return f
			})), s.d(t, "a", (function() {
				return m
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/values.js"),
				r = s.n(n),
				a = s("./node_modules/reselect/es/index.js"),
				i = s("./src/reddit/models/Flair/index.ts"),
				o = s("./src/reddit/selectors/moderatorPermissions.ts"),
				c = s("./src/reddit/selectors/subreddit.ts");
			const d = [],
				u = e => e.emojis.models,
				l = Object(a.a)(u, (e, t) => t.subredditId, (e, t) => {
					const s = e[t];
					return s ? [...r()(s.emojis), ...r()(s.snoomojis)] : d
				}),
				b = Object(a.a)(l, o.g, (e, t) => t.isFlairModOnly, (e, t) => t.flairTemplateType, (e, t, s, n) => e.filter(e => !(e.modFlairOnly && !t || e.modFlairOnly && !s) && (!(!e.userFlairAllowed && n === i.d.UserFlair) && !(!e.postFlairAllowed && n === i.d.LinkFlair)))),
				p = Object(a.a)(u, (e, t) => t.subredditId, (e, t) => Object.keys(e[t].snoomojis)),
				O = (e, t) => Object(c.y)(e, {
					subredditName: t
				}).emojisEnabled,
				g = {
					emojis: {},
					snoomojis: {}
				},
				f = (e, t) => {
					let {
						subredditId: s
					} = t;
					return u(e)[s] || g
				},
				m = (e, t) => !!e.emojis.api.list.pending[t]
		},
		"./src/reddit/selectors/experiments/avatarsInComments.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts"),
				i = s("./src/reddit/selectors/user.ts");
			const o = Object(n.a)(i.H, i.G, (e, t) => e || t),
				c = Object(n.a)(e => Object(a.c)(e, {
					experimentEligibilitySelector: o,
					experimentName: r.f
				}), e => e === r.h.Active),
				d = Object(n.a)(i.H, i.G, (e, t) => !e && !t),
				u = Object(n.a)(e => Object(a.c)(e, {
					experimentEligibilitySelector: d,
					experimentName: r.g
				}), e => e === r.h.Active),
				l = Object(n.a)(c, u, (e, t) => e || t)
		},
		"./src/reddit/selectors/experiments/econ/groupAwarding.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				r = s("./src/reddit/helpers/chooseVariant/index.ts");
			const a = (e => t => {
				const s = Object(r.c)(t, {
					experimentEligibilitySelector: r.a,
					experimentName: e
				});
				return !(!s || Object(n.zc)(s))
			})(n.Y)
		},
		"./src/reddit/selectors/experiments/econAwardKarma.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				r = s("./src/reddit/helpers/chooseVariant/index.ts"),
				a = s("./src/reddit/selectors/user.ts");
			const i = e => {
				const t = Object(r.c)(e, {
					experimentEligibilitySelector: a.H,
					experimentName: n.W
				});
				return !(!t || Object(n.zc)(t))
			}
		},
		"./src/reddit/selectors/experiments/frontpageSignup.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			})), s.d(t, "f", (function() {
				return b
			})), s.d(t, "e", (function() {
				return p
			})), s.d(t, "d", (function() {
				return O
			})), s.d(t, "c", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/contexts/PageLayer/index.tsx"),
				i = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/selectors/experiments/utils.ts"),
				c = s("./src/reddit/selectors/meta.ts"),
				d = s("./src/reddit/selectors/user.ts");
			const u = Object(n.a)(d.O, (e, t) => {
					let {
						pageLayer: s
					} = t;
					return !s || Object(a.y)(s)
				}, c.c, (e, t, s) => !e && t && !s),
				l = Object(n.a)((e, t) => Object(i.c)(e, {
					experimentEligibilitySelector: e => u(e, t),
					experimentName: r.N,
					throttledVariants: {
						[r.gb.CurrentThrottled]: r.N
					}
				}), o.a),
				b = e => e === r.gb.CurrentThrottled,
				p = e => e === r.gb.CurrentThrottled || e === r.gb.CurrentUnthrottled || e === r.gb.CurrentUnthrottledCopy || e === r.gb.NewPopUnthrottledCopy,
				O = e => e === r.gb.NewPopUnthrottledCopy,
				g = e => e === r.gb.NewPageUnthrottledCopy || e === r.gb.NewPageUnthrottledCopyFields,
				f = e => e === r.gb.NewPageUnthrottledCopyFields
		},
		"./src/reddit/selectors/experiments/goldSubredditPowerups.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				r = s("./src/reddit/helpers/chooseVariant/index.ts");
			const a = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: n.ib
				}) === n.mb.Enabled
			}
		},
		"./src/reddit/selectors/experiments/googleOneTap.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "a", (function() {
				return O
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts"),
				i = s("./src/reddit/selectors/meta.ts"),
				o = s("./src/reddit/selectors/user.ts");
			const c = Object(n.a)(i.c, e => !e),
				d = Object(n.a)(e => Object(a.c)(e, {
					experimentEligibilitySelector: e => c(e),
					experimentName: r.F,
					expEventOverride: !1
				}), e => e),
				u = e => e === r.y.Onetap,
				l = e => e === r.y.OnetapAuto,
				b = e => e.user.googleOneTapEnabled,
				p = Object(n.a)(o.H, d, (e, t) => !e && !!t),
				O = Object(n.a)(o.H, d, (e, t) => !e && !!t && !Object(r.zc)(t))
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				r = s("./src/reddit/helpers/chooseVariant/index.ts");
			const a = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: n.H
				}) === n.L.Enabled,
				i = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: n.G
				}) === n.K.Enabled
		},
		"./src/reddit/selectors/experiments/listingBelow.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return b
			})), s.d(t, "a", (function() {
				return p
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/lib/timeAgo/index.ts"),
				a = s("./src/reddit/constants/experiments.ts"),
				i = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				c = s("./src/reddit/selectors/meta.ts"),
				d = s("./src/reddit/selectors/platform.ts"),
				u = s("./src/reddit/selectors/user.ts");
			const l = Object(n.a)(c.c, u.G, u.H, d.g, d.f, o.a, (e, t, s, n, a, i) => !e && !t && !s && n && !!a && !a.isNSFW && !!i && Object(r.c)(i.created / 1e3) < 30),
				b = e => Object(i.c)(e, {
					experimentEligibilitySelector: l,
					experimentName: a.jb,
					expEventOverride: !1
				}),
				p = e => e === a.nb.SearchPostToPost || e === a.nb.NlpPostToPost1 || e === a.nb.NlpPostToPost2 || e === a.nb.NlpPostToPost3
		},
		"./src/reddit/selectors/experiments/postSeo.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return g
			})), s.d(t, "d", (function() {
				return m
			})), s.d(t, "h", (function() {
				return j
			})), s.d(t, "f", (function() {
				return _
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "c", (function() {
				return y
			})), s.d(t, "e", (function() {
				return E
			})), s.d(t, "a", (function() {
				return I
			})), s.d(t, "b", (function() {
				return v
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts"),
				i = s("./src/reddit/helpers/name/index.ts"),
				o = s("./src/reddit/models/Media/index.ts"),
				c = s("./src/reddit/models/RichTextJson/index.ts"),
				d = s("./src/reddit/selectors/meta.ts"),
				u = s("./src/reddit/selectors/posts.ts"),
				l = s("./src/reddit/selectors/user.ts"),
				b = s("./src/reddit/selectors/platform.ts"),
				p = s("./src/reddit/selectors/seo/index.ts");
			const O = Object(n.a)(d.n, e => {
					return "reddit.com" !== e.split(".").splice(1).join(".")
				}),
				g = (e, t) => {
					let {
						post: s
					} = t;
					const n = Object(u.ab)(e, s);
					return n && n.displayText || s && s.author && Object(i.c)(s.author)
				},
				f = (e, t, s) => Object(b.g)(e) && !Object(b.i)(e) && !!t && !!t.title && t.title.length <= 200 && !t.isNSFW && !!t.media && new Date(t.created) > new Date(2020, 5, 20) && new Date(t.created) <= new Date(2020, 7, 29) && (Object(o.G)(t.media) || Object(o.I)(t.media)) && (e => !!e && !!e.media && (Object(o.G)(e.media) || Object(o.I)(e.media) && e.media.richtextContent && e.media.richtextContent.document && e.media.richtextContent.document.some(e => {
					let {
						e: t
					} = e;
					return t === c.m
				})))(t) && (s && !t.media.altText || !s),
				m = Object(n.a)(l.H, O, (e, t) => !e && t),
				j = e => {
					const t = O(e);
					return Object(a.c)(e, {
						experimentName: r.Fb,
						experimentEligibilitySelector: e => !Object(l.H)(e) && t
					})
				},
				_ = e => {
					const t = O(e);
					return Object(a.c)(e, {
						experimentName: r.Cb,
						experimentEligibilitySelector: () => t
					})
				},
				h = e => {
					const t = O(e);
					return Object(a.c)(e, {
						experimentName: r.Eb,
						experimentEligibilitySelector: () => t
					})
				},
				y = e => e === r.Lb.IdCard,
				E = e => e === r.Lb.RailSwap,
				I = (e, t) => {
					const s = Object(u.N)(e, {
						postId: t
					});
					return s && s.media && (Object(o.G)(s.media) || Object(o.I)(s.media)) ? s.media.altText : null
				},
				v = (e, t, s) => Object(a.b)(e, {
					experimentEligibilitySelector: e => s ? ((e, t) => {
						const s = !!t && !!t.media && (Object(o.G)(t.media) || Object(o.I)(t.media)) && t.media.altText;
						return f(e, t, !1) && !!s && s.length <= 250 && t.title.toLowerCase() !== s.toLowerCase()
					})(e, t) : f(e, t, !0),
					experimentName: r.pb,
					expEventOverride: !!s && !!Object(p.a)(e)
				})
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return i
			})), s.d(t, "h", (function() {
				return o
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			})), s.d(t, "e", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "b", (function() {
				return p
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts");
			const i = e => r.Yb.RulesAndWarnings === Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.Rb
				}),
				o = e => r.Yb.WarningsOnly === Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.Rb
				}),
				c = e => r.Nb.Enabled === Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.Gb
				}),
				d = e => r.hc.Enabled === Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.cc
				}),
				u = e => r.ic.Enabled === Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.dc
				}),
				l = (e, t, s) => {
					const n = s(e, t);
					return !(!n || !n.meter) && (n.meter.enabled && u(e) && r.xc.Enabled === Object(a.c)(e, {
						experimentEligibilitySelector: a.a,
						experimentName: r.tc
					}))
				},
				b = Object(n.a)(e => Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.Tb
				}), e => e === r.Zb.Enabled),
				p = e => r.Nb.Enabled === Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: r.Sb
				})
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return d
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/contexts/PageLayer/index.tsx"),
				i = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/selectors/user.ts");
			const c = Object(n.a)(o.H, (e, t) => {
					let {
						pageLayer: s
					} = t;
					return Object(a.y)(s)
				}, (e, t) => {
					let {
						pageLayer: s
					} = t;
					return Object(a.K)(s)
				}, (e, t, s) => !e && !t && s),
				d = Object(n.a)((e, t) => Object(i.c)(e, {
					experimentName: r.P,
					experimentEligibilitySelector: e => c(e, t)
				}), e => e),
				u = e => e === r.nc.NoCommunityWidgets,
				l = e => e === r.nc.NoRulesModerators,
				b = e => e === r.nc.RelatedPostsDu
		},
		"./src/reddit/selectors/experiments/utils.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/reddit/constants/experiments.ts");
			const r = e => {
				if (!Object(n.zc)(e)) return e || void 0
			}
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return i
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "c", (function() {
				return u
			}));
			var n = s("./src/reddit/models/ExternalAccount/index.ts"),
				r = s("./src/reddit/models/User/index.ts"),
				a = s("./src/reddit/selectors/user.ts");
			const i = (e, t) => {
					let {
						username: s
					} = t;
					return !!e.externalAccount.api.user.pending[s]
				},
				o = (e, t) => {
					let {
						username: s
					} = t;
					return e.externalAccount.user[s]
				},
				c = e => {
					const t = Object(a.i)(e);
					if (!t) return;
					const s = Object(r.e)(t),
						n = o(e, {
							username: s
						});
					return n ? n.twitter : void 0
				},
				d = e => !!e.externalAccount.api.connect.pending[n.a.Twitter],
				u = (e, t) => {
					let {
						profileName: s
					} = t;
					if (!s) return null;
					const i = o(e, {
						username: s
					});
					if (!i) return null;
					const c = i[n.a.Twitter];
					if (!c) return null;
					const d = Object(a.i)(e);
					if (!(d && Object(r.e)(d).toLowerCase() === s.toLowerCase())) return c;
					const u = Object(a.gb)(e, {
						userName: s
					});
					return u ? u.prefShowTwitter ? c : null : c
				}
		},
		"./src/reddit/selectors/focusedVerticalSuggestion.ts": function(e, t, s) {
			"use strict";
			s.d(t, "i", (function() {
				return o
			})), s.d(t, "h", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "k", (function() {
				return l
			})), s.d(t, "j", (function() {
				return b
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "f", (function() {
				return m
			})), s.d(t, "c", (function() {
				return j
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "d", (function() {
				return h
			}));
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./src/reddit/featureFlags/index.ts"),
				r = s("./src/reddit/selectors/posts.ts"),
				a = s("./src/reddit/selectors/subreddit.ts"),
				i = s("./src/reddit/selectors/user.ts");
			const o = (e, t) => {
					const s = e.focusedVerticals.interactedSubredditIds && e.focusedVerticals.interactedSubredditIds[t];
					if (s) {
						const t = Object(a.S)(e, {
							subredditId: s
						});
						return t && t.displayText || ""
					}
					return ""
				},
				c = (e, t) => e.focusedVerticals.interactedSubredditIds && e.focusedVerticals.interactedSubredditIds[t] || "",
				d = e => e.focusedVerticals.components.dismissed,
				u = [],
				l = (e, t) => {
					const s = b(e, t);
					if (!s) return u;
					const n = Object(a.W)(e, {
						subredditName: s.name
					});
					return n && n.postIds && n.postIds.length ? n.postIds : u
				},
				b = (e, t) => {
					const s = e.focusedVerticals.recommendedSubredditIds && e.focusedVerticals.recommendedSubredditIds[t];
					return s ? Object(a.S)(e, {
						subredditId: s
					}) : null
				},
				p = (e, t, s, n, a) => {
					const i = a.find(e => e <= t) || -1,
						o = a.find(e => e > t) || 1 / 0;
					return t !== o && t !== i && (!(i + s > t) && (!(t + s > o) && !((e, t, s) => {
						const n = s[t - 1],
							a = s[t],
							i = a && Object(r.N)(e, {
								postId: n
							}) || null,
							o = a && Object(r.N)(e, {
								postId: a
							}) || null;
						return i && i.isSponsored || o && o.isSponsored
					})(e, t, n)))
				},
				O = [3],
				g = (e, t, s) => {
					let {
						listingKey: n
					} = s;
					const a = t.slice().sort();
					let i = -1;
					const o = Object(r.H)(e, {
							listingKey: n
						}),
						c = [];
					return O.forEach(t => {
						let s = i + t;
						if (!(s >= o.length)) {
							for (; s < o.length && !p(e, s, t, o, a);) s += 1;
							s < o.length && (c.push(s), i = s)
						}
					}), c
				},
				f = e => {
					return e.focusedVerticals.api.pending.focusedVerticalGqlPending
				},
				m = e => {
					return e.focusedVerticals.api.error.focusedVerticalGqlError
				},
				j = e => e.focusedVerticals.category,
				_ = e => e.focusedVerticals.lastLoadedEnv,
				h = e => {
					const t = Object(i.G)(e),
						s = n.d.geoSubredditRecommendationDULoggedIn(e),
						r = n.d.geoSubredditRecommendationDULoggedOut(e);
					return t && s || !t && r
				}
		},
		"./src/reddit/selectors/gild.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "g", (function() {
				return a
			})), s.d(t, "h", (function() {
				return i
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "f", (function() {
				return u
			}));
			const n = e => e.gild.gildModalThingId,
				r = e => e.gild.correlationId || void 0,
				a = e => e.gild.isAnonymous,
				i = e => e.gild.isIframed,
				o = e => e.gild.message,
				c = e => e.gild.api.pending,
				d = e => e.gild.api.error,
				u = e => e.gild && e.gild.giveAwardTooltipThingId
		},
		"./src/reddit/selectors/gold/awardIcon.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/reddit/models/Gold/Award.ts"),
				r = s("./src/reddit/selectors/comments.ts"),
				a = s("./src/reddit/selectors/experiments/econ/groupAwarding.ts"),
				i = s("./src/reddit/selectors/gold/giveAwards.ts"),
				o = s("./src/reddit/selectors/posts.ts"),
				c = s("./src/reddit/selectors/user.ts"),
				d = s("./src/reddit/selectors/userPrefs.ts");
			const u = [32, 48, 64, 128],
				l = (e, t, s) => {
					const n = t ? e["staticIcon".concat(s)] : e["icon".concat(s)];
					return (null == n ? void 0 : n.url) ? n.url : t ? e.staticIcon.url : e.icon.url
				},
				b = (e, t) => (null == t ? void 0 : t.awardCountsById) && (null == t ? void 0 : t.awardCountsById[e.id]) && e.awardSubType === n.d.Group && e.tiers && e.tiers.length > 1 && t.awardCountsById[e.id] >= e.tiers[1].awardingsRequired,
				p = e => {
					let {
						award: t,
						size: s,
						prefersReducedMotion: r,
						tierGroupAwardsEnabled: a,
						postOrComment: i
					} = e;
					return t.awardSubType === n.d.Group && a ? (e => {
						let {
							award: t,
							size: s,
							prefersReducedMotion: n,
							postOrComment: r
						} = e;
						if (!b(t, r)) return l(t, n, s);
						const a = r.awardCountsById[t.id],
							i = t.tiers.reduce((e, t) => a >= t.awardingsRequired ? t : e);
						return l(i, n, s)
					})({
						award: t,
						size: s,
						prefersReducedMotion: r,
						postOrComment: i
					}) : l(t, r, s)
				},
				O = (e, t) => {
					let {
						awards: s,
						minSize: n,
						postOrCommentId: i
					} = t;
					const c = Object(d.c)(e),
						l = u.find(e => e >= n),
						O = i ? Object(o.N)(e, {
							postId: i
						}) || Object(r.n)(e, {
							commentId: i
						}) : void 0,
						g = !(!((null == O ? void 0 : O.awardCountsById) && s.some(e => e && b(e, O))) || !Object(a.a)(e));
					return s.reduce((e, t) => (t && (e[t.id] = p({
						award: t,
						size: l,
						prefersReducedMotion: c,
						tierGroupAwardsEnabled: g,
						postOrComment: O
					})), e), {})
				},
				g = (e, t) => {
					let {
						award: s,
						minSize: n,
						postOrCommentId: r
					} = t;
					return s ? O(e, {
						awards: [s],
						minSize: n,
						postOrCommentId: r
					})[s.id] : void 0
				},
				f = (e, t) => {
					let {
						postOrComment: s,
						minSizes: n
					} = t;
					const r = Object.keys(s.awardCountsById || {}).reduce((t, s) => {
						const n = e.awards.models[s];
						return n && t.push(n), t
					}, []);
					return n.reduce((t, n) => {
						const a = O(e, {
							awards: r,
							minSize: n,
							postOrCommentId: s.id
						});
						return t["icon".concat(n)] = a, t
					}, {})
				},
				m = (e, t) => {
					let {
						minSize: s,
						userName: n
					} = t;
					const r = Object(c.gb)(e, {
						userName: n
					});
					if (r && r.awardedLastMonth && r.awardedLastMonth.topAward) return g(e, {
						award: r.awardedLastMonth.topAward,
						minSize: s
					})
				},
				j = e => {
					const t = Object(i.b)(e),
						s = Object(i.a)(e);
					return g(e, {
						award: t,
						postOrCommentId: s || void 0,
						minSize: 512
					})
				}
		},
		"./src/reddit/selectors/gold/econPurchase.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/lib/initializeClient/installReducer.ts"),
				r = s("./src/reddit/reducers/features/econPurchase/index.ts");
			Object(n.a)({
				features: {
					econPurchase: r.a
				}
			});
			const a = (e, t) => {
				let {
					subredditId: s
				} = t;
				return s && e.features.econPurchase.subredditLockedCoins[s] || 0
			}
		},
		"./src/reddit/selectors/gold/giveAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = e => e.gild.selectedAward,
				r = e => e.gild.gildedThing
		},
		"./src/reddit/selectors/gold/productOffers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/lib/makeProductOfferKey/index.ts"),
				r = s("./src/reddit/models/Gold/ProductOffer.ts");
			const a = e => e.subreddits.api.productOffers.pending,
				i = (e, t) => {
					let {
						subredditId: s,
						type: r
					} = t;
					return e.subreddits.productOffers[Object(n.a)(s, r)]
				},
				o = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = i(e, {
						subredditId: s,
						type: r.a.Powerups
					});
					return n && n[0]
				}
		},
		"./src/reddit/selectors/gold/purchaseCatalog.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "i", (function() {
				return o
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "f", (function() {
				return u
			})), s.d(t, "h", (function() {
				return l
			}));
			const n = e => e.goldPurchase.purchaseCatalog.activeSaleConfig,
				r = e => {
					return e.goldPurchase.purchaseCatalog.coinPackages.storefrontPackageIds.map(t => e.goldPurchase.purchaseCatalog.coinPackages.models[t])
				},
				a = e => {
					return e.goldPurchase.purchaseCatalog.coinPackages.dealPackageIds.map(t => e.goldPurchase.purchaseCatalog.coinPackages.models[t])
				},
				i = (e, t) => {
					return a(e).filter(e => e.mobileId === t)[0]
				},
				o = e => {
					return e.goldPurchase.purchaseCatalog.coinPackages.recommendedPackageIds.map(t => e.goldPurchase.purchaseCatalog.coinPackages.models[t])
				},
				c = e => e.goldPurchase.purchaseCatalog.premiumPackages,
				d = e => e.goldPurchase.purchaseCatalog.api.storefrontPending,
				u = e => e.goldPurchase.purchaseCatalog.api.errorMessage,
				l = e => e.goldPurchase.purchaseCatalog.api.recommendedPending
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, s) {
			"use strict";
			s.d(t, "n", (function() {
				return n
			})), s.d(t, "p", (function() {
				return r
			})), s.d(t, "o", (function() {
				return a
			})), s.d(t, "r", (function() {
				return i
			})), s.d(t, "q", (function() {
				return o
			})), s.d(t, "w", (function() {
				return c
			})), s.d(t, "l", (function() {
				return d
			})), s.d(t, "m", (function() {
				return u
			})), s.d(t, "x", (function() {
				return l
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "t", (function() {
				return O
			})), s.d(t, "u", (function() {
				return g
			})), s.d(t, "s", (function() {
				return f
			})), s.d(t, "v", (function() {
				return m
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "e", (function() {
				return _
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "i", (function() {
				return y
			})), s.d(t, "j", (function() {
				return E
			})), s.d(t, "h", (function() {
				return I
			})), s.d(t, "k", (function() {
				return v
			})), s.d(t, "c", (function() {
				return S
			})), s.d(t, "b", (function() {
				return T
			}));
			const n = e => e.goldPurchase.purchaseModal.activePage,
				r = e => e.goldPurchase.purchaseModal.gildThingId || void 0,
				a = e => e.goldPurchase.purchaseModal.correlationId || void 0,
				i = e => e.goldPurchase.purchaseModal.showModal,
				o = e => e.goldPurchase.purchaseModal.packageId,
				c = e => e.goldPurchase.targetedOffer.packageId,
				d = e => e.goldPurchase.premiumPurchaseModal.activePage,
				u = e => e.goldPurchase.premiumPurchaseModal.showModal,
				l = e => e.goldPurchase.updateCardModal.pending,
				b = e => e.goldPurchase.payment.paymentMethod,
				p = e => e.goldPurchase.payment.cardName,
				O = e => e.goldPurchase.payment.savedCardsPending,
				g = e => e.goldPurchase.payment.savedCards,
				f = e => e.goldPurchase.payment.rememberCard,
				m = e => e.goldPurchase.payment.useSavedCard,
				j = e => e.goldPurchase.payment.cardValidation.cardCvc,
				_ = e => e.goldPurchase.payment.cardValidation.cardExpiry,
				h = e => e.goldPurchase.payment.cardValidation.cardNumber,
				y = e => e.goldPurchase.payment.cardValidation.nameOnCard,
				E = e => e.goldPurchase.payment.cardValidation.postalCode,
				I = e => e.goldPurchase.payment.stripeToken.errorMessage,
				v = e => e.goldPurchase.payment.stripeToken.pending,
				S = e => e.goldPurchase.payment.paypal.passthrough,
				T = e => e.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/header.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = e => e.header.isSubscriptionsDropdownOpen
		},
		"./src/reddit/selectors/imageUploads.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			}));
			var n = s("./src/reddit/models/Image/index.tsx");
			const r = e => e.imageUploads,
				a = (e, t) => {
					let {
						id: s
					} = t;
					return r(e)[s]
				},
				i = (e, t) => {
					const s = r(e),
						a = [];
					for (const r in s) {
						const e = s[r];
						e.kind === n.b.TempUploaded && e.context === t && a.push(e)
					}
					return a
				}
		},
		"./src/reddit/selectors/inFeedChaining.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return p
			})), s.d(t, "c", (function() {
				return O
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "f", (function() {
				return j
			})), s.d(t, "b", (function() {
				return _
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeListingKey/index.ts"),
				i = s("./src/reddit/actions/subreddit/similarSubreddit.ts"),
				o = s("./src/reddit/constants/inFeedChaining.ts"),
				c = s("./src/reddit/models/DiscoveryUnit/index.ts"),
				d = s("./src/reddit/selectors/discoveryUnit.ts"),
				u = s("./src/reddit/selectors/posts.ts"),
				l = s("./src/reddit/selectors/subreddit.ts");
			const b = [],
				p = (e, t) => {
					const s = e.posts.chained.idToListingKey[t.postId];
					return t.listingKey === s
				},
				O = (e, t) => {
					const s = e.posts.chained.dismissedIdToListingKey[t.postId];
					return (e => e.posts.chained.dismissed)(e) || t.listingKey === s
				},
				g = Object(n.a)(e => e.posts.chained.idToListingKey, e => Object.keys(e).filter(t => e[t])),
				f = (e, t) => {
					let {
						subredditId: s
					} = t;
					return g(e).some(t => {
						const n = Object(u.ab)(e, {
							postId: t
						});
						return !!n && n.id === s
					})
				},
				m = (e, t) => {
					let {
						subredditName: s
					} = t;
					const n = r.Sb.DAY.toUpperCase(),
						i = Object(a.a)(s, r.O.TOP, {
							t: n
						}),
						o = Object(u.H)(e, {
							listingKey: i
						});
					if (0 !== o.length)
						for (const r of o) {
							const t = Object(u.N)(e, {
								postId: r
							});
							if (t && !t.hidden && !t.isSponsored) return t
						}
				},
				j = (e, t) => {
					let {
						postId: s
					} = t;
					const n = ((e, t) => {
							let {
								postId: s
							} = t;
							const n = Object(u.N)(e, {
								postId: s
							});
							if (!n) return b;
							const r = Object(i.a)({
								subredditIds: [n.belongsTo.id],
								count: o.b
							});
							return Object(l.w)(e, {
								key: r
							})
						})(e, {
							postId: s
						}),
						r = [];
					for (const {
							name: a
						} of n) {
						const t = m(e, {
							subredditName: a
						});
						t && r.push(t.id)
					}
					return r
				},
				_ = (e, t) => {
					let {
						listingName: s
					} = t;
					const n = c.b;
					return Object(d.c)(e, {
						unitName: n
					})
				}
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/reddit/featureFlags/index.ts"),
				r = s("./src/reddit/selectors/moderatorPermissions.ts");
			const a = (e, t) => {
					let {
						subredditId: s
					} = t;
					if (!n.d.subredditInlineEditing(e)) return !1;
					const a = s ? Object(r.j)(e, {
						subredditId: s
					}) : null;
					return !!a && (e => !!e && e.config)(a)
				},
				i = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/interceptedAction.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = e => e.interceptedAction
		},
		"./src/reddit/selectors/modQueue.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "g", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			})), s.d(t, "f", (function() {
				return b
			})), s.d(t, "b", (function() {
				return p
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				a = s("./src/lib/objectSelector/index.ts");
			const i = (e, t) => Object(r.a)({
					onlyOfType: t.queryParams.only,
					profile: t.profileName,
					subreddit: t.subredditName
				}),
				o = Object(a.a)((e, t) => {
					const {
						pageName: s,
						page: n
					} = t, r = i(0, t);
					if (!e.modQueue[s] || !e.modQueue[s].itemOrder[r] || !e.modQueue[s].itemOrder[r][n]) return;
					const a = e.modQueue[s].itemOrder[r][n];
					return a ? a.map(t => e.posts.models[t] || e.comments.models[t]) : []
				}),
				c = (e, t) => {
					const {
						pageName: s
					} = t;
					return !e.modQueue[s] || !e.modQueue[s].api || e.modQueue[s].api.pending
				},
				d = (e, t) => {
					const s = i(0, t);
					return e.modQueue[t.pageName].loadMore[s]
				},
				u = e => Object.keys(e.modQueue.bulkAction.selectedItems),
				l = e => e.modQueue.bulkAction.api.pending,
				b = e => e.modQueue.moderatedCommunitiesOrder.data,
				p = e => {
					const t = e.platform && e.platform.currentPage;
					return t && t.meta && (t.meta.name === n.Bb.MODERATION_PAGES || t.meta.name === n.Bb.MODQUEUE_PAGES)
				}
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return r
			}));
			const n = (e, t) => {
					let {
						commentId: s,
						commentsPageKey: n
					} = t;
					if (!s) return !1;
					if (e.comments.collapsed[n] && s in e.comments.collapsed[n]) return !!e.comments.collapsed[n][s];
					const r = e.comments.models[s];
					return !!r && ("computedCollapsed" in r ? !!r.computedCollapsed : r.collapsedBecauseCrowdControl ? !e.modModeEnabled : r.collapsed)
				},
				r = (e, t) => {
					let {
						commentId: s
					} = t;
					if (!s) return !1;
					const n = e.comments.models[s];
					return !(!n || !n.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/notificationBanner.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = e => t => t.notificationBannerId === e
		},
		"./src/reddit/selectors/oldSiteRules.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = e => e.oldSiteRules
		},
		"./src/reddit/selectors/profileOverviewChronoItems.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return o
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "h", (function() {
				return l
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "a", (function() {
				return p
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "d", (function() {
				return g
			})), s.d(t, "c", (function() {
				return f
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/objectSelector/index.ts"),
				r = s("./src/reddit/models/Flair/index.ts"),
				a = s("./src/reddit/models/PostCreationForm/index.ts");
			r.f.Text, r.f.Spoiler, r.f.Text, r.f.Spoiler, a.h.RICH_TEXT, r.f.Text, r.f.Spoiler, a.h.RICH_TEXT, r.f.Text, r.f.Spoiler, a.h.RICH_TEXT;
			var i = s("./src/reddit/helpers/isComment.ts");
			const o = Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					const n = e.posts.models;
					return c(e, {
						listingKey: s
					}).filter(e => {
						if (Object(i.a)(e)) return !0; {
							const t = n[e];
							return t && !t.hidden
						}
					})
				}),
				c = Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					const n = e.profileOverviewPage.chrono.ids[s];
					return n ? [...n] : []
				}),
				d = Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					return o(e, {
						listingKey: s
					}).reduce((t, s) => {
						const n = Object(i.a)(s) ? e.comments.models[s].postId : s;
						return t[s] = n, t
					}, {})
				}),
				u = (Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					const n = e.posts.models;
					return u(e, {
						listingKey: s
					}).filter(e => {
						const t = n[e];
						return t && !t.hidden
					})
				}), Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					return o(e, {
						listingKey: s
					}).map(t => Object(i.a)(t) ? e.comments.models[t].postId : t)
				})),
				l = Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					const n = e.posts.models,
						r = u(e, {
							listingKey: s
						}),
						a = {};
					return r.forEach(e => a[e] = n[e]), a
				}),
				b = Object(n.a)((e, t) => {
					let {
						listingKey: s
					} = t;
					const n = e.comments.models,
						r = o(e, {
							listingKey: s
						}),
						a = {};
					return r.forEach(e => !!Object(i.a)(e) && (a[e] = n[e])), a
				}),
				p = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.profileOverviewPage.chrono.api.error[s]
				},
				O = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.profileOverviewPage.chrono.api.pending[s]
				},
				g = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.profileOverviewPage.chrono.loadMore[s]
				},
				f = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.profileOverviewPage.chrono.fetchedTokens[s]
				}
		},
		"./src/reddit/selectors/realtimeComments.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				r = s("./src/reddit/featureFlags/index.ts"),
				a = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/reddit/selectors/platform.ts"));
			const i = new Set(["relationship_advice", "sex", "repsneakers", "fashionreps", "tinder", "food", "dating_advice", "skincareaddiction", "sneakers", "justnomil", "childfree", "vegan", "insaneparents", "3dprinting", "woodworking", "homegym", "cooking", "homeimprovement", "raisedbynarcissists", "femaledatingstrategy", "beautyguruchatter", "shittyfoodporn", "loseit", "fitness", "watches", "fundiesnark", "mechanicadvice", "entitledparents", "running", "intermittentfasting", "dating", "parenting", "namenerds", "progresspics", "foodporn", "babybumps", "getmotivated", "crochet", "deadbedrooms", "bjj", "repladies", "keto", "baking", "watchexchange", "curlyhair", "streetwear", "pregnant", "starbucks", "bodybuilding", "malefashionadvice", "breakups", "makeupaddiction", "tattoos", "weddingplanning", "sewing", "reptime", "edc", "piercing", "fashionrepsbst", "diy", "minipainting", "thriftstorehauls", "coffee", "smoking", "beyondthebump", "verifiedfeet", "muslimmarriage", "popping", "fragrance", "kitchenconfidential", "tools", "sneakermarket", "crossstitch", "tryingforababy", "bodyweightfitness", "survivinginfidelity", "theeroticsalon", "diwhy", "flashlight", "knitting", "fasting", "ultralight", "1200isplenty", "homebrewing", "seduction", "camping", "femalefashionadvice", "lego_raffles", "infertility", "askculinary", "polyamory", "malelivingspace", "espresso", "sourdough", "vegetablegardening", "embroidery", "medical", "breakingmom", "vegancirclejerk", "recipes", "breadit", "kibbe", "tacobell", "nattyorjuice", "modelmakers", "eatcheapandhealthy", "xxfitness", "hotpeppers", "bumble", "drunk", "watchuraffle", "weightlossadvice", "indiemakeupandmore", "frugalmalefashion", "forbiddensnacks", "crafts", "hiking", "divorce", "tretinoin", "asianbeauty", "footfetish", "zerowaste", "plasticsurgery", "whiskey", "brogress", "haircarescience", "beautyboxes", "painting", "castiron", "streetwearstartup", "hair", "stepparents", "longdistance", "vegetarian", "nutrition", "beauty", "badmuas", "nootropics", "ttc30", "testosterone", "welding", "showerbeer", "homestead", "muaonthecheap", "kniferaffle", "designerreps", "bourbon", "cocktails", "chefknives", "pizza", "poshmark", "thegirlsurvivalguide", "quittingkratom", "redditlaqueristas", "ipsy", "justnofamily", "tea", "malehairadvice", "beards", "prettyaltgirls", "mercari", "rolex", "traderjoes", "yeezys", "decidingtobebetter", "toddlers", "beer", "makeup", "dhgate", "quilting", "moissanite", "omad", "tfablineporn", "bathandbodyworks", "migraine", "fermentation", "isitbullshit", "breastfeeding", "diabetes", "somethingimade", "wine", "outdoors", "crohnsdisease", "watchescirclejerk", "martialarts", "bbq", "findfashion", "abrathatfits", "accutane", "gainit", "muacjdiscussion", "lushcosmetics", "tattoo", "campinggear", "wetshaving", "ibs", "foreveralonedating", "nails", "chronicpain", "panporn", "raisedbyborderlines", "reduction", "mealprepsunday", "stopsmoking", "wicked_edge", "femalehairadvice", "shitmomgroupssay", "learnart", "engagementrings", "yoga", "cico", "exnocontact", "stretched", "kombucha", "goodyearwelt", "kayaking", "asianparentstories", "healthyfood", "internetparents", "daddit", "crossfit", "gifrecipes", "wewantplates", "acne", "askgirls", "ketorecipes", "justnoso", "bulkorcut", "beautytalkph", "animation", "mead", "orangetheory", "momforaminute", "advancedrunning", "chinatime", "scotch", "powerlifting", "grilling", "cookingforbeginners", "nanny", "family", "opiatesrecovery", "makeupexchange", "kettlebell", "repladiesbst", "bigboobproblems", "love", "adderall", "craftbeer", "mommit", "feetish", "amateur_boxing", "whiskeytribe", "fixit", "celiac", "pelletgrills", "weightlifting", "askparents", "wedding", "breakingdad", "aldi", "narcissisticparents", "veganfitness", "trollingforababy", "starbucksbaristas", "newparents", "steak", "youniqueamua", "ehlersdanlos", "eczema", "hotsauce", "veganrecipes", "howto", "beerporn", "abusiverelationships", "bicycletouring", "snowboarding", "30plusskincare", "fondanthate", "boostedboards", "infertilitybabies", "traeger", "sousvide", "leathercraft", "canberra", "interiordesign", "ivf", "muaythai", "rawdenim", "shoebots", "chipotle", "rowing", "indianskincareaddicts", "dominos", "stupidfood", "blacksmith", "qualityreps", "electronics", "bartenders", "makeuprehab", "stilltrying", "clothdiaps", "plantbaseddiet", "skookum", "plussize", "gettingshredded", "glossier", "supremeclothing", "seiko", "reptimebst", "weddingsunder10k", "swimming", "skincareaddicts", "muacirclejerk", "weightwatchers", "snarkfriends", "workout", "highheels", "veganfoodporn", "gshock", "zerocarb", "spicy", "nonmonogamy", "fitbit", "truechildfree", "womenshealth", "climbharder", "rosacea", "malefashion", "tattoodesigns", "triathlon", "eatsandwiches", "skincareaddictionuk", "trailrunning", "fancyfollicles", "knifemaking", "slowcooking", "wildernessbackpacking", "declutter", "vettech", "jewelry", "tiki", "1500isplenty", "blackhair", "awfuleyebrows", "stockx", "glutenfree", "decaf", "homeschool", "redwingshoes", "subway", "skincare_addiction", "scacirclejerk", "stackadvice", "alcohol", "codependency", "ttcafterloss", "cheese", "malegrooming", "gastricsleeve", "nationalpark", "chefit", "nespresso", "fierceflow", "hydroponics", "longhair", "instantpot", "foodhacks", "ramen", "australianmakeup", "tmj", "toxicparents", "dunksnotdead", "supreme", "scientificnutrition", "handwriting", "carnivore", "weddingdress", "tfabchartstalkers", "adoption", "xxketo4u2", "pregnancyafterloss", "workingmoms", "fitness30plus", "old_recipes", "jeffreestarcosmetics", "womensstreetwear", "techwearclothing", "metalworking", "naturalhair", "fastfood", "seriouseats", "ausskincare", "rum", "caloriecount", "waiting_to_try", "uabat", "miscarriage", "fragranceswap", "flexicas", "random_acts_of_pizza", "sushi", "sneakerscanada", "makeupflatlays", "burgers", "askbaking", "nike", "piercedcock", "gestationaldiabetes", "parentsofmultiples", "makeuplounge", "winemaking", "mclounge", "anorexianervosa", "swatchitforme", "sneakerreps", "tequila", "kennyvsspenny", "makeupaddictioncanada", "indianfood", "tattooedgirls", "iamveryculinary", "flexibility", "52weeksofcooking", "mildlynomil", "sneakerfits", "safe_food", "prisonhooch", "fitnesscirclejerk", "palemua", "fashionadvice", "exvegans", "cookingvideos", "stronglifts5x5", "strength_training", "tallgirls", "dadswhodidnotwantpets", "warts", "ultrarunning", "barber", "strongcurves", "naturalbodybuilding", "february2019bumpers", "biggreenegg", "glasses", "dhgatereps", "keto_food", "overlyspecificedmemes", "frugalfemalefashion", "macarons", "amipregnant", "grilledcheese", "smallbooblove", "palaceclothing", "xxketo", "uglyduckling", "talesfromthepizzaguy", "salsasnobs", "trekbikes", "singleparents", "paralegal", "sharpening", "soylent", "foodscience", "louisvuitton", "nerfmods", "sephora", "adidas", "diet", "moustache", "roasting", "ffacj", "whiskyporn", "hidradenitis", "booty_lovers", "bridezillas", "sebderm", "exercise", "menopause", "eceprofessionals", "custody", "traditionaltattoos", "360waves", "veganuk", "nopoo", "sfr4r", "vintagefashion", "adultchildren", "dessertporn", "budgetfood", "ifseniorclass", "firewater", "drmartens", "legitcheck", "mountaineering", "seikomods", "scacjdiscussion", "whitewater", "nikerunclub", "indieexchange", "reptronics", "footfetishworld", "bodypositive", "deliciouscompliance", "chickfila", "konmari", "diyuk", "bonappetit", "abusiveparents", "wavyhair", "predaddit", "drugstoremua", "ttc_pcos", "supermorbidlyobese", "aerogarden", "drunkencookery", "attachmentparenting", "ketogains", "omegawatches", "skincareexchange", "goruck", "greenhouses", "soda", "dyshidrosis", "gonenatural", "paleo", "diynz", "japanesefood", "sneakerdeals", "weddingphotography", "femalelivingspace", "artisanvideos", "whisky", "ketoaustralia", "ketouk", "covidcookery", "formulafeeders", "estrangedadultchild", "behindtheclosetdoor", "nicuparents", "ketobeginners", "ulta", "myfitnesspal", "tipofmyfork", "koreanbeauty", "artfundamentals", "lesbianfashionadvice", "fitpregnancy", "watchexchangefeedback", "frugalmalefashioncdn", "jumprope", "shave_bazaar", "secondaryinfertility", "cheesemaking", "mexicanfood", "cider", "curlyhairuk", "dadforaminute", "shoes", "christmas", "petitefashionadvice", "singleteenagers", "charcuterie", "ketoscience", "euroskincare", "sugarfreemua", "cowboyboots", "vegande", "happycryingdads", "upcycling", "showerbeergonewild", "moresneakers", "strongman", "fearofgod", "weightgain", "selflove", "water_fasting", "yarnaddicts", "compulsiveskinpicking", "skin", "papajohns", "culinaryplating", "dunkindonuts", "wolfvsgoat", "cautiousbb", "standingdesk", "glitch_art", "austinfood", "whiskago", "repsneakerbst", "personaltraining", "shittygifrecipes", "nootropicsdepot", "bariatricsurgery", "ratemyplate", "babies", "furniturerestoration", "veganism", "choosemyalignment", "hotness", "ladybonersgonemild", "52weeksofbaking", "sexyoutfits", "barista", "makeuporganization", "fosterparents", "blackstonegriddle", "bollywoodfashion", "newborns", "navyblazer", "weighttraining", "crappycontouring", "bravotopchef", "bgccirclejerk", "bromance", "eood", "colourpop", "revengecommunity", "fitmeals", "vegan_food", "theordinaryskincare", "irezumi", "houseplantsuk", "osdd", "edanonymousadults", "bapeheads", "chinesewatches", "bakingnoobs", "cursedfoods", "parents", "breakfastfood", "drpepper", "noses", "march2019bumpers", "emotionalneglect", "japanesestreetwear", "hgtv", "ketodrunk", "smallboobproblems", "toolporn", "askvegans", "veganbeauty", "ethicalfashion", "gyodating", "sushiabomination", "dryfasting", "chinesefood", "benchmade", "dewalt", "njbeer", "makeupfetish", "fragsplits", "divorce_men", "airfryer", "whataburger", "edfood", "fryup", "aimeleondore", "veganbaking", "bluecollarwomen", "snakediet", "flooring", "boostmasterlin", "beardporn", "cake", "putaneggonit", "badparents", "japanesewatches", "vegetarianrecipes", "applewatchfitness", "innout", "mealprep", "jerky", "diybeauty", "skincareflatlays", "myweddingdress", "ifparents", "teespring", "dietandhealth", "repph", "makeupaddicts", "wgtow", "trollmua", "healthy_recipes", "queerception", "fitnessonline", "fashionplus", "monsterenergy", "ifbumpers2019", "todayiwore", "gastricbypass", "hearingaids", "coffeestations", "anycubic", "eloping", "legsgw", "neongenesisevangelion", "twins", "loseweight", "dairyqueen", "mancave", "powerbuilding", "sexybrownwomen", "wings", "couturereps", "cafe", "shoppingaddiction", "puer", "pizzadrivers", "veganchill", "childrenofdeadparents", "bigmenfashionadvice", "fitnessmotivation", "eyebrows", "tshirts", "chocolate", "parkrangers", "maleinfertility", "homeimprovementideas", "legitpiercing", "familyissues", "ifparenting", "kefir", "dcwhisky", "entirebodyexercise", "eustachiantubeclick", "pyrex_love", "breastfeedingsupport", "workouts", "rheumatoidarthritis", "tacos", "customsneakers", "dessert", "pizzahutemployees", "printondemand", "zerowastevegans", "foodievideos", "calmhands", "4hourbodyslowcarb", "eatcheapandvegan", "dyson", "lowcarb", "15minutefood", "swoleacceptance", "justengaged", "vintagesewing", "androgyny", "lactoseintolerant", "stonerfood", "coffeeswap", "wardrobepurge", "glutenfreerecipes", "hotdogs", "repvouch", "wendys", "charcoal", "adamragusea", "veganketo", "friend", "makeuptips", "blacksmithing", "onepotmeals", "bodyacceptance", "unconventionalmakeup", "euphorbiaceae", "whitehousedinners", "lingerieaddiction", "agingparents", "muaconspiracy", "lacqueristas", "monogamy", "randomactsofmakeup", "waiting_to_wed", "preppy", "vegrecipes", "foodscam", "sunflowers", "australianmfa", "badfoodporn", "moderatelygranolamoms", "raisingkids", "offwhitefactory", "vintagefashions", "sandwiches", "sca", "asianbeautyexchange", "rothys", "homefitness", "blendedfamilies", "cosplayers", "vostok", "taylorstitch", "septemberbumpers2017", "milk", "olivemua", "soup", "talesfromthekitchen", "breakfast", "revengexstorm", "vegansnacks", "cleanmakeup", "gucci", "fashion_design", "beginnerfitness", "pinkplants", "rbnchildcare", "narcabuseanddivorce", "perfumes", "fashionwomens35", "desiweddings", "smoothies", "sahp", "justnofil", "agegaprelationship", "vitamix", "baby", "adenium", "best_tattoos", "pandaexpress", "healthyeatingnow", "walstad", "oney", "advancedfitness", "figs", "organicgardening", "fashionporn", "fitnessgirls", "askguys", "kimchi", "dysfunctionalfamily", "veryexpensive", "sausagetalk", "ratemytea", "peeling", "topsecretrecipes", "ketotrees", "biltong", "foodie", "weightlossafterbaby", "makeupeducation", "wewantcups", "thingsmykidsaid", "fatherhood", "todayiate", "ts_withdrawal", "stopdrinkingfitness", "modestdress", "pie", "ketoprogress", "ocdmemes", "posturetipsguide", "fruit", "justnicefits", "cancerfamilysupport", "juicing", "makeupaddictionuk", "cheap_meals", "redhair", "glaucoma", "capsulewardrobe", "mezcal", "mua", "kpopfashion", "getoutofbed", "rawvegan", "foodsafety", "sneakermarketrefs", "glutenfreevegan", "prison", "straightedge", "berries", "buyingforbaby", "wemetonline", "melts", "wallets", "halfevil333", "tanning", "im5andthisismacaroni", "veganfood", "bakeoff", "famnnfp", "uksucculents", "chicagobeer", "dairyfree", "pizzahut", "greeneyed", "childrensbooks", "aj1s", "apartmenthacks", "ketocirclejerk", "braswap", "zpaletteporn", "beautyblogs", "nicotine", "dryagedbeef", "thehighchef", "weddinghashtag", "barbattlestations", "dads", "ketochow", "smokingmeat", "asexualdating", "anorexiarecovery", "budgetcooking", "weddingswap", "coldbrew", "foodhaikus", "restaurant", "shittyfertilityadvice", "kawaii", "cardmaking", "coparenting", "burgerking", "sodastream", "streetwearfits", "wegmans", "shaving", "theketodiet", "jerseymikes", "bpdpartners", "hats", "hot_dog", "veggieshake", "subscriptionboxes", "familiesyouchoose", "food_pantry", "clothingstartups", "avocado", "thehopyard", "topchef", "beerwithaview", "polyfamilies", "adventures", "searchandrescue", "kfc", "cookingcollaboration", "fabrics", "drinking", "trollxweddings", "gingerguys", "lichensclerosus", "planetfitnessmembers", "diplomacy", "wedditnyc", "backpackingdogs", "tegu", "airjordans", "minimal_setups", "koji", "sexeducation", "ketomealseatingnow", "sketchup", "sneakerwatch", "latteart", "cupcakes", "listeningspaces", "hands", "shittingadvice", "canadawhisky", "boba", "cookingtonight", "scandinavianinterior", "dehydrating", "crueltyfree", "makeupartists", "jewelrylove", "lookoftheday", "vegetarianketo", "fiveguys", "handbalancing", "distilling", "sustainablefashion", "repwatch", "bape", "asianeats", "aussiemakeuptrade", "foxbrain", "craftytrolls", "chefknifeswap", "teepublic", "majesticmanes", "ausproperty", "freeletics", "ectopicsupportgroup", "sfx", "mtbtrailbuilding", "crafting", "carhartt", "femalefashion", "80sfastfood", "plcb", "recipeinspiration", "badmakeup", "vedc", "liftingmusic", "beautyinfluencers", "wafflehouse", "crushadvice", "pho", "babyloss", "beautyaddiction", "ketomealprep", "beardtalk", "engaged", "vegetarianism", "glutenfreecooking", "octopus", "liquor", "streeteats", "icecream", "mushroom_cultivation", "satisficing", "mensfashion", "allenedmonds", "underworldmbti", "lesmills", "egg", "bbexchange", "healthyeating", "nailpolish", "mcdonalds", "cosplaybeauties", "rootedporn", "canyoneering", "cocacola", "byuidaho", "datsmiledoe", "meatlessmealprep", "midwives", "veganforbeginners", "makeup101", "psmf", "cosmeticsurgery", "prohealth", "vegetarianfoodporn", "fashionnews", "foodtrucks", "foodphotography", "crocs", "mre", "mimicrecipes", "vegangifrecipes", "tinyhouse", "handbags", "parentinginbulk", "ketodiet", "dinner", "rawring20s", "pins", "caving", "alternativehealth", "singlemothersbychoice", "adopted", "stepmom", "cutekids", "clocks", "jordans", "foodnyc", "naturalbeauty", "chickennuggets", "mom", "accuratelyrateme", "vancouvercraftbeer", "bb30", "trailguides", "canadabeautyexchange", "apartmentdesign", "ketobabies", "smokefire", "btfc", "fruitarian", "customshoes", "caffeine", "bacon", "singledads", "culinary", "filmfashion", "veganity", "foodblog", "shittywoodworking", "peptalkswithpops", "beercirclejerk", "businessfashion", "snacking", "gymshark", "neworleansbeer", "coffee_shop", "perfumeexchange", "tryingforanother", "ketomeals", "easyrecipes", "vodka", "crystalhealing", "fermentedhotsauce", "makeupselfies", "beautydiagrams", "nordicskincare", "shroom", "handtoolrescue", "weightlossfoods", "malefashionmarket", "teenmfa", "tfhcooking", "xxketoover50", "cajunfood", "amazingfitness", "sciencebasedparenting", "myopia", "asiangirlsbeingsexy", "diyweddings", "keto_diet", "fitmama", "breadmachines", "motivationvideos", "henna", "cutyourownhair", "ibsresearch", "florists", "weddingring", "foggypics", "ayurveda", "fastfoodhorrorstories", "helicopterparents", "coffee_roasters", "veganmealprep", "desiketo", "copornot", "foodwishes", "watchhorology", "filipinofood", "ttchealthy", "redditlaqueristaswap", "luxury", "weddingvideography", "allergy", "gainitmeals", "picturesofchina", "mixology", "tdcs", "brownbeauty", "doener", "bmorebourbonsociety", "marfans", "europeanmalefashion", "hypoglycemia", "muscleconfusion", "jewelers", "streetwearsales", "askdad", "landscapingtips", "gaybrosfitness", "hooters", "modulars", "mealplanyourmacros", "repfashion", "ketodessert", "bedding", "socks", "runninglifestyle", "frozendinners", "orthopaedics", "potato", "daddycringe", "accessibility", "veganzerowaste", "xxy", "menswear", "deltaco", "novemberbumpers2017", "haircare", "wholesometeenboys", "stressfreeseason", "askacobbler", "redbull", "worldwhisky", "brownreclusebites", "veganparenting", "trainerroad", "climbingpartners", "ketomealsandrecipes", "fiestaware", "neurofibromatosis", "streetfoodartists", "eggs", "kickwho", "mfacirclejerk", "lymedisease", "deondergrondse", "vegan_travel", "toolsales", "fuckcilantro", "chiropractorzone", "powerwashinggore", "dermatology", "malelifestyle", "projectpan", "neurofeedback", "dysphagia", "grainfather", "wedditgetsfit", "kinobody", "weightlossnews", "ketodietapp", "memantinehcl", "organichealthproducts", "weightlossdiets", "finedining", "fuckingmanly", "antidiet", "condiments", "audiprocdisorder", "popeyes", "exercisepostures", "pez", "onlinefriends", "bys", "wintercycling", "salsa", "outlandishalcoholics", "crossedlegs", "oklahomajoe", "pittsburghbeers", "fastfeeling", "askredditfood", "lioneltrains", "foodnerds", "toolboxmods", "sdam", "irinasabetskaya", "labeer", "yegvegan", "fattylivernafld", "fitlifevideos", "diary", "reebok", "outbreakworld", "modernfashionporn", "davidstea", "ketoconnect", "stepschallenge", "mustard", "pcosandpregnant", "portugalvegan", "xrays", "beercanada", "houstonbeer", "fastfoodreview", "tacticalmedicine", "kidsmeal", "hangovereffect", "misophoniasupport", "deepfried", "fastbuds_family", "adenomyosis", "dnp", "morganeisenberg", "ufyh", "kidsafevideos", "drycleaning", "sobrietyandrecovery", "raptors40k", "eczemabs", "femininenotfeminist", "prosopagnosia", "marriageisbliss", "costumeporn", "motherinlawsfromhell", "32dollars", "sexyness", "breakingeggs", "rabbitreddit", "spinalfusion", "amaro", "freefood", "pistollake", "9round", "purplecoco", "ect", "fmd", "csectioncentral", "dad", "raocdeletes", "olivesplace", "weightlosstechniques", "lgbtweddings", "avascularnecrosis", "naturalnutrition", "bpdrecovery", "marylandeats", "rainbow_babies", "persuasionexperts", "brandy", "nutritionsupport", "stretchedclassifieds", "sanfranciscosecrets", "cmt", "washingtonstategarden", "penpalsover40", "marriedlife", "snowblowers", "queerfamilies", "inlaws", "fragdecants", "fashion", "cordwaining", "treeparents", "autismuk", "bitters", "chd", "sportsmedicine", "stlouisbeer", "bjj_gear", "alopecia_areata", "rbnspouses", "qdoba", "weird_dreams", "psc", "trying2conceive", "asianscuckingpinkies", "blackladiesfitness", "recipegifs", "tfabgrads", "fantasyimages", "gymmotivation", "olivegarden", "girlfriendproblems", "atozplasticsurgery", "foodsandiego", "sneakersreps", "trulieve", "xxweightroom", "floridagardening", "longislandeats", "ghostkitchens", "bento", "lunch", "texasbeer", "sexdolling", "teethdrumming", "mdbeer", "bi4bi", "retinitispigmentosa", "braintumor", "dankrecoverymeme", "shinyfashion", "cozy", "gestationaldiabetics", "randomactsofpetfood", "asianbeautyrehab", "toyreviews", "thoracicoutlet", "canskincare", "hotguysworkingout", "paleolithicketogenic", "paruresis", "supersoil", "bikinisonshow", "makeupfreebies", "astrorelationships", "agricultureporn", "twackedup", "fried", "crueltyfreemua", "carlsjr", "guacmemes", "youtubebeauty", "powerliftingmemes", "budgetweddings", "skincarerehab", "beautifullyenhanced", "thericegoddess", "pottytraining", "finsubteamwork", "hardees", "diamond", "pregnancyproblems", "casualtfab", "condimentpackets", "teenstyle", "ownit", "carpets", "askfastfoodemployees", "erectiledysfunctioned", "selfcare", "snowshoeing", "thingsmadeofchocolate", "paperflowers", "weddingphotographer", "socialworkerstories", "entitledoldpeople", "hownotto", "weddingsolutions", "fitnessguides", "ketogenicdiet", "womensbodybuilding", "foodhack", "kentuckyfriedchicken", "muaeurope", "coffeeoutside", "grease", "freeforallfashion", "vegkc", "closetswap", "onlineclothing", "rhubarbhomies", "grooms", "frugalbeauty", "upliftingvegan", "mito", "lodestone_testing"]);
			var o = s("./src/reddit/helpers/chooseVariant/index.ts"),
				c = s("./src/reddit/selectors/user.ts");
			const d = e => (e => {
				return Object(o.c)(e, {
					experimentEligibilitySelector: () => Object(c.G)(e),
					experimentName: n.Pb
				}) === n.Xb.Enabled
			})(e) && (e => {
				const t = Object(a.e)(e);
				return !!t && i.has(t.toLowerCase())
			})(e) && r.d.realtimeCommentsExperiment(e)
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "h", (function() {
				return i
			})), s.d(t, "g", (function() {
				return o
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "i", (function() {
				return d
			})), s.d(t, "j", (function() {
				return u
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "q", (function() {
				return O
			})), s.d(t, "l", (function() {
				return g
			})), s.d(t, "p", (function() {
				return m
			})), s.d(t, "k", (function() {
				return j
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "r", (function() {
				return h
			})), s.d(t, "m", (function() {
				return y
			})), s.d(t, "n", (function() {
				return E
			})), s.d(t, "d", (function() {
				return I
			})), s.d(t, "e", (function() {
				return v
			})), s.d(t, "o", (function() {
				return S
			})), s.d(t, "b", (function() {
				return T
			}));
			var n = s("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = s("./src/reddit/models/Flair/index.ts"),
				a = s("./src/reddit/models/ScheduledPost/index.ts");
			const i = (e, t) => {
					let {
						subredditId: s
					} = t;
					return ((e, t) => {
						let {
							subredditId: s,
							type: n
						} = t;
						return !!e.posts.scheduledPosts[n].models[s]
					})(e, {
						subredditId: s,
						type: a.f.standalonePosts
					})
				},
				o = (e, t) => {
					let {
						subredditId: s,
						type: n
					} = t;
					return !!e.posts.scheduledPosts[n].pageInfo[s] && e.posts.scheduledPosts[n].pageInfo[s].hasNextPage
				},
				c = (e, t) => {
					let {
						subredditId: s,
						type: n
					} = t;
					return e.posts.scheduledPosts[n].pageInfo[s] ? e.posts.scheduledPosts[n].pageInfo[s].endCursor : null
				},
				d = e => e.posts.scheduledPosts.api.pending,
				u = e => e.posts.scheduledPosts.api.pendingUpdate,
				l = e => e.posts.scheduledPosts.api.error,
				b = {},
				p = [],
				O = (e, t) => {
					let {
						subredditId: s
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[s] || p).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[s] || b)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[s][t])
				},
				g = (e, t) => {
					let {
						subredditId: s
					} = t;
					return (e.posts.scheduledPosts.recurringPosts.postOrder[s] || p).filter(t => !!(e.posts.scheduledPosts.recurringPosts.models[s] || b)[t]).map(t => e.posts.scheduledPosts.recurringPosts.models[s][t])
				},
				f = (e, t) => {
					let {
						subredditId: s,
						scheduledPostId: n,
						type: r
					} = t;
					return (e.posts.scheduledPosts[r].models[s] || b)[n] || void 0
				},
				m = (e, t) => {
					let {
						subredditId: s,
						scheduledPostId: n
					} = t;
					return f(e, {
						subredditId: s,
						scheduledPostId: n,
						type: a.f.standalonePosts
					})
				},
				j = (e, t) => {
					let {
						subredditId: s,
						scheduledPostId: n
					} = t;
					const r = f(e, {
						subredditId: s,
						scheduledPostId: n,
						type: a.f.recurringPosts
					});
					return r || r
				},
				_ = (e, t) => {
					let {
						subredditId: s,
						scheduledPostId: n
					} = t;
					return m(e, {
						subredditId: s,
						scheduledPostId: n
					}) || j(e, {
						subredditId: s,
						scheduledPostId: n
					})
				},
				h = e => e.creations.formData.scheduledPostId,
				y = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: s,
							isSpoiler: a,
							isOriginalContent: i
						} = e;
						const o = [];
						return i && o.push({
							text: "OC",
							type: r.f.Oc
						}), t && o.push(...Object(n.b)(t)), a && o.push({
							text: "spoiler",
							type: r.f.Spoiler
						}), s && o.push({
							text: "nsfw",
							type: r.f.Nsfw
						}), o
					})(t)
				},
				E = e => {
					let {
						scheduledPost: t
					} = e;
					const s = y({
							scheduledPost: t
						}),
						n = s.find(e => e.type === r.f.Richtext);
					return n || (s.find(e => e.type === r.f.Text) || null)
				},
				I = e => e.posts.scheduledPosts[a.f.recurringPosts].editModal.scheduledPostId,
				v = e => e.posts.scheduledPosts[a.f.recurringPosts].editModal.subredditId,
				S = e => e.posts.scheduledPosts.api.pendingUpdate,
				T = e => e.posts.scheduledPosts.api.creationToken
		},
		"./src/reddit/selectors/searchResults.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return r
			})), s.d(t, "e", (function() {
				return a
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "i", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "h", (function() {
				return u
			})), s.d(t, "a", (function() {
				return l
			})), s.d(t, "g", (function() {
				return b
			}));
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			const n = [],
				r = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.listings.listingOrder.api.error[s]
				},
				a = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.listings.listingOrder.api.pending[s]
				},
				i = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.listings.listingOrder.identifiers[s] || []
				},
				o = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.listings.listingOrder.loadMore[s]
				},
				c = e => {
					const t = e.search.searchQuery;
					if (!t) return n;
					const s = e.search.typeahead.idsByQuery[t.toLowerCase()];
					if (!s) return n;
					const r = [];
					return s.forEach(t => {
						r.push(e.search.typeahead.models[t])
					}), r
				},
				d = e => e.search.typeahead.idsByQuery,
				u = e => {
					const t = e.listings.activeKey;
					return e.search.viewTreatment[t]
				},
				l = e => {
					const t = e.listings.activeKey;
					if (t) return e.searchDiscoveryUnits.headerContent[t]
				},
				b = (e, t) => t ? e.search.relatedQueries[t.toLowerCase()] : n
		},
		"./src/reddit/selectors/seo/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return O
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "c", (function() {
				return f
			}));
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/contexts/PageLayer/index.tsx"),
				a = s("./src/reddit/models/Media/index.ts"),
				i = s("./src/reddit/models/Post/index.ts"),
				o = s("./src/reddit/models/RichTextJson/index.ts"),
				c = s("./src/reddit/models/Subreddit/index.ts"),
				d = s("./src/reddit/selectors/experiments/postSeo.ts"),
				u = s("./src/reddit/selectors/platform.ts"),
				l = s("./src/reddit/selectors/posts.ts"),
				b = s("./src/reddit/selectors/subreddit.ts"),
				p = s("./src/reddit/selectors/user.ts");
			const O = e => e.seo.crawler,
				g = Object(n.a)(p.G, b.M, u.i, e => Object(d.d)(e), e => {
					const t = O(e);
					return t && t.name || null
				}, (e, t, s, n, r) => !!r && !e && !s && n && !Object(c.g)(t)),
				f = (e, t) => {
					let {
						pageLayer: s
					} = t;
					if (!s || !Object(r.w)(s) || Object(r.H)(s)) return !1;
					const {
						partialPostId: n
					} = !!s && s.urlParams;
					if (!n) return !1;
					const c = n && Object(i.m)(n),
						d = Object(l.N)(e, {
							postId: c
						});
					return !(!d || !d.media) && (d.media.type === a.o.IMAGE || d.media.type === a.o.RTJSON && d.media.richtextContent && d.media.richtextContent.document && d.media.richtextContent.document.some(e => {
						let {
							e: t
						} = e;
						return t === o.m
					}))
				}
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/selectors/user.ts");
			const a = e => !Object(r.H)(e) && e.seo.linksModule.frontpage || null,
				i = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				o = Object(n.a)(a, e => e ? e.map(e => Object.assign(Object.assign({}, e), {
					links: e.links.map(e => Object.assign(Object.assign({}, e), {
						title: i(e.url)
					})).filter(e => e.title)
				})) : null),
				c = Object(n.a)(o, e => e ? e.map(e => Object.assign(Object.assign({}, e), {
					links: e.links.filter(e => e.visible)
				})) : null),
				d = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = ((e, t) => {
						let {
							subredditId: s
						} = t;
						return e.seo.linksModule.subreddits && e.seo.linksModule.subreddits[s]
					})(e, {
						subredditId: s
					});
					return n && n.subreddits
				}
		},
		"./src/reddit/selectors/tags.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return u
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "k", (function() {
				return b
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "e", (function() {
				return O
			})), s.d(t, "i", (function() {
				return g
			})), s.d(t, "r", (function() {
				return f
			})), s.d(t, "D", (function() {
				return m
			})), s.d(t, "E", (function() {
				return j
			})), s.d(t, "l", (function() {
				return _
			})), s.d(t, "m", (function() {
				return h
			})), s.d(t, "o", (function() {
				return E
			})), s.d(t, "v", (function() {
				return I
			})), s.d(t, "w", (function() {
				return v
			})), s.d(t, "t", (function() {
				return C
			})), s.d(t, "b", (function() {
				return A
			})), s.d(t, "d", (function() {
				return P
			})), s.d(t, "c", (function() {
				return R
			})), s.d(t, "s", (function() {
				return k
			})), s.d(t, "n", (function() {
				return x
			})), s.d(t, "C", (function() {
				return N
			})), s.d(t, "B", (function() {
				return L
			})), s.d(t, "x", (function() {
				return U
			})), s.d(t, "a", (function() {
				return M
			})), s.d(t, "u", (function() {
				return F
			})), s.d(t, "F", (function() {
				return G
			})), s.d(t, "z", (function() {
				return B
			})), s.d(t, "A", (function() {
				return V
			})), s.d(t, "j", (function() {
				return H
			})), s.d(t, "y", (function() {
				return K
			})), s.d(t, "G", (function() {
				return W
			})), s.d(t, "p", (function() {
				return Y
			})), s.d(t, "q", (function() {
				return z
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/some.js"),
				r = s.n(n),
				a = s("./node_modules/lodash/values.js"),
				i = s.n(a),
				o = s("./src/lib/objectSelector/index.ts"),
				c = s("./src/reddit/helpers/tags/index.ts"),
				d = s("./src/reddit/models/Tags/index.ts");
			const u = e => {
					const t = K(e),
						s = t && t.id;
					return i()((e => {
						const t = l(e) ? D(e) : C(e),
							s = b(e),
							n = t.reduce((e, t) => (e[t.id] = Object(d.f)(t), e), {});
						return s.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), n)
					})(e)).filter(e => !e.selected && e.id !== s)
				},
				l = e => e.tags.creation.tagInput || "",
				b = e => e.tags.creation.selectedOptions || [],
				p = e => {
					const t = [];
					for (let s = 0; s < b(e).length; s++) b(e)[s].id && t.push(b(e)[s].id);
					return t || []
				},
				O = e => (b(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				g = e => {
					const t = [];
					for (let s = 0; s < b(e).length; s++) b(e)[s].id || t.push(b(e)[s].displayText);
					return t || []
				},
				f = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				m = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				j = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				_ = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.selected.inputByItemId[s] || ""
				},
				h = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.selected.suggestedInputByItemId[s] || ""
				},
				y = [],
				E = (e, t) => {
					let {
						subredditId: s
					} = t;
					return r()(I(e, {
						subredditId: s
					}), e => !!e.action) || r()(S(e, {
						subredditId: s
					}), e => !!e.action)
				},
				I = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.selected.selectedOptions[s] || y
				},
				v = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.selected.selectedSuggestedOptions[s] || y
				},
				S = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.selected.deselectedOptions[s] || y
				},
				T = {},
				w = {},
				C = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				A = e => e.tags.models.globalSubredditTags,
				D = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				P = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.models.subredditScopedTags[s] || w
				},
				R = (e, t) => {
					const s = i()(t);
					for (let n = 0; n < s.length; n++)
						if (s[n].text.toLowerCase().trim() === e.toLowerCase().trim()) return s[n];
					return null
				},
				k = (e, t) => {
					let {
						itemId: s
					} = t;
					return e.tags.models.itemTags[s] || T
				},
				x = (e, t) => {
					let {
						itemId: s
					} = t;
					return !!e.tags.models.itemTags[s]
				},
				N = (e, t) => {
					let {
						itemId: s
					} = t;
					return e.tags.models.suggestedItemTags[s] || T
				},
				L = (e, t) => {
					let {
						itemId: s
					} = t;
					return i()(N(e, {
						itemId: s
					})).filter(e => e.isRelevant).map(e => Object(d.e)(e, !0))
				},
				U = (e, t) => {
					let {
						itemId: s
					} = t;
					return e.tags.models.sortedItemTags[s] || []
				},
				M = Object(o.a)((e, t) => {
					let {
						thingId: s,
						suggested: n = !1
					} = t;
					const r = B(e, {
						subredditId: s
					});
					return i()(((e, t) => {
						let {
							thingId: s,
							suggested: n = !1
						} = t;
						const r = (n ? h(e, {
								subredditId: s
							}) : _(e, {
								subredditId: s
							})) ? D(e) : C(e),
							a = n ? v(e, {
								subredditId: s
							}) : I(e, {
								subredditId: s
							}),
							i = r.reduce((e, t) => (e[t.id] = Object(d.f)(t), e), {});
						return a.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), i)
					})(e, {
						thingId: s,
						suggested: n
					})).filter(e => !e.selected && e.id !== r)
				}),
				F = (e, t) => {
					let {
						subredditId: s
					} = t;
					return I(e, {
						subredditId: s
					}).concat(S(e, {
						subredditId: s
					}))
				},
				G = (e, t) => {
					let {
						subredditId: s
					} = t;
					return I(e, {
						subredditId: s
					}).filter(c.b).map(e => ({
						text: e.displayText,
						type: d.c.CLASSIFICATION
					}))
				},
				B = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.tags.models.subredditPrimaryTagId[s] || null
				},
				q = (e, t) => t && e.tags.models.globalSubredditTags[t] || null,
				V = (e, t) => {
					const s = B(e, t);
					return q(e, s)
				},
				H = e => e.tags.creation.selectedPrimaryTagId || null,
				K = e => {
					const t = H(e);
					return q(e, t)
				},
				W = e => e.tags.api.updatePrimaryTag.pending,
				Y = (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object.keys(k(e, {
						itemId: s
					})).length > 0
				},
				z = e => b(e).length > 0
		},
		"./src/reddit/selectors/userDataRequest.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = e => e.userDataRequestPage.userDataRequestPageApi.userDataExportEligibility,
				r = e => e.userDataRequestPage.userDataRequestPageApi
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return i
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "d", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "b", (function() {
				return u
			}));
			var n = s("./src/lib/objectSelector/index.ts"),
				r = s("./src/reddit/models/Flair/index.ts"),
				a = s("./src/reddit/selectors/moderatorPermissions.ts");
			const i = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.userFlair[s]
				},
				o = (e, t) => {
					let {
						subredditId: s
					} = t;
					return !e.userFlair[s] || e.userFlair[s].displaySettings.isEnabled
				},
				c = (e, t) => {
					let {
						subredditId: s
					} = t;
					return e.userFlair[s] ? e.userFlair[s].displaySettings.position : r.b.Right
				},
				d = Object(n.a)((e, t) => {
					let {
						subredditId: s
					} = t;
					const n = i(e, {
						subredditId: s
					});
					if (n) return {
						type: r.d.UserFlair,
						displaySettings: n.displaySettings,
						permissions: n.permissions
					}
				}),
				u = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = o(e, {
							subredditId: s
						}),
						r = d(e, {
							subredditId: s
						}),
						c = i(e, {
							subredditId: s
						});
					if (!n || !r || !c) return !1;
					if (c.applied) return !0;
					const u = Object(a.d)(e, {
							subredditId: s
						}),
						{
							canUserChange: l
						} = r.permissions;
					return !!c.templateIds.find(e => {
						return !c.templates[e].modOnly || u
					}) && l
				}
		},
		"./src/reddit/selectors/userPrefs.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			}));
			var n = s("./src/lib/constants/index.ts");
			const r = e => !a(e) && !!e.user.prefs.subscriptionsPinned,
				a = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== n.Bb.MODERATION_PAGES),
				i = e => e.user.prefs.reduceAnimationsFromAwards
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			})), s.d(t, "k", (function() {
				return l
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "i", (function() {
				return O
			})), s.d(t, "e", (function() {
				return g
			})), s.d(t, "f", (function() {
				return f
			})), s.d(t, "j", (function() {
				return m
			})), s.d(t, "h", (function() {
				return j
			})), s.d(t, "g", (function() {
				return _
			})), s.d(t, "b", (function() {
				return h
			}));
			var n = s("./src/lib/objectSelector/index.ts"),
				r = s("./src/reddit/constants/posts.ts"),
				a = s("./src/reddit/helpers/name/index.ts"),
				i = s("./src/reddit/models/Widgets/index.ts"),
				o = s("./src/reddit/selectors/profile.ts"),
				c = s("./src/reddit/selectors/subreddit.ts");
			const d = [],
				u = e => e.widgets.models,
				l = Object(n.a)((e, t) => Object(i.r)(t) ? e.widgets.models[t.widgetId] : Object(i.l)(t.widgetKind)),
				b = (e, t) => e.widgets.idCardIds[t.subredditId],
				p = (e, t) => {
					let s = t.subredditId;
					if (!s && t.subredditName && (s = Object(c.G)(e, t.subredditName)), s) {
						const t = b(e, {
							subredditId: s
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				O = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				g = (e, t) => e.widgets.menuIds[t.subredditId],
				f = (e, t) => {
					const s = g(e, t);
					return s ? e.widgets.models[s] : null
				},
				m = (e, t) => {
					const s = e.widgets.sidebar[t.subredditId];
					return Array.isArray(s) ? s.reduce((t, s) => {
						const n = e.widgets.models[s];
						return n && t.push(n.kind), t
					}, []) : d
				},
				j = (e, t) => {
					const s = O(e, t);
					for (const n of s) {
						const t = e.widgets.models[n];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				_ = (e, t) => {
					const s = O(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return s.length ? s : null
				},
				h = Object(n.a)((e, t) => {
					if (t.type === r.a.PROFILE) {
						const s = Object(o.j)(e, {
							profileName: t.name
						});
						return s ? {
							profile: {
								id: s.id,
								name: Object(a.f)(s.name)
							}
						} : {}
					}
					const s = Object(c.B)(e, {
							subredditName: t.name
						}),
						n = Object(c.y)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: n ? n.contentCategory : null,
							id: s.id,
							name: Object(a.f)(s.name)
						}
					}
				})
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/Governance~Reddit.10701c589819b91ef4c1.js.map