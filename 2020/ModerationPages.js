// https://www.redditstatic.com/desktop2x/ModerationPages.dbb12089e5e6df901894.js
// Retrieved at 6/30/2020, 2:40:08 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["ModerationPages", "Poll~ProfileComments~ProfilePrivate~RpanListingUnit~SearchResults~reddit-components-ClassicPost~redd~f8abff80", "CrowdControlModal~ProfileModeration~Settings~SubredditCreation", "reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddit-compo~0e38b796", "AuthorHovercard~Settings~SubredditWiki", "ChatPost~ModQueuePages", "ModQueue~ModQueuePages", "SubredditCreation~SubredditInlineEditing", "reddit-components-ContentGate", "removalReasonActions"], {
		"./node_modules/lodash/_baseFilter.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseEach.js");
			e.exports = function(e, t) {
				var s = [];
				return n(e, (function(e, n, o) {
					t(e, n, o) && s.push(e)
				})), s
			}
		},
		"./node_modules/lodash/_baseRange.js": function(e, t) {
			var s = Math.ceil,
				n = Math.max;
			e.exports = function(e, t, o, a) {
				for (var r = -1, i = n(s((t - e) / (o || 1)), 0), d = Array(i); i--;) d[a ? i : ++r] = e, e += o;
				return d
			}
		},
		"./node_modules/lodash/_createRange.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseRange.js"),
				o = s("./node_modules/lodash/_isIterateeCall.js"),
				a = s("./node_modules/lodash/toFinite.js");
			e.exports = function(e) {
				return function(t, s, r) {
					return r && "number" != typeof r && o(t, s, r) && (s = r = void 0), t = a(t), void 0 === s ? (s = t, t = 0) : s = a(s), r = void 0 === r ? t < s ? 1 : -1 : a(r), n(t, s, r, e)
				}
			}
		},
		"./node_modules/lodash/countBy.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseAssignValue.js"),
				o = s("./node_modules/lodash/_createAggregator.js"),
				a = Object.prototype.hasOwnProperty,
				r = o((function(e, t, s) {
					a.call(e, s) ? ++e[s] : n(e, s, 1)
				}));
			e.exports = r
		},
		"./node_modules/lodash/filter.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_arrayFilter.js"),
				o = s("./node_modules/lodash/_baseFilter.js"),
				a = s("./node_modules/lodash/_baseIteratee.js"),
				r = s("./node_modules/lodash/isArray.js");
			e.exports = function(e, t) {
				return (r(e) ? n : o)(e, a(t, 3))
			}
		},
		"./node_modules/lodash/flatMap.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseFlatten.js"),
				o = s("./node_modules/lodash/map.js");
			e.exports = function(e, t) {
				return n(o(e, t), 1)
			}
		},
		"./node_modules/lodash/includes.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseIndexOf.js"),
				o = s("./node_modules/lodash/isArrayLike.js"),
				a = s("./node_modules/lodash/isString.js"),
				r = s("./node_modules/lodash/toInteger.js"),
				i = s("./node_modules/lodash/values.js"),
				d = Math.max;
			e.exports = function(e, t, s, l) {
				e = o(e) ? e : i(e), s = s && !l ? r(s) : 0;
				var c = e.length;
				return s < 0 && (s = d(c + s, 0)), a(e) ? s <= c && e.indexOf(t, s) > -1 : !!c && n(e, t, s) > -1
			}
		},
		"./node_modules/lodash/range.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_createRange.js")();
			e.exports = n
		},
		"./node_modules/lodash/times.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseTimes.js"),
				o = s("./node_modules/lodash/_castFunction.js"),
				a = s("./node_modules/lodash/toInteger.js"),
				r = 9007199254740991,
				i = 4294967295,
				d = Math.min;
			e.exports = function(e, t) {
				if ((e = a(e)) < 1 || e > r) return [];
				var s = i,
					l = d(e, i);
				t = o(t), e -= i;
				for (var c = n(l, t); ++s < e;) t(s);
				return c
			}
		},
		"./node_modules/lodash/transform.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_arrayEach.js"),
				o = s("./node_modules/lodash/_baseCreate.js"),
				a = s("./node_modules/lodash/_baseForOwn.js"),
				r = s("./node_modules/lodash/_baseIteratee.js"),
				i = s("./node_modules/lodash/_getPrototype.js"),
				d = s("./node_modules/lodash/isArray.js"),
				l = s("./node_modules/lodash/isBuffer.js"),
				c = s("./node_modules/lodash/isFunction.js"),
				m = s("./node_modules/lodash/isObject.js"),
				u = s("./node_modules/lodash/isTypedArray.js");
			e.exports = function(e, t, s) {
				var p = d(e),
					b = p || l(e) || u(e);
				if (t = r(t, 4), null == s) {
					var h = e && e.constructor;
					s = b ? p ? new h : [] : m(e) && c(h) ? o(i(e)) : {}
				}
				return (b ? n : a)(e, (function(e, n, o) {
					return t(s, e, n, o)
				})), s
			}
		},
		"./node_modules/lodash/uniqueId.js": function(e, t, s) {
			var n = s("./node_modules/lodash/toString.js"),
				o = 0;
			e.exports = function(e) {
				var t = ++o;
				return n(e) + t
			}
		},
		"./node_modules/p-debounce/index.js": function(e, t, s) {
			"use strict";
			const n = (e, t, s = {}) => {
				if (!Number.isFinite(t)) throw new TypeError("Expected `wait` to be a finite number");
				let n, o, a = [];
				return function(...r) {
					return new Promise(i => {
						const d = s.leading && !o;
						clearTimeout(o), o = setTimeout(() => {
							o = null;
							const t = s.leading ? n : e.apply(this, r);
							for (i of a) i(t);
							a = []
						}, t), d ? (n = e.apply(this, r), i(n)) : a.push(i)
					})
				}
			};
			e.exports = n, e.exports.default = n
		},
		"./src/graphql/operations/AllModerators.json": function(e) {
			e.exports = JSON.parse('{"id":"e29846f6d98c"}')
		},
		"./src/graphql/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"7e85bf548364"}')
		},
		"./src/graphql/operations/DeleteScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"dea861ad7f0d"}')
		},
		"./src/graphql/operations/EventPostsBySubredditName.json": function(e) {
			e.exports = JSON.parse('{"id":"d9065033c8d1"}')
		},
		"./src/graphql/operations/FetchModerationLogActions.json": function(e) {
			e.exports = JSON.parse('{"id":"f20f90e251f3"}')
		},
		"./src/graphql/operations/FetchSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"d01eaf3cf517"}')
		},
		"./src/graphql/operations/FetchSubredditTrafficStats.json": function(e) {
			e.exports = JSON.parse('{"id":"d2b39ab0293a"}')
		},
		"./src/graphql/operations/GeoPlaceAutocomplete.json": function(e) {
			e.exports = JSON.parse('{"id":"d2920615716e"}')
		},
		"./src/graphql/operations/SetSubredditGeoPlace.json": function(e) {
			e.exports = JSON.parse('{"id":"ece6b91ed02d"}')
		},
		"./src/graphql/operations/SubmitScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"6f9e584d390a"}')
		},
		"./src/graphql/operations/SubredditFlairedRedditorByName.json": function(e) {
			e.exports = JSON.parse('{"id":"68ffe6747ab8"}')
		},
		"./src/graphql/operations/SubredditFlairedRedditors.json": function(e) {
			e.exports = JSON.parse('{"id":"2967fe5e7d03"}')
		},
		"./src/graphql/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"37d0a2fec08a"}')
		},
		"./src/graphql/operations/SubredditWiki.json": function(e) {
			e.exports = JSON.parse('{"id":"5834be60ee7a"}')
		},
		"./src/graphql/operations/SubredditWikiBannedContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"9b728f1ed735"}')
		},
		"./src/graphql/operations/SubredditWikiContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"6ff60c2af7f1"}')
		},
		"./src/graphql/operations/SubredditWikiPageSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"03acb455993d"}')
		},
		"./src/graphql/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"ae6b571b0675"}')
		},
		"./src/graphql/operations/UpdateSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"1f690708b8b1"}')
		},
		"./src/graphql/operations/WikiComparisonDiff.json": function(e) {
			e.exports = JSON.parse('{"id":"37afdc03bbf6"}')
		},
		"./src/graphql/operations/WikiRevisions.json": function(e) {
			e.exports = JSON.parse('{"id":"83e11ebf7cbf"}')
		},
		"./src/higherOrderComponents/withClickTracking.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return u
			})), s.d(t, "a", (function() {
				return p
			})), s.d(t, "b", (function() {
				return b
			})), s.d(t, "d", (function() {
				return h
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/lodash/omit.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./src/reddit/components/TrackingHelper/index.tsx"),
				d = s("./src/reddit/selectors/telemetry.ts");

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var c = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const m = (e, t, s) => (function() {
				let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : () => {};
				return o => {
					const a = h(o.target, o.currentTarget);
					b(o.target, o.currentTarget, p.anchors) ? a && t && e(t(s, a)) : a && t && e(e => {
						const n = t(s, a)(e);
						let o;
						if (n && n.actionInfo) {
							const e = n.actionInfo,
								{
									pageType: t
								} = e;
							o = c(e, ["pageType"])
						}
						return Object.assign({}, n, {
							actionInfo: Object(d.previousPageActionInfo)(e, o)
						})
					}), b(o.target, o.currentTarget, p.anchorsAndButtons) && n(o)
				}
			});

			function u(e) {
				class t extends r.a.Component {
					constructor() {
						super(...arguments), this.cancelClick = !1
					}
					render() {
						const {
							sendEvent: t,
							eventFactory: s,
							clickTrackingId: n
						} = this.props;
						return r.a.createElement(e, l({}, o()(this.props, "sendEvent", "eventFactory", "clickTrackingId"), {
							afterClickTracking: m(t, s, n)
						}))
					}
				}
				return Object(i.c)(t)
			}
			const p = {
					anchorsAndButtons: ["A", "BUTTON"],
					buttons: ["BUTTON"],
					anchors: ["A"]
				},
				b = (e, t, s) => !s.includes(e.tagName) && (e === t || !!e.parentElement && b(e.parentElement, t, s)),
				h = (e, t) => {
					const s = e.dataset.clickId;
					return s || (e === t ? null : !!e.parentElement && h(e.parentElement, t))
				}
		},
		"./src/higherOrderComponents/withImageUploads.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return l
			}));
			var n = s("./node_modules/react-redux/es/index.js"),
				o = s("./node_modules/reselect/es/index.js"),
				a = s("./src/reddit/actions/imageUploads.ts"),
				r = s("./src/reddit/models/Image/index.tsx"),
				i = s("./src/reddit/selectors/imageUploads.ts");
			const d = Object(o.c)({
				_imageUploads: i.b
			});

			function l(e, t) {
				return Object(n.b)(d, e => ({
					uploadImage: s => e(t(s)),
					cancelUpload: t => e(Object(a.h)(t))
				}), (function(e, t, s) {
					return Object.assign({}, s, t, {
						getImageUploadsIfModified: function(t) {
							return function(e, t) {
								const s = [];
								let n = !1;
								for (const o of t)
									if (Object(r.i)(o) || e[o.id])
										if (e[o.id]) {
											const t = e[o.id];
											s.push(t), n = n || t !== o
										} else n = !0;
								else s.push(o);
								return n ? s : null
							}(e._imageUploads, t)
						}
					})
				}))(e)
			}
		},
		"./src/lib/intersectionObserver/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			let n;
			const o = new Map,
				a = new Map;
			"undefined" != typeof window && (s("./node_modules/intersection-observer/intersection-observer.js"), n = new IntersectionObserver(e => {
				e.forEach(e => {
					const t = e.target,
						s = e.intersectionRatio > 0;
					if (s !== !!a.get(t)) {
						a.set(t, s);
						const n = o.get(t);
						if (n) {
							n(e, s && !!a.get(t))
						}
					}
				})
			}, {
				threshold: [.001]
			}));
			const r = (e, t) => {
					try {
						o.set(e, t), n && n.observe(e)
					} catch (s) {
						0
					}
				},
				i = e => {
					try {
						o.delete(e), n && n.unobserve(e)
					} catch (t) {
						0
					}
				}
		},
		"./src/lib/linkMatchers/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return p
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "i", (function() {
				return g
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "b", (function() {
				return E
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "g", (function() {
				return C
			})), s.d(t, "h", (function() {
				return _
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/linkify-it/index.js"),
				o = s.n(n),
				a = s("./node_modules/tlds/index.js"),
				r = s.n(a),
				i = s("./src/lib/linkMatchers/customLinks.ts"),
				d = s("./node_modules/lodash/values.js"),
				l = s.n(d);
			const c = e => l()(i.b).includes(e.substring(1)),
				m = ["//", "ftp:", "http:", "https:", "mailto:"],
				u = e => ((e, t) => (t.forEach(t => e.add(t, null)), e))(e, m),
				p = o()().tlds(r.a).set({
					fuzzyIP: !0
				}),
				b = o()().set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(i.g.mention.prefix, i.g.mention.config),
				h = u(o()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(i.g.subreddit.prefix, i.g.subreddit.config).add(i.g.subredditFull.prefix, i.g.subreddit.config),
				g = u(o()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(i.g.profile.prefix, i.g.profile.config).add(i.g.profileFull.prefix, i.g.profile.config),
				f = o()().tlds(r.a).set({
					fuzzyIP: !0
				}).add(i.g.subreddit.prefix, i.g.subreddit.config).add(i.g.subredditFull.prefix, i.g.subreddit.config).add(i.g.profile.prefix, i.g.profile.config).add(i.g.profileFull.prefix, i.g.profile.config).add(i.g.mention.prefix, i.g.mention.config),
				x = p.normalize;
			p.normalize = e => {
				x.call(p, e), !e.schema && e.url.startsWith("http:") && (e.url = "https:".concat(e.url.slice(5)))
			};
			const E = (e, t) => {
					return (f.match(e) || []).filter(e => {
						const s = c(e.text);
						return !s || s && t
					})
				},
				v = e => {
					return [...g.match(e) || [], ...b.match(e) || []].map(e => !c(e.text) && e.text.replace(i.a, "")).filter(e => e)
				},
				C = (e, t) => {
					const s = e.match(t);
					if (s && 1 === s.length && 0 === s[0].index && s[0].lastIndex === t.length) return s[0]
				},
				_ = e => {
					const t = p.match(e);
					if (t && 1 === t.length && 0 === t[0].index) {
						const s = t[0];
						return s.lastIndex === e.length ? s : ((e, t) => {
							const s = e.substring(t.lastIndex);
							if (/.*\/\/.*\/.*/.test(t.url) && /^(\?|\!)+$/.test(s)) return t.lastIndex += s.length, t.url += s, t
						})(e, s)
					}
				}
		},
		"./src/lib/loginHref/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/history/esm/history.js");
			t.a = (e, t, s) => {
				const a = Object(o.e)(e),
					r = encodeURIComponent("".concat(t).concat(a));
				return "".concat(n.a.accountManagerOrigin).concat(s || "/login", "?dest=").concat(r)
			}
		},
		"./src/lib/stripQueryParams/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./node_modules/node-libs-browser/node_modules/url/url.js"),
				o = s.n(n);
			t.a = e => {
				const t = o.a.parse(e);
				return t.search = void 0, t.query = null, o.a.format(t)
			}
		},
		"./src/reddit/actions/bulkActions/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return a
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/bulkActions/constants.ts");
			const a = Object(n.a)(o.c),
				r = Object(n.a)(o.b),
				i = Object(n.a)(o.a)
		},
		"./src/reddit/actions/eventPosts/index.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "fetchEventPostsPending", (function() {
				return v
			})), s.d(t, "fetchEventPostsSuccess", (function() {
				return C
			})), s.d(t, "fetchEventPostsFailure", (function() {
				return _
			})), s.d(t, "fetchMoreEventPostsSuccess", (function() {
				return k
			})), s.d(t, "eventPostsRequested", (function() {
				return O
			})), s.d(t, "startEventNowSuccess", (function() {
				return y
			})), s.d(t, "startEventNowRequested", (function() {
				return j
			})), s.d(t, "editEventTimeSuccess", (function() {
				return w
			})), s.d(t, "editEventTimeRequested", (function() {
				return S
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/eventPosts/constants.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/graphql/operations/EventPostsBySubredditName.json"),
				l = s("./src/lib/makeGqlRequest/index.ts");
			var c = s("./src/lib/makeApiRequest/index.ts"),
				m = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts");
			var p = (e, t, s, n, a) => Object(c.a)(Object(m.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/api/event_post_time.json"),
				method: o.cb.POST,
				data: {
					id: t,
					event_start: s,
					event_end: n,
					event_tz: a
				}
			});
			var b = (e, t) => Object(c.a)(Object(m.a)(e, [u.a]), {
					endpoint: "".concat(e.apiUrl, "/api/start_event_post.json"),
					method: o.cb.POST,
					data: {
						id: t
					}
				}),
				h = s("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts"),
				g = s("./src/reddit/models/Toast/index.ts"),
				f = s("./src/reddit/selectors/eventPosts.ts"),
				x = s("./src/reddit/selectors/posts.ts");
			const E = () => n.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4onxm1"
				}),
				v = Object(a.a)(r.e),
				C = Object(a.a)(r.c),
				_ = Object(a.a)(r.b),
				k = Object(a.a)(r.d),
				O = e => async (t, s, n) => {
					let {
						gqlContext: o
					} = n, a = s();
					const r = Object(f.d)(a, {
							subredditName: e
						}),
						c = Object(f.b)(a, {
							subredditName: e
						}),
						m = Object(f.c)(a, {
							subredditName: e
						}),
						u = Object(f.a)(a, {
							subredditName: e
						}),
						p = c && m;
					if (r) return;
					const b = {
						name: e,
						pageSize: 25,
						nonInclusiveCursor: null
					};
					if (p) b.nonInclusiveCursor = u;
					else if (c && !m) return;
					const x = Object(f.e)(a, {
						subredditName: e
					});
					t(v({
						key: x
					}));
					const O = await ((e, t) => Object(l.a)(e, Object.assign({}, d, {
						variables: t
					})))(o(), b);
					if (O.ok) {
						const {
							subredditInfoByName: e
						} = O.body.data, {
							eventPosts: n
						} = e, o = Object(h.a)(n);
						let r = [],
							i = {};
						const d = n.pageInfo || {
							hasNextPage: !1,
							endCursor: null,
							hasPreviousPage: !1,
							startCursor: null
						};
						o.length > 0 && (r = o.map(e => e.id), i = o.reduce((e, t) => (e[t.id] = t, e), {})), a = s(), t((p ? k : C)({
							key: x,
							postIds: r,
							meta: a.meta,
							posts: i,
							pageInfo: d
						}))
					} else t(_({
						error: O.error,
						key: x
					})), t(Object(i.e)({
						kind: g.b.Error,
						text: E()
					}))
				}, y = Object(a.a)(r.f), j = e => async (t, s, o) => {
					let {
						apiContext: a
					} = o;
					if ((await b(a(), e)).ok) {
						const o = () => n.fbt._("Following event has started successfully: {title}", [n.fbt._param("title", d)], {
							hk: "e9iz9"
						});
						t(y({
							postId: e
						}));
						const a = s(),
							r = Object(x.O)(a, {
								postId: e
							}),
							d = r && r.title || "";
						t(Object(i.e)({
							kind: g.b.SuccessMod,
							text: o()
						}))
					} else t(Object(i.e)({
						kind: g.b.Error,
						text: E()
					}))
				}, w = Object(a.a)(r.a), S = (e, t) => async (s, a, r) => {
					let {
						apiContext: d
					} = r;
					const l = await p(d(), e, t.startDate, t.endDate, t.timezoneName);
					if (l.ok) {
						const t = l.body,
							r = 14400,
							d = Math.round(t.event_start / o.Eb);
						let c = t.event_end;
						const m = {
							eventStart: d,
							eventEnd: c = c && Math.round(c / o.Eb) || d + r,
							eventIsLive: t.event_is_live
						};
						s(w({
							postId: e,
							eventInfo: m
						}));
						const u = a(),
							p = Object(x.O)(u, {
								postId: e
							}),
							b = p && p.title || "",
							h = () => n.fbt._("Following event time is updated successfully: {title}", [n.fbt._param("title", b)], {
								hk: "1m1w1c"
							});
						s(Object(i.e)({
							kind: g.b.SuccessMod,
							text: h()
						}))
					} else s(Object(i.e)({
						kind: g.b.Error,
						text: E()
					}))
				}
		},
		"./src/reddit/actions/grantUserFlair/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return _
			})), s.d(t, "d", (function() {
				return j
			})), s.d(t, "a", (function() {
				return P
			})), s.d(t, "c", (function() {
				return R
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/graphql/operations/SubredditFlairedRedditorByName.json"),
				r = s("./src/graphql/operations/SubredditFlairedRedditors.json"),
				i = s("./src/lib/makeGqlRequest/index.ts");
			var d = s("./src/reddit/endpoints/flair/index.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/reddit/helpers/flair.ts"),
				m = s("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts");
			var u = e => {
				const {
					subreddit: t,
					redditorInfoByName: s
				} = e.data, {
					id: n,
					flairedRedditorByName: o
				} = t, a = {};
				let r = null;
				if (!s) return {
					subredditId: n,
					searchResult: r,
					flairedUsers: a
				};
				const {
					name: i
				} = s;
				if (r = i, o) {
					const {
						flair: e,
						redditor: t
					} = o, {
						name: s
					} = t;
					e && (a[s] = Object(m.a)(e)[0])
				}
				return {
					subredditId: n,
					searchResult: r,
					flairedUsers: a
				}
			};
			var p = e => {
					const {
						subreddit: t
					} = e.data, {
						id: s,
						flairedRedditors: n
					} = t, {
						pageInfo: o,
						edges: a
					} = n, r = [], i = {};
					return a.forEach(e => {
						const {
							node: t
						} = e, {
							flair: s,
							redditor: {
								name: n
							}
						} = t;
						if (r.push(n), s) {
							const e = Object(m.a)(s)[0];
							i[n] = e
						}
					}), {
						subredditId: s,
						flairedUsers: i,
						userOrder: r,
						pageInfo: o
					}
				},
				b = s("./src/reddit/models/SubredditModeration/index.ts"),
				h = s("./src/reddit/models/Toast/index.ts"),
				g = s("./src/reddit/models/User/index.ts"),
				f = s("./src/reddit/selectors/subreddit.ts"),
				x = s("./src/reddit/actions/grantUserFlair/constants.ts");
			const E = Object(o.a)(x.i),
				v = Object(o.a)(x.g),
				C = Object(o.a)(x.f),
				_ = (e, t) => async (s, o, a) => {
					let {
						gqlContext: d
					} = a;
					const c = t && t.after || "",
						m = t && t.before || "",
						u = Object(f.F)(o(), e),
						g = Object(b.d)(u, c, m);
					if (!!o().flairedUsers.userOrder[g]) return;
					s(E());
					const x = await ((e, t, s) => Object(i.a)(e, Object.assign({}, r, {
						variables: Object.assign({
							subredditName: t
						}, s)
					})))(d(), e, t);
					if (x.ok) {
						const e = p(x.body),
							t = Object.assign({}, e, {
								key: g
							});
						s(v(t))
					} else {
						const e = x.error;
						s(C(e)), s(Object(l.e)({
							kind: h.b.Error,
							text: n.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})
						}))
					}
				}, k = Object(o.a)(x.l), O = Object(o.a)(x.k), y = Object(o.a)(x.j), j = (e, t) => async (s, o, r) => {
					let {
						gqlContext: d
					} = r;
					const c = Object(f.R)(o(), {
						subredditId: e
					}).name;
					s(k());
					const m = await ((e, t, s) => Object(i.a)(e, Object.assign({}, a, {
						variables: {
							subredditName: t,
							name: s
						}
					})))(d(), c, t);
					if (m.ok) {
						const e = u(m.body);
						s(O(e))
					} else s(y(m.error)), s(Object(l.e)({
						kind: h.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})
					}))
				}, w = Object(o.a)(x.e), S = Object(o.a)(x.c), I = Object(o.a)(x.d), P = (e, t) => async (s, o, a) => {
					let {
						apiContext: r
					} = a;
					const i = o(),
						c = Object(f.R)(i, {
							subredditId: t
						}).name;
					s(w());
					const m = await Object(d.a)(r(), e, c);
					if (m.ok) {
						s(S({
							userName: e,
							subredditId: t
						}));
						const o = Object(l.d)(n.fbt._("User flair cleared", null, {
							hk: "4yyH00"
						}), h.b.SuccessMod);
						s(Object(l.e)(o))
					} else {
						s(I());
						const o = Object(l.d)(n.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "uG2KO"
						}), h.b.Error, n.fbt._("Retry", null, {
							hk: "3oiY99"
						}), P(e, t));
						s(Object(l.e)(o))
					}
					return m.ok || m.error
				}, T = Object(o.a)(x.h), N = Object(o.a)(x.b), M = Object(o.a)(x.a), R = (e, t, s) => async (o, a, r) => {
					let {
						apiContext: i
					} = r;
					const m = a(),
						u = m.flairedUsers.search.result === e && !m.flairedUsers.models[e],
						p = {
							userName: e,
							subredditId: t,
							applied: s
						},
						b = s && s.templateId,
						x = Object(f.R)(m, {
							subredditId: t
						}),
						E = s && Object(c.g)(s),
						v = s ? s.cssClass : void 0,
						C = await Object(d.g)(i(), e, x.name, b, E, v);
					if (C.ok) {
						if (u) {
							let e;
							Object.keys(m.flairedUsers.userOrder).forEach(t => {
								!1 === m.flairedUsers.pageInfo[t].hasNextPage && m.flairedUsers.userOrder[t].length < 50 && (e = t)
							});
							const t = Object.assign({}, p, {
								key: e
							});
							o(M(t))
						}
						e === (m.user.account && Object(g.e)(m.user.account)) ? o(T(p)) : u || o(N(p))
					} else {
						const e = Object(l.d)(n.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4hXQvr"
						}), h.b.Error);
						o(Object(l.e)(e))
					}
					return C.ok || C.error
				}
		},
		"./src/reddit/actions/modQueue/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return R
			})), s.d(t, "d", (function() {
				return F
			})), s.d(t, "f", (function() {
				return H
			})), s.d(t, "a", (function() {
				return W
			})), s.d(t, "b", (function() {
				return V
			})), s.d(t, "c", (function() {
				return q
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/bulkActions/index.ts"),
				i = s("./src/reddit/actions/removalReasons/index.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/endpoints/modQueue/index.ts"),
				c = s("./src/reddit/helpers/flair.ts"),
				m = s("./src/reddit/helpers/isPost.ts"),
				u = s("./src/reddit/models/ModQueue/index.ts"),
				p = s("./src/reddit/models/Toast/index.ts"),
				b = s("./src/reddit/selectors/modQueue.ts"),
				h = s("./src/reddit/selectors/subreddit.ts"),
				g = s("./src/reddit/selectors/telemetry.ts"),
				f = s("./src/telemetry/index.ts"),
				x = s("./src/reddit/actions/modQueue/constants.ts");
			const E = Object(a.a)(x.j),
				v = Object(a.a)(x.i),
				C = Object(a.a)(x.h),
				_ = Object(a.a)(x.g),
				k = Object(a.a)(x.f),
				O = Object(a.a)(x.e),
				y = Object(a.a)(x.n),
				j = Object(a.a)(x.m),
				w = Object(a.a)(x.l),
				S = Object(a.a)(x.q),
				I = Object(a.a)(x.p),
				P = Object(a.a)(x.o),
				T = Object(a.a)(x.w),
				N = Object(a.a)(x.v),
				M = Object(a.a)(x.u),
				R = (e, t, s) => async (a, r, i) => {
					let c, m, b, {
						apiContext: h
					} = i;
					switch (t) {
						case o.gb.Edited:
							c = _, m = O, b = k;
							break;
						case o.gb.Modqueue:
							c = E, m = C, b = v;
							break;
						case o.gb.Reports:
							c = y, m = w, b = j;
							break;
						case o.gb.Spam:
							c = S, m = P, b = I;
							break;
						case o.gb.Unmoderated:
							c = T, m = M, b = N;
							break;
						default:
							throw new Error("Invalid modqueue requested")
					}
					a(c());
					const g = await Object(l.b)(h(), t, s);
					if (g.ok) {
						a(b({
							listingKey: e,
							page: "".concat(s.page || u.b),
							response: g.body
						}))
					} else a(m(g.error)), a(Object(d.e)({
						kind: p.b.Error,
						text: n.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}))
				}, L = Object(a.a)(x.k), A = Object(a.a)(x.b), F = e => async (t, s, o) => {
					let {
						apiContext: a
					} = o;
					const r = s(),
						i = r.modQueue.moderatedCommunitiesOrder.after,
						c = r.modQueue.moderatedCommunitiesOrder.pending,
						m = r.modQueue.moderatedCommunitiesOrder.loaded,
						{
							pageName: u
						} = r.platform.currentPage.urlParams,
						b = u;
					if (e && c || m || !i) return;
					const h = await Object(l.b)(a(), b, {
						moderated_after: i
					});
					h.ok ? (t(L(h.body)), h.body.moderatedAfter ? t(F()) : t(A())) : t(Object(d.e)({
						kind: p.b.Error,
						text: n.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}))
				}, D = Object(a.a)(x.t), B = Object(a.a)(x.s), U = Object(a.a)(x.r), H = (e, t, s) => async (o, a, x) => {
					let {
						apiContext: E
					} = x;
					o(Object(r.c)());
					const v = a(),
						C = Object(b.g)(v),
						_ = v.user.account && v.user.account.displayText;
					for (let t = 0; t < C.length; t++) {
						const s = C[t];
						let n = e;
						[u.a.Approve, u.a.Remove, u.a.Spam].includes(e) && (Object(m.a)(s) ? n += "_link" : n += "_comment"), Object(f.a)(Object.assign({
							source: "bulk_mod_action",
							action: "click",
							noun: n
						}, g.defaults(v), {
							actionInfo: g.actionInfo(v, {
								count: C.length,
								paneName: v.platform.currentPage ? v.platform.currentPage.urlParams.pageName : void 0
							}),
							comment: g.comment(v, s),
							post: g.post(v, s),
							profile: g.profileByPostOrCommentId(v, s),
							screen: g.screen(v),
							subreddit: g.subredditByPostOrCommentId(v, s)
						}))
					}
					const k = {
						ids: C
					};
					t && (k.text = Object(c.g)(t) || "", k.flairTemplateId = ""), s && (k.cssClass = s, k.flairTemplateId = s);
					const O = await Object(l.a)(E(), e, k);
					if (O.ok) {
						o(Object(r.b)(Object.assign({}, O.body, {
							operation: e,
							ids: C,
							username: _,
							options: {
								flair: t
							}
						})));
						const s = function(e, t) {
							switch (e) {
								case u.a.Approve:
									return n.fbt._({
										"*": "{number} posts/comments have been approved",
										_1: "1 post/comment has been approved"
									}, [n.fbt._plural(t, "number")], {
										hk: "2kKhSf"
									});
								case u.a.Flair:
									return n.fbt._({
										"*": "{number} posts/comments have had flair applied",
										_1: "1 post/comment has had flair applied"
									}, [n.fbt._plural(t, "number")], {
										hk: "3syB5O"
									});
								case u.a.IgnoreReports:
									return n.fbt._({
										"*": "{number} posts/comments have had their reports ignored",
										_1: "1 post/comment has had their reports ignored"
									}, [n.fbt._plural(t, "number")], {
										hk: "2WfE4g"
									});
								case u.a.Lock:
									return n.fbt._({
										"*": "{number} posts/comments have been locked",
										_1: "1 post/comment has been locked"
									}, [n.fbt._plural(t, "number")], {
										hk: "45oMbv"
									});
								case u.a.MarkNSFW:
									return n.fbt._({
										"*": "{number} posts/comments have been marked NSFW",
										_1: "1 post/comment has been marked NSFW"
									}, [n.fbt._plural(t, "number")], {
										hk: "oPsQr"
									});
								case u.a.RemovalReason:
									return n.fbt._({
										"*": "{number} posts/comments have had removal reasons applied",
										_1: "1 post/comment has had removal reasons applied"
									}, [n.fbt._plural(t, "number")], {
										hk: "35Tosn"
									});
								case u.a.Remove:
									return n.fbt._({
										"*": "{number} posts/comments have been removed",
										_1: "1 post/comment has been removed"
									}, [n.fbt._plural(t, "number")], {
										hk: "B1ZbE"
									});
								case u.a.Spam:
									return n.fbt._({
										"*": "{number} posts/comments have been marked as spam",
										_1: "1 post/comment has been marked as spam"
									}, [n.fbt._plural(t, "number")], {
										hk: "3OoNfp"
									});
								case u.a.Spoiler:
									return n.fbt._({
										"*": "{number} posts/comments have been marked as spoilers",
										_1: "1 post/comment has been marked as spoilers"
									}, [n.fbt._plural(t, "number")], {
										hk: "1DFW5M"
									});
								case u.a.UnignoreReports:
									return n.fbt._({
										"*": "{number} posts/comments have had their reports un-ignored",
										_1: "1 post/comment has had their reports un-ignored"
									}, [n.fbt._plural(t, "number")], {
										hk: "303Hpb"
									});
								case u.a.Unlock:
									return n.fbt._({
										"*": "{number} posts/comments have been unlocked",
										_1: "1 post/comment has been unlocked"
									}, [n.fbt._plural(t, "number")], {
										hk: "5gUht"
									});
								case u.a.UnmarkNSFW:
									return n.fbt._({
										"*": "{number} posts/comments have been un-marked as NSFW",
										_1: "1 post/comment has been un-marked as NSFW"
									}, [n.fbt._plural(t, "number")], {
										hk: "3oSSST"
									});
								case u.a.Unspoiler:
								case u.a.Unspoiler:
									return n.fbt._({
										"*": "{number} posts/comments have been un-marked as spoilers",
										_1: "1 post/comment has been un-marked as spoilers"
									}, [n.fbt._plural(t, "number")], {
										hk: "3lHoNI"
									})
							}
						}(e, C.length);
						if (e !== u.a.Approve && e !== u.a.Flair) {
							let t, a;
							const c = v.platform.currentPage && v.platform.currentPage.queryParams && v.platform.currentPage.queryParams.subreddit,
								m = c && Object(h.F)(v, c);
							e === u.a.Remove && m && C.length > 1 && (t = n.fbt._("Add a removal reason", null, {
								hk: "3gGDCl"
							}), a = Object(i.fetchReasonsAndOpenModal)(m, C));
							const b = Object(d.d)(s, p.b.Undo, n.fbt._("UNDO", null, {
								hk: "49SEAI"
							}), (() => async (e, t, s) => {
								let {
									apiContext: o
								} = s;
								e(D());
								const a = t(),
									i = Object.keys(a.modQueue.bulkAction.undoLastAction)[0],
									c = a.modQueue.bulkAction.undoLastAction[i],
									m = a.user.account && a.user.account.displayText;
								e(Object(r.c)());
								const u = await Object(l.a)(o(), i, {
									ids: c
								});
								u.ok ? e(B(Object.assign({}, u.body, {
									operation: i,
									ids: c,
									username: m
								}))) : (e(U(u.error)), e(Object(d.e)({
									kind: p.b.Error,
									text: n.fbt._("Oh no! Something went wrong!", null, {
										hk: "16O2Sk"
									})
								})))
							})(), t, a);
							o(Object(d.e)(b))
						} else {
							const e = Object(d.d)(s, p.b.SuccessMod);
							o(Object(d.e)(e))
						}
					} else {
						o(Object(r.a)(O.error));
						const e = Object(d.d)(n.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						}), p.b.Error);
						o(Object(d.e)(e))
					}
				}, W = Object(a.a)(x.a), V = Object(a.a)(x.c), q = Object(a.a)(x.d)
		},
		"./src/reddit/actions/pages/moderationPages/index.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "moderationPageRequested", (function() {
				return de
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react-router-redux/es/index.js"),
				o = s("./src/lib/assertNever.ts"),
				a = s("./src/lib/constants/index.ts"),
				r = s("./src/lib/makeListingKey/index.ts"),
				i = s("./src/reddit/actions/scheduledPosts/index.ts"),
				d = s("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				l = s("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				c = s("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				m = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				u = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				p = s("./src/reddit/helpers/trackers/screenview.ts"),
				b = s("./src/reddit/actions/emoji.ts"),
				h = s("./src/reddit/actions/eventPosts/index.ts"),
				g = s("./src/reddit/actions/gold/communityAwards.ts"),
				f = s("./src/reddit/actions/grantUserFlair/index.ts"),
				x = s("./src/lib/makeActionCreator/index.ts"),
				E = s("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				v = s("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				C = s("./src/reddit/models/SubredditModeration/ModerationLog/index.ts"),
				_ = s("./src/reddit/selectors/subreddit.ts"),
				k = s("./src/reddit/actions/moderationLog/constants.ts");
			const O = Object(x.a)(k.b),
				y = (e, t) => async (s, n, o) => {
					let {
						gqlContext: a
					} = o;
					const r = await Object(E.a)(a(), e, t);
					if (r.body) {
						const t = r.body.data.subreddit.moderation;
						if (t && t.actions) {
							const o = n(),
								a = Object(v.b)(t.actions),
								r = Object(_.F)(o, e),
								{
									hasNextPage: i,
									hasPreviousPage: d,
									endCursor: l,
									startCursor: c
								} = t.actions.pageInfo,
								m = Object(C.a)(r, l, c),
								u = [];
							a.forEach(e => {
								u.push(e.id)
							}), s(O({
								hasNextPage: i,
								hasPreviousPage: d,
								endCursor: l,
								key: m,
								startCursor: c,
								normalizedModerationLog: a,
								actionIds: u,
								subredditId: r
							}))
						}
					}
				};
			var j = s("./src/reddit/actions/modQueue/index.ts"),
				w = s("./src/reddit/actions/pages/chatSettings.ts"),
				S = s("./src/reddit/actions/pages/subreddit.ts"),
				I = s("./src/reddit/actions/pages/subredditWiki/index.ts"),
				P = s("./src/reddit/actions/platform.ts"),
				T = s("./src/reddit/actions/postRequirements/index.ts"),
				N = s("./src/reddit/actions/removalReasons/index.ts"),
				M = s("./src/reddit/actions/streaming/modSettings.ts"),
				R = s("./src/reddit/actions/subreddit.ts"),
				L = s("./src/reddit/actions/subredditModeration.ts"),
				A = s("./src/reddit/actions/subredditSettings.ts"),
				F = s("./src/reddit/actions/tags/index.ts"),
				D = s("./node_modules/fbt/lib/FbtPublic.js"),
				B = s("./src/reddit/actions/toaster.ts"),
				U = s("./src/reddit/actions/trafficStats/constants.ts"),
				H = s("./src/graphql/operations/FetchSubredditTrafficStats.json"),
				W = s("./src/lib/makeGqlRequest/index.ts");
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var V = s("./node_modules/lodash/forEach.js"),
				q = s.n(V),
				G = s("./src/reddit/helpers/graphql/helpers.ts"),
				K = s("./src/reddit/models/TrafficStats/index.ts");
			const z = e => ({
					desktop: new Array(e).fill(0),
					oldReddit: new Array(e).fill(0),
					mWeb: new Array(e).fill(0),
					apps: new Array(e).fill(0),
					total: new Array(e).fill(0)
				}),
				Q = (e, t) => {
					return Object(G.d)(e.startsAt) > Object(G.d)(t.startsAt) ? 1 : -1
				},
				J = (e, t, s) => {
					const n = {
							pageViews: z(t),
							uniqueUsers: z(t)
						},
						o = Object(G.d)(e[0].startsAt);
					return e.map(e => {
						const a = Object(G.d)(e.startsAt),
							r = new Date(a),
							i = t === K.c ? r.getMonth() : Math.round((a - o) / s) % t,
							d = K.d[e.client];
						n.pageViews[d][i] += e.pageViews, n.uniqueUsers[d][i] += e.uniqueUsers
					}), n
				};
			var Z = s("./src/reddit/models/Toast/index.ts");
			const X = Object(x.a)(U.b),
				Y = Object(x.a)(U.c),
				$ = Object(x.a)(U.a),
				ee = e => async (t, s, n) => {
					let {
						gqlContext: o
					} = n;
					const r = Object(_.R)(s(), {
						subredditId: e
					}).name;
					t(Y({
						subredditId: e
					}));
					const i = await ((e, t) => Object(W.a)(e, Object.assign({}, H, {
						variables: t
					})))(o(), {
						subredditName: r
					});
					if (i.ok) {
						const s = i.body.data.subreddit.moderation;
						if (s && s.trafficStats) {
							const n = (e => {
								const t = q()(e, (e, t) => e.sort(Q)),
									s = t.subscriptionData,
									n = s.map(e => e.subscribers),
									o = s.map(e => e.unsubscribers),
									r = J(t.hourStats, K.b, a.J),
									i = J(t.dayStats, K.a, a.x),
									d = J(t.monthStats, K.c, a.eb);
								return {
									pageViews: {
										byHour: r.pageViews,
										byDay: i.pageViews,
										byMonth: d.pageViews
									},
									uniqueUsers: {
										byHour: r.uniqueUsers,
										byDay: i.uniqueUsers,
										byMonth: d.uniqueUsers
									},
									subscribers: n,
									unsubscribers: o
								}
							})(s.trafficStats);
							t(X({
								subredditId: e,
								trafficStats: n
							}))
						}
					} else t($({
						subredditId: e
					})), t(B.e({
						id: "error-block-trafficStats",
						kind: Z.b.Error,
						text: D.fbt._("Try again later", null, {
							hk: "41Goel"
						})
					}))
				};
			var te = s("./src/reddit/models/ModQueue/index.ts"),
				se = s("./src/reddit/models/ScheduledPost/index.ts"),
				ne = s("./src/reddit/selectors/moderatorPermissions.ts"),
				oe = s("./src/reddit/selectors/platform.ts"),
				ae = s("./src/reddit/selectors/postCreations.ts"),
				re = s("./src/reddit/selectors/streamingModSettings.ts"),
				ie = s("./src/reddit/selectors/user.ts");
			const de = e => async (t, s, x) => {
				const {
					params: E
				} = e, {
					subredditName: v,
					pageName: C
				} = E;
				if (C === a.Pb.Wiki) {
					if (await t(Object(I.handleWikiRedirects)(e))) return
				}
				if (C === a.Pb.SubredditContent) return void t(Object(n.c)(se.p));
				const k = Object(r.a)(v, a.O.HOT),
					O = s(),
					D = e.queryParams,
					B = D.page || te.b,
					U = O.listings.postOrder.ids[k],
					H = O.listings.postOrder.api.error[k],
					W = O.listings.postOrder.api.pending[k];
				if (H) return;
				if (W || U && !H) Object(p.f)(s(), !0, v);
				else if (await t(Object(S.i)(k, v, {})), !Object(ie.H)(s()) && C !== a.Pb.Moderators) return void Object(m.a)(t, s());
				if (!C) return;
				let V, q, G, K, z, Q, J, Z, X, Y;
				switch (C) {
					case a.Pb.Awards:
						V = g.g;
						break;
					case a.Pb.Muted:
						V = L.ib;
						break;
					case a.Pb.Contributors:
						V = L.V;
						break;
					case a.Pb.Banned:
						V = L.Z;
						break;
					case a.Pb.Moderators:
						K = !0;
						break;
					case a.Pb.Removal:
						V = N.removalReasonsRequested;
						break;
					case a.Pb.PostRequirements:
						V = T.a, J = !0;
						break;
					case a.Pb.ChatSettings:
						G = !0;
						break;
					case a.Pb.CommunitySettings:
						V = A.f, Z = !0;
						break;
					case a.Pb.Flair:
						V = f.b, Q = !0;
						break;
					case a.Pb.UserFlair:
					case a.Pb.PostFlair:
						V = void 0;
						break;
					case a.Pb.Emojis:
						V = b.l;
						break;
					case a.Pb.Badges:
					case a.Pb.Emotes:
					case a.Pb.SubredditRules:
						V = void 0;
						break;
					case a.Pb.Traffic:
						V = ee;
						break;
					case a.Pb.Modlog:
						V = y, z = !0;
						break;
					case a.Pb.Streaming:
						V = M.a;
						break;
					case a.Pb.Modqueue:
					case a.Pb.Reports:
					case a.Pb.Spam:
					case a.Pb.Edited:
					case a.Pb.Unmoderated:
						q = C;
						break;
					case a.Pb.Wiki:
					case a.Pb.WikiContributors:
					case a.Pb.WikiBanned:
						await t(Object(I.subredditWikDataRequested)(E, D, !0));
						break;
					case a.Pb.ScheduledPostContent:
						X = !0, V = i.i;
						break;
					case a.Pb.EventPostContent:
						Y = !0;
						break;
					default:
						return Object(o.a)(C)
				}
				const $ = s(),
					de = Object(_.U)($, {
						subredditName: v.toLowerCase()
					}),
					le = Object(_.F)($, v),
					ce = Object(_.R)($, {
						subredditId: le
					}),
					me = Object(d.a)(ce),
					ue = Object(ae.Z)(O),
					pe = Object(ie.E)($),
					be = Object(re.a)($),
					he = Object(ne.j)($, {
						subredditId: le
					});
				if (Object(l.a)(C, he, me, ue, pe, be)) {
					if (q) {
						const e = Object(c.a)({
								onlyOfType: D.only,
								subreddit: v
							}),
							n = O.modQueue[q].itemOrder[e],
							o = !!(n && n[B] && n[B].length),
							a = O.modQueue[q].api.error;
						if (O.modQueue[q].api.pending || o && !a) return;
						if (!Object(oe.p)(O)) {
							const n = Object(j.e)(e, q, Object.assign({}, D, {
								subreddit: v
							}));
							await n(t, s, x)
						}
					} else if (K) {
						if (await Object(L.fb)(le, D)(t, s, x), O.moderatingSubreddits[le]) {
							await Object(L.db)(le, D)(t, s, x), O.moderators.invitedModerators.userOrder[le] || await Object(L.eb)(le)(t, s, x)
						}
					} else J ? await V(v)(t, s, x) : G ? await Object(w.e)(le)(t, s, x) : Z ? await Promise.all([V(v, le)(t, s, x), Object(F.k)(le, u.a.communitySettings)(t, s, x)]) : z || Q ? await V(v, D)(t, s, x) : X ? await Object(i.i)({
						subredditId: le
					})(t, s, x) : Y ? await Object(h.eventPostsRequested)(v)(t, s, x) : V && await V(le, D)(t, s, x);
					O.subreddits.rules[le] || await R.o(v)(t, s, x), t(P.l({
						title: de
					}))
				}
			}
		},
		"./src/reddit/actions/pages/shared.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			}));
			var n = s("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = s("./src/reddit/helpers/routeKey/index.ts"),
				a = s("./src/reddit/helpers/trackers/screenview.ts"),
				r = s("./src/telemetry/index.ts"),
				i = s("./src/telemetry/models/Timer.ts");
			const d = () => async (e, t) => {
				const s = t(),
					{
						currentPage: d
					} = s.platform;
				if (!d) return;
				const l = d.routeMatch,
					c = Object(n.a)(s),
					m = Object(o.b)(l, s, c);
				m && r.c.has(m) && Object(a.h)(l, s, i.TimerType.InApp, r.c.end(m))
			}
		},
		"./src/reddit/actions/pages/subredditWiki/index.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "subredditWikiDataPending", (function() {
				return U
			})), s.d(t, "subredditWikiDataLoaded", (function() {
				return H
			})), s.d(t, "subredditWikiDataFailed", (function() {
				return W
			})), s.d(t, "fetchSubredditWikiData", (function() {
				return G
			})), s.d(t, "handleWikiRedirects", (function() {
				return z
			})), s.d(t, "subredditWikDataRequested", (function() {
				return Q
			})), s.d(t, "subredditWikiPageRequested", (function() {
				return J
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/lodash/isEmpty.js"),
				a = s.n(o),
				r = s("./node_modules/react-router-redux/es/index.js"),
				i = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/makeActionCreator/index.ts"),
				l = s("./src/lib/makeListingKey/index.ts"),
				c = s("./src/config.ts"),
				m = s("./src/reddit/actions/platform.ts"),
				u = s("./src/reddit/helpers/path/index.ts");
			var p = s("./src/reddit/actions/ads/index.ts"),
				b = s("./src/reddit/actions/pages/subreddit.ts"),
				h = s("./src/reddit/actions/pages/subredditWiki/constants.ts"),
				g = s("./src/reddit/actions/toaster.ts"),
				f = s("./src/reddit/actions/wiki/wikiBannedContributors/index.ts"),
				x = s("./src/reddit/actions/wiki/wikiContributors/index.ts"),
				E = s("./src/lib/makeGqlRequest/index.ts"),
				v = s("./src/graphql/operations/WikiComparisonDiff.json"),
				C = s("./src/reddit/helpers/wiki/wikiRevision.ts");
			var _ = s("./src/reddit/helpers/wiki/makeComparisonDiffKey.ts"),
				k = s("./src/reddit/selectors/subredditWiki.ts"),
				O = s("./src/reddit/actions/wiki/wikiDiff/constants.ts");
			const y = Object(d.a)(O.c),
				j = Object(d.a)(O.b),
				w = Object(d.a)(O.a),
				S = e => async (t, s, n) => {
					const o = s(),
						a = Object(_.a)(e),
						r = Object(k.i)(o, {
							key: a
						});
					if (r && (r.pending || !r.error)) return !0;
					const d = {
						key: a
					};
					t(y(d));
					const l = await ((e, t) => Object(E.a)(e, Object.assign({}, v, {
						variables: Object.assign({}, t, {
							comparisonRevisionId: Object(C.b)(t.comparisonRevisionId),
							revisionId: Object(C.b)(t.revisionId)
						})
					})))(n.gqlContext(), e);
					let c = null,
						m = "";
					if (l.ok) {
						const e = l.body,
							t = e.data.subreddit && e.data.subreddit.wiki,
							s = t && t.page && t.page.revisionComparisonDiffHtml;
						s ? m = s : c = {
							type: i.E.NOT_FOUND_ERROR
						}
					} else c = l.error || {
						type: i.E.UNKNOWN_ERROR
					};
					return t(c ? w(Object.assign({}, d, {
						error: c
					})) : j(Object.assign({}, d, {
						htmlDiff: m
					}))), !c
				};
			var I = s("./src/reddit/actions/wiki/wikiPageSettings/index.tsx"),
				P = s("./src/reddit/actions/wiki/wikiRevisions/index.ts"),
				T = s("./src/reddit/constants/parameters.ts"),
				N = s("./src/reddit/constants/wiki.ts"),
				M = s("./src/reddit/endpoints/page/subredditWiki.ts"),
				R = s("./src/reddit/helpers/brandSafety/index.ts"),
				L = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				A = s("./src/reddit/models/Toast/index.ts"),
				F = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				D = s("./src/reddit/routes/subredditWiki/normalizeWikiUrl.ts"),
				B = s("./src/reddit/selectors/subreddit.ts");
			const U = Object(d.a)(h.c),
				H = Object(d.a)(h.b),
				W = Object(d.a)(h.a),
				V = (e, t, s, n) => {
					return s === N.j ? q(e, t) : !!Object(k.c)(e, {
						subredditName: t,
						wikiPageName: s,
						revisionId: n
					})
				},
				q = (e, t) => !!Object(k.b)(e, {
					subredditName: t
				}),
				G = e => async (t, s, o) => {
					const {
						canShowFailToast: r,
						wikiPageName: d
					} = e, l = d === N.j, c = Object.assign({}, e, {
						includePageData: e.includePageData && !l
					}), m = d ? Object(L.a)(Object.assign({}, e, {
						wikiPageName: d
					})) : void 0;
					t(U({
						options: c,
						pageKey: m
					}));
					const u = await Object(M.a)(o.gqlContext(), c),
						p = u.body,
						b = u.ok ? p.data && p.data.subreddit && p.data.subreddit.wiki : null;
					return u.ok && b ? t(H({
						options: c,
						pageKey: m,
						subredditWiki: b
					})) : (t(W({
						options: c,
						pageKey: m,
						error: u.error || {
							type: i.E.NOT_FOUND_ERROR
						}
					})), r && t(Object(g.e)({
						id: "SUBREDDIT_WIKI_DATA_ERROR_TOAST",
						kind: A.b.Error,
						text: n.fbt._("Something went wrong loading this page. Try again?", null, {
							hk: "wZxm"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "mgOpG"
						}),
						buttonAction: G(e)
					}))), !(!u.ok || !a()(p.data.subreddit)) || !(!u.ok || !b)
				}, K = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (s, n) => {
						const o = n(),
							a = {
								sort: i.O.HOT
							},
							r = Object(l.a)(e, a.sort),
							d = o.listings.postOrder.api.error[r],
							c = o.listings.postOrder.api.pending[r],
							m = !!o.listings.postOrder.ids[r];
						return !!(c || m && !d) || (await s(Object(b.i)(r, e, a, t)), !n().listings.postOrder.api.error[r])
					}
				}, z = e => async (t, s) => {
					const {
						params: n,
						url: o
					} = e, {
						wikiPageName: a
					} = n, i = Object(D.a)(o, n);
					let d = !1;
					return N.l.includes(a || "") ? (await (async (e, t) => {
						const s = "".concat(c.a.oldRedditUrl).concat(Object(u.b)(e));
						window.location.href = s
					})(e.url), d = !0) : o !== i && (await t(Object(r.c)(i)), d = !0), d
				}, Q = function e(t, s) {
					let o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (a, r, d) => {
						const {
							subredditName: l = N.e,
							wikiPageName: c,
							wikiSubRoute: m
						} = t, u = s[T.x], p = s[T.y], b = u ? Object(C.a)(u) : void 0, h = p ? Object(C.a)(p) : void 0, E = c === N.j, v = m === N.m.Revisions;
						let _ = !1,
							k = !1;
						if (o) {
							const {
								pageName: e
							} = t;
							_ = e === i.Pb.WikiContributors, k = e === i.Pb.WikiBanned
						}
						const O = r(),
							y = (E || o) && !q(O, l),
							j = !!c && !V(O, l, c, b),
							w = [];
						w.push(a(K(l))), (y || j) && w.push(a(G({
							includeDirectory: y,
							includePageData: j,
							revisionId: b,
							subredditName: l,
							wikiPageName: c
						}))), m === N.m.Settings && c && w.push(a(Object(I.c)(l, c))), c && b && h && w.push(a(S({
							comparisonRevisionId: h,
							revisionId: b,
							subredditName: l,
							wikiPageName: c
						}))), v && w.push(a(Object(P.c)({
							isRecent: !c,
							wikiPageName: c,
							subredditName: l
						}))), _ && w.push(a(Object(x.e)(l))), k && w.push(a(Object(f.e)(l))), (await Promise.all(w)).every(Boolean) || a(Object(g.e)({
							kind: A.b.Error,
							text: n.fbt._("Something went wrong", null, {
								hk: "3UWos1"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "mgOpG"
							}),
							buttonAction: e(t, s, o)
						}))
					}
				}, J = e => async (t, s) => {
					if (await t(z(e))) return;
					const {
						params: n,
						queryParams: o
					} = e, a = n.subredditName || N.e;
					t(m.l({
						title: n.wikiPageName ? "".concat(n.wikiPageName, " - ").concat(a) : "wiki - ".concat(a)
					})), await t(Q(n, o));
					const r = Object(B.A)(s(), {
							subredditName: a
						}),
						i = s();
					r && (i.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						t(Object(p.b)(F.a.SUBREDDIT))
					}), t(Object(p.d)({
						isViewSafe: Object(R.a)([], [r])
					})))
				}
		},
		"./src/reddit/actions/postCreation/editing.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return T
			})), s.d(t, "a", (function() {
				return N
			})), s.d(t, "c", (function() {
				return M
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/post.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/lib/constants/index.ts"),
				d = s("./src/lib/makeApiRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/reddit/constants/headers.ts"),
				m = s("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				u = s("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				p = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const b = e => Object.assign({
				api_type: "json",
				show_error_list: !0,
				thing_id: e.post.id,
				validate_on_submit: !0
			}, (e => !(!e.document || !e.document.length))(e) ? (e => ({
				text: null,
				richtext_json: JSON.stringify({
					document: e.document
				})
			}))(e) : (e => ({
				text: e.markdown,
				return_rtjson: !0
			}))(e));
			var h = (e, t) => Object(d.a)(Object(l.a)(e, [c.a]), {
					endpoint: Object(p.a)(Object(m.a)("".concat(e.apiUrl, "/api/editusertext"))),
					method: i.cb.POST,
					data: b(t)
				}).then(u.b),
				g = s("./src/reddit/helpers/overlay/index.ts"),
				f = s("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				x = s("./src/reddit/helpers/trackers/lightbox.ts"),
				E = s("./src/reddit/helpers/trackers/post.ts"),
				v = s("./src/reddit/helpers/trackers/postComposer.ts"),
				C = s("./src/reddit/models/Media/index.ts"),
				_ = s("./src/reddit/models/PostCreationForm/index.ts"),
				k = s("./src/reddit/models/Toast/index.ts"),
				O = s("./src/reddit/selectors/posts.ts"),
				y = s("./src/reddit/actions/postCreation/constants.ts"),
				j = s("./src/reddit/actions/postCreation/general.ts");
			const w = Object(o.a)(y.m),
				S = Object(o.a)(y.n),
				I = Object(o.a)(y.z),
				P = Object(o.a)(y.F),
				T = Object(o.a)(y.G),
				N = (e, t) => async (s, n, o) => {
					let {
						apiContext: a
					} = o;
					const r = n(),
						i = Object(O.O)(r, {
							postId: e
						});
					t ? (s(Object(g.a)(i.permalink)), Object(x.d)(e, "edit")(r)) : Object(E.b)(e, "edit")(r);
					const {
						media: d
					} = i;
					if (!d) return;
					let l, c = _.h.RICH_TEXT,
						m = "";
					d.type === C.n.TEXT ? (c = _.h.MARKDOWN, m = d.content) : d.type === C.n.RTJSON && (m = (c = d.rteMode || _.h.RICH_TEXT) === _.h.MARKDOWN ? d.markdownContent : d.richtextContent, l = d.mediaMetadata || void 0), s(P({
						editorMode: c,
						mediaMetadata: l,
						postContent: m,
						postId: e
					}))
				}, M = e => async (t, s, o) => {
					let {
						apiContext: i
					} = o;
					const {
						post: d
					} = e, l = !d.media || "rtjson" !== d.media.type && "text" !== d.media.type ? "" : d.media.rteMode;
					v.u(s(), Object(j.o)(l)), t(I(d.id));
					const c = await h(i(), e),
						m = !1 === c.body.success;
					if (t(w(d.id)), c.ok && !m) {
						t(Object(r.e)({
							kind: k.b.SuccessCommunity,
							text: n.fbt._("Post successfully edited", null, {
								hk: "xej5K"
							})
						})), t(T(d.id));
						const e = Object(f.a)(c.body);
						t(Object(a.U)({
							[d.id]: e
						}))
					} else t(S(c.error))
				}
		},
		"./src/reddit/actions/removalReasons/index.ts": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "removalReasonsPending", (function() {
				return P
			})), s.d(t, "removalReasonsLoaded", (function() {
				return T
			})), s.d(t, "removalReasonsFailed", (function() {
				return N
			})), s.d(t, "removalReasonsRequested", (function() {
				return M
			})), s.d(t, "removalReasonAddedPending", (function() {
				return R
			})), s.d(t, "removalReasonAddedSuccess", (function() {
				return L
			})), s.d(t, "removalReasonAddedFailed", (function() {
				return A
			})), s.d(t, "addRemovalReason", (function() {
				return F
			})), s.d(t, "editRemovalReasonPending", (function() {
				return D
			})), s.d(t, "editRemovalReasonSuccess", (function() {
				return B
			})), s.d(t, "editRemovalReasonFailed", (function() {
				return U
			})), s.d(t, "editRemovalReason", (function() {
				return H
			})), s.d(t, "deleteRemovalReasonPending", (function() {
				return W
			})), s.d(t, "deleteRemovalReasonSuccess", (function() {
				return V
			})), s.d(t, "deleteRemovalReasonFailed", (function() {
				return q
			})), s.d(t, "deleteRemovalReason", (function() {
				return G
			})), s.d(t, "removedItemsSelected", (function() {
				return K
			})), s.d(t, "fetchReasonsAndOpenModal", (function() {
				return z
			})), s.d(t, "removalReasonSubmittedPending", (function() {
				return Q
			})), s.d(t, "removalReasonSubmittedSuccess", (function() {
				return J
			})), s.d(t, "removalReasonSubmittedFailed", (function() {
				return Z
			})), s.d(t, "removalReasonMessagePending", (function() {
				return X
			})), s.d(t, "removalReasonPrivateMessageSuccess", (function() {
				return Y
			})), s.d(t, "removalReasonPublicMessageSuccess", (function() {
				return $
			})), s.d(t, "removalReasonMessageFailed", (function() {
				return ee
			})), s.d(t, "submitRemovalReason", (function() {
				return te
			})), s.d(t, "submitBulkRemovalReason", (function() {
				return se
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/lib/makeCommentsPageKey/index.ts"),
				i = s("./src/lib/makeDraftKey/index.ts"),
				d = s("./src/reddit/actions/bulkActions/index.ts"),
				l = s("./src/reddit/actions/comment/index.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				m = s("./src/reddit/actions/post.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				p = s("./src/reddit/constants/modals.ts"),
				b = s("./src/lib/makeApiRequest/index.ts"),
				h = s("./src/lib/omitHeaders/index.ts"),
				g = s("./src/reddit/constants/headers.ts"),
				f = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const x = (e, t) => Object(b.a)(Object(h.a)(e, [g.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/modactions/removal_reasons/"),
					method: o.cb.POST,
					type: "json",
					data: {
						item_ids: t.itemIds,
						reason_id: t.reasonId,
						mod_note: t.modNote
					}
				}),
				E = (e, t, s) => Object(b.a)(Object(h.a)(e, [g.a]), {
					endpoint: Object(f.a)("".concat(e.apiUrl, "/api/v1/modactions/removal_").concat(s, "_message/")),
					method: o.cb.POST,
					type: "json",
					data: t
				});
			var v = s("./src/reddit/helpers/isPost.ts"),
				C = s("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				_ = s("./src/reddit/helpers/routeKey/index.ts"),
				k = s("./src/reddit/models/ModQueue/index.ts"),
				O = s("./src/reddit/models/PostDraft/index.ts"),
				y = s("./src/reddit/models/RemovalReason/index.ts"),
				j = s("./src/reddit/models/Toast/index.ts"),
				w = s("./src/reddit/selectors/comments.ts"),
				S = s("./src/reddit/selectors/platform.ts"),
				I = s("./src/reddit/actions/removalReasons/constants.ts");
			const P = Object(a.a)(I.k),
				T = Object(a.a)(I.l),
				N = Object(a.a)(I.j),
				M = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					const r = s().subreddits.models[e].name;
					t(P());
					const i = await ((e, t) => Object(b.a)(Object(h.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons.json"),
						method: o.cb.GET
					}))(a(), r);
					i.ok ? t(T({
						subredditId: e,
						response: i.body
					})) : t(N(i.error))
				}, R = Object(a.a)(I.b), L = Object(a.a)(I.c), A = Object(a.a)(I.a), F = (e, t) => async (s, a, r) => {
					let {
						apiContext: i
					} = r;
					const d = a().subreddits.models[e].name;
					s(R());
					const l = await ((e, t, s) => Object(b.a)(Object(h.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons"),
						method: o.cb.POST,
						data: s
					}))(i(), d, t);
					if (l.ok) {
						const {
							id: o
						} = l.body, a = Object.assign({}, t, {
							id: o
						});
						s(L({
							subredditId: e,
							reason: a
						})), s(Object(u.e)({
							kind: j.b.SuccessMod,
							text: n.fbt._("Removal reason added!", null, {
								hk: "2WSh8N"
							})
						}))
					} else s(A(l.error))
				}, D = Object(a.a)(I.h), B = Object(a.a)(I.i), U = Object(a.a)(I.g), H = (e, t) => async (s, a, r) => {
					let {
						apiContext: i
					} = r;
					const d = a().subreddits.models[e].name;
					s(D());
					const l = await ((e, t, s) => Object(b.a)(Object(h.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons/").concat(s.id),
						method: o.cb.PUT,
						data: {
							message: s.message,
							title: s.title
						}
					}))(i(), d, t);
					l.ok ? (s(B({
						subredditId: e,
						reason: t
					})), s(Object(u.e)({
						kind: j.b.SuccessMod,
						text: n.fbt._("Removal reason saved", null, {
							hk: "28ScuL"
						})
					}))) : s(U(l.error))
				}, W = Object(a.a)(I.e), V = Object(a.a)(I.f), q = Object(a.a)(I.d), G = (e, t) => async (s, a, r) => {
					let {
						apiContext: i
					} = r;
					const d = a().subreddits.models[e].name;
					s(W());
					const l = await ((e, t, s) => Object(b.a)(Object(h.a)(e, [g.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons/").concat(s),
						method: o.cb.DELETE
					}))(i(), d, t);
					l.ok ? (s(V({
						subredditId: e,
						reasonId: t
					})), s(Object(u.e)({
						kind: j.b.SuccessMod,
						text: n.fbt._("Removal reason deleted", null, {
							hk: "4xzgsa"
						})
					}))) : s(q(l.error))
				}, K = Object(a.a)(I.t), z = (e, t) => async (s, n, o) => {
					let {
						apiContext: a
					} = o;
					const r = n();
					r.removalReasons.reasonOrder[e] && r.removalReasons.reasonOrder[e].length > 0 || s(M(e)), s(K({
						subredditId: e,
						itemIds: t
					})), s(Object(c.i)(p.a.ADD_REMOVAL_REASON))
				}, Q = Object(a.a)(I.r), J = Object(a.a)(I.s), Z = Object(a.a)(I.q), X = Object(a.a)(I.n), Y = Object(a.a)(I.o), $ = Object(a.a)(I.p), ee = Object(a.a)(I.m), te = (e, t, s, n, a) => async (d, c, u) => {
					let {
						apiContext: p
					} = u;
					const b = c(),
						h = b.user.account && b.user.account.displayText,
						g = e[0],
						f = Object(v.a)(g) ? y.e.Post : y.e.Comment,
						k = f === y.e.Post ? b.posts.models[g] : b.comments.models[g],
						j = f === y.e.Post ? m.U : l.R;
					if (!k || !h) return;
					d(Q()), d(j({
						[g]: {
							modNote: a,
							modRemovalReason: t && t.title,
							modReasonBy: h
						}
					}));
					const I = {
							itemIds: e,
							modNote: a,
							reasonId: t ? t.id : null
						},
						P = await x(p(), I);
					if (P.ok) {
						if (d(J()), t) {
							d(X());
							const a = {
									itemId: e,
									message: s,
									title: t.title,
									type: n
								},
								c = await E(p(), Object(y.h)(a, f), f);
							if (c.ok)
								if (n === y.f.Public) {
									if (d($()), c.body) {
										const e = Object(C.a)(c.body, h),
											t = {
												comment: e,
												parentId: g
											},
											s = Object(S.g)(b),
											n = b.platform.currentPage && b.platform.currentPage.routeMatch;
										let a = s && n && Object(_.a)(n, b, b.posts.models[e.postId]);
										if (a || (a = Object(r.a)(e.postId, null, {
												sort: o.s,
												hasSortParam: !0
											})), f === y.e.Post) {
											const s = Object(i.a)(O.c.replyToPost, g);
											d(Object(l.mb)(Object.assign({}, t, {
												headCommentId: Object(w.x)(b, {
													commentsPageKey: a
												}),
												commentsPageKey: a,
												draftKey: s
											})));
											const n = b.postStickiedComments.data[g];
											d(Object(l.ib)({
												id: e.id,
												postId: e.postId,
												commentsPageKey: a
											})), n && n !== e.id && d(Object(l.R)({
												[n]: {
													isStickied: !1
												}
											}))
										} else if (f === y.e.Comment) {
											const e = Object(i.a)(O.c.replyToComment, k.id),
												s = Object(w.j)(b, {
													commentId: g,
													commentsPageKey: a
												});
											d(Object(l.kb)(Object.assign({}, t, {
												parentCommentId: g,
												commentsPageKey: a,
												draftKey: e,
												depth: s + 1
											})))
										}
									}
								} else d(Y());
							else d(ee(c.error))
						}
					} else d(Z(P.error)), d(j({
						[g]: {
							modNote: k.modNote,
							modRemovalReason: k.modRemovalReason,
							modReasonBy: k.modReasonBy
						}
					}))
				}, se = (e, t, s, o, a) => async (r, i, l) => {
					let {
						apiContext: c
					} = l;
					const m = i(),
						p = m.user.account && m.user.account.displayText;
					if (!p) return;
					r(Q());
					const b = Object(u.e)({
							kind: j.b.SuccessMod,
							text: n.fbt._({
								"*": "Added removal reason for {number} posts/comments",
								_1: "Added removal reason for 1 post/comment"
							}, [n.fbt._plural(e.length, "number")], {
								hk: "3Gipsf"
							})
						}),
						h = {
							itemIds: e,
							modNote: a,
							reasonId: t ? t.id : null
						},
						g = await x(c(), h);
					if (g.ok) {
						const n = {
							ids: e,
							operation: k.a.RemovalReason,
							username: p,
							options: {
								modNote: a,
								removalReason: t && t.title
							}
						};
						if (r(Object(d.b)(n)), t) {
							const n = {
									itemId: e,
									message: s,
									title: t.title,
									type: o
								},
								a = await E(c(), Object(y.h)(n, y.e.Bulk), y.e.Bulk);
							a.ok ? (r(Y()), r(b)) : r(ee(a.error))
						} else r(b)
					} else r(Z(g.error))
				}
		},
		"./src/reddit/actions/scheduledPosts/delete.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/scheduledPosts/constants.ts"),
				a = s("./src/reddit/actions/toaster.ts"),
				r = s("./src/graphql/operations/DeleteScheduledPost.json"),
				i = s("./src/lib/makeGqlRequest/index.ts");
			var d = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				l = s("./src/reddit/models/ScheduledPost/index.ts"),
				c = s("./src/reddit/models/Toast/index.ts"),
				m = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				u = s("./src/telemetry/index.ts");
			const p = Object(n.a)(o.i),
				b = (e, t) => async (s, n, b) => {
					let {
						gqlContext: h
					} = b;
					const g = Object(m.a)(n(), {
						subredditId: e,
						scheduledPostId: t
					});
					g && Object(l.n)(g) && Object(u.a)(Object(d.x)()(n(), g)), g ? (await ((e, t) => Object(i.a)(e, Object.assign({}, r, {
						variables: t
					})))(h(), {
						input: {
							id: g.id
						}
					})).ok ? (s(Object(a.e)(Object(a.d)(o.q(), c.b.SuccessCommunity))), s(p({
						subredditId: e,
						scheduledPostId: t
					}))) : s(Object(a.e)(Object(a.d)(o.p(), c.b.Error))) : s(Object(a.e)(Object(a.d)(o.u(), c.b.Error)))
				}
		},
		"./src/reddit/actions/scheduledPosts/edit.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return E
			})), s.d(t, "a", (function() {
				return C
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react-router-redux/es/index.js"),
				a = s("./src/telemetry/index.ts"),
				r = s("./src/lib/makeActionCreator/index.ts"),
				i = s("./src/reddit/actions/scheduledPosts/index.ts"),
				d = s("./src/reddit/actions/scheduledPosts/constants.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/reddit/endpoints/scheduledPosts/update.ts"),
				m = s("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				u = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				p = s("./src/reddit/models/ScheduledPost/index.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/routes/postCreation/index.ts"),
				g = s("./src/reddit/selectors/scheduledPosts/index.ts");
			const f = Object(r.a)(d.n),
				x = Object(r.a)(d.b),
				E = (e, t) => async (s, n, a) => {
					const r = Object(g.a)(n(), {
						scheduledPostId: t,
						subredditId: e
					});
					r && (await s(Object(o.b)(Object(h.c)(r.subreddit.name))), s((Object(p.n)(r) ? x : f)(r)))
				}, v = (e, t) => {
					Object(p.n)(t) ? e(Object(i.d)({
						scheduledPost: t
					})) : e(Object(i.h)({
						scheduledPost: t
					}))
				}, C = (e, t, s) => async (o, r, h) => {
					let {
						gqlContext: f
					} = h;
					o(Object(i.g)());
					const x = Object(g.a)(r(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (x && Object(p.n)(x) && Object(a.a)(Object(u.z)()(r(), x)), !x) return void o(Object(i.f)({
						message: n.fbt._("Scheduled post not found", null, {
							hk: "2zjM55"
						})
					}));
					if (!Object.keys(s).length) return void v(o, x);
					const E = await Object(c.a)(f(), Object.assign({}, s, {
							id: t
						})),
						_ = E.body;
					if (!(E.ok && _ && _.data && _.data.updateScheduledPost && _.data.updateScheduledPost.ok && _.data.updateScheduledPost.scheduledPost)) return o(Object(i.f)({
						message: E.error && E.error.fields && E.error.fields.length && E.error.fields[0].msg || n.fbt._("Unknown error", null, {
							hk: "fXs5s"
						})
					})), void o(Object(l.e)(Object(l.d)(d.t(), b.b.Error, d.s(), C(e, t, s))));
					o(Object(l.e)(Object(l.d)(d.w(), b.b.SuccessCommunity))), v(o, Object(m.d)(_.data.updateScheduledPost.scheduledPost))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "g", (function() {
				return E
			})), s.d(t, "f", (function() {
				return v
			})), s.d(t, "h", (function() {
				return C
			})), s.d(t, "d", (function() {
				return _
			})), s.d(t, "c", (function() {
				return j
			})), s.d(t, "e", (function() {
				return S
			})), s.d(t, "i", (function() {
				return P
			})), s.d(t, "a", (function() {
				return T
			})), s.d(t, "b", (function() {
				return M
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/lib/assertNever.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/scheduledPosts/constants.ts"),
				r = s("./src/reddit/actions/scheduledPosts/edit.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/reddit/endpoints/scheduledPosts/index.ts"),
				l = s("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				c = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				m = s("./src/reddit/models/ScheduledPost/index.ts"),
				u = s("./src/reddit/models/Toast/index.ts"),
				p = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				b = s("./src/telemetry/index.ts"),
				h = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const g = 25,
				f = 1e4,
				x = Object(o.a)(a.g),
				E = Object(o.a)(a.k),
				v = Object(o.a)(a.j),
				C = Object(o.a)(a.o),
				_ = Object(o.a)(a.d),
				k = Object(o.a)(a.f),
				O = Object(o.a)(a.m),
				y = Object(o.a)(a.a),
				j = Object(o.a)(a.c),
				w = Object(o.a)(a.e),
				S = Object(o.a)(a.h),
				I = (e, t) => {
					e(w()), e(Object(i.e)(Object(i.d)(a.r(), u.b.Error, a.s(), P(t))))
				},
				P = e => {
					var {
						subredditId: t,
						includeStandalone: s = {
							standaloneFirst: g
						},
						includeRecurring: n = {
							recurringFirst: f
						}
					} = e, o = h(e, ["subredditId", "includeStandalone", "includeRecurring"]);
					return async (e, a, r) => {
						let {
							gqlContext: i
						} = r;
						if (Object(p.g)(a(), {
								subredditId: t
							})) return;
						e(x());
						const c = Object.assign({
								subredditId: t,
								includeRecurring: n,
								includeStandalone: s
							}, o),
							m = await Object(d.b)(i(), c);
						Object(d.f)(m, c) ? N(e, Object(l.e)(m.body.data), c) : I(e, c)
					}
				},
				T = e => async (t, s, n) => {
					let {
						gqlContext: o
					} = n;
					const a = s();
					if (!Object(p.g)(a, {
							subredditId: e
						})) return t(P({
						subredditId: e
					}));
					if (!Object(p.f)(a, {
							subredditId: e,
							type: m.f.standalonePosts
						})) return;
					const r = Object(p.b)(a, {
						subredditId: e,
						type: m.f.standalonePosts
					});
					if (!r) return;
					t(x());
					const i = {
							subredditId: e,
							includeStandalone: {
								standaloneFirst: g,
								standaloneAfter: r
							}
						},
						c = await Object(d.b)(o(), i);
					c.ok ? N(t, Object(l.e)(c.body.data), i) : t(w())
				}, N = (e, t, s) => {
					Object(l.b)(t) ? e(k(t)) : Object(l.a)(t) ? e(y(t)) : Object(l.c)(t) ? e(O(t)) : I(e, s)
				}, M = (e, t) => async (s, o, a) => {
					const i = {},
						d = o();
					switch (e) {
						case "isModDistinguished":
						case "isNsfw":
						case "isOriginalContent":
						case "isSpoiler":
							i[e] = !t[e];
							break;
						case "isSticky":
							i.sticky = t.isSticky ? "NONE" : "SECOND";
							break;
						default:
							return Object(n.a)(e)
					}
					Object(b.a)(Object(c.y)(e, i[e], Object(m.n)(t))(d)), s(Object(r.a)(t.subreddit.id, t.id, i))
				}
		},
		"./src/reddit/actions/streaming/modSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/streaming/constants.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/graphql/operations/FetchSubredditStreamingModSettings.json"),
				d = s("./src/lib/makeGqlRequest/index.ts"),
				l = s("./src/reddit/models/Toast/index.ts"),
				c = s("./src/reddit/selectors/subreddit.ts");
			const m = Object(o.a)(a.a),
				u = e => async (t, s, o) => {
					let {
						gqlContext: a
					} = o;
					const u = Object(c.R)(s(), {
						subredditId: e
					});
					if (void 0 === u) {
						const e = n.fbt._("Invalid subreddit", null, {
								hk: "2iUXvs"
							}),
							s = Object(r.d)(e, l.b.Error);
						return await t(Object(r.e)(Object.assign({}, s, {
							duration: r.a
						}))), {
							reason: e
						}
					}
					const p = await ((e, t) => Object(d.a)(e, Object.assign({}, i, {
						variables: {
							subredditId: t
						}
					})))(a(), e);
					if (!p.ok) {
						const e = n.fbt._("Could not fetch settings for {subredditName}", [n.fbt._param("subredditName", u.name)], {
								hk: "2G8rnU"
							}),
							s = Object(r.d)(e, l.b.Error);
						return await t(Object(r.e)(Object.assign({}, s, {
							duration: r.a
						}))), {
							reason: e
						}
					}
					const b = p.body.data.subredditInfoById;
					return await t(m({
						subredditId: e,
						modSettings: b.liveStreamingInfo
					})), {}
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "g", (function() {
				return l
			}));
			const n = "WIKI_BANNED_CONTRIBUTORS_PENDING",
				o = "WIKI_BANNED_CONTRIBUTORS_LOADED",
				a = "WIKI_BANNED_CONTRIBUTORS_FAILED",
				r = "MORE_WIKI_BANNED_CONTRIBUTORS_LOADED",
				i = "WIKI_BANNED_CONTRIBUTOR_ADDED",
				d = "WIKI_BANNED_CONTRIBUTOR_REMOVED",
				l = "WIKI_BANNED_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return E
			})), s.d(t, "b", (function() {
				return C
			})), s.d(t, "a", (function() {
				return k
			})), s.d(t, "c", (function() {
				return y
			})), s.d(t, "d", (function() {
				return w
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/makeGqlRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/graphql/operations/SubredditWikiBannedContributors.json"),
				m = s("./src/reddit/constants/headers.ts");
			const u = (e, t) => Object(d.a)(e, Object.assign({}, c, {
				variables: t
			}));
			var p = e => {
					const {
						bannedMembersInfo: t
					} = e, {
						edges: s,
						pageInfo: n
					} = t, o = [], a = {};
					return s.forEach(e => {
						const {
							date: t,
							redditor: s,
							editWikiBanInfo: n
						} = e.node;
						s.id && s.name && s.icon && (a[s.id] = {
							id: s.id,
							username: s.name,
							iconUrl: s.icon.url,
							date: t,
							daysRemaining: n.daysRemaining,
							note: n.note
						}, o.push(s.id))
					}), {
						afterToken: n.hasNextPage ? n.endCursor : null,
						bannedContributors: a,
						userOrder: o
					}
				},
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const g = Object(a.a)(h.d),
				f = Object(a.a)(h.c),
				x = Object(a.a)(h.b),
				E = e => async (t, s, n) => {
					t(g({
						subredditName: e
					}));
					const a = {
							subredditName: e
						},
						r = await u(n.gqlContext(), a);
					if (r.ok) {
						const s = r.body,
							n = s.data.subreddit && s.data.subreddit.wiki;
						if (n) {
							const s = p(n);
							t(f(Object.assign({}, s, {
								subredditName: e.toLowerCase()
							})))
						}
					} else {
						const s = r.error || {
							type: o.E.UNKNOWN_ERROR
						};
						t(x({
							error: s,
							subredditName: e.toLowerCase()
						}))
					}
					return r.ok
				}, v = Object(a.a)(h.a), C = (e, t) => async (s, o, a) => {
					const i = {
							subredditName: e,
							after: t
						},
						d = await u(a.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const n = p(t.data.subreddit.wiki);
							s(v(Object.assign({}, n, {
								subredditName: e.toLowerCase()
							})))
						}
					} else s(Object(r.e)({
						kind: b.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "2EIEjY"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: C(e, t)
					}));
					return d.ok
				}, _ = Object(a.a)(h.e), k = (e, t) => async (s, a, d) => {
					const c = await ((e, t, s) => Object(i.a)(Object(l.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/friend"),
						method: o.cb.POST,
						data: {
							api_type: "json",
							name: s.username,
							type: "wikibanned",
							duration: s.duration,
							ban_reason: s.banReason,
							note: s.note
						}
					}))(d.apiContext(), e, t);
					if (c.ok) {
						s(Object(r.e)({
							kind: b.b.SuccessMod,
							text: n.fbt._("Successfully banned user", null, {
								hk: "1VcdP9"
							})
						}));
						const o = {
								subredditName: e,
								username: t.username
							},
							a = (await u(d.gqlContext(), o)).body;
						if (a.data.subreddit.wiki) {
							const t = p(a.data.subreddit.wiki);
							s(_({
								bannedContributor: t.bannedContributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (c.error) {
						let e;
						c.error.type === o.E.USER_DOESNT_EXIST && (e = n.fbt._("That user doesn't exist", null, {
							hk: "1AFgzG"
						})), s(Object(r.e)({
							kind: b.b.Error,
							text: e || n.fbt._("Something went wrong", null, {
								hk: "14O55Y"
							})
						}))
					}
					return c.ok
				}, O = Object(a.a)(h.f), y = (e, t) => async (s, a, d) => {
					const c = await ((e, t, s) => Object(i.a)(Object(l.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/unfriend"),
						method: o.cb.POST,
						data: {
							api_type: "json",
							id: s,
							type: "wikibanned"
						}
					}))(d.apiContext(), e, t);
					return c.ok ? (s(Object(r.e)({
						kind: b.b.SuccessMod,
						text: n.fbt._("User has been successfully removed", null, {
							hk: "381leB"
						})
					})), s(O({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : s(Object(r.e)({
						kind: b.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "4lHXgg"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: y(e, t)
					})), c.ok
				}, j = Object(a.a)(h.g), w = (e, t) => async (s, o, a) => {
					const i = {
							subredditName: e,
							username: t
						},
						d = await u(a.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const n = p(t.data.subreddit.wiki),
								o = Object.keys(n.bannedContributors)[0];
							s(j({
								subredditName: e.toLowerCase(),
								bannedContributor: n.bannedContributors[o]
							}))
						}
					} else s(Object(r.e)({
						kind: b.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "2iRQ4u"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiContributors/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "e", (function() {
				return i
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "g", (function() {
				return l
			}));
			const n = "WIKI_CONTRIBUTORS_PENDING",
				o = "WIKI_CONTRIBUTORS_LOADED",
				a = "WIKI_CONTRIBUTORS_FAILED",
				r = "MORE_WIKI_CONTRIBUTORS_LOADED",
				i = "WIKI_CONTRIBUTOR_ADDED",
				d = "WIKI_CONTRIBUTOR_REMOVED",
				l = "WIKI_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiContributors/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return E
			})), s.d(t, "b", (function() {
				return C
			})), s.d(t, "a", (function() {
				return k
			})), s.d(t, "c", (function() {
				return y
			})), s.d(t, "d", (function() {
				return w
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				d = s("./src/lib/makeGqlRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				c = s("./src/graphql/operations/SubredditWikiContributors.json"),
				m = s("./src/reddit/constants/headers.ts");
			const u = (e, t) => Object(d.a)(e, Object.assign({}, c, {
				variables: t
			}));
			var p = e => {
					const {
						contributorsInfo: t
					} = e, {
						edges: s,
						pageInfo: n
					} = t, o = [], a = {};
					return s.forEach(e => {
						const {
							date: t,
							redditor: s
						} = e.node;
						s.id && s.name && s.icon && (a[s.id] = {
							id: s.id,
							username: s.name,
							iconUrl: s.icon.url,
							date: t
						}, o.push(s.id))
					}), {
						afterToken: n.hasNextPage ? n.endCursor : null,
						contributors: a,
						userOrder: o
					}
				},
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const g = Object(a.a)(h.d),
				f = Object(a.a)(h.c),
				x = Object(a.a)(h.b),
				E = e => async (t, s, n) => {
					t(g({
						subredditName: e
					}));
					const a = {
							subredditName: e
						},
						r = await u(n.gqlContext(), a);
					if (r.ok) {
						const s = r.body,
							n = s.data.subreddit && s.data.subreddit.wiki;
						if (n) {
							const s = p(n);
							t(f(Object.assign({}, s, {
								subredditName: e.toLowerCase()
							})))
						}
					} else {
						const s = r.error || {
							type: o.E.UNKNOWN_ERROR
						};
						t(x({
							error: s,
							subredditName: e.toLowerCase()
						}))
					}
					return r.ok
				}, v = Object(a.a)(h.a), C = (e, t) => async (s, o, a) => {
					const i = {
							subredditName: e,
							after: t
						},
						d = await u(a.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const n = p(t.data.subreddit.wiki);
							s(v(Object.assign({}, n, {
								subredditName: e.toLowerCase()
							})))
						}
					} else s(Object(r.e)({
						kind: b.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: C(e, t)
					}));
					return d.ok
				}, _ = Object(a.a)(h.e), k = (e, t) => async (s, a, d) => {
					const c = await ((e, t, s) => Object(i.a)(Object(l.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/friend"),
						method: o.cb.POST,
						data: {
							api_type: "json",
							name: s,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					if (c.ok) {
						s(Object(r.e)({
							kind: b.b.SuccessMod,
							text: n.fbt._("User has been successfully added", null, {
								hk: "3mt5Vr"
							})
						}));
						const o = {
								subredditName: e,
								username: t
							},
							i = (await u(d.gqlContext(), o)).body;
						if (i.data.subreddit.wiki) {
							const t = p(i.data.subreddit.wiki),
								n = Object.keys(t.contributors)[0];
							!!a().pages.subredditWiki.wikiContributors.listing.models[e.toLowerCase()][n] || s(_({
								contributor: t.contributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (c.error) {
						let e;
						const t = c.error.type;
						t === o.E.USER_DOESNT_EXIST ? e = n.fbt._("That user doesn't exist", null, {
							hk: "1OHcCX"
						}) : t === o.E.BANNED_FROM_SUBREDDIT && (e = n.fbt._("That user is banned from the subreddit", null, {
							hk: "4eZcXp"
						})), s(Object(r.e)({
							kind: b.b.Error,
							text: e || n.fbt._("Something went wrong", null, {
								hk: "3VCQr6"
							})
						}))
					}
					return c.ok
				}, O = Object(a.a)(h.f), y = (e, t) => async (s, a, d) => {
					const c = await ((e, t, s) => Object(i.a)(Object(l.a)(e, [m.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/unfriend"),
						method: o.cb.POST,
						data: {
							api_type: "json",
							id: s,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					return c.ok ? (s(Object(r.e)({
						kind: b.b.SuccessMod,
						text: n.fbt._("User has been successfully removed", null, {
							hk: "2OevWA"
						})
					})), s(O({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : s(Object(r.e)({
						kind: b.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "1zUdz2"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: y(e, t)
					})), c.ok
				}, j = Object(a.a)(h.g), w = (e, t) => async (s, o, a) => {
					const i = {
							subredditName: e,
							username: t
						},
						d = await u(a.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const n = p(t.data.subreddit.wiki),
								o = Object.keys(n.contributors)[0];
							s(j({
								subredditName: e.toLowerCase(),
								contributor: n.contributors[o]
							}))
						}
					} else s(Object(r.e)({
						kind: b.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "2s4L9n"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiDiff/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return a
			}));
			const n = "WIKI_DIFF_PENDING",
				o = "WIKI_DIFF_LOADED",
				a = "WIKI_DIFF_FAILED"
		},
		"./src/reddit/actions/wiki/wikiEditing/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = "WIKI_PAGE_SAVE_SUCCESS"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "b", (function() {
				return r
			}));
			const n = "PAGE__SUBREDDIT_WIKI_PAGE_SETTINGS_LOADED",
				o = "SUBREDDIT_WIKI_PAGE_SETTINGS_UPDATED",
				a = "SUBREDDIT_WIKI_PAGE_CONTRIBUTOR_REOVED",
				r = "SUBREDDIT_WIKI_PAGE_MORE_CONTRIBUTORS_LOADED"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return _
			})), s.d(t, "b", (function() {
				return O
			})), s.d(t, "e", (function() {
				return j
			})), s.d(t, "a", (function() {
				return w
			})), s.d(t, "d", (function() {
				return I
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/subredditSettings.ts"),
				i = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/lib/makeApiRequest/index.ts"),
				l = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				m = s("./src/reddit/constants/headers.ts"),
				u = s("./src/graphql/operations/SubredditWikiPageSettings.json"),
				p = s("./src/reddit/models/SubredditWikiPage/index.ts");
			const b = (e, t) => Object(l.a)(e, Object.assign({}, u, {
					variables: t
				})),
				h = {
					[p.a.Inherit]: "0",
					[p.a.Contributors]: "1",
					[p.a.Mods]: "2"
				};
			var g = e => {
					const {
						editPermissions: t,
						editorsInfo: s,
						isVisible: n
					} = e, {
						edges: o,
						pageInfo: a
					} = s, r = [];
					return o.forEach(e => {
						e.node.name && e.node.icon && r.push({
							username: e.node.name,
							iconUrl: e.node.icon.url
						})
					}), {
						editPermissions: t,
						editorsInfo: r,
						isVisible: n,
						afterToken: a.hasNextPage ? a.endCursor : null
					}
				},
				f = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				x = s("./src/reddit/models/Toast/index.ts"),
				E = s("./src/reddit/selectors/subreddit.ts"),
				v = s("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const C = Object(a.a)(v.c),
				_ = (e, t) => async (s, n, o) => {
					const a = {
							subredditName: e,
							wikiPageName: t
						},
						i = await b(o.gqlContext(), a),
						d = Object(E.F)(n(), e);
					if (Object(E.T)(n(), d) || await s(Object(r.f)(e, d)), i.ok) {
						const e = i.body,
							t = e.data.subreddit && e.data.subreddit.wiki;
						if (t && t.page) {
							const e = g(t.page.settings);
							s(C({
								pageKey: Object(f.a)(a),
								settings: e
							}))
						}
					}
					return i.ok
				}, k = Object(a.a)(v.b), O = (e, t, s) => async (o, a, r) => {
					const d = {
							subredditName: e,
							wikiPageName: t,
							after: s
						},
						l = await b(r.gqlContext(), d);
					if (l.ok) {
						const s = l.body,
							n = s.data.subreddit && s.data.subreddit.wiki;
						if (n && n.page) {
							const s = g(n.page.settings),
								{
									editorsInfo: a,
									afterToken: r
								} = s;
							o(k({
								editorsInfo: a,
								afterToken: r,
								pageKey: Object(f.a)({
									wikiPageName: t,
									subredditName: e
								})
							}))
						}
					} else o(Object(i.e)({
						kind: x.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: O(e, t, s)
					}));
					return l.ok
				}, y = Object(a.a)(v.d), j = e => {
					let {
						editPermissions: t,
						isVisible: s,
						wikiPageName: n,
						subredditName: a
					} = e;
					return async (e, r, i) => {
						const l = await (e => Object(d.a)(Object(c.a)(e.context, [m.a]), {
							endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/wiki/settings/").concat(e.wikiPageName),
							method: o.cb.POST,
							data: {
								permlevel: h[e.editPermissions],
								listed: e.isVisible ? "on" : void 0
							}
						}))({
							context: i.apiContext(),
							editPermissions: t,
							isVisible: s,
							wikiPageName: n,
							subredditName: a
						});
						return l.ok && e(y({
							editPermissions: t,
							isVisible: s,
							pageKey: Object(f.a)({
								wikiPageName: n,
								subredditName: a
							})
						})), l.ok
					}
				}, w = e => {
					let {
						subredditName: t,
						username: s,
						wikiPageName: a
					} = e;
					return async (e, r, l) => {
						const u = await (e => Object(d.a)(Object(c.a)(e.context, [m.a]), {
							endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/api/wiki/alloweditor/add"),
							method: o.cb.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: l.apiContext(),
							wikiPageName: a,
							subredditName: t,
							username: s
						});
						if (u.ok) e(Object(i.e)({
							kind: x.b.SuccessCommunity,
							text: "User successfully added"
						})), await e(_(t, a));
						else if (u.error) {
							const t = u.error.type;
							let s = n.fbt._("Something went wrong", null, {
								hk: "8AkV3"
							});
							t === o.E.NOT_FOUND_ERROR && (s = n.fbt._("That user does not exist", null, {
								hk: "XDM7X"
							})), e(Object(i.e)({
								kind: x.b.Error,
								text: s
							}))
						}
						return u.ok
					}
				}, S = Object(a.a)(v.a), I = e => {
					let {
						subredditName: t,
						username: s,
						wikiPageName: n
					} = e;
					return async (e, a, r) => {
						const l = await (e => Object(d.a)(Object(c.a)(e.context, [m.a]), {
							endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/api/wiki/alloweditor/del"),
							method: o.cb.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: r.apiContext(),
							wikiPageName: n,
							subredditName: t,
							username: s
						});
						return l.ok && (e(Object(i.e)({
							kind: x.b.SuccessCommunity,
							text: "User has been successfully removed"
						})), e(S({
							username: s,
							pageKey: Object(f.a)({
								wikiPageName: n,
								subredditName: t
							})
						}))), l.ok
					}
				}
		},
		"./src/reddit/actions/wiki/wikiRevisions/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "e", (function() {
				return i
			}));
			const n = "WIKI_REVISIONS_PENDING",
				o = "WIKI_REVISIONS_LOADED",
				a = "WIKI_REVISIONS_FAILED",
				r = "WIKI_PAGE_REVERT_SUCCESS",
				i = "WIKI_REVISION_TOGGLE_VISIBILITY"
		},
		"./src/reddit/actions/wiki/wikiRevisions/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return y
			})), s.d(t, "a", (function() {
				return w
			})), s.d(t, "b", (function() {
				return I
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/reddit/endpoints/page/subredditWiki.ts"),
				d = s("./src/lib/makeGqlRequest/index.ts"),
				l = s("./src/graphql/operations/WikiRevisions.json");
			var c = s("./src/lib/makeApiRequest/index.ts"),
				m = s("./src/lib/omitHeaders/index.ts"),
				u = s("./src/reddit/constants/headers.ts"),
				p = s("./src/reddit/helpers/wiki/wikiRevision.ts");
			var b = (e, t) => Object(c.a)(Object(m.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t.subredditName, "/api/wiki/hide"),
				method: o.cb.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var h = (e, t) => Object(c.a)(Object(m.a)(e, [u.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t.subredditName, "/api/wiki/revert"),
				method: o.cb.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var g = e => {
					const t = e.subreddit && e.subreddit.wiki || {},
						s = t.pageRevisions && t.pageRevisions.revisions || t.recentRevisions;
					if (!s) throw new Error("Invalid response");
					return (e => {
						const t = {},
							s = [];
						return e.edges.forEach(e => {
							const n = e.node;
							t[n.id] = n, s.push(n.id)
						}), {
							pageInfo: e.pageInfo,
							revisions: t,
							revisionsIds: s
						}
					})(s)
				},
				f = s("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				x = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				E = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/selectors/subredditWiki.ts"),
				C = s("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const _ = Object(a.a)(C.d),
				k = Object(a.a)(C.c),
				O = Object(a.a)(C.b),
				y = e => async (t, s, a) => {
					const {
						canLoadMore: i = !1,
						canShowFailToast: c = !1,
						isRecent: m,
						subredditName: u,
						wikiPageName: p
					} = e, b = s(), h = Object(f.a)(e), x = Object(v.p)(b, {
						listingKey: h
					});
					if (!i && !!x) return !0;
					const C = x && x.pageInfo.endCursor || void 0;
					if (!(!x || x.pageInfo.hasNextPage)) return !0;
					const j = {
							after: C,
							isRecent: m,
							subredditName: u,
							wikiPageName: p
						},
						w = {
							key: h,
							options: j
						};
					t(_(w));
					const S = await ((e, t) => Object(d.a)(e, Object.assign({}, l, {
						variables: t
					})))(a.gqlContext(), j);
					if (S.ok) {
						const e = S.body;
						if (e.data.subreddit) {
							const s = g(e.data);
							t(k(Object.assign({}, w, s)))
						}
					} else {
						const s = S.error || {
							type: o.E.UNKNOWN_ERROR
						};
						t(O(Object.assign({}, w, {
							error: s
						}))), c && t(Object(r.e)({
							kind: E.b.Error,
							text: n.fbt._("Something went wrong", null, {
								hk: "1e4Swa"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: y(e)
						}))
					}
					return S.ok
				}, j = Object(a.a)(C.a), w = e => async (t, s, o) => {
					const {
						subredditName: a,
						wikiPageName: d
					} = e, l = Object(x.a)(Object.assign({}, e, {
						revisionId: void 0
					})), c = Object(f.a)(Object.assign({}, e, {
						isRecent: !1
					})), m = Object(f.a)(Object.assign({}, e, {
						isRecent: !0
					})), u = Object(v.p)(s(), {
						listingKey: c
					}), p = u && u.ids[0];
					if ((await h(o.apiContext(), e)).ok) {
						const e = (await Object(i.a)(o.gqlContext(), {
								includePageData: !0,
								subredditName: a,
								wikiPageName: d
							})).body,
							s = e.data.subreddit && e.data.subreddit.wiki,
							u = s && s.page;
						if (!u || !u.revision) return;
						if (u.revision.id === p) return void t(Object(r.e)({
							kind: E.b.SuccessCommunityGreen,
							text: n.fbt._("Wiki page is already at selected revision!", null, {
								hk: "46i9jx"
							})
						}));
						t(j({
							page: u,
							pageKey: l,
							pageRevisionsListingKey: c,
							recentRevisionsListingKey: m,
							subredditName: a,
							wikiPageName: d
						}))
					} else t(Object(r.e)({
						kind: E.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "2L5ytY"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: w(e)
					}))
				}, S = Object(a.a)(C.e), I = e => async (t, s, o) => {
					const a = await b(o.apiContext(), e);
					if (a.ok) {
						const s = a.body.status;
						t(S({
							revisionId: e.revisionId,
							isHidden: s
						}))
					} else t(Object(r.e)({
						kind: E.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "2gGq8w"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: w(e)
					}))
				}
		},
		"./src/reddit/components/AdLinkWrapper/index.m.less": function(e, t, s) {
			e.exports = {
				AdLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				adLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT"
			}
		},
		"./src/reddit/components/AdLinkWrapper/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/components/AdLinkWrapper/index.m.less"),
				o = s.n(n);
			const a = s("./src/lib/lessComponent.tsx").a.div("AdLinkWrapper", o.a);
			t.a = a
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less": function(e, t, s) {
			e.exports = {
				PrimaryButton: "_2MgVqpGJKTGicaQowt_R9h",
				primaryButton: "_2MgVqpGJKTGicaQowt_R9h"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/higherOrderComponents/asModal/index.tsx"),
				i = s("./src/lib/lessComponent.tsx"),
				d = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				l = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				c = s("./src/reddit/controls/Button/index.tsx"),
				m = s("./src/reddit/controls/TextButton/index.tsx"),
				u = s("./src/reddit/helpers/isValidUsername/index.tsx"),
				p = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				b = s("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less"),
				h = s.n(b);
			const g = i.a.wrapped(c.f, "PrimaryButton", h.a);
			class f extends a.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						e.onAddSubmitter(e.subredditId, t.username), e.sendEventWithName("add")(), e.toggleModal()
					}, this.state = {
						username: ""
					}
				}
				componentDidMount() {
					this.setState({
						username: this.props.username || ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(d.d, null, a.a.createElement(d.h, null, a.a.createElement(p.a, null, a.a.createElement(d.p, null, n.fbt._("Add approved user", null, {
						hk: "rVlIL"
					})), a.a.createElement(m.a, {
						onClick: e.toggleModal
					}, a.a.createElement(d.b, null)))), a.a.createElement(d.k, null, a.a.createElement(l.d, {
						placeholder: n.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: this.onInputChange,
						value: this.state.username,
						autoFocus: !0
					})), a.a.createElement(d.f, null, a.a.createElement(d.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, n.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(g, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !Object(u.a)(t.username)
					}, n.fbt._("Add user", null, {
						hk: "23A7cj"
					}))))
				}
			}
			t.a = Object(r.a)(f)
		},
		"./src/reddit/components/ApprovedSubmitterList/index.m.less": function(e, t, s) {
			e.exports = {
				PencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				pencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/lessComponent.tsx"),
				m = s("./src/lib/timeAgo/index.ts"),
				u = s("./src/reddit/actions/modal.ts"),
				p = s("./src/reddit/actions/subredditModeration.ts"),
				b = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				g = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				x = s("./src/reddit/components/Scroller/Simple.tsx"),
				E = s("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				v = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				C = s("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				_ = s("./src/reddit/controls/Button/index.tsx"),
				k = s("./src/reddit/icons/svgs/Pencil/index.tsx"),
				O = s("./src/reddit/models/SubredditModeration/index.ts"),
				y = s("./src/reddit/selectors/activeModalId.ts"),
				j = s("./src/reddit/selectors/subredditModeration.ts"),
				w = s("./src/reddit/contexts/PageLayer/index.tsx"),
				S = s("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx"),
				I = s("./src/reddit/components/ApprovedSubmitterList/index.m.less"),
				P = s.n(I);
			const T = 24,
				N = c.a.wrapped(k.a, "PencilIcon", P.a),
				M = Object(w.t)({
					username: e => Object(w.S)(e).user
				}),
				R = Object(d.c)({
					approvedSubmitters: j.e,
					approvedSubmittersListPending: j.a,
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(y.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(y.a)(e),
					loadMoreToken: j.b,
					searchPending: j.c,
					searchResult: j.d
				}),
				L = Object(i.b)(R, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						addSubmitter: (t, s) => e(Object(p.U)(t, s)),
						loadMore: t => e(Object(p.V)(s, {
							after: t
						})),
						removeSubmitter: (t, s) => e(Object(p.mb)(t, s)),
						searchForSubmitter: (t, s) => e(Object(p.W)(t, s)),
						toggleRemoveUserModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						toggleAddUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class A extends r.a.Component {
				constructor(e) {
					super(e), this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveUserModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeSubmitter(this.props.subredditId, this.state.userId)
					}, this.onSearch = e => {
						this.props.searchForSubmitter(this.props.subredditId, e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveSubmitter = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddUserModal()
					}, this.renderUser = e => r.a.createElement(C.b, {
						timeAgo: Object(m.d)(e.approvedAtUTC),
						pageName: l.Pb.Contributors,
						primaryButton: r.a.createElement("a", {
							href: "".concat(n.a.redditUrl, "/message/compose/?to=").concat(e.username),
							rel: "noopener noreferrer",
							target: "_blank"
						}, r.a.createElement(_.n, null, o.fbt._("Send message", null, {
							hk: "2bul7M"
						}))),
						secondaryButton: r.a.createElement(_.n, {
							onClick: () => this.handleRemoveToggled(e.id, e.username)
						}, o.fbt._("Remove", null, {
							hk: "40fFvl"
						})),
						subredditId: this.props.subredditId,
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderAddUserModal = () => r.a.createElement(S.a, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.props.addSubmitter,
						sendEventWithName: this.props.sendEventWithName,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: this.props.username,
						withOverlay: !0
					}), this.state = O.a
				}
				componentDidMount() {
					this.props.username && this.approveSubmitter()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = e.approvedSubmitters.length ? e.approvedSubmitters[e.approvedSubmitters.length - 1].id : void 0;
					return e.approvedSubmitters.length ? r.a.createElement(r.a.Fragment, null, r.a.createElement(f.c, null, r.a.createElement(_.f, {
						onClick: this.approveSubmitter
					}, o.fbt._("Approve user", null, {
						hk: "2v6FxN"
					}))), r.a.createElement(f.a, null, r.a.createElement(f.b, null, o.fbt._("Approved users", null, {
						hk: "1alMeD"
					}), r.a.createElement(g.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009164452")
					})), r.a.createElement(v.b, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), t.searchTerm ? r.a.createElement(E.a, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !e.searchResult,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm
					}, e.searchResult && this.renderUser(e.searchResult)) : r.a.createElement(x.b, {
						loadMoreToken: s,
						onLoadMore: this.onLoadMore
					}, e.approvedSubmitters.map((e, t) => ({
						estHeight: T,
						id: e.id,
						render: () => this.renderUser(e)
					})))), e.isAddUserModalOpen && this.renderAddUserModal(), e.isConfirmModalOpen && t.userId && t.username && r.a.createElement(b.a, {
						actionText: o.fbt._("Remove", null, {
							hk: "42TALr"
						}),
						modalText: o.fbt._("Are you sure you want to remove {username} as an approved user?", [o.fbt._param("username", t.username)], {
							hk: "4ELjHt"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: e.toggleRemoveUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(f.c, null, r.a.createElement(_.f, {
						onClick: this.approveSubmitter
					}, o.fbt._("Approve user", null, {
						hk: "1qX1LT"
					}))), r.a.createElement(f.a, null, r.a.createElement(f.b, null, o.fbt._("Approved users", null, {
						hk: "pxkv2"
					}), r.a.createElement(g.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009164452")
					})), e.approvedSubmittersListPending ? r.a.createElement(C.a, null) : r.a.createElement(h.c, {
						text: o.fbt._("No approved users in {subredditName}", [o.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1VEG1v"
						})
					}, r.a.createElement(N, null))), e.isAddUserModalOpen && this.renderAddUserModal())
				}
			}
			t.a = M(L(A))
		},
		"./src/reddit/components/BannedUserList/ExpandedComponent.m.less": function(e, t, s) {
			e.exports = {
				UnthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				unthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				BanReason: "SrZ1u3sJDzvdTgFW_XYZl",
				banReason: "SrZ1u3sJDzvdTgFW_XYZl",
				ExpandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				expandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				ModNote: "_3hA381rnksvJreaBfQTIC3",
				modNote: "_3hA381rnksvJreaBfQTIC3",
				ModNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				modNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				SectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				sectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				ContextContainer: "_1pqL5T1jpl-iWaJcvRftmU",
				contextContainer: "_1pqL5T1jpl-iWaJcvRftmU"
			}
		},
		"./src/reddit/components/BannedUserList/index.m.less": function(e, t, s) {
			e.exports = {
				BanIcon: "_1c2rKv1iuQylye8ejI6-1v",
				banIcon: "_1c2rKv1iuQylye8ejI6-1v"
			}
		},
		"./src/reddit/components/BannedUserList/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return J
			}));
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./node_modules/lodash/find.js"),
				m = s.n(c);
			const u = [{
				ms: l.Zb,
				unit: "years"
			}, {
				ms: l.eb,
				unit: "months"
			}, {
				ms: l.x,
				unit: "days"
			}, {
				ms: l.J,
				unit: "hours"
			}, {
				ms: l.db,
				unit: "minutes"
			}, {
				ms: l.Eb,
				unit: "seconds"
			}, {
				ms: 1,
				unit: "milliseconds"
			}];
			var p = s("./src/lib/lessComponent.tsx"),
				b = s("./src/lib/timeAgo/index.ts"),
				h = s("./src/reddit/actions/modal.ts"),
				g = s("./src/reddit/actions/subredditModeration.ts"),
				f = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				x = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				E = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				v = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				C = s("./src/reddit/components/Scroller/Simple.tsx"),
				_ = s("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				k = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				O = s("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				y = s("./src/reddit/controls/Button/index.tsx"),
				j = s("./src/reddit/icons/svgs/Ban/index.tsx"),
				w = s("./src/reddit/models/SubredditModeration/index.ts"),
				S = s("./src/reddit/selectors/activeModalId.ts"),
				I = s("./src/reddit/selectors/subredditModeration.ts"),
				P = s("./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx"),
				T = s("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				N = s("./src/reddit/components/CompactPost/index.tsx"),
				M = s("./src/reddit/contexts/PageLayer/index.tsx"),
				R = s("./src/reddit/components/BannedUserList/ExpandedComponent.m.less"),
				L = s.n(R);
			const A = Object(M.t)({
					currentProfileName: M.h,
					isCommentsPage: M.w,
					isCommentPermalink: M.v,
					isProfilePostListing: M.I,
					pageLayer: e => e
				}),
				F = p.a.wrapped(T.c, "UnthreadedComment", L.a),
				D = p.a.div("BanReason", L.a),
				B = p.a.div("ExpandedComponentContainer", L.a),
				U = p.a.div("ModNote", L.a),
				H = p.a.div("ModNoteContainer", L.a),
				W = p.a.div("SectionTitle", L.a),
				V = p.a.div("ContextContainer", L.a),
				q = e => () => {};
			var G = A(e => {
					const {
						currentProfileName: t,
						isCommentPermalink: s,
						isCommentsPage: n,
						isProfilePostListing: o,
						pageLayer: a,
						user: i
					} = e;
					return r.a.createElement(B, null, i.modNote && r.a.createElement(H, null, r.a.createElement(W, null, "Mod note:"), r.a.createElement(U, null, i.modNote)), r.a.createElement("div", null, r.a.createElement(W, null, "Banned For:"), r.a.createElement(D, null, i.reason), (i.postId || i.commentId) && r.a.createElement(V, null, i.postId && r.a.createElement(N.default, {
						currentProfileName: t,
						isCommentsPage: n,
						isCommentPermalink: s,
						isProfilePostListing: o,
						pageLayer: a,
						last: !0,
						postId: i.postId,
						hideModTools: !0,
						inSubredditOrProfile: !0
					}), i.commentId && r.a.createElement(F, {
						commentId: i.commentId,
						highlight: !1,
						trackClick: q
					}))))
				}),
				K = s("./src/reddit/components/BannedUserList/index.m.less"),
				z = s.n(K);
			const Q = 48,
				J = e => {
					if (null == e) return o.fbt._("Permanent", null, {
						hk: "3pNDzS"
					}); {
						const t = function(e) {
							const t = m()(u, t => e >= t.ms);
							return t ? {
								amount: Math.floor(e / t.ms),
								unit: t.unit
							} : {
								amount: 0,
								unit: "justNow"
							}
						}(864e5 * e);
						return o.fbt._({
							"*": "{number} days left",
							_1: "1 day left"
						}, [o.fbt._plural(t.amount, "number")], {
							hk: "3VM32a"
						})
					}
				},
				Z = e => {
					const t = Object(b.d)(e.bannedAtUTC),
						s = J(e.duration);
					return "".concat(t, " (").concat(s, ")")
				},
				X = p.a.wrapped(j.a, "BanIcon", z.a),
				Y = Object(d.c)({
					bannedUsers: I.m,
					bannedUsersList: I.i,
					bannedUsersListPending: I.h,
					loadMoreToken: I.j,
					isBanUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(S.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--BanUserConfirmation" === Object(S.a)(e),
					searchPending: I.k,
					searchResult: I.l
				}),
				$ = Object(i.b)(Y, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						loadMore: t => e(Object(g.Z)(s, {
							after: t
						})),
						onUnbanUser: t => () => e(Object(g.nb)(s, t)),
						searchForBannedUser: t => e(Object(g.ab)(s, t)),
						toggleBanUserModal: () => e(Object(h.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class ee extends r.a.Component {
				constructor(e) {
					super(e), this.handleBanUserToggled = e => {
						if (e) {
							const {
								id: t,
								username: s
							} = e;
							this.setState({
								userId: t,
								username: s
							})
						} else this.setState(Object.assign({}, w.a, {
							searchTerm: this.state.searchTerm
						}));
						this.props.isBanUserModalOpen || this.props.sendEventWithName(e ? "edit_user" : "ban_dialog_banpage")(), this.props.toggleBanUserModal()
					}, this.addBannedUser = () => this.handleBanUserToggled(null), this.onSearch = e => {
						this.props.searchForBannedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.renderBannedUser = e => {
						const t = this.props.bannedUsers[e] || this.props.searchResult;
						return t ? r.a.createElement(O.b, {
							description: t.reason,
							expandedComponent: r.a.createElement(G, {
								user: t
							}),
							pageName: l.Pb.Banned,
							primaryButton: r.a.createElement(y.n, {
								onClick: () => this.handleBanUserToggled(t),
								"data-redditstyle": !0
							}, o.fbt._("Edit", null, {
								hk: "1nftDt"
							})),
							subredditId: this.props.subredditId,
							timeAgo: Z(t),
							userIcon: t.accountIcon,
							username: t.username
						}) : r.a.createElement("div", null)
					}, this.renderAddBannedUserModal = () => r.a.createElement(P.a, {
						ignoreDefaultFocus: !0,
						onUnbanUser: this.state.userId ? this.props.onUnbanUser(this.state.userId) : void 0,
						subredditId: this.props.subredditId,
						toggleModal: () => this.handleBanUserToggled(null),
						trackAddEvent: this.props.sendEventWithName("add_banpage"),
						trackEventWithName: this.props.sendEventWithName,
						user: this.state.userId ? this.state.searchTerm ? this.props.searchResult || null : this.props.bannedUsers[this.state.userId] : null,
						withOverlay: !0
					}), this.state = w.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = e.bannedUsersList.length ? e.bannedUsersList[e.bannedUsersList.length - 1].id : void 0;
					return e.bannedUsersList.length ? r.a.createElement(r.a.Fragment, null, r.a.createElement(v.c, null, r.a.createElement(y.f, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, o.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), r.a.createElement(v.a, null, r.a.createElement(v.b, null, o.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), r.a.createElement(E.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), r.a.createElement(k.b, {
						onSearch: this.onSearch,
						activeSearchQuery: this.state.searchTerm
					}), t.searchTerm ? r.a.createElement(_.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderBannedUser(e.searchResult.id)) : r.a.createElement(C.b, {
						loadMoreToken: s,
						onLoadMore: this.onLoadMore
					}, e.bannedUsersList.map(e => ({
						estHeight: Q,
						id: e.id,
						render: () => this.renderBannedUser(e.id)
					})))), e.isBanUserModalOpen && this.renderAddBannedUserModal(), e.isConfirmModalOpen && t.userId && t.username && r.a.createElement(f.a, {
						actionText: o.fbt._("Remove", null, {
							hk: "Lczwm"
						}),
						modalText: o.fbt._("Are you sure you want to ban {username}?", [o.fbt._param("username", t.username)], {
							hk: "4f7Mkp"
						}),
						onConfirm: () => {},
						toggleModal: e.toggleBanUserModal,
						trackClick: e.sendEventWithName("remove")
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(v.c, null, r.a.createElement(y.f, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, " ", o.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), r.a.createElement(v.a, null, r.a.createElement(v.b, null, o.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), r.a.createElement(E.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), e.bannedUsersListPending ? r.a.createElement(O.a, null) : r.a.createElement(x.c, {
						text: o.fbt._("No banned users in {subredditName}", [o.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1nOcbC"
						})
					}, r.a.createElement(X, null))), e.isBanUserModalOpen && this.renderAddBannedUserModal())
				}
			}
			t.a = $(ee)
		},
		"./src/reddit/components/CallToActionButton/index.m.less": function(e, t, s) {
			e.exports = {
				CallToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				callToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				mNotCardView: "_33VrFkg3gJpkL8AlPfcHUE"
			}
		},
		"./src/reddit/components/CallToActionButton/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				i = s("./src/reddit/components/CallToActionButton/index.m.less"),
				d = s.n(i);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var c = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			t.a = e => {
				var {
					className: t
				} = e, s = c(e, ["className"]);
				return o.a.createElement(r.a, l({
					className: Object(a.a)(t, d.a.CallToActionButton, {
						[d.a.mNotCardView]: s.isNotCardView
					})
				}, s))
			}
		},
		"./src/reddit/components/CharacterCountdown/index.m.less": function(e, t, s) {
			e.exports = {
				container: "s5ap8yh1b4ZfwxvHizW3f",
				mOverflow: "_19JhaP1slDQqu2XgT3vVS0"
			}
		},
		"./src/reddit/components/CharacterCountdown/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				i = s("./src/reddit/components/CharacterCountdown/index.m.less"),
				d = s.n(i);
			const {
				fbt: l
			} = s("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => o.a.createElement(r.b, {
				className: Object(a.a)(e.className, d.a.container, e.text.length > e.maxChars ? d.a.mOverflow : null)
			}, l._({
				"*": "{characters} Characters remaining",
				_1: "1 Character remaining"
			}, [l._plural(e.maxChars - e.text.length, "characters")], {
				hk: "V22sW"
			}))
		},
		"./src/reddit/components/ChatButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./src/reddit/actions/chat/toggle.ts"),
				i = s("./src/reddit/components/TrackingHelper/index.tsx"),
				d = s("./src/reddit/controls/Button/index.tsx"),
				l = s("./src/reddit/helpers/trackers/authorHovercard.ts");
			const c = e => {
				let {
					onStartChat: t,
					children: s,
					className: n,
					sendEvent: a,
					contextId: r
				} = e;
				return o.a.createElement(d.f, {
					onClick: () => {
						t(), a(Object(l.b)(r))
					},
					className: n
				}, s)
			};
			c.displayName = "ChatButton";
			const m = Object(a.b)(null, (e, t) => {
				let {
					contextId: s,
					userId: n
				} = t;
				return {
					onStartChat: () => {
						e(Object(r.a)(n, s))
					}
				}
			});
			t.a = m(Object(i.c)(c))
		},
		"./src/reddit/components/ClassicPost/Placeholder.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return C
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/components/PostLeftRail/index.tsx"),
				l = s("./src/reddit/components/VerticalVotes/votes.tsx"),
				c = s("./src/reddit/contexts/PageLayer/index.tsx"),
				m = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				u = s("./src/reddit/models/Vote/index.ts"),
				p = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				b = s.n(p),
				h = s("./src/reddit/components/ClassicPost/placeholder.m.less"),
				g = s.n(h);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const x = Object(c.t)(),
				E = Object(r.c)({
					isFakeSubreddit: c.x
				}),
				v = Object(a.b)(E),
				C = e => {
					const t = {
						interactive: !1,
						voteState: u.a.notVoted
					};
					return o.a.createElement("div", {
						className: Object(i.a)(e.className, g.a.emptyVerticalVotes)
					}, o.a.createElement(l.d, f({
						key: "u"
					}, t)), e.children, o.a.createElement(l.c, f({
						key: "d"
					}, t)))
				},
				_ = () => o.a.createElement(C, null, o.a.createElement("div", {
					className: g.a.emptyScore,
					key: "s"
				}));
			t.b = x(v(e => o.a.createElement("div", {
				className: Object(i.a)(e.className, b.a.classicPostStyles, b.a.classicAndCompactPlaceholderStyles)
			}, o.a.createElement(d.b, null, o.a.createElement(_, null)), o.a.createElement("div", {
				className: g.a.mainBody
			}, o.a.createElement("div", {
				className: g.a.thumbnailContainer
			}, o.a.createElement("div", {
				className: Object(i.a)(g.a.thumbnail, Object(m.b)(e))
			})), o.a.createElement("div", {
				className: g.a.content
			}, o.a.createElement("div", {
				key: "a"
			}, o.a.createElement("div", {
				key: "aa",
				className: Object(i.a)(g.a.title, Object(m.b)(e))
			}), o.a.createElement("div", {
				key: "ab",
				className: Object(i.a)(g.a.meta, Object(m.b)(e))
			})), o.a.createElement("div", {
				key: "f",
				className: g.a.flatlist
			}, o.a.createElement("div", {
				key: "fa",
				className: Object(i.a)(g.a.flatlistExpando, Object(m.b)(e))
			}), o.a.createElement("div", {
				key: "fb",
				className: g.a.flatlistSeparator
			}), o.a.createElement("div", {
				key: "fc",
				className: Object(i.a)(g.a.flatListItemOne, Object(m.b)(e))
			}), o.a.createElement("div", {
				key: "fd",
				className: Object(i.a)(g.a.flatListItemTwo, Object(m.b)(e))
			})))))))
		},
		"./src/reddit/components/ClassicPost/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "renderMedia", (function() {
				return W
			})), s.d(t, "SearchResultsClassicPost", (function() {
				return G
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/config.ts"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = s("./src/lib/getShortenedLink.ts"),
				l = s("./src/reddit/components/AdLinkWrapper/index.tsx"),
				c = s("./src/reddit/components/CallToActionButton/index.tsx"),
				m = s("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				u = s("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				p = s("./src/reddit/components/ExpandoButton/index.tsx"),
				b = s("./src/reddit/components/Flatlist/index.tsx"),
				h = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				g = s("./src/reddit/components/ModModeReports/index.tsx"),
				f = s("./src/reddit/components/ModModeReports/helpers.ts"),
				x = s("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				E = s("./src/reddit/components/PostContainer/index.tsx"),
				v = s("./src/reddit/components/PostMedia/index.tsx"),
				C = s("./src/reddit/components/PostMeta/index.tsx"),
				_ = s("./src/reddit/components/PostOverflowMenu/index.tsx"),
				k = s("./src/reddit/components/PostRailAndVotes/index.tsx"),
				O = s("./src/reddit/components/PostTitle/index.tsx"),
				y = s("./src/reddit/components/PostTopMeta/index.tsx"),
				j = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				w = s("./src/reddit/models/Media/index.ts"),
				S = s("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				I = s("./src/reddit/connectors/ClassicPost/index.tsx"),
				P = s("./src/reddit/connectors/ClassicPost/searchResults.tsx"),
				T = s("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				N = s("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				M = s("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				R = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				L = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				A = s.n(L),
				F = s("./src/reddit/components/ClassicPost/index.m.less"),
				D = s.n(F);

			function B() {
				return (B = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const U = 16;
			class H extends o.a.Component {
				componentDidUpdate(e) {
					this.props.onSizeChanged && e.isExpanded !== this.props.isExpanded && this.props.onSizeChanged(this.props.post.id)
				}
				render() {
					const {
						className: e,
						currentUser: t,
						handleVote: s,
						isExpanded: n,
						isMeta: i,
						inSubredditOrProfile: v,
						eventFactory: I,
						first: P,
						flairStyleTemplate: L,
						formatTitle: F,
						isCheckboxSelected: H,
						isCurrentUserProfilePost: V,
						isFrontpage: q,
						isLoggedIn: G,
						isOverlay: K,
						moderatorPermissions: z,
						modModeEnabled: Q,
						onClickPost: J,
						onIgnoreReports: Z,
						onOpenReportsDropdown: X,
						poll: Y,
						post: $,
						redditStyle: ee,
						scrollerItemRef: te,
						showBulkActionCheckbox: se,
						showEditFlair: ne,
						showMedia: oe,
						subredditOrProfile: ae,
						toggleCheckbox: re,
						userIsOp: ie
					} = this.props, de = ee ? void 0 : L, le = this.props.crosspost || void 0, ce = Object(M.a)(z), me = Object(T.a)(z), ue = Object(N.a)(z), pe = Q && M.a, be = !!$.media && $.media.type === w.n.RTJSON, he = ie && be, ge = v && !oe, fe = !!$.media && Object(w.B)($.media), xe = {
						flairStyleTemplate: de,
						post: $,
						inSubredditOrProfile: v,
						isCurrentUserProfilePost: V,
						isOverlay: K,
						shouldShowSubscribeButton: !(q && G),
						subredditOrProfile: ae
					}, Ee = o.a.createElement(E.a, {
						className: Object(r.a)(A.a.classicPostStyles, D.a.postContainer, Object(R.a)(this.props), P ? D.a.mFirst : void 0, e),
						isOverlay: K,
						style: Object.assign({}, Object(R.d)(this.props), Object(R.b)(this.props.flairStyleTemplate)),
						post: $,
						onClick: J,
						eventFactory: I
					}, o.a.createElement(k.a, {
						model: $,
						handleVote: s,
						showBulkActionCheckbox: se,
						isCheckboxSelected: H,
						toggleCheckbox: re,
						flairStyleTemplate: de,
						redditStyle: ee,
						subreddit: ae
					}), o.a.createElement(x.a, {
						"data-click-id": "background",
						flairStyleTemplate: de
					}, o.a.createElement(u.a, {
						className: D.a.eventMeta,
						post: $
					}), o.a.createElement("div", {
						className: D.a.mainBody
					}, o.a.createElement("div", {
						className: ge ? D.a.expandoContainer : D.a.thumbnailContainer
					}, !ge && o.a.createElement(S.a, {
						className: D.a.classicThumbnail,
						crosspost: le && $,
						isMeta: i,
						post: le || $,
						redditStyle: ee,
						templatePlaceholderImage: de && de.postPlaceholderImage,
						removeLink: fe
					}), o.a.createElement(p.a, {
						crosspost: le,
						className: D.a.rightExpando,
						isExpanded: !!n,
						post: $,
						useMediaIcons: !1
					})), o.a.createElement("div", {
						className: D.a.content,
						"data-click-id": "body",
						style: {
							paddingBottom: "".concat(U, "px")
						}
					}, o.a.createElement(O.c, {
						className: Y ? D.a.titleWithPoll : void 0,
						format: F,
						poll: Y,
						post: $,
						redditStyle: ee,
						size: O.b.Medium,
						titleColor: de && de.postTitleColor,
						isOverlay: K
					}, $.source && !le && o.a.createElement(j.a, {
						href: $.source.url,
						isSponsored: $.isSponsored,
						postId: $.id,
						source: $.source
					}, Object(d.a)($))), o.a.createElement(C.a, B({
						key: "PostMeta"
					}, xe)), Q && ce && Object(f.c)($) && o.a.createElement(g.a, {
						onIgnoreReports: Z,
						reportable: $
					}), o.a.createElement("div", {
						className: D.a.spacer
					}), $.source && $.source.url && $.isSponsored && o.a.createElement(l.a, {
						className: D.a.adLinkWrapper
					}, o.a.createElement(j.a, {
						href: $.source.url.replace(a.a.redditUrl, ""),
						isSponsored: $.isSponsored,
						postId: $.id,
						source: $.source
					}, $.source.displayText), $.callToAction && o.a.createElement(c.a, {
						href: $.source.url.replace(a.a.redditUrl, ""),
						isSponsored: $.isSponsored,
						postId: $.id,
						source: $.source
					}, $.callToAction)), o.a.createElement("div", {
						className: D.a.flatlistContainer
					}, o.a.createElement(p.a, {
						className: D.a.leftExpando,
						crosspost: le,
						isExpanded: !!n,
						post: $,
						useMediaIcons: !1
					}), o.a.createElement(m.a, {
						className: D.a.horizontalVotes,
						compact: !1,
						flairStyleTemplate: de,
						model: $,
						onVoteClick: s
					}), o.a.createElement(b.a, {
						className: D.a.flatlistSeparator
					}), o.a.createElement(b.c, {
						className: D.a.flatlist,
						currentUser: t,
						hasModFlairPerms: me,
						hasModPostPerms: ce,
						hasModFullPerms: ue,
						isOverlay: !!K,
						modModeEnabled: Q,
						onIgnoreReports: Z,
						onOpenReportsDropdown: X,
						post: $,
						showEditPost: he,
						showEditFlair: ne,
						tooltipType: K ? y.c.Lightbox : void 0,
						useFlatlistBreakpoints: Object(_.h)({
							editPost: !pe,
							save: !pe,
							hide: !pe,
							report: !pe
						})
					})), o.a.createElement(h.d, {
						postId: $.id
					}))), W($, te, n)));
					return o.a.createElement(o.a.Fragment, null, Ee)
				}
			}
			const W = (e, t, s) => s ? e.crosspostRootId ? o.a.createElement("div", {
					className: D.a.crosspostMediaWrapper
				}, V(e, t)) : V(e, t) : null,
				V = (e, t) => o.a.createElement(v.a, {
					isExpando: !0,
					isListing: !0,
					isNotCardView: !0,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					showFull: !0,
					showCentered: !0,
					post: e
				}),
				q = Object(i.a)(H),
				G = Object(P.a)(q);
			t.default = Object(I.a)(q)
		},
		"./src/reddit/components/ClassicPost/placeholder.m.less": function(e, t, s) {
			e.exports = {
				thumbnailContainer: "_3cwq18vPueuAxRSrd1foNB",
				mainBody: "_1jxw1P65tWXN5u8kVHlX-n",
				content: "_2KR7fLQx_7rIv8QaoeXKZw",
				emptyScore: "_6w7aNMh3t6UMe07Q6oWFE",
				emptyVerticalVotes: "_1Xs9oeessHWcuF0VTVxRnl",
				thumbnail: "_2XOZ5bYpLdswvBAYUNa-ly",
				title: "n3AVRrP7HOfc0gAtGFpfv",
				meta: "_1BoNlCqTsaeLXkuZbADxyl",
				flatlist: "_1IgQuZI8L6A0NcShWmf08y",
				flatlistExpando: "_2AMaFX8Gwojg29X4_nOnaL",
				flatlistSeparator: "oljBm1Q059l3l84VHO9VM",
				flatListItemOne: "_2xeK0Acj_38O5kqiHgp7VC",
				flatListItemTwo: "_3WphuhFsMSKk2tQyD3fZeI"
			}
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less": function(e, t, s) {
			e.exports = {
				DistinguishShield: "_3cuXnOdiXHbT8t5tAaGgKr",
				distinguishShield: "_3cuXnOdiXHbT8t5tAaGgKr",
				RestrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				restrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				Approve: "_19WnAmcAChJM1wTzSOV1p2",
				approve: "_19WnAmcAChJM1wTzSOV1p2",
				Lock: "_1-s5lNmDynkeEE7Z0x-t6q",
				lock: "_1-s5lNmDynkeEE7Z0x-t6q",
				Remove: "_1TzXdATrX8P6QZjY89r6Ln",
				remove: "_1TzXdATrX8P6QZjY89r6Ln",
				Show: "YoaDbMbI8PpFFWQbD_Uwq",
				show: "YoaDbMbI8PpFFWQbD_Uwq",
				Spam: "_2rc9zwviU90yoF6FCv5jvs",
				spam: "_2rc9zwviU90yoF6FCv5jvs",
				CommentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk",
				commentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk"
			}
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return A
			})), s.d(t, "a", (function() {
				return W
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/lessComponent.tsx"),
				m = s("./src/reddit/actions/comment/index.ts"),
				u = s("./src/reddit/actions/tooltip.ts"),
				p = s("./src/reddit/components/DistinguishCommentDropdown/index.tsx"),
				b = s("./src/reddit/components/ModModeReports/helpers.ts"),
				h = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				g = s("./src/reddit/components/TrackingHelper/index.tsx"),
				f = s("./src/reddit/contexts/PageLayer/index.tsx"),
				x = s("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				E = s("./src/reddit/helpers/trackers/modTools.ts"),
				v = s("./src/reddit/selectors/moderatingComments.ts"),
				C = s("./src/reddit/selectors/moderatorPermissions.ts"),
				_ = s("./src/reddit/selectors/tooltip.ts"),
				k = s("./src/reddit/selectors/user.ts"),
				O = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				y = s("./src/reddit/icons/fonts/helpers.tsx"),
				j = s("./src/reddit/icons/fonts/DistinguishShield/index.m.less"),
				w = s.n(j);
			var S = c.a.wrapped(e => a.a.createElement("i", {
					className: "".concat(Object(y.b)("distinguishShield"), " ").concat(e.className)
				}), "DistinguishShield", w.a),
				I = s("./src/reddit/icons/fonts/Lock/index.tsx"),
				P = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				T = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				N = s("./src/reddit/icons/svgs/Show/index.tsx"),
				M = s("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				R = s.n(M),
				L = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const A = c.a.wrapped(h.c, "RestrictedButton", R.a),
				F = c.a.wrapped(O.a, "Approve", R.a),
				D = c.a.wrapped(I.a, "Lock", R.a),
				B = c.a.wrapped(P.a, "Remove", R.a),
				U = c.a.wrapped(T.a, "Spam", R.a),
				H = c.a.wrapped(N.a, "Show", R.a),
				W = c.a.wrapped(S, "DistinguishShield", R.a),
				V = Object(f.t)(),
				q = e => "Distinguish--Dropdown--".concat(e),
				G = Object(i.c)({
					currentUser: k.i,
					collapsedBecauseCrowdControl: (e, t) => {
						let {
							comment: s
						} = t;
						return Object(v.a)(e, {
							commentId: s.id
						})
					},
					isDistinguishDropdownOpen: (e, t) => {
						let {
							comment: s
						} = t;
						return Object(_.b)(q(s.id))(e)
					},
					moderatorPermissions: (e, t) => {
						const {
							comment: s
						} = t;
						return Object(f.g)(e, t) || Object(C.j)(e, {
							subredditId: s.subredditId
						})
					},
					modModeEnabled: f.P
				}),
				K = Object(r.b)(G, (e, t) => {
					let {
						comment: s
					} = t;
					return {
						onApproveComment: () => e(Object(m.H)(s.id)),
						onDistinguishComment: (t, n) => e(Object(m.S)(s.id, t, n)),
						onLockComment: () => e(Object(m.X)(s.id)),
						onRemoveComment: () => e(Object(m.cb)(s.id, !1)),
						onSpamComment: () => e(Object(m.cb)(s.id, !0)),
						onShowComment: () => e(Object(m.Y)(s.id)),
						onToggleDistinguishDropdown: () => e(Object(u.h)({
							tooltipId: q(s.id)
						}))
					}
				});
			t.c = V(K(c.a.wrapped(Object(g.c)(e => {
				var {
					className: t,
					comment: s,
					currentUser: o,
					isCommentAuthor: r,
					collapsedBecauseCrowdControl: i,
					moderatorPermissions: c,
					modModeEnabled: m,
					onApproveComment: u,
					onDistinguishComment: h,
					onLockComment: g,
					onRemoveComment: f,
					onShowComment: v,
					onSpamComment: C,
					onToggleDistinguishDropdown: _,
					sendEvent: k
				} = e, O = L(e, ["className", "comment", "currentUser", "isCommentAuthor", "collapsedBecauseCrowdControl", "moderatorPermissions", "modModeEnabled", "onApproveComment", "onDistinguishComment", "onLockComment", "onRemoveComment", "onShowComment", "onSpamComment", "onToggleDistinguishDropdown", "sendEvent"]);
				const y = Object(x.a)(c),
					j = Object(b.b)(s),
					w = s.isApproved && j,
					S = !!o && o.isEmployee,
					I = !s.isRemoved,
					P = i,
					T = e => k(Object(E.a)(e, s.id));
				return a.a.createElement("div", {
					className: t
				}, (s.bannedBy || j) && a.a.createElement(A, {
					text: w ? n.fbt._("Reapprove", null, {
						hk: "1XngBU"
					}) : n.fbt._("Approve", null, {
						hk: "2219Nh"
					}),
					onClick: () => {
						u(), T("approve")
					}
				}, a.a.createElement(F, null)), I && a.a.createElement(a.a.Fragment, null, a.a.createElement(A, {
					text: s.bannedBy === l.k ? n.fbt._("Confirm Removal", null, {
						hk: "3JozXJ"
					}) : n.fbt._("Remove", null, {
						hk: "VP5J0"
					}),
					onClick: () => {
						f(), s.bannedBy === l.k ? T("confirm_remove") : T("remove")
					}
				}, a.a.createElement(B, null)), a.a.createElement(A, {
					text: n.fbt._("Spam", null, {
						hk: "1jEVwZ"
					}),
					onClick: () => {
						C(), T("spam")
					}
				}, a.a.createElement(U, null))), a.a.createElement(A, {
					text: s.isLocked ? n.fbt._("Unlock", null, {
						hk: "KGYeO"
					}) : n.fbt._("Lock", null, {
						hk: "3rDzwU"
					}),
					onClick: () => {
						g(), T(s.isLocked ? "unlock" : "lock")
					}
				}, a.a.createElement(D, null)), r && !S && !s.bannedBy && a.a.createElement(A, {
					className: Object(d.a)({
						[R.a.selected]: O.isDistinguishDropdownOpen
					}),
					onClick: () => {
						T("mod_distinguish_menu"), _()
					}
				}, a.a.createElement(W, null), a.a.createElement(p.a, {
					isAdminDistinguished: s.isAdmin,
					isDropdownOpen: O.isDistinguishDropdownOpen,
					isModDistinguished: s.isMod,
					isStickied: s.isStickied,
					isTopLevelComment: !s.parentId,
					isUserEmployee: S,
					isUserMod: y,
					onDistinguishComment: h,
					sendEventWithName: T,
					tooltipId: q(s.id)
				})), P && a.a.createElement(A, {
					text: n.fbt._("Show Comment", null, {
						hk: "2ki02n"
					}),
					onClick: () => {
						v()
					}
				}, a.a.createElement(H, null)))
			}), "CommentModToolsFlatlist", R.a)))
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.m.less": function(e, t, s) {
			e.exports = {
				CommentAuthorLink: "f3THgbzMYccGW8vbqZBUH",
				commentAuthorLink: "f3THgbzMYccGW8vbqZBUH",
				badgeIconStyle: "_2MlVoXUc3Eo3KGWDukM9xn",
				modBadgeIconStyle: "_1kqPGnOAdnd9gPUXDU2_AS",
				DonationAmount: "_3sY3k4LLYR5dbXRxnGkhwG",
				donationAmount: "_3sY3k4LLYR5dbXRxnGkhwG",
				RightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				rightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				EditedText: "uMVXpG5M2xxHNW2g94S8K",
				editedText: "uMVXpG5M2xxHNW2g94S8K",
				MetaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				metaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				publicPoints: "_2LXcsgibmlCEsBPk8MLy7e",
				AuthorHoverCard: "_16AAktgl_rVbXAeiWU9CQd",
				authorHoverCard: "_16AAktgl_rVbXAeiWU9CQd",
				Component: "_36uQqfCEixcb8d3_aWB5H6",
				component: "_36uQqfCEixcb8d3_aWB5H6",
				AdminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				adminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				Approve: "_34mJxMS9sOCTo8dtFMQOLR",
				approve: "_34mJxMS9sOCTo8dtFMQOLR",
				Lock: "_3ATarJMtY0XRI9Lgu7e7DC",
				lock: "_3ATarJMtY0XRI9Lgu7e7DC",
				AdminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				adminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				Automoderator: "EytgzUMjj1jcbKtFsodey",
				automoderator: "EytgzUMjj1jcbKtFsodey",
				removed: "_2jIbl66ymb_twdJlZslQ-e",
				CakeIcon: "_1HLCDx7CkNvQgmNroGXenu",
				cakeIcon: "_1HLCDx7CkNvQgmNroGXenu",
				Moderator: "_174Mk1p6pYIrr6f1y6b4fn",
				moderator: "_174Mk1p6pYIrr6f1y6b4fn",
				Remove: "_1DQWCB93pHPVVJCXOGsblO",
				remove: "_1DQWCB93pHPVVJCXOGsblO",
				Report: "_2wYWDvjfG1JR6VNK9ryPFk",
				report: "_2wYWDvjfG1JR6VNK9ryPFk",
				Spam: "_3kK86gdpll9ihjOPWJE6f2",
				spam: "_3kK86gdpll9ihjOPWJE6f2",
				Op: "_2pZswNTz_uW46hN02djL7j",
				op: "_2pZswNTz_uW46hN02djL7j",
				Contractor: "_1hbZy7yehvtj0w4ec-2u3Y",
				contractor: "_1hbZy7yehvtj0w4ec-2u3Y",
				redditorIcon: "_2SkK42s487b14gsRa4zinm",
				MetaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				metaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				StickiedText: "_1eNQE7Kj1TEqCLAn1BUKJy",
				stickiedText: "_1eNQE7Kj1TEqCLAn1BUKJy",
				DeletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				deletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				RemovalReason: "Gtgj2P-Js5aSN72H6Mqms",
				removalReason: "Gtgj2P-Js5aSN72H6Mqms",
				container: "_3ezOJqKdLbgkHsXcfvS5SA",
				collapsed: "_2k27lgIDltx9kOzVGXt48i",
				hasBadges: "_1KMFaeLEhRikeFEOlWE9Ti",
				liveStreaming: "_1iUed95f0HTc84gBtoOxdc",
				CrowdControlText: "Eoj3NCGwtl7hQcr7Rnc0N",
				crowdControlText: "Eoj3NCGwtl7hQcr7Rnc0N",
				metaText: "_3_GZIIN1xcMEC5AVuv4kfa"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/tooltip.ts"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/constants/index.ts"),
				m = s("./src/lib/humanizeDateTime/index.ts"),
				u = s("./src/lib/lessComponent.tsx"),
				p = s("./src/lib/timeAgo/index.ts"),
				b = s("./src/reddit/components/AuthorLink/index.tsx"),
				h = s("./src/reddit/components/AwardBadges/index.tsx"),
				g = s("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx"),
				f = s("./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx"),
				x = s("./src/reddit/components/Economics/Support/DonationAmount/async.tsx"),
				E = s("./src/reddit/featureFlags/index.ts"),
				v = s("./src/reddit/selectors/economics.ts"),
				C = s("./src/reddit/components/Economics/TopTippers/Icon/index.tsx"),
				_ = s("./src/reddit/components/Economics/TopTippers/CommentUsername/index.m.less"),
				k = s.n(_);
			const O = e => {
				switch (e) {
					case 1:
						return {
							color: "#FF2500", fontWeight: 700
						};
					case 2:
						return {
							color: "#FF7300", fontWeight: 700
						};
					case 3:
						return {
							color: "#FFA200", fontWeight: 700
						};
					default:
						return {}
				}
			};
			var y = Object(r.b)(() => Object(i.c)({
					post: (e, t) => {
						let {
							contentId: s
						} = t;
						return e.posts.models[s]
					},
					tippers: (e, t) => {
						if (E.d.spTopTippers(e)) return Object(v.y)(e, t)
					}
				}))((function(e) {
					if (e.tippers && e.tippers.allTippers.has(e.userId)) {
						const t = e.tippers.topTippers.ranking[e.userId] || 5,
							s = a.a.cloneElement(a.a.Children.only(e.children), {
								style: O(t)
							});
						return a.a.createElement("div", {
							className: k.a.container
						}, a.a.createElement(C.a, {
							className: k.a.badge,
							creatorId: e.creatorId || e.post && e.post.authorId,
							rank: t,
							subredditId: e.subredditId
						}), s)
					}
					return e.children
				})),
				j = s("./src/reddit/components/Flair/index.tsx"),
				w = s("./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx"),
				S = s("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				I = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				P = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				T = s("./src/reddit/components/PostTopMeta/index.tsx"),
				N = s("./src/reddit/helpers/isRemoved.ts"),
				M = s("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				R = s("./src/reddit/helpers/showReportIndicator/index.ts"),
				L = s("./src/reddit/actions/comment/index.ts"),
				A = s("./src/reddit/models/Comment/index.ts"),
				F = s("./src/reddit/models/Flair/index.ts"),
				D = s("./src/reddit/icons/fonts/Admin/index.tsx"),
				B = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				U = s("./src/reddit/icons/fonts/Lock/index.tsx"),
				H = s("./src/reddit/icons/fonts/helpers.tsx"),
				W = s("./src/reddit/icons/fonts/Op/index.m.less"),
				V = s.n(W);
			var q = u.a.wrapped(e => a.a.createElement("i", {
					className: "".concat(Object(H.b)("op"), " ").concat(e.className),
					id: e.id,
					onMouseEnter: e.onMouseEnter,
					onMouseLeave: e.onMouseLeave
				}, a.a.createElement(H.a, null, e.desc)), "OpIcon", V.a),
				G = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				K = s("./src/reddit/icons/fonts/Report/index.tsx"),
				z = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				Q = s("./src/reddit/icons/svgs/Automoderator/index.tsx"),
				J = s("./src/reddit/icons/svgs/Cake/index.tsx"),
				Z = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				X = s("./src/reddit/controls/MetaData/index.tsx"),
				Y = s("./src/reddit/selectors/subreddit.ts"),
				$ = s("./src/reddit/selectors/userFlair.ts"),
				ee = s("./src/reddit/components/Comments/Comment/TopMeta/index.m.less"),
				te = s.n(ee);

			function se() {
				return (se = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var ne = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const oe = u.a.wrapped(j.b, "RightPositionedAuthorFlair", te.a),
				ae = u.a.wrapped(D.a, "AdminIcon", te.a),
				re = u.a.wrapped(B.a, "Approve", te.a),
				ie = u.a.wrapped(U.a, "Lock", te.a),
				de = u.a.div("AdminEmeritus", te.a),
				le = u.a.wrapped(Q.a, "Automoderator", te.a),
				ce = u.a.wrapped(J.a, "CakeIcon", te.a),
				me = u.a.wrapped(Z.a, "Moderator", te.a),
				ue = u.a.wrapped(G.a, "Remove", te.a),
				pe = u.a.wrapped(K.a, "Report", te.a),
				be = u.a.wrapped(z.a, "Spam", te.a),
				he = u.a.wrapped(q, "Op", te.a),
				ge = u.a.wrapped(D.a, "Contractor", te.a),
				fe = u.a.a("MetaLink", te.a),
				xe = u.a.wrapped(X.a, "EditedText", te.a),
				Ee = u.a.wrapped(X.a, "StickiedText", te.a),
				ve = u.a.span("DeletedText", te.a),
				Ce = u.a.wrapped(X.a, "MetaSeparator", te.a),
				_e = u.a.wrapped(X.a, "CrowdControlText", te.a),
				ke = u.a.wrapped(S.b, "AuthorHoverCard", te.a),
				Oe = u.a.a("RemovalReason", te.a),
				ye = u.a.wrapped(g.b, "Component", te.a),
				je = e => (t, s) => {
					let {
						comment: n,
						renderedInOverlay: o
					} = s;
					return "".concat(e).concat(n.id).concat(o ? "inOverlay" : "")
				},
				we = () => n.fbt._("Reddit admin, speaking officially", null, {
					hk: "3vg8wE"
				}),
				Se = () => n.fbt._("Cake day", null, {
					hk: "1xptSi"
				}),
				Ie = () => n.fbt._("Reddit admin emeritus", null, {
					hk: "1Md5AV"
				}),
				Pe = e => n.fbt._("Moderator of {subredditDisplayText}, speaking officially", [n.fbt._param("subredditDisplayText", e)], {
					hk: "3pHm3n"
				}),
				Te = () => n.fbt._("Original Poster", null, {
					hk: "3DqK8z"
				}),
				Ne = () => n.fbt._("Reddit contractor", null, {
					hk: "3APwEh"
				}),
				Me = Object(r.b)(() => Object(i.c)({
					adminTooltipId: je("CommentTopMeta--Admin--"),
					cakedayTooltipId: je("CommentTopMeta--cakeday--"),
					adminEmeritusTooltipId: je("CommentTopMeta--AdEm--"),
					automodTooltipId: je("CommentTopMeta--Automod--"),
					approveTooltipId: je("CommentTopMeta--Approve--"),
					createdTooltipId: je("CommentTopMeta--Created--"),
					contractorTooltipId: je("CommentTopMeta--Contractor--"),
					gildedTooltipId: je("CommentTopMeta--Gold--"),
					lockedTooltipId: je("CommentTopMeta--Locked--"),
					modTooltipId: je("CommentTopMeta--Mod--"),
					opTooltipId: je("CommentTopMeta--OP--"),
					removeTooltipId: je("CommentTopMeta--Remove--"),
					reportTooltipId: je("CommentTopMeta--Report--"),
					spamTooltipId: je("CommentTopMeta--Spam--"),
					hasBadges: (e, t) => {
						let {
							comment: s
						} = t;
						return !!Object(v.w)(e, s.subredditId, s.authorId).length
					},
					subredditDisplayText: (e, t) => {
						const s = Object(Y.I)(e, {
							commentId: t.comment.id
						});
						return s ? s.displayText : ""
					},
					topTippersEnabled: E.d.spTopTippers,
					flairPosition: (e, t) => {
						let {
							comment: s
						} = t;
						return Object($.d)(e, {
							subredditId: s.subredditId
						})
					}
				}), (e, t) => ({
					onCreatedClick: () => {
						window.addEventListener("focus", (function s() {
							((e, t, s) => {
								window.removeEventListener("focus", s), e(Object(L.N)({
									commentListNodeId: t
								})), window.setTimeout(() => e(Object(L.N)({
									commentListNodeId: t
								})), 5e3)
							})(e, t.comment.id, s)
						}))
					},
					onHideTooltip: () => e(Object(d.i)()),
					onShowTooltip: t => e(Object(d.f)({
						tooltipId: t
					})),
					openRemovalReasonModal: () => {
						s.e("removalReasonActions").then(s.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(s => e(s.fetchReasonsAndOpenModal(t.comment.subredditId, [t.comment.id])))
					}
				}));
			t.a = Me(e => {
				const {
					adminEmeritusTooltipId: t,
					adminTooltipId: s,
					approveTooltipId: n,
					automodTooltipId: o,
					cakedayTooltipId: r,
					children: i,
					className: d,
					collapsed: m,
					collapsedBecauseCrowdControl: u,
					comment: p,
					commentsPageKey: b,
					contractorTooltipId: g,
					compact: E,
					flair: v,
					flairPosition: C,
					hasBadges: _,
					isAvatarsInCommentsEnabled: k,
					isLivestreaming: O,
					ignoreFlairPosition: y,
					ignoreLock: S,
					lockedTooltipId: I,
					modTooltipId: N,
					onHideTooltip: M,
					onShowTooltip: R,
					opTooltipId: L,
					openRemovalReasonModal: D,
					removeTooltipId: B,
					renderContractorBadge: U,
					renderedInOverlay: H,
					reportTooltipId: W,
					spamTooltipId: V,
					subredditDisplayText: q,
					topTippersEnabled: G
				} = e;
				if (p.isDeleted) return a.a.createElement(Re, se({}, e, {
					className: Object(l.a)(d, te.a.container, {
						[te.a.collapsed]: m
					})
				}));
				if (m) return a.a.createElement(Le, se({}, e, {
					className: Object(l.a)(d, te.a.container, {
						[te.a.collapsed]: m
					})
				}));
				const K = !y && C === F.b.Left;
				return a.a.createElement("div", {
					className: Object(l.a)(d, te.a.container, {
						[te.a.collapsed]: m,
						[te.a.hasBadges]: _,
						[te.a.liveStreaming]: O
					})
				}, v && K && a.a.createElement(j.b, {
					flair: v,
					forceSmallEmojis: E
				}), !Object(A.d)(p) && a.a.createElement(ye, {
					showAddCustom: !0,
					subredditId: p.subredditId,
					userId: p.authorId,
					uniqueIdentifier: p.id
				}), a.a.createElement(ke, {
					postOrComment: p,
					tooltipType: H ? T.c.Lightbox : void 0
				}, a.a.createElement(f.b, {
					ignore: Object(A.d)(p) || !!p.distinguishType && p.distinguishType !== c.C.NONE,
					subredditId: p.subredditId,
					userId: p.authorId
				}, a.a.createElement(Fe, {
					comment: p,
					isLivestreaming: O,
					isStrong: !!E,
					isAuthorDeleted: Object(A.d)(p),
					topTippersEnabled: G
				}, i && i))), u && a.a.createElement(_e, null, "Crowd Control"), u && a.a.createElement(X.c, {
					className: te.a.metaText,
					key: "crowdControlSeparator"
				}), v && !K && a.a.createElement(oe, {
					flair: v,
					forceSmallEmojis: E
				}), !E && a.a.createElement(w.a, {
					className: te.a.publicPoints,
					contentId: p.id,
					metaSeparator: a.a.createElement(X.c, {
						className: te.a.metaText
					}),
					subredditId: p.subredditId,
					userId: p.authorId,
					username: p.author
				}), a.a.createElement(a.a.Fragment, null, a.a.createElement(P.b, {
					commentId: p.id
				}), a.a.createElement(P.a, {
					commentId: p.id,
					commentsPageKey: b
				}), a.a.createElement(Ue, {
					comment: p,
					compact: E,
					adminTooltipId: s,
					adminEmeritusTooltipId: t,
					cakedayTooltipId: r,
					contractorTooltipId: g,
					modTooltipId: N,
					onHideTooltip: M,
					onShowTooltip: R,
					opTooltipId: L,
					renderContractorBadge: U,
					subredditDisplayText: q
				})), !E && a.a.createElement(a.a.Fragment, null, !p.isDeleted && !k && a.a.createElement(X.b, {
					className: te.a.metaText,
					isScoreHidden: p.isScoreHidden,
					score: p.score
				}), !k && a.a.createElement(X.c, {
					className: te.a.metaText,
					key: "scoreCreatedSeparator"
				}), a.a.createElement(De, se({
					key: "Created"
				}, e)), p.isStickied && We(), p.editedAt && Ae(p.editedAt)), a.a.createElement(a.a.Fragment, null, a.a.createElement(He, {
					comment: p,
					approveTooltipId: n,
					automodTooltipId: o,
					ignoreLock: S,
					lockedTooltipId: I,
					onHideTooltip: M,
					onShowTooltip: R,
					openRemovalReasonModal: D,
					removeTooltipId: B,
					reportTooltipId: W,
					spamTooltipId: V
				}), a.a.createElement(x.a, {
					className: te.a.DonationAmount,
					contentId: p.id,
					subredditId: p.subredditId
				})), a.a.createElement(h.a, {
					isOverlay: H,
					thing: p
				}))
			});
			const Re = e => {
					const {
						childrenInfo: t,
						collapsed: s,
						className: o,
						comment: r
					} = e;
					return a.a.createElement("div", {
						className: o
					}, a.a.createElement(ve, null, r.deletedBy === A.a.User ? n.fbt._("Comment deleted by user", null, {
						hk: "1Rtt4V"
					}) : n.fbt._("Comment removed by moderator", null, {
						hk: "E1t49"
					})), a.a.createElement(De, se({
						key: "Created"
					}, e)), s && Be({
						childrenInfo: t
					}))
				},
				Le = e => {
					const {
						comment: t,
						className: s,
						childrenInfo: n
					} = e;
					return a.a.createElement("div", {
						className: s
					}, a.a.createElement("div", null, a.a.createElement(Fe, {
						comment: t,
						isAuthorDeleted: Object(A.d)(t),
						topTippersEnabled: !1
					})), a.a.createElement(X.b, {
						className: te.a.metaText,
						isScoreHidden: t.isScoreHidden,
						score: t.score
					}), a.a.createElement(X.c, {
						className: te.a.metaText,
						key: "scoreCreatedSeparator"
					}), a.a.createElement(De, se({
						key: "Created"
					}, e)), Be({
						childrenInfo: n
					}))
				},
				Ae = e => a.a.createElement(o.Fragment, null, a.a.createElement(X.c, {
					className: te.a.metaText
				}), a.a.createElement(xe, null, n.fbt._("edited {time}", [n.fbt._param("time", Object(p.d)(e))], {
					hk: "1tiB0u"
				}))),
				Fe = e => {
					const t = a.a.createElement(b.a, {
						className: te.a.CommentAuthorLink,
						author: e.comment.author,
						isAdmin: e.comment.isAdmin,
						isAdminEmeritus: e.comment.distinguishType === c.C.ALUMNI_ADMIN,
						isAuthorDeleted: e.isAuthorDeleted,
						isLivestreaming: e.isLivestreaming,
						isMod: e.comment.isMod,
						isOp: e.comment.isOp,
						isStrong: e.isStrong,
						style: e.style
					}, e.children && e.children, e.comment.author);
					return e.topTippersEnabled ? a.a.createElement(y, {
						contentId: e.comment.postId,
						subredditId: e.comment.subredditId,
						userId: e.comment.authorId
					}, t) : t
				};
			class De extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onShowCreatedTooltip = () => this.props.onShowTooltip(this.props.createdTooltipId)
				}
				render() {
					const e = this.props,
						{
							comment: t,
							onCreatedClick: s
						} = e,
						n = ne(e, ["comment", "onCreatedClick"]);
					return a.a.createElement(fe, {
						href: t.permalink,
						id: n.createdTooltipId,
						onClick: s,
						onMouseEnter: this.onShowCreatedTooltip,
						onMouseLeave: n.onHideTooltip,
						rel: "nofollow",
						target: "_blank"
					}, a.a.createElement("span", null, Object(p.d)(t.created)), Ve(n.createdTooltipId, Object(m.a)(t.created)))
				}
			}
			const Be = e => {
				const {
					hasContinueThread: t,
					numChildren: s
				} = e.childrenInfo || {
					hasContinueThread: !1,
					numChildren: 0
				};
				return a.a.createElement(Ce, {
					className: te.a.metaText
				}, t ? n.fbt._({
					"*": "More than {number} children",
					_1: "More than 1 child"
				}, [n.fbt._plural(s, "number")], {
					hk: "13XC7a"
				}) : n.fbt._({
					"*": "{number} children",
					_1: "1 child"
				}, [n.fbt._plural(s, "number")], {
					hk: "dhX9w"
				}))
			};
			class Ue extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onShowCakedayTooltip = () => this.props.onShowTooltip(this.props.cakedayTooltipId), this.onShowAdminTooltip = () => this.props.onShowTooltip(this.props.adminTooltipId), this.onShowAdminEmeritusTooltip = () => this.props.onShowTooltip(this.props.adminEmeritusTooltipId), this.onShowModTooltip = () => this.props.onShowTooltip(this.props.modTooltipId), this.onShowOpTooltip = () => this.props.onShowTooltip(this.props.opTooltipId), this.onShowContractorTooltip = () => this.props.onShowTooltip(this.props.contractorTooltipId)
				}
				render() {
					const e = this.props,
						{
							comment: t
						} = e,
						s = ne(e, ["comment"]);
					return a.a.createElement(o.Fragment, null, t.isAuthorCakeday && a.a.createElement(ce, {
						"aria-label": Se(),
						id: s.cakedayTooltipId,
						onMouseEnter: this.onShowCakedayTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isAuthorCakeday && Ve(s.cakedayTooltipId, Se()), t.isAdmin && a.a.createElement(ae, {
						desc: we(),
						id: s.adminTooltipId,
						onMouseEnter: this.onShowAdminTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isAdmin && Ve(s.adminTooltipId, we()), t.distinguishType === c.C.ALUMNI_ADMIN && a.a.createElement(de, {
						"aria-label": Ie(),
						id: s.adminEmeritusTooltipId,
						onMouseEnter: this.onShowAdminEmeritusTooltip,
						onMouseLeave: s.onHideTooltip
					}, "Δ"), t.distinguishType === c.C.ALUMNI_ADMIN && Ve(s.adminEmeritusTooltipId, Ie()), t.isMod && a.a.createElement(me, {
						desc: Pe(s.subredditDisplayText),
						id: s.modTooltipId,
						onMouseEnter: this.onShowModTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isMod && Ve(s.modTooltipId, Pe(s.subredditDisplayText)), t.isOp && a.a.createElement(he, {
						desc: Te(),
						id: s.opTooltipId,
						onMouseEnter: this.onShowOpTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isOp && Ve(s.opTooltipId, Te()), s.renderContractorBadge && a.a.createElement(ge, {
						desc: Ne(),
						id: s.contractorTooltipId,
						onMouseEnter: this.onShowContractorTooltip,
						onMouseLeave: s.onHideTooltip
					}), s.renderContractorBadge && Ve(s.contractorTooltipId, Ne()))
				}
			}
			class He extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onShowApproveTooltip = () => this.props.onShowTooltip(this.props.approveTooltipId), this.onShowRemoveTooltip = () => this.props.onShowTooltip(this.props.removeTooltipId), this.onShowSpamTooltip = () => this.props.onShowTooltip(this.props.spamTooltipId), this.onShowAutomodTooltip = () => this.props.onShowTooltip(this.props.automodTooltipId), this.onShowReportTooltip = () => this.props.onShowTooltip(this.props.reportTooltipId)
				}
				render() {
					const e = this.props,
						{
							comment: t
						} = e,
						s = ne(e, ["comment"]);
					return a.a.createElement(o.Fragment, null, (t.approvedBy || t.isApproved) && a.a.createElement(re, {
						desc: Object(M.a)(t),
						id: s.approveTooltipId,
						onMouseEnter: this.onShowApproveTooltip,
						onMouseLeave: s.onHideTooltip
					}), (t.approvedBy || t.isApproved) && Ve(s.approveTooltipId, Object(M.a)(t)), Object(N.a)(t) && a.a.createElement(ue, {
						desc: Object(M.c)(t),
						id: s.removeTooltipId,
						onMouseEnter: this.onShowRemoveTooltip,
						onMouseLeave: s.onHideTooltip
					}), Object(N.a)(t) && Ve(s.removeTooltipId, Object(M.c)(t)), Object(N.a)(t) && t.isRemoved && !t.modNote && !t.modRemovalReason && a.a.createElement(Oe, {
						onClick: s.openRemovalReasonModal
					}, n.fbt._("Add a removal reason", null, {
						hk: "L6yrL"
					})), Object(N.a)(t) && !(t.isRemoved && !t.modNote && !t.modRemovalReason) && a.a.createElement(Oe, {
						onMouseEnter: this.onShowRemoveTooltip,
						onMouseLeave: s.onHideTooltip
					}, n.fbt._("Removal reason", null, {
						hk: "20NRw8"
					})), t.isLocked && !s.ignoreLock && a.a.createElement(ie, {
						desc: n.fbt._("Locked", null, {
							hk: "40Ju3g"
						}),
						id: s.lockedTooltipId,
						onMouseEnter: () => {
							s.onShowTooltip(s.lockedTooltipId)
						},
						onMouseLeave: s.onHideTooltip
					}), t.bannedBy && t.isSpam && a.a.createElement(be, {
						desc: Object(M.e)(t),
						id: s.spamTooltipId,
						onMouseEnter: this.onShowSpamTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.bannedBy && t.isSpam && Ve(s.spamTooltipId, Object(M.e)(t)), ("AutoModerator" === t.bannedBy || "AutoModerator" === t.approvedBy) && a.a.createElement(le, {
						className: Object(l.a)({
							[te.a.removed]: !!t.bannedBy
						}),
						desc: M.b,
						id: s.automodTooltipId,
						key: s.automodTooltipId,
						onMouseEnter: this.onShowAutomodTooltip,
						onMouseLeave: s.onHideTooltip
					}), ("AutoModerator" === t.bannedBy || "AutoModerator" === t.approvedBy) && Ve(s.automodTooltipId, M.b), Object(R.a)(t) && a.a.createElement(pe, {
						desc: Object(M.d)(t.numReports),
						id: s.reportTooltipId,
						onMouseEnter: this.onShowReportTooltip,
						onMouseLeave: s.onHideTooltip
					}), Object(R.a)(t) && Ve(s.reportTooltipId, Object(M.d)(t.numReports)))
				}
			}
			const We = () => a.a.createElement(o.Fragment, null, a.a.createElement(X.c, {
					className: te.a.metaText
				}), a.a.createElement(Ee, null, n.fbt._("Stickied comment", null, {
					hk: "XUSav"
				}))),
				Ve = (e, t) => a.a.createElement(I.c, {
					tooltipId: e,
					text: t
				})
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.m.less": function(e, t, s) {
			e.exports = {
				VoteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				voteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				ContentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				contentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				CommentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				commentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				CommentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				commentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				CommentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				commentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				Fade: "_3Q0PfUquGeJoHhFKeS5MRg",
				fade: "_3Q0PfUquGeJoHhFKeS5MRg",
				ParentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				parentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				Component: "_29-oldqrqqPwwjRRH0aLqU",
				component: "_29-oldqrqqPwwjRRH0aLqU"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return I
			})), s.d(t, "b", (function() {
				return N
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/objectSelector/index.ts"),
				d = s("./src/reddit/actions/comment/index.ts"),
				l = s("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				c = s("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				m = s("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				u = s("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				p = s("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				b = s("./src/reddit/components/ModModeReports/index.tsx"),
				h = s("./src/reddit/components/PostRailAndVotes/index.tsx"),
				g = s("./src/reddit/components/RichTextJson/index.tsx"),
				f = s("./src/reddit/helpers/getRichTextContent/index.ts"),
				x = s("./src/reddit/models/Vote/index.ts"),
				E = s("./src/reddit/selectors/comments.ts"),
				v = s("./src/reddit/selectors/subreddit.ts"),
				C = s("./src/reddit/components/Comments/UnthreadedComment/index.m.less"),
				_ = s.n(C),
				k = s("./src/lib/lessComponent.tsx");
			const O = k.a.div("VoteSpacer", _.a),
				y = k.a.div("ContentWrapper", _.a),
				j = k.a.div("CommentContentWrapper", _.a),
				w = k.a.div("CommentBody", _.a),
				S = k.a.div("Fade", _.a),
				I = k.a.div("ParentPostTitle", _.a),
				P = k.a.div("CommentParentWrapper", _.a),
				T = Object(r.c)({
					comment: (e, t) => Object(E.n)(e, t),
					flair: E.e,
					subreddit: v.I
				}),
				N = Object(a.b)(T, (e, t) => {
					let {
						commentId: s,
						trackClick: n
					} = t;
					return {
						onIgnoreReports: () => e(Object(d.pb)(s)),
						onVoteClick: t => {
							const [o, a] = t === x.a.upvoted ? [Object(d.rb)(s), "upvote_comment"] : [Object(d.T)(s), "downvote_comment"];
							n(a)(), e(o)
						}
					}
				}),
				M = Object(i.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			t.c = N(k.a.wrapped(e => {
				const {
					className: t,
					comment: s,
					flair: n,
					hasReports: a,
					isCheckboxSelected: r = !1,
					onIgnoreReports: i,
					onVoteClick: d,
					showModTools: x,
					subreddit: E,
					showBulkActionCheckbox: v,
					toggleCheckbox: C
				} = e;
				return o.a.createElement(c.a, {
					className: t,
					clickTrackingId: s.id,
					permalink: s.permalink
				}, o.a.createElement(h.a, {
					model: s,
					handleVote: d,
					showBulkActionCheckbox: v,
					isCheckboxSelected: r,
					toggleCheckbox: C,
					subreddit: E
				}), o.a.createElement(O, null, o.a.createElement(y, null, o.a.createElement(P, null, s.postTitle && o.a.createElement(I, null, s.postTitle), s.postAuthor && o.a.createElement(p.a, {
					comment: s
				})), o.a.createElement(j, null, o.a.createElement(m.a, {
					comment: s
				}, o.a.createElement(w, null, o.a.createElement(g.a, {
					content: Object(f.a)(s),
					rtJsonElementProps: M(e)
				}), o.a.createElement(S, null)), o.a.createElement(u.a, {
					comment: s,
					flair: n,
					subredditName: E ? E.displayText : null
				}), a && o.a.createElement(b.a, {
					onIgnoreReports: i,
					reportable: s
				}), x && !s.isDeleted && o.a.createElement(l.c, {
					comment: s
				}))))))
			}, "Component", _.a))
		},
		"./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./src/lib/addQueryParams/index.ts"),
				i = s("./src/higherOrderComponents/withClickTracking.tsx"),
				d = s("./src/reddit/helpers/overlay/index.ts"),
				l = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const c = Object(a.b)(null, e => ({
				openLightbox: t => e(Object(d.a)(t))
			}));
			class m extends o.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const e = this.props,
						{
							afterClickTracking: t,
							permalink: s,
							openLightbox: n
						} = e,
						a = l(e, ["afterClickTracking", "permalink", "openLightbox"]),
						i = e => t(() => e.metaKey || e.ctrlKey || 1 === e.button ? window.open(Object(r.a)(s, {
							context: 3
						})) : n(Object(r.a)(s, {
							context: 3
						})))(e);
					return o.a.createElement("div", {
						className: a.className,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3)), 1 === e.button && i(e)
						},
						onClick: e => {
							!this.cancelClick && 0 === e.button && i(e)
						}
					}, a.children)
				}
			}
			t.a = c(Object(i.c)(m))
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less": function(e, t, s) {
			e.exports = {
				DashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u",
				dashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/lessComponent.tsx"),
				r = s("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less"),
				i = s.n(r);
			const d = a.a.div("DashWrapper", i.a);
			t.a = e => null === e.comment.parentId ? o.a.createElement(d, null, e.children) : o.a.createElement(d, null, o.a.createElement(d, null, e.children))
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less": function(e, t, s) {
			e.exports = {
				SubredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				subredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				TopMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				topMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				Inline: "meK3ndVOmnvQt6wVaAg5W",
				inline: "meK3ndVOmnvQt6wVaAg5W",
				PostedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				postedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				TextContainer: "iV3Hb5JWIQSpA3WhioY-N",
				textContainer: "iV3Hb5JWIQSpA3WhioY-N"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/reddit/components/Comments/Comment/TopMeta/index.tsx"),
				i = s("./src/reddit/layout/row/Inline/index.tsx"),
				d = s("./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less"),
				l = s.n(d),
				c = s("./src/lib/lessComponent.tsx");
			const m = c.a.wrapped(i.a, "Inline", l.a),
				u = c.a.wrapped(i.a, "PostedInfo", l.a),
				p = c.a.wrapped(i.a, "SubredditWrapper", l.a),
				b = c.a.div("TextContainer", l.a),
				h = c.a.wrapped(r.a, "TopMeta", l.a);
			t.a = e => a.a.createElement(m, {
				className: e.className
			}, e.subredditName && a.a.createElement(p, null, e.subredditName && a.a.createElement(b, null, e.subredditName)), a.a.createElement(u, null, a.a.createElement(b, null, "".concat(n.fbt._("Commented by", null, {
				hk: "4Dveap"
			}))), a.a.createElement(h, {
				collapsedBecauseCrowdControl: e.comment.collapsedBecauseCrowdControl,
				collapsed: !1,
				comment: e.comment,
				flair: e.flair,
				renderedInOverlay: !1
			})))
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less": function(e, t, s) {
			e.exports = {
				AuthorLink: "_2jljMb6FK7HnIb15zmm1of",
				authorLink: "_2jljMb6FK7HnIb15zmm1of",
				SubredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				subredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				TextContainer: "_2in6k_0-sFgKVz16hifq03",
				textContainer: "_2in6k_0-sFgKVz16hifq03",
				SubredditIcon: "uCjYZbKNai0INWGwHjoUh",
				subredditIcon: "uCjYZbKNai0INWGwHjoUh",
				Inline: "_2VWXAfRlnHG_4nydI7J4l3",
				inline: "_2VWXAfRlnHG_4nydI7J4l3"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/AuthorLink/index.tsx"),
				r = s("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				i = s("./src/reddit/components/SubredditIcon/index.tsx"),
				d = s("./src/reddit/layout/row/Inline/index.tsx"),
				l = s("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less"),
				c = s.n(l),
				m = s("./src/lib/lessComponent.tsx");
			const {
				fbt: u
			} = s("./node_modules/fbt/lib/FbtPublic.js"), p = m.a.wrapped(a.a, "AuthorLink", c.a), b = m.a.wrapped(d.a, "Inline", c.a), h = m.a.wrapped(d.a, "SubredditWrapper", c.a), g = m.a.div("TextContainer", c.a), f = m.a.wrapped(i.b, "SubredditIcon", c.a);
			t.a = e => o.a.createElement(b, null, e.subredditOrProfile && o.a.createElement(h, null, e.subredditOrProfile && o.a.createElement(f, {
				subredditOrProfile: e.subredditOrProfile
			}), e.subredditOrProfile && o.a.createElement(g, null, e.subredditOrProfile.displayText)), u._("posted by", null, {
				hk: "1EuRc2"
			}), e.comment.postAuthor && o.a.createElement(r.b, {
				postOrComment: e.comment,
				author: e.comment.postAuthor
			}, o.a.createElement(p, {
				author: e.comment.postAuthor,
				isUnstyled: !0
			}, "u/".concat(e.comment.postAuthor))))
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.m.less": function(e, t, s) {
			e.exports = {
				Icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				IconText: "_6cNM5NdF82ASM5hiBVNN5",
				iconText: "_6cNM5NdF82ASM5hiBVNN5",
				Animate: "_3j98tX1WZapEArV-4rmJe5",
				animate: "_3j98tX1WZapEArV-4rmJe5",
				top: "_3Dr1MoYY5Yv4YhbQFFcks0",
				bottom: "_1GRYNQhMsR-00cWDJcE3UJ",
				bigCircle: "_85rqvRijdIsn3s0j-gUaw",
				midCircle: "RS1g6Gd_W67wwWKSteEB1",
				smallCircle: "lRlGcfTzZ7njZnIUyvhGH",
				play: "_3Kxa8oHGuT_QpP4zIN5jrV",
				blinker: "_20WvB_9deo7bJVi4af1dSS"
			}
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/selectors/experiments/chatPost.ts"),
				m = s("./src/reddit/components/CommentsChat/LiveIcon/index.m.less"),
				u = s.n(m);
			const p = .1,
				b = Object(d.c)({
					isChatPost: c.e,
					isChatPostExperiment: c.d
				}),
				h = Object(i.b)(b, e => ({
					sendChatPostExposureEvent: (t, s) => e((e, n) => Object(c.g)(n(), t, s))
				}));
			class g extends r.a.Component {
				constructor(e) {
					super(e), this.onVisibilityChange = e => {
						e.isIntersecting && e.intersectionRatio >= p ? this.state.visible || (this.setState({
							visible: !0
						}), this.sendChatPostExposureEvent()) : this.state.visible && this.setState({
							visible: !1
						})
					}, this.state = {
						visible: null
					}
				}
				sendChatPostExposureEvent() {
					const {
						isChatPost: e,
						isMod: t,
						sendChatPostExposureEvent: s
					} = this.props;
					s(e, t)
				}
				render() {
					const {
						visible: e
					} = this.state, {
						isChatPost: t,
						isChatPostExperiment: s
					} = this.props, a = s && (null === e || e);
					return t ? r.a.createElement(n.a, {
						rootMargin: "20px 0px 20px 0px",
						threshold: p,
						onChange: this.onVisibilityChange
					}, s ? r.a.createElement("div", {
						className: Object(l.a)(u.a.Icon, this.props.className)
					}, r.a.createElement("span", {
						className: Object(l.a)(u.a.Animate, u.a.top, {
							[u.a.play]: a
						})
					}, r.a.createElement("span", {
						className: u.a.bigCircle
					}), r.a.createElement("span", {
						className: u.a.midCircle
					}), r.a.createElement("span", {
						className: u.a.smallCircle
					})), r.a.createElement("p", {
						className: u.a.IconText
					}, o.fbt._("Live Discussion", null, {
						hk: "2akFwx"
					})), r.a.createElement("span", {
						className: Object(l.a)(u.a.Animate, u.a.bottom, {
							[u.a.play]: a
						})
					}, r.a.createElement("span", {
						className: u.a.bigCircle
					}), r.a.createElement("span", {
						className: u.a.midCircle
					}), r.a.createElement("span", {
						className: u.a.smallCircle
					}))) : r.a.createElement("span", null)) : null
				}
			}
			t.a = h(g)
		},
		"./src/reddit/components/CommentsLink/index.m.less": function(e, t, s) {
			e.exports = {
				commentsLink: "_1UoeAeSRhOKSNdY_h3iS1O",
				commentIcon: "_3DVrpDrMM9NLT6TlsTUMxC",
				defaultCursorWrapper: "_3m17ICJgx45k_z-t82iVuO",
				link: "_1Hw7tY9pMr-T1F4P1C-xNU",
				text: "FHCV02u6Cp2zYL0fhQPsO"
			}
		},
		"./src/reddit/components/CommentsLink/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/permalinkToOverlayLocation/index.ts"),
				m = s("./src/lib/prettyPrintNumber/index.ts"),
				u = s("./src/reddit/constants/componentTestIds.ts"),
				p = s("./src/reddit/constants/postLayout.ts"),
				b = s("./src/reddit/helpers/path/index.ts"),
				h = s("./src/reddit/icons/fonts/Comment/index.tsx"),
				g = s("./src/reddit/selectors/experiments/chatPost.ts"),
				f = s("./src/reddit/selectors/experiments/postSeo.ts"),
				x = s("./src/reddit/selectors/posts.ts"),
				E = s("./src/reddit/selectors/user.ts"),
				v = s("./src/reddit/components/CommentsLink/index.m.less"),
				C = s.n(v);
			const _ = Object(r.b)(() => Object(d.c)({
					isChatPostExperiment: g.d,
					isPostSEOEligible: f.f,
					postPermalink: x.M,
					shouldOpenPostInNewTab: E.U
				})),
				k = e => {
					let t, {
						type: s,
						numComments: r,
						isChatPostExperiment: i,
						modModeEnabled: d,
						hasModPostPerms: l,
						shouldShowIcon: c,
						shouldShowText: u,
						text: b
					} = e;
					return t = b || (s === p.g.Compact || d && l || i ? Object(m.b)(r) : n.fbt._({
						"*": "{number} comments",
						_1: "1 comment"
					}, [n.fbt._plural(r, "number", Object(m.b)(r))], {
						hk: "1QeOde"
					})), a.a.createElement(o.Fragment, null, c && a.a.createElement(h.a, {
						className: C.a.commentIcon,
						role: "presentation"
					}), u && a.a.createElement("span", {
						className: C.a.text
					}, t))
				};
			t.a = _(e => {
				const {
					className: t,
					hasModPostPerms: s,
					isChatPostExperiment: n,
					isCommentPermalink: o,
					isCommentsPage: r,
					isOverlay: d,
					isPostSEOEligible: m,
					modModeEnabled: p,
					numComments: h,
					onClick: g,
					postPermalink: f,
					shouldOpenPostInNewTab: x,
					shouldShowIcon: E = !0,
					shouldShowText: v = !0,
					text: _,
					type: O
				} = e, y = r && !o && !m, j = o && !d, w = a.a.createElement(k, {
					type: O,
					numComments: h,
					isChatPostExperiment: n,
					modModeEnabled: p,
					hasModPostPerms: s,
					shouldShowIcon: E,
					shouldShowText: v,
					text: _
				});
				return y ? a.a.createElement("div", {
					className: Object(l.a)(C.a.commentsLink, C.a.defaultCursorWrapper, t),
					onClick: g
				}, w) : a.a.createElement(i.a, {
					rel: "nofollow",
					"data-click-id": "comments",
					"data-test-id": u.a,
					className: Object(l.a)(C.a.commentsLink, C.a.link, t),
					target: x ? "_blank" : void 0,
					to: j ? Object(b.b)(f) : Object(c.a)(f, !0),
					onClick: g
				}, w)
			})
		},
		"./src/reddit/components/CommunityAwardList/AwardRow/index.m.less": function(e, t, s) {
			e.exports = {
				row: "_1SJYzo3UAyKEOF7dfuB9mj",
				awardName: "KMxVBNnYo_dcBwZGB9Y7a",
				unfilledAward: "_3s20dmDQOAFnj9VBvMb_K9",
				awardDetail: "_2NA5kHSdCz8PTAq-oiC2lE",
				awardExpiresDetail: "_23IvuOow0OJsmKnkmU_FEX",
				headerRow: "_1NbiD8qa7KncC2IlK9RoSb",
				awardIconImage: "_3sB_KQUJdYFc6cPgCjizd4",
				deleteIcon: "_1Aox5T2z7StzW_M0WfnDTe",
				rightAlign: "_3MpqTEDv3tS3-u-1uNAt6Y",
				createButton: "_3pXwHsShRJ0s12b9e-_gCX",
				emptyIcon: "yy-p6aZDVdPVBPBYMhbEy",
				emptyDetails: "LUZArpcpRdOTEPUDrjKVR",
				awardLoadingContainer: "_2WNYZIJMYIXJIS_IJIIiTe"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.m.less": function(e, t, s) {
			e.exports = {
				contentContainer: "_27C02100EX-RnLoDyL_PYT",
				gildIcon: "_3f4YbBVVbX4YXols-8AmgC",
				infoIcon: "_1HPeb_FxEOzicQ4BuIVonK",
				pageInfo: "_2bEhfADeSjJE-8zKoxjbGy",
				awardToDelete: "dzAx082Iu3F9M7xS-PL80",
				awardToDeleteIcon: "_11ikfBu3qqa0paYAJLQINO"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/gold/communityAwards.ts"),
				l = s("./src/reddit/actions/modal.ts"),
				c = s("./src/reddit/actions/tooltip.ts"),
				m = s("./src/reddit/constants/gold.ts"),
				u = s("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				p = s("./src/reddit/helpers/correlationIdTracker.ts"),
				b = s("./src/reddit/helpers/trackers/communityAwards.ts"),
				h = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/higherOrderComponents/makeAsync.tsx")),
				g = s("./src/lib/loadWithRetries/index.ts");
			var f = Object(h.a)({
					getComponent: () => Object(g.a)(() => Promise.all([s.e("AwardCreationModal").then(s.bind(null, "./src/reddit/components/AwardCreationModal/index.tsx"))])).then(e => e[0].default),
					ErrorComponent: () => null,
					LoadingComponent: () => null
				}),
				x = s("./src/reddit/models/Gold/Award.ts"),
				E = s("./src/reddit/components/ConfirmModal/index.tsx"),
				v = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				C = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = s("./src/reddit/components/TrackingHelper/index.tsx"),
				k = s("./src/reddit/icons/svgs/Gild/index.tsx"),
				O = s("./src/reddit/icons/svgs/Info/index.tsx"),
				y = s("./src/reddit/selectors/activeModalId.ts"),
				j = s("./node_modules/lodash/times.js"),
				w = s.n(j),
				S = s("./src/lib/classNames/index.ts"),
				I = s("./src/reddit/controls/Button/index.tsx"),
				P = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				T = s("./src/reddit/helpers/awards/getIconForSize.ts"),
				N = s("./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts"),
				M = s("./src/reddit/layout/row/RightAlign/index.tsx"),
				R = s("./src/reddit/components/CommunityAwardList/AwardRow/index.m.less"),
				L = s.n(R);
			const {
				fbt: A
			} = s("./node_modules/fbt/lib/FbtPublic.js"), F = () => a.a.createElement("div", {
				className: L.a.row
			}, a.a.createElement("div", {
				className: L.a.awardName
			}, a.a.createElement("div", {
				className: L.a.emptyDetails
			})), a.a.createElement("div", {
				className: L.a.awardDetail
			}, a.a.createElement("div", {
				className: L.a.emptyIcon
			})), a.a.createElement("div", {
				className: L.a.awardDetail
			}, a.a.createElement("div", {
				className: L.a.emptyDetails
			})), a.a.createElement("div", {
				className: L.a.awardDetail
			}, a.a.createElement("div", {
				className: L.a.emptyDetails
			}))), D = e => a.a.createElement("div", {
				className: Object(S.a)(e.className, L.a.awardLoadingContainer)
			}, w()(10, e => a.a.createElement(F, {
				key: e
			}))), B = e => {
				let {
					subredditId: t
				} = e;
				return a.a.createElement("div", {
					className: L.a.headerRow
				}, a.a.createElement("div", {
					className: L.a.awardName
				}, A._("Name", null, {
					hk: "2rgEdc"
				})), a.a.createElement("div", {
					className: L.a.awardDetail
				}, A._("Icon", null, {
					hk: "zWzOj"
				})), a.a.createElement("div", {
					className: L.a.awardDetail
				}, A._("Coins", null, {
					hk: "2uhz31"
				})), a.a.createElement("div", {
					className: L.a.awardDetail
				}, A._("Type", null, {
					hk: "1rYgKO"
				})), Object(N.a)(t) && a.a.createElement("div", {
					className: L.a.awardDetail
				}, A._("Starts", null, {
					hk: "HW61W"
				})), Object(N.a)(t) && a.a.createElement("div", {
					className: L.a.awardDetail
				}, A._("Expires", null, {
					hk: "3hS2VX"
				})))
			}, U = e => {
				let {
					date: t
				} = e;
				return a.a.createElement("div", {
					className: L.a.awardExpiresDetail
				}, t && t.toLocaleString())
			}, H = e => a.a.createElement("div", {
				className: L.a.row
			}, a.a.createElement("div", {
				className: Object(S.a)(L.a.awardName, L.a.unfilledAward)
			}, A._({
				"*": "Create up to {quantity} more {coin-price} Coin Awards",
				_1: "Create up to {quantity} more {coin-price} Coin Award"
			}, [A._param("quantity", e.quantity), A._param("coin-price", e.coinPrice), A._plural(e.quantity)], {
				hk: "4nSQI7"
			})), a.a.createElement(M.a, {
				className: L.a.rightAlign
			}, a.a.createElement(I.f, {
				className: L.a.createButton,
				onClick: e.onCreate
			}, A._("Create", null, {
				hk: "3aEi77"
			})))), W = e => a.a.createElement("div", {
				className: L.a.row
			}, a.a.createElement("div", {
				className: Object(S.a)(L.a.awardName, L.a.unfilledAward)
			}, A._("Create a Moderator-Only Award", null, {
				hk: "3aMmTo"
			})), a.a.createElement(M.a, {
				className: L.a.rightAlign
			}, a.a.createElement(I.f, {
				className: L.a.createButton,
				onClick: e.onCreate
			}, A._("Create", null, {
				hk: "3aEi77"
			})))), V = e => a.a.createElement("div", {
				className: L.a.row
			}, a.a.createElement("div", {
				className: Object(S.a)(L.a.awardName, L.a.unfilledAward)
			}, A._("Create an Award", null, {
				hk: "1zGxjw"
			})), a.a.createElement(M.a, {
				className: L.a.rightAlign
			}, a.a.createElement(I.f, {
				className: L.a.createButton,
				onClick: e.onCreate
			}, A._("Create", null, {
				hk: "3aEi77"
			}))));
			class q extends a.a.Component {
				constructor() {
					super(...arguments), this.onDelete = e => {
						e.preventDefault(), this.props.onDelete(this.props.award.id)
					}
				}
				render() {
					const {
						award: e,
						canDelete: t,
						subredditId: s
					} = this.props, n = Object(T.a)(e, 32), o = Object(N.a)(s), r = e.startsAt ? new Date(e.startsAt) : void 0, i = e.endsAt ? new Date(e.endsAt) : void 0;
					return a.a.createElement("div", {
						className: L.a.row
					}, a.a.createElement("div", {
						className: L.a.awardName
					}, e.name), a.a.createElement("div", {
						className: L.a.awardDetail
					}, a.a.createElement("img", {
						className: L.a.awardIconImage,
						src: n,
						title: e.name
					})), a.a.createElement("div", {
						className: L.a.awardDetail
					}, e.coinPrice || 0), a.a.createElement("div", {
						className: L.a.awardDetail
					}, e.awardType === x.f.Moderator ? A._("Mod only", null, {
						hk: "UxkP0"
					}) : A._("All", null, {
						hk: "2J55F0"
					})), o && [a.a.createElement(U, {
						key: "startDate",
						date: r
					}), a.a.createElement(U, {
						key: "endDate",
						date: i
					})], a.a.createElement(M.a, {
						className: L.a.rightAlign
					}, t && a.a.createElement("a", {
						href: ".",
						onClick: this.onDelete
					}, a.a.createElement(P.b, {
						className: L.a.deleteIcon
					}))))
				}
			}
			var G = q,
				K = s("./src/reddit/selectors/communityAwards.ts"),
				z = s("./src/reddit/components/CommunityAwardList/index.m.less"),
				Q = s.n(z);
			const J = Object(i.c)({
					awards: K.e,
					awardsPending: K.d,
					communityAwardsDisabled: K.b,
					isAddAwardModalOpen: e => Object(y.a)(e) === m.a,
					isConfirmModalOpen: e => Object(y.a)(e) === m.b
				}),
				Z = Object(r.b)(J, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						deleteAward: t => e(Object(d.f)(s, t)),
						toggleAddAwardModal: () => e(Object(l.i)(m.a)),
						toggleConfirmModal: () => e(Object(l.i)(m.b)),
						toggleTooltip: t => e(Object(c.h)({
							tooltipId: t
						}))
					}
				}),
				X = {
					awardId: null,
					selectedCoinPrice: void 0,
					selectedModOnly: void 0
				};
			class Y extends a.a.Component {
				constructor(e) {
					super(e), this.openAddAwardModal = (e, t) => {
						Object(p.d)(p.a.AwardCreationFlow), this.props.sendEvent(Object(b.d)()), this.setState({
							selectedCoinPrice: e,
							selectedModOnly: t
						}, this.props.toggleAddAwardModal)
					}, this.openDeleteAwardModal = e => {
						Object(p.d)(p.a.AwardDeletionFlow), this.props.toggleConfirmModal(), this.setState({
							awardId: e
						})
					}, this.confirmDeleteAward = () => {
						const {
							awardId: e
						} = this.state, {
							awards: t
						} = this.props;
						if (this.props.toggleConfirmModal(), e) {
							const s = t.filter(t => t.id === e)[0];
							s && this.props.sendEvent(Object(b.f)(s)), this.props.deleteAward(e), Object(p.b)(p.a.AwardDeletionFlow)
						}
					}, this.renderAwardSlotRow = e => {
						const {
							awards: t,
							moderatorPermissions: s,
							subredditId: n
						} = this.props, o = !(!s || !s.all);
						if (!e.filled && t.length < m.d) return a.a.createElement(H, {
							coinPrice: e.price,
							key: e.price,
							onCreate: () => this.openAddAwardModal(e.price),
							quantity: e.quantity
						});
						if (!e.filled) return null;
						const {
							award: r
						} = e;
						return a.a.createElement(G, {
							key: r.id,
							award: r,
							canDelete: o,
							onDelete: this.openDeleteAwardModal,
							subredditId: n
						})
					}, this.renderAwardToDelete = () => {
						const {
							awards: e
						} = this.props, {
							awardId: t
						} = this.state;
						if (!t) return null;
						const s = e.filter(e => e.id === t)[0];
						return s ? a.a.createElement("div", {
							className: Q.a.awardToDelete
						}, a.a.createElement("span", null, n.fbt._("Remove:", null, {
							hk: "1Y4r4o"
						})), a.a.createElement("img", {
							src: s.icon.url,
							className: Q.a.awardToDeleteIcon
						}), a.a.createElement("span", null, s.name)) : null
					}, this.renderInfo = () => a.a.createElement("div", {
						className: Q.a.pageInfo
					}, a.a.createElement(O.a, {
						className: Q.a.infoIcon
					}), a.a.createElement("p", null, n.fbt._("Community Awards are unique to each community, and members can give them to each other. Moderators can design and name the Awards however they want.", null, {
						hk: "1mzX5Y"
					})), a.a.createElement("p", null, n.fbt._("A portion of Coins from Community Award purchases will be deposited to the community’s Coin balance. Moderators can use Coins from that balance to reward members with Mod Awards. The Coin balance is shown only to moderators in the community’s sidebar", null, {
						hk: "2TVMDb"
					}))), this.state = X
				}
				renderAwardsList() {
					const {
						awards: e,
						awardsPending: t,
						moderatorPermissions: s,
						subredditId: n
					} = this.props;
					if (t) return a.a.createElement(D, null);
					const o = Object(u.a)(n),
						r = s && s.all,
						i = this.getAwardSlots().filter(e => r && !o || e.filled),
						d = e.filter(e => e.awardType === x.f.Moderator),
						l = e.length < m.d && d.length < m.e && r && !o;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(B, {
						subredditId: n
					}), o && a.a.createElement(V, {
						onCreate: () => this.openAddAwardModal()
					}), i.map(this.renderAwardSlotRow), l && a.a.createElement(W, {
						onCreate: () => this.openAddAwardModal(void 0, !0)
					}))
				}
				getAwardSlots() {
					const {
						awards: e
					} = this.props, t = Object(x.j)(e), s = e => e.filled && e.award.awardType === x.f.Moderator;
					return t.sort((e, t) => s(e) && !s(t) ? 1 : s(t) && !s(e) ? -1 : e.price !== t.price ? e.price - t.price : e.filled && !t.filled ? -1 : (t.filled && e.filled, 1))
				}
				render() {
					const {
						communityAwardsDisabled: e,
						isAddAwardModalOpen: t,
						isConfirmModalOpen: s,
						subreddit: o,
						subredditId: r,
						toggleAddAwardModal: i,
						toggleConfirmModal: d
					} = this.props, {
						awardId: l,
						selectedCoinPrice: c,
						selectedModOnly: m
					} = this.state;
					return o.isNSFW || o.isQuarantined || e ? this.renderBlacklistedView() : a.a.createElement(a.a.Fragment, null, a.a.createElement(C.a, {
						className: Q.a.contentContainer
					}, a.a.createElement(C.b, null, n.fbt._("Awards", null, {
						hk: "epgXs"
					})), this.renderAwardsList()), this.renderInfo(), t && a.a.createElement(f, {
						defaultCoinPrice: c,
						defaultModOnly: m,
						subredditId: r,
						toggleModal: () => {
							i(), Object(p.b)(p.a.AwardCreationFlow)
						}
					}), s && l && a.a.createElement(E.a, {
						acceptText: n.fbt._("Delete", null, {
							hk: "4bgtZx"
						}),
						cancelText: n.fbt._("Cancel", null, {
							hk: "2TSLl5"
						}),
						headerText: n.fbt._("Delete Award", null, {
							hk: "7q2D7"
						}),
						message: n.fbt._("Deleting an Award will remove the option for members of your community to give the Award. Existing Awards will remain on the posts and comments that have received them.", null, {
							hk: "3tX5sQ"
						}),
						onAccept: this.confirmDeleteAward,
						onCancel: d,
						onClose: d,
						onOverlayClick: d,
						withOverlay: !0
					}, this.renderAwardToDelete()))
				}
				renderBlacklistedView() {
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(C.a, {
						className: Q.a.contentContainer
					}, a.a.createElement(C.b, null, n.fbt._("Awards", null, {
						hk: "epgXs"
					})), a.a.createElement(v.c, {
						text: n.fbt._("Community Awards have been disabled for this community.", null, {
							hk: "2g21s6"
						})
					}, a.a.createElement(k.a, {
						className: Q.a.gildIcon
					}))))
				}
			}
			t.a = Z(Object(_.c)(Y))
		},
		"./src/reddit/components/CommunitySettings/components.m.less": function(e, t, s) {
			e.exports = {
				InputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				inputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				FormContainer: "_37sNfY6fNJVPqyQXOHlg3K",
				formContainer: "_37sNfY6fNJVPqyQXOHlg3K"
			}
		},
		"./src/reddit/components/CommunitySettings/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "e", (function() {
				return a
			})), s.d(t, "k", (function() {
				return r
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "a", (function() {
				return d
			})), s.d(t, "l", (function() {
				return l
			})), s.d(t, "m", (function() {
				return c
			})), s.d(t, "o", (function() {
				return m
			})), s.d(t, "n", (function() {
				return u
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "j", (function() {
				return h
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "i", (function() {
				return f
			})), s.d(t, "p", (function() {
				return x
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = 500,
				o = 100,
				a = 5e3,
				r = 5e5,
				i = 0,
				d = 1440,
				l = 36600,
				c = 1e9,
				m = {
					Disabled: "disabled",
					"Mods only": "modonly",
					Anyone: "anyone"
				},
				u = ["Wiki is disabled for all users except mods", "Only mods, approved wiki contributors, or those on a page's edit list may edit", "Anyone who can submit to the community may edit"],
				p = {
					Any: "any",
					"Links only": "link",
					"Text posts only": "self"
				},
				b = ["Any post type is allowed", "Only links to external sites are allowed", "Only text posts are allowed"],
				h = {
					Low: "low",
					"High (default)": "high",
					All: "all"
				},
				g = {
					"Low (default)": "low",
					High: "high",
					All: "all"
				},
				f = {
					"none (recommended)": null,
					best: "confidence",
					old: "old",
					top: "top",
					"q&a": "qa",
					"live (beta)": "live",
					controversial: "controversial",
					new: "new"
				},
				x = (e, t) => Object.keys(e).find(s => e[s] === t)
		},
		"./src/reddit/components/CommunitySettings/index.m.less": function(e, t, s) {
			e.exports = {
				communityTopicsHelpLink: "_2Tzl9XrmQzUn94gYHRUYMI",
				welcomeMessageHelpLink: "_3-XV8EhlxRlIzoFKUI6gmQ",
				fullWidthTextContainer: "_2SnK_8NMPSqmFfF-es2GGa",
				subtextContainer: "_2sWG233wmE9wNycTEyRHRN",
				sectionSubtext: "_2gZA-d4bPf-v-QStyl39CP",
				subtextLink: "_3m7YXm3a55mNltI6wwKkal",
				numCommunityTopicsSelected: "Ty_datAAaSbn2GX5-1O58",
				welcomeMessageEnabled: "_21a0DjKnRl3i1ItjJ8cSyf",
				geoForm: "_1QCMnCbDgm4T-QmBwOFkQ7",
				geoText: "lhgqy5yEx-4vqJhuaRIW_",
				geoInput: "_20j3hiEorqFwMLxftPVQG1"
			}
		},
		"./src/reddit/components/CommunitySettings/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/isEqual.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/reddit/actions/pages/shared.ts"),
				m = s("./src/reddit/actions/subredditSettings.ts"),
				u = s("./src/reddit/actions/tags/index.ts"),
				p = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				b = s("./src/reddit/components/TrackingHelper/index.tsx"),
				h = s("./src/reddit/controls/Button/index.tsx"),
				g = s("./src/reddit/featureFlags/index.ts"),
				f = s("./src/reddit/helpers/trackers/communitySettings.ts"),
				x = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				E = s("./src/reddit/models/Tags/index.ts"),
				v = s("./src/reddit/selectors/experiments/chatPost.ts"),
				C = s("./src/reddit/selectors/subreddit.ts"),
				_ = s("./src/reddit/selectors/tags.ts"),
				k = s("./src/reddit/selectors/user.ts"),
				O = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/config.ts")),
				y = s("./node_modules/fbt/lib/FbtPublic.js"),
				j = s("./src/reddit/components/CommunityTopics/index.tsx"),
				w = s("./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx"),
				S = s("./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx"),
				I = s("./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx"),
				P = s("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				T = s("./src/reddit/components/Settings/shared/Widgets.tsx"),
				N = s("./src/reddit/controls/Link/index.tsx"),
				M = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				R = s("./src/reddit/controls/RadioInput/index.tsx"),
				L = s("./src/reddit/models/Flair/index.ts"),
				A = s("./src/reddit/models/SubredditRestrictions/index.ts"),
				F = s("./src/reddit/pages/SubredditCreation/index.tsx"),
				D = s("./src/lib/lessComponent.tsx"),
				B = s("./src/reddit/controls/FormFields/index.tsx"),
				U = s("./src/reddit/components/CommunitySettings/components.m.less"),
				H = s.n(U);
			const W = D.a.wrapped(B.b, "InputField", H.a),
				V = D.a.div("FormContainer", H.a);
			var q = s("./src/reddit/components/CommunitySettings/helpers.ts"),
				G = s("./src/lib/classNames/index.ts"),
				K = s("./src/reddit/actions/toaster.ts"),
				z = s("./src/reddit/components/GeoForm/GeoForm.tsx"),
				Q = s("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				J = s("./src/lib/makeGqlRequest/index.ts"),
				Z = s("./src/graphql/operations/SetSubredditGeoPlace.json"),
				X = async (e, t) => Object(J.a)(e, Object.assign({}, Z, {
					variables: t
				})), Y = s("./src/reddit/helpers/localStorage/index.ts"), $ = s("./src/reddit/hooks/useGqlContext.ts"), ee = s("./src/reddit/models/Toast/index.ts"), te = s("./src/reddit/components/CommunitySettings/index.m.less"), se = s.n(te);

			function ne(e) {
				const {
					initialPlace: t = {
						name: "",
						id: ""
					},
					subredditId: s,
					update: n
				} = e, o = Object($.a)(), d = Object(i.c)(), [l, c] = Object(a.useState)(t.id), [m, u] = Object(a.useState)(!1), [p, b] = Object(a.useState)(!0);
				return Object(a.useEffect)(() => {
					b(Object(Y.t)("location")), Object(Y.ab)("location")
				}, []), r.a.createElement(r.a.Fragment, null, r.a.createElement(P.a, null, y.fbt._("Community Location", null, {
					hk: "3aowzb"
				})), r.a.createElement(T.k, {
					label: r.a.createElement(r.a.Fragment, null, y.fbt._("Get discovered by local redditors", null, {
						hk: "1qjcaD"
					}), !p && r.a.createElement(Q.a, null)),
					textContainerClassName: Object(G.a)(se.a.fullWidthTextContainer, se.a.geoText),
					subtext: y.fbt._("Add a location to your community and get discovered by redditors near you.", null, {
						hk: "SZnsE"
					})
				}, r.a.createElement(z.a, {
					initialValue: t.name,
					initialPlaceId: l,
					onPlace: e => n(e, "placeId"),
					onSubmit: async function(e) {
						let {
							placeId: t,
							sessionId: n
						} = e;
						if (!t || t === l) return;
						u(!0);
						const a = await X(o(), {
							input: {
								subredditId: s,
								geoPlace: {
									id: t,
									sessionId: n,
									source: "GOOGLE_MAPS"
								}
							}
						});
						if (u(!1), !a.ok) return d(Object(K.e)({
							kind: ee.b.Error,
							text: y.fbt._("Something went wrong", null, {
								hk: "2PnKbu"
							}),
							duration: 5e3
						}));
						c(t), d(Object(K.e)({
							kind: ee.b.SuccessCommunity,
							text: y.fbt._("Successfully updated community location", null, {
								hk: "3aGk2e"
							}),
							duration: 5e3
						}))
					},
					disabled: m,
					className: se.a.geoForm,
					inputClassName: se.a.geoInput
				})))
			}
			const oe = {
				[A.e.Post]: {
					short: () => y.fbt._("Post only (default)", null, {
						hk: "2XJHW4"
					}),
					long: () => y.fbt._("Only approved users can post. Anyone can comment.", null, {
						hk: "3frgit"
					})
				},
				[A.e.Comment]: {
					short: () => y.fbt._("Comment only", null, {
						hk: "2OhQB5"
					}),
					long: () => y.fbt._("Only approved users can comment. Anyone can post.", null, {
						hk: "2F24kr"
					})
				},
				[A.e.PostAndComment]: {
					short: () => y.fbt._("Post & Comment", null, {
						hk: "1lWCl2"
					}),
					long: () => y.fbt._("Only approved users can post and comment.", null, {
						hk: "4GkEs6"
					})
				}
			};

			function ae(e) {
				const {
					isEmployee: t,
					restrictions: s,
					settings: n,
					subreddit: o,
					subredditId: a,
					subredditName: i,
					testWelcomeMessage: d,
					update: c,
					geoPlace: m
				} = e, {
					disableContributorRequests: u,
					over18: b,
					publicDescription: h,
					restrictCommenting: g,
					restrictPosting: E,
					subredditType: v,
					title: C,
					welcomeMessageEnabled: _,
					welcomeMessageText: k
				} = n, D = [], B = [];
				for (const r of Object.keys(oe)) B.push(oe[r].short()), D.push(oe[r].long());
				const U = o.subscribers < q.k || !!k;
				return r.a.createElement(p.a, null, r.a.createElement(V, null, r.a.createElement(p.b, null, y.fbt._("Community settings", null, {
					hk: "3mvH70"
				})), r.a.createElement(P.a, null, y.fbt._("Community Profile", null, {
					hk: "91aEK"
				})), r.a.createElement(T.e, {
					label: y.fbt._("Community name", null, {
						hk: "260EEx"
					}),
					maxChars: q.d,
					onChange: e => c(e.currentTarget.value, "title"),
					textContainerClassName: se.a.fullWidthTextContainer,
					value: C || ""
				}), r.a.createElement(T.k, {
					label: y.fbt._("Community topics", null, {
						hk: "49aoGo"
					}),
					textContainerClassName: se.a.fullWidthTextContainer,
					subtext: r.a.createElement("span", {
						className: se.a.subtextContainer
					}, y.fbt._("This will help Reddit recommend your community to relevant users and other discovery experiences.", null, {
						hk: "3WYTu5"
					}), " ", r.a.createElement(M.a, {
						className: se.a.communityTopicsHelpLink,
						isSponsored: !1,
						source: null,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360024518712",
						rel: "noopener noreferrer",
						target: "_blank"
					}, y.fbt._("Learn more.", null, {
						hk: "1y3kXY"
					})), " ", " ", r.a.createElement("span", {
						className: se.a.numCommunityTopicsSelected
					}, r.a.createElement(w.a, {
						subredditId: a
					}))),
					direction: "column"
				}, r.a.createElement(S.b, {
					subredditId: a,
					onPrimarySelect: e.onPrimarySelect
				}), (!!e.selectedPrimaryTag || e.hasSecondaryTags) && r.a.createElement(j.b, {
					context: x.a.communitySettings,
					subredditId: a
				}), r.a.createElement(I.a, {
					context: x.a.communitySettings,
					subredditId: a
				})), r.a.createElement(T.g, {
					label: y.fbt._("Community description", null, {
						hk: "1XBKXj"
					}),
					onChange: e => c(e.currentTarget.value, "publicDescription", !1),
					maxChars: q.c,
					rows: 2,
					subtext: y.fbt._("This is how new members come to understand your community.", null, {
						hk: "llaA4"
					}),
					value: h || ""
				}), U && r.a.createElement(T.o, {
					className: _ ? se.a.welcomeMessageEnabled : void 0,
					on: _,
					onClick: () => c(!_, "welcomeMessageEnabled"),
					label: y.fbt._("Send welcome message to new members", null, {
						hk: "4euZSE"
					}),
					subtext: r.a.createElement("span", null, y.fbt._("Create a custom welcome message to greet people when they join your community. People who receive a welcome message are more likely to participate in your community. This field supports markdown.", null, {
						hk: "2Xj0zb"
					}), " ", r.a.createElement(M.a, {
						className: se.a.welcomeMessageHelpLink,
						isSponsored: !1,
						source: null,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360002551551-Welcoming-new-members",
						rel: "noopener noreferrer",
						target: "_blank"
					}, y.fbt._("Learn more.", null, {
						hk: "NkFhF"
					})))
				}), U && _ && r.a.createElement(r.a.Fragment, null, r.a.createElement(T.g, {
					actionLink: r.a.createElement(N.a, {
						onClick: () => d(i, k)
					}, y.fbt._("Send me a test message", null, {
						hk: "4iE1go"
					})),
					label: null,
					onChange: e => {
						c(e.currentTarget.value, "welcomeMessageText")
					},
					maxChars: q.e,
					rows: 2,
					value: k || ""
				})), r.a.createElement(ne, {
					subredditId: a,
					update: c,
					initialPlace: m
				}), r.a.createElement(P.a, null, y.fbt._("community type", null, {
					hk: "3T2OkK"
				})), r.a.createElement(T.k, {
					label: y.fbt._("Type of Community", null, {
						hk: "2PReGw"
					}),
					direction: "column"
				}, r.a.createElement(R.a, {
					value: v,
					name: "type",
					onChange: e => c(e, "subredditType")
				}, Object(F.radioOptions)(t, s))), r.a.createElement(T.o, {
					on: b,
					onClick: () => c(!b, "over18"),
					label: r.a.createElement("span", null, y.fbt._("18+ year old community", null, {
						hk: "3VzYZp"
					}), r.a.createElement(T.l, {
						flair: L.f.Nsfw
					})),
					subtext: y.fbt._("When your community is marked as an 18+ community, users must be flagged as 18+ in their user settings", null, {
						hk: "2h28m0"
					})
				}), "restricted" === v && r.a.createElement(r.a.Fragment, null, r.a.createElement(P.a, null, y.fbt._("Restricted Community Settings", null, {
					hk: "1HiDiC"
				})), r.a.createElement(T.d, {
					label: y.fbt._("Approved users have the ability to", null, {
						hk: "2pduhW"
					}),
					items: B,
					selected: (() => {
						let e = A.e.Post;
						return g && E ? e = A.e.PostAndComment : g && (e = A.e.Comment), oe[e].short()
					})(),
					onClick: e => {
						e === oe[A.e.PostAndComment].short() ? (c(!0, A.f.Comment), c(!0, A.f.Post)) : e === oe[A.e.Comment].short() ? (c(!1, A.f.Post), c(!0, A.f.Comment)) : e === oe[A.e.Post].short() && (c(!0, A.f.Post), c(!1, A.f.Comment))
					},
					id: "restrictionOptions",
					descriptions: D
				}), r.a.createElement(T.o, {
					on: !u,
					onClick: () => c(!u, "disableContributorRequests"),
					label: y.fbt._("Accepting new requests to post", null, {
						hk: "bTpYB"
					})
				})), r.a.createElement(P.a, null, y.fbt._("Advanced Settings", null, {
					hk: "1e5Esr"
				})), r.a.createElement(T.f, {
					label: y.fbt._("Settings for old site", null, {
						hk: "4wmYj3"
					}),
					subtext: y.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "gYPuP"
					}),
					link: "".concat(O.a.oldRedditUrl, "/r/").concat(i, "/about/edit"),
					onClick: () => e.sendEvent(Object(f.b)(l.Qb.Posts)),
					openInNewTab: !0,
					last: !0
				})))
			}
			var re = e => {
					const {
						settings: t,
						subredditName: s,
						update: n,
						isChatPostsCreationEnabled: o,
						isImageGallerySettingEnabled: a
					} = e, {
						allowChatPostCreation: i,
						allowGalleries: d,
						allowImages: c,
						allowPolls: m,
						allowPostCrossposts: u,
						collapseDeletedComments: b,
						commentScoreHideMins: h,
						contentOptions: g,
						spamComments: x,
						spamLinks: E,
						spamSelfposts: v,
						spoilersEnabled: C,
						suggestedCommentSort: _
					} = t;
					return r.a.createElement(p.a, null, r.a.createElement(V, null, r.a.createElement(p.b, null, y.fbt._("Post and Comment settings", null, {
						hk: "14OI7p"
					})), r.a.createElement(P.a, null, y.fbt._("Posts", null, {
						hk: "2i2G4r"
					})), r.a.createElement(T.d, {
						label: y.fbt._("Post type options", null, {
							hk: "M9AdT"
						}),
						items: Object.keys(q.h),
						selected: Object(q.p)(q.h, g),
						onClick: e => n(q.h[e], "contentOptions"),
						id: "contentOptions",
						descriptions: q.g
					}), r.a.createElement(T.o, {
						on: u,
						onClick: () => n(!u, "allowPostCrossposts"),
						label: y.fbt._("Allow crossposting of posts.", null, {
							hk: "19EiBT"
						})
					}), o && r.a.createElement(T.o, {
						on: i,
						onClick: () => n(!i, "allowChatPostCreation"),
						label: y.fbt._("Allow chat posts creation by users.", null, {
							hk: "4zwoUf"
						})
					}), r.a.createElement(T.o, {
						on: C,
						onClick: () => n(!C, "spoilersEnabled"),
						label: r.a.createElement("span", null, y.fbt._("Enable spoiler tag", null, {
							hk: "2CtBpB"
						}), r.a.createElement(T.l, {
							flair: L.f.Spoiler
						})),
						subtext: y.fbt._("Media on posts with the spoiler tag are blurred", null, {
							hk: "4rVOs6"
						})
					}), r.a.createElement(T.o, {
						on: c,
						onClick: () => {
							n(!c, "allowImages"), a && n(!c, "allowGalleries")
						},
						label: y.fbt._("Allow image uploads and links to image hosting sites", null, {
							hk: "20ETVO"
						})
					}), a && c && r.a.createElement(T.o, {
						on: d,
						onClick: () => n(!d, "allowGalleries"),
						label: y.fbt._("Allow multiple images per post", null, {
							hk: "Pcjq5"
						})
					}), r.a.createElement(T.o, {
						on: m,
						onClick: () => n(!m, "allowPolls"),
						label: y.fbt._("Allow polls", null, {
							hk: "15LXRO"
						})
					}), r.a.createElement(T.k, {
						label: y.fbt._("Spam filter strength", null, {
							hk: "4C4qar"
						}),
						subtext: y.fbt._("'HIGH' is the standard filter, 'LOW' disables most filtering, 'ALL' will filter every post initially and they will need to be approved manually to be visible", null, {
							hk: "mdxeP"
						})
					}), r.a.createElement(T.d, {
						label: y.fbt._("Posts", null, {
							hk: "1SdpTj"
						}),
						items: Object.keys(q.j),
						id: "spamSelfposts",
						selected: Object(q.p)(q.j, v),
						onClick: e => n(q.j[e], "spamSelfposts"),
						indent: !0
					}), r.a.createElement(T.d, {
						label: y.fbt._("Links", null, {
							hk: "Ia7TU"
						}),
						items: Object.keys(q.j),
						id: "spamLinks",
						selected: Object(q.p)(q.j, E),
						onClick: e => n(q.j[e], "spamLinks"),
						indent: !0
					}), r.a.createElement(T.d, {
						label: y.fbt._("Comments", null, {
							hk: "1X5Fv2"
						}),
						items: Object.keys(q.b),
						selected: Object(q.p)(q.b, x),
						onClick: e => n(q.b[e], "spamComments"),
						indent: !0,
						id: "spamComments"
					}), r.a.createElement(P.a, null, y.fbt._("Comments", null, {
						hk: "4sAqsA"
					})), r.a.createElement(T.d, {
						label: y.fbt._("Suggested sort", null, {
							hk: "4Af3Lr"
						}),
						subtext: y.fbt._("All comment feeds in community will default to this sort setting", null, {
							hk: "4grj1W"
						}),
						items: Object.keys(q.i),
						selected: Object(q.p)(q.i, _),
						onClick: e => n(q.i[e], "suggestedCommentSort"),
						id: "suggestedCommentSort"
					}), r.a.createElement(T.o, {
						on: b,
						onClick: () => n(!b, "collapseDeletedComments"),
						label: y.fbt._("Collapse deleted and removed comments", null, {
							hk: "Iw8kU"
						})
					}), r.a.createElement(T.k, {
						label: y.fbt._("Minutes to hide comment scores", null, {
							hk: "1DJhj0"
						}),
						direction: "column"
					}, r.a.createElement(W, {
						onChange: e => n(e.currentTarget.value, "commentScoreHideMins"),
						isInvalid: !(h >= q.f && h <= q.a),
						min: q.f,
						max: q.a,
						type: "number",
						value: h
					})), r.a.createElement(P.a, null, y.fbt._("Advanced Settings", null, {
						hk: "53xlS"
					})), r.a.createElement(T.f, {
						label: y.fbt._("Settings for old site", null, {
							hk: "2jzUi8"
						}),
						subtext: y.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
							hk: "4DHBV2"
						}),
						link: "".concat(O.a.oldRedditUrl, "/r/").concat(s, "/about/edit"),
						onClick: () => e.sendEvent(Object(f.b)(l.Qb.Posts)),
						openInNewTab: !0,
						last: !0
					})))
				},
				ie = e => {
					const {
						crowdControlModeEnabled: t,
						crowdControlLevelEnabled: s,
						isChatPostsCreationEnabled: n,
						settings: o,
						subredditName: a,
						update: i
					} = e, {
						allowDiscovery: d,
						contentVisible: c,
						crowdControlMode: m,
						crowdControlLevel: u,
						crowdControlChatLevel: b,
						excludeBannedModqueue: h,
						toxicityThresholdChatLevel: g
					} = o, x = {
						0: {
							text: "Off",
							color: "#787C7E",
							subText: "Use Crowd Control to automatically collapse comments from users you’re not sure about."
						},
						1: {
							text: "Lenient",
							color: "#46D160",
							subText: "Comments from users who have negative karma in your community are automatically collapsed."
						},
						2: {
							text: "Moderate",
							color: "#FFB000",
							subText: "Comments from new users and users with negative karma in your community are automatically collapsed."
						},
						3: {
							text: "Strict",
							color: "#EA0027",
							subText: "Comments from users who haven’t joined your community, new users, and users with negative karma in your community are automatically collapsed."
						}
					};
					return r.a.createElement(p.a, null, r.a.createElement(V, null, r.a.createElement(p.b, null, y.fbt._("Safety & privacy settings", null, {
						hk: "34ghQV"
					})), r.a.createElement(P.a, null, y.fbt._("Safety", null, {
						hk: "2QSter"
					})), r.a.createElement(T.o, {
						on: h,
						onClick: () => i(!h, "excludeBannedModqueue"),
						label: y.fbt._("Exclude posts by site-wide banned users", null, {
							hk: "Kmfy0"
						}),
						subtext: y.fbt._("Posts are excluded from modqueue/unmoderated", null, {
							hk: "2P2pfc"
						})
					}), t && r.a.createElement(T.o, {
						on: m,
						onClick: () => i(!m, "crowdControlMode"),
						label: y.fbt._("Turn on crowd control mode", null, {
							hk: "2qY8D5"
						}),
						subtext: y.fbt._("When crowd control is enabled, comments from users who aren't yet fully trusted in your community (including new users) will display as collapsed by default", null, {
							hk: "13Z3pC"
						})
					}), s && r.a.createElement(T.i, {
						ticks: x,
						min: 0,
						max: Object.keys(x).length - 1,
						step: 1,
						value: u,
						onChange: e => i(e.target.value, "crowdControlLevel"),
						label: y.fbt._("Adjust Crowd Control", null, {
							hk: "4oJUSP"
						}),
						subtext: y.fbt._("{subText}", [y.fbt._param("subText", x[u].subText)], {
							hk: "3ZFhAV"
						})
					}), (n || C.m) && r.a.createElement(r.a.Fragment, null, r.a.createElement(T.i, {
						ticks: x,
						min: 0,
						max: Object.keys(x).length - 1,
						step: 1,
						value: b,
						onChange: e => i(e.target.value, "crowdControlChatLevel"),
						label: y.fbt._("Adjust Crowd Control for Chat Posts", null, {
							hk: "vTy7k"
						}),
						subtext: y.fbt._("{subText}", [y.fbt._param("subText", x[b].subText)], {
							hk: "12hf9Y"
						})
					}), r.a.createElement(T.o, {
						on: !!Number(g),
						onClick: () => {
							i(Number(g) ? "0" : "1", "toxicityThresholdChatLevel")
						},
						label: y.fbt._("Collapse Toxic Messages in Chat Post", null, {
							hk: "1Pk3G5"
						}),
						subtext: y.fbt._("Comments that our model scores as toxic will be automatically collapsed.", null, {
							hk: "Rohtu"
						})
					})), r.a.createElement(P.a, null, y.fbt._("Discover", null, {
						hk: "1I53SY"
					})), r.a.createElement(T.m, {
						className: se.a.sectionSubtext
					}, y.fbt._("Show your community to the general Reddit population or just to people who have similar interests, by adjusting how people can find it. Not sure what’s best for you? {=Learn More.}", [y.fbt._param("=Learn More.", r.a.createElement("a", {
						className: se.a.subtextLink,
						target: "_blank",
						rel: "noopener noreferrer",
						href: "https://mods.reddithelp.com/hc/en-us/sections/360000685771-General-Common-Questions"
					}, y.fbt._("Learn More.", null, {
						hk: "3oTITT"
					})))], {
						hk: "4nomNH"
					})), r.a.createElement(T.o, {
						on: c,
						onClick: () => i(!c, "contentVisible"),
						label: y.fbt._("Show up in high-traffic feeds", null, {
							hk: "3l7KBc"
						}),
						subtext: y.fbt._("Allow your community to be in r/all, r/popular, and trending lists where it can be seen by the general Reddit population.", null, {
							hk: "iH0lY"
						})
					}), r.a.createElement(T.o, {
						on: d,
						onClick: () => i(!d, "allowDiscovery"),
						label: y.fbt._("Get recommended to individual redditors", null, {
							hk: "4wmaiH"
						}),
						subtext: y.fbt._("Let Reddit recommend your community to people who have similar interests.", null, {
							hk: "487MMM"
						})
					}), r.a.createElement(P.a, null, y.fbt._("Advanced Settings", null, {
						hk: "3TL9Or"
					})), r.a.createElement(T.f, {
						link: "".concat(O.a.oldRedditUrl, "/r/").concat(a, "/about/edit"),
						onClick: () => e.sendEvent(Object(f.b)(l.Qb.Safety)),
						openInNewTab: !0,
						last: !0,
						label: y.fbt._("Settings for old site", null, {
							hk: "1WHvCJ"
						}),
						subtext: y.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
							hk: "2wPmwa"
						})
					})))
				},
				de = e => {
					const {
						settings: t,
						subredditName: s,
						update: n
					} = e, {
						wikiEditAge: o,
						wikiEditKarma: a,
						wikimode: i
					} = t;
					return r.a.createElement(p.a, null, r.a.createElement(V, null, r.a.createElement(p.b, null, y.fbt._("Wiki settings", null, {
						hk: "1gmluS"
					})), r.a.createElement(P.a, null, y.fbt._("Community wiki pages", null, {
						hk: "1LwxaS"
					})), r.a.createElement(T.d, {
						label: y.fbt._("Wikis can be edited by", null, {
							hk: "3brAqG"
						}),
						items: Object.keys(q.o),
						selected: Object(q.p)(q.o, i),
						onClick: e => n(q.o[e], "wikimode"),
						id: "wikimode",
						descriptions: q.n
					}), r.a.createElement(T.k, {
						label: y.fbt._("Karma required to edit and create wiki pages", null, {
							hk: "3OgR7v"
						}),
						direction: "column"
					}, r.a.createElement(W, {
						onChange: e => n(e.currentTarget.value, "wikiEditKarma"),
						isInvalid: !(a >= q.f && a <= q.m),
						min: q.f,
						max: q.m,
						type: "number",
						value: a
					})), r.a.createElement(T.k, {
						label: y.fbt._("Age of Reddit account required to edit and create wiki pages", null, {
							hk: "3UE6cD"
						}),
						direction: "column"
					}, r.a.createElement(W, {
						onChange: e => n(e.currentTarget.value, "wikiEditAge"),
						isInvalid: !(o >= q.f && o <= q.l),
						min: q.f,
						max: q.l,
						type: "number",
						value: o
					})), r.a.createElement(P.a, null, y.fbt._("Advanced Settings", null, {
						hk: "4drMhK"
					})), r.a.createElement(T.f, {
						label: y.fbt._("Settings for old site", null, {
							hk: "2YU3sQ"
						}),
						subtext: y.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
							hk: "1ihkVe"
						}),
						link: "".concat(O.a.oldRedditUrl, "/r/").concat(s, "/about/edit"),
						onClick: () => e.sendEvent(Object(f.b)(l.Qb.Wikis)),
						openInNewTab: !0,
						last: !0
					})))
				};
			const {
				fbt: le
			} = s("./node_modules/fbt/lib/FbtPublic.js"), ce = Object(d.c)({
				allowChatPostCreation: (e, t) => Object(v.b)(e, t.subredditId),
				crowdControlModeEnabled: g.d.enableCrowdControlMode,
				crowdControlLevelEnabled: g.d.enableCrowdControlLevel,
				isChatPostsCreationEnabled: (e, t) => Object(v.c)(e, t.subredditId),
				isImageGallerySettingEnabled: g.d.ImageGallerySubredditSetting,
				isEmployee: k.E,
				restrictions: C.p,
				settings: (e, t) => Object(C.T)(e, t.subredditId),
				subreddit: C.R,
				selectedPrimaryTag: _.A,
				hasSecondaryTags: _.p,
				geoPlace: (e, t) => e.tags.models.geoPlaces[t.subredditId]
			}), me = Object(i.b)(ce, (e, t) => {
				let {
					subredditId: s
				} = t;
				return {
					onViewPageEvent: () => e(Object(c.a)()),
					testWelcomeMessage: (t, s) => e(Object(m.g)(t, s)),
					save: (t, s) => e(Object(m.h)(s, t)),
					saveCommunityTopics: t => e(Object(u.i)(t, x.a.communitySettings)),
					onPrimarySelect: t => e(Object(u.j)({
						primaryTagId: t,
						subredditId: s
					})),
					savePrimaryTopic: t => {
						t && e(Object(u.s)(s, {
							tagId: t.id,
							state: E.d.TAGGED
						}, !1))
					}
				}
			});
			class ue extends r.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.saveSettings = () => {
						this.props.save(this.state.changed, this.props.subredditId), this.props.saveCommunityTopics(this.props.subredditId), this.props.savePrimaryTopic(this.props.selectedPrimaryTag);
						for (const e in this.state.changed) this.props.sendEvent(Object(f.c)(e, this.state.changed[e], this.props.settings[e]));
						this.setState({
							settings: this.state.settings,
							changed: {}
						})
					}, this.update = function(e, s) {
						let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						n && t.props.sendEvent(Object(f.d)(s, e, t.state.settings[s])), t.setState(t => ({
							changed: Object.assign({}, t.changed, {
								[s]: e
							}),
							settings: Object.assign({}, t.settings, {
								[s]: e
							})
						}))
					}, this.renderSubpage = () => {
						const e = Object.assign({}, this.props, {
							settings: this.state.settings,
							update: this.update
						});
						if (!this.state.settings) return null;
						switch (this.props.subpageName) {
							case l.Qb.Safety:
								return r.a.createElement(ie, e);
							case l.Qb.Posts:
								return r.a.createElement(re, e);
							case l.Qb.Wikis:
								return r.a.createElement(de, e);
							default:
								return r.a.createElement(ae, e)
						}
					}, this.state = {
						settings: e.settings,
						changed: {}
					}
				}
				componentDidMount() {
					this.props.onViewPageEvent()
				}
				componentDidUpdate(e) {
					!this.props.settings || o()(e.settings, this.props.settings) || o()(this.state.settings, this.props.settings) || this.setState({
						settings: this.props.settings
					})
				}
				render() {
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(p.c, null, r.a.createElement(h.f, {
						onClick: this.saveSettings,
						"data-redditstyle": !0
					}, le._("Save changes", null, {
						hk: "8mSp0"
					}))), this.renderSubpage())
				}
			}
			t.a = me(Object(b.c)(ue))
		},
		"./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/reddit/models/Tags/index.ts"),
				d = s("./src/reddit/selectors/tags.ts");
			const {
				fbt: l
			} = s("./node_modules/fbt/lib/FbtPublic.js"), c = Object(r.c)({
				selectedOptions: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(d.v)(e, {
						subredditId: s
					})
				}
			});
			t.a = Object(a.b)(c)(e => o.a.createElement(o.a.Fragment, null, e.selectedOptions.length, "/", i.a))
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less": function(e, t, s) {
			e.exports = {
				menuItemsWrapper: "_1OISxDncG3tn4CibwqeC4e",
				tooltip: "UNHdPZIwwyCehEV-NfEY7"
			}
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return T
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/tags/index.ts"),
				l = s("./src/reddit/actions/tooltip.ts"),
				c = s("./src/reddit/components/ContentTooltip/index.tsx"),
				m = s("./src/reddit/components/TrackingHelper/index.tsx"),
				u = s("./src/reddit/controls/Button/index.tsx"),
				p = s("./src/reddit/helpers/localStorage/index.ts"),
				b = s("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				h = s("./src/reddit/components/InlineSubredditEditing/index.m.less"),
				g = s.n(h);
			const {
				fbt: f
			} = s("./node_modules/fbt/lib/FbtPublic.js");
			class x extends a.a.Component {
				componentDidMount() {
					this.props.sendEvent(b.e), this.props.onViewTooltip()
				}
				render() {
					const {
						translatedTitle: e,
						translatedDesc: t,
						translatedButtonText: s
					} = this.props;
					return a.a.createElement("div", {
						className: g.a.tooltipContent,
						onClick: e => {
							e.preventDefault(), e.stopPropagation()
						}
					}, a.a.createElement("span", {
						className: g.a.topRow
					}, a.a.createElement("h3", {
						className: g.a.title
					}, e)), a.a.createElement("p", {
						className: g.a.tooltipBody
					}, t), a.a.createElement(u.f, {
						className: g.a.gotIt,
						onClick: this.props.onDismissTooltip
					}, s || f._("Got it", null, {
						hk: "4CoCjQ"
					})))
				}
			}
			var E = Object(r.b)(void 0, e => ({
				onDismissTooltip: () => {
					e(Object(l.i)()), Object(p.U)()
				},
				onViewTooltip: () => {
					Object(p.hb)()
				}
			}))(Object(m.c)(x));
			const v = "editable-primary-topic-idcard";
			var C = s("./src/reddit/controls/DropdownSelector/index.tsx"),
				_ = s("./src/reddit/models/Tags/index.ts"),
				k = s("./src/reddit/selectors/tags.ts"),
				O = s("./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less"),
				y = s.n(O);
			const j = e => {
					let {
						hasPrimaryTag: t,
						hasSecondaryTags: s
					} = e;
					if (t) return null;
					let o = n.fbt._("Add Community Topics", null, {
							hk: "2wd4kg"
						}),
						r = n.fbt._("Tell us what topics are relevant to your community so we can surface it to the right users", null, {
							hk: "24NCiQ"
						});
					return s && (o = n.fbt._("Add a Primary Topic", null, {
						hk: "41x5Gv"
					}), r = n.fbt._("Oops we don’t have a primary topic yet. Add one so we can surface your community to the right users", null, {
						hk: "XayPA"
					})), a.a.createElement(c.a, {
						className: y.a.tooltip,
						tooltipId: v,
						defaultTooltipPosition: "left",
						tooltipSizeEstimate: {
							height: 150,
							width: 320
						}
					}, a.a.createElement(E, {
						translatedTitle: o,
						translatedDesc: r
					}))
				},
				w = {
					availablePrimaryTags: k.t
				},
				S = Object(i.c)(Object.assign({}, w, {
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: s
						} = t;
						return s && Object(k.A)(e, {
							subredditId: s
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: s
						} = t;
						return Object.keys(Object(k.s)(e, {
							itemId: s
						})).length > 0
					},
					isSaving: k.G
				})),
				I = Object(i.c)(Object.assign({}, w, {
					selectedPrimaryTag: k.y,
					hasSecondaryTags: () => !1,
					isSaving: e => Object(k.G)(e)
				}));
			class P extends a.a.Component {
				constructor(e) {
					super(e), this.state = {
						tooltipDismissed: !0
					}
				}
				componentDidMount() {
					const e = this.props.onShowTooltip;
					this.setState({
						tooltipDismissed: Object(p.m)()
					}, () => {
						this.isTooltipEnabled() && e && e()
					})
				}
				isTooltipEnabled() {
					const {
						shouldShowTooltip: e = !1,
						selectedPrimaryTag: t
					} = this.props;
					return !this.state.tooltipDismissed && !t && e
				}
				render() {
					const {
						availablePrimaryTags: e,
						className: t,
						hasSecondaryTags: s,
						isSaving: o,
						onPrimaryTopicSelected: r,
						selectedPrimaryTag: i
					} = this.props, d = i && i.text;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(C.b, {
						id: this.isTooltipEnabled() ? v : void 0,
						className: t,
						isTopicsStyle: !0,
						displayText: d || n.fbt._("Add a Primary Topic", null, {
							hk: "1HgVte"
						}),
						options: e.map(e => ({
							displayText: e.text,
							value: e.id,
							isSelected: !!i && i.id === e.id
						})),
						onSelect: r,
						menuItemsClassName: y.a.menuItemsWrapper,
						showSelectedCheckmark: !0,
						isSaving: o
					}), this.isTooltipEnabled() && a.a.createElement(j, {
						hasPrimaryTag: !!i,
						hasSecondaryTags: s
					}))
				}
			}
			const T = Object(r.b)(I, e => ({
					onPrimaryTopicSelected: t => {
						e(Object(d.d)({
							primaryTagId: t.value
						}))
					}
				}))(P),
				N = Object(r.b)(S, (e, t) => {
					let {
						subredditId: s,
						onPrimarySelect: n
					} = t;
					return {
						onPrimaryTopicSelected: t => {
							t.isSelected || !n ? t.isSelected || e(Object(d.s)(s, {
								tagId: t.value,
								state: _.d.TAGGED
							})) : n(t.value)
						},
						onShowTooltip: () => {
							e(Object(l.f)({
								tooltipId: v
							}))
						}
					}
				});
			t.b = N(P)
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less": function(e, t, s) {
			e.exports = {
				suggestedTopicsContainer: "_3qCTJNZ-iSCZa0wyVfs6my",
				relatedText: "_389N9jvZJu60U3E7vIF00n",
				closeIcon: "M40GQ3RaivlkCl8WQ-pXo",
				plusIcon: "_2OYvdU1reofcbKMJ0wvC_x",
				suggestedTopic: "_1RmiLhJpOUx_hgduPf3F5O",
				closeIconContainer: "sHLJV3zATRod0k1f_m71I",
				suggestedTopicText: "_1-rmQV4Wee08Dt-h2GyW-o"
			}
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/reddit/actions/tags/index.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/icons/svgs/Close/index.tsx"),
				u = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				p = s("./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less"),
				b = s.n(p);
			var h = e => a.a.createElement("span", {
					className: b.a.suggestedTopic,
					onClick: () => e.onSuggestedTopicSelected(e.suggestedTopic)
				}, a.a.createElement(u.a, {
					className: b.a.plusIcon
				}), a.a.createElement("span", {
					className: b.a.suggestedTopicText
				}, e.suggestedTopic.displayText), a.a.createElement("span", {
					className: b.a.closeIconContainer,
					onClick: t => {
						t.preventDefault(), t.stopPropagation(), e.onSuggestedTopicDismissed(e.suggestedTopic)
					}
				}, a.a.createElement(m.a, {
					className: b.a.closeIcon
				}))),
				g = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				f = s("./src/reddit/models/Tags/index.ts"),
				x = s("./src/reddit/models/Toast/index.ts"),
				E = s("./src/reddit/selectors/tags.ts");
			const v = Object(i.c)({
					suggestedOptions: (e, t) => {
						let {
							subredditId: s
						} = t;
						const n = Object(E.B)(e, {
								itemId: s
							}),
							o = Object(E.v)(e, {
								subredditId: s
							}),
							a = Object(E.z)(e, {
								subredditId: s
							});
						return n.filter(e => !!e.id && a !== e.id && !o.find(t => !!t.id && t.id === e.id))
					}
				}),
				C = Object(r.b)(v, (e, t) => {
					let {
						subredditId: s,
						onOptionSelected: o,
						context: a
					} = t;
					return {
						onSuggestedOptionDismissed: t => {
							e(Object(l.r)(s, [], [{
								subredditId: s,
								tagId: t.id,
								isRelevant: !1
							}], a, !0))
						},
						onSuggestedOptionSelected: t => {
							e((e, r) => {
								const i = r();
								Object(E.v)(i, {
									subredditId: s
								}).length >= f.a ? e(Object(c.e)(Object.assign({}, Object(c.d)(n.fbt._("You can only add up to {max number of topics} community topics", [n.fbt._param("max number of topics", f.a.toString())], {
									hk: "1OySAh"
								}), x.b.Error), {
									duration: c.a
								}))) : (e(Object(l.n)({
									subredditId: s,
									option: t
								})), Object(g.c)(r(), s, t, {
									context: a
								}), o && o(t))
							})
						}
					}
				});
			t.a = C(e => e.suggestedOptions.length ? a.a.createElement("div", {
				className: Object(d.a)(b.a.suggestedTopicsContainer, e.className)
			}, e.children || a.a.createElement("span", {
				className: b.a.relatedText
			}, n.fbt._("Related:", null, {
				hk: "1qt7CO"
			})), e.suggestedOptions.map(t => a.a.createElement(h, {
				key: t.id,
				suggestedTopic: t,
				onSuggestedTopicSelected: e.onSuggestedOptionSelected,
				onSuggestedTopicDismissed: e.onSuggestedOptionDismissed
			}))) : null)
		},
		"./src/reddit/components/CommunityTopics/index.m.less": function(e, t, s) {
			e.exports = {
				communityTopicsContainer: "wsNyCIZw7veQPURlfXwXb"
			}
		},
		"./src/reddit/components/CommunityTopics/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return x
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/tags/index.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				c = s("./src/reddit/components/MultiOptionSelect/index.tsx"),
				m = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				u = s("./src/reddit/models/Tags/index.ts"),
				p = s("./src/reddit/models/Toast/index.ts"),
				b = s("./src/reddit/selectors/tags.ts"),
				h = s("./src/reddit/components/CommunityTopics/index.m.less"),
				g = s.n(h);
			const f = Object(i.c)({
				availableSubredditTags: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(b.d)(e, {
						subredditId: s
					})
				},
				subredditTags: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(b.s)(e, {
						itemId: s
					})
				},
				availableGlobalOptions: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(b.a)(e, {
						thingId: s
					})
				},
				selectedOptions: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(b.v)(e, {
						subredditId: s
					})
				},
				isLoading: e => Object(b.E)(e),
				currentInput: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(b.l)(e, {
						subredditId: s
					})
				}
			});
			class x extends a.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							s = e.filter(e => !e.selected);
						this.onOptionsSelected(t), s.forEach(e => this.onOptionDeselected(e))
					}, this.onFocus = () => {
						this.props.onSearchBarFocused(), this.props.onFocus && this.props.onFocus()
					}
				}
				onOptionsSelected(e) {
					const t = u.a - this.props.selectedOptions.length,
						s = e.filter(e => !!e.displayText.trim()),
						n = s.slice(0, t);
					n.forEach(e => {
						if (!e.id) {
							const t = Object(b.c)(e.displayText, this.props.availableSubredditTags);
							t && (e = Object(u.f)(t, !0))
						}
						this.props.optionSelected(Object.assign({}, e, {
							displayText: e.displayText.trim()
						}))
					}), n.length !== s.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(e)
				}
				render() {
					return a.a.createElement("div", {
						className: g.a.communityTopicsContainer
					}, a.a.createElement(c.a, {
						readOnlyMode: this.props.readOnlyMode,
						addText: n.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						childClassNames: this.props.childClassNames,
						dropdownHeaderText: n.fbt._("Suggested topics", null, {
							hk: "1RASWg"
						}),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > u.a,
						isLoading: this.props.isLoading,
						maxOptionLength: u.b,
						maxOptionsToDisplay: this.props.maxTopicsToDisplay,
						onSearchBarFocus: this.onFocus,
						onSearchBarBlur: this.props.onBlur,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: !0
					}, this.props.children))
				}
			}
			t.b = Object(r.b)(f, (e, t) => {
				let {
					subredditId: s,
					context: o
				} = t;
				return {
					optionSelected: t => {
						e(Object(d.n)({
							subredditId: s,
							option: t
						})), e((e, n) => {
							m.e(n(), s, t, {
								context: o
							})
						})
					},
					optionDeselected: t => {
						e(Object(d.m)({
							subredditId: s,
							option: t
						})), e((e, n) => {
							m.d(n(), s, t, {
								context: o
							})
						})
					},
					onInputChanged: t => e(Object(d.l)({
						subredditId: s,
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {
						m.b(t(), s, {
							context: o
						})
					}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(l.e)(Object.assign({}, Object(l.d)(n.fbt._({
							"*": "You can only add up to max {number} community topics",
							_1: "You can only add up to max 1 community topic"
						}, [n.fbt._plural(u.a, "number")], {
							hk: "s07I1"
						}), p.b.Error), {
							duration: l.a
						})))
					})
				}
			})(x)
		},
		"./src/reddit/components/CompactPost/index.m.less": function(e, t, s) {
			e.exports = {
				hideAboveSmallTablet: "FX_aWE8xMirpzniJDh7I9",
				responsiveExpandoButton: "_3gazhzxd2iBGYb2k67_HTw",
				mHideAboveSmallTablets: "_2zV_ARVPrYN10xmbbb_4Lu",
				responsiveMeta: "_1xomvNxK4aHGoGa-YDw1Mc",
				verticalVotes: "WAapGmF_gr09J509Af-gC",
				commentsLink: "Nz0lkWnnj2V_4iBKE0WL7",
				hideBelowSmallTablet: "z_7pbLL4hZp6ikYkq0prE",
				horizontalVotes: "_37nbKm3ee5NGx6e-LXErLD",
				postTopMeta: "_1ghZRP5m5xDLh0up1rFt0e",
				mHideBelowSmallTablets: "_3x_hdVQw5uJh6xeAGoZock",
				adLinkWrapper: "_4Dt8djtbHlJ5uCZDX_SeV",
				content: "_1B7SUGHK0QDoHimxX2a9D0",
				leftRail: "_2r9FABr2qYEUDyZoenhn6N",
				bulkActionCheckbox: "_44ehKZ_pl1NGGaaTYouZR",
				subredditIcon: "_1kWbgdOrvSeXIZZRIw4uBS",
				topLine: "_2ZjElFi3ORaU3VPrwmdoCp",
				postBadges: "_126a2ACB41algqMEwA34TF",
				flatList: "_3jwri54NGT-SRatPIZYiMo",
				expandedContentWrapper: "_12wy0ZFFaS3a49145uXWXt",
				crosspostMediaWrapper: "_2fCIreZsKBNS3esgsKKksM",
				compactWrapper: "YA9IzN0YR-G5_oD5EUydl",
				compactPostRow: "WnMeTcero48dKo501T-19",
				donationAmount: "_1TjU-e4dgCSlbuHHatC0G9",
				leftRailWrapper: "_3YgWdffoKyCp7UaGAEQpoo",
				proposalMetaData: "_1_B8IWlNlt5jJVg4cKy7nL",
				isEvent: "_1csviRG5jI9xOrcsmpbfwt",
				chain: "_1el-fLKTUXg-19pIbGUHgk",
				modToolsFlatlist: "_20p7Nh6bZU7MOqYuB2uJcy",
				postContainer: "_2bHVWuR_l_wVivC3FKfLFf",
				leftBorderWrapper: "_3ZmFVbkR23TIZ-3nboLYXe"
			}
		},
		"./src/reddit/components/CompactPost/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "renderSubredditIcon", (function() {
				return Pe
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/config.ts"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				m = s("./src/reddit/components/TrackingHelper/index.tsx"),
				u = s("./src/reddit/constants/postLayout.ts"),
				p = s("./src/reddit/helpers/showReportIndicator/index.ts"),
				b = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				h = s("./src/reddit/helpers/trackers/post.ts"),
				g = s("./src/reddit/models/Media/index.ts"),
				f = s("./src/reddit/models/User/index.ts"),
				x = s("./src/reddit/models/Vote/index.ts"),
				E = s("./src/reddit/actions/post.ts"),
				v = s("./src/reddit/actions/postFlair.ts"),
				C = s("./src/reddit/actions/tooltip.ts"),
				_ = s("./src/reddit/selectors/activeModalId.ts"),
				k = s("./src/reddit/selectors/moderatorPermissions.ts"),
				O = s("./src/reddit/selectors/postFlair.ts"),
				y = s("./src/reddit/selectors/posts.ts"),
				j = s("./src/reddit/selectors/user.ts"),
				w = s("./src/reddit/components/AdLinkWrapper/index.tsx"),
				S = s("./src/reddit/components/AwardBadges/index.tsx"),
				I = s("./src/reddit/components/CallToActionButton/index.tsx"),
				P = s("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				T = s("./src/reddit/components/CommentsLink/index.tsx"),
				N = s("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				M = s("./src/reddit/components/Economics/Support/DonationAmount/async.tsx"),
				R = s("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				L = s("./src/reddit/components/ExpandoButton/index.tsx"),
				A = s("./src/reddit/components/Flatlist/index.tsx"),
				F = s("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				D = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				B = s("./src/reddit/components/ModActionsMenu/index.tsx"),
				U = s("./src/reddit/components/ModerationPrompts/Prompt.tsx"),
				H = s("./src/reddit/components/ModerationPrompts/Survey.tsx"),
				W = s("./src/reddit/components/ModModeReports/index.tsx"),
				V = s("./src/reddit/components/ModModeReports/helpers.ts"),
				q = s("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				G = s("./src/reddit/components/PopupPortal/index.tsx"),
				K = s("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				z = s("./src/reddit/components/PostBadges/index.tsx"),
				Q = s("./src/reddit/components/PostContainer/index.tsx"),
				J = s("./src/reddit/components/PostFlairPicker/index.tsx"),
				Z = s("./src/reddit/components/PostLeftRail/index.tsx"),
				X = s("./src/reddit/components/PostMedia/index.tsx"),
				Y = s("./src/reddit/components/PostModModeDropdown/index.tsx"),
				$ = s("./src/reddit/components/PostOverflowMenu/index.tsx"),
				ee = s("./src/reddit/components/PostTitle/index.tsx"),
				te = s("./src/reddit/components/PostTopMeta/index.tsx"),
				se = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				ne = s("./src/reddit/components/SponsoredLabel/index.tsx"),
				oe = s("./src/reddit/components/SubredditIcon/index.tsx"),
				ae = s("./src/reddit/components/VerticalVotes/index.tsx"),
				re = s("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				ie = s("./src/reddit/contexts/InsideOverlay.tsx"),
				de = s("./src/reddit/contexts/PageLayer/index.tsx"),
				le = s("./src/reddit/controls/Checkbox/index.tsx"),
				ce = s("./src/reddit/controls/MetaData/index.tsx"),
				me = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				ue = s("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				pe = s("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				be = s("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				he = s("./src/reddit/helpers/postEvent.ts"),
				ge = s("./src/reddit/icons/fonts/IgnoreReport/index.tsx"),
				fe = s("./src/reddit/icons/fonts/Report/index.tsx"),
				xe = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				Ee = s.n(xe),
				ve = s("./src/reddit/components/CompactPost/index.m.less"),
				Ce = s.n(ve);

			function _e() {
				return (_e = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var ke = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const Oe = e => {
					var {
						isCompact: t
					} = e, s = ke(e, ["isCompact"]);
					return o.a.createElement(L.a, _e({
						className: Object(l.a)(Ce.a.responsiveExpandoButton, {
							[Ce.a.mHideAboveSmallTablets]: !!t,
							[Ce.a.mHideBelowSmallTablets]: !t
						})
					}, s))
				},
				ye = Object(a.b)(() => Object(i.c)({
					activeModalId: _.a,
					crosspost: y.d,
					currentUser: j.i,
					flairStyleTemplate: de.R,
					isActive: y.j,
					isExpanded: y.m,
					layout: de.N,
					moderatorPermissions: k.i,
					modModeEnabled: de.P,
					poll: (e, t) => {
						const s = e.posts.metaMap[t.postId];
						if (s) return e.polls.models[s]
					},
					post: y.O,
					showEditFlair: O.a,
					subredditOrProfile: y.bb,
					userIsOp: j.hb
				}), (e, t) => {
					let {
						listingKey: s,
						listingName: n,
						postId: o
					} = t;
					return {
						dispatchFlairChanged: t => {
							let {
								post: s,
								previewFlair: n,
								selectedTemplateId: o
							} = t;
							return e(Object(v.h)({
								post: s,
								previewFlair: n,
								selectedTemplateId: o
							}))
						},
						handleVote: t => {
							const s = t === x.a.upvoted ? Object(E.db)(o) : Object(E.z)(o);
							e(s)
						},
						onIgnoreReports: () => e(Object(E.bb)(o)),
						onOpenReportsDropdown: t => e(Object(C.h)({
							tooltipId: t
						}))
					}
				}, (e, t, s) => Object.assign({}, s, e, t, {
					onFlairChanged: s => {
						let {
							previewFlair: n,
							selectedTemplateId: o
						} = s;
						return t.dispatchFlairChanged({
							post: e.post,
							previewFlair: n,
							selectedTemplateId: o
						})
					}
				}));
			class je extends o.a.Component {
				componentDidUpdate(e) {
					this.props.onSizeChanged && e.isExpanded !== this.props.isExpanded && this.props.onSizeChanged(this.props.post.id)
				}
				render() {
					const {
						activeModalId: e,
						className: t,
						currentProfileName: s,
						crosspost: n,
						currentUser: a,
						eventFactory: r,
						flairStyleTemplate: i,
						handleVote: c,
						isCheckboxSelected: m = !1,
						isCommentsPage: x,
						isCommentPermalink: E,
						isExpanded: v,
						isOverlay: C,
						isProfilePostListing: _,
						inSubredditOrProfile: k = !1,
						layout: O,
						moderatorPermissions: y,
						modModeEnabled: j,
						onClickPost: L,
						onFlairChanged: X,
						onIgnoreReports: ne,
						poll: oe,
						post: ie,
						subredditOrProfile: de,
						userIsOp: ce,
						hideModTools: xe,
						scrollerItemRef: ve,
						showBulkActionCheckbox: _e,
						showEditFlair: ke,
						toggleCheckbox: Oe,
						tooltipType: ye,
						sendEvent: je
					} = this.props, Se = !!ie.media && ie.media.type === g.n.RTJSON, Pe = ce && Se, Ne = Object(J.b)(ie.id, C), Me = Object(be.a)(y), Re = Object(ue.a)(y), Le = Object(pe.a)(y), Ae = "-mod-actions-menu-".concat(ie.id), Fe = "voting-arrows-".concat(ie.id), De = !!a && Object(f.e)(a) === ie.author, Be = Object(V.c)(ie), Ue = Object(F.a)("View--Reports", ie.id, ye), He = Object(V.a)(ie), We = !(C || x || E), Ve = ie.media && ie.media.type === g.n.LIVEVIDEO, {
						moderationPrompt: qe
					} = ie, Ge = e => je(Object(h.f)(ie.id, e)), Ke = o.a.createElement(Q.a, {
						className: Object(l.a)(Ee.a.compactPostStyles, Ce.a.postContainer, Object(b.a)(this.props), t),
						isOverlay: C,
						style: Object.assign({}, Object(b.d)(this.props), Object(b.b)(this.props.flairStyleTemplate)),
						post: ie,
						onClick: L,
						eventFactory: r
					}, o.a.createElement("div", {
						className: Ce.a.compactWrapper
					}, o.a.createElement("div", {
						className: Ce.a.leftRailWrapper
					}, o.a.createElement("div", {
						className: Ce.a.leftRail,
						style: {
							borderColor: Object(Z.c)({
								isRemoved: !!ie.bannedBy,
								isReported: Object(p.a)(ie),
								isSponsored: ie.isSponsored,
								theme: this.props.theme
							})
						}
					}, _e && o.a.createElement(le.a, {
						className: Ce.a.bulkActionCheckbox,
						isCheckboxSelected: m,
						toggleCheckbox: Oe
					}), o.a.createElement(ae.a, {
						className: Ce.a.verticalVotes,
						compact: !0,
						flairStyleTemplate: i,
						model: ie,
						onVoteClick: c
					}), o.a.createElement(N.a, {
						className: Ce.a.horizontalVotes,
						compact: !1,
						flairStyleTemplate: i,
						model: ie,
						onVoteClick: c,
						upvoteTooltipId: Fe
					}), qe && o.a.createElement(G.b, {
						rightOf: Fe
					}, "survey" === qe ? o.a.createElement(H.a, {
						post: ie,
						subredditName: de.name,
						isOverlay: !!C
					}) : o.a.createElement(U.a, {
						post: ie,
						subredditName: de.name,
						isOverlay: !!C
					})))), o.a.createElement(K.a, {
						className: Object(l.a)(Ce.a.content, {
							[Ce.a.isEvent]: Object(he.a)(ie)
						}),
						"data-click-id": "background",
						flairStyleTemplate: i
					}, o.a.createElement(R.a, {
						isCompactMode: !0,
						post: ie
					}), o.a.createElement("div", {
						className: Ce.a.compactPostRow
					}, !xe && Ie(ie, n, v, !1), !k && !ie.isSponsored && o.a.createElement(D.h, {
						type: ie.belongsTo.type,
						id: ie.belongsTo.id
					}), o.a.createElement("div", {
						className: Ce.a.topLine,
						"data-click-id": "body"
					}, o.a.createElement(ee.c, {
						post: ie,
						poll: oe,
						size: ee.b.Small,
						titleColor: i && i.postTitleColor,
						isOverlay: !1
					}), Te(ie, de), o.a.createElement(te.d, {
						className: Ce.a.postTopMeta,
						flairStyleTemplate: i,
						post: ie,
						showSub: !!de && !k && !ie.isSponsored,
						subredditOrProfile: de
					}), o.a.createElement(z.a, {
						className: Ce.a.postBadges,
						displayText: de ? de.displayText : null,
						inSubredditOrProfile: k,
						post: ie
					}), de && o.a.createElement(M.a, {
						className: Ce.a.donationAmount,
						contentId: ie.id,
						subredditId: de.id
					}), o.a.createElement(S.a, {
						isOverlay: !!C,
						thing: ie
					})), We && !Ve && o.a.createElement("div", null, o.a.createElement(P.a, {
						className: Ce.a.liveDiscussionIcon,
						isMod: Me,
						postId: ie.postId
					})), o.a.createElement("div", {
						className: Ce.a.flatList
					}, o.a.createElement(T.a, {
						className: Ce.a.commentsLink,
						hasModPostPerms: Me,
						isCommentsPage: x,
						isCommentPermalink: E,
						isOverlay: C,
						postId: ie.id,
						modModeEnabled: j,
						numComments: ie.numComments,
						type: u.g.Compact
					}), o.a.createElement(q.a, {
						className: Ce.a.modToolsFlatlist,
						isOverlay: !1,
						layout: O,
						modModeEnabled: j,
						post: ie,
						sendEvent: je,
						showIconsOnly: !0
					}), Me && o.a.createElement(B.a, {
						dropdownId: Ae,
						onClick: () => Ge("post_mod_action_menu")
					}, o.a.createElement(A.b, null), o.a.createElement(Y.a, {
						canEditFlair: Re && ke,
						hasModPostPerms: Me,
						hasModFullPerms: Le,
						isOverlay: !1,
						isPostAuthor: De,
						modModeEnabled: j,
						post: ie,
						tooltipId: Ae
					})), Me && Be && !j && o.a.createElement(se.c, {
						text: "".concat(He),
						onClick: () => {
							this.props.onOpenReportsDropdown(Ue), Ge("post_report_menu")
						},
						id: Ue
					}, o.a.createElement(re.a, {
						model: ie,
						onIgnoreReports: () => {
							ne(), Ge(ie.ignoreReports ? "restore_reports" : "ignore_reports")
						},
						tooltipId: Ue
					}), ie.ignoreReports ? o.a.createElement(ge.a, null) : o.a.createElement(fe.a, null)), o.a.createElement($.g, {
						currentProfileName: s,
						isCommentsPage: x,
						isOverlay: !1,
						isProfilePostListing: _,
						layout: O,
						permalink: ie.permalink,
						postId: ie.postId,
						sendEvent: je,
						showEditPost: Pe,
						showEditFlair: ke,
						dropdownId: "".concat(ie.id, "-overflow-menu"),
						useFlatlistBreakpoints: Object($.h)({
							share: !1,
							editPost: !1,
							save: !1,
							gild: !1,
							hide: !1,
							report: !1
						})
					}), !xe && Ie(ie, n, v, !0))), ie.source && ie.source.url && ie.isSponsored && o.a.createElement(w.a, {
						className: Ce.a.adLinkWrapper
					}, o.a.createElement(me.a, {
						href: ie.source.url.replace(d.a.redditUrl, ""),
						isSponsored: ie.isSponsored,
						postId: ie.id,
						source: ie.source
					}, ie.source.displayText), ie.callToAction && o.a.createElement(I.a, {
						href: ie.source.url.replace(d.a.redditUrl, ""),
						isSponsored: ie.isSponsored,
						postId: ie.id,
						source: ie.source,
						isNotCardView: !0
					}, ie.callToAction)), j && Me && Be && o.a.createElement("div", {
						className: Ce.a.compactPostRow
					}, o.a.createElement(W.a, {
						onIgnoreReports: ne,
						reportable: ie
					})), o.a.createElement(D.d, {
						postId: ie.id
					}))), v && o.a.createElement(we, {
						post: ie,
						scrollerItemRef: ve,
						flairStyleTemplate: i
					}), e === Ne && o.a.createElement(J.a, {
						flairs: ie.flair,
						subredditId: ie.belongsTo.id,
						modalId: Ne,
						onFlairChanged: X
					}));
					return o.a.createElement(o.a.Fragment, null, Ke)
				}
			}
			const we = e => o.a.createElement(K.a, {
					className: Object(l.a)(e.className, Ce.a.expandedContentWrapper),
					flairStyleTemplate: e.flairStyleTemplate
				}, e.post.crosspostRootId ? o.a.createElement("div", {
					className: Ce.a.crosspostMediaWrapper
				}, Se(e.post, e.scrollerItemRef)) : Se(e.post, e.scrollerItemRef)),
				Se = (e, t) => o.a.createElement(X.a, {
					isExpando: !0,
					isListing: !0,
					isNotCardView: !0,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					showFull: !0,
					showCentered: !0,
					post: e
				}),
				Ie = (e, t, s, n) => o.a.createElement(Oe, {
					crosspost: t,
					isCompact: n,
					isExpanded: s,
					post: e,
					useMediaIcons: !0
				}),
				Pe = e => o.a.createElement(r.a, {
					"data-click-id": "subreddit",
					to: e.url
				}, o.a.createElement(oe.b, {
					className: Ce.a.subredditIcon,
					subredditOrProfile: e
				})),
				Te = (e, t) => o.a.createElement("div", {
					className: Ce.a.responsiveMeta
				}, o.a.createElement(ce.b, {
					isScoreHidden: e.scoreHidden,
					score: e.score
				}), o.a.createElement(ce.c, null), Object(ce.d)(e.numComments), o.a.createElement(ce.c, null), t && o.a.createElement("a", {
					href: t.url
				}, o.a.createElement(ce.a, null, t.displayText)), e.isSponsored && [o.a.createElement(ne.a, {
					key: "label"
				}), o.a.createElement(ce.c, {
					key: "separator"
				})], !e.isSponsored && o.a.createElement(ce.a, null, " Posted by "), o.a.createElement(te.b, {
					post: e
				}));
			t.default = ye(Object(m.c)(Object(ie.b)(Object(c.a)(je))))
		},
		"./src/reddit/components/ConfirmModal/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_3DhQ2s_h1XCiwltypHmlbp",
				close: "_2oxgXPm-tiPAEPsJoUw-ZD",
				headerText: "_2sDCzF6zlpNJ5cbVDRCPOS",
				text: "_3eWjwYvkDvPzyq4FlubrF9",
				buttonWrapper: "_6ZHRZ8Epefe887d7LL-q6",
				primaryButton: "Ch-0dFLxLOtcc6xCyQvsk",
				secondaryButton: "bgwHoiDoSwFVZKRTLRQMF"
			}
		},
		"./src/reddit/components/ConfirmModal/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/higherOrderComponents/asModal/index.tsx"),
				r = s("./src/reddit/controls/Button/index.tsx"),
				i = s("./src/reddit/components/ConfirmModal/index.m.less"),
				d = s.n(i),
				l = s("./src/reddit/components/ModalStyledComponents/index.tsx");
			t.a = Object(a.a)(e => o.a.createElement("div", {
				className: d.a.container
			}, o.a.createElement("button", {
				onClick: () => e.onClose ? e.onClose() : e.onCancel(),
				className: d.a.close
			}, o.a.createElement(l.b, null)), o.a.createElement(l.h, null, o.a.createElement("h2", {
				className: d.a.headerText
			}, e.headerText)), o.a.createElement(l.k, null, e.message && o.a.createElement("p", {
				className: d.a.text
			}, e.message), e.children && o.a.createElement("div", {
				className: d.a.text
			}, e.children), o.a.createElement("div", {
				className: d.a.buttonWrapper
			}, e.cancelText && o.a.createElement(r.i, {
				className: d.a.secondaryButton,
				onClick: e.onCancel
			}, e.cancelText), o.a.createElement(r.f, {
				className: d.a.primaryButton,
				onClick: e.onAccept
			}, e.acceptText)))))
		},
		"./src/reddit/components/ContentGate/index.m.less": function(e, t, s) {
			e.exports = {
				ButtonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				buttonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				Container: "_32zGs4bO3IunZfS9bSJY0_",
				container: "_32zGs4bO3IunZfS9bSJY0_",
				Description: "_3VTI5BOpJO70xoBKSqz3O9",
				description: "_3VTI5BOpJO70xoBKSqz3O9",
				PrivateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				privateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				PrivateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				privateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				PrivateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				privateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				Link: "o4oSRcSrppMzf__hxJKxn",
				link: "o4oSRcSrppMzf__hxJKxn",
				LinkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				linkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				LinkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				linkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				SecondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				secondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				SecondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				secondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				GoHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				goHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				Image: "_1jefpljVGT-eHObg40F8Dm",
				image: "_1jefpljVGT-eHObg40F8Dm",
				ImagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				imagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				LeftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				leftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				LeftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				leftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				SecondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				secondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				SecondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				secondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				Title: "_2XKLlvmuqdor3RvVbYZfgz",
				title: "_2XKLlvmuqdor3RvVbYZfgz",
				PageBody: "bDDEX4BSkswHAG_45VkFB",
				pageBody: "bDDEX4BSkswHAG_45VkFB",
				QuarantineMessageWrapper: "_3wi4h3DGgmtUEzxlHDUM0n",
				quarantineMessageWrapper: "_3wi4h3DGgmtUEzxlHDUM0n"
			}
		},
		"./src/reddit/components/ContentGate/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./src/config.ts"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router/esm/react-router.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/loginHref/index.ts"),
				c = s("./src/reddit/actions/contentGate.ts"),
				m = s("./src/reddit/actions/preferences.ts"),
				u = s("./src/reddit/components/CreateCommunityButton/index.tsx"),
				p = s("./src/lib/lessComponent.tsx"),
				b = s("./src/reddit/components/Footer/index.m.less"),
				h = s.n(b);
			const {
				fbt: g
			} = s("./node_modules/fbt/lib/FbtPublic.js"), f = p.a.div("FooterContainer", h.a), x = p.a.div("UserAgreement", h.a), E = p.a.a("UserAgreementLink", h.a), v = p.a.a("PrivacyLink", h.a);
			var C = () => a.a.createElement(f, null, a.a.createElement(x, null, g._("Use of this site constitutes acceptance of our {=User Agreement} and {=Privacy Policy} . ©{year} reddit inc. All rights reserved. REDDIT and the ALIEN Logo are registered trademarks of reddit inc.", [g._param("=User Agreement", a.a.createElement(E, {
					href: "".concat(n.a.redditUrl, "/help/useragreement")
				}, g._("User Agreement", null, {
					hk: "2srkM2"
				}))), g._param("=Privacy Policy", a.a.createElement(v, {
					href: "".concat(n.a.redditUrl, "/help/privacypolicy")
				}, g._("Privacy Policy", null, {
					hk: "2nBcYA"
				}))), g._param("year", (new Date).getFullYear())], {
					hk: "335pdO"
				}))),
				_ = s("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				k = s("./src/reddit/components/RichTextJson/index.tsx"),
				O = (s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/lodash/flatMap.js")),
				y = s.n(O),
				j = s("./src/lib/linkMatchers/index.ts"),
				w = s("./src/lib/linkMatchers/customLinks.ts"),
				S = s("./src/reddit/controls/OutboundLink/index.tsx");
			const I = /\[(.+?)\]\((.+?)\)/g,
				P = e => {
					const t = e.split(I);
					if (1 === t.length) return [e];
					const s = [];
					for (let n = 0; n < t.length; n += 3) {
						const [e, o, a] = t.slice(n, n + 3);
						s.push(e), s.push([a, o])
					}
					return s
				};
			var T = a.a.memo(e => {
					let t = [e.text];
					return e.parseMdLinks && (t = y()(t, P)), e.parseRegularLinks && (t = y()(t, e => Array.isArray(e) ? [e] : (e => {
						const t = j.e.add(w.g.subreddit.prefix, w.g.subreddit.config).match(e);
						if (!t) return [e];
						const s = [];
						let n = null;
						for (const o of t) s.push(e.slice(n ? n.lastIndex : 0, o.index)), n = o, s.push([o.url, o.text]);
						return n && s.push(e.slice(n.lastIndex)), s
					})(e))), a.a.createElement(a.a.Fragment, null, " ", t.map((t, s) => {
						if (Array.isArray(t)) {
							const [n, o] = t;
							return a.a.createElement(S.a, {
								className: e.linkClassName,
								href: n,
								isSponsored: !1,
								key: s,
								source: null
							}, o)
						}
						return a.a.createElement("span", {
							key: s
						}, t)
					}), " ")
				}),
				N = s("./src/reddit/contexts/PageLayer/index.tsx"),
				M = s("./src/reddit/controls/Button/index.tsx"),
				R = s("./src/reddit/models/ContentGate.ts"),
				L = s("./src/reddit/selectors/meta.ts"),
				A = s("./src/reddit/selectors/user.ts"),
				F = s("./src/reddit/components/ContentGate/index.m.less"),
				D = s.n(F);
			const {
				fbt: B
			} = s("./node_modules/fbt/lib/FbtPublic.js"), U = p.a.div("ButtonsContainer", D.a), H = p.a.div("Container", D.a), W = p.a.div("Description", D.a), V = p.a.div("PrivateSubredditDetails", D.a), q = p.a.div("PrivateSubredditDescription", D.a), G = p.a.h3("PrivateSubredditName", D.a), K = p.a.a("Link", D.a), z = p.a.wrapped(M.h, "LinkRouterButton", D.a), Q = p.a.wrapped(M.g, "LinkButton", D.a), J = p.a.wrapped(M.k, "SecondaryLinkRouterButton", D.a), Z = p.a.wrapped(M.j, "SecondaryLinkButton", D.a), X = p.a.wrapped(z, "GoHomeLinkButton", D.a), Y = p.a.img("Image", D.a), $ = p.a.img("ImagePlaceholder", D.a), ee = p.a.wrapped(z, "LeftLinkRouterButton", D.a), te = p.a.wrapped(Q, "LeftLinkButton", D.a), se = p.a.wrapped(Z, "SecondaryLeftLinkButton", D.a), ne = p.a.wrapped(J, "SecondaryLeftLinkRouterButton", D.a), oe = p.a.h3("Title", D.a), ae = p.a.div("PageBody", D.a), re = p.a.div("QuarantineMessageWrapper", D.a), ie = Object(d.c)({
				isLoggedIn: A.G,
				origin: L.l,
				user: A.i
			}), de = Object(N.t)(), le = Object(r.b)(ie, (e, t) => {
				let {
					subredditName: s
				} = t;
				return {
					continueToQuarantinedSubreddit: async () => {
						await e(m.C(s)), window.location.reload()
					},
					setNSFWPreference: async () => {
						await e(Object(c.l)())
					}
				}
			}), ce = e => {
				const {
					banMessage: t,
					contentGateType: s,
					continueToQuarantinedSubreddit: o,
					isLoggedIn: r,
					location: i,
					origin: d,
					pageLayer: m,
					quarantineRequiresEmail: p,
					quarantineMessage: b,
					quarantineMessageHtml: h,
					quarantineMessageRTJson: g,
					setNSFWPreference: f,
					subredditDescription: x,
					subredditName: E,
					user: v
				} = e, C = () => {
					r ? f() : Object(c.k)(), window.location.reload()
				};
				switch (s) {
					case R.a.GoldSubreddit:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/gold/premium-crest.png")
						}), a.a.createElement(oe, null, B._("r/{community name} is a Reddit Premium community", [B._param("community name", E)], {
							hk: "2lyDwB"
						})), a.a.createElement(W, null, B._("The moderators in this community have set it to Reddit Premium members only. You must upgrade to a Reddit Premium membership to continue.", null, {
							hk: "mIiOw"
						})), a.a.createElement(U, null, v ? a.a.createElement(se, {
							href: "".concat(n.a.redditUrl, "/premium")
						}, B._("Get Premium", null, {
							hk: "3ChWi4"
						})) : a.a.createElement(te, {
							href: Object(l.a)(i, d)
						}, B._("Sign Up", null, {
							hk: "rvpjy"
						})), v ? a.a.createElement(z, {
							to: "/"
						}, B._("Go Home", null, {
							hk: "49p4or"
						})) : a.a.createElement(Z, {
							href: Object(l.a)(i, d)
						}, B._("Log in", null, {
							hk: "odEG4"
						}))));
					case R.a.Nsfw:
					case R.a.NsfwCustomFeed:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/content-gate-icons/nsfw.png")
						}), a.a.createElement(oe, null, s === R.a.Nsfw ? B._("You must be 18+ to view this community", null, {
							hk: "IQmEA"
						}) : B._("You must be 18+ to view this Custom Feed", null, {
							hk: "3pmHS2"
						})), a.a.createElement(W, null, B._("You must be at least eighteen years old to view this content. Are you over eighteen and willing to see adult content?", null, {
							hk: "gI12S"
						})), a.a.createElement(U, null, a.a.createElement(ee, {
							to: "/"
						}, B._("No", null, {
							hk: "3fMglW"
						})), a.a.createElement(Z, {
							onClick: C
						}, B._("Yes", null, {
							hk: "2hpRkN"
						}))));
					case R.a.PrivateSubreddit:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/content-gate-icons/private.png")
						}), a.a.createElement(oe, null, B._("You must be invited to visit this community", null, {
							hk: "dHP8K"
						})), x && x.length && a.a.createElement(V, null, a.a.createElement(G, null, "r/", E), a.a.createElement(q, null, a.a.createElement("div", null, x))), a.a.createElement(W, null, B._("The moderators in this community have set it to private. You must be a moderator or approved user to visit.", null, {
							hk: "nwL0k"
						})), a.a.createElement(U, null, v ? a.a.createElement(se, {
							href: "".concat(n.a.redditUrl, "/message/compose?to=/r/").concat(E)
						}, B._("Message Mods", null, {
							hk: "vVe1i"
						})) : a.a.createElement(se, {
							href: Object(l.a)(i, d)
						}, B._("Sign Up", null, {
							hk: "rvpjy"
						})), a.a.createElement(z, {
							to: "/"
						}, v ? B._("Go Home", null, {
							hk: "49p4or"
						}) : B._("Explore Reddit", null, {
							hk: "3IwwVU"
						}))));
					case R.a.QuarantinedSubreddit:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/content-gate-icons/quarantined.png")
						}), a.a.createElement(oe, null, B._("Are you sure you want to view this community?", null, {
							hk: "2BtxLM"
						})), a.a.createElement(W, null, B._("This community is {=quarantined}", [B._param("=quarantined", a.a.createElement(K, {
							href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/quarantined-subreddits"
						}, B._("quarantined", null, {
							hk: "2XqfJa"
						})))], {
							hk: "2B9i8y"
						}), a.a.createElement(re, null, g ? a.a.createElement(k.a, {
							content: g,
							rtJsonElementProps: {
								pageLayer: m
							}
						}) : h ? a.a.createElement(_.a, {
							html: h
						}) : b || B._("Quarantined communities are dedicated to shocking or highly offensive content. You must be logged in with a verified email to continue.", null, {
							hk: "3kRIzE"
						})), B._("Are you certain you want to continue?", null, {
							hk: "1gr5Bw"
						})), a.a.createElement(U, null, ((e, t, s) => {
							return !(e && e.hasVerifiedEmail) && s ? a.a.createElement(U, null, a.a.createElement(ne, {
								to: "/"
							}, B._("No Thank You", null, {
								hk: "4B26AR"
							})), a.a.createElement(Q, {
								href: "".concat(n.a.redditUrl, "/prefs/update")
							}, B._("Verify Email", null, {
								hk: "1893cq"
							}))) : a.a.createElement(U, null, a.a.createElement(ee, {
								to: "/"
							}, B._("No Thank You", null, {
								hk: "4B26AR"
							})), a.a.createElement(Z, {
								onClick: t
							}, B._("Continue", null, {
								hk: "4nU0mS"
							})))
						})(v, o, p)));
					case R.a.SubredditBanned:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/content-gate-icons/banned.png")
						}), a.a.createElement(oe, null, B._("r/{community name} has been banned from Reddit", [B._param("community name", E)], {
							hk: "2at9Se"
						})), (e => a.a.createElement(W, null, e ? a.a.createElement(T, {
							linkClassName: D.a.Link,
							text: e,
							parseMdLinks: !0,
							parseRegularLinks: !0
						}) : B._("This community has been banned for violating the Reddit rules.", null, {
							hk: "3iUVxA"
						})))(t), a.a.createElement(U, null, a.a.createElement(z, {
							to: "/"
						}, B._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case R.a.SubredditBlockedForLegalReason:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/snoomoji/snoo_thoughtful.png")
						}), a.a.createElement(oe, null, B._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "4bCnhl"
						})), a.a.createElement(U, null, a.a.createElement(z, {
							to: "/"
						}, B._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case R.a.SubredditDoesNotExist:
						return a.a.createElement("div", null, a.a.createElement($, null), a.a.createElement(oe, null, B._("Sorry, there aren’t any communities on Reddit with that name.", null, {
							hk: "31DRpe"
						})), a.a.createElement(W, null, B._("This community may have been banned or the community name is incorrect.", null, {
							hk: "1lYMG2"
						})), a.a.createElement(U, null, v && a.a.createElement(u.a, {
							eventSource: "content_gate"
						}), a.a.createElement(X, {
							to: "/"
						}, B._("Go Home", null, {
							hk: "49p4or"
						}))));
					case R.a.ProfileDoesNotExist:
					case R.a.ProfileDeleted:
					case R.a.ProfileSuspended:
					case R.a.ProfileBlockedForLegalReason:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/snoomoji/snoo_thoughtful.png")
						}), a.a.createElement(oe, null, (e => {
							const {
								contentGateType: t
							} = e;
							switch (t) {
								case R.a.ProfileBlockedForLegalReason:
									return B._("This content has been restricted in your country in response to a legal request.", null, {
										hk: "4eeylO"
									});
								case R.a.ProfileDeleted:
									return B._("This user has deleted their account.", null, {
										hk: "2IAF6m"
									});
								case R.a.ProfileSuspended:
									return a.a.createElement(a.a.Fragment, null, B._("This account has been {=suspended} .", [B._param("=suspended", a.a.createElement(K, {
										href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/suspensions"
									}, B._("suspended", null, {
										hk: "3nHGgi"
									})))], {
										hk: "4cuTBS"
									}));
								case R.a.ProfileDoesNotExist:
									return a.a.createElement(a.a.Fragment, null, a.a.createElement(oe, null, B._("Sorry, nobody on Reddit goes by that name.", null, {
										hk: "3i02av"
									})), a.a.createElement(W, null, B._("The person may have been banned or the username is incorrect.", null, {
										hk: "36ab4J"
									})))
							}
						})(e)), a.a.createElement(U, null, a.a.createElement(X, {
							to: "/"
						}, B._("Go Home", null, {
							hk: "49p4or"
						}))));
					case R.a.CustomFeedDoesNotExist:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/snoomoji/snoo_thoughtful.png")
						}), a.a.createElement(oe, null, B._("Sorry, this custom feed is private or does not exist.", null, {
							hk: "2Ml4j9"
						})), a.a.createElement(U, null, a.a.createElement(X, {
							to: "/"
						}, B._("Go Home", null, {
							hk: "49p4or"
						}))));
					case R.a.PostBlockedForLegalReason:
						return a.a.createElement("div", null, a.a.createElement(Y, {
							src: "".concat(n.a.assetPath, "/img/snoomoji/snoo_thoughtful.png")
						}), a.a.createElement(oe, null, B._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "1q1rVU"
						})), a.a.createElement(U, null, a.a.createElement(z, {
							to: "/"
						}, B._("Explore Reddit", null, {
							hk: "FrUWU"
						}))))
				}
			};
			t.default = de(le(Object(i.i)(e => a.a.createElement(H, null, a.a.createElement("div", null, a.a.createElement(ae, null, ce(e))), a.a.createElement(C, null)))))
		},
		"./src/reddit/components/ContentTooltip/index.m.less": function(e, t, s) {
			e.exports = {
				StyledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				styledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				fadeIn: "_2bkYZH_kJx5pIHW0Ts5P6e",
				caretOnBottom: "_1rF-A55THyDL-rQ9ZUDQ4_",
				caretOnTop: "_1MHCyMQAMeqRqf5DPWWeq3",
				caretOnLeft: "nVD-oexLbZI_4QjhrkLFz",
				caretOnRight: "KRVDnoE1RIC5qyqQLXxGG"
			}
		},
		"./src/reddit/components/ContentTooltip/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./src/higherOrderComponents/addOverlayEvents.tsx"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/higherOrderComponents/asTooltip.tsx"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				m = s("./src/lib/fastdom/index.ts"),
				u = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				p = s("./src/reddit/selectors/tooltip.ts"),
				b = s("./src/reddit/components/ContentTooltip/index.m.less"),
				h = s.n(b);

			function g() {
				return (g = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var f = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const x = {
					height: 200,
					width: 200
				},
				E = e => {
					switch (e) {
						case "top":
							return "bottom";
						case "right":
							return "left";
						case "left":
							return "right";
						case "bottom":
						default:
							return "top"
					}
				},
				v = Object(c.a)(e => {
					const {
						children: t,
						className: s,
						style: n,
						caretPosition: o,
						caretColor: r
					} = e, i = f(e, ["children", "className", "style", "caretPosition", "caretColor"]);
					return a.a.createElement("div", g({
						className: Object(l.a)(s, h.a.StyledTooltipContainer, {
							[h.a.caretOnTop]: "top" === o,
							[h.a.caretOnLeft]: "left" === o,
							[h.a.caretOnRight]: "right" === o,
							[h.a.caretOnBottom]: "bottom" === o
						}),
						style: Object.assign({}, n, {
							"--contentTooltip-caretColor": r && r[o] ? r[o] : Object(u.a)(e).body
						})
					}, i), t)
				}),
				C = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: s
						} = t;
						return Object(p.b)(s)(e)
					}
				}),
				_ = Object(d.a)(v, [n.a.Click, n.a.Keydown]),
				k = Object(r.b)(C);
			class O extends a.a.Component {
				constructor(e) {
					super(e), this.checkAndSetPosition = () => {
						const {
							tooltipId: e,
							tooltipSizeEstimate: t = x
						} = this.props;
						m.a.read(() => {
							const s = document.getElementById(e);
							if (!s) return;
							const n = s.getBoundingClientRect();
							if (!("undefined" != typeof window)) return void this.setState({
								position: this.props.defaultTooltipPosition
							});
							let o = !0;
							switch (this.props.defaultTooltipPosition) {
								case "bottom":
									o = window.innerHeight - n.bottom > t.height;
									break;
								case "left":
									o = n.left > t.width;
									break;
								case "right":
									o = n.right <= window.innerWidth - t.width;
									break;
								case "top":
								default:
									o = n.top > t.height
							}
							this.setState({
								position: o ? this.props.defaultTooltipPosition : E(this.props.defaultTooltipPosition)
							})
						})
					}, this.state = {
						position: null
					}
				}
				componentDidUpdate(e) {
					!e.isOpen && this.props.isOpen && this.checkAndSetPosition(), e.isOpen && !this.props.isOpen && this.setState({
						position: null
					})
				}
				getPositions(e) {
					switch (e || this.props.defaultTooltipPosition) {
						case "bottom":
							return {
								tooltipPosition: ["center", "top"], targetPosition: ["center", "bottom"], caretPosition: "top"
							};
						case "left":
							return {
								tooltipPosition: ["right", "center"], targetPosition: ["left", "center"], caretPosition: "right"
							};
						case "right":
							return {
								tooltipPosition: ["left", "center"], targetPosition: ["right", "center"], caretPosition: "left"
							};
						case "top":
						default:
							return {
								tooltipPosition: ["center", "bottom"], targetPosition: ["center", "top"], caretPosition: "bottom"
							}
					}
				}
				render() {
					const {
						position: e
					} = this.state, {
						targetPosition: t,
						tooltipPosition: s,
						caretPosition: n
					} = this.getPositions(e);
					return a.a.createElement(_, g({}, this.props, {
						caretPosition: n,
						targetPosition: t,
						tooltipPosition: s
					}))
				}
			}
			t.a = k(O)
		},
		"./src/reddit/components/CreateCommunityButton/index.m.less": function(e, t, s) {
			e.exports = {
				SecondaryButton: "_3U-J6NPoBHbyibarrb7T3F",
				secondaryButton: "_3U-J6NPoBHbyibarrb7T3F",
				StyledTooltip: "FIYolDqalszTnjjNfThfT",
				styledTooltip: "FIYolDqalszTnjjNfThfT"
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/tooltip.ts"),
				l = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				c = s("./src/reddit/components/TrackingHelper/index.tsx"),
				m = s("./src/reddit/controls/Button/index.tsx"),
				u = s("./src/reddit/helpers/overlay/index.ts"),
				p = s("./src/reddit/helpers/trackers/subredditCreation.ts"),
				b = s("./src/reddit/selectors/user.ts"),
				h = s("./src/reddit/components/CreateCommunityButton/index.m.less"),
				g = s.n(h),
				f = s("./src/lib/lessComponent.tsx");
			const x = "create-community-button",
				E = f.a.wrapped(m.i, "SecondaryButton", g.a),
				v = f.a.wrapped(l.c, "StyledTooltip", g.a),
				C = Object(i.c)({
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(b.ab)(e),
					userIsSuspended: b.M
				});
			t.a = Object(r.b)(C, (e, t) => {
				let {
					eventSource: s
				} = t;
				return {
					openCommunityCreation: t => {
						t(Object(p.b)(s)), e(Object(u.a)("/subreddits/create"))
					},
					onShowTooltip: () => e(Object(d.f)({
						tooltipId: x
					})),
					onHideTooltip: () => e(Object(d.i)())
				}
			})(Object(c.c)(e => {
				let {
					className: t,
					eventSource: s,
					onShowTooltip: o,
					onHideTooltip: r,
					openCommunityCreation: i,
					sendEvent: d,
					userDoesNotHaveEnoughExpToCreateCommunity: l,
					userIsSuspended: c
				} = e;
				return a.a.createElement(E, {
					className: t,
					disabled: c || l,
					onClick: () => i(d),
					onMouseEnter: o,
					onMouseLeave: r,
					id: x
				}, n.fbt._("Create Community", null, {
					hk: "RLA8A"
				}), l ? a.a.createElement(v, {
					caretOnTop: !0,
					tooltipId: x,
					text: n.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "2R1OXu"
					})
				}) : c ? a.a.createElement(v, {
					caretOnTop: !0,
					tooltipId: x,
					text: n.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "2xBDEw"
					})
				}) : null)
			}))
		},
		"./src/reddit/components/CrosspostBox/index.m.less": function(e, t, s) {
			e.exports = {
				mediaContainer: "P8p9Nku0-ZbYCsaCOSE2t",
				Container: "_2ED-O3JtIcOqp8iIL1G5cg",
				container: "_2ED-O3JtIcOqp8iIL1G5cg",
				PostMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				postMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				PostTitle: "_2akYJO5RtMK_ptA408seyG",
				postTitle: "_2akYJO5RtMK_ptA408seyG",
				FlatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				flatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				FlatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				flatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				FlatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				flatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				LinkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				linkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				Content: "_379A_08LTBsR4c8POTldR_",
				content: "_379A_08LTBsR4c8POTldR_",
				ThumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX",
				thumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX"
			}
		},
		"./src/reddit/components/CrosspostBox/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/permalinkToOverlayLocation/index.ts"),
				c = s("./src/lib/prettyPrintNumber/index.ts"),
				m = s("./src/reddit/components/Media/index.tsx"),
				u = s("./src/reddit/components/PostMeta/index.tsx"),
				p = s("./src/reddit/components/PostTitle/index.tsx"),
				b = s("./src/reddit/components/SourceLink/index.tsx"),
				h = s("./src/reddit/components/Thumbnail/index.tsx"),
				g = s("./src/lib/constants/index.ts"),
				f = s("./src/reddit/selectors/posts.ts"),
				x = s("./src/reddit/selectors/user.ts"),
				E = s("./src/reddit/components/CrosspostBox/index.m.less"),
				v = s.n(E),
				C = s("./src/lib/lessComponent.tsx");

			function _() {
				return (_ = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const k = C.a.div("Container", v.a),
				O = C.a.div("PostMetaWrapper", v.a),
				y = C.a.wrapped(p.c, "PostTitle", v.a),
				j = C.a.div("FlatList", v.a),
				w = C.a.div("FlatItem", v.a),
				S = C.a.span("FlatListDotSpacer", v.a),
				I = C.a.wrapped(k, "LinkContainer", v.a),
				P = C.a.div("Content", v.a),
				T = C.a.div("ThumbnailContainer", v.a),
				N = Object(d.c)({
					isCurrentUserProfilePost: f.k,
					isTopicPage: e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== g.Ab.TOPIC),
					post: f.O,
					shouldOpenPostInNewTab: x.U,
					subreddit: f.bb
				}),
				M = Object(r.b)(N);
			t.a = M(e => {
				const {
					className: t,
					isCurrentUserProfilePost: s,
					isTopicPage: n,
					mediaProps: o,
					post: r,
					subreddit: i
				} = e;
				if (!r) return null;
				const d = {
						post: r,
						hideGildCta: !0,
						inSubredditOrProfile: !1,
						isCurrentUserProfilePost: s,
						isTopicPage: n,
						shouldShowSubscribeButton: !1,
						subredditOrProfile: i,
						tooltipType: "".concat("CrosspostBox", "--").concat(o.isListing)
					},
					l = t;
				return r && !r.media ? a.a.createElement(I, {
					className: l
				}, a.a.createElement(P, null, a.a.createElement(O, null, a.a.createElement(u.a, d)), R(r), r.source && a.a.createElement(b.a, {
					post: r
				}), A(e)), D(e)) : a.a.createElement(k, {
					className: l
				}, a.a.createElement(O, null, a.a.createElement(u.a, d)), R(r), L(e), A(e))
			});
			const R = e => a.a.createElement(y, {
					isCrosspost: !0,
					post: e,
					shouldLinkWrap: !0,
					size: p.b.Small
				}),
				L = e => {
					const {
						mediaProps: t,
						post: s
					} = e, n = Object.assign({}, t, {
						post: s,
						crosspost: t.post
					});
					return a.a.createElement("div", null, a.a.createElement(m.a, _({}, n, {
						className: v.a.mediaContainer
					})))
				},
				A = e => {
					const {
						post: t
					} = e, {
						score: s
					} = t;
					return a.a.createElement(j, null, a.a.createElement(w, null, n.fbt._({
						"*": "{point count} points",
						_1: "1 point"
					}, [n.fbt._plural(s, "point count", Object(c.b)(s))], {
						hk: "PNZhd"
					})), a.a.createElement(S, null), a.a.createElement(w, null, F(e)))
				},
				F = e => {
					const {
						post: t,
						shouldOpenPostInNewTab: s
					} = e, {
						numComments: o
					} = t;
					return a.a.createElement(i.a, {
						"data-click-id": "comments",
						to: Object(l.a)(t.permalink, !0),
						target: s ? "_blank" : void 0
					}, n.fbt._({
						"*": "{comment count} comments",
						_1: "1 comment"
					}, [n.fbt._plural(o, "comment count", Object(c.b)(o))], {
						hk: "xPYWL"
					}))
				},
				D = e => a.a.createElement(T, null, a.a.createElement(h.a, {
					post: e.post
				}))
		},
		"./src/reddit/components/DistinguishCommentDropdown/DistinguishOptions.m.less": function(e, t, s) {
			e.exports = {
				DistinguishWrapper: "_3aVdI6Y8gye7mgZBvUx5X-",
				distinguishWrapper: "_3aVdI6Y8gye7mgZBvUx5X-",
				Inline: "_2fiLaXOPdMYold0b-FKdVN",
				inline: "_2fiLaXOPdMYold0b-FKdVN",
				RadioOff: "_1kl3eXeS_cuuM03T3_G8G1",
				radioOff: "_1kl3eXeS_cuuM03T3_G8G1",
				RadioOn: "_1EcSEYj-g98-QR-5idlQZr",
				radioOn: "_1EcSEYj-g98-QR-5idlQZr",
				DistinguishOptions: "_1uVj4QJ6tIy-PC9lK3eOYO",
				distinguishOptions: "_1uVj4QJ6tIy-PC9lK3eOYO"
			}
		},
		"./src/reddit/components/DistinguishCommentDropdown/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/constants/index.ts"),
				r = s("./node_modules/fbt/lib/FbtPublic.js"),
				i = s("./src/lib/lessComponent.tsx"),
				d = s("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				l = s("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				c = s("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				m = s("./src/reddit/layout/row/Inline/index.tsx"),
				u = s("./src/reddit/components/DistinguishCommentDropdown/DistinguishOptions.m.less"),
				p = s.n(u);
			const b = i.a.div("DistinguishWrapper", p.a),
				h = i.a.wrapped(m.a, "Inline", p.a),
				g = i.a.wrapped(l.a, "RadioOff", p.a),
				f = i.a.wrapped(c.a, "RadioOn", p.a),
				x = e => o.a.createElement(h, {
					onClick: e.selected ? void 0 : e.onClick
				}, e.selected ? o.a.createElement(f, null) : o.a.createElement(g, null), e.text),
				E = i.a.wrapped(e => {
					const {
						className: t,
						style: s,
						isAdminDistinguished: n,
						isUserEmployee: i,
						isUserMod: d,
						isModDistinguished: l,
						isStickied: c,
						isTopLevelComment: m,
						onDistinguishComment: u
					} = e;
					return o.a.createElement(b, {
						className: t,
						style: s
					}, o.a.createElement(x, {
						onClick: () => u(a.C.NONE, null),
						selected: !l && !n,
						text: r.fbt._("Undistinguish", null, {
							hk: "1P0FyT"
						})
					}), d && o.a.createElement(x, {
						onClick: () => u(a.C.MODERATOR, null),
						selected: l && !c,
						text: r.fbt._("Distinguish as Mod", null, {
							hk: "KDx42"
						})
					}), m && d && o.a.createElement(x, {
						onClick: () => u(a.C.MODERATOR, !0),
						selected: l && c,
						text: r.fbt._("Distinguish as Mod and Sticky", null, {
							hk: "1J1DBd"
						})
					}), i && o.a.createElement(x, {
						onClick: () => u(a.C.ADMIN, null),
						selected: n && !c,
						text: r.fbt._("Distinguish as Admin", null, {
							hk: "1JsJOX"
						})
					}), i && d && m && o.a.createElement(x, {
						onClick: () => u(a.C.ADMIN, !0),
						selected: n && c,
						text: r.fbt._("Distinguish as Admin and Sticky", null, {
							hk: "3x8QWN"
						})
					}))
				}, "DistinguishOptions", p.a);
			var v = Object(d.a)(E);
			t.a = e => {
				const {
					className: t,
					isAdminDistinguished: s,
					isUserEmployee: n,
					isUserMod: r,
					isModDistinguished: i,
					isStickied: d,
					isTopLevelComment: l,
					onDistinguishComment: c,
					sendEventWithName: m,
					tooltipId: u
				} = e;
				return o.a.createElement("div", {
					className: t,
					id: u
				}, o.a.createElement(v, {
					isAdminDistinguished: s,
					isUserEmployee: n,
					isUserMod: r,
					isModDistinguished: i,
					isOpen: e.isDropdownOpen,
					tooltipId: u,
					isStickied: d,
					isTopLevelComment: l,
					onDistinguishComment: (e, t) => {
						c(e, t), e === a.C.MODERATOR ? m(!d && t ? "distinguish_sticky" : "distinguish") : e === a.C.ADMIN ? m("admin_distinguish") : i && e !== a.C.MODERATOR ? m("undistinguish") : s && e !== a.C.ADMIN && m("admin_undistinguish"), d && !t && m("unsticky")
					}
				}))
			}
		},
		"./src/reddit/components/Economics/TopTippers/CommentUsername/index.m.less": function(e, t, s) {
			e.exports = {
				badge: "_17rA6EEcc6RUglkZkHnYGO",
				container: "EorVQyBcpl50FYvpH-VTa"
			}
		},
		"./src/reddit/components/Economics/TopTippers/Icon/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/config.ts");
			const r = new Set(["t2_ktrtg"]),
				i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5,
						t = arguments.length > 1 ? arguments[1] : void 0;
					return "".concat(a.a.assetPath, "/img/badges/topTippers/").concat(t, "/rank-").concat(e, ".png")
				};
			t.a = e => o.a.createElement("img", {
				className: e.className,
				src: i(e.rank, e.creatorId && r.has(e.creatorId) ? e.creatorId : e.subredditId)
			})
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2A1Ng1fBxjU-qYqbEJn_sm",
				EventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventFollowButton: "_2XCKBYzBTZpjOAFEWv1tSy",
				isCompact: "_2gNxoOe_xKaMk0mmYMQCGs"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/eventTools/index.ts"),
				i = s("./src/lib/lessComponent.tsx"),
				d = s("./src/reddit/components/EventPost/PostEventMeta/index.tsx"),
				l = s("./src/reddit/components/PostFollow/index.tsx"),
				c = s("./src/reddit/helpers/postCollection.ts"),
				m = s("./src/reddit/helpers/postEvent.ts"),
				u = s("./src/reddit/components/EventPost/EventMetaHeader/index.m.less"),
				p = s.n(u);
			const b = i.a.div("EventMetaWrapper", p.a);
			t.a = e => {
				let {
					className: t,
					isCompactMode: s,
					post: n
				} = e;
				if (!Object(m.a)(n)) return null;
				const i = n && n.eventInfo,
					u = Object(c.a)(n),
					h = i && Object(r.c)(i.eventStart, i.eventEnd);
				return o.a.createElement("div", {
					className: Object(a.a)(p.a.container, t, {
						[p.a.isCompact]: !!s
					})
				}, o.a.createElement(b, {
					className: p.a.eventMetaWrapper
				}, o.a.createElement(d.a, {
					post: n
				}), !u && h && o.a.createElement(l.a, {
					className: p.a.eventFollowButton,
					post: n,
					isEventFollow: !0
				})))
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.m.less": function(e, t, s) {
			e.exports = {
				PostEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				postEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				PostEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				postEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				PostEventNowText: "BGfronFwr_0rXxOJmxp10",
				postEventNowText: "BGfronFwr_0rXxOJmxp10",
				Container: "_3NIcD2Vr2xrSAq08U14kCy",
				container: "_3NIcD2Vr2xrSAq08U14kCy",
				CalendarIcon: "LEz3F0HfvMpdo96occzKU",
				calendarIcon: "LEz3F0HfvMpdo96occzKU",
				LiveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				liveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				LoadingState: "_27_KVVxYHZ7v44CE2vg8bT",
				loadingState: "_27_KVVxYHZ7v44CE2vg8bT"
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/eventTools/index.ts"),
				r = (s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/fbt/lib/FbtPublic.js")),
				i = s("./src/lib/constants/index.ts");

			function d(e) {
				return e.toLocaleDateString(void 0, {
					month: "numeric",
					day: "numeric"
				})
			}
			var l = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				c = s("./src/reddit/icons/fonts/Calendar/index.tsx"),
				m = s("./src/reddit/icons/fonts/Live/index.tsx"),
				u = s("./src/reddit/components/EventPost/PostEventMeta/index.m.less"),
				p = s.n(u),
				b = s("./src/lib/lessComponent.tsx");
			const h = b.a.span("PostEventFutureText", p.a),
				g = b.a.span("PostEventPastText", p.a),
				f = b.a.span("PostEventNowText", p.a),
				x = b.a.span("Container", p.a),
				E = b.a.wrapped(c.a, "CalendarIcon", p.a),
				v = b.a.wrapped(m.a, "LiveIcon", p.a),
				C = b.a.div("LoadingState", p.a);
			class _ extends n.Component {
				constructor(e) {
					super(e), this.state = {
						mounted: !1
					}
				}
				componentDidMount() {
					this.setState({
						mounted: !0
					})
				}
				render() {
					const {
						className: e,
						post: t
					} = this.props, {
						eventInfo: s
					} = t;
					if (!s) return null;
					const {
						eventEnd: n,
						eventIsLive: c,
						eventStart: m
					} = s, u = Object(a.e)(m, n);
					let p, b;
					if (this.state.mounted || u === a.a.Live) p = function(e, t, s) {
						const n = Object(a.e)(e, t),
							o = new Date(e * i.Eb);
						let l;
						if (n === a.a.Live || s) return r.fbt._("Now", null, {
							hk: "Prpcg"
						});
						n === a.a.Future ? l = Object(a.d)(e) ? r.fbt._("Today", null, {
							hk: "1sZpnp"
						}).toString() : Object(a.b)(e) >= 5 ? d(o) : o.toLocaleDateString(void 0, {
							weekday: "long"
						}) : n === a.a.Past && (l = Object(a.d)(e) ? r.fbt._("Today", null, {
							hk: "1sZpnp"
						}).toString() : d(o));
						const c = function(e) {
							return e.toLocaleTimeString(void 0, {
								hour12: !0,
								hour: "numeric",
								minute: "2-digit"
							}).replace(/ /g, "").toUpperCase()
						}(o);
						return "".concat(l, " @ ").concat(c)
					}(m, n, c);
					else {
						const e = Object(l.a)({
							isLoading: !0
						});
						p = o.a.createElement(C, {
							className: e
						})
					}
					if (c) b = o.a.createElement(f, null, o.a.createElement(v, null), p);
					else if (u === a.a.Future) b = o.a.createElement(h, null, o.a.createElement(E, null), p);
					else {
						if (u !== a.a.Past) return null;
						b = o.a.createElement(g, null, o.a.createElement(E, null), p)
					}
					return o.a.createElement(x, {
						className: e
					}, b)
				}
			}
			t.a = _
		},
		"./src/reddit/components/ExpandoButton/index.m.less": function(e, t, s) {
			e.exports = {
				outer: "RvLtAcdRtbOQbhFB7MD_T",
				icon: "saNpcHve-34zjaa0cbIxW",
				hideOnHover: "_25HJpaEPiVNq6Ss3Ad7dp9",
				showOnHover: "_2S05CzViTnl3I2ekCABqFo",
				outboundLinkIcon: "_1zB4YvOwHPxdPEXG2CYhKB"
			}
		},
		"./src/reddit/components/ExpandoButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/permalinkToOverlayLocation/index.ts"),
				c = s("./src/reddit/actions/post.ts"),
				m = s("./src/reddit/controls/OutboundLink/index.tsx"),
				u = s("./src/reddit/helpers/postHasSelfText/index.ts"),
				p = s("./src/reddit/icons/fonts/Crosspost/index.tsx"),
				b = s("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				h = s("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				g = s("./src/reddit/icons/fonts/helpers.tsx"),
				f = s("./src/reddit/icons/fonts/Expandos/Media/Lightbox/index.m.less"),
				x = s.n(f);
			var E = s("./src/lib/lessComponent.tsx").a.wrapped(e => a.a.createElement("i", {
					className: "".concat(Object(g.b)("expandoMediaLightbox"), " ").concat(e.className),
					onClick: e.onClick
				}), "LightboxIcon", x.a),
				v = s("./src/reddit/icons/fonts/Expandos/Media/Video/index.tsx"),
				C = s("./src/reddit/icons/fonts/Gif/index.tsx"),
				_ = s("./src/reddit/icons/fonts/Link/index.tsx"),
				k = s("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				O = s("./src/reddit/icons/fonts/Photos/index.tsx"),
				y = s("./src/reddit/icons/fonts/Text/index.tsx"),
				j = s("./src/reddit/icons/svgs/Poll/index.tsx"),
				w = s("./src/reddit/models/Media/index.ts"),
				S = s("./src/reddit/components/ExpandoButton/index.m.less"),
				I = s.n(S);
			const P = Object(r.b)(null, (e, t) => ({
					toggle: () => e(Object(c.A)({
						postId: t.post.id
					}))
				})),
				T = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						s = arguments.length > 2 ? arguments[2] : void 0;
					const n = Object(d.a)(I.a.icon, I.a.hideOnHover);
					if (t) return a.a.createElement(p.a, {
						className: n
					});
					if (s.pollData) return a.a.createElement(j.a, {
						className: n
					});
					switch (e) {
						case w.n.GIFVIDEO:
							return a.a.createElement(C.a, {
								className: n
							});
						case w.n.IMAGE:
							return a.a.createElement(O.a, {
								className: n
							});
						case w.n.TEXT:
						case w.n.RTJSON:
							return a.a.createElement(y.a, {
								className: n
							});
						case w.n.VIDEO:
							return a.a.createElement(v.a, {
								className: n
							});
						case w.n.EMBED:
						default:
							return a.a.createElement(_.a, {
								className: n
							})
					}
				};
			t.a = P(e => {
				const {
					className: t,
					crosspost: s,
					enableCrosspostIcon: o,
					isExpanded: r,
					post: c,
					toggle: p,
					useMediaIcons: g
				} = e, f = s || c, x = o && !!s;
				return f.media && !(("rtjson" === f.media.type || "text" === f.media.type) && !Object(u.a)(f)) || !!c.pollData ? a.a.createElement("button", {
					"aria-expanded": r,
					"aria-haspopup": !0,
					"aria-label": n.fbt._("Expand content", null, {
						hk: "1e35IG"
					}),
					className: Object(d.a)(t, I.a.outer),
					"data-click-id": r ? "expando_close" : "expando_open",
					onClick: p
				}, r ? a.a.createElement(b.a, {
					className: I.a.icon
				}) : g ? a.a.createElement(a.a.Fragment, null, T(f.media && f.media.type, x, c), a.a.createElement(h.a, {
					className: Object(d.a)(I.a.icon, I.a.showOnHover)
				})) : a.a.createElement(h.a, {
					className: I.a.icon
				})) : f.source && f.source.url ? a.a.createElement(m.a, {
					"aria-label": n.fbt._("Open external content", null, {
						hk: "2FfpSI"
					}),
					className: Object(d.a)(t, I.a.outer),
					"data-click-id": "expando_open",
					href: f.source.url,
					isSponsored: c.isSponsored,
					postId: c.id,
					source: c.source,
					target: "_blank"
				}, a.a.createElement(k.a, {
					className: Object(d.a)(I.a.icon, I.a.outboundLinkIcon)
				})) : a.a.createElement(i.a, {
					"aria-label": n.fbt._("View content", null, {
						hk: "24KLWF"
					}),
					className: Object(d.a)(t, I.a.outer),
					"data-click-id": "expando_open",
					to: Object(l.a)(f.permalink),
					rel: "nofollow"
				}, a.a.createElement(E, {
					className: I.a.icon
				}))
			})
		},
		"./src/reddit/components/Flatlist/ResponsiveRow.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				i = s("./src/reddit/controls/Dropdown/Row.tsx"),
				d = s("./src/reddit/components/Flatlist/index.m.less"),
				l = s.n(d);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var m = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			t.a = e => {
				var {
					flatlistItem: t,
					isLoggedIn: s,
					isUserOp: n,
					noBreakpoints: d
				} = e, u = m(e, ["flatlistItem", "isLoggedIn", "isUserOp", "noBreakpoints"]);
				return o.a.createElement(i.a, c({}, u, {
					className: d ? l.a.responsiveRow : Object(a.a)(l.a.responsiveRow, Object(r.b)({
						flatlistItem: t,
						isLoggedIn: s,
						isUserOp: n
					}))
				}))
			}
		},
		"./src/reddit/components/Flatlist/breakpoints.m.less": function(e, t, s) {
			e.exports = {
				HideIfVWSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				hideIfVwSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				FirstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				firstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				LoggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				loggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				LoggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				loggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				OpVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				opVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				EditingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				editingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				SecondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				secondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				AwardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				awardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				HideIfVWLarger: "_1k3nXWGGz2NdPr8dg49Tbs",
				hideIfVwLarger: "_1k3nXWGGz2NdPr8dg49Tbs"
			}
		},
		"./src/reddit/components/Flatlist/constants.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.EditPost = "EDITPOST", e.EditFlair = "EDITFLAIR", e.Save = "SAVE", e.Gild = "GILD", e.Hide = "HIDE", e.PostOverflowMenu = "POST_OVERFLOW_MENU", e.Report = "REPORT", e.Share = "SHARE"
				}(n || (n = {}))
		},
		"./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return m
			}));
			var n, o, a, r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/Flatlist/breakpoints.m.less"),
				d = s.n(i),
				l = s("./src/reddit/components/Flatlist/constants.ts");
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(n || (n = {})),
			function(e) {
				e.First = "FirstGroup", e.Editing = "EditingGroup", e.Second = "SecondGroup", e.Awarding = "AwardingGroup"
			}(o || (o = {})),
			function(e) {
				e.LoggedIn = "LoggedInVariant", e.LoggedOut = "LoggedOutVariant", e.Op = "OpVariant"
			}(a || (a = {}));
			const c = {
					[l.a.EditFlair]: o.Editing,
					[l.a.EditPost]: o.Editing,
					[l.a.Gild]: o.Awarding,
					[l.a.Hide]: o.First,
					[l.a.PostOverflowMenu]: o.First,
					[l.a.Report]: o.First,
					[l.a.Save]: o.First,
					[l.a.Share]: o.Second
				},
				m = e => {
					return (e => {
						const t = d.a[e.type],
							s = d.a[e.group],
							n = d.a[e.groupVariant];
						return Object(r.a)(t, s, n)
					})({
						type: e.breakpointType || n.HideIfVWSmaller,
						group: c[e.flatlistItem],
						groupVariant: ((e, t) => e && t ? a.Op : e ? a.LoggedIn : a.LoggedOut)(e.isLoggedIn, e.isUserOp)
					})
				}
		},
		"./src/reddit/components/Flatlist/index.m.less": function(e, t, s) {
			e.exports = {
				flatlistContainer: "_3-miAEojrCvx_4FQ8x3P-s",
				responsiveRow: "YszYBnnIoNY8pZ6UwCivd",
				flatlistSeparator: "x7sinePdvDKj7bf-cdm4Z",
				flexSpacer: "_21pmAV9gWG6F_UKVe7YIE0",
				modActionsIcon: "_15c1hqseW25EvRu0WP2Dq5",
				shareText: "_6_44iTtZoeY6_XChKt5b0",
				commentsLink: "_2qww3J5KKzsD7e5DO0BvvU",
				supportButton: "_3NIVQWStkLT7RXnwKpKNuT",
				ShareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareIcon: "_1GQDWqbF-wkYWbrpmOvjqJ",
				ShareMenu: "_JRBNstMcGxbZUxrrIKXe",
				shareMenu: "_JRBNstMcGxbZUxrrIKXe",
				liveDiscussionWrapper: "_3rnnBQZL1OOttG3tFn629n",
				large: "_26YkhAfncIjLM3iT6Gbcvt"
			}
		},
		"./src/reddit/components/Flatlist/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return ve
			})), s.d(t, "a", (function() {
				return Ce
			})), s.d(t, "d", (function() {
				return je
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = s("./src/lib/lessComponent.tsx"),
				m = s("./src/lib/timezone/index.ts"),
				u = s("./src/reddit/actions/gold/modals.ts"),
				p = s("./src/reddit/actions/modal.ts"),
				b = s("./src/reddit/actions/post.ts"),
				h = s("./src/reddit/actions/postCreation/editing.ts"),
				g = s("./src/reddit/actions/postFlair.ts"),
				f = s("./src/reddit/actions/reportFlow.ts"),
				x = s("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				E = s("./src/reddit/components/CommentsLink/index.tsx"),
				v = s("./src/higherOrderComponents/makeAsync.tsx"),
				C = s("./src/reddit/featureFlags/index.ts"),
				_ = s("./src/reddit/selectors/economics.ts");
			const k = Object(v.a)({
				ErrorComponent: () => null,
				LoadingComponent: () => null,
				getComponent: () => Promise.all([s.e("vendors~CoinPurchaseModal~EconPowerupsPurchaseModal~EconomicsCommunityTipJar~EconomicsEntryPointsCom~c2417cdc"), s.e("vendors~EconomicsEntryPointsPostFlatlistSupportCTA~InFeedChaining~Poll~PostCreation~Reddit~Subreddit~2c16ee4a"), s.e("EconomicsCommunityTipJar~EconomicsEntryPointsCommentFlatlistSupportCTA~EconomicsEntryPointsPostFlatl~d7fcad44"), s.e("EconomicsCommunityTipJar~EconomicsEntryPointsCommentFlatlistSupportCTA~EconomicsEntryPointsPostFlatl~ad34f221"), s.e("EconomicsEntryPointsPostFlatlistSupportCTA")]).then(s.bind(null, "./src/reddit/components/Economics/EntryPoints/PostFlatlistSupportCTA/index.tsx")).then(e => e.default)
			});
			var O = Object(r.b)(() => Object(i.c)({
					featureEnabled: C.d.spSupport,
					userAcceptsSupport: (e, t) => {
						const s = e.posts.models[t.contentId];
						return !!s && Object(_.l)(e, {
							contentId: s.id,
							subredditId: t.subredditId
						})
					}
				}))((function(e) {
					return e.featureEnabled && e.userAcceptsSupport ? a.a.createElement(k, e) : null
				})),
				y = s("./src/reddit/constants/colors.ts"),
				j = s("./src/reddit/components/ContentTooltip/index.tsx"),
				w = s("./src/reddit/components/GiveAwardTooltip/index.m.less"),
				S = s.n(w);
			const {
				fbt: I
			} = s("./node_modules/fbt/lib/FbtPublic.js");
			class P extends a.a.Component {
				render() {
					const {
						tooltipId: e
					} = this.props;
					return a.a.createElement(j.a, {
						caretColor: {
							top: y.a.op
						},
						tooltipSizeEstimate: {
							height: 39,
							width: 314
						},
						tooltipId: e,
						defaultTooltipPosition: "bottom"
					}, a.a.createElement("div", {
						className: S.a.container
					}, a.a.createElement("div", {
						className: S.a.newBadge
					}, I._("New", null, {
						hk: "1XUPF"
					})), a.a.createElement("div", {
						className: S.a.text
					}, I._("Try giving a new Appreciation Award", null, {
						hk: "1V7ZWF"
					}))))
				}
			}
			var T = P,
				N = s("./src/reddit/components/ModActionsMenu/index.tsx"),
				M = s("./src/reddit/components/ModModeReports/helpers.ts"),
				R = s("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				L = s("./src/reddit/components/PostFlairPicker/index.tsx"),
				A = s("./src/reddit/components/PostModModeDropdown/index.tsx"),
				F = s("./src/reddit/components/PostOverflowMenu/index.tsx"),
				D = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				B = s("./src/reddit/components/ShareMenu/index.tsx"),
				U = s("./src/reddit/components/TrackingHelper/index.tsx"),
				H = s("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				W = s("./src/reddit/constants/postLayout.ts"),
				V = s("./src/reddit/contexts/PageLayer/index.tsx"),
				q = s("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				G = s("./src/reddit/helpers/styles/smartTextColor.ts"),
				K = s("./src/reddit/selectors/user.ts"),
				z = s("./src/reddit/components/Flatlist/ResponsiveRow.tsx"),
				Q = s("./src/reddit/helpers/correlationIdTracker.ts"),
				J = s("./src/reddit/helpers/trackers/modTools.ts"),
				Z = s("./src/reddit/helpers/trackers/post.ts"),
				X = s("./src/reddit/icons/fonts/IgnoreReport/index.tsx"),
				Y = s("./src/reddit/icons/fonts/ModActions/index.tsx"),
				$ = s("./src/reddit/icons/fonts/Report/index.tsx"),
				ee = s("./src/reddit/icons/fonts/Share/index.tsx"),
				te = s("./src/reddit/models/Media/index.ts"),
				se = s("./src/reddit/models/NewStructuredStyles/index.ts"),
				ne = s("./src/reddit/models/PostCreationForm/index.ts"),
				oe = s("./src/reddit/models/User/index.ts"),
				ae = s("./src/reddit/components/Flatlist/constants.ts"),
				re = s("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				ie = s("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				de = s("./src/reddit/actions/postCollection/index.ts"),
				le = s("./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx"),
				ce = s("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx"),
				me = s("./src/reddit/selectors/activeModalId.ts"),
				ue = s("./src/reddit/components/Flatlist/index.m.less"),
				pe = s.n(ue);

			function be() {
				return (be = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var he = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			let ge, fe;
			const xe = c.a.button("ShareButton", pe.a),
				Ee = c.a.wrapped(B.a, "ShareMenu", pe.a),
				ve = Object(l.a)(e => {
					var {
						className: t
					} = e, s = he(e, ["className"]);
					return a.a.createElement(Y.a, be({}, s, {
						className: Object(d.a)(pe.a.modActionsIcon, t),
						style: {
							color: Object(G.a)(Object(q.a)(s), se.a.actionIcon, se.b.actionIcon)
						}
					}))
				}),
				Ce = e => a.a.createElement("div", be({}, e, {
					className: Object(d.a)(pe.a.flatlistSeparator, e.className)
				})),
				_e = Object(V.t)({
					currentProfileName: V.h,
					isCommentPermalink: V.v,
					isCommentsPage: V.w,
					isProfilePostListing: V.I,
					pageLayer: e => e
				}),
				ke = Object(i.c)({
					activeModalId: me.a,
					layout: V.N,
					userIsOp: K.hb,
					subreddit: V.q
				}),
				Oe = Object(r.b)(ke, (e, t) => {
					let {
						post: n,
						isOverlay: o,
						isCommentsPage: a
					} = t;
					return {
						addPostToCollection: (t, s) => e(Object(de.a)(t, s)),
						onToggleModal: t => e(Object(p.i)(t)),
						onToggleSave: () => e(Object(b.W)(n.postId)),
						onHide: t => e(Object(b.ab)(n.postId, !n.hidden, o, !0)),
						onReportClick: () => e(Object(f.j)(n.postId, o)),
						onEdit: () => {
							const t = !o && !a;
							e(Object(h.a)(n.postId, t))
						},
						onFlairPost: () => e(Object(p.i)(Object(L.b)(n.postId, o))),
						onGildClick: t => e(Object(u.d)({
							correlationId: t,
							thingId: n.postId
						})),
						onFlairChanged: t => {
							let {
								selectedTemplateId: s,
								previewFlair: o
							} = t;
							return e(Object(g.h)({
								post: n,
								selectedTemplateId: s,
								previewFlair: o
							}))
						},
						toggleEditStartTimeModal: async () => {
							ge && fe || ([ge, fe] = await Promise.all([s.e("schedulePickerModal").then(s.bind(null, "./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx")).then(e => e.default), Promise.resolve().then(s.bind(null, "./src/reddit/actions/eventPosts/index.ts")).then(e => e.editEventTimeRequested)])), e(Object(p.i)(Object(ne.r)(n.postId, o, ne.j.POST_OVERFLOW_MENU)))
						},
						addEventStartTime: t => {
							fe && e(fe(n.id, t))
						}
					}
				});
			class ye extends a.a.Component {
				constructor() {
					super(...arguments), this.handleGild = async () => {
						const {
							onGildClick: e,
							post: t,
							sendEvent: n
						} = this.props;
						e(Object(Q.d)(Q.a.GildingFlow, !0));
						const {
							clickGildEvent: o
						} = await Promise.resolve().then(s.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						n(o(t.id))
					}, this.onToggleCurrentModal = () => {
						this.props.activeModalId && this.props.onToggleModal(this.props.activeModalId)
					}, this.onToggleCollectionListModal = () => {
						const {
							isOverlay: e,
							post: t
						} = this.props, s = Object(ne.s)(t.id, e);
						this.props.onToggleModal(s)
					}, this.addPostToCollection = e => {
						this.props.addPostToCollection(e.id, this.props.post.id).then(() => this.onToggleCurrentModal())
					}, this.sendEventWithName = e => {
						const {
							isOverlay: t,
							post: s,
							sendEvent: n
						} = this.props;
						n(Object(Z.f)(s.id, e, t ? "post_detail" : "post"))
					}, this.onSaveClick = () => {
						this.props.onToggleSave(), this.sendEventWithName(this.props.post.saved ? "unsave" : "save")
					}, this.onHideClick = () => {
						this.props.onHide(!!this.props.post.hidden), this.sendEventWithName(this.props.post.hidden ? "unhide" : "hide")
					}, this.onReportClick = () => {
						this.props.onReportClick(), this.sendEventWithName("report")
					}
				}
				render() {
					const {
						activeModalId: e,
						addEventStartTime: t,
						className: s,
						currentProfileName: o,
						currentUser: r,
						hasModFlairPerms: i,
						hasModFullPerms: l,
						hasModPostPerms: c,
						isCommentPermalink: u,
						isCommentsPage: p,
						isLargePost: b,
						isOverlay: h,
						isProfilePostListing: g,
						isSticky: f,
						layout: v,
						modModeEnabled: C,
						onFlairChanged: _,
						onIgnoreReports: k,
						onOpenReportsDropdown: y,
						pageLayer: j,
						post: w,
						sendEvent: S,
						showEditFlair: I,
						showEditPost: P,
						subreddit: B,
						toggleEditStartTimeModal: U,
						tooltipType: V,
						userIsOp: q
					} = this.props, G = !!r && Object(oe.e)(r) === w.author, K = Object(ie.a)("View--Reports", w.id, V), Q = Object(ie.a)("View--GiveAward", w.id, V), Y = Object(M.c)(w), se = je("-mod-actions-menu", w.id, h, f), de = Object(M.a)(w), me = w.postId, ue = v === W.g.Large, be = !p && ue || c && C, he = !(h || p || u), fe = r && w.isGildable, Ce = w.media && w.media.type === te.n.LIVEVIDEO;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement("div", {
						className: Object(d.a)(pe.a.flatlistContainer, s)
					}, a.a.createElement(E.a, {
						className: pe.a.commentsLink,
						hasModPostPerms: c,
						isCommentsPage: p,
						isCommentPermalink: u,
						isOverlay: h,
						postId: w.id,
						modModeEnabled: C,
						numComments: w.numComments
					}), B && r && !q && !w.isNSFW && a.a.createElement(O, {
						className: pe.a.supportButton,
						contentId: w.id,
						inPostFeed: he,
						modModeEnabled: c && C,
						renderInPortal: he,
						subredditId: B.id,
						targetName: w.author
					}), fe && a.a.createElement(a.a.Fragment, null, a.a.createElement(z.a, {
						displayText: n.fbt._("Give Award", null, {
							hk: "NIFUn"
						}),
						flatlistItem: ae.a.Gild,
						isLoggedIn: !!r,
						isUserOp: q,
						onClick: this.handleGild,
						skipRoleAttr: !0
					}, a.a.createElement(F.a, {
						id: Q
					})), a.a.createElement(T, {
						postOrComment: w,
						tooltipId: Q
					})), a.a.createElement(Ee, {
						className: Object(re.b)({
							flatlistItem: ae.a.Share,
							isLoggedIn: !!r,
							isUserOp: q
						}),
						dropdownId: je("-share-menu", w.id, h, f),
						permalink: w.permalink,
						post: w,
						sendEventWithName: this.sendEventWithName,
						subreddit: B
					}, a.a.createElement(xe, {
						"data-click-id": "share"
					}, a.a.createElement(ee.a, {
						className: pe.a.shareIcon
					}), a.a.createElement("span", {
						className: pe.a.shareText
					}, n.fbt._("share", null, {
						hk: "1eAfZg"
					})))), P && !be && a.a.createElement(z.a, {
						displayText: n.fbt._("Edit post", null, {
							hk: "Jq2Cr"
						}),
						flatlistItem: ae.a.EditPost,
						isLoggedIn: !!r,
						isUserOp: q,
						onClick: this.props.onEdit,
						skipRoleAttr: !0
					}, a.a.createElement(F.c, null)), (!c || !C) && a.a.createElement(z.a, {
						displayText: w.saved ? n.fbt._("unsave", null, {
							hk: "4Dn4IT"
						}) : n.fbt._("save", null, {
							hk: "3NOMst"
						}),
						flatlistItem: ae.a.Save,
						isLoggedIn: !!r,
						isUserOp: q,
						onClick: this.onSaveClick,
						skipRoleAttr: !0
					}, w.saved ? a.a.createElement(F.f, null) : a.a.createElement(F.e, null)), !w.isSponsored && !be && a.a.createElement(z.a, {
						displayText: w.hidden ? n.fbt._("unhide", null, {
							hk: "151XLs"
						}) : n.fbt._("hide", null, {
							hk: "4AnA6R"
						}),
						flatlistItem: ae.a.Hide,
						isLoggedIn: !!r,
						isUserOp: q,
						onClick: this.onHideClick,
						skipRoleAttr: !0
					}, a.a.createElement(F.b, null)), !G && !w.isSponsored && !be && a.a.createElement(z.a, {
						displayText: n.fbt._("report", null, {
							hk: "1phfns"
						}),
						flatlistItem: ae.a.Report,
						isLoggedIn: !!r,
						isUserOp: q,
						onClick: this.onReportClick,
						skipRoleAttr: !0
					}, a.a.createElement(F.d, null)), a.a.createElement(R.a, {
						isOverlay: h,
						layout: v,
						modModeEnabled: C,
						post: w,
						sendEvent: S
					}), c && a.a.createElement(N.a, {
						dropdownId: se,
						onClick: () => S(Object(Z.f)(w.id, "post_mod_action_menu"))
					}, a.a.createElement(ve, null), a.a.createElement(A.a, {
						canEditFlair: i && !!I,
						hasModFullPerms: l,
						hasModPostPerms: c,
						isOverlay: !!h,
						isPostAuthor: G,
						modModeEnabled: C,
						post: w,
						tooltipId: se
					})), c && Y && !C && a.a.createElement(D.c, {
						text: "".concat(de),
						onClick: () => {
							y(K), S(Object(Z.f)(w.id, "post_report_menu"))
						},
						id: K
					}, a.a.createElement(H.a, {
						model: w,
						onIgnoreReports: () => {
							k(), S(Object(J.j)(w.ignoreReports ? "restore_reports" : "ignore_reports", w.id))
						},
						tooltipId: K
					}), w.ignoreReports ? a.a.createElement(X.a, null) : a.a.createElement($.a, null)), (r || !w.isSponsored) && a.a.createElement(F.g, {
						currentProfileName: o,
						dropdownId: je("-overflow-menu", w.id, h, f),
						isCommentsPage: p,
						isFixed: f,
						isOverlay: !!h,
						isProfilePostListing: g,
						layout: v,
						modModeWithPost: C && c,
						pageLayer: j,
						permalink: w.permalink,
						postId: me,
						sendEvent: S,
						showEditPost: !!P,
						showEditFlair: !!I,
						useFlatlistBreakpoints: this.props.useFlatlistBreakpoints,
						toggleAddEventStartTimeModal: U,
						toggleEditStartTimeModal: U
					}), e === Object(ne.s)(w.id, h) && a.a.createElement(le.a, {
						subredditId: w.belongsTo.id,
						onClose: this.onToggleCurrentModal,
						postId: w.id,
						onSelectCollection: this.addPostToCollection,
						titleText: n.fbt._("Add post to a collection", null, {
							hk: "38vSyF"
						}),
						onItemHoverActionText: n.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						isOverlay: h
					}), e === Object(ne.r)(w.id, h, ne.j.POST_OVERFLOW_MENU) && ge && a.a.createElement(ge, {
						onChange: t,
						onClose: U,
						schedule: Object(m.c)(w),
						shouldShowDeleteButton: !1
					}), e === Object(ne.t)(w.id, h) && a.a.createElement(ce.a, {
						onCancel: this.onToggleCollectionListModal,
						onCollectionCreated: this.addPostToCollection,
						subredditId: w.belongsTo.id
					}), e === Object(L.b)(w.id, h) && a.a.createElement(L.a, {
						flairs: w.flair,
						subredditId: w.belongsTo.id,
						modalId: Object(L.b)(w.id, h),
						onFlairChanged: _
					}), a.a.createElement("div", {
						className: pe.a.flexSpacer
					})), he && !Ce && a.a.createElement(x.a, {
						className: Object(d.a)(pe.a.liveDiscussionWrapper, {
							[pe.a.large]: b
						}),
						isMod: c,
						postId: w.postId
					}))
				}
			}
			const je = (e, t, s, n) => {
				let o = t;
				return s && (o += "-overlay"), n && (o += "-sticky"), o += e
			};
			t.c = _e(Oe(Object(U.c)(ye)))
		},
		"./src/reddit/components/Footer/index.m.less": function(e, t, s) {
			e.exports = {
				FooterContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				footerContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				UserAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				userAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				PrivacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				privacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				UserAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				userAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh"
			}
		},
		"./src/reddit/components/GeoForm/GeoForm.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return j
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/uuid/v4.js"),
				r = s.n(a),
				i = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/controls/Button/index.tsx");
			var l = s("./node_modules/fbt/lib/FbtPublic.js"),
				c = s("./node_modules/p-debounce/index.js"),
				m = s.n(c),
				u = s("./src/reddit/constants/keycodes.ts"),
				p = s("./src/lib/makeGqlRequest/index.ts"),
				b = s("./src/lib/sentry/index.ts"),
				h = s("./src/graphql/operations/GeoPlaceAutocomplete.json");
			const g = (e, t) => async s => {
				let n;
				try {
					n = await async function(e, t) {
						return Object(p.a)(e, Object.assign({}, h, {
							variables: t
						}))
					}(e(), {
						query: s,
						sessionId: t
					})
				} catch (o) {
					return b.c.captureException(o), []
				}
				return n.body.data.geoPlaceAutocomplete || []
			};
			var f = s("./src/reddit/hooks/useGqlContext.ts"),
				x = s("./src/reddit/hooks/useOnClickOutside.ts"),
				E = e => o.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 13 16",
					xmlns: "http://www.w3.org/2000/svg"
				}, o.a.createElement("path", {
					d: "m10.4442 10.9445c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5m0-8.944c-3.554 0-6.444 2.891-6.444 6.444 0 3.32 5.143 8.658 5.73 9.256.189.192.446.3.714.3.269 0 .526-.108.714-.3.587-.598 5.73-5.936 5.73-9.256 0-3.553-2.89-6.444-6.444-6.444",
					fill: "inherit",
					fillRule: "evenodd",
					transform: "translate(-4 -2)"
				})),
				v = s("./src/reddit/components/GeoForm/index.m.less"),
				C = s.n(v);

			function _(e) {
				const {
					value: t,
					setValue: s,
					setPlaceId: a,
					disabled: r,
					onFocus: d,
					sessionId: c,
					className: p
				} = e, b = Object(f.a)(), [h, x] = Object(n.useState)(!1), v = function(e, t, s) {
					const [o, a] = Object(n.useState)([]), r = Object(n.useMemo)(() => m()(s, 300), [s]);
					return Object(n.useEffect)(() => {
						e && t && r(e).then(e => {
							a(e)
						}).catch(() => a([]))
					}, [e]), o
				}(t, h, g(b, c)), {
					highlightValue: _,
					selectedIndex: O,
					onKeyDown: y,
					isClosed: j,
					setClosed: w
				} = function(e, t, s) {
					const [o, a] = Object(n.useState)(-1), [r, i] = Object(n.useState)(!!e.length), [d, l] = Object(n.useState)(void 0);
					return {
						highlightValue: d,
						selectedIndex: o,
						onKeyDown: n => {
							if (n.key === u.b.ArrowDown) {
								const t = Math.min(o + 1, e.length - 1);
								a(t), l(e[t])
							} else if (n.key === u.b.ArrowUp) {
								const t = Math.max(o - 1, -1);
								a(t), l(e[t])
							} else n.key === u.b.Enter && o > -1 ? (a(-1), t(e[o].name), s(e[o].id), i(!0), n.preventDefault()) : n.key === u.b.Escape ? (a(-1), i(!0)) : l(void 0)
						},
						isClosed: r,
						setClosed: i
					}
				}(v, s, a), S = "location-input-".concat(c);
				return o.a.createElement("div", {
					className: C.a.autocompleteInput
				}, o.a.createElement("label", {
					className: C.a.geoLabel,
					htmlFor: S
				}, o.a.createElement(E, {
					className: C.a.locationIcon
				})), o.a.createElement("input", {
					className: Object(i.a)(C.a.geoInput, p),
					name: S,
					disabled: r,
					onKeyDown: y,
					value: _ && _.name || t,
					placeholder: l.fbt._("Add location", null, {
						hk: "1BaqFd"
					}),
					onChange: e => {
						s(e.currentTarget.value), a(""), w(!1)
					},
					onFocus: () => {
						x(!0), d()
					},
					onBlur: () => x(!1)
				}), v.length && !j ? o.a.createElement(k, {
					id: c,
					items: v.map(e => e.name),
					selectedIndex: O,
					selectValue: e => {
						s(v[e].name), a(v[e].id), w(!0)
					},
					onClickOutside: () => w(!0)
				}) : null)
			}

			function k(e) {
				const {
					id: t,
					items: s,
					selectedIndex: n,
					selectValue: a,
					onClickOutside: r
				} = e;
				return Object(x.a)("autocomplete-dropdown-".concat(t), r), o.a.createElement("ul", {
					className: C.a.autocompleteDropdown,
					id: "autocomplete-dropdown-".concat(t)
				}, s.map((e, t) => o.a.createElement("li", {
					key: "".concat(e).concat(t),
					onClick: () => a(t),
					className: Object(i.a)({
						[C.a.highlight]: t === n
					})
				}, e)))
			}
			const {
				fbt: O
			} = s("./node_modules/fbt/lib/FbtPublic.js"), y = () => {};

			function j(e) {
				const {
					className: t,
					initialValue: s,
					initialPlaceId: a,
					disabled: l = !1,
					onFocus: c = y,
					onPlace: m = y,
					onValue: u = y,
					inputClassName: p
				} = e, b = function() {
					const [e, t] = Object(n.useState)(!1);
					return Object(n.useEffect)(() => t(!0), []), e
				}(), [h] = Object(n.useState)(() => r()()), [g, f] = Object(n.useState)(s || ""), [x, E] = Object(n.useState)(a || "");
				return b ? o.a.createElement("form", {
					className: Object(i.a)(C.a.geoForm, t),
					onSubmit: t => {
						t.preventDefault(), x !== a && e.onSubmit({
							name: g,
							placeId: x,
							sessionId: h
						})
					}
				}, o.a.createElement(_, {
					className: p,
					value: g,
					sessionId: h,
					setValue: e => {
						f(e), u(e)
					},
					setPlaceId: e => {
						E(e), m(e)
					},
					disabled: l,
					onFocus: c
				}), x && x !== a && o.a.createElement(d.i, {
					className: C.a.submitButton,
					type: "submit",
					disabled: l
				}, O._("Submit", null, {
					hk: "3kKxBt"
				}))) : null
			}
		},
		"./src/reddit/components/GeoForm/index.m.less": function(e, t, s) {
			e.exports = {
				geoForm: "dnC9V9HtkUxsmza-vEXgC",
				geoLabel: "_3T9bJ1ttSXUxb9rxZI9jMC",
				locationIcon: "_2Jm0p-hd1-KYZJI9iP3n6",
				geoInput: "_2O28-fZaU1kYnMmsiMKw3y",
				autocompleteInput: "oP84ZJjEgYLr154hrXHd8",
				autocompleteDropdown: "_1pwsnPyclgUCyjdfT0xWmx",
				highlight: "_1kfPE4TrjHsTFgvmrF1s33"
			}
		},
		"./src/reddit/components/GiveAwardTooltip/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_17AlFvm1kWw8NYe0FZKlMB",
				newBadge: "_18TPfQgPhTmXJ8270Nc5nM",
				text: "_26N1OuVJykHlztxQkPEfqb"
			}
		},
		"./src/reddit/components/GrantUserFlair/index.m.less": function(e, t, s) {
			e.exports = {
				titleRow: "_1knBg4PWacEaLvDRHAvsTp",
				flairDetails: "_2bPY-7msbc_UjCac-In6Li",
				flairEditColumn: "_2ebZb7SML8ZCy-QsS6tUc0",
				column: "_3vuuCvX3U56Wb64Bz3AX9W",
				iconsColumn: "Q9C1YLEYQHPi_NuLIcsS3",
				removeIcon: "_2IP600IxdVV8-hzfus_xst",
				removeButton: "Yd-aY1XSmw6atYPPJHm9n",
				row: "_3W5UQ4TDClfiDY4zEBYSqT",
				flairEditHelperText: "_2JpPK1gCbDBJBbMRrx-fe6",
				errorIndicator: "_1gmumWT2YihpY16NJJw_ac",
				hasError: "Uu_my_fNiUJaUT-wFhyeq",
				flairContainer: "_1c46XAzSY3wg6lATaRh11v",
				userLink: "_14IDyvxQsRUGTR9unevdzm",
				textInput: "_3OzKI46CUHBipWh2v7Cfq",
				dropdownTriangle: "_3L2zEwdN8hdor-MjnuTTXx",
				dropdownTarget: "_2q91kdzeOjUsLeozfWfPZI",
				dropdownContainer: "_2SgxV6WihN0lLBZ06jChDN",
				dropdownRow: "Hsh_7uWgjhtYFcA5QqiI6",
				userIcon: "uHVmBRWHNpGMMkIFBthWs",
				modIcon: "_31YDoZrj2KLLxWJhYimRfb",
				infoTooltip: "i75byXeh_ZzdbD0HGxb4",
				tooltipText: "_3FXJw0xh37YZHaJP_j3Npe",
				tooltipIconContainer: "_1dZeti3tpsM8YrfluheTX5",
				tooltipIconRow: "_2B9YDCXdUsKx20YPQ_0guj",
				tooltipIconText: "_2_doCenMWfLXsGEvDSq1NB",
				cssInputError: "_3ySNKx0QJZRCNOFB6345zX",
				bottomBarRow: "Tf16TWgXZcNKzLmD4PDPq",
				topBar: "e-h9YD6UZh8FOUPTG6drY",
				disabledBanner: "_3rrCSsx0QD7pFwGJquTq-6",
				warningIcon: "_3MSU8YNfdz6icABES0GIkK",
				emptyList: "y4YDfdWBHO7s3GVuYjBDF",
				flairIcon: "_3RYWcdo8Ov1AjwCGeCUsfs",
				mainText: "_8uYoAAuUrGW1iwcBP-2eS",
				fadeIn: "_3YR0vW4lNgbJJ7RgssVmf-"
			}
		},
		"./src/reddit/components/GrantUserFlair/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/lodash/find.js"),
				r = s.n(a),
				i = s("./node_modules/react/index.js"),
				d = s.n(i),
				l = s("./node_modules/react-redux/es/index.js"),
				c = s("./node_modules/reselect/es/index.js"),
				m = s("./src/lib/addQueryParams/index.ts"),
				u = s("./src/lib/omitKey/index.ts"),
				p = s("./src/lib/stripQueryParams/index.ts"),
				b = s("./src/reddit/actions/grantUserFlair/index.ts"),
				h = s("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				g = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = s("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				x = s("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				E = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				v = s("./src/lib/classNames/index.ts"),
				C = s("./src/reddit/components/SaveIndicator/index.m.less"),
				_ = s.n(C),
				k = e => d.a.createElement("svg", {
					className: e.className,
					viewBox: "3 4 14 14",
					xmlns: "http://www.w3.org/2000/svg"
				}, d.a.createElement("g", null, d.a.createElement("path", {
					d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
					fill: "inherit"
				}))),
				O = s("./src/reddit/icons/svgs/Clear/index.tsx"),
				y = s("./src/reddit/icons/svgs/Replay/index.tsx"),
				j = s("./src/reddit/models/ApiRequestState/index.ts");
			const w = {
				[j.a.Pending]: () => o.fbt._("Saving", null, {
					hk: "3r9uZO"
				}),
				[j.a.Complete]: () => o.fbt._("Saved", null, {
					hk: "e9tAk"
				}),
				[j.a.Failed]: () => o.fbt._("Save error", null, {
					hk: "3NFi3S"
				})
			};
			var S = e => d.a.createElement(d.a.Fragment, null, e.status === j.a.Pending && d.a.createElement(y.a, {
					className: Object(v.a)(_.a.icon, _.a.pendingIcon)
				}), e.status === j.a.Complete && d.a.createElement(k, {
					className: Object(v.a)(_.a.icon, _.a.savedIcon)
				}), e.status === j.a.Failed && d.a.createElement(O.a, {
					className: Object(v.a)(_.a.icon, _.a.saveErrorIcon)
				}), d.a.createElement("span", {
					className: _.a.caption
				}, w[e.status]())),
				I = s("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				P = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				T = s("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				N = s("./src/reddit/components/TrackingHelper/index.tsx"),
				M = s("./src/reddit/constants/colors.ts"),
				R = s("./src/reddit/contexts/PageLayer/index.tsx"),
				L = s("./src/reddit/helpers/flair.ts"),
				A = s("./src/reddit/selectors/telemetry.ts");
			const F = e => ({
					subreddit: A.subreddit(e),
					profile: A.profile(e),
					userSubreddit: A.userSubreddit(e)
				}),
				D = e => t => Object.assign({
					source: "grant_user_flair",
					action: "click",
					noun: e
				}, F(t)),
				B = () => D("search_username"),
				U = () => D("page_forward"),
				H = () => D("page_back"),
				W = () => D("remove_granted_user_flair"),
				V = (e, t) => s => Object.assign({
					source: "grant_user_flair",
					action: "autosave",
					noun: e,
					actionInfo: Object.assign({}, A.actionInfo(s), {
						settingValue: t
					})
				}, F(s)),
				q = () => V("flair_text"),
				G = e => V("flair_template", e || "none"),
				K = e => V("css_class", e);
			var z = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Q = s("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				J = s("./src/reddit/icons/svgs/User/index.tsx"),
				Z = (s("./node_modules/core-js/modules/es6.regexp.search.js"), s("./src/reddit/models/SubredditModeration/index.ts"));
			const X = [];
			var Y = s("./src/reddit/selectors/meta.ts"),
				$ = s("./src/reddit/selectors/userFlair.ts"),
				ee = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				te = s("./src/reddit/components/GrantUserFlair/index.m.less"),
				se = s.n(te);
			var ne = () => d.a.createElement("div", {
					className: se.a.emptyList
				}, d.a.createElement(ee.a, {
					className: se.a.flairIcon
				}), d.a.createElement("div", {
					className: se.a.mainText
				}, o.fbt._("You do not have any users with user flair", null, {
					hk: "4D1S5Z"
				})), d.a.createElement("div", null, o.fbt._("Search for a user to assign a user flair", null, {
					hk: "2YaDOy"
				}))),
				oe = s("./node_modules/lodash/filter.js"),
				ae = s.n(oe),
				re = s("./node_modules/lodash/isEqual.js"),
				ie = s.n(re),
				de = s("./node_modules/lodash/omit.js"),
				le = s.n(de),
				ce = s("./src/reddit/constants/flair.ts"),
				me = s("./src/reddit/helpers/validateFlairCssClass.ts");
			const ue = 200;
			var pe;
			! function(e) {
				e[e.Save = 0] = "Save", e[e.Delete = 1] = "Delete"
			}(pe || (pe = {}));
			const be = e => null === e.flair,
				he = e => !(!e.apiError && !e.clientValidationError),
				ge = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					const s = Date.now();
					return ae()(e, e => {
						if (!e || e.clientValidationError) return !1;
						if (e.apiError && !t) return !1;
						if (be(e)) return !0;
						return s - e.changedAt > 2e3 || t
					})
				},
				fe = (e, t, s) => {
					const n = Object.keys(e).filter(n => {
						const o = e[n],
							a = t[n] || null;
						return !(!!a || n === s || !he(o)) || !!ie()(a, o.flair)
					});
					return n.length ? le()(e, n) : e
				},
				xe = (e, t) => {
					const s = t || ce.a;
					return (e ? Object(L.m)(e, s) || Object(me.a)(e.cssClass || "") : "") || void 0
				};
			var Ee = s("./node_modules/lodash/noop.js"),
				ve = s.n(Ee),
				Ce = s("./src/reddit/components/Flair/index.tsx"),
				_e = s("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				ke = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				Oe = s("./src/reddit/controls/InternalLink/index.tsx"),
				ye = s("./src/reddit/icons/svgs/Remove/index.tsx"),
				je = s("./src/reddit/models/Flair/index.ts"),
				we = s("./src/higherOrderComponents/asTooltip.tsx"),
				Se = s("./src/reddit/actions/tooltip.ts"),
				Ie = s("./src/reddit/constants/keycodes.ts"),
				Pe = s("./src/reddit/controls/Dropdown/index.tsx"),
				Te = s("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				Ne = s("./src/reddit/selectors/tooltip.ts");
			const Me = e => "UserFlairPicker--".concat(e),
				Re = Object(we.a)(Pe.a),
				Le = e => {
					let {
						flair: t
					} = e;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(Ce.b, {
						flair: Object(L.c)(t),
						forceSmallEmojis: !0
					}), t.textEditable && d.a.createElement(J.a, {
						className: se.a.userIcon
					}), t.modOnly && d.a.createElement(z.a, {
						className: se.a.modIcon
					}))
				},
				Ae = Object(c.c)({
					isDropdownOpen: (e, t) => Object(Ne.b)(Me(t.userName))(e)
				});
			class Fe extends d.a.Component {
				constructor(e) {
					super(e), this.onSetFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.findNextFocusableItem = () => {
						if (void 0 === this.state.focusedIndex) return -1; {
							const e = this.state.focusedIndex + 1;
							if (e <= this.props.templateIds.length - 1) return e
						}
					}, this.onMouseEnter = e => {
						const t = document.getElementById("focus-".concat(e));
						t && (t.focus(), this.onSetFocus(e))
					}, this.findPreviousFocusableItem = () => {
						if (void 0 !== this.state.focusedIndex && -1 !== this.state.focusedIndex) return this.state.focusedIndex - 1
					}, this.onKeyDown = e => {
						if (e.keyCode === Ie.a.ArrowDown)
							if (e.preventDefault(), this.props.isDropdownOpen) {
								const e = this.findNextFocusableItem();
								if (void 0 !== e) {
									const t = document.getElementById("focus-".concat(e));
									t && (t.focus(), t.scrollIntoView({
										block: "nearest"
									})), this.onSetFocus(e)
								}
							} else this.props.onToggleDropdown();
						if (e.keyCode === Ie.a.ArrowUp) {
							e.preventDefault();
							const t = this.findPreviousFocusableItem();
							if (void 0 !== t) {
								const e = document.getElementById("focus-".concat(t));
								e && (e.focus(), e.scrollIntoView({
									block: "nearest"
								})), this.onSetFocus(t)
							}
						}
						if (e.keyCode === Ie.a.Tab && this.props.isDropdownOpen && e.preventDefault(), e.keyCode === Ie.a.Enter) {
							if (e.preventDefault(), e.stopPropagation(), this.props.isDropdownOpen && void 0 !== this.state.focusedIndex) {
								const e = this.props.templateIds[this.state.focusedIndex];
								this.props.onSelectFlairTemplate(e)
							}
							this.props.onToggleDropdown()
						}
					}, this.state = {}
				}
				render() {
					const {
						props: e
					} = this;
					return d.a.createElement("button", {
						className: se.a.dropdownTarget,
						id: Me(e.userName),
						onClick: e.onToggleDropdown,
						onKeyDown: this.onKeyDown
					}, e.selectedTemplateId && e.userFlairTemplates[e.selectedTemplateId] ? d.a.createElement(Le, {
						flair: e.userFlairTemplates[e.selectedTemplateId]
					}) : o.fbt._("none", null, {
						hk: "ng6B"
					}), d.a.createElement(Te.a, {
						className: se.a.dropdownTriangle
					}), d.a.createElement(Re, {
						className: se.a.dropdownContainer,
						isOpen: e.isDropdownOpen,
						tooltipId: Me(e.userName)
					}, d.a.createElement("button", {
						className: se.a.dropdownRow,
						id: "focus-".concat(-1),
						onClick: () => e.onSelectFlairTemplate(void 0),
						onMouseEnter: () => this.onMouseEnter(-1),
						tabIndex: -1
					}, o.fbt._("none", null, {
						hk: "ng6B"
					})), e.templateIds.map((t, s) => {
						const n = e.userFlairTemplates[t];
						return d.a.createElement("button", {
							className: se.a.dropdownRow,
							id: "focus-".concat(s),
							key: t,
							onClick: () => e.onSelectFlairTemplate(t),
							onMouseEnter: () => this.onMouseEnter(s),
							tabIndex: -1
						}, d.a.createElement(Le, {
							flair: n
						}))
					})))
				}
			}
			var De = Object(l.b)(Ae, (e, t) => ({
				onToggleDropdown: () => e(Object(Se.h)({
					tooltipId: Me(t.userName)
				}))
			}))(Fe);
			const Be = e => "emoji-picker-".concat(e),
				Ue = Object(L.b)();
			class He extends d.a.PureComponent {
				constructor() {
					super(...arguments), this.onSelectFlairTemplate = e => {
						const t = e && this.props.userFlairTemplates[e],
							s = t ? Object(L.c)(t) : Ue;
						this.props.onChange(this.props.username, s)
					}, this.onFlairContentChanged = e => {
						this.props.onChange(this.props.username, e)
					}, this.onChangeCssClass = e => {
						const t = e.target.value,
							s = this.props.flair || Ue;
						this.props.onChange(this.props.username, Object.assign({}, s, {
							cssClass: t
						}))
					}, this.removeFlair = () => {
						this.props.onChange(this.props.username, null)
					}
				}
				render() {
					const {
						props: e
					} = this, {
						hasError: t
					} = e, s = e.flair || Ue, n = Object(_e.a)(), o = s.templateId, a = o && e.userFlairTemplates[o] || ce.a, r = !!a && a.modOnly, i = !Object(me.a)(s.cssClass || "");
					return d.a.createElement("div", {
						className: Object(v.a)(se.a.row, t ? se.a.hasError : null)
					}, d.a.createElement("div", {
						className: se.a.errorIndicator
					}, d.a.createElement(O.a, null)), d.a.createElement(Oe.a, {
						className: se.a.userLink,
						to: "/user/".concat(e.username)
					}, d.a.createElement(ke.a, {
						user: e.username,
						tooltipId: "grantuserflair--userhovercard--".concat(e.username),
						subredditId: e.subredditId,
						sendHoverCardEvent: ve.a
					}, e.username, d.a.createElement("div", {
						className: se.a.flairContainer
					}, d.a.createElement(Ce.b, {
						flair: s
					})))), d.a.createElement("div", {
						className: se.a.flairDetails
					}, d.a.createElement("div", {
						className: se.a.column
					}, d.a.createElement(De, {
						onSelectFlairTemplate: this.onSelectFlairTemplate,
						selectedTemplateId: o,
						templateIds: e.templateIds,
						userFlairTemplates: e.userFlairTemplates,
						userName: this.props.username
					})), d.a.createElement("div", {
						className: se.a.flairEditColumn
					}, d.a.createElement(n, {
						allowBlank: !e.isChanged,
						emojiPickerId: Be(e.username),
						flair: s,
						flairTemplateType: je.d.UserFlair,
						flairTemplate: a,
						helperTextClass: se.a.flairEditHelperText,
						isCompact: !0,
						isFlairModOnly: r,
						onChange: this.onFlairContentChanged,
						subredditId: e.subredditId
					})), d.a.createElement("div", {
						className: se.a.column
					}, d.a.createElement("input", {
						className: Object(v.a)(se.a.textInput, {
							[se.a.cssInputError]: !i
						}),
						value: s.cssClass || "",
						onChange: this.onChangeCssClass,
						disabled: !!a.id
					})), d.a.createElement("button", {
						className: se.a.removeButton,
						onClick: this.removeFlair
					}, d.a.createElement(ye.a, {
						className: se.a.removeIcon
					}))))
				}
			}
			var We = He;
			const Ve = {},
				qe = Object(R.t)({
					currentPageUrl: R.e
				}),
				Ge = Object(c.c)({
					flairedUserOrder: (e, t) => {
						const s = Object(Z.d)(t.subredditId, t.after, t.before);
						return e.flairedUsers.userOrder[s] || X
					},
					flairedUsers: (e, t) => e.flairedUsers.models[t.subredditId],
					isFlairedUsersListPending: e => e.flairedUsers.api.pending,
					isSearchPending: e => e.flairedUsers.search.api.pending,
					isUserFlairEnabled: $.a,
					origin: Y.l,
					pageInfo: (e, t) => {
						const s = Object(Z.d)(t.subredditId, t.after, t.before);
						return e.flairedUsers.pageInfo[s]
					},
					searchResult: (e, t) => e.flairedUsers.search.result,
					userFlairData: $.c
				}),
				Ke = Object(l.b)(Ge, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						deleteUserFlair: (t, s) => e(Object(b.a)(t, s)),
						saveFlairedUser: (t, n) => e(Object(b.c)(t, s, n)),
						searchFlairedUser: t => e(Object(b.d)(s, t))
					}
				});
			class ze extends d.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.isUnmounted = !1, this.pendingRequestsMap = new Map, this.autoSaveIntervalId = 0, this.processChanges = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						t.autoSaveIntervalId || (t.autoSaveIntervalId = window.setInterval(t.processChanges, ue));
						const {
							flairedUsers: s
						} = t.props, {
							unsavedChanges: n,
							searchTerm: o
						} = t.state, a = fe(n, s, o), r = ge(a, e);
						r.forEach(t.sendChangeToServer), a !== n && t.setState({
							unsavedChanges: a
						})
					}, this.sendChangeToServer = async e => {
						const t = e.username;
						if (this.pendingRequestsMap.get(t)) return;
						const s = this.props.flairedUsers[t] || null;
						this.sendTelemetryEvents(s, e.flair);
						const n = e.flair ? {
							type: pe.Save,
							promise: this.props.saveFlairedUser(t, e.flair)
						} : {
							type: pe.Delete,
							promise: this.props.deleteUserFlair(t, this.props.subredditId)
						};
						this.pendingRequestsMap.set(t, n);
						const o = await n.promise;
						this.pendingRequestsMap.delete(t), this.isUnmounted || this.setState(s => {
							const n = s.unsavedChanges[t];
							return e !== n ? null : {
								unsavedChanges: !0 === o ? Object(u.a)(s.unsavedChanges, t) : Object.assign({}, this.state.unsavedChanges, {
									[t]: Object.assign({}, e, {
										apiError: o
									})
								})
							}
						})
					}, this.onFlairChanged = (e, t) => {
						const {
							templates: s
						} = this.props.userFlairData, n = t && t.templateId ? s[t.templateId] : void 0;
						this.setState(s => {
							return {
								unsavedChanges: Object.assign({}, s.unsavedChanges, {
									[e]: {
										flair: t,
										username: e,
										changedAt: Date.now(),
										clientValidationError: xe(t, n)
									}
								})
							}
						})
					}, this.onSearch = e => {
						this.props.searchFlairedUser(e), this.setState({
							searchTerm: e
						}), this.props.sendEvent(B())
					}, this.onCancelSearch = () => {
						this.setState({
							searchTerm: null
						})
					}, this.onClickNextPage = () => this.props.sendEvent(U()), this.onClickPrevPage = () => this.props.sendEvent(H()), this.renderUserRow = e => {
						const {
							state: t,
							props: s
						} = this, n = s.flairedUsers[e] || null, o = t.unsavedChanges[e], a = o && !be(o) ? o.flair : n;
						return d.a.createElement(We, {
							flair: a,
							hasError: !!o && he(o),
							isChanged: !!o,
							key: e,
							onChange: this.onFlairChanged,
							subredditId: s.subredditId,
							templateIds: s.userFlairData.templateIds,
							userFlairTemplates: s.userFlairData.templates,
							username: e
						})
					}, this.state = {
						searchTerm: null,
						unsavedChanges: Ve
					}
				}
				componentDidUpdate() {
					this.processChanges()
				}
				componentWillUnmount() {
					this.isUnmounted = !0, this.processChanges(!0), window.clearInterval(this.autoSaveIntervalId)
				}
				sendTelemetryEvents(e, t) {
					if (!t) return void this.props.sendEvent(W());
					let s = e || Object(L.b)();
					const n = s.templateId || void 0,
						o = t.templateId || void 0;
					if (o !== n) {
						this.props.sendEvent(G(o));
						const e = t.templateId && this.props.userFlairData.templates[t.templateId];
						s = e ? Object(L.c)(e) : s
					}
					Object(L.o)(t, s) || this.props.sendEvent(q()), t.cssClass !== s.cssClass && this.props.sendEvent(K(t.cssClass || ""))
				}
				getIndicatorStatus() {
					const {
						unsavedChanges: e
					} = this.state;
					if (e === Ve) return null;
					const t = !!r()(e, e => he(e));
					return !!r()(e, e => !he(e)) ? j.a.Pending : t ? j.a.Failed : j.a.Complete
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = this.getIndicatorStatus(), a = e.pageInfo && (e.pageInfo.hasNextPage || e.pageInfo.hasPreviousPage), r = !e.flairedUserOrder.length && !a;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(E.c, {
						className: se.a.topBar
					}, null !== s && d.a.createElement(S, {
						status: s
					})), d.a.createElement(E.a, null, d.a.createElement(E.b, null, o.fbt._("Grant user flair", null, {
						hk: "N1r42"
					}), d.a.createElement(g.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360028091332")
					})), !e.isUserFlairEnabled && d.a.createElement(h.a, {
						className: se.a.disabledBanner,
						color: M.a.quarantine,
						icon: d.a.createElement(Q.a, {
							className: se.a.warningIcon
						}),
						title: o.fbt._("User flair has been disabled for this community", null, {
							hk: "3BBvFe"
						}),
						subtitle: o.fbt._("User flair will not be displayed in posts or comments", null, {
							hk: "3E4WaA"
						})
					}), d.a.createElement(P.b, {
						activeSearchQuery: t.searchTerm,
						onSearch: this.onSearch
					}, e.pageInfo && !t.searchTerm && d.a.createElement(x.a, {
						prevTo: Object(m.a)(Object(p.a)("".concat(e.origin).concat(e.currentPageUrl)), {
							before: e.pageInfo.startCursor
						}),
						prevButtonEnabled: e.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: e.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(m.a)(Object(p.a)("".concat(e.origin).concat(e.currentPageUrl)), {
							after: e.pageInfo.endCursor
						})
					})), d.a.createElement("div", {
						className: se.a.titleRow
					}, o.fbt._("Username with preview", null, {
						hk: "1RFjbI"
					}), d.a.createElement("div", {
						className: se.a.flairDetails
					}, d.a.createElement("div", {
						className: se.a.column
					}, o.fbt._("Flair template", null, {
						hk: "18cQfH"
					}), d.a.createElement(f.a, {
						className: se.a.infoTooltip
					}, d.a.createElement("div", {
						className: se.a.tooltipText
					}, o.fbt._("Flair templates determine the flair's background colors, text colors, and permissions", null, {
						hk: "4y58Eg"
					})), d.a.createElement("div", {
						className: se.a.tooltipIconContainer
					}, d.a.createElement("div", {
						className: se.a.tooltipIconRow
					}, d.a.createElement(z.a, {
						className: se.a.modIcon
					}), d.a.createElement("span", {
						className: se.a.tooltipIconText
					}, o.fbt._("Available only to mods", null, {
						hk: "2s7Gci"
					}))), d.a.createElement("div", {
						className: se.a.tooltipIconRow
					}, d.a.createElement(J.a, {
						className: se.a.userIcon
					}), d.a.createElement("span", {
						className: se.a.tooltipIconText
					}, o.fbt._("User editable", null, {
						hk: "3tIGRy"
					})))))), d.a.createElement("div", {
						className: se.a.flairEditColumn
					}, o.fbt._("Flair text", null, {
						hk: "2ab8Up"
					}), d.a.createElement(f.a, {
						text: o.fbt._("Changes the text and emojis within the user flair", null, {
							hk: "4dBW4C"
						})
					})), d.a.createElement("div", {
						className: se.a.column
					}, o.fbt._("Css class", null, {
						hk: "1TNNcJ"
					}), d.a.createElement(f.a, {
						text: o.fbt._("CSS classes determine styling for flair in old Reddit", null, {
							hk: "j4AU"
						})
					})))), t.searchTerm ? d.a.createElement(I.a, {
						cancelSearch: this.onCancelSearch,
						noResultsFound: !e.searchResult,
						searchTerm: t.searchTerm,
						searchPending: e.isSearchPending
					}, e.searchResult && this.renderUserRow(e.searchResult)) : e.isFlairedUsersListPending ? d.a.createElement(T.a, null) : r ? d.a.createElement(ne, null) : e.flairedUserOrder.map(this.renderUserRow), e.pageInfo && !t.searchTerm && d.a.createElement("div", {
						className: se.a.bottomBarRow
					}, d.a.createElement(x.a, {
						prevTo: Object(m.a)(Object(p.a)("".concat(e.origin).concat(e.currentPageUrl)), {
							before: e.pageInfo.startCursor
						}),
						prevButtonEnabled: e.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: e.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(m.a)(Object(p.a)("".concat(e.origin).concat(e.currentPageUrl)), {
							after: e.pageInfo.endCursor
						})
					}))))
				}
			}
			t.a = qe(Ke(Object(N.c)(ze)))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/reddit/actions/tooltip.ts"),
				d = s("./src/reddit/models/User/index.ts"),
				l = s("./src/reddit/selectors/experiments/econAwardKarma.ts"),
				c = s("./src/reddit/selectors/gov.ts"),
				m = s("./src/reddit/selectors/meta.ts"),
				u = s("./src/reddit/selectors/moderatorPermissions.ts"),
				p = s("./src/reddit/selectors/tooltip.ts"),
				b = s("./src/reddit/selectors/user.ts"),
				h = s("./src/reddit/selectors/userFlair.ts"),
				g = s("./src/reddit/selectors/userPrefs.ts"),
				f = s("./src/reddit/selectors/profile.ts"),
				x = s("./node_modules/fbt/lib/FbtPublic.js"),
				E = s("./src/config.ts"),
				v = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				C = s("./src/lib/lessComponent.tsx"),
				_ = s("./src/lib/prettyPrintNumber/index.ts"),
				k = s("./src/lib/timeAgo/index.ts"),
				O = s("./src/reddit/components/ChatButton/index.tsx"),
				y = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				j = s("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				w = s("./src/reddit/components/SubscribeButton/index.tsx"),
				S = s("./src/reddit/components/UserIcon/index.tsx"),
				I = s("./src/reddit/helpers/trackers/authorHovercard.ts"),
				P = s("./src/reddit/icons/fonts/Info/index.tsx"),
				T = s("./src/reddit/icons/svgs/Admin/index.tsx"),
				N = s("./src/reddit/icons/svgs/Karma/index.tsx"),
				M = s("./src/reddit/icons/svgs/Premium/index.tsx"),
				R = s("./src/reddit/models/Gold/Award.ts"),
				L = s("./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx"),
				A = s("./src/reddit/actions/inContextModeration.ts"),
				F = s("./src/reddit/actions/modal.ts"),
				D = s("./src/reddit/actions/subredditModeration.ts"),
				B = s("./src/reddit/constants/modals.ts"),
				U = s("./src/reddit/components/Hovercards/helpers.ts"),
				H = s("./src/reddit/icons/svgs/Ban/index.tsx"),
				W = s("./src/reddit/icons/svgs/Mute/index.tsx"),
				V = s("./src/reddit/icons/svgs/Unban/index.tsx"),
				q = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				G = s("./src/reddit/selectors/subredditModeration.ts"),
				K = s("./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less"),
				z = s.n(K);
			const {
				fbt: Q
			} = s("./node_modules/fbt/lib/FbtPublic.js"), J = C.a.wrapped(H.a, "BanIcon", z.a), Z = C.a.wrapped(W.a, "MuteIcon", z.a), X = C.a.wrapped(V.a, "UnbanIcon", z.a), Y = Object(r.c)({
				hasModMailPermissions: Object(u.a)(q.c.mail),
				isUserBanned: (e, t) => !!Object(G.g)(e, {
					subredditId: t.subredditId,
					username: t.username
				}),
				user: (e, t) => Object(b.eb)(e, {
					userName: t.username
				})
			});
			class $ extends o.a.Component {
				componentDidMount() {
					this.props.requestUserBanInfo()
				}
				render() {
					const {
						className: e,
						contextId: t,
						hasModMailPermissions: s,
						isUserBanned: n,
						onUnbanUser: a,
						sendEvent: r,
						toggleBanModal: i,
						toggleMuteModal: d
					} = this.props;
					return o.a.createElement("div", {
						className: e
					}, n ? o.a.createElement(U.a, {
						role: "button",
						onClick: () => {
							a(this.props.user.id), r(I.e(t))
						}
					}, o.a.createElement(X, null), Q._("Unban User", null, {
						hk: "1aASyW"
					})) : o.a.createElement(U.a, {
						role: "button",
						onClick: () => {
							i(), r(I.a(t))
						}
					}, o.a.createElement(J, null), Q._("Ban User", null, {
						hk: "3OhuLx"
					})), s && o.a.createElement(U.a, {
						role: "button",
						onClick: () => {
							d(), r(I.d(t))
						}
					}, o.a.createElement(Z, null), Q._("Mute User", null, {
						hk: "3MCujH"
					})))
				}
			}
			var ee = Object(a.b)(Y, (e, t) => {
					let {
						username: s,
						subredditId: n,
						contextId: o
					} = t;
					return {
						onUnbanUser: t => e(Object(D.nb)(n, t)),
						requestUserBanInfo: () => e(Object(D.Z)(n, {
							username: s
						})),
						toggleBanModal: () => {
							e(Object(A.c)({
								username: s,
								subredditId: n,
								contextId: o
							})), e(Object(D.X)(n, s))
						},
						toggleMuteModal: () => {
							e(Object(A.d)({
								username: s,
								subredditId: n,
								contextId: o
							})), e(Object(F.i)(B.a.MUTE_USER))
						}
					}
				})($),
				te = s("./src/reddit/actions/userFlair.ts"),
				se = s("./src/reddit/icons/svgs/Tag/index.tsx"),
				ne = s("./src/reddit/components/Hovercards/AuthorHovercard/ModFlairActions.m.less"),
				oe = s.n(ne);
			const {
				fbt: ae
			} = s("./node_modules/fbt/lib/FbtPublic.js"), re = C.a.wrapped(se.a, "FlairIcon", oe.a);
			var ie = Object(a.b)(null, (e, t) => ({
					onToggleUserFlairModal: () => e(Object(te.p)(t.subredditId, t.username))
				}))(e => o.a.createElement(U.a, {
					role: "button",
					onClick: () => {
						e.onToggleUserFlairModal(), e.sendEvent(I.c(e.contextId))
					}
				}, o.a.createElement(re, null), ae._("Edit user flair", null, {
					hk: "4mTxM"
				}))),
				de = s("./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less"),
				le = s.n(de);

			function ce() {
				return (ce = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const me = C.a.wrapped(S.a, "UserIcon", le.a),
				ue = C.a.wrapped(w.a, "SubscribeButton", le.a),
				pe = C.a.wrapped(O.a, "ChatButton", le.a),
				be = C.a.wrapped(N.a, "KarmaIcon", le.a),
				he = C.a.wrapped(M.a, "PremiumIcon", le.a),
				ge = C.a.wrapped(v.a, "UserNameLink", le.a),
				fe = C.a.div("UserNameMetaData", le.a),
				xe = C.a.div("MetaDataItem", le.a),
				Ee = C.a.div("Bullet", le.a),
				ve = C.a.div("UserNameContainer", le.a),
				Ce = C.a.div("UserInfoContainer", le.a),
				_e = C.a.div("PostKarma", le.a),
				ke = C.a.div("CommentKarma", le.a),
				Oe = C.a.div("KarmaGrid", le.a),
				ye = C.a.div("GenericKarma", le.a),
				je = C.a.a("InfoLink", le.a),
				we = C.a.div("KarmaCount", le.a),
				Se = C.a.div("KarmaLabel", le.a),
				Ie = C.a.div("GenericKarmaLabel", le.a),
				Pe = C.a.div("BannerImage", le.a),
				Te = C.a.div("UserContainer", le.a),
				Ne = C.a.div("BottomSpacer", le.a),
				Me = C.a.div("Container", le.a),
				Re = e => o.a.createElement("div", null, o.a.createElement("div", null, o.a.createElement(ge, {
					to: "/user/".concat(e.userName, "/")
				}, "u/".concat(e.userName)), e.user.isEmployee && o.a.createElement(T.a, {
					className: le.a.adminIcon,
					title: x.fbt._("Reddit admin", null, {
						hk: "15wBTE"
					})
				}), e.user.isGold && o.a.createElement(v.a, {
					to: "/premium"
				}, o.a.createElement(he, null))), o.a.createElement(fe, null, e.user.username && o.a.createElement(xe, null, e.user.username, o.a.createElement(Ee, null, "•")), o.a.createElement(xe, null, Object(k.d)(e.user.createdUtc || e.user.created)))),
				Le = e => {
					const {
						showAwardKarma: t,
						user: s
					} = e;
					return t ? o.a.createElement(Oe, null, o.a.createElement(ye, null, o.a.createElement(we, null, Object(_.b)(s.postKarma)), o.a.createElement(Ie, null, x.fbt._({
						"*": "Post Karma",
						_1: " Post Karma"
					}, [x.fbt._plural(s.postKarma)], {
						hk: "3K4oaH"
					}))), o.a.createElement(ye, null, o.a.createElement(we, null, Object(_.b)(s.commentKarma)), o.a.createElement(Ie, null, x.fbt._({
						"*": "Comment Karma",
						_1: " Comment Karma"
					}, [x.fbt._plural(s.commentKarma)], {
						hk: "3gKRx9"
					}))), o.a.createElement(ye, null, o.a.createElement(we, null, Object(_.b)(s.awardeeKarma)), o.a.createElement(Ie, null, x.fbt._({
						"*": "Awardee Karma",
						_1: " Awardee Karma"
					}, [x.fbt._plural(s.awardeeKarma)], {
						hk: "3nzm9q"
					}), o.a.createElement(je, {
						href: R.a,
						target: "_blank",
						rel: "noopener noreferrer"
					}, o.a.createElement(P.a, {
						className: le.a.infoIcon
					})))), o.a.createElement(ye, null, o.a.createElement(we, null, Object(_.b)(s.awarderKarma)), o.a.createElement(Ie, null, x.fbt._({
						"*": "Awarder Karma",
						_1: " Awarder Karma"
					}, [x.fbt._plural(s.awarderKarma)], {
						hk: "4zXN3B"
					}), o.a.createElement(je, {
						href: R.a,
						target: "_blank",
						rel: "noopener noreferrer"
					}, o.a.createElement(P.a, {
						className: le.a.infoIcon
					}))))) : o.a.createElement(Ce, null, o.a.createElement(be, null), o.a.createElement(_e, null, o.a.createElement(we, null, Object(_.b)(s.postKarma)), o.a.createElement(Se, null, x.fbt._({
						"*": "Post Karma",
						_1: " Post Karma"
					}, [x.fbt._plural(s.postKarma)], {
						hk: "3K4oaH"
					}))), o.a.createElement(ke, null, o.a.createElement(we, null, Object(_.b)(s.commentKarma)), o.a.createElement(Se, null, x.fbt._({
						"*": "Comment Karma",
						_1: " Comment Karma"
					}, [x.fbt._plural(s.commentKarma)], {
						hk: "3gKRx9"
					}))))
				},
				Ae = Object(j.a)(e => {
					const {
						className: t,
						contextId: s,
						hideNSFWPref: n,
						hoverId: a,
						isCurrentUser: r,
						isLoggedIn: i,
						origin: d,
						moderatorPermissions: l,
						prefersReducedMotion: c,
						sendEvent: m,
						showAwardKarma: u,
						style: p,
						subredditId: b,
						userName: h,
						user: g,
						userFlair: f,
						acceptChats: v
					} = e;
					if (!g) return o.a.createElement(Me, {
						style: p
					});
					const C = g.isNSFW && n,
						_ = g.accountIcon || "".concat(E.a.assetPath, "/img/snoo_user_placeholder.png"),
						k = l && l.flair,
						O = l && l.access,
						j = f && f.templateIds && f.templateIds.length > 0,
						w = f && f.displaySettings && f.displaySettings.isEnabled,
						{
							awardedLastMonth: S
						} = g,
						P = C ? "".concat(E.a.assetPath, "/img/user-info-banner.png") : e.user.bannerImage;
					return o.a.createElement(Me, {
						className: t,
						id: a,
						style: p
					}, P && o.a.createElement(Pe, {
						style: {
							backgroundImage: "url('".concat(P, "')")
						}
					}), o.a.createElement(Te, null, o.a.createElement(ve, null, o.a.createElement(me, {
						iconUrl: _,
						isNSFW: g.isNSFW,
						userName: h
					}), o.a.createElement(Re, {
						origin: d,
						user: g,
						userName: h
					})), o.a.createElement(Le, {
						showAwardKarma: u,
						user: g
					}), S && o.a.createElement(L.a, {
						prefersReducedMotion: c,
						recentAwardings: S,
						username: h
					}), i && !r && v && o.a.createElement(pe, {
						contextId: s,
						userId: g.id
					}, x.fbt._("Start Chat", null, {
						hk: "2mfqRE"
					})), g.hasUserProfile && !r && o.a.createElement(ue, {
						identifier: {
							name: e.user.username,
							type: "profile"
						},
						getEventFactory: e => Object(I.g)(e ? "unfollow" : "follow", s),
						small: !0
					})), O && s && !r && b && o.a.createElement(ee, {
						contextId: s,
						subredditId: b,
						sendEvent: m,
						username: h
					}), k && s && j && w && b && o.a.createElement(ie, {
						contextId: s,
						subredditId: b,
						sendEvent: m,
						username: h
					}), o.a.createElement(y.i, {
						contextId: s,
						subredditId: b,
						user: g
					}), !(O || i) && o.a.createElement(Ne, null))
				});
			var Fe = e => {
				const t = e.activeTooltipId === e.tooltipId;
				return o.a.createElement(Ae, ce({
					isOpen: t
				}, e))
			};
			const De = Object(r.c)({
					tokenName: c.p,
					activeTooltipId: p.a,
					isCurrentUser: (e, t) => {
						const s = Object(b.i)(e);
						return !!s && Object(d.e)(s) === t.userName
					},
					isLoggedIn: b.H,
					hideNSFWPref: b.z,
					moderatorPermissions: u.j,
					origin: m.l,
					prefersReducedMotion: g.c,
					showAwardKarma: l.a,
					user: b.eb,
					userFlair: h.c,
					acceptChats: (e, t) => {
						const s = Object(f.h)(e, {
							profileName: t.userName
						});
						return !s || s.acceptChats
					}
				}),
				Be = Object(a.b)(De, (e, t) => ({
					onHideTooltip: () => e(Object(i.i)())
				}));
			t.a = Be(e => o.a.createElement("div", {
				className: e.className,
				id: e.tooltipId,
				onMouseLeave: e.onHideTooltip
			}, o.a.createElement(Fe, {
				activeTooltipId: e.activeTooltipId,
				contextId: e.contextId,
				isCurrentUser: e.isCurrentUser,
				isLoggedIn: e.isLoggedIn,
				hideNSFWPref: e.hideNSFWPref,
				hoverId: e.hoverId,
				moderatorPermissions: e.moderatorPermissions,
				onHideTooltip: e.onHideTooltip,
				origin: e.origin,
				prefersReducedMotion: e.prefersReducedMotion,
				sendEvent: e.sendEvent,
				showAwardKarma: e.showAwardKarma,
				subredditId: e.subredditId,
				tokenName: e.tokenName,
				tooltipId: e.tooltipId,
				tooltipType: e.tooltipType,
				user: e.user,
				userFlair: e.userFlair,
				userName: e.userName,
				acceptChats: e.acceptChats
			})))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less": function(e, t, s) {
			e.exports = {
				BanIcon: "_2g595huO3XJ8C5PGbnTIcH",
				banIcon: "_2g595huO3XJ8C5PGbnTIcH",
				MuteIcon: "_1qnIs5F_qVlqqqY9ZvtGHT",
				muteIcon: "_1qnIs5F_qVlqqqY9ZvtGHT",
				UnbanIcon: "_3gnOs3YMjVI2NyE6rZjyL3",
				unbanIcon: "_3gnOs3YMjVI2NyE6rZjyL3"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModFlairActions.m.less": function(e, t, s) {
			e.exports = {
				FlairIcon: "_2xaYvwRfHZMRW_6lyBpV4v",
				flairIcon: "_2xaYvwRfHZMRW_6lyBpV4v"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/Hovercards/HoverDiv/index.tsx"),
				r = s("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				i = s("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = Object(i.c)(e => {
				const t = "".concat(e.tooltipId, "-hover-id");
				return o.a.createElement(a.a, {
					hoverId: t,
					sendHoverEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId,
					authorOrSubredditName: e.user
				}, e.children, o.a.createElement(r.a, {
					className: e.className,
					hoverId: t,
					sendEvent: e.sendEvent,
					subredditId: e.subredditId,
					tooltipId: e.tooltipId,
					tooltipType: e.tooltipType,
					userName: e.user
				}))
			})
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less": function(e, t, s) {
			e.exports = {
				ChatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				chatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				UserIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				userIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				SubscribeButton: "yFByQg8RzENoqoOt0ysAk",
				subscribeButton: "yFByQg8RzENoqoOt0ysAk",
				KarmaIcon: "_2XmHHGriP3EYLhv_9BG6OT",
				karmaIcon: "_2XmHHGriP3EYLhv_9BG6OT",
				PremiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				premiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				Token: "_2U0P3n4v75sHsDvQmSKNz3",
				token: "_2U0P3n4v75sHsDvQmSKNz3",
				UserNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				userNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				UserNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				userNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				GildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				gildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				Bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				MetaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				metaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				UserNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				userNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				UserInfoContainer: "_3l7ptRjFJYo-fcXXajRpqn",
				userInfoContainer: "_3l7ptRjFJYo-fcXXajRpqn",
				PostKarma: "_2T3kavHwxOaL76xfa9id7",
				postKarma: "_2T3kavHwxOaL76xfa9id7",
				CommentKarma: "_1rFYsN1yoSDrDTRfqagI5r",
				commentKarma: "_1rFYsN1yoSDrDTRfqagI5r",
				KarmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				karmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				GenericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				genericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				KarmaCount: "_18aX_pAQub_mu1suz4-i8j",
				karmaCount: "_18aX_pAQub_mu1suz4-i8j",
				KarmaLabel: "_1b2tgHrvjFKgTLyFIQ9B6T",
				karmaLabel: "_1b2tgHrvjFKgTLyFIQ9B6T",
				GenericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				genericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				InfoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				infoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				BannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				bannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				UserContainer: "_m7PpFuKATP9fZF4xKf9R",
				userContainer: "_m7PpFuKATP9fZF4xKf9R",
				BottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				bottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				UserActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				userActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				Container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				adminIcon: "_2aJuBKF3mo4YJS4YFkeU9a"
			}
		},
		"./src/reddit/components/Hovercards/HoverDiv/index.m.less": function(e, t, s) {
			e.exports = {
				HoverDiv: "_2mHuuvyV9doV3zwbZPtIPG",
				hoverDiv: "_2mHuuvyV9doV3zwbZPtIPG"
			}
		},
		"./src/reddit/components/Hovercards/HoverDiv/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return v
			})), s.d(t, "b", (function() {
				return C
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/lessComponent.tsx"),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/profile/index.ts"),
				l = s("./src/reddit/actions/tooltip.ts"),
				c = s("./src/reddit/selectors/tooltip.ts");
			const m = Object(i.c)({
				dropdownIsOpen: (e, t) => Object(c.b)(t.tooltipId)(e)
			});
			var u = Object(r.b)(m, (e, t) => ({
					onCloseUserDropdown: () => e(Object(l.i)()),
					onOpenUserDropdown: async () => {
						e(Object(l.f)({
							tooltipId: t.tooltipId
						})), t.authorOrSubredditName && e(Object(d.d)(t.authorOrSubredditName))
					}
				})),
				p = s("./src/reddit/actions/subreddit.ts");
			const b = Object(i.c)({
				dropdownIsOpen: (e, t) => Object(c.b)(t.tooltipId)(e)
			});
			var h = Object(r.b)(b, (e, t) => ({
					onCloseUserDropdown: () => e(Object(l.i)()),
					onOpenUserDropdown: async () => {
						e(Object(l.f)({
							tooltipId: t.tooltipId
						})), t.authorOrSubredditName && e(Object(p.t)(t.authorOrSubredditName))
					}
				})),
				g = s("./src/reddit/components/Hovercards/HoverDiv/index.m.less"),
				f = s.n(g);
			class x extends o.a.Component {
				constructor() {
					super(...arguments), this.closeHovercardTimeoutId = 0, this.openHovercardTimeoutId = 0, this.isHovering = !1, this.hoverEl = void 0, this.onHoverElMouseEnter = () => {
						this.isHovering = !0
					}, this.onHoverElMouseLeave = () => {
						this.isHovering = !1
					}, this.onMouseEnter = e => {
						this.closeHovercardTimeoutId && clearTimeout(this.closeHovercardTimeoutId), this.openHovercardTimeoutId = window.setTimeout(() => {
							this.isHovering || this.props.dropdownIsOpen || (this.props.onOpenUserDropdown(), this.props.sendHoverEvent())
						}, 500)
					}, this.onMouseLeave = () => {
						this.openHovercardTimeoutId && clearTimeout(this.openHovercardTimeoutId), this.closeHovercardTimeoutId = window.setTimeout(() => {
							this.isHovering || this.props.onCloseUserDropdown()
						}, 300)
					}
				}
				componentDidMount() {
					const e = document.getElementById(this.props.hoverId);
					e && (this.hoverEl = e, this.addHoverListeners(this.hoverEl))
				}
				componentWillUnmount() {
					this.hoverEl && this.removeHoverListeners(this.hoverEl), this.hoverEl = void 0, this.openHovercardTimeoutId && window.clearTimeout(this.openHovercardTimeoutId)
				}
				addHoverListeners(e) {
					e.addEventListener("mouseenter", this.onHoverElMouseEnter), e.addEventListener("mouseleave", this.onHoverElMouseLeave)
				}
				removeHoverListeners(e) {
					e.removeEventListener("mouseenter", this.onHoverElMouseEnter), e.removeEventListener("mouseleave", this.onHoverElMouseLeave)
				}
				render() {
					const {
						children: e,
						className: t
					} = this.props;
					return o.a.createElement("div", {
						className: t,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, e)
				}
			}
			const E = a.a.wrapped(x, "HoverDiv", f.a),
				v = u(E),
				C = h(E)
		},
		"./src/reddit/components/Hovercards/helpers.m.less": function(e, t, s) {
			e.exports = {
				UserActionItem: "_3HFQBVggvR9KDsFzm7jIdr",
				userActionItem: "_3HFQBVggvR9KDsFzm7jIdr"
			}
		},
		"./src/reddit/components/Hovercards/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			})), s.d(t, "b", (function() {
				return d
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/layout/row/Inline/index.tsx"),
				a = s("./src/reddit/components/Hovercards/helpers.m.less"),
				r = s.n(a);
			const i = n.a.wrapped(o.a, "UserActionItem", r.a),
				d = e => {
					const {
						author: t,
						itemId: s,
						subredditName: n,
						tooltipIdPrefix: o,
						tooltipType: a
					} = e;
					let r = o;
					return s && (r = "".concat(r, "--").concat(s)), a && (r = "".concat(r, "--").concat(a)), t && (r = "".concat(r, "--").concat(t)), n && (r = "".concat(r, "--").concat(n)), r
				}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, s) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				i = s.n(r),
				d = s("./src/lib/lessComponent.tsx");
			const l = d.a.div("IconWrapper", i.a),
				c = d.a.div("TextWrapper", i.a);
			t.a = e => {
				const {
					className: t,
					color: s,
					icon: n,
					subtitle: r,
					title: d
				} = e;
				return o.a.createElement("div", {
					className: Object(a.a)(t, i.a.wrapper),
					style: s && {
						borderColor: s
					} || {}
				}, o.a.createElement("div", {
					className: i.a.leftSideRectangle,
					style: s && {
						backgroundColor: s
					} || {}
				}), n ? o.a.createElement(l, null, n) : o.a.createElement(l, null), o.a.createElement(c, null, o.a.createElement("div", {
					className: i.a.title
				}, d), r && o.a.createElement("div", {
					className: i.a.subtitle
				}, r)))
			}
		},
		"./src/reddit/components/InlineSubredditEditing/index.m.less": function(e, t, s) {
			e.exports = {
				tooltipContent: "RrvkJ7ntzKYyaCOxMJ1RM",
				title: "BE2vGjFTJ80XkdBpRRr0p",
				tooltipBody: "_2yezzi8dgIemh3F2q_kvcp",
				topRow: "_1JfvdiRxYTSKf1IIe7DUvM",
				gotIt: "_1MHKCZd72tAgyoZWvIYM-G"
			}
		},
		"./src/reddit/components/ModActionsMenu/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/reddit/actions/tooltip.ts"),
				d = s("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				l = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				c = s("./src/reddit/selectors/tooltip.ts");
			const m = Object(r.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: s
						} = t;
						return Object(c.b)(s)(e)
					}
				}),
				u = Object(a.b)(m, (e, t) => {
					let {
						dropdownId: s
					} = t;
					return {
						toggleDropdown: () => e(Object(i.h)({
							tooltipId: s
						}))
					}
				}),
				p = () => null;
			t.a = u(e => o.a.createElement("div", {
				id: e.dropdownId,
				onClick: e.dropdownIsOpen ? p : e.onClick
			}, e.inCommentFlatlist ? o.a.createElement(d.b, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children) : o.a.createElement(l.c, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children)))
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_12gWQ2C_gotA8s5-CJIlq9",
				icon: "_3-Fcrds7R5ihAWPAttv3AL",
				title: "_1vL1j4mpTYI5NOR335bInG",
				subtitle: "_3FOOtAw2Q-T7szrSBAbo9i"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less": function(e, t, s) {
			e.exports = {
				tabBar: "_1ItRVjBpP4aLG0vg-nXbwO",
				tab: "_3A18ggmDWAI5_Fz0nDOs-z",
				selected: "_3U85C8qDDoOUoOINg-E_3S"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less": function(e, t, s) {
			e.exports = {
				contentContainer: "_2O3bUryrh35-WVnz9Zoet5",
				content: "_1FTRfhuddBV5YzYiIzObiO",
				grid: "_3i8uEN2ZVREoZOqW0PBJKD",
				header: "_3TFv4L83k0sAQxxxDJCzh9",
				actionHeader: "_3XGx1tfvY30VXMwrnAYMfZ",
				cell: "_30GfT3S_RWhS9B1JiSCaIJ",
				imageCell: "_1mzA539xYQn08RGzbn-Rgl",
				image: "_2UKv8w6-nnOZn6-lOqv57x",
				imagePlaceholder: "_2-8LfoYIQ37smNisBTPrPA",
				title: "_2cEKePFj4PUyuqlM_8uInw",
				caption: "_33iTirQvYAUBeq5vAp6Nr6",
				timeCell: "_1EzbYLhrmLPhhpk2FFAmcj",
				actionCell: "_1JvlfJR1EFT7pnSONpgiXk",
				dropdownSelector: "_2K7txHCmQX-J_7K7zNiCM1",
				byModerator: "_3czV_FVsdvYbnimTT57vCK",
				line: "_22JqeR_rL-tI8mxRb7N8Mq",
				loadingTextLong: "_2AZFpVa_LwltM1gTwCGIDe",
				loadingTextShort: "_1LWRk2sNojXWsOI1Y85nf7"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return W
			})), s.d(t, "b", (function() {
				return V
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./src/reddit/actions/governance/errorToast.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				c = s("./src/reddit/contexts/ApiContext.tsx"),
				m = s("./src/reddit/endpoints/economics/uploadedAssets.ts"),
				u = s("./src/reddit/models/Toast/index.ts"),
				p = s("./src/lib/lessComponent.tsx"),
				b = s("./src/reddit/icons/svgs/SnooHappy/index.tsx"),
				h = s("./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less"),
				g = s.n(h);
			const f = {
				[m.a.Uploaded]: {
					title: () => n.fbt._("No more to review!", null, {
						hk: "2rF58X"
					}),
					subtitle: () => n.fbt._("There are no new submissions", null, {
						hk: "3h54Ot"
					})
				},
				[m.a.Approved]: {
					title: () => n.fbt._("Nothing approved yet", null, {
						hk: "157fUO"
					}),
					subtitle: () => n.fbt._("Submissions will be here once you approve them", null, {
						hk: "pLc2c"
					})
				},
				[m.a.Rejected]: {
					title: () => n.fbt._("Nothing rejected yet", null, {
						hk: "1XN9kw"
					}),
					subtitle: () => n.fbt._("Submissions will be here once you reject them", null, {
						hk: "2IYFHB"
					})
				}
			};
			var x = e => {
					const t = f[e.selectedStatus];
					return a.a.createElement("div", {
						className: g.a.container
					}, a.a.createElement(b.a, {
						className: g.a.icon
					}), a.a.createElement("h3", {
						className: g.a.title
					}, t.title()), a.a.createElement("p", {
						className: g.a.subtitle
					}, t.subtitle()))
				},
				E = s("./src/reddit/components/AuthorLink/index.tsx"),
				v = s("./src/reddit/controls/DropdownSelector/index.tsx"),
				C = s("./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less"),
				_ = s.n(C);
			const k = p.a.div("cell", _.a),
				O = () => [{
					displayText: n.fbt._("New", null, {
						hk: "2xTBYx"
					}),
					value: m.a.Uploaded
				}, {
					displayText: n.fbt._("Approved", null, {
						hk: "1xx5DL"
					}),
					value: m.a.Approved
				}, {
					displayText: n.fbt._("Rejected", null, {
						hk: "25TTJE"
					}),
					value: m.a.Rejected
				}],
				y = () => O().slice(1, 3),
				j = new Intl.DateTimeFormat(void 0, {
					month: "numeric",
					day: "numeric",
					year: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric"
				}).format;

			function w(e) {
				const {
					item: t,
					onItemAction: s
				} = e, o = O().find(e => e.value === t.status);
				let r = t.type === m.b.Badge ? t.extra.description : void 0;
				return r && r.endsWith(" u/" + t.uploader) && (r = r.slice(0, r.length - t.uploader.length - 3)), a.a.createElement(a.a.Fragment, null, a.a.createElement(k, {
					className: _.a.imageCell
				}, a.a.createElement("div", {
					className: _.a.image,
					style: {
						backgroundImage: "url(".concat(t.url, ")")
					}
				})), a.a.createElement(k, {
					className: _.a.nameCell
				}, a.a.createElement("div", {
					className: _.a.title
				}, t.type === m.b.Emote ? ":".concat(t.name, ":") : t.name), a.a.createElement("div", {
					className: _.a.caption
				}, r, " ", a.a.createElement(E.a, {
					author: t.uploader,
					style: {
						color: t.type === m.b.Badge ? t.extra.color : void 0
					}
				}, "u/", t.uploader))), a.a.createElement(k, {
					className: _.a.timeCell
				}, j(t.createdAt)), a.a.createElement(k, {
					className: _.a.actionCell
				}, a.a.createElement(v.a, {
					className: _.a.dropdownSelector,
					displayText: o ? o.displayText : "",
					options: y(),
					onSelect: e => s(t, e.value),
					isCompactStyle: !0
				}), t.status !== m.a.Uploaded && !!t.moderator && !!t.modifiedAt && a.a.createElement("div", {
					className: _.a.byModerator
				}, n.fbt._("by u/ {moderator}, {time-modified}", [n.fbt._param("moderator", t.moderator), n.fbt._param("time-modified", j(t.modifiedAt))], {
					hk: "25I5ES"
				}))), a.a.createElement("div", {
					className: _.a.line
				}))
			}
			var S = s("./src/lib/classNames/index.ts");
			const I = p.a.div("cell", _.a),
				P = () => a.a.createElement(a.a.Fragment, null, a.a.createElement(I, {
					className: _.a.imageCell
				}, a.a.createElement("div", {
					className: Object(S.a)(_.a.image, _.a.imagePlaceholder)
				})), a.a.createElement(I, {
					className: _.a.nameCell
				}, a.a.createElement("div", {
					className: _.a.loadingTextLong
				})), a.a.createElement(I, null, a.a.createElement("div", {
					className: _.a.loadingTextShort
				})), a.a.createElement(I, {
					className: _.a.actionCell
				}, a.a.createElement("div", {
					className: _.a.loadingTextShort
				})), a.a.createElement("div", {
					className: _.a.line
				}));
			var T = () => a.a.createElement(a.a.Fragment, null, a.a.createElement(P, null), a.a.createElement(P, null), a.a.createElement(P, null), a.a.createElement(P, null));
			const {
				fbt: N
			} = s("./node_modules/fbt/lib/FbtPublic.js"), M = p.a.div("header", _.a);
			var R = e => {
					const {
						onAssetAction: t,
						assets: s,
						selectedStatus: n
					} = e;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement("div", {
						className: _.a.grid
					}, a.a.createElement(M, null, N._("Image", null, {
						hk: "3ImlXy"
					})), a.a.createElement(M, null, N._("Name and Description", null, {
						hk: "ZMWPH"
					})), a.a.createElement(M, null, N._("Submission Time", null, {
						hk: "3qPqQa"
					})), a.a.createElement(M, {
						className: _.a.actionHeader
					}, N._("Action", null, {
						hk: "27SYzP"
					})), !s && a.a.createElement(T, null), s && !!s.length && s.map(e => a.a.createElement(w, {
						item: e,
						key: e.name,
						onItemAction: t
					}))), s && !s.length && a.a.createElement(x, {
						selectedStatus: n
					}))
				},
				L = s("./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less"),
				A = s.n(L);
			const F = e => a.a.createElement("button", {
					className: Object(S.a)(A.a.tab, {
						[A.a.selected]: e.selected
					}),
					onClick: e.onClick
				}, e.children),
				D = e => a.a.createElement("div", {
					className: A.a.tabBar
				}, [m.a.Uploaded, m.a.Approved, m.a.Rejected].map(t => a.a.createElement(F, {
					onClick: () => e.onTabSelected(t),
					selected: t === e.value,
					value: t,
					key: t
				}, (e => {
					switch (e) {
						case m.a.Uploaded:
							return n.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							});
						case m.a.Approved:
							return n.fbt._("Approved", null, {
								hk: "37lIL9"
							});
						case m.a.Rejected:
							return n.fbt._("Rejected", null, {
								hk: "W16pI"
							});
						default:
							return n.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							})
					}
				})(t))));

			function B() {
				return (B = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			class U extends a.a.Component {
				constructor() {
					super(...arguments), this.state = {
						selectedStatus: m.a.Uploaded
					}, this.onTabChange = async e => {
						this.setState({
							assets: void 0,
							selectedStatus: e
						});
						const t = await Object(m.c)(this.props.apiContext(), this.props.subredditId, this.props.assetType, e);
						t.ok ? this.setState({
							assets: t.body.assets || []
						}) : this.props.onGovernanceError(t.error)
					}, this.onAssetAction = async (e, t) => {
						if (e.status === t) return;
						const s = this.props.assetType,
							n = await Object(m.d)(this.props.apiContext(), this.props.subredditId, s, e.id, {
								status: t
							});
						if (n.ok) {
							const n = this.state.assets;
							this.setState({
								assets: n && n.filter(t => t !== e)
							}), t === m.a.Approved ? this.props.onApproved(s) : t === m.a.Rejected && this.props.onRejected(s)
						} else this.props.onGovernanceError(n.error)
					}
				}
				componentDidMount() {
					this.onTabChange(this.state.selectedStatus)
				}
				render() {
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(l.a, {
						className: _.a.contentContainer
					}, a.a.createElement(l.b, null, this.props.assetType === m.b.Badge ? n.fbt._("User uploaded badges", null, {
						hk: "3qGdzT"
					}) : n.fbt._("User uploaded emotes", null, {
						hk: "1GJiVz"
					})), a.a.createElement("div", {
						className: _.a.content
					}, a.a.createElement(D, {
						onTabSelected: this.onTabChange,
						value: this.state.selectedStatus
					}), a.a.createElement(R, {
						selectedStatus: this.state.selectedStatus,
						assets: this.state.assets,
						onAssetAction: this.onAssetAction
					}))))
				}
			}
			const H = Object(c.b)(Object(r.b)(void 0, (e, t) => ({
					onGovernanceError: t => Object(i.a)(e, t),
					onApproved: t => e(Object(d.e)({
						kind: u.b.SuccessCommunity,
						text: t === m.b.Badge ? n.fbt._("Approved badge!", null, {
							hk: "3B3r07"
						}) : n.fbt._("Approved emote!", null, {
							hk: "tWzSE"
						})
					})),
					onRejected: t => e(Object(d.e)({
						kind: u.b.SuccessCommunity,
						text: t === m.b.Badge ? n.fbt._("Rejected badge", null, {
							hk: "1X6cSg"
						}) : n.fbt._("Rejected emote", null, {
							hk: "3RS2kT"
						})
					}))
				}))(U)),
				W = e => a.a.createElement(H, B({
					assetType: m.b.Badge
				}, e)),
				V = e => a.a.createElement(H, B({
					assetType: m.b.Emote
				}, e))
		},
		"./src/reddit/components/ModHub/Content/NoPermissions.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./src/reddit/components/ModHub/Content/index.m.less"),
				d = s.n(i);
			t.a = e => r.a.createElement("div", {
				className: d.a.noPermissions
			}, r.a.createElement("img", {
				className: d.a.rememberTheHuman,
				src: "".concat(n.a.assetPath, "/img/content-gate-icons/remember-the-human.png")
			}), e.isModerator ? o.fbt._("Sorry, you do not have the moderator permissions needed to view this page", null, {
				hk: "4wUDIF"
			}) : o.fbt._("Sorry, this is a moderator-only page", null, {
				hk: "2BZEIA"
			}), r.a.createElement("div", {
				className: d.a.noPermissionsSmallText
			}, e.isModerator ? o.fbt._("You need to change your mod permissions to view this page", null, {
				hk: "RS9sd"
			}) : e.subredditDisplayText ? o.fbt._("You must be a moderator of {subredditName} to view this page", [o.fbt._param("subredditName", e.subredditDisplayText)], {
				hk: "8eU68"
			}) : o.fbt._("You must be a moderator to view this page", null, {
				hk: "2N7TXH"
			})))
		},
		"./src/reddit/components/ModHub/Content/WelcomeMessage.m.less": function(e, t, s) {
			e.exports = {
				ModerateIcon: "khXWcHNm7cUFKCGgNfNPy",
				moderateIcon: "khXWcHNm7cUFKCGgNfNPy",
				ModHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ",
				modHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ"
			}
		},
		"./src/reddit/components/ModHub/Content/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "CgYEK3BSwEitV3N5dS53Y",
				titleFontH2: "WtxSi4x3A6EHSYOlNO6dC",
				titleFontH3: "_1s8gRCw9ZEGeZdDLi4SjEs",
				titleFontH4: "iJgEN-DVO9xH1ING9PGia",
				titleFontH5: "_1Pk2HmstIcHsVCyXL0s7WR",
				titleFontH6: "_27G51xRMOXRk6p8hF2iFF4",
				metadataFont: "_3qFnOmsyfNVU4dOg-nT7AH",
				flairFont: "IHVtmv3d9vjFTy7sOv4nb",
				labelsFont: "_3veeqeCCuB-y_5Uz7aZwNo",
				actionFont: "_2GGs_1qJNsgRTBkJjB3JyV",
				smallButtonFont: "_1wMkSw4TKFwpURuJjoijc8",
				largeButtonFont: "_37n4mei_IKI2b0S9cUN6kj",
				tabFont: "_2uzD_ZiaRuda1gPntdeFV-",
				strongTextFont: "_3iiIycx9Jvd-wtbZRRlyrS",
				bodyFontH1: "_18F7ywSczMXfDxvUzIkKou",
				bodyFontH2: "_2gpSS7qXgM9-crN9KgQr_O",
				bodyFontH3: "-JM-6-h-SOMTCi9a5ZG0g",
				bodyFontH4: "_3ZVYgWzZxJjL_cahDG32l",
				bodyFontH5: "_15iJEJUM-il2Ud09a9yqhY",
				bodyFontH6: "_2kFIrTxjdWaprwQ9leev5x",
				bodyFont: "_38q9ZzND20FKMoX8BeB0u8",
				bodyFontSmall: "_1tFfFAHeLftmld2a2M4yIs",
				bodyFontMono: "_1N1SJCd40K_9LeW3MSWULf",
				rememberTheHuman: "_2S6IM2TPtTriI4r_2Op1Od",
				noPermissions: "_3jaCG74Q3u55JqGJy3u664",
				noPermissionsSmallText: "_1Kxv5kLQoEOhRatEhltXrQ",
				container: "_3gsyCuYXsGWEEgPSTuX9aw",
				isLargePostLayout: "_1WGjuBpIEjcQC-x3_lE_Nu"
			}
		},
		"./src/reddit/components/ModHub/Content/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/core-js/modules/es6.symbol.js"),
				o = s.n(n),
				a = s("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = s("./node_modules/react/index.js"),
				i = s.n(r),
				d = s("./src/lib/assertNever.ts"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/reddit/components/ApprovedSubmitterList/index.tsx"),
				m = s("./src/reddit/components/BannedUserList/index.tsx"),
				u = s("./src/reddit/components/CommunityAwardList/index.tsx"),
				p = s("./src/reddit/components/CommunitySettings/index.tsx"),
				b = s("./src/reddit/components/GrantUserFlair/index.tsx"),
				h = s("./src/reddit/components/ModerationLog/index.tsx"),
				g = s("./src/reddit/components/ModeratorsList/index.tsx"),
				f = s("./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx"),
				x = s("./src/reddit/components/ModHub/Emojis/index.tsx"),
				E = s("./src/reddit/components/MutedUserList/index.tsx"),
				v = s("./src/reddit/components/RemovalReasons/index.tsx"),
				C = s("./src/reddit/components/Streaming/ModSettings/index.tsx"),
				_ = s("./src/reddit/components/SubredditContent/EventPostContent/index.tsx"),
				k = s("./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx"),
				O = s("./src/reddit/components/SubredditRules/index.tsx"),
				y = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const j = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-PostRequirements",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => s.e("reddit-components-ModHub-PostRequirements").then(s.bind(null, "./src/reddit/components/ModHub/PostRequirements/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/PostRequirements/index.tsx"
					}
				}),
				w = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-ChatSettings",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => s.e("reddit-components-ModHub-ChatSettings").then(s.bind(null, "./src/reddit/components/ModHub/ChatSettings/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/ChatSettings/index.tsx"
					}
				}),
				S = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-TrafficStats",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => s.e("reddit-components-ModHub-TrafficStats").then(s.bind(null, "./src/reddit/components/ModHub/TrafficStats/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/TrafficStats/index.tsx"
					}
				}),
				I = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-PostFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), s.e("reddit-components-ModHub-flairs-PostFlairManagement")]).then(s.bind(null, "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx"
					}
				}),
				P = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-UserFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), s.e("reddit-components-ModHub-flairs-UserFlairManagement")]).then(s.bind(null, "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx"
					}
				}),
				T = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-Wiki-ModHubWikiManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("SubredditWiki~reddit-components-Wiki-ModHubWikiManagement"), s.e("reddit-components-Wiki-ModHubWikiManagement")]).then(s.bind(null, "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx"
					}
				}),
				N = Object(a.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-Content-ModQueue",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("CollectionCommentsPage~CommentsPage~Frontpage~ModListing~ModQueuePages~Multireddit~ProfileOverview~P~6ef4688e"), s.e("ModQueuePages~reddit-components-ModHub-Content-ModQueue"), s.e("reddit-components-ModHub-Content-ModQueue")]).then(s.bind(null, "./src/reddit/components/ModHub/Content/ModQueue.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/Content/ModQueue.tsx"
					}
				}),
				M = e => {
					const {
						layout: t,
						pageName: s,
						postTypeFilter: n,
						subpageName: o
					} = e, a = y(e, ["layout", "pageName", "postTypeFilter", "subpageName"]), r = Object.assign({}, a, {
						subredditId: e.subreddit.id
					});
					switch (s) {
						case l.Pb.Removal:
							return i.a.createElement(v.a, {
								subredditId: e.subreddit.id,
								sendEventWithName: e.sendEventWithName
							});
						case l.Pb.Contributors:
							return i.a.createElement(c.a, r);
						case l.Pb.Banned:
							return i.a.createElement(m.a, r);
						case l.Pb.Streaming:
							return i.a.createElement(C.a, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case l.Pb.Muted:
							return i.a.createElement(E.a, r);
						case l.Pb.Moderators:
							return i.a.createElement(g.a, r);
						case l.Pb.Modlog:
							return i.a.createElement(h.a, r);
						case l.Pb.PostRequirements:
							return i.a.createElement(j, {
								subredditName: e.subreddit.name
							});
						case l.Pb.ChatSettings:
							return i.a.createElement(w, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case l.Pb.Flair:
							return i.a.createElement(b.a, {
								after: e.after,
								before: e.before,
								subredditId: e.subreddit.id
							});
						case l.Pb.PostFlair:
							return i.a.createElement(I, {
								subredditId: e.subreddit.id
							});
						case l.Pb.UserFlair:
							return i.a.createElement(P, {
								subredditId: e.subreddit.id
							});
						case l.Pb.Badges:
							return i.a.createElement(f.a, {
								subredditId: e.subreddit.id
							});
						case l.Pb.Emotes:
							return i.a.createElement(f.b, {
								subredditId: e.subreddit.id
							});
						case l.Pb.SubredditRules:
							return i.a.createElement(O.a, {
								subreddit: e.subreddit
							});
						case l.Pb.CommunitySettings:
							return i.a.createElement(p.a, {
								subredditId: e.subreddit.id,
								subpageName: e.subpageName,
								subredditName: e.subreddit.name
							});
						case l.Pb.Modqueue:
						case l.Pb.Reports:
						case l.Pb.Spam:
						case l.Pb.Edited:
						case l.Pb.Unmoderated:
							return i.a.createElement(N, {
								after: e.after,
								layout: t,
								page: e.page,
								pageName: s,
								postTypeFilter: n,
								sendEventWithName: e.sendEventWithName,
								subredditName: e.subreddit.name
							});
						case l.Pb.Awards:
							return i.a.createElement(u.a, r);
						case l.Pb.Emojis:
							return i.a.createElement(x.a, {
								subreddit: e.subreddit
							});
						case l.Pb.Wiki:
						case l.Pb.WikiContributors:
						case l.Pb.WikiBanned:
							return i.a.createElement(T, {
								subreddit: e.subreddit
							});
						case l.Pb.Traffic:
							return i.a.createElement(S, {
								subreddit: e.subreddit
							});
						case l.Pb.SubredditContent:
							return null;
						case l.Pb.ScheduledPostContent:
							return i.a.createElement(k.a, {
								subreddit: e.subreddit
							});
						case l.Pb.EventPostContent:
							return i.a.createElement(_.a, {
								subredditName: e.subreddit.name
							});
						default:
							return Object(d.a)(s)
					}
				};
			t.a = M
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less": function(e, t, s) {
			e.exports = {
				checkbox: "_20ADRJAodM5zU1OpvNEeRz",
				checkboxText: "_21Bw38NODPHxkJ8zAXjoUZ",
				closeButton: "_3m2cog1fzR2zNYfyXI2GUB",
				emojiDisplay: "_1mMSj2QBZEQ97i-4y3-WOp",
				emojiNameDisplay: "_2lbIQVKPZ4LHDNpBLwSOps",
				imageDisplay: "_3BXziWyChS-zhQ5XC9lt4k",
				appearsIn: "_1DhToTbLLM2OC-Ze5nDwCq",
				imageTitle: "_2KrLezTGMfd18btz-KkYMi",
				modalBody: "_1PLlW-_ZV0vWQQ6LS1Z2lH",
				modalAddButton: "_1vUjBClk27uHOAYH__0rj9",
				modalCancelButton: "_23RRFTkR9NKrC22rmMDNfI",
				modFlairOnlyToggle: "_19ExxuLL5lOZW35TZFXIHf",
				modIcon: "_3ta-U9hY9R1H_BRwYv1zhl",
				modProTip: "_2yN7aUrL8peCADm-u303LV",
				modProTips: "_3WtRXJc1jCLpCEw7-mlEBU",
				proTip: "_8wjmRK1w6qEGzue3BNNOA",
				modProTipTitle: "_392GI--ZxhpUHn1eRTKzqA",
				tipList: "_3PPlagKiQrtoOsW4pcf3vc"
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less": function(e, t, s) {
			e.exports = {
				alertIcon: "_34rhMfrLYNSjUkhTK958Um",
				characterCountdown: "_15Hq3tMBKH4TWo9OJs8gny",
				clearIcon: "aCmT6tHKACP3PLk6IU6XT",
				duplicatesIcon: "Eq88P0Zb-rOoo4N5OL5uk",
				duplicateWarning: "DRp2YTik6Ln3yUKp7LBUv",
				editEmojiFooter: "_2ZoRiRDs45wlLK-ZnHzUh",
				editEmojiDisplay: "_2rDJJ0Uk_ySvUA9QNoKoKU",
				emojiDisplays: "_2FsakuX5ZR_IIPcwXQu0eD",
				errorText: "_3bRRwpzb2xfP5erPt9R6Cg",
				expandLeft: "_2byjR1IbLclRfoyvyjMDUz",
				iconSpacer: "_3tWeESqi0MQaqN5wKqkv68",
				imageDisplay: "_1MHWj3sdAGALX7r7UzFF0J",
				duplicateInput: "_280zGglckljUYhFjwaBt14",
				input: "_3xzW-TBy6RXHXBjCE9Yz7s",
				inputPlaceholder: "_1964bAdk8xBAb8-d_Mthtt",
				modalAddButton: "_2yQ10LXNPJ6antT2NgaTmI",
				modalCancelButton: "_31Qk2tb7PaP2XWWL2o4HM1",
				modProTip: "NSSpRN8n70A1TesDNcvxE",
				progressBar: "_3EbPa1JwqT9b_QgXnHzJsx",
				innerBarClassName: "_3CJpdsYAp2vfEOO_U7AaO8",
				progressText: "Wz5fdVLDZuS4d-ix-j4s9",
				replacingDescription: "_1oXr6AKswirSKypchDoX1n",
				replacingTitle: "oNyr5QxUcemiI3SFwjhvc",
				uploadingTitle: "_3ZEFRZKrLVT92hTIG7sRa9",
				textButton: "_3ZzQTZKV1t84-ND6HHwnsx",
				uploaderContainer: "OCFZ6HIQUbokDXiubxQEZ"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.m.less": function(e, t, s) {
			e.exports = {
				alertIcon: "_3x5p0Ujs6EWdeLO8-fVE7v",
				emojisDisabled: "_2H7y73ZptDGSake8tFEj0n",
				labelTitle: "_2R2K1Sz81kscliWYqOq1xU",
				labelDescription: "_1TqFvv__UfmckLHp5llo7q",
				leftForm: "_22aW9zYAhDGH2HdlJ-WWIM",
				modalBody: "_1_UK8ZmVC7e_nkeSs5CGnA",
				modalCloseButton: "_2-arZqA5i-aG-76OM9aj7k",
				modalEnableSection: "_2Wd3qBH4SU1NauwzVOQbVT",
				modalEmojiSizeSection: "_3PsrWxvZyoYyzlCO8-teTE",
				disabledSection: "nviCef6_SvGHUNBJ0PXCH",
				customSizesForm: "YV6F0NfRo0VVVRzgk8aWf",
				emojiSizeBlock: "_1W4FjSOnfJWdtKYBcNtUYO",
				emojiDimensions: "_1_bSuIYPhn5kOylTKydVsO",
				emojiDimensionInput: "e4AoJYmrnNFhWAXR_KBWX",
				sizeLimitText: "_3bUpAXL4dOTbZTUE9bJ_5s",
				sizeLimitTextWarning: "_2JlgfupPT3v8ScLuT7NYXC",
				modalFooter: "_2R2UP3vtcyZqyNdUy9Y0nX",
				modalSubmitButton: "w7T2GA8_RqtkSpD4h6YKH",
				modalCancelButton: "_2wvHObzKgyjObCvFZ0QOp0",
				rightForm: "_1eE1s4H4f1_A3ck0iF679O",
				row: "_2NQoOHp9q7uhb8h4XdVWK",
				displayWrapper: "jiCIuKa0E1BjfGfUV407r",
				emojiDisplay: "_32BxZer8uLzSVJMZqqo95_",
				emojiName: "_2hJHG1X01WKzuznOL4l6ge",
				appears: "ZVOiCMvsomJLwhS8k4VPP",
				permissions: "UxdnKubszq3iR9sJGFwiY",
				buttonWrapper: "PflXNgwgKckPGaFe9wW8V",
				editEmoji: "_3RR0-7gyjso1AHuVhVbb6u",
				editSnoomoji: "FCFv4UPC_NQjiTCEBoOCD",
				trashIcon: "_2l2KeCLkXUEz_czKdpFqSw",
				settingsButton: "_2dh14d_OrE4Etrg44_cb4t",
				toggleSwitch: "_17kocpcRdOCXJwPiOk68B-",
				topRow: "_2oevuimQpT3hztJ5Rpf_hy",
				appearsTitle: "_1Qzxm6lOFpTR3O3hzKloA9",
				imageTitle: "_1NOoO9mz09cpZjIRT9nHTh",
				nameTitle: "_1Ra9yqtrrSj9q0akrKs83v",
				permissionsTitle: "_1gNO8_Ywz6va1MbMV7-jDG",
				titleTooltip: "_279Uba_Gpg0WVLV8efIdK_"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/lodash/map.js"),
				r = s.n(a),
				i = s("./node_modules/react/index.js"),
				d = s.n(i),
				l = s("./node_modules/react-redux/es/index.js"),
				c = s("./node_modules/reselect/es/index.js"),
				m = s("./src/lib/lessComponent.tsx"),
				u = s("./src/reddit/actions/emoji.ts"),
				p = s("./src/reddit/actions/modal.ts"),
				b = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = s("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				g = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = s("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				x = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				E = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				v = s("./src/reddit/components/TrackingHelper/index.tsx"),
				C = s("./src/reddit/constants/colors.ts"),
				_ = s("./src/reddit/controls/Button/index.tsx"),
				k = s("./src/reddit/selectors/telemetry.ts");
			const O = e => ({
					subreddit: k.subreddit(e),
					profile: k.profile(e),
					userSubreddit: k.userSubreddit(e)
				}),
				y = (e, t) => s => Object.assign({
					source: "emoji",
					action: "toggle",
					noun: e,
					actionInfo: {
						settingValue: t ? "on" : "off"
					}
				}, O(s)),
				j = e => t => Object.assign({
					source: "emoji",
					action: "click",
					noun: e
				}, O(t)),
				w = (e, t) => s => Object.assign({
					source: "emoji",
					action: "click",
					noun: e,
					actionInfo: k.actionInfo(s, {
						count: t
					})
				}, O(s));
			var S = s("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				I = s("./src/reddit/selectors/activeModalId.ts"),
				P = s("./src/reddit/selectors/emojis.ts"),
				T = s("./src/reddit/components/ModHub/Emojis/index.m.less"),
				N = s.n(T),
				M = s("./src/reddit/controls/ImageDisplay/index.tsx"),
				R = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				L = s("./src/reddit/layout/row/Inline/index.tsx");
			const A = m.a.span("appears", N.a),
				F = m.a.span("buttonWrapper", N.a),
				D = m.a.span("displayWrapper", N.a),
				B = m.a.wrapped(M.a, "emojiDisplay", N.a),
				U = m.a.span("emojiName", N.a),
				H = m.a.span("permissions", N.a),
				W = m.a.wrapped(L.a, "row", N.a),
				V = m.a.wrapped(R.b, "trashIcon", N.a);
			var q = e => d.a.createElement(W, null, d.a.createElement(D, null, d.a.createElement(B, {
					backgroundImage: e.emoji.url
				})), d.a.createElement(U, null, e.emoji.name), d.a.createElement(A, null, ((e, t) => e && t ? o.fbt._("Post flair, user flair", null, {
					hk: "gLvKb"
				}) : e ? o.fbt._("Post flair", null, {
					hk: "dcIoz"
				}) : t ? o.fbt._("User flair", null, {
					hk: "4fQagx"
				}) : "")(e.emoji.postFlairAllowed, e.emoji.userFlairAllowed)), d.a.createElement(H, null, e.emoji.modFlairOnly && o.fbt._("Mod only", null, {
					hk: "NMZoE"
				})), d.a.createElement(F, null, d.a.createElement(_.n, {
					className: e.isSnoomoji ? N.a.editSnoomoji : N.a.editEmoji,
					onClick: () => e.onEdit(e.emoji, e.isSnoomoji)
				}, o.fbt._("Edit", null, {
					hk: "1nftDt"
				})), !e.isSnoomoji && d.a.createElement("button", {
					onClick: () => e.onRemove(e.emoji.name)
				}, d.a.createElement(V, null)))),
				G = s("./node_modules/lodash/clamp.js"),
				K = s.n(G),
				z = s("./src/higherOrderComponents/asModal/index.tsx"),
				Q = s("./src/lib/classNames/index.ts"),
				J = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				Z = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				X = s("./src/reddit/controls/TextButton/index.tsx"),
				Y = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				$ = s("./src/reddit/selectors/subreddit.ts"),
				ee = s("./src/reddit/controls/ToggleSwitch/index.tsx");
			const te = m.a.span("labelDescription", N.a),
				se = m.a.span("labelTitle", N.a),
				ne = m.a.div("leftForm", N.a),
				oe = m.a.div("rightForm", N.a),
				ae = m.a.wrapped(ee.a, "toggleSwitch", N.a);
			var re = e => d.a.createElement("div", {
				className: e.className
			}, d.a.createElement(ne, null, d.a.createElement(se, null, o.fbt._("{title}", [o.fbt._param("title", e.title)], {
				hk: "4bYhaP"
			})), d.a.createElement(te, null, o.fbt._("{description}", [o.fbt._param("description", e.description)], {
				hk: "1lFxbr"
			}))), d.a.createElement(oe, null, d.a.createElement(ae, {
				on: e.on,
				onToggle: e.onToggle
			})));
			const ie = 40,
				de = 16,
				le = {
					width: 32,
					height: 32
				},
				ce = e => {
					const t = parseInt(e, 10) || 0;
					return K()(t, 1, ie)
				},
				me = m.a.wrapped(Z.c, "emojiDimensionInput", N.a),
				ue = m.a.span("emojiDimensions", N.a),
				pe = m.a.span("emojiSizeBlock", N.a),
				be = m.a.wrapped(re, "modalEnableSection", N.a),
				he = m.a.wrapped(J.d, "modalBody", N.a),
				ge = m.a.wrapped(J.a, "modalCancelButton", N.a),
				fe = m.a.wrapped(X.a, "modalCloseButton", N.a),
				xe = m.a.wrapped(J.f, "modalFooter", N.a),
				Ee = m.a.wrapped(_.f, "modalSubmitButton", N.a),
				ve = Object(c.c)({
					emojisCustomSize: (e, t) => Object($.x)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize,
					isEmojisEnabled: (e, t) => Object($.x)(e, {
						subredditName: t.subreddit.name
					}).emojisEnabled
				}),
				Ce = Object(l.b)(ve, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						setCustomSize: t => e(Object(u.n)(s.id, t)),
						toggleEnableEmojis: t => e(Object(u.k)(s.id, t))
					}
				});
			class _e extends d.a.Component {
				constructor(e) {
					super(e), this.handleEmojiSizesToggle = () => this.setState({
						customSizeEnabled: !this.state.customSizeEnabled
					}), this.handleEnableEmojisToggle = () => this.setState({
						emojisEnabled: !this.state.emojisEnabled
					}), this.handleWidthChange = e => {
						const t = ce(e.target.value);
						this.setState({
							width: t
						})
					}, this.handleHeightChange = e => {
						const t = ce(e.target.value);
						this.setState({
							height: t
						})
					}, this.enableHasBeenToggled = () => this.props.isEmojisEnabled !== this.state.emojisEnabled, this.sizeHasBeenToggled = () => !!this.props.emojisCustomSize !== this.state.customSizeEnabled, this.sizeHasBeenEdited = () => !(!this.props.emojisCustomSize || !this.state.customSizeEnabled) && (this.props.emojisCustomSize[0] !== this.state.width || this.props.emojisCustomSize[1] !== this.state.height), this.canSave = () => this.enableHasBeenToggled() || this.sizeHasBeenToggled() || this.sizeHasBeenEdited(), this.onSave = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.enableHasBeenToggled() && (e.toggleEnableEmojis(t.emojisEnabled), e.sendEvent(y("enable", t.emojisEnabled))), this.sizeHasBeenToggled() || this.sizeHasBeenEdited()) {
							const s = t.customSizeEnabled ? {
								width: Math.max(t.width, de),
								height: Math.max(t.height, de)
							} : void 0;
							e.setCustomSize(s), e.sendEvent(y("custom_sizing", t.customSizeEnabled))
						}
						e.toggleModal(), e.sendEvent(j("save_emoji_settings"))
					}, this.state = {
						customSizeEnabled: !!e.emojisCustomSize,
						emojisEnabled: e.isEmojisEnabled,
						height: e.emojisCustomSize ? e.emojisCustomSize[1] : le.height,
						width: e.emojisCustomSize ? e.emojisCustomSize[0] : le.width
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = t.customSizeEnabled && (t.width < de || t.height < de), n = s ? o.fbt._("Invalid number, must be between {minSize} to {maxSize}px", [o.fbt._param("minSize", de.toString()), o.fbt._param("maxSize", ie.toString())], {
						hk: "3bkWk5"
					}) : o.fbt._("Must be between {minSize} to {maxSize}px", [o.fbt._param("minSize", de.toString()), o.fbt._param("maxSize", ie.toString())], {
						hk: "1Gp9cj"
					});
					return d.a.createElement(he, null, d.a.createElement(J.h, null, d.a.createElement(Y.a, null, d.a.createElement(J.p, null, o.fbt._("Emoji settings", null, {
						hk: "1GjUM3"
					})), d.a.createElement(fe, {
						onClick: e.toggleModal
					}, d.a.createElement(J.b, null)))), d.a.createElement(J.k, null, d.a.createElement(be, {
						description: "Allow emojis to be used in post and user flair within your community",
						on: t.emojisEnabled,
						onToggle: this.handleEnableEmojisToggle,
						title: "Enable emojis in this community"
					}), d.a.createElement(re, {
						className: t.emojisEnabled ? N.a.modalEmojiSizeSection : Object(Q.a)(N.a.modalEmojiSizeSection, N.a.disabledSection),
						description: "Enables emojis to be displayed at custom sizes for user flair in comments. Emojis will be displayed 16 x 16px everywhere else.",
						on: t.customSizeEnabled,
						onToggle: this.handleEmojiSizesToggle,
						title: "Custom sized emojis"
					}), d.a.createElement("span", {
						className: t.emojisEnabled && t.customSizeEnabled ? N.a.customSizesForm : Object(Q.a)(N.a.customSizesForm, N.a.disabledSection)
					}, d.a.createElement(pe, null, d.a.createElement(ue, null, o.fbt._("Width", null, {
						hk: "3jjMQm"
					})), d.a.createElement(me, {
						disabled: !t.customSizeEnabled || !t.emojisEnabled,
						name: "width",
						onChange: this.handleWidthChange,
						value: t.width
					})), d.a.createElement(pe, null, d.a.createElement(ue, null, o.fbt._("Height", null, {
						hk: "3nMJXk"
					})), d.a.createElement(me, {
						disabled: !t.customSizeEnabled || !t.emojisEnabled,
						name: "height",
						onChange: this.handleHeightChange,
						value: t.height
					})), d.a.createElement("div", {
						className: s ? N.a.sizeLimitTextWarning : N.a.sizeLimitText
					}, n))), d.a.createElement(xe, null, d.a.createElement(ge, {
						onClick: e.toggleModal
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(Ee, {
						disabled: !this.canSave() || s,
						onClick: this.onSave
					}, o.fbt._("Save", null, {
						hk: "45QjJC"
					}))))
				}
			}
			var ke = Object(z.a)(Ce(_e)),
				Oe = (s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/reddit/actions/toaster.ts")),
				ye = s("./src/reddit/components/StructuredStyles/ImageUpload/index.tsx"),
				je = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				we = s("./src/reddit/controls/CheckboxInput/index.tsx"),
				Se = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Ie = s("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				Pe = s("./src/reddit/models/Image/index.tsx"),
				Te = s("./src/reddit/models/Toast/index.ts"),
				Ne = s("./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less"),
				Me = s.n(Ne),
				Re = s("./src/higherOrderComponents/withImageUploads.tsx"),
				Le = s("./src/reddit/icons/svgs/Clear/index.tsx"),
				Ae = s("./src/reddit/models/Emoji/index.ts"),
				Fe = s("./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less"),
				De = s.n(Fe),
				Be = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				Ue = s("./src/reddit/components/ProgressBar/index.tsx"),
				He = s("./src/reddit/controls/ErrorText/index.tsx");
			const We = 5,
				Ve = 95,
				qe = 600,
				Ge = 100;
			class Ke extends d.a.Component {
				constructor() {
					super(...arguments), this.intervalToken = 0, this.state = {
						timeStarted: Date.now(),
						percent: We
					}, this.tick = () => {
						const e = function(e) {
							const t = e / qe,
								s = (Math.log(t / 10) + 3) / 2.1;
							return Math.max(Ve, Math.min(We, 100 * s))
						}(Date.now() - this.state.timeStarted);
						this.setState({
							percent: e
						}), e === Ve && this.intervalToken && window.clearInterval(this.intervalToken)
					}
				}
				componentDidMount() {
					this.intervalToken = window.setInterval(this.tick, Ge)
				}
				componentWillUnmount() {
					this.intervalToken && window.clearInterval(this.intervalToken)
				}
				render() {
					return d.a.createElement(Ue.a, {
						className: De.a.progressBar,
						innerBarClassName: De.a.innerBarClassName,
						percent: this.state.percent
					})
				}
			}
			var ze = Ke;
			const Qe = m.a.wrapped(Be.a, "characterCountdown", De.a),
				Je = m.a.wrapped(Le.a, "clearIcon", De.a),
				Ze = m.a.wrapped(He.b, "errorText", De.a),
				Xe = m.a.wrapped(Y.a, "expandLeft", De.a),
				Ye = m.a.div("iconSpacer", De.a),
				$e = m.a.wrapped(M.a, "imageDisplay", De.a),
				et = m.a.div("inputPlaceholder", De.a),
				tt = m.a.wrapped(Y.a, "inputPlaceholder", De.a),
				st = m.a.wrapped(X.a, "textButton", De.a);
			class nt extends d.a.Component {
				constructor() {
					super(...arguments), this.handleChangeEmojiName = e => {
						this.props.onChangeEmojiName && this.props.onChangeEmojiName(this.props.index, e.target.value)
					}, this.handleRemove = e => {
						this.props.onCancel(this.props.index)
					}, this.renderContent = () => {
						const {
							emojiName: e,
							errorText: t,
							fileName: s,
							handleRetry: n,
							imageData: a,
							isDuplicate: r
						} = this.props;
						switch (a.kind) {
							case Pe.b.NotUploaded:
							case Pe.b.Pending:
								return d.a.createElement("div", null, d.a.createElement(tt, null, a.kind === Pe.b.NotUploaded ? d.a.createElement(ze, null) : d.a.createElement(Ue.a, {
									className: De.a.progressBar,
									innerBarClassName: De.a.innerBarClassName,
									percent: 0
								}), d.a.createElement(st, {
									onClick: this.handleRemove
								}, o.fbt._("Cancel", null, {
									hk: "2TSLl5"
								}))), d.a.createElement(je.b, null, o.fbt._("Uploading {fileName}", [o.fbt._param("fileName", s)], {
									hk: "NIxvK"
								})));
							case Pe.b.FailedToUpload:
							case Pe.b.Invalid:
								return d.a.createElement("div", null, d.a.createElement(tt, null, o.fbt._("Failed to upload", null, {
									hk: "2LBRW2"
								}), n ? d.a.createElement(st, {
									onClick: n
								}, o.fbt._("Retry", null, {
									hk: "3EwbaK"
								})) : d.a.createElement(st, {
									onClick: this.handleRemove
								}, o.fbt._("Remove", null, {
									hk: "alTFO"
								}))), t && d.a.createElement(Ze, null, t));
							case Pe.b.Uploaded:
								return d.a.createElement(et, null, o.fbt._("Saved", null, {
									hk: "2xDFZZ"
								}));
							default:
								return d.a.createElement("div", null, d.a.createElement(Z.c, {
									className: r ? De.a.duplicateInput : De.a.input,
									onChange: this.handleChangeEmojiName,
									placeholder: o.fbt._("Emoji name", null, {
										hk: "UpQdA"
									}),
									value: e
								}), d.a.createElement(Xe, null, d.a.createElement(Qe, {
									maxChars: Ae.d,
									text: e
								}), d.a.createElement(st, {
									onClick: this.handleRemove
								}, o.fbt._("Remove", null, {
									hk: "4rJmk"
								}))), t && d.a.createElement(Ze, null, t))
						}
					}
				}
				render() {
					const {
						emojiName: e,
						imageData: t,
						isSaving: s
					} = this.props;
					return s ? d.a.createElement(d.a.Fragment, null, d.a.createElement(et, null, d.a.createElement(ze, null)), d.a.createElement(je.b, null, o.fbt._("Saving {emojiName}", [o.fbt._param("emojiName", e)], {
						hk: "3lMST7"
					}))) : d.a.createElement(Ie.a, null, t.kind === Pe.b.FailedToUpload || t.kind === Pe.b.Invalid ? d.a.createElement(Ye, null, d.a.createElement(Je, null)) : d.a.createElement($e, {
						backgroundImage: t.url
					}), this.renderContent())
				}
			}
			var ot = nt,
				at = (s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/lodash/countBy.js")),
				rt = s.n(at),
				it = s("./node_modules/lodash/filter.js"),
				dt = s.n(it),
				lt = s("./node_modules/lodash/includes.js"),
				ct = s.n(lt),
				mt = s("./node_modules/lodash/transform.js"),
				ut = s.n(mt);
			const pt = /^[A-Za-z0-9_-]{1,24}$/,
				bt = ["reddit", "snoo", "spez"],
				ht = (e, t, s) => !pt.test(e) || !s && (e => {
					const t = e.toLowerCase();
					return bt.reduce((e, s) => e || -1 !== t.indexOf(s), !1)
				})(e) ? o.fbt._("Invalid emoji name", null, {
					hk: "2Oromm"
				}) : ct()(t, e) ? o.fbt._("This name is already taken", null, {
					hk: "4dwdJL"
				}) : "",
				gt = e => e.name ? e.name.replace(/\.[^.]*$/, "").replace(/[^A-Za-z0-9_-]/g, " ").trim().replace(/ +/g, "_").slice(0, 24) : "",
				ft = (e, t) => (t.kind !== Pe.b.TempUploaded || !e.emojiNameError && !e.isNameMissing) && (t.kind !== Pe.b.NotUploaded && t.kind !== Pe.b.Pending),
				xt = e => {
					let t = "";
					return e.file.size > Ae.a ? t = "file-size-error" : (e.height > Ae.b || e.width > Ae.c) && (t = "image-size-error"), {
						emojiNameError: "",
						imageError: t,
						name: gt(e.file),
						fileName: e.file.name,
						isNameMissing: !1
					}
				},
				Et = (e, t) => t.reduce((t, s) => s.kind === e ? t + 1 : t, 0),
				vt = (e, t) => {
					const {
						emojiNameError: s,
						imageError: n,
						isNameMissing: a
					} = t;
					let r = "";
					e.kind === Pe.b.FailedToUpload && (r = e.error.fields && e.error.fields.length ? e.error.fields[0].msg : o.fbt._("Something went wrong", null, {
						hk: "2fCWXR"
					}));
					const i = r || !1,
						d = s || !!a && o.fbt._("Emoji name is required", null, {
							hk: "4sL3l7"
						});
					let l = "";
					return "file-size-error" === n ? l = o.fbt._("File size too large", null, {
						hk: "EksGU"
					}) : "image-size-error" === n && (l = o.fbt._("Image size too large", null, {
						hk: "1xjOmq"
					})), l || i || d || ""
				},
				Ct = e => {
					const t = dt()(e, e => !e.emojiNameError && !e.imageError),
						s = rt()(t, e => e.name);
					return ut()(s, (e, t, s) => {
						t > 1 && e.push(s)
					}, [])
				},
				_t = 500,
				kt = m.a.div("UploaderContainer", De.a),
				Ot = m.a.wrapped(S.a, "alertIcon", De.a),
				yt = m.a.wrapped(Le.a, "duplicatesIcon", De.a),
				jt = m.a.wrapped(J.o, "duplicateWarning", De.a),
				wt = m.a.wrapped(_.f, "modalAddButton", De.a),
				St = m.a.wrapped(J.a, "modalCancelButton", De.a),
				It = m.a.div("uploaderContainer", De.a),
				Pt = m.a.wrapped(J.o, "modProTip", De.a),
				Tt = m.a.div("progressText", De.a),
				Nt = m.a.wrapped(J.o, "replacingDescription", De.a),
				Mt = m.a.div("replacingTitle", De.a),
				Rt = m.a.div("uploadingTitle", De.a),
				Lt = Object(c.c)({
					emojis: P.d,
					isSnoomojiSubreddit: $.n,
					reservedEmojiNames: P.e
				}),
				At = Object(l.b)(Lt, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						emojisUploadedToast: () => e(Oe.e({
							kind: Te.b.SuccessCommunityGreen,
							text: o.fbt._("New emojis added!", null, {
								hk: "1Q1mEq"
							})
						})),
						saveEmoji: (t, n, o) => e(Object(u.p)({
							imageData: t,
							subredditId: s,
							emojiName: n,
							settings: o
						}))
					}
				});
			class Ft extends d.a.Component {
				constructor(e) {
					super(e), this.timeoutToken = 0, this.loadIndex = 0, this.tempUploadNext = async () => {
						const e = this.getNextPendingImageToLoad();
						if (!e) return this.timeoutToken = 0, void(this.loadIndex = 0);
						const {
							subredditId: t
						} = this.props, s = this.state.emojiData[e.id], n = Object(Pe.m)(e);
						await this.props.uploadImage({
							imageData: n,
							subredditId: t,
							emojiName: s.name,
							settings: this.props.emojiSettings
						}), this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(this.tempUploadNext, _t) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.emojiIsADuplicate = (e, t) => e && t && t.some(t => t.id === e.id), this.saveNext = e => {
						const t = this.getNextTempUploadedImageToSave();
						if (!t) return this.timeoutToken = 0, void(this.loadIndex = 0);
						if (!this.emojiIsADuplicate(t, e)) {
							const e = this.state.emojiData[t.id],
								s = this.props.saveEmoji(t, e.name, this.props.emojiSettings);
							this.setState({
								emojisUploaded: this.state.emojisUploaded || s
							})
						}
						this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(() => this.saveNext(e), _t) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.onChangeEmojiName = (e, t) => {
						const {
							isSnoomojiSubreddit: s,
							reservedEmojiNames: n
						} = this.props;
						if (t.length > Ae.d) return;
						const o = this.state.isReplacing ? this.state.replacingEmoji && this.state.replacingEmoji[e] : this.state.localData[e];
						if (!o) return;
						const a = this.state.emojiData,
							r = a[o.id],
							i = t ? ht(t, n, s) : "";
						a[o.id].emojiNameError = i, a[o.id].name = t;
						const d = Ct(a);
						this.setState({
							duplicateNames: d,
							emojiData: Object.assign({}, this.state.emojiData, {
								[o.id]: Object.assign({}, r, {
									emojiNameError: i,
									isNameMissing: !t,
									name: t
								})
							})
						})
					}, this.canSave = () => {
						let e = !1;
						for (const t of this.state.localData) {
							if (!ft(this.state.emojiData[t.id], t)) return !1;
							t.kind === Pe.b.TempUploaded && (e = !0)
						}
						return e
					}, this.getValidatedState = () => {
						const {
							isSnoomojiSubreddit: e,
							reservedEmojiNames: t
						} = this.props, s = {};
						for (const n of this.state.localData) {
							let o = this.state.emojiData[n.id];
							const a = ht(o.name, t, e);
							o.name && !a || (o = Object.assign({}, o, {
								emojiNameError: a,
								isNameMissing: !o.name
							})), s[n.id] = o
						}
						return {
							emojiData: s
						}
					}, this.onApply = () => {
						const e = this.getValidatedState();
						this.setState(e, () => {
							if (this.canSave()) {
								const e = this.props.emojis[this.props.subredditId].emojis,
									t = [];
								for (const n of this.state.localData) {
									if (n.kind !== Pe.b.TempUploaded) continue;
									this.state.emojiData[n.id].name in e && t.push(n)
								}
								t.length ? (this.setState({
									replacingEmoji: t,
									isReplacing: !0
								}), this.saveNext(t)) : (this.setState({
									isSavingImage: !0
								}), this.props.setIsSaving(!0), this.saveNext());
								const s = Et(Pe.b.TempUploaded, this.state.localData) - t.length;
								s > 0 && (this.props.sendEvent(w("add", s)), this.sendSettingsEvent())
							}
						})
					}, this.sendSettingsEvent = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: s
						} = this.props.emojiSettings;
						this.props.sendEvent(y("mods_only", e)), this.props.sendEvent(y("appear_user_flair", t)), this.props.sendEvent(y("appear_post_flair", s))
					}, this.handleSaveAndReplace = () => {
						this.setState({
							isReplacing: !1,
							isSavingImage: !0
						}), this.props.setIsSaving(!0);
						const {
							replacingEmoji: e
						} = this.state, t = e ? e.length : 0;
						this.saveNext(), t > 0 && (this.props.sendEvent(w("replace", t)), this.sendSettingsEvent())
					}, this.handleCancelReplace = () => {
						this.setState({
							isReplacing: !1,
							replacingEmoji: null
						}), this.props.stopEditing(), this.props.sendEvent(j("dont_replace"))
					}, this.findEmojiIndexById = e => this.state.localData.findIndex(t => t.id === e), this.removeEmoji = e => {
						const {
							isReplacing: t,
							localData: s,
							replacingEmoji: n
						} = this.state;
						let o, a = e;
						t && n && n[e] && (a = this.findEmojiIndexById(n[e].id), (o = n.slice(0)).splice(e, 1), this.setState({
							replacingEmoji: o
						}));
						const r = s[a],
							i = s.slice(0);
						i.splice(a, 1);
						const d = Object.assign({}, this.state.emojiData);
						delete d[r.id], this.setState({
							duplicateNames: Ct(d),
							emojiData: d,
							localData: i
						}), t && n ? 0 === o.length && this.props.returnToAddState() : 0 === i.length && this.props.returnToAddState()
					}, this.retryEmojiUpload = () => {
						this.props.returnToAddState()
					};
					const t = {},
						s = [];
					for (const n of e.images) {
						const e = xt(n);
						t[n.id] = e, e.imageError ? s.push(Object(Pe.l)(n, e.imageError)) : s.push(n)
					}
					this.state = {
						duplicateNames: Ct(t),
						emojiData: t,
						emojisUploaded: !1,
						isReplacing: !1,
						isSavingImage: !1,
						localData: s,
						replacingEmoji: null
					}
				}
				componentWillMount() {
					this.loadIndex = 0, this.tempUploadNext()
				}
				getNextPendingImageToLoad() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const s = this.state.localData[e];
						if (s.kind === Pe.b.Pending) {
							t = s;
							break
						}
					}
					return this.loadIndex = e, t
				}
				getNextTempUploadedImageToSave() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const s = this.state.localData[e];
						if (s.kind === Pe.b.TempUploaded) {
							t = s;
							break
						}
					}
					return this.loadIndex = e, t
				}
				componentWillReceiveProps(e) {
					const t = e.getImageUploadsIfModified(this.state.localData);
					if (!t) return;
					let s = !1;
					const {
						isSavingImage: n
					} = this.state, o = {};
					for (const a of t) o[a.id] = this.state.emojiData[a.id], s = s || a.kind === Pe.b.TempUploaded;
					!n || s ? (this.props.setIsSaving(n), this.setState({
						emojiData: o,
						isSavingImage: n,
						localData: t
					})) : this.props.stopEditing()
				}
				componentWillUnmount() {
					for (const e of this.state.localData) this.props.cancelUpload(e);
					this.timeoutToken && window.clearTimeout(this.timeoutToken), this.state.emojisUploaded && this.props.emojisUploadedToast(), this.setState({
						emojisUploaded: !1,
						isReplacing: !1
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = t.isReplacing ? t.replacingEmoji || [] : t.localData;
					return d.a.createElement(kt, null, d.a.createElement(It, null, t.duplicateNames.length > 0 ? d.a.createElement(jt, null, d.a.createElement(yt, null), o.fbt._("Duplicate names", null, {
						hk: "4kkNr1"
					})) : !t.isReplacing && d.a.createElement(Pt, null, d.a.createElement(Ot, null), o.fbt._("Names cannot be edited once added", null, {
						hk: "3f45r5"
					})), d.a.createElement(J.k, null, t.isReplacing ? d.a.createElement(d.a.Fragment, null, d.a.createElement(Mt, null, o.fbt._("Replacing emojis", null, {
						hk: "4cKike"
					})), d.a.createElement(Nt, null, o.fbt._("These emoji names already exist in your community. Replacing these emojis will not change pre-existing permissions. Do you want to replace them?", null, {
						hk: "3iPBUU"
					}))) : d.a.createElement(Rt, null, o.fbt._("Uploading emojis", null, {
						hk: "7keSV"
					})), d.a.createElement("div", {
						className: !t.isReplacing && De.a.emojiDisplays
					}, s.map((e, s) => {
						const n = this.state.emojiData[e.id],
							o = e.kind === Pe.b.FailedToUpload || e.kind === Pe.b.Invalid,
							a = t.replacingEmoji && !t.replacingEmoji.find(t => t.id === e.id);
						if (t.isSavingImage && (o || a)) return;
						const r = vt(e, n);
						return d.a.createElement(je.a, {
							key: e.id
						}, d.a.createElement(ot, {
							emojiName: n.name,
							errorText: r,
							fileName: n.fileName,
							imageData: e,
							index: s,
							isDuplicate: t.duplicateNames.includes(n.name),
							isSaving: t.isSavingImage,
							onCancel: this.removeEmoji,
							onChangeEmojiName: this.onChangeEmojiName
						}))
					})), !t.isReplacing && d.a.createElement(Tt, null, t.isSavingImage ? o.fbt._("{savedCount} out of {savedTotal} saved", [o.fbt._param("savedCount", Et(Pe.b.Uploaded, t.localData).toString()), o.fbt._param("savedTotal", t.localData.length.toString())], {
						hk: "3v1E9N"
					}) : o.fbt._("{uploadedCount} out of {uploadedTotal} uploaded", [o.fbt._param("uploadedCount", Et(Pe.b.TempUploaded, t.localData).toString()), o.fbt._param("uploadedTotal", t.localData.length.toString())], {
						hk: "41qbSa"
					})))), d.a.createElement(J.f, null, d.a.createElement(St, {
						disabled: t.isSavingImage,
						onClick: t.isReplacing ? this.handleCancelReplace : e.stopEditing
					}, t.isReplacing ? o.fbt._("Don't replace", null, {
						hk: "4d8hwM"
					}) : o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(wt, {
						disabled: t.isSavingImage || !this.canSave() || t.duplicateNames.length > 0,
						onClick: t.isReplacing ? this.handleSaveAndReplace : this.onApply
					}, t.isReplacing ? o.fbt._("Replace", null, {
						hk: "45noqB"
					}) : o.fbt._("Add", null, {
						hk: "2wi3d4"
					}))))
				}
			}
			var Dt = Object(Re.a)(At(Ft), u.q),
				Bt = s("./src/reddit/actions/imageUploads.ts"),
				Ut = s("./src/reddit/selectors/imageUploads.ts");
			const Ht = m.a.div("UploaderContainer", De.a),
				Wt = m.a.wrapped(Ht, "editEmojiDisplay", De.a),
				Vt = Object(c.c)({
					reduxImage: (e, t) => {
						let {
							pendingImage: s
						} = t;
						const n = Object(Ut.b)(e),
							o = s && s.id;
						return o && n[o] || void 0
					}
				});
			class qt extends d.a.Component {
				constructor(e) {
					super(e), this.onCancelAndRetry = () => {
						this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage), this.props.onRetryUpload()
					}
				}
				componentDidMount() {
					const e = Object(Pe.m)(this.props.pendingImage);
					this.props.uploadImage({
						imageData: e,
						subredditId: this.props.subredditId,
						emojiName: this.props.emoji.name,
						settings: this.props.emojiSettings
					})
				}
				componentDidUpdate(e) {
					this.props.reduxImage && this.props.reduxImage !== e.reduxImage && this.props.onImageChange(this.props.reduxImage)
				}
				componentWillUnmount() {
					this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage)
				}
				render() {
					const {
						pendingImage: e,
						reduxImage: t,
						emoji: s
					} = this.props, n = xt(e), o = Object(Pe.l)(e, n.imageError), a = n.imageError ? o : t || e, r = vt(a, n);
					return !r && a.kind === Pe.b.TempUploaded || a.kind === Pe.b.Uploaded ? null : d.a.createElement(Wt, null, d.a.createElement(ot, {
						emojiName: s.name,
						errorText: r,
						fileName: n.fileName,
						handleRetry: this.onCancelAndRetry,
						imageData: a,
						index: 0,
						isSaving: !1,
						onCancel: this.onCancelAndRetry
					}))
				}
			}
			var Gt = Object(l.b)(Vt, e => ({
				uploadImage: t => e(Object(u.q)(t)),
				cancelUpload: t => e(Object(Bt.h)(t))
			}))(qt);

			function Kt() {
				return (Kt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const zt = 32,
				Qt = 128,
				Jt = 64,
				Zt = 100,
				Xt = m.a.div("appearsIn", Me.a),
				Yt = m.a.wrapped(we.a, "checkbox", Me.a),
				$t = m.a.span("checkboxText", Me.a),
				es = m.a.wrapped(X.a, "closeButton", Me.a),
				ts = m.a.div("imageTitle", Me.a),
				ss = m.a.wrapped(_.f, "modalAddButton", Me.a),
				ns = m.a.wrapped(J.d, "modalBody", Me.a),
				os = m.a.wrapped(J.a, "modalCancelButton", Me.a),
				as = m.a.wrapped(J.k, "modalMain", Me.a),
				rs = m.a.wrapped(re, "modFlairOnlyToggle", Me.a),
				is = m.a.wrapped(Se.a, "modIcon", Me.a),
				ds = m.a.li("modProTip", Me.a),
				ls = m.a.div("modProTips", Me.a),
				cs = m.a.div("modProTipTitle", Me.a),
				ms = m.a.div("proTip", Me.a),
				us = m.a.ul("tipList", Me.a),
				ps = e => !!e && (e.kind === Pe.b.Pending ? !!xt(e).imageError : e.kind === Pe.b.FailedToUpload);
			var bs;
			! function(e) {
				e[e.AddState = 0] = "AddState", e[e.SingleEmojiEditState = 1] = "SingleEmojiEditState", e[e.BulkUploadState = 2] = "BulkUploadState"
			}(bs || (bs = {}));
			const hs = m.a.wrapped(Ie.a, "emojiDisplay", Me.a),
				gs = m.a.div("emojiNameDisplay", Me.a),
				fs = m.a.wrapped(M.a, "imageDisplay", Me.a),
				xs = e => d.a.createElement(hs, null, d.a.createElement(fs, {
					backgroundImage: e.url
				}), d.a.createElement(gs, null, e.emojiName)),
				Es = Object(c.c)({
					emojisCustomSize: (e, t) => Object($.x)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize
				}),
				vs = Object(l.b)(Es, (e, t) => {
					let {
						emoji: s,
						isSnoomoji: n,
						subreddit: a
					} = t;
					return {
						saveEmoji: (t, s, n) => e(u.p({
							imageData: n,
							subredditId: a.id,
							emojiName: t,
							settings: s
						})),
						saveEmojiSettings: t => {
							s && e(u.o(s.name, n, t, a.id))
						},
						saveEmojiSuccessToast: () => e(Oe.e({
							kind: Te.b.SuccessCommunityGreen,
							text: o.fbt._("Emoji edits saved!", null, {
								hk: "3luBMA"
							})
						}))
					}
				});
			class Cs extends d.a.Component {
				constructor(e) {
					super(e), this.closeModal = () => {
						this.props.toggleModal()
					}, this.clearImageData = () => {
						this.setState({
							imageData: [],
							emojiDraftImage: void 0
						})
					}, this.onEditingImageChange = e => {
						this.setState({
							emojiDraftImage: e
						})
					}, this.handleMultiImageInput = async e => {
						let t;
						const s = this.state.emojiState === bs.SingleEmojiEditState;
						s && this.clearImageData(), t = Array.isArray(e) ? s ? e.slice(0, 1) : e.slice(0, Zt) : [e];
						const n = await Promise.all(t.map(Pe.f));
						s ? this.setState({
							imageData: n
						}) : this.setState({
							emojiState: bs.BulkUploadState,
							imageData: n
						})
					}, this.handleModExclusiveToggle = () => this.setState({
						settings: Object.assign({}, this.state.settings, {
							modFlairOnly: !this.state.settings.modFlairOnly
						})
					}), this.handleTogglePostFlair = () => this.setState({
						settings: Object.assign({}, this.state.settings, {
							postFlairAllowed: !this.state.settings.postFlairAllowed
						})
					}), this.handleToggleUserFlair = () => this.setState({
						settings: Object.assign({}, this.state.settings, {
							userFlairAllowed: !this.state.settings.userFlairAllowed
						})
					}), this.returnToAdd = () => {
						this.setState({
							emojiState: bs.AddState
						}), this.clearImageData()
					}, this.sendToggleEvent = (e, t) => this.props.sendEvent(y(e, t)), this.modFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.modFlairOnly !== this.state.settings.modFlairOnly, this.userFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.userFlairAllowed !== this.state.settings.userFlairAllowed, this.postFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.postFlairAllowed !== this.state.settings.postFlairAllowed, this.settingsHaveBeenChanged = () => this.modFlairSettingHasChanged() || this.userFlairSettingHasChanged() || this.postFlairSettingHasChanged(), this.sendTelemetryEvents = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: s
						} = this.state.settings;
						this.modFlairSettingHasChanged() && this.sendToggleEvent("mods_only", e), this.userFlairSettingHasChanged() && this.sendToggleEvent("appear_user_flair", t), this.postFlairSettingHasChanged() && this.sendToggleEvent("appear_post_flair", s)
					}, this.saveEmoji = async () => {
						const {
							props: e,
							state: t
						} = this, s = {
							modFlairOnly: t.settings.modFlairOnly,
							postFlairAllowed: t.settings.postFlairAllowed,
							userFlairAllowed: t.settings.userFlairAllowed
						};
						if (this.setIsSaving(!0), e.emoji) {
							if (e.isSnoomoji || e.emoji && !t.emojiDraftImage) e.saveEmojiSettings(s);
							else if (e.emoji && t.emojiDraftImage && t.emojiDraftImage.kind === Pe.b.TempUploaded) {
								await e.saveEmoji(e.emoji.name, s, t.emojiDraftImage) && e.saveEmojiSuccessToast()
							}
							this.sendTelemetryEvents()
						}
						this.closeModal(), this.setIsSaving(!1)
					}, this.setIsSaving = e => this.setState({
						isSaving: e
					}), this.state = {
						emojiState: e.emoji ? bs.SingleEmojiEditState : bs.AddState,
						imageData: [],
						isSaving: !1,
						settings: {
							modFlairOnly: !!e.emoji && e.emoji.modFlairOnly,
							postFlairAllowed: !e.emoji || e.emoji.postFlairAllowed,
							userFlairAllowed: !e.emoji || e.emoji.userFlairAllowed
						}
					}
				}
				render() {
					const {
						emoji: e,
						emojisCustomSize: t,
						isSnoomoji: s,
						sendEvent: n,
						subreddit: a
					} = this.props, {
						emojiDraftImage: r,
						emojiState: i,
						imageData: l,
						isSaving: c,
						settings: m
					} = this.state, u = {
						emojiSettings: m,
						stopEditing: this.closeModal,
						subredditId: a.id
					}, p = 2 * (t ? t[0] : zt), b = 2 * (t ? t[1] : zt), h = l.length > 0 ? l[0] : void 0, g = h && h.url, f = r && r.url, x = g || f, E = r && r.kind === Pe.b.TempUploaded, v = ps(h || r), C = i !== bs.SingleEmojiEditState || (!this.settingsHaveBeenChanged() && !E || v);
					return d.a.createElement(ns, null, d.a.createElement(J.h, null, d.a.createElement(Y.a, null, d.a.createElement(J.p, null, e ? o.fbt._("Edit emoji", null, {
						hk: "4awCz5"
					}) : o.fbt._("Add new emojis", null, {
						hk: "2DrJ62"
					})), d.a.createElement(es, {
						disabled: c,
						onClick: this.closeModal
					}, d.a.createElement(J.b, null)))), (i === bs.AddState || i === bs.SingleEmojiEditState) && d.a.createElement(d.a.Fragment, null, i === bs.AddState && d.a.createElement(ls, null, d.a.createElement(cs, null, d.a.createElement(is, null), o.fbt._("Mod pro tips!", null, {
						hk: "30l9bq"
					})), d.a.createElement(us, null, d.a.createElement(ds, null, o.fbt._("Emoji names will use the image file name and will be editable once uploaded", null, {
						hk: "2fvAIQ"
					})), d.a.createElement(ds, null, o.fbt._("You can upload up to {maxUpload} emojis at once", [o.fbt._param("maxUpload", Zt.toString())], {
						hk: "4aMYoX"
					})))), d.a.createElement(as, null, i === bs.SingleEmojiEditState && e && d.a.createElement(xs, {
						emojiName: e.name,
						url: x || e.url
					}), !s && d.a.createElement(d.a.Fragment, null, d.a.createElement(je.i, null, d.a.createElement(ts, null, e ? o.fbt._("Image", null, {
						hk: "3fzI70"
					}) : o.fbt._("Images", null, {
						hk: "3SapUk"
					})), e && i === bs.SingleEmojiEditState && h && d.a.createElement(Gt, Kt({}, u, {
						emoji: e,
						onRetryUpload: this.clearImageData,
						pendingImage: h,
						onImageChange: this.onEditingImageChange
					})), (!l.length || E) && !(e && v) && d.a.createElement(ye.b, {
						label: o.fbt._("Drag and Drop or Upload Image", null, {
							hk: "3y5WvP"
						}),
						onChange: this.handleMultiImageInput,
						multiple: !0
					}), d.a.createElement(je.b, null, o.fbt._("Max upload dimensions {maxEmojiWidth} x {maxEmojiHeight}px", [o.fbt._param("maxEmojiWidth", Qt.toString()), o.fbt._param("maxEmojiHeight", Qt.toString())], {
						hk: "yal28"
					})), d.a.createElement(je.b, null, o.fbt._("Max file size {MAX_FILE_SIZE}KB", [o.fbt._param("MAX_FILE_SIZE", Jt.toString())], {
						hk: "1t1L0f"
					}))), d.a.createElement(ms, null, o.fbt._("Recommended upload dimensions: {recommendedWidth} x {recommendedHeight}px", [o.fbt._param("recommendedWidth", p.toString()), o.fbt._param("recommendedHeight", b.toString())], {
						hk: "35CqDV"
					}))), d.a.createElement(Xt, null, o.fbt._("Appears in:", null, {
						hk: "3SZP5W"
					})), d.a.createElement(Yt, {
						name: "postFlair",
						onChange: this.handleTogglePostFlair,
						value: m.postFlairAllowed
					}, d.a.createElement($t, null, o.fbt._("Post flair", null, {
						hk: "mAzeZ"
					}))), d.a.createElement(Yt, {
						name: "userFlair",
						onChange: this.handleToggleUserFlair,
						value: m.userFlairAllowed
					}, d.a.createElement($t, null, o.fbt._("User flair", null, {
						hk: "qVf7x"
					}))), d.a.createElement(rs, {
						description: "Only appears in post and user flair that are restricted for mod use.",
						on: m.modFlairOnly,
						onToggle: this.handleModExclusiveToggle,
						title: "Mod only"
					})), d.a.createElement(J.f, null, d.a.createElement(os, {
						disabled: c,
						onClick: this.closeModal
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(ss, {
						disabled: C,
						onClick: this.saveEmoji
					}, e ? o.fbt._("Save", null, {
						hk: "1M9aqH"
					}) : o.fbt._("Add", null, {
						hk: "2wi3d4"
					})))), i === bs.BulkUploadState && d.a.createElement(Dt, Kt({}, u, {
						images: l,
						returnToAddState: this.returnToAdd,
						sendEvent: n,
						setIsSaving: this.setIsSaving
					})))
				}
			}
			var _s = Object(z.a)(vs(Cs));
			const ks = m.a.wrapped(S.a, "alertIcon", N.a),
				Os = m.a.span("appearsTitle", N.a),
				ys = m.a.span("imageTitle", N.a),
				js = m.a.span("nameTitle", N.a),
				ws = m.a.span("permissionsTitle", N.a),
				Ss = m.a.wrapped(_.i, "settingsButton", N.a),
				Is = m.a.wrapped(f.a, "titleTooltip", N.a),
				Ps = m.a.wrapped(E.a, "topRow", N.a),
				Ts = Object(c.c)({
					emojis: P.d,
					isConfirmModalOpen: Object(I.b)("EmojiManager--DeleteEmojiConfirmation--Modal"),
					isEmojisEnabled: (e, t) => Object(P.b)(e, t.subreddit.name),
					isEmojiSettingsModalOpen: Object(I.b)("EmojiManager--Settings--Modal"),
					isUploadEmojisModalOpen: Object(I.b)("EmojiManager--UploadEmojis--Modal")
				}),
				Ns = Object(l.b)(Ts, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						deleteEmoji: t => e(u.j(t, s.id)),
						toggleDeleteConfirmationModal: () => e(Object(p.i)("EmojiManager--DeleteEmojiConfirmation--Modal")),
						toggleSettingsModal: () => e(Object(p.i)("EmojiManager--Settings--Modal")),
						toggleUploadEmojisModal: () => e(Object(p.i)("EmojiManager--UploadEmojis--Modal"))
					}
				});
			class Ms extends d.a.Component {
				constructor(e) {
					super(e), this.onClickEditEmoji = (e, t) => {
						this.props.toggleUploadEmojisModal(), this.setState({
							emojiToEdit: e,
							isSnoomoji: t
						})
					}, this.onConfirmDelete = () => {
						this.props.deleteEmoji(this.state.emojiNameToDelete), this.setState({
							emojiNameToDelete: ""
						}), this.props.sendEvent(j("delete"))
					}, this.handleRemoveEmoji = e => {
						this.setState({
							emojiNameToDelete: e
						}), this.props.toggleDeleteConfirmationModal()
					}, this.state = {
						emojiNameToDelete: "",
						emojiToEdit: null,
						isSnoomoji: !1
					}
				}
				static getDerivedStateFromProps(e, t) {
					return t.emojiToEdit && !e.isUploadEmojisModalOpen ? {
						emojiToEdit: null,
						isSnoomoji: !1
					} : null
				}
				render() {
					const {
						emojis: e,
						isConfirmModalOpen: t,
						isEmojisEnabled: s,
						isEmojiSettingsModalOpen: a,
						isUploadEmojisModalOpen: i,
						sendEvent: l,
						subreddit: c,
						toggleDeleteConfirmationModal: m,
						toggleSettingsModal: u,
						toggleUploadEmojisModal: p
					} = this.props;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(x.c, null, d.a.createElement(Ss, {
						onClick: u
					}, o.fbt._("Emoji settings", null, {
						hk: "2k202A"
					})), d.a.createElement(_.f, {
						onClick: p
					}, o.fbt._("Add emoji", null, {
						hk: "DTe8a"
					}))), d.a.createElement(x.a, null, d.a.createElement(x.b, null, o.fbt._("Emoji management", null, {
						hk: "6xN5s"
					}), d.a.createElement(g.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360010560371")
					})), !s && d.a.createElement(h.a, {
						className: N.a.emojisDisabled,
						color: C.a.quarantine,
						icon: d.a.createElement(ks, null),
						subtitle: o.fbt._("Emojis in flairs will not be displayed, and existing emojis will appear as plain text.", null, {
							hk: "2WaMtH"
						}),
						title: o.fbt._("Emojis have been disabled for this community", null, {
							hk: "7LNIO"
						})
					}), d.a.createElement(Ps, null, d.a.createElement(ys, null, o.fbt._("Image", null, {
						hk: "1rlqjH"
					})), d.a.createElement(js, null, o.fbt._("Name", null, {
						hk: "1ugGFI"
					})), d.a.createElement(Os, null, o.fbt._("Appears in", null, {
						hk: "3K8vjU"
					}), d.a.createElement(Is, {
						text: o.fbt._("Set emoji to appear in post flair or user flair", null, {
							hk: "4cg4Se"
						})
					})), d.a.createElement(ws, null, o.fbt._("Settings", null, {
						hk: "2CRrAq"
					}), d.a.createElement(Is, {
						text: o.fbt._("Set emoji to only appear in mod-only flair", null, {
							hk: "2yS10f"
						})
					}))), e[c.id] && r()(e[c.id].emojis, e => d.a.createElement(q, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !1,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), e[c.id] && r()(e[c.id].snoomojis, e => d.a.createElement(q, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !0,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), t && d.a.createElement(b.a, {
						toggleModal: m,
						onConfirm: this.onConfirmDelete,
						actionText: o.fbt._("Delete", null, {
							hk: "332ZH4"
						}),
						headerText: o.fbt._("Delete emoji?", null, {
							hk: "3VBsS8"
						}),
						modalText: o.fbt._("Do you wish to delete this emoji?", null, {
							hk: "2sPCxc"
						}),
						trackClick: () => {},
						withOverlay: !0
					}), a && d.a.createElement(ke, {
						sendEvent: l,
						subreddit: c,
						toggleModal: u,
						withOverlay: !0
					}), i && d.a.createElement(_s, {
						emoji: this.state.emojiToEdit,
						isSnoomoji: this.state.isSnoomoji,
						sendEvent: l,
						subreddit: c,
						toggleModal: p,
						withOverlay: !0
					})))
				}
			}
			t.a = Ns(Object(v.c)(Ms))
		},
		"./src/reddit/components/ModHub/InfoLink/index.m.less": function(e, t, s) {
			e.exports = {
				linkContainer: "_3-yXs2bljbMxTPT6hDZU1I",
				infoIcon: "_2Eloqzd6Vfz9eGsjyzVfsf"
			}
		},
		"./src/reddit/components/ModHub/InfoLink/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/higherOrderComponents/asTooltip.tsx"),
				i = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = s("./src/reddit/icons/fonts/Info/index.tsx"),
				l = s("./src/reddit/components/ModHub/InfoLink/index.m.less"),
				c = s.n(l);
			const m = Object(r.a)(i.b),
				u = ["center", "top"],
				p = ["center", "bottom"];
			class b extends a.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					return a.a.createElement("a", {
						className: c.a.linkContainer,
						href: this.props.linkUrl,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef,
						target: "_blank",
						rel: "noopener noreferrer"
					}, a.a.createElement(d.a, {
						className: c.a.infoIcon
					}), a.a.createElement(m, {
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: u,
						text: n.fbt._("Learn more", null, {
							hk: "3zoGtq"
						}),
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.m.less": function(e, t, s) {
			e.exports = {
				iconContainer: "_39qwCVfS_zadCI7gaPX3MI",
				textTooltip: "_1yEjLpHWBPakuE9kTnIp_w"
			}
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/higherOrderComponents/asTooltip.tsx"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = s("./src/reddit/icons/fonts/Info/index.tsx"),
				l = s("./src/reddit/components/ModHub/InfoTooltip/index.m.less"),
				c = s.n(l);
			const m = Object(a.a)(i.a),
				u = ["center", "bottom"],
				p = ["center", "top"];
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						props: e
					} = this;
					return o.a.createElement("span", {
						className: c.a.iconContainer,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef
					}, o.a.createElement(d.a, null), o.a.createElement(m, {
						className: Object(r.a)(e.className, c.a.textTooltip),
						children: e.children,
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: u,
						text: e.text,
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/ModHubNav/NavItem.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/controls/InternalLink/index.tsx"),
				d = s("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				l = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				c = s("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				m = s.n(c);
			const u = () => a.a.createElement("div", {
				className: m.a.newLinkIndicator
			}, n.fbt._("New", null, {
				hk: "BnhHE"
			}));
			t.b = e => e.path ? e.isExternal ? a.a.createElement("a", {
				className: m.a.navLinkStyles,
				href: e.path,
				onClick: e.onClick,
				target: "_blank",
				rel: "noopener noreferrer"
			}, e.label, a.a.createElement(d.a, {
				className: m.a.outboundLinkIcon
			})) : a.a.createElement(i.a, {
				className: Object(r.a)(m.a.navLinkStyles, {
					[m.a.activeLink]: !!e.isActive
				}),
				to: e.path,
				onClick: e.onClick
			}, e.label, e.isNew && a.a.createElement(u, null), e.isBeta && a.a.createElement("div", {
				className: m.a.newLinkIndicator
			}, n.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && a.a.createElement("div", {
				className: m.a.updatedLinkIndicator
			}, n.fbt._("Updated", null, {
				hk: "2xkGR3"
			})), e.showInboundArrow && a.a.createElement(l.a, {
				className: m.a.inboundLinkIcon
			})) : a.a.createElement("button", {
				className: m.a.navLinkStyles,
				onClick: e.onClick
			}, e.label)
		},
		"./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less": function(e, t, s) {
			e.exports = {
				wikiNavPanel: "KAUs91LhLIPR2bTL1aZRJ",
				contentTree: "_3_qIKXEwRmWcog7k9kGSno",
				footer: "_3FqEpSEBROhNwQ6pW6xmwJ",
				primaryButton: "_3fO0HSLh0kUxdhfv06hiTX",
				pageNavItem: "gCZ0Yr9nZYa9NaCdn8-eS",
				indentLine: "_2qFuXxmElNrzv3E9Qyb5xi",
				itemText: "_8bMrzJrL3U19A5yc6HTgj",
				mActive: "_1gyKwA8_GLuoQ1hu3Apd-w",
				mExists: "_3E5JJL5f6BXoTxqDq40IbB"
			}
		},
		"./src/reddit/components/ModHub/ModHubNav/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1rWejsW3eX4yw72E6Wfmyh",
				titleFontH2: "_10H_HMu7R7ett8pmawqwCS",
				titleFontH3: "_22nuZii7bWeL3c1xoXOl9",
				titleFontH4: "_2UjVJakiyf4d3yQ1sBrOzz",
				titleFontH5: "_22v1odcGzDJaLHik5W5qCz",
				titleFontH6: "_3BdZeq3g8CWhfeqBhIiW7f",
				metadataFont: "BQ88O08B4nIUNd4oLud39",
				flairFont: "_24GksXJ4va-4ZEamEGSlFB",
				labelsFont: "bd2r035T3aLLBkiMZaODQ",
				actionFont: "v0ITosHo9F3Rl2_llDtrc",
				smallButtonFont: "_3Sxxei5IvhyFBFPSQeJemM",
				largeButtonFont: "_-8HW12kqXpCzSoPxOQgrN",
				tabFont: "_2TpZx4pScQqA92z2QTYbIk",
				strongTextFont: "jPwoQR2t4sGD2BGLwCS0o",
				bodyFontH1: "_3hxV-zVTwf7J5X6U1gL2PA",
				bodyFontH2: "_1lSzh7ct7vogYQk35ULeJl",
				bodyFontH3: "_2C3DyZAU4ai6HhZtVTe-Bu",
				bodyFontH4: "_2tzV3r0Sow-B7LA2KMLD45",
				bodyFontH5: "_1-ivrwr3LQQJ2_7q7woFBf",
				bodyFontH6: "pJbG4WvyXqhjYGMHv_062",
				bodyFont: "gPA4LKC5gx8g56loAEuW2",
				bodyFontSmall: "_2U2PATpiHbmfDjkovIbtF9",
				bodyFontMono: "_1tyVWTRiPy8hBs1o6HBJ_a",
				navContainer: "_2xA0SygQ9V-9Vkdad_4tnh",
				wikiNavContainer: "_3wKmughJWQCbpbTpgwf2R_",
				navSection: "_1hDKgrVgEqwg3ogyzK0xTx",
				sectionHeader: "_1C6NYhYvuXKUDoONxrMR0d",
				iconStyles: "_1lHK5OQSXGaQzgW07E3Fh4",
				inboundLinkIcon: "_1cE0_wpoZtV5YKzwxXgxQ6",
				outboundLinkIcon: "_2Fb1fof3pZ4qO7_ZowwnXG",
				navLinkStyles: "jFCRipwFbBNJ4rl18HMK5",
				activeLink: "_4Gq-jEYAhrOCtha4RZ1JZ",
				breadcrumb: "_2Pw-8XrjTaQdxaxIicJXly",
				breadcrumbButton: "_1ofO-HYNTNyx_FUAEbIMME",
				newLinkIndicator: "_26hxZhi3N_WA1WUC6pQRpa",
				updatedLinkIndicator: "_1oCiY0B1NLkEfFfIfSJIF_"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2QinjfjfDTG6Df4_Tb_eRN",
				iconStyles: "_1MvzgnzkNefTZKkd4A5o1Y",
				arrowLeft: "_1Hul4w6ANujC9NsFF6_j4f"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/controls/InternalLink/index.tsx"),
				i = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				d = s("./src/reddit/components/ModHub/PaginationButtons/index.m.less"),
				l = s.n(d);
			t.a = e => o.a.createElement("div", {
				className: l.a.container
			}, e.prevButtonEnabled && o.a.createElement(r.a, {
				to: e.prevTo,
				onClick: e.prevButtonOnClick
			}, o.a.createElement(i.a, {
				className: Object(a.a)(l.a.iconStyles, l.a.arrowLeft)
			})), e.nextButtonEnabled && o.a.createElement(r.a, {
				to: e.nextTo,
				onClick: e.nextButtonOnClick
			}, o.a.createElement(i.a, {
				className: l.a.iconStyles
			})))
		},
		"./src/reddit/components/ModHub/StyledComponents/index.m.less": function(e, t, s) {
			e.exports = {
				ContentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				contentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				PageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				pageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				TopBar: "_2YY5qLRbI5q6_0JQVKiGt_",
				topBar: "_2YY5qLRbI5q6_0JQVKiGt_"
			}
		},
		"./src/reddit/components/ModHub/StyledComponents/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "c", (function() {
				return d
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				a = s.n(o);
			const r = n.a.div("ContentContainer", a.a),
				i = n.a.div("PageTitle", a.a),
				d = n.a.div("TopBar", a.a)
		},
		"./src/reddit/components/ModModeReports/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return a
			}));
			const n = e => (e.numReports || 0) > 0 || !!e.modReportsDismissed && e.modReportsDismissed.length > 0 || !!e.userReportsDismissed && e.userReportsDismissed.length > 0,
				o = e => {
					if (e.numReports && e.numReports > 0) return e.numReports;
					return (e.modReportsDismissed && e.modReportsDismissed.length || 0) + (e.userReportsDismissed && e.userReportsDismissed.length || 0)
				},
				a = e => (e.numReports || 0) > 0
		},
		"./src/reddit/components/ModModeReports/index.m.less": function(e, t, s) {
			e.exports = {
				Text: "_1gNngyeM0l7oKkuGjoSTm",
				text: "_1gNngyeM0l7oKkuGjoSTm",
				Placeholder: "_1oYW-msczpGlYVcXmyEu9j",
				placeholder: "_1oYW-msczpGlYVcXmyEu9j"
			}
		},
		"./src/reddit/components/ModModeReports/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/@loadable/component/dist/loadable.esm.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/ModModeReports/index.m.less"),
				d = s.n(i);
			const {
				fbt: l
			} = s("./node_modules/fbt/lib/FbtPublic.js"), c = r.a.div("Text", d.a), m = r.a.div("Placeholder", d.a), u = () => a.a.createElement(m, null, a.a.createElement(c, null, l._("Loading reports…", null, {
				hk: "4gwdQw"
			}))), p = Object(n.a)({
				resolved: {},
				chunkName: () => "ModerationDropdowns",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!s.m[t]
				},
				importAsync: () => s.e("ModerationDropdowns").then(s.bind(null, "./src/reddit/components/ModModeReports/_ModModeReports.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return s(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeReports/_ModModeReports.tsx"
				}
			}, {
				fallback: a.a.createElement(u, null),
				ssr: !1
			});
			t.a = p
		},
		"./src/reddit/components/ModToolsFlatlist/breakpoints.m.less": function(e, t, s) {
			e.exports = {
				HideIfVWSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				hideIfVwSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				ApproveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				approveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				DefaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				defaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				CompactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				compactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				RemoveGroup: "_3LzZxt89CjBbx__WYlCPCh",
				removeGroup: "_3LzZxt89CjBbx__WYlCPCh",
				SpamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				spamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				FlairGroup: "_129dedXMiIcel_grUelwoG",
				flairGroup: "_129dedXMiIcel_grUelwoG",
				HideIfVWLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				hideIfVwLarger: "_1RO0TIeDG89QPdOWgZwUvR"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/constants.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})),
				function(e) {
					e.Flair = "FLAIR", e.Spam = "SPAM", e.Remove = "REMOVE", e.Approve = "APPROVE"
				}(n || (n = {}))
		},
		"./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return m
			}));
			var n, o, a, r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				d = s("./src/reddit/components/ModToolsFlatlist/breakpoints.m.less"),
				l = s.n(d);
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(n || (n = {})),
			function(e) {
				e.Approve = "ApproveGroup", e.Remove = "RemoveGroup", e.Spam = "SpamGroup", e.Flair = "FlairGroup"
			}(o || (o = {})),
			function(e) {
				e.Compact = "CompactVariant", e.Default = "DefaultVariant"
			}(a || (a = {}));
			const c = {
					[i.a.Approve]: o.Approve,
					[i.a.Remove]: o.Remove,
					[i.a.Spam]: o.Spam,
					[i.a.Flair]: o.Flair
				},
				m = e => {
					const t = c[e.flatlistItem],
						s = l.a[e.breakpointType],
						n = l.a[t],
						o = e.isCompact ? l.a[a.Compact] : l.a[a.Default];
					return Object(r.a)(s, n, o)
				}
		},
		"./src/reddit/components/ModToolsFlatlist/index.m.less": function(e, t, s) {
			e.exports = {
				container: "OccjSdFd6HkHhShRg6DOl"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				m = s("./src/reddit/actions/post.ts"),
				u = s("./src/reddit/actions/tooltip.ts"),
				p = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				b = s("./src/reddit/components/ModModeReports/helpers.ts"),
				h = s("./src/reddit/components/PostFlairPicker/index.tsx"),
				g = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				f = s("./src/reddit/constants/postLayout.ts"),
				x = s("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				E = s("./src/reddit/helpers/trackers/post.ts"),
				v = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				C = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				_ = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				k = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				O = s("./src/reddit/selectors/activeModalId.ts"),
				y = s("./src/reddit/selectors/moderatorPermissions.ts"),
				j = s("./src/reddit/selectors/postFlair.ts"),
				w = s("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				S = s("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				I = s("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				P = s.n(I);
			const T = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return Object(S.b)({
						breakpointType: S.a.HideIfVWSmaller,
						flatlistItem: e,
						isCompact: t
					})
				},
				N = Object(r.b)(() => Object(i.c)({
					activeModalId: O.a,
					canEditFlair: (e, t) => {
						let {
							post: s
						} = t;
						return Object(j.a)(e, {
							postId: s.id
						})
					},
					moderatorPermissions: (e, t) => Object(y.i)(e, {
						postId: t.post.id
					})
				}), (e, t) => {
					let {
						post: s
					} = t;
					return {
						onApprovePost: () => e(Object(m.v)(s.id)),
						onOpenPostModModeDropdown: t => e(Object(u.h)({
							tooltipId: t
						})),
						onRemovePost: () => e(Object(m.V)(s.id, !1)),
						onSpamPost: () => e(Object(m.V)(s.id, !0)),
						onFlairPost: t => () => e(Object(c.i)(t))
					}
				});
			t.a = N(e => {
				const {
					canEditFlair: t,
					className: s,
					isOverlay: r,
					layout: i,
					moderatorPermissions: c,
					modModeEnabled: m,
					onApprovePost: u,
					onFlairPost: O,
					onRemovePost: y,
					onSpamPost: j,
					post: S,
					sendEvent: I,
					showIconsOnly: N
				} = e, M = Object(x.a)(c), R = Object(b.b)(S), L = !(!S.approvedBy || !R), A = Object(h.b)(S.id, r), F = M && m && !S.isSponsored, D = t && m;
				let B, U, H;
				N || (B = ((e, t) => e ? n.fbt._("reapprove", null, {
					hk: "OJvB1"
				}) : t ? n.fbt._("approved", null, {
					hk: "2bWAFI"
				}) : n.fbt._("approve", null, {
					hk: "2DIHcM"
				}))(L, S.approvedBy), U = ((e, t) => e ? t === l.k ? n.fbt._("Confirm removal", null, {
					hk: "1t5tKM"
				}) : n.fbt._("removed", null, {
					hk: "35ZTch"
				}) : n.fbt._("remove", null, {
					hk: "3LWMcS"
				}))(S.isRemoved, S.bannedBy), H = (e => e ? n.fbt._("spammed", null, {
					hk: "3GPrkZ"
				}) : n.fbt._("spam", null, {
					hk: "3ebJLg"
				}))(S.isSpam));
				const W = !r && i === f.g.Compact;
				return a.a.createElement("div", {
					className: Object(d.a)(P.a.container, s)
				}, F && a.a.createElement(o.Fragment, null, a.a.createElement(g.b, {
					className: T(w.a.Approve, W),
					key: "approveButton",
					text: B,
					disabled: !!S.approvedBy && !R,
					onClick: () => {
						u(), I(Object(E.f)(S.id, "approve"))
					}
				}, a.a.createElement(v.a, null)), a.a.createElement(g.d, {
					className: T(w.a.Remove, W),
					key: "removeButton",
					text: U,
					disabled: S.isRemoved && S.bannedBy !== l.k,
					onClick: () => {
						y(), S.isRemoved && S.bannedBy === l.k ? I(Object(E.f)(S.id, "confirm_remove")) : I(Object(E.f)(S.id, "remove"))
					}
				}, a.a.createElement(C.a, null)), a.a.createElement(g.d, {
					className: T(w.a.Spam, W),
					key: "removeSpamButton",
					text: H,
					disabled: S.isSpam,
					onClick: () => {
						j(), I(Object(E.f)(S.id, "spam"))
					}
				}, a.a.createElement(_.a, null))), D && a.a.createElement(g.c, {
					className: T(w.a.Flair, W),
					key: "tagButton",
					onClick: () => {
						O(A)(), I(Object(E.f)(S.id, "post_flair_picker"))
					}
				}, a.a.createElement(k.a, null)), a.a.createElement(p.f, {
					postId: S.id
				}))
			})
		},
		"./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_3aaWXDPwVg-rhD0DvWeyIg",
				titleFontH2: "_3RrF8F_t0SfGrUYfrMwbPy",
				titleFontH3: "_36oA-I2A9k4cBPYs3kAlux",
				titleFontH4: "_1neT2k10waDvSZYxkd9bk8",
				titleFontH5: "_3oeJNjYGx_aLE6l4o6Jhcr",
				titleFontH6: "_2CsvILRAMCNlhcGlq7eAZF",
				metadataFont: "_2odnjtlqO4r8tdO5H9fwLW",
				flairFont: "k5rlVaQw1fQ4nW2C-cK8H",
				labelsFont: "_20rPk9VJ1JfA7IuzEuFf25",
				actionFont: "_1YoZx3mOGBx4yxG_aQD3dq",
				smallButtonFont: "_3eWaIQ1VVjPR_5vUm4bU74",
				largeButtonFont: "rBsu7j_nL4EsDsP9nsEx4",
				tabFont: "_3WOHej9q3BPonP3nmtGWrh",
				strongTextFont: "_1efJllSuh9p67WrocQmmWR",
				bodyFontH1: "_1m_v2MMDlDugLUDKRkPnPP",
				bodyFontH2: "uhtqruCImDdb6YMrply29",
				bodyFontH3: "oI7G9eYumAFmPy69WN078",
				bodyFontH4: "_3NN_fRjCSJGnly_ejXsz8m",
				bodyFontH5: "_1lK4S52h6Glz4-OysTx6SF",
				bodyFontH6: "BarCcSBvd2WaM4vhBY1_R",
				bodyFont: "RIX67Ch_ZE4SYGnQlkPWs",
				bodyFontSmall: "_1_FK7Ynr3eStBK-2Nbutbg",
				bodyFontMono: "_1mpZy47SxXNRDTLTEdCUmV",
				dropdownRow: "_3p4amLmnNdNRS9NcI_TnQm",
				filter: "_1LUEYTVtU-JweRiTGrVNn6",
				container: "_1GH53do8Ql17wdDC_i_NDf",
				containerText: "KiwwtIazAS77Aa_w3AdBE",
				listContainer: "FyBjuKMom1xYgTT7w5Dg1",
				selector: "_3fe64brTItATv48WIPt-Af"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1o6EpuTR_pbdKk4biOJFOD",
				titleFontH2: "_2scGKAM0oQo5UQ0sAeTYcJ",
				titleFontH3: "nZ8gtQ7wSBH1Ei4U88QyH",
				titleFontH4: "cWWmG8ptxDy68exgcmkxK",
				titleFontH5: "_2ltEgDFK7lEC55mqYn2t1k",
				titleFontH6: "_1wRduyAnZyUXSUvy0rPJ7E",
				metadataFont: "_3iKB3xohr95CjhTE-YrXL4",
				flairFont: "_2tIFOrubLwHvQfSpZ7MBvr",
				labelsFont: "_1Qc6zGFV60DgXsfeg4iK1-",
				actionFont: "bD7YA5ocXtmwPNG0x7gqi",
				smallButtonFont: "wa3Y6CP3s2WY-9hiMRcK6",
				largeButtonFont: "_1Td1TQRNZA20xRbI-LLHsA",
				tabFont: "_3Bdl5CdTghtfz5X9Qkn7y0",
				strongTextFont: "_2bBsKMYboYeah9nlKp4p8e",
				bodyFontH1: "_2b6RUiVz7aEMUoaiEalXki",
				bodyFontH2: "_1gD38a1FX6kmxcFvUyP8bB",
				bodyFontH3: "_20D34o21pcOy-JSvp0fq42",
				bodyFontH4: "_368KGbv676rMnmb_kPY7-A",
				bodyFontH5: "_2o6Gp_6yxl-T5p9MHsV3hI",
				bodyFontH6: "_2jp4S3tPdfLXU3FVoOvCWi",
				bodyFont: "O3aukKYU-BhYFQQgCIAcN",
				bodyFontSmall: "_10AKt1uw6lDYoTkaQ2Egu-",
				bodyFontMono: "_3tQKpxkireZBsmkNyZ5-0J",
				row: "_3sZTiywtJTK5dskqy0h2G2",
				modNameCell: "_1hV1AUW4J0YvMuEK7-Ph1H",
				usernameLink: "_25VIbQ9CpcAT2Uys4A2mFb",
				actionLink: "_2yXBXFFI2XxJRqd89Zwd25",
				createdAtTooltip: "zMBbz2oHRB9_15CBkQ3P4",
				detailsContainer: "_3pusa5HaB8VO3ODi63vjLl",
				detailsContent: "piNOo-es-o0F7rcLiUu0N",
				detailsType: "_3P62Ird8EqkkVbqN0bv1tU",
				icon: "VzgXNIgPGoNVtsv9-uwYE",
				iconWrapper: "_3cDZ1nhaOv-edC1Ixznjgd",
				negativeTreatment: "XqM6DP9JAGpvwgodvCcuI",
				positiveTreatment: "Ob5o1Q3oVSaizQinm6DD",
				tooltip: "_33OjvBwqb5PPwalXFSmAoy"
			}
		},
		"./src/reddit/components/ModerationLog/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_2OYuAlGNOY6MlJjEC6nWEY",
				titleFontH2: "_2cz1b71RqIGBP0q1sEpoc1",
				titleFontH3: "pNuW5Xi4qPFjDgkhE2utU",
				titleFontH4: "HnjsgzUiJm7Rz4yf-QTnU",
				titleFontH5: "_32jYSRMv-UqDvlwAZ9yI4P",
				titleFontH6: "WyhSydN2c9D7w_ikI_LsS",
				metadataFont: "klmtj4Euuox2ljWXOzJqz",
				flairFont: "_1XFZbbYMt1bMVk_65YaTug",
				labelsFont: "_2lbFHk9fPHfy-Pj2cQ56ef",
				actionFont: "_250q84vRQ0qeydB79AJun",
				smallButtonFont: "_3QKadDpX2GixU1usvLUiww",
				largeButtonFont: "_24SnRKi2v2z3Q8DfWx8Cfd",
				tabFont: "_1y1SLpqv4ViOdLE8d7R03R",
				strongTextFont: "_1bRU6ybRMZMA-zL-dR_BFc",
				bodyFontH1: "_2qrAJcHH1W18XK6K_iZjmY",
				bodyFontH2: "_2yInLfhO3hB7n5aflEa_Y5",
				bodyFontH3: "_31VlGQEcOO_KNq8afFO4lZ",
				bodyFontH4: "_13MU9oPUeX9-FTZJw6fEdd",
				bodyFontH5: "_3h1ag_p5AVxzseMoTk9Oee",
				bodyFontH6: "_2GA-IlakdRmzOgQVFN2Q_F",
				bodyFont: "_3W9ZZjex4uhC0x4j0tXUE8",
				bodyFontSmall: "_2wYhe0C_P9ON8nur1uwzBd",
				bodyFontMono: "Ygu6NDZ2VS1jqJxKuuJ67",
				contentContainer: "PLQrC-Lzmu2AHBmciLxW5",
				table: "_27_l-nXesULxjvqLhpd6Ie",
				timeColHeader: "_1qWSBc-O0drE3JbIiVNEqE",
				modNameColHeader: "_2vKvLM8vE2iV6p5T0b5J42",
				actionNameColHeader: "_3pOXEjq1uyvW71Pp3gS7yv",
				icon: "_2iiHYO0HlG5gGeXyf7S3_q",
				iconContainer: "_3leJW5B-x65UTDfhDAblD_",
				title: "_2pFg2GOWUWlkKFlSaV-iFq",
				tooltip: "jkeAqS2MNV7nCHZkp4vi9",
				actionTooltip: "p12QqrsFSXUXQXCVTreZ5",
				actionTooltipDescription: "_2SZhKngNXxQ-MnrDr17Fm-",
				allIconsContainer: "_2zekEhqxlIqb4STkFCskIT",
				detailTooltip: "_20tDXbrpUnXW12ZXmRZdKa",
				bottomBarRow: "_28pYv3DHnyqXo6lJwzAOcG"
			}
		},
		"./src/reddit/components/ModerationLog/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/makeActionCreator/index.ts"),
				c = s("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				m = s("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				u = s("./src/reddit/selectors/subreddit.ts"),
				p = s("./src/reddit/actions/moderationLog/constants.ts");
			const b = Object(l.a)(p.a);
			var h = s("./node_modules/react-router-redux/es/index.js"),
				g = s("./src/higherOrderComponents/asTooltip.tsx"),
				f = s("./src/reddit/actions/tooltip.ts"),
				x = (s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/reddit/constants/keycodes.ts"));
			const E = ["Anti-Evil Operations", "Reddit Legal"];
			var v;
			! function(e) {
				e.ACTION = "action", e.MODERATOR = "moderator"
			}(v || (v = {}));
			const C = {
					ALL_ACTIONS: () => o.fbt._("All actions", null, {
						hk: "3sHzD4"
					}),
					ACCEPT_MODERATOR_INVITE: () => o.fbt._("Accept moderator invite", null, {
						hk: "3WJot2"
					}),
					ADD_COMMUNITY_TOPICS: () => o.fbt._("Add community topics", null, {
						hk: "4xgglk"
					}),
					ADD_CONTRIBUTOR: () => o.fbt._("Add contributor", null, {
						hk: "444ZK"
					}),
					ADD_MODERATOR: () => o.fbt._("Add moderator", null, {
						hk: "4rRghF"
					}),
					APPROVE_COMMENT: () => o.fbt._("Approve comment", null, {
						hk: "1gvHWC"
					}),
					APPROVE_LINK: () => o.fbt._("Approve link", null, {
						hk: "2LqFt4"
					}),
					BAN_USER: () => o.fbt._("Ban user", null, {
						hk: "4DmPqi"
					}),
					COLLECTIONS: () => o.fbt._("Collections", null, {
						hk: "3a39Wa"
					}),
					COMMUNITY_STYLING: () => o.fbt._("Community styling", null, {
						hk: "386ps9"
					}),
					COMMUNITY_WIDGETS: () => o.fbt._("Community widgets", null, {
						hk: "4ml45n"
					}),
					CREATE_AWARD: () => o.fbt._("Create award", null, {
						hk: "bWa9w"
					}),
					CREATE_RULE: () => o.fbt._("Create rule", null, {
						hk: "28uE69"
					}),
					CREATE_SCHEDULED_POST: () => o.fbt._("Create scheduled post", null, {
						hk: "mVbI1"
					}),
					DELETE_AWARD: () => o.fbt._("Delete award", null, {
						hk: "3xYaZ7"
					}),
					DELETE_RULE: () => o.fbt._("Delete rule", null, {
						hk: "2lWdRL"
					}),
					DELETE_SCHEDULED_POST: () => o.fbt._("Delete scheduled post", null, {
						hk: "MhwRy"
					}),
					DISABLE_AWARD: () => o.fbt._("Disable award", null, {
						hk: "2yFBt7"
					}),
					DISTINGUISH: () => o.fbt._("Distinguish", null, {
						hk: "3cWniK"
					}),
					EDIT_FLAIR: () => o.fbt._("Edit flair", null, {
						hk: "mD0CV"
					}),
					EDIT_RULE: () => o.fbt._("Edit rule", null, {
						hk: "2T4TJx"
					}),
					EDIT_SCHEDULED_POST: () => o.fbt._("Edit scheduled post", null, {
						hk: "1XCmsI"
					}),
					EDIT_SETTINGS: () => o.fbt._("Edit settings", null, {
						hk: "3o8q46"
					}),
					HIDDEN_AWARD: () => o.fbt._("Hide award", null, {
						hk: "31lRN8"
					}),
					EVENTS: () => o.fbt._("Events", null, {
						hk: "4Bq9wt"
					}),
					IGNORE_REPORTS: () => o.fbt._("Ignore reports", null, {
						hk: "1defIy"
					}),
					INVITE_MODERATOR: () => o.fbt._("Invite moderator", null, {
						hk: "1DbgL5"
					}),
					LOCK: () => o.fbt._("Lock", null, {
						hk: "39hTi5"
					}),
					MARK_NSFW: () => o.fbt._("Mark nsfw", null, {
						hk: "3bo45o"
					}),
					MARK_ORIGINAL_CONTENT: () => o.fbt._("Mark original content", null, {
						hk: "SadHO"
					}),
					MOD_AWARD_GIVEN: () => o.fbt._("Mod award given by moderators", null, {
						hk: "35cQgR"
					}),
					MODMAIL_ENROLLMENT: () => o.fbt._("Modmail enrollment", null, {
						hk: "4ee1XK"
					}),
					MUTE_USER: () => o.fbt._("Mute user", null, {
						hk: "3kPYe4"
					}),
					REMOVE_COMMENT: () => o.fbt._("Remove comment", null, {
						hk: "vEI4S"
					}),
					REMOVE_COMMUNITY_TOPICS: () => o.fbt._("Remove community topics", null, {
						hk: "1tLjxQ"
					}),
					REMOVE_CONTRIBUTOR: () => o.fbt._("Remove contributor", null, {
						hk: "4FMLz6"
					}),
					REMOVE_LINK: () => o.fbt._("Remove link", null, {
						hk: "tmjch"
					}),
					REMOVE_MODERATOR: () => o.fbt._("Remove moderator", null, {
						hk: "1FHVTB"
					}),
					REMOVE_WIKI_CONTRIBUTOR: () => o.fbt._("Remove wiki contributor", null, {
						hk: "1PcCja"
					}),
					REORDER_RULES: () => o.fbt._("Reorder rules", null, {
						hk: "306Bqx"
					}),
					SET_CONTEST_MODE: () => o.fbt._("Set contest mode", null, {
						hk: "1pERnU"
					}),
					SET_PERMISSIONS: () => o.fbt._("Set permissions", null, {
						hk: "3UzkKU"
					}),
					SET_SUGGESTEDSORT: () => o.fbt._("Set suggested sort", null, {
						hk: "208T6K"
					}),
					SHOW_COMMENT: () => o.fbt._("Show comment", null, {
						hk: "n5M3i"
					}),
					SPAM_COMMENT: () => o.fbt._("Spam comment", null, {
						hk: "2ROyTD"
					}),
					SPAM_LINK: () => o.fbt._("Spam link", null, {
						hk: "2G5xg3"
					}),
					SPOILER: () => o.fbt._("Spoiler", null, {
						hk: "2nfv1a"
					}),
					STICKY: () => o.fbt._("Sticky", null, {
						hk: "1W6JrJ"
					}),
					SUBMIT_SCHEDULED_POST: () => o.fbt._("Submit scheduled post", null, {
						hk: "1i2VUH"
					}),
					UNBAN_USER: () => o.fbt._("Unban user", null, {
						hk: "4m2iNP"
					}),
					UNIGNORE_REPORTS: () => o.fbt._("Unignore reports", null, {
						hk: "1wfp99"
					}),
					UNINVITE_MODERATOR: () => o.fbt._("Uninvite moderator", null, {
						hk: "3E6UkD"
					}),
					UNLOCK: () => o.fbt._("Unlock", null, {
						hk: "2BHnOC"
					}),
					UNMUTE_USER: () => o.fbt._("Unmute user", null, {
						hk: "25tct2"
					}),
					UNSET_CONTEST_MODE: () => o.fbt._("Unset contest mode", null, {
						hk: "AxsDk"
					}),
					UNSPOILER: () => o.fbt._("Unspoiler", null, {
						hk: "2gE1K1"
					}),
					UNSTICKY: () => o.fbt._("Unsticky", null, {
						hk: "U5tvd"
					}),
					WIKI_BANNED: () => o.fbt._("Wiki banned", null, {
						hk: "1nk4H7"
					}),
					WIKI_CONTRIBUTOR: () => o.fbt._("Wiki contributor", null, {
						hk: "1W6zn3"
					}),
					WIKI_PAGE_LISTED: () => o.fbt._("Wiki page listed", null, {
						hk: "4aghdO"
					}),
					WIKI_PERM_LEVEL: () => o.fbt._("Wiki perm level", null, {
						hk: "4waHE"
					}),
					WIKI_REVISE: () => o.fbt._("Wiki revise", null, {
						hk: "3FZuIJ"
					}),
					WIKI_UNBANNED: () => o.fbt._("Wiki unbanned", null, {
						hk: "1fAtKd"
					})
				},
				_ = {
					added_event_times: () => o.fbt._("added event times to post", null, {
						hk: "1TpgVq"
					}),
					added_flair_styling: () => o.fbt._("added flair styling", null, {
						hk: "zQ6Tv"
					}),
					added_styling: () => o.fbt._("modified community styling", null, {
						hk: "xSJ7B"
					}),
					added_to_collection: () => o.fbt._("added post to collection", null, {
						hk: "3V4fk0"
					}),
					added_widget: () => o.fbt._("added widget", null, {
						hk: "1eVJg6"
					}),
					allow_discovery: () => o.fbt._("toggle allow in search/onboarding/discovery", null, {
						hk: "3on6Qf"
					}),
					allow_top: () => o.fbt._("toggle allow in default/trending lists", null, {
						hk: "DikzW"
					}),
					collapse_deleted_comments: () => o.fbt._("toggle collapse deleted/removed comments", null, {
						hk: "22QPzD"
					}),
					comment_score_hide_mins: () => o.fbt._("comment score hide period", null, {
						hk: "21jsup"
					}),
					confirm_ham: () => o.fbt._("approved", null, {
						hk: "3xh84x"
					}),
					confirm_spam: () => o.fbt._("confirm spam", null, {
						hk: "2yAos0"
					}),
					created_collection: () => o.fbt._("created collection", null, {
						hk: "3vtmUM"
					}),
					css_on_cname: () => o.fbt._("toggle custom css from cname", null, {
						hk: "LTlcB"
					}),
					del_banner: () => o.fbt._("delete banner image", null, {
						hk: "2HRlu"
					}),
					del_header: () => o.fbt._("delete header image", null, {
						hk: "2k08m2"
					}),
					del_icon: () => o.fbt._("delete icon image", null, {
						hk: "43ObSQ"
					}),
					del_image: () => o.fbt._("delete image", null, {
						hk: "4ztzG0"
					}),
					deleted_collection: () => o.fbt._("deleted collection", null, {
						hk: "1T8FDF"
					}),
					description: () => o.fbt._("sidebar description", null, {
						hk: "3gBQBx"
					}),
					domain: () => o.fbt._("domain", null, {
						hk: "37Eg7w"
					}),
					edited_collection_description: () => o.fbt._("edited collection description", null, {
						hk: "ViGod"
					}),
					edited_collection_display_layout: () => o.fbt._("edited collection display layout", null, {
						hk: "xGExq"
					}),
					edited_collection_title: () => o.fbt._("edited collection title", null, {
						hk: "2x6aKQ"
					}),
					edited_event_body: () => o.fbt._("edited event post body", null, {
						hk: "2uwjvL"
					}),
					edited_event_times: () => o.fbt._("edited event post times", null, {
						hk: "3HNoa4"
					}),
					edited_event_title: () => o.fbt._("edited event post title", null, {
						hk: "4itZHA"
					}),
					edited_widget: () => o.fbt._("edited widget", null, {
						hk: "4eaNe6"
					}),
					exclude_banned_modqueue: () => o.fbt._("toggle exclude banned users posts from modqueue", null, {
						hk: "j41F1"
					}),
					flair_clear_template: () => o.fbt._("clear flair template", null, {
						hk: "1IMRYi"
					}),
					flair_csv: () => o.fbt._("edit flair by csv", null, {
						hk: "480ZDT"
					}),
					flair_delete_template: () => o.fbt._("delete flair template", null, {
						hk: "bJ8f2"
					}),
					flair_add: () => o.fbt._("add flair", null, {
						hk: "281rsb"
					}),
					flair_delete: () => o.fbt._("delete flair", null, {
						hk: "2UkqAp"
					}),
					flair_edit: () => o.fbt._("edit flair", null, {
						hk: "3oxZYq"
					}),
					flair_enabled: () => o.fbt._("toggle flair enabled", null, {
						hk: "9WUzt"
					}),
					flair_position: () => o.fbt._("toggle user flair position", null, {
						hk: "4cwkk5"
					}),
					flair_self_enabled: () => o.fbt._("toggle user assigned flair enabled", null, {
						hk: "4q13ZR"
					}),
					flair_template: () => o.fbt._("add/edit flair templates", null, {
						hk: "NSSHD"
					}),
					free_form_reports: () => o.fbt._("toggle allow free form reports by users", null, {
						hk: "3MBfJn"
					}),
					header_title: () => o.fbt._("header title", null, {
						hk: "40Y0QO"
					}),
					ignore_reports: () => o.fbt._("ignore reports", null, {
						hk: "h7fov"
					}),
					lang: () => o.fbt._("language", null, {
						hk: "2xhrR8"
					}),
					link_flair_position: () => o.fbt._("toggle link flair position", null, {
						hk: "3j33wQ"
					}),
					link_flair_self_enabled: () => o.fbt._("toggle submitter assigned link flair enabled", null, {
						hk: "43EykN"
					}),
					link_type: () => o.fbt._("link type", null, {
						hk: "2FuNM"
					}),
					over_18: () => o.fbt._("toggle viewers must be over 18", null, {
						hk: "PRgas"
					}),
					permanent: () => o.fbt._("permanent ban", null, {
						hk: "3MeL5T"
					}),
					permission_moderator_invite: () => o.fbt._("set permissions on moderator invitation", null, {
						hk: "hA7I9"
					}),
					permission_moderator: () => o.fbt._("set permissions on moderator", null, {
						hk: "1yq3O2"
					}),
					public_description: () => o.fbt._("description", null, {
						hk: "JizZj"
					}),
					public_traffic: () => o.fbt._("toggle public traffic stats page", null, {
						hk: "qIXty"
					}),
					remove_self: () => o.fbt._("removed self", null, {
						hk: "I5wgr"
					}),
					remove: () => o.fbt._("remove", null, {
						hk: "mAXhe"
					}),
					removed_from_collection: () => o.fbt._("removed post from collection", null, {
						hk: "2dwuxr"
					}),
					removed_styling: () => o.fbt._("removed community styling", null, {
						hk: "1p7Io9"
					}),
					removed_widget: () => o.fbt._("removed widget", null, {
						hk: "43WUko"
					}),
					show_cname_sidebar: () => o.fbt._("toggle show sidebar from cname", null, {
						hk: "4nlv2A"
					}),
					show_media: () => o.fbt._("toggle show thumbnail images of content", null, {
						hk: "2XmVTJ"
					}),
					spam: () => o.fbt._("spam", null, {
						hk: "3usg93"
					}),
					stylesheet: () => o.fbt._("stylesheet", null, {
						hk: "1TOdUF"
					}),
					submit_link_label: () => o.fbt._("submit link button label", null, {
						hk: "4BdL19"
					}),
					submit_text_label: () => o.fbt._("submit text post button label", null, {
						hk: "4wc8qi"
					}),
					title: () => o.fbt._("title", null, {
						hk: "3tlhiX"
					}),
					type: () => o.fbt._("type", null, {
						hk: "14BQua"
					}),
					unspam: () => o.fbt._("unspam", null, {
						hk: "3SxHQ4"
					}),
					upload_image_banner: () => o.fbt._("upload image banner", null, {
						hk: "1ocFEe"
					}),
					upload_image_header: () => o.fbt._("upload image header", null, {
						hk: "3J6pke"
					}),
					upload_image_icon: () => o.fbt._("upload image icon", null, {
						hk: "4jr6Eg"
					}),
					upload_image: () => o.fbt._("upload image", null, {
						hk: "2KN9ig"
					}),
					copyright_removal: () => o.fbt._("copyright removal", null, {
						hk: "9vN6G"
					}),
					copyright_restoration: () => o.fbt._("copyright restoration", null, {
						hk: "35qFx5"
					})
				};
			var k, O;
			! function(e) {
				e.AWARD = "Award", e.COMMENT = "Comment", e.FLAIR = "Flair", e.MULTIPLE = "Multiple", e.POST = "Post", e.REDDITOR = "Redditor", e.SETTINGS = "Settings", e.WIKI = "Wiki", e.COLLECTION = "Collection", e.EVENT = "Event"
			}(k || (k = {})),
			function(e) {
				e.NONE = "none", e.POSITIVE = "positive", e.NEGATIVE = "negative"
			}(O || (O = {}));
			var y = s("./src/reddit/controls/InternalLink/index.tsx"),
				j = s("./src/lib/addQueryParams/index.ts"),
				w = s("./src/lib/stripQueryParams/index.ts");
			const S = e => {
				const t = e.action && "ALL_ACTIONS" !== e.action ? e.action : null,
					s = e.moderator || null,
					n = e.endCursor || null,
					o = e.startCursor || null;
				return Object(j.a)(Object(w.a)(e.currentPageUrl), {
					action: t,
					moderator: s,
					after: n,
					before: o
				})
			};
			var I = s("./src/reddit/selectors/telemetry.ts");
			const P = e => ({
					subreddit: I.subreddit(e),
					userSubreddit: I.userSubreddit(e)
				}),
				T = () => e => Object.assign({
					source: "mod_log",
					action: "click",
					noun: "mod_filter_dropdown"
				}, P(e)),
				N = () => e => Object.assign({
					source: "mod_filter_dropdown",
					action: "click",
					noun: "moderator"
				}, P(e)),
				M = () => e => Object.assign({
					source: "mod_log",
					action: "click",
					noun: "mod_action_dropdown"
				}, P(e)),
				R = e => t => Object.assign({
					source: "mod_action_dropdown",
					action: "click",
					noun: e.toLowerCase()
				}, P(t));
			var L = s("./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less"),
				A = s.n(L);
			class F extends r.a.Component {
				constructor(e) {
					super(e), this.buildModLogUrlForAction = e => {
						const {
							currentPageUrl: t,
							moderator: s
						} = this.props;
						return S({
							currentPageUrl: t,
							moderator: s,
							action: e
						})
					}, this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							s = this.getFilteredActions(t);
						this.setState({
							currentInputText: t,
							filteredActions: s
						})
					}, this.onKeyDown = e => {
						if (e.which === x.a.Enter) {
							const {
								filteredActions: t
							} = this.state, s = t.length ? this.buildModLogUrlForAction(t[0]) : null;
							s && (this.props.onChangeUrl(s), e.preventDefault())
						}
					}, this.onActionClick = e => {
						this.props.sendEvent(R(e))
					}, this.state = {
						currentInputText: "",
						filteredActions: this.getFilteredActions("")
					}
				}
				getFilteredActions(e) {
					let t = Object.keys(C);
					if (e) {
						const s = e.toLowerCase();
						t = t.filter(e => C[e]().toString().toLowerCase().includes(s))
					}
					return t
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredActions: t
					} = this.state;
					return r.a.createElement("div", {
						role: "menu",
						className: e
					}, r.a.createElement("input", {
						"aria-label": o.fbt._("Filter", null, {
							hk: "UqHZD"
						}),
						className: A.a.filter,
						placeholder: o.fbt._("Filter", null, {
							hk: "3sxP3l"
						}),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map(e => r.a.createElement(y.a, {
						className: A.a.dropdownRow,
						onClick: () => this.onActionClick(e),
						to: this.buildModLogUrlForAction(e)
					}, C[e]())))
				}
			}
			var D = F,
				B = s("./src/lib/objectSelector/index.ts"),
				U = s("./src/reddit/models/SubredditModeration/ModerationLog/index.ts");
			const H = Object(B.a)((e, t) => {
					let {
						subredditId: s
					} = t, n = [];
					const o = W(e),
						a = V(e);
					if (o && a) {
						const t = Object(U.a)(s, o, a),
							r = e.moderationLog.actions.itemOrder[s] && e.moderationLog.actions.itemOrder[s][t];
						r && (n = r.map(t => e.moderationLog.actions.models[s][t]))
					}
					return n
				}),
				W = e => e.moderationLog.endCursor,
				V = e => e.moderationLog.startCursor,
				q = e => {
					let {
						name: t,
						urlPath: s
					} = e;
					return r.a.createElement(y.a, {
						className: A.a.dropdownRow,
						to: s
					}, t)
				},
				G = "a",
				K = "AutoModerator",
				z = Object(d.c)({
					allModerators: (e, t) => {
						let {
							subredditId: s
						} = t;
						return ((e, t) => e.moderationLog.moderators[t] || [])(e, s)
					}
				});
			class Q extends r.a.Component {
				constructor(e) {
					super(e), this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							s = this.getList(t);
						this.setState({
							currentInputText: t,
							filteredList: s
						})
					}, this.onKeyDown = e => {
						if (e.which === x.a.Enter) {
							const {
								filteredList: t
							} = this.state, s = t.length ? t[0].url : "";
							s && (this.props.onChangeUrl(s), e.preventDefault())
						}
					}, this.onDropdownClick = e => {
						e.target instanceof HTMLAnchorElement && this.props.sendEvent(N())
					}, this.state = {
						currentInputText: "",
						filteredList: this.getList("")
					}
				}
				getList(e) {
					const {
						action: t,
						currentPageUrl: s
					} = this.props, n = e => S({
						currentPageUrl: s,
						action: t,
						moderator: e
					}), a = [{
						url: n(""),
						displayText: "".concat(o.fbt._("All Moderators", null, {
							hk: "3vmWA8"
						}))
					}, {
						url: n(G),
						displayText: "".concat(o.fbt._("Admins", null, {
							hk: "4mKRNI"
						}))
					}, {
						url: n(K),
						displayText: "".concat(o.fbt._("AutoModerator", null, {
							hk: "4wxc1W"
						}))
					}, ...this.props.allModerators.map(e => ({
						url: n(e.name),
						displayText: e.name
					}))];
					if (e) {
						const t = e.toLowerCase();
						return a.filter(e => e.displayText.toLowerCase().includes(t))
					}
					return a
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredList: t
					} = this.state;
					return r.a.createElement("div", {
						role: "menu",
						className: e,
						onClick: this.onDropdownClick
					}, r.a.createElement("input", {
						"aria-label": o.fbt._("Filter", null, {
							hk: "1qnOD5"
						}),
						className: A.a.filter,
						placeholder: o.fbt._("Filter", null, {
							hk: "1sWvOA"
						}),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map((e, t) => r.a.createElement(q, {
						key: t,
						name: e.displayText,
						urlPath: e.url
					})))
				}
			}
			var J = Object(i.b)(z)(Q),
				Z = s("./src/reddit/components/TrackingHelper/index.tsx"),
				X = s("./src/reddit/controls/Dropdown/index.tsx"),
				Y = s("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				$ = s("./src/reddit/selectors/tooltip.ts");
			const ee = "mod-log-action-filter-dropdown",
				te = "mod-log-moderator-filter-dropdown",
				se = Object(g.a)(X.a),
				ne = Object(d.c)({
					isActionFilterDropdownOpen: Object($.b)(ee),
					isModeratorFilterDropdownOpen: Object($.b)(te)
				});
			class oe extends r.a.Component {
				constructor() {
					super(...arguments), this.getContainerText = e => {
						const {
							action: t,
							moderator: s
						} = this.props;
						if (e === v.MODERATOR) {
							let e = s;
							return s === G && (e = o.fbt._("Admins", null, {
								hk: "1qJDMA"
							})), e || o.fbt._("All Moderators", null, {
								hk: "18DhaK"
							})
						}
						if (e === v.ACTION) {
							return t && C[t] && C[t]() || o.fbt._("Actions", null, {
								hk: "1s4OJD"
							})
						}
					}, this.openModFilterDropdown = () => {
						this.props.onOpenDropdown(te), this.props.sendEvent(T())
					}, this.openActionFilterDropdown = () => {
						this.props.onOpenDropdown(ee), this.props.sendEvent(M())
					}
				}
				stopPropagation(e) {
					e.nativeEvent.stopImmediatePropagation()
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						isActionFilterDropdownOpen: s,
						isModeratorFilterDropdownOpen: n,
						moderator: a,
						subredditId: i
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement("div", {
						className: A.a.container,
						onClickCapture: this.stopPropagation
					}, r.a.createElement("button", {
						"aria-expanded": n,
						"aria-label": o.fbt._("Start typing to filter moderators or use up and down to select.", null, {
							hk: "4ff0MW"
						}),
						className: A.a.selector,
						id: te,
						onClick: this.openModFilterDropdown,
						role: "navigation"
					}, r.a.createElement("span", {
						className: A.a.containerText
					}, this.getContainerText(v.MODERATOR)), r.a.createElement(Y.a, null)), r.a.createElement(se, {
						tooltipId: te,
						isOpen: n
					}, r.a.createElement(J, {
						action: e,
						className: A.a.listContainer,
						currentPageUrl: t,
						moderator: a,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent,
						subredditId: i
					}))), r.a.createElement("div", {
						className: A.a.container,
						onClickCapture: this.stopPropagation
					}, r.a.createElement("button", {
						"aria-expanded": s,
						"aria-label": o.fbt._("Start typing to filter the mod actions or use up and down to select.", null, {
							hk: "32A4KB"
						}),
						className: A.a.selector,
						id: ee,
						onClick: this.openActionFilterDropdown,
						role: "navigation"
					}, r.a.createElement("span", {
						className: A.a.containerText
					}, this.getContainerText(v.ACTION)), r.a.createElement(Y.a, null)), r.a.createElement(se, {
						tooltipId: ee,
						isOpen: s
					}, r.a.createElement(D, {
						action: e,
						className: A.a.listContainer,
						currentPageUrl: t,
						moderator: a,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent
					}))))
				}
			}
			var ae = Object(i.b)(ne, e => ({
					onOpenDropdown: t => e(Object(f.h)({
						tooltipId: t
					})),
					pushUrl: t => e(Object(h.b)(t))
				}))(Object(Z.c)(oe)),
				re = s("./node_modules/lodash/noop.js"),
				ie = s.n(re),
				de = s("./src/lib/timeAgo/index.ts"),
				le = s("./src/reddit/components/AuthorLink/index.tsx"),
				ce = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				me = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				ue = s("./src/reddit/models/User/index.ts"),
				pe = s("./src/lib/assertNever.ts");
			var be = s("./src/reddit/icons/fonts/Comment/index.tsx"),
				he = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M14 0H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 2h12c.77 0 1.468.301 2 .78V2a2 2 0 0 0-2-2zm0 3H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 5h12c.77 0 1.468.301 2 .78V5a2 2 0 0 0-2-2zM2 6h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2z"
				}))),
				ge = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M4 16h12V9H4v7zM17 4h-2V3a1 1 0 0 0-2 0v1H7V3a1 1 0 0 0-2 0v1H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"
				}))),
				fe = s("./src/reddit/icons/svgs/Gild/index.tsx"),
				xe = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M15.5,7.75 L12.5,7.75 C12.224,7.75 12,7.526 12,7.25 C12,6.974 12.224,6.75 12.5,6.75 L15.5,6.75 C15.776,6.75 16,6.974 16,7.25 C16,7.526 15.776,7.75 15.5,7.75 Z M15.5,10.5 L12.5,10.5 C12.224,10.5 12,10.276 12,10 C12,9.724 12.224,9.5 12.5,9.5 L15.5,9.5 C15.776,9.5 16,9.724 16,10 C16,10.276 15.776,10.5 15.5,10.5 Z M15.5,13.25 L4.5,13.25 C4.224,13.25 4,13.026 4,12.75 C4,12.474 4.224,12.25 4.5,12.25 L15.5,12.25 C15.776,12.25 16,12.474 16,12.75 C16,13.026 15.776,13.25 15.5,13.25 Z M4.5,16 C4.224,16 4,15.776 4,15.5 C4,15.224 4.224,15 4.5,15 L15.5,15 C15.776,15 16,15.224 16,15.5 C16,15.776 15.776,16 15.5,16 L4.5,16 Z M4,4.5 C4,4.224 4.224,4 4.5,4 L9.813,4 C10.089,4 10.313,4.224 10.313,4.5 L10.313,10 C10.313,10.276 10.089,10.5 9.813,10.5 L4.5,10.5 C4.224,10.5 4,10.276 4,10 L4,4.5 Z M3,2 C2.447,2 2,2.447 2,3 L2,17 C2,17.553 2.447,18 3,18 L17,18 C17.553,18 18,17.553 18,17 L18,3 C18,2.447 17.553,2 17,2 L3,2 Z"
				}))),
				Ee = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 10 10"
				}, r.a.createElement("path", {
					d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M6.2103,5.78636 C6.3275,5.90356 6.3275,6.09356 6.2103,6.21076 C6.1519,6.26916 6.0751,6.29836 5.9983,6.29836 C5.9211,6.29836 5.8447,6.26916 5.7859,6.21076 L4.9983,5.42276 L4.2103,6.21076 C4.1519,6.26916 4.0751,6.29836 3.9983,6.29836 C3.9211,6.29836 3.8447,6.26916 3.7859,6.21076 C3.6687,6.09356 3.6687,5.90356 3.7859,5.78636 L4.5739,4.99836 L3.7859,4.21076 C3.6687,4.09356 3.6687,3.90356 3.7859,3.78636 C3.9031,3.66916 4.0931,3.66916 4.2103,3.78636 L4.9983,4.57436 L5.7859,3.78636 C5.9031,3.66916 6.0931,3.66916 6.2103,3.78636 C6.3275,3.90356 6.3275,4.09356 6.2103,4.21076 L5.4223,4.99836 L6.2103,5.78636 Z M7.4023,2.59436 C6.0767,1.26836 3.9195,1.26916 2.5939,2.59436 C1.2687,3.91996 1.2687,6.07716 2.5939,7.40276 C3.2567,8.06556 4.1275,8.39676 4.9983,8.39676 C5.8687,8.39676 6.7395,8.06556 7.4023,7.40276 C8.7279,6.07716 8.7279,3.91996 7.4023,2.59436 Z"
				})),
				ve = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 10 10"
				}, r.a.createElement("path", {
					d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M8.0828,3.27736 L7.5232,2.71736 C7.448,2.64216 7.3464,2.60016 7.2404,2.60016 C7.134,2.60016 7.0324,2.64216 6.9576,2.71736 L4.16,5.51456 L3.0428,4.39736 C2.8868,4.24096 2.6336,4.24096 2.4772,4.39736 L1.9172,4.95736 C1.7608,5.11376 1.7608,5.36696 1.9172,5.52296 L3.8772,7.48296 C3.9556,7.56096 4.0576,7.60016 4.16,7.60016 C4.2624,7.60016 4.3648,7.56096 4.4428,7.48296 L8.0828,3.84296 C8.2392,3.68656 8.2392,3.43376 8.0828,3.27736 Z"
				})),
				Ce = s("./src/reddit/icons/svgs/Redditor/index.tsx"),
				_e = s("./src/reddit/icons/svgs/Settings/index.tsx"),
				ke = s("./src/reddit/icons/svgs/Tag/index.tsx"),
				Oe = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M13.8711,6 L5.8711,6 C5.5951,6 5.3711,5.776 5.3711,5.5 C5.3711,5.224 5.5951,5 5.8711,5 L13.8711,5 C14.1471,5 14.3711,5.224 14.3711,5.5 C14.3711,5.776 14.1471,6 13.8711,6 M13.8711,9 L5.8711,9 C5.5951,9 5.3711,8.776 5.3711,8.5 C5.3711,8.224 5.5951,8 5.8711,8 L13.8711,8 C14.1471,8 14.3711,8.224 14.3711,8.5 C14.3711,8.776 14.1471,9 13.8711,9 M13.8711,12 L5.8711,12 C5.5951,12 5.3711,11.776 5.3711,11.5 C5.3711,11.224 5.5951,11 5.8711,11 L13.8711,11 C14.1471,11 14.3711,11.224 14.3711,11.5 C14.3711,11.776 14.1471,12 13.8711,12 M13.8711,15 L5.8711,15 C5.5951,15 5.3711,14.776 5.3711,14.5 C5.3711,14.224 5.5951,14 5.8711,14 L13.8711,14 C14.1471,14 14.3711,14.224 14.3711,14.5 C14.3711,14.776 14.1471,15 13.8711,15 M16.0001,2 L4.0001,2 C3.4471,2 3.0001,2.448 3.0001,3 L3.0001,17 C3.0001,17.552 3.4471,18 4.0001,18 L16.0001,18 C16.5531,18 17.0001,17.552 17.0001,17 L17.0001,3 C17.0001,2.448 16.5531,2 16.0001,2"
				}))),
				ye = s("./src/reddit/models/Comment/index.ts"),
				je = s("./src/reddit/models/Post/index.ts"),
				we = s("./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less"),
				Se = s.n(we);
			const Ie = e => {
					let {
						action: t,
						urlPath: s
					} = e;
					const n = (e => {
							switch (e) {
								case "ALL_ACTIONS":
									return;
								case "ADD_CONTRIBUTOR":
								case "ADD_MODERATOR":
									return {
										type: k.REDDITOR, treatment: O.POSITIVE
									};
								case "BAN_USER":
								case "MUTE_USER":
								case "REMOVE_CONTRIBUTOR":
								case "REMOVE_MODERATOR":
									return {
										type: k.REDDITOR, treatment: O.NEGATIVE
									};
								case "CREATE_AWARD":
								case "MOD_AWARD_GIVEN":
									return {
										type: k.AWARD, treatment: O.POSITIVE
									};
								case "DELETE_AWARD":
								case "DISABLE_AWARD":
								case "HIDDEN_AWARD":
									return {
										type: k.AWARD, treatment: O.NEGATIVE
									};
								case "ACCEPT_MODERATOR_INVITE":
								case "INVITE_MODERATOR":
								case "SET_PERMISSIONS":
								case "UNBAN_USER":
								case "UNINVITE_MODERATOR":
								case "UNMUTE_USER":
									return {
										type: k.REDDITOR, treatment: O.NONE
									};
								case "APPROVE_COMMENT":
								case "SHOW_COMMENT":
									return {
										type: k.COMMENT, treatment: O.POSITIVE
									};
								case "REMOVE_COMMENT":
								case "SPAM_COMMENT":
									return {
										type: k.COMMENT, treatment: O.NEGATIVE
									};
								case "EDIT_FLAIR":
									return {
										type: k.FLAIR, treatment: O.NONE
									};
								case "APPROVE_LINK":
									return {
										type: k.POST, treatment: O.POSITIVE
									};
								case "REMOVE_LINK":
								case "SPAM_LINK":
									return {
										type: k.POST, treatment: O.NEGATIVE
									};
								case "LOCK":
								case "MARK_NSFW":
								case "MARK_ORIGINAL_CONTENT":
								case "SET_CONTEST_MODE":
								case "SET_SUGGESTEDSORT":
								case "SPOILER":
								case "UNLOCK":
								case "UNSET_CONTEST_MODE":
								case "UNSPOILER":
									return {
										type: k.POST, treatment: O.NONE
									};
								case "DISTINGUISH":
								case "IGNORE_REPORTS":
								case "STICKY":
								case "UNIGNORE_REPORTS":
								case "UNSTICKY":
									return {
										type: k.MULTIPLE, treatment: O.NONE
									};
								case "ADD_COMMUNITY_TOPICS":
								case "REMOVE_COMMUNITY_TOPICS":
								case "COMMUNITY_STYLING":
								case "COMMUNITY_WIDGETS":
								case "CREATE_RULE":
								case "DELETE_RULE":
								case "EDIT_RULE":
								case "REORDER_RULES":
								case "EDIT_SETTINGS":
								case "MODMAIL_ENROLLMENT":
									return {
										type: k.SETTINGS, treatment: O.NONE
									};
								case "REMOVE_WIKI_CONTRIBUTOR":
								case "WIKI_BANNED":
									return {
										type: k.WIKI, treatment: O.NEGATIVE
									};
								case "WIKI_CONTRIBUTOR":
								case "WIKI_PAGE_LISTED":
								case "WIKI_PERM_LEVEL":
								case "WIKI_REVISE":
								case "WIKI_UNBANNED":
									return {
										type: k.WIKI, treatment: O.NONE
									};
								case "COLLECTIONS":
									return {
										type: k.COLLECTION, treatment: O.NONE
									};
								case "EVENTS":
									return {
										type: k.EVENT, treatment: O.NONE
									};
								case "CREATE_SCHEDULED_POST":
								case "EDIT_SCHEDULED_POST":
								case "DELETE_SCHEDULED_POST":
								case "SUBMIT_SCHEDULED_POST":
									return {
										type: k.POST, treatment: O.NONE
									};
								default:
									Object(pe.a)(e)
							}
						})(t.action),
						o = t.target && t.target.__typename,
						a = o === ye.b.Comment || ye.b.DeletedComment;
					let i;
					switch (n && n.type) {
						case k.AWARD:
							i = r.a.createElement(fe.a, {
								className: Se.a.icon
							});
							break;
						case k.COMMENT:
							i = r.a.createElement(be.a, null);
							break;
						case k.FLAIR:
							i = r.a.createElement(ke.a, {
								className: Se.a.icon
							});
							break;
						case k.POST:
							i = r.a.createElement(xe, {
								className: Se.a.icon
							});
							break;
						case k.REDDITOR:
							i = r.a.createElement(Ce.a, {
								className: Se.a.icon
							});
							break;
						case k.SETTINGS:
							i = r.a.createElement(_e.a, {
								className: Se.a.icon
							});
							break;
						case k.WIKI:
							i = r.a.createElement(Oe, {
								className: Se.a.icon
							});
							break;
						case k.COLLECTION:
							i = r.a.createElement(he, {
								className: Se.a.icon
							});
							break;
						case k.EVENT:
							i = r.a.createElement(ge, {
								className: Se.a.icon
							});
							break;
						case k.MULTIPLE:
							a && (i = r.a.createElement(be.a, null)), o === je.f.SubredditPost && (i = r.a.createElement(xe, {
								className: Se.a.icon
							}))
					}
					const d = C[t.action];
					return r.a.createElement(y.a, {
						className: Se.a.actionLink,
						to: s
					}, r.a.createElement("span", {
						className: Se.a.iconWrapper
					}, i, n && n.treatment === O.POSITIVE ? r.a.createElement(ve, {
						className: Se.a.positiveTreatment
					}) : n && n.treatment === O.NEGATIVE ? r.a.createElement(Ee, {
						className: Se.a.negativeTreatment
					}) : null), d && d())
				},
				Pe = e => {
					let {
						action: t
					} = e;
					const s = t.target && t.target.__typename;
					let n, o, a, i = t.target;
					switch (s) {
						case je.f.SubredditPost:
							n = (i = i).authorInfo && i.authorInfo.__typename === ue.c.AvailableRedditor && i.authorInfo.name || null, o = i.title, a = i.permalink;
							break;
						case je.f.DeletedSubredditPost:
							n = null, o = (i = i).title, a = i.permalink;
							break;
						case ue.c.AvailableRedditor:
							n = (i = i) && i.name || null, o = null;
							break;
						case ye.b.Comment:
							n = (i = i).authorInfo && i.authorInfo.__typename === ue.c.AvailableRedditor && i.authorInfo.name || null, o = i.content && i.content.markdown, a = i.permalink;
							break;
						case ye.b.DeletedComment:
							n = null, o = (i = i).postInfo && i.postInfo.title, a = i.postInfo && i.postInfo.permalink;
							break;
						default:
							n = null, o = null, a = void 0
					}
					let d = t.details;
					_[t.details] && (d = t.details && _[t.details]());
					let l = t.actionNotes || d;
					return t.actionNotes && d && (l = "".concat(d, ": ").concat(t.actionNotes)), r.a.createElement("div", {
						className: Se.a.detailsContainer
					}, n && !E.includes(n) ? r.a.createElement(ce.a, {
						tooltipId: "userlink-".concat(t.id),
						user: n,
						sendHoverCardEvent: ie.a
					}, r.a.createElement(le.a, {
						className: Se.a.usernameLink,
						author: n
					}, "u/".concat(n))) : n, o && a && r.a.createElement("a", {
						className: Se.a.detailsContent,
						target: "_blank",
						rel: "noopener noreferrer",
						href: a
					}, o), l && r.a.createElement("span", {
						className: Se.a.detailsType
					}, "(".concat(l, ")")))
				},
				Te = "mod-log-timestamp-";
			class Ne extends r.a.Component {
				constructor() {
					super(...arguments), this.createTimestamp = e => {
						return new Date(e).toString()
					}, this.getTooltipId = e => "".concat(Te).concat(e), this.getActionModeratorName = e => e && e.__typename === ue.c.AvailableRedditor ? e.name : null
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						moderator: s,
						onHideTooltip: n,
						onShowTooltip: o
					} = this.props, a = this.getTooltipId(e.id), i = this.getActionModeratorName(e.moderator);
					return r.a.createElement("tr", {
						className: Se.a.row
					}, r.a.createElement("td", null, r.a.createElement("span", {
						id: a,
						onMouseEnter: () => o(a),
						onMouseLeave: n,
						className: Se.a.tooltip
					}, Object(de.d)(e.createdAt / 1e3), r.a.createElement(me.c, {
						className: Se.a.createdAtTooltip,
						tooltipId: a,
						text: this.createTimestamp(e.createdAt)
					}))), r.a.createElement("td", {
						className: Se.a.modNameCell
					}, i && !E.includes(i) ? r.a.createElement(ce.a, {
						tooltipId: "modlink-".concat(e.id),
						user: i,
						sendHoverCardEvent: ie.a
					}, r.a.createElement(le.a, {
						author: i,
						className: Se.a.usernameLink
					}, i)) : i), r.a.createElement("td", null, r.a.createElement(Ie, {
						action: e,
						urlPath: S({
							currentPageUrl: t,
							action: e.action,
							moderator: s
						})
					})), r.a.createElement("td", null, r.a.createElement(Pe, {
						action: e
					})))
				}
			}
			var Me = Object(i.b)(null, e => ({
					onHideTooltip: () => e(Object(f.i)()),
					onShowTooltip: t => e(Object(f.f)({
						tooltipId: t
					}))
				}))(Ne),
				Re = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				Le = s("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				Ae = s("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				Fe = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				De = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				Be = s("./src/reddit/constants/parameters.ts"),
				Ue = s("./src/reddit/contexts/PageLayer/index.tsx"),
				He = s("./src/reddit/components/ModerationLog/index.m.less"),
				We = s.n(He);
			const Ve = Object(Ue.t)({
					currentPageUrl: Ue.e,
					queryParams: Ue.S
				}),
				qe = Object(d.c)({
					actionsList: H,
					endCursor: W,
					nextPage: (e, t) => {
						let {
							subredditId: s
						} = t;
						return e.moderationLog.hasNextPage[s]
					},
					previousPage: (e, t) => {
						let {
							subredditId: s
						} = t;
						return e.moderationLog.hasPreviousPage[s]
					},
					startCursor: V
				}),
				Ge = Object(i.b)(qe, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						fetchAllModerators: () => e((e => async (t, s, n) => {
							let {
								gqlContext: o
							} = n;
							const a = s(),
								r = Object(u.F)(a, e);
							if (a.moderationLog.moderators[r]) return;
							const i = await Object(c.b)(o(), e);
							if (i.body) {
								const e = i.body.data.subreddit.moderators;
								if (e) {
									const s = Object(m.a)(e);
									t(b({
										normalizedModerators: s,
										subredditId: r
									}))
								}
							}
						})(s.name))
					}
				});
			class Ke extends r.a.Component {
				componentDidMount() {
					"complete" === document.readyState ? this.props.fetchAllModerators() : window.addEventListener("load", this.props.fetchAllModerators)
				}
				render() {
					const {
						actionsList: e,
						currentPageUrl: t,
						endCursor: s,
						nextPage: a,
						previousPage: i,
						queryParams: d,
						startCursor: l,
						subredditId: c
					} = this.props, m = d[Be.n] || null, u = d[Be.m] || null, p = {
						currentPageUrl: t,
						action: m,
						moderator: u,
						startCursor: l
					}, b = {
						currentPageUrl: t,
						endCursor: s,
						action: m,
						moderator: u
					};
					return r.a.createElement(Fe.a, {
						className: We.a.contentContainer
					}, r.a.createElement(Fe.b, null, o.fbt._("Mod log", null, {
						hk: "UdwRO"
					}), r.a.createElement(Re.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360022402312")
					})), r.a.createElement(De.a, null, r.a.createElement("span", {
						className: We.a.title
					}, o.fbt._("Filter by", null, {
						hk: "3RkGvd"
					})), r.a.createElement(ae, {
						action: m,
						currentPageUrl: t,
						moderator: u,
						subredditId: c
					}), r.a.createElement(Ae.a, {
						prevButtonEnabled: i,
						prevTo: S(p),
						nextButtonEnabled: a,
						nextTo: S(b)
					})), r.a.createElement("table", {
						className: We.a.table
					}, r.a.createElement("thead", null, r.a.createElement("tr", null, r.a.createElement("th", {
						className: We.a.timeColHeader
					}, o.fbt._("time", null, {
						hk: "1EnamY"
					})), r.a.createElement("th", {
						className: We.a.modNameColHeader
					}, o.fbt._("moderator", null, {
						hk: "22lRDF"
					})), r.a.createElement("th", {
						className: We.a.actionNameColHeader
					}, r.a.createElement("span", {
						className: We.a.tooltip
					}, o.fbt._("action", null, {
						hk: "243Ltb"
					}), r.a.createElement(Le.a, {
						className: We.a.actionTooltip
					}, r.a.createElement("div", {
						className: We.a.actionTooltipDescription
					}, o.fbt._("Actions performed within your community", null, {
						hk: "3RTNED"
					})), r.a.createElement("div", {
						className: We.a.allIconsContainer
					}, r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(xe, {
						className: We.a.icon
					}), o.fbt._("Post", null, {
						hk: "9rK7i"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(be.a, null), o.fbt._("Comment", null, {
						hk: "1N3Vo2"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(ke.a, {
						className: We.a.icon
					}), o.fbt._("Flair", null, {
						hk: "roX9r"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(Oe, {
						className: We.a.icon
					}), o.fbt._("Wiki", null, {
						hk: "27Czfb"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(Ce.a, {
						className: We.a.icon
					}), o.fbt._("User management", null, {
						hk: "NIFnh"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(_e.a, {
						className: We.a.icon
					}), o.fbt._("Community settings", null, {
						hk: "139FAy"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(he, {
						className: We.a.icon
					}), o.fbt._("Collection", null, {
						hk: "3a6W4E"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(ge, {
						className: We.a.icon
					}), o.fbt._("Event", null, {
						hk: "2odtv8"
					})), r.a.createElement("div", {
						className: We.a.iconContainer
					}, r.a.createElement(fe.a, {
						className: We.a.icon
					}), o.fbt._("Award", null, {
						hk: "1wcAOA"
					})))))), r.a.createElement("th", null, r.a.createElement("span", {
						className: We.a.tooltip
					}, o.fbt._("details", null, {
						hk: "1hCsar"
					}), r.a.createElement(Le.a, {
						text: o.fbt._("Displays the author, post or comment link, and any additional information", null, {
							hk: "1EN2HF"
						})
					}))))), r.a.createElement("tbody", null, e.map(e => r.a.createElement(Me, {
						key: e.id,
						action: e,
						currentPageUrl: t,
						moderator: u
					})))), r.a.createElement("div", {
						className: We.a.bottomBarRow
					}, r.a.createElement(Ae.a, {
						prevButtonEnabled: i,
						prevTo: S(p),
						nextButtonEnabled: a,
						nextTo: S(b)
					})))
				}
			}
			t.a = Ve(Ge(Ke))
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.m.less": function(e, t, s) {
			e.exports = {
				NoResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				noResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				NoResultsText: "_3V0T64xptTp5xLaY-1nsaz",
				noResultsText: "_3V0T64xptTp5xLaY-1nsaz"
			}
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			})), s.d(t, "b", (function() {
				return l
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/lessComponent.tsx"),
				r = s("./src/reddit/components/ModerationPagesEmptyList/index.m.less"),
				i = s.n(r);
			const d = a.a.div("NoResultsContainer", i.a),
				l = a.a.div("NoResultsText", i.a);
			t.c = e => {
				const {
					childrenPosition: t = "top"
				} = e;
				return o.a.createElement(d, {
					className: e.className
				}, "top" === t && e.children, o.a.createElement(l, null, e.text), "bottom" === t && e.children)
			}
		},
		"./src/reddit/components/ModerationPrompts/Prompt.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return h
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = s("./src/reddit/actions/post.ts"),
				l = s("./src/reddit/actions/reportFlow.ts"),
				c = s("./src/reddit/components/Popup/index.tsx"),
				m = s("./src/reddit/components/Popup/Button.tsx"),
				u = s("./src/reddit/helpers/trackers/reportPrompt.ts"),
				p = s("./src/reddit/hooks/useTracking.ts"),
				b = s("./src/reddit/components/ModerationPrompts/useActivePromptId.ts");

			function h(e) {
				const {
					subredditName: t,
					post: s,
					isOverlay: h
				} = e, [g, f] = Object(o.useState)(!0), x = Object(b.b)(s.id, h), E = Object(r.c)(), v = Object(p.a)(), C = Object(b.a)(s, h), _ = (e, n) => v(Object(u.a)(t, s.id, e, n));
				Object(o.useEffect)(() => {
					C && _("modal", "show")
				}, [C]);
				if (!C || !g) return null;
				const k = n.fbt._("Help r/{subredditName} mods", [n.fbt._param("subredditName", t)], {
					hk: "1rusN4"
				});
				return a.a.createElement(c.a, {
					id: x,
					title: k,
					onClose: () => {
						f(!1), _("close", "click"), E(Object(d.J)()), E(Object(d.U)({
							[s.id]: {
								moderationPrompt: void 0
							}
						}))
					},
					onClickOutside: () => {
						E(Object(d.J)())
					}
				}, a.a.createElement("p", null, n.fbt._("Report this post if it's breaking {=Reddit} or {=community} rules.", [n.fbt._param("=Reddit", a.a.createElement("a", {
					href: "https://www.redditinc.com/policies/content-policy",
					target: "_blank",
					rel: "noopener noreferrer"
				}, n.fbt._("Reddit", null, {
					hk: "4g8g4O"
				}))), n.fbt._param("=community", a.a.createElement(i.a, {
					to: "/r/".concat(t, "/about/rules"),
					target: "_blank"
				}, n.fbt._("community", null, {
					hk: "1cy8jU"
				})))], {
					hk: "sfngx"
				})), a.a.createElement(m.a, {
					onClick: () => (f(!1), _("report", "click"), void E(Object(l.j)(s.id)))
				}, n.fbt._("Report", null, {
					hk: "4oVcnd"
				})))
			}
		},
		"./src/reddit/components/ModerationPrompts/Survey.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return g
			}));
			var n, o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = s("./src/reddit/actions/post.ts"),
				c = s("./src/reddit/actions/reportFlow.ts"),
				m = s("./src/reddit/components/Popup/index.tsx"),
				u = s("./src/reddit/components/Popup/Button.tsx"),
				p = s("./src/reddit/helpers/trackers/reportPrompt.ts"),
				b = s("./src/reddit/hooks/useTracking.ts"),
				h = s("./src/reddit/components/ModerationPrompts/useActivePromptId.ts");

			function g(e) {
				const {
					subredditName: t,
					post: s,
					isOverlay: g
				} = e, [f, x] = Object(a.useState)(n.Survey), E = Object(h.b)(s.id, g), v = Object(i.c)(), C = Object(b.a)(), _ = Object(h.a)(s, g), k = (e, n) => C(Object(p.b)(t, s.id, e, n));
				Object(a.useEffect)(() => {
					_ && k("modal", "show")
				}, [_]);
				const O = e => {
					x(n.Closed), k("site" === e ? "breaks_reddit_rules" : "breaks_community_rules", "click"), v(Object(c.j)(s.id, void 0, void 0, e))
				};
				if (!_) return null;
				let y = null;
				const j = {
					id: E,
					title: o.fbt._("Why did you downvote this post?", null, {
						hk: "2tTiIx"
					}),
					onClose: () => {
						x(n.Closed), k("close", "click"), v(Object(l.J)())
					},
					onClickOutside: () => {
						v(Object(l.J)())
					}
				};
				switch (f) {
					case n.Survey:
						y = r.a.createElement(m.a, j, r.a.createElement("p", null, o.fbt._("Your answer helps r/ {subredditName} mods improve this community.", [o.fbt._param("subredditName", t)], {
							hk: "DNEel"
						})), r.a.createElement(u.a, {
							onClick: () => {
								x(n.OffTopic), k("off_topic", "click")
							}
						}, o.fbt._("It's off topic", null, {
							hk: "4iG26l"
						})), r.a.createElement(u.a, {
							onClick: () => {
								x(n.DontLike), k("dont_like", "click")
							}
						}, o.fbt._("I don't like it", null, {
							hk: "1jB1Mh"
						})), r.a.createElement(u.a, {
							onClick: () => {
								x(n.BreaksRules), k("breaks_rules", "click")
							}
						}, o.fbt._("It breaks the rules", null, {
							hk: "1yQBhi"
						})));
						break;
					case n.OffTopic:
						y = r.a.createElement(m.a, j, r.a.createElement("p", null, o.fbt._("Got it. Thanks for helping out this community.", null, {
							hk: "22pTV3"
						})));
						break;
					case n.DontLike:
						y = r.a.createElement(m.a, j, r.a.createElement("p", null, o.fbt._("Just a reminder, it’s not an official rule but it is considered improper Reddiquette to downvote an otherwise acceptable post because you don’t personally like it.", null, {
							hk: "3mRvPM"
						})));
						break;
					case n.BreaksRules:
						y = r.a.createElement(m.a, j, r.a.createElement("p", null, o.fbt._("Let us know if it breaks {=Reddit} or {=community} rules.", [o.fbt._param("=Reddit", r.a.createElement("a", {
							href: "https://www.redditinc.com/policies/content-policy",
							target: "_blank",
							rel: "noopener noreferrer"
						}, o.fbt._("Reddit", null, {
							hk: "1amvzD"
						}))), o.fbt._param("=community", r.a.createElement(d.a, {
							to: "/r/".concat(t, "/about/rules"),
							target: "_blank"
						}, o.fbt._("community", null, {
							hk: "2TnSrt"
						})))], {
							hk: "1mXxTX"
						})), r.a.createElement(u.a, {
							onClick: () => O("site")
						}, o.fbt._("It breaks Reddit rules", null, {
							hk: "3MxBm9"
						})), r.a.createElement(u.a, {
							onClick: () => O("community")
						}, o.fbt._("It breaks community rules", null, {
							hk: "3XbHan"
						})));
						break;
					case n.Closed:
				}
				return y
			}! function(e) {
				e[e.Survey = 0] = "Survey", e[e.OffTopic = 1] = "OffTopic", e[e.DontLike = 2] = "DontLike", e[e.BreaksRules = 3] = "BreaksRules", e[e.Closed = 4] = "Closed"
			}(n || (n = {}))
		},
		"./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "TOhrvfHoucDPr36mCCzXd",
				titleFontH2: "_3brDTRw250hGX1o5_C0hbB",
				titleFontH3: "_1wry80KT9v8gZ-OR85HxZU",
				titleFontH4: "_3UyiSE-qM-508iK8v3J9VE",
				titleFontH5: "_1X7-zzcj5Xf8vTf2xtYjK5",
				titleFontH6: "_2o19XEin0G5ad6iDvABrhH",
				metadataFont: "_1IpedXmIlnKyWpICNENnHX",
				flairFont: "_17kIb-dmfAlFCaIsLz34ar",
				labelsFont: "_3IrRBgoth_MxadAqzwGE2p",
				actionFont: "_1F_YPbXlF7ItI0z0j2Kdvy",
				smallButtonFont: "Irj9r66tO2hdWqbJx-vWa",
				largeButtonFont: "_26FBjOBHlTgNO9o-fMxWOX",
				tabFont: "_1DLO-Qu2r3PHt-swAklwVx",
				strongTextFont: "_2umiFjo_kHT370YVhqkBUV",
				bodyFontH1: "czPuE4HoIQInpzrURaqrX",
				bodyFontH2: "_1RMqo3EKzteTfSdM5Q-OSg",
				bodyFontH3: "_1SHo5_8OixTqxTjJ466mw1",
				bodyFontH4: "_3_zdAqdo55tnx5RHhyuGVr",
				bodyFontH5: "_22jno3ihRm-Ef63KN0Wuxa",
				bodyFontH6: "_28OREyYTHZDHgLjcK4pt_d",
				bodyFont: "_38nKHi6IDujIOM7SuazWPd",
				bodyFontSmall: "_1lPuNthSPFYSROqTVgJlNG",
				bodyFontMono: "_3C9ynyJ6Z174Fb3-8O20xa",
				footer: "_1a_UtwKPW009WQq9JDInTY",
				checkbox: "hXaFasafnItuHCckiO50p",
				checkboxContainer: "_15zz-Q8aRGCDeqROyYsa6f",
				primaryButton: "h4QlBfFmd6UnAtiNaOhcR",
				ModalBody: "_2UK71LqBvNes-Kto-uSxfU",
				modalBody: "_2UK71LqBvNes-Kto-uSxfU",
				SecondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				secondaryText: "jJBOgTxr1pZp_VDUmHpJ3"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitePendingModal.m.less": function(e, t, s) {
			e.exports = {
				ModalText: "LuEOOX6cpsihxJHcF5aDv",
				modalText: "LuEOOX6cpsihxJHcF5aDv",
				ModalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				modalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				PrimaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				primaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				SecondaryButton: "_31o7G_2349tIzHKunBJEua",
				secondaryButton: "_31o7G_2349tIzHKunBJEua",
				Section: "K3DxSh_MxIy1lMkeHIPMc",
				section: "K3DxSh_MxIy1lMkeHIPMc",
				Image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				ModalMain: "_3Nec6X3UqKJgLUGDaw4NCq",
				modalMain: "_3Nec6X3UqKJgLUGDaw4NCq"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less": function(e, t, s) {
			e.exports = {
				ListTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				listTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				ListContainer: "_1IFQy3zyz-Lgs7iYZtQaPI",
				listContainer: "_1IFQy3zyz-Lgs7iYZtQaPI"
			}
		},
		"./src/reddit/components/ModeratorsList/Moderator.m.less": function(e, t, s) {
			e.exports = {
				PencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				pencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				TrashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				trashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				InteractiveDiv: "qaNZ40bbce8HBshNk04f0",
				interactiveDiv: "qaNZ40bbce8HBshNk04f0"
			}
		},
		"./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less": function(e, t, s) {
			e.exports = {
				PrimaryButton: "_3j2WCnh8ZjDRHIILJwKzkx",
				primaryButton: "_3j2WCnh8ZjDRHIILJwKzkx"
			}
		},
		"./src/reddit/components/ModeratorsList/index.m.less": function(e, t, s) {
			e.exports = {
				ListContainer: "_3s9PIWHO5f49Yj01FelAkk",
				listContainer: "_3s9PIWHO5f49Yj01FelAkk",
				SecondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				secondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				EditableTitle: "_1IBuDqoejky7tmj25quCUh",
				editableTitle: "_1IBuDqoejky7tmj25quCUh",
				UsersLoading: "_1oLmt3eyMItCQozx1nTk1E",
				usersLoading: "_1oLmt3eyMItCQozx1nTk1E"
			}
		},
		"./src/reddit/components/ModeratorsList/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/addQueryParams/index.ts"),
				c = s("./src/lib/lessComponent.tsx"),
				m = s("./src/lib/stripQueryParams/index.ts"),
				u = s("./src/reddit/actions/modal.ts"),
				p = s("./src/reddit/actions/subredditModeration.ts"),
				b = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				h = s("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				g = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				f = s("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				x = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				E = s("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				v = s("./src/reddit/contexts/PageLayer/index.tsx"),
				C = s("./src/reddit/controls/Button/index.tsx"),
				_ = s("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				k = s("./src/reddit/models/SubredditModeration/index.ts"),
				O = s("./src/reddit/selectors/activeModalId.ts"),
				y = s("./src/reddit/selectors/meta.ts"),
				j = s("./src/reddit/selectors/moderatorPermissions.ts"),
				w = s("./src/reddit/selectors/subredditModeration.ts"),
				S = s("./src/reddit/selectors/user.ts"),
				I = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/higherOrderComponents/asModal/index.tsx")),
				P = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				T = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				N = s("./src/reddit/controls/CheckboxWithLabel/index.tsx"),
				M = s("./src/reddit/controls/TextButton/index.tsx"),
				R = s("./src/reddit/helpers/isValidUsername/index.tsx"),
				L = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				A = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				F = s("./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less"),
				D = s.n(F);
			const B = e => {
					switch (e) {
						case A.c.all:
							return o.fbt._("Full Permissions", null, {
								hk: "DMhUW"
							});
						case A.c.access:
							return o.fbt._("Access", null, {
								hk: "1WHuWY"
							});
						case A.c.config:
							return o.fbt._("Config", null, {
								hk: "2puxZi"
							});
						case "chat_config":
						case A.c.chatConfig:
							return o.fbt._("Chat Config", null, {
								hk: "1QOA13"
							});
						case "chat_operator":
						case A.c.chatOperator:
							return o.fbt._("Chat Operator", null, {
								hk: "3nv6AR"
							});
						case A.c.flair:
							return o.fbt._("Flair", null, {
								hk: "16OIHu"
							});
						case A.c.mail:
							return o.fbt._("Mail", null, {
								hk: "4t8jDQ"
							});
						case A.c.posts:
							return o.fbt._("Posts", null, {
								hk: "v6V5n"
							});
						case A.c.wiki:
							return o.fbt._("Wiki", null, {
								hk: "3gSX65"
							});
						default:
							return o.fbt._("Full Permissions", null, {
								hk: "DMhUW"
							})
					}
				},
				U = Object(i.b)(null, (e, t) => {
					let {
						subredditId: s,
						after: n,
						before: o
					} = t;
					return {
						addModerator: (t, n) => e(Object(p.T)(s, t, n)),
						editModerator: (t, n, o) => e(Object(p.cb)(s, t, n, o)),
						removeModerator: t => e(Object(p.lb)(s, t, n, o))
					}
				}),
				H = c.a.span("SecondaryText", D.a),
				W = c.a.wrapped(P.d, "ModalBody", D.a);
			class V extends r.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.toggleSelect = (e, t) => {
						if (this.props.isEditingSelf) return;
						const s = Object.assign({}, this.state.permissions, {
							[e]: !t
						});
						"all" === e && s.all ? Object.keys(s).forEach(e => s[e] = !0) : s[e] || (s.all = !1), this.setState({
							permissions: s
						}), this.props.sendEventWithName("permission")()
					}, this.onSubmit = e => {
						e.preventDefault();
						const {
							props: t,
							state: s
						} = this;
						t.isEditingSelf ? t.toggleModal() : (t.isEditingPerms && t.user ? (t.editModerator(s.username, s.permissions, t.user.id), t.sendEventWithName("edit")()) : (t.addModerator(s.username, s.permissions), t.sendEventWithName("invite_moderator")()), t.toggleModal())
					}, this.onRemove = () => {
						this.props.user && (this.props.removeModerator(this.props.user.id), this.props.sendEventWithName("remove")()), this.props.toggleModal()
					}, this.state = {
						username: e.user ? e.user.username : "",
						permissions: e.user ? e.user.modPermissions : A.a
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = ["all", ...Object.keys(t.permissions).filter(e => "all" !== e)];
					return r.a.createElement(W, null, r.a.createElement(P.h, null, r.a.createElement(L.a, null, r.a.createElement(P.p, null, e.isEditingPerms ? o.fbt._("Edit", null, {
						hk: "1nftDt"
					}) : o.fbt._("Invite Moderators", null, {
						hk: "hkBh1"
					}), e.username && o.fbt._(": u/{username}", [o.fbt._param("username", e.username)], {
						hk: "2FWWEd"
					})), r.a.createElement(M.a, {
						onClick: e.toggleModal
					}, r.a.createElement(P.b, null)))), r.a.createElement("form", {
						onSubmit: this.onSubmit
					}, r.a.createElement(P.k, null, !e.isEditingPerms && r.a.createElement(P.g, null, r.a.createElement(T.d, {
						autoFocus: !0,
						placeholder: o.fbt._("Enter Username", null, {
							hk: "2fYsDe"
						}),
						onChange: this.onUsernameChange
					})), r.a.createElement(P.p, null, o.fbt._("Permissions", null, {
						hk: "GkHkd"
					}), e.isEditingSelf && r.a.createElement(H, null, o.fbt._("(can't edit)", null, {
						hk: "3LZvZi"
					}))), t.permissions && s.map((s, n) => r.a.createElement("div", {
						className: D.a.checkboxContainer,
						key: s
					}, r.a.createElement(N.a, {
						autoFocus: !(!e.isEditingPerms || 0 !== n) || void 0,
						className: D.a.checkbox,
						disabled: e.isEditingSelf,
						isSelected: t.permissions[s],
						onClick: () => this.toggleSelect(s, t.permissions[s]),
						text: B(s)
					})))), r.a.createElement(P.f, {
						className: D.a.footer
					}, r.a.createElement(C.f, {
						className: D.a.primaryButton,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(R.a)(t.username),
						type: "submit"
					}, e.isEditingPerms ? o.fbt._("Save", null, {
						hk: "3h5uV"
					}) : o.fbt._("Invite", null, {
						hk: "2F1syY"
					})), r.a.createElement(P.a, {
						autoFocus: !!e.isEditingSelf || void 0,
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.isEditingPerms && !e.isEditingSelf && r.a.createElement(P.r, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, o.fbt._("Remove", null, {
						hk: "2aiywk"
					})))))
				}
			}
			var q = Object(I.a)(U(V)),
				G = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				K = s("./src/reddit/components/TrackingHelper/index.tsx"),
				z = s("./src/reddit/selectors/telemetry.ts");
			const Q = e => t => Object.assign({
				source: "remove_mod_invite",
				action: "click",
				noun: e
			}, (e => ({
				screen: z.screen(e),
				subreddit: z.subreddit(e)
			}))(t));
			var J = s("./src/lib/constants/index.ts"),
				Z = s("./src/lib/timeAgo/index.ts"),
				X = s("./src/reddit/icons/svgs/Pencil/index.tsx"),
				Y = s("./src/reddit/icons/svgs/Trash/index.tsx"),
				$ = s("./src/reddit/components/ModeratorsList/Moderator.m.less"),
				ee = s.n($);
			const te = e => {
					const t = [],
						s = Object.keys(e);
					return e.all ? o.fbt._("Full Permissions", null, {
						hk: "YQ6uq"
					}) : (s.forEach((function(s) {
						e[s] && t.push(B(s))
					})), 0 === t.length ? o.fbt._("No permissions", null, {
						hk: "3eH05z"
					}) : t.join(", "))
				},
				se = c.a.wrapped(X.a, "PencilIcon", ee.a),
				ne = c.a.wrapped(Y.a, "TrashIcon", ee.a),
				oe = c.a.div("InteractiveDiv", ee.a),
				ae = e => r.a.createElement(oe, {
					onClick: e.onClick
				}, e.moderatorType === k.c.Editable ? r.a.createElement(se, null) : r.a.createElement(ne, null));
			var re = e => r.a.createElement(E.b, {
					additionalText: te(e.moderator.modPermissions),
					pageName: J.Pb.Moderators,
					primaryButton: e.moderatorType && e.onClick && r.a.createElement(ae, {
						onClick: e.onClick,
						moderatorType: e.moderatorType
					}),
					timeAgo: Object(Z.d)(e.moderator.moddedAtUTC),
					subredditId: e.subredditId,
					userIcon: e.moderator.accountIcon,
					username: e.moderator.username,
					moderatorType: e.moderatorType
				}),
				ie = s("./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less"),
				de = s.n(ie);
			const le = c.a.div("ListTitle", de.a),
				ce = c.a.div("ListContainer", de.a),
				me = Object(d.c)({
					invitedModeratorsList: w.s,
					isConfirmModalOpen: Object(O.b)("ModerationPage--Modal--RemoveModeratorConfirmation")
				});
			class ue extends r.a.Component {
				constructor(e) {
					super(e), this.onToggleRemovalModal = e => {
						this.setState({
							selectedModerator: e
						}), this.props.toggleConfirmUserActionModal(), e && this.props.sendEventWithName("remove_mod_invite")()
					}, this.state = {
						selectedModerator: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					if (0 === e.invitedModeratorsList.length) return null;
					const s = () => this.props.sendEvent(Q("cancel"));
					return r.a.createElement("div", null, r.a.createElement(le, null, o.fbt._("Invited moderators", null, {
						hk: "2UdpbF"
					})), r.a.createElement(ce, null, e.invitedModeratorsList.map(t => r.a.createElement(re, {
						key: t.id,
						moderator: t,
						moderatorType: k.c.Invited,
						onClick: () => this.onToggleRemovalModal(t),
						subredditId: e.subredditId
					}))), e.isConfirmModalOpen && t.selectedModerator && r.a.createElement(G.a, {
						actionText: o.fbt._("Remove", null, {
							hk: "nUCi0"
						}),
						modalText: o.fbt._("Are you sure you want to rescind the moderator invite to %{username}?", null, {
							hk: "AVoDm"
						}),
						onConfirm: () => e.removeInvitedModerator(t.selectedModerator.id),
						toggleModal: this.onToggleRemovalModal,
						onCancel: s,
						onClose: s,
						trackClick: () => this.props.sendEvent(Q("remove"))
					}))
				}
			}
			var pe = Object(i.b)(me, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						removeInvitedModerator: t => e(Object(p.kb)(s, t)),
						toggleConfirmUserActionModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveModeratorConfirmation"))
					}
				})(Object(K.c)(ue)),
				be = s("./src/reddit/components/ModeratorsList/InvitePendingModal.m.less"),
				he = s.n(be);
			const {
				fbt: ge
			} = s("./node_modules/fbt/lib/FbtPublic.js"), fe = Object(i.b)(null, (e, t) => {
				let {
					subredditId: s
				} = t;
				return {
					acceptInvite: () => e(Object(p.S)(s)),
					declineInvite: () => e(Object(p.bb)(s))
				}
			}), xe = c.a.wrapped(P.o, "ModalText", he.a), Ee = c.a.wrapped(xe, "ModalTextBold", he.a), ve = c.a.wrapped(C.f, "PrimaryButton", he.a), Ce = c.a.wrapped(C.i, "SecondaryButton", he.a), _e = c.a.div("Section", he.a), ke = c.a.img("Image", he.a), Oe = c.a.wrapped(P.k, "ModalMain", he.a);
			var ye = Object(I.a)(fe(e => r.a.createElement(P.d, null, r.a.createElement(Oe, null, r.a.createElement(L.a, null, r.a.createElement("div", null), r.a.createElement(M.a, {
					onClick: e.toggleModal
				}, r.a.createElement(P.b, null))), r.a.createElement(_e, null, r.a.createElement(ke, {
					src: "".concat(n.a.assetPath, "/img/snoo-success@2x.png")
				})), r.a.createElement(Ee, null, ge._("Congrats!", null, {
					hk: "T4Ccw"
				})), r.a.createElement(xe, null, ge._("You are invited to become a moderator!", null, {
					hk: "1jRLWz"
				}))), r.a.createElement(P.f, null, r.a.createElement(Ce, {
					onClick: t => {
						e.toggleModal(), e.declineInvite(), e.sendEventWithName("declineinvite")()
					},
					"data-redditstyle": !0
				}, ge._("Decline", null, {
					hk: "1iOsJe"
				})), r.a.createElement(ve, {
					onClick: t => {
						e.toggleModal(), e.acceptInvite(), e.sendEventWithName("acceptinvite")()
					},
					"data-redditstyle": !0
				}, ge._("Accept", null, {
					hk: "2fkYc4"
				})))))),
				je = s("./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less"),
				we = s.n(je);
			const {
				fbt: Se
			} = s("./node_modules/fbt/lib/FbtPublic.js"), Ie = Object(i.b)(null, (e, t) => {
				let {
					subredditId: s,
					userId: n,
					after: o,
					before: a
				} = t;
				return {
					removeModerator: () => e(Object(p.lb)(s, n, o, a))
				}
			}), Pe = c.a.wrapped(C.f, "PrimaryButton", we.a);
			class Te extends r.a.Component {
				constructor() {
					super(...arguments), this.onRemove = () => {
						this.props.removeModerator(), this.props.sendEventWithName("resign")(), this.props.toggleModal()
					}
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement(P.d, null, r.a.createElement(P.h, null, r.a.createElement(L.a, null, r.a.createElement(P.p, null, Se._("Leave as mod", null, {
						hk: "3ajWeG"
					})), r.a.createElement(M.a, {
						onClick: e.toggleModal
					}, r.a.createElement(P.b, null)))), r.a.createElement(P.k, null, r.a.createElement(P.o, null, Se._("Once you leave as a mod, you will lose mod permissions and will be unable to access any mod tools for this community. Are you sure you wish to leave as a mod of this community?", null, {
						hk: "4qm9md"
					}))), r.a.createElement(P.f, null, r.a.createElement(P.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Se._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(Pe, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, Se._("Leave", null, {
						hk: "2ZHZVX"
					}))))
				}
			}
			var Ne = Object(I.a)(Ie(Te)),
				Me = s("./src/reddit/components/ModeratorsList/index.m.less"),
				Re = s.n(Me);
			const Le = c.a.div("ListContainer", Re.a),
				Ae = c.a.wrapped(C.i, "SecondaryButton", Re.a),
				Fe = Object(v.t)({
					currentPageUrl: v.e
				}),
				De = Object(d.c)({
					currentUser: S.i,
					nextAfterToken: w.x,
					nextAfterEditableToken: w.p,
					nextBeforeToken: w.y,
					nextBeforeEditableToken: w.q,
					editableModerators: w.r,
					editableModeratorsList: w.o,
					isInvitePending: w.u,
					moderators: w.B,
					moderatorsList: w.w,
					moderatorPermissions: j.j,
					isAddUserModalOpen: Object(O.b)("ModerationPage--Modal--AddModerator"),
					isEditableListPending: w.n,
					isInvitePendingModalOpen: Object(O.b)("ModerationPage--Modal--InvitePending"),
					isModeratorListPending: w.v,
					isResignAsModeratorModalOpen: Object(O.b)("ModerationPage--Modal--Resign"),
					origin: y.l,
					searchPending: w.z,
					searchResult: w.A
				}),
				Be = Object(i.b)(De, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						searchForModerator: t => e(Object(p.gb)(s, t)),
						toggleAddModeratorModal: () => e(Object(u.i)("ModerationPage--Modal--AddModerator")),
						toggleInvitePendingModal: () => e(Object(u.i)("ModerationPage--Modal--InvitePending")),
						toggleResignAsModModal: () => e(Object(u.i)("ModerationPage--Modal--Resign"))
					}
				}),
				Ue = c.a.div("EditableTitle", Re.a),
				He = c.a.wrapped(E.a, "UsersLoading", Re.a);
			class We extends r.a.Component {
				constructor() {
					super(...arguments), this.state = k.a, this.toggleModal = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.isAddUserModalOpen || t || this.props.sendEventWithName("open_invite_dialog")(), this.props.toggleAddModeratorModal()
					}, this.onSearch = e => {
						this.props.searchForModerator(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.isButtonEnabled = (e, t) => !!(e && e.length > 0 && t), this.isModeratorsListPaginated = () => !(!this.props.nextBeforeToken && !this.props.nextAfterToken), this.renderEditableList = e => {
						const t = !(!e.nextBeforeEditableToken && !e.nextAfterEditableToken),
							s = e.isEditableListPending || e.isModeratorListPending;
						return r.a.createElement(r.a.Fragment, null, r.a.createElement(Ue, null, o.fbt._("You can edit these moderators", null, {
							hk: "1KTZtm"
						})), t && r.a.createElement(x.a, null, r.a.createElement(h.a, {
							prevButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextBeforeEditableToken),
							prevTo: Object(l.a)(Object(m.a)("".concat(e.origin).concat(e.currentPageUrl)), {
								before: e.before,
								beforeEditable: e.nextBeforeEditableToken,
								after: e.after
							}),
							nextButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextAfterEditableToken),
							nextTo: Object(l.a)(Object(m.a)("".concat(e.origin).concat(e.currentPageUrl)), {
								after: e.after,
								afterEditable: e.nextAfterEditableToken,
								before: e.before
							})
						})), r.a.createElement(Le, null, e.editableModeratorsList && e.editableModeratorsList.length > 0 ? e.editableModeratorsList.map(e => r.a.createElement(re, {
							key: e.id,
							moderator: e,
							moderatorType: k.c.Editable,
							onClick: this.toggleModal(e.id, e.username),
							subredditId: this.props.subredditId
						})) : s ? r.a.createElement(He, null) : null))
					}
				}
				componentDidMount() {
					this.props.isInvitePending && !this.props.isInvitePendingModalOpen && this.props.toggleInvitePendingModal()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = !!e.moderatorPermissions, a = Object(_.a)(e.moderatorPermissions);
					return r.a.createElement(r.a.Fragment, null, s && r.a.createElement(g.c, null, r.a.createElement(Ae, {
						onClick: e.toggleResignAsModModal
					}, o.fbt._("Leave as mod", null, {
						hk: "3TwqTg"
					})), a && r.a.createElement(C.f, {
						onClick: this.toggleModal(null, null)
					}, o.fbt._("Invite user as mod", null, {
						hk: "3lJRJW"
					}))), r.a.createElement(g.a, null, r.a.createElement(g.b, null, o.fbt._("Moderators of {subredditName}", [o.fbt._param("subredditName", e.subreddit.displayText)], {
						hk: "3p7NwA"
					}), r.a.createElement(b.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009381491")
					})), r.a.createElement(x.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}, !t.searchTerm && this.isModeratorsListPaginated() && r.a.createElement(h.a, {
						prevButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextBeforeToken),
						prevTo: Object(l.a)(Object(m.a)("".concat(e.origin).concat(e.currentPageUrl)), {
							afterEditable: e.afterEditable,
							before: e.nextBeforeToken,
							beforeEditable: e.beforeEditable
						}),
						nextButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextAfterToken),
						nextTo: Object(l.a)(Object(m.a)("".concat(e.origin).concat(e.currentPageUrl)), {
							after: e.nextAfterToken,
							afterEditable: e.afterEditable,
							beforeEditable: e.beforeEditable
						})
					})), t.searchTerm ? r.a.createElement(f.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && r.a.createElement(re, {
						moderator: e.searchResult,
						moderatorType: e.searchResult.isEditable ? k.c.Editable : void 0,
						onClick: e.searchResult.isEditable ? this.toggleModal(e.searchResult.id, e.searchResult.username) : void 0,
						subredditId: e.subredditId
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(Le, null, e.moderatorsList && e.moderatorsList.length > 0 ? e.moderatorsList.map(e => r.a.createElement(re, {
						key: e.id,
						moderator: e,
						subredditId: this.props.subredditId
					})) : e.isModeratorListPending ? r.a.createElement(He, null) : null), a && r.a.createElement(r.a.Fragment, null, this.renderEditableList(e), r.a.createElement(pe, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId
					})))), e.isAddUserModalOpen && r.a.createElement(q, {
						ignoreDefaultFocus: !0,
						after: e.afterEditable,
						before: e.beforeEditable,
						subredditId: e.subredditId,
						sendEventWithName: e.sendEventWithName,
						toggleModal: this.toggleModal(null, null),
						isEditingPerms: !!t.username,
						isEditingSelf: !(!t.userId || !e.currentUser) && t.userId === e.currentUser.id,
						username: t.username,
						user: t.userId && e.editableModerators ? e.editableModerators[t.userId] : null,
						withOverlay: !0
					}), e.currentUser && e.isResignAsModeratorModalOpen && r.a.createElement(Ne, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleResignAsModModal,
						userId: e.currentUser.id,
						withOverlay: !0
					}), e.isInvitePendingModalOpen && r.a.createElement(ye, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleInvitePendingModal,
						withOverlay: !0
					}))
				}
			}
			t.a = Fe(Be(We))
		},
		"./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less": function(e, t, s) {
			e.exports = {
				optionSearchBarContainer: "_3eVrzdp5khbz6W2NhQv7kl",
				optionSearchBarError: "_3va8RfTnDLBo2hfMm5URpu",
				optionSearchBarReadOnly: "_2siJVLOBn72IxBt8i_A1gZ",
				loadingIcon: "_3UsfWdV2CKiIs_EOeGhVxv",
				input: "_1OEtZmrYX2ct3ycV1AaUZS",
				hiddenInput: "_3WSlf55CAQYRdOxtxENgA7",
				optionsOverflowIndication: "_2qfFc8Ix-QpBqu8UNEXeH3"
			}
		},
		"./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less": function(e, t, s) {
			e.exports = {
				activeOption: "_2Kg5EXAuLcqhsBbdEr4SGZ",
				freeTextOption: "_2H29-4MOHAslt1eKYtcGaV",
				lastFixedOption: "_1ClyNNAK4vP9o_uoSwKe0Q",
				option: "_1xWVaijFIih7uj-n4FXzH2",
				availableOptionContainer: "T2jLhmuhOy8DeOHjz6WRG",
				addText: "_1OqThwyrfhl2eJ9YhWoy2I",
				optionsContainer: "_1ZmC1GBXYnksnMU9IrTAHd",
				relativeContainer: "_3SrGeaD5FxXfpWjhSAFBD-",
				dropdown: "_2dqCXnStO_Dc8Srt_lJqVj",
				dropdownHeaderText: "_2EaXrPilAtjz6VRh_xvOGU"
			}
		},
		"./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less": function(e, t, s) {
			e.exports = {
				selectedOptionComponentContainer: "_3nUaRUcJJfrvOWldA3i10S",
				closeIcon: "_1RvgsgnXdbtv2cwTTTbT7o",
				selectedOptionComponentContainerError: "_2Qpr0YORGp3CmDjJW9Txrf"
			}
		},
		"./src/reddit/components/MultiOptionSelect/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./node_modules/lodash/some.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/constants/keycodes.ts"),
				l = (s("./node_modules/core-js/modules/es6.symbol.js"), s("./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less")),
				c = s.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			class p extends r.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.handleOptionSelected(this.props.index)
					}, this.handleMouseEnter = () => {
						this.props.handleOnMouseEnter(this.props.index)
					}
				}
				shouldComponentUpdate(e) {
					return e.className !== this.props.className || e.divRef !== this.props.divRef || e.displayText !== this.props.displayText
				}
				render() {
					const e = this.props,
						{
							addText: t,
							displayText: s,
							divRef: n,
							handleOnMouseEnter: o,
							handleOptionSelected: a,
							index: d,
							className: l
						} = e,
						p = u(e, ["addText", "displayText", "divRef", "handleOnMouseEnter", "handleOptionSelected", "index", "className"]);
					return r.a.createElement("div", m({
						className: Object(i.a)(c.a.availableOptionContainer, l)
					}, p, {
						onMouseEnter: this.handleMouseEnter,
						onClick: this.handleClick,
						ref: n
					}), t && r.a.createElement("span", {
						className: c.a.addText
					}, t, " "), s)
				}
			}
			class b extends r.a.Component {
				constructor(e) {
					super(e), this.handleOptionSelectedByIndex = e => {
						this.props.selectableOptions[e] && this.handleOptionSelected(this.props.selectableOptions[e])
					}, this.handleFreeTextOptionSelected = () => {
						this.handleOptionSelected({
							id: null,
							displayText: this.props.currentInput,
							selected: !0
						})
					}, this.clearSelectedIndex = () => {
						this.setSelectedIndex(-1)
					}, this.setOptionActiveByIndex = e => {
						"number" == typeof e && e > -1 && this.setSelectedIndex(e)
					}, this.setFreeTextOptionActive = () => {
						this.setSelectedIndex(this.getOptionsLength() - 1)
					}, this.state = {
						selectedIndex: -1
					}, this.scrollContainer = r.a.createRef(), this.optionsContainer = r.a.createRef(), this.activeOptionDOMRef = r.a.createRef()
				}
				focus() {
					this.optionsContainer.current && this.optionsContainer.current.focus()
				}
				matchesDOMElement(e) {
					return this.optionsContainer.current === e
				}
				handleOptionSelected(e) {
					this.handleOptionsSelected([e])
				}
				handleOptionsSelected(e) {
					this.props.onOptionsChanged(e.map(e => Object.assign({}, e, {
						selected: !0
					})))
				}
				setSelectedIndex(e) {
					this.setState({
						selectedIndex: e
					})
				}
				freeTextEntryActive() {
					return this.props.allowFreeTextEntry && this.props.currentInput
				}
				getOptionsLength() {
					return this.freeTextEntryActive() ? this.props.selectableOptions.length + 1 : this.props.selectableOptions.length
				}
				freeTextOptionSelected() {
					return this.freeTextEntryActive() && this.state.selectedIndex === this.getOptionsLength() - 1
				}
				validOptionSelected() {
					return this.state.selectedIndex > -1 && this.state.selectedIndex < this.getOptionsLength()
				}
				handlePaste(e) {
					if (e.clipboardData.types.includes("text/plain")) return e.preventDefault(), e.stopPropagation(), void this.handleOptionsSelected(e.clipboardData.getData("text/plain").split(d.b.Comma).filter(e => !!e).map(e => ({
						id: null,
						displayText: e.trim(),
						selected: !0
					})))
				}
				handleKeyPress(e) {
					const {
						splitOnCommaPress: t
					} = this.props;
					return e.which === d.a.ArrowUp ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex - 1 > -1 ? this.state.selectedIndex - 1 : this.getOptionsLength() - 1)) : e.which === d.a.ArrowDown ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex + 1 < this.getOptionsLength() ? this.state.selectedIndex + 1 : 0)) : e.which === d.a.Comma && t ? (e.preventDefault(), e.stopPropagation(), this.handleFreeTextOptionSelected()) : e.which === d.a.Enter ? (e.preventDefault(), e.stopPropagation(), !this.validOptionSelected() || this.freeTextOptionSelected() ? this.handleFreeTextOptionSelected() : this.handleOptionSelected(this.props.selectableOptions[this.state.selectedIndex])) : void 0
				}
				componentDidUpdate() {
					if (!this.activeOptionDOMRef.current || !this.scrollContainer.current) return;
					const e = this.activeOptionDOMRef.current.getBoundingClientRect(),
						t = this.scrollContainer.current.getBoundingClientRect();
					if (e.top < t.top || e.bottom > t.bottom) {
						if (0 === this.state.selectedIndex) return void(this.scrollContainer.current.scrollTop = 0);
						if (e.top < t.top) return void(this.scrollContainer.current.scrollTop = this.activeOptionDOMRef.current.offsetTop);
						this.scrollContainer.current.scrollTop += e.bottom - t.bottom
					}
				}
				shouldRenderDropdownHeaderText() {
					return !!this.props.dropdownHeaderText && (!this.freeTextEntryActive() || this.props.selectableOptions.length > 0)
				}
				render() {
					return r.a.createElement("div", {
						className: c.a.relativeContainer
					}, r.a.createElement("div", {
						className: Object(i.a)(c.a.dropdown, this.props.className),
						ref: this.scrollContainer
					}, r.a.createElement("div", {
						ref: this.optionsContainer,
						tabIndex: -1,
						className: c.a.optionsContainer,
						onMouseOut: this.clearSelectedIndex
					}, this.shouldRenderDropdownHeaderText() && r.a.createElement("h3", {
						className: c.a.dropdownHeaderText
					}, this.props.dropdownHeaderText), this.props.selectableOptions.map((e, t) => {
						const s = [this.state.selectedIndex === t ? c.a.activeOption : c.a.option];
						return this.freeTextEntryActive() && t === this.props.selectableOptions.length - 1 && s.push(c.a.lastFixedOption), r.a.createElement(p, {
							key: e.id,
							className: Object(i.a)(...s),
							index: t,
							handleOptionSelected: this.handleOptionSelectedByIndex,
							handleOnMouseEnter: this.setOptionActiveByIndex,
							divRef: t === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
							displayText: e.displayText
						})
					}), this.freeTextEntryActive() && r.a.createElement(p, {
						key: "options-list-dropdown-free-text-option",
						className: Object(i.a)(c.a.freeTextOption, this.state.selectedIndex === this.getOptionsLength() - 1 ? c.a.activeOption : c.a.option),
						handleOptionSelected: () => this.handleFreeTextOptionSelected(),
						handleOnMouseEnter: this.setFreeTextOptionActive,
						divRef: this.getOptionsLength() - 1 === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
						addText: this.props.addText,
						displayText: this.props.currentInput
					}))))
				}
			}
			var h = s("./src/reddit/icons/svgs/Close/index.tsx"),
				g = s("./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less"),
				f = s.n(g);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var E = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			var v = e => {
					const {
						className: t,
						innerRef: s,
						onClickHandler: n,
						option: o,
						maxLength: a
					} = e, d = E(e, ["className", "innerRef", "onClickHandler", "option", "maxLength"]), l = [f.a.selectedOptionComponentContainer, t];
					return a && a < o.displayText.length && l.push(f.a.selectedOptionComponentContainerError), r.a.createElement("div", x({
						className: Object(i.a)(...l),
						ref: s
					}, d, {
						onClick: n
					}), o.displayText, r.a.createElement(h.a, {
						className: f.a.closeIcon
					}))
				},
				C = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				_ = s("./src/reddit/helpers/readOnlyMode/index.ts"),
				k = s("./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less"),
				O = s.n(k);

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const j = 10,
				w = e => e.stopPropagation();
			class S extends r.a.Component {
				constructor(e) {
					super(e), this.handleKeyPress = e => {
						e.which !== d.a.Delete && e.which !== d.a.Backspace || !this.lastSelectedOptionComponentRef.current || "" !== this.props.value || (this.lastSelectedOptionComponentRef.current.focus(), e.preventDefault(), e.stopPropagation())
					}, this.handleMouseEnterSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !0
						})
					}, this.handleMouseLeaveSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !1
						})
					}, this.onSearchBarFocus = e => {
						Object(_.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
							isFocused: !0
						}), this.props.onFocus && this.inputRef.current === e.target && this.props.onFocus())
					}, this.onSearchBarBlur = e => {
						if (this.containerRef.current && e.relatedTarget && this.containerRef.current.contains(e.relatedTarget)) return e.preventDefault(), void e.stopPropagation();
						this.props.onBlur && this.props.onBlur(e), this.setState({
							isFocused: !1
						})
					}, this.inputRef = r.a.createRef(), this.containerRef = r.a.createRef(), this.lastSelectedOptionComponentRef = r.a.createRef(), this.state = {
						isHoveringOverSelectedOption: !1,
						isFocused: !1
					}
				}
				focus() {
					Object(_.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
						isFocused: !0
					}))
				}
				reset() {
					this.inputRef.current && (this.inputRef.current.value = "")
				}
				deselectOption(e) {
					this.props.onOptionsChanged([Object.assign({}, e, {
						selected: !1
					})]), this.setState({
						isHoveringOverSelectedOption: !1
					})
				}
				onSelectedOptionComponentKeyDown(e, t) {
					this.state.isHoveringOverSelectedOption || e.which !== d.a.Delete && e.which !== d.a.Backspace || (e.preventDefault(), e.stopPropagation(), this.deselectOption(t), this.focus())
				}
				render() {
					const e = {};
					Object(_.c)(this.props.readOnlyMode) || (e.tabIndex = 0);
					const t = this.props.selectedOptionComponent || v,
						s = "number" == typeof this.props.maxOptionsToDisplay && this.props.options.length > this.props.maxOptionsToDisplay;
					return r.a.createElement("div", y({
						"aria-invalid": this.props.isError,
						className: Object(i.a)(this.props.className, O.a.optionSearchBarContainer, {
							[O.a.optionSearchBarError]: this.props.isError,
							[O.a.optionSearchBarReadOnly]: Object(_.c)(this.props.readOnlyMode)
						}),
						ref: this.containerRef,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur
					}, e), this.props.options.map((e, n) => {
						if (!(s && n >= (this.props.maxOptionsToDisplay || 0))) return r.a.createElement(t, {
							tabIndex: 0,
							onFocus: w,
							key: e.id || e.displayText,
							option: e,
							onKeyDown: t => this.onSelectedOptionComponentKeyDown(t, e),
							onClickHandler: () => {
								this.deselectOption(e), this.focus()
							},
							onMouseEnter: this.handleMouseEnterSelectedOptionComponent,
							onMouseLeave: this.handleMouseLeaveSelectedOptionComponent,
							maxLength: this.props.maxLength,
							innerRef: n === this.props.options.length - 1 ? this.lastSelectedOptionComponentRef : void 0
						})
					}), s && r.a.createElement("span", {
						className: O.a.optionsOverflowIndication
					}, "+".concat(this.props.options.length - (this.props.maxOptionsToDisplay || 0))), this.props.children, !Object(_.c)(this.props.readOnlyMode) && r.a.createElement("input", {
						className: Object(i.a)(O.a.input, {
							[O.a.hiddenInput]: Object(_.b)(this.props.readOnlyMode)
						}),
						ref: this.inputRef,
						type: "text",
						onKeyDown: this.handleKeyPress,
						value: this.props.value,
						onChange: this.props.onInputChanged,
						maxLength: this.props.maxLength
					}), this.props.isLoading && r.a.createElement(C.a, {
						className: O.a.loadingIcon,
						sizePx: j
					}), this.state.isFocused && r.a.createElement(b, {
						className: this.props.dropdownClassName,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						selectableOptions: this.props.selectableOptions,
						onOptionsChanged: this.props.onOptionsChanged,
						ref: this.props.dropdownRef,
						currentInput: this.props.value,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						splitOnCommaPress: this.props.splitOnCommaPress
					}))
				}
			}
			var I = s("./node_modules/reselect/es/index.js");
			const P = [],
				T = {};
			class N extends r.a.Component {
				constructor(e) {
					super(e), this._selectableOptionsSelector = Object(I.a)(e => e.availableOptions || P, e => e.input, (e, t) => e.filter(e => {
						const s = e.displayText.toLowerCase(),
							n = t.toLowerCase();
						return 0 === s.indexOf(n) || o()(s.split(/[\s\/]+/), e => 0 === e.indexOf(n))
					})), this.onSearchBarFocus = () => {
						Object(_.c)(this.props.readOnlyMode) || this.state.searchBarIsFocused || (this.setState({
							searchBarIsFocused: !0
						}), this.props.onSearchBarFocus && this.props.onSearchBarFocus())
					}, this.onSearchBarBlur = e => {
						if (!Object(_.c)(this.props.readOnlyMode)) return this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.matchesDOMElement(e.relatedTarget) ? (e.stopPropagation(), e.preventDefault(), void setTimeout(() => {
							this.optionSearchBarRef.current && this.optionSearchBarRef.current.focus()
						}, 0)) : (this.setState({
							searchBarIsFocused: !1
						}), void(this.props.onSearchBarBlur && this.props.onSearchBarBlur(e)))
					}, this.setInput = e => {
						Object(_.b)(this.props.readOnlyMode) || this.props.input !== e && this.props.onInputChanged(e)
					}, this.onOptionChanged = e => {
						this.onOptionsChanged([e])
					}, this.onOptionsChanged = e => {
						this.props.onOptionsChanged(e), o()(e, e => !!e.selected) && this.setInput("")
					}, this.onInputChanged = e => {
						Object(_.b)(this.props.readOnlyMode) || this.setInput(e.currentTarget.value)
					}, this.onKeyDown = e => {
						Object(_.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handleKeyPress(e)
					}, this.onPaste = e => {
						Object(_.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handlePaste(e)
					}, this.state = {
						searchBarIsFocused: !1
					}, this.optionsListDropdownRef = r.a.createRef(), this.optionSearchBarRef = r.a.createRef()
				}
				getSelectableOptions() {
					return this._selectableOptionsSelector(this.props)
				}
				render() {
					const {
						childClassNames: e = T
					} = this.props;
					return r.a.createElement("div", {
						className: this.props.className,
						onKeyDown: this.onKeyDown,
						onPaste: this.onPaste
					}, r.a.createElement(S, {
						className: e.searchBarClassName,
						dropdownClassName: e.optionsListDropdownClassName,
						isError: this.props.isError,
						readOnlyMode: this.props.readOnlyMode || _.a.editable,
						isLoading: this.props.isLoading,
						ref: this.optionSearchBarRef,
						options: this.props.selectedOptions,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur,
						onOptionsChanged: this.onOptionsChanged,
						onInputChanged: this.onInputChanged,
						maxLength: this.props.maxOptionLength,
						maxOptionsToDisplay: this.props.maxOptionsToDisplay,
						value: this.props.input,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						selectableOptions: this.getSelectableOptions(),
						dropdownRef: this.optionsListDropdownRef,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: this.props.splitOnCommaPress
					}, this.props.children))
				}
			}
			t.a = N
		},
		"./src/reddit/components/MutedUserList/ExpandedComponent.m.less": function(e, t, s) {
			e.exports = {
				BannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				bannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				EmptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				emptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				ExpandedContainer: "_1EEdKUOD4OiTBBQQkot-L9",
				expandedContainer: "_1EEdKUOD4OiTBBQQkot-L9"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less": function(e, t, s) {
			e.exports = {
				PrimaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				primaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				ModalText: "_3P1niYqJc2au-fmA-xIl7i",
				modalText: "_3P1niYqJc2au-fmA-xIl7i"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./src/higherOrderComponents/asModal/index.tsx"),
				d = s("./src/lib/lessComponent.tsx"),
				l = s("./src/reddit/actions/subredditModeration.ts"),
				c = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				p = s("./src/reddit/controls/Button/index.tsx"),
				b = s("./src/reddit/controls/TextButton/index.tsx"),
				h = s("./src/reddit/helpers/isValidUsername/index.tsx"),
				g = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				f = s("./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less"),
				x = s.n(f);
			const E = 300,
				v = Object(r.b)(null, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						onMuteUser: (t, n) => e(Object(l.hb)(s, t, n))
					}
				}),
				C = d.a.wrapped(p.f, "PrimaryButton", x.a),
				_ = d.a.wrapped(m.o, "ModalText", x.a);
			class k extends a.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onReasonChange = e => {
						this.setState({
							reason: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const e = this.state.username;
						this.props.onMuteUser(e, this.state.reason), this.props.trackAddEvent(), this.props.toggleModal()
					}, this.state = {
						username: this.props.username || "",
						reason: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(m.d, null, a.a.createElement(m.h, null, a.a.createElement(g.a, null, a.a.createElement(m.p, null, n.fbt._("Mute user", null, {
						hk: "326ljo"
					}), e.username && ": u/".concat(e.username)), a.a.createElement(b.a, {
						onClick: e.toggleModal
					}, a.a.createElement(m.b, null)))), a.a.createElement(m.k, null, !e.username && a.a.createElement(m.g, null, a.a.createElement(u.d, {
						autoFocus: !0,
						placeholder: n.fbt._("Username to mute", null, {
							hk: "3GB7UW"
						}),
						onChange: this.onUsernameChange,
						value: this.state.username,
						"data-redditstyle": !0
					})), a.a.createElement(m.g, null, a.a.createElement(_, null, n.fbt._("Note about why they are muted", null, {
						hk: "12YIn5"
					})), a.a.createElement(m.e, null, n.fbt._("Only visible to other moderators. Not visible to user", null, {
						hk: "4Ahum2"
					}))), a.a.createElement(m.s, {
						maxLength: E,
						onChange: this.onReasonChange,
						placeholder: n.fbt._("Reason they were muted", null, {
							hk: "3E29Hf"
						}),
						value: this.state.reason,
						"data-redditstyle": !0
					}), a.a.createElement(c.a, {
						maxChars: E,
						text: this.state.reason
					})), a.a.createElement(m.f, null, a.a.createElement(m.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, n.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(C, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(h.a)(t.username)
					}, n.fbt._("Mute user", null, {
						hk: "1z1Ss8"
					}))))
				}
			}
			t.default = Object(i.a)(v(k))
		},
		"./src/reddit/components/MutedUserList/index.m.less": function(e, t, s) {
			e.exports = {
				MuteIcon: "XHViv8EEjdjsATc3T66r9",
				muteIcon: "XHViv8EEjdjsATc3T66r9"
			}
		},
		"./src/reddit/components/MutedUserList/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/lessComponent.tsx"),
				m = s("./src/lib/timeAgo/index.ts"),
				u = s("./src/reddit/actions/modal.ts"),
				p = s("./src/reddit/actions/subredditModeration.ts"),
				b = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				g = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				x = s("./src/reddit/components/Scroller/Simple.tsx"),
				E = s("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				v = s("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				C = s("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				_ = s("./src/reddit/controls/Button/index.tsx"),
				k = s("./src/reddit/icons/svgs/Mute/index.tsx"),
				O = s("./src/reddit/models/SubredditModeration/index.ts"),
				y = s("./src/reddit/selectors/activeModalId.ts"),
				j = s("./src/reddit/selectors/subredditModeration.ts"),
				w = s("./src/reddit/components/MutedUserList/ExpandedComponent.m.less"),
				S = s.n(w);
			const {
				fbt: I
			} = s("./node_modules/fbt/lib/FbtPublic.js"), P = c.a.span("BannedBy", S.a), T = c.a.span("EmptyState", S.a), N = c.a.div("ExpandedContainer", S.a);
			var M = e => r.a.createElement(N, null, e.reason ? r.a.createElement(P, null, I._("Mod note {mutedByUsername}", [I._param("mutedByUsername", e.mutedBy)], {
					hk: "15D34v"
				})) : r.a.createElement(T, null, I._("No mod note.", null, {
					hk: "3rpIuv"
				})), e.reason),
				R = s("./src/reddit/components/MutedUserList/MuteUserModal/index.tsx"),
				L = s("./src/reddit/components/MutedUserList/index.m.less"),
				A = s.n(L);
			const F = 24,
				D = c.a.wrapped(k.a, "MuteIcon", A.a),
				B = Object(d.c)({
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(y.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(y.a)(e),
					loadMoreToken: j.E,
					mutedUsers: j.H,
					mutedUsersListPending: j.D,
					searchPending: j.F,
					searchResult: j.G
				}),
				U = Object(i.b)(B, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						loadMore: t => e(Object(p.ib)(s, {
							after: t
						})),
						searchForMutedUser: t => e(Object(p.jb)(s, t)),
						toggleAddUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser")),
						toggleUnmuteUserModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						unmuteUser: t => () => e(Object(p.ob)(s, t))
					}
				});
			class H extends r.a.Component {
				constructor(e) {
					super(e), this.onSearch = e => {
						this.props.searchForMutedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.unmuteToggled = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.sendEventWithName("edit_user")(), this.props.toggleUnmuteUserModal()
					}, this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.muteUser = () => {
						this.props.toggleAddUserModal(), this.props.sendEventWithName("mute_dialog_mutepage")()
					}, this.renderMutedUser = e => r.a.createElement(C.b, {
						description: e.reason,
						expandedComponent: r.a.createElement(M, {
							mutedBy: e.mutedBy,
							reason: e.reason
						}),
						pageName: l.Pb.Muted,
						primaryButton: r.a.createElement(_.n, {
							onClick: this.unmuteToggled(e.id, e.username)
						}, o.fbt._("Unmute", null, {
							hk: "334kKM"
						})),
						subredditId: this.props.subredditId,
						timeAgo: Object(m.d)(e.mutedAtUTC),
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderMuteUserModal = () => r.a.createElement(R.a, {
						ignoreDefaultFocus: !0,
						trackAddEvent: this.props.sendEventWithName("add_mutepage"),
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						withOverlay: !0
					}), this.state = O.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, {
						mutedUsers: s
					} = e;
					let a;
					return s.length && (a = s[s.length - 1].id), e.mutedUsers.length ? r.a.createElement(r.a.Fragment, null, r.a.createElement(f.c, null, r.a.createElement(_.f, {
						onClick: this.muteUser
					}, o.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), r.a.createElement(f.a, null, r.a.createElement(f.b, null, o.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), r.a.createElement(g.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), r.a.createElement(v.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}), t.searchTerm ? r.a.createElement(E.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderMutedUser(e.searchResult)) : r.a.createElement(x.b, {
						loadMoreToken: a,
						onLoadMore: this.onLoadMore
					}, e.mutedUsers.map((e, t) => ({
						estHeight: F,
						id: e.id,
						render: () => this.renderMutedUser(e)
					})))), e.isAddUserModalOpen && this.renderMuteUserModal(), e.isConfirmModalOpen && t.userId && t.username && r.a.createElement(b.a, {
						actionText: o.fbt._("Remove", null, {
							hk: "2OeYUT"
						}),
						modalText: o.fbt._("Are you sure you want to unmute {username}?", [o.fbt._param("username", t.username)], {
							hk: "2Pq8hv"
						}),
						onConfirm: e.unmuteUser(t.userId),
						toggleModal: e.toggleUnmuteUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(f.c, null, r.a.createElement(_.f, {
						onClick: this.muteUser
					}, o.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), r.a.createElement(f.a, null, r.a.createElement(f.b, null, o.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), r.a.createElement(g.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), e.mutedUsersListPending ? r.a.createElement(C.a, null) : r.a.createElement(h.c, {
						text: o.fbt._("No muted users in {subredditName}", [o.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1o0lOP"
						})
					}, r.a.createElement(D, null)), e.isAddUserModalOpen && this.renderMuteUserModal()))
				}
			}
			t.a = U(H)
		},
		"./src/reddit/components/Paginator/index.m.less": function(e, t, s) {
			e.exports = {
				controlRow: "_2ixigr45sqDsYvVlMBgbMm",
				nextButtonContainer: "CloCv22o0KvzOk8LzB4VX",
				prevButtonContainer: "_2Tfdm_mlb1NvgbaCCkMtdV",
				nextButton: "_1VFGYMJpiKtL_S9_RYS-CD",
				prevButton: "eX92mTA_HDG9gpfIzIGhs"
			}
		},
		"./src/reddit/components/Popup/Button.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/Popup/index.m.less"),
				r = s.n(a);

			function i(e) {
				return o.a.createElement("button", {
					className: r.a.popupButton,
					onClick: e.onClick
				}, e.children)
			}
		},
		"./src/reddit/components/Popup/index.m.less": function(e, t, s) {
			e.exports = {
				popup: "t5ViKDVyrrlzRbCpXvJu7",
				header: "preWelIDv3a0Fgtd5_QjN",
				title: "_3Xw5NRiOh-SAcOXIUMIm-l",
				closeButton: "_3oee1_5V2jOvP4BaO2LCQu",
				popupButton: "_3nddrgCBXpzDP5XYzrH3ZY"
			}
		},
		"./src/reddit/components/Popup/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/uuid/v4.js"),
				r = s.n(a),
				i = s("./src/reddit/hooks/useOnClickOutside.ts"),
				d = s("./src/reddit/components/Popup/index.m.less"),
				l = s.n(d);

			function c(e) {
				const {
					id: t = r()(),
					onClose: s,
					onClickOutside: n,
					title: a,
					children: d
				} = e;
				return Object(i.a)(t, n), o.a.createElement("div", {
					id: t,
					"aria-modal": !0,
					className: l.a.popup,
					role: "dialog",
					tabIndex: -1
				}, o.a.createElement("h3", {
					className: l.a.header
				}, o.a.createElement("span", {
					className: l.a.title
				}, a), o.a.createElement("button", {
					className: l.a.closeButton,
					onClick: s
				}, "✕")), d)
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.m.less": function(e, t, s) {
			e.exports = {
				backgroundWrapper: "_1poyrkZ7g36PawDueRza-J",
				badge: "_1lLKAbRNH1mm32sVm7yCzQ"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				d = s("./src/reddit/components/PostBackgroundWrapper/index.m.less"),
				l = s.n(d);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var m = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			t.a = Object(r.a)(e => {
				const {
					children: t,
					className: s,
					flairStyleTemplate: n,
					onClick: r,
					post: d,
					redditStyle: u,
					theme: p
				} = e, b = m(e, ["children", "className", "flairStyleTemplate", "onClick", "post", "redditStyle", "theme"]);
				return o.a.createElement("div", c({
					className: Object(a.a)(l.a.backgroundWrapper, s),
					style: Object(i.c)(n, e),
					onClick: r
				}, b), t)
			})
		},
		"./src/reddit/components/PostBadges/index.m.less": function(e, t, s) {
			e.exports = {
				adminIcon: "_1cje4rrmwL0yZgCOlGyBJ-",
				approveIcon: "_1knR9NIIXdSFC9IeFN11JL",
				automoderator: "_2etEb_0bRB9axAqF3uX28S",
				icon: "_3vju76MdF2FaGmELBeiJ_r",
				lockIcon: "_3wTfn3Meg1rXJ-qd2jUWMt",
				modIcon: "_SMl46gACTEszA_4A0Qfs",
				removeIcon: "_3yuF1RnBRJL4OS_STsoXcC",
				reportIcon: "_3guZWUAROueft8TPPGDZ-R",
				spamIcon: "_2BWw37nLL0rX6n7xcXciyD",
				stickyIcon: "NI8uZ-19oHf9gPO8jOvFu",
				isRemoved: "_27iLVqax1FuPWTymkSkKAq",
				archivedIcon: "_2WSiH2JwZq4bXuvrDn-cgU",
				addRemovalReason: "COGitU-ItwLZG_fP5rsdE",
				removalReason: "_16Ih3bzeELRlI6AWeW-nFy"
			}
		},
		"./src/reddit/components/PostBadges/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/constants/index.ts"),
				c = s("./src/reddit/actions/tooltip.ts"),
				m = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				u = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				p = s("./src/reddit/constants/posts.ts"),
				b = s("./src/reddit/contexts/PageLayer/index.tsx"),
				h = s("./src/reddit/helpers/isRemoved.ts"),
				g = s("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				f = s("./src/reddit/helpers/showReportIndicator/index.ts"),
				x = s("./src/reddit/models/Post/index.ts"),
				E = s("./src/reddit/selectors/posts.ts"),
				v = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				C = s("./src/reddit/icons/fonts/Archived/index.tsx"),
				_ = s("./src/reddit/icons/fonts/Lock/index.tsx"),
				k = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				O = s("./src/reddit/icons/fonts/Report/index.tsx"),
				y = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				j = s("./src/reddit/icons/fonts/Sticky/index.tsx"),
				w = s("./src/reddit/icons/svgs/Automoderator/index.tsx"),
				S = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				I = s("./src/reddit/components/PostBadges/index.m.less"),
				P = s.n(I);

			function T() {
				return (T = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const N = e => a.a.createElement("span", T({
					className: P.a.removalReason
				}, e), e.children),
				M = () => n.fbt._("Archived", null, {
					hk: "zv3q3"
				}),
				R = () => n.fbt._("Comments are locked", null, {
					hk: "8HjJ9"
				}),
				L = e => n.fbt._("Moderator of {community name}", [n.fbt._param("community name", e)], {
					hk: "nJqIB"
				}),
				A = () => n.fbt._("Stickied post", null, {
					hk: "3qSaBs"
				}),
				F = () => n.fbt._("Pinned post", null, {
					hk: "2oxErI"
				}),
				D = (e, t, s) => {
					const n = "PostBadges--".concat(e, "--").concat(t);
					return s ? "".concat(n, "--").concat(s) : n
				},
				B = Object(b.t)({
					isProfilePostListing: b.I,
					isSubreddit: b.K,
					pageLayer: e => e
				}),
				U = Object(i.c)({
					isPinned: (e, t) => {
						let {
							post: s
						} = t;
						return Object(E.u)(e, {
							postId: s.id
						})
					},
					modModeEnabled: b.P
				}),
				H = Object(r.b)(U, (e, t) => ({
					onHideTooltip: () => e(Object(c.i)()),
					onOpenRemovalReasonModal: () => {
						s.e("removalReasonActions").then(s.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(s => e(s.fetchReasonsAndOpenModal(t.post.belongsTo.id, [t.post.id])))
					},
					onShowTooltip: t => () => e(Object(c.f)({
						tooltipId: t
					}))
				}));
			t.a = B(H(e => {
				let {
					className: t,
					displayText: s,
					isSubreddit: r,
					inSubredditOrProfile: i,
					isCompactPinnedPost: c,
					isPinned: b,
					isProfilePostListing: E,
					modModeEnabled: I,
					onHideTooltip: B,
					onOpenRemovalReasonModal: U,
					onShowTooltip: H,
					post: W,
					tooltipType: V
				} = e;
				const q = {
						caretOnTop: !1
					},
					G = W.isRemoved && !W.modRemovalReason && !W.modNote && W.belongsTo.type === p.a.SUBREDDIT,
					K = D("Approve", W.id, V),
					z = D("Archived", W.id, V),
					Q = D("Automod", W.id, V),
					J = D("Lock", W.id, V),
					Z = D("Mod", W.id, V),
					X = D("Remove", W.id, V),
					Y = D("Report", W.id, V),
					$ = D("Spam", W.id, V),
					ee = D("Sticky", W.id, V),
					te = D("Pinned", W.id, V);
				return a.a.createElement("div", {
					className: t
				}, i && s && W.distinguishType === l.C.MODERATOR && a.a.createElement(o.Fragment, null, a.a.createElement(S.a, {
					className: P.a.modIcon,
					desc: L(s),
					id: Z,
					onMouseEnter: H(Z),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: Z,
					text: L(s)
				}, q))), W.isArchived && a.a.createElement(o.Fragment, null, a.a.createElement(C.a, {
					className: P.a.archivedIcon,
					desc: M(),
					id: z,
					onMouseEnter: H(z),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: z,
					text: M()
				}, q))), W.isLocked && a.a.createElement(o.Fragment, null, a.a.createElement(_.a, {
					className: P.a.lockIcon,
					desc: R(),
					id: J,
					onMouseEnter: H(J),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: J,
					text: R()
				}, q))), r && Object(x.k)(W) && !c && a.a.createElement(o.Fragment, null, a.a.createElement(j.a, {
					className: P.a.stickyIcon,
					desc: A(),
					id: ee,
					onMouseEnter: H(ee),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: ee,
					text: A()
				}, q))), E && b && a.a.createElement(o.Fragment, null, a.a.createElement(j.a, {
					className: P.a.stickyIcon,
					desc: F(),
					id: te,
					onMouseEnter: H(te),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: te,
					text: F()
				}, q))), (W.isApproved || W.approvedBy) && a.a.createElement(o.Fragment, null, a.a.createElement(v.a, {
					className: P.a.approveIcon,
					desc: Object(g.a)(W),
					id: K,
					onMouseEnter: H(K),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: K,
					text: Object(g.a)(W)
				}, q))), Object(h.a)(W) && a.a.createElement(o.Fragment, null, a.a.createElement(k.a, {
					className: P.a.removeIcon,
					desc: Object(g.c)(W),
					id: X,
					onMouseEnter: H(X),
					onMouseLeave: B
				}), G && a.a.createElement(u.a, {
					className: P.a.addRemovalReason,
					onClick: U,
					text: n.fbt._("Add a removal reason", null, {
						hk: "1YDo3"
					})
				}), (W.modRemovalReason || W.modNote) && a.a.createElement(N, {
					onMouseEnter: H(X),
					onMouseLeave: B
				}, n.fbt._("Removal reason", null, {
					hk: "2DhKVZ"
				})), a.a.createElement(m.c, T({
					tooltipId: X,
					text: Object(g.c)(W)
				}, q))), W.bannedBy && W.isSpam && a.a.createElement(o.Fragment, null, a.a.createElement(y.a, {
					className: P.a.spamIcon,
					desc: Object(g.e)(W),
					id: $,
					onMouseEnter: H($),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: $,
					text: Object(g.e)(W)
				}, q))), ("AutoModerator" === W.approvedBy || "AutoModerator" === W.bannedBy) && a.a.createElement(o.Fragment, null, a.a.createElement(w.a, {
					className: Object(d.a)(P.a.automoderator, !!W.bannedBy && P.a.isRemoved),
					desc: g.b,
					id: Q,
					onMouseEnter: H(Q),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: Q,
					text: g.b
				}, q))), Object(f.a)(W) && !I && a.a.createElement(o.Fragment, null, a.a.createElement(O.a, {
					className: P.a.reportIcon,
					desc: Object(g.d)(W.numReports),
					id: Y,
					onMouseEnter: H(Y),
					onMouseLeave: B
				}), a.a.createElement(m.c, T({
					tooltipId: Y,
					text: Object(g.d)(W.numReports)
				}, q))))
			}))
		},
		"./src/reddit/components/PostContainer/index.m.less": function(e, t, s) {
			e.exports = {
				WrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz",
				wrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz"
			}
		},
		"./src/reddit/components/PostContainer/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/reselect/es/index.js"),
				r = s("./src/reddit/components/AdViewability/index.tsx"),
				i = s("./src/reddit/connectors/PostViewable/index.ts"),
				d = s("./src/reddit/models/Media/index.ts"),
				l = s("./src/reddit/selectors/video.ts"),
				c = s("./src/lib/classNames/index.ts"),
				m = s("./src/higherOrderComponents/withClickTracking.tsx"),
				u = s("./src/reddit/components/PostContainer/index.m.less"),
				p = s.n(u);
			const b = Object(a.c)({
					clickTrackingId: (e, t) => {
						let {
							post: s
						} = t;
						return s.id
					},
					buffering: (e, t) => {
						let {
							post: s
						} = t;
						return Object(l.a)(e, {
							postId: s.id
						})
					},
					playing: (e, t) => {
						let {
							post: s
						} = t;
						return Object(l.f)(e, {
							postId: s.id
						})
					},
					continuousViewingStartedAt: (e, t) => {
						let {
							post: s
						} = t;
						return Object(l.c)(e, {
							postId: s.id
						})
					}
				}),
				h = Object(i.a)(b),
				g = e => {
					const t = Object(m.d)(e.target, e.currentTarget),
						s = Object(m.b)(e.target, e.currentTarget, m.a.buttons);
					return "subreddit" !== t && s
				};
			class f extends o.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						children: t,
						className: s,
						makePostContainerId: n,
						post: a,
						onClick: i,
						onPostContentClick: l,
						style: m,
						ref: u
					} = this.props, b = o.a.createElement("div", {
						style: m,
						ref: u,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3))
						},
						onClick: t => {
							!this.cancelClick && t.button < 2 && (e(() => i && i(t, a))(t), l && g(t) && l(t, a))
						},
						className: Object(c.a)(p.a.WrappedPost, s, "Post ".concat(a.id), {
							promotedlink: a.isSponsored
						}),
						id: n ? n(a.id) : a.id,
						tabIndex: -1
					}, t), h = !!a.media && a.media.type === d.n.VIDEO;
					return a.isSponsored || h ? o.a.createElement(r.a, {
						post: a,
						trackDisplay: !0
					}, b) : b
				}
			}
			t.a = h(Object(m.c)(f))
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1IZotn_IQQ1fgtUjaFYbkd",
				onHoverActionText: "_1Zlk1VrZ8puYZy5lJOfz--",
				Container: "_1IZotn_IQQ1fgtUjaFYbkd",
				PostTitle: "_1hzDym_NpIlizkTDXc_rQj",
				postTitle: "_1hzDym_NpIlizkTDXc_rQj",
				MetaLine: "_67JuJTdFwIJPLPDkyPX-f",
				metaLine: "_67JuJTdFwIJPLPDkyPX-f",
				SubredditName: "_88OYON0K3w_tpnmCSWlUX",
				subredditName: "_88OYON0K3w_tpnmCSWlUX",
				InfoSpan: "_3DFfW-OG-MvCLiiEN18mpq",
				infoSpan: "_3DFfW-OG-MvCLiiEN18mpq"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less": function(e, t, s) {
			e.exports = {
				Wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				TopRow: "vuQEtla32r0kemmh11Hov",
				topRow: "vuQEtla32r0kemmh11Hov",
				TitleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				titleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				DetailsContainer: "_87UrrqUro4oVpXFAElZUX",
				detailsContainer: "_87UrrqUro4oVpXFAElZUX",
				ButtonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				buttonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				CloseWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				closeWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				Close: "_1TaKYhB80ExuTPoLaQZMRE",
				close: "_1TaKYhB80ExuTPoLaQZMRE",
				Empty: "_20K7F6rAgXGH5z83v7Ifiv",
				empty: "_20K7F6rAgXGH5z83v7Ifiv",
				EmptyImage: "_2eLeResic3Gc77W_edgNGt",
				emptyImage: "_2eLeResic3Gc77W_edgNGt",
				EmptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				emptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				FilterWrapper: "pKfhphFBuya82DYP2Q90X",
				filterWrapper: "pKfhphFBuya82DYP2Q90X",
				FilterInput: "_3W5cary86KmYWrVgEpGKPb",
				filterInput: "_3W5cary86KmYWrVgEpGKPb",
				SearchIcon: "_9T_dguVcd795c_vOyl9s4",
				searchIcon: "_9T_dguVcd795c_vOyl9s4",
				PlusIcon: "hfmgzmXCLe3hvSyZad9WP",
				plusIcon: "hfmgzmXCLe3hvSyZad9WP",
				CreateCollectionButton: "_34_h0zRV3AgFr_0sh99pKz",
				createCollectionButton: "_34_h0zRV3AgFr_0sh99pKz"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/higherOrderComponents/asModal/index.tsx"),
				c = s("./src/lib/memoizeByReference/index.ts"),
				m = s("./src/reddit/actions/postCreation/general.ts"),
				u = s("./src/reddit/components/TrackingHelper/index.tsx"),
				p = s("./src/reddit/constants/keycodes.ts"),
				b = s("./src/reddit/controls/Button/index.tsx"),
				h = s("./src/reddit/controls/Input/index.tsx"),
				g = s("./src/reddit/icons/svgs/Close/index.tsx"),
				f = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				x = s("./src/reddit/icons/svgs/Search/index.tsx"),
				E = s("./src/reddit/layout/row/Inline/index.tsx"),
				v = s("./src/reddit/models/PostCreationForm/index.ts"),
				C = s("./src/reddit/selectors/postCollection.ts"),
				_ = s("./src/lib/timeAgo/index.ts"),
				k = s("./src/reddit/controls/MetaSeparator/index.tsx"),
				O = s("./src/reddit/helpers/name/index.ts"),
				y = s("./src/reddit/models/Subreddit/index.ts"),
				j = s("./src/reddit/models/User/index.ts"),
				w = s("./src/reddit/selectors/subreddit.ts"),
				S = s("./src/reddit/selectors/user.ts"),
				I = s("./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less"),
				P = s.n(I),
				T = s("./src/lib/lessComponent.tsx");
			const {
				fbt: N
			} = s("./node_modules/fbt/lib/FbtPublic.js"), M = T.a.div("Container", P.a), R = T.a.h2("PostTitle", P.a), L = T.a.div("MetaLine", P.a), A = T.a.span("SubredditName", P.a), F = T.a.time("InfoSpan", P.a), D = Object(d.c)({
				subreddit: (e, t) => {
					let {
						collection: {
							subredditId: s
						}
					} = t;
					return s ? Object(w.R)(e, {
						subredditId: s
					}) : void 0
				},
				user: S.i
			});
			class B extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.onClick = () => {
						this.props.onClick(this.props.collection.id)
					}
				}
				render() {
					const {
						collection: e,
						subreddit: t,
						user: s,
						onHoverActionText: n
					} = this.props, o = t && Object(y.f)(t) && s ? Object(O.c)(Object(j.e)(s)) : t ? t.displayText : "", a = e.postIds.length;
					return r.a.createElement(M, {
						onClick: this.onClick,
						className: P.a.container
					}, r.a.createElement(R, {
						"data-redditstyle": !0
					}, e.title), r.a.createElement(L, {
						"data-redditstyle": !0
					}, o && r.a.createElement(A, {
						"data-redditstyle": !0
					}, o), o && r.a.createElement(k.b, null), r.a.createElement(F, null, N._({
						"*": "{number of posts} posts",
						_1: "1 post"
					}, [N._plural(a, "number of posts")], {
						hk: "1Uy96U"
					})), r.a.createElement(k.b, null), r.a.createElement(F, null, N._("created {time}", [N._param("time", Object(_.d)(e.createdAtUTC))], {
						hk: "2cUc5m"
					}))), n && r.a.createElement("div", {
						className: P.a.onHoverActionText
					}, r.a.createElement("span", null, n)))
				}
			}
			var U = Object(i.b)(D)(B),
				H = s("./src/reddit/helpers/trackers/postCollection.ts"),
				W = s("./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less"),
				V = s.n(W);
			const q = "".concat(n.a.assetPath, "/img/snoo-drafts.png"),
				G = T.a.div("TopRow", V.a),
				K = T.a.div("TitleRow", V.a),
				z = T.a.div("DetailsContainer", V.a),
				Q = T.a.wrapped(E.a, "ButtonRow", V.a),
				J = T.a.div("CloseWrapper", V.a),
				Z = T.a.wrapped(g.a, "Close", V.a),
				X = T.a.div("Empty", V.a),
				Y = T.a.img("EmptyImage", V.a),
				$ = T.a.p("EmptyText", V.a),
				ee = T.a.div("FilterWrapper", V.a),
				te = T.a.wrapped(h.a, "FilterInput", V.a),
				se = T.a.wrapped(x.a, "SearchIcon", V.a),
				ne = T.a.wrapped(f.a, "PlusIcon", V.a),
				oe = T.a.wrapped(b.j, "CreateCollectionButton", V.a),
				ae = Object(c.a)((e, t) => {
					const s = t.toLowerCase();
					return e.filter(e => e.title.toLowerCase().includes(s))
				}),
				re = Object(d.c)({
					collections: C.w
				}),
				ie = Object(i.b)(re, (e, t) => {
					let {
						postId: s,
						isOverlay: n
					} = t;
					return {
						onOpenCreateCollectionModal: () => {
							let t = v.b;
							s && (t = Object(v.t)(s, !!n)), e(Object(m.y)(t))
						}
					}
				});
			class de extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						filterStr: ""
					}, this.close = () => {
						this.props.sendEvent(Object(H.c)()), this.props.onClose()
					}, this.handleEscapeKey = e => {
						e.keyCode === p.a.Escape && this.close()
					}, this.handleCreateCollectionClicked = () => {
						this.props.onOpenCreateCollectionModal(), this.props.sendEvent(Object(H.j)())
					}, this.handleCollectionSelected = e => {
						this.props.onSelectCollection(e), this.props.sendEvent(Object(H.q)())
					}, this.onFilterStringChange = e => {
						this.setState({
							filterStr: e.target.value
						})
					}, this.renderItem = e => r.a.createElement(U, {
						key: e.id,
						collection: e,
						onClick: () => this.handleCollectionSelected(e),
						onHoverActionText: this.props.onItemHoverActionText
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey), this.props.sendEvent(Object(H.d)())
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderNoCollections() {
					return r.a.createElement(X, null, r.a.createElement(Y, {
						src: q
					}), r.a.createElement($, null, o.fbt._("Your collections will live here", null, {
						hk: "FCxWg"
					})))
				}
				renderNoFilterMatches() {
					return r.a.createElement(X, null, r.a.createElement($, null, o.fbt._("No collection matching filter", null, {
						hk: "2vawdK"
					}), ";"))
				}
				render() {
					const {
						collections: e,
						titleText: t
					} = this.props;
					let s;
					if (0 === e.length) s = this.renderNoCollections();
					else {
						const t = ae(e, this.state.filterStr);
						s = 0 === t.length ? this.renderNoFilterMatches() : t.map(this.renderItem)
					}
					return r.a.createElement("div", {
						className: V.a.wrapper,
						"data-redditstyle": !0
					}, r.a.createElement(G, null, r.a.createElement(K, {
						"data-redditstyle": !0
					}, t || o.fbt._("My collections", null, {
						hk: "3yKovS"
					}), r.a.createElement(J, {
						onClick: this.close
					}, r.a.createElement(Z, {
						"data-redditstyle": !0
					}))), r.a.createElement(ee, null, r.a.createElement(se, null), r.a.createElement(te, {
						placeholder: o.fbt._("Find a collection", null, {
							hk: "3DbFBU"
						}),
						value: this.state.filterStr,
						onChange: this.onFilterStringChange
					}))), r.a.createElement(z, null, s), r.a.createElement(Q, null, r.a.createElement(oe, {
						onClick: this.handleCreateCollectionClicked
					}, r.a.createElement(ne, null), o.fbt._("Create a collection", null, {
						hk: "37xJVm"
					}))))
				}
			}
			const le = Object(l.a)(ie(Object(u.c)(de)));
			t.a = le
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less": function(e, t, s) {
			e.exports = {
				Container: "_3vV_tKesULQ5WMGh38lX4b",
				container: "_3vV_tKesULQ5WMGh38lX4b",
				Content: "_11JSvybbRhcX_cfoagpne_",
				content: "_11JSvybbRhcX_cfoagpne_",
				TitleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				titleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				Details: "_3Uw02TWwSQhLfCJkPsihqr",
				details: "_3Uw02TWwSQhLfCJkPsihqr",
				Footer: "_25MDqXgOCWDBjtAEBi2cmy",
				footer: "_25MDqXgOCWDBjtAEBi2cmy",
				CancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				cancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				CloseWrapper: "_GVnqGyX40oKfgIS56Q-k",
				closeWrapper: "_GVnqGyX40oKfgIS56Q-k",
				CloseIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				closeIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				Label: "_3QPFKpxsmu6j_gbiAuVgfW",
				label: "_3QPFKpxsmu6j_gbiAuVgfW",
				TitleInput: "ZEfw7a99aHsmkl4fx38l5",
				titleInput: "ZEfw7a99aHsmkl4fx38l5",
				AddCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				addCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				PrimaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				primaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				LoadingIcon: "_3cD2qECfUUTwega16qDhBc",
				loadingIcon: "_3cD2qECfUUTwega16qDhBc",
				ErrorText: "GIQ2YnBHQtY1QM1yPEhCR",
				errorText: "GIQ2YnBHQtY1QM1yPEhCR"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/higherOrderComponents/asModal/index.tsx"),
				l = s("./src/lib/formatApiError/index.ts"),
				c = s("./src/reddit/actions/postCollection/index.ts"),
				m = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = s("./src/reddit/constants/postCreation.ts"),
				p = s("./src/reddit/controls/Button/index.tsx"),
				b = s("./src/reddit/controls/ErrorText/index.tsx"),
				h = s("./src/reddit/controls/Input/index.tsx"),
				g = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				f = s("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				x = s("./src/reddit/icons/svgs/Close/index.tsx"),
				E = s("./src/reddit/layout/row/Inline/index.tsx"),
				v = s("./src/reddit/selectors/postCollection.ts"),
				C = s("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less"),
				_ = s.n(C),
				k = s("./src/lib/lessComponent.tsx");
			const O = k.a.div("Container", _.a),
				y = k.a.div("Content", _.a),
				j = k.a.div("TitleRow", _.a),
				w = k.a.div("Details", _.a),
				S = k.a.wrapped(m.f, "Footer", _.a),
				I = k.a.wrapped(p.i, "CancelButton", _.a),
				P = k.a.div("CloseWrapper", _.a),
				T = k.a.wrapped(x.a, "CloseIcon", _.a),
				N = k.a.label("Label", _.a),
				M = k.a.wrapped(h.a, "TitleInput", _.a),
				R = k.a.wrapped(f.a, "AddCollectionIcon", _.a),
				L = k.a.wrapped(p.f, "PrimaryActionButton", _.a),
				A = k.a.wrapped(g.a, "LoadingIcon", _.a),
				F = k.a.wrapped(b.b, "ErrorText", _.a),
				D = Object(i.c)({
					collection: v.r,
					error: v.c,
					isPending: v.h
				}),
				B = Object(r.b)(D, (e, t) => ({
					onCreate: (t, s) => e(Object(c.b)(t, s)),
					onUpdate: s => e(Object(c.h)(t.collectionId, s))
				}));
			class U extends a.a.PureComponent {
				constructor(e) {
					super(e), this.onTitleChange = e => {
						this.setState({
							collectionTitle: e.target.value
						})
					}, this.onPrimaryButtonClick = async () => {
						const {
							collectionId: e,
							subredditId: t
						} = this.props, {
							collectionTitle: s
						} = this.state;
						if (e) {
							await this.props.onUpdate(s) && this.props.onCollectionUpdated && this.props.onCollectionUpdated()
						} else {
							const e = await this.props.onCreate(s, t);
							e && this.props.onCollectionCreated && this.props.onCollectionCreated(e)
						}
					}, this.onClose = () => {
						this.props.onCancel()
					};
					const {
						collection: t
					} = e;
					this.state = {
						collectionTitle: t ? t.title : ""
					}
				}
				render() {
					const {
						collectionId: e,
						error: t,
						isPending: s
					} = this.props, o = !e, r = !!this.state.collectionTitle.trim(), i = o ? n.fbt._("Create", null, {
						hk: "Ijp7n"
					}) : n.fbt._("Save", null, {
						hk: "2Onrrv"
					});
					return a.a.createElement(O, null, a.a.createElement(P, {
						onClick: this.props.onCancel
					}, a.a.createElement(T, null)), a.a.createElement(y, null, o && a.a.createElement(a.a.Fragment, null, a.a.createElement(j, null, a.a.createElement(R, null), n.fbt._("Create a collection", null, {
						hk: "3ndxk5"
					})), a.a.createElement(w, null, n.fbt._("Group posts into one feed. Create a series of events or just a group of random things. Make something awesome!", null, {
						hk: "2eCAQw"
					}))), a.a.createElement(N, null, o ? n.fbt._("Give a title for your collection", null, {
						hk: "Uaqbe"
					}) : n.fbt._("Edit title", null, {
						hk: "1jzweg"
					}), a.a.createElement(M, {
						maxLength: u.e,
						onChange: this.onTitleChange,
						placeholder: n.fbt._("Enter title", null, {
							hk: "3B0iRI"
						}),
						value: this.state.collectionTitle
					}))), a.a.createElement(S, null, a.a.createElement(E.a, null, a.a.createElement(I, {
						onClick: this.props.onCancel
					}, n.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(L, {
						onClick: this.onPrimaryButtonClick,
						disabled: s || !r
					}, s ? a.a.createElement(A, {
						sizePx: 10
					}) : i)), t && a.a.createElement(F, null, Object(l.a)(t))))
				}
			}
			t.a = Object(d.a)(B(U))
		},
		"./src/reddit/components/PostFlairPicker/index.m.less": function(e, t, s) {
			e.exports = {
				buttonsRow: "cF9DU_4WDAKS4gs43ct2_",
				clearButton: "_3vB6Y9PiwJ0YV6c9MGbDwT"
			}
		},
		"./src/reddit/components/PostFlairPicker/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return y
			}));
			var n, o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/reddit/components/TrackingHelper/index.tsx"),
				c = s("./src/higherOrderComponents/asModal/index.tsx"),
				m = s("./src/reddit/actions/modal.ts"),
				u = s("./src/reddit/components/FlairPickerTitle/index.tsx"),
				p = s("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				b = s("./src/reddit/components/FlairPreview/index.tsx"),
				h = s("./src/reddit/components/FlairSearch/index.tsx"),
				g = s("./src/reddit/controls/Button/index.tsx"),
				f = s("./src/reddit/models/Flair/index.ts"),
				x = s("./src/reddit/selectors/moderatorPermissions.ts"),
				E = s("./src/reddit/selectors/postFlair.ts"),
				v = s("./src/reddit/selectors/subreddit.ts"),
				C = s("./src/reddit/selectors/telemetry.ts"),
				_ = s("./src/reddit/components/PostFlairPicker/helpers.ts"),
				k = s("./src/reddit/components/PostFlairPicker/index.m.less"),
				O = s.n(k);
			! function(e) {
				e.UNSET = "unset", e.MOD_FLATLIST = "postModFlatlist", e.POST_OVERFLOW = "postOverlay"
			}(n || (n = {}));
			const y = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : n.UNSET;
					return "PostFlair__Modal-[postId: ".concat(e, "]-isOverlay[").concat(t, "]-position[").concat(s, "]")
				},
				j = Object(d.c)({
					flairData: E.d,
					subreddit: v.R,
					isMod: (e, t) => !!Object(x.j)(e, t)
				});
			class w extends r.a.Component {
				constructor(e) {
					super(e), this.getTrackingNoun = (e, t) => this.props.isMod ? e : t, this.onApply = () => {
						const {
							previewFlair: e
						} = this.state, t = e && e.templateId;
						this.props.onFlairChanged({
							previewFlair: e,
							selectedTemplateId: t
						}), this.props.closeModal && this.props.closeModal(), this.track(this.getTrackingNoun("flairadd_mod", "flairadd_user"))
					}, this.onClear = () => this.setSelectedFlair(null), this.setSelectedFlair = e => {
						this.setState({
							previewFlair: e
						})
					}, this.track = e => this.props.sendEvent(t => ({
						source: "post_flair_picker",
						action: "click",
						noun: e,
						subreddit: Object(C.subredditById)(t, this.props.subredditId)
					}));
					const t = Object(_.c)(e.flairs);
					this.state = {
						previewFlair: t || null
					}
				}
				canSave() {
					const {
						templates: e
					} = this.props.flairData, {
						previewFlair: t
					} = this.state, s = Object(_.c)(this.props.flairs) || null;
					return Object(_.b)(e, t, s)
				}
				render() {
					const {
						props: e
					} = this, {
						previewFlair: t
					} = this.state, {
						className: s,
						flairData: n,
						subreddit: a
					} = e, i = a.displayText, {
						templates: d,
						templateIds: l
					} = n, {
						canSave: c
					} = this.canSave();
					return r.a.createElement(p.a, {
						className: s
					}, r.a.createElement(u.a, {
						onClosePressed: e.closeModal,
						title: o.fbt._("Select {subredditName} flair", [o.fbt._param("subredditName", i)], {
							hk: "1lDMWS"
						})
					}), r.a.createElement(b.a, {
						flair: t,
						flairTemplateType: f.d.LinkFlair,
						placeholderText: o.fbt._("Post Title", null, {
							hk: "43RsbC"
						})
					}), r.a.createElement(h.a, {
						flair: t,
						flairTemplateType: f.d.LinkFlair,
						subredditId: a.id,
						templates: d,
						templateIds: l,
						onChange: this.setSelectedFlair
					}), r.a.createElement("div", {
						className: O.a.buttonsRow
					}, r.a.createElement(g.f, {
						disabled: !c,
						onClick: this.onApply
					}, o.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), r.a.createElement(g.i, {
						className: O.a.clearButton,
						onClick: this.onClear
					}, o.fbt._("Clear Flair", null, {
						hk: "3jvT0B"
					}))))
				}
			}
			const S = Object(i.b)(j, (e, t) => ({
				closeModal: () => e(Object(m.i)(t.modalId))
			}))(w);
			t.a = Object(c.a)(Object(l.c)(S))
		},
		"./src/reddit/components/PostFollow/index.m.less": function(e, t, s) {
			e.exports = {
				collectionFollow: "_1yF34mDRcD_ii0n-Ak0OdI",
				isFollowed: "gBrTiaH_Z7HT5D96vnUfJ",
				isEventFollow: "_1iTFEDTdpF-KFmOZvDuGHH"
			}
		},
		"./src/reddit/components/PostFollow/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return h
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/reddit/actions/post.ts"),
				c = s("./src/reddit/components/TrackingHelper/index.tsx"),
				m = s("./src/reddit/helpers/trackers/postCollection.ts"),
				u = s("./src/reddit/components/PostFollow/index.m.less"),
				p = s.n(u);
			class b extends a.a.Component {
				constructor(e) {
					super(e), this.onFollowClick = () => {
						const {
							isEventFollow: e,
							onFollow: t,
							post: {
								id: s,
								isFollowed: n
							},
							sendEvent: o
						} = this.props, a = !!n;
						o(e ? Object(m.o)({
							postId: s,
							isFollowed: a
						}) : Object(m.g)({
							postId: s,
							isFollowed: a
						})), t && t()
					}, this.onMouseEnter = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !1
						})
					}, this.state = {
						isHovered: !1
					}
				}
				render() {
					const {
						className: e,
						isEventFollow: t,
						post: s
					} = this.props, o = this.state.isHovered, r = s.isFollowed;
					let i = r ? n.fbt._("Followed", null, {
						hk: "2oc9IH"
					}) : n.fbt._("Follow", null, {
						hk: "NkunG"
					});
					return r && o && (i = n.fbt._("Unfollow", null, {
						hk: "2sJ8xn"
					})), a.a.createElement("button", {
						className: Object(d.a)(p.a.collectionFollow, {
							[p.a.isFollowed]: !!s.isFollowed,
							[p.a.isEventFollow]: t
						}, e),
						onClick: this.onFollowClick,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, i)
				}
			}
			const h = Object(r.b)(() => Object(i.c)({}), (e, t) => {
				let {
					post: s
				} = t;
				return {
					onFollow: () => e(Object(l.F)(s.isSponsored ? s.postId : s.id))
				}
			})(Object(c.c)(b))
		},
		"./src/reddit/components/PostLeftRail/index.m.less": function(e, t, s) {
			e.exports = {
				postLeftRail: "_23h0-EcaBUorIHC-JZyh6J"
			}
		},
		"./src/reddit/components/PostLeftRail/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return c
			})), s.d(t, "c", (function() {
				return m
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = s("./src/reddit/constants/colors.ts"),
				d = s("./src/reddit/components/PostLeftRail/index.m.less"),
				l = s.n(d);
			const c = 40,
				m = e => e.isRemoved ? i.a.removed : e.isReported ? i.a.reported : "transparent",
				u = Object(r.a)(e => {
					const t = m(e),
						s = {
							width: "".concat(c, "px"),
							borderLeft: "4px solid ".concat(t)
						};
					return o.a.createElement("div", {
						className: Object(a.a)(l.a.postLeftRail, e.className),
						style: e.withoutComputedStyles ? {} : s
					}, e.children)
				});
			t.b = u
		},
		"./src/reddit/components/PostMedia/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/CrosspostBox/index.tsx"),
				r = s("./src/reddit/components/Media/index.tsx");
			t.a = e => {
				const {
					post: t
				} = e;
				return t.crosspostRootId ? o.a.createElement(a.a, {
					postId: t.crosspostRootId,
					mediaProps: Object.assign({}, e, {
						crosspost: t,
						primaryContent: !1
					})
				}) : o.a.createElement(r.a, Object.assign({}, e, {
					primaryContent: !!e.showFull
				}))
			}
		},
		"./src/reddit/components/PostMeta/index.m.less": function(e, t, s) {
			e.exports = {
				donationAmount: "_1x9gNS8wlrugqgwofOEcGq",
				metaContainer: "Ywkt6EDfNWINeTr9lP29H",
				postTopMeta: "iaAYGvTNtknkTxuHArCzL",
				subredditName: "_1L0pdcPf58t25Jy6ljHIKR"
			}
		},
		"./src/reddit/components/PostMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/AwardBadges/index.tsx"),
				r = s("./src/reddit/components/Economics/Support/DonationAmount/async.tsx"),
				i = s("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				d = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				l = s("./src/reddit/components/PostBadges/index.tsx"),
				c = s("./src/reddit/components/PostTopMeta/index.tsx"),
				m = s("./src/reddit/components/QuarantinedLabel/index.tsx"),
				u = s("./src/reddit/components/SubredditNameLink/index.tsx"),
				p = s("./src/reddit/components/SubscribeButton/Inline.tsx"),
				b = s("./src/reddit/constants/posts.ts"),
				h = s("./src/reddit/controls/MetaSeparator/index.tsx"),
				g = s("./src/reddit/helpers/trackers/post.ts"),
				f = s("./src/reddit/models/Subreddit/index.ts"),
				x = s("./src/reddit/components/PostMeta/index.m.less"),
				E = s.n(x);
			t.a = e => {
				const {
					flairStyleTemplate: t,
					hideGildCta: s,
					inSubredditOrProfile: n,
					isCurrentUserProfilePost: x,
					isOverlay: v,
					isTopicPage: C,
					post: _,
					shouldShowSubscribeButton: k,
					subredditOrProfile: O,
					tooltipType: y
				} = e, j = !!C;
				return o.a.createElement("div", {
					className: E.a.metaContainer
				}, !n && !_.isSponsored && O && o.a.createElement(i.a, {
					postId: _.id,
					subredditName: O.name
				}, o.a.createElement(u.a, {
					className: E.a.subredditName,
					"data-click-id": "subreddit",
					to: O.url
				}, O.displayText)), O && O.isQuarantined && o.a.createElement(m.a, null), !n && !_.isSponsored && O && k && !x && o.a.createElement(p.a, {
					getEventFactory: e => Object(g.f)(_.id, e ? "unsubscribe" : "subscribe"),
					identifier: {
						name: O.name,
						type: Object(f.f)(O) ? b.a.PROFILE : b.a.SUBREDDIT
					},
					postId: _.id,
					small: !0
				}), !n && !_.isSponsored && o.a.createElement(h.b, null), !n && !_.isSponsored && o.a.createElement(d.h, {
					type: _.belongsTo.type,
					id: _.belongsTo.id
				}), o.a.createElement(c.d, {
					className: E.a.postTopMeta,
					flairStyleTemplate: t,
					post: _,
					tooltipType: y
				}), o.a.createElement(l.a, {
					displayText: O ? O.displayText : null,
					inSubredditOrProfile: !!n,
					post: _,
					tooltipType: y
				}), O && o.a.createElement(r.a, {
					className: E.a.donationAmount,
					contentId: _.id,
					subredditId: O.id
				}), !j && o.a.createElement(a.a, {
					hideCta: s,
					isOverlay: !!v,
					thing: _
				}))
			}
		},
		"./src/reddit/components/PostModModeDropdown/DropdownHelpers.m.less": function(e, t, s) {
			e.exports = {
				ListContainer: "VHCAEHBEuD8bln8MDFl35",
				listContainer: "VHCAEHBEuD8bln8MDFl35",
				Icon: "_3WbGqnEpw_ds1P508Qawma",
				icon: "_3WbGqnEpw_ds1P508Qawma",
				CheckboxMenuItem: "_9csa2XobkeFZUX8Fc_FNY",
				checkboxMenuItem: "_9csa2XobkeFZUX8Fc_FNY",
				DropdownRow: "x_9o8pHUgKrlsT51QhLnG",
				dropdownRow: "x_9o8pHUgKrlsT51QhLnG"
			}
		},
		"./src/reddit/components/PostModModeDropdown/DropdownHelpers.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			})), s.d(t, "d", (function() {
				return h
			})), s.d(t, "f", (function() {
				return g
			})), s.d(t, "g", (function() {
				return f
			})), s.d(t, "h", (function() {
				return x
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "b", (function() {
				return v
			})), s.d(t, "c", (function() {
				return C
			})), s.d(t, "e", (function() {
				return _
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/controls/CheckboxMenuItem/index.tsx"),
				a = s("./src/reddit/controls/Dropdown/Row.tsx"),
				r = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				i = s("./src/reddit/icons/fonts/Envelope/index.tsx"),
				d = s("./src/reddit/icons/fonts/Lock/index.tsx"),
				l = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				c = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				m = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				u = s("./src/reddit/components/PostModModeDropdown/DropdownHelpers.m.less"),
				p = s.n(u);
			const b = n.a.wrapped(r.a, "Icon", p.a),
				h = n.a.wrapped(i.a, "Icon", p.a),
				g = n.a.wrapped(d.a, "Icon", p.a),
				f = n.a.wrapped(l.a, "Icon", p.a),
				x = n.a.wrapped(c.a, "Icon", p.a),
				E = n.a.wrapped(m.a, "Icon", p.a),
				v = n.a.wrapped(o.b, "CheckboxMenuItem", p.a),
				C = n.a.wrapped(a.b, "DropdownRow", p.a),
				_ = n.a.div("ListContainer", p.a)
		},
		"./src/reddit/components/PostModModeDropdown/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/higherOrderComponents/makeAsync.tsx"),
				o = s("./src/lib/loadWithRetries/index.ts");
			const a = () => null;
			t.a = Object(n.a)({
				ErrorComponent: a,
				getComponent: () => Object(o.a)(() => s.e("ModerationDropdowns").then(s.bind(null, "./src/reddit/components/PostModModeDropdown/_PostModModeDropdown.tsx"))).then(e => e.default),
				LoadingComponent: a
			})
		},
		"./src/reddit/components/PostOverflowMenu/index.m.less": function(e, t, s) {
			e.exports = {
				overflowMenu: "_1EbinKu2t3KjaT2gR156Qp",
				DropdownRow: "_1muOrgIRB6t41qDocDiXul",
				dropdownRow: "_1muOrgIRB6t41qDocDiXul",
				disabledRow: "_2Odc33_zXVGMHX8Um_2eO7",
				AddCollectionIcon: "_3McOViCQeBaGf3kRQLi-YJ",
				addCollectionIcon: "_3McOViCQeBaGf3kRQLi-YJ",
				CalendarIcon: "_1zSdStUj7GoJJcKjQ7zhG8",
				calendarIcon: "_1zSdStUj7GoJJcKjQ7zhG8",
				Icon: "_2V4nGS1AmzWhA62lzdCu4r",
				icon: "_2V4nGS1AmzWhA62lzdCu4r",
				LinkIcon: "_1lgI_HBlGeEd4PRa5CuxRF",
				linkIcon: "_1lgI_HBlGeEd4PRa5CuxRF",
				LiveIcon: "otoj2GWn145x5kC1YJdJV",
				liveIcon: "otoj2GWn145x5kC1YJdJV",
				PostCheckboxMenuItem: "_3fGEO8uLSvUJEOP4lDX35p",
				postCheckboxMenuItem: "_3fGEO8uLSvUJEOP4lDX35p"
			}
		},
		"./src/reddit/components/PostOverflowMenu/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return he
			})), s.d(t, "b", (function() {
				return ge
			})), s.d(t, "c", (function() {
				return fe
			})), s.d(t, "d", (function() {
				return xe
			})), s.d(t, "f", (function() {
				return Ee
			})), s.d(t, "e", (function() {
				return ve
			})), s.d(t, "h", (function() {
				return Me
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/lib/constants/index.ts"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/react-router/esm/react-router.js"),
				l = s("./node_modules/reselect/es/index.js"),
				c = s("./src/telemetry/index.ts"),
				m = s("./src/lib/classNames/index.ts"),
				u = s("./src/lib/lessComponent.tsx"),
				p = s("./src/reddit/actions/eventPosts/index.ts"),
				b = s("./src/reddit/actions/gold/modals.ts"),
				h = s("./src/reddit/actions/modal.ts"),
				g = s("./src/reddit/actions/pinnedPost.ts"),
				f = s("./src/reddit/actions/post.ts"),
				x = s("./src/reddit/actions/postCreation/editing.ts"),
				E = s("./src/reddit/actions/reportFlow.ts"),
				v = s("./src/reddit/constants/posts.ts"),
				C = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				_ = s("./src/reddit/icons/fonts/Admin/index.tsx"),
				k = s("./src/reddit/icons/fonts/Calendar/index.tsx"),
				O = s("./src/reddit/icons/fonts/Embed/index.tsx"),
				y = s("./src/reddit/icons/fonts/Gift/index.tsx"),
				j = s("./src/reddit/icons/fonts/helpers.tsx"),
				w = s("./src/reddit/icons/fonts/Hide/index.m.less"),
				S = s.n(w);
			var I = u.a.wrapped(e => r.a.createElement("i", {
					className: "".concat(Object(j.b)("hide"), " ").concat(e.className)
				}), "HideIcon", S.a),
				P = s("./src/reddit/icons/fonts/Link/index.tsx"),
				T = s("./src/reddit/icons/fonts/Live/index.tsx"),
				N = s("./src/reddit/icons/fonts/Pencil/index.tsx"),
				M = s("./src/reddit/icons/fonts/Report/index.tsx"),
				R = s("./src/reddit/icons/fonts/Save/index.tsx"),
				L = s("./src/reddit/icons/fonts/Sticky/index.tsx"),
				A = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				F = s("./src/reddit/icons/fonts/Unpin/index.m.less"),
				D = s.n(F);
			var B = u.a.wrapped(e => r.a.createElement("i", {
					className: Object(m.a)(Object(j.b)("unpin"), e.className)
				}), "UnpinIcon", D.a),
				U = s("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				H = s("./src/reddit/icons/svgs/Saved/index.tsx"),
				W = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				V = s("./src/reddit/components/OverflowMenu/index.tsx"),
				q = s("./src/reddit/components/ReportFlow/index.tsx"),
				G = s("./src/reddit/contexts/PageLayer/index.tsx"),
				K = s("./src/reddit/controls/CheckboxMenuItem/index.tsx"),
				z = s("./src/reddit/controls/Dropdown/Row.tsx"),
				Q = s("./src/reddit/components/Flatlist/constants.ts"),
				J = s("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				Z = s("./src/reddit/constants/postLayout.ts"),
				X = s("./src/reddit/helpers/correlationIdTracker.ts"),
				Y = s("./src/reddit/helpers/isCrosspost.ts"),
				$ = s("./src/reddit/helpers/postEvent.ts"),
				ee = s("./src/reddit/helpers/trackers/post.ts"),
				te = s("./src/reddit/models/Subreddit/index.ts"),
				se = s("./src/reddit/selectors/activeModalId.ts"),
				ne = s("./src/reddit/selectors/posts.ts"),
				oe = s("./src/reddit/selectors/subreddit.ts"),
				ae = s("./src/reddit/selectors/user.ts"),
				re = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				ie = s("./src/reddit/components/PostFlairPicker/index.tsx"),
				de = s("./src/reddit/actions/postCollection/index.ts"),
				le = s("./src/reddit/helpers/trackers/postCollection.ts"),
				ce = s("./src/reddit/models/PostCreationForm/index.ts"),
				me = s("./src/reddit/selectors/postCollection.ts"),
				ue = s("./src/reddit/components/PostOverflowMenu/index.m.less"),
				pe = s.n(ue),
				be = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const he = u.a.wrapped(y.a, "Icon", pe.a),
				ge = u.a.wrapped(I, "Icon", pe.a),
				fe = u.a.wrapped(N.a, "Icon", pe.a),
				xe = u.a.wrapped(M.a, "Icon", pe.a),
				Ee = u.a.wrapped(H.a, "Icon", pe.a),
				ve = u.a.wrapped(R.a, "Icon", pe.a),
				Ce = u.a.wrapped(_.a, "Icon", pe.a),
				_e = u.a.wrapped(U.a, "AddCollectionIcon", pe.a),
				ke = u.a.wrapped(O.a, "Icon", pe.a),
				Oe = u.a.wrapped(L.a, "Icon", pe.a),
				ye = u.a.wrapped(A.a, "Icon", pe.a),
				je = u.a.wrapped(W.b, "Icon", pe.a),
				we = u.a.wrapped(B, "Icon", pe.a),
				Se = u.a.wrapped(T.a, "LiveIcon", pe.a),
				Ie = u.a.wrapped(k.a, "CalendarIcon", pe.a),
				Pe = u.a.wrapped(P.a, "LinkIcon", pe.a),
				Te = u.a.wrapped(z.b, "DropdownRow", pe.a),
				Ne = u.a.wrapped(K.a, "PostCheckboxMenuItem", pe.a),
				Me = e => {
					let {
						gild: t = !0,
						save: s = !0,
						share: n = !0,
						report: o = !0,
						editPost: a = !0,
						hide: r = !0
					} = e;
					return {
						[Q.a.Gild]: t,
						[Q.a.Save]: s,
						[Q.a.Share]: n,
						[Q.a.Report]: o,
						[Q.a.EditPost]: a,
						[Q.a.Hide]: r
					}
				},
				Re = Object(i.b)(() => Object(l.c)({
					currentUser: ae.i,
					isConfirmDeleteOpen: (e, t) => {
						let {
							postId: s
						} = t;
						return Object(se.a)(e) === "".concat("POST_OVERFLOW_DELETE_CONFIRMATION", "_").concat(s)
					},
					isFutureEvent: me.j,
					isSaved: ne.x,
					isHidden: ne.p,
					isSponsored: ne.z,
					isNSFW: ne.s,
					isOC: ne.t,
					isPinned: ne.u,
					isSpoiler: ne.y,
					post: ne.O,
					postSubredditAboutInfo: ne.P,
					reportFlowIsOpen: (e, t) => {
						let {
							isOverlay: s,
							postId: n
						} = t;
						return e.reportFlow.openedFromModalPage === s && e.reportFlow.postOrCommentId === n
					},
					sendRepliesToggled: ne.Y,
					showPinAction: (e, t) => {
						var {
							isProfilePostListing: s
						} = t, n = be(t, ["isProfilePostListing"]);
						return Object(G.B)(e, n) && s && Object(ae.hb)(e, n) && Object(ae.fb)(e, {
							userName: Object(ne.O)(e, {
								postId: n.postId
							}).author
						})
					},
					subredditOrProfile: ne.bb,
					hasSubredditRules: oe.k,
					userIsOp: ae.hb,
					isPostPartOfACollection: me.l,
					shouldRenderCollectionEditButtons: (e, t) => {
						let {
							postId: s
						} = t;
						if (Object(ne.O)(e, {
								postId: s
							}).isSponsored) return !1;
						const n = Object(ne.bb)(e, {
							postId: s
						});
						if (!n) return !1;
						const o = n.type === te.d.User;
						return Object(me.s)(e, n.name, o)
					}
				}), (e, t) => {
					let {
						permalink: s,
						postId: n,
						isOverlay: o,
						isCommentsPage: a
					} = t;
					return {
						onCopyLink: () => e(Object(f.G)(s)),
						onDelete: t => e(Object(f.P)(n, t, o)),
						onDistinguishPost: t => e(Object(f.y)(n, t)),
						onGildClick: t => e(Object(b.d)({
							correlationId: t,
							thingId: n
						})),
						onToggleSave: () => e(Object(f.W)(n)),
						onToggleNSFW: () => e(Object(f.L)(n)),
						onToggleOC: () => e(Object(f.M)(n)),
						onTogglePinned: () => e(Object(g.i)(n)),
						onToggleSpoiler: () => e(Object(f.Z)(n)),
						onHide: t => e(Object(f.ab)(n, !t, o, !0)),
						onReportClick: () => e(Object(E.j)(n, o)),
						onStartEventNow: () => {
							e((e, t) => Object(c.a)(Object(C.p)()(t()))), e(Object(p.startEventNowRequested)(n))
						},
						onEdit: () => {
							const t = !o && !a;
							e(Object(x.a)(n, t))
						},
						onFlairPost: () => e(Object(h.i)(Object(ie.b)(n, o))),
						onToggleSendReplies: () => e(Object(f.X)(n)),
						showCollectionsList: (t, s) => {
							e(Object(de.e)(t)).then(() => {
								const t = Object(ce.s)(s, o);
								e(h.i(t))
							})
						},
						toggleConfirmDelete: () => e(Object(h.i)("".concat("POST_OVERFLOW_DELETE_CONFIRMATION", "_").concat(n)))
					}
				});
			class Le extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.handlePostEvent = e => {
						const {
							isOverlay: t,
							post: s,
							sendEvent: n
						} = this.props;
						n(Object(ee.f)(s.id, e, t ? "post_detail" : "post"))
					}, this.handleClickMenuButton = () => {
						this.handlePostEvent("post_overflow_menu")
					}, this.handleDeletePost = e => {
						e && (this.props.onDelete(e), this.handlePostEvent("delete"))
					}, this.handleEdit = () => {
						this.handlePostEvent("edit"), this.props.onEdit()
					}, this.handleGild = async () => {
						const e = Object(X.d)(X.a.GildingFlow, !0);
						this.props.onGildClick(e);
						const {
							clickGildEvent: t
						} = await Promise.resolve().then(s.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						this.props.sendEvent(t(this.props.postId))
					}, this.toggleHide = () => {
						const e = this.props.isHidden ? "unhide" : "hide";
						this.handlePostEvent(e), this.props.onHide(this.props.isHidden)
					}, this.toggleSave = () => {
						const e = this.props.isSaved ? "unsave" : "save";
						this.handlePostEvent(e), this.props.onToggleSave()
					}, this.handleReport = () => {
						this.handlePostEvent("report"), this.props.onReportClick()
					}, this.toggleOC = () => {
						this.handlePostEvent(this.props.isOC ? "unmark_original_content" : "mark_original_content"), this.props.onToggleOC()
					}, this.togglePinned = () => {
						this.handlePostEvent(this.props.isPinned ? "unpin" : "pin"), this.props.isPinned ? this.props.sendEvent(Object(ee.g)(this.props.post.id)) : this.props.sendEvent(Object(ee.c)(this.props.post.id)), this.props.onTogglePinned()
					}, this.toggleSpoiler = () => {
						this.handlePostEvent(this.props.isSpoiler ? "unmark_spoiler" : "mark_spoiler"), this.props.onToggleSpoiler()
					}, this.toggleNSFW = () => {
						this.handlePostEvent(this.props.isNSFW ? "unmark_nsfw" : "mark_nsfw"), this.props.onToggleNSFW()
					}, this.getBreakpointClass = e => {
						const {
							props: t
						} = this;
						if (!t.ignoreBreakpoints && t.useFlatlistBreakpoints[e]) return Object(J.b)({
							breakpointType: J.a.HideIfVWLarger,
							flatlistItem: e,
							isLoggedIn: !!t.currentUser,
							isUserOp: t.userIsOp
						})
					}, this.handleAddToCollection = () => {
						const {
							isPostPartOfACollection: e,
							showCollectionsList: t,
							post: s,
							sendEvent: n
						} = this.props;
						e || (n(Object(le.b)(s.id)), t(s.belongsTo.id, s.id))
					}
				}
				getOverflowMenuBreakpointClass() {
					const {
						props: e
					} = this, t = e.layout === Z.g.Classic;
					if (!(e.ignoreBreakpoints || e.modModeWithPost || e.userIsOp || !e.isCommentsPage && !t)) return Object(J.b)({
						breakpointType: J.a.HideIfVWLarger,
						flatlistItem: Q.a.PostOverflowMenu,
						isLoggedIn: !!e.currentUser,
						isUserOp: e.userIsOp
					})
				}
				renderDropdownIcons() {
					const {
						props: e
					} = this, {
						currentUser: t,
						isFutureEvent: s,
						isPinned: a,
						onStartEventNow: i,
						post: d,
						shouldRenderCollectionEditButtons: l,
						showEditFlair: c,
						showPinAction: m,
						toggleAddEventStartTimeModal: u,
						toggleEditStartTimeModal: p,
						userIsOp: b
					} = e, h = e.currentUser && e.currentUser.isEmployee, g = Object(Y.a)(e.post), f = e.post.belongsTo.type === v.a.PROFILE || Object(te.e)(e.postSubredditAboutInfo), x = t && d.isGildable, E = Object($.a)(e.post);
					return r.a.createElement("div", null, x && r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.Gild),
						displayText: n.fbt._("Give Award", null, {
							hk: "3mYeGJ"
						}),
						onClick: this.handleGild
					}, r.a.createElement(he, null)), r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.Share),
						displayText: n.fbt._("Copy link", null, {
							hk: "ETZxA"
						}),
						onClick: () => {
							this.handlePostEvent("share_copy"), e.onCopyLink()
						}
					}, r.a.createElement(Pe, null)), r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.Share),
						displayText: n.fbt._("Embed", null, {
							hk: "3u0v6r"
						}),
						onClick: () => {
							this.handlePostEvent("share_embed"), window.open("https://embed.redditmedia.com/widgets/embed?url=".concat(e.post.permalink), "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, r.a.createElement(ke, null)), e.showEditPost && r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.EditPost),
						displayText: n.fbt._("Edit post", null, {
							hk: "3gVzz0"
						}),
						onClick: this.handleEdit,
						isSelected: e.isHidden
					}, r.a.createElement(fe, null)), c && r.a.createElement(Te, {
						displayText: n.fbt._("Edit flair", null, {
							hk: "qt3W7"
						}),
						onClick: e.onFlairPost,
						isSelected: e.isHidden
					}, r.a.createElement(ye, null)), r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.Save),
						displayText: e.isSaved ? n.fbt._("unsave", null, {
							hk: "HDDPm"
						}) : n.fbt._("save", null, {
							hk: "3bg2gs"
						}),
						onClick: this.toggleSave,
						isSelected: e.isSaved
					}, e.isSaved ? r.a.createElement(Ee, null) : r.a.createElement(ve, null)), m && r.a.createElement(Te, {
						displayText: a ? n.fbt._("Unpin Post from Profile", null, {
							hk: "6DYfk"
						}) : n.fbt._("Pin Post to Profile", null, {
							hk: "2RWbNF"
						}),
						onClick: this.togglePinned
					}, this.props.isPinned ? r.a.createElement(we, null) : r.a.createElement(Oe, null)), !e.isSponsored && r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.Hide),
						displayText: e.isHidden ? n.fbt._("unhide", null, {
							hk: "1P4IxC"
						}) : n.fbt._("hide", null, {
							hk: "48yKzW"
						}),
						onClick: this.toggleHide,
						isSelected: e.isHidden
					}, r.a.createElement(ge, null)), !e.isSponsored && !b && r.a.createElement(Te, {
						className: this.getBreakpointClass(Q.a.Report),
						displayText: n.fbt._("report", null, {
							hk: "128RPn"
						}),
						onClick: this.handleReport
					}, r.a.createElement(xe, null)), l && s && i && r.a.createElement(Te, {
						onClick: i,
						displayText: n.fbt._("Start event now", null, {
							hk: "3VomTN"
						})
					}, r.a.createElement(Se, null)), l && s && p && r.a.createElement(Te, {
						onClick: p,
						displayText: n.fbt._("Edit start time", null, {
							hk: "2typ17"
						})
					}, r.a.createElement(Ie, null)), l && !E && u && r.a.createElement(Te, {
						displayText: n.fbt._("Add event start time", null, {
							hk: "1XXqzu"
						}),
						onClick: u
					}, r.a.createElement(Ie, null)), l && r.a.createElement(Te, {
						className: this.props.isPostPartOfACollection ? pe.a.disabledRow : void 0,
						displayText: n.fbt._("Add to collection", null, {
							hk: "3UNHgN"
						}),
						onClick: this.handleAddToCollection,
						noHover: this.props.isPostPartOfACollection
					}, r.a.createElement(_e, null)), b && r.a.createElement(Te, {
						displayText: n.fbt._("delete", null, {
							hk: "4kSfzC"
						}),
						onClick: this.props.toggleConfirmDelete
					}, r.a.createElement(je, null)), h && e.userIsOp && r.a.createElement(Te, {
						displayText: e.post.distinguishType === o.C.ADMIN ? n.fbt._("undistinguish", null, {
							hk: "2chGON"
						}) : n.fbt._("Distinguish as admin", null, {
							hk: "2xltiM"
						}),
						onClick: () => e.post.distinguishType === o.C.ADMIN ? e.onDistinguishPost(o.C.NONE) : e.onDistinguishPost(o.C.ADMIN)
					}, r.a.createElement(Ce, null)), b && f && !g && r.a.createElement(Ne, {
						text: n.fbt._("Mark as OC", null, {
							hk: "2vGyoC"
						}),
						onClick: this.toggleOC,
						isSelected: this.props.isOC
					}), b && r.a.createElement(Ne, {
						text: n.fbt._("Mark as Spoiler", null, {
							hk: "3PJk7A"
						}),
						onClick: this.toggleSpoiler,
						isSelected: this.props.isSpoiler
					}), b && r.a.createElement(Ne, {
						text: n.fbt._("Mark as NSFW", null, {
							hk: "4qK6JN"
						}),
						onClick: this.toggleNSFW,
						isSelected: this.props.isNSFW
					}), e.userIsOp && r.a.createElement(Ne, {
						text: n.fbt._("Send me reply notifications", null, {
							hk: "6AmTA"
						}),
						onClick: e.onToggleSendReplies,
						isSelected: this.props.sendRepliesToggled
					}))
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement("div", null, r.a.createElement(V.b, {
						className: Object(m.a)(pe.a.overflowMenu, this.getOverflowMenuBreakpointClass(), e.className),
						dropdownId: e.dropdownId,
						isFixed: e.isFixed,
						layout: e.layout,
						onClick: this.handleClickMenuButton
					}, this.renderDropdownIcons()), e.reportFlowIsOpen && e.subredditOrProfile && e.hasSubredditRules && r.a.createElement(q.a, {
						withOverlay: !0,
						overlayCustomStyles: q.b,
						postId: e.postId
					}), this.props.isConfirmDeleteOpen && r.a.createElement(Ae, {
						toggleConfirmDelete: this.props.toggleConfirmDelete,
						handleDeletePost: this.handleDeletePost
					}))
				}
			}
			const Ae = Object(d.i)(e => r.a.createElement(re.a, {
				toggleModal: e.toggleConfirmDelete,
				onConfirm: () => e.handleDeletePost(e.location),
				actionText: n.fbt._("delete post", null, {
					hk: "49hVoG"
				}),
				headerText: n.fbt._("Delete post?", null, {
					hk: "3g7QoX"
				}),
				modalText: n.fbt._("Are you sure you want to delete your post? You can't undo this.", null, {
					hk: "2eDKWP"
				}),
				withOverlay: !0
			}));
			t.g = Re(Le)
		},
		"./src/reddit/components/PostRailAndVotes/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/ModerationPrompts/Prompt.tsx"),
				r = s("./src/reddit/components/ModerationPrompts/Survey.tsx"),
				i = s("./src/reddit/components/PopupPortal/index.tsx"),
				d = s("./src/reddit/components/PostLeftRail/index.tsx"),
				l = s("./src/reddit/components/VerticalVotes/index.tsx"),
				c = s("./src/reddit/controls/Checkbox/index.tsx"),
				m = s("./src/reddit/helpers/isPost.ts"),
				u = s("./src/reddit/helpers/showReportIndicator/index.ts");
			t.a = e => {
				const {
					model: t,
					handleVote: s,
					showBulkActionCheckbox: n = !1,
					isCheckboxSelected: p = !1,
					toggleCheckbox: b = (() => {}),
					flairStyleTemplate: h,
					redditStyle: g,
					subreddit: f,
					isOverlay: x
				} = e, E = "upvote-button-".concat(t.id).concat(x ? "-overlay" : ""), {
					moderationPrompt: v
				} = t;
				return o.a.createElement(d.b, {
					isRemoved: !!t.bannedBy,
					isReported: Object(u.a)(t),
					isSponsored: !!Object(m.b)(t) && t.isSponsored,
					redditStyle: g
				}, n && o.a.createElement(c.a, {
					isCheckboxSelected: p,
					toggleCheckbox: b
				}), o.a.createElement(l.a, {
					flairStyleTemplate: h,
					model: t,
					onVoteClick: s,
					redditStyle: g,
					upvoteTooltipId: E
				}), v && o.a.createElement(i.b, {
					rightOf: E
				}, "survey" === v ? o.a.createElement(r.a, {
					post: t,
					subredditName: f.name,
					isOverlay: !!x
				}) : o.a.createElement(a.a, {
					post: t,
					subredditName: f.name,
					isOverlay: !!x
				})))
			}
		},
		"./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/config.ts"),
				r = s("./src/lib/prettyPrintNumber/index.ts"),
				i = s("./src/reddit/helpers/awards/getIconForSize.ts"),
				d = s("./src/reddit/components/ProfileIdCard/index.m.less"),
				l = s.n(d);
			const {
				fbt: c
			} = s("./node_modules/fbt/lib/FbtPublic.js");
			class m extends o.a.PureComponent {
				render() {
					const {
						prefersReducedMotion: e,
						recentAwardings: t,
						username: s
					} = this.props;
					if (!t.topAward) return null;
					const {
						topAward: n,
						totalCount: d
					} = t, m = Object(i.a)(n, 32, e), u = n.description ? n.description : n.name;
					return o.a.createElement("a", {
						className: l.a.AwardedLastMonth,
						href: "".concat(a.a.oldRedditUrl, "/user/").concat(s, "/gilded")
					}, o.a.createElement("div", {
						className: l.a.iconColumn
					}, o.a.createElement("img", {
						alt: u,
						className: l.a.icon,
						src: m
					}), d > 1 && o.a.createElement("span", {
						className: l.a.count
					}, "+".concat(Object(r.b)(d - 1)))), o.a.createElement("div", {
						className: l.a.textColumn
					}, c._({
						"*": "Received the {award-name} Award and more in the past 30 days",
						_1: "Received the {award-name} Award in the past 30 days"
					}, [c._param("award-name", n.name), c._plural(d)], {
						hk: "16MJHe"
					})))
				}
			}
			t.a = m
		},
		"./src/reddit/components/ProfileIdCard/index.m.less": function(e, t, s) {
			e.exports = {
				SnooIconWrapper: "_308WM6C-yV5iwS0Iy8nOfI",
				snooIconWrapper: "_308WM6C-yV5iwS0Iy8nOfI",
				actionItem: "_1l7CTV4NjDjmzX8DiiSgTL",
				AwardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				awardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				textColumn: "_wi1DtT7oN7k_x5oIV8zm",
				iconColumn: "_32tzMaZn7x3dfQC5MXndJn",
				icon: "_12jN4wdttUosp76WHzuieI",
				count: "_6xPPP5HdELF-SZJL8layH",
				awardIcon: "_2Eq8z6UD7I0ul3wnZ-YT80",
				adminIcon: "_1sNQxemH_0rq1jtZAMyAZd",
				button: "_2q1wcTx60QKM_bQ1Maev7b"
			}
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, s) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/ProgressBar/index.m.less"),
				i = s.n(r);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: s,
					percent: n
				} = e;
				return o.a.createElement("div", {
					className: Object(a.a)(i.a.outerBar, t)
				}, o.a.createElement("div", {
					className: Object(a.a)(i.a.innerBar, s),
					style: {
						width: "".concat(n.toFixed(2), "%")
					}
				}))
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.m.less": function(e, t, s) {
			e.exports = {
				StyledRawHTMLDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH",
				styledRawHtmlDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/polished/dist/polished.es.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = s("./src/lib/lessComponent.tsx"),
				l = s("./src/reddit/actions/page.ts"),
				c = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				m = s("./src/reddit/components/RawHTMLDisplay/index.m.less"),
				u = s.n(m);
			const p = Object(r.b)(null, e => ({
					onNavigate: t => e(Object(l.G)(t))
				})),
				b = d.a.wrapped(e => a.a.createElement("div", {
					className: e.className,
					dangerouslySetInnerHTML: {
						__html: e.html
					},
					onClick: t => {
						((e, t, s) => {
							if (!e.ctrlKey && !e.metaKey && 1 !== e.button && "A" === e.target.tagName) {
								e.preventDefault(), t(e.target.getAttribute("href"))
							}
							e.target.classList && e.target.classList.contains("md-spoiler-text") && (e.target.dataset.revealed = !0), s && s(e)
						})(t, e.onNavigate, e.onClick)
					},
					style: Object.assign({}, e.style, {
						"--RawHTMLDisplay-tr-even": Object(n.g)(Object(c.a)(e).body, .8),
						"--RawHTMLDisplay-tr-odd": Object(n.g)(Object(c.a)(e).line, .8)
					})
				}), "StyledRawHTMLDisplay", u.a);
			t.a = p(Object(i.a)(b))
		},
		"./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less": function(e, t, s) {
			e.exports = {
				button: "_1i9YssSDgp0wmEC43VdLTX",
				prevButton: "_2IBDYNRoTxtwgs13LWRpeM",
				arrowIcon: "QD6Re7us6VNRFNYSiD6to",
				disabled: "_3Lm3n-nPFfEcJoNjVwcm3r"
			}
		},
		"./src/reddit/components/RecurringPostList/EditModal/async.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(n.a)({
				resolved: {},
				chunkName: () => "reddit-components-RecurringPostList-EditModal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!s.m[t]
				},
				importAsync: () => s.e("reddit-components-RecurringPostList-EditModal").then(s.bind(null, "./src/reddit/components/RecurringPostList/EditModal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return s(t)
				},
				resolve() {
					return "./src/reddit/components/RecurringPostList/EditModal/index.tsx"
				}
			})
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less": function(e, t, s) {
			e.exports = {
				contentRow: "Bt3uIal7yhwFSN9JorIng",
				contentRowMeta: "t6hD4d7F06TL2yv9vfp7h",
				title: "_3Evplg8YGmH6GDFsdQ0_nE",
				ownerName: "_215cUXwEuCE5hl0eYEIt_o",
				ownerNameContainer: "_2yAEv_Vw_ItUYbNbAjpSsL"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_29n8ITXzfA7e5YAUZXR5Tv",
				metaRow: "NjfRmSRZrEkWYNAACYBql",
				replayIcon: "_17pwQtUdmIHAeybqNegNzP",
				recurrenceRules: "rX2aiRDwgPF22x70hQxqp",
				pencilIcon: "z5A_DxaYn2G2TQSSQCpi2"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return N
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./src/telemetry/index.ts"),
				i = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/actions/modal.ts"),
				l = s("./src/reddit/actions/scheduledPosts/index.ts"),
				c = s("./src/reddit/components/AuthorLink/index.tsx"),
				m = s("./src/reddit/components/Thumbnail/index.tsx"),
				u = s("./src/reddit/components/RecurringPostList/Thumbnail/index.m.less"),
				p = s.n(u);
			var b = e => {
					let {
						post: t
					} = e;
					return o.a.createElement("div", {
						className: p.a.thumbnailContainer
					}, o.a.createElement(m.a, {
						post: t,
						contentTypeClassName: p.a.placeholderIcon
					}))
				},
				h = s("./src/reddit/components/ScheduledPost/index.tsx"),
				g = s("./src/reddit/models/ScheduledPost/index.ts"),
				f = s("./node_modules/reselect/es/index.js"),
				x = s("./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less"),
				E = s.n(x);
			const {
				fbt: v
			} = s("./node_modules/fbt/lib/FbtPublic.js"), C = Object(f.c)({
				media: (e, t) => {
					let {
						scheduledPost: s
					} = t;
					return Object.assign({}, h.b, {
						isNSFW: s.isNsfw,
						title: s.title
					})
				}
			});
			var _ = Object(a.b)(C)(e => o.a.createElement("div", {
					className: Object(i.a)(E.a.contentRow, e.className)
				}, o.a.createElement(b, {
					post: e.media
				}), o.a.createElement("div", {
					className: E.a.contentRowMeta
				}, o.a.createElement("div", {
					className: E.a.title
				}, e.scheduledPost.title), o.a.createElement("div", {
					className: E.a.ownerNameContainer
				}, Object(g.l)(e.scheduledPost.owner) && o.a.createElement("span", {
					className: E.a.ownerName
				}, v._("by {username}", [v._param("username", o.a.createElement(c.a, {
					author: e.scheduledPost.owner.name,
					isUnstyled: !0
				}, e.scheduledPost.owner.prefixedName))], {
					hk: "FAgpK"
				})), e.children)))),
				k = s("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx");
			var O = Object(k.a)(e => o.a.createElement(o.a.Fragment, null, e.renderOverflowMenu())),
				y = s("./src/reddit/helpers/scheduledPosts/index.ts"),
				j = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				w = s("./src/reddit/icons/svgs/Pencil/index.tsx"),
				S = s("./src/reddit/icons/svgs/Replay/index.tsx"),
				I = s("./src/reddit/components/RecurringPostList/RecurringPost/index.m.less"),
				P = s.n(I);
			const {
				fbt: T
			} = s("./node_modules/fbt/lib/FbtPublic.js"), N = "RECURRING_POSTS__EDIT", M = Object(a.b)(null, (e, t) => ({
				editRecurringPostRequested: () => {
					e(Object(l.c)({
						id: t.item.id,
						subredditId: t.item.subreddit.id
					})), e((e, t) => Object(r.a)(Object(j.g)()(t()))), e(Object(d.i)(N))
				},
				onOpenOverflow: () => {
					e((e, t) => Object(r.a)(Object(j.l)(!0)(t())))
				},
				onUpdateMetadata: s => e(Object(l.b)(s, t.item))
			}));
			class R extends o.a.PureComponent {
				render() {
					const {
						className: e,
						item: t,
						editRecurringPostRequested: s
					} = this.props, n = Object(y.e)(t);
					return o.a.createElement("div", {
						className: Object(i.a)(e, P.a.container)
					}, o.a.createElement("div", {
						className: P.a.metaRow
					}, o.a.createElement(S.a, {
						className: P.a.replayIcon
					}), o.a.createElement("div", {
						className: P.a.recurrenceRules,
						title: n
					}, n), o.a.createElement("button", {
						onClick: s
					}, o.a.createElement(w.a, {
						className: P.a.pencilIcon
					}))), o.a.createElement(_, {
						scheduledPost: t
					}, o.a.createElement(O, {
						scheduledPost: t,
						onUpdateMetadata: this.props.onUpdateMetadata,
						onOpenOverflow: this.props.onOpenOverflow
					})))
				}
			}
			t.b = M(R)
		},
		"./src/reddit/components/RecurringPostList/Thumbnail/index.m.less": function(e, t, s) {
			e.exports = {
				placeholderIcon: "_2rWvDY38-Fa_14y347Il6W",
				thumbnailContainer: "_3cYCw7NYRAJwj6LvL8esBu"
			}
		},
		"./src/reddit/components/RecurringPostList/index.m.less": function(e, t, s) {
			e.exports = {
				titleContainer: "p9wLLlADU1pVQu4nx3HCF",
				postList: "_1qL48rnJIqcVj5nNuXkDSw",
				pageButtonPortal: "_3lBUQT-Vexm0jXk3WmIYJq",
				recurringPostsContainer: "_2UggIw0Xee7HvpOtrWrepd",
				lastRecurringPostItem: "dx2RjIkNec1E2-a1DyP07",
				emptyContainer: "_1Aurc-hBrd1zsfrQxHeZoq",
				icon: "_1BRYUIpfNcLUEr5L8DeJ8i",
				schedulePostLink: "_1mxUgytAdxfLqJuzRgGifT"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less": function(e, t, s) {
			e.exports = {
				DisplayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				displayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				DropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				dropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				ReasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				reasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				Dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				DropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				dropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				DropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				dropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				DropdownContainer: "_33sg6HoBYll4rCDqRzRUdu",
				dropdownContainer: "_33sg6HoBYll4rCDqRzRUdu"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less": function(e, t, s) {
			e.exports = {
				CharacterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				characterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				EmptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				emptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				ModNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				modNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				PrimaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				primaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				RadioOption: "_30JuaHooKBU-I9UQwxEwhL",
				radioOption: "_30JuaHooKBU-I9UQwxEwhL",
				BoldText: "_22_ggqyuhsjDD3F2auyNjc",
				boldText: "_22_ggqyuhsjDD3F2auyNjc",
				ModNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				modNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				MessageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				messageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				Info: "_3Bf1PCbZnJJBM391IWRv8D",
				info: "_3Bf1PCbZnJJBM391IWRv8D",
				SmallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				smallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				FormOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				formOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				ModalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				modalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				FooterRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				footerRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				ButtonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				buttonRow: "_3zZmX0EjloIkzwt2-sRI2_"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/higherOrderComponents/asModal/index.tsx"),
				d = s("./src/lib/lessComponent.tsx"),
				l = s("./src/reddit/actions/removalReasons/index.ts"),
				c = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = s("./src/reddit/controls/Button/index.tsx"),
				p = s("./src/reddit/controls/InternalLink/index.tsx"),
				b = s("./src/reddit/controls/RadioInput/index.tsx"),
				h = s("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				g = s("./src/reddit/controls/TextButton/index.tsx"),
				f = s("./src/reddit/icons/fonts/Info/index.tsx"),
				x = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				E = s("./src/reddit/models/RemovalReason/index.ts"),
				v = s("./src/reddit/selectors/removalReasons.ts"),
				C = s("./src/reddit/selectors/subreddit.ts"),
				_ = s("./src/reddit/selectors/user.ts"),
				k = s("./node_modules/fbt/lib/FbtPublic.js"),
				O = s("./src/reddit/controls/Dropdown/index.tsx"),
				y = s("./src/reddit/controls/Dropdown/Row.tsx"),
				j = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				w = s("./src/reddit/layout/row/Inline/index.tsx"),
				S = s("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less"),
				I = s.n(S);
			const P = d.a.wrapped(w.a, "DisplayContainer", I.a),
				T = d.a.div("DropdownLabel", I.a),
				N = d.a.div("ReasonTitle", I.a),
				M = e => o.a.createElement(P, null, o.a.createElement(T, null, e.dropdownLabel), e.selectedReason && o.a.createElement(N, null, e.selectedReason)),
				R = d.a.wrapped(O.a, "Dropdown", I.a),
				L = d.a.wrapped(j.b, "DropdownTriangle", I.a),
				A = d.a.wrapped(y.b, "DropdownRow", I.a),
				F = d.a.button("DropdownContainer", I.a);
			var D = e => o.a.createElement(F, {
					onClick: e.onToggleDropdown
				}, o.a.createElement(M, {
					dropdownLabel: e.isLoading ? k.fbt._("Loading...", null, {
						hk: "1bT6op"
					}) : k.fbt._("Reason for removal", null, {
						hk: "3C9ecg"
					}),
					selectedReason: e.selectedReason ? e.selectedReason.title : null
				}), o.a.createElement(L, null), e.isDropdownOpen && o.a.createElement(R, {
					isOverlay: !0
				}, o.a.createElement(A, {
					displayText: k.fbt._("None", null, {
						hk: "2443EZ"
					}),
					onClick: () => e.onSelectReason(null)
				}), e.subredditRemovalReasons.map((t, s) => o.a.createElement(A, {
					displayText: "".concat(s + 1, ". ").concat(t.title),
					key: t.title,
					onClick: () => e.onSelectReason(t)
				})))),
				B = s("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less"),
				U = s.n(B);
			const {
				fbt: H
			} = s("./node_modules/fbt/lib/FbtPublic.js"), W = e => {
				switch (e) {
					case E.f.Private:
						return "private_subreddit";
					case E.f.PrivateExposed:
						return "private_personal";
					default:
						return e
				}
			}, V = {
				isDropdownOpen: !1,
				message: "",
				modNote: "",
				removalType: E.f.Public,
				selectedReason: null
			}, q = Object(r.c)({
				currentUserName: e => {
					const t = Object(_.i)(e);
					if (t) return t.displayText
				},
				isLoading: v.a,
				removalReasons: v.c,
				subredditName: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(C.R)(e, {
						subredditId: s
					}).name
				}
			}), G = Object(a.b)(q, e => ({
				submitBulkRemovalReason: (t, s, n, o, a) => e(Object(l.submitBulkRemovalReason)(t, s, n, o, a)),
				submitRemovalReason: (t, s, n, o, a) => e(Object(l.submitRemovalReason)(t, s, n, o, a))
			})), K = d.a.wrapped(c.a, "CharacterCountdown", U.a), z = d.a.div("EmptyState", U.a), Q = d.a.wrapped(m.n, "ModNoteDescription", U.a), J = d.a.wrapped(u.f, "PrimaryButton", U.a), Z = d.a.wrapped(h.a, "RadioOption", U.a), X = d.a.span("BoldText", U.a), Y = d.a.wrapped(m.s, "ModNoteInput", U.a), $ = d.a.wrapped(m.s, "MessageInput", U.a), ee = d.a.wrapped(f.a, "Info", U.a), te = d.a.div("SmallInfoText", U.a), se = d.a.div("FormOptionsContainer", U.a), ne = d.a.wrapped(m.f, "ModalFooter", U.a), oe = d.a.div("FooterRow", U.a), ae = d.a.wrapped(oe, "ButtonRow", U.a);
			class re extends o.a.Component {
				constructor(e) {
					super(e), this.onSelectRemovalType = e => {
						this.setState({
							removalType: e
						}), this.props.trackClick("type_".concat(W(e)))()
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onUpdateModNote = e => {
						this.setState({
							modNote: e.currentTarget.value
						})
					}, this.handleToggleDropdown = () => this.setState({
						isDropdownOpen: !this.state.isDropdownOpen
					}), this.closeDropdown = () => {
						this.state.isDropdownOpen && this.setState({
							isDropdownOpen: !1
						})
					}, this.onSelectReason = e => {
						this.setState({
							selectedReason: e
						}), this.props.trackClick("reason")(), e && this.setState({
							message: e.message
						}), this.closeDropdown()
					}, this.canSave = () => !(this.state.message.length > E.a || this.state.modNote.length > E.b) && (this.state.selectedReason ? this.state.message.trim().length > 0 : this.state.modNote.trim().length > 0), this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.canSave()) {
							(t.removalContextType === E.e.Bulk ? e.submitBulkRemovalReason : e.submitRemovalReason)(e.itemIds, t.selectedReason, t.message.trim(), t.removalType, t.modNote.trim()), e.trackClick("sent")(), t.selectedReason && e.trackClick("sent_".concat(W(t.removalType)))(), t.modNote && e.trackClick("sent_modnote")(), e.toggleModal()
						}
					}, this.onCancel = () => {
						this.props.toggleModal(), this.props.trackClick("cancel")()
					}, this.renderRemovalTypeOptions = () => {
						const {
							props: e,
							state: t
						} = this, s = [];
						return t.removalContextType !== E.e.Bulk && s.push(o.a.createElement(Z, {
							key: E.f.Public,
							showButton: !0,
							tabIndex: 0,
							value: E.f.Public
						}, o.a.createElement("div", null, t.removalContextType === E.e.Post ? H._("Public: Write a sticky comment on the post", null, {
							hk: "1UIQkF"
						}) : H._("Public: Write a reply to the comment", null, {
							hk: "1iZ1RC"
						})))), s.push(o.a.createElement(Z, {
							key: E.f.Private,
							showButton: !0,
							tabIndex: 0,
							value: E.f.Private
						}, o.a.createElement("div", null, H._("Private: send a Modmail from {subredditName} to the user", [H._param("subredditName", o.a.createElement(X, null, "r/".concat(e.subredditName)))], {
							hk: "1wUxMe"
						})))), e.currentUserName && s.push(o.a.createElement(Z, {
							key: E.f.PrivateExposed,
							showButton: !0,
							tabIndex: 0,
							value: E.f.PrivateExposed
						}, o.a.createElement("div", null, H._("Private: send a Modmail from {currentUserName} to the user", [H._param("currentUserName", o.a.createElement(X, null, "u/".concat(e.currentUserName)))], {
							hk: "wFSJr"
						})))), s
					}, this.state = Object.assign({}, V, {
						removalContextType: Object(E.g)(e.itemIds)
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(m.d, {
						onClick: this.closeDropdown
					}, e.isLoading || e.removalReasons.length > 0 && o.a.createElement(m.h, null, o.a.createElement(x.a, null, o.a.createElement(m.p, null, H._("Add a removal reason", null, {
						hk: "4odEgX"
					}), e.itemIds.length > 1 && H._("({number of items} posts/comments)", [H._param("number of items", e.itemIds.length)], {
						hk: "4u7ZzL"
					})), o.a.createElement(g.a, {
						onClick: this.onCancel
					}, o.a.createElement(m.b, null)))), o.a.createElement(m.k, null, e.isLoading || e.removalReasons.length > 0 ? o.a.createElement(D, {
						isDropdownOpen: t.isDropdownOpen,
						isLoading: e.isLoading,
						onSelectReason: this.onSelectReason,
						onToggleDropdown: this.handleToggleDropdown,
						selectedReason: t.selectedReason,
						subredditRemovalReasons: e.removalReasons
					}) : o.a.createElement(z, null, H._("You don't have any removal reasons yet", null, {
						hk: "2cPgPy"
					}), o.a.createElement(p.a, {
						to: "/r/".concat(e.subredditName, "/about/removal"),
						target: "_blank"
					}, o.a.createElement(u.n, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, H._("Add a removal reason", null, {
						hk: "3MHM7e"
					})))), t.selectedReason && o.a.createElement(se, null, o.a.createElement(m.g, null, o.a.createElement(b.a, {
						name: "REMOVAL_REASON_INPUT",
						onChange: this.onSelectRemovalType,
						value: t.removalType
					}, this.renderRemovalTypeOptions())), o.a.createElement($, {
						value: t.message,
						onChange: this.onMessageInputChange
					}), o.a.createElement(K, {
						maxChars: E.a,
						text: t.message.trim()
					}), o.a.createElement(te, null, t.removalType !== E.f.Public && o.a.createElement(o.a.Fragment, null, o.a.createElement(ee, null), H._("A link to the removed content will be appended to your message", null, {
						hk: "1DbEGF"
					}))))), o.a.createElement(ne, null, o.a.createElement(oe, null, o.a.createElement(Q, null, H._("Mod note (Only mods will see this note)", null, {
						hk: "3InAsy"
					}))), o.a.createElement(oe, null, o.a.createElement(Y, {
						placeholder: H._("This is a short note to your mod team on why the content was removed.", null, {
							hk: "4goqsC"
						}),
						value: t.modNote,
						onChange: this.onUpdateModNote
					})), o.a.createElement(oe, null, o.a.createElement(K, {
						maxChars: E.b,
						text: t.modNote.trim()
					})), o.a.createElement(ae, null, o.a.createElement(u.i, {
						onClick: this.onCancel,
						"data-redditstyle": !0
					}, H._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(J, {
						onClick: this.onSubmit,
						disabled: !this.canSave(),
						"data-redditstyle": !0
					}, H._("Submit", null, {
						hk: "42zLFy"
					})))))
				}
			}
			t.default = Object(i.a)(G(re))
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less": function(e, t, s) {
			e.exports = {
				GenericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				genericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				DeleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				deleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				PrimaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				primaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				TextArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				textArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				ModalFooter: "a8KANZ6wvta1y_8QSZmeS",
				modalFooter: "a8KANZ6wvta1y_8QSZmeS",
				Input: "tWupUgopHVvjD9_bZZVy0",
				input: "tWupUgopHVvjD9_bZZVy0"
			}
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less": function(e, t, s) {
			e.exports = {
				EditButton: "_3Z3niHttcaJCxThBE2-eNN",
				editButton: "_3Z3niHttcaJCxThBE2-eNN",
				Row: "_1ERpdeakuaRdyW5OEGvV_a",
				row: "_1ERpdeakuaRdyW5OEGvV_a",
				ReasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				reasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				ReasonText: "_3Vv7n3XK-P5uslyAy7Li0w",
				reasonText: "_3Vv7n3XK-P5uslyAy7Li0w"
			}
		},
		"./src/reddit/components/RemovalReasons/index.m.less": function(e, t, s) {
			e.exports = {
				Rules: "-z_XjylM-4VxXIVlUJupm",
				rules: "-z_XjylM-4VxXIVlUJupm"
			}
		},
		"./src/reddit/components/RemovalReasons/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/lessComponent.tsx"),
				c = s("./src/reddit/actions/modal.ts"),
				m = s("./src/reddit/actions/removalReasons/index.ts"),
				u = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				p = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				b = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				h = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = s("./src/reddit/controls/Button/index.tsx"),
				f = s("./src/reddit/icons/svgs/Rules/index.tsx"),
				x = s("./src/reddit/models/RemovalReason/index.ts"),
				E = s("./src/reddit/selectors/activeModalId.ts"),
				v = s("./src/reddit/selectors/removalReasons.ts"),
				C = s("./src/higherOrderComponents/asModal/index.tsx"),
				_ = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				k = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				O = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				y = s("./src/reddit/controls/TextButton/index.tsx"),
				j = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				w = s("./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less"),
				S = s.n(w);
			const I = {
					message: "",
					title: ""
				},
				P = l.a.wrapped(k.e, "GenericGreetingText", S.a),
				T = l.a.wrapped(k.r, "DeleteReasonButton", S.a),
				N = l.a.wrapped(g.f, "PrimaryButton", S.a),
				M = l.a.wrapped(k.s, "TextArea", S.a),
				R = l.a.wrapped(k.f, "ModalFooter", S.a),
				L = l.a.wrapped(O.c, "Input", S.a);
			class A extends r.a.Component {
				constructor(e) {
					super(e), this.onTitleInputChange = e => {
						e.currentTarget.value.length <= x.d && this.setState({
							title: e.currentTarget.value
						})
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onSave = () => {
						const e = {
							title: this.state.title.trim(),
							message: this.state.message.trim()
						};
						this.props.removalReason && (e.id = this.props.removalReason.id), this.props.onSubmit(e), this.props.sendEvent(), this.props.toggleModal()
					}, this.canSave = () => this.state.title.trim().length > 0 && this.state.title.trim().length <= x.d && this.state.message.trim().length > 0 && this.state.message.trim().length <= x.a, this.state = e.removalReason ? {
						title: e.removalReason.title,
						message: e.removalReason.message
					} : I
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(k.d, null, r.a.createElement(k.h, null, r.a.createElement(j.a, null, r.a.createElement(k.p, null, e.removalReason ? o.fbt._("Edit removal reason", null, {
						hk: "1P0jAw"
					}) : o.fbt._("Add new reason", null, {
						hk: "jDYo"
					})), r.a.createElement(y.a, {
						onClick: e.toggleModal
					}, r.a.createElement(k.b, null)))), r.a.createElement(k.k, null, r.a.createElement(k.g, null, r.a.createElement(L, {
						placeholder: o.fbt._("Removal reason title", null, {
							hk: "4hFurd"
						}),
						value: t.title,
						onChange: this.onTitleInputChange
					}), r.a.createElement(_.a, {
						text: t.title.trim(),
						maxChars: x.d
					})), r.a.createElement(k.n, null, o.fbt._("Reason message:", null, {
						hk: "yMtrM"
					})), r.a.createElement(P, null, o.fbt._("Hi u/username,", null, {
						hk: "NE4XP"
					})), r.a.createElement(M, {
						placeholder: o.fbt._("Write a message that will communicate to the user why their post was removed.", null, {
							hk: "4u5AVO"
						}),
						value: t.message,
						onChange: this.onMessageInputChange,
						"data-redditstyle": !0
					}), r.a.createElement(_.a, {
						text: t.message.trim(),
						maxChars: x.a
					})), r.a.createElement(R, null, r.a.createElement(N, {
						onClick: this.onSave,
						"data-redditstyle": !0,
						disabled: !this.canSave()
					}, e.removalReason ? o.fbt._("Save", null, {
						hk: "2U0EXj"
					}) : o.fbt._("Add new reason", null, {
						hk: "34P0ii"
					})), r.a.createElement(k.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.removalReason && r.a.createElement(T, {
						onClick: e.onDeleteReason
					}, o.fbt._("Delete", null, {
						hk: "n7R3f"
					}))))
				}
			}
			var F = Object(C.a)(A),
				D = s("./src/reddit/layout/row/Inline/index.tsx"),
				B = s("./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less"),
				U = s.n(B);
			const {
				fbt: H
			} = s("./node_modules/fbt/lib/FbtPublic.js"), W = l.a.wrapped(g.n, "EditButton", U.a), V = l.a.wrapped(D.a, "Row", U.a), q = l.a.div("ReasonNumber", U.a), G = l.a.div("ReasonText", U.a);
			var K = e => r.a.createElement(V, null, r.a.createElement(q, null, e.index + 1), r.a.createElement(G, null, e.removalReason.title), r.a.createElement(W, {
					onClick: e.onEdit,
					"data-redditstyle": !0
				}, H._("Edit", null, {
					hk: "1nftDt"
				}))),
				z = s("./src/reddit/components/RemovalReasons/index.m.less"),
				Q = s.n(z);
			const J = {
					reasonToEdit: null
				},
				Z = l.a.wrapped(f.a, "Rules", Q.a),
				X = Object(d.c)({
					isConfirmModalOpen: e => "RemovalReasons--Modal--DeleteConfirmation" === Object(E.a)(e),
					isRemovalReasonEditorModalOpen: e => "RemovalReasons--Editor--Modal" === Object(E.a)(e),
					removalReasons: v.c
				}),
				Y = Object(i.b)(X, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						addRemovalReason: t => e(Object(m.addRemovalReason)(s, t)),
						deleteRemovalReason: t => e(Object(m.deleteRemovalReason)(s, t)),
						editRemovalReason: t => e(Object(m.editRemovalReason)(s, t)),
						toggleConfirmationModal: () => e(Object(c.i)("RemovalReasons--Modal--DeleteConfirmation")),
						toggleReasonEditorModal: () => e(Object(c.i)("RemovalReasons--Editor--Modal"))
					}
				});
			class $ extends r.a.Component {
				constructor(e) {
					super(e), this.onAddReason = () => {
						this.setState({
							reasonToEdit: null
						}), this.props.toggleReasonEditorModal(), this.props.sendEventWithName("add_new")()
					}, this.onEditReason = e => () => {
						this.setState({
							reasonToEdit: e
						}), this.props.toggleReasonEditorModal(), e && this.props.sendEventWithName("edit")()
					}, this.renderReasonEditorModal = () => r.a.createElement(F, {
						onDeleteReason: () => {
							this.props.toggleReasonEditorModal(), this.props.toggleConfirmationModal()
						},
						onSubmit: this.state.reasonToEdit ? this.props.editRemovalReason : this.props.addRemovalReason,
						removalReason: this.state.reasonToEdit,
						sendEvent: this.state.reasonToEdit ? this.props.sendEventWithName("edit_save") : this.props.sendEventWithName("new_save"),
						subredditId: this.props.subredditId,
						toggleModal: this.onEditReason(null),
						withOverlay: !0
					}), this.state = J
				}
				render() {
					const {
						deleteRemovalReason: e,
						isConfirmModalOpen: t,
						isRemovalReasonEditorModalOpen: s,
						removalReasons: a,
						sendEventWithName: i,
						toggleConfirmationModal: d
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(h.c, null, r.a.createElement(g.f, {
						onClick: this.onAddReason,
						disabled: a.length >= x.c || s,
						"data-redditstyle": !0
					}, o.fbt._("Add removal reason", null, {
						hk: "2fHPVe"
					}))), r.a.createElement(h.a, null, r.a.createElement(h.b, null, o.fbt._("Removal reasons", null, {
						hk: "3IWxkH"
					}), r.a.createElement(b.a, {
						linkUrl: "".concat(n.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360010094892")
					})), a.length > 0 ? a.map((e, t) => r.a.createElement(K, {
						index: t,
						key: e.title,
						onEdit: this.onEditReason(e),
						removalReason: e
					})) : r.a.createElement(p.c, {
						text: o.fbt._("No removal reasons yet", null, {
							hk: "1j70G1"
						})
					}, r.a.createElement(Z, null))), s && this.renderReasonEditorModal(), t && this.state.reasonToEdit && r.a.createElement(u.a, {
						actionText: o.fbt._("Delete", null, {
							hk: "3BvUe8"
						}),
						headerText: o.fbt._("Delete reason", null, {
							hk: "q2qun"
						}),
						modalText: o.fbt._("Are you sure you want to delete this reason?", null, {
							hk: "1FTfMR"
						}),
						onConfirm: () => {
							this.state.reasonToEdit && e(this.state.reasonToEdit.id)
						},
						toggleModal: () => {
							d(), this.setState({
								reasonToEdit: null
							})
						},
						trackClick: i("delete"),
						withOverlay: !0
					}))
				}
			}
			t.a = Y($)
		},
		"./src/reddit/components/ReportFlow/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/higherOrderComponents/makeAsync.tsx"),
				o = s("./src/lib/loadWithRetries/index.ts");
			const a = {
					backgroundColor: s("./src/reddit/constants/colors.ts").a.overlayReportFlow
				},
				r = () => null;
			t.a = Object(n.a)({
				ErrorComponent: r,
				getComponent: () => Object(o.a)(() => Promise.all([s.e("ReportFlow~ReportPage"), s.e("ReportFlow")]).then(s.bind(null, "./src/reddit/components/ReportFlow/_ReportFlow.tsx"))).then(e => e.default),
				LoadingComponent: r
			})
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.m.less": function(e, t, s) {
			e.exports = {
				removalReasonButton: "_3IEDcFIIs_TeXsZtKZGzUd",
				TextWrapper: "smOzqVIOoNqmSJcyBX2N6",
				textWrapper: "smOzqVIOoNqmSJcyBX2N6",
				Button: "_1rNBkuuOkN2SorEXyRkYjB",
				button: "_1rNBkuuOkN2SorEXyRkYjB",
				ApproveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				approveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				RemoveButton: "_2OvUr_pd3kddsNP_f35S28",
				removeButton: "_2OvUr_pd3kddsNP_f35S28"
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return c
			})), s.d(t, "b", (function() {
				return m
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "a", (function() {
				return p
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/RestrictedFlatlistButton/index.m.less"),
				d = s.n(i);
			const l = r.a.span("TextWrapper", d.a),
				c = r.a.wrapped(e => o.a.createElement("button", {
					className: e.className,
					disabled: e.disabled,
					id: e.id,
					onClick: e.disabled ? void 0 : e.onClick
				}, e.children, e.text && o.a.createElement(l, null, e.text, " ")), "Button", d.a),
				m = r.a.wrapped(c, "ApproveButton", d.a),
				u = r.a.wrapped(c, "RemoveButton", d.a),
				p = e => o.a.createElement("button", {
					className: Object(a.a)(d.a.removalReasonButton, e.className),
					onClick: e.onClick
				}, e.text)
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, s) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				d = s.n(i);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var c = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			t.a = r.a.wrapped(e => {
				const {
					children: t,
					className: s,
					renderBelow: n,
					text: r,
					tooltipContentClass: i
				} = e, m = c(e, ["children", "className", "renderBelow", "text", "tooltipContentClass"]);
				return o.a.createElement("div", l({}, m, {
					className: Object(a.a)(d.a.container, s)
				}), r ? o.a.createElement("div", {
					className: Object(a.a)(d.a.tooltip, i, n ? d.a.below : d.a.above)
				}, r) : null, t)
			}, "HoverTooltip", d.a)
		},
		"./src/reddit/components/SaveIndicator/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_13ubiSSjUBWaeyJM-itH7X",
				titleFontH2: "_2V4_0G0gJO4R1v-_sO5D_j",
				titleFontH3: "_32Uo9qgINsZX5CSOtFM0e2",
				titleFontH4: "_2AWEwOuuK5wBnQGyiB5sSq",
				titleFontH5: "_8460KZXLwbKYkuLfDNr_-",
				titleFontH6: "_7GhKEQrcNu3JuSHqj9pJc",
				metadataFont: "qilOmvvpr4iY8iiHxuV5Y",
				flairFont: "SovT7HaLHcqz1BM9MWXPA",
				labelsFont: "_3Ngpaj84VwPqy3s6Tr3GEJ",
				actionFont: "_3RLwRjy5tGM8nl4kID8Tfg",
				smallButtonFont: "nb_OfRzzHKNkGteZC-TyY",
				largeButtonFont: "_2fhzAdDCEdDseFevwE6mBQ",
				tabFont: "_3E-egg7Cy7bL6JzsZuFTcn",
				strongTextFont: "_2vvi6WI_4yX2H2H-b2aBCF",
				bodyFontH1: "_2_nWm6krUlDJnEF9pk7xNK",
				bodyFontH2: "_3zzd4vTmfrG1aK91i6m2j9",
				bodyFontH3: "_3tFwmsoGmyp52EFCoZ0GCV",
				bodyFontH4: "MdKdTVjxUaPPkDvG_msXr",
				bodyFontH5: "_2dNFOZceckCrwGYG8Avi-k",
				bodyFontH6: "_3sSb6LvOgvwy7eawwX4Gtq",
				bodyFont: "_2fiuzofxgtB6yu9nAHLuqW",
				bodyFontSmall: "_2IcqO4djjAVsOalbW_Zpa9",
				bodyFontMono: "_2i_EmKzaFJfCskmkHdmmgJ",
				icon: "cO908rcinWKz894i8I5jJ",
				pendingIcon: "U2dgL2i9_EJN8R_MLFTjS",
				savedIcon: "_1iGcF7LdvT-OMRgF7xKWqm",
				saveErrorIcon: "kWS-87C-v-iTlGGxQOmxu",
				caption: "_1MAESVWNqu44JbWmHGJsuI"
			}
		},
		"./src/reddit/components/ScheduledPost/ControlRow/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_1xM2tjm8c7LuqnoEJG1Ws1",
				controlRow: "P7KCCrRfT4TO2wcnk_Kjv",
				controlRowItem: "_1AkGbjxtRpq3ZhKADdUTU3"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.m.less": function(e, t, s) {
			e.exports = {
				content: "_297_pyPlxmqBF0tLkUhTME",
				icon: "_1n_ojuNDT8JeH9DxmHJZt9",
				author: "_1k9D_vEsQ8odWCNERbDOxX",
				modIcon: "_3ryKOTfQ_vqgap0EZsZHAl",
				stickyIcon: "qfjbZcX6-FZK2BGrOXezD"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/AuthorLink/index.tsx"),
				r = s("./src/reddit/components/SubredditNameLink/index.tsx"),
				i = s("./src/reddit/controls/MetaSeparator/index.tsx"),
				d = s("./src/reddit/icons/fonts/Sticky/index.tsx"),
				l = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				c = s("./src/reddit/models/ScheduledPost/index.ts"),
				m = s("./src/reddit/components/ScheduledPost/MetaLine/index.m.less"),
				u = s.n(m);
			class p extends o.a.PureComponent {
				render() {
					if (!Object(c.m)(this.props.subreddit)) return null;
					const {
						isModDistinguished: e,
						subreddit: t,
						owner: s,
						isSticky: n
					} = this.props;
					return o.a.createElement("span", {
						className: u.a.content
					}, o.a.createElement(r.a, {
						to: t.path
					}, t.prefixedName), Object(c.l)(s) && o.a.createElement(o.a.Fragment, null, o.a.createElement(i.a, null), o.a.createElement(a.a, {
						className: u.a.author,
						author: s.name,
						isUnstyled: !0
					}, s.prefixedName)), e && o.a.createElement(l.a, {
						className: u.a.modIcon
					}), n && o.a.createElement(d.a, {
						className: u.a.stickyIcon
					}))
				}
			}
			t.a = p
		},
		"./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return h
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./node_modules/fbt/lib/FbtPublic.js"),
				d = s("./src/reddit/components/OverflowMenu/index.tsx"),
				l = s("./src/reddit/components/PostModModeDropdown/DropdownHelpers.tsx");
			var c = e => o.a.createElement(d.b, {
					dropdownId: "".concat("SCHEDULED_POST_DROPDOWN").concat(e.scheduledPostId),
					onClick: e.onOpenOverflow
				}, o.a.createElement(l.b, {
					isSelected: e.isSticky,
					onClick: e.onToggleIsSticky,
					text: i.fbt._("Sticky post", null, {
						hk: "UOShB"
					})
				}), o.a.createElement(l.b, {
					isSelected: e.isModDistinguished,
					onClick: e.onToggleIsModDistinguished,
					text: i.fbt._("Distinguish as Mod", null, {
						hk: "3opu7K"
					})
				}), o.a.createElement(l.b, {
					isSelected: e.isOriginalContent,
					onClick: e.onToggleIsOC,
					text: i.fbt._("Mark as OC", null, {
						hk: "32LGcQ"
					})
				}), o.a.createElement(l.b, {
					isSelected: e.isNsfw,
					onClick: e.onToggleIsNsfw,
					text: i.fbt._("Mark as NSFW", null, {
						hk: "2qBIcp"
					})
				}), o.a.createElement(l.b, {
					isSelected: e.isSpoiler,
					onClick: e.onToggleIsSpoiler,
					text: i.fbt._("Mark as Spoiler", null, {
						hk: "rOev9"
					})
				})),
				m = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				u = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const p = Object(r.c)({
					isLoading: m.i
				}),
				b = Object(a.b)(p);

			function h(e) {
				class t extends o.a.Component {
					constructor(e) {
						super(e), this.isSaving = !1, this.onToggleMetadata = e => {
							this.setState(Object.assign({}, this.state, {
								[e]: !this.state[e]
							})), this.isSaving = !0, this.props.onUpdateMetadata(e)
						}, this.onToggleIsSticky = () => this.onToggleMetadata("isSticky"), this.onToggleIsModDistinguished = () => this.onToggleMetadata("isModDistinguished"), this.onToggleIsOriginalContent = () => this.onToggleMetadata("isOriginalContent"), this.onToggleIsNsfw = () => this.onToggleMetadata("isNsfw"), this.onToggleIsSpoiler = () => this.onToggleMetadata("isSpoiler"), this.renderOverflowMenu = () => o.a.createElement(c, {
							scheduledPostId: this.props.scheduledPost.id,
							onOpenOverflow: this.props.onOpenOverflow,
							onToggleIsSticky: this.onToggleIsSticky,
							onToggleIsModDistinguished: this.onToggleIsModDistinguished,
							onToggleIsOC: this.onToggleIsOriginalContent,
							onToggleIsNsfw: this.onToggleIsNsfw,
							onToggleIsSpoiler: this.onToggleIsSpoiler,
							isModDistinguished: this.state.isModDistinguished,
							isOriginalContent: this.state.isOriginalContent,
							isNsfw: this.state.isNsfw,
							isSticky: this.state.isSticky,
							isSpoiler: this.state.isSpoiler
						}), this.state = {
							isModDistinguished: this.props.scheduledPost.isModDistinguished,
							isNsfw: this.props.scheduledPost.isNsfw,
							isOriginalContent: this.props.scheduledPost.isOriginalContent,
							isSpoiler: this.props.scheduledPost.isSpoiler,
							isSticky: this.props.scheduledPost.isSticky
						}
					}
					componentDidUpdate(e) {
						e.isLoading && !this.props.isLoading && this.isSaving && (this.isSaving = !1, this.setState({
							isModDistinguished: this.props.scheduledPost.isModDistinguished || !1,
							isNsfw: this.props.scheduledPost.isNsfw || !1,
							isOriginalContent: this.props.scheduledPost.isOriginalContent || !1,
							isSpoiler: this.props.scheduledPost.isSpoiler || !1,
							isSticky: this.props.scheduledPost.isSticky || !1
						}))
					}
					render() {
						const t = this.props,
							{
								isLoading: s,
								scheduledPost: n,
								onUpdateMetadata: a,
								onOpenOverflow: r
							} = t,
							i = u(t, ["isLoading", "scheduledPost", "onUpdateMetadata", "onOpenOverflow"]),
							d = Object.assign({}, i, {
								renderOverflowMenu: this.renderOverflowMenu
							});
						return o.a.createElement(e, d)
					}
				}
				return b(t)
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.m.less": function(e, t, s) {
			e.exports = {
				title: "_3jA9JBnv4bqmmiAw3Akmug"
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/ScheduledPost/PostTitle/index.m.less"),
				r = s.n(a);
			class i extends o.a.PureComponent {
				render() {
					return o.a.createElement("span", {
						className: r.a.title
					}, this.props.title)
				}
			}
			t.a = i
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1YrhJ0z1RfTXg7jHYgApSr",
				error: "_2_f_ecVpbx4yoMzazJYkDP",
				retryButton: "_1KbjdUJVdbZQOJN8d6LTsX"
			}
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less": function(e, t, s) {
			e.exports = {
				container: "qDE3oDok1392-t8IDOBfk",
				clock: "_2sfIhl6E6vfZCwxx54EUNB",
				timeMetaData: "_3ZqmD_fQ-lxmvQJVOuIgP1"
			}
		},
		"./src/reddit/components/ScheduledPost/index.m.less": function(e, t, s) {
			e.exports = {
				body: "_320l2eVngsr4Ord9dXc2er",
				container: "_26zeT5d9JKXWbWzOT4ncpg",
				thumbnailContainer: "_2UwJRJuqEbkRCV8O6REq8h",
				mainBody: "_3pHV3zwe-Q9-xNEB0iM3WT",
				backgroundWrapper: "_2KWv8ukh9RMgpOturAiV9z",
				content: "hAQclO6xLNG3WDMgkywGo",
				flairList: "_1-tY_25z_pkhbFvUz2-AqS",
				Icon: "_3XIOnqmz8vxSaPmPEY11Wh",
				icon: "_3XIOnqmz8vxSaPmPEY11Wh"
			}
		},
		"./src/reddit/components/ScheduledPost/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return fe
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/telemetry/index.ts"),
				c = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				m = s("./src/reddit/actions/scheduledPosts/index.ts"),
				u = s("./src/reddit/actions/scheduledPosts/delete.ts"),
				p = s("./src/reddit/actions/scheduledPosts/edit.ts"),
				b = s("./src/lib/makeActionCreator/index.ts"),
				h = s("./src/reddit/actions/page.ts"),
				g = s("./src/reddit/actions/scheduledPosts/constants.ts"),
				f = s("./src/reddit/actions/toaster.ts"),
				x = s("./src/graphql/operations/SubmitScheduledPost.json"),
				E = s("./src/lib/makeGqlRequest/index.ts");
			var v = s("./src/reddit/models/Toast/index.ts");
			const C = Object(b.a)(g.l),
				_ = (e, t) => async (s, n, o) => {
					let {
						gqlContext: a
					} = o;
					const r = Object(i.o)(n(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (!r) return void s(Object(f.e)(Object(f.d)(g.u(), v.b.Error)));
					const d = await ((e, t) => Object(E.a)(e, Object.assign({}, x, {
						variables: t
					})))(a(), {
						input: {
							id: r.id
						}
					});
					if (!d.ok) return void s(Object(f.e)(Object(f.d)(g.v(), v.b.Error, g.s(), _(e, t))));
					const l = d.body.data.submitScheduledPost.post.permalink;
					s(Object(h.G)(l, !1)), s(Object(f.e)(Object(f.d)(g.x(), v.b.SuccessCommunity))), s(C({
						subredditId: e,
						scheduledPostId: t
					}))
				};
			var k = s("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				O = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				y = s("./src/reddit/components/FlairList/index.tsx"),
				j = s("./src/reddit/components/PostLeftRail/index.tsx"),
				w = s("./src/reddit/components/VerticalVotes/votes.tsx"),
				S = s("./src/reddit/controls/Score/index.tsx"),
				I = s("./src/reddit/models/Vote/index.ts"),
				P = s("./src/reddit/components/VerticalVotes/index.m.less"),
				T = s.n(P);
			class N extends a.a.PureComponent {
				render() {
					return a.a.createElement("div", {
						className: T.a.votesContainer
					}, a.a.createElement("button", {
						className: T.a.disabledVoteIcon,
						"aria-label": n.fbt._("Upvote", null, {
							hk: "4aEt1X"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, a.a.createElement(w.d, {
						compact: !1,
						voteState: I.a.notVoted,
						interactive: !1
					})), a.a.createElement(S.a, {
						disableInlineColor: !0,
						className: T.a.disabledScore,
						score: 0,
						voteState: I.a.notVoted,
						isScoreHidden: !0
					}), a.a.createElement("button", {
						className: T.a.disabledVoteIcon,
						"aria-label": n.fbt._("downvote", null, {
							hk: "4xXpvV"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, a.a.createElement(w.c, {
						compact: !1,
						voteState: I.a.notVoted,
						interactive: !1
					})))
				}
			}
			var M = N,
				R = s("./src/reddit/constants/thumbnails.ts"),
				L = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				A = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				F = s("./src/reddit/models/PostCreationForm/index.ts"),
				D = s("./src/reddit/models/ScheduledPost/index.ts"),
				B = s("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx"),
				U = s("./src/lib/classNames/index.ts"),
				H = s("./src/reddit/icons/svgs/Pencil/index.tsx"),
				W = s("./src/reddit/icons/svgs/Post/index.tsx"),
				V = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				q = s("./src/reddit/components/ScheduledPost/ControlRow/index.m.less"),
				G = s.n(q);
			const K = e => {
				const {
					icon: t,
					onClick: s
				} = e;
				return a.a.createElement("span", {
					onClick: s,
					className: Object(U.a)(G.a.controlRowItem, e.className)
				}, a.a.createElement(t, {
					className: G.a.icon
				}), " ", e.text)
			};
			class z extends a.a.Component {
				render() {
					return a.a.createElement("span", {
						className: G.a.controlRow
					}, this.props.onSubmitPostNow && a.a.createElement(K, {
						icon: W.a,
						text: n.fbt._("Submit post now", null, {
							hk: "QkS4y"
						}),
						onClick: this.props.onSubmitPostNow
					}), a.a.createElement(K, {
						icon: H.a,
						text: n.fbt._("Edit", null, {
							hk: "1nftDt"
						}),
						onClick: this.props.onEditScheduledPost
					}), a.a.createElement(K, {
						icon: V.b,
						text: n.fbt._("Delete", null, {
							hk: "1uVY7w"
						}),
						onClick: this.props.onDeleteScheduledPost
					}), this.props.renderOverflowMenu())
				}
			}
			var Q = Object(B.a)(z),
				J = s("./src/reddit/components/ScheduledPost/MetaLine/index.tsx"),
				Z = s("./src/reddit/components/ScheduledPost/PostTitle/index.tsx"),
				X = s("./src/reddit/icons/svgs/Clear/index.tsx"),
				Y = s("./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less"),
				$ = s.n(Y);
			const {
				fbt: ee
			} = s("./node_modules/fbt/lib/FbtPublic.js");
			class te extends a.a.PureComponent {
				componentDidMount() {
					this.props.onViewFailedPost()
				}
				render() {
					return a.a.createElement("div", {
						className: $.a.container
					}, a.a.createElement(X.a, {
						className: $.a.error
					}), ee._("Post failed to submit! Please {=retry}", [ee._param("=retry", a.a.createElement("button", {
						className: $.a.retryButton,
						onClick: this.props.onSubmitPostNow
					}, ee._("retry", null, {
						hk: "hER94"
					})))], {
						hk: "4yOnl8"
					}))
				}
			}
			var se = Object(r.b)(null, (e, t) => {
					let {
						scheduledPost: s
					} = t;
					return {
						onSubmitPostNow: () => {
							e(_(s.subreddit.id, s.id)), e((e, t) => Object(l.a)(Object(A.r)()(t())))
						},
						onViewFailedPost: () => e((e, t) => Object(l.a)(Object(A.B)()(t(), s)))
					}
				})(te),
				ne = s("./src/reddit/helpers/scheduledPosts/index.ts"),
				oe = s("./src/reddit/icons/svgs/Clock/index.tsx"),
				ae = s("./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less"),
				re = s.n(ae);
			const {
				fbt: ie
			} = s("./node_modules/fbt/lib/FbtPublic.js"), de = e => {
				const t = Object(ne.c)(e.publishAt),
					s = Object(ne.d)(e.clientTimezone).displayText;
				return "".concat(t, " ").concat(s)
			};
			class le extends a.a.PureComponent {
				render() {
					return a.a.createElement("div", {
						className: re.a.container
					}, a.a.createElement(oe.a, {
						className: re.a.clock
					}), ie._("This post is scheduled for {=[time]}", [ie._param("=[time]", a.a.createElement("span", {
						className: re.a.timeMetaData
					}, ie._("{time}", [ie._param("time", de(this.props.scheduledPost))], {
						hk: "JrMs3"
					})))], {
						hk: "4gFrnr"
					}))
				}
			}
			var ce = le;
			class me extends a.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props;
					switch (e.state) {
						case D.e.FAILED:
							return a.a.createElement(se, {
								scheduledPost: e
							});
						case D.e.PROCESSING:
						case D.e.CREATED:
						default:
							return a.a.createElement(ce, {
								scheduledPost: e
							})
					}
				}
			}
			var ue = me,
				pe = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				be = s.n(pe),
				he = s("./src/reddit/components/ScheduledPost/index.m.less"),
				ge = s.n(he);
			const fe = {
					isNSFW: !1,
					media: {
						content: "",
						markdownContent: "",
						isRichtextPreview: !0,
						mediaMetadata: null,
						obfuscated: null,
						richtextContent: {
							document: []
						},
						rteMode: F.h.RICH_TEXT,
						type: "rtjson"
					},
					thumbnail: {
						url: R.a.DEFAULT,
						width: null,
						height: null
					},
					title: "",
					source: null,
					isSponsored: !1
				},
				xe = Object(d.c)({
					media: (e, t) => {
						let {
							scheduledPostId: s,
							subredditId: n
						} = t;
						const o = Object(i.o)(e, {
							subredditId: n,
							scheduledPostId: s
						});
						return o ? Object.assign({}, fe, {
							isNSFW: o.isNsfw,
							title: o.title
						}) : null
					},
					flair: (e, t) => {
						let {
							scheduledPostId: s,
							subredditId: n
						} = t;
						const o = Object(i.o)(e, {
							subredditId: n,
							scheduledPostId: s
						});
						return o ? Object(i.l)({
							scheduledPost: o
						}) : null
					},
					scheduledPost: (e, t) => {
						let {
							scheduledPostId: s,
							subredditId: n
						} = t;
						return Object(i.o)(e, {
							subredditId: n,
							scheduledPostId: s
						})
					}
				}),
				Ee = Object(r.b)(xe, (e, t) => {
					let {
						scheduledPostId: s,
						subredditId: n
					} = t;
					return {
						onSubmitPostNow: () => {
							e(_(n, s)), e((e, t) => Object(l.a)(Object(A.r)()(t())))
						},
						onEditScheduledPost: () => {
							e(Object(p.b)(n, s)), e((e, t) => Object(l.a)(Object(A.f)()(t())))
						},
						onDeleteScheduledPost: () => e(Object(u.a)(n, s)),
						onOpenOverflow: () => {
							e((e, t) => Object(l.a)(Object(A.l)(!1)(t())))
						},
						onUpdateMetadata: t => e((e, o) => {
							const a = Object(i.o)(o(), {
								subredditId: n,
								scheduledPostId: s
							});
							a && e(Object(m.b)(t, a))
						})
					}
				});
			class ve extends a.a.PureComponent {
				constructor(e) {
					super(e), this.onSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !0
					}), this.onCancelSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !1
					}), this.onConfirmSubmitPostNow = () => this.props.onSubmitPostNow(), this.onEditScheduledPost = () => {
						this.props.onEditScheduledPost()
					}, this.onDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !0
					}), this.onCancelDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !1
					}), this.onConfirmDeleteScheduledPost = () => this.props.onDeleteScheduledPost(), this.state = {
						deleteConfirmModalIsOpen: !1,
						submitConfirmModalIsOpen: !1
					}
				}
				render() {
					const {
						media: e,
						flair: t,
						scheduledPost: s
					} = this.props;
					return e && t && s ? a.a.createElement("div", {
						className: ge.a.container
					}, a.a.createElement(ue, {
						scheduledPost: s
					}), a.a.createElement("div", {
						className: be.a.classicPostStyles
					}, a.a.createElement(j.b, null, a.a.createElement(M, null)), a.a.createElement("div", {
						style: Object(L.c)(void 0, this.props),
						className: ge.a.backgroundWrapper
					}, a.a.createElement("div", {
						className: ge.a.mainBody
					}, a.a.createElement("div", {
						className: ge.a.thumbnailContainer
					}, a.a.createElement(k.a, {
						post: e
					})), a.a.createElement("div", {
						className: ge.a.content
					}, a.a.createElement("div", null, a.a.createElement(Z.a, {
						title: s.title
					}), a.a.createElement(y.a, {
						className: ge.a.flairList,
						flair: t
					})), a.a.createElement(J.a, {
						isModDistinguished: s.isModDistinguished,
						isSticky: s.isSticky,
						subreddit: s.subreddit,
						owner: s.owner
					}), a.a.createElement(Q, {
						onSubmitPostNow: s.state === D.e.FAILED ? void 0 : this.onSubmitPostNow,
						onEditScheduledPost: this.onEditScheduledPost,
						onDeleteScheduledPost: this.onDeleteScheduledPost,
						onUpdateMetadata: this.props.onUpdateMetadata,
						scheduledPost: s,
						onOpenOverflow: this.props.onOpenOverflow
					}))))), this.state.deleteConfirmModalIsOpen && a.a.createElement(O.a, {
						onClose: this.onCancelDeleteScheduledPost,
						onCancel: this.onCancelDeleteScheduledPost,
						onConfirm: this.onConfirmDeleteScheduledPost,
						actionText: n.fbt._("Delete", null, {
							hk: "1WN0R6"
						}),
						modalText: n.fbt._("Are you sure you want to delete this scheduled post? This action cannot be undone.", null, {
							hk: "1EdQC7"
						}),
						withOverlay: !0
					}), this.state.submitConfirmModalIsOpen && a.a.createElement(O.a, {
						onClose: this.onCancelSubmitPostNow,
						onCancel: this.onCancelSubmitPostNow,
						onConfirm: this.onConfirmSubmitPostNow,
						actionText: n.fbt._("Submit", null, {
							hk: "3kl12J"
						}),
						modalText: n.fbt._("Are you sure you want to submit this scheduled post now? This action cannot be undone.", null, {
							hk: "18O8dB"
						}),
						withOverlay: !0
					})) : null
				}
			}
			t.a = Object(c.a)(Ee(ve))
		},
		"./src/reddit/components/Settings/shared/SectionHeading.m.less": function(e, t, s) {
			e.exports = {
				Component: "BotIImuktRA9aFAPP0O4Z",
				component: "BotIImuktRA9aFAPP0O4Z"
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/components/Settings/shared/SectionHeading.m.less"),
				o = s.n(n),
				a = s("./src/lib/lessComponent.tsx");
			t.a = a.a.h3("Component", o.a)
		},
		"./src/reddit/components/Settings/shared/Widgets.m.less": function(e, t, s) {
			e.exports = {
				Label: "asxizthf5kZpmoY27VBKd",
				label: "asxizthf5kZpmoY27VBKd",
				HoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				hoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				ControlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				controlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				TextContainer: "_3dLmvT0hpACHFxhncqzCOr",
				textContainer: "_3dLmvT0hpACHFxhncqzCOr",
				inModal: "_2O2JPVgOlh8J6OW_9ur4BQ",
				ActionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				actionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				Wrapper: "_2f63as5b5FASHMqGd5P1o0",
				wrapper: "_2f63as5b5FASHMqGd5P1o0",
				isCreateCommunity: "_38bDTwLcytTCF-174R0UXB",
				mColumn: "_1HH_g-CLQB1BPcqOhZcakt",
				mLast: "_3Lu6XJyVbSLDVKDx-wue2g",
				mIndent: "_2D65jEbgD16ae_sJ8BG4AD",
				mDisabled: "LvI7FSBTGgYo2skaf18Zv",
				Subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				isNightModeOn: "KUWYDFs7fIjkQNSOL_BR6",
				Wrapper__LineBreak: "wVinKyEoajEmwhqwINYGd",
				wrapperLineBreak: "wVinKyEoajEmwhqwINYGd",
				Link: "oFObIzV6ZJDQuG09BXh8u",
				link: "oFObIzV6ZJDQuG09BXh8u",
				SubtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				subtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				LinkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				linkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				LinkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				linkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				ArrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				arrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				StyledFlair: "_1F2irboi-xRChkhyndP6ct",
				styledFlair: "_1F2irboi-xRChkhyndP6ct",
				SpoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				spoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				NSFWFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				nsfwFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				DropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				dropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				DropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				dropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				Row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				DropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				dropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				DescriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				descriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				Circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				RangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				rangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				RangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				rangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				Ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				TickText: "_1hEYjTFCxEu2ILobPvatAp",
				tickText: "_1hEYjTFCxEu2ILobPvatAp",
				PreSubText: "_2_hv6QgJ151j9WmCyETVfC",
				preSubText: "_2_hv6QgJ151j9WmCyETVfC",
				MultiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				multiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				ActionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				actionLinkContainer: "e4RehzaESS5nfk-O6pYoK"
			}
		},
		"./src/reddit/components/Settings/shared/Widgets.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "m", (function() {
				return G
			})), s.d(t, "j", (function() {
				return Z
			})), s.d(t, "n", (function() {
				return Y
			})), s.d(t, "k", (function() {
				return se
			})), s.d(t, "l", (function() {
				return re
			})), s.d(t, "o", (function() {
				return ie
			})), s.d(t, "i", (function() {
				return be
			})), s.d(t, "b", (function() {
				return he
			})), s.d(t, "f", (function() {
				return ge
			})), s.d(t, "a", (function() {
				return fe
			})), s.d(t, "d", (function() {
				return Oe
			})), s.d(t, "h", (function() {
				return ye
			})), s.d(t, "c", (function() {
				return je
			})), s.d(t, "e", (function() {
				return we
			})), s.d(t, "g", (function() {
				return Se
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/actions/tooltip.ts"),
				l = s("./src/higherOrderComponents/asTooltip.tsx"),
				c = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = s("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				u = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				p = s("./src/reddit/controls/Dropdown/index.tsx"),
				b = s("./src/reddit/controls/Dropdown/Row.tsx"),
				h = s("./src/reddit/controls/FormFields/index.tsx"),
				g = s("./src/lib/lessComponent.tsx"),
				f = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				x = s("./src/reddit/controls/Select/index.m.less"),
				E = s.n(x);

			function v() {
				return (v = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var C = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const _ = g.a.span("Wrapper", E.a),
				k = g.a.select("Inner", E.a),
				O = g.a.wrapped(f.b, "Caret", E.a);

			function y(e) {
				var {
					className: t,
					innerClassName: s
				} = e, n = C(e, ["className", "innerClassName"]);
				const a = n.disabled ? {
					"data-disabled": n.disabled
				} : {};
				return o.a.createElement(_, {
					className: t
				}, o.a.createElement(k, v({
					className: s
				}, n)), o.a.createElement(O, v({
					isSubreddit: !0
				}, a)))
			}
			var j = s("./src/reddit/controls/ToggleSwitch/index.tsx"),
				w = s("./src/reddit/controls/Typography/index.tsx"),
				S = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				I = s("./src/reddit/icons/svgs/Circle/index.tsx"),
				P = s("./src/reddit/icons/svgs/OutboundLink/index.tsx"),
				T = s("./node_modules/lodash/range.js"),
				N = s.n(T),
				M = s("./src/reddit/controls/Button/index.tsx"),
				R = s("./src/reddit/layout/row/Inline/index.tsx"),
				L = s("./src/reddit/models/Flair/index.ts"),
				A = s("./src/reddit/selectors/tooltip.ts"),
				F = s("./src/reddit/selectors/user.ts"),
				D = s("./src/reddit/components/Settings/shared/Widgets.m.less"),
				B = s.n(D);

			function U() {
				return (U = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var H = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const W = Object(l.a)(p.a),
				V = g.a.wrapped(I.a, "Circle", B.a),
				q = g.a.h3("Label", B.a),
				G = g.a.wrapped(w.c, "Subtext", B.a),
				K = g.a.wrapped(m.a, "HoverTooltip", B.a),
				z = g.a.div("ControlContainer", B.a),
				Q = g.a.div("TextContainer", B.a),
				J = g.a.div("ActionContainer", B.a),
				Z = e => {
					var {
						className: t,
						direction: s,
						isCreateCommunity: n,
						inModal: a,
						isNightModeOn: r,
						disabled: d,
						indent: l,
						last: c
					} = e, m = H(e, ["className", "direction", "isCreateCommunity", "inModal", "isNightModeOn", "disabled", "indent", "last"]);
					return o.a.createElement("div", U({}, m, {
						className: Object(i.a)(B.a.Wrapper, t, {
							[B.a.mColumn]: "column" === s,
							[B.a.mDisabled]: !!d,
							[B.a.mIndent]: !!l,
							[B.a.mLast]: !!c,
							[B.a.isCreateCommunity]: !!n,
							[B.a.inModal]: !!a,
							[B.a.isNightModeOn]: !!r
						})
					}))
				},
				X = g.a.a("Link", B.a),
				Y = g.a.wrapped(X, "SubtextLink", B.a),
				$ = g.a.wrapped(P.a, "LinkIcon", B.a),
				ee = g.a.button("LinkButton", B.a),
				te = g.a.wrapped(S.a, "ArrowRight", B.a),
				se = e => o.a.createElement(Z, {
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					isCreateCommunity: e.isCreateCommunity,
					last: e.last
				}, o.a.createElement(Q, {
					className: e.textContainerClassName
				}, o.a.createElement(q, null, e.label, e.isRequired && o.a.createElement(V, null)), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, e.children)),
				ne = g.a.div("StyledFlair", B.a),
				oe = g.a.wrapped(ne, "SpoilerFlair", B.a),
				ae = g.a.wrapped(ne, "NSFWFlair", B.a),
				re = e => {
					switch (e.flair) {
						case L.f.Nsfw:
							return o.a.createElement(ae, null, "NSFW");
						case L.f.Spoiler:
							return o.a.createElement(oe, null, "SPOILER");
						default:
							return null
					}
				},
				ie = e => o.a.createElement(Z, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, o.a.createElement(Q, null, o.a.createElement(R.a, null, o.a.createElement(q, null, e.label)), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, o.a.createElement(z, null, e.tooltip && o.a.createElement(K, {
					tooltipContentClass: e.tooltipContentClassName,
					text: e.tooltip
				}), o.a.createElement(j.a, {
					on: e.on,
					forceOn: e.forceOn,
					onToggle: e.onClick,
					disabled: e.disabled
				})))),
				de = g.a.input("RangeSliderInput", B.a),
				le = g.a.div("RangeSlider", B.a),
				ce = g.a.div("Ticks", B.a),
				me = g.a.div("TickText", B.a),
				ue = g.a.div("PreSubText", B.a),
				pe = Object(r.c)({
					isNightModeOn: F.S
				}),
				be = Object(a.b)(pe)(e => o.a.createElement(Z, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled,
					inModal: e.inModal,
					isNightModeOn: e.isNightModeOn,
					direction: e.direction
				}, o.a.createElement(Q, {
					style: {
						flex: 5
					}
				}, !e.inModal && o.a.createElement(R.a, null, o.a.createElement(q, null, e.label)), o.a.createElement(G, null, " ", o.a.createElement(ue, {
					style: {
						color: e.ticks[e.value].color
					}
				}, " ", e.ticks[e.value].text + ": ", " "), " ", e.subtext)), o.a.createElement(J, {
					style: {
						flex: 3,
						margin: "20px 20px 0 0"
					}
				}, o.a.createElement(le, null, o.a.createElement(de, {
					style: {
						background: "linear-gradient(to right, " + N()(1, e.max + 1).map((t, s) => t <= e.value ? "".concat(e.ticks[e.value].color, " ").concat((t - 1) / e.max * 100, "%,\n                    ").concat(e.ticks[e.value].color, " ").concat(t / e.max * 100 - 1, "%,\n                    #fff ").concat(t / e.max * 100 - 1, "%,\n                    #fff ").concat(t / e.max * 100, "%") : t !== e.max ? "#c5c5c5 ".concat((t - 1) / e.max * 100, "%, #c5c5c5 ").concat(t / e.max * 100 - 1, "%,\n                    #fff ").concat(t / e.max * 100 - 1, "%,\n                    #fff ").concat(t / e.max * 100, "%") : "#c5c5c5 ".concat((t - 1) / e.max * 100, "%")) + ", #C5C5C5 100%)"
					},
					className: "range-slider-input",
					type: "range",
					min: e.min,
					max: e.max,
					step: e.step,
					value: e.value,
					onChange: e.onChange,
					onInput: e.onChange
				}), o.a.createElement(ce, null, Object.keys(e.ticks).map((t, s) => o.a.createElement(me, {
					key: t,
					style: {
						color: t === e.value.toString() ? e.ticks[t].color : "#878A8C"
					}
				}, e.ticks[t].text))))))),
				he = e => o.a.createElement(Z, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, o.a.createElement(Q, null, o.a.createElement(R.a, null, o.a.createElement(q, null, e.label)), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, o.a.createElement(z, null, o.a.createElement(M.i, {
					onClick: e.onClick
				}, e.actionText)))),
				ge = e => o.a.createElement(Z, {
					className: e.className,
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, o.a.createElement(Q, null, o.a.createElement(X, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, e.label, o.a.createElement($, null)), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, o.a.createElement(X, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, o.a.createElement(te, null)))),
				fe = e => o.a.createElement(Z, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, o.a.createElement(Q, null, o.a.createElement(ee, {
					onClick: e.onClick
				}, e.label), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, o.a.createElement(ee, {
					onClick: e.onClick
				}, o.a.createElement(te, null)))),
				xe = g.a.div("DropdownWrapper", B.a),
				Ee = g.a.wrapped(b.b, "DropdownRow", B.a),
				ve = g.a.span("Row", B.a),
				Ce = g.a.wrapped(f.b, "DropdownTriangle", B.a),
				_e = g.a.div("DescriptionsRow", B.a),
				ke = Object(r.c)({
					isOpen: (e, t) => Object(A.b)(t.id)(e)
				}),
				Oe = Object(a.b)(ke, (e, t) => ({
					openDropdown: () => {
						e(Object(d.h)({
							tooltipId: t.id
						}))
					}
				}))(e => o.a.createElement(Z, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, o.a.createElement(Q, null, o.a.createElement(q, null, e.label), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, (e => o.a.createElement(xe, {
					onClick: e.openDropdown
				}, o.a.createElement(ve, {
					id: "".concat("SettingDropdown--").concat(e.id)
				}, e.displayTitle || e.selected), o.a.createElement(Ce, null), o.a.createElement(W, {
					container: void 0,
					isOpen: e.isOpen,
					renderContentsHidden: !0,
					isOverlay: !1,
					tooltipId: "".concat("SettingDropdown--").concat(e.id)
				}, e.items.map((t, s) => o.a.createElement(Ee, {
					displayText: e.displayItems ? e.displayItems[s] : t,
					isSelected: e.selected === t,
					onClick: () => e.onClick(t),
					key: s
				}))), e.descriptions && o.a.createElement(_e, null, e.descriptions[e.items.indexOf(e.selected)])))(e)))),
				ye = e => {
					var {
						disabled: t,
						last: s,
						onChange: a
					} = e, r = H(e, ["disabled", "last", "onChange"]);
					const i = Object(n.useCallback)(e => a(e.target.value), [a]);
					return o.a.createElement(Z, {
						disabled: t
					}, o.a.createElement(Q, null, o.a.createElement(q, null, r.label), o.a.createElement(G, null, r.subtext)), o.a.createElement("div", {
						className: B.a.Wrapper__LineBreak
					}), o.a.createElement(Z, {
						last: s,
						indent: !0,
						disabled: t
					}, o.a.createElement(y, {
						className: "redditStyle",
						disabled: t || r.inputDisabled,
						onChange: i,
						value: r.selected
					}, r.items.map(e => {
						let {
							value: t,
							text: s
						} = e;
						return o.a.createElement("option", {
							key: t,
							value: t
						}, s)
					}))))
				},
				je = e => o.a.createElement(Z, {
					className: e.className,
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, o.a.createElement(Q, null, o.a.createElement(q, null, e.label), o.a.createElement(G, null, e.subtext)), o.a.createElement(J, null, e.children)),
				we = e => o.a.createElement(se, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, o.a.createElement(h.a, {
					disabled: !1,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					type: "text",
					value: e.value,
					onBlur: e.onBlur
				}), !e.hideCountdown && o.a.createElement(c.a, {
					maxChars: e.maxChars,
					text: e.value
				})),
				Se = e => o.a.createElement(se, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, o.a.createElement(u.i, {
					disabled: !1,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					rows: e.rows || 4,
					style: {
						marginBottom: e.isCreateCommunity ? "4px" : 0,
						resize: e.isCreateCommunity ? "vertical" : "both"
					},
					value: e.value,
					onBlur: e.onBlur
				}), o.a.createElement("div", {
					className: B.a.MultiLineInputSettingsBottomRow
				}, !e.hideCountdown && o.a.createElement(c.a, {
					maxChars: e.maxChars,
					text: e.value || ""
				}), !!e.actionLink && o.a.createElement("div", {
					className: B.a.ActionLinkContainer
				}, e.actionLink)))
		},
		"./src/reddit/components/ShareMenu/index.m.less": function(e, t, s) {
			e.exports = {
				dropdown: "PWY92ySDjTYrTAiutq4ty",
				dropdownRow: "_2snJGyyGyyH38duHobOUKE",
				linkIcon: "_1GObrri0j7y_9IWiGUfPjp",
				crosspostIcon: "_1m76BHzDzRsM1te7HBxUqd",
				embedIcon: "_3MSdPVJwGxrpakz-e1MQhO"
			}
		},
		"./src/reddit/components/ShareMenu/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router/esm/react-router.js"),
				d = s("./node_modules/react-router-redux/es/index.js"),
				l = s("./node_modules/reselect/es/index.js"),
				c = s("./src/reddit/actions/tooltip.ts"),
				m = s("./src/lib/addQueryParams/index.ts"),
				u = s("./src/reddit/actions/post.ts"),
				p = s("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				b = s("./src/reddit/controls/Dropdown/index.tsx"),
				h = s("./src/reddit/controls/Dropdown/Row.tsx"),
				g = s("./src/reddit/icons/fonts/Crosspost/index.tsx"),
				f = s("./src/reddit/icons/fonts/Embed/index.tsx"),
				x = s("./src/reddit/icons/fonts/Link/index.tsx"),
				E = s("./src/reddit/models/Subreddit/index.ts"),
				v = s("./src/reddit/routes/postCreation/constants.ts"),
				C = s("./src/reddit/selectors/tooltip.ts"),
				_ = s("./src/reddit/components/ShareMenu/index.m.less"),
				k = s.n(_),
				O = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const y = Object(p.a)(b.a),
				j = Object(l.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: s
						} = t;
						return Object(C.b)(s)(e)
					}
				}),
				w = Object(r.b)(j, (e, t) => {
					var {
						dropdownId: s,
						permalink: n
					} = t, o = O(t, ["dropdownId", "permalink"]);
					return {
						onCrosspost: () => {
							o.post && e(Object(d.b)("".concat(v.b, "?source_id=").concat(o.post.id)))
						},
						toggleDropdown: () => {
							e(Object(c.h)({
								tooltipId: s
							}))
						},
						copyLink: () => e(Object(u.G)(Object(m.a)(n, {
							utm_source: "share",
							utm_medium: "web2x"
						})))
					}
				});
			t.a = w(Object(i.i)(e => {
				const t = !e.subreddit || e.subreddit && e.subreddit.type === E.d.Public,
					s = !!e.post && e.post.isCrosspostable && !e.post.isSponsored;
				return a.a.createElement("div", {
					className: e.className,
					onClick: e.toggleDropdown,
					id: e.dropdownId
				}, e.children, a.a.createElement(y, {
					className: k.a.dropdown,
					isOpen: e.dropdownIsOpen,
					tooltipId: e.dropdownId
				}, a.a.createElement(h.b, {
					className: k.a.dropdownRow,
					displayText: n.fbt._("Copy link", null, {
						hk: "1tCqox"
					}),
					onClick: () => {
						e.sendEventWithName("share_copy"), e.copyLink()
					}
				}, a.a.createElement(x.a, {
					className: k.a.linkIcon
				})), s && a.a.createElement(h.b, {
					className: k.a.dropdownRow,
					displayText: n.fbt._("crosspost", null, {
						hk: "23zSN6"
					}),
					onClick: () => {
						e.sendEventWithName("share_crosspost"), e.onCrosspost()
					}
				}, a.a.createElement(g.a, {
					className: k.a.crosspostIcon
				})), t && a.a.createElement(h.b, {
					className: k.a.dropdownRow,
					displayText: n.fbt._("Embed", null, {
						hk: "2CcsuC"
					}),
					onClick: () => {
						e.sendEventWithName("share_embed"), window.open("https://embed.redditmedia.com/widgets/embed?url=".concat(e.permalink), "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
					}
				}, a.a.createElement(f.a, {
					className: k.a.embedIcon
				}))))
			}))
		},
		"./src/reddit/components/SourceLink/index.m.less": function(e, t, s) {
			e.exports = {
				OutboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				outboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				SourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				sourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				"m-comment": "_1-PD0_zreH-KVwpFoCLvQF",
				mComment: "_1-PD0_zreH-KVwpFoCLvQF"
			}
		},
		"./src/reddit/components/SourceLink/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/getShortenedLink.ts"),
				i = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				d = s("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				l = s("./src/reddit/components/SourceLink/index.m.less"),
				c = s.n(l),
				m = s("./src/lib/lessComponent.tsx");
			const u = m.a.wrapped(d.a, "OutboundLinkIcon", c.a),
				p = m.a.div("SourceLinkWrapper", c.a);
			t.a = e => {
				const {
					className: t,
					post: s,
					isCommentsPage: n
				} = e, {
					source: d,
					isSponsored: l
				} = s;
				return d ? o.a.createElement(p, {
					className: Object(a.a)({
						[c.a["m-comment"]]: n
					}, t)
				}, o.a.createElement(i.a, {
					href: d.url,
					isSponsored: l,
					postId: s.id,
					source: d
				}, Object(r.a)(s), o.a.createElement(u, null))) : null
			}
		},
		"./src/reddit/components/Streaming/ModSettings/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_16pMBJPhtfeyyncMfo7aDr",
				topBar: "_1DEjdLJpmb7fufFzhwqQm0",
				contentContainer: "ZV-o_W-prpE7EI4zyZ1hr",
				formBody: "_3xfSWCFu_alfjEX12_hBAB"
			}
		},
		"./src/reddit/components/Streaming/ModSettings/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				d = s("./src/reddit/actions/modal.ts"),
				l = s("./src/reddit/actions/streaming/modSettings.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx"),
				u = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				p = s("./src/reddit/components/Settings/shared/Widgets.tsx"),
				b = s("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				h = s("./src/reddit/contexts/ApiContext.tsx"),
				g = s("./src/reddit/controls/Button/index.tsx"),
				f = s("./src/reddit/controls/FormFields/index.tsx"),
				x = s("./src/graphql/operations/UpdateSubredditStreamingModSettings.json"),
				E = s("./src/lib/makeGqlRequest/index.ts"),
				v = s("./src/reddit/models/Toast/index.ts"),
				C = s("./src/reddit/selectors/activeModalId.ts"),
				_ = s("./src/reddit/selectors/streamingModSettings.ts"),
				k = s("./src/reddit/components/Streaming/ModSettings/index.m.less"),
				O = s.n(k);
			const y = Object(i.c)({
					modSettings: _.b,
					isAddUserModalOpen: e => "ModerationPage--Streaming--AddUser" === Object(C.a)(e)
				}),
				j = Object(r.b)(y, (e, t) => ({
					onSave: async (s, n) => {
						const o = await T(t.subredditId, s, n);
						return P(o) ? o : await e(Object(l.a)(t.subredditId))
					},
					onUserAdd: async (s, n, o) => {
						const a = [...n.whitelistedUsers.map(e => ({
								redditorName: e.name
							})), {
								redditorName: s
							}],
							r = await T(t.subredditId, {
								whitelistedRedditors: a
							}, o);
						return P(r) ? r : await e(Object(l.a)(t.subredditId))
					},
					onUserRemove: async (s, n, o) => {
						const a = n.whitelistedUsers.filter(e => e.name !== s).map(e => ({
								redditorName: e.name
							})),
							r = await T(t.subredditId, {
								whitelistedRedditors: a
							}, o);
						return P(r) ? r : await e(Object(l.a)(t.subredditId))
					},
					showToast: t => e(Object(c.e)(Object.assign({}, t, {
						duration: c.a
					}))),
					toggleAddUserModal: () => e(Object(d.i)("ModerationPage--Streaming--AddUser"))
				})),
				w = e => parseInt(e, 10),
				S = e => Object(c.d)(e, v.b.SuccessMod),
				I = e => Object(c.d)(e, v.b.Error),
				P = e => void 0 !== e.reason,
				T = async (e, t, s) => {
					const o = await ((e, t) => Object(E.a)(e, Object.assign({}, x, {
						variables: t
					})))(s(), {
						input: {
							subredditId: e,
							liveStreamingModeratorSettings: t
						}
					});
					if (!o.ok || !o.body.data.updateSubredditLiveStreamingModeratorSettings.ok) {
						return {
							reason: o.error && o.error.fields ? o.error.fields[0].msg : n.fbt._("Could not update settings", null, {
								hk: "6IIoR"
							})
						}
					}
					return {}
				};
			class N extends a.a.Component {
				constructor(e) {
					super(e), this.onChange = e => {
						const t = Object.assign({}, this.state.changedModSettings, e);
						this.setState({
							changedModSettings: t
						})
					}, this.onSaveClick = async () => {
						const e = await this.props.onSave(this.state.changedModSettings, this.props.gqlContext);
						P(e) ? await this.props.showToast(I(n.fbt._("Failed update. {reason}", [n.fbt._param("reason", e.reason)], {
							hk: "6wZm6"
						}))) : (this.setState({
							changedModSettings: {}
						}), await this.props.showToast(S(n.fbt._("Successfully updated settings for '{subredditName}'", [n.fbt._param("subredditName", this.props.subredditName)], {
							hk: "2Lvaxf"
						}))))
					}, this.onUserAdd = async (e, t) => {
						if (this.isDuplicateUser(t)) return void(await this.props.showToast(I(n.fbt._("'{username}' has already been added", [n.fbt._param("username", t)], {
							hk: "25Zkkf"
						}))));
						const s = await this.props.onUserAdd(t, this.props.modSettings, this.props.gqlContext);
						P(s) ? await this.props.showToast(I(n.fbt._("Failed to add user '{username}'. {reason}", [n.fbt._param("username", t), n.fbt._param("reason", s.reason)], {
							hk: "19nyAb"
						}))) : await this.props.showToast(S(n.fbt._("Successfully added user '{username}'", [n.fbt._param("username", t)], {
							hk: "21TnrI"
						})))
					}, this.isDuplicateUser = e => !!this.props.modSettings.whitelistedUsers.find(t => t.name === e), this.onUserRemove = async e => {
						const t = await this.props.onUserRemove(e, this.props.modSettings, this.props.gqlContext);
						P(t) ? await this.props.showToast(I(n.fbt._("Could not remove user '{username}'. {reason}", [n.fbt._param("username", e), n.fbt._param("reason", t.reason)], {
							hk: "2Em6nW"
						}))) : await this.props.showToast(S(n.fbt._("Successfully removed user '{username}'", [n.fbt._param("username", e)], {
							hk: "1W09of"
						})))
					}, this.onUserAddButtonClick = () => {
						this.props.toggleAddUserModal()
					}, this.renderAddUserModal = () => a.a.createElement(m.a, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.onUserAdd,
						sendEventWithName: this.noopEventSend,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: "",
						withOverlay: !0
					}), this.noopEventSend = () => () => {}, this.state = {
						changedModSettings: {}
					}
				}
				render() {
					const e = Object.assign({}, this.props.modSettings, this.state.changedModSettings),
						{
							isLiveStreamingEnabled: t,
							maxLiveStreams: s,
							minKarma: o,
							minAccountAgeDays: r,
							durationLimitSeconds: i,
							whitelistedUsers: d
						} = e;
					return a.a.createElement("div", {
						className: O.a.container
					}, a.a.createElement(u.c, {
						className: O.a.topBar
					}, a.a.createElement(g.f, {
						onClick: this.onSaveClick
					}, n.fbt._("Save changes", null, {
						hk: "1IXBxj"
					}))), a.a.createElement(u.a, {
						className: O.a.contentContainer
					}, a.a.createElement(u.b, null, n.fbt._("Streaming", null, {
						hk: "byVoG"
					})), a.a.createElement("div", {
						className: O.a.formBody
					}, a.a.createElement(p.o, {
						on: t,
						label: n.fbt._("Is Enabled:", null, {
							hk: "3nJuI1"
						})
					}), a.a.createElement(p.k, {
						label: n.fbt._("Max Streams:", null, {
							hk: "4iD2Qm"
						}),
						direction: "row"
					}, a.a.createElement(f.b, {
						onChange: e => this.onChange({
							maxLiveStreams: w(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 1e3,
						value: s
					})), a.a.createElement(p.k, {
						label: n.fbt._("Min Karma:", null, {
							hk: "3A0HeV"
						}),
						direction: "row"
					}, a.a.createElement(f.b, {
						onChange: e => this.onChange({
							minKarma: w(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						value: o
					})), a.a.createElement(p.k, {
						label: n.fbt._("Min Account Age:", null, {
							hk: "48vjNT"
						}),
						direction: "row"
					}, a.a.createElement(f.b, {
						onChange: e => this.onChange({
							minAccountAgeDays: w(e.currentTarget.value)
						}),
						min: 0,
						type: "number",
						value: r
					})), a.a.createElement(p.k, {
						label: n.fbt._("Duration limit(seconds):", null, {
							hk: "1qYFbP"
						}),
						direction: "row"
					}, a.a.createElement(f.b, {
						onChange: e => this.onChange({
							durationLimitSeconds: w(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 86400,
						value: i
					})), a.a.createElement(p.k, {
						label: n.fbt._("Whitelisted Users:", null, {
							hk: "22mRdu"
						}),
						direction: "row"
					}, a.a.createElement(g.f, {
						onClick: this.onUserAddButtonClick
					}, n.fbt._("Add User", null, {
						hk: "2LVCTV"
					}))), d.map(e => a.a.createElement(b.b, {
						key: e.id,
						timeAgo: "",
						subredditId: this.props.subredditId,
						userIcon: e.icon.url,
						username: e.name,
						secondaryButton: a.a.createElement(g.n, {
							onClick: () => this.onUserRemove(e.name)
						}, n.fbt._("Remove", null, {
							hk: "4hG9Uo"
						}))
					})))), this.props.isAddUserModalOpen && this.renderAddUserModal())
				}
			}
			t.a = Object(h.b)(j(N))
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less": function(e, t, s) {
			e.exports = {
				StyledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				styledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				BreadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				breadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				BreadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe"
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/lessComponent.tsx"),
				r = s("./src/reddit/components/TrackingHelper/index.tsx"),
				i = s("./src/reddit/helpers/trackers/blade.ts"),
				d = s("./src/reddit/icons/svgs/Chevron/index.tsx"),
				l = s("./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less"),
				c = s.n(l);
			const m = a.a.wrapped(d.a, "StyledChevron", c.a),
				u = a.a.div("BreadcrumbElement", c.a),
				p = a.a.div("BreadcrumbContainer", c.a);
			t.b = Object(r.c)(e => o.a.createElement(p, null, e.breadcrumbs.map(t => o.a.createElement(u, {
				key: t.title,
				onClick: () => {
					e.sendEvent(Object(i.a)()), e.onNavigate(t)
				}
			}, o.a.createElement(m, null), t.title))))
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.m.less": function(e, t, s) {
			e.exports = {
				ImageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				imageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				ImageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				imageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				ImageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				imageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				FileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				fileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				ContainerUploading: "rOyNUbZnjJvWxtyInd1T8",
				containerUploading: "rOyNUbZnjJvWxtyInd1T8",
				Label: "_2ZFG2IQMaso9iA14qjicA_",
				label: "_2ZFG2IQMaso9iA14qjicA_",
				isOver: "_1B5UKMPaEBX3HOKKEBfp7o",
				ImageInput: "_362HLUlCiz7UbtVPniNjjW",
				imageInput: "_362HLUlCiz7UbtVPniNjjW"
			}
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return E
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/controls/FileDrop/index.tsx"),
				d = s("./src/reddit/controls/ImageInput/index.tsx"),
				l = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				c = s("./src/reddit/icons/svgs/ImageUpload/index.tsx"),
				m = s("./src/reddit/components/StructuredStyles/ImageUpload/index.m.less"),
				u = s.n(m);
			const {
				fbt: p
			} = s("./node_modules/fbt/lib/FbtPublic.js"), b = r.a.wrapped(c.a, "ImageUploadIcon", u.a), h = r.a.div("ImageIconRow", u.a), g = r.a.div("ImageUploadText", u.a), f = r.a.wrapped(i.a, "FileDrop", u.a), x = r.a.div("ContainerUploading", u.a), E = e => o.a.createElement(x, {
				className: e.className
			}, o.a.createElement(h, null, o.a.createElement(l.a, {
				sizePx: 40,
				center: !0
			})), o.a.createElement(g, null, p._("Uploading...", null, {
				hk: "2ICpZ2"
			}))), v = r.a.label("Label", u.a);
			t.b = e => o.a.createElement(f, {
				className: e.className,
				onDrop: e.onChange,
				render: t => o.a.createElement(v, {
					className: Object(a.a)({
						[u.a.isOver]: t
					}, e.labelClassName)
				}, o.a.createElement(h, null, e.icon || o.a.createElement(b, null)), o.a.createElement(g, null, e.label), o.a.createElement(d.a, {
					className: u.a.ImageInput,
					name: e.name,
					value: e.value,
					onChange: e.onChange,
					multiple: e.multiple,
					tabIndex: e.tabIndex
				}))
			})
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less": function(e, t, s) {
			e.exports = {
				FormPage: "_9ZuQyDXhFth1qKJF4KNm8",
				formPage: "_9ZuQyDXhFth1qKJF4KNm8",
				HomePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				homePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				HomePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				homePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				HomePageGroup: "_306gA2lxjCHX44ssikUp3O",
				homePageGroup: "_306gA2lxjCHX44ssikUp3O",
				FormPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				formPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				FormPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				formPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				FormGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				formGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				FormGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				formGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				FormElement: "c5RWd-O3CYE-XSLdTyjtI",
				formElement: "c5RWd-O3CYE-XSLdTyjtI",
				FormGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				formGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				FormItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				formItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				FormElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				formElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				FormElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				formElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				FormElementError: "horIoLCod23xkzt7MmTpC",
				formElementError: "horIoLCod23xkzt7MmTpC",
				FormElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				formElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				FormListItem: "_2M7LQbQxH40ingJ9h9RslL",
				formListItem: "_2M7LQbQxH40ingJ9h9RslL"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.ts": function(e, t, s) {
			"use strict";
			s.d(t, "k", (function() {
				return r
			})), s.d(t, "p", (function() {
				return i
			})), s.d(t, "n", (function() {
				return d
			})), s.d(t, "o", (function() {
				return l
			})), s.d(t, "m", (function() {
				return c
			})), s.d(t, "l", (function() {
				return m
			})), s.d(t, "f", (function() {
				return u
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "i", (function() {
				return g
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "b", (function() {
				return x
			})), s.d(t, "c", (function() {
				return E
			})), s.d(t, "d", (function() {
				return v
			})), s.d(t, "j", (function() {
				return C
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less"),
				a = s.n(o);
			const r = n.a.section("FormPage", a.a),
				i = n.a.h1("HomePageTitle", a.a),
				d = n.a.button("HomePageBreadcrumb", a.a),
				l = n.a.div("HomePageGroup", a.a),
				c = n.a.h1("FormPageTitle", a.a),
				m = n.a.div("FormPageSection", a.a),
				u = n.a.div("FormGroup", a.a),
				p = n.a.h2("FormGroupTitle", a.a),
				b = n.a.div("FormElement", a.a),
				h = n.a.div("FormGroupDescription", a.a),
				g = n.a.div("FormItem", a.a),
				f = n.a.h3("FormElementTitle", a.a),
				x = n.a.div("FormElementDescription", a.a),
				E = n.a.div("FormElementError", a.a),
				v = n.a.div("FormElementSubGroup", a.a),
				C = n.a.li("FormListItem", a.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less": function(e, t, s) {
			e.exports = {
				ModalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				modalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				Input: "_1BJV17HgWhhC-BxrpqGjM",
				input: "_1BJV17HgWhhC-BxrpqGjM",
				Checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				CheckboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				checkboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				iconStyles: "_349rJ1BueyeldYiZniwYOz",
				RadioOff: "_23-RdhX276B0bg5nrt0cpf",
				radioOff: "_23-RdhX276B0bg5nrt0cpf",
				RadioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				radioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				Textarea: "_2gchCc4pmLk-CHEErYmFaP",
				textarea: "_2gchCc4pmLk-CHEErYmFaP",
				StyledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				styledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				StyledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN",
				styledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return m
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "a", (function() {
				return h
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "i", (function() {
				return f
			})), s.d(t, "h", (function() {
				return x
			})), s.d(t, "g", (function() {
				return E
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/controls/Input/ModalInput.tsx"),
				a = s("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				r = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				i = s("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = s("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				l = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less"),
				c = s.n(l);
			const m = n.a.wrapped(o.a, "ModalInput", c.a),
				u = n.a.input("Input", c.a),
				p = n.a.wrapped(d.a, "RadioOn", c.a),
				b = n.a.wrapped(i.a, "RadioOff", c.a),
				h = n.a.wrapped(a.a, "Checkbox", c.a),
				g = n.a.wrapped(r.a, "CheckboxSelected", c.a),
				f = n.a.textarea("Textarea", c.a),
				x = n.a.label("StyledLabel", c.a),
				E = n.a.input("StyledFileInput", c.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, s) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return c
			})), s.d(t, "a", (function() {
				return m
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				i = s.n(r);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const c = e => {
					var {
						disabled: t
					} = e, s = l(e, ["disabled"]);
					return o.a.createElement("div", d({}, s, {
						className: Object(a.a)(i.a.FormNavElement, {
							[i.a.disabled]: t
						})
					}), s.children)
				},
				m = e => {
					var {
						canDrop: t,
						className: s,
						isDragging: n,
						isOver: r,
						disabled: c
					} = e, m = l(e, ["canDrop", "className", "isDragging", "isOver", "disabled"]);
					return o.a.createElement("div", d({}, m, {
						className: Object(a.a)(i.a.DragCard, {
							[i.a.disabled]: c,
							[i.a.isDraffing]: n,
							[i.a.isOverAndCanDrop]: r && t
						}, s)
					}))
				}
		},
		"./src/reddit/components/SubredditContent/EventPostContent/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/reddit/actions/eventPosts/index.ts"),
				c = s("./src/reddit/components/ClassicPost/index.tsx"),
				m = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				u = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				p = s("./src/reddit/components/Scroller/Simple.tsx"),
				b = s("./src/reddit/components/SubredditContent/index.tsx"),
				h = s("./src/reddit/components/TrackingHelper/index.tsx"),
				g = s("./src/reddit/constants/postLayout.ts"),
				f = s("./src/reddit/controls/Button/index.tsx"),
				x = s("./src/reddit/helpers/overlay/index.ts"),
				E = s("./src/reddit/helpers/postComponentForLayout/index.tsx"),
				v = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				C = e => a.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, a.a.createElement("g", null, a.a.createElement("path", {
					d: "M17,4 C17.552,4 18,4.448 18,5 L18,8 L18,17 C18,17.552 17.552,18 17,18 L3,18 C2.448,18 2,17.552 2,17 L2,8 L2,5 C2,4.448 2.448,4 3,4 L5,4 L5,3 C5,2.448 5.448,2 6,2 C6.552,2 7,2.448 7,3 L7,4 L13,4 L13,3 C13,2.448 13.448,2 14,2 C14.552,2 15,2.448 15,3 L15,4 L17,4 Z M4,16 L16,16 L16,9 L4,9 L4,16 Z"
				}))),
				_ = s("./src/reddit/routes/postCreation/index.ts"),
				k = s("./src/reddit/selectors/eventPosts.ts"),
				O = s("./src/reddit/components/SubredditContent/index.m.less"),
				y = s.n(O);
			const j = Object(d.c)({
					eventPosts: k.f,
					isPending: k.d,
					hasData: k.b,
					endCursor: k.a
				}),
				w = Object(r.b)(j, (e, t) => {
					let {
						subredditName: s
					} = t;
					return {
						onClickPost: t => {
							e(Object(x.a)(t.permalink))
						},
						fetchMorePosts: () => {
							e(Object(l.eventPostsRequested)(s))
						}
					}
				});
			class S extends a.a.PureComponent {
				componentDidMount() {
					this.props.sendEvent(Object(v.C)())
				}
				renderEmptyState() {
					const {
						subredditName: e
					} = this.props;
					return a.a.createElement(m.c, {
						className: y.a.emptyStateContainer,
						text: n.fbt._("No upcoming or live events in r/{subredditName}", [n.fbt._param("subredditName", e)], {
							hk: "3wRma7"
						}),
						childrenPosition: "bottom"
					}, a.a.createElement(C, {
						className: y.a.icon
					}), a.a.createElement(i.a, {
						className: y.a.schedulePostLink,
						to: Object(_.c)(e)
					}, n.fbt._("Create Event Post", null, {
						hk: "PXBmQ"
					})))
				}
				renderBody() {
					const {
						endCursor: e,
						eventPosts: t,
						fetchMorePosts: s,
						hasData: n,
						onClickPost: o
					} = this.props;
					return a.a.createElement("div", {
						className: y.a.contentContainer
					}, a.a.createElement("div", {
						className: y.a.standaloneContainer
					}, n ? a.a.createElement(p.b, {
						className: y.a.scroller,
						onLoadMore: s,
						loadMoreToken: e || void 0
					}, t.map((e, t) => ({
						id: e.id,
						estHeight: Object(E.c)(e, g.g.Classic),
						render: s => a.a.createElement(c.default, {
							key: "event-post-id-".concat(e.id),
							className: y.a.eventPostContainer,
							postId: e.id,
							first: 0 === t,
							isOverlay: !1,
							onClickPost: () => o(e)
						})
					}))) : this.renderEmptyState()))
				}
				render() {
					const {
						isPending: e,
						hasData: t
					} = this.props;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(u.c, null, a.a.createElement(i.a, {
						to: Object(_.c)(this.props.subredditName)
					}, a.a.createElement(f.f, null, n.fbt._("Schedule an event post", null, {
						hk: "nk1bA"
					})))), a.a.createElement(u.a, null, a.a.createElement(u.b, {
						className: y.a.pageTitle
					}, n.fbt._("Upcoming and live events", null, {
						hk: "MAeQO"
					}), a.a.createElement("span", {
						className: y.a.betaIndicator
					}, n.fbt._("Beta", null, {
						hk: "z4XPh"
					}))), !t && e ? Object(b.a)() : this.renderBody(), t && e && Object(b.a)(1)))
				}
			}
			t.a = w(Object(h.c)(S))
		},
		"./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = s("./src/reddit/actions/scheduledPosts/index.ts"),
				l = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				c = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				m = s("./node_modules/reselect/es/index.js"),
				u = s("./src/lib/classNames/index.ts"),
				p = s("./src/reddit/actions/modal.ts"),
				b = (s("./node_modules/core-js/modules/es6.symbol.js"), s("./src/lib/CSSVariableProvider/index.tsx")),
				h = s("./src/reddit/controls/Button/index.tsx"),
				g = s("./src/reddit/components/Paginator/index.m.less"),
				f = s.n(g);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var E = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const {
				fbt: v
			} = s("./node_modules/fbt/lib/FbtPublic.js"), C = e => {
				const {
					isNextButton: t,
					isActive: s
				} = e, n = E(e, ["isNextButton", "isActive"]);
				return a.a.createElement(h.d, x({
					disabled: !s
				}, n))
			};
			class _ extends a.a.Component {
				constructor(e) {
					super(e), this.onHandlePrev = () => this.onHandlePageChange(!1), this.onHandleNext = () => this.onHandlePageChange(!0), this.state = {
						currentCursor: void 0
					}
				}
				getCurrentCursorIdx() {
					const {
						items: e
					} = this.props, {
						currentCursor: t
					} = this.state;
					return t ? e.findIndex(e => e.id === t) : -1
				}
				getRenderableItems() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props, s = this.getCurrentCursorIdx() + 1;
					return e.slice(s, s + t)
				}
				hasPrevPage() {
					return !(this.getCurrentCursorIdx() <= 0)
				}
				hasNextPage() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props;
					return !(this.getCurrentCursorIdx() + t > e.length - 2)
				}
				onHandlePageChange(e) {
					const {
						items: t,
						itemsPerPage: s
					} = this.props, n = this.getCurrentCursorIdx();
					if (e && !this.hasNextPage()) return;
					if (!e && !this.hasPrevPage()) return;
					const o = e ? Math.max(-1, Math.min(n + s, t.length - 2)) : Math.max(-1, n - s);
					this.setState({
						currentCursor: t[o] ? t[o].id : void 0
					})
				}
				renderControlRow() {
					const {
						usePortalForControlRow: e,
						controlRowPortal: t,
						pagerButton: s = C
					} = this.props, n = this.hasPrevPage(), o = this.hasNextPage();
					if (!n && !o) return null;
					const r = a.a.createElement("div", {
						className: f.a.controlRow
					}, a.a.createElement("span", {
						className: f.a.prevButtonContainer
					}, a.a.createElement(s, {
						className: f.a.prevButton,
						onClick: this.onHandlePrev,
						isNextButton: !1,
						isActive: n
					}, v._("Previous", null, {
						hk: "4hX0ue"
					}))), a.a.createElement("span", {
						className: f.a.nextButtonContainer
					}, a.a.createElement(s, {
						className: f.a.nextButton,
						onClick: this.onHandleNext,
						isNextButton: !0,
						isActive: o
					}, v._("Next", null, {
						hk: "2GFsYc"
					}))));
					return e && !t ? null : t ? Object(b.d)(r, t) : r
				}
				render() {
					const {
						className: e,
						lastItemClassName: t,
						itemComponent: s
					} = this.props, n = this.getRenderableItems();
					return a.a.createElement("div", {
						className: e
					}, n.map((e, o) => a.a.createElement(s, {
						className: t && o === n.length - 1 ? t : void 0,
						key: e.id,
						item: e
					})), this.renderControlRow())
				}
			}
			var k = _,
				O = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				y = s("./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less"),
				j = s.n(y);
			var w = e => a.a.createElement("button", {
					className: Object(u.a)(j.a.button, e.className, {
						[j.a.prevButton]: !e.isNextButton,
						[j.a.disabled]: !e.isActive
					}),
					onClick: e.onClick,
					disabled: !e.isActive
				}, a.a.createElement(O.a, {
					className: j.a.arrowIcon
				})),
				S = s("./src/reddit/components/RecurringPostList/EditModal/async.tsx"),
				I = s("./src/reddit/components/RecurringPostList/RecurringPost/index.tsx"),
				P = s("./src/reddit/components/TrackingHelper/index.tsx"),
				T = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				N = s("./src/reddit/icons/svgs/Replay/index.tsx"),
				M = s("./src/reddit/routes/postCreation/index.ts"),
				R = s("./src/reddit/selectors/activeModalId.ts"),
				L = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				A = s("./src/reddit/components/RecurringPostList/index.m.less"),
				F = s.n(A);
			const {
				fbt: D
			} = s("./node_modules/fbt/lib/FbtPublic.js"), B = 5, U = Object(m.c)({
				recurringPosts: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(L.k)(e, {
						subredditId: s.id
					})
				},
				editModalIsOpen: e => Object(R.a)(e) === I.a,
				editingRecurringPostId: L.c,
				editingRecurringPostSubredditId: L.d
			});
			class H extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.pageButtonPortalRef = a.a.createRef(), this.onEditModalSuccessfulSave = () => {
						this.props.editModalIsOpen && this.props.toggleModal()
					}, this.onClickLink = () => {
						this.props.sendEvent(Object(T.n)())
					}
				}
				renderEmptyState() {
					return a.a.createElement(l.c, {
						className: F.a.emptyContainer,
						text: D._("No recurring posts", null, {
							hk: "2G7szl"
						}),
						childrenPosition: "bottom"
					}, a.a.createElement(N.a, {
						className: F.a.icon
					}), a.a.createElement(i.a, {
						className: F.a.schedulePostLink,
						onClick: this.onClickLink,
						to: Object(M.c)(this.props.subreddit.name)
					}, D._("Schedule recurring post", null, {
						hk: "1TrUPC"
					})))
				}
				render() {
					const {
						className: e,
						recurringPosts: t,
						editModalIsOpen: s,
						subreddit: n,
						editingRecurringPostSubredditId: o,
						editingRecurringPostId: r
					} = this.props;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement("div", {
						className: Object(u.a)(e, F.a.postList)
					}, a.a.createElement("div", {
						className: F.a.titleContainer
					}, D._("Recurring posts", null, {
						hk: "30aHKv"
					}), a.a.createElement("div", {
						ref: this.pageButtonPortalRef,
						className: F.a.pageButtonPortal
					})), t.length ? a.a.createElement(k, {
						className: F.a.recurringPostsContainer,
						lastItemClassName: F.a.lastRecurringPostItem,
						itemsPerPage: B,
						items: t,
						itemComponent: I.b,
						pagerButton: w,
						usePortalForControlRow: !0,
						controlRowPortal: this.pageButtonPortalRef.current
					}) : this.renderEmptyState()), s && !!r && !!o && n.id === o && a.a.createElement(S.a, {
						scheduledPostId: r,
						subredditId: o,
						onSuccessfulSave: this.onEditModalSuccessfulSave,
						withOverlay: !0
					}))
				}
			}
			var W = Object(r.b)(U, (e, t) => ({
					toggleModal: () => e(Object(p.i)(I.a))
				}))(Object(P.c)(H)),
				V = s("./src/reddit/components/ScheduledPost/index.tsx"),
				q = s("./src/reddit/components/Scroller/Simple.tsx"),
				G = s("./src/reddit/components/SubredditContent/index.tsx"),
				K = s("./src/reddit/components/SubredditContent/index.m.less"),
				z = s.n(K),
				Q = s("./src/reddit/icons/svgs/Clock/index.tsx"),
				J = s("./src/reddit/models/ScheduledPost/index.ts"),
				Z = s("./src/telemetry/index.ts");
			const X = Object(m.c)({
					isLoading: L.h,
					hasData: (e, t) => {
						let {
							subreddit: s
						} = t;
						return Object(L.g)(e, {
							subredditId: s.id
						})
					},
					standalonePosts: (e, t) => {
						let {
							subreddit: s
						} = t;
						return Object(L.p)(e, {
							subredditId: s.id
						})
					},
					loadMoreToken: (e, t) => {
						let {
							subreddit: s
						} = t;
						return Object(L.b)(e, {
							subredditId: s.id,
							type: J.f.standalonePosts
						})
					}
				}),
				Y = Object(r.b)(X, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						onLoadMoreStandaloneScheduledPosts: () => e(Object(d.a)(s.id)),
						onViewScheduledPostsQueue: () => e((e, t) => Object(Z.a)(Object(T.F)()(t())))
					}
				});
			class $ extends a.a.PureComponent {
				render() {
					const {
						hasData: e,
						standalonePosts: t,
						onLoadMore: s,
						loadMoreToken: n,
						renderEmptyState: o,
						subreddit: r
					} = this.props;
					return a.a.createElement("div", {
						className: z.a.contentContainer
					}, a.a.createElement("div", {
						className: z.a.standaloneContainer
					}, e && t.length ? a.a.createElement(q.b, {
						className: z.a.scroller,
						onLoadMore: s,
						loadMoreToken: n || void 0
					}, t.map(e => ({
						id: e.id,
						estHeight: 112,
						render: t => a.a.createElement(V.a, {
							key: "scheduled-post-id-".concat(e.id),
							scheduledPostId: e.id,
							subredditId: e.subreddit.id
						})
					}))) : o()), a.a.createElement(W, {
						className: z.a.sidebar,
						subreddit: r
					}))
				}
			}
			class ee extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.renderStandaloneEmptyState = () => {
						const {
							subreddit: e
						} = this.props;
						return a.a.createElement(l.c, {
							className: z.a.emptyStateContainer,
							text: n.fbt._("No scheduled posts in r/{subredditName}", [n.fbt._param("subredditName", e.name)], {
								hk: "mUwQ4"
							}),
							childrenPosition: "bottom"
						}, a.a.createElement(Q.a, {
							className: z.a.icon
						}), a.a.createElement(i.a, {
							className: z.a.schedulePostLink,
							to: Object(M.c)(e.name)
						}, n.fbt._("Schedule post", null, {
							hk: "xI07X"
						})))
					}
				}
				componentDidMount() {
					this.props.onViewScheduledPostsQueue()
				}
				renderBody() {
					const {
						hasData: e,
						loadMoreToken: t,
						onLoadMoreStandaloneScheduledPosts: s,
						standalonePosts: n,
						subreddit: o
					} = this.props;
					return a.a.createElement($, {
						renderEmptyState: this.renderStandaloneEmptyState,
						hasData: e,
						standalonePosts: n,
						onLoadMore: s,
						subreddit: o,
						loadMoreToken: t
					})
				}
				render() {
					const {
						isLoading: e,
						hasData: t,
						subreddit: s
					} = this.props;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(c.c, null, a.a.createElement(i.a, {
						to: Object(M.c)(s.name)
					}, a.a.createElement(h.f, null, n.fbt._("Schedule post", null, {
						hk: "4qwaw0"
					})))), a.a.createElement(c.a, null, a.a.createElement(c.b, {
						className: z.a.pageTitle
					}, n.fbt._("Scheduled posts", null, {
						hk: "28Qjmj"
					}), a.a.createElement("span", {
						className: z.a.betaIndicator
					}, n.fbt._("Beta", null, {
						hk: "z4XPh"
					}))), !t && e ? Object(G.a)() : this.renderBody(), t && e && Object(G.a)(1)))
				}
			}
			t.a = Y(ee)
		},
		"./src/reddit/components/SubredditContent/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1N366WahaKnCqUlSezl6CQ",
				titleFontH2: "_2ySCAslCokkxUasLc4m7l0",
				titleFontH3: "_3Na_u-vwpkuPZfuuvUROk-",
				titleFontH4: "_30jImFPUovcaQMWasU-Ohq",
				titleFontH5: "_1fkIEAH9a9eCt2B8XAaUbq",
				titleFontH6: "bHSjFLbSCNEywMorkTrqn",
				metadataFont: "_2Qe8DvvY_RxPEkj-mRpX65",
				flairFont: "_1TXuHKPD3YeZiCgMqyoBBe",
				labelsFont: "_1MiMOmZyBl0g5x8oLzodW8",
				actionFont: "_3USAKL0kbrc0ZhCvZS-J4j",
				smallButtonFont: "_2JaNUow_hy9X8yw0QFNOSg",
				largeButtonFont: "_2QdyaDMXRLLL3gChJ0NOE9",
				tabFont: "_1bq9fxhlMVaxA2GQdVomf4",
				strongTextFont: "_3qauH8UCZvDtHIr65uebN5",
				bodyFontH1: "_2qU2oh77HnIxSqTey1ZezW",
				bodyFontH2: "_2XZkZ1zrfSvpi64O-KP4IB",
				bodyFontH3: "_1icF_z4wcZT687-ao6Mzr7",
				bodyFontH4: "ZRi07Zo9aba1n7XQY_Xio",
				bodyFontH5: "_1dhvcwu2KcypL8_En9Aa7I",
				bodyFontH6: "_1FGIk1pK7xZjRbWXhruioE",
				bodyFont: "_3xTpswgMylBeM6Y-XFNTUD",
				bodyFontSmall: "_3U8U5anYwaLfjJvSrrhIKo",
				bodyFontMono: "_1VL2XaMyhrq5PiMxCa8tkv",
				icon: "_1wICBaO2ARQK5N8CBXP8kI",
				schedulePostLink: "_3hO2emEyTZ-txWczRsI6lb",
				betaIndicator: "q9zqS5nIMgIr22a55zflg",
				pageTitle: "_2HS4U5X7Rt3fT__Kpgmp9M",
				contentContainer: "_2i38uCMOvjLO0N4T-QGmV1",
				scroller: "_2toQcR3aw1_hj1A49e4wi7",
				sidebar: "_3Pz5gIKK5q2FYttguHTNa3",
				emptyStateContainer: "_3uHuaRL_-Tec711luXRhl8",
				standaloneContainer: "Q7W5RJknO1UJ-qscCW0k6",
				eventPostContainer: "_1WvFOm4w7Qt8CpM_XKK9y8"
			}
		},
		"./src/reddit/components/SubredditContent/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/ClassicPost/Placeholder.tsx");

			function r() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3;
				const t = [];
				for (let s = 0; s < e; s++) t.push(o.a.createElement(a.b, {
					isLoading: !0
				}));
				return o.a.createElement(o.a.Fragment, null, t)
			}
		},
		"./src/reddit/components/SubredditModerationSearch/index.m.less": function(e, t, s) {
			e.exports = {
				SearchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				searchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				NoResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				noResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				Container: "_3RNapyf_4ZQOEfoJhVRMEO",
				container: "_3RNapyf_4ZQOEfoJhVRMEO",
				SearchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				searchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				SearchStatus: "uTK2QKUebu8hg0gYZWTI7",
				searchStatus: "uTK2QKUebu8hg0gYZWTI7",
				Bold: "_2u65S50DJfsU-z8bR0G2DQ",
				bold: "_2u65S50DJfsU-z8bR0G2DQ"
			}
		},
		"./src/reddit/components/SubredditModerationSearch/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				d = s("./src/reddit/controls/Button/index.tsx"),
				l = s("./src/reddit/helpers/normalizeUsername/index.tsx"),
				c = s("./src/reddit/layout/row/Inline/index.tsx"),
				m = s("./src/reddit/layout/row/RightAlign/index.tsx"),
				u = s("./src/reddit/icons/svgs/Search/index.tsx"),
				p = s("./src/reddit/components/SubredditModerationSearch/index.m.less"),
				b = s.n(p);
			const h = r.a.wrapped(u.a, "SearchIcon", b.a),
				g = r.a.wrapped(i.a, "NoResultsContainer", b.a),
				f = r.a.div("Container", b.a),
				x = r.a.wrapped(c.a, "SearchStatusBar", b.a),
				E = r.a.div("SearchStatus", b.a),
				v = r.a.span("Bold", b.a);
			t.a = e => {
				if (e.searchPending) return null;
				const t = Object(l.a)(e.searchTerm);
				return e.noResultsFound ? a.a.createElement(g, null, a.a.createElement(h, null), a.a.createElement(i.b, null, n.fbt._("No results for {searchTerm}", [n.fbt._param("searchTerm", "u/".concat(t))], {
					hk: "1nDAlG"
				})), a.a.createElement(d.n, {
					onClick: e.cancelSearch
				}, n.fbt._("See all", null, {
					hk: "3aLS8s"
				}))) : a.a.createElement(f, null, a.a.createElement(x, null, a.a.createElement(E, null, n.fbt._("1 search result for {=[searchTerm]}", [n.fbt._param("=[searchTerm]", a.a.createElement(v, {
					"data-redditstyle": !0
				}, n.fbt._("{searchTerm}", [n.fbt._param("searchTerm", "'".concat(t, "':"))], {
					hk: "1B9ZWG"
				})))], {
					hk: "iAcV5"
				})), a.a.createElement(m.a, null, a.a.createElement(d.n, {
					onClick: e.cancelSearch
				}, n.fbt._("See all", null, {
					hk: "3aLS8s"
				})))), e.children)
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.m.less": function(e, t, s) {
			e.exports = {
				topBarRow: "_3H6HwkSZ2zUC1pwaIMv-EY",
				searchIcon: "_1lo1uHsqx3-EkgYDL4xKEB",
				searchInput: "_1ox94KT4YX0mmZgLO51PG_",
				searchButton: "_3-3xbjG4pcuzlB7SzgBvzg"
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			})), s.d(t, "b", (function() {
				return u
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/helpers/normalizeUsername/index.tsx"),
				d = s("./src/reddit/icons/svgs/Search/index.tsx"),
				l = s("./src/reddit/components/SubredditModerationTopBar/index.m.less"),
				c = s.n(l);
			const m = r.a.div("topBarRow", c.a);
			class u extends a.a.Component {
				constructor(e) {
					super(e), this.onSearchChange = e => {
						Object(i.a)(e.currentTarget.value).length < 21 && this.setState({
							searchInputText: e.currentTarget.value
						})
					}, this.onKeyPress = e => {
						"Enter" === e.key && this.onSearch()
					}, this.onSearch = () => {
						this.props.onSearch(this.state.searchInputText)
					}, this.state = {
						searchInputText: ""
					}
				}
				componentWillReceiveProps(e) {
					this.props.activeSearchQuery && null === e.activeSearchQuery && this.setState({
						searchInputText: ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement("div", {
						className: c.a.topBarRow
					}, a.a.createElement("input", {
						className: c.a.searchInput,
						onChange: this.onSearchChange,
						onKeyPress: this.onKeyPress,
						placeholder: n.fbt._("Search for a user", null, {
							hk: "1yTo6e"
						}),
						type: "text",
						value: t.searchInputText
					}), a.a.createElement("button", {
						className: c.a.searchButton,
						onClick: this.onSearch
					}, a.a.createElement(d.a, {
						className: c.a.searchIcon
					})), e.children)
				}
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.m.less": function(e, t, s) {
			e.exports = {
				Row: "_2O5kmPXewMHlCcrRWrjEB_",
				row: "_2O5kmPXewMHlCcrRWrjEB_",
				Username: "_1sIhmckJjyRyuR_z7M5kbI",
				username: "_1sIhmckJjyRyuR_z7M5kbI",
				RightAlign: "_3f00u5KR-M4rdaonscLX8k",
				rightAlign: "_3f00u5KR-M4rdaonscLX8k",
				Description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				AdditionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				additionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				ChevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				chevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				ChevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				chevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				ExpandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				expandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				Bullet: "_1VQtDRh-JtZQghS8jetaHR",
				bullet: "_1VQtDRh-JtZQghS8jetaHR",
				PlaceholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				placeholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				EmptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				emptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				EmptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				emptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				UsersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg",
				usersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg"
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return R
			}));
			var n = s("./node_modules/lodash/times.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./src/lib/lessComponent.tsx"),
				d = s("./src/reddit/components/TrackingHelper/index.tsx"),
				l = s("./src/reddit/helpers/trackers/moderationPages.ts"),
				c = s("./src/reddit/components/UserNameAndIcon/index.tsx"),
				m = s("./src/reddit/controls/Button/index.tsx"),
				u = s("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				p = s("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				b = s("./src/reddit/layout/row/Inline/index.tsx"),
				h = s("./src/reddit/layout/row/RightAlign/index.tsx"),
				g = s("./src/reddit/components/SubredditModerationUserItem/index.m.less"),
				f = s.n(g);
			const {
				fbt: x
			} = s("./node_modules/fbt/lib/FbtPublic.js"), E = (e, t) => {
				const s = "UserInfoTooltip--".concat(e);
				return t ? "".concat(s, "--").concat(t) : s
			}, v = i.a.wrapped(b.a, "Row", f.a), C = i.a.div("Username", f.a), _ = i.a.wrapped(h.a, "RightAlign", f.a), k = i.a.div("Description", f.a), O = i.a.div("AdditionalText", f.a), y = i.a.wrapped(u.a, "ChevronDown", f.a), j = i.a.wrapped(p.a, "ChevronUp", f.a), w = i.a.div("ExpandoContainer", f.a), S = i.a.span("Bullet", f.a), I = i.a.div("PlaceholderItem", f.a), P = i.a.wrapped(I, "EmptyUserIcon", f.a), T = i.a.wrapped(I, "EmptyDetails", f.a), N = i.a.div("UsersLoadingContainer", f.a), M = () => r.a.createElement(v, null, r.a.createElement(P, null), r.a.createElement(T, null), r.a.createElement(T, null)), R = e => r.a.createElement(N, {
				className: e.className
			}, o()(e.rows || 10, e => r.a.createElement(M, {
				key: e
			})));
			class L extends r.a.Component {
				constructor(e) {
					super(e), this.onToggleExpandedComponent = () => {
						this.props.pageName && !this.state.isExpanded && this.props.sendEvent(l.a("more_detail", this.props.pageName)), this.setState({
							isExpanded: !this.state.isExpanded
						})
					}, this.sendHoverCardEvent = () => {
						this.props.pageName && this.props.sendEvent(l.c(this.props.pageName))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(v, null, r.a.createElement(C, null, r.a.createElement(c.a, {
						username: e.username,
						userIcon: e.userIcon,
						tooltipId: E(e.username, e.moderatorType),
						subredditId: e.subredditId,
						sendHoverCardEvent: this.sendHoverCardEvent
					})), r.a.createElement(k, null, e.timeAgo, e.description && r.a.createElement(r.a.Fragment, null, r.a.createElement(S, null, "•"), e.description)), r.a.createElement(_, null, e.additionalText && r.a.createElement(O, null, e.additionalText), e.primaryButton, e.secondaryButton, e.tertiaryButton, e.expandedComponent && r.a.createElement(m.n, {
						onClick: this.onToggleExpandedComponent
					}, x._("More Details", null, {
						hk: "KnMc6"
					}), t.isExpanded ? r.a.createElement(j, null) : r.a.createElement(y, null)))), t.isExpanded && r.a.createElement(w, null, e.expandedComponent))
				}
			}
			t.b = Object(d.c)(L)
		},
		"./src/reddit/components/SubredditRules/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1fQ3jmS7djNiAnk2kVsPko",
				titleFontH2: "_39dtESYDu10VI6hZlt8jT_",
				titleFontH3: "_2_Ya84laiZ_AK4zBLZeXmE",
				titleFontH4: "_2k9S2SK_mdrMw9dXzIJka3",
				titleFontH5: "_3hrj37O_iGAZk7ssKstspL",
				titleFontH6: "_2KYRCY7gyTJjBx_Vr5pjqd",
				metadataFont: "_2hHNLn3quM7R0Znfoal7Wi",
				flairFont: "KkD9-eQEXAm_GdJAbixZ5",
				labelsFont: "_1xgXWixwTrYRf6JjxPm7ft",
				actionFont: "_1HQtdMEzh4gag8do4e9j7Z",
				smallButtonFont: "zWcRyj2-0oiXHbpM-5L1A",
				largeButtonFont: "_2PIOcp6QTxVygtl2u9ji_a",
				tabFont: "UtQUA6_scmmMeiLaweTg2",
				strongTextFont: "_2adE8ldKa4w_dETRAs-vdP",
				bodyFontH1: "_3lbK38dxFajKo78JrAEtIe",
				bodyFontH2: "_1CH0HVqZd3qMaT2gzU5mYn",
				bodyFontH3: "xk7ESbG2cmLPdln3D1fVi",
				bodyFontH4: "_29_oVfDyKoOggix5Gj6kah",
				bodyFontH5: "_1RoE8VrwOjvkyDDc-a8RZ_",
				bodyFontH6: "_3jwZ9V_jg7YZ4T-0cmGzxY",
				bodyFont: "_2iji_FM7kTNPRlaRGrPpq8",
				bodyFontSmall: "oJpqQ5hwA0NwwwlDu-EZH",
				bodyFontMono: "_2nUMbdZlQ1fQpJ_LaDNrbn",
				duplicateName: "_31Visb7b2S-tj09Ls_2Acy",
				emptyDetails: "_8PDfWWfcYPlmlmOr2Notr",
				emptyIcon: "_2tEWDkQudqJGiBAQsXSYXE",
				emptyRightIcon: "aF9GyLBXjDrRFO_7BTOYU",
				expandDetails: "_19etb4qzR1xpaHDy7AVdRr",
				header: "_2Xb_1g-T9iGzHDDy3_XpMD",
				DragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragIcon: "RR4AdUs4L9geua2bjCoqQ",
				icon: "PbUpiwMGWTjzrcYfCTdc0",
				iconButton: "_138C3cC0PAtIwsXoIAfGvJ",
				iconWrapper: "Ep3vJhfng2q2-wfiIgstP",
				loadingContainer: "ve35wYJQyEHavtRQYDY7V",
				metadata: "_1xQ_DrqnJXDZq1ptXHxYIB",
				middleMeta: "_2OWUxJA0Dhi0onvygJk3_i",
				middleMetaBlock: "n1lY8o9sGnqcqSfVzm5Vs",
				modalCloseButton: "zKQ8lyAF3pYyDoSlTpTjA",
				modalDescriptionBlock: "_26a81Mk5bsppGjI9AXbmWS",
				modalDescriptionField: "_1brIoxFWlohWpvu34OwZQP",
				modalFooter: "R-9ebJbU9igzPDfUi4Txg",
				modalRadioButton: "_1KFGHoJGHbU05yh6-sQIr5",
				modalRadioText: "_360Lh4DKj256s8RdElARFo",
				modalReasonField: "_1hdSGf--gQDRwsU96bzao1",
				modalRemoveButton: "_2yAePObDkhgZql3P1FHRu1",
				modalReportMeta: "_21sqmEi4OnC4uXlcUGDT_T",
				modalReportTitle: "_1y0X9006mE_5nlHfol1nc2",
				modalRule: "_1AlCnggMuPLxxDUbWWhG2q",
				modalRuleField: "QP-_TXfrh6G1-IRJif4Cy",
				modalRuleTitle: "_2I1A_fyvhaC7TYrYwA047Y",
				modalSubmitButton: "hHFW3BkgX7tSn5Nev-ooY",
				placeholderRow: "hv6YY1IfCww5loDzbkuMS",
				row: "_1LfPdWXylWmVTmLinhd4xl",
				rulesHeader: "_3MOq7UPqtI4o9EnAyCWkEQ",
				rulesIcon: "_29Fl8s_IvZwHxUPNV2ARiW",
				rulesInfo: "KTZ0Ir6xknUXuN4WMI7RN",
				ruleMetaText: "iVYauV_t6_ChREoxhNGsU",
				ruleMetaTitle: "ffGjaCMPoTUkhkVp6rHw5",
				emptyWrapper: "_2-xwKK1EqJlzI2dO7SIrbF",
				ruleNumber: "_3DEhjnxmn1BzXcJ_ml7kSQ",
				ruleText: "_1ZwBW5sLL75ZAZvQreMjn-",
				PrimaryButton: "_3GOmWOjCh6hPWZg1j-zPkr",
				primaryButton: "_3GOmWOjCh6hPWZg1j-zPkr"
			}
		},
		"./src/reddit/components/SubredditRules/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/config.ts"),
				a = s("./node_modules/lodash/isEqual.js"),
				r = s.n(a),
				i = s("./node_modules/lodash/times.js"),
				d = s.n(i),
				l = s("./node_modules/react/index.js"),
				c = s.n(l),
				m = s("./node_modules/react-redux/es/index.js"),
				u = s("./node_modules/reselect/es/index.js"),
				p = s("./src/lib/lessComponent.tsx"),
				b = s("./src/reddit/actions/modal.ts"),
				h = s("./src/lib/makeActionCreator/index.ts"),
				g = s("./src/reddit/actions/subredditRules/constants.ts"),
				f = s("./src/reddit/actions/toaster.ts"),
				x = s("./src/reddit/endpoints/subreddit/rules.ts"),
				E = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/selectors/subreddit.ts");
			const C = Object(h.a)(g.e),
				_ = (e, t) => async (s, o, a) => {
					let {
						apiContext: r
					} = a;
					const i = Object(v.R)(o(), {
							subredditId: e
						}).name,
						d = "success-block-".concat(t.rule),
						l = "error-block-".concat(t.rule),
						c = await Object(x.a)(r(), i, t);
					if (c.ok) {
						const t = c.body;
						s(C({
							rules: t,
							subredditId: e
						})), s(f.e({
							id: d,
							kind: E.b.SuccessCommunityGreen,
							text: n.fbt._("Rule added", null, {
								hk: "4D4jbP"
							})
						}))
					} else s(f.e({
						id: l,
						kind: E.b.Error,
						text: c.json.errors ? c.json.errors[0][1] : n.fbt._("An error has occured. Please try again later", null, {
							hk: "2C9b4N"
						})
					}))
				}, k = Object(h.a)(g.f), O = Object(h.a)(g.g), y = Object(h.a)(g.d), j = (e, t) => async (s, o, a) => {
					let {
						apiContext: r
					} = a;
					const i = Object(v.R)(o(), {
							subredditId: e
						}).name,
						d = Object(v.N)(o(), {
							subredditId: e
						}),
						l = "success-block-".concat(e),
						c = "error-block-".concat(e),
						m = await Object(x.e)(r(), i, t);
					if (m.ok) {
						const t = m.body;
						s(y({
							rules: t,
							subredditId: e
						})), s(f.e({
							id: l,
							kind: E.b.SuccessCommunityGreen,
							text: n.fbt._("Rule order updated", null, {
								hk: "3bmmvl"
							}),
							buttonText: n.fbt._("Undo", null, {
								hk: "1RYWKC"
							}),
							buttonAction: j(e, d)
						}))
					} else s(f.e({
						id: c,
						kind: E.b.Error,
						text: "explanation" in m ? m.explanation : m.json && "errors" in m.json ? m.json.errors[0][1] : n.fbt._("An error has occured. Please try again later", null, {
							hk: "1XJ2UQ"
						})
					}))
				};
			var w = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				S = s("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				I = s("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				P = s("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				T = s("./src/reddit/components/TrackingHelper/index.tsx"),
				N = s("./src/reddit/controls/Button/index.tsx"),
				M = s("./src/reddit/controls/Sortable/index.tsx"),
				R = s("./src/reddit/selectors/telemetry.ts");
			const L = e => ({
					subreddit: R.subreddit(e),
					profile: R.profile(e),
					userSubreddit: R.userSubreddit(e)
				}),
				A = e => t => Object.assign({
					source: "rules",
					action: "click",
					noun: e
				}, L(t)),
				F = (e, t) => s => Object.assign({
					source: "rules",
					action: "click",
					noun: e,
					actionInfo: R.actionInfo(s, {
						count: t
					})
				}, L(s));
			var D = s("./src/reddit/icons/svgs/Rules/index.tsx"),
				B = s("./src/reddit/layout/row/Inline/index.tsx"),
				U = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				H = s("./src/reddit/models/Rule/index.ts"),
				W = s("./src/reddit/selectors/activeModalId.ts"),
				V = s("./src/reddit/selectors/moderatorPermissions.ts"),
				q = s("./src/reddit/components/SubredditRules/index.m.less"),
				G = s.n(q),
				K = s("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				z = s("./src/reddit/icons/svgs/Grapple/index.tsx");
			const Q = p.a.wrapped(K.a, "DragCard", G.a);
			var J = e => c.a.createElement(Q, {
					isDragging: e.isDragging,
					isOver: e.isOver,
					canDrop: e.canDrop
				}, c.a.createElement(B.a, {
					className: G.a.row
				}, c.a.createElement("span", {
					className: G.a.ruleNumber
				}, e.index + 1), c.a.createElement("span", {
					className: G.a.ruleText
				}, e.shortName), c.a.createElement("span", {
					className: G.a.iconWrapper
				}, c.a.createElement(z.a, {
					className: G.a.dragIcon,
					title: n.fbt._("Drag", null, {
						hk: "dBKmA"
					})
				})))),
				Z = s("./src/higherOrderComponents/asModal/index.tsx"),
				X = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				Y = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				$ = s("./src/reddit/controls/RadioInput/index.tsx"),
				ee = s("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				te = s("./src/reddit/controls/TextButton/index.tsx"),
				se = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");
			const ne = {
					rule: "",
					kind: "all",
					reportReason: "",
					description: ""
				},
				oe = Object(m.b)(null, (e, t) => ({
					createRule: s => e(_(t.subredditId, s)),
					updateRule: (s, o) => e(((e, t, s) => async (o, a, r) => {
						let {
							apiContext: i
						} = r;
						const d = Object(v.R)(a(), {
								subredditId: e
							}).name,
							l = "success-block-".concat(t.rule),
							c = "error-block-".concat(t.rule),
							m = await Object(x.f)(i(), d, t, s);
						if (m.ok) {
							const t = m.body;
							o(k({
								rules: t,
								subredditId: e,
								oldName: s
							})), o(f.e({
								id: l,
								kind: E.b.SuccessCommunityGreen,
								text: n.fbt._("Rule updated", null, {
									hk: "1ljetO"
								})
							}))
						} else o(f.e({
							id: c,
							kind: E.b.Error,
							text: m.json.errors ? m.json.errors[0][1] : n.fbt._("An error has occured. Please try again later", null, {
								hk: "2acjBM"
							})
						}))
					})(t.subredditId, s, o))
				}));
			class ae extends c.a.Component {
				constructor(e) {
					super(e), this.onRuleInputChange = e => {
						e.currentTarget.value.trim().length <= H.g && this.setState({
							rule: e.currentTarget.value
						})
					}, this.onReportReasonInputChange = e => {
						e.currentTarget.value.trim().length <= H.f && this.setState({
							reportReason: e.currentTarget.value
						})
					}, this.onDescriptionInputChange = e => {
						e.currentTarget.value.trim().length <= H.d && this.setState({
							description: e.currentTarget.value
						})
					}, this.onSave = () => {
						const {
							props: e,
							state: t
						} = this, s = {
							rule: t.rule.trim(),
							kind: t.kind,
							reason: t.reportReason.trim(),
							description: t.description.trim()
						};
						e.rule ? e.updateRule(s, e.rule.shortName) : e.createRule(s), e.toggleModal(), e.sendEvent()
					}, this.canSave = () => {
						const {
							props: e,
							state: t
						} = this, s = t.rule.trim(), n = t.reportReason.trim(), o = t.description.trim(), a = !e.ruleNames.includes(s) || e.ruleNames.includes(s) && e.rule && e.rule.shortName === s, r = !e.rule || (e.rule.shortName !== s || e.rule.violationReason !== t.reportReason || e.rule.kind !== t.kind || e.rule.description !== o);
						return a && r && s.length > 0 && s.length <= H.g && n.length <= H.f && o.length <= H.d && t.kind
					}, this.selectRuleKind = e => {
						this.setState({
							kind: e
						})
					}, this.isDuplicateRuleName = () => {
						const {
							props: e,
							state: t
						} = this, s = !e.rule || e.rule.shortName !== t.rule.trim(), n = e.ruleNames.includes(t.rule.trim());
						return 0 !== t.rule.trim().length && s && n
					}, this.state = e.rule ? {
						rule: e.rule.shortName,
						kind: e.rule.kind,
						reportReason: e.rule.violationReason || "",
						description: e.rule.description || ""
					} : ne
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return c.a.createElement(Y.d, null, c.a.createElement(Y.h, null, c.a.createElement(se.a, null, c.a.createElement(Y.p, null, e.rule ? n.fbt._("Edit rule", null, {
						hk: "2zflTO"
					}) : n.fbt._("Add rule", null, {
						hk: "1xqo5O"
					})), c.a.createElement(te.a, {
						className: G.a.modalCloseButton,
						onClick: e.toggleModal
					}, c.a.createElement(Y.b, null)))), c.a.createElement(Y.k, null, c.a.createElement(Y.g, null, c.a.createElement(Y.o, {
						className: G.a.modalRule
					}, n.fbt._("Rule", null, {
						hk: "1W7esG"
					})), c.a.createElement(Y.s, {
						className: G.a.modalRuleField,
						onChange: this.onRuleInputChange,
						placeholder: n.fbt._('Rule displayed (e.g. "No photos")', null, {
							hk: "GdEW"
						}),
						value: t.rule
					}), this.isDuplicateRuleName() && c.a.createElement("span", {
						className: G.a.duplicateName
					}, n.fbt._("You have another rule with this title. Please change.", null, {
						hk: "2EPSGv"
					})), c.a.createElement(X.a, {
						maxChars: H.g,
						text: t.rule.trim()
					})), c.a.createElement(Y.g, null, c.a.createElement(Y.o, {
						className: G.a.modalRuleTitle
					}, n.fbt._("Applies to", null, {
						hk: "Pzu3b"
					})), c.a.createElement($.a, {
						name: "RULE_KIND_PICKER",
						onChange: this.selectRuleKind,
						value: t.kind
					}, c.a.createElement(ee.a, {
						className: G.a.modalRadioButton,
						key: H.b.all,
						value: H.b.all,
						selected: t.kind === H.b.all,
						showButton: !0,
						tabIndex: t.kind === H.b.all ? 0 : -1
					}, c.a.createElement(Y.o, {
						className: G.a.modalRadioText
					}, n.fbt._("Posts & comments", null, {
						hk: "tHmQq"
					}))), c.a.createElement(ee.a, {
						className: G.a.modalRadioButton,
						key: H.b.post,
						value: H.b.post,
						selected: t.kind === H.b.post,
						showButton: !0,
						tabIndex: t.kind === H.b.post ? 0 : -1
					}, c.a.createElement(Y.o, {
						className: G.a.modalRadioText
					}, n.fbt._("Posts only", null, {
						hk: "16dDBr"
					}))), c.a.createElement(ee.a, {
						className: G.a.modalRadioButton,
						key: H.b.comment,
						value: H.b.comment,
						selected: t.kind === H.b.comment,
						showButton: !0,
						tabIndex: t.kind === H.b.comment ? 0 : -1
					}, c.a.createElement(Y.o, {
						className: G.a.modalRadioText
					}, n.fbt._("Comments only", null, {
						hk: "2V8qUA"
					}))))), c.a.createElement(Y.g, null, c.a.createElement(Y.o, {
						className: G.a.modalReportTitle
					}, n.fbt._("Report reason", null, {
						hk: "3ShjE9"
					})), c.a.createElement(Y.l, {
						className: G.a.modalReportMeta
					}, n.fbt._("Defaults to rule name if left blank", null, {
						hk: "2xObiU"
					})), c.a.createElement(Y.s, {
						className: G.a.modalReasonField,
						onChange: this.onReportReasonInputChange,
						placeholder: t.rule.trim().length > 0 && 0 === t.reportReason.trim().length ? t.rule : n.fbt._('Reason rule is broken (e.g. "This is a photo")', null, {
							hk: "2Op1SL"
						}),
						value: t.reportReason
					}), c.a.createElement(X.a, {
						maxChars: H.f,
						text: t.reportReason.trim()
					})), c.a.createElement("div", {
						className: G.a.modalDescriptionBlock
					}, c.a.createElement(Y.o, {
						className: G.a.modalRuleTitle
					}, n.fbt._("Full description", null, {
						hk: "4CTvQy"
					})), c.a.createElement(Y.s, {
						className: G.a.modalDescriptionField,
						onChange: this.onDescriptionInputChange,
						placeholder: n.fbt._("Enter the full description of the rule.", null, {
							hk: "3EyaJe"
						}),
						value: t.description
					}), c.a.createElement(X.a, {
						maxChars: H.d,
						text: t.description.trim()
					}))), c.a.createElement(Y.f, {
						className: G.a.modalFooter
					}, c.a.createElement(N.f, {
						className: G.a.modalSubmitButton,
						onClick: this.onSave,
						disabled: !this.canSave()
					}, e.rule ? n.fbt._("Save", null, {
						hk: "ufsfP"
					}) : n.fbt._("Add new rule", null, {
						hk: "2dy0gV"
					})), c.a.createElement(Y.a, {
						onClick: e.toggleModal
					}, n.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.rule && c.a.createElement(Y.r, {
						className: G.a.modalRemoveButton,
						onClick: e.onDelete
					}, n.fbt._("Delete", null, {
						hk: "4ysFr0"
					}))))
				}
			}
			var re = Object(Z.a)(oe(ae)),
				ie = s("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				de = s("./src/reddit/components/RichTextJson/index.tsx"),
				le = s("./src/lib/constants/index.ts"),
				ce = s("./src/lib/humanizeUTCDate/index.tsx"),
				me = s("./src/lib/timeAgo/index.ts");
			var ue = e => {
					const t = (e => e - 8 * le.J / le.Eb)(e);
					return Object(me.c)(t) >= 1 ? Object(ce.a)(t) : Object(me.d)(t)
				},
				pe = s("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				be = s("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				he = s("./src/reddit/icons/svgs/Pencil/index.tsx"),
				ge = s("./src/reddit/models/RichTextJson/index.ts");
			const fe = {};
			class xe extends c.a.Component {
				constructor(e) {
					super(e), this.toggleExpandDetails = () => {
						this.setState(e => ({
							isExpanded: !e.isExpanded
						}))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						hasConfigPerms: e,
						index: t,
						onEdit: s,
						subredditRule: o
					} = this.props, a = o.descriptionRichText ? JSON.parse(o.descriptionRichText).document : void 0;
					return c.a.createElement(c.a.Fragment, null, c.a.createElement(B.a, {
						className: G.a.row
					}, c.a.createElement("span", {
						className: G.a.ruleNumber
					}, t + 1), c.a.createElement("span", {
						className: G.a.ruleText
					}, o.shortName), c.a.createElement("span", {
						className: G.a.iconWrapper
					}, e && c.a.createElement("button", {
						className: G.a.iconButton,
						onClick: s
					}, c.a.createElement(he.a, {
						className: G.a.icon,
						title: n.fbt._("Edit", null, {
							hk: "1nftDt"
						})
					})), c.a.createElement("button", {
						className: G.a.iconButton,
						onClick: this.toggleExpandDetails
					}, this.state.isExpanded ? c.a.createElement(pe.a, {
						className: G.a.icon,
						title: n.fbt._("Collapse", null, {
							hk: "eGqwd"
						})
					}) : c.a.createElement(be.a, {
						className: G.a.icon,
						title: n.fbt._("Expand", null, {
							hk: "4dMVPg"
						})
					})))), this.state.isExpanded && c.a.createElement(B.a, {
						className: G.a.expandDetails
					}, c.a.createElement("span", {
						className: G.a.metadata
					}, c.a.createElement("span", {
						className: G.a.ruleMetaTitle
					}, n.fbt._("Report reason", null, {
						hk: "2RH1DJ"
					})), c.a.createElement("span", {
						className: G.a.ruleMetaText
					}, o.violationReason && 0 !== o.violationReason.length ? o.violationReason : o.shortName)), c.a.createElement("span", {
						className: G.a.middleMeta
					}, c.a.createElement("div", {
						className: G.a.middleMetaBlock
					}, c.a.createElement("div", {
						className: G.a.ruleMetaTitle
					}, n.fbt._("Applies to", null, {
						hk: "19eYpy"
					})), c.a.createElement("div", {
						className: G.a.ruleMetaText
					}, o.kind === H.b.all ? n.fbt._("Posts & comments", null, {
						hk: "34PjHx"
					}) : o.kind === H.b.post ? n.fbt._("Posts only", null, {
						hk: "3MllWy"
					}) : n.fbt._("Comments only", null, {
						hk: "StCEa"
					}))), c.a.createElement("div", {
						className: G.a.middleMetaBlock
					}, c.a.createElement("div", {
						className: G.a.ruleMetaTitle
					}, n.fbt._("Created", null, {
						hk: "gSE9w"
					})), c.a.createElement("div", {
						className: G.a.ruleMetaText
					}, ue(o.createdUtc)))), c.a.createElement("span", {
						className: G.a.metadata
					}, c.a.createElement("span", {
						className: G.a.ruleMetaTitle
					}, n.fbt._("Full description", null, {
						hk: "20Lgcg"
					})), c.a.createElement("span", {
						className: G.a.ruleMetaText
					}, a && !Object(ge.F)({
						document: a
					}) ? c.a.createElement(de.a, {
						className: G.a.ruleMetaText,
						content: {
							document: a
						},
						rtJsonElementProps: fe
					}) : o.descriptionHtml ? c.a.createElement(ie.a, {
						className: G.a.ruleMetaText,
						html: o.descriptionHtml
					}) : o.description))))
				}
			}
			var Ee = xe;
			const ve = p.a.wrapped(N.f, "PrimaryButton", G.a),
				Ce = () => c.a.createElement(B.a, {
					className: G.a.placeholderRow
				}, c.a.createElement("span", {
					className: G.a.emptyWrapper
				}, c.a.createElement("span", {
					className: G.a.emptyIcon
				})), c.a.createElement("span", {
					className: G.a.emptyDetails
				}), c.a.createElement("span", {
					className: G.a.iconWrapper
				}, c.a.createElement("span", {
					className: G.a.emptyRightIcon
				}), c.a.createElement("span", {
					className: G.a.emptyRightIcon
				}))),
				_e = () => c.a.createElement("div", {
					className: G.a.loadingContainer
				}, d()(15, e => c.a.createElement(Ce, {
					key: e
				}))),
				ke = Object(u.c)({
					hasModConfigPerms: (e, t) => Object(V.a)(U.c.config)(e, {
						subredditId: t.subreddit.id
					}),
					isConfirmModalOpen: e => "SubredditRule--Modal--DeleteConfirmation" === Object(W.a)(e),
					isRuleEditorOpen: e => "SubredditRule--Editor--Modal" === Object(W.a)(e),
					isSubredditRulesPending: e => Object(v.P)(e),
					ruleOrder: (e, t) => Object(v.N)(e, {
						subredditId: t.subreddit.id
					}),
					subredditRules: (e, t) => Object(v.Q)(e, {
						subredditId: t.subreddit.id
					})
				}),
				Oe = Object(m.b)(ke, (e, t) => ({
					removeRule: (s, o) => e(((e, t, s) => async (o, a, r) => {
						let {
							apiContext: i
						} = r;
						const d = Object(v.R)(a(), {
								subredditId: e
							}).name,
							l = Object(v.Q)(a(), {
								subredditId: e
							})[s],
							c = "success-block-".concat(t),
							m = "error-block-".concat(t),
							u = await Object(x.d)(i(), d, t);
						if (u.ok) {
							const t = u.body;
							o(O({
								rules: t,
								subredditId: e
							})), o(f.e({
								id: c,
								kind: E.b.SuccessCommunityGreen,
								text: n.fbt._("Rule deleted", null, {
									hk: "2Kwoph"
								}),
								buttonText: n.fbt._("Undo", null, {
									hk: "1RYWKC"
								}),
								buttonAction: _(e, {
									rule: l.shortName,
									kind: l.kind,
									reason: l.violationReason,
									description: l.description
								})
							}))
						} else o(f.e({
							id: m,
							kind: E.b.Error,
							text: u.json.errors ? u.json.errors[0][1] : n.fbt._("An error has occured. Please try again later", null, {
								hk: "37ELrZ"
							})
						}))
					})(t.subreddit.id, s, o)),
					reorderRules: s => {
						e(j(t.subreddit.id, s))
					},
					toggleConfirmationModal: () => e(Object(b.i)("SubredditRule--Modal--DeleteConfirmation")),
					toggleRuleEditorModal: () => e(Object(b.i)("SubredditRule--Editor--Modal"))
				}));
			class ye extends c.a.Component {
				constructor(e) {
					super(e), this.deleteRule = () => {
						const e = this.state.ruleToEdit;
						e && this.props.removeRule(e.shortName, e.priority)
					}, this.onConfirmDeleteRule = () => {
						this.props.toggleConfirmationModal()
					}, this.onEditRule = e => {
						this.setState({
							ruleToEdit: e
						}), this.props.toggleRuleEditorModal()
					}, this.handleDrop = (e, t, s) => this.setState({
						ruleOrder: s,
						numRulesMoved: this.state.numRulesMoved + 1
					}), this.reorderRules = () => {
						this.props.reorderRules(this.state.ruleOrder), this.props.sendEvent(F("save_reorder", this.state.numRulesMoved)), this.stopReorder()
					}, this.startReorder = () => {
						this.setState({
							isReordering: !0,
							ruleOrder: this.props.ruleOrder
						})
					}, this.stopReorder = () => this.setState({
						isReordering: !1,
						numRulesMoved: 0
					}), this.toggleConfirmationModal = () => {
						this.props.toggleConfirmationModal(), this.setState({
							ruleToEdit: null
						})
					}, this.toggleEditorModal = () => {
						this.props.toggleRuleEditorModal(), this.setState({
							ruleToEdit: null
						})
					}, this.trackClick = e => this.props.sendEvent(A(e)), this.trackEdit = () => this.state.ruleToEdit ? this.trackClick("save_edit") : this.trackClick("save_new"), this.trackDelete = () => this.trackClick("delete"), this.state = {
						numRulesMoved: 0,
						ruleToEdit: null,
						ruleOrder: e.ruleOrder,
						isReordering: !1
					}
				}
				render() {
					const {
						hasModConfigPerms: e,
						isConfirmModalOpen: t,
						isRuleEditorOpen: s,
						isSubredditRulesPending: a,
						subreddit: i,
						subredditRules: d
					} = this.props;
					return c.a.createElement(c.a.Fragment, null, e && c.a.createElement(P.c, null, this.state.isReordering ? c.a.createElement(N.i, {
						onClick: this.stopReorder
					}, n.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})) : c.a.createElement(N.n, {
						onClick: this.startReorder,
						disabled: d.length <= 1
					}, n.fbt._("Reorder rules", null, {
						hk: "1qh7V6"
					})), this.state.isReordering ? c.a.createElement(ve, {
						onClick: this.reorderRules,
						disabled: r()(d.map(e => e.shortName), this.state.ruleOrder)
					}, n.fbt._("Save", null, {
						hk: "3nstB"
					})) : c.a.createElement(ve, {
						onClick: this.toggleEditorModal,
						disabled: a || d.length >= H.e
					}, n.fbt._("Add rule", null, {
						hk: "6GEk0"
					}))), d.length ? c.a.createElement(P.a, null, c.a.createElement("div", {
						className: G.a.header
					}, c.a.createElement(P.b, {
						className: G.a.rulesHeader
					}, n.fbt._("Rules", null, {
						hk: "41SmPR"
					}), c.a.createElement(I.a, {
						linkUrl: "".concat(o.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360023379211")
					})), !this.state.isReordering && c.a.createElement("div", {
						className: G.a.rulesInfo
					}, n.fbt._("These are rules that visitors must follow to participate. They can be used as reasons to report or ban posts, comments, and users. Communities can have a maximum of 15 rules.", null, {
						hk: "1C2Vjc"
					}))), this.state.isReordering ? c.a.createElement(M.a, {
						values: this.state.ruleOrder,
						render: (e, t, s, n, o) => c.a.createElement(J, {
							isDragging: s,
							isOver: n,
							canDrop: o,
							index: t,
							shortName: e
						}),
						onDrop: this.handleDrop
					}) : d.map((t, s) => c.a.createElement(Ee, {
						hasConfigPerms: e,
						index: s,
						key: "".concat(i.name, "-").concat(t.shortName),
						onEdit: () => this.onEditRule(t),
						subredditRule: t
					}))) : c.a.createElement(P.a, null, c.a.createElement("div", {
						className: G.a.header
					}, c.a.createElement(P.b, {
						className: G.a.rulesHeader
					}, n.fbt._("Rules", null, {
						hk: "41SmPR"
					}), c.a.createElement(I.a, {
						linkUrl: "".concat(o.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360023379211")
					}))), a ? c.a.createElement(_e, null) : c.a.createElement(S.c, {
						text: n.fbt._("No rules yet", null, {
							hk: "pYLkV"
						})
					}, c.a.createElement(D.a, {
						className: G.a.rulesIcon
					}))), s && c.a.createElement(re, {
						onDelete: this.onConfirmDeleteRule,
						rule: this.state.ruleToEdit,
						ruleNames: d.map(e => e.shortName),
						sendEvent: this.trackEdit,
						subredditId: i.id,
						toggleModal: this.toggleEditorModal,
						withOverlay: !0
					}), t && this.state.ruleToEdit && c.a.createElement(w.a, {
						actionText: n.fbt._("Delete", null, {
							hk: "2ZdVqx"
						}),
						headerText: n.fbt._("Delete rule", null, {
							hk: "5q2Ri"
						}),
						modalText: n.fbt._("Are you sure you want to delete this rule?", null, {
							hk: "2diD6u"
						}),
						onConfirm: this.deleteRule,
						toggleModal: this.toggleConfirmationModal,
						trackClick: this.trackDelete,
						withOverlay: !0
					}))
				}
			}
			t.a = Oe(Object(T.c)(ye))
		},
		"./src/reddit/components/SubscribeButton/Base.m.less": function(e, t, s) {
			e.exports = {
				IconButton: "_1zyZUfB30L-DDI98CCLJlQ",
				iconButton: "_1zyZUfB30L-DDI98CCLJlQ",
				active: "_2FebEA49ReODemDlwzYHSR",
				SubscribeIcon: "_1O2i-ToERP3a0i4GSL0QwU",
				subscribeIcon: "_1O2i-ToERP3a0i4GSL0QwU",
				UnsubscribeIcon: "_1uBzAtenMgErKev3G7oXru",
				unsubscribeIcon: "_1uBzAtenMgErKev3G7oXru",
				isSmall: "_2ilDLNSvkCHD3Cs9duy9Q_",
				SubscribeIconButton: "_2kBlhw4LJXNnk73IJcwWsT",
				subscribeIconButton: "_2kBlhw4LJXNnk73IJcwWsT",
				UnsubscribeIconButton: "_1kRJoT0CagEmHsFjl2VT4R",
				unsubscribeIconButton: "_1kRJoT0CagEmHsFjl2VT4R",
				SubscribeInternalButton: "_3VgTjAJVNNV7jzlnwY-OFY",
				subscribeInternalButton: "_3VgTjAJVNNV7jzlnwY-OFY",
				UnsubscribeButton: "_2QmHYFeMADTpuXJtd36LQs",
				unsubscribeButton: "_2QmHYFeMADTpuXJtd36LQs",
				UnsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				unsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				UnsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW",
				unsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW"
			}
		},
		"./src/reddit/components/SubscribeButton/Base.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return j
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/reddit/constants/elementClassNames.ts"),
				i = s("./src/reddit/controls/Button/index.tsx"),
				d = s("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				l = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				c = s("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				m = s("./src/reddit/components/SubscribeButton/Base.m.less"),
				u = s.n(m),
				p = s("./src/lib/classNames/index.ts"),
				b = s("./src/lib/lessComponent.tsx");

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var g = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const f = b.a.button("IconButton", u.a),
				x = b.a.wrapped(l.a, "SubscribeIcon", u.a),
				E = b.a.wrapped(d.a, "UnsubscribeIcon", u.a),
				v = b.a.wrapped(e => {
					var {
						border: t,
						small: s
					} = e, n = g(e, ["border", "small"]);
					return a.a.createElement(f, n, a.a.createElement(x, {
						className: Object(p.a)(n.className, {
							[u.a.isSmall]: s
						})
					}))
				}, "SubscribeIconButton", u.a),
				C = b.a.wrapped(e => {
					var {
						border: t,
						small: s
					} = e, n = g(e, ["border", "small"]);
					return t ? a.a.createElement(i.f, h({}, n, {
						className: Object(p.a)(n.className, {
							[u.a.isSmall]: s
						})
					})) : a.a.createElement(i.n, h({}, n, {
						className: Object(p.a)(n.className, {
							[u.a.isSmall]: s
						})
					}))
				}, "SubscribeInternalButton", u.a),
				_ = e => {
					var {
						icon: t
					} = e, s = g(e, ["icon"]);
					return t ? a.a.createElement(v, h({}, s, {
						className: Object(p.a)(s.className, {
							[u.a.isSmall]: s.small
						})
					})) : a.a.createElement(C, h({}, s, {
						className: Object(p.a)(s.className, {
							[u.a.isSmall]: s.small
						})
					}))
				},
				k = b.a.wrapped(e => {
					var {
						border: t,
						small: s,
						type: n
					} = e, o = g(e, ["border", "small", "type"]);
					return a.a.createElement(f, o, a.a.createElement(E, {
						className: Object(p.a)(r.n, o.className, {
							[u.a.isSmall]: s
						})
					}))
				}, "UnsubscribeIconButton", u.a),
				O = b.a.wrapped(e => {
					var {
						border: t,
						small: s,
						type: o
					} = e, r = g(e, ["border", "small", "type"]);
					const d = a.a.createElement(a.a.Fragment, null, a.a.createElement("span", {
							className: u.a.UnsubscribeButtonDefault
						}, "subreddit" === o ? n.fbt._("Joined", null, {
							hk: "1MTmIz"
						}) : n.fbt._("Following", null, {
							hk: "1wQlVR"
						})), a.a.createElement("span", {
							className: u.a.UnsubscribeButtonHover
						}, "subreddit" === o ? n.fbt._("Leave", null, {
							hk: "2lLnnn"
						}) : n.fbt._("Unfollow", null, {
							hk: "2b5ERD"
						}))),
						l = Object(p.a)(r.className, {
							[u.a.isSmall]: s
						});
					return t ? a.a.createElement(i.i, h({}, r, {
						className: l,
						children: d
					})) : a.a.createElement(i.n, h({}, r, {
						className: l,
						children: d
					}))
				}, "UnsubscribeButton", u.a),
				y = e => {
					var {
						icon: t
					} = e, s = g(e, ["icon"]);
					return t ? a.a.createElement(k, h({}, s, {
						className: Object(p.a)(s.className, {
							[u.a.isSmall]: s.small
						})
					})) : a.a.createElement(O, h({}, s, {
						className: Object(p.a)(s.className, {
							[u.a.isSmall]: s.small
						})
					}))
				};
			class j extends a.a.Component {
				constructor() {
					super(...arguments), this.onClick = e => {
						if (this.props.userIsSubscriber ? this.props.onUnsubscribe() : this.props.onSubscribe(), this.props.onClick && this.props.onClick(e), this.props.getEventFactory) {
							const e = this.props.getEventFactory(this.props.userIsSubscriber);
							e && this.props.sendEvent(e)
						}
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						border: e = !0,
						className: t,
						icon: s = !1,
						id: n,
						small: o = !1
					} = this.props, r = {
						border: e,
						className: t,
						icon: s,
						onClick: this.onClick,
						small: o
					};
					return this.props.userIsSubscriber ? a.a.createElement(y, h({}, r, {
						type: this.props.identifier.type
					})) : a.a.createElement(_, h({}, r, {
						id: n
					}), this.props.children, Object(c.a)({
						type: this.props.identifier.type,
						key: "subscribe"
					}))
				}
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.m.less": function(e, t, s) {
			e.exports = {
				SubscribeInternalButton: "QvUHhznbRVbKaK8dZGZVV",
				subscribeInternalButton: "QvUHhznbRVbKaK8dZGZVV",
				UnsubscribeButton: "_3gteUGkVlyl5VuSsNQJaz1",
				unsubscribeButton: "_3gteUGkVlyl5VuSsNQJaz1",
				isLarge: "_2jGEuWB6HWtIbTjMG68OXY",
				ButtonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				buttonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				Checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				Plus: "_2zcGm9WDxG67GYyNNvHzlA",
				plus: "_2zcGm9WDxG67GYyNNvHzlA",
				unsubscribeButtonHoverStyles: "_1tZ_edPYFuF6jhuTr_iPEE",
				joinCleanupContent: "_3GS035a5A47X7LR9VSQYy6"
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/components/TrackingHelper/index.tsx"),
				r = s("./src/reddit/connectors/SubscribeButton/index.ts"),
				i = s("./src/reddit/controls/Button/index.tsx"),
				d = s("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				l = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				c = s("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				m = s("./src/reddit/components/SubscribeButton/Inline.m.less"),
				u = s.n(m),
				p = s("./src/lib/classNames/index.ts"),
				b = s("./src/lib/lessComponent.tsx");

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var g = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const f = b.a.wrapped(e => {
					var {
						small: t,
						shouldReverseColor: s
					} = e, n = g(e, ["small", "shouldReverseColor"]);
					const a = s ? i.i : i.f;
					return o.a.createElement(a, h({}, n, {
						className: Object(p.a)(n.className, {
							[u.a.isLarge]: !t
						})
					}))
				}, "SubscribeInternalButton", u.a),
				x = b.a.wrapped(e => {
					var {
						small: t,
						belongsToType: s,
						shouldReverseColor: n
					} = e, a = g(e, ["small", "belongsToType", "shouldReverseColor"]);
					const r = n ? i.f : i.i;
					return o.a.createElement(r, h({}, a, {
						className: Object(p.a)(a.className, {
							[u.a.isLarge]: !t
						})
					}))
				}, "UnsubscribeButton", u.a),
				E = b.a.wrapped(d.a, "Checkmark", u.a),
				v = b.a.wrapped(l.a, "Plus", u.a),
				C = b.a.div("ButtonSpacer", u.a);
			class _ extends o.a.Component {
				constructor(e) {
					super(e), this.onMouseEnter = () => {
						this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						this.setState({
							isHovered: !1
						})
					}, this.onClick = e => {
						const {
							props: t
						} = this;
						if (t.userIsSubscriber ? t.onUnsubscribe() : (this.setState({
								hasJustSubscribed: !0
							}), t.onSubscribe()), t.onClick && t.onClick(e), t.getEventFactory) {
							const e = t.getEventFactory(t.userIsSubscriber);
							e && t.sendEvent(e)
						}
					}, this.state = {
						hasJustSubscribed: !1,
						isHovered: !1
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const e = this.props,
						{
							className: t,
							identifier: s,
							onSubscribe: n,
							onUnsubscribe: a,
							postId: r,
							sendEvent: i,
							small: d = !1,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: b,
							onSubscriptionsRequested: _
						} = e,
						k = g(e, ["className", "identifier", "onSubscribe", "onUnsubscribe", "postId", "sendEvent", "small", "userIsSubscriber", "doNotHideOtherSubscribeButtons", "getEventFactory", "onSubscriptionsRequested"]),
						O = this.state.isHovered;
					let y = l ? "subscribed" : "subscribe";
					l && O && (y = "unsubscribe");
					const j = Object(c.a)({
						type: s.type,
						key: y
					});
					return l ? this.state.hasJustSubscribed || m ? o.a.createElement(x, h({
						className: Object(p.a)(t, {
							[u.a.isLarge]: !d,
							[u.a.unsubscribeButtonHoverStyles]: !d
						}),
						onClick: this.onClick,
						small: d,
						belongsToType: s.type,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, k), d && o.a.createElement(E, null), !d && !O && o.a.createElement(E, null), !d && j) : d ? null : o.a.createElement(C, null) : o.a.createElement(o.a.Fragment, null, o.a.createElement(f, h({
						className: Object(p.a)(t, {
							[u.a.isLarge]: !d
						}),
						onClick: this.onClick,
						small: d
					}, k, {
						id: "subscribe-button-".concat(r),
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}), o.a.createElement(v, null), !d && j))
				}
			}
			t.a = Object(r.a)(Object(a.c)(_))
		},
		"./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js");
			const o = e => {
					let {
						type: t
					} = e;
					return "subreddit" === t ? "subredditActions" : "profileActions"
				},
				a = {
					subredditActions: {
						subscribe: () => n.fbt._("Join", null, {
							hk: "3Nhj3V"
						}),
						subscribed: () => n.fbt._("Joined", null, {
							hk: "1YGago"
						}),
						unsubscribe: () => n.fbt._("Leave", null, {
							hk: "299znK"
						})
					},
					profileActions: {
						subscribe: () => n.fbt._("Follow", null, {
							hk: "18PRa5"
						}),
						subscribed: () => n.fbt._("Following", null, {
							hk: "sjS3y"
						}),
						unsubscribe: () => n.fbt._("Unfollow", null, {
							hk: "3c0uwF"
						})
					}
				},
				r = e => {
					let {
						type: t,
						key: s
					} = e;
					return a[o({
						type: t
					})][s]()
				}
		},
		"./src/reddit/components/SubscribeButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/components/TrackingHelper/index.tsx"),
				o = s("./src/reddit/connectors/SubscribeButton/index.ts"),
				a = s("./src/reddit/components/SubscribeButton/Base.tsx");
			t.a = Object(o.a)(Object(n.c)(a.a))
		},
		"./src/reddit/components/UserNameAndIcon/index.m.less": function(e, t, s) {
			e.exports = {
				UserIconContainer: "_3gyThPd4NTS21qtNdizCxE",
				userIconContainer: "_3gyThPd4NTS21qtNdizCxE",
				UserIcon: "_1utZNH6IItbNzgdnUBW-Bp",
				userIcon: "_1utZNH6IItbNzgdnUBW-Bp",
				UserLink: "_2Q3rLIRb_ij54AEsabVm9L",
				userLink: "_2Q3rLIRb_ij54AEsabVm9L"
			}
		},
		"./src/reddit/components/UserNameAndIcon/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				d = s("./src/reddit/components/UserIcon/index.tsx"),
				l = s("./src/reddit/controls/InternalLink/index.tsx"),
				c = s("./src/reddit/components/UserNameAndIcon/index.m.less"),
				m = s.n(c);
			const u = r.a.span("UserIconContainer", m.a),
				p = r.a.wrapped(d.a, "UserIcon", m.a),
				b = r.a.wrapped(l.a, "UserLink", m.a);
			t.a = e => a.a.createElement(b, {
				className: e.className,
				to: "".concat(n.a.redditUrl, "/user/").concat(e.username)
			}, a.a.createElement(i.a, {
				user: e.username,
				sendHoverCardEvent: e.sendHoverCardEvent,
				subredditId: e.subredditId,
				tooltipId: e.tooltipId
			}, a.a.createElement(u, {
				style: {
					height: e.iconSize || "32px",
					width: e.iconSize || "32px"
				}
			}, a.a.createElement(p, {
				iconUrl: e.userIcon,
				isNSFW: !1,
				userName: e.username
			})), e.username))
		},
		"./src/reddit/components/ViewReportsDropdown/Loader.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(n.a)({
				resolved: {},
				chunkName: () => "reddit-components-ViewReportsDropdown-index",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!s.m[t]
				},
				importAsync: () => s.e("reddit-components-ViewReportsDropdown-index").then(s.bind(null, "./src/reddit/components/ViewReportsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return s(t)
				},
				resolve() {
					return "./src/reddit/components/ViewReportsDropdown/index.tsx"
				}
			})
		},
		"./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less": function(e, t, s) {
			e.exports = {
				modalBody: "_1bgWTt9jbjzFmQBe0xzfBc",
				notice: "_19wd_7K0Gqdp6cf0Pno6jX",
				sectionTitle: "_2eB-lbdBJ7yGnpy9iCXf27",
				primaryButton: "_1Wp9oAwAZieyVMe4wA5SeL",
				dropdownContainer: "_2-waVlosIHdWwUa_OBavKm",
				dropdownTarget: "_1mcRpBQSnN5ALeKix2x4Py",
				targetText: "_3QRCCOc1SfjMkk4bZCW5lD",
				dropdown: "_1Uq_MgLQhUk4iL9iHGz3qL",
				dropdownRow: "_2UfNC6z3v6GQsT_TQn-eoZ",
				errorText: "_31tw_6Xr1vH0KRVUnoJEdv"
			}
		},
		"./src/reddit/connectors/ClassicPost/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return g
			})), s.d(t, "b", (function() {
				return f
			}));
			var n = s("./node_modules/react-redux/es/index.js"),
				o = s("./node_modules/reselect/es/index.js"),
				a = s("./src/reddit/actions/post.ts"),
				r = s("./src/reddit/actions/tooltip.ts"),
				i = s("./src/reddit/models/Vote/index.ts"),
				d = s("./src/reddit/contexts/InsideOverlay.tsx"),
				l = s("./src/reddit/contexts/PageLayer/index.tsx"),
				c = s("./src/reddit/selectors/activeModalId.ts"),
				m = s("./src/reddit/selectors/experiments/chatPost.ts"),
				u = s("./src/reddit/selectors/moderatorPermissions.ts"),
				p = s("./src/reddit/selectors/postFlair.ts"),
				b = s("./src/reddit/selectors/posts.ts"),
				h = s("./src/reddit/selectors/user.ts");
			const g = {
					autoplayPref: h.b,
					activeModalId: c.a,
					crosspost: b.d,
					currentUser: h.i,
					isActive: b.j,
					isChatPostExperiment: m.d,
					isCurrentUserProfilePost: b.k,
					isExpanded: b.m,
					isLoggedIn: h.H,
					isMeta: (e, t) => {
						let {
							postId: s
						} = t;
						return Object(b.r)(e, s)
					},
					moderatorPermissions: u.i,
					modModeEnabled: l.P,
					post: b.O,
					poll: (e, t) => {
						const s = e.posts.metaMap[t.postId];
						return s ? e.polls.models[s] : null
					},
					showEditFlair: p.a,
					showMedia: l.r,
					subredditOrProfile: b.bb,
					userIsOp: h.hb,
					flairStyleTemplate: l.R
				},
				f = (e, t) => {
					let {
						listingKey: s,
						listingName: n,
						postId: o
					} = t;
					return {
						handleVote: t => {
							const s = t === i.a.upvoted ? Object(a.db)(o) : Object(a.z)(o);
							e(s)
						},
						onIgnoreReports: () => e(Object(a.bb)(o)),
						onOpenReportsDropdown: t => e(Object(r.h)({
							tooltipId: t
						}))
					}
				},
				x = Object(n.b)(() => Object(o.c)(g), f, (e, t, s) => Object.assign({}, e, t, s, {
					formatTitle: e => e.title
				}));
			t.a = e => x(Object(d.b)(e))
		},
		"./src/reddit/connectors/ClassicPost/searchResults.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.constructor.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/LRUCache/index.ts"),
				d = s("./src/reddit/contexts/PageLayer/index.tsx"),
				l = s("./src/reddit/connectors/ClassicPost/index.tsx");
			const c = Object(d.t)({
					searchQuery: d.V
				}),
				m = new i.a(250),
				u = e => {
					const t = e.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
					return e => {
						const s = "".concat(e.id, "-").concat(t);
						let n = m.get(s);
						if (void 0 === n) {
							const a = new RegExp("(\\b".concat(t, "\\b)"), "gi"),
								r = e.title.split(a);
							for (let e = 1; e < r.length; e += 2) r[e] = o.a.createElement("em", {
								style: {
									fontWeight: 700
								}
							}, r[e]);
							n = o.a.createElement("span", {
								style: {
									fontWeight: "normal"
								}
							}, o.a.Children.toArray(r)), m.set(s, n)
						}
						return n
					}
				},
				p = Object(a.b)(() => Object(r.c)(l.c), l.b, (e, t, s) => Object.assign({}, e, t, s, {
					formatTitle: u(s.searchQuery || "")
				}));
			t.a = e => c(p(e))
		},
		"./src/reddit/connectors/SubscribeButton/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react-redux/es/index.js"),
				o = s("./node_modules/reselect/es/index.js"),
				a = s("./src/reddit/actions/subscription/index.ts"),
				r = s("./src/reddit/selectors/subreddit.ts");
			t.a = Object(n.b)(() => Object(o.c)({
				userIsSubscriber: r.cb
			}), (e, t) => {
				let {
					identifier: s
				} = t;
				return {
					onSubscribe: () => e(a.d([s], !0)),
					onSubscriptionsRequested: () => e(a.e()),
					onUnsubscribe: () => e(a.d([s], !1))
				}
			})
		},
		"./src/reddit/constants/componentTestIds.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return n
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "e", (function() {
				return i
			}));
			const n = "comment",
				o = "comment-submission-form-markdown",
				a = "comment-submission-form-richtext",
				r = "comments-page-link-num-comments",
				i = "post-content"
		},
		"./src/reddit/constants/postCreation.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return o
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return r
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "g", (function() {
				return l
			}));
			const n = "PostCreation-AddEventButton",
				o = 500,
				a = "PostCreation-CollectionEducationTooltip",
				r = "PostCreation-EventEducationTooltip",
				i = 300,
				d = i,
				l = "PostCreation-AddToCollectionButton"
		},
		"./src/reddit/controls/Checkbox/index.m.less": function(e, t, s) {
			e.exports = {
				Checkbox: "_2nBuBcqz2x0pSPNZfAPkF",
				checkbox: "_2nBuBcqz2x0pSPNZfAPkF",
				mActive: "tLupTGll01Uj0qzkNAjEB",
				mActiveRedditStyle: "_3zu1ZycuCQZ6UeSogWYVka",
				mDisabled: "_2hst4PduZ_m486CeR0rkEm",
				mDisabledRedditStyle: "_2MFHixazvnGgoOmoOzwbIu",
				CheckboxSizing: "_1yJa2uREsO-mxGPj5tbxXy",
				checkboxSizing: "_1yJa2uREsO-mxGPj5tbxXy"
			}
		},
		"./src/reddit/controls/Checkbox/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Checkbox/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var d = e => o.a.createElement("svg", i({
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, e), o.a.createElement("g", {
					transform: "translate(-32.000000, -173.000000)"
				}, o.a.createElement("g", {
					transform: "translate(32.000000, 173.000000)"
				}, o.a.createElement("path", {
					d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M4.5,8.5 C4.22385763,8.5 4,8.72385763 4,9 L4,11 C4,11.2761424 4.22385763,11.5 4.5,11.5 L15.5,11.5 C15.7761424,11.5 16,11.2761424 16,11 L16,9 C16,8.72385763 15.7761424,8.5 15.5,8.5 L4.5,8.5 Z"
				})))),
				l = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				c = s("./src/reddit/controls/Checkbox/index.m.less"),
				m = s.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const b = e => t => {
					const {
						className: s,
						disabled: n,
						redditStyle: r,
						"data-redditstyle": i
					} = t, d = p(t, ["className", "disabled", "redditStyle", "data-redditstyle"]), l = ((e, t, s) => {
						const n = !(!t && !s);
						let o = "";
						return o = e ? n ? m.a.mDisabledRedditStyle : m.a.mDisabled : n ? m.a.mActiveRedditStyle : m.a.mActive
					})(n, r, i);
					return o.a.createElement(e, u({
						className: Object(a.a)(m.a.Checkbox, l, s)
					}, d))
				},
				h = b(l.a),
				g = b(d);
			t.a = e => {
				const t = e.isHalfCheckboxSelected ? g : e.isCheckboxSelected ? h : r.a;
				return o.a.createElement("button", {
					"aria-checked": e.isHalfCheckboxSelected ? "mixed" : e.isCheckboxSelected,
					className: e.className,
					onClick: t => {
						e.toggleCheckbox && (t.stopPropagation(), e.toggleCheckbox())
					},
					disabled: e.disabled
				}, o.a.createElement(t, {
					className: Object(a.a)(m.a.CheckboxSizing, e.className),
					"data-redditstyle": e.redditStyle,
					disabled: e.disabled,
					style: e.checkBoxStyle
				}))
			}
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, s) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = s("./src/reddit/layout/row/Inline/index.tsx"),
				l = s("./src/reddit/controls/CheckboxInput/index.m.less"),
				c = s.n(l);
			t.a = e => o.a.createElement(d.a, {
				"aria-checked": !!e.value,
				"aria-disabled": e.disabled,
				"aria-labelledby": e.name,
				className: Object(a.a)(e.className, c.a.checkboxInput, e.disabled ? c.a.disabled : null),
				onClick: e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0,
				role: "checkbox"
			}, o.a.createElement("input", {
				value: e.value ? e.value.toString() : "",
				type: "hidden"
			}), e.value ? o.a.createElement(i.a, {
				className: c.a.checkboxSelected
			}) : o.a.createElement(r.a, null), e.children)
		},
		"./src/reddit/controls/CheckboxMenuItem/index.m.less": function(e, t, s) {
			e.exports = {
				checkbox: "_2zOuGd5s9dLeXmKJ8TJF9T",
				checkboxSelected: "LevaZhN5EO7Pei7YvAi1W",
				sharedIconStyles: "_19iKCOTFpWIyFwZ0bqQhg",
				checkboxMenuItem: "_2eawLPCtwzvTZhWKtaUgZQ",
				expandRight: "_34Odk7t6y-rCPxPcYJa4Nw",
				postCheckboxMenuItem: "_3LyKu57c-QkPvlFvAgWop5"
			}
		},
		"./src/reddit/controls/CheckboxMenuItem/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = s("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				l = s("./src/reddit/controls/CheckboxMenuItem/index.m.less"),
				c = s.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const p = e => o.a.createElement("div", {
					className: Object(a.a)(c.a.checkboxMenuItem, e.className),
					onClick: e.onClick
				}, o.a.createElement(d.a, {
					className: c.a.expandRight
				}, e.isSelected ? o.a.createElement(i.a, {
					className: c.a.checkboxSelected
				}) : o.a.createElement(r.a, {
					className: c.a.checkbox
				}), e.text)),
				b = e => {
					var {
						className: t
					} = e, s = u(e, ["className"]);
					return o.a.createElement(p, m({
						className: Object(a.a)(c.a.postCheckboxMenuItem, t)
					}, s))
				};
			t.b = p
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return x
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/lodash/throttle.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				l = s("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				c = s("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				m = s("./src/reddit/layout/row/InlineButton/index.tsx"),
				u = s("./src/reddit/controls/Dropdown/index.m.less"),
				p = s.n(u),
				b = s("./src/reddit/controls/Dropdown/row.m.less"),
				h = s.n(b);

			function g() {
				return (g = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var f = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			class x extends r.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = o()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, s = Object(i.a)(h.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? r.a.createElement(d.a, g({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href
					}), e.children && r.a.createElement("span", {
						className: s
					}, e.children), r.a.createElement("span", {
						className: Object(i.a)(h.a.text, e.textClassName)
					}, e.displayText)) : r.a.createElement(m.a, g({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: o()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? r.a.createElement("div", null, e.children) : r.a.createElement("span", {
						className: s
					}, e.children)), e.displayText && r.a.createElement("span", {
						className: Object(i.a)(h.a.text, e.textClassName)
					}, e.displayText), e.showSelectedCheckmark && e.isSelected && r.a.createElement(c.a, {
						className: h.a.checkmark
					}), e.showDropdownTriangle && r.a.createElement(l.a, {
						className: p.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				var {
					className: t
				} = e, s = f(e, ["className"]);
				const n = Object(i.a)(h.a.row, t, {
					[h.a.mIsInteractive]: !s.noHover,
					[h.a.mIsSelected]: s.isSelected,
					[h.a.topics]: s.isTopicsStyle
				});
				return r.a.createElement(x, g({
					className: n
				}, s))
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, s) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				iconStyles: "_2XOVBjNLHjJIznEsn35vs2",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				topics: "kR_ljR-F8vtc-ORj1uipB",
				checkmark: "_3Iua3qlR9JiTwjjk6NKye1",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.m.less": function(e, t, s) {
			e.exports = {
				dropdownMenu: "_1PLoXiZH4WKzHTfmYIt34X",
				selector: "apk_M-7ks6NcaiMN8cotM",
				selectorContent: "Ot99igbaJ5id3P1tw6wow",
				compact: "_1qaMsHCBrTmejbIUPjsRVI",
				caretDown: "_2i4dyr-iTBOmkZ4fL_M70P",
				topics: "qWs3cMcSjquK-OXl-9jH5",
				loadingIcon: "_3WxhmmhQ3cYt1J7mtfcoKG",
				menuItems: "_3ssvFhIB2HAXL261eWf7G0",
				menuOption: "_1Qm1phX3yfiJHnjgi_O_9V"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./node_modules/react-dom/index.js"),
				r = s.n(a),
				i = s("./src/reddit/controls/DropdownSelector/index.m.less"),
				d = s.n(i),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/controls/Dropdown/Row.tsx"),
				m = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				u = s("./src/reddit/icons/svgs/Dropdown/index.tsx");
			const p = e => {
				e.preventDefault()
			};
			class b extends o.a.Component {
				constructor() {
					super(...arguments), this.dropdownButton = o.a.createRef(), this.menuItems = o.a.createRef(), this.state = {
						isOpen: !1
					}, this.handleDocumentClick = e => {
						const t = r.a.findDOMNode(this);
						t && (t.contains(e.target) || this.setState({
							isOpen: !1
						}))
					}, this.onSelectOption = (e, t, s) => {
						const {
							onSelect: n
						} = this.props;
						e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopPropagation(), n(t), s && this.dropdownButton.current && this.dropdownButton.current.focus(), this.setState({
							isOpen: !1
						})
					}, this.onOptionClick = (e, t) => {
						this.onSelectOption(e, t)
					}, this.handleDropdownClick = e => {
						e.preventDefault(), this.props.onOpen && this.props.onOpen(), this.setState({
							isOpen: !this.state.isOpen
						})
					}, this.handleDropdownBlur = e => {
						let t = !1;
						if (e.relatedTarget === this.dropdownButton.current) t = !0;
						else {
							if (!this.menuItems.current) return;
							const s = this.menuItems.current.getElementsByClassName(d.a.menuOption);
							for (let n = 0; n < s.length; n++) e.relatedTarget === s[n] && (t = !0)
						}
						this.setState({
							isOpen: t
						})
					}, this.handleDropdownKeyDown = e => {
						if (!this.state.isOpen && [40, 32, 13].includes(e.keyCode)) return e.preventDefault(), void this.setState({
							isOpen: !0
						}, this.focusOnFirstOption);
						40 === e.keyCode && (e.preventDefault(), this.focusOnFirstOption()), 27 === e.keyCode && this.state.isOpen && (e.stopPropagation(), e.nativeEvent.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), this.setState({
							isOpen: !1
						}))
					}, this.handleOptionKeyDown = (e, t) => {
						if (32 === e.keyCode || 13 === e.keyCode) this.onSelectOption(e, t, !0);
						else if (38 === e.keyCode || 40 === e.keyCode) {
							if (e.preventDefault(), !this.menuItems.current) return;
							const t = this.menuItems.current.getElementsByClassName(d.a.menuOption);
							for (let s = 0; s < t.length; s++) t[s] === e.target && (38 === e.keyCode && s > 0 && t[s - 1].focus(), 40 === e.keyCode && s < t.length - 1 && t[s + 1].focus())
						}
					}
				}
				componentDidMount() {
					document.body.addEventListener("click", this.handleDocumentClick, !1)
				}
				componentWillUnmount() {
					document.body.removeEventListener("click", this.handleDocumentClick, !1)
				}
				focusOnFirstOption() {
					if (!this.menuItems.current) return;
					const e = this.menuItems.current.getElementsByClassName(d.a.menuOption);
					e.length && e[0].focus()
				}
				getDropdownMenuItems() {
					const {
						options: e,
						showSelectedCheckmark: t,
						isTopicsStyle: s
					} = this.props;
					return e.map((e, n) => o.a.createElement(c.b, {
						key: n + e.displayText,
						className: Object(l.a)(d.a.menuOption, {
							[d.a.topics]: s
						}),
						noIcon: !0,
						onKeydown: t => this.handleOptionKeyDown(t, e),
						onMouseDown: t => this.onOptionClick(t, e),
						onBlur: this.handleDropdownBlur,
						showSelectedCheckmark: t,
						isSelected: void 0 !== e.isSelected ? e.isSelected : void 0,
						isTopicsStyle: s
					}, e.displayText))
				}
				render() {
					const {
						buttonClassName: e,
						className: t,
						displayText: s,
						isCompactStyle: n,
						isTopicsStyle: a,
						menuItemsClassName: r,
						name: i,
						isSaving: c
					} = this.props, {
						isOpen: b
					} = this.state;
					return o.a.createElement("div", {
						id: this.props.id,
						className: Object(l.a)(d.a.dropdownMenu, t, {
							[d.a.topics]: a
						})
					}, o.a.createElement("button", {
						onClick: this.handleDropdownClick,
						className: Object(l.a)(e, d.a.selector, {
							[d.a.compact]: n
						}, {
							[d.a.topics]: a
						}),
						name: i,
						role: "menu",
						ref: this.dropdownButton,
						onBlur: this.handleDropdownBlur,
						onKeyDown: this.handleDropdownKeyDown
					}, o.a.createElement("span", {
						className: d.a.selectorContent,
						tabIndex: -1
					}, s), c ? o.a.createElement(m.a, {
						sizePx: 8,
						className: d.a.loadingIcon
					}) : o.a.createElement(u.b, {
						className: d.a.caretDown
					})), o.a.createElement("div", {
						className: Object(l.a)(d.a.menuItems, r, {
							[d.a.topics]: a
						}),
						onMouseDown: p,
						ref: this.menuItems
					}, b && this.getDropdownMenuItems()))
				}
			}
			t.b = b
		},
		"./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less": function(e, t, s) {
			e.exports = {
				wrapper: "_2AfJEqW9tv4b_kolKEuS9K",
				titleRow: "p4QfstubN5cRxd-gy8gFH",
				detailsContainer: "_2V3KEAhexNh-mP3TbrVClC",
				buttonRow: "_1fcbQFwN65ik28DNmWnpX4",
				confirmButton: "zcMEJWBL7q-mYGOPSpjN-"
			}
		},
		"./src/reddit/controls/ErrorText/index.m.less": function(e, t, s) {
			e.exports = {
				wrapper: "_2hGJP-9xfXBXd0wqhBLHhY",
				description: "_3h_9YwxjuOr77VhScPrjCI",
				moreText: "_1Y0BrhDgcSTeSYvmSPYepI"
			}
		},
		"./src/reddit/controls/ErrorText/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return j
			})), s.d(t, "c", (function() {
				return w
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/lodash/uniqueId.js"),
				a = s.n(o),
				r = s("./node_modules/raf/index.js"),
				i = s.n(r),
				d = s("./node_modules/react/index.js"),
				l = s.n(d),
				c = s("./node_modules/react-redux/es/index.js"),
				m = s("./node_modules/reselect/es/index.js"),
				u = s("./src/lib/classNames/index.ts"),
				p = s("./src/reddit/actions/modal.ts"),
				b = s("./src/reddit/selectors/activeModalId.ts"),
				h = s("./src/higherOrderComponents/asModal/index.tsx"),
				g = s("./src/reddit/controls/Button/index.tsx"),
				f = s("./src/reddit/layout/row/Inline/index.tsx"),
				x = s("./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less"),
				E = s.n(x);
			var v = Object(h.a)(e => {
					const {
						children: t,
						title: s
					} = e;
					return l.a.createElement("div", {
						className: E.a.wrapper
					}, l.a.createElement(f.a, {
						className: E.a.titleRow
					}, s), l.a.createElement("div", {
						className: E.a.detailsContainer
					}, t), l.a.createElement(f.a, {
						className: E.a.buttonRow
					}, l.a.createElement(g.f, {
						className: E.a.confirmButton,
						onClick: e.onConfirmed
					}, n.fbt._("Ok", null, {
						hk: "2Giu9U"
					}))))
				}),
				C = s("./src/reddit/controls/ErrorText/index.m.less"),
				_ = s.n(C);
			const k = Object(m.c)({
				activeModalId: b.a
			});
			class O extends l.a.Component {
				constructor(e) {
					super(e), this.spanRef = l.a.createRef(), this.toggleModal = () => {
						this.props.toggleErrorTextModal(this.state.modalId)
					}, this.state = {
						textHasOverflowed: !1,
						modalId: "ErrorTextModal--".concat(a()())
					}
				}
				componentDidMount() {
					this.calcTextDidOverflow()
				}
				componentDidUpdate() {
					this.calcTextDidOverflow()
				}
				calcTextDidOverflow() {
					i()(() => {
						const e = this.spanRef.current;
						if (!e) return;
						const t = e.scrollWidth > e.clientWidth;
						this.setState(e => e.textHasOverflowed !== t ? {
							textHasOverflowed: t
						} : null)
					})
				}
				render() {
					const {
						children: e,
						activeModalId: t,
						className: s,
						errorModalBody: o,
						errorModalTitle: a = n.fbt._("Error", null, {
							hk: "2nPF4G"
						}),
						moreText: r = n.fbt._("More", null, {
							hk: "1bCAQ0"
						})
					} = this.props, {
						modalId: i,
						textHasOverflowed: d
					} = this.state;
					return l.a.createElement("div", {
						className: Object(u.a)(_.a.wrapper, s)
					}, l.a.createElement("span", {
						className: _.a.description,
						ref: this.spanRef
					}, e), d && l.a.createElement("span", {
						className: _.a.moreText,
						onClick: this.toggleModal
					}, r), t === i && l.a.createElement(v, {
						onConfirmed: this.toggleModal,
						title: a
					}, o || e))
				}
			}
			const y = Object(c.b)(k, e => ({
					toggleErrorTextModal: t => e(Object(p.i)(t))
				}))(O),
				j = e => {
					const {
						className: t,
						errorClassName: s,
						errorModalTitle: n,
						fallbackMessage: o,
						messages: a = []
					} = e, r = a.length ? a : o ? [o] : [];
					return r.length ? l.a.createElement("div", {
						className: t
					}, r.map((e, t) => l.a.createElement(y, {
						className: s,
						errorModalTitle: n,
						key: t
					}, e))) : null
				},
				w = e => l.a.createElement(j, {
					fallbackMessage: n.fbt._("Something went wrong", null, {
						hk: "Cw1BT"
					}),
					messages: e
				});
			t.b = y
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/flow.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-dnd/lib/index.js"),
				d = s("./node_modules/react-dnd-html5-backend/lib/index.js"),
				l = s("./src/reddit/helpers/dragDropContext/index.ts");
			const c = d.NativeTypes.FILE,
				m = o()(Object(i.DropTarget)(c, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const s = t.getItem();
						s.files && e.onDrop(s.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), l.a);
			class u extends r.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(r.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = m(u)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, s) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "c", (function() {
				return f
			})), s.d(t, "d", (function() {
				return v
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/controls/ErrorText/index.tsx"),
				d = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				l = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				c = s("./src/reddit/controls/FormFields/index.m.less"),
				m = s.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			const b = r.a.input("input", m.a),
				h = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				g = e => {
					const {
						label: t,
						children: s,
						inputRef: n,
						className: r
					} = e, i = p(e, ["label", "children", "inputRef", "className"]), d = void 0 !== e.value && "" !== e.value;
					return o.a.createElement("div", {
						className: Object(a.a)(m.a.inputWrapper, r, {
							[m.a.mIsInvalid]: e.isInvalid
						}),
						onClick: h
					}, o.a.createElement(b, u({
						"aria-invalid": e.isInvalid,
						innerRef: n
					}, i)), e.label && o.a.createElement("label", {
						className: Object(a.a)(m.a.label, {
							[m.a.mHasValue]: d
						})
					}, e.label), e.children)
				},
				f = e => {
					const {
						label: t,
						children: s,
						inputRef: n,
						className: r,
						redditStyle: i
					} = e, d = p(e, ["label", "children", "inputRef", "className", "redditStyle"]), l = void 0 !== e.value && "" !== e.value;
					return o.a.createElement("div", {
						className: Object(a.a)(m.a.inputMovingLabelWrapper, r, {
							[m.a.mIsRedditStyle]: i
						}),
						onClick: h
					}, o.a.createElement(b, u({
						innerRef: n
					}, d)), e.label && o.a.createElement("label", {
						className: Object(a.a)(m.a.label, {
							[m.a.mHasValue]: l
						})
					}, e.label), e.children)
				},
				x = e => o.a.createElement("div", {
					className: Object(a.a)(m.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", o.a.createElement(d.a, {
					className: m.a.plus
				}));
			var E;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(E || (E = {}));
			class v extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: E.ADD
						})
					}, this.updateValue = (e, t) => {
						const s = this.props.values.slice();
						s[t] = e.target.value, this.props.onChange(s)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							s = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: E.REMOVE,
							value: s,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: s,
						placeholder: n,
						errors: a = []
					} = this.props;
					return e.map((e, r) => o.a.createElement(g, {
						inputRef: e => this.setInputRef(e, r),
						isInvalid: !!a[r],
						disabled: t,
						type: "text",
						label: s,
						onChange: e => this.updateValue(e, r),
						placeholder: n,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, o.a.createElement("div", {
						className: m.a.trashContainer,
						onClick: () => this.removeValue(r)
					}, o.a.createElement(l.b, {
						className: m.a.trash
					})), !!a[r] && o.a.createElement(i.b, {
						className: m.a.errorText
					}, a[r])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: s,
						maxLength: n,
						addValueText: r,
						disabled: i
					} = this.props;
					this.focusedInput = null;
					const d = !(!!n && s.length >= n) && !i;
					return o.a.createElement("div", {
						className: Object(a.a)(m.a.multiInputWrapper, e)
					}, t && d && o.a.createElement(x, {
						onClick: this.addValue,
						text: r
					}), this.renderFields(), !t && d && o.a.createElement(x, {
						onClick: this.addValue,
						text: r
					}))
				}
			}
		},
		"./src/reddit/controls/ImageDisplay/index.m.less": function(e, t, s) {
			e.exports = {
				imageDisplay: "_1OSym2TYADlQNpSDWNxtjB"
			}
		},
		"./src/reddit/controls/ImageDisplay/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/controls/ImageDisplay/index.m.less"),
				i = s.n(r);
			t.a = e => {
				let {
					backgroundImage: t,
					children: s,
					className: n
				} = e;
				return o.a.createElement("div", {
					className: Object(a.a)(i.a.imageDisplay, n),
					style: {
						backgroundImage: "url('".concat(t, "')")
					},
					children: s
				})
			}
		},
		"./src/reddit/controls/ImageInput/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			class a extends o.a.Component {
				constructor(e) {
					super(e), this.onFileInput = e => {
						const t = e.currentTarget.files,
							s = this.props.multiple ? [...t] : t[0];
						this.props.onChange(s), this.setState(() => ({
							value: s
						}))
					}, this.state = {
						value: e.value || ""
					}
				}
				static getDerivedStateFromProps(e, t) {
					return {
						value: t.value || e.value || ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = "string" == typeof t.value ? t.value : "", n = "object" == typeof t.value ? t.value : null, a = s || n;
					return o.a.createElement("div", {
						className: e.className
					}, s && o.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						readOnly: !0,
						type: "text",
						value: s,
						tabIndex: e.tabIndex
					}), !a && o.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						type: "file",
						onChange: this.onFileInput,
						accept: "image/x-png,image/jpeg",
						multiple: e.multiple || !1,
						tabIndex: e.tabIndex
					}))
				}
			}
		},
		"./src/reddit/controls/Input/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/controls/Input/index.m.less"),
				a = s.n(o);
			t.a = n.a.input("input", a.a)
		},
		"./src/reddit/controls/MetaData/index.m.less": function(e, t, s) {
			e.exports = {
				metaText: "_2ETuFsVzMBxiHia6HfJCTQ"
			}
		},
		"./src/reddit/controls/MetaData/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "b", (function() {
				return p
			})), s.d(t, "d", (function() {
				return b
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/lib/prettyPrintNumber/index.ts"),
				d = (s("./src/lib/timeAgo/index.ts"), s("./src/reddit/controls/MetaData/index.m.less")),
				l = s.n(d),
				c = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
					}
					return s
				};
			const m = r.a.span("metaText", l.a),
				u = e => a.a.createElement(m, e, " · "),
				p = e => {
					var {
						isScoreHidden: t,
						score: s,
						useUpvotes: o
					} = e, r = c(e, ["isScoreHidden", "score", "useUpvotes"]);
					const d = Object(i.b)(s),
						l = n.fbt._({
							"*": "{number} upvotes",
							_1: "1 upvote"
						}, [n.fbt._plural(s, "number", d)], {
							hk: "2L3T21"
						}),
						u = t ? n.fbt._("Score hidden", null, {
							hk: "SDk6B"
						}) : o ? l : n.fbt._({
							"*": "{number} points",
							_1: "1 point"
						}, [n.fbt._plural(s, "number", d)], {
							hk: "gf67v"
						});
					return a.a.createElement(m, r, u)
				},
				b = e => a.a.createElement(m, null, n.fbt._({
					"*": "{number} comments",
					_1: "1 comment"
				}, [n.fbt._plural(e, "number", Object(i.b)(e))], {
					hk: "3bVMk9"
				}))
		},
		"./src/reddit/controls/Select/index.m.less": function(e, t, s) {
			e.exports = {
				Wrapper: "DuuuuIp9EubfvJyrdxytL",
				wrapper: "DuuuuIp9EubfvJyrdxytL",
				Caret: "_8fOXBcWxu_c3tlrAKMR3R",
				caret: "_8fOXBcWxu_c3tlrAKMR3R",
				Inner: "_3-_epznhOfLDNH3-plYM6l",
				inner: "_3-_epznhOfLDNH3-plYM6l",
				redditStyle: "_2PDExzXmSTOdxzNjRB1Pww"
			}
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/helpers/dragDropContext/index.ts"),
				r = s("./node_modules/lodash/flow.js"),
				i = s.n(r),
				d = s("./node_modules/react-dnd/lib/index.js");
			class l extends o.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? i()(e.connectDropTarget, e.connectDragSource)(o.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var c = i()(Object(d.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const s = t.getDropResult();
						e.onDrop(e.id, s.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(d.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const s = t.getItem();
					return e.id !== s.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(l);
			class m extends o.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(s => {
							const n = s.values.slice(),
								o = n.indexOf(e),
								a = n.splice(o, 1)[0];
							let r = n.indexOf(t);
							return o <= r && (r += 1), n.splice(r, 0, a), this.props.onDrop(e, t, n), {
								values: n
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: s,
						render: n
					} = this.props;
					return o.a.createElement("div", {
						className: e
					}, this.state.values.map((e, a) => o.a.createElement(c, {
						id: e,
						key: t && t(e),
						index: a,
						render: n,
						onDrop: this.onDrop,
						onClick: s
					})))
				}
			}
			t.a = Object(a.a)(m)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, s) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/controls/InternalLink/index.tsx"),
				a = s("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				r = s.n(a);
			t.a = n.a.wrapped(o.a, "unstyledInternalLink", r.a)
		},
		"./src/reddit/endpoints/economics/uploadedAssets.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "d", (function() {
				return l
			}));
			var n, o, a = s("./src/config.ts"),
				r = s("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t, s, n) {
				const o = "assetType=".concat(s, "&assetStatus=").concat(n);
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(a.a.metaUrl, "/modtools/").concat(t, "/assets?").concat(o)
				})
			}

			function d(e, t, s) {
				const o = new FormData;
				return o.append("assetType", s.assetType), o.append("assetName", s.assetName), o.append("upfile", s.imageFile), s.assetType === n.Badge && (o.append("badgeColor", s.badgeColor || ""), o.append("badgeDescription", s.badgeDescription || "")), Object(r.a)(e, {
					endpoint: "".concat(a.a.metaUrl, "/modtools/").concat(t, "/assets"),
					method: "post",
					type: null,
					data: o
				})
			}

			function l(e, t, s, n, o) {
				return Object(r.a)(e, {
					endpoint: "".concat(a.a.metaUrl, "/modtools/").concat(t, "/assets/").concat(s, "s/").concat(n),
					method: "patch",
					data: o
				})
			}! function(e) {
				e.Badge = "badge", e.Emote = "emote"
			}(n || (n = {})),
			function(e) {
				e.Uploaded = "uploaded", e.Approved = "approved", e.Rejected = "rejected"
			}(o || (o = {}))
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "b", (function() {
				return l
			}));
			var n, o = s("./src/config.ts"),
				a = s("./src/reddit/endpoints/governance/requester.ts");

			function r(e) {
				switch (e) {
					case n.Ethereum:
					case n.EthTraderEthereum:
						return "Ethereum Main Network";
					case n.Rinkeby:
					case n.EthTraderRinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}
			async function i(e, t, s) {
				return Object(a.a)(e, {
					method: "post",
					endpoint: "".concat(o.a.metaUrl, "/crypto/").concat(t, "/challenges"),
					data: {
						challengeType: "registration-challenge-EIP712",
						address: s
					}
				})
			}
			async function d(e, t, s) {
				return await Object(a.a)(e, {
					method: "post",
					endpoint: "".concat(o.a.metaUrl, "/crypto/").concat(t, "/registrations"),
					data: s
				})
			}
			async function l(e, t, s) {
				return await Object(a.a)(e, {
					method: "delete",
					endpoint: "".concat(o.a.metaUrl, "/crypto/").concat(t, "/registrations/").concat(s)
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.EthTraderEthereum = "ethereum:1:ethtrader", e.EthTraderRinkeby = "ethereum:4:ethtrader", e.Stellar = "stellar"
			}(n || (n = {}))
		},
		"./src/reddit/endpoints/page/subredditWiki.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/lib/makeGqlRequest/index.ts"),
				o = s("./src/graphql/operations/SubredditWiki.json");
			const a = (e, t) => Object(n.a)(e, Object.assign({}, o, {
				variables: t
			}))
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return l
			})), s.d(t, "f", (function() {
				return m
			})), s.d(t, "d", (function() {
				return u
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "e", (function() {
				return h
			})), s.d(t, "a", (function() {
				return x
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/graphql/operations/CreateScheduledPost.json"),
				o = s("./src/graphql/operations/SubredditScheduledPosts.json"),
				a = s("./src/lib/makeGqlRequest/index.ts"),
				r = s("./src/reddit/helpers/flair.ts"),
				i = s("./src/reddit/models/PostCreationForm/index.ts"),
				d = s("./src/reddit/models/ScheduledPost/index.ts");
			const l = (e, t) => Object(a.a)(e, Object.assign({}, o, {
					variables: Object.assign({}, t, {
						includeRecurring: !(!t.includeRecurring || !t.includeRecurring.recurringFirst),
						includeStandalone: !(!t.includeStandalone || !t.includeStandalone.standaloneFirst),
						recurringAfter: t.includeRecurring ? t.includeRecurring.recurringAfter : void 0,
						recurringFirst: t.includeRecurring ? t.includeRecurring.recurringFirst : void 0,
						standaloneAfter: t.includeStandalone ? t.includeStandalone.standaloneAfter : void 0,
						standaloneFirst: t.includeStandalone ? t.includeStandalone.standaloneFirst : void 0
					})
				})),
				c = (e, t) => {
					if (!e.ok || !e.body) return !1;
					const s = e.body;
					return !!(s.data && s.data.subredditInfoById && s.data.subredditInfoById.scheduledPosts && s.data.subredditInfoById.scheduledPosts[t] && s.data.subredditInfoById.scheduledPosts[t].edges)
				},
				m = (e, t) => !(!e.ok || !e.body) && (!(t.includeStandalone && !(e => c(e, d.f.standalonePosts))(e)) && !(t.includeRecurring && !(e => c(e, d.f.recurringPosts))(e))),
				u = (e, t, s) => Object.assign({
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNSFW,
					title: e.title,
					isOriginalContent: e.isOC,
					flair: e.flair ? {
						id: e.flair.templateId,
						text: Object(r.g)(e.flair)
					} : {},
					subredditId: s,
					isSendReplies: e.sendReplies
				}, p(t), f(e)),
				p = e => ({
					scheduling: {
						publishAt: e.submitDate,
						clientTimezone: e.timezoneName,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					}
				}),
				b = e => ({
					scheduling: Object.keys(e).length > 0 ? {
						clientTimezone: e.timezoneName || void 0,
						publishAt: e.submitDate || void 0,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					} : void 0
				}),
				h = e => {
					const t = u(e.submission, e.schedule, e.subredditId);
					return Object.assign({
						id: e.scheduledPostId
					}, t, {
						flair: Object.keys(t.flair || {}).length ? Object.assign({}, t.flair) : {
							id: "",
							text: ""
						}
					})
				},
				g = e => /^https?:\/\//i.test(e) ? e : "http://".concat(e),
				f = e => {
					switch (e.kind) {
						case i.o.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case i.o.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case i.o.LINK:
							return {
								content: {}, link: {
									url: g(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				x = (e, t) => Object(a.a)(e, Object.assign({}, n, {
					variables: {
						input: t
					}
				}))
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/graphql/operations/UpdateScheduledPost.json"),
				o = s("./src/lib/makeGqlRequest/index.ts");
			const a = (e, t) => Object(o.a)(e, Object.assign({}, n, {
				variables: {
					input: t
				}
			}))
		},
		"./src/reddit/endpoints/subredditModeration/moderationLog.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/graphql/operations/AllModerators.json"),
				o = s("./src/graphql/operations/FetchModerationLogActions.json"),
				a = s("./src/lib/makeGqlRequest/index.ts");
			const r = (e, t, s) => Object(a.a)(e, Object.assign({}, o, {
					variables: Object.assign({
						subredditName: t
					}, s)
				})),
				i = (e, t) => Object(a.a)(e, Object.assign({}, n, {
					variables: {
						subredditName: t
					}
				}))
		},
		"./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/reddit/models/Subreddit/index.ts");
			const o = new Set(["goins", "gold_testing", "inthesoulstone", "lounge", "lssgoldnormal", "maymodsguide1", "maymodsguide2", "megalounge", "pan2", "pan3", "venkman_bookclub", "whatssnoo", "translation_piglatin", "translation_pirate", "translation_initials", "translation_german", "translation_british"]),
				a = new Set([n.d.Private]),
				r = e => !(!e || !e.name) && (!!o.has(e.name.toLowerCase()) || !e.isNSFW && !e.isQuarantined && !a.has(e.type))
		},
		"./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = new Set(["t5_q0gj4", "t5_z5gli", "t5_22cerq", "t5_3j0kj"]),
				o = e => n.has(e)
		},
		"./src/reddit/helpers/brandSafety/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/reddit/models/WhitelistStatus/index.ts");
			const o = (e, t) => {
				const s = e.some(e => e.isNSFW),
					o = t.some(e => e.wls === n.a.NO_ADS);
				return !s && !o
			}
		},
		"./src/reddit/helpers/canAccessModerationPage/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts");
			t.a = (e, t, s, o, a, r) => {
				switch (e) {
					case n.Pb.Awards:
						return !!t && !!s;
					case n.Pb.SubredditRules:
					case n.Pb.Moderators:
						return !0;
					case n.Pb.Modlog:
						return !!t;
					case n.Pb.Muted:
						return !!(t && t.access && t.mail);
					case n.Pb.Banned:
					case n.Pb.Contributors:
						return !(!t || !t.access);
					case n.Pb.Flair:
					case n.Pb.PostFlair:
					case n.Pb.UserFlair:
						return !(!t || !t.flair);
					case n.Pb.CommunitySettings:
						return !(!t || !t.config);
					case n.Pb.Modqueue:
					case n.Pb.Reports:
					case n.Pb.Edited:
					case n.Pb.Spam:
					case n.Pb.Unmoderated:
					case n.Pb.PostRequirements:
					case n.Pb.Removal:
						return !(!t || !t.posts);
					case n.Pb.ChatSettings:
						return !(!t || !(t.chatConfig || t.chatOperator || t.all));
					case n.Pb.Badges:
					case n.Pb.Emojis:
						return !!t;
					case n.Pb.Emotes:
						return !(!t || !t.config);
					case n.Pb.Streaming:
						return !!(t && t.all && r);
					case n.Pb.Wiki:
					case n.Pb.WikiBanned:
					case n.Pb.WikiContributors:
						return !(!t || !t.wiki);
					case n.Pb.Traffic:
						return a || !!t;
					case n.Pb.EventPostContent:
					case n.Pb.ScheduledPostContent:
						return !!o;
					default:
						return !1
				}
			}
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react-dnd/lib/index.js"),
				o = s("./node_modules/react-dnd-html5-backend/lib/index.js"),
				a = s.n(o);
			t.a = Object(n.DragDropContext)(a.a)
		},
		"./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/reddit/helpers/graphql/helpers.ts");
			const o = e => {
					const t = [];
					for (const {
							node: s
						} of e.edges) {
						const {
							action: e,
							actionNotes: o,
							createdAt: a,
							details: r,
							id: i,
							moderator: d,
							subredditName: l,
							target: c
						} = s, m = {
							action: e,
							actionNotes: o,
							createdAt: Object(n.d)(a),
							details: r,
							id: i,
							moderator: d,
							subredditName: l,
							target: c
						};
						t.push(m)
					}
					return t
				},
				a = e => {
					const t = [];
					for (const {
							node: s
						} of e.edges) {
						const {
							id: e,
							name: n
						} = s, o = {
							id: e,
							name: n
						};
						t.push(o)
					}
					return t
				}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return a
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "d", (function() {
				return h
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			const n = e => e.subredditInfoById.scheduledPosts.recurringPosts ? {
					recurringPosts: {
						models: p(e.subredditInfoById.scheduledPosts.recurringPosts.edges),
						pageInfo: Object.assign({}, e.subredditInfoById.scheduledPosts.recurringPosts.pageInfo)
					},
					recurringPostsIds: e.subredditInfoById.scheduledPosts.recurringPosts.edges.map(e => e.node.id)
				} : {},
				o = e => e.subredditInfoById.scheduledPosts.standalonePosts ? {
					standalonePosts: {
						models: m(e.subredditInfoById.scheduledPosts.standalonePosts.edges),
						pageInfo: Object.assign({}, e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo)
					},
					standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
				} : {},
				a = e => Object.assign({}, e, {
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: Object.assign({}, n(e), o(e))
					}
				}),
				r = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.recurringPosts && !!e.subredditInfoById.scheduledPosts.recurringPostsIds,
				i = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.standalonePosts && !!e.subredditInfoById.scheduledPosts.standalonePostsIds,
				d = e => r(e) && i(e),
				l = e => !r(e) && i(e),
				c = e => r(e) && !i(e),
				m = e => e.map(e => u(e.node)),
				u = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					subreddit: Object.assign({}, e.subreddit),
					owner: Object.assign({}, e.owner),
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt.split(".")[0],
					state: e.state,
					flair: e.flair ? Object.assign({}, e.flair) : void 0,
					isSticky: "NONE" !== e.sticky && !!e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				}),
				p = e => e.map(e => b(e.node)),
				b = e => Object.assign({}, u(e), {
					frequency: e.frequency,
					byMonthDays: e.byMonthDays || [],
					byWeekDays: e.byWeekDays || [],
					interval: e.interval || 1
				}),
				h = e => (e => !!e.frequency && !!e.interval)(e) ? b(e) : u(e)
		},
		"./src/reddit/helpers/hasModFlairPermissions/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => !!e && !!e.flair
		},
		"./src/reddit/helpers/hasModFullPermissions/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => !!e && !!e.all
		},
		"./src/reddit/helpers/hasModPostPermissions/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => !!e && !!e.posts
		},
		"./src/reddit/helpers/isValidUsername/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/helpers/normalizeUsername/index.tsx");
			t.a = e => {
				const t = Object(n.a)(e.trim());
				return t.length > 2 && t.length <= 20
			}
		},
		"./src/reddit/helpers/postComponentForLayout/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return g
			})), s.d(t, "c", (function() {
				return v
			})), s.d(t, "b", (function() {
				return C
			}));
			var n = s("./node_modules/@loadable/component/dist/loadable.esm.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./src/lib/isUrl/index.ts"),
				i = s("./src/lib/logs/console.ts"),
				d = s("./src/reddit/constants/postLayout.ts"),
				l = s("./src/reddit/models/Media/index.ts");
			const c = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-BlankPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => s.e("reddit-components-BlankPost").then(s.bind(null, "./src/reddit/components/BlankPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/BlankPost/index.tsx"
					}
				}),
				m = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-ClassicPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("vendors~Poll~PostCreation~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-~1a75b64b"), s.e("CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~InFeedChaining~~9f4422c2"), s.e("ChatMessageInput~ChatPost~CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceRelease~be557eac"), s.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~InFeedChaining~ModerationPages~Poll~~089203bf"), s.e("ChatPost~CollectionCommentsPage~CommentsPage~ModQueuePages~ModerationPages~Poll~ProfileComments~Prof~8c7a65fc"), s.e("CollectionCommentsPage~CommentsPage~ModerationPages~Poll~PostDraft~ProfileComments~ProfileOverview~P~0040a89a"), s.e("Poll~ProfileComments~ProfilePrivate~RpanListingUnit~SearchResults~reddit-components-ClassicPost~redd~f8abff80"), s.e("Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddi~90fdacc3"), s.e("reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddit-compo~0e38b796"), s.e("reddit-components-ClassicPost")]).then(s.bind(null, "./src/reddit/components/ClassicPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ClassicPost/index.tsx"
					}
				}),
				u = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-CompactPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("vendors~Poll~PostCreation~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-~1a75b64b"), s.e("CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~InFeedChaining~~9f4422c2"), s.e("ChatMessageInput~ChatPost~CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceRelease~be557eac"), s.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~InFeedChaining~ModerationPages~Poll~~089203bf"), s.e("ChatPost~CollectionCommentsPage~CommentsPage~ModQueuePages~ModerationPages~Poll~ProfileComments~Prof~8c7a65fc"), s.e("CollectionCommentsPage~CommentsPage~ModerationPages~Poll~PostDraft~ProfileComments~ProfileOverview~P~0040a89a"), s.e("Poll~ProfileComments~ProfilePrivate~RpanListingUnit~SearchResults~reddit-components-ClassicPost~redd~f8abff80"), s.e("Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddi~90fdacc3"), s.e("reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddit-compo~0e38b796"), s.e("reddit-components-CompactPost")]).then(s.bind(null, "./src/reddit/components/CompactPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/CompactPost/index.tsx"
					}
				}),
				p = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-LargePost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("vendors~Poll~PostCreation~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-~1a75b64b"), s.e("CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~InFeedChaining~~9f4422c2"), s.e("ChatMessageInput~ChatPost~CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceRelease~be557eac"), s.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~InFeedChaining~ModerationPages~Poll~~089203bf"), s.e("ChatPost~CollectionCommentsPage~CommentsPage~ModQueuePages~ModerationPages~Poll~ProfileComments~Prof~8c7a65fc"), s.e("CollectionCommentsPage~CommentsPage~ModerationPages~Poll~PostDraft~ProfileComments~ProfileOverview~P~0040a89a"), s.e("Poll~ProfileComments~ProfilePrivate~RpanListingUnit~SearchResults~reddit-components-ClassicPost~redd~f8abff80"), s.e("Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddi~90fdacc3"), s.e("reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddit-compo~0e38b796"), s.e("reddit-components-LargePost")]).then(s.bind(null, "./src/reddit/components/LargePost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/LargePost/index.tsx"
					}
				}),
				b = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-MediumPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("vendors~Poll~PostCreation~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-~1a75b64b"), s.e("ChatPost~CollectionCommentsPage~CommentsPage~ModQueuePages~ModerationPages~Poll~ProfileComments~Prof~8c7a65fc"), s.e("CollectionCommentsPage~CommentsPage~ModerationPages~Poll~PostDraft~ProfileComments~ProfileOverview~P~0040a89a"), s.e("Poll~ProfileComments~ProfilePrivate~RpanListingUnit~SearchResults~reddit-components-ClassicPost~redd~f8abff80"), s.e("Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddi~90fdacc3"), s.e("reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~reddit-compo~0e38b796"), s.e("reddit-components-MediumPost")]).then(s.bind(null, "./src/reddit/components/MediumPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/MediumPost/index.tsx"
					}
				}),
				h = {
					[d.g.Large]: p,
					[d.g.Medium]: b,
					[d.g.Classic]: m,
					[d.g.Compact]: u
				},
				g = e => a.a.createElement(c, e),
				f = ["https://www.mcdonalds.com", "https://d2n94wep25xhn0.cloudfront.net", "https://www.dyson.com", "https://dyson.com"],
				x = e => e.source && e.source.url && e.isSponsored && f.some(t => e.source.url.startsWith(t)),
				E = e => !e.media || e.media.type === l.n.EMBED && !(l.b.has(e.media.provider) || x(e)),
				v = (e, t) => {
					if (e.isBlank) return 0;
					switch (t) {
						case d.g.Medium:
							return 188;
						case d.g.Classic:
							return 96;
						case d.g.Compact:
							return 32;
						default:
							return 200
					}
				};

			function C(e) {
				let {
					isCrosspost: t,
					isFirstPost: s,
					layout: n,
					post: o
				} = e;
				if (o.isBlank) return g;
				const a = !o.media && !!o.source && Object(r.a)(o.source.url),
					l = t && a;
				n === d.g.Large && E(o) && !l && (n = d.g.Medium);
				const c = h[n];
				return void 0 === c ? (Object(i.a)(void 0, "Could not find component for layout ".concat(n, ".")), g) : s && o.isSponsored && n === d.g.Large ? b : c
			}
		},
		"./src/reddit/helpers/readOnlyMode/index.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})), s.d(t, "b", (function() {
					return o
				})), s.d(t, "c", (function() {
					return a
				})),
				function(e) {
					e.editable = "editable", e.focusableReadOnly = "focusablereadonly", e.readOnly = "readonly"
				}(n || (n = {}));
			const o = e => a(e) || e === n.focusableReadOnly,
				a = e => e === n.readOnly
		},
		"./src/reddit/helpers/styles/mixins/index.m.less": function(e, t, s) {
			e.exports = {
				baseLargeAndMediumPostStyles: "_2lHXa-mLMsRfm1Q5JxgU4r",
				basePostStyles: "REwsaLIz5u3DhM7zbbzIU",
				classicPostStyles: "bE7JgM2ex7W3aF3zci5bm",
				compactPostStyles: "FeLWdhOO-cVXowAo3Rndk",
				largeAndMediumPostStyles: "_3Qkp11fjcAw9I9wtLo8frE",
				baseClassicAndCompactPostStyles: "_2yN8L-c8UBoKxHn0-vg_dS",
				baseSubredditStyles: "_2zRMh6o0BucltCL6o64pa4",
				classicAndCompactActiveStyles: "_1Accc3h2AW0sB8E4CcEz2n",
				mIsActive: "_1LmKpEAguLZV4jQMgQSFVL",
				classicAndCompactPlaceholderStyles: "_3joKifdh6j3tG_vsgFS85R",
				mUseRedditTheme: "_1nQXomgzQ2rnBsRU2iZ00l",
				largeAndMediumActiveStyles: "_1qftyZQ2bhqP62lbPjoGAh"
			}
		},
		"./src/reddit/helpers/styles/mixins/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "b", (function() {
				return h
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "d", (function() {
				return f
			}));
			var n = s("./node_modules/polished/dist/polished.es.js"),
				o = s("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				a = s("./src/reddit/helpers/styles/smartTextColor.ts"),
				r = s("./src/reddit/models/NewStructuredStyles/index.ts"),
				i = s("./src/reddit/models/Theme/index.ts"),
				d = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				l = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				c = s.n(l);
			const m = {},
				u = e => Object(i.g)(Object(d.a)(e).post, Object(d.a)(e).backgroundImage, Object(d.a)(e).backgroundImagePosition),
				p = (e, t) => {
					if (e) {
						if (e.postBackgroundImage) return {
							background: Object(i.g)(e.postBackgroundColor || Object(d.a)(t).post, e.postBackgroundImage, Object(d.a)(t).backgroundImagePosition)
						};
						if (e.postBackgroundColor) return {
							background: Object(i.g)(e.postBackgroundColor, null, null)
						}
					}
					return {
						background: u(t)
					}
				},
				b = e => Object(n.l)(.2, e),
				h = e => e && e.postBackgroundColor ? {
					backgroundColor: b(e.postBackgroundColor)
				} : m,
				g = e => e.isActive ? c.a.mIsActive : void 0,
				f = e => {
					const t = Object(a.a)(Object(o.a)(e), r.a.actionIcon, r.b.actionIcon);
					return {
						color: t,
						cursor: "pointer",
						fill: t
					}
				}
		},
		"./src/reddit/helpers/trackers/communityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return d
			})), s.d(t, "f", (function() {
				return l
			})), s.d(t, "b", (function() {
				return c
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			}));
			var n = s("./src/reddit/models/Gold/Award.ts"),
				o = s("./src/reddit/selectors/telemetry.ts"),
				a = s("./src/reddit/helpers/correlationIdTracker.ts");
			const r = e => Object.assign({}, o.defaults(e), {
					screen: o.screen(e),
					subreddit: o.subreddit(e),
					userSubreddit: o.userSubreddit(e)
				}),
				i = e => ({
					awardId: e.id,
					awardName: e.name,
					isModAward: e.awardType === n.f.Moderator,
					numberCoins: e.coinPrice,
					numberMonths: Math.floor((e.daysOfPremium || 0) / 30),
					numberCoinsToRecipient: e.coinReward || 0,
					numberCoinsToCommunity: e.subredditCoinReward || 0
				}),
				d = () => e => Object.assign({}, r(e), {
					source: "awards",
					action: "click",
					correlationId: Object(a.c)(a.a.AwardCreationFlow),
					noun: "create"
				}),
				l = e => t => Object.assign({}, r(t), {
					source: "awards",
					action: "click",
					correlationId: Object(a.c)(a.a.AwardDeletionFlow),
					noun: "delete",
					goldPurchase: e ? i(e) : null,
					media: e ? {
						url: e.icon.url
					} : null
				}),
				c = (e, t, s) => n => Object.assign({}, r(n), {
					source: "create_award",
					action: e,
					correlationId: Object(a.c)(a.a.AwardCreationFlow),
					noun: t,
					goldPurchase: s
				}),
				m = (e, t, s, n) => o => Object.assign({}, r(o), {
					source: "create_award",
					action: "upload",
					correlationId: Object(a.c)(a.a.AwardCreationFlow),
					noun: "image",
					actionInfo: n ? {
						reason: n
					} : {
						success: !0
					},
					media: t ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						uploadDuration: s,
						url: e,
						width: t.width
					} : null
				}),
				u = (e, t, s) => n => Object.assign({}, r(n), {
					source: "create_award",
					action: "click",
					correlationId: Object(a.c)(a.a.AwardCreationFlow),
					noun: "create",
					media: t && e ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						url: e,
						width: t.width
					} : null,
					goldPurchase: s ? i(s) : null
				}),
				p = (e, t, s) => n => Object.assign({}, r(n), {
					source: "create_award",
					action: e,
					correlationId: Object(a.c)(a.a.AwardCreationFlow),
					noun: t,
					goldPurchase: s ? i(s) : null
				})
		},
		"./src/reddit/helpers/trackers/communitySettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "b", (function() {
				return h
			}));
			var n = s("./node_modules/lodash/snakeCase.js"),
				o = s.n(n),
				a = s("./src/lib/constants/index.ts"),
				r = s("./src/reddit/selectors/telemetry.ts");
			const i = {
					contentOptions: "link_type",
					contentVisible: "allow_top",
					subredditType: "type",
					welcomeMessageText: "welcome_message"
				},
				d = {
					allowChatPostCreation: a.Qb.Posts,
					allowDiscovery: a.Qb.Safety,
					allowGalleries: a.Qb.Posts,
					allowImages: a.Qb.Posts,
					allowPolls: a.Qb.Posts,
					allowPostCrossposts: a.Qb.Posts,
					collapseDeletedComments: a.Qb.Posts,
					commentScoreHideMins: a.Qb.Posts,
					contentOptions: a.Qb.Posts,
					contentVisible: a.Qb.Safety,
					crowdControlChatLevel: a.Qb.Safety,
					crowdControlLevel: a.Qb.Safety,
					crowdControlMode: a.Qb.Safety,
					disableContributorRequests: a.Qb.Community,
					excludeBannedModqueue: a.Qb.Safety,
					over18: a.Qb.Community,
					publicDescription: a.Qb.Community,
					restrictCommenting: a.Qb.Community,
					restrictPosting: a.Qb.Community,
					spamComments: a.Qb.Posts,
					spamLinks: a.Qb.Posts,
					spamSelfposts: a.Qb.Posts,
					spoilersEnabled: a.Qb.Posts,
					subredditType: a.Qb.Community,
					suggestedCommentSort: a.Qb.Posts,
					toxicityThresholdChatLevel: a.Qb.Safety,
					welcomeMessageEnabled: a.Qb.Community,
					welcomeMessageText: a.Qb.Community,
					wikiEditAge: a.Qb.Wikis,
					wikiEditKarma: a.Qb.Wikis,
					wikimode: a.Qb.Wikis
				},
				l = {
					[a.Qb.Community]: "community_settings_details",
					[a.Qb.Safety]: "community_settings_safety",
					[a.Qb.Posts]: "community_settings_content",
					[a.Qb.Wikis]: "community_settings_wiki"
				},
				c = e => i[e] || o()(e),
				m = e => {
					const t = d[e];
					return t && l[t] || "community_settings"
				},
				u = (e, t, s) => n => Object.assign({
					source: m(e),
					action: "click",
					noun: c(e),
					setting: {
						value: String(t),
						oldValue: String(s)
					},
					subreddit: r.subreddit(n)
				}, r.defaults(n)),
				p = (e, t, s) => n => Object.assign({
					source: m(e),
					action: "save",
					noun: c(e),
					setting: {
						value: String(t),
						oldValue: String(s)
					},
					subreddit: r.subreddit(n)
				}, r.defaults(n)),
				b = e => t => Object.assign({
					source: "community_settings",
					action: "click",
					noun: l[e]
				}, r.defaults(t)),
				h = e => t => Object.assign({
					source: l[e],
					action: "click",
					noun: "r2_community_settings"
				}, r.defaults(t))
		},
		"./src/reddit/helpers/trackers/modHub.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: n.screen(e),
					subreddit: n.subreddit(e),
					userSubreddit: n.userSubreddit(e)
				}),
				a = e => t => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: e
				}, o(t)),
				r = () => e => Object.assign({
					source: "breadcrumb",
					action: "click",
					noun: "subreddit"
				}, o(e)),
				i = () => e => Object.assign({
					source: "id_card",
					action: "click",
					noun: "mod_hub_nav"
				}, o(e))
		},
		"./src/reddit/helpers/trackers/moderationPages.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "c", (function() {
				return d
			}));
			var n = s("./src/lib/constants/index.ts"),
				o = s("./src/reddit/selectors/telemetry.ts");
			const a = e => ({
					screen: o.screen(e),
					profile: o.profile(e),
					subreddit: o.subreddit(e)
				}),
				r = e => {
					switch (e) {
						case n.Pb.Banned:
							return "banned";
						case n.Pb.Muted:
							return "muted";
						case n.Pb.Contributors:
							return "contributors";
						case n.Pb.Moderators:
							return "modmanagement";
						case n.Pb.Removal:
							return "set_removal_reasons";
						case n.Pb.CommunitySettings:
							return "edit";
						default:
							return e
					}
				},
				i = (e, t) => s => Object.assign({
					source: r(t),
					noun: e,
					action: "click"
				}, a(s)),
				d = e => t => Object.assign({
					source: r(e),
					noun: "hover_user_hovercard",
					action: "view"
				}, a(t))
		},
		"./src/reddit/helpers/trackers/reportPrompt.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			})), s.d(t, "b", (function() {
				return a
			}));
			var n = s("./src/reddit/selectors/telemetry.ts");
			const o = (e, t, s, o) => a => ({
					source: "report_prompt",
					noun: s,
					action: o,
					subreddit: n.subredditByName(a, e),
					post: n.post(a, t)
				}),
				a = (e, t, s, o) => a => ({
					source: "report_survey",
					noun: s,
					action: o,
					subreddit: n.subredditByName(a, e),
					post: n.post(a, t)
				})
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "m", (function() {
				return i
			})), s.d(t, "E", (function() {
				return d
			})), s.d(t, "q", (function() {
				return l
			})), s.d(t, "t", (function() {
				return c
			})), s.d(t, "u", (function() {
				return m
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "s", (function() {
				return b
			})), s.d(t, "v", (function() {
				return h
			})), s.d(t, "o", (function() {
				return g
			})), s.d(t, "h", (function() {
				return f
			})), s.d(t, "F", (function() {
				return x
			})), s.d(t, "C", (function() {
				return E
			})), s.d(t, "f", (function() {
				return v
			})), s.d(t, "r", (function() {
				return C
			})), s.d(t, "l", (function() {
				return _
			})), s.d(t, "k", (function() {
				return k
			})), s.d(t, "i", (function() {
				return O
			})), s.d(t, "e", (function() {
				return y
			})), s.d(t, "w", (function() {
				return j
			})), s.d(t, "j", (function() {
				return w
			})), s.d(t, "d", (function() {
				return S
			})), s.d(t, "p", (function() {
				return I
			})), s.d(t, "y", (function() {
				return P
			})), s.d(t, "n", (function() {
				return T
			})), s.d(t, "g", (function() {
				return N
			})), s.d(t, "D", (function() {
				return M
			})), s.d(t, "z", (function() {
				return R
			})), s.d(t, "a", (function() {
				return L
			})), s.d(t, "x", (function() {
				return A
			})), s.d(t, "A", (function() {
				return F
			})), s.d(t, "B", (function() {
				return D
			}));
			var n = s("./src/reddit/models/ScheduledPost/index.ts"),
				o = s("./src/reddit/selectors/telemetry.ts");
			const a = e => Object.assign({}, o.defaults(e), {
					screen: o.screen(e),
					subreddit: o.subreddit(e),
					userSubreddit: o.userSubreddit(e)
				}),
				r = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone,
					isRecurring: Object(n.n)(e)
				}),
				i = () => e => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post"
				}, a(e)),
				d = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer"
				}, a(e)),
				l = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date"
				}, a(e)),
				c = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time"
				}, a(e)),
				m = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone"
				}, a(e)),
				u = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply"
				}, a(e)),
				p = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel"
				}, a(e)),
				b = e => t => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit"
				}, a(t), {
					scheduledPost: r(e)
				}),
				h = e => t => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit"
				}, a(t), {
					scheduledPost: r(e)
				}),
				g = () => e => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts"
				}, a(e)),
				f = () => e => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: "event_posts"
				}, a(e)),
				x = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, a(e)),
				E = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, a(e)),
				v = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "edit_post"
				}, a(e)),
				C = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "submit_post_now"
				}, a(e)),
				_ = e => t => Object.assign({
					source: "post",
					action: "click",
					noun: "overflow_menu"
				}, a(t), {
					actionInfo: o.actionInfo(t, {
						pageType: e ? "recurring_posts" : "scheduled_posts"
					})
				}),
				k = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "one_time_frequency"
				}, a(e)),
				O = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "hourly_frequency"
				}, a(e)),
				y = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "daily_frequency"
				}, a(e)),
				j = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "weekly_frequency"
				}, a(e)),
				w = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "monthly_frequency"
				}, a(e)),
				S = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "custom_frequency"
				}, a(e)),
				I = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "start_event_now"
				}, a(e)),
				P = (e, t, s) => r => Object.assign({
					source: "post",
					action: "click",
					noun: Object(n.k)(e)
				}, a(r), {
					actionInfo: o.actionInfo(r, {
						settingValue: t ? "true" : "false",
						pageType: s ? "recurring_posts" : "scheduled_posts"
					})
				}),
				T = () => e => Object.assign({
					source: "recurring_post_module",
					action: "click",
					noun: "schedule_post_cta"
				}, a(e)),
				N = () => e => Object.assign({
					source: "recurring_post_module",
					action: "click",
					noun: "edit_recurring_post"
				}, a(e)),
				M = () => e => Object.assign({
					source: "recurring_post_composer",
					action: "view",
					noun: "recurring_post_composer"
				}, a(e)),
				R = () => (e, t) => Object.assign({
					source: "recurring_post_composer",
					action: "click",
					noun: "update"
				}, a(e), {
					scheduledPost: r(t)
				}),
				L = () => e => Object.assign({
					source: "recurring_post_composer",
					action: "click",
					noun: "cancel"
				}, a(e)),
				A = () => (e, t) => Object.assign({
					source: "recurring_post_composer",
					action: "click",
					noun: "delete"
				}, a(e), {
					scheduledPost: r(t)
				}),
				F = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "view",
					noun: "custom_schedule_post_composer"
				}, a(e)),
				D = () => (e, t) => {
					const s = a(e);
					return Object.assign({
						source: "post",
						action: "view",
						noun: "error"
					}, s, {
						actionInfo: Object.assign({}, s.actionInfo, {
							reason: "failed_post"
						}),
						scheduledPost: r(t)
					})
				}
		},
		"./src/reddit/helpers/validateFlairCssClass.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.match.js"), s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./src/reddit/constants/flair.ts");
			const a = new RegExp("^[a-zA-Z0-9-]{1,".concat(o.f, "}$"));
			t.a = e => {
				if (!e) return;
				const t = e.split(" ").filter(Boolean);
				if (t.length > o.c) return n.fbt._("Too many class names", null, {
					hk: "musK5"
				});
				const s = t.find(e => !e.match(a));
				return s ? s.length > o.f ? n.fbt._("Class name should not be longer than 100 characters", null, {
					hk: "2nBmgP"
				}) : n.fbt._("Class name contains an invalid character", null, {
					hk: "4kdVCU"
				}) : void 0
			}
		},
		"./src/reddit/helpers/wiki/buildWikiPagesTree.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/sortBy.js"),
				o = s.n(n),
				a = s("./src/reddit/constants/wiki.ts");
			const r = e => {
				return o()(e, e => "".concat(e.path, "/").startsWith("".concat(a.i, "/")) ? "\0".concat(e.path) : e.path).filter(e => !a.l.includes(e.path))
			};
			t.a = e => {
				const t = new Map,
					s = [];
				return r(e).forEach(e => {
					const n = Object.assign({}, e, {
							children: []
						}),
						o = n.parent ? t.get(n.parent) : null;
					o ? o.children.push(n) : s.push(n), t.set(n.path, n)
				}), s
			}
		},
		"./src/reddit/helpers/wiki/makeComparisonDiffKey.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				const {
					comparisonRevisionId: t,
					revisionId: s,
					subredditName: n,
					wikiPageName: o
				} = e;
				return "[".concat(n, "]--[").concat(o, "]--[rev1:").concat(s, "]--[rev2:").concat(t, "]").toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeRevisionsListingKey.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				const t = e.isRecent ? "(recent)" : e.wikiPageName;
				return "[".concat(e.subredditName, "]--[").concat(t, "]").toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeWikiPageKey.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				let t = "[".concat(e.subredditName, "]--[").concat(e.wikiPageName, "]");
				return e.revisionId && (t += "--[rev:".concat(e.revisionId, "]")), t.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/validatePageName.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "b", (function() {
				return d
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var n = s("./src/reddit/constants/wiki.ts");
			const o = new RegExp("^[-\\w]+(?:\\/[-\\w]+){0,".concat(n.c, "}$")),
				a = /^[-\w]+$/;
			var r;
			! function(e) {
				e[e.InvalidPageName = 1] = "InvalidPageName", e[e.RestrictedPageName = 2] = "RestrictedPageName", e[e.MaxLengthExceed = 3] = "MaxLengthExceed", e[e.PageAlreadyExists = 4] = "PageAlreadyExists"
			}(r || (r = {}));
			const i = e => {
					if (!a.test(e.toLowerCase())) return r.InvalidPageName
				},
				d = (e, t) => {
					const s = e.toLowerCase(),
						a = s.split("/")[0],
						i = n.b.has(a),
						d = n.f.has(a) && s !== n.h && s !== n.k;
					if (i || d) return r.RestrictedPageName;
					if (!o.test(s)) return r.InvalidPageName;
					if (t) {
						if (t.some(e => e.path.toLowerCase() === s)) return r.PageAlreadyExists
					}
					return s.length > n.d ? r.MaxLengthExceed : void 0
				}
		},
		"./src/reddit/helpers/wiki/wikiRevision.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return o
			}));
			const n = e => e.startsWith("WikiRevision_") ? e : "WikiRevision_" + e,
				o = e => e.startsWith("WikiRevision_") ? e.slice("WikiRevision_".length) : e
		},
		"./src/reddit/hooks/useGqlContext.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./node_modules/react/index.js"),
				o = s("./src/reddit/contexts/ApiContext.tsx");

			function a() {
				const {
					gqlContext: e
				} = Object(n.useContext)(o.a);
				return e
			}
		},
		"./src/reddit/hooks/useOnClickOutside.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./node_modules/react/index.js");

			function o(e, t) {
				const s = Object(n.useCallback)(s => {
					if (!t) return;
					const n = document.getElementById(e);
					n && (n.contains(s.target) || t(s))
				}, [e, t]);
				Object(n.useEffect)(() => {
					if (t) return document.body.addEventListener("click", s), () => {
						document.body.removeEventListener("click", s)
					}
				}, [t, s])
			}
		},
		"./src/reddit/icons/fonts/Archived/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);
			t.a = e => o.a.createElement("i", {
				className: Object(a.a)(Object(r.b)("archived"), d.a.archivedIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(r.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Calendar/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);
			t.a = e => o.a.createElement("i", {
				className: Object(a.a)(Object(r.b)("calendar"), d.a.calendarIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Comment/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var c = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			t.a = e => {
				var {
					className: t
				} = e, s = c(e, ["className"]);
				return o.a.createElement("i", l({
					className: Object(a.a)(Object(r.b)("comment"), d.a.commentIcon, t)
				}, s))
			}
		},
		"./src/reddit/icons/fonts/Crosspost/index.m.less": function(e, t, s) {
			e.exports = {
				CrosspostIcon: "_1lgwGF1j_DukLN7vdKUyHn",
				crosspostIcon: "_1lgwGF1j_DukLN7vdKUyHn"
			}
		},
		"./src/reddit/icons/fonts/Crosspost/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Crosspost/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("crosspost"), " ").concat(e.className)
			}), "CrosspostIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/DistinguishShield/index.m.less": function(e, t, s) {
			e.exports = {
				DistinguishShield: "_3qx_qM22xH7s5oSucqWca",
				distinguishShield: "_3qx_qM22xH7s5oSucqWca"
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.m.less": function(e, t, s) {
			e.exports = {
				DropdownTriangle: "_28O0gzb6GMS8lbDeySdpwp",
				dropdownTriangle: "_28O0gzb6GMS8lbDeySdpwp"
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/DropdownTriangle/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("dropdownTriangle"), " ").concat(e.className)
			}), "DropdownTriangle", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Embed/index.m.less": function(e, t, s) {
			e.exports = {
				EmbedIcon: "_1J2DOAiKZ5l1xq516M9W_Q",
				embedIcon: "_1J2DOAiKZ5l1xq516M9W_Q"
			}
		},
		"./src/reddit/icons/fonts/Embed/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Embed/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("embed"), " ").concat(e.className)
			}), "EmbedIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Envelope/index.m.less": function(e, t, s) {
			e.exports = {
				Envelope: "gsQG-L1wCCIUe8dJEOA6C",
				envelope: "gsQG-L1wCCIUe8dJEOA6C"
			}
		},
		"./src/reddit/icons/fonts/Envelope/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Envelope/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("envelope"), " ").concat(e.className)
			}), "Envelope", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less": function(e, t, s) {
			e.exports = {
				CollapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI",
				collapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("expandoArrowCollapse"), " ").concat(e.className),
				onClick: e.onClick,
				title: e.title
			}), "CollapseIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less": function(e, t, s) {
			e.exports = {
				ExpandIcon: "QOwFub52NskNmv0MdMa2_",
				expandIcon: "QOwFub52NskNmv0MdMa2_"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("expandoArrowExpand"), " ").concat(e.className),
				onClick: e.onClick,
				title: e.title
			}), "ExpandIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Expandos/Media/Lightbox/index.m.less": function(e, t, s) {
			e.exports = {
				LightboxIcon: "_1RQFWa5zHMcVoJ2MvnnGM3",
				lightboxIcon: "_1RQFWa5zHMcVoJ2MvnnGM3"
			}
		},
		"./src/reddit/icons/fonts/Hide/index.m.less": function(e, t, s) {
			e.exports = {
				HideIcon: "_1ps3GcyMra2ZVakeRQFnGj",
				hideIcon: "_1ps3GcyMra2ZVakeRQFnGj"
			}
		},
		"./src/reddit/icons/fonts/IgnoreReport/index.m.less": function(e, t, s) {
			e.exports = {
				IgnoreReportIcon: "_3iBgiSReJX5KcPORjE1Yuf",
				ignoreReportIcon: "_3iBgiSReJX5KcPORjE1Yuf"
			}
		},
		"./src/reddit/icons/fonts/IgnoreReport/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/IgnoreReport/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("ignoreReport"), " ").concat(e.className)
			}), "IgnoreReportIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Info/index.m.less": function(e, t, s) {
			e.exports = {
				InfoIcon: "_3nKAYOml-oSgh4pKL20-sC",
				infoIcon: "_3nKAYOml-oSgh4pKL20-sC"
			}
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Info/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("info"), " ").concat(e.className)
			}), "InfoIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Live/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);
			t.a = e => o.a.createElement("i", {
				className: Object(a.a)(Object(r.b)("live"), d.a.liveIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Menu/index.m.less": function(e, t, s) {
			e.exports = {
				MenuIcon: "_2L8b_l8zFzAkWuMyZJ1_vg",
				menuIcon: "_2L8b_l8zFzAkWuMyZJ1_vg"
			}
		},
		"./src/reddit/icons/fonts/Menu/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Menu/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("menu"), " ").concat(e.className)
			}), "MenuIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/ModActions/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("i", l({}, e, {
				className: Object(a.a)(Object(r.b)("modActions"), d.a.modActions, e.className)
			}))
		},
		"./src/reddit/icons/fonts/Op/index.m.less": function(e, t, s) {
			e.exports = {
				OpIcon: "_3mrrZsVUDI2b3p1rpkjbph",
				opIcon: "_3mrrZsVUDI2b3p1rpkjbph"
			}
		},
		"./src/reddit/icons/fonts/Pencil/index.m.less": function(e, t, s) {
			e.exports = {
				PencilIcon: "fKeLCuOy1oZ3UGfRARX6w",
				pencilIcon: "fKeLCuOy1oZ3UGfRARX6w"
			}
		},
		"./src/reddit/icons/fonts/Pencil/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Pencil/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("pencil"), " ").concat(e.className)
			}), "PencilIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Save/index.m.less": function(e, t, s) {
			e.exports = {
				SaveIcon: "_3n1jtdyipCtmS0HkOM1Tfd",
				saveIcon: "_3n1jtdyipCtmS0HkOM1Tfd"
			}
		},
		"./src/reddit/icons/fonts/Save/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Save/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("save"), " ").concat(e.className)
			}), "SaveIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Share/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);
			t.a = e => o.a.createElement("i", {
				className: Object(a.a)(Object(r.b)("share"), d.a.shareIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Sticky/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/fonts/helpers.tsx"),
				i = s("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = s.n(i);
			t.a = e => o.a.createElement("i", {
				className: Object(a.a)(Object(r.b)("sticky"), d.a.stickyIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(r.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Tag/index.m.less": function(e, t, s) {
			e.exports = {
				TagIcon: "_2e-QjEsH3vADXyIpSzLW6_",
				tagIcon: "_2e-QjEsH3vADXyIpSzLW6_"
			}
		},
		"./src/reddit/icons/fonts/Tag/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Tag/index.m.less"),
				i = s.n(r);
			const d = s("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(a.b)("tag"), " ").concat(e.className)
			}), "TagIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Unpin/index.m.less": function(e, t, s) {
			e.exports = {
				UnpinIcon: "_1X-tE86a0YWmVh310hgKTZ",
				unpinIcon: "_1X-tE86a0YWmVh310hgKTZ"
			}
		},
		"./src/reddit/icons/fonts/commonStyles.m.less": function(e, t, s) {
			e.exports = {
				iconFont: "WxKparxaBCy4-EWML7xc3",
				approveIcon: "MAe2tslj1FAD6GliiZ3it",
				calendarIcon: "_2YXLfgRGcJoCJROcTAGqir",
				commentIcon: "_3ch9jJ0painNf41PmU4F9i",
				lockIcon: "XHMWG1CPWX8RXeNg-o5-R",
				modActions: "_3phKxmomoio9ulzAoL4XhZ",
				moderateIcon: "_2Xt7ltq8LezAkf8ZF8x9dv",
				removeIcon: "_2IVG3b9-lczna8tonL9FWB",
				reportIcon: "_1MDjRAzxk1RSTB12748O1v",
				shareIcon: "xwmljjCrovDE5C9MasZja",
				spamIcon: "_1Gn6JH0U8GJtJXSIc54IMU",
				stickyIcon: "hMF1wBi2Z6Lh9zHskfhX1",
				adminIcon: "_3ACtZ0jvC5KDN8RNxR0lXX",
				archivedIcon: "_2trXhUAJMhIhxp8a2zvOVP",
				liveIcon: "_3cdJ6BHH65ws78AzuO0KLw"
			}
		},
		"./src/reddit/icons/svgs/AddCollection/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 24 24"
			}, o.a.createElement("defs", null, o.a.createElement("path", {
				id: "svg-add-collection",
				d: "M19.2 2.4a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V4.8a2.4 2.4 0 0 1 2.4-2.4h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V8.4A2.4 2.4 0 0 1 4.8 6h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v7.2a2.4 2.4 0 0 1-2.4 2.4H4.8a2.4 2.4 0 0 1-2.4-2.4V12a2.4 2.4 0 0 1 2.4-2.4h14.4zm-3.806 5.1H12.9v-2.494a.9.9 0 1 0-1.8 0V14.7H8.607a.9.9 0 1 0 0 1.8H11.1v2.494a.9.9 0 1 0 1.8 0V16.5h2.494a.9.9 0 0 0 0-1.8z"
			})), o.a.createElement("use", {
				fill: "inherit",
				xlinkHref: "#".concat("svg-add-collection"),
				fillRule: "evenodd"
			}))
		},
		"./src/reddit/icons/svgs/Admin/index.m.less": function(e, t, s) {
			e.exports = {
				admin: "_1PeZajQI0Wm8P3B45yshR",
				mEnabled: "_3axV0unm-cpsxoKWYwKh2x"
			}
		},
		"./src/reddit/icons/svgs/Admin/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Admin/index.m.less"),
				i = s.n(r);
			t.a = e => o.a.createElement("svg", {
				className: Object(a.a)(e.className, i.a.admin, {
					[i.a.mEnabled]: e.enabled
				}),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 -0.75 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && o.a.createElement("title", null, e.title), e.desc && o.a.createElement("desc", null, e.desc), o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "M19.99,9.3125 C19.99,8.104375 19.010625,7.125 17.8025,7.125 C17.213125,7.125 16.67875,7.359375 16.285625,7.73875 C14.8075,6.6725 12.776875,5.98 10.514375,5.886875 L11.491875,1.2875 L14.695625,1.96875 C14.775,2.756875 15.433125,3.375 16.2425,3.375 C17.105625,3.375 17.805,2.675625 17.805,1.8125 C17.805,0.949375 17.105625,0.25 16.2425,0.25 C15.6575,0.25 15.154375,0.575 14.88625,1.050625 L11.228125,0.273125 C11.10625,0.24625 10.98,0.270625 10.875625,0.338125 C10.77125,0.40625 10.698125,0.5125 10.6725,0.63375 L9.556875,5.8825 C7.26,5.960625 5.1975,6.65625 3.7,7.735 C3.306875,7.358125 2.775,7.125 2.1875,7.125 C0.979375,7.125 0,8.104375 0,9.3125 C0,10.20125 0.530625,10.965 1.2925,11.306875 C1.25875,11.524375 1.24,11.745 1.24,11.96875 C1.24,15.334375 5.1575,18.0625 9.99,18.0625 C14.8225,18.0625 18.74,15.334375 18.74,11.96875 C18.74,11.746875 18.721875,11.5275 18.68875,11.31125 C19.455,10.97125 19.99,10.205 19.99,9.3125"
			})), o.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, o.a.createElement("polygon", {
				points: "0 20 20 20 20 0 0 0"
			}), o.a.createElement("g", {
				transform: "translate(0 1)"
			})))
		},
		"./src/reddit/icons/svgs/ArrowRight/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", a({
				viewBox: "0 0 11.4 11.4",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "m11.17929,5.99479c0.08081,-0.19519 0.08081,-0.41599 0,-0.61118c-0.0408,-0.0984 -0.0992,-0.1864 -0.17361,-0.2608l-4.79963,-4.79911c-0.31283,-0.3128 -0.81847,-0.3128 -1.1313,0c-0.31283,0.31279 -0.31283,0.81918 0,1.13118l3.43471,3.43433l-7.66949,0c-0.44244,0 -0.80007,0.3584 -0.80007,0.79999c0,0.44159 0.35763,0.79999 0.80007,0.79999l7.66949,0l-3.43471,3.43433c-0.31283,0.3128 -0.31283,0.81919 0,1.13118c0.15601,0.156 0.36083,0.2344 0.56565,0.2344c0.20482,0 0.40964,-0.0784 0.56565,-0.2344l4.79963,-4.79911c0.07441,-0.0744 0.13281,-0.1624 0.17361,-0.2608"
			})))
		},
		"./src/reddit/icons/svgs/Ban/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M12.8172,7.49104 C12.8172,7.70304 12.7332,7.90704 12.5828,8.05664 L9.5196,11.11984 C9.3636,11.27584 9.1588,11.35424 8.954,11.35424 C8.7492,11.35424 8.5444,11.27584 8.3884,11.11984 L7.2572,9.98784 L2.966,14.27904 C2.8092,14.43584 2.6044,14.51344 2.4004,14.51344 C2.1956,14.51344 1.9908,14.43584 1.834,14.27904 C1.522,13.96704 1.522,13.46064 1.834,13.14784 L6.126,8.85664 L4.9948,7.72544 C4.682,7.41264 4.682,6.90704 4.9948,6.59424 L8.0572,3.53104 C8.3572,3.23104 8.8884,3.23104 9.1884,3.53104 L12.5828,6.92544 C12.7332,7.07504 12.8172,7.27904 12.8172,7.49104 Z M3.86328,6.26288 C3.65848,6.26288 3.45368,6.18448 3.29768,6.02848 C2.98488,5.71568 2.98488,5.21008 3.29768,4.89728 L6.36008,1.83408 C6.67288,1.52208 7.17928,1.52208 7.49128,1.83408 C7.80408,2.14688 7.80408,2.65328 7.49128,2.96528 L4.42888,6.02848 C4.27288,6.18448 4.06808,6.26288 3.86328,6.26288 Z M14.27968,8.62264 C14.59248,8.93544 14.59248,9.44104 14.27968,9.75384 L11.21728,12.81624 C11.06128,12.97224 10.85648,13.05064 10.65168,13.05064 C10.44688,13.05064 10.24208,12.97224 10.08608,12.81624 C9.77328,12.50424 9.77328,11.99784 10.08608,11.68504 L13.14848,8.62264 C13.46128,8.30984 13.96688,8.30984 14.27968,8.62264 Z"
			})))
		},
		"./src/reddit/icons/svgs/Cake/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				className: e.className,
				viewBox: "0 0 40 40",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M37.5,22.5V20h-35v15c0,1.4,1.1,2.5,2.5,2.5h30c1.4,0,2.5-1.1,2.5-2.5v0H6.2C5.6,35,5,34.5,5,33.8l0,0c0-0.7,0.6-1.2,1.2-1.2h31.3V30H6.2C5.6,30,5,29.5,5,28.8v0c0-0.7,0.6-1.2,1.2-1.2h31.3V25H6.2C5.6,25,5,24.5,5,23.8v0c0-0.7,0.6-1.2,1.2-1.2H37.5z"
			}), o.a.createElement("path", {
				d: "M22.5,6c0,1.4-1.1,2.5-2.5,2.5S17.5,7.4,17.5,6S20,0,20,0S22.5,4.6,22.5,6z"
			}), o.a.createElement("path", {
				d: "M20,15L20,15c-0.7,0-1.3-0.6-1.3-1.2v-2.5c0-0.7,0.6-1.2,1.2-1.2h0c0.7,0,1.2,0.6,1.2,1.2v2.5C21.2,14.5,20.7,15,20,15z"
			}), o.a.createElement("path", {
				d: "M22.8,11.3v2.3c0,1.4-1,2.7-2.5,2.9c-1.6,0.2-3-1.1-3-2.7v-5c0,0,0-0.1,0-0.1l-0.8-0.4c-0.9-0.4-2-0.3-2.7,0.4L2.5,18.5h35L22.8,11.3z"
			}))))
		},
		"./src/reddit/icons/svgs/ChevronUp/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("polygon", {
				fill: "inherit",
				transform: "translate(6.029200, 6.044700) scale(1, -1) translate(-6.029200, -6.044700)",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/Circle/index.m.less": function(e, t, s) {
			e.exports = {
				circle: "_17IuRdA-NY8vFk-Tt991sn"
			}
		},
		"./src/reddit/icons/svgs/Circle/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Circle/index.m.less"),
				i = s.n(r);
			t.a = e => o.a.createElement("svg", {
				className: Object(a.a)(i.a.circle, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 8 8"
			}, o.a.createElement("g", {
				fill: "inherit",
				stroke: "none"
			}, o.a.createElement("circle", {
				r: "4",
				cy: "4",
				cx: "4"
			})))
		},
		"./src/reddit/icons/svgs/Clock/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 11 11"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M5 3.75C5 3.47388 5.22363 3.25 5.5 3.25C5.77637 3.25 6 3.47388 6 3.75V5.53735L7.81689 6.58643C8.05615 6.72449 8.13818 7.03027 8 7.26941C7.86182 7.50861 7.55615 7.59052 7.31689 7.45245L5.25049 6.25934C5.07861 6.16028 4.98779 5.97504 5.00146 5.78992L5 5.75V3.75Z",
				fill: "inherit"
			}), o.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M11 5.5C11 8.53754 8.5376 11 5.5 11C2.4624 11 0 8.53754 0 5.5C0 2.46246 2.4624 0 5.5 0C8.5376 0 11 2.46246 11 5.5ZM10 5.5C10 7.98529 7.98535 10 5.5 10C3.01465 10 1 7.98529 1 5.5C1 3.01471 3.01465 1 5.5 1C7.98535 1 10 3.01471 10 5.5Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Eye/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);

			function a(e) {
				return o.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 40 40"
				}, o.a.createElement("g", null, o.a.createElement("path", {
					d: "M20,8C9.1,8,0.5,14,0.5,21.7h4c0-3.6,3.4-6.9,8.2-8.5C11,15,10,17.4,10,20c0,5.5,4.5,10,10,10s10-4.5,10-10c0-2.6-1-5-2.7-6.8c4.8,1.7,8.2,4.9,8.2,8.5h4C39.5,14,30.9,8,20,8z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Gild/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && o.a.createElement("desc", null, e.desc), o.a.createElement("g", {
				stroke: "none",
				strokeWidth: "1",
				fillRule: "evenodd"
			}, o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "m15.1275768 8.9935-2.059 2.204.371 2.992c.022.181-.055.359-.203.466-.087.064-.19.096-.294.096-.072 0-.144-.016-.211-.047l-2.73200003-1.277-2.731 1.277c-.164.076-.359.059-.506-.049-.148-.107-.225-.285-.202-.466l.37-2.992-2.059-2.204c-.124-.133-.166-.323-.11-.496s.202-.302.381-.336l2.96-.573 1.46-2.639c.175-.318.69900003-.318.87500003 0l1.46 2.639 2.959.573c.179.034.325.163.381.336s.014.363-.11.496m2.911-2.985-6.586-4.786c-.869-.63-2.03700003-.63-2.90600003 0v.001l-6.586 4.785c-.869.631-1.23 1.742-.898 2.764l2.515 7.743c.332 1.021 1.278 1.708 2.352 1.708h8.14000003c1.075 0 2.02-.687 2.352-1.708l2.516-7.743c.332-1.022-.03-2.133-.899-2.764"
			}))))
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, s) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Grapple/index.m.less"),
				i = s.n(r);
			t.a = e => o.a.createElement("svg", {
				className: Object(a.a)(e.className, i.a.grapple, {
					[i.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("title", {
				id: "".concat(e.title, "-title")
			}, e.title), o.a.createElement("g", null, o.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/ImageUpload/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_2irXdPA4C5flwkupsFkN9-"
			}
		},
		"./src/reddit/icons/svgs/ImageUpload/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/ImageUpload/index.m.less"),
				i = s.n(r);
			t.a = e => o.a.createElement("svg", {
				className: Object(a.a)(i.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("polygon", {
				fill: "inherit",
				opacity: "0",
				points: "0.610673352 20 20.625 20 20.625 0 0.610673352 0"
			}), o.a.createElement("path", {
				d: "M17.451,9.14823765 C17.03,5.40791696 13.8555,2.5 10,2.5 C6.1445,2.5 2.97,5.40791696 2.549,9.14823765 C1.0455,9.84024195 0,11.3551568 0,13.1173944 C0,15.531665 1.959,17.4892627 4.375,17.4892627 L7.8125,17.4892627 L7.8125,12.8051181 L5,12.8051181 C4.8735,12.8051181 4.7595,12.7291725 4.7115,12.6122563 C4.6625,12.49534 4.6895,12.3614359 4.779,12.272 L9.779,7.2755791 C9.901,7.15366643 10.099,7.15366643 10.221,7.2755791 L15.187,12.2375247 C15.2665,12.2944839 15.3185,12.3874173 15.3185,12.4928418 C15.3185,12.6652183 15.1785,12.8051181 15.006,12.8051181 L15,12.8051181 L12.1875,12.8051181 L12.1875,17.4892627 L15.625,17.4892627 C18.041,17.4892627 20,15.531665 20,13.1173944 C20,11.3551568 18.954,9.84024195 17.451,9.14823765",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Karma/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M6.42528593,9.54562407 C4.41043013,8.02026355 3.10790651,5.60355545 3.10790651,2.88165092 L3.10790651,2.79711586 L3.19244157,2.79711586 C5.9143461,2.79711586 8.33136499,4.09963948 9.85641472,6.11449528 C8.02399304,6.25279712 6.56358777,7.7128916 6.42528593,9.54562407 Z M6.42528593,10.2560915 C6.56358777,12.088824 8.02399304,13.5489184 9.85641472,13.6872203 C8.33136499,15.7020761 5.9143461,17.0045997 3.19244157,17.0045997 L3.10790651,17.0045997 L3.10790651,16.9200646 C3.10790651,14.1981601 4.41043013,11.781452 6.42528593,10.2560915 Z M13.6872203,10.2560915 C15.7020761,11.781452 17.0045997,14.1981601 17.0045997,16.9200646 L17.0045997,17.0045997 L16.9200646,17.0045997 C14.1981601,17.0045997 11.7811412,15.7020761 10.2560915,13.6872203 C12.0885132,13.5489184 13.5486077,12.088824 13.6872203,10.2560915 Z M16.9200646,2.79711586 L17.0045997,2.79711586 L17.0045997,2.88165092 C17.0045997,5.60324465 15.7020761,8.02026355 13.6872203,9.54562407 C13.5489184,7.7128916 12.0885132,6.25279712 10.2560915,6.11449528 C11.7811412,4.09963948 14.1981601,2.79711586 16.9200646,2.79711586 Z M19.9403282,9.84895574 L20,9.90862755 L19.9403282,9.96829935 C18.9346096,10.9740179 17.7346469,11.6624192 16.46227,12.0474888 C15.9659373,11.2534187 15.3446668,10.5308304 14.6071606,9.90862755 C15.3446668,9.28642466 15.9659373,8.5638364 16.46227,7.76976629 C17.7346469,8.1548359 18.9346096,8.8432372 19.9403282,9.84895574 Z M9.90862755,5.39283938 C9.28642466,4.65533317 8.5638364,4.03406266 7.76976629,3.53772999 C8.1548359,2.26535306 8.8432372,1.06539035 9.84895574,0.0596718051 L9.90862755,0 L9.96829935,0.0596718051 C10.9740179,1.06539035 11.6624192,2.26535306 12.0474888,3.53772999 C11.2534187,4.03406266 10.5308304,4.65533317 9.90862755,5.39283938 Z M5.39283938,9.90862755 C4.65533317,10.5308304 4.03406266,11.2534187 3.53772999,12.0474888 C2.26535306,11.6624192 1.06539035,10.9740179 0.0596718051,9.96829935 L0,9.90862755 L0.0596718051,9.84895574 C1.06539035,8.8432372 2.26535306,8.1548359 3.53772999,7.76976629 C4.03406266,8.5638364 4.65533317,9.28642466 5.39283938,9.90862755 Z M9.90862755,14.6071606 C10.5308304,15.3446668 11.2534187,15.9659373 12.0474888,16.46227 C11.6624192,17.7346469 10.9740179,18.9346096 9.96829935,19.9403282 L9.90862755,20 L9.84895574,19.9403282 C8.8432372,18.9346096 8.1548359,17.7346469 7.76976629,16.46227 C8.5638364,15.9659373 9.28642466,15.3446668 9.90862755,14.6071606 Z"
			})))
		},
		"./src/reddit/icons/svgs/Lock/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 40 40",
				xmlns: "http://www.w3.org/2000/svg",
				fill: e.fill
			}, o.a.createElement("g", null, o.a.createElement("rect", {
				x: "7.5",
				y: "12.5",
				width: "0",
				height: "0"
			}), o.a.createElement("path", {
				fill: "inherit",
				d: "M32.5,17.5v-2.6c0-6.8-5.6-12.4-12.4-12.4h-0.2c-6.8,0-12.4,5.6-12.4,12.4v2.6C6.1,17.5,5,18.6,5,20v10c0,5.5,4.5,10,10,10h10c5.5,0,10-4.5,10-10V20C35,18.6,33.9,17.5,32.5,17.5z M12.5,17.5v-2.6c0-4.1,3.3-7.4,7.4-7.4h0.2c4.1,0,7.4,3.3,7.4,7.4v2.6H12.5z"
			})))
		},
		"./src/reddit/icons/svgs/Mute/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M9.97968,8.20936 C10.13568,8.36536 10.13568,8.61896 9.97968,8.77496 C9.90128,8.85336 9.79888,8.89256 9.69648,8.89256 C9.59488,8.89256 9.49248,8.85336 9.41408,8.77496 L7.99968,7.36056 L6.58608,8.77496 C6.50768,8.85336 6.40528,8.89256 6.30288,8.89256 C6.20048,8.89256 6.09808,8.85336 6.02048,8.77496 C5.86368,8.61896 5.86368,8.36536 6.02048,8.20936 L7.43408,6.79496 L6.02048,5.38136 C5.86368,5.22536 5.86368,4.97176 6.02048,4.81576 C6.17648,4.65976 6.43008,4.65976 6.58608,4.81576 L7.99968,6.22936 L9.41408,4.81576 C9.57008,4.65976 9.82368,4.65976 9.97968,4.81576 C10.13568,4.97176 10.13568,5.22536 9.97968,5.38136 L8.56528,6.79496 L9.97968,8.20936 Z M12.79968,1.59976 L3.19968,1.59976 C2.31808,1.59976 1.59968,2.31816 1.59968,3.19976 L1.59968,10.59496 C1.59968,11.47736 2.31808,12.19496 3.19968,12.19496 L6.10528,12.19496 L7.33408,14.03896 C7.48288,14.26136 7.73248,14.39496 7.99968,14.39496 C8.26688,14.39496 8.51728,14.26136 8.66528,14.03896 L9.89488,12.19496 L12.79968,12.19496 C13.68208,12.19496 14.39968,11.47736 14.39968,10.59496 L14.39968,3.19976 C14.39968,2.31816 13.68208,1.59976 12.79968,1.59976 L12.79968,1.59976 Z",
				id: "path-1"
			})))
		},
		"./src/reddit/icons/svgs/Remove/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				id: e.id,
				tabIndex: e.tabIndex,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement("g", null, o.a.createElement("path", {
				fillRule: "evenodd",
				d: "M13.5559061,14.5 C13.5559061,14.776 13.3283409,15 13.0479481,15 C12.7675552,15 12.53999,14.776 12.53999,14.5 L12.53999,9 C12.53999,8.724 12.7675552,8.5 13.0479481,8.5 C13.3283409,8.5 13.5559061,8.724 13.5559061,9 L13.5559061,14.5 Z M10.508158,14.5 C10.508158,14.776 10.2805928,15 10.0002,15 C9.71980718,15 9.49224199,14.776 9.49224199,14.5 L9.49224199,9 C9.49224199,8.724 9.71980718,8.5 10.0002,8.5 C10.2805928,8.5 10.508158,8.724 10.508158,9 L10.508158,14.5 Z M7.46040996,14.5 C7.46040996,14.776 7.23284477,15 6.95245195,15 C6.67205913,15 6.44449394,14.776 6.44449394,14.5 L6.44449394,9 C6.44449394,8.724 6.67205913,8.5 6.95245195,8.5 C7.23284477,8.5 7.46040996,8.724 7.46040996,9 L7.46040996,14.5 Z M15.492242,6 C15.7736507,6 16.0002,6.224 16.0002,6.5 L16.0002,16.5 C16.0002,17.327 15.3164885,18 14.476326,18 L5.52407403,18 C4.68391148,18 4.0002,17.327 4.0002,16.5 L4.0002,6.5 C4.0002,6.224 4.22674927,6 4.50815801,6 L15.492242,6 Z M15.491585,3 C15.7719541,3 15.9995,3.224 15.9995,3.5 L15.9995,4.5 C15.9995,4.776 15.7719541,5 15.491585,5 L4.50741501,5 C4.22704592,5 3.9995,4.776 3.9995,4.5 L3.9995,3.5 C3.9995,3.224 4.22704592,3 4.50741501,3 L7.51325603,3 L8.26598607,2.167 C8.36248993,2.061 8.50064281,2 8.6459065,2 L11.3541093,2 C11.4983572,2 11.6365101,2.061 11.7340298,2.167 L12.485744,3 L15.491585,3 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", a({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), o.a.createElement("g", null, o.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Rules/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 30 30",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M20.7094669,9.4275 L9.29053307,9.4275 C8.86319398,9.4275 8.51636806,9.0915 8.51636806,8.6775 C8.51636806,8.2635 8.86319398,7.9275 9.29053307,7.9275 L20.7094669,7.9275 C21.136806,7.9275 21.4836319,8.2635 21.4836319,8.6775 C21.4836319,9.0915 21.136806,9.4275 20.7094669,9.4275 M20.7094669,14.142 L9.29053307,14.142 C8.86319398,14.142 8.51636806,13.806 8.51636806,13.392 C8.51636806,12.978 8.86319398,12.642 9.29053307,12.642 L20.7094669,12.642 C21.136806,12.642 21.4836319,12.978 21.4836319,13.392 C21.4836319,13.806 21.136806,14.142 20.7094669,14.142 M20.7094669,18.858 L9.29053307,18.858 C8.86319398,18.858 8.51636806,18.522 8.51636806,18.108 C8.51636806,17.6925 8.86319398,17.358 9.29053307,17.358 L20.7094669,17.358 C21.136806,17.358 21.4836319,17.6925 21.4836319,18.108 C21.4836319,18.522 21.136806,18.858 20.7094669,18.858 M20.7094669,23.5725 L9.29053307,23.5725 C8.86319398,23.5725 8.51636806,23.2365 8.51636806,22.8225 C8.51636806,22.407 8.86319398,22.0725 9.29053307,22.0725 L20.7094669,22.0725 C21.136806,22.0725 21.4836319,22.407 21.4836319,22.8225 C21.4836319,23.2365 21.136806,23.5725 20.7094669,23.5725 M23.95167,4.5 L20.4570891,4.5 C19.9198186,3.6075 18.9335324,3 17.7893165,3 L12.2106835,3 C11.0664676,3 10.0801814,3.6075 9.54291086,4.5 L6.04833002,4.5 C5.19365185,4.5 4.5,5.172 4.5,6 L4.5,25.5 C4.5,26.328 5.19365185,27 6.04833002,27 L23.95167,27 C24.8063482,27 25.5,26.328 25.5,25.5 L25.5,6 C25.5,5.172 24.8063482,4.5 23.95167,4.5"
			})))
		},
		"./src/reddit/icons/svgs/Saved/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_2OUcXcp-8gkoFyUSKdNTxF"
			}
		},
		"./src/reddit/icons/svgs/Saved/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Saved/index.m.less"),
				i = s.n(r);
			t.a = e => o.a.createElement("svg", {
				className: Object(a.a)(i.a.icon, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("path", {
				d: "M12.5 2h-11a.5.5 0 0 0 0 1A2.5 2.5 0 0 1 4 5.5v12.24a1 1 0 0 0 1.4.92l4.6-2 4.6 2a1 1 0 0 0 1.4-.92V5.5A3.5 3.5 0 0 0 12.5 2zm1 6.53l-4.26 4.29a.75.75 0 0 1-1.06 0L6.47 11.1A.75.75 0 0 1 7.53 10l1.18 1.18 3.76-3.76a.75.75 0 0 1 1.06 1.06z"
			}))
		},
		"./src/reddit/icons/svgs/Show/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("path", {
				d: "M17.71,10.29,14.95,7.54a7,7,0,0,0-9.9,0L2.29,10.29a1,1,0,0,0,1.41,1.41L6.46,8.95c.07-.07.14-.11.21-.17a4,4,0,1,0,6.65,0c.07.06.15.11.21.17l2.76,2.76a1,1,0,0,0,1.41-1.41Z"
			}))
		},
		"./src/reddit/icons/svgs/Tag/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				style: e.style,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "M5.14293863,3.38188919 C5.75317178,3.99212234 5.75317178,4.98136473 5.14293863,5.59159788 C4.53270548,6.20183104 3.54346309,6.20183104 2.93322994,5.59159788 C2.32299679,4.98136473 2.32299679,3.99212234 2.93322994,3.38188919 C3.54346309,2.77165604 4.53270548,2.77165604 5.14293863,3.38188919 Z M1.01449569,2.94595786 L1,9.03662212 C1.00035355,9.55457784 1.19162594,10.0654625 1.55790725,10.4317438 L9.89929239,18.7731289 C10.6622606,19.5360972 11.8989904,19.5360972 12.661605,18.7734825 L18.7381272,12.6969604 C19.5007418,11.9343457 19.5007418,10.697616 18.7377736,9.93464773 L10.3963885,1.59326259 C10.0301071,1.22698128 9.54786032,1.00707107 9.02955105,1.00707107 L2.96045355,1 C1.8814086,1 1.01414214,1.86726647 1.01449569,2.94595786 Z"
			})))
		},
		"./src/reddit/icons/svgs/Trash/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, o.a.createElement("g", null, o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("polygon", {
				points: "10,38.8 30,38.8 31.2,10.9 8.7,10.9"
			}), o.a.createElement("path", {
				d: "M27.5,3.8H25c0-1.4-1.1-2.5-2.5-2.5h-5c-1.4,0-2.5,1.1-2.5,2.5h-2.5c-2.8,0-5,2.2-5,5h25C32.5,6,30.3,3.8,27.5,3.8z"
			}))))
		},
		"./src/reddit/icons/svgs/Trash2/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_1Fa4RPHlhrfUZuNaXK2-eP"
			}
		},
		"./src/reddit/icons/svgs/Trash2/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			}));
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Trash2/index.m.less"),
				i = s.n(r);
			const d = e => o.a.createElement("svg", {
				className: Object(a.a)(i.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, o.a.createElement("path", {
				d: "M16.5,2H12.71l-.85-.85A.5.5,0,0,0,11.5,1h-3a.5.5,0,0,0-.35.15L7.29,2H3.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5h13a.5.5,0,0,0,.5-.5v-1A.5.5,0,0,0,16.5,2Z"
			}), o.a.createElement("path", {
				d: "M16.5,5H3.5a.5.5,0,0,0-.5.5v12A1.5,1.5,0,0,0,4.5,19h11A1.5,1.5,0,0,0,17,17.5V5.5A.5.5,0,0,0,16.5,5ZM6.75,15.5a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Z"
			}));
			t.b = d
		},
		"./src/reddit/icons/svgs/Unban/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M8,6.77247619 L8,6.27380952 L7.5072,6.27380952 L8,6.77247619 Z M7,5.76057143 L7,0.80952381 L11,0.80952381 L11,6.27380952 L10,6.27380952 L10,8.79628571 L15.9072,14.7738095 L15.2,15.4894286 L1,1.12038095 L1.7072,0.404761905 L3,1.71295238 L3,1.00178571 C3,0.44847619 3.4432,0 3.99,0 L4.01,0 C4.5568,0 5,0.44847619 5,1.00178571 L5,3.7367619 L5.8,4.54628571 L5.8,0.80952381 C5.8,0.585690476 5.9792,0.404761905 6.2,0.404761905 C6.4208,0.404761905 6.6,0.585690476 6.6,0.80952381 L6.6,5.35580952 L7,5.76057143 Z M8.2,8.9047619 L10.2,10.9285714 L10.2,14.2706905 C10.2,14.824 9.7568,15.2724762 9.21,15.2724762 L9.19,15.2724762 C8.6432,15.2724762 8.2,14.824 8.2,14.2706905 L8.2,8.9047619 Z M5.8,6.47619048 L6.284,6.96595238 C6.2568,6.97161905 6.2288,6.97485714 6.2,6.97485714 C5.9792,6.97485714 5.8,6.79392857 5.8,6.57009524 L5.8,6.47619048 Z M12.2,0.404761905 C12.4208,0.404761905 12.6,0.586095238 12.6,0.80952381 L12.6,6.67857143 C12.6,6.902 12.4208,7.08333333 12.2,7.08333333 C11.9792,7.08333333 11.8,6.902 11.8,6.67857143 L11.8,0.80952381 C11.8,0.586095238 11.9792,0.404761905 12.2,0.404761905 Z M14.01,0 C14.5568,0 15,0.44847619 15,1.00178571 L15,6.08154762 C15,6.63485714 14.5568,7.08333333 14.01,7.08333333 L13.99,7.08333333 C13.4432,7.08333333 13,6.63485714 13,6.08154762 L13,1.00178571 C13,0.44847619 13.4432,0 13.99,0 L14.01,0 Z M3,4.04761905 L5,6.07142857 L5,6.37783333 C5,6.93114286 4.5568,7.37961905 4.01,7.37961905 L3.99,7.37961905 C3.4432,7.37961905 3,6.93114286 3,6.37783333 L3,4.04761905 Z"
			})))
		},
		"./src/reddit/icons/svgs/User/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				o = s.n(n);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("path", {
				d: "M12,11 C15.309,11 18,13.691 18,17 C18,17.553 17.552,18 17,18 L3,18 C2.448,18 2,17.553 2,17 C2,13.691 4.691,11 8,11 L12,11 Z M10,9.7334 C7.868,9.7334 6.133,7.9994 6.133,5.8664 L6.133,4.8664 C6.133,2.7344 7.868,1.0004 10,1.0004 C12.132,1.0004 13.867,2.7344 13.867,4.8664 L13.867,5.8664 C13.867,7.9994 12.132,9.7334 10,9.7334 Z"
			}))
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, s) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/lessComponent.tsx"),
				o = s("./src/reddit/layout/row/RightAlign/index.m.less"),
				a = s.n(o);
			t.a = n.a.div("rightAligned", a.a)
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.m.less": function(e, t, s) {
			e.exports = {
				left: "_3YRHtGWABKh4OVO3s5gJwt",
				right: "_1IPWlMFPB_zPPajVPKk5Dy",
				expandRightContainer: "_2CUZHyZpRYmdvLE9tOI-2L"
			}
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				o = s.n(n),
				a = s("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/layout/twoCol/ExpandRight/index.m.less"),
				d = s.n(i);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var c = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (s[n[o]] = e[n[o]])
				}
				return s
			};
			t.a = Object(a.a)(e => {
				const {
					className: t,
					children: s,
					heightLeft: n,
					widthLeft: a,
					gutter: i
				} = e, m = c(e, ["className", "children", "heightLeft", "widthLeft", "gutter"]);
				return o.a.createElement("div", l({
					className: Object(r.a)(d.a.expandRightContainer, t)
				}, m), o.a.createElement("div", {
					className: d.a.left,
					style: {
						flexBasis: a,
						height: n,
						marginRight: i
					}
				}, Array.isArray(s) && s[0]), o.a.createElement("div", {
					className: d.a.right
				}, Array.isArray(s) && s[1]))
			}, 2)
		},
		"./src/reddit/models/RemovalReason/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return o
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "e", (function() {
				return l
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "h", (function() {
				return m
			}));
			var n = s("./src/reddit/helpers/isPost.ts");
			const o = 20,
				a = 50,
				r = 1e4,
				i = 100;
			var d, l;
			! function(e) {
				e.Private = "private", e.PrivateExposed = "private_exposed", e.Public = "public"
			}(d || (d = {})),
			function(e) {
				e.Bulk = "bulk", e.Comment = "comment", e.Post = "link"
			}(l || (l = {}));
			const c = e => 1 === e.length ? Object(n.a)(e[0]) ? l.Post : l.Comment : l.Bulk,
				m = (e, t) => {
					return {
						[t === l.Bulk ? "item_ids" : "item_id"]: e.itemId,
						message: e.message,
						title: e.title,
						type: e.type
					}
				}
		},
		"./src/reddit/models/SubredditModeration/ModerationLog/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = (e, t, s) => "".concat(e, "-").concat(((e, t) => t || e || "1")(s, t))
		},
		"./src/reddit/models/SubredditWikiPage/index.ts": function(e, t, s) {
			"use strict";
			var n, o;
			s.d(t, "b", (function() {
					return n
				})), s.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.MayNotView = "MAY_NOT_VIEW", e.PageNotCreated = "PAGE_NOT_CREATED", e.PageNotFound = "PAGE_NOT_FOUND", e.RestrictedPage = "RESTRICTED_PAGE", e.Unknown = "UNKNOWN", e.Valid = "VALID", e.WikiDisabled = "WIKI_DISABLED"
				}(n || (n = {})),
				function(e) {
					e.Inherit = "INHERIT_SUBREDDIT_PERMS", e.Contributors = "CONTRIBUTORS", e.Mods = "MODS"
				}(o || (o = {}))
		},
		"./src/reddit/models/TrafficStats/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return o
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return r
			}));
			const n = 97,
				o = 57,
				a = 12;
			var r;
			! function(e) {
				e.TOTAL = "total", e.DESKTOP = "desktop", e.OLD_REDDIT = "oldReddit", e.IOS = "apps", e.ANDROID = "apps", e.MOBILE_WEB = "mWeb"
			}(r || (r = {}))
		},
		"./src/reddit/pages/ModHub/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_2WsiFpk8Yr5G2mp45qaGCa",
				titleFontH2: "_3oXE2EKQ3PsqyyApE-s3aj",
				titleFontH3: "_17o-6Y7vVLdL6oVMkFWo0m",
				titleFontH4: "uPBfC6MDaNJ-ozFZg2PFk",
				titleFontH5: "si3j-_p1olO8M1E2zoXjC",
				titleFontH6: "_14LzReKyHQwLHa-Rye3bAv",
				metadataFont: "_2NmVHGIdF8GNcMPPaHtwzz",
				flairFont: "D_gevKcOJSKbb6VlvHPj_",
				labelsFont: "_27eE-dU25b8hwKWg4bTqFz",
				actionFont: "_2dfa5IRwlqKVb61Lr36T98",
				smallButtonFont: "_20OTyO3PvAmgnQP4SoJgGt",
				largeButtonFont: "_2nrHVa4dyedAaDcfRLLE5z",
				tabFont: "_3Bpld0JoC9VmYlZZ5Dyms1",
				strongTextFont: "_25hN89q-zD6Y-U11Y_e4aZ",
				bodyFontH1: "bhfIpkByfOrflj2uqeOu3",
				bodyFontH2: "_3xwPD6mwo8KG7WQa3W8njG",
				bodyFontH3: "_1o3ciR8XDGZ_1S7FR7rmrb",
				bodyFontH4: "KyspXVcxKfpH-yrxxQ4EY",
				bodyFontH5: "_20z_x36tiklZi1W-Z3uqvJ",
				bodyFontH6: "_14VGsHSpx6uKHLlJqMng5B",
				bodyFont: "_3ejsRrJq-hN84OvmuolQYo",
				bodyFontSmall: "_1c--mrP_57nHX86Jy6YDjW",
				bodyFontMono: "_2jHXa8pmE696zxLXFfT4I0",
				contentWrapper: "_2Z3MiFrgj2rofHXrH1YVKn",
				isModerator: "_1haViLcso0RRPvkDGZgDLJ",
				BackgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				backgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				SubredditLink: "_3u_4BK4_gVwVyX1YIZjFft",
				subredditLink: "_3u_4BK4_gVwVyX1YIZjFft",
				Header: "_12UrKOfuM441n-zHotruas",
				header: "_12UrKOfuM441n-zHotruas",
				SubredditIcon: "_2N81CG8WsdJLudQQiSy8oZ",
				subredditIcon: "_2N81CG8WsdJLudQQiSy8oZ",
				Body: "_3hAOyl8ThaUgCBqiNvN_sN",
				body: "_3hAOyl8ThaUgCBqiNvN_sN"
			}
		},
		"./src/reddit/pages/ModHub/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			s("./node_modules/core-js/modules/es6.regexp.search.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/lodash/fromPairs.js"),
				o = s.n(n),
				a = s("./node_modules/react/index.js"),
				r = s.n(a),
				i = s("./node_modules/react-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/extractQueryParams/index.ts"),
				m = s("./src/lib/lessComponent.tsx"),
				u = s("./src/reddit/components/ContentGate/index.tsx"),
				p = s("./node_modules/fbt/lib/FbtPublic.js"),
				b = s("./src/lib/assertNever.ts"),
				h = s("./src/lib/constants/index.ts");
			const g = e => {
				switch (e) {
					case h.Pb.Awards:
						return p.fbt._("Awards", null, {
							hk: "EiSXW"
						});
					case h.Pb.Banned:
						return p.fbt._("Banned", null, {
							hk: "35R8OD"
						});
					case h.Pb.Muted:
						return p.fbt._("Muted", null, {
							hk: "f2nJu"
						});
					case h.Pb.Contributors:
						return p.fbt._("Approved", null, {
							hk: "180AS9"
						});
					case h.Pb.Moderators:
						return p.fbt._("Moderators", null, {
							hk: "4qdV8t"
						});
					case h.Pb.SubredditRules:
						return p.fbt._("Rules", null, {
							hk: "2SNdd8"
						});
					case h.Pb.Removal:
						return p.fbt._("Removal reasons", null, {
							hk: "1smDUM"
						});
					case h.Pb.Modqueue:
						return p.fbt._("Mod queue", null, {
							hk: "yEBGb"
						});
					case h.Pb.Reports:
						return p.fbt._("Reports", null, {
							hk: "4Ctcb1"
						});
					case h.Pb.Spam:
						return p.fbt._("Spam", null, {
							hk: "1D73Vp"
						});
					case h.Pb.Unmoderated:
						return p.fbt._("Unmoderated", null, {
							hk: "3TOaeD"
						});
					case h.Pb.Edited:
						return p.fbt._("Edited", null, {
							hk: "OLtvW"
						});
					case h.Pb.PostRequirements:
						return p.fbt._("Post requirements", null, {
							hk: "3UBlR0"
						});
					case h.Pb.ChatSettings:
						return p.fbt._("Chat settings", null, {
							hk: "3gycCw"
						});
					case h.Pb.Modlog:
						return p.fbt._("Mod log", null, {
							hk: "3uy7LL"
						});
					case h.Pb.Flair:
						return p.fbt._("Grant user flair", null, {
							hk: "2B8sTJ"
						});
					case h.Pb.CommunitySettings:
						return p.fbt._("Community settings", null, {
							hk: "XbHzi"
						});
					case h.Pb.Emojis:
						return p.fbt._("Emojis", null, {
							hk: "3mPnxe"
						});
					case h.Pb.UserFlair:
						return p.fbt._("User flair", null, {
							hk: "3kleCv"
						});
					case h.Pb.PostFlair:
						return p.fbt._("Post flair", null, {
							hk: "2Y1FKb"
						});
					case h.Pb.Badges:
						return p.fbt._("Badges", null, {
							hk: "3vM0lt"
						});
					case h.Pb.Emotes:
						return p.fbt._("Emotes", null, {
							hk: "2Ivxxq"
						});
					case h.Pb.Wiki:
					case h.Pb.WikiContributors:
					case h.Pb.WikiBanned:
						return p.fbt._("Wiki pages", null, {
							hk: "WdSXv"
						});
					case h.Pb.Traffic:
						return p.fbt._("Traffic stats", null, {
							hk: "3mcw71"
						});
					case h.Pb.ScheduledPostContent:
					case h.Pb.SubredditContent:
						return p.fbt._("Scheduled posts", null, {
							hk: "19KZjq"
						});
					case h.Pb.EventPostContent:
						return p.fbt._("Event posts", null, {
							hk: "3ejc42"
						});
					case h.Pb.Streaming:
						return p.fbt._("Streaming", null, {
							hk: "OF6K8"
						});
					default:
						return Object(b.a)(e)
				}
			};
			var f = s("./src/reddit/components/SubredditIcon/index.tsx"),
				x = s("./src/reddit/components/TrackingHelper/index.tsx"),
				E = s("./src/reddit/contexts/PageLayer/index.tsx"),
				v = s("./src/reddit/controls/InternalLink/index.tsx"),
				C = s("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				_ = s("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				k = s("./src/reddit/helpers/getSubredditErrorProps/index.ts"),
				O = s("./src/reddit/helpers/trackers/moderationPages.ts"),
				y = s("./src/reddit/helpers/trackers/modHub.ts"),
				j = s("./src/reddit/models/ModQueue/index.ts"),
				w = s("./src/reddit/selectors/moderatorPermissions.ts"),
				S = s("./src/reddit/selectors/postCreations.ts"),
				I = s("./src/reddit/selectors/streamingModSettings.ts"),
				P = s("./src/reddit/selectors/subreddit.ts"),
				T = s("./src/reddit/selectors/user.ts"),
				N = s("./src/reddit/components/ModHub/Content/index.tsx"),
				M = s("./src/reddit/components/ModHub/Content/NoPermissions.tsx"),
				R = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				L = s("./src/reddit/components/ModHub/Content/WelcomeMessage.m.less"),
				A = s.n(L);
			const F = m.a.wrapped(R.a, "ModerateIcon", A.a),
				D = m.a.div("ModHubWelcomeMessage", A.a);
			var B = e => r.a.createElement(D, null, r.a.createElement(F, null), p.fbt._("Welcome to the mod tools for {subredditName}", [p.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "7Usff"
				})),
				U = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/config.ts")),
				H = s("./node_modules/react-router-redux/es/index.js"),
				W = s("./src/reddit/actions/modal.ts"),
				V = s("./src/reddit/constants/modals.ts"),
				q = s("./src/reddit/featureFlags/index.ts"),
				G = s("./src/reddit/helpers/localStorage/index.ts"),
				K = s("./src/reddit/helpers/trackers/communitySettings.ts"),
				z = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				Q = s("./src/reddit/icons/svgs/Chat/index.tsx"),
				J = s("./src/reddit/icons/svgs/Help/index.tsx"),
				Z = e => r.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", null, r.a.createElement("path", {
					fillRule: "evenodd",
					d: "M17,9.4802 C17.553,9.4802 18,9.9272 18,10.4802 C18,11.0332 17.553,11.4802 17,11.4802 L8,11.4802 C7.447,11.4802 7,11.0332 7,10.4802 C7,9.9272 7.447,9.4802 8,9.4802 L17,9.4802 Z M17,15.4802 C17.553,15.4802 18,15.9272 18,16.4802 C18,17.0332 17.553,17.4802 17,17.4802 L8,17.4802 C7.447,17.4802 7,17.0332 7,16.4802 C7,15.9272 7.447,15.4802 8,15.4802 L17,15.4802 Z M8,5.4802 C7.447,5.4802 7,5.0332 7,4.4802 C7,3.9272 7.447,3.4802 8,3.4802 L13.161,3.4802 L17,3.4802 C17.553,3.4802 18,3.9272 18,4.4802 C18,5.0332 17.553,5.4802 17,5.4802 L13.161,5.4802 L8,5.4802 Z M4.8799,9.9099 C4.9199,9.9999 4.9499,10.0899 4.9699,10.1899 C4.9899,10.2799 4.9999,10.3799 4.9999,10.4799 C4.9999,10.8799 4.8399,11.2609 4.5599,11.5399 C4.4199,11.6809 4.2599,11.7899 4.0689,11.8699 C3.8899,11.9399 3.6999,11.9799 3.4999,11.9799 C3.0999,11.9799 2.7199,11.8199 2.4399,11.5399 C2.1599,11.2609 1.9999,10.8799 1.9999,10.4799 C1.9999,10.3799 2.0099,10.2799 2.0299,10.1899 C2.0499,10.0899 2.0799,9.9999 2.1089,9.9099 C2.1499,9.8199 2.1999,9.7299 2.2499,9.6499 C2.3099,9.5699 2.3699,9.4899 2.4399,9.4199 C2.9999,8.8599 4.0099,8.8599 4.5599,9.4199 C4.6299,9.4899 4.6899,9.5699 4.7499,9.6499 C4.7999,9.7299 4.8499,9.8199 4.8799,9.9099 Z M4.3301,15.2302 C4.4101,15.2902 4.4901,15.3502 4.5591,15.4192 C4.8401,15.7002 5.0001,16.0802 5.0001,16.4802 C5.0001,16.8792 4.8401,17.2502 4.5591,17.5402 C4.4201,17.6802 4.2501,17.7902 4.0691,17.8702 C3.8901,17.9402 3.7001,17.9802 3.5001,17.9802 C3.3001,17.9802 3.1091,17.9402 2.9301,17.8702 C2.7401,17.7902 2.5801,17.6802 2.4391,17.5402 C2.1491,17.2502 2.0001,16.8792 2.0001,16.4802 C2.0001,16.0892 2.1601,15.7002 2.4391,15.4192 C2.5101,15.3502 2.5901,15.2902 2.6701,15.2302 C2.7501,15.1802 2.8401,15.1292 2.9301,15.0892 C3.0191,15.0602 3.1091,15.0302 3.2101,15.0102 C3.3991,14.9702 3.6001,14.9702 3.7901,15.0102 C3.8901,15.0302 3.9791,15.0602 4.0691,15.0892 C4.1601,15.1292 4.2501,15.1802 4.3301,15.2302 Z M2.4395,3.4197 C2.9905,2.8597 4.0095,2.8597 4.5595,3.4197 C4.8395,3.6997 5.0005,4.0897 5.0005,4.4807 C5.0005,4.8797 4.8395,5.2497 4.5595,5.5397 C4.4195,5.6807 4.2595,5.7897 4.0695,5.8697 C3.8895,5.9407 3.7005,5.9807 3.5005,5.9807 C3.2995,5.9807 3.1095,5.9407 2.9195,5.8697 C2.7405,5.7897 2.5805,5.6807 2.4395,5.5397 C2.1495,5.2497 2.0005,4.8797 2.0005,4.4807 C2.0005,4.0897 2.1605,3.6997 2.4395,3.4197 Z"
				}))),
				X = e => {
					let {
						className: t
					} = e;
					return r.a.createElement("svg", {
						className: t,
						xmlns: "http://www.w3.org/2000/svg",
						viewBox: "0 0 20 20"
					}, r.a.createElement("path", {
						d: "M15,12 C15,13.103 14.103,14 13,14 L7,14 C5.897,14 5,13.103 5,12 L5,8 C5,7.886 5.016,7.776 5.033,7.668 L9.063,10.891 C9.339,11.111 9.669,11.222 10,11.222 C10.331,11.222 10.661,11.111 10.938,10.891 L14.967,7.668 C14.984,7.776 15,7.886 15,8 L15,12 Z M7,6 L13,6 C13.619,6 14.167,6.289 14.534,6.732 L10.313,10.109 C10.131,10.254 9.869,10.254 9.688,10.109 L5.466,6.732 C5.833,6.289 6.381,6 7,6 Z M17.274,3.038 L10.274,1.038 C10.095,0.987 9.905,0.987 9.726,1.038 L2.726,3.038 C2.296,3.161 2,3.554 2,4 L2,11 C2,16.688 9.41,18.871 9.726,18.962 C9.815,18.987 9.907,19 10,19 C10.093,19 10.185,18.987 10.274,18.962 C10.59,18.871 18,16.688 18,11 L18,4 C18,3.554 17.704,3.161 17.274,3.038 Z"
					}))
				},
				Y = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, r.a.createElement("path", {
					d: "M6.0156,4.0156 L15.4926,4.0156 C15.6686,4.0156 15.8366,4.0456 15.9996,4.0886 L15.9996,2.9996 C15.9996,2.4476 15.5526,1.9996 14.9996,1.9996 L2.9996,1.9996 C2.4476,1.9996 1.9996,2.4476 1.9996,2.9996 L1.9996,14.9996 C1.9996,15.5526 2.4476,15.9996 2.9996,15.9996 L4.0886,15.9996 C4.0456,15.8366 4.0156,15.6686 4.0156,15.4926 L4.0156,6.0156 C4.0156,4.9116 4.9116,4.0156 6.0156,4.0156 M17,5 C17.553,5 18,5.447 18,6 L18,17 C18,17.553 17.553,18 17,18 L6,18 C5.447,18 5,17.553 5,17 L5,6 C5,5.447 5.447,5 6,5 L17,5 Z M15.5,12 L15.5,8.5 C15.5,8.276 15.352,8.081 15.138,8.02 L11.638,7.02 C11.548,6.994 11.452,6.994 11.362,7.02 L7.862,8.02 C7.648,8.081 7.5,8.276 7.5,8.5 L7.5,12 C7.5,14.845 11.205,15.936 11.362,15.98 C11.407,15.993 11.454,16 11.5,16 C11.546,16 11.593,15.993 11.638,15.98 C11.795,15.936 15.5,14.845 15.5,12 Z"
				})),
				$ = s("./src/reddit/icons/svgs/Rules/index.tsx"),
				ee = s("./src/reddit/icons/svgs/Settings/index.tsx"),
				te = e => {
					let {
						className: t
					} = e;
					return r.a.createElement("svg", {
						className: t,
						xmlns: "http://www.w3.org/2000/svg",
						viewBox: "0 0 20 20"
					}, r.a.createElement("path", {
						d: "M1,8 C1.552,8 2,8.448 2,9 L2,14 C2,14.552 1.552,15 1,15 C0.448,15 0,14.552 0,14 L0,9 C0,8.448 0.448,8 1,8 Z M5.6665,5 C6.2185,5 6.6665,5.448 6.6665,6 L6.6665,14 C6.6665,14.552 6.2185,15 5.6665,15 C5.1145,15 4.6665,14.552 4.6665,14 L4.6665,6 C4.6665,5.448 5.1145,5 5.6665,5 Z M10.3335,3 C10.8855,3 11.3335,3.448 11.3335,4 L11.3335,14 C11.3335,14.552 10.8855,15 10.3335,15 C9.7815,15 9.3335,14.552 9.3335,14 L9.3335,4 C9.3335,3.448 9.7815,3 10.3335,3 Z M15,0 C15.552,0 16,0.448 16,1 L16,14 C16,14.552 15.552,15 15,15 C14.448,15 14,14.552 14,14 L14,1 C14,0.448 14.448,0 15,0 Z"
					}))
				},
				se = s("./src/reddit/icons/svgs/Tag/index.tsx"),
				ne = s("./src/reddit/icons/svgs/User/index.tsx"),
				oe = s("./src/reddit/routes/moderationPages/index.ts"),
				ae = s("./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx"),
				re = s("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				ie = s.n(re);

			function de() {
				return (de = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var le = e => r.a.createElement("div", de({
					className: Object(l.a)(ie.a.breadcrumb, e.className)
				}, e), r.a.createElement("button", {
					className: ie.a.breadcrumbButton
				}, r.a.createElement(ae.a, null), p.fbt._("Back to mod tools", null, {
					hk: "4udiKO"
				}))),
				ce = s("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				me = s("./src/higherOrderComponents/asModal/index.tsx"),
				ue = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				pe = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				be = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				he = s("./src/reddit/constants/wiki.ts"),
				ge = s("./src/reddit/controls/Button/index.tsx"),
				fe = s("./src/reddit/controls/TextButton/index.tsx"),
				xe = s("./src/reddit/helpers/wiki/buildWikiPagesTree.ts"),
				Ee = s("./src/reddit/helpers/wiki/validatePageName.ts"),
				ve = s("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				Ce = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				_e = (s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./src/reddit/controls/Dropdown/index.tsx")),
				ke = s("./src/reddit/controls/Dropdown/Row.tsx"),
				Oe = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				ye = s("./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less"),
				je = s.n(ye);
			class we extends r.a.Component {
				constructor(e) {
					super(e), this.onToggleDropdown = () => {
						this.setState({
							isDropdownOpen: !this.state.isDropdownOpen
						})
					}, this.onSelectParentPage = e => {
						this.props.onSelectParentPage(e), this.onToggleDropdown()
					}, this.state = {
						isDropdownOpen: !1
					}
				}
				render() {
					const {
						pageTree: e,
						parentPageName: t
					} = this.props, {
						isDropdownOpen: s
					} = this.state, n = p.fbt._("None", null, {
						hk: "3FT0YQ"
					});
					return r.a.createElement("div", {
						className: je.a.dropdownContainer
					}, r.a.createElement("button", {
						className: je.a.dropdownTarget,
						onClick: this.onToggleDropdown
					}, r.a.createElement("div", {
						className: je.a.targetText
					}, t || n), r.a.createElement(Oe.b, null)), s && r.a.createElement(_e.a, {
						className: je.a.dropdown
					}, r.a.createElement(ke.b, {
						className: je.a.dropdownRow,
						displayText: n,
						onClick: () => this.onSelectParentPage(void 0)
					}), e.map(e => e.depth >= he.c ? null : he.f.has(e.path.split("/")[0]) ? null : r.a.createElement(ke.b, {
						className: je.a.dropdownRow,
						displayText: e.path,
						key: e.path,
						onClick: () => this.onSelectParentPage(e.path)
					}))))
				}
			}
			var Se = we;
			const Ie = e => {
				switch (e) {
					case Ee.a.InvalidPageName:
						return p.fbt._("Invalid page name", null, {
							hk: "1gQvCb"
						});
					case Ee.a.MaxLengthExceed:
						return p.fbt._("Name exceeds character limit", null, {
							hk: "RDoIC"
						});
					case Ee.a.PageAlreadyExists:
						return p.fbt._("That page already exists", null, {
							hk: "xEyyR"
						});
					case Ee.a.RestrictedPageName:
						return p.fbt._("Restricted page name", null, {
							hk: "Bjv5o"
						})
				}
			};
			class Pe extends r.a.Component {
				constructor(e) {
					super(e), this.onChangePageName = e => {
						this.setState({
							partialPageName: e.currentTarget.value
						})
					}, this.onSelectParentPage = e => {
						this.setState({
							parentPageName: e
						})
					}, this.getNewPagePath = () => {
						let e = "";
						return this.state.parentPageName && (e += "".concat(this.state.parentPageName, "/")), (e += "".concat(this.state.partialPageName)).toLowerCase()
					}, this.state = {
						partialPageName: "",
						parentPageName: void 0
					}
				}
				hasError() {
					const {
						pageTree: e
					} = this.props, {
						partialPageName: t
					} = this.state;
					return Object(Ee.c)(t) || Object(Ee.b)(this.getNewPagePath(), e)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = this.hasError();
					return r.a.createElement(pe.d, {
						className: je.a.modalBody
					}, r.a.createElement(pe.h, null, r.a.createElement(Ce.a, null, r.a.createElement(pe.p, null, p.fbt._("Create a new wiki page", null, {
						hk: "V7Jnm"
					})), r.a.createElement(fe.a, {
						onClick: e.toggleModal
					}, r.a.createElement(pe.b, null)))), r.a.createElement("div", {
						className: je.a.notice
					}, r.a.createElement(ve.a, null), p.fbt._("Parent page and page URL cannot be edited once created", null, {
						hk: "20D6uz"
					})), r.a.createElement(pe.k, null, r.a.createElement("div", {
						className: je.a.sectionTitle
					}, p.fbt._("Parent page", null, {
						hk: "1FeKiT"
					})), r.a.createElement(Se, {
						onSelectParentPage: this.onSelectParentPage,
						pageTree: Object(xe.b)(e.pageTree || []),
						parentPageName: t.parentPageName
					}), r.a.createElement("div", {
						className: je.a.sectionTitle
					}, p.fbt._("Page URL", null, {
						hk: "WL8sn"
					})), r.a.createElement(be.d, {
						placeholder: p.fbt._("ex: rules", null, {
							hk: "J0qH1"
						}),
						onChange: this.onChangePageName,
						value: t.partialPageName
					}), r.a.createElement(ue.a, {
						text: this.getNewPagePath(),
						maxChars: he.d
					}), r.a.createElement("div", {
						className: je.a.errorText
					}, t.partialPageName && s ? Ie(s) : null)), r.a.createElement(pe.f, null, r.a.createElement(pe.a, {
						onClick: e.toggleModal
					}, p.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(ge.h, {
						disabled: !t.partialPageName || !!s,
						className: je.a.primaryButton,
						to: "".concat(e.subredditUrl, "about/wiki/create/").concat(this.getNewPagePath())
					}, p.fbt._("Create", null, {
						hk: "2W0PL1"
					}))))
				}
			}
			var Te = Object(me.a)(Pe),
				Ne = s("./src/reddit/selectors/activeModalId.ts"),
				Me = s("./src/reddit/selectors/subredditWiki.ts"),
				Re = s("./node_modules/lodash/times.js"),
				Le = s.n(Re),
				Ae = s("./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less"),
				Fe = s.n(Ae);
			class De extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.containerRef = r.a.createRef()
				}
				componentDidMount() {
					this.scrollToActiveItemIfNeeded()
				}
				scrollToActiveItemIfNeeded() {
					const e = this.containerRef.current,
						t = e && e.getElementsByClassName(Fe.a.mActive)[0];
					if (!e || !t) return;
					const s = e.getBoundingClientRect(),
						n = t.getBoundingClientRect();
					n.top >= s.top && n.bottom <= s.bottom || t.scrollIntoView()
				}
				render() {
					const {
						activePageName: e,
						baseUrl: t,
						directory: s
					} = this.props, n = Object(xe.b)(s && s.pageTree || []);
					return r.a.createElement("div", {
						ref: this.containerRef,
						className: Fe.a.contentTree
					}, n.map(s => {
						const n = s.path === e;
						return r.a.createElement(v.a, {
							key: s.path,
							className: Fe.a.pageNavLink,
							to: "".concat(t, "/").concat(s.path)
						}, r.a.createElement("div", {
							className: Object(l.a)(Fe.a.pageNavItem, {
								[Fe.a.mActive]: n,
								[Fe.a.mExists]: s.isPagePresent
							})
						}, Le()(s.depth, () => r.a.createElement("div", {
							className: Fe.a.indentLine
						})), r.a.createElement("span", {
							className: Fe.a.itemText
						}, "/".concat(s.name))))
					}))
				}
			}
			const Be = Object(d.c)({
				directory: (e, t) => Object(Me.b)(e, {
					subredditName: t.subreddit.name
				}),
				isCreateWikiPageModalOpen: e => "CreateWikiPageModal" === Object(Ne.a)(e)
			});
			class Ue extends r.a.Component {
				constructor() {
					super(...arguments), this.onToggleCreateWikiModal = () => {
						this.props.toggleCreateWikiModal()
					}
				}
				render() {
					const {
						directory: e,
						isCreateWikiPageModalOpen: t,
						subreddit: s,
						toggleCreateWikiModal: n,
						pageLayer: o
					} = this.props;
					if (!o) return null;
					const {
						urlParams: a
					} = o, {
						wikiPageName: i,
						wikiSubRoute: d,
						pageName: l
					} = a;
					return r.a.createElement("div", {
						className: Fe.a.wikiNavPanel
					}, r.a.createElement(ge.f, {
						className: Fe.a.primaryButton,
						onClick: this.onToggleCreateWikiModal
					}, p.fbt._("Create new page", null, {
						hk: "35WDuL"
					})), r.a.createElement(De, {
						activePageName: i,
						baseUrl: "".concat(s.url, "about/wiki"),
						directory: e
					}), r.a.createElement("div", {
						className: Fe.a.footer
					}, r.a.createElement(ce.b, {
						isActive: d === he.m.Revisions && !i,
						label: p.fbt._("Recent wiki revisions", null, {
							hk: "278VnD"
						}),
						path: "".concat(s.url, "about/wiki/revisions")
					}), r.a.createElement(ce.b, {
						isActive: l === h.Pb.WikiContributors,
						label: p.fbt._("Add wiki contributors", null, {
							hk: "1XHd90"
						}),
						path: "".concat(s.url, "about/wikicontributors")
					}), r.a.createElement(ce.b, {
						isActive: l === h.Pb.WikiBanned,
						label: p.fbt._("Ban wiki contributors", null, {
							hk: "3IVNKp"
						}),
						path: "".concat(s.url, "about/wikibanned")
					}), r.a.createElement(ce.b, {
						label: p.fbt._("Wiki settings", null, {
							hk: "1Jctxf"
						}),
						path: "".concat(s.url, "about/edit?page=wikis")
					})), t && r.a.createElement(Te, {
						pageTree: e && e.pageTree,
						subredditUrl: s.url,
						toggleModal: n,
						withOverlay: !0
					}))
				}
			}
			var He = Object(E.t)()(Object(i.b)(Be, e => ({
				toggleCreateWikiModal: () => e(Object(W.i)("CreateWikiPageModal"))
			}))(Ue));
			const We = Object(d.c)({
				isBadgesEnabled: q.d.spCustomBadges,
				isEligibleForCommunityAwards: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(C.a)(s)
				},
				isEmotesEnabled: q.d.spEmotesModTools,
				isUsingNewModMail: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(P.o)(e, {
						subredditId: s.id
					})
				},
				isEligibleForScheduledPosts: q.d.scheduledPosts,
				isStreamingEnabled: I.a
			});
			class Ve extends r.a.Component {
				constructor(e, t) {
					super(e, t), this.trackClick = e => this.props.sendEvent(y.b(e)), this.trackCommunitySettingsNavItemClick = e => this.props.sendEvent(Object(K.a)(e)), this.onClickAwards = () => this.trackClick("awards"), this.onClickStreaming = () => this.trackClick("streaming"), this.onClickModQueue = () => this.trackClick("mod_queue"), this.onClickReports = () => this.trackClick("reports"), this.onClickSpam = () => this.trackClick("spam"), this.onClickEdited = () => this.trackClick("edited"), this.onClickUnmoderated = () => this.trackClick("unmoderated"), this.onClickBannedUsers = () => this.trackClick("ban_users"), this.onClickMutedUsers = () => this.trackClick("mute_users"), this.onClickApprovedSubmitters = () => this.trackClick("approved_submitters"), this.onClickEmojis = () => this.trackClick("emoji"), this.onClickModerators = () => this.trackClick("moderators"), this.onClickManageChatrooms = () => {
						this.props.toggleManageChatroomsModal(), this.trackClick("manage_chatrooms")
					}, this.onClickChatSettings = () => this.trackClick("chat_settings"), this.onClickCommunitySettings = () => this.trackClick("community_settings"), this.onClickCommunityAppearance = () => this.trackClick("community_appearance"), this.onClickModMail = () => {
						const e = this.props.isUsingNewModMail ? "mod_mail" : "old_modmail";
						this.trackClick(e)
					}, this.onClickRemovalReasons = () => this.trackClick("removal_reasons"), this.onClickRules = () => this.trackClick("rules"), this.onClickPostRequirements = () => this.trackClick("post_requirements"), this.onClickAutomodConfig = () => this.trackClick("automod_config"), this.onClickWikiPages = () => this.trackClick("wiki"), this.onClickTraffic = () => this.trackClick("traffic"), this.onClickModLog = () => this.trackClick("mod_log"), this.onClickModSupport = () => this.trackClick("r_mod_support"), this.onClickModHelp = () => this.trackClick("mod_help"), this.onClickContactReddit = () => this.trackClick("contact_reddit"), this.onClickModGuidelines = () => this.trackClick("mod_guidelines"), this.onClickModHelpCenter = () => this.trackClick("mod_help_center"), this.onClickPostFlair = () => this.trackClick("post_flair"), this.onClickUserFlair = () => this.trackClick("user_flair"), this.onClickGrantUserFlair = () => this.trackClick("grant_user_flair"), this.onClickBadges = () => this.trackClick("badges"), this.onClickEmotes = () => this.trackClick("emotes"), this.onClickScheduledPosts = () => this.props.sendEvent(Object(z.o)()), this.onClickEventPosts = () => this.props.sendEvent(Object(z.h)()), this.onGoToModHub = () => {
						const e = this.props.moderatorPermissions && this.props.moderatorPermissions.posts,
							t = "".concat(this.props.subreddit.url, "about/"),
							s = e ? "".concat(t, "modqueue") : t;
						this.props.pushUrl(s)
					}, this.state = {
						locationSettingSeen: !0
					}
				}
				componentDidMount() {
					this.setState({
						locationSettingSeen: Object(G.t)("location")
					})
				}
				render() {
					const {
						props: e
					} = this;
					switch (e.pageName) {
						case h.Pb.CommunitySettings: {
							const t = !e.subpageName || !Object.values(h.Qb).includes(e.subpageName);
							return r.a.createElement("div", {
								className: ie.a.navContainer
							}, r.a.createElement(le, {
								onClick: this.onGoToModHub
							}), r.a.createElement(ce.b, {
								label: p.fbt._("Community", null, {
									hk: "1EIoJe"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Qb.Community),
								isNew: !this.state.locationSettingSeen,
								path: "".concat(e.subreddit.url, "about/edit?page=community"),
								isActive: t || e.subpageName === h.Qb.Community
							}), r.a.createElement(ce.b, {
								label: p.fbt._("Safety and Privacy", null, {
									hk: "3E0TnI"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Qb.Safety),
								path: "".concat(e.subreddit.url, "about/edit?page=safety"),
								isActive: e.subpageName === h.Qb.Safety
							}), r.a.createElement(ce.b, {
								label: p.fbt._("Posts and Comments", null, {
									hk: "2jt4ea"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Qb.Posts),
								path: "".concat(e.subreddit.url, "about/edit?page=posts"),
								isActive: e.subpageName === h.Qb.Posts
							}), r.a.createElement(ce.b, {
								label: p.fbt._("Wikis", null, {
									hk: "2X1iz1"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Qb.Wikis),
								path: "".concat(e.subreddit.url, "about/edit?page=wikis"),
								isActive: e.subpageName === h.Qb.Wikis
							}))
						}
						case h.Pb.Wiki:
						case h.Pb.WikiContributors:
						case h.Pb.WikiBanned:
							return r.a.createElement("div", {
								className: Object(l.a)(ie.a.navContainer, ie.a.wikiNavContainer)
							}, r.a.createElement(le, {
								onClick: this.onGoToModHub
							}), e.moderatorPermissions.wiki && r.a.createElement(He, {
								subreddit: e.subreddit
							}));
						default:
							return r.a.createElement("div", {
								className: ie.a.navContainer
							}, e.moderatorPermissions.posts && r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(Y, {
								className: ie.a.iconStyles
							}), p.fbt._("Queues", null, {
								hk: "2BbIZV"
							})), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Modqueue,
								label: g(h.Pb.Modqueue),
								onClick: this.onClickModQueue,
								path: "".concat(e.subreddit.url, "about/modqueue")
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Reports,
								label: g(h.Pb.Reports),
								onClick: this.onClickReports,
								path: "".concat(e.subreddit.url, "about/reports")
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Spam,
								label: g(h.Pb.Spam),
								onClick: this.onClickSpam,
								path: "".concat(e.subreddit.url, "about/spam")
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Edited,
								label: g(h.Pb.Edited),
								onClick: this.onClickEdited,
								path: "".concat(e.subreddit.url, "about/edited")
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Unmoderated,
								label: g(h.Pb.Unmoderated),
								onClick: this.onClickUnmoderated,
								path: "".concat(e.subreddit.url, "about/unmoderated")
							})), r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(ne.a, {
								className: ie.a.iconStyles
							}), p.fbt._("User management", null, {
								hk: "3G4BgD"
							})), e.moderatorPermissions.access && r.a.createElement(r.a.Fragment, null, r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Banned,
								label: g(h.Pb.Banned),
								onClick: this.onClickBannedUsers,
								path: "".concat(e.subreddit.url, "about/banned")
							}), e.moderatorPermissions.mail && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Muted,
								label: g(h.Pb.Muted),
								onClick: this.onClickMutedUsers,
								path: "".concat(e.subreddit.url, "about/muted")
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Contributors,
								label: g(h.Pb.Contributors),
								onClick: this.onClickApprovedSubmitters,
								path: "".concat(e.subreddit.url, "about/contributors")
							})), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Moderators,
								label: g(h.Pb.Moderators),
								onClick: this.onClickModerators,
								path: "".concat(e.subreddit.url, "about/moderators")
							})), (e.moderatorPermissions.flair || e.moderatorPermissions.config) && r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(se.a, {
								className: ie.a.iconStyles
							}), e.isBadgesEnabled ? p.fbt._("Badges, flair & emojis", null, {
								hk: "1FuDnm"
							}) : p.fbt._("Flair & emojis", null, {
								hk: "42b2AJ"
							})), e.moderatorPermissions.flair && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Flair,
								label: g(h.Pb.Flair),
								onClick: this.onClickGrantUserFlair,
								path: "".concat(e.subreddit.url, "about/flair")
							}), e.moderatorPermissions.config && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Emojis,
								label: g(h.Pb.Emojis),
								onClick: this.onClickEmojis,
								path: "".concat(e.subreddit.url, "about/emojis")
							}), e.moderatorPermissions.flair && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.UserFlair,
								label: g(h.Pb.UserFlair),
								onClick: this.onClickUserFlair,
								path: "".concat(e.subreddit.url, "about/userflair")
							}), e.moderatorPermissions.flair && e.moderatorPermissions.config && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.PostFlair,
								label: g(h.Pb.PostFlair),
								onClick: this.onClickPostFlair,
								path: "".concat(e.subreddit.url, "about/postflair")
							}), e.isBadgesEnabled && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Badges,
								label: g(h.Pb.Badges),
								onClick: this.onClickBadges,
								path: "".concat(e.subreddit.url, "about/badges")
							}), e.isEmotesEnabled && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Emotes,
								label: g(h.Pb.Emotes),
								onClick: this.onClickEmotes,
								path: "".concat(e.subreddit.url, "about/emotes")
							})), (e.moderatorPermissions.config || e.moderatorPermissions.posts) && r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement($.a, {
								className: ie.a.iconStyles
							}), p.fbt._("Rules and regulations", null, {
								hk: "QAksk"
							})), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.SubredditRules,
								label: g(h.Pb.SubredditRules),
								onClick: this.onClickRules,
								path: "".concat(e.subreddit.url, "about/rules")
							}), e.moderatorPermissions.posts && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Removal,
								label: g(h.Pb.Removal),
								onClick: this.onClickRemovalReasons,
								path: "".concat(e.subreddit.url, "about/removal")
							}), e.moderatorPermissions.config && r.a.createElement(r.a.Fragment, null, r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.PostRequirements,
								label: g(h.Pb.PostRequirements),
								onClick: this.onClickPostRequirements,
								path: "".concat(e.subreddit.url, "about/settings")
							}), r.a.createElement(ce.b, {
								label: p.fbt._("Automod", null, {
									hk: "1IngsO"
								}),
								onClick: this.onClickAutomodConfig,
								path: "".concat(e.subreddit.url, "about/wiki/config/automoderator")
							}))), e.isEligibleForScheduledPosts && r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(Z, {
								className: ie.a.iconStyles
							}), p.fbt._("Content", null, {
								hk: "IAh5R"
							})), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.ScheduledPostContent,
								label: p.fbt._("Scheduled posts", null, {
									hk: "11S6dN"
								}),
								onClick: this.onClickScheduledPosts,
								path: Object(oe.d)(e.subreddit.displayText),
								isBeta: !0
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.EventPostContent,
								label: p.fbt._("Event posts", null, {
									hk: "3D98hc"
								}),
								onClick: this.onClickEventPosts,
								path: Object(oe.b)(e.subreddit.displayText),
								isBeta: !0
							})), (e.moderatorPermissions.config || e.moderatorPermissions.wiki) && r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(ee.a, {
								className: ie.a.iconStyles
							}), p.fbt._("Other", null, {
								hk: "ST5RE"
							})), e.isEligibleForCommunityAwards && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Awards,
								label: p.fbt._("Awards", null, {
									hk: "48U4Du"
								}),
								onClick: this.onClickAwards,
								path: "".concat(e.subreddit.url, "about/awards"),
								isNew: !0
							}), e.moderatorPermissions.config && e.isStreamingEnabled && r.a.createElement(ce.b, {
								label: g(h.Pb.Streaming),
								onClick: this.onClickStreaming,
								path: "".concat(e.subreddit.url, "about/streaming"),
								isNew: !0
							}), e.moderatorPermissions.wiki && r.a.createElement(ce.b, {
								label: p.fbt._("Wiki pages", null, {
									hk: "wShFl"
								}),
								onClick: this.onClickWikiPages,
								path: "".concat(U.a.redditUrl).concat(e.subreddit.url, "about/wiki/index")
							}), e.moderatorPermissions.config && r.a.createElement(ce.b, {
								label: p.fbt._("Community settings", null, {
									hk: "2xOUK6"
								}),
								onClick: this.onClickCommunitySettings,
								isNew: !this.state.locationSettingSeen,
								path: "".concat(e.subreddit.url, "about/edit?page=community"),
								showInboundArrow: !0
							}), e.moderatorPermissions.config && r.a.createElement(ce.b, {
								label: p.fbt._("Community appearance", null, {
									hk: "3AHttA"
								}),
								path: "".concat(e.subreddit.url, "?styling=true"),
								onClick: this.onClickCommunityAppearance,
								showInboundArrow: !0
							})), e.moderatorPermissions.mail && r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(X, {
								className: ie.a.iconStyles
							}), p.fbt._("Modmail", null, {
								hk: "Eh4Vu"
							})), r.a.createElement(ce.b, {
								isExternal: !0,
								label: p.fbt._("Modmail", null, {
									hk: "3Xkgqo"
								}),
								onClick: this.onClickModMail,
								path: e.isUsingNewModMail ? "https://mod.reddit.com" : "".concat(U.a.redditUrl, "/message/moderator/")
							})), r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(Q.a, {
								className: ie.a.iconStyles
							}), p.fbt._("Chat", null, {
								hk: "4mJ2vR"
							})), r.a.createElement(ce.b, {
								label: p.fbt._("Manage chatrooms", null, {
									hk: "3TLjjv"
								}),
								onClick: this.onClickManageChatrooms
							}), e.moderatorPermissions.config && r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.ChatSettings,
								label: g(h.Pb.ChatSettings),
								onClick: this.onClickChatSettings,
								path: "".concat(e.subreddit.url, "about/chat"),
								isNew: !0
							})), r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(te, {
								className: ie.a.iconStyles
							}), p.fbt._("Community activity", null, {
								hk: "1vGSer"
							})), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Traffic,
								label: p.fbt._("Traffic stats", null, {
									hk: "vw5CU"
								}),
								onClick: this.onClickTraffic,
								path: "".concat(e.subreddit.url, "about/traffic")
							}), r.a.createElement(ce.b, {
								isActive: e.pageName === h.Pb.Modlog,
								label: g(h.Pb.Modlog),
								onClick: this.onClickModLog,
								path: "".concat(e.subreddit.url, "about/log")
							})), r.a.createElement("div", {
								className: ie.a.navSection
							}, r.a.createElement("div", {
								className: ie.a.sectionHeader
							}, r.a.createElement(J.a, {
								className: ie.a.iconStyles
							}), p.fbt._("Mod help center", null, {
								hk: "256YE"
							})), r.a.createElement(ce.b, {
								isExternal: !0,
								label: p.fbt._("Mod help center", null, {
									hk: "4dCwWU"
								}),
								onClick: this.onClickModHelpCenter,
								path: U.a.redditHelpUrl.modHelpCenter
							}), r.a.createElement(ce.b, {
								isExternal: !0,
								label: p.fbt._("Moderator guidelines", null, {
									hk: "3marKI"
								}),
								onClick: this.onClickModGuidelines,
								path: "https://www.reddit.com/help/healthycommunities/"
							}), r.a.createElement(ce.b, {
								isExternal: !0,
								label: "r/ModSupport",
								onClick: this.onClickModSupport,
								path: "/r/ModSupport/"
							}), r.a.createElement(ce.b, {
								isExternal: !0,
								label: "r/ModHelp",
								onClick: this.onClickModHelp,
								path: "/r/modhelp/"
							}), r.a.createElement(ce.b, {
								isExternal: !0,
								label: p.fbt._("Contact Reddit", null, {
									hk: "2NRBBx"
								}),
								onClick: this.onClickContactReddit,
								path: "https://www.reddithelp.com/en/submit-request/rusername"
							})))
					}
				}
			}
			var qe = Object(i.b)(We, e => ({
					toggleManageChatroomsModal: () => e(Object(W.i)(V.a.MANAGE_SUBREDDIT_CHAT)),
					pushUrl: t => e(Object(H.b)(t))
				}))(Object(x.c)(Ve)),
				Ge = s("./src/reddit/pages/ModHub/index.m.less"),
				Ke = s.n(Ge);
			const ze = m.a.div("BackgroundContainer", Ke.a),
				Qe = m.a.wrapped(v.a, "SubredditLink", Ke.a),
				Je = m.a.div("Header", Ke.a),
				Ze = m.a.wrapped(f.b, "SubredditIcon", Ke.a),
				Xe = m.a.div("Body", Ke.a),
				Ye = Object(d.c)({
					contentGateInfo: (e, t) => Object(T.e)(e, t.match.params.subredditName)
				}),
				$e = Object(d.c)({
					queryParams: (e, t) => {
						let {
							location: s
						} = t;
						return o()([...Object(c.a)(s.search)])
					}
				}),
				et = Object(d.c)({
					moderatorPermissions: (e, t) => {
						const s = Object(P.F)(e, t.match.params.subredditName);
						if (s) return Object(w.j)(e, {
							subredditId: s
						})
					}
				}),
				tt = Object(d.c)({
					subreddit: (e, t) => Object(P.A)(e, {
						subredditName: t.match.params.subredditName
					})
				}),
				st = Object(i.b)(() => Object(d.a)(Ye, T.E, I.a, E.N, et, T.V, S.Z, tt, $e, (e, t) => t.match.params.pageName, (e, t, s, n, o, a, r, i, d, l) => {
					let {
						contentGateInfo: c
					} = e, {
						moderatorPermissions: m
					} = o, {
						subreddit: u
					} = i, {
						queryParams: p
					} = d;
					const {
						after: b,
						afterEditable: h,
						before: g,
						beforeEditable: f,
						only: x,
						page: E
					} = p;
					return {
						contentGateInfo: c,
						isEligibleForCommunityAwards: Object(C.a)(u),
						isEmployee: t,
						isStreamingEnabled: s,
						layout: n,
						moderatorPermissions: m,
						isScheduledPostsEnabled: r,
						subreddit: u,
						renderNSFWContentGate: u && u.isNSFW && !a,
						page: "".concat(E || j.b),
						pageName: l,
						postTypeFilter: x,
						after: b || "",
						afterEditable: h,
						before: g,
						beforeEditable: f
					}
				})),
				nt = Object(E.t)();
			class ot extends r.a.Component {
				constructor() {
					super(...arguments), this.sendEventWithName = e => () => {
						this.props.sendEvent(t => ({
							source: Object(O.b)(this.props.pageName),
							action: "click",
							noun: e
						}))
					}, this.onClickSubredditLink = () => {
						this.props.sendEvent(y.c())
					}
				}
				componentDidUpdate(e) {
					(this.props.pageName && this.props.pageName !== e.pageName || this.props.page && this.props.page !== e.page) && (document.documentElement.scrollTop = document.body.scrollTop = 0)
				}
				render() {
					const {
						props: e
					} = this;
					if (!e.subreddit) {
						const t = Object(k.a)(e.contentGateInfo, e.renderNSFWContentGate, e.match.params.subredditName);
						return t ? r.a.createElement(u.default, t) : null
					}
					const t = !!e.moderatorPermissions;
					return r.a.createElement(ze, null, r.a.createElement(Je, null, r.a.createElement(Ze, {
						subredditOrProfile: e.subreddit
					}), r.a.createElement(Qe, {
						to: e.subreddit.url,
						onClick: this.onClickSubredditLink
					}, e.subreddit.displayText), e.pageName && "/ ".concat(g(e.pageName))), r.a.createElement(Xe, null, e.moderatorPermissions && r.a.createElement(qe, {
						moderatorPermissions: e.moderatorPermissions,
						pageName: e.pageName,
						subpageName: e.page,
						subreddit: e.subreddit
					}), r.a.createElement("div", {
						className: Object(l.a)(Ke.a.contentWrapper, t && Ke.a.isModerator)
					}, e.pageName && Object(_.a)(e.pageName, e.moderatorPermissions, e.isEligibleForCommunityAwards, e.isScheduledPostsEnabled, e.isEmployee, e.isStreamingEnabled) ? r.a.createElement(N.a, {
						after: e.after,
						afterEditable: e.afterEditable,
						before: e.before,
						beforeEditable: e.beforeEditable,
						layout: e.layout,
						moderatorPermissions: e.moderatorPermissions,
						page: e.page,
						pageName: e.pageName,
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: this.sendEventWithName,
						subpageName: e.page,
						subreddit: e.subreddit
					}) : e.moderatorPermissions ? r.a.createElement(B, {
						subredditDisplayText: e.subreddit.displayText
					}) : r.a.createElement(M.a, {
						isModerator: t,
						subredditDisplayText: e.subreddit.displayText
					}))))
				}
			}
			t.default = nt(st(Object(x.c)(ot)))
		},
		"./src/reddit/pages/SubredditCreation/Layout/index.m.less": function(e, t, s) {
			e.exports = {
				Sidebar: "_21QIcELhFLJ4T6uOUKqej7",
				sidebar: "_21QIcELhFLJ4T6uOUKqej7",
				isOverlay: "_3JejK3woZKuE7psWYzZMk-",
				Content: "_2wEvMk0HNO1vMRXR89R4YE",
				content: "_2wEvMk0HNO1vMRXR89R4YE",
				Container: "_3rOOumzhn2kQeSbQA1BtJI",
				container: "_3rOOumzhn2kQeSbQA1BtJI",
				OuterContainer: "_1t_20Pp0ozZf5JHADFW277",
				outerContainer: "_1t_20Pp0ozZf5JHADFW277"
			}
		},
		"./src/reddit/pages/SubredditCreation/index.m.less": function(e, t, s) {
			e.exports = {
				sublabel: "_3iEQMbJzyCJP7q0YQLg6j4",
				subtitle: "_1NkQ5U2m0s_6vOfhCgiIgT",
				radioDescription: "_2VfO_j9K0NqNwA6JyAl8Dk",
				buttonContainer: "rktXqe6ilbY86M7UI5N0",
				isOverlay: "_2-RGOjReVDKqocc0lhfKCD",
				field: "lzEa7-AzGmC9abTt7-RJG",
				isCreatePending: "_3rxpxb7pMWAbGQ6_JA_my7",
				subredditCreation: "_3eSVsnKJOqAQo-ixxTeJcl",
				container: "_2oaybRT7snUp8XlyHlRiSP",
				title: "_19pYcIVThkZW5KMHTi8qsc",
				nsfw: "_hnZsl3c6qOjy4qOD9r0R",
				createButton: "rJOmFCS_DMZSRltlKtpyt",
				pendingText: "oXus6jwjzhkeznWdE45YL",
				metaFieldDescription: "fd5WCBCH7kTLTlNepW054",
				numCommunityTopicsSelected: "_1QES7ND3zudXR2epk08OVa",
				subtextContainer: "_1V23LtWm6tqb0xlD1Xkh-W",
				radioContainer: "_3qUROz4qvkxCG-oEJTkW3x",
				radioContent: "luCqkz2vQaP-L_NeDD98b",
				fullWidthTextContainer: "_2jvToia6nJCdTHqp_Tw_fp",
				Info: "cP738yi9DxlBmCQTtFLop",
				info: "cP738yi9DxlBmCQTtFLop",
				RadioOption: "_2uqw2bfrk5pQeRVMtPVRUR",
				radioOption: "_2uqw2bfrk5pQeRVMtPVRUR",
				StyledTooltip: "_3mMji3dmYN3jsQ2Ri0owBm",
				styledTooltip: "_3mMji3dmYN3jsQ2Ri0owBm",
				Public: "_3fiOvK-VXqZ9cZO0d912xA",
				public: "_3fiOvK-VXqZ9cZO0d912xA",
				RadioIcon: "_1vr9rsoGcISz-S6s7p_6s-",
				radioIcon: "_1vr9rsoGcISz-S6s7p_6s-",
				Restricted: "_3RYKKCLydFkeZVJov0xebO",
				restricted: "_3RYKKCLydFkeZVJov0xebO",
				Private: "_19fLjAFVy42ZR2vocDvgUW",
				private: "_19fLjAFVy42ZR2vocDvgUW",
				Employee: "ExNY0v88NVrkWCfrt55XJ",
				employee: "ExNY0v88NVrkWCfrt55XJ",
				CloseButton: "_1I-ULJ_Pqw5ZwVbFuh5I6W",
				closeButton: "_1I-ULJ_Pqw5ZwVbFuh5I6W",
				ErrorText: "_2ay6MX8oi5mY0chgCSBVHO",
				errorText: "_2ay6MX8oi5mY0chgCSBVHO"
			}
		},
		"./src/reddit/pages/SubredditCreation/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "radioOptions", (function() {
				return be
			}));
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-redux/es/index.js"),
				d = s("./node_modules/reselect/es/index.js"),
				l = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/formatApiError/index.ts"),
				m = s("./src/reddit/actions/subredditCreation.ts"),
				u = s("./src/reddit/actions/tooltip.ts"),
				p = (s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./src/reddit/actions/tags/index.ts")),
				b = s("./src/reddit/actions/toaster.ts"),
				h = s("./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx"),
				g = s("./src/reddit/components/MultiOptionSelect/index.tsx"),
				f = s("./src/reddit/models/Tags/index.ts"),
				x = s("./src/reddit/models/Toast/index.ts"),
				E = s("./src/reddit/selectors/tags.ts"),
				v = s("./src/reddit/components/CommunityTopics/index.m.less"),
				C = s.n(v);
			const _ = Object(d.c)({
				availableGlobalOptions: E.f,
				selectedOptions: E.k,
				isLoading: E.E,
				currentInput: E.g,
				selectedPrimaryTag: E.y,
				hasSecondaryTags: E.q
			});
			class k extends a.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							s = e.filter(e => !e.selected);
						this.onOptionsSelected(t), s.forEach(e => this.onOptionDeselected(e))
					}
				}
				onOptionsSelected(e) {
					const t = f.a - this.props.selectedOptions.length,
						s = e.filter(e => !!e.displayText.trim()),
						n = s.slice(0, t);
					n.forEach(e => {
						this.props.optionSelected(Object.assign({}, e, {
							displayText: e.displayText.trim()
						}))
					}), n.length !== s.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(Object.assign({}, e, {
						displayText: e.displayText.trim()
					}))
				}
				render() {
					return a.a.createElement("div", {
						className: C.a.communityTopicsContainer
					}, a.a.createElement(h.a, null), (!!this.props.selectedPrimaryTag || this.props.hasSecondaryTags) && a.a.createElement(g.a, {
						addText: n.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						dropdownHeaderText: n.fbt._("Suggested topics", null, {
							hk: "1qNrZC"
						}),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > f.a,
						isLoading: this.props.isLoading,
						maxOptionLength: f.b,
						onSearchBarFocus: this.props.onSearchBarFocused,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						splitOnCommaPress: !0
					}))
				}
			}
			var O = Object(r.b)(_, e => ({
					optionSelected: t => {
						e(Object(p.c)({
							option: t
						}))
					},
					optionDeselected: t => {
						e(Object(p.b)({
							option: t
						}))
					},
					onInputChanged: t => e(Object(p.a)({
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(b.e)(Object.assign({}, Object(b.d)(n.fbt._("You can only add up to {max number of topics} community topics", [n.fbt._param("max number of topics", f.a.toString())], {
							hk: "1OySAh"
						}), x.b.Error), {
							duration: b.a
						})))
					})
				}))(k),
				y = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				j = s("./src/reddit/components/Settings/shared/Widgets.tsx"),
				w = s("./src/reddit/components/TrackingHelper/index.tsx"),
				S = s("./src/reddit/constants/history.ts"),
				I = s("./src/reddit/contexts/InsideOverlay.tsx"),
				P = s("./src/reddit/controls/Button/index.tsx"),
				T = s("./src/reddit/controls/CheckboxInput/index.tsx"),
				N = s("./src/reddit/controls/ErrorText/index.tsx"),
				M = s("./src/reddit/controls/RadioInput/index.tsx"),
				R = s("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				L = s("./src/reddit/helpers/trackers/screenview.ts"),
				A = s("./src/reddit/helpers/trackers/subredditCreation.ts"),
				F = s("./src/reddit/icons/svgs/Admin/index.tsx"),
				D = s("./src/reddit/icons/svgs/Close/index.tsx"),
				B = s("./src/reddit/icons/svgs/Eye/index.tsx"),
				U = s("./src/reddit/icons/svgs/Info/index.tsx"),
				H = s("./src/reddit/icons/svgs/Lock/index.tsx"),
				W = s("./src/reddit/icons/svgs/User/index.tsx"),
				V = s("./src/reddit/models/Subreddit/index.ts"),
				q = s("./src/reddit/models/SubredditRestrictions/index.ts"),
				G = s("./src/config.ts"),
				K = s("./src/reddit/pages/SubredditCreation/Layout/index.m.less"),
				z = s.n(K);
			var Q = e => a.a.createElement("div", {
					className: z.a.OuterContainer
				}, a.a.createElement("div", {
					className: Object(l.a)(e.className, z.a.Container, {
						[z.a.isOverlay]: e.isOverlay
					})
				}, a.a.createElement("div", {
					className: Object(l.a)(z.a.Sidebar, {
						[z.a.isOverlay]: e.isOverlay
					}),
					style: {
						backgroundImage: "url(".concat(G.a.assetPath, "/img/").concat(e.isOverlay ? "community-creation" : "partner-connection", ".png)")
					}
				}), a.a.createElement("div", {
					className: Object(l.a)(z.a.Content, {
						[z.a.isOverlay]: e.isOverlay
					})
				}, e.children))),
				J = s("./src/reddit/selectors/subreddit.ts"),
				Z = s("./src/reddit/selectors/user.ts"),
				X = s("./src/reddit/pages/SubredditCreation/index.m.less"),
				Y = s.n(X),
				$ = s("./src/lib/lessComponent.tsx");
			const ee = 21,
				te = 500,
				se = "create-title-info",
				ne = $.a.wrapped(U.a, "Info", Y.a),
				oe = $.a.wrapped(R.a, "RadioOption", Y.a),
				ae = $.a.wrapped(y.c, "Tooltip", Y.a),
				re = $.a.wrapped(W.a, "Public", Y.a),
				ie = $.a.wrapped(B.a, "Restricted", Y.a),
				de = $.a.wrapped(H.a, "Private", Y.a),
				le = $.a.wrapped(F.a, "Employee", Y.a),
				ce = $.a.wrapped(D.a, "CloseButton", Y.a),
				me = $.a.wrapped(N.b, "ErrorText", Y.a),
				ue = Object(d.c)({
					error: J.i,
					isCreatePending: J.l,
					isEmployee: Z.E,
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(Z.ab)(e),
					userIsSuspended: Z.M,
					allTags: E.e,
					existingTags: E.h,
					newTags: E.i,
					selectedCommunityTopicsOptions: E.k,
					selectedPrimaryTagId: E.j
				}),
				pe = Object(r.b)(ue, e => ({
					createCommunity: t => e(Object(m.f)(t)),
					clearErrors: () => e(Object(m.e)()),
					onCloseLocation: t => e(Object(i.b)(t)),
					onShowTooltip: () => e(Object(u.f)({
						tooltipId: se
					})),
					onHideTooltip: () => e(Object(u.i)())
				})),
				be = (e, t) => [a.a.createElement(oe, {
					key: "public",
					showButton: !0,
					value: "public"
				}, a.a.createElement("div", {
					className: Y.a.radioContent
				}, a.a.createElement("div", null, a.a.createElement(re, null)), a.a.createElement("div", {
					className: Y.a.radioContainer
				}, a.a.createElement("div", {
					className: Y.a.sublabel
				}, n.fbt._("Public", null, {
					hk: "DK992"
				})), a.a.createElement("div", {
					className: Object(l.a)(Y.a.metafieldDescription, Y.a.radioDescription)
				}, n.fbt._("Anyone can view, post, and comment to this community", null, {
					hk: "1PfFUA"
				}))))), a.a.createElement(oe, {
					key: "restricted",
					showButton: !0,
					value: "restricted"
				}, a.a.createElement("div", {
					className: Y.a.radioContent
				}, a.a.createElement("div", null, a.a.createElement(ie, null)), a.a.createElement("div", {
					className: Y.a.radioContainer
				}, a.a.createElement("div", {
					className: Y.a.sublabel
				}, n.fbt._("Restricted", null, {
					hk: "1iBTDq"
				})), a.a.createElement("div", {
					className: Object(l.a)(Y.a.metafieldDescription, Y.a.radioDescription)
				}, Object(q.g)(t))))), a.a.createElement(oe, {
					key: "private",
					showButton: !0,
					value: "private"
				}, a.a.createElement("div", {
					className: Y.a.radioContent
				}, a.a.createElement("div", null, a.a.createElement(de, null)), a.a.createElement("div", {
					className: Y.a.radioContainer
				}, a.a.createElement("div", {
					className: Y.a.sublabel
				}, n.fbt._("Private", null, {
					hk: "3q5SYn"
				})), a.a.createElement("div", {
					className: Object(l.a)(Y.a.metafieldDescription, Y.a.radioDescription)
				}, n.fbt._("Only approved users can view and submit to this community", null, {
					hk: "3z8OI6"
				}))))), a.a.createElement(oe, {
					key: "employees_only",
					showButton: !0,
					value: "employees_only",
					hidden: !e
				}, a.a.createElement("div", {
					className: Y.a.radioContent
				}, a.a.createElement("div", null, a.a.createElement(le, null)), a.a.createElement("div", {
					className: Y.a.radioContainer
				}, a.a.createElement("div", {
					className: Y.a.sublabel
				}, n.fbt._("Employees only", null, {
					hk: "1arrQC"
				})), a.a.createElement("div", {
					className: Object(l.a)(Y.a.metafieldDescription, Y.a.radioDescription)
				}, n.fbt._("Only Reddit employees can view and submit to this community", null, {
					hk: "3ty23C"
				})))))];
			class he extends a.a.Component {
				constructor(e) {
					super(e), this.onNameChange = e => {
						this.setState({
							name: e.target.value
						})
					}, this.onDescriptionChange = e => {
						this.setState({
							description: e.target.value
						})
					}, this.update = (e, t) => this.setState({
						[t]: e
					}), this.onTypeChange = e => {
						this.setState({
							type: e
						})
					}, this.onCreateCommunityClick = () => {
						this.props.isCreatePending || (clearTimeout(this.timeout), this.props.createCommunity({
							name: this.state.name,
							publicDescription: this.state.description,
							type: this.state.type,
							over18: this.state.over18,
							restrictCommenting: this.state.restrictCommenting,
							restrictPosting: this.state.restrictPosting,
							allTags: this.props.allTags,
							newTags: this.props.newTags,
							existingTags: this.props.existingTags,
							primaryTagId: this.props.selectedPrimaryTagId || void 0
						}), this.timeout = window.setTimeout(() => {
							this.props.isCreatePending && this.setState({
								waitingForSuccessfulCommunity: !0
							})
						}, 2e3))
					}, this.errorHelper = e => {
						if (!e) return {};
						const t = e.fields && e.fields.length && e.fields[0] && e.fields[0].field,
							s = e.type;
						if ("name" === t) {
							if ("NO_TEXT" === s) return {
								name: n.fbt._("A Community Name is required", null, {
									hk: "2ocQBg"
								})
							};
							if ("BAD_SR_NAME" === s) return {
								name: n.fbt._("Make sure your Community Name follows all of the formatting rules", null, {
									hk: "2pGksk"
								})
							};
							if ("SUBREDDIT_EXISTS" === s) return {
								name: n.fbt._("This Community Name is already taken", null, {
									hk: "1aiGKw"
								})
							};
							if ("SUBREDDIT_UNAVAILABLE" === s) return {
								name: n.fbt._("This Community Name is unavailable", null, {
									hk: "2Dl0j6"
								})
							}
						} else {
							if ("public_description" === t) return {
								publicDescription: n.fbt._("A Community Description is required", null, {
									hk: "tO1GW"
								})
							};
							if ("topics" === t && "TOPICS_MISSING" === s) return {
								topics: n.fbt._("A Primary Topic is required", null, {
									hk: "2DJ9vR"
								})
							}
						}
						return {
							generic: Object(c.a)(e)
						}
					}, this.state = {
						name: "",
						description: "",
						type: V.d.Public,
						over18: !1,
						waitingForSuccessfulCommunity: !1,
						restrictCommenting: !1,
						restrictPosting: !0
					}
				}
				componentDidMount() {
					const {
						sendEvent: e
					} = this.props;
					e(Object(L.q)()), this.props.clearErrors()
				}
				componentWillUnmount() {
					clearTimeout(this.timeout)
				}
				render() {
					const {
						error: e,
						isCreatePending: t,
						isEmployee: s,
						isOverlay: o,
						onCloseLocation: r,
						onHideTooltip: i,
						onShowTooltip: d,
						sendEvent: c,
						userDoesNotHaveEnoughExpToCreateCommunity: m,
						userIsSuspended: u
					} = this.props, p = this.errorHelper(e), {
						over18: b,
						waitingForSuccessfulCommunity: h
					} = this.state, {
						location: g
					} = this.props;
					return a.a.createElement(Q, {
						className: Object(l.a)(Y.a.subredditCreation, {
							[Y.a.isOverlay]: o
						}),
						isOverlay: o
					}, a.a.createElement("div", {
						className: Y.a.container
					}, a.a.createElement("h1", {
						className: Y.a.title
					}, n.fbt._("Create a community", null, {
						hk: "SlFa7"
					}), o && a.a.createElement(ce, {
						onClick: () => {
							c(Object(A.a)()), r(g.state[S.a.CloseLocation])
						}
					})), m ? a.a.createElement("h2", {
						className: Y.a.sublabel
					}, n.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "44qhJp"
					})) : u ? a.a.createElement("h2", {
						className: Y.a.sublabel
					}, n.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "3trJMZ"
					})) : a.a.createElement(a.a.Fragment, null, a.a.createElement(j.e, {
						hideCountdown: !0,
						isCreateCommunity: !0,
						isRequired: !0,
						label: n.fbt._("Name", null, {
							hk: "3OIzgl"
						}),
						textContainerClassName: Y.a.fullWidthTextContainer,
						onChange: this.onNameChange,
						maxChars: ee,
						value: this.state.name,
						subtext: a.a.createElement("span", {
							className: Y.a.subtextContainer
						}, n.fbt._("Community names including capitalization cannot be changed.", null, {
							hk: "VjrZg"
						}), a.a.createElement("span", {
							id: se,
							onMouseEnter: d,
							onMouseLeave: i,
							className: Y.a.info
						}, a.a.createElement(ne, null), a.a.createElement(ae, {
							caretOnTop: !0,
							tooltipId: se,
							text: n.fbt._('Names cannot have spaces (e.g., "r/bookclub" not "r/book club"), must be between 3-21 characters, and underscores ("_") are the only special characters allowed. Avoid using solely trademarked names (e.g., "r/FansOfAcme" not "r/Acme").', null, {
								hk: "3RsycS"
							})
						})))
					}), p.name && a.a.createElement(me, null, p.name), a.a.createElement(j.k, {
						isRequired: !0,
						label: n.fbt._("Topics", null, {
							hk: "2iixv1"
						}),
						textContainerClassName: Y.a.fullWidthTextContainer,
						subtext: a.a.createElement("span", {
							className: Y.a.subtextContainer
						}, n.fbt._("This will help relevant users find your community.", null, {
							hk: "3LM2Jb"
						}), a.a.createElement("span", null, "".concat(this.props.selectedCommunityTopicsOptions.length, "/").concat(f.a))),
						direction: "column"
					}, a.a.createElement(O, null)), p.topics && a.a.createElement(me, null, p.topics), a.a.createElement(j.g, {
						hideCountdown: !0,
						isCreateCommunity: !0,
						isRequired: !0,
						label: n.fbt._("Description", null, {
							hk: "4gli9v"
						}),
						onChange: this.onDescriptionChange,
						maxChars: te,
						rows: 2,
						subtext: n.fbt._("This is how new members come to understand your community.", null, {
							hk: "35Gh2u"
						}),
						textContainerClassName: Y.a.fullWidthTextContainer,
						value: this.state.description
					}), p.publicDescription && a.a.createElement(me, null, p.publicDescription), a.a.createElement(j.k, {
						label: n.fbt._("Community type", null, {
							hk: "152EhZ"
						}),
						direction: "column",
						isCreateCommunity: !0,
						textContainerClassName: Y.a.fullWidthTextContainer
					}, a.a.createElement(M.a, {
						value: this.state.type,
						name: "type",
						onChange: this.onTypeChange
					}, be(s, "post"))), a.a.createElement("div", {
						className: Object(l.a)(Y.a.field, {
							[Y.a.isCreatePending]: t
						})
					}, a.a.createElement("div", {
						className: Y.a.subtitle
					}, n.fbt._("Adult content", null, {
						hk: "20arB"
					})), a.a.createElement(T.a, {
						name: "over18",
						value: b,
						onChange: () => this.update(!this.state.over18, "over18"),
						disabled: t
					}, a.a.createElement("div", {
						className: Y.a.nsfw
					}, "NSFW"), a.a.createElement("div", {
						className: Y.a.sublabel
					}, n.fbt._("18+ year old community", null, {
						hk: "1XxZMV"
					})))), p.generic && a.a.createElement(me, null, p.generic), h && a.a.createElement("div", {
						className: Y.a.pendingText
					}, n.fbt._("Your community is being created...", null, {
						hk: "3dSTrq"
					})), a.a.createElement("div", {
						className: Object(l.a)(Y.a.buttonContainer, {
							[Y.a.isOverlay]: o
						})
					}, o && a.a.createElement(P.i, {
						disabled: t,
						className: Y.a.createButton,
						onClick: () => {
							r(g.state[S.a.CloseLocation]), c(Object(A.a)())
						}
					}, n.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(P.f, {
						disabled: t,
						className: Y.a.createButton,
						onClick: this.onCreateCommunityClick
					}, n.fbt._("Create Community", null, {
						hk: "QE8Y3"
					}))))))
				}
			}
			t.default = Object(w.c)(pe(Object(I.b)(he)))
		},
		"./src/reddit/selectors/eventPosts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return a
			})), s.d(t, "f", (function() {
				return r
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "b", (function() {
				return d
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "a", (function() {
				return c
			}));
			var n = s("./src/lib/makeListingKey/index.ts"),
				o = s("./src/reddit/selectors/posts.ts");
			const a = (e, t) => {
					let {
						subredditName: s
					} = t;
					return Object(n.a)("ModhubPage-EventPosts", "timeline", {
						subredditName: s
					})
				},
				r = (e, t) => {
					const s = a(e, t);
					return Object(o.U)(e, {
						listingKey: s
					}) || []
				},
				i = (e, t) => {
					const s = a(e, t);
					return !!e.listings.postOrder.api.pending[s]
				},
				d = (e, t) => {
					const s = a(e, t);
					return !!(e.listings.postOrder.ids[s] || []).length
				},
				l = (e, t) => {
					const s = a(e, t),
						n = e.listings.postOrder.pageInfo[s];
					return !(!n || !n.hasNextPage)
				},
				c = (e, t) => {
					const s = a(e, t),
						n = e.listings.postOrder.pageInfo[s];
					return n && n.endCursor || null
				}
		},
		"./src/reddit/selectors/experiments/pollsGA.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = e => !0
		},
		"./src/reddit/selectors/gov.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return m
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "h", (function() {
				return g
			})), s.d(t, "i", (function() {
				return f
			})), s.d(t, "j", (function() {
				return x
			})), s.d(t, "p", (function() {
				return E
			})), s.d(t, "q", (function() {
				return v
			})), s.d(t, "o", (function() {
				return C
			})), s.d(t, "l", (function() {
				return _
			})), s.d(t, "m", (function() {
				return k
			})), s.d(t, "s", (function() {
				return O
			})), s.d(t, "a", (function() {
				return y
			})), s.d(t, "f", (function() {
				return j
			})), s.d(t, "r", (function() {
				return w
			})), s.d(t, "n", (function() {
				return S
			})), s.d(t, "k", (function() {
				return I
			}));
			var n = s("./src/reddit/contexts/PageLayer/index.tsx"),
				o = s("./src/reddit/endpoints/governance/crypto.ts"),
				a = s("./src/reddit/featureFlags/index.ts"),
				r = s("./src/reddit/selectors/experiments/pollsGA.ts"),
				i = s("./src/reddit/selectors/postCreations.ts");
			const d = [],
				l = {},
				c = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				},
				m = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = O(e, {
						subredditId: s
					});
					return n && n.extra && n.extra.contracts && n.extra.contracts.harberger ? n.extra.contracts.harberger : {
						address: void 0,
						decimals: void 0,
						image: void 0,
						taxRate: .01,
						token: void 0
					}
				},
				u = (e, t) => {
					const s = _(e, t);
					if (s) return s.mainHeader
				},
				p = (e, t) => {
					const s = _(e, t);
					return s && s.mainHeader ? s.mainHeader.price : "0"
				},
				b = (e, t) => {
					const s = _(e, t);
					return s && s.mainHeader ? {
						owner: s.mainHeader.owner,
						ownerId: s.mainHeader.ownerId
					} : l
				},
				h = (e, t) => t && t.subredditId ? (e.user.wallets[t.subredditId] || {}).latest : void 0,
				g = (e, t) => {
					if (Object(r.a)(e)) {
						const t = Object(i.g)(e);
						if (t.allowedPostTypes && t.allowedPostTypes.polls) return !0
					}
					const s = a.d.spPolls(e) || a.d.spKarmaPoints(e),
						n = t && t.subredditId ? e.subreddits.gov.meta[t.subredditId] : void 0;
					if (n) {
						const e = !!n.polls && !1 === n.polls.canCreate;
						return s && !e
					}
					return s
				},
				f = (e, t) => {
					return (e.users.publicWallets[t.userId] || {})[t.subredditId]
				},
				x = (e, t) => {
					const s = Object(n.m)(e, t);
					return s && e.subreddits.gov.releaseNotes[s] || d
				},
				E = (e, t) => t && t.subredditId && (e.subreddits.gov.meta[t.subredditId] || {}).name || "Subreddit Points",
				v = (e, t) => t && t.subredditId && (e.subreddits.gov.meta[t.subredditId] || {}).images || c,
				C = (e, t) => {
					const s = w(e, t);
					return s && s.decimals ? "1" + "0".repeat(s.decimals) : "1"
				},
				_ = (e, t) => t.subredditId ? e.subreddits.gov.assets[t.subredditId] : void 0,
				k = (e, t) => t && t.subredditId ? e.subreddits.gov.meta[t.subredditId] : void 0,
				O = (e, t) => {
					const s = k(e, t);
					return s && s.walletProvider
				},
				y = (e, t) => {
					const s = O(e, t),
						n = k(e, t);
					return s && s.provider || n && n.provider
				},
				j = (e, t) => {
					const s = y(e, t);
					return s === o.a.Ethereum || s === o.a.Rinkeby || s === o.a.EthTraderEthereum || s === o.a.EthTraderRinkeby
				},
				w = (e, t) => {
					const s = O(e, t),
						n = y(e, t);
					if (s && !s.inTransition && n === o.a.Stellar) return {
						address: s.extra && s.extra.issuerAddress || "",
						decimals: s.extra && s.extra.decimals || 7,
						symbol: s.extra && s.extra.token || "PHOTON"
					};
					const a = s && s.extra && s.extra.contracts,
						r = a && a.unlocked;
					return r && {
						address: r.address,
						symbol: r.token || "",
						decimals: r.decimals || 18,
						image: r.image
					}
				},
				S = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = O(e, {
						subredditId: s
					});
					return n && n.extra && n.extra.contracts && n.extra.contracts.subscriptions ? n.extra.contracts.subscriptions : {
						address: void 0
					}
				},
				I = (e, t) => {
					const s = k(e, t);
					return !!s && !!s.walletProvider && !s.walletProvider.inTransition
				}
		},
		"./src/reddit/selectors/streamingModSettings.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/reddit/selectors/user.ts");
			const o = {
					startTime: "",
					endTime: ""
				},
				a = {
					isLiveStreamingEnabled: !1,
					maxLiveStreams: void 0,
					minKarma: void 0,
					minAccountAgeDays: void 0,
					durationLimitSeconds: void 0,
					schedule: {
						sunday: o,
						monday: o,
						tuesday: o,
						wednesday: o,
						thursday: o,
						friday: o,
						saturday: o
					},
					whitelistedUsers: []
				},
				r = e => {
					const t = Object(n.i)(e);
					return t && t.isEmployee || !1
				},
				i = (e, t) => {
					const s = e.streaming.modSettings[t.subredditId];
					return s ? {
						isLiveStreamingEnabled: s.isLiveStreamingEnabled,
						maxLiveStreams: s.maxLiveStreams,
						minKarma: s.minKarma,
						minAccountAgeDays: s.minAccountAgeDays,
						durationLimitSeconds: s.durationLimitSeconds,
						schedule: {
							sunday: d(s.weeklySchedule.sunday),
							monday: d(s.weeklySchedule.monday),
							tuesday: d(s.weeklySchedule.tuesday),
							wednesday: d(s.weeklySchedule.wednesday),
							thursday: d(s.weeklySchedule.thursday),
							friday: d(s.weeklySchedule.friday),
							saturday: d(s.weeklySchedule.saturday)
						},
						whitelistedUsers: s.whitelistedRedditors
					} : a
				},
				d = e => Object.assign({}, o, e[0])
		},
		"./src/reddit/selectors/subredditWiki.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return pe
			})), s.d(t, "a", (function() {
				return be
			})), s.d(t, "c", (function() {
				return he
			})), s.d(t, "p", (function() {
				return ge
			})), s.d(t, "q", (function() {
				return fe
			})), s.d(t, "o", (function() {
				return xe
			})), s.d(t, "n", (function() {
				return Ee
			})), s.d(t, "i", (function() {
				return ve
			})), s.d(t, "d", (function() {
				return Ce
			})), s.d(t, "j", (function() {
				return _e
			})), s.d(t, "m", (function() {
				return ke
			})), s.d(t, "k", (function() {
				return Oe
			})), s.d(t, "l", (function() {
				return ye
			})), s.d(t, "e", (function() {
				return je
			})), s.d(t, "h", (function() {
				return we
			})), s.d(t, "f", (function() {
				return Se
			})), s.d(t, "g", (function() {
				return Ie
			}));
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./src/lib/objectSelector/index.ts"),
				o = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				a = s("./src/lib/initializeClient/installReducer.ts"),
				r = s("./node_modules/redux/es/redux.js"),
				i = s("./src/reddit/actions/wiki/wikiDiff/constants.ts");
			const d = {};
			var l = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case i.b: {
							const {
								key: s,
								htmlDiff: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: {
									htmlDiff: n
								}
							})
						}
						case i.c: {
							const {
								key: s
							} = t.payload;
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], {
									pending: !0
								})
							})
						}
						case i.a: {
							const {
								key: s,
								error: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], {
									pending: !1,
									error: n
								})
							})
						}
						default:
							return e
					}
				},
				c = s("./src/reddit/actions/pages/subredditWiki/constants.ts");
			const m = {};
			var u = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.b:
							const s = t.payload,
								{
									subredditWiki: n,
									options: o
								} = s,
								a = n && n.directory;
							if (!a) return e;
							const {
								subredditName: r
							} = o;
							return Object.assign({}, e, {
								[r.toLowerCase()]: a
							});
						default:
							return e
					}
				},
				p = s("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const b = {};
			var h = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.b: {
							const {
								subredditWiki: s,
								pageKey: n
							} = t.payload, {
								page: o
							} = s;
							return n && o ? Object.assign({}, e, {
								[n]: o
							}) : e
						}
						case p.a: {
							const {
								pageKey: s,
								page: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				g = s("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const f = {};
			var x = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case g.c: {
							const {
								settings: s,
								pageKey: n
							} = t.payload;
							return s ? Object.assign({}, e, {
								[n]: s
							}) : e
						}
						case g.d: {
							const {
								isVisible: s,
								editPermissions: n,
								pageKey: o
							} = t.payload, a = e[o];
							return a ? Object.assign({}, e, {
								[o]: Object.assign({}, a, {
									isVisible: s,
									editPermissions: n
								})
							}) : e
						}
						case g.b: {
							const {
								editorsInfo: s,
								afterToken: n,
								pageKey: o
							} = t.payload, a = e[o];
							if (!a) return e;
							const r = [...a.editorsInfo, ...s];
							return Object.assign({}, e, {
								[o]: Object.assign({}, a, {
									editorsInfo: r,
									afterToken: n
								})
							})
						}
						case g.a: {
							const {
								username: s,
								pageKey: n
							} = t.payload, o = e[n];
							if (!o) return e;
							const a = o.editorsInfo.filter(e => e.username !== s);
							return Object.assign({}, e, {
								[n]: Object.assign({}, o, {
									editorsInfo: a
								})
							})
						}
						default:
							return e
					}
				},
				E = s("./src/lib/omitKey/index.ts");
			const v = {};
			var C = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.b: {
						const {
							key: s,
							error: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					case p.d:
					case p.c: {
						const {
							key: s
						} = t.payload;
						return Object(E.a)(e, s)
					}
					default:
						return e
				}
			};
			const _ = {};
			var k = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case p.d:
						case p.b:
						case p.c: {
							const {
								key: s
							} = t.payload, n = t.type === p.d;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				O = Object(r.c)({
					error: C,
					pending: k
				}),
				y = s("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const j = {};
			var w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case p.c: {
						const {
							key: s,
							options: n,
							pageInfo: o,
							revisionsIds: a
						} = t.payload, r = e[s], i = n.after && r ? [...r.ids, ...a] : a;
						return Object.assign({}, e, {
							[s]: {
								ids: i,
								pageInfo: o
							}
						})
					}
					case p.a: {
						const {
							page: {
								revision: s
							},
							pageRevisionsListingKey: n,
							recentRevisionsListingKey: o
						} = t.payload, a = e[n];
						return a && s ? Object.assign({}, Object(E.a)(e, o), {
							[n]: Object.assign({}, a, {
								ids: [s.id, ...a.ids]
							})
						}) : e
					}
					case y.a: {
						const {
							pageRevisionsListingKey: s,
							recentRevisionsListingKey: n
						} = t.payload, o = Object.assign({}, e);
						return delete o[s], delete o[n], o
					}
					default:
						return e
				}
			};
			const S = {};
			var I = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : S,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case c.b: {
							const {
								subredditWiki: {
									page: s
								}
							} = t.payload, n = s && s.revision;
							return n && !e[n.id] ? Object.assign({}, e, {
								[n.id]: n
							}) : e
						}
						case p.c: {
							const {
								revisions: s
							} = t.payload;
							return Object.assign({}, e, s)
						}
						case p.a: {
							const {
								page: s
							} = t.payload, n = s.revision;
							return n ? Object.assign({}, e, {
								[n.id]: n
							}) : e
						}
						case p.e: {
							const {
								revisionId: s,
								isHidden: n
							} = t.payload, o = e[s];
							return o ? Object.assign({}, e, {
								[s]: Object.assign({}, o, {
									isHidden: n
								})
							}) : e
						}
						default:
							return e
					}
				},
				P = Object(r.c)({
					api: O,
					listings: w,
					models: I
				}),
				T = s("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const N = {};
			var M = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case T.c:
					case T.a: {
						const {
							subredditName: s,
							afterToken: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const R = {};
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case T.b: {
						const {
							subredditName: s,
							error: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					case T.d:
					case T.c: {
						const {
							subredditName: s
						} = t.payload;
						return Object(E.a)(e, s)
					}
					default:
						return e
				}
			};
			const A = {};
			var F = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : A,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case T.d:
						case T.c:
						case T.b: {
							const {
								subredditName: s
							} = t.payload, n = t.type === T.d;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				D = Object(r.c)({
					error: L,
					pending: F
				});
			const B = {};
			var U = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : B,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case T.c:
						case T.a: {
							const {
								subredditName: s,
								bannedContributors: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], n)
							})
						}
						case T.e: {
							const {
								subredditName: s,
								bannedContributor: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: Object.assign({}, e[s], n)
							})
						}
						case T.f: {
							const {
								subredditName: s,
								userId: n
							} = t.payload, o = Object(E.a)(e[s], n);
							return Object.assign({}, e, {
								[s]: o
							})
						}
						default:
							return e
					}
				},
				H = s("./node_modules/lodash/uniq.js"),
				W = s.n(H);
			const V = {};
			var q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : V,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case T.c:
						case T.a: {
							const {
								subredditName: s,
								userOrder: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: W()([...e[s] || [], ...n])
							})
						}
						case T.e: {
							const {
								subredditName: s,
								userOrder: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: W()([...n, ...e[s] || []])
							})
						}
						case T.f: {
							const {
								subredditName: s,
								userId: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: (e[s] || []).filter(e => e !== n)
							})
						}
						default:
							return e
					}
				},
				G = Object(r.c)({
					afterToken: M,
					api: D,
					models: U,
					userOrder: q
				});
			const K = {};
			var z = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : K,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case T.g: {
							const {
								subredditName: s,
								bannedContributor: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				Q = Object(r.c)({
					listing: G,
					search: z
				}),
				J = s("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const Z = {};
			var X = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case J.c:
					case J.a: {
						const {
							subredditName: s,
							afterToken: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					default:
						return e
				}
			};
			const Y = {};
			var $ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case J.b: {
						const {
							subredditName: s,
							error: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: n
						})
					}
					case J.d:
					case J.c: {
						const {
							subredditName: s
						} = t.payload;
						return Object(E.a)(e, s)
					}
					default:
						return e
				}
			};
			const ee = {};
			var te = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ee,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case J.d:
						case J.c:
						case J.b: {
							const {
								subredditName: s
							} = t.payload, n = t.type === J.d;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				se = Object(r.c)({
					error: $,
					pending: te
				});
			const ne = {};
			var oe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ne,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case J.c:
					case J.a: {
						const {
							subredditName: s,
							contributors: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], n)
						})
					}
					case J.e: {
						const {
							subredditName: s,
							contributor: n
						} = t.payload;
						return Object.assign({}, e, {
							[s]: Object.assign({}, e[s], n)
						})
					}
					case J.f: {
						const {
							subredditName: s,
							userId: n
						} = t.payload, o = Object(E.a)(e[s], n);
						return Object.assign({}, e, {
							newState: o
						})
					}
					default:
						return e
				}
			};
			const ae = {};
			var re = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ae,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case J.c:
						case J.a: {
							const {
								subredditName: s,
								userOrder: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: W()([...e[s] || [], ...n])
							})
						}
						case J.e: {
							const {
								subredditName: s,
								userOrder: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: [...n, ...e[s] || []]
							})
						}
						case J.f: {
							const {
								subredditName: s,
								userId: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: (e[s] || []).filter(e => e !== n)
							})
						}
						default:
							return e
					}
				},
				ie = Object(r.c)({
					afterToken: X,
					api: se,
					models: oe,
					userOrder: re
				});
			const de = {};
			var le = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : de,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case J.g: {
							const {
								subredditName: s,
								contributor: n
							} = t.payload;
							return Object.assign({}, e, {
								[s]: n
							})
						}
						default:
							return e
					}
				},
				ce = Object(r.c)({
					listing: ie,
					search: le
				}),
				me = Object(r.c)({
					diff: l,
					directory: u,
					pages: h,
					pageSettings: x,
					revisions: P,
					wikiBannedContributors: Q,
					wikiContributors: ce
				});
			Object(a.a)({
				pages: {
					subredditWiki: me
				}
			});
			const ue = [],
				pe = (e, t) => {
					const {
						subredditName: s
					} = t;
					if (e.pages && e.pages.subredditWiki) return e.pages.subredditWiki.directory[s.toLowerCase()]
				},
				be = (e, t) => {
					const {
						subredditName: s
					} = t;
					return !!e.subreddits.api.wiki.pending[s.toLowerCase()]
				},
				he = (e, t) => {
					const s = Object(o.a)(t);
					if (e.pages && e.pages.subredditWiki) return e.pages.subredditWiki.pages[s]
				},
				ge = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.pages.subredditWiki.revisions.listings[s]
				},
				fe = (e, t) => {
					let {
						listingKey: s
					} = t;
					return !!e.pages.subredditWiki.revisions.api.pending[s]
				},
				xe = (e, t) => {
					let {
						listingKey: s
					} = t;
					return !!e.pages.subredditWiki.revisions.api.error[s]
				},
				Ee = (e, t) => {
					return (e => e.pages.subredditWiki.revisions.models)(e)[t.revisionId]
				},
				ve = (e, t) => {
					let {
						key: s
					} = t;
					return e.pages.subredditWiki.diff[s]
				},
				Ce = (e, t) => {
					const s = Object(o.a)(t);
					return e.pages.subredditWiki.pageSettings[s]
				},
				_e = (e, t) => {
					const {
						subredditName: s
					} = t;
					return !!e.pages.subredditWiki.wikiContributors.listing.api.pending[s.toLowerCase()]
				},
				ke = Object(n.a)((e, t) => {
					let {
						subredditName: s
					} = t;
					const n = s.toLowerCase(),
						o = e.pages.subredditWiki.wikiContributors.listing,
						a = o.userOrder[n],
						r = o.models[n];
					return a ? a.map(e => r[e]) : ue
				}),
				Oe = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.pages.subredditWiki.wikiContributors.listing.afterToken[s.toLowerCase()]
				},
				ye = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.pages.subredditWiki.wikiContributors.search[s.toLowerCase()]
				},
				je = (e, t) => {
					const {
						subredditName: s
					} = t;
					return !!e.pages.subredditWiki.wikiBannedContributors.listing.api.pending[s.toLowerCase()]
				},
				we = Object(n.a)((e, t) => {
					let {
						subredditName: s
					} = t;
					const n = s.toLowerCase(),
						o = e.pages.subredditWiki.wikiBannedContributors.listing,
						a = o.userOrder[n],
						r = o.models[n];
					return a ? a.map(e => r[e]) : ue
				}),
				Se = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.listing.afterToken[s.toLowerCase()]
				},
				Ie = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.search[s.toLowerCase()]
				}
		}
	}
]);
//# sourceMappingURL=ModerationPages.dbb12089e5e6df901894.js.map