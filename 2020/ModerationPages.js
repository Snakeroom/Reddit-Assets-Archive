// https://www.redditstatic.com/desktop2x/ModerationPages.dc5a96a37a300697b8ff.js
// Retrieved at 1/30/2020, 10:30:17 AM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["ModerationPages", "CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModListing~ModQueuePages~Multireddit~ProfileCo~ae34fcbd", "ModListing~ModQueuePages~Multireddit~ProfilePosts~SearchResults~Topic", "AuthorHovercard~Settings~SubredditWiki", "ProfileModeration~Settings~SubredditCreation", "AdminCommunityTopics~SubredditInlineEditing", "ChatPost~ModQueuePages", "ModQueue~ModQueuePages", "removalReasonActions"], {
		"./node_modules/lodash/_baseFilter.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseEach.js");
			e.exports = function(e, t) {
				var s = [];
				return n(e, (function(e, n, a) {
					t(e, n, a) && s.push(e)
				})), s
			}
		},
		"./node_modules/lodash/countBy.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseAssignValue.js"),
				a = s("./node_modules/lodash/_createAggregator.js"),
				o = Object.prototype.hasOwnProperty,
				r = a((function(e, t, s) {
					o.call(e, s) ? ++e[s] : n(e, s, 1)
				}));
			e.exports = r
		},
		"./node_modules/lodash/filter.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_arrayFilter.js"),
				a = s("./node_modules/lodash/_baseFilter.js"),
				o = s("./node_modules/lodash/_baseIteratee.js"),
				r = s("./node_modules/lodash/isArray.js");
			e.exports = function(e, t) {
				return (r(e) ? n : a)(e, o(t, 3))
			}
		},
		"./node_modules/lodash/includes.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseIndexOf.js"),
				a = s("./node_modules/lodash/isArrayLike.js"),
				o = s("./node_modules/lodash/isString.js"),
				r = s("./node_modules/lodash/toInteger.js"),
				i = s("./node_modules/lodash/values.js"),
				c = Math.max;
			e.exports = function(e, t, s, d) {
				e = a(e) ? e : i(e), s = s && !d ? r(s) : 0;
				var l = e.length;
				return s < 0 && (s = c(l + s, 0)), o(e) ? s <= l && e.indexOf(t, s) > -1 : !!l && n(e, t, s) > -1
			}
		},
		"./node_modules/lodash/negate.js": function(e, t) {
			var s = "Expected a function";
			e.exports = function(e) {
				if ("function" != typeof e) throw new TypeError(s);
				return function() {
					var t = arguments;
					switch (t.length) {
						case 0:
							return !e.call(this);
						case 1:
							return !e.call(this, t[0]);
						case 2:
							return !e.call(this, t[0], t[1]);
						case 3:
							return !e.call(this, t[0], t[1], t[2])
					}
					return !e.apply(this, t)
				}
			}
		},
		"./node_modules/lodash/omitBy.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_baseIteratee.js"),
				a = s("./node_modules/lodash/negate.js"),
				o = s("./node_modules/lodash/pickBy.js");
			e.exports = function(e, t) {
				return o(e, a(n(t)))
			}
		},
		"./node_modules/lodash/transform.js": function(e, t, s) {
			var n = s("./node_modules/lodash/_arrayEach.js"),
				a = s("./node_modules/lodash/_baseCreate.js"),
				o = s("./node_modules/lodash/_baseForOwn.js"),
				r = s("./node_modules/lodash/_baseIteratee.js"),
				i = s("./node_modules/lodash/_getPrototype.js"),
				c = s("./node_modules/lodash/isArray.js"),
				d = s("./node_modules/lodash/isBuffer.js"),
				l = s("./node_modules/lodash/isFunction.js"),
				m = s("./node_modules/lodash/isObject.js"),
				u = s("./node_modules/lodash/isTypedArray.js");
			e.exports = function(e, t, s) {
				var p = c(e),
					b = p || d(e) || u(e);
				if (t = r(t, 4), null == s) {
					var h = e && e.constructor;
					s = b ? p ? new h : [] : m(e) && l(h) ? a(i(e)) : {}
				}
				return (b ? n : o)(e, (function(e, n, a) {
					return t(s, e, n, a)
				})), s
			}
		},
		"./src/graphql/operations/AllModerators.json": function(e) {
			e.exports = JSON.parse('{"id":"e29846f6d98c"}')
		},
		"./src/graphql/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"7e85bf548364"}')
		},
		"./src/graphql/operations/DeleteScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"dea861ad7f0d"}')
		},
		"./src/graphql/operations/FetchModerationLogActions.json": function(e) {
			e.exports = JSON.parse('{"id":"f20f90e251f3"}')
		},
		"./src/graphql/operations/FetchSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"69f088de5b46"}')
		},
		"./src/graphql/operations/FetchSubredditTrafficStats.json": function(e) {
			e.exports = JSON.parse('{"id":"d2b39ab0293a"}')
		},
		"./src/graphql/operations/PollVote.json": function(e) {
			e.exports = JSON.parse('{"id":"a20cc8dd230d"}')
		},
		"./src/graphql/operations/SubmitScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"6f9e584d390a"}')
		},
		"./src/graphql/operations/SubredditFlairedRedditorByName.json": function(e) {
			e.exports = JSON.parse('{"id":"68ffe6747ab8"}')
		},
		"./src/graphql/operations/SubredditFlairedRedditors.json": function(e) {
			e.exports = JSON.parse('{"id":"2967fe5e7d03"}')
		},
		"./src/graphql/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"fdef8ef65300"}')
		},
		"./src/graphql/operations/SubredditWiki.json": function(e) {
			e.exports = JSON.parse('{"id":"5834be60ee7a"}')
		},
		"./src/graphql/operations/SubredditWikiBannedContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"9b728f1ed735"}')
		},
		"./src/graphql/operations/SubredditWikiContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"6ff60c2af7f1"}')
		},
		"./src/graphql/operations/SubredditWikiPageSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"03acb455993d"}')
		},
		"./src/graphql/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"cef08b94c057"}')
		},
		"./src/graphql/operations/UpdateSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"1f690708b8b1"}')
		},
		"./src/graphql/operations/WikiComparisonDiff.json": function(e) {
			e.exports = JSON.parse('{"id":"37afdc03bbf6"}')
		},
		"./src/graphql/operations/WikiRevisions.json": function(e) {
			e.exports = JSON.parse('{"id":"83e11ebf7cbf"}')
		},
		"./src/higherOrderComponents/withImageUploads.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			}));
			var n = s("./node_modules/react-redux/es/index.js"),
				a = s("./node_modules/reselect/es/index.js"),
				o = s("./src/reddit/actions/imageUploads.ts"),
				r = s("./src/reddit/models/Image/index.tsx"),
				i = s("./src/reddit/selectors/imageUploads.ts");
			const c = Object(a.c)({
				_imageUploads: i.a
			});

			function d(e, t) {
				return Object(n.b)(c, e => ({
					uploadImage: s => e(t(s)),
					cancelUpload: t => e(Object(o.h)(t))
				}), (function(e, t, s) {
					return Object.assign({}, s, t, {
						getImageUploadsIfModified: function(t) {
							return function(e, t) {
								const s = [];
								let n = !1;
								for (const a of t)
									if (Object(r.i)(a) || e[a.id])
										if (e[a.id]) {
											const t = e[a.id];
											s.push(t), n = n || t !== a
										} else n = !0;
								else s.push(a);
								return n ? s : null
							}(e._imageUploads, t)
						}
					})
				}))(e)
			}
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./node_modules/bignumber.js/bignumber.js");

			function a(e, t) {
				const s = new n.BigNumber(e),
					a = new n.BigNumber(t),
					o = new n.BigNumber(s.dividedBy(a)),
					r = new n.BigNumber("100").multipliedBy(o);
				return new n.BigNumber(r).toNumber()
			}
		},
		"./src/lib/convertToCamelCase/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = e => {
				const t = {};
				for (const s in e) {
					t[s.replace(/_\w/g, e => e[1].toUpperCase())] = e[s]
				}
				return t
			}
		},
		"./src/lib/intersectionObserver/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			let n;
			const a = new Map,
				o = new Map;
			"undefined" != typeof window && (s("./node_modules/intersection-observer/intersection-observer.js"), n = new IntersectionObserver(e => {
				e.forEach(e => {
					const t = e.target,
						s = e.intersectionRatio > 0;
					if (s !== !!o.get(t)) {
						o.set(t, s);
						const n = a.get(t);
						if (n) {
							n(e, s && !!o.get(t))
						}
					}
				})
			}, {
				threshold: [.001]
			}));
			const r = (e, t) => {
					try {
						a.set(e, t), n && n.observe(e)
					} catch (s) {
						0
					}
				},
				i = e => {
					try {
						a.delete(e), n && n.unobserve(e)
					} catch (t) {
						0
					}
				}
		},
		"./src/reddit/actions/bulkActions/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return o
			})), s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/bulkActions/constants.ts");
			const o = Object(n.a)(a.c),
				r = Object(n.a)(a.b),
				i = Object(n.a)(a.a)
		},
		"./src/reddit/actions/governance/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/app/strings/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/lib/prettyPrintNumber/index.ts"),
				r = s("./src/reddit/actions/modal.ts"),
				i = s("./src/reddit/actions/post.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/config.ts"),
				l = s("./src/reddit/endpoints/governance/requester.ts");
			var m = s("./src/reddit/endpoints/governance/poll.ts");
			var u = s("./src/reddit/endpoints/governance/wallet.ts"),
				p = s("./src/reddit/models/Poll/index.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/models/Vote/index.ts"),
				g = s("./src/reddit/selectors/gov.ts"),
				E = s("./src/reddit/actions/governance/constants.ts"),
				x = s("./src/reddit/actions/governance/errorToast.ts");
			s.d(t, "a", (function() {
				return f
			})), s.d(t, "b", (function() {
				return v
			})), s.d(t, "d", (function() {
				return O
			})), s.d(t, "e", (function() {
				return y
			})), s.d(t, "h", (function() {
				return T
			})), s.d(t, "i", (function() {
				return L
			})), s.d(t, "f", (function() {
				return D
			})), s.d(t, "g", (function() {
				return A
			})), s.d(t, "j", (function() {
				return F
			})), s.d(t, "c", (function() {
				return B
			}));
			const f = Object(a.a)(E.b),
				v = Object(a.a)(E.c),
				C = Object(a.a)(E.d),
				O = Object(a.a)(E.e),
				j = Object(a.a)(E.f),
				y = (Object(a.a)(E.g), Object(a.a)(E.h), Object(a.a)(E.i)),
				k = Object(a.a)(E.j),
				w = Object(a.a)(E.k),
				S = Object(a.a)(E.l),
				N = Object(a.a)(E.r),
				T = Object(a.a)(E.s),
				_ = Object(a.a)(E.t),
				I = Object(a.a)(E.u),
				P = Object(a.a)(E.v),
				M = Object(a.a)(E.w),
				R = Object(a.a)(E.x),
				L = Object(a.a)(E.y),
				D = (e, t) => async (s, n, a) => {
					let o, {
							apiContext: r,
							gqlContext: c
						} = a,
						d = n().polls.models[e];
					if (s(w({
							pollId: e
						})), (o = d.type === p.a.GA ? await Object(m.c)(c(), e, t) : await Object(m.b)(r(), d.subredditId, e, t)).ok) {
						if (d.type === p.a.GA) {
							const {
								options: e
							} = o.body.data.updatePostPollVoteState.poll;
							s(j({
								pollId: d.id,
								optionId: t,
								options: e
							}))
						} else s(S(o.body));
						const a = n();
						if ((d = a.polls.models[e]) && Object(p.d)(d)) {
							const {
								postId: e
							} = d, t = a.posts.models[e];
							t && t.voteState === h.a.notVoted && s(Object(i.N)(e))
						}
					} else s(k({
						pollId: e,
						error: o.error || o.errors[0].message
					})), Object(x.a)(s, o.error || o.errors[0].messsage)
				}, A = (e, t) => async (s, a, i) => {
					let {
						apiContext: m
					} = i;
					s(_());
					const u = a().transfers.communityPoints.contentId || void 0,
						p = await
					function(e, t) {
						return Object(l.a)(e, {
							data: {
								amount: t.amount,
								contentId: t.contentId,
								description: t.message,
								receiveUserName: t.recipient
							},
							endpoint: "".concat(d.a.metaUrl, "/wallets/me/").concat(t.subredditId, "/transfers"),
							method: "post"
						})
					}(m(), Object.assign({}, e, {
						contentId: u
					}));
					if (p.ok) {
						const i = a().user.language;
						s(I(Object.assign({}, p.body, {
							subredditId: e.subredditId
						}))), s(Object(c.e)({
							kind: b.b.SuccessCommunity,
							text: Object(n.a)(i, "gov.transferSuccess", {
								amount: Object(o.a)(e.amount),
								recipient: e.recipient,
								tokenName: Object(g.o)(a(), {
									subredditId: e.subredditId
								})
							})
						})), t && s(Object(r.f)())
					} else s(N({
						error: p.error
					})), Object(x.a)(s, p.error)
				}, F = e => async (t, s, n) => {
					let {
						apiContext: a
					} = n;
					t(M());
					const o = await Object(u.a)(a(), e);
					o.ok ? t(R(o.body)) : t(P({
						error: o.error
					}))
				}, B = (e, t) => async (s, a, o) => {
					let {
						apiContext: r
					} = o;
					s(C());
					const i = await
					function(e, t, s) {
						return Object(l.a)(e, {
							data: {
								optOut: t
							},
							method: "patch",
							endpoint: "".concat(d.a.metaUrl, "/wallets/").concat(s, "/me")
						})
					}(r(), e, t);
					if (i.ok) {
						s(R({
							[t]: i.body
						}));
						const o = e ? "polls.optOutSuccess" : "polls.optInSuccess";
						s(Object(c.e)({
							kind: b.b.SuccessCommunity,
							text: Object(n.a)(a().user.language, o, {
								tokenName: Object(g.o)(a(), {
									subredditId: t
								})
							})
						}))
					} else Object(x.a)(s, i.error)
				}
		},
		"./src/reddit/actions/grantUserFlair/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/graphql/operations/SubredditFlairedRedditorByName.json"),
				o = s("./src/graphql/operations/SubredditFlairedRedditors.json"),
				r = s("./src/lib/makeGqlRequest/index.ts");
			var i = s("./src/reddit/endpoints/flair/index.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/reddit/helpers/flair.ts"),
				l = s("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts");
			var m = e => {
				const {
					subreddit: t,
					redditorInfoByName: s
				} = e.data, {
					id: n,
					flairedRedditorByName: a
				} = t, o = {};
				let r = null;
				if (!s) return {
					subredditId: n,
					searchResult: r,
					flairedUsers: o
				};
				const {
					name: i
				} = s;
				if (r = i, a) {
					const {
						flair: e,
						redditor: t
					} = a, {
						name: s
					} = t;
					e && (o[s] = Object(l.a)(e)[0])
				}
				return {
					subredditId: n,
					searchResult: r,
					flairedUsers: o
				}
			};
			var u = e => {
					const {
						subreddit: t
					} = e.data, {
						id: s,
						flairedRedditors: n
					} = t, {
						pageInfo: a,
						edges: o
					} = n, r = [], i = {};
					return o.forEach(e => {
						const {
							node: t
						} = e, {
							flair: s,
							redditor: {
								name: n
							}
						} = t;
						if (r.push(n), s) {
							const e = Object(l.a)(s)[0];
							i[n] = e
						}
					}), {
						subredditId: s,
						flairedUsers: i,
						userOrder: r,
						pageInfo: a
					}
				},
				p = s("./src/reddit/i18n/utils.ts"),
				b = s("./src/reddit/models/SubredditModeration/index.ts"),
				h = s("./src/reddit/models/Toast/index.ts"),
				g = s("./src/reddit/models/User/index.ts"),
				E = s("./src/reddit/selectors/subreddit.ts"),
				x = s("./src/reddit/actions/grantUserFlair/constants.ts");
			s.d(t, "b", (function() {
				return O
			})), s.d(t, "d", (function() {
				return w
			})), s.d(t, "a", (function() {
				return _
			})), s.d(t, "c", (function() {
				return R
			}));
			const f = Object(n.a)(x.i),
				v = Object(n.a)(x.g),
				C = Object(n.a)(x.f),
				O = (e, t) => async (s, n, a) => {
					let {
						gqlContext: i
					} = a;
					const d = t && t.after || "",
						l = t && t.before || "",
						m = Object(E.G)(n(), e),
						g = Object(b.d)(m, d, l);
					if (!!n().flairedUsers.userOrder[g]) return;
					s(f());
					const x = await ((e, t, s) => Object(r.a)(e, Object.assign({}, o, {
						variables: Object.assign({
							subredditName: t
						}, s)
					})))(i(), e, t);
					if (x.ok) {
						const e = u(x.body),
							t = Object.assign({}, e, {
								key: g
							});
						s(v(t))
					} else {
						const e = x.error;
						s(C(e)), s(Object(c.e)({
							kind: h.b.Error,
							text: Object(p.c)("Something went wrong")
						}))
					}
				}, j = Object(n.a)(x.l), y = Object(n.a)(x.k), k = Object(n.a)(x.j), w = (e, t) => async (s, n, o) => {
					let {
						gqlContext: i
					} = o;
					const d = Object(E.S)(n(), {
						subredditId: e
					}).name;
					s(j());
					const l = await ((e, t, s) => Object(r.a)(e, Object.assign({}, a, {
						variables: {
							subredditName: t,
							name: s
						}
					})))(i(), d, t);
					if (l.ok) {
						const e = m(l.body);
						s(y(e))
					} else s(k(l.error)), s(Object(c.e)({
						kind: h.b.Error,
						text: Object(p.c)("Something went wrong")
					}))
				}, S = Object(n.a)(x.e), N = Object(n.a)(x.c), T = Object(n.a)(x.d), _ = (e, t) => async (s, n, a) => {
					let {
						apiContext: o
					} = a;
					const r = n(),
						d = Object(E.S)(r, {
							subredditId: t
						}).name;
					s(S());
					const l = await Object(i.a)(o(), e, d);
					if (l.ok) {
						s(N({
							userName: e,
							subredditId: t
						}));
						const n = Object(c.d)(Object(p.c)("User flair cleared"), h.b.SuccessMod);
						s(Object(c.e)(n))
					} else {
						s(T());
						const n = Object(c.d)(Object(p.c)("Sorry, flair wasn't deleted."), h.b.Error, Object(p.c)("Retry"), _(e, t));
						s(Object(c.e)(n))
					}
					return l.ok || l.error
				}, I = Object(n.a)(x.h), P = Object(n.a)(x.b), M = Object(n.a)(x.a), R = (e, t, s) => async (n, a, o) => {
					let {
						apiContext: r
					} = o;
					const l = a(),
						m = l.flairedUsers.search.result === e && !l.flairedUsers.models[e],
						u = {
							userName: e,
							subredditId: t,
							applied: s
						},
						b = s && s.templateId,
						x = Object(E.S)(l, {
							subredditId: t
						}),
						f = s && Object(d.g)(s),
						v = s ? s.cssClass : void 0,
						C = await Object(i.g)(r(), e, x.name, b, f, v);
					if (C.ok) {
						if (m) {
							let e;
							Object.keys(l.flairedUsers.userOrder).forEach(t => {
								!1 === l.flairedUsers.pageInfo[t].hasNextPage && l.flairedUsers.userOrder[t].length < 50 && (e = t)
							});
							const t = Object.assign({}, u, {
								key: e
							});
							n(M(t))
						}
						e === (l.user.account && Object(g.f)(l.user.account)) ? n(I(u)) : m || n(P(u))
					} else {
						const e = Object(c.d)(Object(p.c)("Sorry, flair wasn't saved."), h.b.Error);
						n(Object(c.e)(e))
					}
					return C.ok || C.error
				}
		},
		"./src/reddit/actions/modQueue/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return D
			})), s.d(t, "d", (function() {
				return B
			})), s.d(t, "f", (function() {
				return q
			})), s.d(t, "a", (function() {
				return V
			})), s.d(t, "b", (function() {
				return z
			})), s.d(t, "c", (function() {
				return K
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/app/strings/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeActionCreator/index.ts"),
				r = s("./src/reddit/actions/bulkActions/index.ts"),
				i = s("./src/reddit/actions/removalReasons/index.ts"),
				c = s("./src/reddit/actions/toaster.ts"),
				d = s("./src/reddit/endpoints/modQueue/index.ts"),
				l = s("./src/reddit/helpers/flair.ts"),
				m = s("./src/reddit/helpers/isPost.ts"),
				u = s("./src/reddit/i18n/utils.ts"),
				p = s("./src/reddit/models/ModQueue/index.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/selectors/modQueue.ts"),
				g = s("./src/reddit/selectors/subreddit.ts"),
				E = s("./src/reddit/selectors/telemetry.ts"),
				x = s("./src/reddit/selectors/user.ts"),
				f = s("./src/telemetry/index.ts"),
				v = s("./src/reddit/actions/modQueue/constants.ts");
			const C = Object(o.a)(v.j),
				O = Object(o.a)(v.i),
				j = Object(o.a)(v.h),
				y = Object(o.a)(v.g),
				k = Object(o.a)(v.f),
				w = Object(o.a)(v.e),
				S = Object(o.a)(v.n),
				N = Object(o.a)(v.m),
				T = Object(o.a)(v.l),
				_ = Object(o.a)(v.q),
				I = Object(o.a)(v.p),
				P = Object(o.a)(v.o),
				M = Object(o.a)(v.w),
				R = Object(o.a)(v.v),
				L = Object(o.a)(v.u),
				D = (e, t, s) => async (o, r, i) => {
					let l, m, u, {
						apiContext: h
					} = i;
					switch (t) {
						case a.fb.Edited:
							l = y, m = w, u = k;
							break;
						case a.fb.Modqueue:
							l = C, m = j, u = O;
							break;
						case a.fb.Reports:
							l = S, m = T, u = N;
							break;
						case a.fb.Spam:
							l = _, m = P, u = I;
							break;
						case a.fb.Unmoderated:
							l = M, m = L, u = R;
							break;
						default:
							throw new Error("Invalid modqueue requested")
					}
					o(l());
					const g = await Object(d.b)(h(), t, s);
					if (g.ok) {
						o(u({
							listingKey: e,
							page: "".concat(s.page || p.b),
							response: g.body
						}))
					} else {
						const e = Object(x.S)(r());
						o(m(g.error)), o(Object(c.e)({
							kind: b.b.Error,
							text: Object(n.a)(e, "subredditModeration.modQueue.toastText.somethingWentWrong")
						}))
					}
				}, A = Object(o.a)(v.k), F = Object(o.a)(v.b), B = e => async (t, s, a) => {
					let {
						apiContext: o
					} = a;
					const r = s(),
						i = r.modQueue.moderatedCommunitiesOrder.after,
						l = r.modQueue.moderatedCommunitiesOrder.pending,
						m = r.modQueue.moderatedCommunitiesOrder.loaded,
						{
							pageName: u
						} = r.platform.currentPage.urlParams,
						p = u;
					if (e && l || m || !i) return;
					const h = await Object(d.b)(o(), p, {
						moderated_after: i
					});
					if (h.ok) t(A(h.body)), h.body.moderatedAfter ? t(B()) : t(F());
					else {
						const e = Object(x.S)(s());
						t(Object(c.e)({
							kind: b.b.Error,
							text: Object(n.a)(e, "subredditModeration.modQueue.toastText.somethingWentWrong")
						}))
					}
				}, U = Object(o.a)(v.t), H = Object(o.a)(v.s), W = Object(o.a)(v.r), q = (e, t, s) => async (a, o, v) => {
					let {
						apiContext: C
					} = v;
					a(Object(r.c)());
					const O = o(),
						j = O.user.language,
						y = Object(h.f)(O),
						k = O.user.account && O.user.account.displayText,
						w = Object(n.a)(j, "subredditModeration.modQueue.toastText.".concat(e)),
						S = Object(n.a)(j, "subredditModeration.modQueue.toastText.postsComments");
					for (let t = 0; t < y.length; t++) {
						const s = y[t];
						let n = e;
						[p.a.Approve, p.a.Remove, p.a.Spam].includes(e) && (Object(m.a)(s) ? n += "_link" : n += "_comment"), Object(f.a)(Object.assign({
							source: "bulk_mod_action",
							action: "click",
							noun: n
						}, E.defaults(O), {
							actionInfo: E.actionInfo(O, {
								count: y.length,
								paneName: O.platform.currentPage ? O.platform.currentPage.urlParams.pageName : void 0
							}),
							comment: E.comment(O, s),
							post: E.post(O, s),
							profile: E.profileByPostOrCommentId(O, s),
							screen: E.screen(O),
							subreddit: E.subredditByPostOrCommentId(O, s)
						}))
					}
					const N = {
						ids: y
					};
					t && (N.text = Object(l.g)(t) || "", N.flairTemplateId = ""), s && (N.cssClass = s, N.flairTemplateId = s);
					const T = await Object(d.a)(C(), e, N);
					if (T.ok)
						if (a(Object(r.b)(Object.assign({}, T.body, {
								operation: e,
								ids: y,
								username: k,
								options: {
									flair: t
								}
							}))), e !== p.a.Approve && e !== p.a.Flair) {
							let t, s;
							const o = O.platform.currentPage && O.platform.currentPage.queryParams && O.platform.currentPage.queryParams.subreddit,
								l = o && Object(g.G)(O, o);
							e === p.a.Remove && l && y.length > 1 && (t = Object(u.c)("Add a removal reason"), s = Object(i.fetchReasonsAndOpenModal)(l, y));
							const m = Object(c.d)("".concat(y.length, " ").concat(S, " ").concat(w), b.b.Undo, Object(n.a)(j, "subredditModeration.modQueue.toastText.undo"), (() => async (e, t, s) => {
								let {
									apiContext: a
								} = s;
								e(U());
								const o = t(),
									i = Object.keys(o.modQueue.bulkAction.undoLastAction)[0],
									l = o.modQueue.bulkAction.undoLastAction[i],
									m = o.user.account && o.user.account.displayText;
								e(Object(r.c)());
								const u = await Object(d.a)(a(), i, {
									ids: l
								});
								if (u.ok) e(H(Object.assign({}, u.body, {
									operation: i,
									ids: l,
									username: m
								})));
								else {
									const s = Object(x.S)(t());
									e(W(u.error)), e(Object(c.e)({
										kind: b.b.Error,
										text: Object(n.a)(s, "subredditModeration.modQueue.toastText.somethingWentWrong")
									}))
								}
							})(), t, s);
							a(Object(c.e)(m))
						} else {
							const e = Object(c.d)("".concat(y.length, " ").concat(S, " ").concat(w), b.b.SuccessMod);
							a(Object(c.e)(e))
						}
					else {
						a(Object(r.a)(T.error));
						const e = Object(c.d)(Object(n.a)(j, "subredditModeration.modQueue.toastText.somethingWentWrong"), b.b.Error);
						a(Object(c.e)(e))
					}
				}, V = Object(o.a)(v.a), z = Object(o.a)(v.c), K = Object(o.a)(v.d)
		},
		"./src/reddit/actions/pages/moderationPages/index.ts": function(e, t, s) {
			"use strict";
			s.r(t);
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/assertNever.ts"),
				a = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeListingKey/index.ts"),
				r = s("./src/reddit/actions/scheduledPosts/index.ts"),
				i = s("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				c = s("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				d = s("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				l = s("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				m = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				u = s("./src/reddit/helpers/trackers/screenview.ts"),
				p = s("./src/reddit/actions/emoji.ts"),
				b = s("./src/reddit/actions/gold/communityAwards.ts"),
				h = s("./src/reddit/actions/grantUserFlair/index.ts"),
				g = s("./src/lib/makeActionCreator/index.ts"),
				E = s("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				x = s("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				f = s("./src/reddit/models/SubredditModeration/ModerationLog/index.ts"),
				v = s("./src/reddit/selectors/subreddit.ts"),
				C = s("./src/reddit/actions/moderationLog/constants.ts");
			const O = Object(g.a)(C.b),
				j = (e, t) => async (s, n, a) => {
					let {
						gqlContext: o
					} = a;
					const r = await Object(E.a)(o(), e, t);
					if (r.body) {
						const t = r.body.data.subreddit.moderation;
						if (t && t.actions) {
							const a = n(),
								o = Object(x.b)(t.actions),
								r = Object(v.G)(a, e),
								{
									hasNextPage: i,
									hasPreviousPage: c,
									endCursor: d,
									startCursor: l
								} = t.actions.pageInfo,
								m = Object(f.a)(r, d, l),
								u = [];
							o.forEach(e => {
								u.push(e.id)
							}), s(O({
								hasNextPage: i,
								hasPreviousPage: c,
								endCursor: d,
								key: m,
								startCursor: l,
								normalizedModerationLog: o,
								actionIds: u,
								subredditId: r
							}))
						}
					}
				};
			var y = s("./src/reddit/actions/modQueue/index.ts"),
				k = s("./src/reddit/actions/pages/subreddit.ts"),
				w = s("./src/reddit/actions/pages/subredditWiki/index.ts"),
				S = s("./src/reddit/actions/platform.ts"),
				N = s("./src/reddit/actions/postRequirements/index.ts"),
				T = s("./src/reddit/actions/removalReasons/index.ts"),
				_ = s("./src/reddit/actions/streaming/modSettings.ts"),
				I = s("./src/reddit/actions/subreddit.ts"),
				P = s("./src/reddit/actions/subredditModeration.ts"),
				M = s("./src/reddit/actions/subredditSettings.ts"),
				R = s("./src/reddit/actions/tags/index.ts"),
				L = s("./src/reddit/actions/toaster.ts"),
				D = s("./src/reddit/actions/trafficStats/constants.ts"),
				A = s("./src/graphql/operations/FetchSubredditTrafficStats.json"),
				F = s("./src/lib/makeGqlRequest/index.ts");
			s("./node_modules/core-js/modules/es6.array.sort.js");
			var B = s("./node_modules/lodash/forEach.js"),
				U = s.n(B),
				H = s("./src/reddit/helpers/graphql/helpers.ts"),
				W = s("./src/reddit/models/TrafficStats/index.ts");
			const q = e => ({
					desktop: new Array(e).fill(0),
					oldReddit: new Array(e).fill(0),
					mWeb: new Array(e).fill(0),
					apps: new Array(e).fill(0),
					total: new Array(e).fill(0)
				}),
				V = (e, t) => {
					return Object(H.j)(e.startsAt) > Object(H.j)(t.startsAt) ? 1 : -1
				},
				z = (e, t, s) => {
					const n = {
							pageViews: q(t),
							uniqueUsers: q(t)
						},
						a = Object(H.j)(e[0].startsAt);
					return e.map(e => {
						const o = Object(H.j)(e.startsAt),
							r = new Date(o),
							i = t === W.c ? r.getMonth() : Math.floor((o - a) / s % t),
							c = W.d[e.client];
						n.pageViews[c][i] += e.pageViews, n.uniqueUsers[c][i] += e.uniqueUsers
					}), n
				};
			var K = s("./src/reddit/i18n/utils.ts"),
				Q = s("./src/reddit/models/Toast/index.ts");
			const G = Object(g.a)(D.b),
				J = Object(g.a)(D.c),
				Z = Object(g.a)(D.a),
				X = e => async (t, s, n) => {
					let {
						gqlContext: o
					} = n;
					const r = Object(v.S)(s(), {
						subredditId: e
					}).name;
					t(J({
						subredditId: e
					}));
					const i = await ((e, t) => Object(F.a)(e, Object.assign({}, A, {
						variables: t
					})))(o(), {
						subredditName: r
					});
					if (i.ok) {
						const s = i.body.data.subreddit.moderation;
						if (s && s.trafficStats) {
							const n = (e => {
								const t = U()(e, (e, t) => e.sort(V)),
									s = t.subscriptionData,
									n = s.map(e => e.subscribers),
									o = s.map(e => e.unsubscribers),
									r = z(t.hourStats, W.b, a.I),
									i = z(t.dayStats, W.a, a.w),
									c = z(t.monthStats, W.c, a.db);
								return {
									pageViews: {
										byHour: r.pageViews,
										byDay: i.pageViews,
										byMonth: c.pageViews
									},
									uniqueUsers: {
										byHour: r.uniqueUsers,
										byDay: i.uniqueUsers,
										byMonth: c.uniqueUsers
									},
									subscribers: n,
									unsubscribers: o
								}
							})(s.trafficStats);
							t(G({
								subredditId: e,
								trafficStats: n
							}))
						}
					} else t(Z({
						subredditId: e
					})), t(L.e({
						id: "error-block-trafficStats",
						kind: Q.b.Error,
						text: Object(K.c)("Try again later")
					}))
				};
			var Y = s("./src/reddit/models/ModQueue/index.ts"),
				$ = s("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				ee = s("./src/reddit/selectors/moderatorPermissions.ts"),
				te = s("./src/reddit/selectors/platform.ts"),
				se = s("./src/reddit/selectors/postCreations.ts"),
				ne = s("./src/reddit/selectors/user.ts");
			s.d(t, "moderationPageRequested", (function() {
				return ae
			}));
			const ae = e => async (t, s, g) => {
				const {
					params: E
				} = e, {
					subredditName: x,
					pageName: f
				} = E;
				if (f === a.Nb.Wiki) {
					if (await t(Object(w.handleWikiRedirects)(e))) return
				}
				const C = Object(o.a)(x, a.N.HOT),
					O = s(),
					L = e.queryParams,
					D = L.page || Y.b,
					A = O.listings.postOrder.ids[C],
					F = O.listings.postOrder.api.error[C],
					B = O.listings.postOrder.api.pending[C];
				if (F) return;
				if (B || A && !F) Object(u.e)(s(), !0, x);
				else if (await t(Object(k.i)(C, x, {})), !Object(ne.J)(s()) && f !== a.Nb.Moderators) return void Object(l.a)(t, s());
				if (!f) return;
				let U, H, W, q, V, z, K;
				switch (f) {
					case a.Nb.Awards:
						U = b.g;
						break;
					case a.Nb.Muted:
						U = P.ib;
						break;
					case a.Nb.Contributors:
						U = P.V;
						break;
					case a.Nb.Banned:
						U = P.Z;
						break;
					case a.Nb.Moderators:
						W = !0;
						break;
					case a.Nb.Removal:
						U = T.removalReasonsRequested;
						break;
					case a.Nb.PostRequirements:
						U = N.a, z = !0;
						break;
					case a.Nb.CommunitySettings:
						U = M.f, K = !0;
						break;
					case a.Nb.Flair:
						U = h.b, V = !0;
						break;
					case a.Nb.UserFlair:
					case a.Nb.PostFlair:
						U = void 0;
						break;
					case a.Nb.Emojis:
						U = p.l;
						break;
					case a.Nb.Badges:
					case a.Nb.Emotes:
					case a.Nb.SubredditRules:
						U = void 0;
						break;
					case a.Nb.Traffic:
						U = X;
						break;
					case a.Nb.Modlog:
						U = j, q = !0;
						break;
					case a.Nb.Streaming:
						U = _.a;
						break;
					case a.Nb.Modqueue:
					case a.Nb.Reports:
					case a.Nb.Spam:
					case a.Nb.Edited:
					case a.Nb.Unmoderated:
						H = f;
						break;
					case a.Nb.Wiki:
					case a.Nb.WikiContributors:
					case a.Nb.WikiBanned:
						await t(Object(w.subredditWikDataRequested)(E, L, !0));
						break;
					case a.Nb.SubredditContent:
						U = r.d;
						break;
					default:
						return Object(n.a)(f)
				}
				const Q = s(),
					G = Object(v.V)(Q, {
						subredditName: x.toLowerCase()
					}),
					J = Object(v.G)(Q, x),
					Z = Object(v.S)(Q, {
						subredditId: J
					}),
					ae = Object(i.a)(Z),
					oe = Object(se.Y)(O),
					re = Object(ne.G)(Q),
					ie = Object($.b)(Q),
					ce = Object(ee.j)(Q, {
						subredditId: J
					});
				if (Object(c.a)(f, ce, ae, oe, re, ie)) {
					if (H) {
						const e = Object(d.a)({
								onlyOfType: L.only,
								subreddit: x
							}),
							n = O.modQueue[H].itemOrder[e],
							a = !!(n && n[D] && n[D].length),
							o = O.modQueue[H].api.error;
						if (O.modQueue[H].api.pending || a && !o) return;
						if (!Object(te.p)(O)) {
							const n = Object(y.e)(e, H, Object.assign({}, L, {
								subreddit: x
							}));
							await n(t, s, g)
						}
					} else if (W) {
						if (await Object(P.fb)(J, L)(t, s, g), O.moderatingSubreddits[J]) {
							await Object(P.db)(J, L)(t, s, g), O.moderators.invitedModerators.userOrder[J] || await Object(P.eb)(J)(t, s, g)
						}
					} else z ? await U(x)(t, s, g) : K ? await Promise.all([U(x, J)(t, s, g), Object(R.i)(J, m.a.communitySettings)(t, s, g)]) : q || V ? await U(x, L)(t, s, g) : U && await U(J, L)(t, s, g);
					O.subreddits.rules[J] || await I.o(x)(t, s, g), t(S.l({
						title: G
					})), Object(u.e)(s(), !!s().listings.postOrder.api.error[C], x)
				}
			}
		},
		"./src/reddit/actions/pages/subredditWiki/index.ts": function(e, t, s) {
			"use strict";
			s.r(t);
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js");
			var n = s("./node_modules/lodash/isEmpty.js"),
				a = s.n(n),
				o = s("./node_modules/react-router-redux/es/index.js"),
				r = s("./src/app/strings/index.ts"),
				i = s("./src/lib/constants/index.ts"),
				c = s("./src/lib/makeActionCreator/index.ts"),
				d = s("./src/lib/makeListingKey/index.ts"),
				l = s("./src/config.ts"),
				m = s("./src/reddit/actions/platform.ts"),
				u = s("./src/reddit/helpers/path/index.ts");
			var p = s("./src/reddit/actions/ads/index.ts"),
				b = s("./src/reddit/actions/pages/subreddit.ts"),
				h = s("./src/reddit/actions/pages/subredditWiki/constants.ts"),
				g = s("./src/reddit/actions/toaster.ts"),
				E = s("./src/reddit/actions/wiki/wikiBannedContributors/index.ts"),
				x = s("./src/reddit/actions/wiki/wikiContributors/index.ts"),
				f = s("./src/lib/makeGqlRequest/index.ts"),
				v = s("./src/graphql/operations/WikiComparisonDiff.json"),
				C = s("./src/reddit/helpers/wiki/wikiRevision.ts");
			var O = s("./src/reddit/helpers/wiki/makeComparisonDiffKey.ts"),
				j = s("./src/reddit/selectors/subredditWiki.ts"),
				y = s("./src/reddit/actions/wiki/wikiDiff/constants.ts");
			const k = Object(c.a)(y.c),
				w = Object(c.a)(y.b),
				S = Object(c.a)(y.a),
				N = e => async (t, s, n) => {
					const a = s(),
						o = Object(O.a)(e),
						r = Object(j.i)(a, {
							key: o
						});
					if (r && (r.pending || !r.error)) return !0;
					const c = {
						key: o
					};
					t(k(c));
					const d = await ((e, t) => Object(f.a)(e, Object.assign({}, v, {
						variables: Object.assign({}, t, {
							comparisonRevisionId: Object(C.b)(t.comparisonRevisionId),
							revisionId: Object(C.b)(t.revisionId)
						})
					})))(n.gqlContext(), e);
					let l = null,
						m = "";
					if (d.ok) {
						const e = d.body,
							t = e.data.subreddit && e.data.subreddit.wiki,
							s = t && t.page && t.page.revisionComparisonDiffHtml;
						s ? m = s : l = {
							type: i.D.NOT_FOUND_ERROR
						}
					} else l = d.error || {
						type: i.D.UNKNOWN_ERROR
					};
					return t(l ? S(Object.assign({}, c, {
						error: l
					})) : w(Object.assign({}, c, {
						htmlDiff: m
					}))), !l
				};
			var T = s("./src/reddit/actions/wiki/wikiPageSettings/index.tsx"),
				_ = s("./src/reddit/actions/wiki/wikiRevisions/index.ts"),
				I = s("./src/reddit/constants/parameters.ts"),
				P = s("./src/reddit/constants/wiki.ts"),
				M = s("./src/reddit/endpoints/page/subredditWiki.ts"),
				R = s("./src/reddit/helpers/brandSafety/index.ts"),
				L = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				D = s("./src/reddit/i18n/utils.ts"),
				A = s("./src/reddit/models/Toast/index.ts"),
				F = s("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				B = s("./src/reddit/routes/subredditWiki/normalizeWikiUrl.ts"),
				U = s("./src/reddit/selectors/subreddit.ts"),
				H = s("./src/reddit/selectors/user.ts");
			s.d(t, "subredditWikiDataPending", (function() {
				return W
			})), s.d(t, "subredditWikiDataLoaded", (function() {
				return q
			})), s.d(t, "subredditWikiDataFailed", (function() {
				return V
			})), s.d(t, "fetchSubredditWikiData", (function() {
				return Q
			})), s.d(t, "handleWikiRedirects", (function() {
				return J
			})), s.d(t, "subredditWikDataRequested", (function() {
				return Z
			})), s.d(t, "subredditWikiPageRequested", (function() {
				return X
			}));
			const W = Object(c.a)(h.c),
				q = Object(c.a)(h.b),
				V = Object(c.a)(h.a),
				z = (e, t, s, n) => {
					return s === P.j ? K(e, t) : !!Object(j.c)(e, {
						subredditName: t,
						wikiPageName: s,
						revisionId: n
					})
				},
				K = (e, t) => !!Object(j.b)(e, {
					subredditName: t
				}),
				Q = e => async (t, s, n) => {
					const {
						canShowFailToast: o,
						wikiPageName: c
					} = e, d = c === P.j, l = Object(H.S)(s()), m = Object.assign({}, e, {
						includePageData: e.includePageData && !d
					}), u = c ? Object(L.a)(Object.assign({}, e, {
						wikiPageName: c
					})) : void 0;
					t(W({
						options: m,
						pageKey: u
					}));
					const p = await Object(M.a)(n.gqlContext(), m),
						b = p.body,
						h = p.ok ? b.data && b.data.subreddit && b.data.subreddit.wiki : null;
					return p.ok && h ? t(q({
						options: m,
						pageKey: u,
						subredditWiki: h
					})) : (t(V({
						options: m,
						pageKey: u,
						error: p.error || {
							type: i.D.NOT_FOUND_ERROR
						}
					})), o && t(Object(g.e)({
						id: "SUBREDDIT_WIKI_DATA_ERROR_TOAST",
						kind: A.b.Error,
						text: Object(r.a)(l, "error.genericPage"),
						buttonText: Object(r.a)(l, "listings.toast.retryButton"),
						buttonAction: Q(e)
					}))), !(!p.ok || !a()(b.data.subreddit)) || !(!p.ok || !h)
				}, G = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (s, n) => {
						const a = n(),
							o = {
								sort: i.N.HOT
							},
							r = Object(d.a)(e, o.sort),
							c = a.listings.postOrder.api.error[r],
							l = a.listings.postOrder.api.pending[r],
							m = !!a.listings.postOrder.ids[r];
						return !!(l || m && !c) || (await s(Object(b.i)(r, e, o, t)), !n().listings.postOrder.api.error[r])
					}
				}, J = e => async (t, s) => {
					const {
						params: n,
						url: a
					} = e, {
						wikiPageName: r
					} = n, i = Object(B.a)(a, n);
					let c = !1;
					return P.k.includes(r || "") ? (await (async (e, t) => {
						const s = "".concat(l.a.oldRedditUrl).concat(Object(u.b)(e));
						window.location.href = s
					})(e.url), c = !0) : a !== i && (await t(Object(o.c)(i)), c = !0), c
				}, Z = function e(t, s) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (a, o, r) => {
						const {
							subredditName: c = P.e,
							wikiPageName: d,
							wikiSubRoute: l
						} = t, m = s[I.w], u = s[I.x], p = m ? Object(C.a)(m) : void 0, b = u ? Object(C.a)(u) : void 0, h = d === P.j, f = l === P.l.Revisions;
						let v = !1,
							O = !1;
						if (n) {
							const {
								pageName: e
							} = t;
							v = e === i.Nb.WikiContributors, O = e === i.Nb.WikiBanned
						}
						const j = o(),
							y = (h || n) && !K(j, c),
							k = !!d && !z(j, c, d, p),
							w = [];
						w.push(a(G(c))), (y || k) && w.push(a(Q({
							includeDirectory: y,
							includePageData: k,
							revisionId: p,
							subredditName: c,
							wikiPageName: d
						}))), l === P.l.Settings && d && w.push(a(Object(T.c)(c, d))), d && p && b && w.push(a(N({
							comparisonRevisionId: b,
							revisionId: p,
							subredditName: c,
							wikiPageName: d
						}))), f && w.push(a(Object(_.c)({
							isRecent: !d,
							wikiPageName: d,
							subredditName: c
						}))), v && w.push(a(Object(x.e)(c))), O && w.push(a(Object(E.e)(c))), (await Promise.all(w)).every(Boolean) || a(Object(g.e)({
							kind: A.b.Error,
							text: Object(D.c)("Something went wrong"),
							buttonText: Object(D.c)("Retry"),
							buttonAction: e(t, s, n)
						}))
					}
				}, X = e => async (t, s) => {
					if (await t(J(e))) return;
					const {
						params: n,
						queryParams: a
					} = e, o = n.subredditName || P.e;
					t(m.l({
						title: n.wikiPageName ? "".concat(n.wikiPageName, " - ").concat(o) : "wiki - ".concat(o)
					})), await t(Z(n, a));
					const r = Object(U.B)(s(), {
							subredditName: o
						}),
						i = s();
					r && (i.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						t(Object(p.b)(F.a.SUBREDDIT))
					}), t(Object(p.d)({
						isViewSafe: Object(R.a)([], [r])
					})))
				}
		},
		"./src/reddit/actions/postCreation/mediaUpload.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/uuid/v4.js"),
				a = s.n(n),
				o = s("./src/app/strings/index.ts"),
				r = s("./src/lib/constants/index.ts"),
				i = s("./src/lib/formatApiError/index.ts"),
				c = s("./src/lib/makeActionCreator/index.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/actions/upload.ts"),
				m = s("./src/lib/makeApiRequest/index.ts"),
				u = s("./src/lib/omitHeaders/index.ts"),
				p = s("./src/reddit/constants/headers.ts");
			var b = s("./src/reddit/helpers/correlationIdTracker.ts"),
				h = s("./src/reddit/helpers/imagePreview/index.ts"),
				g = s("./src/reddit/helpers/media/index.ts"),
				E = s("./src/reddit/models/Upload/index.ts"),
				x = s("./src/reddit/selectors/telemetry.ts"),
				f = s("./src/telemetry/index.ts");
			const v = async e => {
				let {
					state: t,
					uploadKey: s,
					assetId: n,
					isCanceled: a,
					fileSource: o,
					uploadDuration: r,
					correlationId: i
				} = e;
				const c = t.uploads[s],
					d = a || c.status === E.a.CANCELED,
					{
						file: l,
						url: m,
						metadata: u,
						error: p
					} = c,
					b = u.mimetype || l.type,
					h = b.startsWith("video/"),
					g = c.status === E.a.SUCCESS;
				let v = "";
				p ? v = JSON.stringify(p) : d && (v = "canceled");
				const C = {
					width: u.width,
					height: u.height,
					duration: u.videoDuration && Math.round(1e3 * u.videoDuration)
				};
				Object(f.a)(Object.assign({
					source: h ? "videoupload" : "imageupload",
					action: "upload",
					correlationId: i,
					noun: h ? "video" : "image"
				}, (e => Object.assign({}, x.defaults(e), {
					screen: x.screen(e),
					profile: x.profile(e),
					subreddit: x.subreddit(e)
				}))(t), {
					actionInfo: Object.assign({}, x.actionInfo(t), {
						success: g
					}, v ? {
						reason: v
					} : {}),
					media: Object.assign({
						mimetype: b,
						uploadDuration: r,
						source: o,
						fileName: l.name,
						size: l.size,
						type: h ? "video" : "image"
					}, n ? {
						id: n
					} : {}, m ? {
						url: m
					} : {}, C)
				}))
			};
			var C = s("./src/reddit/helpers/trackers/postComposer.ts"),
				O = s("./src/reddit/models/Toast/index.ts"),
				j = s("./src/reddit/selectors/postCreations.ts"),
				y = s("./src/reddit/selectors/user.ts"),
				k = s("./src/reddit/actions/postCreation/constants.ts");
			s.d(t, "d", (function() {
				return T
			})), s.d(t, "c", (function() {
				return I
			})), s.d(t, "a", (function() {
				return P
			})), s.d(t, "b", (function() {
				return M
			}));
			const w = Object(c.a)(k.v),
				S = Object(c.a)(k.w),
				N = Object(c.a)(k.u),
				T = e => async (t, s) => {
					t(w());
					const n = e.map(e => {
						let {
							url: s,
							uploadKey: n
						} = e;
						const a = Object(g.a)(Object(g.c)(s), "poster.png");
						return t(I(a, n))
					});
					await Promise.all(n);
					const a = s().uploads,
						o = e.map(e => {
							let {
								uploadKey: t
							} = e;
							return a[t]
						}).find(e => e.status !== E.a.SUCCESS);
					t(o ? N(o.error) : S())
				}, _ = (e, t) => ({
					error: t ? {
						type: e,
						fields: [{
							field: "",
							msg: t
						}]
					} : {
						type: e
					}
				});
			const I = (e, t, s, n) => async (a, i, c) => {
				let {
					apiContext: d
				} = c;
				const x = Object(j.g)(i()),
					f = Date.now();
				let O = null,
					k = !1,
					w = !1,
					S = !1;
				const N = e => {
					if (!S && s && k) {
						S = !0;
						const n = i(),
							a = Date.now() - f,
							o = Object(b.c)(b.a.PostComposer);
						w ? v({
							state: n,
							uploadKey: t,
							assetId: O,
							isCanceled: e,
							fileSource: s,
							uploadDuration: a,
							correlationId: o
						}) : C.q(n, t)
					}
				};
				t.startsWith(E.b.RTE_MEDIA);
				await a(Object(l.k)(e, t, async c => {
					k = !0, Object(l.j)(c.id, () => {
						N(!0)
					});
					const {
						error: b,
						metadata: E
					} = await async function(e, t, s, n) {
						const a = Object(y.S)(e),
							i = s && s.allowedPostTypes,
							c = s && s.name,
							d = await Object(g.g)(t) || t.type,
							l = Object(g.b)(t) || void 0;
						if (!l) return _("UNSUPPORTED_BROWSER");
						const m = {
							localUrl: l,
							mimetype: d
						};
						if (!d || !Object(g.i)(d)) return {
							error: {
								type: r.L
							}
						};
						if (d.startsWith("image/")) {
							if (i && !i.images) {
								const e = Object(o.a)(a, "postCreation.mediaInput.imagesAreNotAllowed", {
									subredditName: c
								});
								return _(r.L, e)
							}
							if ("image/gif" === d) {
								if (t.size > r.Q) return _(r.G)
							} else if (t.size > r.S) return _(r.J);
							const e = await Object(h.a)(l);
							m.width = e.width, m.height = e.height
						} else if (d.startsWith("video/")) {
							if (t.size > r.X) return _(r.Vb);
							let e;
							try {
								e = await Object(g.h)(l, !0)
							} catch (u) {
								return _(r.L)
							}
							if (i) {
								const {
									videos: t,
									images: s
								} = i;
								if (s && !t && e.duration > r.Y) {
									const e = Object(o.a)(a, "postCreation.mediaInput.videoTooLongForImageOnlySubreddit", {
										subredditName: c
									});
									return _(r.L, e)
								}
								if (!s && !t) {
									const e = Object(o.a)(a, "postCreation.mediaInput.videosAreNotAllowed", {
										subredditName: c
									});
									return _(r.L, e)
								}
							}
							if (e.duration > r.W) {
								const e = Object(o.a)(a, "postCreation.mediaInput.videoTooLongInGeneral");
								return _(r.L, e)
							}
							m.height = e.height, m.width = e.width, m.videoDuration = e.duration, m.videoFirstFrameUrl = e.firstFrame.dataUrl
						}
						return {
							metadata: m
						}
					}(i(), e, x);
					if (b || !E) return {
						error: b
					};
					a(Object(l.l)({
						key: t,
						metadata: Object.assign({
							fileSource: s
						}, E)
					})), w = !0, n && n();
					const f = e.name,
						v = await (async (e, t, s) => Object(m.b)(Object(u.a)(e, [p.a]), {
							endpoint: "".concat(e.apiUrl, "/api/media/asset.json"),
							method: r.bb.POST,
							data: {
								filepath: t,
								mimetype: s
							}
						}))(d(), f, E.mimetype);
					if (!v.ok) return {
						error: v.error || void 0
					};
					O = v.body.asset.asset_id;
					const C = v.body.asset.websocket_url;
					return {
						uploadLease: v.body.args,
						websocketUrl: C
					}
				}, !0)), N(!1)
			}, P = e => async (t, s, n) => {
				let {
					apiContext: a
				} = n;
				const o = s().uploads[e];
				o && !Object(E.d)(o) && await t(I(o.file, o.key, o.metadata.fileSource))
			}, M = (e, t, s) => async (n, r) => {
				const c = e.map((e, o) => new Promise(async o => {
						const r = Object(E.e)(E.b.RTE_MEDIA, "".concat(s, "-").concat(a()().slice(-6)));
						await n(I(e, r, t, () => o(r))), o(r)
					})),
					l = await Promise.all(c);
				n(function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
					return async (s, n) => {
						const {
							uploads: a,
							user: {
								language: r
							}
						} = n(), c = e.map(e => a[e]).filter(e => e.status === E.a.FAILED && !e.metadata.mimetype).map(e => e.error), l = c.length > t ? t - 1 : c.length, m = c.length - l;
						c.slice(0, l).forEach(e => s(Object(d.e)({
							duration: d.a,
							kind: O.b.Error,
							text: Object(i.a)(r, e)
						}))), m > 0 && s(Object(d.e)({
							duration: d.a,
							kind: O.b.Error,
							text: Object(o.c)(r, "postCreation.cannotAddFiles", m)
						}))
					}
				}(l))
			}
		},
		"./src/reddit/actions/postCreation/submit.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/telemetry/index.ts"),
				r = s("./src/reddit/actions/governance/index.ts"),
				i = s("./src/reddit/actions/layers.ts"),
				c = s("./src/reddit/actions/page.ts"),
				d = s("./src/reddit/actions/postDraft.ts"),
				l = s("./src/reddit/actions/scheduledPosts/index.ts"),
				m = s("./src/reddit/actions/toaster.ts"),
				u = s("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				p = s("./src/config.ts"),
				b = s("./src/lib/convertToCamelCase/index.ts"),
				h = s("./src/lib/makeApiRequest/index.ts"),
				g = s("./src/reddit/endpoints/post/create.ts");
			var E = s("./src/reddit/endpoints/scheduledPosts/index.ts"),
				x = s("./src/reddit/endpoints/scheduledPosts/update.ts"),
				f = s("./src/reddit/featureFlags/index.ts"),
				v = s("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				C = s("./src/reddit/helpers/scheduledPosts/index.ts"),
				O = s("./src/reddit/helpers/trackers/postComposer.ts"),
				j = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				y = s("./src/reddit/i18n/utils.ts"),
				k = s("./src/reddit/models/Poll/index.ts"),
				w = s("./src/reddit/models/PostCreationForm/index.ts"),
				S = s("./src/reddit/models/Toast/index.ts"),
				N = s("./src/reddit/models/User/index.ts"),
				T = s("./src/reddit/selectors/experiments/pollsGA.ts"),
				_ = s("./src/reddit/selectors/layers.ts"),
				I = s("./src/reddit/selectors/postCreations.ts"),
				P = s("./src/reddit/selectors/postDraft.ts"),
				M = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				R = s("./src/reddit/selectors/user.ts"),
				L = s("./src/reddit/models/Post/index.ts"),
				D = s("./src/reddit/actions/postCreation/constants.ts"),
				A = s("./src/reddit/actions/postCreation/general.ts"),
				F = s("./src/reddit/actions/postCreation/mediaUpload.ts");
			s.d(t, "a", (function() {
				return H
			})), s.d(t, "c", (function() {
				return V
			})), s.d(t, "b", (function() {
				return J
			}));
			const B = Object(a.a)(D.y),
				U = Object(a.a)(D.N),
				H = Object(a.a)(D.p),
				W = Object(a.a)(D.A),
				q = Object(a.a)(D.Y),
				V = Object(a.a)(D.H),
				z = Object(a.a)(D.a),
				K = Object(a.a)(D.D),
				Q = (e, t) => {
					const s = t.creations.formData.govType,
						n = Object.assign({}, e);
					if (s && (n.type = s), n.type === k.a.ReplaceTopMod) n.params = {
						userName: t.creations.formData.newTopMod
					}, n.options = k.f[k.a.ReplaceTopMod]();
					else if (n.type === k.a.Spinoff) {
						const e = t.creations.formData.newSubreddit;
						n.params = {
							subreddit: e
						}, n.options = k.f[k.a.Spinoff](e)
					} else n.options = n.options.map(e => ({
						text: e.text.trim()
					})).filter(e => !!e.text);
					return n
				},
				G = e => {
					const t = e.uploads,
						s = Object(I.K)(e),
						a = Object(I.a)(e),
						o = Object(I.V)(e);
					if (a === n.Gb.POST) return u.a.getPendingThumbnailUploads(o, t);
					if (a === n.Gb.MEDIA && s) {
						const {
							video: e
						} = s;
						if (e && e.thumbnail && !t[w.n]) return [Object.assign({}, e.thumbnail, {
							uploadKey: w.n
						})]
					}
				},
				J = (e, t) => async (s, a, o) => {
					let {
						apiContext: r
					} = o, i = a();
					const {
						pending: c
					} = i.creations.api.post.submit, l = Object(P.g)(i);
					if (c || l) return;
					s(K(e)), i = a();
					const m = Object(I.a)(i),
						u = f.d.rteVideoPoster(i),
						p = G(i),
						b = m === n.Gb.MEDIA;
					p && (u || b) && (await s(F.d(p)), G(a())) || (e === w.r.Draft ? await s(Object(d.r)(t.draftId)) : e === w.r.ScheduledPost && Object(M.j)(i) ? await s(Z(t)) : e === w.r.ScheduledPost ? await s(X(t)) : await s(Y(t)))
				}, Z = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					const r = s(),
						i = Object(I.S)(r),
						d = Object(I.T)(r, e),
						m = Object(I.g)(r),
						u = Object(M.j)(r);
					if (!(d && m.id && i && Object(C.e)(u))) return;
					const p = m.id,
						b = Object(M.h)(s(), {
							subredditId: p,
							scheduledPostId: u
						});
					if (b && Object(o.a)(Object(j.l)(b)(r)), t(B(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(I.s)(s()))) return;
					const h = Object(E.d)({
							submission: d,
							schedule: i,
							subredditId: m.id,
							scheduledPostId: u
						}),
						g = await Object(x.a)(a(), h);
					if (g.ok) {
						t(Object(l.c)({
							subredditId: m.id
						}));
						const e = "/r/".concat(m.name, "/about/content");
						return void t(Object(c.I)(e, !1))
					}
					const f = g.error;
					t(H(f))
				}, X = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					const r = s(),
						i = Object(I.S)(r),
						d = Object(I.T)(r, e),
						m = Object(I.g)(r);
					if (!d || !m.id || !i) return;
					if (t(B(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(I.s)(s()))) return;
					const u = await Object(E.a)(a(), Object(E.c)(d, i, m.id));
					if (u.ok) {
						t(Object(l.c)({
							subredditId: m.id
						}));
						const e = u.body.data.createScheduledPost.scheduledPost;
						e && Object(o.a)(Object(j.i)(Object(v.a)(e))(r));
						const s = "/r/".concat(m.name, "/about/content");
						return void t(Object(c.I)(s, !1))
					}
					const p = u.error;
					t(H(p))
				}, Y = e => async (t, s, a) => {
					let {
						apiContext: o
					} = a;
					const d = s(),
						l = Object(I.T)(d, e),
						u = !!Object(_.a)(d),
						E = d.creations.formData.isPoll,
						x = d.creations.formData.polls ? Q(d.creations.formData.polls, d) : Q({
							duration: n.w,
							options: []
						}, d);
					if (!l) return;
					if (t(B(l)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(I.s)(s()))) return;
					let f;
					if ((f = E ? Object(T.b)(d) ? await Object(g.a)(o(), Object.assign({}, l, {
								kind: w.p.POLL,
								poll: x
							})) : await
							function(e, t, s) {
								const a = t.destSubreddit.id;
								return Object(h.b)(e, {
									method: n.bb.POST,
									endpoint: "".concat(p.a.metaUrl, "/polls/").concat(a),
									type: "json",
									data: Object.assign({
										poll: s,
										subredditId: a
									}, Object(b.a)(Object(g.c)(t)))
								}).then(async e => {
									const s = e.ok ? Object.assign({}, e, {
											body: {
												json: {
													data: e.body
												}
											}
										}) : e,
										n = await Object(g.d)(s, t);
									if (n.ok) {
										const t = n.body;
										return {
											body: Object.assign({}, t, {
												poll: e.body.poll
											}),
											ok: !0,
											status: e.status
										}
									}
									return {
										error: n.body,
										ok: !1,
										status: e.status
									}
								})
							}(o(), l, x) : await Object(g.b)(o(), l)).ok) {
						const e = Object(R.i)(d),
							s = f.body;
						if (t(U({
								draftId: l.draftId,
								response: s
							})), E && !Object(T.b)(d) && t(Object(r.e)({
								poll: s.poll
							})), !u) {
							const n = (s.path || "/user/".concat(Object(N.f)(e), "/posts")).replace(/^\/r\/u_/, "/user/");
							t(Object(c.I)(n, !1))
						}
					} else {
						if (E) {
							const e = f.error;
							t(W(e))
						}
						const e = f.error;
						if (e.type === n.D.BAD_CAPTCHA_ERROR) t(z());
						else if (e.type === n.D.VALIDATION_ERROR) t(q(e));
						else if (e.type === n.D.SUBMIT_VALIDATION_ERROR) t(V(e));
						else if (e.type === n.D.RATELIMIT && u) {
							t(Object(i.i)());
							const s = e.fields && e.fields[0] && e.fields[0].msg || Object(y.c)("Layer creation has failed. You can create one layer per 60 minutes"),
								n = Object(m.d)(s, S.b.Error);
							t(Object(m.e)(n))
						} else t(H(e))
					}
					const v = Object(A.o)(l.kind),
						C = f.ok && f.body && f.body.id && Object(L.m)(f.body.id),
						j = s();
					O.o(j, v, C)
				}
		},
		"./src/reddit/actions/removalReasons/index.ts": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/lib/constants/index.ts"),
				o = s("./src/lib/makeCommentsPageKey/index.ts"),
				r = s("./src/lib/makeDraftKey/index.ts"),
				i = s("./src/reddit/helpers/isPost.ts"),
				c = s("./src/reddit/helpers/routeKey/index.ts"),
				d = s("./src/reddit/models/PostDraft/index.ts"),
				l = s("./src/reddit/actions/bulkActions/index.ts"),
				m = s("./src/reddit/actions/comment/index.ts"),
				u = s("./src/reddit/actions/modal.ts"),
				p = s("./src/reddit/actions/post.ts"),
				b = s("./src/reddit/actions/toaster.ts"),
				h = s("./src/reddit/constants/modals.ts"),
				g = s("./src/lib/makeApiRequest/index.ts"),
				E = s("./src/lib/omitHeaders/index.ts"),
				x = s("./src/reddit/constants/headers.ts"),
				f = s("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const v = (e, t) => Object(g.b)(Object(E.a)(e, [x.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/modactions/removal_reasons/"),
					method: a.bb.POST,
					type: "json",
					data: {
						item_ids: t.itemIds,
						reason_id: t.reasonId,
						mod_note: t.modNote
					}
				}),
				C = (e, t, s) => Object(g.b)(Object(E.a)(e, [x.a]), {
					endpoint: Object(f.a)("".concat(e.apiUrl, "/api/v1/modactions/removal_").concat(s, "_message/")),
					method: a.bb.POST,
					type: "json",
					data: t
				});
			var O = s("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				j = s("./src/reddit/i18n/utils.ts"),
				y = s("./src/reddit/models/ModQueue/index.ts"),
				k = s("./src/reddit/models/RemovalReason/index.ts"),
				w = s("./src/reddit/models/Toast/index.ts"),
				S = s("./src/reddit/selectors/comments.ts"),
				N = s("./src/reddit/selectors/platform.ts"),
				T = s("./src/reddit/actions/removalReasons/constants.ts");
			s.d(t, "removalReasonsPending", (function() {
				return _
			})), s.d(t, "removalReasonsLoaded", (function() {
				return I
			})), s.d(t, "removalReasonsFailed", (function() {
				return P
			})), s.d(t, "removalReasonsRequested", (function() {
				return M
			})), s.d(t, "removalReasonAddedPending", (function() {
				return R
			})), s.d(t, "removalReasonAddedSuccess", (function() {
				return L
			})), s.d(t, "removalReasonAddedFailed", (function() {
				return D
			})), s.d(t, "addRemovalReason", (function() {
				return A
			})), s.d(t, "editRemovalReasonPending", (function() {
				return F
			})), s.d(t, "editRemovalReasonSuccess", (function() {
				return B
			})), s.d(t, "editRemovalReasonFailed", (function() {
				return U
			})), s.d(t, "editRemovalReason", (function() {
				return H
			})), s.d(t, "deleteRemovalReasonPending", (function() {
				return W
			})), s.d(t, "deleteRemovalReasonSuccess", (function() {
				return q
			})), s.d(t, "deleteRemovalReasonFailed", (function() {
				return V
			})), s.d(t, "deleteRemovalReason", (function() {
				return z
			})), s.d(t, "removedItemsSelected", (function() {
				return K
			})), s.d(t, "fetchReasonsAndOpenModal", (function() {
				return Q
			})), s.d(t, "removalReasonSubmittedPending", (function() {
				return G
			})), s.d(t, "removalReasonSubmittedSuccess", (function() {
				return J
			})), s.d(t, "removalReasonSubmittedFailed", (function() {
				return Z
			})), s.d(t, "removalReasonMessagePending", (function() {
				return X
			})), s.d(t, "removalReasonPrivateMessageSuccess", (function() {
				return Y
			})), s.d(t, "removalReasonPublicMessageSuccess", (function() {
				return $
			})), s.d(t, "removalReasonMessageFailed", (function() {
				return ee
			})), s.d(t, "submitRemovalReason", (function() {
				return te
			})), s.d(t, "submitBulkRemovalReason", (function() {
				return se
			}));
			const _ = Object(n.a)(T.k),
				I = Object(n.a)(T.l),
				P = Object(n.a)(T.j),
				M = e => async (t, s, n) => {
					let {
						apiContext: o
					} = n;
					const r = s().subreddits.models[e].name;
					t(_());
					const i = await ((e, t) => Object(g.b)(Object(E.a)(e, [x.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons.json"),
						method: a.bb.GET
					}))(o(), r);
					i.ok ? t(I({
						subredditId: e,
						response: i.body
					})) : t(P(i.error))
				}, R = Object(n.a)(T.b), L = Object(n.a)(T.c), D = Object(n.a)(T.a), A = (e, t) => async (s, n, o) => {
					let {
						apiContext: r
					} = o;
					const i = n().subreddits.models[e].name;
					s(R());
					const c = await ((e, t, s) => Object(g.b)(Object(E.a)(e, [x.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons"),
						method: a.bb.POST,
						data: s
					}))(r(), i, t);
					if (c.ok) {
						const {
							id: n
						} = c.body, a = Object.assign({}, t, {
							id: n
						});
						s(L({
							subredditId: e,
							reason: a
						})), s(Object(b.e)({
							kind: w.b.SuccessMod,
							text: Object(j.c)("Removal reason added!")
						}))
					} else s(D(c.error))
				}, F = Object(n.a)(T.h), B = Object(n.a)(T.i), U = Object(n.a)(T.g), H = (e, t) => async (s, n, o) => {
					let {
						apiContext: r
					} = o;
					const i = n().subreddits.models[e].name;
					s(F());
					const c = await ((e, t, s) => Object(g.b)(Object(E.a)(e, [x.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons/").concat(s.id),
						method: a.bb.PUT,
						data: {
							message: s.message,
							title: s.title
						}
					}))(r(), i, t);
					c.ok ? (s(B({
						subredditId: e,
						reason: t
					})), s(Object(b.e)({
						kind: w.b.SuccessMod,
						text: Object(j.c)("Removal reason saved")
					}))) : s(U(c.error))
				}, W = Object(n.a)(T.e), q = Object(n.a)(T.f), V = Object(n.a)(T.d), z = (e, t) => async (s, n, o) => {
					let {
						apiContext: r
					} = o;
					const i = n().subreddits.models[e].name;
					s(W());
					const c = await ((e, t, s) => Object(g.b)(Object(E.a)(e, [x.a]), {
						endpoint: "".concat(e.apiUrl, "/api/v1/").concat(t, "/removal_reasons/").concat(s),
						method: a.bb.DELETE
					}))(r(), i, t);
					c.ok ? (s(q({
						subredditId: e,
						reasonId: t
					})), s(Object(b.e)({
						kind: w.b.SuccessMod,
						text: Object(j.c)("Removal reason deleted")
					}))) : s(V(c.error))
				}, K = Object(n.a)(T.t), Q = (e, t) => async (s, n, a) => {
					let {
						apiContext: o
					} = a;
					const r = n();
					r.removalReasons.reasonOrder[e] && r.removalReasons.reasonOrder[e].length > 0 || s(M(e)), s(K({
						subredditId: e,
						itemIds: t
					})), s(Object(u.i)(h.a.ADD_REMOVAL_REASON))
				}, G = Object(n.a)(T.r), J = Object(n.a)(T.s), Z = Object(n.a)(T.q), X = Object(n.a)(T.n), Y = Object(n.a)(T.o), $ = Object(n.a)(T.p), ee = Object(n.a)(T.m), te = (e, t, s, n, l) => async (u, b, h) => {
					let {
						apiContext: g
					} = h;
					const E = b(),
						x = E.user.account && E.user.account.displayText,
						f = e[0],
						j = Object(i.a)(f) ? k.e.Post : k.e.Comment,
						y = j === k.e.Post ? E.posts.models[f] : E.comments.models[f],
						w = j === k.e.Post ? p.E : m.R;
					if (!y || !x) return;
					u(G()), u(w({
						[f]: {
							modNote: l,
							modRemovalReason: t && t.title,
							modReasonBy: x
						}
					}));
					const T = {
							itemIds: e,
							modNote: l,
							reasonId: t ? t.id : null
						},
						_ = await v(g(), T);
					if (_.ok) {
						if (u(J()), t) {
							u(X());
							const i = {
									itemId: e,
									message: s,
									title: t.title,
									type: n
								},
								l = await C(g(), Object(k.h)(i, j), j);
							if (l.ok)
								if (n === k.f.Public) {
									if (u($()), l.body) {
										const e = Object(O.a)(l.body, x),
											t = {
												comment: e,
												parentId: f
											},
											s = Object(N.g)(E),
											n = E.platform.currentPage && E.platform.currentPage.routeMatch;
										let i = s && n && Object(c.a)(n, E, E.posts.models[e.postId]);
										if (i || (i = Object(o.a)(e.postId, null, {
												sort: a.r,
												hasSortParam: !0
											})), j === k.e.Post) {
											const s = Object(r.a)(d.c.replyToPost, f);
											u(Object(m.mb)(Object.assign({}, t, {
												headCommentId: Object(S.x)(E, {
													commentsPageKey: i
												}),
												commentsPageKey: i,
												draftKey: s
											})));
											const n = E.postStickiedComments.data[f];
											u(Object(m.ib)({
												id: e.id,
												postId: e.postId,
												commentsPageKey: i
											})), n && n !== e.id && u(Object(m.R)({
												[n]: {
													isStickied: !1
												}
											}))
										} else if (j === k.e.Comment) {
											const e = Object(r.a)(d.c.replyToComment, y.id),
												s = Object(S.j)(E, {
													commentId: f,
													commentsPageKey: i
												});
											u(Object(m.kb)(Object.assign({}, t, {
												parentCommentId: f,
												commentsPageKey: i,
												draftKey: e,
												depth: s + 1
											})))
										}
									}
								} else u(Y());
							else u(ee(l.error))
						}
					} else u(Z(_.error)), u(w({
						[f]: {
							modNote: y.modNote,
							modRemovalReason: y.modRemovalReason,
							modReasonBy: y.modReasonBy
						}
					}))
				}, se = (e, t, s, n, a) => async (o, r, i) => {
					let {
						apiContext: c
					} = i;
					const d = r(),
						m = d.user.account && d.user.account.displayText;
					if (!m) return;
					o(G());
					const u = Object(b.e)({
							kind: w.b.SuccessMod,
							text: Object(j.c)("Added removal reason for ".concat(Object(j.b)("number", e.length), " posts/comments"))
						}),
						p = {
							itemIds: e,
							modNote: a,
							reasonId: t ? t.id : null
						},
						h = await v(c(), p);
					if (h.ok) {
						const r = {
							ids: e,
							operation: y.a.RemovalReason,
							username: m,
							options: {
								modNote: a,
								removalReason: t && t.title
							}
						};
						if (o(Object(l.b)(r)), t) {
							const a = {
									itemId: e,
									message: s,
									title: t.title,
									type: n
								},
								r = await C(c(), Object(k.h)(a, k.e.Bulk), k.e.Bulk);
							r.ok ? (o(Y()), o(u)) : o(ee(r.error))
						} else o(u)
					} else o(Z(h.error))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return g
			})), s.d(t, "d", (function() {
				return x
			})), s.d(t, "a", (function() {
				return f
			})), s.d(t, "b", (function() {
				return v
			}));
			var n = s("./src/lib/makeActionCreator/index.ts"),
				a = s("./src/reddit/actions/postCreation/submit.ts"),
				o = s("./src/reddit/actions/scheduledPosts/constants.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/reddit/endpoints/scheduledPosts/index.ts"),
				c = s("./src/reddit/endpoints/scheduledPosts/update.ts"),
				d = s("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				l = s("./src/reddit/models/Toast/index.ts"),
				m = s("./src/reddit/selectors/scheduledPosts/index.ts");
			const u = Object(n.a)(o.c),
				p = Object(n.a)(o.g),
				b = Object(n.a)(o.b),
				h = Object(n.a)(o.a),
				g = Object(n.a)(o.d),
				E = Object(n.a)(o.h),
				x = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					if (Object(m.b)(s(), {
							subredditId: e
						})) return;
					t(u());
					const c = await Object(i.b)(a(), {
						subredditId: e,
						first: 25
					});
					if (!c.ok || !c.body || !c.body.data.subredditInfoById.scheduledPosts) return t(h()), void t(Object(r.e)(Object(r.d)(o.l(), l.b.Error, o.m(), x(e))));
					t(b(Object(d.b)(c.body.data)))
				}, f = e => async (t, s, n) => {
					let {
						gqlContext: a
					} = n;
					const o = s();
					if (!Object(m.b)(o, {
							subredditId: e
						})) return t(x(e));
					if (!Object(m.c)(o, {
							subredditId: e
						})) return;
					const r = Object(m.a)(o, {
						subredditId: e
					});
					if (!r) return;
					t(u());
					const c = await Object(i.b)(a(), {
						subredditId: e,
						first: 25,
						after: r
					});
					c.ok ? t(b(Object(d.b)(c.body.data))) : t(h())
				}, v = (e, t) => async (s, n, o) => {
					let {
						gqlContext: r
					} = o;
					s(p(t));
					const i = {
						[e]: !t[e]
					};
					let d;
					if ((d = "isSticky" === e ? await Object(c.a)(r(), {
							id: t.id,
							sticky: t[e] ? "NONE" : "SECOND"
						}) : await Object(c.a)(r(), Object.assign({
							id: t.id
						}, i))).ok) {
						const e = Object.assign({}, t, i);
						return void s(E({
							scheduledPost: e
						}))
					}
					const l = d.error;
					s(Object(a.a)(l))
				}
		},
		"./src/reddit/actions/streaming/modSettings.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/streaming/constants.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/graphql/operations/FetchSubredditStreamingModSettings.json"),
				c = s("./src/lib/makeGqlRequest/index.ts"),
				d = s("./src/graphql/operations/UpdateSubredditStreamingModSettings.json"),
				l = s("./src/reddit/models/Toast/index.ts"),
				m = s("./src/reddit/selectors/subreddit.ts");
			s.d(t, "a", (function() {
				return p
			})), s.d(t, "b", (function() {
				return b
			}));
			const u = Object(a.a)(o.a),
				p = e => async (t, s, a) => {
					let {
						gqlContext: o
					} = a;
					const d = Object(m.S)(s(), {
						subredditId: e
					});
					if (void 0 !== d) {
						const s = await ((e, t) => Object(c.a)(e, Object.assign({}, i, {
							variables: {
								subredditId: t
							}
						})))(o(), e);
						if (s.ok && s.body) {
							const n = s.body.data.subredditInfoById;
							if (n) return await t(u({
								subredditId: e,
								modSettings: n.liveStreamingInfo
							})), {
								success: !0
							}
						}
						const a = (e => {
							const t = n.fbt._("Could not fetch settings for '{subredditName}'", [n.fbt._param("subredditName", e)], {
								hk: "2b2yFB"
							});
							return Object(r.d)(t, l.b.Error)
						})(d.name);
						t(Object(r.e)(Object.assign({}, a, {
							duration: r.a
						})))
					}
					return {
						success: !1
					}
				}, b = (e, t) => async (s, n, a) => {
					const o = await ((e, t) => Object(c.a)(e, Object.assign({}, d, {
						variables: t
					})))(a.gqlContext(), {
						input: {
							subredditId: e,
							liveStreamingModeratorSettings: t
						}
					});
					if (o.ok && o.body.data.updateSubredditLiveStreamingModeratorSettings.ok) {
						if ((await p(e)(s, n, a)).success) return {
							success: !0
						}
					}
					return {
						success: !1
					}
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/graphql/operations/SubredditWikiBannedContributors.json"),
				l = s("./src/reddit/constants/headers.ts");
			const m = (e, t) => Object(i.a)(e, Object.assign({}, d, {
				variables: t
			}));
			var u = e => {
					const {
						bannedMembersInfo: t
					} = e, {
						edges: s,
						pageInfo: n
					} = t, a = [], o = {};
					return s.forEach(e => {
						const {
							date: t,
							redditor: s,
							editWikiBanInfo: n
						} = e.node;
						s.id && s.name && s.icon && (o[s.id] = {
							id: s.id,
							username: s.name,
							iconUrl: s.icon.url,
							date: t,
							daysRemaining: n.daysRemaining,
							note: n.note
						}, a.push(s.id))
					}), {
						afterToken: n.hasNextPage ? n.endCursor : null,
						bannedContributors: o,
						userOrder: a
					}
				},
				p = s("./src/reddit/i18n/utils.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			s.d(t, "e", (function() {
				return f
			})), s.d(t, "b", (function() {
				return C
			})), s.d(t, "a", (function() {
				return j
			})), s.d(t, "c", (function() {
				return k
			})), s.d(t, "d", (function() {
				return S
			}));
			const g = Object(a.a)(h.d),
				E = Object(a.a)(h.c),
				x = Object(a.a)(h.b),
				f = e => async (t, s, a) => {
					t(g({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						r = await m(a.gqlContext(), o);
					if (r.ok) {
						const s = r.body,
							n = s.data.subreddit && s.data.subreddit.wiki;
						if (n) {
							const s = u(n);
							t(E(Object.assign({}, s, {
								subredditName: e.toLowerCase()
							})))
						}
					} else {
						const s = r.error || {
							type: n.D.UNKNOWN_ERROR
						};
						t(x({
							error: s,
							subredditName: e.toLowerCase()
						}))
					}
					return r.ok
				}, v = Object(a.a)(h.a), C = (e, t) => async (s, n, a) => {
					const r = {
							subredditName: e,
							after: t
						},
						i = await m(a.gqlContext(), r);
					if (i.ok) {
						const t = i.body;
						if (t.data.subreddit.wiki) {
							const n = u(t.data.subreddit.wiki);
							s(v(Object.assign({}, n, {
								subredditName: e.toLowerCase()
							})))
						}
					} else s(Object(o.e)({
						kind: b.b.Error,
						text: Object(p.c)("Something went wrong"),
						buttonText: Object(p.c)("Retry"),
						buttonAction: C(e, t)
					}));
					return i.ok
				}, O = Object(a.a)(h.e), j = (e, t) => async (s, a, i) => {
					const d = await ((e, t, s) => Object(r.b)(Object(c.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/friend"),
						method: n.bb.POST,
						data: {
							api_type: "json",
							name: s.username,
							type: "wikibanned",
							duration: s.duration,
							ban_reason: s.banReason,
							note: s.note
						}
					}))(i.apiContext(), e, t);
					if (d.ok) {
						s(Object(o.e)({
							kind: b.b.SuccessMod,
							text: Object(p.c)("Successfully banned user")
						}));
						const n = {
								subredditName: e,
								username: t.username
							},
							a = (await m(i.gqlContext(), n)).body;
						if (a.data.subreddit.wiki) {
							const t = u(a.data.subreddit.wiki);
							s(O({
								bannedContributor: t.bannedContributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (d.error) {
						let e;
						d.error.type === n.D.USER_DOESNT_EXIST && (e = Object(p.c)("That user doesn't exist")), s(Object(o.e)({
							kind: b.b.Error,
							text: e || Object(p.c)("Something went wrong")
						}))
					}
					return d.ok
				}, y = Object(a.a)(h.f), k = (e, t) => async (s, a, i) => {
					const d = await ((e, t, s) => Object(r.b)(Object(c.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/unfriend"),
						method: n.bb.POST,
						data: {
							api_type: "json",
							id: s,
							type: "wikibanned"
						}
					}))(i.apiContext(), e, t);
					return d.ok ? (s(Object(o.e)({
						kind: b.b.SuccessMod,
						text: Object(p.c)("User has been successfully removed")
					})), s(y({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : s(Object(o.e)({
						kind: b.b.Error,
						text: Object(p.c)("Something went wrong"),
						buttonText: Object(p.c)("Retry"),
						buttonAction: k(e, t)
					})), d.ok
				}, w = Object(a.a)(h.g), S = (e, t) => async (s, n, a) => {
					const r = {
							subredditName: e,
							username: t
						},
						i = await m(a.gqlContext(), r);
					if (i.ok) {
						const t = i.body;
						if (t.data.subreddit.wiki) {
							const n = u(t.data.subreddit.wiki),
								a = Object.keys(n.bannedContributors)[0];
							s(w({
								subredditName: e.toLowerCase(),
								bannedContributor: n.bannedContributors[a]
							}))
						}
					} else s(Object(o.e)({
						kind: b.b.Error,
						text: Object(p.c)("Something went wrong")
					}));
					return i.ok
				}
		},
		"./src/reddit/actions/wiki/wikiContributors/index.ts": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				r = s("./src/lib/makeApiRequest/index.ts"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/graphql/operations/SubredditWikiContributors.json"),
				l = s("./src/reddit/constants/headers.ts");
			const m = (e, t) => Object(i.a)(e, Object.assign({}, d, {
				variables: t
			}));
			var u = e => {
					const {
						contributorsInfo: t
					} = e, {
						edges: s,
						pageInfo: n
					} = t, a = [], o = {};
					return s.forEach(e => {
						const {
							date: t,
							redditor: s
						} = e.node;
						s.id && s.name && s.icon && (o[s.id] = {
							id: s.id,
							username: s.name,
							iconUrl: s.icon.url,
							date: t
						}, a.push(s.id))
					}), {
						afterToken: n.hasNextPage ? n.endCursor : null,
						contributors: o,
						userOrder: a
					}
				},
				p = s("./src/reddit/i18n/utils.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			s.d(t, "e", (function() {
				return f
			})), s.d(t, "b", (function() {
				return C
			})), s.d(t, "a", (function() {
				return j
			})), s.d(t, "c", (function() {
				return k
			})), s.d(t, "d", (function() {
				return S
			}));
			const g = Object(a.a)(h.d),
				E = Object(a.a)(h.c),
				x = Object(a.a)(h.b),
				f = e => async (t, s, a) => {
					t(g({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						r = await m(a.gqlContext(), o);
					if (r.ok) {
						const s = r.body,
							n = s.data.subreddit && s.data.subreddit.wiki;
						if (n) {
							const s = u(n);
							t(E(Object.assign({}, s, {
								subredditName: e.toLowerCase()
							})))
						}
					} else {
						const s = r.error || {
							type: n.D.UNKNOWN_ERROR
						};
						t(x({
							error: s,
							subredditName: e.toLowerCase()
						}))
					}
					return r.ok
				}, v = Object(a.a)(h.a), C = (e, t) => async (s, n, a) => {
					const r = {
							subredditName: e,
							after: t
						},
						i = await m(a.gqlContext(), r);
					if (i.ok) {
						const t = i.body;
						if (t.data.subreddit.wiki) {
							const n = u(t.data.subreddit.wiki);
							s(v(Object.assign({}, n, {
								subredditName: e.toLowerCase()
							})))
						}
					} else s(Object(o.e)({
						kind: b.b.Error,
						text: Object(p.c)("Something went wrong"),
						buttonText: Object(p.c)("Retry"),
						buttonAction: C(e, t)
					}));
					return i.ok
				}, O = Object(a.a)(h.e), j = (e, t) => async (s, a, i) => {
					const d = await ((e, t, s) => Object(r.b)(Object(c.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/friend"),
						method: n.bb.POST,
						data: {
							api_type: "json",
							name: s,
							type: "wikicontributor"
						}
					}))(i.apiContext(), e, t);
					if (d.ok) {
						s(Object(o.e)({
							kind: b.b.SuccessMod,
							text: Object(p.c)("User has been successfully added")
						}));
						const n = {
								subredditName: e,
								username: t
							},
							r = (await m(i.gqlContext(), n)).body;
						if (r.data.subreddit.wiki) {
							const t = u(r.data.subreddit.wiki),
								n = Object.keys(t.contributors)[0];
							!!a().subreddits.subredditWiki.wikiContributors.listing.models[e.toLowerCase()][n] || s(O({
								contributor: t.contributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (d.error) {
						let e;
						const t = d.error.type;
						t === n.D.USER_DOESNT_EXIST ? e = Object(p.c)("That user doesn't exist") : t === n.D.BANNED_FROM_SUBREDDIT && (e = Object(p.c)("That user is banned from the subreddit")), s(Object(o.e)({
							kind: b.b.Error,
							text: e || Object(p.c)("Something went wrong")
						}))
					}
					return d.ok
				}, y = Object(a.a)(h.f), k = (e, t) => async (s, a, i) => {
					const d = await ((e, t, s) => Object(r.b)(Object(c.a)(e, [l.a]), {
						endpoint: "".concat(e.apiUrl, "/r/").concat(t, "/api/unfriend"),
						method: n.bb.POST,
						data: {
							api_type: "json",
							id: s,
							type: "wikicontributor"
						}
					}))(i.apiContext(), e, t);
					return d.ok ? (s(Object(o.e)({
						kind: b.b.SuccessMod,
						text: Object(p.c)("User has been successfully removed")
					})), s(y({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : s(Object(o.e)({
						kind: b.b.Error,
						text: Object(p.c)("Something went wrong"),
						buttonText: Object(p.c)("Retry"),
						buttonAction: k(e, t)
					})), d.ok
				}, w = Object(a.a)(h.g), S = (e, t) => async (s, n, a) => {
					const r = {
							subredditName: e,
							username: t
						},
						i = await m(a.gqlContext(), r);
					if (i.ok) {
						const t = i.body;
						if (t.data.subreddit.wiki) {
							const n = u(t.data.subreddit.wiki),
								a = Object.keys(n.contributors)[0];
							s(w({
								subredditName: e.toLowerCase(),
								contributor: n.contributors[a]
							}))
						}
					} else s(Object(o.e)({
						kind: b.b.Error,
						text: Object(p.c)("Something went wrong")
					}));
					return i.ok
				}
		},
		"./src/reddit/actions/wiki/wikiPageSettings/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/subredditSettings.ts"),
				r = s("./src/reddit/actions/toaster.ts"),
				i = s("./src/lib/makeApiRequest/index.ts"),
				c = s("./src/lib/makeGqlRequest/index.ts"),
				d = s("./src/lib/omitHeaders/index.ts"),
				l = s("./src/reddit/constants/headers.ts"),
				m = s("./src/graphql/operations/SubredditWikiPageSettings.json"),
				u = s("./src/reddit/models/SubredditWikiPage/index.ts");
			const p = (e, t) => Object(c.a)(e, Object.assign({}, m, {
					variables: t
				})),
				b = {
					[u.a.Inherit]: "0",
					[u.a.Contributors]: "1",
					[u.a.Mods]: "2"
				};
			var h = e => {
					const {
						editPermissions: t,
						editorsInfo: s,
						isVisible: n
					} = e, {
						edges: a,
						pageInfo: o
					} = s, r = [];
					return a.forEach(e => {
						e.node.name && e.node.icon && r.push({
							username: e.node.name,
							iconUrl: e.node.icon.url
						})
					}), {
						editPermissions: t,
						editorsInfo: r,
						isVisible: n,
						afterToken: o.hasNextPage ? o.endCursor : null
					}
				},
				g = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				E = s("./src/reddit/i18n/utils.ts"),
				x = s("./src/reddit/models/Toast/index.ts"),
				f = s("./src/reddit/selectors/subreddit.ts"),
				v = s("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			s.d(t, "c", (function() {
				return O
			})), s.d(t, "b", (function() {
				return y
			})), s.d(t, "e", (function() {
				return w
			})), s.d(t, "a", (function() {
				return S
			})), s.d(t, "d", (function() {
				return T
			}));
			const C = Object(a.a)(v.c),
				O = (e, t) => async (s, n, a) => {
					const r = {
							subredditName: e,
							wikiPageName: t
						},
						i = await p(a.gqlContext(), r),
						c = Object(f.G)(n(), e);
					if (Object(f.U)(n(), c) || await s(Object(o.f)(e, c)), i.ok) {
						const e = i.body,
							t = e.data.subreddit && e.data.subreddit.wiki;
						if (t && t.page) {
							const e = h(t.page.settings);
							s(C({
								pageKey: Object(g.a)(r),
								settings: e
							}))
						}
					}
					return i.ok
				}, j = Object(a.a)(v.b), y = (e, t, s) => async (n, a, o) => {
					const i = {
							subredditName: e,
							wikiPageName: t,
							after: s
						},
						c = await p(o.gqlContext(), i);
					if (c.ok) {
						const s = c.body,
							a = s.data.subreddit && s.data.subreddit.wiki;
						if (a && a.page) {
							const s = h(a.page.settings),
								{
									editorsInfo: o,
									afterToken: r
								} = s;
							n(j({
								editorsInfo: o,
								afterToken: r,
								pageKey: Object(g.a)({
									wikiPageName: t,
									subredditName: e
								})
							}))
						}
					} else n(Object(r.e)({
						kind: x.b.Error,
						text: Object(E.c)("Something went wrong"),
						buttonText: Object(E.c)("Retry"),
						buttonAction: y(e, t, s)
					}));
					return c.ok
				}, k = Object(a.a)(v.d), w = e => {
					let {
						editPermissions: t,
						isVisible: s,
						wikiPageName: a,
						subredditName: o
					} = e;
					return async (e, r, c) => {
						const m = await (e => Object(i.b)(Object(d.a)(e.context, [l.a]), {
							endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/wiki/settings/").concat(e.wikiPageName),
							method: n.bb.POST,
							data: {
								permlevel: b[e.editPermissions],
								listed: e.isVisible ? "on" : void 0
							}
						}))({
							context: c.apiContext(),
							editPermissions: t,
							isVisible: s,
							wikiPageName: a,
							subredditName: o
						});
						return m.ok && e(k({
							editPermissions: t,
							isVisible: s,
							pageKey: Object(g.a)({
								wikiPageName: a,
								subredditName: o
							})
						})), m.ok
					}
				}, S = e => {
					let {
						subredditName: t,
						username: s,
						wikiPageName: a
					} = e;
					return async (e, o, c) => {
						const m = await (e => Object(i.b)(Object(d.a)(e.context, [l.a]), {
							endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/api/wiki/alloweditor/add"),
							method: n.bb.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: c.apiContext(),
							wikiPageName: a,
							subredditName: t,
							username: s
						});
						if (m.ok) e(Object(r.e)({
							kind: x.b.SuccessCommunity,
							text: "User successfully added"
						})), await e(O(t, a));
						else if (m.error) {
							const t = m.error.type;
							let s = Object(E.c)("Something went wrong");
							t === n.D.NOT_FOUND_ERROR && (s = Object(E.c)("That user does not exist")), e(Object(r.e)({
								kind: x.b.Error,
								text: s
							}))
						}
						return m.ok
					}
				}, N = Object(a.a)(v.a), T = e => {
					let {
						subredditName: t,
						username: s,
						wikiPageName: a
					} = e;
					return async (e, o, c) => {
						const m = await (e => Object(i.b)(Object(d.a)(e.context, [l.a]), {
							endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/api/wiki/alloweditor/del"),
							method: n.bb.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: c.apiContext(),
							wikiPageName: a,
							subredditName: t,
							username: s
						});
						return m.ok && (e(Object(r.e)({
							kind: x.b.SuccessCommunity,
							text: "User has been successfully removed"
						})), e(N({
							username: s,
							pageKey: Object(g.a)({
								wikiPageName: a,
								subredditName: t
							})
						}))), m.ok
					}
				}
		},
		"./src/reddit/actions/wiki/wikiRevisions/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts"),
				a = s("./src/lib/makeActionCreator/index.ts"),
				o = s("./src/reddit/actions/toaster.ts"),
				r = s("./src/reddit/endpoints/page/subredditWiki.ts"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/graphql/operations/WikiRevisions.json");
			var d = s("./src/lib/makeApiRequest/index.ts"),
				l = s("./src/lib/omitHeaders/index.ts"),
				m = s("./src/reddit/constants/headers.ts"),
				u = s("./src/reddit/helpers/wiki/wikiRevision.ts");
			var p = (e, t) => Object(d.b)(Object(l.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t.subredditName, "/api/wiki/hide"),
				method: n.bb.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(u.b)(t.revisionId)
				}
			});
			var b = (e, t) => Object(d.b)(Object(l.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/r/").concat(t.subredditName, "/api/wiki/revert"),
				method: n.bb.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(u.b)(t.revisionId)
				}
			});
			var h = e => {
					const t = e.subreddit && e.subreddit.wiki || {},
						s = t.pageRevisions && t.pageRevisions.revisions || t.recentRevisions;
					if (!s) throw new Error("Invalid response");
					return (e => {
						const t = {},
							s = [];
						return e.edges.forEach(e => {
							const n = e.node;
							t[n.id] = n, s.push(n.id)
						}), {
							pageInfo: e.pageInfo,
							revisions: t,
							revisionsIds: s
						}
					})(s)
				},
				g = s("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				E = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				x = s("./src/reddit/i18n/utils.ts"),
				f = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/selectors/subredditWiki.ts"),
				C = s("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			s.d(t, "c", (function() {
				return k
			})), s.d(t, "a", (function() {
				return S
			})), s.d(t, "b", (function() {
				return T
			}));
			const O = Object(a.a)(C.d),
				j = Object(a.a)(C.c),
				y = Object(a.a)(C.b),
				k = e => async (t, s, a) => {
					const {
						canLoadMore: r = !1,
						canShowFailToast: d = !1,
						isRecent: l,
						subredditName: m,
						wikiPageName: u
					} = e, p = s(), b = Object(g.a)(e), E = Object(v.p)(p, {
						listingKey: b
					});
					if (!r && !!E) return !0;
					const C = E && E.pageInfo.endCursor || void 0;
					if (!(!E || E.pageInfo.hasNextPage)) return !0;
					const w = {
							after: C,
							isRecent: l,
							subredditName: m,
							wikiPageName: u
						},
						S = {
							key: b,
							options: w
						};
					t(O(S));
					const N = await ((e, t) => Object(i.a)(e, Object.assign({}, c, {
						variables: t
					})))(a.gqlContext(), w);
					if (N.ok) {
						const e = N.body;
						if (e.data.subreddit) {
							const s = h(e.data);
							t(j(Object.assign({}, S, s)))
						}
					} else {
						const s = N.error || {
							type: n.D.UNKNOWN_ERROR
						};
						t(y(Object.assign({}, S, {
							error: s
						}))), d && t(Object(o.e)({
							kind: f.b.Error,
							text: Object(x.c)("Something went wrong"),
							buttonText: Object(x.c)("Retry"),
							buttonAction: k(e)
						}))
					}
					return N.ok
				}, w = Object(a.a)(C.a), S = e => async (t, s, n) => {
					const {
						subredditName: a,
						wikiPageName: i
					} = e, c = Object(E.a)(Object.assign({}, e, {
						revisionId: void 0
					})), d = Object(g.a)(Object.assign({}, e, {
						isRecent: !1
					})), l = Object(g.a)(Object.assign({}, e, {
						isRecent: !0
					})), m = Object(v.p)(s(), {
						listingKey: d
					}), u = m && m.ids[0];
					if ((await b(n.apiContext(), e)).ok) {
						const e = (await Object(r.a)(n.gqlContext(), {
								includePageData: !0,
								subredditName: a,
								wikiPageName: i
							})).body,
							s = e.data.subreddit && e.data.subreddit.wiki,
							m = s && s.page;
						if (!m || !m.revision) return;
						if (m.revision.id === u) return void t(Object(o.e)({
							kind: f.b.SuccessCommunityGreen,
							text: Object(x.c)("Wiki page is already at selected revision!")
						}));
						t(w({
							page: m,
							pageKey: c,
							pageRevisionsListingKey: d,
							recentRevisionsListingKey: l,
							subredditName: a,
							wikiPageName: i
						}))
					} else t(Object(o.e)({
						kind: f.b.Error,
						text: Object(x.c)("Something went wrong"),
						buttonText: Object(x.c)("Retry"),
						buttonAction: S(e)
					}))
				}, N = Object(a.a)(C.e), T = e => async (t, s, n) => {
					const a = await p(n.apiContext(), e);
					if (a.ok) {
						const s = a.body.status;
						t(N({
							revisionId: e.revisionId,
							isHidden: s
						}))
					} else t(Object(o.e)({
						kind: f.b.Error,
						text: Object(x.c)("Something went wrong"),
						buttonText: Object(x.c)("Retry"),
						buttonAction: S(e)
					}))
				}
		},
		"./src/reddit/components/AdLinkWrapper/index.m.less": function(e, t, s) {
			e.exports = {
				AdLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				adLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT"
			}
		},
		"./src/reddit/components/AdLinkWrapper/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/components/AdLinkWrapper/index.m.less"),
				a = s.n(n);
			const o = s("./src/lib/lessComponent.tsx").a.div("AdLinkWrapper", a.a);
			t.a = o
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less": function(e, t, s) {
			e.exports = {
				PrimaryButton: "_2MgVqpGJKTGicaQowt_R9h",
				primaryButton: "_2MgVqpGJKTGicaQowt_R9h"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/index.m.less": function(e, t, s) {
			e.exports = {
				PencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				pencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS"
			}
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/DaysInput.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				d = s("./src/reddit/i18n/utils.ts"),
				l = s("./src/reddit/components/BannedUserList/AddBannedUserModal/_AddBannedUserModal.m.less"),
				m = s.n(l);
			const u = r.a.div("BanLength", m.a),
				p = r.a.wrapped(i.m, "BanLengthDays", m.a),
				b = r.a.wrapped(i.h, "NumberInput", m.a),
				h = r.a.div("StyledPermanentLabel", m.a),
				g = r.a.div("DescriptionText", m.a),
				E = r.a.div("BanLengthContainer", m.a),
				x = r.a.div("CheckboxWrapper", m.a),
				f = r.a.div("PermanentCheckbox", m.a);
			t.a = e => a.a.createElement(i.f, null, a.a.createElement(i.i, null, Object(d.c)("How long?")), a.a.createElement(E, null, a.a.createElement(u, {
				className: Object(o.a)({
					[m.a.isDisabled]: e.isDurationPermanent
				})
			}, a.a.createElement(b, {
				tabIndex: 0,
				disabled: e.isDurationPermanent,
				onChange: e.onChangeDuration,
				min: "0",
				type: "number",
				value: void 0 !== e.duration && null !== e.duration ? e.duration : ""
			}), a.a.createElement(p, null, Object(d.c)("Days"))), a.a.createElement(h, {
				onClick: e.togglePermanent
			}, a.a.createElement(f, {
				onKeyDown: e.togglePermanent
			}, a.a.createElement(x, {
				tabIndex: 0
			}, e.isDurationPermanent ? a.a.createElement(c.b, null) : a.a.createElement(c.a, null))), a.a.createElement(g, null, Object(d.c)("Permanent")))))
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/RulesDropdown.m.less": function(e, t, s) {
			e.exports = {
				Container: "cCcS9FtX9EtCZndWE2KoT",
				container: "cCcS9FtX9EtCZndWE2KoT",
				Dropdown: "_2SggQ3MVXsSCJaJnZohv5W",
				dropdown: "_2SggQ3MVXsSCJaJnZohv5W",
				Row: "_2_cyr9JIpA0CtkJpzPGSMX",
				row: "_2_cyr9JIpA0CtkJpzPGSMX",
				dropdownTarget: "_16JYr1_9yGQHSLHdyiWlGz",
				targetText: "_2A6qbw0TmdARh8bjwQ2ofj",
				DropdownRow: "_2lfpXKpvpeZ4oyQ-CMp9Le",
				dropdownRow: "_2lfpXKpvpeZ4oyQ-CMp9Le"
			}
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/RulesDropdown.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/lessComponent.tsx"),
				c = s("./src/reddit/constants/keycodes.ts"),
				d = s("./src/reddit/controls/Dropdown/index.tsx"),
				l = s("./src/reddit/controls/Dropdown/Row.tsx"),
				m = s("./src/reddit/i18n/utils.ts"),
				u = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				p = s("./src/reddit/selectors/oldSiteRules.ts"),
				b = s("./src/reddit/selectors/subreddit.ts"),
				h = s("./src/reddit/components/BannedUserList/AddBannedUserModal/RulesDropdown.m.less"),
				g = s.n(h);
			const E = i.a.div("Container", g.a),
				x = i.a.wrapped(d.a, "Dropdown", g.a),
				f = i.a.wrapped(l.b, "DropdownRow", g.a),
				v = Object(r.c)({
					oldSiteRules: p.a,
					subredditRules: b.R
				}),
				C = Object(o.b)(v);
			class O extends a.a.Component {
				constructor(e) {
					super(e), this.api = null, this.closeDropdown = () => {
						this.state.isOpen && this.setState({
							isOpen: !1
						})
					}, this.handleToggleDropdown = () => this.setState({
						isOpen: !this.state.isOpen
					}), this.handleSelectReason = (e, t) => {
						this.props.onSelectReason(t), e.key !== c.b.Tab && e.preventDefault(), this.closeDropdown()
					}, this.getRuleShortNames = () => {
						return [...this.props.subredditRules ? this.props.subredditRules.map(e => e.shortName) : [], ...this.props.oldSiteRules, "other"]
					}, this.state = {
						isOpen: !1,
						activeRow: -1
					}, this.api = {
						closeDropdown: this.closeDropdown
					}
				}
				componentDidMount() {
					this.props.onDropdownApi && this.props.onDropdownApi(this.api)
				}
				componentWillMount() {
					this.props.onDropdownApi && this.props.onDropdownApi(null)
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(E, null, a.a.createElement("button", {
						className: g.a.dropdownTarget,
						onClick: this.handleToggleDropdown
					}, a.a.createElement("div", {
						className: g.a.targetText
					}, e.reason || Object(m.c)("None")), a.a.createElement(u.b, null)), t.isOpen && a.a.createElement(x, {
						isOverlay: !0
					}, this.getRuleShortNames().map((t, s) => a.a.createElement(f, {
						key: t,
						displayText: t,
						index: s,
						isSelected: e.reason === t,
						onClick: e => this.handleSelectReason(e, t)
					}))))
				}
			}
			t.a = C(O)
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/_AddBannedUserModal.m.less": function(e, t, s) {
			e.exports = {
				Unban: "_1MjK_ZbXYkYgjvnYRxXErB",
				unban: "_1MjK_ZbXYkYgjvnYRxXErB",
				UnbanButton: "yByd-IEj7iofnvyb9tmne",
				unbanButton: "yByd-IEj7iofnvyb9tmne",
				PrimaryButton: "EM-EsR6tL9UA_MTsXHtS0",
				primaryButton: "EM-EsR6tL9UA_MTsXHtS0",
				ModalText: "_2Y9SCHsLMT105713rB10IV",
				modalText: "_2Y9SCHsLMT105713rB10IV",
				BanLength: "_14KS1Rt4ecAeHrAVFStL2n",
				banLength: "_14KS1Rt4ecAeHrAVFStL2n",
				isDisabled: "_3FQWLp6TeLNW0P14RMTGUn",
				BanLengthDays: "_34HussaQod-Yr8UQii6_EM",
				banLengthDays: "_34HussaQod-Yr8UQii6_EM",
				NumberInput: "_2_hBB86aqyqySSaODRHCt8",
				numberInput: "_2_hBB86aqyqySSaODRHCt8",
				StyledPermanentLabel: "_28lH71X854yinMNr2pzLlV",
				styledPermanentLabel: "_28lH71X854yinMNr2pzLlV",
				DescriptionText: "_2qrQzheLoaZZVefsJXThbW",
				descriptionText: "_2qrQzheLoaZZVefsJXThbW",
				BanLengthContainer: "Wt-OAd3PRXDzyks4SeiTT",
				banLengthContainer: "Wt-OAd3PRXDzyks4SeiTT",
				Bullet: "LusCMd8yHS-4_9XlhZpDY",
				bullet: "LusCMd8yHS-4_9XlhZpDY",
				VisibilityNote: "_1znuUPndM3k-XpOdaInCRt",
				visibilityNote: "_1znuUPndM3k-XpOdaInCRt",
				PermanentCheckbox: "_2yikAT1fG9F2gljm8b0FM5",
				permanentCheckbox: "_2yikAT1fG9F2gljm8b0FM5",
				ModalFooter: "Zfyj5B049nkMNmpt2F4PK",
				modalFooter: "Zfyj5B049nkMNmpt2F4PK",
				FooterRow: "ayyLCu5N-CWR6bsdVNMwW",
				footerRow: "ayyLCu5N-CWR6bsdVNMwW",
				CheckboxWrapper: "_33C5Xe1t7nuSQoLX8Nkpay",
				checkboxWrapper: "_33C5Xe1t7nuSQoLX8Nkpay"
			}
		},
		"./src/reddit/components/BannedUserList/ExpandedComponent.m.less": function(e, t, s) {
			e.exports = {
				UnthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				unthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				BanReason: "SrZ1u3sJDzvdTgFW_XYZl",
				banReason: "SrZ1u3sJDzvdTgFW_XYZl",
				ExpandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				expandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				ModNote: "_3hA381rnksvJreaBfQTIC3",
				modNote: "_3hA381rnksvJreaBfQTIC3",
				ModNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				modNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				SectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				sectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				ContextContainer: "_1pqL5T1jpl-iWaJcvRftmU",
				contextContainer: "_1pqL5T1jpl-iWaJcvRftmU"
			}
		},
		"./src/reddit/components/BannedUserList/index.m.less": function(e, t, s) {
			e.exports = {
				BanIcon: "_1c2rKv1iuQylye8ejI6-1v",
				banIcon: "_1c2rKv1iuQylye8ejI6-1v"
			}
		},
		"./src/reddit/components/BlockNavigation/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/react-router/esm/react-router.js"),
				i = s("./src/reddit/actions/modal.ts");
			const c = "non-empty-string-to-block-navigation";
			class d extends a.a.Component {
				constructor() {
					super(...arguments), this.onBeforeUnload = e => {
						if (this.props.enabled) return e.preventDefault(), e.returnValue = "", ""
					}, this.message = (e, t) => {
						return !0 === (this.props.confirmNavigate || this.defaultConfirmNavigate)(e, t) || c
					}, this.defaultConfirmNavigate = (e, t) => {
						const {
							ignoreCurrentLocation: s = !0,
							location: n,
							showModal: a,
							dialogId: o
						} = this.props;
						return !(!s || e.pathname !== n.pathname) || (o && a(), !1)
					}
				}
				componentDidMount() {
					this.props.blockOnBeforeUnload && window.addEventListener("beforeunload", this.onBeforeUnload)
				}
				componentWillUnmount() {
					this.props.blockOnBeforeUnload && window.removeEventListener("beforeunload", this.onBeforeUnload)
				}
				render() {
					const {
						enabled: e = !0
					} = this.props;
					return a.a.createElement(r.b, {
						message: this.message,
						when: e
					})
				}
			}
			t.a = Object(o.b)(null, (e, t) => ({
				showModal: () => e(Object(i.h)(t.dialogId))
			}))(Object(r.i)(d))
		},
		"./src/reddit/components/CallToActionButton/index.m.less": function(e, t, s) {
			e.exports = {
				CallToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				callToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				mNotCardView: "_33VrFkg3gJpkL8AlPfcHUE"
			}
		},
		"./src/reddit/components/CallToActionButton/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				i = s("./src/reddit/components/CallToActionButton/index.m.less"),
				c = s.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			t.a = e => {
				var {
					className: t
				} = e, s = l(e, ["className"]);
				return a.a.createElement(r.a, d({
					className: Object(o.a)(t, c.a.CallToActionButton, {
						[c.a.mNotCardView]: s.isNotCardView
					})
				}, s))
			}
		},
		"./src/reddit/components/CharacterCountdown/index.m.less": function(e, t, s) {
			e.exports = {
				container: "s5ap8yh1b4ZfwxvHizW3f",
				mOverflow: "_19JhaP1slDQqu2XgT3vVS0"
			}
		},
		"./src/reddit/components/CharacterCountdown/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				i = s("./src/reddit/i18n/utils.ts"),
				c = s("./src/reddit/components/CharacterCountdown/index.m.less"),
				d = s.n(c);
			t.a = e => a.a.createElement(r.b, {
				className: Object(o.a)(e.className, d.a.container, e.text.length > e.maxChars ? d.a.mOverflow : null)
			}, "".concat(e.maxChars - e.text.length, " ").concat(Object(i.c)("Characters")))
		},
		"./src/reddit/components/ChatButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./src/reddit/actions/chat/toggle.ts"),
				i = s("./src/reddit/components/TrackingHelper/index.tsx"),
				c = s("./src/reddit/controls/Button/index.tsx"),
				d = s("./src/reddit/helpers/trackers/authorHovercard.ts");
			const l = e => {
				let {
					onStartChat: t,
					children: s,
					className: n,
					sendEvent: o,
					contextId: r
				} = e;
				return a.a.createElement(c.f, {
					onClick: () => {
						t(), o(Object(d.b)(r))
					},
					className: n
				}, s)
			};
			l.displayName = "ChatButton";
			const m = Object(o.b)(null, (e, t) => {
				let {
					contextId: s,
					userId: n
				} = t;
				return {
					onStartChat: () => {
						e(Object(r.a)(n, s))
					}
				}
			});
			t.a = m(Object(i.b)(l))
		},
		"./src/reddit/components/ClassicPost/Placeholder.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return C
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/components/PostLeftRail/index.tsx"),
				d = s("./src/reddit/components/VerticalVotes/votes.tsx"),
				l = s("./src/reddit/contexts/PageLayer/index.tsx"),
				m = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				u = s("./src/reddit/models/Vote/index.ts"),
				p = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				b = s.n(p),
				h = s("./src/reddit/components/ClassicPost/placeholder.m.less"),
				g = s.n(h);

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const x = Object(l.t)(),
				f = Object(r.c)({
					isFakeSubreddit: l.y
				}),
				v = Object(o.b)(f),
				C = e => {
					const t = {
						interactive: !1,
						voteState: u.a.notVoted
					};
					return a.a.createElement("div", {
						className: Object(i.a)(e.className, g.a.emptyVerticalVotes)
					}, a.a.createElement(d.d, E({
						key: "u"
					}, t)), e.children, a.a.createElement(d.c, E({
						key: "d"
					}, t)))
				},
				O = () => a.a.createElement(C, null, a.a.createElement("div", {
					className: g.a.emptyScore,
					key: "s"
				}));
			t.b = x(v(e => a.a.createElement("div", {
				className: Object(i.a)(e.className, b.a.classicPostStyles, b.a.classicAndCompactPlaceholderStyles)
			}, a.a.createElement(c.b, null, a.a.createElement(O, null)), a.a.createElement("div", {
				className: g.a.mainBody
			}, a.a.createElement("div", {
				className: g.a.thumbnailContainer
			}, a.a.createElement("div", {
				className: Object(i.a)(g.a.thumbnail, Object(m.b)(e))
			})), a.a.createElement("div", {
				className: g.a.content
			}, a.a.createElement("div", {
				key: "a"
			}, a.a.createElement("div", {
				key: "aa",
				className: Object(i.a)(g.a.title, Object(m.b)(e))
			}), a.a.createElement("div", {
				key: "ab",
				className: Object(i.a)(g.a.meta, Object(m.b)(e))
			})), a.a.createElement("div", {
				key: "f",
				className: g.a.flatlist
			}, a.a.createElement("div", {
				key: "fa",
				className: Object(i.a)(g.a.flatlistExpando, Object(m.b)(e))
			}), a.a.createElement("div", {
				key: "fb",
				className: g.a.flatlistSeparator
			}), a.a.createElement("div", {
				key: "fc",
				className: Object(i.a)(g.a.flatListItemOne, Object(m.b)(e))
			}), a.a.createElement("div", {
				key: "fd",
				className: Object(i.a)(g.a.flatListItemTwo, Object(m.b)(e))
			})))))))
		},
		"./src/reddit/components/ClassicPost/placeholder.m.less": function(e, t, s) {
			e.exports = {
				thumbnailContainer: "_3cwq18vPueuAxRSrd1foNB",
				mainBody: "_1jxw1P65tWXN5u8kVHlX-n",
				content: "_2KR7fLQx_7rIv8QaoeXKZw",
				emptyScore: "_6w7aNMh3t6UMe07Q6oWFE",
				emptyVerticalVotes: "_1Xs9oeessHWcuF0VTVxRnl",
				thumbnail: "_2XOZ5bYpLdswvBAYUNa-ly",
				title: "n3AVRrP7HOfc0gAtGFpfv",
				meta: "_1BoNlCqTsaeLXkuZbADxyl",
				flatlist: "_1IgQuZI8L6A0NcShWmf08y",
				flatlistExpando: "_2AMaFX8Gwojg29X4_nOnaL",
				flatlistSeparator: "oljBm1Q059l3l84VHO9VM",
				flatListItemOne: "_2xeK0Acj_38O5kqiHgp7VC",
				flatListItemTwo: "_3WphuhFsMSKk2tQyD3fZeI"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.m.less": function(e, t, s) {
			e.exports = {
				CommentAuthorLink: "f3THgbzMYccGW8vbqZBUH",
				commentAuthorLink: "f3THgbzMYccGW8vbqZBUH",
				badgeIconStyle: "_2MlVoXUc3Eo3KGWDukM9xn",
				modBadgeIconStyle: "_1kqPGnOAdnd9gPUXDU2_AS",
				DonationAmount: "_3sY3k4LLYR5dbXRxnGkhwG",
				donationAmount: "_3sY3k4LLYR5dbXRxnGkhwG",
				RightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				rightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				EditedText: "uMVXpG5M2xxHNW2g94S8K",
				editedText: "uMVXpG5M2xxHNW2g94S8K",
				MetaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				metaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				publicPoints: "_2LXcsgibmlCEsBPk8MLy7e",
				AuthorHoverCard: "_16AAktgl_rVbXAeiWU9CQd",
				authorHoverCard: "_16AAktgl_rVbXAeiWU9CQd",
				Component: "_36uQqfCEixcb8d3_aWB5H6",
				component: "_36uQqfCEixcb8d3_aWB5H6",
				AdminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				adminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				Approve: "_34mJxMS9sOCTo8dtFMQOLR",
				approve: "_34mJxMS9sOCTo8dtFMQOLR",
				Lock: "_3ATarJMtY0XRI9Lgu7e7DC",
				lock: "_3ATarJMtY0XRI9Lgu7e7DC",
				AdminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				adminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				Automoderator: "EytgzUMjj1jcbKtFsodey",
				automoderator: "EytgzUMjj1jcbKtFsodey",
				removed: "_2jIbl66ymb_twdJlZslQ-e",
				CakeIcon: "_1HLCDx7CkNvQgmNroGXenu",
				cakeIcon: "_1HLCDx7CkNvQgmNroGXenu",
				Moderator: "_174Mk1p6pYIrr6f1y6b4fn",
				moderator: "_174Mk1p6pYIrr6f1y6b4fn",
				Remove: "_1DQWCB93pHPVVJCXOGsblO",
				remove: "_1DQWCB93pHPVVJCXOGsblO",
				Report: "_2wYWDvjfG1JR6VNK9ryPFk",
				report: "_2wYWDvjfG1JR6VNK9ryPFk",
				Spam: "_3kK86gdpll9ihjOPWJE6f2",
				spam: "_3kK86gdpll9ihjOPWJE6f2",
				Op: "_2pZswNTz_uW46hN02djL7j",
				op: "_2pZswNTz_uW46hN02djL7j",
				Contractor: "_1hbZy7yehvtj0w4ec-2u3Y",
				contractor: "_1hbZy7yehvtj0w4ec-2u3Y",
				redditorIcon: "_2SkK42s487b14gsRa4zinm",
				MetaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				metaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				StickiedText: "_1eNQE7Kj1TEqCLAn1BUKJy",
				stickiedText: "_1eNQE7Kj1TEqCLAn1BUKJy",
				DeletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				deletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				RemovalReason: "Gtgj2P-Js5aSN72H6Mqms",
				removalReason: "Gtgj2P-Js5aSN72H6Mqms",
				container: "_3ezOJqKdLbgkHsXcfvS5SA",
				collapsed: "_2k27lgIDltx9kOzVGXt48i",
				hasBadges: "_1KMFaeLEhRikeFEOlWE9Ti",
				liveStreaming: "_1iUed95f0HTc84gBtoOxdc",
				metaText: "_3_GZIIN1xcMEC5AVuv4kfa",
				CrowdControlText: "Eoj3NCGwtl7hQcr7Rnc0N",
				crowdControlText: "Eoj3NCGwtl7hQcr7Rnc0N"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/app/strings/index.ts"),
				c = s("./src/reddit/actions/tooltip.ts"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/constants/index.ts"),
				m = s("./src/lib/humanizeDateTime/index.ts"),
				u = s("./src/lib/lessComponent.tsx"),
				p = s("./src/lib/timeAgo/index.ts"),
				b = s("./src/reddit/components/AuthorLink/index.tsx"),
				h = s("./src/reddit/components/AwardBadges/index.tsx"),
				g = s("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx"),
				E = s("./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx"),
				x = s("./src/reddit/components/Economics/Support/DonationAmount/async.tsx"),
				f = s("./src/reddit/featureFlags/index.ts"),
				v = s("./src/reddit/selectors/economics.ts"),
				C = s("./src/reddit/components/Economics/TopTippers/Icon/index.tsx"),
				O = s("./src/reddit/components/Economics/TopTippers/CommentUsername/index.m.less"),
				j = s.n(O);
			const y = e => {
				switch (e) {
					case 1:
						return {
							color: "#FF2500", fontWeight: 700
						};
					case 2:
						return {
							color: "#FF7300", fontWeight: 700
						};
					case 3:
						return {
							color: "#FFA200", fontWeight: 700
						};
					default:
						return {}
				}
			};
			var k = Object(o.b)(() => Object(r.c)({
					post: (e, t) => {
						let {
							contentId: s
						} = t;
						return e.posts.models[s]
					},
					tippers: (e, t) => {
						if (f.d.spTopTippers(e)) return Object(v.s)(e, t)
					}
				}))((function(e) {
					if (e.tippers && e.tippers.allTippers.has(e.userId)) {
						const t = e.tippers.topTippers.ranking[e.userId] || 5,
							s = a.a.cloneElement(a.a.Children.only(e.children), {
								style: y(t)
							});
						return a.a.createElement("div", {
							className: j.a.container
						}, a.a.createElement(C.a, {
							className: j.a.badge,
							creatorId: e.creatorId || e.post && e.post.authorId,
							rank: t,
							subredditId: e.subredditId
						}), s)
					}
					return e.children
				})),
				w = s("./src/reddit/components/Flair/index.tsx"),
				S = s("./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx"),
				N = s("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				T = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				_ = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				I = s("./src/reddit/components/PostTopMeta/index.tsx"),
				P = s("./src/reddit/helpers/isRemoved.ts"),
				M = s("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				R = s("./src/reddit/helpers/showReportIndicator/index.ts"),
				L = s("./src/reddit/i18n/utils.ts"),
				D = s("./src/reddit/actions/comment/index.ts"),
				A = s("./src/reddit/models/Comment/index.ts"),
				F = s("./src/reddit/models/Flair/index.ts"),
				B = s("./src/reddit/icons/fonts/Admin/index.tsx"),
				U = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				H = s("./src/reddit/icons/fonts/Lock/index.tsx"),
				W = s("./src/reddit/icons/fonts/helpers.tsx"),
				q = s("./src/reddit/icons/fonts/Op/index.m.less"),
				V = s.n(q);
			var z = u.a.wrapped(e => a.a.createElement("i", {
					className: "".concat(Object(W.b)("op"), " ").concat(e.className),
					id: e.id,
					onMouseEnter: e.onMouseEnter,
					onMouseLeave: e.onMouseLeave
				}, a.a.createElement(W.a, null, e.desc)), "OpIcon", V.a),
				K = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				Q = s("./src/reddit/icons/fonts/Report/index.tsx"),
				G = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				J = s("./src/reddit/icons/svgs/Automoderator/index.tsx"),
				Z = s("./src/reddit/icons/svgs/Cake/index.tsx"),
				X = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Y = s("./src/reddit/controls/MetaData/index.tsx"),
				$ = s("./src/reddit/selectors/experiments/publicAwarding.ts"),
				ee = s("./src/reddit/selectors/subreddit.ts"),
				te = s("./src/reddit/selectors/userFlair.ts"),
				se = s("./src/reddit/components/Comments/Comment/TopMeta/index.m.less"),
				ne = s.n(se);

			function ae() {
				return (ae = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var oe = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const re = u.a.wrapped(w.b, "RightPositionedAuthorFlair", ne.a),
				ie = u.a.wrapped(B.a, "AdminIcon", ne.a),
				ce = u.a.wrapped(U.a, "Approve", ne.a),
				de = u.a.wrapped(H.a, "Lock", ne.a),
				le = u.a.div("AdminEmeritus", ne.a),
				me = u.a.wrapped(J.a, "Automoderator", ne.a),
				ue = u.a.wrapped(Z.a, "CakeIcon", ne.a),
				pe = u.a.wrapped(X.a, "Moderator", ne.a),
				be = u.a.wrapped(K.a, "Remove", ne.a),
				he = u.a.wrapped(Q.a, "Report", ne.a),
				ge = u.a.wrapped(G.a, "Spam", ne.a),
				Ee = u.a.wrapped(z, "Op", ne.a),
				xe = u.a.wrapped(B.a, "Contractor", ne.a),
				fe = u.a.a("MetaLink", ne.a),
				ve = u.a.wrapped(Y.a, "EditedText", ne.a),
				Ce = u.a.wrapped(Y.a, "StickiedText", ne.a),
				Oe = u.a.span("DeletedText", ne.a),
				je = u.a.wrapped(Y.a, "MetaSeparator", ne.a),
				ye = u.a.wrapped(Y.a, "CrowdControlText", ne.a),
				ke = u.a.wrapped(N.b, "AuthorHoverCard", ne.a),
				we = u.a.a("RemovalReason", ne.a),
				Se = u.a.wrapped(g.b, "Component", ne.a),
				Ne = Object(i.d)("comment.children"),
				Te = Object(i.d)("comment.moreThanChildren"),
				_e = e => (t, s) => {
					let {
						comment: n,
						renderedInOverlay: a
					} = s;
					return "".concat(e).concat(n.id).concat(a ? "inOverlay" : "")
				},
				Ie = Object(i.e)("comment.tooltips.admin"),
				Pe = Object(i.e)("comment.tooltips.cakeday"),
				Me = Object(i.e)("comment.tooltips.adminEmeritus"),
				Re = Object(i.e)("comment.tooltips.moderator"),
				Le = Object(i.e)("comment.tooltips.op"),
				De = Object(i.e)("comment.tooltips.contractor"),
				Ae = Object(o.b)(() => Object(r.c)({
					adminTooltipId: _e("CommentTopMeta--Admin--"),
					cakedayTooltipId: _e("CommentTopMeta--cakeday--"),
					adminEmeritusTooltipId: _e("CommentTopMeta--AdEm--"),
					automodTooltipId: _e("CommentTopMeta--Automod--"),
					approveTooltipId: _e("CommentTopMeta--Approve--"),
					createdTooltipId: _e("CommentTopMeta--Created--"),
					contractorTooltipId: _e("CommentTopMeta--Contractor--"),
					gildedTooltipId: _e("CommentTopMeta--Gold--"),
					lockedTooltipId: _e("CommentTopMeta--Locked--"),
					modTooltipId: _e("CommentTopMeta--Mod--"),
					opTooltipId: _e("CommentTopMeta--OP--"),
					publicAwardersEnabled: e => !!Object($.a)(e),
					removeTooltipId: _e("CommentTopMeta--Remove--"),
					reportTooltipId: _e("CommentTopMeta--Report--"),
					spamTooltipId: _e("CommentTopMeta--Spam--"),
					hasBadges: (e, t) => {
						let {
							comment: s
						} = t;
						return !!Object(v.q)(e, s.subredditId, s.authorId).length
					},
					subredditDisplayText: (e, t) => {
						const s = Object(ee.J)(e, {
							commentId: t.comment.id
						});
						return s ? s.displayText : ""
					},
					topTippersEnabled: f.d.spTopTippers,
					flairPosition: (e, t) => {
						let {
							comment: s
						} = t;
						return Object(te.d)(e, {
							subredditId: s.subredditId
						})
					}
				}), (e, t) => ({
					onCreatedClick: () => {
						window.addEventListener("focus", (function s() {
							((e, t, s) => {
								window.removeEventListener("focus", s), e(Object(D.N)({
									commentListNodeId: t
								})), window.setTimeout(() => e(Object(D.N)({
									commentListNodeId: t
								})), 5e3)
							})(e, t.comment.id, s)
						}))
					},
					onHideTooltip: () => e(Object(c.h)()),
					onShowTooltip: t => e(Object(c.f)({
						tooltipId: t
					})),
					openRemovalReasonModal: () => {
						s.e("removalReasonActions").then(s.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(s => e(s.fetchReasonsAndOpenModal(t.comment.subredditId, [t.comment.id])))
					}
				}));
			t.a = Ae(e => {
				const {
					adminEmeritusTooltipId: t,
					adminTooltipId: s,
					approveTooltipId: n,
					automodTooltipId: o,
					cakedayTooltipId: r,
					children: i,
					className: c,
					collapsed: m,
					collapsedBecauseCrowdControl: u,
					comment: p,
					commentsPageKey: b,
					contractorTooltipId: g,
					compact: f,
					flair: v,
					flairPosition: C,
					hasBadges: O,
					isLivestreaming: j,
					ignoreFlairPosition: y,
					ignoreLock: k,
					language: N,
					lockedTooltipId: T,
					modTooltipId: P,
					onHideTooltip: M,
					onShowTooltip: R,
					opTooltipId: L,
					openRemovalReasonModal: D,
					publicAwardersEnabled: B,
					removeTooltipId: U,
					renderContractorBadge: H,
					renderedInOverlay: W,
					reportTooltipId: q,
					spamTooltipId: V,
					subredditDisplayText: z,
					topTippersEnabled: K
				} = e;
				if (p.isDeleted) return a.a.createElement(Fe, ae({}, e, {
					className: Object(d.a)(c, ne.a.container, {
						[ne.a.collapsed]: m
					})
				}));
				if (m) return a.a.createElement(Be, ae({}, e, {
					className: Object(d.a)(c, ne.a.container, {
						[ne.a.collapsed]: m
					})
				}));
				const Q = !y && C === F.b.Left;
				return a.a.createElement("div", {
					className: Object(d.a)(c, ne.a.container, {
						[ne.a.collapsed]: m,
						[ne.a.hasBadges]: O,
						[ne.a.liveStreaming]: j
					})
				}, v && Q && a.a.createElement(w.b, {
					flair: v,
					forceSmallEmojis: f
				}), !Object(A.d)(p) && a.a.createElement(Se, {
					showAddCustom: !0,
					subredditId: p.subredditId,
					userId: p.authorId,
					uniqueIdentifier: p.id
				}), a.a.createElement(ke, {
					postOrComment: p,
					tooltipType: W ? I.c.Lightbox : void 0
				}, a.a.createElement(E.b, {
					ignore: Object(A.d)(p) || !!p.distinguishType && p.distinguishType !== l.B.NONE,
					subredditId: p.subredditId,
					userId: p.authorId
				}, a.a.createElement(He, {
					comment: p,
					isLivestreaming: j,
					isStrong: !!f,
					isAuthorDeleted: Object(A.d)(p),
					topTippersEnabled: K
				}, i && i))), u && a.a.createElement(ye, null, "Crowd Control"), u && a.a.createElement(Y.c, {
					className: ne.a.metaText,
					key: "crowdControlSeparator"
				}), v && !Q && a.a.createElement(re, {
					flair: v,
					forceSmallEmojis: f
				}), !f && a.a.createElement(S.a, {
					className: ne.a.publicPoints,
					contentId: p.id,
					subredditId: p.subredditId,
					userId: p.authorId,
					username: p.author
				}), a.a.createElement(a.a.Fragment, null, a.a.createElement(_.b, {
					commentId: p.id
				}), a.a.createElement(_.a, {
					commentId: p.id,
					commentsPageKey: b
				}), a.a.createElement(Ve, {
					comment: p,
					compact: f,
					adminTooltipId: s,
					adminEmeritusTooltipId: t,
					cakedayTooltipId: r,
					contractorTooltipId: g,
					language: N,
					modTooltipId: P,
					onHideTooltip: M,
					onShowTooltip: R,
					opTooltipId: L,
					renderContractorBadge: H,
					subredditDisplayText: z
				})), !f && a.a.createElement(a.a.Fragment, null, !p.isDeleted && a.a.createElement(Y.b, {
					className: ne.a.metaText,
					isScoreHidden: p.isScoreHidden,
					language: N,
					score: p.score
				}), a.a.createElement(Y.c, {
					className: ne.a.metaText,
					key: "scoreCreatedSeparator"
				}), a.a.createElement(We, ae({
					key: "Created"
				}, e)), p.isStickied && Ke(N), p.editedAt && Ue(N, p.editedAt)), a.a.createElement(a.a.Fragment, null, a.a.createElement(ze, {
					comment: p,
					approveTooltipId: n,
					automodTooltipId: o,
					ignoreLock: k,
					language: N,
					lockedTooltipId: T,
					onHideTooltip: M,
					onShowTooltip: R,
					openRemovalReasonModal: D,
					removeTooltipId: U,
					reportTooltipId: q,
					spamTooltipId: V
				}), a.a.createElement(x.a, {
					className: ne.a.DonationAmount,
					contentId: p.id,
					subredditId: p.subredditId
				})), a.a.createElement(h.a, {
					showAwarders: B,
					tooltipType: W ? I.c.Lightbox : void 0,
					thing: p
				}))
			});
			const Fe = e => {
					const {
						language: t,
						childrenInfo: s,
						collapsed: n,
						className: o,
						comment: r
					} = e;
					return a.a.createElement("div", {
						className: o
					}, a.a.createElement(Oe, null, r.deletedBy === A.a.User ? Object(i.a)(t, "comment.commentDeletedByAuthor") : Object(i.a)(t, "comment.commentDeletedByMod")), a.a.createElement(We, ae({
						key: "Created"
					}, e)), n && qe({
						childrenInfo: s,
						language: t
					}))
				},
				Be = e => {
					const {
						comment: t,
						language: s,
						className: n,
						childrenInfo: o
					} = e;
					return a.a.createElement("div", {
						className: n
					}, a.a.createElement("div", null, a.a.createElement(He, {
						comment: t,
						isAuthorDeleted: Object(A.d)(t),
						topTippersEnabled: !1
					})), a.a.createElement(Y.b, {
						className: ne.a.metaText,
						isScoreHidden: t.isScoreHidden,
						language: s,
						score: t.score
					}), a.a.createElement(Y.c, {
						className: ne.a.metaText,
						key: "scoreCreatedSeparator"
					}), a.a.createElement(We, ae({
						key: "Created"
					}, e)), qe({
						childrenInfo: o,
						language: s
					}))
				},
				Ue = (e, t) => a.a.createElement(n.Fragment, null, a.a.createElement(Y.c, {
					className: ne.a.metaText
				}), a.a.createElement(ve, null, Object(i.a)(e, "comment.edited", {
					time: Object(p.d)(e, t)
				}))),
				He = e => {
					const t = a.a.createElement(b.a, {
						className: ne.a.CommentAuthorLink,
						author: e.comment.author,
						isAdmin: e.comment.isAdmin,
						isAdminEmeritus: e.comment.distinguishType === l.B.ALUMNI_ADMIN,
						isAuthorDeleted: e.isAuthorDeleted,
						isLivestreaming: e.isLivestreaming,
						isMod: e.comment.isMod,
						isOp: e.comment.isOp,
						isStrong: e.isStrong,
						style: e.style
					}, e.children && e.children, e.comment.author);
					return e.topTippersEnabled ? a.a.createElement(k, {
						contentId: e.comment.postId,
						subredditId: e.comment.subredditId,
						userId: e.comment.authorId
					}, t) : t
				};
			class We extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onShowCreatedTooltip = () => this.props.onShowTooltip(this.props.createdTooltipId)
				}
				render() {
					const e = this.props,
						{
							comment: t,
							language: s,
							onCreatedClick: n
						} = e,
						o = oe(e, ["comment", "language", "onCreatedClick"]);
					return a.a.createElement(fe, {
						href: t.permalink,
						id: o.createdTooltipId,
						onClick: n,
						onMouseEnter: this.onShowCreatedTooltip,
						onMouseLeave: o.onHideTooltip,
						rel: "nofollow",
						target: "_blank"
					}, a.a.createElement("span", null, Object(p.d)(s, t.created)), Qe(o.createdTooltipId, Object(m.a)(t.created)))
				}
			}
			const qe = e => {
				const {
					hasContinueThread: t,
					numChildren: s
				} = e.childrenInfo || {
					hasContinueThread: !1,
					numChildren: 0
				};
				return a.a.createElement(je, {
					className: ne.a.metaText
				}, "(", t ? Te(e.language, s, {
					numChildren: s
				}) : Ne(e.language, s, {
					numChildren: s
				}), ")")
			};
			class Ve extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onShowCakedayTooltip = () => this.props.onShowTooltip(this.props.cakedayTooltipId), this.onShowAdminTooltip = () => this.props.onShowTooltip(this.props.adminTooltipId), this.onShowAdminEmeritusTooltip = () => this.props.onShowTooltip(this.props.adminEmeritusTooltipId), this.onShowModTooltip = () => this.props.onShowTooltip(this.props.modTooltipId), this.onShowOpTooltip = () => this.props.onShowTooltip(this.props.opTooltipId), this.onShowContractorTooltip = () => this.props.onShowTooltip(this.props.contractorTooltipId)
				}
				render() {
					const e = this.props,
						{
							comment: t
						} = e,
						s = oe(e, ["comment"]);
					return a.a.createElement(n.Fragment, null, t.isAuthorCakeday && a.a.createElement(ue, {
						"aria-label": Pe(s.language),
						id: s.cakedayTooltipId,
						onMouseEnter: this.onShowCakedayTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isAuthorCakeday && Qe(s.cakedayTooltipId, Pe(s.language)), t.isAdmin && a.a.createElement(ie, {
						desc: Ie(s.language),
						id: s.adminTooltipId,
						onMouseEnter: this.onShowAdminTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isAdmin && Qe(s.adminTooltipId, Ie(s.language)), t.distinguishType === l.B.ALUMNI_ADMIN && a.a.createElement(le, {
						"aria-label": Me(s.language),
						children: "Δ",
						id: s.adminEmeritusTooltipId,
						onMouseEnter: this.onShowAdminEmeritusTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.distinguishType === l.B.ALUMNI_ADMIN && Qe(s.adminEmeritusTooltipId, Me(s.language)), t.isMod && a.a.createElement(pe, {
						desc: Re(s.language, {
							displayText: s.subredditDisplayText
						}),
						id: s.modTooltipId,
						onMouseEnter: this.onShowModTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isMod && Qe(s.modTooltipId, Re(s.language, {
						displayText: s.subredditDisplayText
					})), t.isOp && a.a.createElement(Ee, {
						desc: Le(s.language),
						id: s.opTooltipId,
						onMouseEnter: this.onShowOpTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.isOp && Qe(s.opTooltipId, Le(s.language)), s.renderContractorBadge && a.a.createElement(xe, {
						desc: De(s.language),
						id: s.contractorTooltipId,
						onMouseEnter: this.onShowContractorTooltip,
						onMouseLeave: s.onHideTooltip
					}), s.renderContractorBadge && Qe(s.contractorTooltipId, De(s.language)))
				}
			}
			class ze extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onShowApproveTooltip = () => this.props.onShowTooltip(this.props.approveTooltipId), this.onShowRemoveTooltip = () => this.props.onShowTooltip(this.props.removeTooltipId), this.onShowSpamTooltip = () => this.props.onShowTooltip(this.props.spamTooltipId), this.onShowAutomodTooltip = () => this.props.onShowTooltip(this.props.automodTooltipId), this.onShowReportTooltip = () => this.props.onShowTooltip(this.props.reportTooltipId)
				}
				render() {
					const e = this.props,
						{
							comment: t
						} = e,
						s = oe(e, ["comment"]);
					return a.a.createElement(n.Fragment, null, (t.approvedBy || t.isApproved) && a.a.createElement(ce, {
						desc: Object(M.a)(s.language, t),
						id: s.approveTooltipId,
						onMouseEnter: this.onShowApproveTooltip,
						onMouseLeave: s.onHideTooltip
					}), (t.approvedBy || t.isApproved) && Qe(s.approveTooltipId, Object(M.a)(s.language, t)), Object(P.a)(t) && a.a.createElement(be, {
						desc: Object(M.c)(s.language, t),
						id: s.removeTooltipId,
						onMouseEnter: this.onShowRemoveTooltip,
						onMouseLeave: s.onHideTooltip
					}), Object(P.a)(t) && Qe(s.removeTooltipId, Object(M.c)(s.language, t)), Object(P.a)(t) && t.isRemoved && !t.modNote && !t.modRemovalReason && a.a.createElement(we, {
						onClick: s.openRemovalReasonModal
					}, Object(i.a)(s.language, "modTools.addARemovalReason")), Object(P.a)(t) && !(t.isRemoved && !t.modNote && !t.modRemovalReason) && a.a.createElement(we, {
						onMouseEnter: this.onShowRemoveTooltip,
						onMouseLeave: s.onHideTooltip
					}, Object(i.a)(s.language, "modTools.removalReason")), t.isLocked && !s.ignoreLock && a.a.createElement(de, {
						desc: Object(L.c)("Locked"),
						id: s.lockedTooltipId,
						onMouseEnter: () => {
							s.onShowTooltip(s.lockedTooltipId)
						},
						onMouseLeave: s.onHideTooltip
					}), t.bannedBy && t.isSpam && a.a.createElement(ge, {
						desc: Object(M.e)(s.language, t),
						id: s.spamTooltipId,
						onMouseEnter: this.onShowSpamTooltip,
						onMouseLeave: s.onHideTooltip
					}), t.bannedBy && t.isSpam && Qe(s.spamTooltipId, Object(M.e)(s.language, t)), ("AutoModerator" === t.bannedBy || "AutoModerator" === t.approvedBy) && a.a.createElement(me, {
						className: Object(d.a)({
							[ne.a.removed]: !!t.bannedBy
						}),
						desc: Object(M.b)(s.language),
						id: s.automodTooltipId,
						key: s.automodTooltipId,
						onMouseEnter: this.onShowAutomodTooltip,
						onMouseLeave: s.onHideTooltip
					}), ("AutoModerator" === t.bannedBy || "AutoModerator" === t.approvedBy) && Qe(s.automodTooltipId, Object(M.b)(s.language)), Object(R.a)(t) && a.a.createElement(he, {
						desc: Object(M.d)(s.language, t.numReports),
						id: s.reportTooltipId,
						onMouseEnter: this.onShowReportTooltip,
						onMouseLeave: s.onHideTooltip
					}), Object(R.a)(t) && Qe(s.reportTooltipId, Object(M.d)(s.language, t.numReports)))
				}
			}
			const Ke = e => a.a.createElement(n.Fragment, null, a.a.createElement(Y.c, {
					className: ne.a.metaText
				}), a.a.createElement(Ce, null, Object(i.a)(e, "comment.stickied"))),
				Qe = (e, t) => a.a.createElement(T.c, {
					tooltipId: e,
					text: t
				})
		},
		"./src/reddit/components/Comments/CompactUnthreadedComment/index.m.less": function(e, t, s) {
			e.exports = {
				BulkActionCheckbox: "_3iI16gsT5wEWtruoBxoOtR",
				bulkActionCheckbox: "_3iI16gsT5wEWtruoBxoOtR",
				UnthreadedCommentContainer: "sXloQX7r47Wzsk9BzGm2",
				unthreadedCommentContainer: "sXloQX7r47Wzsk9BzGm2",
				CommentColumn: "_1Xweq4o-zB3i3DcXmGzzCo",
				commentColumn: "_1Xweq4o-zB3i3DcXmGzzCo",
				ModToolsFlatlist: "vP5hkZOVsSDk7GDKAq7OO",
				modToolsFlatlist: "vP5hkZOVsSDk7GDKAq7OO",
				CommentContentWrapper: "-ejG1vHwBmlz_5bhISopO",
				commentContentWrapper: "-ejG1vHwBmlz_5bhISopO",
				CommentParentWrapper: "_3mX7brFt-u4nDJSVh-jpOe",
				commentParentWrapper: "_3mX7brFt-u4nDJSVh-jpOe",
				LeftRail: "Z9hmG99TfBJCAbBf-qUN5",
				leftRail: "Z9hmG99TfBJCAbBf-qUN5",
				hasBorder: "_1XsRq0m2kXDelxfbhz55U6",
				VoteColumn: "raHWe-JvKoiuubD1zI79q",
				voteColumn: "raHWe-JvKoiuubD1zI79q",
				CommentBody: "_2MpQwJBmFbNsa_Vw7EV8OX",
				commentBody: "_2MpQwJBmFbNsa_Vw7EV8OX",
				Fade: "oJgHb8jt8pcSpTiugG0Db",
				fade: "oJgHb8jt8pcSpTiugG0Db",
				Votes: "EJ8j2TI5xV293AHVFV98I",
				votes: "EJ8j2TI5xV293AHVFV98I",
				score: "_1dQ0ZDSConSfUQpPh7-fct",
				ParentPostTitle: "_3lXem8Q27IuhplBpcrbkOv",
				parentPostTitle: "_3lXem8Q27IuhplBpcrbkOv",
				Component: "_3WdgziOPlXBwthdefEr85r",
				component: "_3WdgziOPlXBwthdefEr85r",
				isBanned: "_34REldWOs0k5_KaRonS2V5",
				isReported: "sYxWb5PNRmW4dH0vC6Qiy"
			}
		},
		"./src/reddit/components/Comments/LargeUnthreadedComment/index.m.less": function(e, t, s) {
			e.exports = {
				VoteSpacer: "_3SDIICEtoL7xtFw7iXPmd4",
				voteSpacer: "_3SDIICEtoL7xtFw7iXPmd4",
				ContentWrapper: "_3kLHiyeJw88pJ2rFPeO-h_",
				contentWrapper: "_3kLHiyeJw88pJ2rFPeO-h_",
				Meta: "TmC-aUr9G4BhD7f1fazLW",
				meta: "TmC-aUr9G4BhD7f1fazLW",
				CommentParentWrapper: "XNRBSCtZVEKlAOHUTl8fv",
				commentParentWrapper: "XNRBSCtZVEKlAOHUTl8fv",
				CommentContentWrapper: "_3CTfjjt3pW3hsmgbSddrW6",
				commentContentWrapper: "_3CTfjjt3pW3hsmgbSddrW6",
				Fade: "_2Mj-hTi0oAhSeVNOXqsYr2",
				fade: "_2Mj-hTi0oAhSeVNOXqsYr2",
				Component: "_3Pul81GjcQcqXueoAqkS0P",
				component: "_3Pul81GjcQcqXueoAqkS0P"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.m.less": function(e, t, s) {
			e.exports = {
				VoteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				voteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				ContentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				contentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				CommentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				commentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				CommentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				commentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				CommentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				commentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				Fade: "_3Q0PfUquGeJoHhFKeS5MRg",
				fade: "_3Q0PfUquGeJoHhFKeS5MRg",
				ParentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				parentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				Component: "_29-oldqrqqPwwjRRH0aLqU",
				component: "_29-oldqrqqPwwjRRH0aLqU"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return _
			})), s.d(t, "b", (function() {
				return M
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/objectSelector/index.ts"),
				c = s("./src/reddit/actions/comment/index.ts"),
				d = s("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				l = s("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				m = s("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				u = s("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				p = s("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				b = s("./src/reddit/components/ModModeReports/index.tsx"),
				h = s("./src/reddit/components/PostRailAndVotes/index.tsx"),
				g = s("./src/reddit/components/RichTextJson/index.tsx"),
				E = s("./src/reddit/helpers/getRichTextContent/index.ts"),
				x = s("./src/reddit/models/Vote/index.ts"),
				f = s("./src/reddit/selectors/comments.ts"),
				v = s("./src/reddit/selectors/subreddit.ts"),
				C = s("./src/reddit/selectors/user.ts"),
				O = s("./src/reddit/components/Comments/UnthreadedComment/index.m.less"),
				j = s.n(O),
				y = s("./src/lib/lessComponent.tsx");
			const k = y.a.div("VoteSpacer", j.a),
				w = y.a.div("ContentWrapper", j.a),
				S = y.a.div("CommentContentWrapper", j.a),
				N = y.a.div("CommentBody", j.a),
				T = y.a.div("Fade", j.a),
				_ = y.a.div("ParentPostTitle", j.a),
				I = y.a.div("CommentParentWrapper", j.a),
				P = Object(r.c)({
					comment: (e, t) => Object(f.n)(e, t),
					flair: f.e,
					language: C.S,
					subreddit: v.J
				}),
				M = Object(o.b)(P, (e, t) => {
					let {
						commentId: s,
						trackClick: n
					} = t;
					return {
						onIgnoreReports: () => e(Object(c.pb)(s)),
						onVoteClick: t => {
							const [a, o] = t === x.a.upvoted ? [Object(c.rb)(s), "upvote_comment"] : [Object(c.T)(s), "downvote_comment"];
							n(o)(), e(a)
						}
					}
				}),
				R = Object(i.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			t.c = M(y.a.wrapped(e => {
				const {
					className: t,
					comment: s,
					flair: n,
					hasReports: o,
					isCheckboxSelected: r = !1,
					language: i,
					onIgnoreReports: c,
					onVoteClick: x,
					showModTools: f,
					subreddit: v,
					showBulkActionCheckbox: C,
					toggleCheckbox: O
				} = e;
				return a.a.createElement(l.a, {
					className: t,
					clickTrackingId: s.id,
					permalink: s.permalink
				}, a.a.createElement(h.a, {
					model: s,
					handleVote: x,
					showBulkActionCheckbox: C,
					isCheckboxSelected: r,
					toggleCheckbox: O
				}), a.a.createElement(k, null, a.a.createElement(w, null, a.a.createElement(I, null, s.postTitle && a.a.createElement(_, null, s.postTitle), s.postAuthor && a.a.createElement(p.a, {
					comment: s
				})), a.a.createElement(S, null, a.a.createElement(m.a, {
					comment: s
				}, a.a.createElement(N, null, a.a.createElement(g.a, {
					content: Object(E.a)(s),
					rtJsonElementProps: R(e)
				}), a.a.createElement(T, null)), a.a.createElement(u.a, {
					comment: s,
					flair: n,
					language: i,
					subredditName: v ? v.displayText : null
				}), o && a.a.createElement(b.a, {
					language: i,
					onIgnoreReports: c,
					reportable: s
				}), f && !s.isDeleted && a.a.createElement(d.c, {
					comment: s,
					language: i
				}))))))
			}, "Component", j.a))
		},
		"./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./src/lib/addQueryParams/index.ts"),
				i = s("./src/higherOrderComponents/withClickTracking.tsx"),
				c = s("./src/reddit/helpers/overlay/index.ts"),
				d = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var a = 0;
						for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
					}
					return s
				};
			const l = Object(o.b)(null, e => ({
				openLightbox: t => e(Object(c.a)(t))
			}));
			class m extends a.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const e = this.props,
						{
							afterClickTracking: t,
							permalink: s,
							openLightbox: n
						} = e,
						o = d(e, ["afterClickTracking", "permalink", "openLightbox"]),
						i = e => t(() => e.metaKey || e.ctrlKey || 1 === e.button ? window.open(Object(r.a)(s, {
							context: 3
						})) : n(Object(r.a)(s, {
							context: 3
						})))(e);
					return a.a.createElement("div", {
						className: o.className,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3)), 1 === e.button && i(e)
						},
						onClick: e => {
							!this.cancelClick && 0 === e.button && i(e)
						}
					}, o.children)
				}
			}
			t.a = l(Object(i.c)(m))
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less": function(e, t, s) {
			e.exports = {
				DashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u",
				dashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/lessComponent.tsx"),
				r = s("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less"),
				i = s.n(r);
			const c = o.a.div("DashWrapper", i.a);
			t.a = e => null === e.comment.parentId ? a.a.createElement(c, null, e.children) : a.a.createElement(c, null, a.a.createElement(c, null, e.children))
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less": function(e, t, s) {
			e.exports = {
				SubredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				subredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				TopMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				topMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				Inline: "meK3ndVOmnvQt6wVaAg5W",
				inline: "meK3ndVOmnvQt6wVaAg5W",
				PostedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				postedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				TextContainer: "iV3Hb5JWIQSpA3WhioY-N",
				textContainer: "iV3Hb5JWIQSpA3WhioY-N"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/app/strings/index.ts"),
				r = s("./src/reddit/components/Comments/Comment/TopMeta/index.tsx"),
				i = s("./src/reddit/layout/row/Inline/index.tsx"),
				c = s("./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less"),
				d = s.n(c),
				l = s("./src/lib/lessComponent.tsx");
			const m = l.a.wrapped(i.a, "Inline", d.a),
				u = l.a.wrapped(i.a, "PostedInfo", d.a),
				p = l.a.wrapped(i.a, "SubredditWrapper", d.a),
				b = l.a.div("TextContainer", d.a),
				h = l.a.wrapped(r.a, "TopMeta", d.a);
			t.a = e => a.a.createElement(m, {
				className: e.className
			}, e.subredditName && a.a.createElement(p, null, e.subredditName && a.a.createElement(b, null, e.subredditName)), a.a.createElement(u, null, a.a.createElement(b, null, "".concat(Object(o.a)(e.language, "comment.commentedBy"))), a.a.createElement(h, {
				collapsedBecauseCrowdControl: e.comment.collapsedBecauseCrowdControl,
				collapsed: !1,
				comment: e.comment,
				flair: e.flair,
				language: e.language,
				renderedInOverlay: !1
			})))
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less": function(e, t, s) {
			e.exports = {
				AuthorLink: "_2jljMb6FK7HnIb15zmm1of",
				authorLink: "_2jljMb6FK7HnIb15zmm1of",
				SubredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				subredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				TextContainer: "_2in6k_0-sFgKVz16hifq03",
				textContainer: "_2in6k_0-sFgKVz16hifq03",
				SubredditIcon: "uCjYZbKNai0INWGwHjoUh",
				subredditIcon: "uCjYZbKNai0INWGwHjoUh",
				Inline: "_2VWXAfRlnHG_4nydI7J4l3",
				inline: "_2VWXAfRlnHG_4nydI7J4l3"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/components/AuthorLink/index.tsx"),
				r = s("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				i = s("./src/reddit/components/SubredditIcon/index.tsx"),
				c = s("./src/reddit/i18n/components.tsx"),
				d = s("./src/reddit/layout/row/Inline/index.tsx"),
				l = s("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less"),
				m = s.n(l),
				u = s("./src/lib/lessComponent.tsx");
			const p = u.a.wrapped(o.a, "AuthorLink", m.a),
				b = u.a.wrapped(d.a, "Inline", m.a),
				h = u.a.wrapped(d.a, "SubredditWrapper", m.a),
				g = u.a.div("TextContainer", m.a),
				E = u.a.wrapped(i.b, "SubredditIcon", m.a);
			t.a = e => a.a.createElement(b, null, e.subredditOrProfile && a.a.createElement(h, null, e.subredditOrProfile && a.a.createElement(E, {
				subredditOrProfile: e.subredditOrProfile
			}), e.subredditOrProfile && a.a.createElement(g, null, e.subredditOrProfile.displayText)), a.a.createElement(c.c, null, "posted by"), e.comment.postAuthor && a.a.createElement(r.b, {
				postOrComment: e.comment,
				author: e.comment.postAuthor
			}, a.a.createElement(p, {
				author: e.comment.postAuthor,
				isUnstyled: !0
			}, "u/".concat(e.comment.postAuthor))))
		},
		"./src/reddit/components/CommunityAwardList/AwardRow/index.m.less": function(e, t, s) {
			e.exports = {
				row: "_1SJYzo3UAyKEOF7dfuB9mj",
				awardName: "KMxVBNnYo_dcBwZGB9Y7a",
				unfilledAward: "_3s20dmDQOAFnj9VBvMb_K9",
				awardDetail: "_2NA5kHSdCz8PTAq-oiC2lE",
				awardExpiresDetail: "_23IvuOow0OJsmKnkmU_FEX",
				headerRow: "_1NbiD8qa7KncC2IlK9RoSb",
				awardIconImage: "_3sB_KQUJdYFc6cPgCjizd4",
				deleteIcon: "_1Aox5T2z7StzW_M0WfnDTe",
				rightAlign: "_3MpqTEDv3tS3-u-1uNAt6Y",
				createButton: "_3pXwHsShRJ0s12b9e-_gCX",
				emptyIcon: "yy-p6aZDVdPVBPBYMhbEy",
				emptyDetails: "LUZArpcpRdOTEPUDrjKVR",
				awardLoadingContainer: "_2WNYZIJMYIXJIS_IJIIiTe"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.m.less": function(e, t, s) {
			e.exports = {
				contentContainer: "_27C02100EX-RnLoDyL_PYT",
				gildIcon: "_3f4YbBVVbX4YXols-8AmgC",
				infoIcon: "_1HPeb_FxEOzicQ4BuIVonK",
				pageInfo: "_2bEhfADeSjJE-8zKoxjbGy",
				awardToDelete: "dzAx082Iu3F9M7xS-PL80",
				awardToDeleteIcon: "_11ikfBu3qqa0paYAJLQINO"
			}
		},
		"./src/reddit/components/CommunitySettings/components.m.less": function(e, t, s) {
			e.exports = {
				InputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				inputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				FormContainer: "_37sNfY6fNJVPqyQXOHlg3K",
				formContainer: "_37sNfY6fNJVPqyQXOHlg3K"
			}
		},
		"./src/reddit/components/CommunitySettings/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return n
			})), s.d(t, "d", (function() {
				return a
			})), s.d(t, "e", (function() {
				return o
			})), s.d(t, "k", (function() {
				return r
			})), s.d(t, "f", (function() {
				return i
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "l", (function() {
				return d
			})), s.d(t, "m", (function() {
				return l
			})), s.d(t, "o", (function() {
				return m
			})), s.d(t, "n", (function() {
				return u
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "g", (function() {
				return b
			})), s.d(t, "j", (function() {
				return h
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "p", (function() {
				return x
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = 500,
				a = 100,
				o = 5e3,
				r = 5e5,
				i = 0,
				c = 1440,
				d = 36600,
				l = 1e9,
				m = {
					Disabled: "disabled",
					"Mods only": "modonly",
					Anyone: "anyone"
				},
				u = ["Wiki is disabled for all users except mods", "Only mods, approved wiki contributors, or those on a page's edit list may edit", "Anyone who can submit to the community may edit"],
				p = {
					Any: "any",
					"Links only": "link",
					"Text posts only": "self"
				},
				b = ["Any post type is allowed", "Only links to external sites are allowed", "Only text posts are allowed"],
				h = {
					Low: "low",
					"High (default)": "high",
					All: "all"
				},
				g = {
					"Low (default)": "low",
					High: "high",
					All: "all"
				},
				E = {
					"none (recommended)": null,
					best: "confidence",
					old: "old",
					top: "top",
					"q&a": "qa",
					"live (beta)": "live",
					controversial: "controversial",
					new: "new"
				},
				x = (e, t) => Object.keys(e).find(s => e[s] === t)
		},
		"./src/reddit/components/CommunitySettings/index.m.less": function(e, t, s) {
			e.exports = {
				welcomeMessageHelpLink: "_3-XV8EhlxRlIzoFKUI6gmQ",
				communityTopicsHelpLink: "_2Tzl9XrmQzUn94gYHRUYMI",
				fullWidthTextContainer: "_2SnK_8NMPSqmFfF-es2GGa",
				subtextContainer: "_2sWG233wmE9wNycTEyRHRN",
				numCommunityTopicsSelected: "Ty_datAAaSbn2GX5-1O58",
				welcomeMessageEnabled: "_21a0DjKnRl3i1ItjJ8cSyf"
			}
		},
		"./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/app/strings/index.ts"),
				c = s("./src/reddit/models/Tags/index.ts"),
				d = s("./src/reddit/selectors/tags.ts"),
				l = s("./src/reddit/selectors/user.ts");
			const m = Object(r.c)({
				selectedOptions: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(d.r)(e, {
						subredditId: s
					})
				},
				language: l.S
			});
			t.a = Object(o.b)(m)(e => a.a.createElement(a.a.Fragment, null, Object(i.a)(e.language, "communityTopics.numSelected", {
				part: e.selectedOptions.length,
				whole: c.a
			})))
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less": function(e, t, s) {
			e.exports = {
				suggestedTopicsContainer: "_3qCTJNZ-iSCZa0wyVfs6my",
				relatedText: "_389N9jvZJu60U3E7vIF00n",
				closeIcon: "M40GQ3RaivlkCl8WQ-pXo",
				plusIcon: "_2OYvdU1reofcbKMJ0wvC_x",
				suggestedTopic: "_1RmiLhJpOUx_hgduPf3F5O",
				closeIconContainer: "sHLJV3zATRod0k1f_m71I",
				suggestedTopicText: "_1-rmQV4Wee08Dt-h2GyW-o"
			}
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/app/strings/index.ts"),
				c = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/actions/tags/index.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/icons/svgs/Close/index.tsx"),
				u = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				p = s("./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less"),
				b = s.n(p);
			var h = e => a.a.createElement("span", {
					className: b.a.suggestedTopic,
					onClick: () => e.onSuggestedTopicSelected(e.suggestedTopic)
				}, a.a.createElement(u.a, {
					className: b.a.plusIcon
				}), a.a.createElement("span", {
					className: b.a.suggestedTopicText
				}, e.suggestedTopic.displayText), a.a.createElement("span", {
					className: b.a.closeIconContainer,
					onClick: t => {
						t.preventDefault(), t.stopPropagation(), e.onSuggestedTopicDismissed(e.suggestedTopic)
					}
				}, a.a.createElement(m.a, {
					className: b.a.closeIcon
				}))),
				g = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				E = s("./src/reddit/i18n/components.tsx"),
				x = s("./src/reddit/models/Tags/index.ts"),
				f = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/selectors/tags.ts"),
				C = s("./src/reddit/selectors/user.ts");
			const O = Object(r.c)({
					suggestedOptions: (e, t) => {
						let {
							subredditId: s
						} = t;
						const n = Object(v.u)(e, {
								itemId: s
							}),
							a = Object(v.r)(e, {
								subredditId: s
							});
						return n.filter(e => !!e.id && !a.find(t => !!t.id && t.id === e.id))
					}
				}),
				j = Object(o.b)(O, (e, t) => {
					let {
						subredditId: s,
						onOptionSelected: n,
						context: a
					} = t;
					return {
						onSuggestedOptionDismissed: t => {
							e(Object(d.p)(s, [], [{
								subredditId: s,
								tagId: t.id,
								isRelevant: !1
							}], a, !0))
						},
						onSuggestedOptionSelected: t => {
							e((e, o) => {
								const r = o();
								Object(v.r)(r, {
									subredditId: s
								}).length >= x.a ? e(Object(l.e)(Object.assign({}, Object(l.d)(Object(i.a)(Object(C.S)(o()), "communityTopics.maxTopicsHit", {
									max: x.a
								}), f.b.Error), {
									duration: l.a
								}))) : (e(Object(d.l)({
									subredditId: s,
									option: t
								})), Object(g.c)(o(), s, t, {
									context: a
								}), n && n(t))
							})
						}
					}
				});
			t.a = j(e => e.suggestedOptions.length ? a.a.createElement("div", {
				className: Object(c.a)(b.a.suggestedTopicsContainer, e.className)
			}, e.children || a.a.createElement("span", {
				className: b.a.relatedText
			}, a.a.createElement(E.c, null, "Related: ")), e.suggestedOptions.map(t => a.a.createElement(h, {
				key: t.id,
				suggestedTopic: t,
				onSuggestedTopicSelected: e.onSuggestedOptionSelected,
				onSuggestedTopicDismissed: e.onSuggestedOptionDismissed
			}))) : null)
		},
		"./src/reddit/components/CommunityTopics/index.m.less": function(e, t, s) {
			e.exports = {
				communityTopicsContainer: "wsNyCIZw7veQPURlfXwXb"
			}
		},
		"./src/reddit/components/CommunityTopics/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return v
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/app/strings/index.ts"),
				c = s("./src/reddit/actions/tags/index.ts"),
				d = s("./src/reddit/actions/toaster.ts"),
				l = s("./src/reddit/components/MultiOptionSelect/index.tsx"),
				m = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				u = s("./src/reddit/i18n/utils.ts"),
				p = s("./src/reddit/models/Tags/index.ts"),
				b = s("./src/reddit/models/Toast/index.ts"),
				h = s("./src/reddit/selectors/tags.ts"),
				g = s("./src/reddit/selectors/user.ts"),
				E = s("./src/reddit/components/CommunityTopics/index.m.less"),
				x = s.n(E);
			const f = Object(r.c)({
				availableSubredditTags: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(h.d)(e, {
						subredditId: s
					})
				},
				subredditTags: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(h.p)(e, {
						itemId: s
					})
				},
				availableGlobalOptions: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(h.a)(e, {
						thingId: s
					})
				},
				selectedOptions: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(h.r)(e, {
						subredditId: s
					})
				},
				isLoading: e => Object(h.x)(e),
				currentInput: (e, t) => {
					let {
						subredditId: s
					} = t;
					return Object(h.k)(e, {
						subredditId: s
					})
				},
				language: e => Object(g.S)(e)
			});
			class v extends a.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							s = e.filter(e => !e.selected);
						this.onOptionsSelected(t), s.forEach(e => this.onOptionDeselected(e))
					}, this.onFocus = () => {
						this.props.onSearchBarFocused(), this.props.onFocus && this.props.onFocus()
					}
				}
				onOptionsSelected(e) {
					const t = p.a - this.props.selectedOptions.length,
						s = e.filter(e => !!e.displayText.trim()),
						n = s.slice(0, t);
					n.forEach(e => {
						if (!e.id) {
							const t = Object(h.c)(e.displayText, this.props.availableSubredditTags);
							t && (e = Object(p.e)(t, !0))
						}
						this.props.optionSelected(Object.assign({}, e, {
							displayText: e.displayText.trim()
						}))
					}), n.length !== s.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(e)
				}
				render() {
					return a.a.createElement("div", {
						className: x.a.communityTopicsContainer
					}, a.a.createElement(l.a, {
						readOnlyMode: this.props.readOnlyMode,
						addText: Object(u.c)("Add"),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						childClassNames: this.props.childClassNames,
						dropdownHeaderText: Object(u.c)("Suggested topics"),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > p.a,
						isLoading: this.props.isLoading,
						maxOptionLength: p.b,
						maxOptionsToDisplay: this.props.maxTopicsToDisplay,
						onSearchBarFocus: this.onFocus,
						onSearchBarBlur: this.props.onBlur,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: !0
					}, this.props.children))
				}
			}
			t.b = Object(o.b)(f, (e, t) => {
				let {
					subredditId: s,
					context: n
				} = t;
				return {
					optionSelected: t => {
						e(Object(c.l)({
							subredditId: s,
							option: t
						})), e((e, a) => {
							m.e(a(), s, t, {
								context: n
							})
						})
					},
					optionDeselected: t => {
						e(Object(c.k)({
							subredditId: s,
							option: t
						})), e((e, a) => {
							m.d(a(), s, t, {
								context: n
							})
						})
					},
					onInputChanged: t => e(Object(c.j)({
						subredditId: s,
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {
						m.b(t(), s, {
							context: n
						})
					}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(d.e)(Object.assign({}, Object(d.d)(Object(i.a)(Object(g.S)(t()), "communityTopics.maxTopicsHit", {
							max: p.a
						}), b.b.Error), {
							duration: d.a
						})))
					})
				}
			})(v)
		},
		"./src/reddit/components/CompactPost/Placeholder/index.m.less": function(e, t, s) {
			e.exports = {
				emptyScore: "_3RRgbzXvoZ4MUYm45lAqp7",
				emptyVotes: "_2rSb53hAOWG9j6R_ToxoSJ",
				wrapper: "_2wuOxz4--LcoxCYSrpCBlx",
				expandoContainer: "_3CIl2qTD30RwYsMAGO2Y2S",
				expando: "_2UCpUVZ4aSncQhvkrQW_0i",
				subredditIconContainer: "_2IJnSguizdehDk_JnTKrdK",
				topLine: "_1OQE_XsSHzM7AtjVQahjoI",
				title: "_28eZmJsl2bogBZ2KPmeoFO",
				meta: "_24dJJDh8muEbehYysONmV1",
				comments: "_2-iJVRFJK-xC7a7xgBF-T5",
				ellipsis: "_1IFRAIwzfwChKq85FhLG69",
				flatList: "_3HxvQvODjYEHa-X5AuQinY"
			}
		},
		"./src/reddit/components/CompactPost/Placeholder/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/components/SubredditIcon/index.tsx"),
				d = s("./src/reddit/components/VerticalVotes/votes.tsx"),
				l = s("./src/reddit/contexts/PageLayer/index.tsx"),
				m = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				u = s("./src/reddit/models/Vote/index.ts"),
				p = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				b = s.n(p),
				h = s("./src/reddit/components/CompactPost/Placeholder/index.m.less"),
				g = s.n(h);

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const x = Object(l.t)(),
				f = Object(r.c)({
					isFakeSubreddit: l.y
				}),
				v = Object(o.b)(f),
				C = e => {
					const t = {
						interactive: !1,
						voteState: u.a.notVoted
					};
					return a.a.createElement("div", {
						className: g.a.emptyVotes
					}, a.a.createElement(d.d, E({
						key: "u"
					}, t)), a.a.createElement("div", {
						key: "s",
						className: g.a.emptyScore
					}), a.a.createElement(d.c, E({
						key: "d"
					}, t)))
				},
				O = e => a.a.createElement(c.a, {
					className: Object(m.a)(e)
				}),
				j = e => a.a.createElement("div", {
					className: g.a.flatList
				}, a.a.createElement("div", {
					className: Object(i.a)(g.a.comments, Object(m.b)(e))
				}), a.a.createElement("div", {
					className: Object(i.a)(g.a.ellipsis, Object(m.b)(e))
				}));
			t.a = x(v(e => a.a.createElement("div", {
				className: Object(i.a)(e.className, b.a.compactPostStyles, b.a.classicAndCompactPlaceholderStyles)
			}, a.a.createElement("div", {
				className: g.a.wrapper
			}, a.a.createElement(C, E({
				key: "c"
			}, e)), a.a.createElement("div", {
				key: "a",
				className: g.a.expandoContainer
			}, a.a.createElement("div", {
				className: Object(i.a)(g.a.expando, Object(m.a)(e))
			})), a.a.createElement("div", {
				key: "d",
				className: g.a.subredditIconContainer
			}, a.a.createElement(O, {
				isLoading: !1
			})), a.a.createElement("div", {
				key: "e",
				className: g.a.topLine
			}, a.a.createElement("div", {
				key: "ea",
				className: Object(i.a)(g.a.title, Object(m.b)(e))
			}), a.a.createElement("div", {
				key: "eb",
				className: Object(i.a)(g.a.meta, Object(m.b)(e))
			})), a.a.createElement(j, E({
				key: "f"
			}, e))))))
		},
		"./src/reddit/components/CompactPost/index.m.less": function(e, t, s) {
			e.exports = {
				hideAboveSmallTablet: "FX_aWE8xMirpzniJDh7I9",
				verticalVotes: "WAapGmF_gr09J509Af-gC",
				responsiveExpandoButton: "_3gazhzxd2iBGYb2k67_HTw",
				mHideAboveSmallTablets: "_2zV_ARVPrYN10xmbbb_4Lu",
				responsiveMeta: "_1xomvNxK4aHGoGa-YDw1Mc",
				hideBelowSmallTablet: "z_7pbLL4hZp6ikYkq0prE",
				horizontalVotes: "_37nbKm3ee5NGx6e-LXErLD",
				mHideBelowSmallTablets: "_3x_hdVQw5uJh6xeAGoZock",
				postTopMeta: "_1ghZRP5m5xDLh0up1rFt0e",
				commentsLink: "Nz0lkWnnj2V_4iBKE0WL7",
				adLinkWrapper: "_4Dt8djtbHlJ5uCZDX_SeV",
				content: "_1B7SUGHK0QDoHimxX2a9D0",
				leftRail: "_2r9FABr2qYEUDyZoenhn6N",
				bulkActionCheckbox: "_44ehKZ_pl1NGGaaTYouZR",
				subredditIcon: "_1kWbgdOrvSeXIZZRIw4uBS",
				topLine: "_2ZjElFi3ORaU3VPrwmdoCp",
				postBadges: "_126a2ACB41algqMEwA34TF",
				flatList: "_3jwri54NGT-SRatPIZYiMo",
				expandedContentWrapper: "_12wy0ZFFaS3a49145uXWXt",
				crosspostMediaWrapper: "_2fCIreZsKBNS3esgsKKksM",
				compactWrapper: "YA9IzN0YR-G5_oD5EUydl",
				compactPostRow: "WnMeTcero48dKo501T-19",
				donationAmount: "_1TjU-e4dgCSlbuHHatC0G9",
				leftRailWrapper: "_3YgWdffoKyCp7UaGAEQpoo",
				proposalMetaData: "_1_B8IWlNlt5jJVg4cKy7nL",
				isEvent: "_1csviRG5jI9xOrcsmpbfwt",
				chain: "_1el-fLKTUXg-19pIbGUHgk",
				modToolsFlatlist: "_20p7Nh6bZU7MOqYuB2uJcy",
				postContainer: "_2bHVWuR_l_wVivC3FKfLFf",
				leftBorderWrapper: "_3ZmFVbkR23TIZ-3nboLYXe"
			}
		},
		"./src/reddit/components/CompactPost/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t), s.d(t, "renderSubredditIcon", (function() {
				return Se
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = s("./node_modules/reselect/es/index.js"),
				c = s("./src/config.ts"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				m = s("./src/reddit/components/TrackingHelper/index.tsx"),
				u = s("./src/reddit/constants/postLayout.ts"),
				p = s("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				b = s("./src/reddit/helpers/showReportIndicator/index.ts"),
				h = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				g = s("./src/reddit/helpers/trackers/post.ts"),
				E = s("./src/reddit/models/Media/index.ts"),
				x = s("./src/reddit/models/User/index.ts"),
				f = s("./src/reddit/models/Vote/index.ts"),
				v = s("./src/reddit/actions/post.ts"),
				C = s("./src/reddit/actions/postFlair.ts"),
				O = s("./src/reddit/actions/tooltip.ts"),
				j = s("./src/reddit/selectors/activeModalId.ts"),
				y = s("./src/reddit/selectors/experiments/adSidebar.ts"),
				k = s("./src/reddit/selectors/moderatorPermissions.ts"),
				w = s("./src/reddit/selectors/postFlair.ts"),
				S = s("./src/reddit/selectors/posts.ts"),
				N = s("./src/reddit/selectors/user.ts"),
				T = s("./src/reddit/components/AdLinkWrapper/index.tsx"),
				_ = s("./src/reddit/components/AwardBadges/index.tsx"),
				I = s("./src/reddit/components/CallToActionButton/index.tsx"),
				P = s("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				M = s("./src/reddit/components/CommentsLink/index.tsx"),
				R = s("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				L = s("./src/reddit/components/Economics/Support/DonationAmount/async.tsx"),
				D = s("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				A = s("./src/reddit/components/ExpandoButton/index.tsx"),
				F = s("./src/reddit/components/Flatlist/index.tsx"),
				B = s("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				U = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				H = s("./src/reddit/components/ModActionsMenu/index.tsx"),
				W = s("./src/reddit/components/ModModeReports/index.tsx"),
				q = s("./src/reddit/components/ModModeReports/helpers.ts"),
				V = s("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				z = s("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				K = s("./src/reddit/components/PostBadges/index.tsx"),
				Q = s("./src/reddit/components/PostContainer/index.tsx"),
				G = s("./src/reddit/components/PostFlairPicker/index.tsx"),
				J = s("./src/reddit/components/PostLeftRail/index.tsx"),
				Z = s("./src/reddit/components/PostMedia/index.tsx"),
				X = s("./src/reddit/components/PostModModeDropdown/index.tsx"),
				Y = s("./src/reddit/components/PostOverflowMenu/index.tsx"),
				$ = s("./src/reddit/components/PostTitle/index.tsx"),
				ee = s("./src/reddit/components/PostTopMeta/index.tsx"),
				te = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				se = s("./src/reddit/components/SponsoredLabel/index.tsx"),
				ne = s("./src/reddit/components/SubredditIcon/index.tsx"),
				ae = s("./src/reddit/components/VerticalVotes/index.tsx"),
				oe = s("./src/reddit/components/ViewReportsDropdown/index.tsx"),
				re = s("./src/reddit/contexts/InsideOverlay.tsx"),
				ie = s("./src/reddit/contexts/PageLayer/index.tsx"),
				ce = s("./src/reddit/controls/Checkbox/index.tsx"),
				de = s("./src/reddit/controls/MetaData/index.tsx"),
				le = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				me = s("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				ue = s("./src/reddit/helpers/postEvent.ts"),
				pe = s("./src/reddit/icons/fonts/IgnoreReport/index.tsx"),
				be = s("./src/reddit/icons/fonts/Report/index.tsx"),
				he = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				ge = s.n(he),
				Ee = s("./src/reddit/components/CompactPost/index.m.less"),
				xe = s.n(Ee);

			function fe() {
				return (fe = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var ve = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const Ce = e => {
					var {
						isCompact: t
					} = e, s = ve(e, ["isCompact"]);
					return a.a.createElement(A.a, fe({
						className: Object(d.a)(xe.a.responsiveExpandoButton, {
							[xe.a.mHideAboveSmallTablets]: !!t,
							[xe.a.mHideBelowSmallTablets]: !t
						})
					}, s))
				},
				Oe = Object(o.b)(() => Object(i.c)({
					activeModalId: j.a,
					crosspost: S.c,
					currentUser: N.i,
					flairStyleTemplate: ie.Q,
					isActive: S.g,
					isExpanded: S.j,
					language: N.S,
					layout: ie.M,
					moderatorPermissions: k.i,
					modModeEnabled: ie.O,
					poll: (e, t) => {
						const s = e.posts.metaMap[t.postId];
						if (s) return e.polls.models[s]
					},
					post: S.I,
					showEditFlair: w.a,
					subredditOrProfile: S.U,
					userIsOp: N.jb,
					isInAdLeftSidebarExperiment: y.a
				}), (e, t) => {
					let {
						listingKey: s,
						listingName: n,
						postId: a
					} = t;
					return {
						dispatchFlairChanged: t => {
							let {
								post: s,
								previewFlair: n,
								selectedTemplateId: a
							} = t;
							return e(Object(C.h)({
								post: s,
								previewFlair: n,
								selectedTemplateId: a
							}))
						},
						handleVote: t => {
							const s = t === f.a.upvoted ? Object(v.N)(a) : Object(v.o)(a);
							e(s)
						},
						onIgnoreReports: () => e(Object(v.L)(a)),
						onOpenReportsDropdown: t => e(Object(O.g)({
							tooltipId: t
						}))
					}
				}, (e, t, s) => Object.assign({}, s, e, t, {
					onFlairChanged: s => {
						let {
							previewFlair: n,
							selectedTemplateId: a
						} = s;
						return t.dispatchFlairChanged({
							post: e.post,
							previewFlair: n,
							selectedTemplateId: a
						})
					}
				}));
			class je extends a.a.Component {
				componentDidUpdate(e) {
					this.props.onSizeChanged && e.isExpanded !== this.props.isExpanded && this.props.onSizeChanged(this.props.post.id)
				}
				render() {
					const {
						activeModalId: e,
						className: t,
						currentProfileName: s,
						crosspost: n,
						currentUser: o,
						eventFactory: r,
						flairStyleTemplate: i,
						handleVote: l,
						isCheckboxSelected: m = !1,
						isCommentsPage: f,
						isCommentPermalink: v,
						isExpanded: C,
						isInAdLeftSidebarExperiment: O,
						isOverlay: j,
						isProfilePostListing: y,
						inSubredditOrProfile: k = !1,
						language: w,
						layout: S,
						moderatorPermissions: N,
						modModeEnabled: A,
						onClickPost: Z,
						onFlairChanged: se,
						onIgnoreReports: ne,
						poll: re,
						post: ie,
						subredditOrProfile: de,
						userIsOp: he,
						hideModTools: Ee,
						scrollerItemRef: fe,
						showBulkActionCheckbox: ve,
						showEditFlair: Ce,
						toggleCheckbox: Oe,
						tooltipType: je,
						sendEvent: ke
					} = this.props, Se = !!ie.media && ie.media.type === E.n.RTJSON, Te = he && Se, _e = Object(G.b)(ie.id, j), Ie = Object(p.a)(N), Pe = Object(me.a)(N), Me = "-mod-actions-menu-".concat(ie.id), Re = !!o && Object(x.f)(o) === ie.author, Le = Object(q.c)(ie), De = Object(B.a)("View--Reports", ie.id, je), Ae = Object(q.a)(ie), Fe = !(j || f || v), Be = e => ke(Object(g.f)(ie.id, e)), Ue = a.a.createElement(Q.a, {
						className: Object(d.a)(ge.a.compactPostStyles, xe.a.postContainer, Object(h.a)(this.props), t),
						isOverlay: j,
						style: Object.assign({}, Object(h.d)(this.props), Object(h.b)(this.props.flairStyleTemplate)),
						post: ie,
						onClick: Z,
						eventFactory: r
					}, a.a.createElement("div", {
						className: xe.a.compactWrapper
					}, a.a.createElement("div", {
						className: xe.a.leftRailWrapper
					}, a.a.createElement("div", {
						className: xe.a.leftRail,
						style: {
							borderColor: Object(J.c)({
								isRemoved: !!ie.bannedBy,
								isReported: Object(b.a)(ie),
								isSponsored: ie.isSponsored,
								theme: this.props.theme,
								isInAdLeftSidebarExperiment: O
							})
						}
					}, ve && a.a.createElement(ce.a, {
						className: xe.a.bulkActionCheckbox,
						isCheckboxSelected: m,
						toggleCheckbox: Oe
					}), a.a.createElement(ae.a, {
						className: xe.a.verticalVotes,
						compact: !0,
						flairStyleTemplate: i,
						model: ie,
						onVoteClick: l
					}), a.a.createElement(R.a, {
						className: xe.a.horizontalVotes,
						compact: !1,
						flairStyleTemplate: i,
						model: ie,
						onVoteClick: l
					}))), a.a.createElement(z.a, {
						className: Object(d.a)(xe.a.content, {
							[xe.a.isEvent]: Object(ue.a)(ie)
						}),
						"data-click-id": "background",
						flairStyleTemplate: i
					}, a.a.createElement(D.a, {
						isCompactMode: !0,
						language: w,
						post: ie
					}), a.a.createElement("div", {
						className: xe.a.compactPostRow
					}, !Ee && we(ie, n, C, !1), !k && !ie.isSponsored && a.a.createElement(U.h, {
						type: ie.belongsTo.type,
						id: ie.belongsTo.id
					}), a.a.createElement("div", {
						className: xe.a.topLine,
						"data-click-id": "body"
					}, a.a.createElement($.c, {
						post: ie,
						poll: re,
						size: $.b.Small,
						titleColor: i && i.postTitleColor,
						isOverlay: !1
					}), Ne(ie, de, w), a.a.createElement(ee.d, {
						className: xe.a.postTopMeta,
						flairStyleTemplate: i,
						language: w,
						post: ie,
						showSub: !!de && !k && !ie.isSponsored,
						subredditOrProfile: de
					}), a.a.createElement(K.a, {
						className: xe.a.postBadges,
						displayText: de ? de.displayText : null,
						inSubredditOrProfile: k,
						language: w,
						post: ie
					}), de && a.a.createElement(L.a, {
						className: xe.a.donationAmount,
						contentId: ie.id,
						subredditId: de.id
					}), a.a.createElement(_.a, {
						isOverlay: j,
						tooltipType: je,
						thing: ie
					})), Fe && a.a.createElement("div", null, a.a.createElement(P.a, {
						className: xe.a.liveDiscussionIcon,
						isMod: Ie,
						postId: ie.postId
					})), a.a.createElement("div", {
						className: xe.a.flatList
					}, a.a.createElement(M.a, {
						className: xe.a.commentsLink,
						hasModPostPerms: Ie,
						isCommentsPage: f,
						isCommentPermalink: v,
						isOverlay: j,
						postId: ie.id,
						modModeEnabled: A,
						numComments: ie.numComments,
						type: u.g.Compact
					}), a.a.createElement(V.a, {
						className: xe.a.modToolsFlatlist,
						isOverlay: !1,
						layout: S,
						modModeEnabled: A,
						post: ie,
						sendEvent: ke,
						showIconsOnly: !0
					}), Ie && a.a.createElement(H.a, {
						dropdownId: Me,
						onClick: () => Be("post_mod_action_menu")
					}, a.a.createElement(F.b, null), a.a.createElement(X.a, {
						canEditFlair: Pe && Ce,
						hasModPostPerms: Ie,
						isOverlay: !1,
						isPostAuthor: Re,
						language: w,
						modModeEnabled: A,
						post: ie,
						tooltipId: Me
					})), Ie && Le && !A && a.a.createElement(te.c, {
						text: "".concat(Ae),
						onClick: () => {
							this.props.onOpenReportsDropdown(De), Be("post_report_menu")
						},
						id: De
					}, a.a.createElement(oe.a, {
						model: ie,
						onIgnoreReports: () => {
							ne(), Be(ie.ignoreReports ? "restore_reports" : "ignore_reports")
						},
						tooltipId: De
					}), ie.ignoreReports ? a.a.createElement(pe.a, null) : a.a.createElement(be.a, null)), a.a.createElement(Y.g, {
						currentProfileName: s,
						isCommentsPage: f,
						isOverlay: !1,
						isProfilePostListing: y,
						layout: S,
						permalink: ie.permalink,
						postId: ie.postId,
						sendEvent: ke,
						showEditPost: Te,
						showEditFlair: Ce,
						dropdownId: "".concat(ie.id, "-overflow-menu"),
						useFlatlistBreakpoints: Object(Y.h)({
							share: !1,
							editPost: !1,
							save: !1,
							gild: !1,
							hide: !1,
							report: !1
						})
					}), !Ee && we(ie, n, C, !0))), ie.source && ie.source.url && ie.isSponsored && a.a.createElement(T.a, {
						className: xe.a.adLinkWrapper
					}, a.a.createElement(le.a, {
						href: ie.source.url.replace(c.a.redditUrl, ""),
						isSponsored: ie.isSponsored,
						source: ie.source
					}, ie.source.displayText), ie.callToAction && a.a.createElement(I.a, {
						href: ie.source.url.replace(c.a.redditUrl, ""),
						isSponsored: ie.isSponsored,
						source: ie.source,
						isNotCardView: !0
					}, ie.callToAction)), A && Ie && Le && a.a.createElement("div", {
						className: xe.a.compactPostRow
					}, a.a.createElement(W.a, {
						language: w,
						onIgnoreReports: ne,
						reportable: ie
					})), a.a.createElement(U.d, {
						postId: ie.id
					}))), C && a.a.createElement(ye, {
						post: ie,
						scrollerItemRef: fe,
						flairStyleTemplate: i
					}), e === _e && a.a.createElement(G.a, {
						flairs: ie.flair,
						subredditId: ie.belongsTo.id,
						modalId: _e,
						onFlairChanged: se
					}));
					return a.a.createElement(a.a.Fragment, null, Ue)
				}
			}
			const ye = e => a.a.createElement(z.a, {
					className: Object(d.a)(e.className, xe.a.expandedContentWrapper),
					flairStyleTemplate: e.flairStyleTemplate
				}, e.post.crosspostRootId ? a.a.createElement("div", {
					className: xe.a.crosspostMediaWrapper
				}, ke(e.post, e.scrollerItemRef)) : ke(e.post, e.scrollerItemRef)),
				ke = (e, t) => a.a.createElement(Z.a, {
					isExpando: !0,
					isListing: !0,
					isNotCardView: !0,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					showFull: !0,
					showCentered: !0,
					post: e
				}),
				we = (e, t, s, n) => a.a.createElement(Ce, {
					crosspost: t,
					isCompact: n,
					isExpanded: s,
					post: e,
					useMediaIcons: !0
				}),
				Se = e => a.a.createElement(r.a, {
					"data-click-id": "subreddit",
					to: e.url
				}, a.a.createElement(ne.b, {
					className: xe.a.subredditIcon,
					subredditOrProfile: e
				})),
				Ne = (e, t, s) => a.a.createElement("div", {
					className: xe.a.responsiveMeta
				}, a.a.createElement(de.b, {
					isScoreHidden: e.scoreHidden,
					language: s,
					score: e.score
				}), a.a.createElement(de.c, null), Object(de.d)(e.numComments, s), a.a.createElement(de.c, null), t && a.a.createElement("a", {
					href: t.url
				}, a.a.createElement(de.a, null, t.displayText)), e.isSponsored && [a.a.createElement(se.a, {
					key: "label"
				}), a.a.createElement(de.c, {
					key: "separator"
				})], !e.isSponsored && a.a.createElement(de.a, null, " Posted by "), a.a.createElement(ee.b, {
					post: e
				}));
			t.default = Oe(Object(m.b)(Object(re.b)(Object(l.a)(je))))
		},
		"./src/reddit/components/ConfirmModal/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_3DhQ2s_h1XCiwltypHmlbp",
				close: "_2oxgXPm-tiPAEPsJoUw-ZD",
				headerText: "_2sDCzF6zlpNJ5cbVDRCPOS",
				text: "_3eWjwYvkDvPzyq4FlubrF9",
				buttonWrapper: "_6ZHRZ8Epefe887d7LL-q6",
				primaryButton: "Ch-0dFLxLOtcc6xCyQvsk",
				secondaryButton: "bgwHoiDoSwFVZKRTLRQMF"
			}
		},
		"./src/reddit/components/ConfirmModal/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/higherOrderComponents/asModal/index.tsx"),
				r = s("./src/reddit/controls/Button/index.tsx"),
				i = s("./src/reddit/components/ConfirmModal/index.m.less"),
				c = s.n(i),
				d = s("./src/reddit/components/ModalStyledComponents/index.tsx");
			t.a = Object(o.a)(e => a.a.createElement("div", {
				className: c.a.container
			}, a.a.createElement("button", {
				onClick: () => e.onClose ? e.onClose() : e.onCancel(),
				className: c.a.close
			}, a.a.createElement(d.b, null)), a.a.createElement(d.g, null, a.a.createElement("h2", {
				className: c.a.headerText
			}, e.headerText)), a.a.createElement(d.j, null, e.message && a.a.createElement("p", {
				className: c.a.text
			}, e.message), e.children && a.a.createElement("div", {
				className: c.a.text
			}, e.children), a.a.createElement("div", {
				className: c.a.buttonWrapper
			}, e.cancelText && a.a.createElement(r.i, {
				className: c.a.secondaryButton,
				onClick: e.onCancel
			}, e.cancelText), a.a.createElement(r.f, {
				className: c.a.primaryButton,
				onClick: e.onAccept
			}, e.acceptText)))))
		},
		"./src/reddit/components/Economics/TopTippers/CommentUsername/index.m.less": function(e, t, s) {
			e.exports = {
				badge: "_17rA6EEcc6RUglkZkHnYGO",
				container: "EorVQyBcpl50FYvpH-VTa"
			}
		},
		"./src/reddit/components/Economics/TopTippers/Icon/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/config.ts");
			const r = new Set(["t2_ktrtg"]),
				i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5,
						t = arguments.length > 1 ? arguments[1] : void 0;
					return "".concat(o.a.assetPath, "/img/badges/topTippers/").concat(t, "/rank-").concat(e, ".png")
				};
			t.a = e => a.a.createElement("img", {
				className: e.className,
				src: i(e.rank, e.creatorId && r.has(e.creatorId) ? e.creatorId : e.subredditId)
			})
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2A1Ng1fBxjU-qYqbEJn_sm",
				EventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventFollowButton: "_2XCKBYzBTZpjOAFEWv1tSy",
				isCompact: "_2gNxoOe_xKaMk0mmYMQCGs"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/eventTools/index.ts"),
				i = s("./src/lib/lessComponent.tsx"),
				c = s("./src/reddit/components/EventPost/PostEventMeta/index.tsx"),
				d = s("./src/reddit/components/PostFollow/index.tsx"),
				l = s("./src/reddit/helpers/postCollection.ts"),
				m = s("./src/reddit/helpers/postEvent.ts"),
				u = s("./src/reddit/components/EventPost/EventMetaHeader/index.m.less"),
				p = s.n(u);
			const b = i.a.div("EventMetaWrapper", p.a);
			t.a = e => {
				let {
					className: t,
					isCompactMode: s,
					language: n,
					post: i
				} = e;
				if (!Object(m.a)(i)) return null;
				const u = i && i.eventInfo,
					h = Object(l.a)(i),
					g = u && Object(r.c)(u.eventStart, u.eventEnd);
				return a.a.createElement("div", {
					className: Object(o.a)(p.a.container, t, {
						[p.a.isCompact]: !!s
					})
				}, a.a.createElement(b, {
					className: p.a.eventMetaWrapper
				}, a.a.createElement(c.a, {
					language: n,
					post: i
				}), !h && g && a.a.createElement(d.a, {
					className: p.a.eventFollowButton,
					post: i,
					isEventFollow: !0
				})))
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.m.less": function(e, t, s) {
			e.exports = {
				PostEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				postEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				PostEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				postEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				PostEventNowText: "BGfronFwr_0rXxOJmxp10",
				postEventNowText: "BGfronFwr_0rXxOJmxp10",
				Container: "_3NIcD2Vr2xrSAq08U14kCy",
				container: "_3NIcD2Vr2xrSAq08U14kCy",
				CalendarIcon: "LEz3F0HfvMpdo96occzKU",
				calendarIcon: "LEz3F0HfvMpdo96occzKU",
				LiveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				liveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				LoadingState: "_27_KVVxYHZ7v44CE2vg8bT",
				loadingState: "_27_KVVxYHZ7v44CE2vg8bT"
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/eventTools/index.ts"),
				r = (s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./src/app/strings/index.ts")),
				i = s("./src/lib/constants/index.ts");

			function c(e, t) {
				return e.toLocaleDateString(t, {
					month: "numeric",
					day: "numeric"
				})
			}
			var d = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				l = s("./src/reddit/icons/fonts/Calendar/index.tsx"),
				m = s("./src/reddit/icons/fonts/Live/index.tsx"),
				u = s("./src/reddit/components/EventPost/PostEventMeta/index.m.less"),
				p = s.n(u),
				b = s("./src/lib/lessComponent.tsx");
			const h = b.a.span("PostEventFutureText", p.a),
				g = b.a.span("PostEventPastText", p.a),
				E = b.a.span("PostEventNowText", p.a),
				x = b.a.span("Container", p.a),
				f = b.a.wrapped(l.a, "CalendarIcon", p.a),
				v = b.a.wrapped(m.a, "LiveIcon", p.a),
				C = b.a.div("LoadingState", p.a);
			class O extends n.Component {
				constructor(e) {
					super(e), this.state = {
						mounted: !1
					}
				}
				componentDidMount() {
					this.setState({
						mounted: !0
					})
				}
				render() {
					const {
						className: e,
						language: t,
						post: s
					} = this.props, {
						eventInfo: n
					} = s;
					if (!n) return null;
					const {
						eventEnd: l,
						eventIsLive: m,
						eventStart: u
					} = n, p = Object(o.e)(u, l);
					let b, O;
					if (this.state.mounted || p === o.a.Live) b = function(e, t, s, n) {
						const a = Object(o.e)(e, t),
							d = new Date(e * i.Cb);
						let l;
						if (a === o.a.Live || n) return Object(r.a)(s, "posts.event.inProgress");
						a === o.a.Future ? l = Object(o.d)(e) ? Object(r.a)(s, "posts.event.today") : Object(o.b)(e) >= 5 ? c(d, s) : function(e, t) {
							return e.toLocaleDateString(t, {
								weekday: "long"
							})
						}(d, s) : a === o.a.Past && (l = Object(o.d)(e) ? Object(r.a)(s, "posts.event.today") : c(d, s));
						const m = function(e, t) {
							return e.toLocaleTimeString(t, {
								hour12: !0,
								hour: "numeric",
								minute: "2-digit"
							}).replace(/ /g, "").toUpperCase()
						}(d, s);
						return "".concat(l, " @ ").concat(m)
					}(u, l, t, m);
					else {
						const e = Object(d.a)({
							isLoading: !0
						});
						b = a.a.createElement(C, {
							className: e
						})
					}
					if (m) O = a.a.createElement(E, null, a.a.createElement(v, null), b);
					else if (p === o.a.Future) O = a.a.createElement(h, null, a.a.createElement(f, null), b);
					else {
						if (p !== o.a.Past) return null;
						O = a.a.createElement(g, null, a.a.createElement(f, null), b)
					}
					return a.a.createElement(x, {
						className: e
					}, O)
				}
			}
			t.a = O
		},
		"./src/reddit/components/ExpandoButton/index.m.less": function(e, t, s) {
			e.exports = {
				outer: "RvLtAcdRtbOQbhFB7MD_T",
				icon: "saNpcHve-34zjaa0cbIxW",
				hideOnHover: "_25HJpaEPiVNq6Ss3Ad7dp9",
				showOnHover: "_2S05CzViTnl3I2ekCABqFo",
				outboundLinkIcon: "_1zB4YvOwHPxdPEXG2CYhKB"
			}
		},
		"./src/reddit/components/ExpandoButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/permalinkToOverlayLocation/index.ts"),
				d = s("./src/reddit/i18n/utils.ts"),
				l = s("./src/reddit/actions/post.ts"),
				m = s("./src/reddit/controls/OutboundLink/index.tsx"),
				u = s("./src/reddit/helpers/postHasSelfText/index.ts"),
				p = s("./src/reddit/icons/fonts/Crosspost/index.tsx"),
				b = s("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				h = s("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				g = s("./src/reddit/icons/fonts/helpers.tsx"),
				E = s("./src/reddit/icons/fonts/Expandos/Media/Lightbox/index.m.less"),
				x = s.n(E);
			var f = s("./src/lib/lessComponent.tsx").a.wrapped(e => a.a.createElement("i", {
					className: "".concat(Object(g.b)("expandoMediaLightbox"), " ").concat(e.className),
					onClick: e.onClick
				}), "LightboxIcon", x.a),
				v = s("./src/reddit/icons/fonts/Expandos/Media/Video/index.tsx"),
				C = s("./src/reddit/icons/fonts/Gif/index.tsx"),
				O = s("./src/reddit/icons/fonts/Link/index.tsx"),
				j = s("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				y = s("./src/reddit/icons/fonts/Photos/index.tsx"),
				k = s("./src/reddit/icons/fonts/Text/index.tsx"),
				w = s("./src/reddit/models/Media/index.ts"),
				S = s("./src/reddit/components/ExpandoButton/index.m.less"),
				N = s.n(S);
			const T = Object(o.b)(null, (e, t) => ({
					toggle: () => e(Object(l.p)({
						postId: t.post.id
					}))
				})),
				_ = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					const s = Object(i.a)(N.a.icon, N.a.hideOnHover);
					if (t) return a.a.createElement(p.a, {
						className: s
					});
					switch (e) {
						case w.n.GIFVIDEO:
							return a.a.createElement(C.a, {
								className: s
							});
						case w.n.IMAGE:
							return a.a.createElement(y.a, {
								className: s
							});
						case w.n.TEXT:
						case w.n.RTJSON:
							return a.a.createElement(k.a, {
								className: s
							});
						case w.n.VIDEO:
							return a.a.createElement(v.a, {
								className: s
							});
						case w.n.EMBED:
						default:
							return a.a.createElement(O.a, {
								className: s
							})
					}
				};
			t.a = T(e => {
				const {
					className: t,
					crosspost: s,
					enableCrosspostIcon: n,
					isExpanded: o,
					post: l,
					toggle: p,
					useMediaIcons: g
				} = e, E = s || l, x = n && !!s;
				return E.media && !(("rtjson" === E.media.type || "text" === E.media.type) && !Object(u.a)(E)) ? a.a.createElement("button", {
					"aria-expanded": o,
					"aria-haspopup": !0,
					"aria-label": Object(d.c)("Expand content"),
					className: Object(i.a)(t, N.a.outer),
					"data-click-id": o ? "expando_close" : "expando_open",
					onClick: p
				}, o ? a.a.createElement(b.a, {
					className: N.a.icon
				}) : g ? a.a.createElement(a.a.Fragment, null, _(E.media && E.media.type, x), a.a.createElement(h.a, {
					className: Object(i.a)(N.a.icon, N.a.showOnHover)
				})) : a.a.createElement(h.a, {
					className: N.a.icon
				})) : E.source && E.source.url ? a.a.createElement(m.a, {
					"aria-label": Object(d.c)("Open external content"),
					className: Object(i.a)(t, N.a.outer),
					"data-click-id": "expando_open",
					href: E.source.url,
					isSponsored: l.isSponsored,
					source: l.source,
					target: "_blank"
				}, a.a.createElement(j.a, {
					className: Object(i.a)(N.a.icon, N.a.outboundLinkIcon)
				})) : a.a.createElement(r.a, {
					"aria-label": Object(d.c)("View content"),
					className: Object(i.a)(t, N.a.outer),
					"data-click-id": "expando_open",
					to: Object(c.a)(E.permalink),
					rel: "nofollow"
				}, a.a.createElement(f, {
					className: N.a.icon
				}))
			})
		},
		"./src/reddit/components/GrantUserFlair/index.m.less": function(e, t, s) {
			e.exports = {
				titleRow: "_1knBg4PWacEaLvDRHAvsTp",
				flairDetails: "_2bPY-7msbc_UjCac-In6Li",
				flairEditColumn: "_2ebZb7SML8ZCy-QsS6tUc0",
				column: "_3vuuCvX3U56Wb64Bz3AX9W",
				iconsColumn: "Q9C1YLEYQHPi_NuLIcsS3",
				removeIcon: "_2IP600IxdVV8-hzfus_xst",
				removeButton: "Yd-aY1XSmw6atYPPJHm9n",
				row: "_3W5UQ4TDClfiDY4zEBYSqT",
				flairEditHelperText: "_2JpPK1gCbDBJBbMRrx-fe6",
				errorIndicator: "_1gmumWT2YihpY16NJJw_ac",
				hasError: "Uu_my_fNiUJaUT-wFhyeq",
				flairContainer: "_1c46XAzSY3wg6lATaRh11v",
				userLink: "_14IDyvxQsRUGTR9unevdzm",
				textInput: "_3OzKI46CUHBipWh2v7Cfq",
				dropdownTriangle: "_3L2zEwdN8hdor-MjnuTTXx",
				dropdownTarget: "_2q91kdzeOjUsLeozfWfPZI",
				dropdownContainer: "_2SgxV6WihN0lLBZ06jChDN",
				dropdownRow: "Hsh_7uWgjhtYFcA5QqiI6",
				userIcon: "uHVmBRWHNpGMMkIFBthWs",
				modIcon: "_31YDoZrj2KLLxWJhYimRfb",
				infoTooltip: "i75byXeh_ZzdbD0HGxb4",
				tooltipText: "_3FXJw0xh37YZHaJP_j3Npe",
				tooltipIconContainer: "_1dZeti3tpsM8YrfluheTX5",
				tooltipIconRow: "_2B9YDCXdUsKx20YPQ_0guj",
				tooltipIconText: "_2_doCenMWfLXsGEvDSq1NB",
				cssInputError: "_3ySNKx0QJZRCNOFB6345zX",
				bottomBarRow: "Tf16TWgXZcNKzLmD4PDPq",
				topBar: "e-h9YD6UZh8FOUPTG6drY",
				disabledBanner: "_3rrCSsx0QD7pFwGJquTq-6",
				warningIcon: "_3MSU8YNfdz6icABES0GIkK",
				emptyList: "y4YDfdWBHO7s3GVuYjBDF",
				flairIcon: "_3RYWcdo8Ov1AjwCGeCUsfs",
				mainText: "_8uYoAAuUrGW1iwcBP-2eS",
				fadeIn: "_3YR0vW4lNgbJJ7RgssVmf-"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/reddit/actions/tooltip.ts"),
				c = s("./src/reddit/models/User/index.ts"),
				d = s("./src/reddit/selectors/gov.ts"),
				l = s("./src/reddit/selectors/meta.ts"),
				m = s("./src/reddit/selectors/moderatorPermissions.ts"),
				u = s("./src/reddit/selectors/tooltip.ts"),
				p = s("./src/reddit/selectors/user.ts"),
				b = s("./src/reddit/selectors/userFlair.ts"),
				h = s("./src/config.ts"),
				g = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				E = s("./src/lib/lessComponent.tsx"),
				x = s("./src/lib/prettyPrintNumber/index.ts"),
				f = s("./src/lib/timeAgo/index.ts"),
				v = s("./src/reddit/i18n/components.tsx"),
				C = s("./src/reddit/components/ChatButton/index.tsx"),
				O = s("./src/reddit/components/JSAPIContainers/index.tsx"),
				j = s("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				y = s("./src/reddit/components/SubscribeButton/index.tsx"),
				k = s("./src/reddit/helpers/trackers/authorHovercard.ts"),
				w = s("./src/reddit/icons/svgs/Admin/index.tsx"),
				S = s("./src/reddit/icons/svgs/Karma/index.tsx"),
				N = s("./src/reddit/icons/svgs/Premium/index.tsx"),
				T = s("./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx"),
				_ = s("./src/reddit/i18n/utils.ts"),
				I = s("./src/reddit/actions/inContextModeration.ts"),
				P = s("./src/reddit/actions/modal.ts"),
				M = s("./src/reddit/actions/subredditModeration.ts"),
				R = s("./src/reddit/constants/modals.ts"),
				L = s("./src/reddit/components/Hovercards/helpers.ts"),
				D = s("./src/reddit/icons/svgs/Ban/index.tsx"),
				A = s("./src/reddit/icons/svgs/Mute/index.tsx"),
				F = s("./src/reddit/icons/svgs/Unban/index.tsx"),
				B = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				U = s("./src/reddit/selectors/subredditModeration.ts"),
				H = s("./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less"),
				W = s.n(H);
			const {
				fbt: q
			} = s("./node_modules/fbt/lib/FbtPublic.js"), V = E.a.wrapped(D.a, "BanIcon", W.a), z = E.a.wrapped(A.a, "MuteIcon", W.a), K = E.a.wrapped(F.a, "UnbanIcon", W.a), Q = Object(r.c)({
				hasModMailPermissions: Object(m.a)(B.c.mail),
				isUserBanned: (e, t) => !!Object(U.g)(e, {
					subredditId: t.subredditId,
					username: t.username
				}),
				user: (e, t) => Object(p.hb)(e, {
					userName: t.username
				})
			});
			class G extends a.a.Component {
				componentDidMount() {
					this.props.requestUserBanInfo()
				}
				render() {
					const {
						className: e,
						contextId: t,
						hasModMailPermissions: s,
						isUserBanned: n,
						onUnbanUser: o,
						sendEvent: r,
						toggleBanModal: i,
						toggleMuteModal: c
					} = this.props;
					return a.a.createElement("div", {
						className: e
					}, n ? a.a.createElement(L.a, {
						role: "button",
						onClick: () => {
							o(this.props.user.id), r(k.e(t))
						}
					}, a.a.createElement(K, null), q._("Unban User", null, {
						hk: "1aASyW"
					})) : a.a.createElement(L.a, {
						role: "button",
						onClick: () => {
							i(), r(k.a(t))
						}
					}, a.a.createElement(V, null), q._("Ban User", null, {
						hk: "3OhuLx"
					})), s && a.a.createElement(L.a, {
						role: "button",
						onClick: () => {
							c(), r(k.d(t))
						}
					}, a.a.createElement(z, null), q._("Mute User", null, {
						hk: "3MCujH"
					})))
				}
			}
			var J = Object(o.b)(Q, (e, t) => {
					let {
						username: s,
						subredditId: n,
						contextId: a
					} = t;
					return {
						onUnbanUser: t => e(Object(M.nb)(n, t)),
						requestUserBanInfo: () => e(Object(M.Z)(n, {
							username: s
						})),
						toggleBanModal: () => {
							e(Object(I.c)({
								username: s,
								subredditId: n,
								contextId: a
							})), e(Object(M.X)(n, s))
						},
						toggleMuteModal: () => {
							e(Object(I.d)({
								username: s,
								subredditId: n,
								contextId: a
							})), e(Object(P.i)(R.a.MUTE_USER))
						}
					}
				})(G),
				Z = s("./src/reddit/actions/userFlair.ts"),
				X = s("./src/reddit/icons/svgs/Tag/index.tsx"),
				Y = s("./src/reddit/components/Hovercards/AuthorHovercard/ModFlairActions.m.less"),
				$ = s.n(Y);
			const ee = E.a.wrapped(X.a, "FlairIcon", $.a);
			var te = Object(o.b)(null, (e, t) => ({
					onToggleUserFlairModal: () => e(Object(Z.p)(t.subredditId, t.username))
				}))(e => a.a.createElement(L.a, {
					role: "button",
					onClick: () => {
						e.onToggleUserFlairModal(), e.sendEvent(k.c(e.contextId))
					}
				}, a.a.createElement(ee, null), a.a.createElement(v.c, null, "Edit user flair"))),
				se = s("./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less"),
				ne = s.n(se);

			function ae() {
				return (ae = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const oe = E.a.div("SubredditIcon", ne.a),
				re = E.a.wrapped(y.a, "SubscribeButton", ne.a),
				ie = E.a.wrapped(C.a, "ChatButton", ne.a),
				ce = E.a.wrapped(S.a, "KarmaIcon", ne.a),
				de = E.a.wrapped(N.a, "PremiumIcon", ne.a),
				le = E.a.wrapped(g.a, "UserNameLink", ne.a),
				me = E.a.div("UserNameMetaData", ne.a),
				ue = E.a.div("MetaDataItem", ne.a),
				pe = E.a.div("Bullet", ne.a),
				be = E.a.div("UserNameContainer", ne.a),
				he = E.a.div("UserInfoContainer", ne.a),
				ge = E.a.div("PostKarma", ne.a),
				Ee = E.a.div("CommentKarma", ne.a),
				xe = E.a.div("KarmaCount", ne.a),
				fe = E.a.div("KarmaLabel", ne.a),
				ve = E.a.div("BannerImage", ne.a),
				Ce = E.a.div("UserContainer", ne.a),
				Oe = E.a.div("BottomSpacer", ne.a),
				je = E.a.div("Container", ne.a),
				ye = e => a.a.createElement("div", null, a.a.createElement("div", null, a.a.createElement(le, {
					to: "/user/".concat(e.userName, "/")
				}, "u/".concat(e.userName)), e.user.isEmployee && a.a.createElement(w.a, {
					className: ne.a.adminIcon,
					title: Object(_.c)("Reddit admin")
				}), e.user.isGold && a.a.createElement(g.a, {
					to: "/premium"
				}, a.a.createElement(de, null))), a.a.createElement(me, null, e.user.username && a.a.createElement(ue, null, e.user.username, a.a.createElement(pe, null, "•")), a.a.createElement(ue, null, Object(f.d)(e.language, e.user.created)))),
				ke = e => a.a.createElement(he, null, a.a.createElement(ce, null), a.a.createElement(ge, null, a.a.createElement(xe, null, Object(x.b)(e.user.postKarma)), a.a.createElement(fe, null, a.a.createElement(v.c, null, "Post Karma"))), a.a.createElement(Ee, null, a.a.createElement(xe, null, Object(x.b)(e.user.commentKarma)), a.a.createElement(fe, null, a.a.createElement(v.c, null, "Comment Karma")))),
				we = Object(j.a)(e => {
					const {
						className: t,
						contextId: s,
						hideNSFWPref: n,
						hoverId: o,
						isCurrentUser: r,
						isLoggedIn: i,
						origin: c,
						language: d,
						moderatorPermissions: l,
						sendEvent: m,
						style: u,
						subredditId: p,
						userName: b,
						user: g,
						userFlair: E
					} = e;
					if (!g) return a.a.createElement(je, {
						style: u
					});
					const x = g.isNSFW && n,
						f = g.accountIcon || "".concat(h.a.assetPath, "/img/snoo_user_placeholder.png"),
						v = l && l.flair,
						C = l && l.access,
						j = E && E.templateIds && E.templateIds.length > 0,
						y = E && E.displaySettings && E.displaySettings.isEnabled,
						{
							awardedLastMonth: w
						} = g,
						S = x ? "".concat(h.a.assetPath, "/img/user-info-banner.png") : e.user.bannerImage,
						N = x ? "".concat(h.a.assetPath, "/img/avatar_over18_square.png") : f;
					return a.a.createElement(je, {
						className: t,
						id: o,
						style: u
					}, a.a.createElement(ve, {
						style: {
							backgroundImage: "url('".concat(S, "')")
						}
					}), a.a.createElement(Ce, null, a.a.createElement(be, null, a.a.createElement(oe, {
						style: {
							background: "url('".concat(N, "')"),
							backgroundSize: "contain"
						}
					}), a.a.createElement(ye, {
						language: d,
						origin: c,
						user: g,
						userName: b
					})), a.a.createElement(ke, {
						language: d,
						user: g,
						userName: b
					}), w && a.a.createElement(T.a, {
						recentAwardings: w,
						username: b
					}), i && !r && a.a.createElement(ie, {
						contextId: s,
						userId: g.id
					}, Object(_.c)("Start Chat")), g.hasUserProfile && !r && a.a.createElement(re, {
						identifier: {
							name: e.user.username,
							type: "profile"
						},
						getEventFactory: e => Object(k.g)(e ? "unfollow" : "follow", s),
						small: !0
					})), C && s && !r && p && a.a.createElement(J, {
						contextId: s,
						language: d,
						subredditId: p,
						sendEvent: m,
						username: b
					}), v && s && j && y && p && a.a.createElement(te, {
						contextId: s,
						language: d,
						subredditId: p,
						sendEvent: m,
						username: b
					}), a.a.createElement(O.i, {
						contextId: s,
						subredditId: p,
						user: g
					}), !(C || i) && a.a.createElement(Oe, null))
				});
			var Se = e => {
				const t = e.activeTooltipId === e.tooltipId;
				return a.a.createElement(we, ae({
					isOpen: t
				}, e))
			};
			const Ne = Object(r.c)({
					tokenName: d.o,
					activeTooltipId: u.a,
					isCurrentUser: (e, t) => {
						const s = Object(p.i)(e);
						return !!s && Object(c.f)(s) === t.userName
					},
					isLoggedIn: p.J,
					hideNSFWPref: p.z,
					language: p.S,
					moderatorPermissions: m.j,
					origin: l.g,
					user: p.hb,
					userFlair: b.c
				}),
				Te = Object(o.b)(Ne, (e, t) => ({
					onHideTooltip: () => e(Object(i.h)())
				}));
			t.a = Te(e => a.a.createElement("div", {
				className: e.className,
				id: e.tooltipId,
				onMouseLeave: e.onHideTooltip
			}, a.a.createElement(Se, {
				activeTooltipId: e.activeTooltipId,
				contextId: e.contextId,
				isCurrentUser: e.isCurrentUser,
				isLoggedIn: e.isLoggedIn,
				hideNSFWPref: e.hideNSFWPref,
				hoverId: e.hoverId,
				language: e.language,
				moderatorPermissions: e.moderatorPermissions,
				onHideTooltip: e.onHideTooltip,
				origin: e.origin,
				sendEvent: e.sendEvent,
				subredditId: e.subredditId,
				tokenName: e.tokenName,
				tooltipId: e.tooltipId,
				tooltipType: e.tooltipType,
				user: e.user,
				userFlair: e.userFlair,
				userName: e.userName
			})))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less": function(e, t, s) {
			e.exports = {
				BanIcon: "_2g595huO3XJ8C5PGbnTIcH",
				banIcon: "_2g595huO3XJ8C5PGbnTIcH",
				MuteIcon: "_1qnIs5F_qVlqqqY9ZvtGHT",
				muteIcon: "_1qnIs5F_qVlqqqY9ZvtGHT",
				UnbanIcon: "_3gnOs3YMjVI2NyE6rZjyL3",
				unbanIcon: "_3gnOs3YMjVI2NyE6rZjyL3"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModFlairActions.m.less": function(e, t, s) {
			e.exports = {
				FlairIcon: "_2xaYvwRfHZMRW_6lyBpV4v",
				flairIcon: "_2xaYvwRfHZMRW_6lyBpV4v"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/components/Hovercards/HoverDiv/index.tsx"),
				r = s("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				i = s("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = Object(i.b)(e => {
				const t = "".concat(e.tooltipId, "-hover-id");
				return a.a.createElement(o.a, {
					hoverId: t,
					sendHoverEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId,
					authorOrSubredditName: e.user
				}, e.children, a.a.createElement(r.a, {
					className: e.className,
					hoverId: t,
					sendEvent: e.sendEvent,
					subredditId: e.subredditId,
					tooltipId: e.tooltipId,
					tooltipType: e.tooltipType,
					userName: e.user
				}))
			})
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less": function(e, t, s) {
			e.exports = {
				ChatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				chatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				SubredditIcon: "_59_dv7TVnod9oIzsOdPEM",
				subredditIcon: "_59_dv7TVnod9oIzsOdPEM",
				SubscribeButton: "yFByQg8RzENoqoOt0ysAk",
				subscribeButton: "yFByQg8RzENoqoOt0ysAk",
				KarmaIcon: "_2XmHHGriP3EYLhv_9BG6OT",
				karmaIcon: "_2XmHHGriP3EYLhv_9BG6OT",
				PremiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				premiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				Token: "_2U0P3n4v75sHsDvQmSKNz3",
				token: "_2U0P3n4v75sHsDvQmSKNz3",
				UserNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				userNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				UserNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				userNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				GildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				gildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				MetaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				metaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				Bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				UserNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				userNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				UserInfoContainer: "_3l7ptRjFJYo-fcXXajRpqn",
				userInfoContainer: "_3l7ptRjFJYo-fcXXajRpqn",
				PostKarma: "_2T3kavHwxOaL76xfa9id7",
				postKarma: "_2T3kavHwxOaL76xfa9id7",
				CommentKarma: "_1rFYsN1yoSDrDTRfqagI5r",
				commentKarma: "_1rFYsN1yoSDrDTRfqagI5r",
				KarmaCount: "_18aX_pAQub_mu1suz4-i8j",
				karmaCount: "_18aX_pAQub_mu1suz4-i8j",
				KarmaLabel: "_1b2tgHrvjFKgTLyFIQ9B6T",
				karmaLabel: "_1b2tgHrvjFKgTLyFIQ9B6T",
				BannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				bannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				UserContainer: "_m7PpFuKATP9fZF4xKf9R",
				userContainer: "_m7PpFuKATP9fZF4xKf9R",
				BottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				bottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				UserActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				userActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				Container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				adminIcon: "_2aJuBKF3mo4YJS4YFkeU9a"
			}
		},
		"./src/reddit/components/Hovercards/HoverDiv/index.m.less": function(e, t, s) {
			e.exports = {
				HoverDiv: "_2mHuuvyV9doV3zwbZPtIPG",
				hoverDiv: "_2mHuuvyV9doV3zwbZPtIPG"
			}
		},
		"./src/reddit/components/Hovercards/HoverDiv/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/lessComponent.tsx"),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				c = s("./src/reddit/actions/profile/index.ts"),
				d = s("./src/reddit/actions/tooltip.ts"),
				l = s("./src/reddit/selectors/tooltip.ts");
			const m = Object(i.c)({
				dropdownIsOpen: (e, t) => Object(l.b)(t.tooltipId)(e)
			});
			var u = Object(r.b)(m, (e, t) => ({
					onCloseUserDropdown: () => e(Object(d.h)()),
					onOpenUserDropdown: async () => {
						e(Object(d.f)({
							tooltipId: t.tooltipId
						})), t.authorOrSubredditName && e(Object(c.d)(t.authorOrSubredditName))
					}
				})),
				p = s("./src/reddit/actions/subreddit.ts");
			const b = Object(i.c)({
				dropdownIsOpen: (e, t) => Object(l.b)(t.tooltipId)(e)
			});
			var h = Object(r.b)(b, (e, t) => ({
					onCloseUserDropdown: () => e(Object(d.h)()),
					onOpenUserDropdown: async () => {
						e(Object(d.f)({
							tooltipId: t.tooltipId
						})), t.authorOrSubredditName && e(Object(p.t)(t.authorOrSubredditName))
					}
				})),
				g = s("./src/reddit/components/Hovercards/HoverDiv/index.m.less"),
				E = s.n(g);
			s.d(t, "a", (function() {
				return v
			})), s.d(t, "b", (function() {
				return C
			}));
			class x extends a.a.Component {
				constructor() {
					super(...arguments), this.closeHovercardTimeoutId = 0, this.openHovercardTimeoutId = 0, this.isHovering = !1, this.hoverEl = void 0, this.onHoverElMouseEnter = () => {
						this.isHovering = !0
					}, this.onHoverElMouseLeave = () => {
						this.isHovering = !1
					}, this.onMouseEnter = e => {
						this.closeHovercardTimeoutId && clearTimeout(this.closeHovercardTimeoutId), this.openHovercardTimeoutId = window.setTimeout(() => {
							this.isHovering || this.props.dropdownIsOpen || (this.props.onOpenUserDropdown(), this.props.sendHoverEvent())
						}, 500)
					}, this.onMouseLeave = () => {
						this.openHovercardTimeoutId && clearTimeout(this.openHovercardTimeoutId), this.closeHovercardTimeoutId = window.setTimeout(() => {
							this.isHovering || this.props.onCloseUserDropdown()
						}, 300)
					}
				}
				componentDidMount() {
					const e = document.getElementById(this.props.hoverId);
					e && (this.hoverEl = e, this.addHoverListeners(this.hoverEl))
				}
				componentWillUnmount() {
					this.hoverEl && this.removeHoverListeners(this.hoverEl), this.hoverEl = void 0, this.openHovercardTimeoutId && window.clearTimeout(this.openHovercardTimeoutId)
				}
				addHoverListeners(e) {
					e.addEventListener("mouseenter", this.onHoverElMouseEnter), e.addEventListener("mouseleave", this.onHoverElMouseLeave)
				}
				removeHoverListeners(e) {
					e.removeEventListener("mouseenter", this.onHoverElMouseEnter), e.removeEventListener("mouseleave", this.onHoverElMouseLeave)
				}
				render() {
					const {
						children: e,
						className: t
					} = this.props;
					return a.a.createElement("div", {
						className: t,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, e)
				}
			}
			const f = o.a.wrapped(x, "HoverDiv", E.a),
				v = u(f),
				C = h(f)
		},
		"./src/reddit/components/Hovercards/helpers.m.less": function(e, t, s) {
			e.exports = {
				UserActionItem: "_3HFQBVggvR9KDsFzm7jIdr",
				userActionItem: "_3HFQBVggvR9KDsFzm7jIdr"
			}
		},
		"./src/reddit/components/Hovercards/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			})), s.d(t, "b", (function() {
				return c
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/layout/row/Inline/index.tsx"),
				o = s("./src/reddit/components/Hovercards/helpers.m.less"),
				r = s.n(o);
			const i = n.a.wrapped(a.a, "UserActionItem", r.a),
				c = e => {
					const {
						author: t,
						itemId: s,
						subredditName: n,
						tooltipIdPrefix: a,
						tooltipType: o
					} = e;
					let r = a;
					return s && (r = "".concat(r, "--").concat(s)), o && (r = "".concat(r, "--").concat(o)), t && (r = "".concat(r, "--").concat(t)), n && (r = "".concat(r, "--").concat(n)), r
				}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, s) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				i = s.n(r),
				c = s("./src/lib/lessComponent.tsx");
			const d = c.a.div("IconWrapper", i.a),
				l = c.a.div("TextWrapper", i.a);
			t.a = e => {
				const {
					className: t,
					color: s,
					icon: n,
					subtitle: r,
					title: c
				} = e;
				return a.a.createElement("div", {
					className: Object(o.a)(t, i.a.wrapper),
					style: s && {
						borderColor: s
					} || {}
				}, a.a.createElement("div", {
					className: i.a.leftSideRectangle,
					style: s && {
						backgroundColor: s
					} || {}
				}), n ? a.a.createElement(d, null, n) : a.a.createElement(d, null), a.a.createElement(l, null, a.a.createElement("div", {
					className: i.a.title
				}, c), r && a.a.createElement("div", {
					className: i.a.subtitle
				}, r)))
			}
		},
		"./src/reddit/components/LargePost/placeholder.m.less": function(e, t, s) {
			e.exports = {
				content: "_1yYeg-XN7v7i06TrK8Lh13",
				emptyVerticalVotes: "_3Qm3gV6v4Y9YWuQgCqMvJr",
				emptyScore: "y9vamInQ4LrXndusvhkBl",
				topLine: "_3QuUl4wSXyqVEAkIgGaLXl",
				topMetaOne: "_3vDeGQp8VifbnDC95HagCL",
				topMetaTwo: "Nci_4K-inwrSvpM-HSgWy",
				title: "_1QxTngAAL4xURgv5RVNOq1",
				media: "_2cFr_UVzM0pQGvZVL2Pmx5",
				flatlist: "_33_7mRxP4egdr8CL9OMSdb",
				flatlistItemOne: "_EVV9UvUf3cYf-HtTUL33",
				flatListItemTwo: "_2Ovk4TwuzZDamFhAj_X5Nl",
				bottomMeta: "_3Yno3UEEUpbfXOklgaEf27",
				postActionBar: "_3-iHWkhaRqC0JmCwckFVg1",
				postActionButton: "_314KvlynGyTcpUjSXckrbY",
				long: "_3EpUFkJ6GGzK-aVzndYmTT"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_12gWQ2C_gotA8s5-CJIlq9",
				icon: "_3-Fcrds7R5ihAWPAttv3AL",
				title: "_1vL1j4mpTYI5NOR335bInG",
				subtitle: "_3FOOtAw2Q-T7szrSBAbo9i"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less": function(e, t, s) {
			e.exports = {
				tabBar: "_1ItRVjBpP4aLG0vg-nXbwO",
				tab: "_3A18ggmDWAI5_Fz0nDOs-z",
				selected: "_3U85C8qDDoOUoOINg-E_3S"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less": function(e, t, s) {
			e.exports = {
				contentContainer: "_2O3bUryrh35-WVnz9Zoet5",
				content: "_1FTRfhuddBV5YzYiIzObiO",
				grid: "_3i8uEN2ZVREoZOqW0PBJKD",
				header: "_3TFv4L83k0sAQxxxDJCzh9",
				actionHeader: "_3XGx1tfvY30VXMwrnAYMfZ",
				cell: "_30GfT3S_RWhS9B1JiSCaIJ",
				imageCell: "_1mzA539xYQn08RGzbn-Rgl",
				image: "_2UKv8w6-nnOZn6-lOqv57x",
				imagePlaceholder: "_2-8LfoYIQ37smNisBTPrPA",
				title: "_2cEKePFj4PUyuqlM_8uInw",
				caption: "_33iTirQvYAUBeq5vAp6Nr6",
				timeCell: "_1EzbYLhrmLPhhpk2FFAmcj",
				actionCell: "_1JvlfJR1EFT7pnSONpgiXk",
				dropdownSelector: "_2K7txHCmQX-J_7K7zNiCM1",
				byModerator: "_3czV_FVsdvYbnimTT57vCK",
				line: "_22JqeR_rL-tI8mxRb7N8Mq",
				loadingTextLong: "_2AZFpVa_LwltM1gTwCGIDe",
				loadingTextShort: "_1LWRk2sNojXWsOI1Y85nf7"
			}
		},
		"./src/reddit/components/ModHub/Content/NoPermissions.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./src/app/strings/index.ts"),
				i = s("./src/reddit/components/ModHub/Content/index.m.less"),
				c = s.n(i);
			t.a = e => o.a.createElement("div", {
				className: c.a.noPermissions
			}, o.a.createElement("img", {
				className: c.a.rememberTheHuman,
				src: "".concat(n.a.assetPath, "/img/content-gate-icons/remember-the-human.png")
			}), e.isModerator ? Object(r.a)(e.language, "subredditModeration.modHub.incorrectPermissions") : Object(r.a)(e.language, "subredditModeration.modHub.modOnlyPage"), o.a.createElement("div", {
				className: c.a.noPermissionsSmallText
			}, e.isModerator ? Object(r.a)(e.language, "subredditModeration.modHub.incorrectPermissionsSubtext") : e.subredditDisplayText ? Object(r.a)(e.language, "subredditModeration.modHub.mustBeAModOfSubreddit", {
				subredditName: e.subredditDisplayText
			}) : Object(r.a)(e.language, "subredditModeration.modHub.mustBeAMod")))
		},
		"./src/reddit/components/ModHub/Content/WelcomeMessage.m.less": function(e, t, s) {
			e.exports = {
				ModerateIcon: "khXWcHNm7cUFKCGgNfNPy",
				moderateIcon: "khXWcHNm7cUFKCGgNfNPy",
				ModHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ",
				modHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ"
			}
		},
		"./src/reddit/components/ModHub/Content/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "CgYEK3BSwEitV3N5dS53Y",
				titleFontH2: "WtxSi4x3A6EHSYOlNO6dC",
				titleFontH3: "_1s8gRCw9ZEGeZdDLi4SjEs",
				titleFontH4: "iJgEN-DVO9xH1ING9PGia",
				titleFontH5: "_1Pk2HmstIcHsVCyXL0s7WR",
				titleFontH6: "_27G51xRMOXRk6p8hF2iFF4",
				metadataFont: "_3qFnOmsyfNVU4dOg-nT7AH",
				flairFont: "IHVtmv3d9vjFTy7sOv4nb",
				labelsFont: "_3veeqeCCuB-y_5Uz7aZwNo",
				actionFont: "_2GGs_1qJNsgRTBkJjB3JyV",
				smallButtonFont: "_1wMkSw4TKFwpURuJjoijc8",
				largeButtonFont: "_37n4mei_IKI2b0S9cUN6kj",
				tabFont: "_2uzD_ZiaRuda1gPntdeFV-",
				strongTextFont: "_3iiIycx9Jvd-wtbZRRlyrS",
				extraSmallFont: "ZVMudqNfA5HZ3QWDGW-rq",
				bodyFontH1: "_18F7ywSczMXfDxvUzIkKou",
				bodyFontH2: "_2gpSS7qXgM9-crN9KgQr_O",
				bodyFontH3: "-JM-6-h-SOMTCi9a5ZG0g",
				bodyFontH4: "_3ZVYgWzZxJjL_cahDG32l",
				bodyFontH5: "_15iJEJUM-il2Ud09a9yqhY",
				bodyFontH6: "_2kFIrTxjdWaprwQ9leev5x",
				bodyFont: "_38q9ZzND20FKMoX8BeB0u8",
				bodyFontSmall: "_1tFfFAHeLftmld2a2M4yIs",
				bodyFontMono: "_1N1SJCd40K_9LeW3MSWULf",
				rememberTheHuman: "_2S6IM2TPtTriI4r_2Op1Od",
				noPermissions: "_3jaCG74Q3u55JqGJy3u664",
				noPermissionsSmallText: "_1Kxv5kLQoEOhRatEhltXrQ",
				container: "_3gsyCuYXsGWEEgPSTuX9aw",
				isLargePostLayout: "_1WGjuBpIEjcQC-x3_lE_Nu"
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less": function(e, t, s) {
			e.exports = {
				checkbox: "_20ADRJAodM5zU1OpvNEeRz",
				checkboxText: "_21Bw38NODPHxkJ8zAXjoUZ",
				closeButton: "_3m2cog1fzR2zNYfyXI2GUB",
				emojiDisplay: "_1mMSj2QBZEQ97i-4y3-WOp",
				emojiNameDisplay: "_2lbIQVKPZ4LHDNpBLwSOps",
				imageDisplay: "_3BXziWyChS-zhQ5XC9lt4k",
				appearsIn: "_1DhToTbLLM2OC-Ze5nDwCq",
				imageTitle: "_2KrLezTGMfd18btz-KkYMi",
				modalBody: "_1PLlW-_ZV0vWQQ6LS1Z2lH",
				modalAddButton: "_1vUjBClk27uHOAYH__0rj9",
				modalCancelButton: "_23RRFTkR9NKrC22rmMDNfI",
				modFlairOnlyToggle: "_19ExxuLL5lOZW35TZFXIHf",
				modIcon: "_3ta-U9hY9R1H_BRwYv1zhl",
				modProTip: "_2yN7aUrL8peCADm-u303LV",
				modProTips: "_3WtRXJc1jCLpCEw7-mlEBU",
				proTip: "_8wjmRK1w6qEGzue3BNNOA",
				modProTipTitle: "_392GI--ZxhpUHn1eRTKzqA",
				tipList: "_3PPlagKiQrtoOsW4pcf3vc"
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less": function(e, t, s) {
			e.exports = {
				alertIcon: "_34rhMfrLYNSjUkhTK958Um",
				characterCountdown: "_15Hq3tMBKH4TWo9OJs8gny",
				clearIcon: "aCmT6tHKACP3PLk6IU6XT",
				duplicatesIcon: "Eq88P0Zb-rOoo4N5OL5uk",
				duplicateWarning: "DRp2YTik6Ln3yUKp7LBUv",
				editEmojiFooter: "_2ZoRiRDs45wlLK-ZnHzUh",
				editEmojiDisplay: "_2rDJJ0Uk_ySvUA9QNoKoKU",
				emojiDisplays: "_2FsakuX5ZR_IIPcwXQu0eD",
				errorText: "_3bRRwpzb2xfP5erPt9R6Cg",
				expandLeft: "_2byjR1IbLclRfoyvyjMDUz",
				iconSpacer: "_3tWeESqi0MQaqN5wKqkv68",
				imageDisplay: "_1MHWj3sdAGALX7r7UzFF0J",
				duplicateInput: "_280zGglckljUYhFjwaBt14",
				input: "_3xzW-TBy6RXHXBjCE9Yz7s",
				inputPlaceholder: "_1964bAdk8xBAb8-d_Mthtt",
				modalAddButton: "_2yQ10LXNPJ6antT2NgaTmI",
				modalCancelButton: "_31Qk2tb7PaP2XWWL2o4HM1",
				modProTip: "NSSpRN8n70A1TesDNcvxE",
				progressBar: "_3EbPa1JwqT9b_QgXnHzJsx",
				innerBarClassName: "_3CJpdsYAp2vfEOO_U7AaO8",
				progressText: "Wz5fdVLDZuS4d-ix-j4s9",
				replacingDescription: "_1oXr6AKswirSKypchDoX1n",
				replacingTitle: "oNyr5QxUcemiI3SFwjhvc",
				uploadingTitle: "_3ZEFRZKrLVT92hTIG7sRa9",
				textButton: "_3ZzQTZKV1t84-ND6HHwnsx",
				uploaderContainer: "OCFZ6HIQUbokDXiubxQEZ"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.m.less": function(e, t, s) {
			e.exports = {
				alertIcon: "_3x5p0Ujs6EWdeLO8-fVE7v",
				emojisDisabled: "_2H7y73ZptDGSake8tFEj0n",
				labelTitle: "_2R2K1Sz81kscliWYqOq1xU",
				labelDescription: "_1TqFvv__UfmckLHp5llo7q",
				leftForm: "_22aW9zYAhDGH2HdlJ-WWIM",
				modalBody: "_1_UK8ZmVC7e_nkeSs5CGnA",
				modalCloseButton: "_2-arZqA5i-aG-76OM9aj7k",
				modalEnableSection: "_2Wd3qBH4SU1NauwzVOQbVT",
				modalEmojiSizeSection: "_3PsrWxvZyoYyzlCO8-teTE",
				disabledSection: "nviCef6_SvGHUNBJ0PXCH",
				customSizesForm: "YV6F0NfRo0VVVRzgk8aWf",
				emojiSizeBlock: "_1W4FjSOnfJWdtKYBcNtUYO",
				emojiDimensions: "_1_bSuIYPhn5kOylTKydVsO",
				emojiDimensionInput: "e4AoJYmrnNFhWAXR_KBWX",
				sizeLimitText: "_3bUpAXL4dOTbZTUE9bJ_5s",
				sizeLimitTextWarning: "_2JlgfupPT3v8ScLuT7NYXC",
				modalFooter: "_2R2UP3vtcyZqyNdUy9Y0nX",
				modalSubmitButton: "w7T2GA8_RqtkSpD4h6YKH",
				modalCancelButton: "_2wvHObzKgyjObCvFZ0QOp0",
				rightForm: "_1eE1s4H4f1_A3ck0iF679O",
				row: "_2NQoOHp9q7uhb8h4XdVWK",
				displayWrapper: "jiCIuKa0E1BjfGfUV407r",
				emojiDisplay: "_32BxZer8uLzSVJMZqqo95_",
				emojiName: "_2hJHG1X01WKzuznOL4l6ge",
				appears: "ZVOiCMvsomJLwhS8k4VPP",
				permissions: "UxdnKubszq3iR9sJGFwiY",
				buttonWrapper: "PflXNgwgKckPGaFe9wW8V",
				editEmoji: "_3RR0-7gyjso1AHuVhVbb6u",
				editSnoomoji: "FCFv4UPC_NQjiTCEBoOCD",
				trashIcon: "_2l2KeCLkXUEz_czKdpFqSw",
				settingsButton: "_2dh14d_OrE4Etrg44_cb4t",
				toggleSwitch: "_17kocpcRdOCXJwPiOk68B-",
				topRow: "_2oevuimQpT3hztJ5Rpf_hy",
				appearsTitle: "_1Qzxm6lOFpTR3O3hzKloA9",
				imageTitle: "_1NOoO9mz09cpZjIRT9nHTh",
				nameTitle: "_1Ra9yqtrrSj9q0akrKs83v",
				permissionsTitle: "_1gNO8_Ywz6va1MbMV7-jDG",
				titleTooltip: "_279Uba_Gpg0WVLV8efIdK_"
			}
		},
		"./src/reddit/components/ModHub/InfoLink/index.m.less": function(e, t, s) {
			e.exports = {
				linkContainer: "_3-yXs2bljbMxTPT6hDZU1I",
				infoIcon: "_2Eloqzd6Vfz9eGsjyzVfsf"
			}
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.m.less": function(e, t, s) {
			e.exports = {
				iconContainer: "_39qwCVfS_zadCI7gaPX3MI",
				textTooltip: "_1yEjLpHWBPakuE9kTnIp_w"
			}
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/higherOrderComponents/asTooltip.tsx"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				c = s("./src/reddit/icons/fonts/Info/index.tsx"),
				d = s("./src/reddit/components/ModHub/InfoTooltip/index.m.less"),
				l = s.n(d);
			const m = Object(o.a)(i.a),
				u = ["center", "bottom"],
				p = ["center", "top"];
			class b extends a.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						props: e
					} = this;
					return a.a.createElement("span", {
						className: l.a.iconContainer,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef
					}, a.a.createElement(c.a, null), a.a.createElement(m, {
						className: Object(r.a)(e.className, l.a.textTooltip),
						children: e.children,
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: u,
						text: e.text,
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less": function(e, t, s) {
			e.exports = {
				wikiNavPanel: "KAUs91LhLIPR2bTL1aZRJ",
				contentTree: "_3_qIKXEwRmWcog7k9kGSno",
				footer: "_3FqEpSEBROhNwQ6pW6xmwJ",
				primaryButton: "_3fO0HSLh0kUxdhfv06hiTX",
				pageNavItem: "gCZ0Yr9nZYa9NaCdn8-eS",
				indentLine: "_2qFuXxmElNrzv3E9Qyb5xi",
				itemText: "_8bMrzJrL3U19A5yc6HTgj",
				mExists: "_3E5JJL5f6BXoTxqDq40IbB",
				mActive: "_1gyKwA8_GLuoQ1hu3Apd-w"
			}
		},
		"./src/reddit/components/ModHub/ModHubNav/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1rWejsW3eX4yw72E6Wfmyh",
				titleFontH2: "_10H_HMu7R7ett8pmawqwCS",
				titleFontH3: "_22nuZii7bWeL3c1xoXOl9",
				titleFontH4: "_2UjVJakiyf4d3yQ1sBrOzz",
				titleFontH5: "_22v1odcGzDJaLHik5W5qCz",
				titleFontH6: "_3BdZeq3g8CWhfeqBhIiW7f",
				metadataFont: "BQ88O08B4nIUNd4oLud39",
				flairFont: "_24GksXJ4va-4ZEamEGSlFB",
				labelsFont: "bd2r035T3aLLBkiMZaODQ",
				actionFont: "v0ITosHo9F3Rl2_llDtrc",
				smallButtonFont: "_3Sxxei5IvhyFBFPSQeJemM",
				largeButtonFont: "_-8HW12kqXpCzSoPxOQgrN",
				tabFont: "_2TpZx4pScQqA92z2QTYbIk",
				strongTextFont: "jPwoQR2t4sGD2BGLwCS0o",
				extraSmallFont: "_1slNDutLp6KeS9GESLSnFr",
				bodyFontH1: "_3hxV-zVTwf7J5X6U1gL2PA",
				bodyFontH2: "_1lSzh7ct7vogYQk35ULeJl",
				bodyFontH3: "_2C3DyZAU4ai6HhZtVTe-Bu",
				bodyFontH4: "_2tzV3r0Sow-B7LA2KMLD45",
				bodyFontH5: "_1-ivrwr3LQQJ2_7q7woFBf",
				bodyFontH6: "pJbG4WvyXqhjYGMHv_062",
				bodyFont: "gPA4LKC5gx8g56loAEuW2",
				bodyFontSmall: "_2U2PATpiHbmfDjkovIbtF9",
				bodyFontMono: "_1tyVWTRiPy8hBs1o6HBJ_a",
				navContainer: "_2xA0SygQ9V-9Vkdad_4tnh",
				wikiNavContainer: "_3wKmughJWQCbpbTpgwf2R_",
				navSection: "_1hDKgrVgEqwg3ogyzK0xTx",
				sectionHeader: "_1C6NYhYvuXKUDoONxrMR0d",
				iconStyles: "_1lHK5OQSXGaQzgW07E3Fh4",
				inboundLinkIcon: "_1cE0_wpoZtV5YKzwxXgxQ6",
				outboundLinkIcon: "_2Fb1fof3pZ4qO7_ZowwnXG",
				navLinkStyles: "jFCRipwFbBNJ4rl18HMK5",
				activeLink: "_4Gq-jEYAhrOCtha4RZ1JZ",
				breadcrumb: "_2Pw-8XrjTaQdxaxIicJXly",
				breadcrumbButton: "_1ofO-HYNTNyx_FUAEbIMME",
				newLinkIndicator: "_26hxZhi3N_WA1WUC6pQRpa",
				updatedLinkIndicator: "_1oCiY0B1NLkEfFfIfSJIF_"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2QinjfjfDTG6Df4_Tb_eRN",
				iconStyles: "_1MvzgnzkNefTZKkd4A5o1Y",
				arrowLeft: "_1Hul4w6ANujC9NsFF6_j4f"
			}
		},
		"./src/reddit/components/ModHub/PostRequirements/ExperimentalWarning/index.m.less": function(e, t, s) {
			e.exports = {
				container: "tOgWYyLMKsdhQTgibBFPq",
				icon: "_2WZP5eFqFOt5lKBiryg7bf"
			}
		},
		"./src/reddit/components/ModHub/PostRequirements/FormPlaceholder/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_26QbsLXJCM9nhMCYYHK1hm",
				section: "_wNy7GtSLN6952OcTgdtu",
				sectionTitle: "_3rQtfyw1iarE1M82sgJtmr",
				line: "_1gQORQjYCODB7ALLENCatm",
				sectionBodyRow: "_1Ddqyl5B6UwCfefEA5O_0H"
			}
		},
		"./src/reddit/components/ModHub/PostRequirements/LabeledControl/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1V9PYnJ8RmuOiSbRk3WbSs",
				labelText: "_2JfUBmgk1skgAdhCcH1_gX"
			}
		},
		"./src/reddit/components/ModHub/PostRequirements/MinMaxInput/index.m.less": function(e, t, s) {
			e.exports = {
				maxInput: "_17nKLWjcL1n_HnKVHJZXvx",
				minInput: "_1KvJAf9ahO9CayGPALiod-",
				errorMessages: "_3tjvkXhGM-bzjHkXYQh6do"
			}
		},
		"./src/reddit/components/ModHub/PostRequirements/MultiStringsInput/index.m.less": function(e, t, s) {
			e.exports = {
				control: "_3FWbf4ZX9cEB8zJ4XtobY4",
				wordsCountdown: "_3XUXdRXUNaAdfhHb5br1yI"
			}
		},
		"./src/reddit/components/ModHub/PostRequirements/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2ENgUMuUMqeQPvwRZMpU_o",
				topBar: "_2q_D2-UMtaaNzEbpWYvSiz",
				pageDetailText: "_3LkqU8WCjvjpyLQsqJMnXc",
				contentContainer: "_3jkOB3Eli5osHFVU2P-aT2",
				formBody: "_3MU3K5dkqHvuqm5XJLAPo5",
				toggleSetting: "_1eisT1cCAj1y7sgVIPgF24",
				characterCountdown: "_30XBnjFMzGZLHo9PCCWFDE",
				multipleInput: "_3ZAk7m7FqeeWYNcF6cAu7e",
				repostFrequencyInput: "_2_7epmrUbTPw9Cghrl1L3x",
				sectionLegend: "_1NZLVNQxmcOnsjYQDV-2fb",
				bodyRestrictionSetting: "_2Q_kTY-70ZB3EUSZyGm_in",
				radioOption: "_3URbiG4h80-15bxYv8WpQj",
				textarea: "Y0qpB_aFql-FqwkGtbWCI",
				domainsTextarea: "APYMQGCMUIdUO--TK4FkT",
				externalLink: "_1jVWLYoDggtpbqPGQbchAY",
				loadingIcon: "_1CThyJZyqIA7SUmDqkr-s8"
			}
		},
		"./src/reddit/components/ModHub/StyledComponents/index.m.less": function(e, t, s) {
			e.exports = {
				ContentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				contentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				PageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				pageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				TopBar: "_2YY5qLRbI5q6_0JQVKiGt_",
				topBar: "_2YY5qLRbI5q6_0JQVKiGt_"
			}
		},
		"./src/reddit/components/ModHub/TrafficStats/ChartStats/StatBlock/index.m.less": function(e, t, s) {
			e.exports = {
				StatBlock: "_15yDFywuWpwMfKQl2EX5QL",
				statBlock: "_15yDFywuWpwMfKQl2EX5QL",
				contentContainer: "Z5iuUgIrKzcPbug956rzs",
				value: "_3nB9M6tty7F-_-jxg4SlDR",
				timeFrame: "My7ZRJ2oCTkOWGK-VO3-T"
			}
		},
		"./src/reddit/components/ModHub/TrafficStats/ChartStats/index.m.less": function(e, t, s) {
			e.exports = {
				contentContainer: "_3fTZTX-AXrihLC0t-DQwIi",
				viewNav: "_1KUVJ64hhjMPIEeine0cpe",
				NavItem: "_2hMH8rygvSO4vIcLaFPwev",
				navItem: "_2hMH8rygvSO4vIcLaFPwev",
				NavItemSelected: "_3Hm3WQPMg73Jn5A51WVJdx",
				navItemSelected: "_3Hm3WQPMg73Jn5A51WVJdx",
				statContainer: "_2CFSpDjzO7AYBVPBZwkwcE",
				chartContainer: "_24gv__gflVe-1EEEvtLXTn",
				chartPlaceholder: "_2yL5PVICoAVOqVrTI0atoo",
				yAxis: "_2LKGM1hSwZTFMcaRHp1UDX",
				chartNav: "_2zFkOhTILSIr8_YQTKpLHd",
				buttonLeft: "bU-gLdHG7cprmpQDQSc8v",
				ArrowLeft: "_1Qk0xAYMIhSPe5ASi5nTcC",
				arrowLeft: "_1Qk0xAYMIhSPe5ASi5nTcC",
				isDisabled: "_2AMC2xlwTYJTQi-eqt-BoO",
				buttonGroup: "_2Lt9qlKkea1sYE5-zCWtLo",
				hideNavArrows: "_1AunUk0wbBsEUQUsqdQ2MV",
				navButton: "aPY9hO-MgeyV2eRHxr169",
				navButtonSelected: "_1LnuqjKY2_jF5DaJ_siSrV",
				buttonRight: "C9l4ZgMi7DFJ4TCod-287",
				hideButtons: "_3ZFrLs3IL0jeev6csLQjnu",
				ArrowRight: "_1Oc_QLvwMhJnNq2Ll-ViAO",
				arrowRight: "_1Oc_QLvwMhJnNq2Ll-ViAO"
			}
		},
		"./src/reddit/components/ModHub/TrafficStats/DataTable/index.m.less": function(e, t, s) {
			e.exports = {
				contentContainer: "_1yULy9aDqyShG7EN8EMQz7",
				viewNav: "_29nBxAsanlTjLQS7kPY0Mx",
				NavItem: "nbvhagKy2pBAm4tw2LEEH",
				navItem: "nbvhagKy2pBAm4tw2LEEH",
				NavItemSelected: "_2C9eNSrWNjYRNELdD83yNQ",
				navItemSelected: "_2C9eNSrWNjYRNELdD83yNQ",
				dataBar: "Z6qNfzPBLhRm8yQh2OwfN",
				dropdownButton: "_1AD4p2NNgRW0L4i4Sy9sB-",
				timeDropdown: "_1HPGkSqiuHglKyAhmxRxcR",
				timeLabel: "_11-Q1eouDxfGUYcjSTidW5",
				dropdownIcon: "_3zVdh3jBxtCW7BmAElN38t",
				iconUp: "_1k6uzKsQNWH4Mlv6NlQoiA",
				pageviewsCol: "lLqYVOonnKKpGz0hmSKmF",
				uniquesCol: "FWlqJiTte_o972wQjwBnZ",
				membersCol: "_203qQ7TLOHFe9EKmhxOiyB",
				dataRow: "_23vJv7PbwZphG7Y4LE5wFA",
				date: "_20yg7LJ0AnZ9VbToLrodJf",
				pageviews: "_1ayTZ5UF8G1ofHayw3X6I-",
				uniques: "qd1wOHnWPjWqI4sGO5fNe",
				members: "_1bOFcKMTQ0EWkUDaLpPfaX"
			}
		},
		"./src/reddit/components/ModHub/TrafficStats/helpers.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "e", (function() {
				return r
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "n", (function() {
				return m
			})), s.d(t, "o", (function() {
				return u
			})), s.d(t, "p", (function() {
				return p
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "k", (function() {
				return h
			})), s.d(t, "j", (function() {
				return g
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "f", (function() {
				return x
			})), s.d(t, "h", (function() {
				return f
			})), s.d(t, "m", (function() {
				return v
			})), s.d(t, "l", (function() {
				return C
			}));
			s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n, a, o, r, i = s("./node_modules/lodash/times.js"),
				c = s.n(i),
				d = s("./src/reddit/models/TrafficStats/index.ts");
			! function(e) {
				e.Hour = "Hour", e.Day = "Day", e.Month = "Month"
			}(n || (n = {})),
			function(e) {
				e.Hour = "byHour", e.Day = "byDay", e.Month = "byMonth"
			}(a || (a = {})),
			function(e) {
				e.Members = "Members", e.Uniques = "Uniques", e.Pageviews = "Pageviews"
			}(o || (o = {})),
			function(e) {
				e.Members = "subscribers", e.Uniques = "uniqueUsers", e.Pageviews = "pageViews"
			}(r || (r = {}));
			const l = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
				m = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
				u = e => [...e].reverse(),
				p = (e, t) => e.slice(t, e.length).concat(e.slice(0, t)),
				b = {
					[n.Hour]: d.b,
					[n.Day]: d.a,
					[n.Month]: d.c
				},
				h = (e, t, s) => {
					const a = new Date(e),
						o = m[a.getMonth()];
					return t === n.Month ? "".concat(o.slice(0, 3), " '").concat(a.getFullYear().toString().slice(2, 4)) : a.toLocaleDateString("en", {
						month: s ? "long" : "short",
						day: "numeric"
					})
				},
				g = e => {
					return new Date(e).toLocaleTimeString("en", {
						hour: "numeric"
					}).replace(" ", "")
				},
				E = (e, t, s) => {
					return new Date(e).toLocaleDateString("en", {
						weekday: t === n.Hour || s ? void 0 : "short",
						month: "numeric",
						day: "numeric",
						year: s ? "2-digit" : void 0
					})
				},
				x = e => Array.isArray(e) ? e.reduce((e, t) => e + parseInt(t), 0) : parseInt(e),
				f = e => {
					const t = v(n.Day, !0),
						s = new Array(l.length).fill(0);
					return e.forEach((e, n) => {
						const a = new Date(t[n]).getDay();
						s[a] = s[a] + e
					}), s
				},
				v = (e, t) => {
					const s = b[e],
						a = c()(s, t => {
							const s = new Date;
							return e === n.Hour ? s.setHours(s.getHours() - t) : e === n.Day ? s.setDate(s.getDate() - t) : (s.setDate(1), s.setMonth(s.getMonth() - t)), s.getTime()
						});
					return t ? u(a) : a
				},
				C = (e, t, s) => {
					if (t === o.Members) return [e.subscribers, e.unsubscribers];
					const n = r[t],
						i = a[s],
						c = e[n][i];
					return [c.desktop, c.oldReddit, c.mWeb, c.apps]
				}
		},
		"./src/reddit/components/ModHub/TrafficStats/index.m.less": function(e, t, s) {
			e.exports = {
				trafficStats: "_2ukk3tTNze71whUirp41zy",
				titleText: "GRV6dNoWlN_pWb67IX82x",
				updateText: "_3UAMTLjanr69s4h5Swl1ny"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairSettingsModal/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1J76qb5HBy2bYaTNJsgjRQ",
				modalHeader: "_34gci9egz3Lvx3-STpfNID",
				contentBlock: "Bv6ZRypNeiF988NrqtV_-",
				assignOwnControl: "yDJKjvn3AuAahOSYVsmN2",
				details: "Pk8ny_YG59Ztx9VspQ3qF",
				modalFooter: "_2ifl0uRUahQVqB35XKqJMH",
				loadingIcon: "_1vCqQS850C3SRB28BQKa9c",
				disabled: "_2mowWGWRE_iy-2cDlstT_N"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/ColorSwitch/index.m.less": function(e, t, s) {
			e.exports = {
				switch: "_3w3fE7K9kEYfKQNJfS7h1V",
				dark: "_1xkEHX0d9o3Leyz85QBWyK",
				light: "_2OSFC0fFqJUB10_LJPZyUh"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/PostAppearanceEditor/PostFlairStyleTemplateEditor/index.m.less": function(e, t, s) {
			e.exports = {
				container: "E8V2n_zGKhMURqvEjj_MQ",
				leftFieldset: "_2B9dHYxe8C55ooQKc4HVbG",
				rightFieldset: "nhsR7f8a-odEVtQkD2ib3",
				imageUploadHelpText: "_3AWYW8095eSH07dsirGiy2"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/PostAppearanceEditor/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2bUb177wy8SfzvupJhnGQm",
				layoutSwitch: "_2AgVMPLD10-uvYb_f_6J_j",
				postPreview: "_2QGQ9RGZIrujMmofDGKNIb",
				postWrapper: "U-g4XNsEdnQPA16-R9-MF",
				card: "_3YkT6O_PLA-Tgn8B_MdVZb",
				postComponent: "_1FpOHu-2X05dj66wRTFLQD",
				classic: "_3fPXWT4i8aZtN3wnvz7fnb",
				postFlairStyleTemplateEditor: "_3F9nD6NLUOAjVddW0LwPpq"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1RWRNUFARQ67YPY0T-C1jF",
				mainContent: "_2DEL2D_A1ZIK29CtYqdFzR",
				leftFieldset: "_3z7u3YO0GUisGjIfFcnHMg",
				rightFieldset: "_2vfzPMlNuCIhrMc0lQyYdT",
				labelWithTooltip: "_4Uaw8lVxHo2lY4j4t_XzL",
				disabledControl: "_392ahLMjIjFG3-AGPQwLWl",
				cssClassErrorText: "ku1Pmz9v_zKW5vb2FAMtC",
				cssClassInfoText: "zTzmzC7HblUsSCKUqsj7u",
				radioOption: "_2Xwmo3U9NfvRjFZjumh1mH",
				postAppearanceEditor: "_2Z7Qv3fH_yOsjWSQXQVYuR",
				buttonsRow: "_1yYtAhZ28OzxktteQTDUu-",
				loadingIcon: "_1XjCjvbFr0Mtgdl8kzgfhG",
				cssClassInput: "SA-3EuoQcj0-WJ7WmMcX9",
				dropdownSelector: "_2mfUKkihI-iTELKYoDENik",
				dropdownSelectorButton: "gQ7NneYZ6tweP5jrEvMfc"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateRow/index.m.less": function(e, t, s) {
			e.exports = {
				row: "_2Ge0QyGqQ2ohMh3nujj9kI",
				flairPreviewCell: "_3SFR7AjB3wiRzkfpGm8pc3",
				cssClassCell: "_1tSivioO33rCxJr8NbnGCB",
				settingsCell: "_2JkfNJ7R1JE4IjqcpoT9Kc",
				flairIdCell: "_2_R05GOuWSUDX3PyASVGmm",
				flairComponent: "_36dQHXyJCojtRpWCQSngY9",
				removeButton: "_36ymF43Lc8scdO9e4wilot",
				reordering: "_1BI3W_3n3-wJyOB0q5bD5r"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/FlairsDisabledBanner/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_2PM4mIanlspkCfVf5Sj0QB"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/LabeledControl/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_8NYQ3gScy-Wk0h4-kYr5",
				topLabel: "_1VadQpxPDRwv7NdnGts8pb",
				labelText: "_32kO6m8pH6JDfvC5n-8Gz-",
				leftLabel: "_3BQnoB5bKs-pvvm4jXSqb4"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/Placeholder/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2V6ckA-uEsF-HfsqbS3PCM",
				icon: "_54dKejbOLtpr14TV40ksT",
				header: "ebXTqyXoNZinSoqY2ZdQN",
				details: "_3QhMX3iKRWXx2prOvqUrwn"
			}
		},
		"./src/reddit/components/ModHub/flairs/FlairManagement/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_37KbqgukAyMf3s-j7AnBWR",
				topBar: "aF7EPRLqx7OlHhB0WLt-D",
				contentContainer: "_2HFh2ax8D_Jy7s1JHIHvUf",
				dragItem: "_3Yi1TDHslArM_O4ZmGiRCs",
				dragIcon: "slRmsO8r_7d7nV3JEKKi1",
				disabledBanner: "_2zhcnoXRRItZEJVXtE1Dez",
				table: "_32J_8vxjcfCvTyyaKNxzMV",
				tableHead: "_3X_p9WCvR91mqMt0eaAzjT",
				flairPreviewColHeader: "_2so4kKMPMvORvnsfCZIrI6",
				cssClassColHeader: "_3VPBNym2HhcfxWqX_XAtad",
				settingsColHeader: "_13gi3MUppeK5PJ1_waWROR",
				flairIdColHeader: "_2iWLnXdkCIwJvCNl66f_JX",
				tableBody: "_6ltpvqnPD-3oGbRWx8i3b"
			}
		},
		"./src/reddit/components/ModModeReports/index.m.less": function(e, t, s) {
			e.exports = {
				Text: "_1gNngyeM0l7oKkuGjoSTm",
				text: "_1gNngyeM0l7oKkuGjoSTm",
				Placeholder: "_1oYW-msczpGlYVcXmyEu9j",
				placeholder: "_1oYW-msczpGlYVcXmyEu9j"
			}
		},
		"./src/reddit/components/ModModeReports/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/higherOrderComponents/makeAsync.tsx"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/lib/loadWithRetries/index.ts"),
				c = s("./src/reddit/i18n/components.tsx"),
				d = s("./src/reddit/components/ModModeReports/index.m.less"),
				l = s.n(d);
			const m = r.a.div("Text", l.a),
				u = r.a.div("Placeholder", l.a),
				p = Object(o.a)({
					ErrorComponent: e => {
						let {
							className: t
						} = e;
						return a.a.createElement(u, {
							className: t
						})
					},
					getComponent: () => Object(i.a)(() => s.e("ModerationDropdowns").then(s.bind(null, "./src/reddit/components/ModModeReports/_ModModeReports.tsx")).then(e => e.default)),
					LoadingComponent: e => {
						let {
							className: t
						} = e;
						return a.a.createElement(u, {
							className: t
						}, a.a.createElement(m, null, a.a.createElement(c.c, null, "Loading reports…")))
					}
				});
			t.a = e => a.a.createElement(p, e)
		},
		"./src/reddit/components/ModQueueList/EmptyQueueBanner.m.less": function(e, t, s) {
			e.exports = {
				Container: "_3gono-WZrSL-d6xVXvjtMy",
				container: "_3gono-WZrSL-d6xVXvjtMy",
				Image: "cSzjL6IStvPqHPZ7Y7ly8",
				image: "cSzjL6IStvPqHPZ7Y7ly8",
				Title: "_15y0pZYrlSHF1PcfsddZ-q",
				title: "_15y0pZYrlSHF1PcfsddZ-q",
				Text: "_2jaFduo9u1gW746Eq2bUKo",
				text: "_2jaFduo9u1gW746Eq2bUKo"
			}
		},
		"./src/reddit/components/ModQueueList/LayoutNavigation.m.less": function(e, t, s) {
			e.exports = {
				Inline: "_3JHX3et1k6IdasjG0oW12P",
				inline: "_3JHX3et1k6IdasjG0oW12P",
				Filter: "_1OcIyF84egvn4Y6482t8jQ",
				filter: "_1OcIyF84egvn4Y6482t8jQ",
				filterMargin: "_2bX-c80byEShP8Q3c-pyFF",
				LayoutSwitch: "_31lr1WpF-1P7ga7WE4KVS7",
				layoutSwitch: "_31lr1WpF-1P7ga7WE4KVS7"
			}
		},
		"./src/reddit/components/ModQueueList/LayoutNavigation.tsx": function(e, t, s) {
			"use strict";
			var n, a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				c = s("./src/app/strings/index.ts"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/reddit/actions/tooltip.ts"),
				m = s("./src/higherOrderComponents/asTooltip.tsx"),
				u = s("./src/lib/lessComponent.tsx"),
				p = s("./src/reddit/actions/modQueue/index.ts"),
				b = s("./src/reddit/controls/Dropdown/index.tsx"),
				h = s("./src/reddit/controls/LayoutSwitch/index.tsx"),
				g = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				E = s("./src/reddit/layout/row/Inline/index.tsx"),
				x = s("./src/reddit/selectors/profile.ts"),
				f = s("./src/reddit/selectors/subreddit.ts"),
				v = s("./src/reddit/selectors/tooltip.ts"),
				C = s("./src/lib/addQueryParams/index.ts"),
				O = s("./src/lib/filterQueryParams/index.ts"),
				j = s("./src/reddit/i18n/utils.ts"),
				y = s("./src/reddit/controls/Dropdown/Row.tsx"),
				k = s("./src/reddit/controls/InternalLink/index.tsx"),
				w = s("./src/reddit/selectors/meta.ts"),
				S = s("./src/reddit/components/ModQueueList/PostTypeFilterDropdown.m.less"),
				N = s.n(S);
			! function(e) {
				e.Comments = "comments", e.Posts = "links"
			}(n || (n = {}));
			const T = u.a.wrapped(y.b, "Row", N.a),
				_ = Object(i.c)({
					currentPage: e => e.platform.currentPage,
					origin: w.g
				});
			var I = Object(r.b)(_)(e => o.a.createElement("div", null, o.a.createElement(k.a, {
					onClick: e.sendEventWithName("content_type_both"),
					to: Object(O.a)("".concat(e.origin).concat(e.currentPage.url), ["after", "before", "only", "page"])
				}, o.a.createElement(T, {
					displayText: Object(j.c)("Posts and Comments"),
					isSelected: !e.postTypeFilter
				})), o.a.createElement(k.a, {
					onClick: e.sendEventWithName("content_type_post"),
					to: Object(C.a)(Object(O.a)("".concat(e.origin).concat(e.currentPage.url), ["after", "before", "page"]), {
						only: n.Posts
					})
				}, o.a.createElement(T, {
					displayText: Object(j.c)("Posts"),
					isSelected: e.postTypeFilter === n.Posts
				})), o.a.createElement(k.a, {
					onClick: e.sendEventWithName("content_type_comment"),
					to: Object(C.a)(Object(O.a)("".concat(e.origin).concat(e.currentPage.url), ["after", "before", "page"]), {
						only: n.Comments
					})
				}, o.a.createElement(T, {
					displayText: Object(j.c)("Comments"),
					isSelected: e.postTypeFilter === n.Comments
				})))),
				P = (s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.regexp.search.js"), s("./src/reddit/contexts/PageLayer/index.tsx")),
				M = s("./src/reddit/controls/SearchBar/index.tsx"),
				R = s("./src/reddit/selectors/moderatorPermissions.ts"),
				L = s("./src/reddit/components/ModQueueList/SubredditSelectorDropdown.m.less"),
				D = s.n(L);
			const A = Object(P.t)({
					currentPageUrl: P.e
				}),
				F = Object(i.c)({
					moderatingSubreddits: R.k,
					origin: w.g
				}),
				B = Object(r.b)(F),
				U = u.a.div("DropdownContainer", D.a),
				H = u.a.div("SearchBarContainer", D.a),
				W = u.a.wrapped(y.b, "Row", D.a),
				q = e => "user" === e.type ? {
					profile: e.name
				} : {
					subreddit: e.name
				};
			class V extends o.a.Component {
				constructor(e) {
					super(e), this.state = {
						search: ""
					}, this.updateSortedSubreddits(e), this.updateFilteredSubreddits(e, this.state)
				}
				componentWillUpdate(e, t) {
					e.moderatingSubreddits !== this.props.moderatingSubreddits ? (this.updateSortedSubreddits(e), this.updateFilteredSubreddits(e, t)) : t.search !== this.state.search && this.updateFilteredSubreddits(e, t)
				}
				updateSortedSubreddits(e) {
					this.sortedSubreddits = e.moderatingSubreddits.slice().sort((e, t) => e.displayText.toLowerCase() > t.displayText.toLowerCase() ? 1 : -1)
				}
				updateFilteredSubreddits(e, t) {
					if (!t.search) return void(this.filteredSubreddits = this.sortedSubreddits);
					const s = t.search.toLowerCase();
					let n;
					n = e.moderatingSubreddits !== this.props.moderatingSubreddits || 0 !== s.indexOf(this.state.search) ? this.sortedSubreddits : this.filteredSubreddits, this.filteredSubreddits = n.filter(e => -1 !== e.displayText.toLowerCase().indexOf(s))
				}
				stopPropagation(e) {
					e.nativeEvent.stopImmediatePropagation()
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(U, {
						onClickCapture: this.stopPropagation
					}, o.a.createElement(H, null, o.a.createElement(M.a, {
						autoFocus: !0,
						onTextChange: e => this.setState({
							search: e.currentTarget.value
						}),
						placeholder: Object(j.c)("Find subreddit"),
						value: t.search
					})), o.a.createElement(k.a, {
						to: Object(O.a)("".concat(e.origin).concat(e.currentPageUrl), ["after", "before", "page", "profile", "subreddit"])
					}, o.a.createElement(W, {
						displayText: Object(j.c)("All subreddits"),
						isSelected: !e.subredditName && !e.profileName
					})), this.filteredSubreddits.map(t => {
						const s = q(t);
						return o.a.createElement(k.a, {
							key: t.id,
							to: Object(C.a)(Object(O.a)("".concat(e.origin).concat(e.currentPageUrl), ["after", "before", "page", "profile", "subreddit"]), s)
						}, o.a.createElement(W, {
							displayText: t.displayText,
							isSelected: e.subredditName ? e.subredditName === t.name : e.profileName === t.name
						}))
					}))
				}
			}
			var z = A(B(V)),
				K = s("./src/reddit/components/ModQueueList/LayoutNavigation.m.less"),
				Q = s.n(K);
			const G = Object(m.a)(b.a),
				J = "MODQ--SUBREDDIT_FILTER_DROPDOWN",
				Z = "MODQ--POST_TYPE_FILTER_DROPDOWN",
				X = u.a.wrapped(E.a, "Inline", Q.a),
				Y = u.a.div("Filter", Q.a),
				$ = u.a.wrapped(h.a, "LayoutSwitch", Q.a),
				ee = Object(i.c)({
					isPostTypeFilterDropdownOpen: Object(v.b)(Z),
					isSubredditFilterDropdownOpen: Object(v.b)(J),
					profile: (e, t) => {
						let {
							profileName: s
						} = t;
						return s ? Object(x.j)(e, {
							profileName: s
						}) : null
					},
					subreddit: (e, t) => {
						let {
							subredditName: s
						} = t;
						return s ? Object(f.B)(e, {
							subredditName: s
						}) : null
					}
				}),
				te = Object(r.b)(ee, e => ({
					loadAllSubreddits: () => e(Object(p.d)(!0)),
					onOpenDropdown: t => e(Object(l.g)({
						tooltipId: t
					}))
				}));
			class se extends o.a.Component {
				constructor() {
					super(...arguments), this.onOpenSubredditFilterDropdown = () => {
						this.props.loadAllSubreddits(), this.props.onOpenDropdown(J), this.props.sendEventWithName("subreddit")
					}, this.onOpenPostTypeFilterDropdown = () => {
						this.props.onOpenDropdown(Z), this.props.sendEventWithName("content_type")
					}
				}
				render() {
					const {
						props: e
					} = this, t = e.subreddit && e.subreddit.displayText || e.profile && e.profile.displayText || Object(c.a)(e.language, "subredditModeration.modQueue.filters.allSubreddits"), s = e.postTypeFilter && Object(c.a)(e.language, "subredditModeration.modQueue.filters.".concat(e.postTypeFilter)) || Object(c.a)(e.language, "subredditModeration.modQueue.filters.allPostTypes");
					return o.a.createElement(X, null, !e.hideSubredditFilter && o.a.createElement(o.a.Fragment, null, o.a.createElement(Y, {
						id: J,
						onClick: this.onOpenSubredditFilterDropdown
					}, t, o.a.createElement(g.b, null)), o.a.createElement(G, {
						isOpen: e.isSubredditFilterDropdownOpen,
						tooltipId: J
					}, o.a.createElement(z, {
						language: e.language,
						profileName: e.profileName,
						subredditName: e.subredditName
					}))), e.showTypeFilter && o.a.createElement("div", {
						className: Object(d.a)({
							[Q.a.filterMargin]: !e.hideSubredditFilter
						})
					}, o.a.createElement(Y, {
						id: Z,
						onClick: this.onOpenPostTypeFilterDropdown
					}, s, o.a.createElement(g.b, null)), o.a.createElement(G, {
						isOpen: e.isPostTypeFilterDropdownOpen,
						tooltipId: Z
					}, o.a.createElement(I, {
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: e.sendEventWithName
					}))), o.a.createElement($, null))
				}
			}
			t.a = te(se)
		},
		"./src/reddit/components/ModQueueList/ModToolsBulkOperations/ExtraModToolsList.m.less": function(e, t, s) {
			e.exports = {
				StatusItem: "_2K7YZXKFsZRhsQQ4AbJmxU",
				statusItem: "_2K7YZXKFsZRhsQQ4AbJmxU",
				StatusContainer: "_2iPB1Z8ZMY-jLMenh1R4K4",
				statusContainer: "_2iPB1Z8ZMY-jLMenh1R4K4",
				StatusList: "B7xBQCW-i0XkgeJ22rgLC",
				statusList: "B7xBQCW-i0XkgeJ22rgLC"
			}
		},
		"./src/reddit/components/ModQueueList/ModToolsBulkOperations/index.m.less": function(e, t, s) {
			e.exports = {
				CheckboxContainer: "DsVp-bHpfq0Oq0qA6pTak",
				checkboxContainer: "DsVp-bHpfq0Oq0qA6pTak",
				Checkbox: "_3IYLDjbdCg9uE2oDb5e7Sn",
				checkbox: "_3IYLDjbdCg9uE2oDb5e7Sn",
				DropdownTriangle: "_3ePiZ_UzH5lFQIPzp35YXS",
				dropdownTriangle: "_3ePiZ_UzH5lFQIPzp35YXS",
				DropdownRow: "_5USHbSyhRaiAEnOouxEk9",
				dropdownRow: "_5USHbSyhRaiAEnOouxEk9",
				Bullet: "K9CBgM-Xyd_FBz7TcYHah",
				bullet: "K9CBgM-Xyd_FBz7TcYHah",
				Text: "_14Wi7Tj4JyvXkmtsyZkG9e",
				text: "_14Wi7Tj4JyvXkmtsyZkG9e",
				ModToolsBulkOperations: "IncH4Lk7NsVjvrE51jpu8",
				modToolsBulkOperations: "IncH4Lk7NsVjvrE51jpu8"
			}
		},
		"./src/reddit/components/ModQueueList/PostTypeFilterDropdown.m.less": function(e, t, s) {
			e.exports = {
				Row: "_1i-lQzTwq8UQrdKuiR_jer",
				row: "_1i-lQzTwq8UQrdKuiR_jer"
			}
		},
		"./src/reddit/components/ModQueueList/SubredditSelectorDropdown.m.less": function(e, t, s) {
			e.exports = {
				DropdownContainer: "CxFih1Dllyb7Ee-gA27SM",
				dropdownContainer: "CxFih1Dllyb7Ee-gA27SM",
				SearchBarContainer: "_3TBm4aNfLDgkYxeb3BL6Qu",
				searchBarContainer: "_3TBm4aNfLDgkYxeb3BL6Qu",
				Row: "_2-Mqfq2jQLCLoIJJX5d6ER",
				row: "_2-Mqfq2jQLCLoIJJX5d6ER"
			}
		},
		"./src/reddit/components/ModQueueList/index.m.less": function(e, t, s) {
			e.exports = {
				ItemContainer: "_2QxKXxKsAXysE1p_Y7m66a",
				itemContainer: "_2QxKXxKsAXysE1p_Y7m66a",
				ButtonContainer: "_1UWG2tG2gGruVUIlnO6Qwr",
				buttonContainer: "_1UWG2tG2gGruVUIlnO6Qwr"
			}
		},
		"./src/reddit/components/ModQueueList/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/difference.js"),
				a = s.n(n),
				o = s("./node_modules/lodash/includes.js"),
				r = s.n(o),
				i = s("./node_modules/react/index.js"),
				c = s.n(i),
				d = s("./node_modules/react-redux/es/index.js"),
				l = s("./node_modules/reselect/es/index.js"),
				m = s("./src/lib/addQueryParams/index.ts"),
				u = s("./src/lib/lessComponent.tsx"),
				p = s("./src/reddit/actions/modQueue/index.ts"),
				b = s("./src/reddit/actions/post.ts"),
				h = s("./src/reddit/components/ModModeReports/helpers.ts"),
				g = s("./src/lib/classNames/index.ts"),
				E = s("./src/reddit/controls/Button/index.tsx"),
				x = s("./src/reddit/i18n/components.tsx"),
				f = s("./src/reddit/layout/row/Inline/index.tsx"),
				v = s("./src/reddit/components/PaginationButtons/index.m.less"),
				C = s.n(v),
				O = e => c.a.createElement(f.a, {
					className: C.a.buttonContainer
				}, c.a.createElement(E.o, {
					className: Object(g.a)(C.a.routerLink, {
						[C.a.mDisabled]: !e.prevButtonEnabled
					}),
					disabled: !e.prevButtonEnabled,
					to: e.prevTo,
					"data-redditstyle": !0
				}, c.a.createElement(x.c, null, "Back")), c.a.createElement(E.o, {
					className: Object(g.a)(C.a.routerLink, {
						[C.a.mDisabled]: !e.nextButtonEnabled
					}),
					disabled: !e.nextButtonEnabled,
					to: e.nextTo,
					"data-redditstyle": !0
				}, c.a.createElement(x.c, null, "Next"))),
				j = s("./src/reddit/components/PostList/index.tsx"),
				y = s("./src/reddit/contexts/PageLayer/index.tsx"),
				k = s("./src/reddit/helpers/isComment.ts"),
				w = s("./src/reddit/helpers/isPost.ts"),
				S = s("./src/reddit/helpers/postComponentForLayout/index.tsx"),
				N = s("./src/reddit/selectors/telemetry.ts");
			const T = (e, t) => s => ({
				source: "bulk_mod_action",
				action: "click",
				noun: t,
				media: N.media(s, e),
				post: N.post(s, e),
				profile: N.profile(s),
				screen: N.screen(s),
				session: N.session(s),
				subreddit: N.subreddit(s)
			});
			var _ = s("./src/lib/logs/console.ts"),
				I = s("./src/lib/objectSelector/index.ts"),
				P = s("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				M = s("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				R = s("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				L = s("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				D = s("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				A = s("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				F = s("./src/reddit/components/ModModeReports/index.tsx"),
				B = s("./src/reddit/components/RichTextJson/index.tsx"),
				U = s("./src/reddit/components/VerticalVotes/index.tsx"),
				H = s("./src/reddit/controls/Checkbox/index.tsx"),
				W = s("./src/reddit/helpers/getRichTextContent/index.ts"),
				q = s("./src/reddit/helpers/showReportIndicator/index.ts"),
				V = s("./src/reddit/components/Comments/CompactUnthreadedComment/index.m.less"),
				z = s.n(V);
			const K = u.a.div("LeftRail", z.a),
				Q = u.a.wrapped(H.a, "BulkActionCheckbox", z.a),
				G = u.a.wrapped(R.a, "UnthreadedCommentContainer", z.a),
				J = u.a.div("CommentColumn", z.a),
				Z = u.a.div("VoteColumn", z.a),
				X = u.a.wrapped(P.c, "ModToolsFlatlist", z.a),
				Y = u.a.div("CommentBody", z.a),
				$ = u.a.div("Fade", z.a),
				ee = u.a.wrapped(U.a, "Votes", z.a),
				te = u.a.div("CommentContentWrapper", z.a),
				se = u.a.div("ParentPostTitle", z.a),
				ne = u.a.div("CommentParentWrapper", z.a),
				ae = Object(I.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			var oe = Object(M.b)(u.a.wrapped(e => {
					const {
						className: t,
						comment: s,
						flair: n,
						isCheckboxSelected: a = !1,
						language: o,
						onIgnoreReports: r,
						onVoteClick: i,
						showModTools: d,
						subreddit: l,
						showBulkActionCheckbox: m,
						toggleCheckbox: u
					} = e;
					return c.a.createElement(G, {
						className: Object(g.a)(t, {
							[z.a.isBanned]: !!s.bannedBy,
							[z.a.isReported]: Object(q.a)(s)
						}),
						clickTrackingId: s.id,
						permalink: s.permalink
					}, c.a.createElement(K, {
						className: Object(g.a)({
							[z.a.hasBorder]: !!s.bannedBy || Object(q.a)(s)
						})
					}, m && c.a.createElement(Q, {
						isCheckboxSelected: a,
						toggleCheckbox: u
					})), c.a.createElement(Z, null, c.a.createElement(ee, {
						compact: !1,
						model: s,
						onVoteClick: i,
						scoreClassName: z.a.score
					})), c.a.createElement(J, null, c.a.createElement(ne, null, s.postTitle && c.a.createElement(se, null, s.postTitle), s.postAuthor && c.a.createElement(A.a, {
						comment: s
					})), c.a.createElement(te, null, c.a.createElement(L.a, {
						comment: s
					}, c.a.createElement(Y, null, c.a.createElement(B.a, {
						content: Object(W.a)(s),
						rtJsonElementProps: ae(e)
					}), c.a.createElement($, null)), c.a.createElement(D.a, {
						comment: s,
						flair: n,
						language: o,
						subredditName: l ? l.displayText : null
					}), Object(h.c)(s) && c.a.createElement(F.a, {
						language: o,
						onIgnoreReports: r,
						reportable: s
					}), d && !s.isDeleted && c.a.createElement(X, {
						comment: s,
						language: o
					})))))
				}, "Component", z.a)),
				re = s("./src/reddit/components/PostRailAndVotes/index.tsx"),
				ie = s("./src/reddit/components/Comments/LargeUnthreadedComment/index.m.less"),
				ce = s.n(ie);
			const de = u.a.div("VoteSpacer", ce.a),
				le = u.a.div("ContentWrapper", ce.a),
				me = u.a.wrapped(D.a, "Meta", ce.a),
				ue = u.a.div("CommentParentWrapper", ce.a),
				pe = u.a.div("CommentContentWrapper", ce.a),
				be = u.a.div("Fade", ce.a),
				he = Object(I.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			var ge = Object(M.b)(u.a.wrapped(e => {
					const {
						className: t,
						comment: s,
						flair: n,
						hasReports: a,
						isCheckboxSelected: o = !1,
						language: r,
						onIgnoreReports: i,
						onVoteClick: d,
						showModTools: l,
						subreddit: m,
						showBulkActionCheckbox: u,
						toggleCheckbox: p
					} = e;
					return c.a.createElement(R.a, {
						className: t,
						clickTrackingId: s.id,
						permalink: s.permalink
					}, c.a.createElement(re.a, {
						model: s,
						handleVote: d,
						showBulkActionCheckbox: u,
						isCheckboxSelected: o,
						toggleCheckbox: p
					}), c.a.createElement(de, null, c.a.createElement(le, null, c.a.createElement(ue, null, s.postAuthor && c.a.createElement(A.a, {
						comment: s,
						subredditOrProfile: m
					}), s.postTitle && c.a.createElement(M.a, null, s.postTitle)), c.a.createElement(L.a, {
						comment: s
					}, c.a.createElement(pe, null, c.a.createElement(B.a, {
						content: Object(W.a)(s),
						rtJsonElementProps: he(e)
					}), c.a.createElement(be, null)), a && c.a.createElement(F.a, {
						language: r,
						onIgnoreReports: i,
						reportable: s
					}), c.a.createElement(me, {
						comment: s,
						flair: n,
						language: r
					}))), l && !s.isDeleted && c.a.createElement(P.c, {
						comment: s,
						language: r
					})))
				}, "Component", ce.a)),
				Ee = s("./src/reddit/constants/postLayout.ts");
			const xe = {
					[Ee.g.Large]: ge,
					[Ee.g.Medium]: M.c,
					[Ee.g.Classic]: M.c,
					[Ee.g.Compact]: oe
				},
				fe = e => null;
			var ve = s("./src/reddit/models/Flair/index.ts"),
				Ce = s("./src/reddit/models/Media/index.ts"),
				Oe = s("./src/reddit/models/ModQueue/index.ts"),
				je = s("./src/reddit/selectors/meta.ts"),
				ye = s("./src/reddit/selectors/modQueue.ts"),
				ke = s("./src/reddit/selectors/subreddit.ts"),
				we = s("./src/config.ts"),
				Se = s("./src/reddit/components/ModQueueList/EmptyQueueBanner.m.less"),
				Ne = s.n(Se);
			const Te = "".concat(we.a.assetPath, "/img/snoomoji/cat_blep.png"),
				_e = u.a.div("Container", Ne.a),
				Ie = u.a.div("Image", Ne.a),
				Pe = u.a.div("Title", Ne.a),
				Me = u.a.div("Text", Ne.a);
			var Re = () => c.a.createElement(_e, null, c.a.createElement(Ie, {
					style: {
						backgroundImage: "url(".concat(Te, ")")
					}
				}), c.a.createElement(Pe, null, c.a.createElement(x.c, null, "The queue is clean!")), c.a.createElement(Me, null, c.a.createElement(x.c, null, "Kitteh is pleased"))),
				Le = s("./src/reddit/components/PostList/Placeholder.tsx");
			const De = Object(y.t)(),
				Ae = Object(l.c)({
					layout: y.M
				});
			var Fe = De(Object(d.b)(Ae)(e => c.a.createElement(Le.a, {
					isLoading: !0,
					layout: e.layout
				}))),
				Be = s("./node_modules/fbt/lib/FbtPublic.js"),
				Ue = s("./node_modules/lodash/flatten.js"),
				He = s.n(Ue),
				We = s("./src/reddit/actions/tooltip.ts"),
				qe = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				Ve = s("./src/reddit/icons/fonts/helpers.tsx"),
				ze = s("./src/reddit/icons/fonts/List/index.m.less"),
				Ke = s.n(ze);
			var Qe = u.a.wrapped(e => c.a.createElement("i", {
					className: "".concat(Object(Ve.b)("list"), " ").concat(e.className)
				}), "ListIcon", Ke.a),
				Ge = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				Je = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				Ze = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				Xe = s("./src/higherOrderComponents/asTooltip.tsx"),
				Ye = s("./src/reddit/actions/modal.ts"),
				$e = s("./src/reddit/components/PostFlairPicker/index.tsx"),
				et = s("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				tt = s("./src/reddit/controls/Dropdown/index.tsx"),
				st = s("./src/reddit/controls/Dropdown/Row.tsx"),
				nt = s("./src/reddit/helpers/flair.ts"),
				at = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				ot = s("./src/reddit/selectors/activeModalId.ts"),
				rt = s("./src/reddit/selectors/moderatorPermissions.ts"),
				it = s("./src/reddit/selectors/postFlair.ts"),
				ct = s("./src/reddit/selectors/posts.ts"),
				dt = s("./src/reddit/selectors/tooltip.ts"),
				lt = s("./src/reddit/components/TrackingHelper/index.tsx"),
				mt = s("./src/reddit/components/ModQueueList/ModToolsBulkOperations/ExtraModToolsList.m.less"),
				ut = s.n(mt);
			const pt = u.a.wrapped(e => c.a.createElement("button", {
					className: e.className,
					disabled: e.isDisabled,
					onClick: e.onClick,
					title: e.isDisabled ? Be.fbt._("You can't take that action on a comment", null, {
						hk: "26RFsw"
					}) : void 0
				}, c.a.createElement(f.a, null, e.buttonText)), "StatusItem", ut.a),
				bt = u.a.div("StatusContainer", ut.a),
				ht = Object(l.c)({
					selectedItems: ye.f
				}),
				gt = Object(d.b)(ht, e => ({
					onIgnoreReports: () => e(Object(p.f)(Oe.a.IgnoreReports)),
					onLock: () => e(Object(p.f)(Oe.a.Lock)),
					onMarkNSFW: () => e(Object(p.f)(Oe.a.MarkNSFW)),
					onSpoiler: () => e(Object(p.f)(Oe.a.Spoiler)),
					onUnignoreReports: () => e(Object(p.f)(Oe.a.UnignoreReports)),
					onUnlock: () => e(Object(p.f)(Oe.a.Unlock)),
					onUnmarkNSFW: () => e(Object(p.f)(Oe.a.UnmarkNSFW)),
					onUnspoiler: () => e(Object(p.f)(Oe.a.Unspoiler))
				})),
				Et = e => e.some(e => Object(k.a)(e)),
				xt = u.a.wrapped(gt(Object(lt.b)(e => c.a.createElement("div", {
					className: e.className,
					style: e.style
				}, c.a.createElement(bt, null, c.a.createElement(pt, {
					onClick: e.onIgnoreReports,
					buttonText: Be.fbt._("Ignore Reports", null, {
						hk: "1hZ3hN"
					})
				}), c.a.createElement(pt, {
					onClick: e.onUnignoreReports,
					buttonText: Be.fbt._("Unignore Reports", null, {
						hk: "3y089p"
					})
				}), c.a.createElement(pt, {
					isDisabled: Et(e.selectedItems),
					onClick: e.onLock,
					buttonText: Be.fbt._("Lock", null, {
						hk: "4bc0vl"
					})
				}), c.a.createElement(pt, {
					isDisabled: Et(e.selectedItems),
					onClick: e.onUnlock,
					buttonText: Be.fbt._("Unlock", null, {
						hk: "Pe2ML"
					})
				}), c.a.createElement(pt, {
					isDisabled: Et(e.selectedItems),
					onClick: e.onSpoiler,
					buttonText: Be.fbt._("Mark as Spoiler", null, {
						hk: "4pIu4V"
					})
				}), c.a.createElement(pt, {
					isDisabled: Et(e.selectedItems),
					onClick: e.onUnspoiler,
					buttonText: Be.fbt._("Unmark as Spoiler", null, {
						hk: "1ImDYd"
					})
				}), c.a.createElement(pt, {
					isDisabled: Et(e.selectedItems),
					onClick: e.onMarkNSFW,
					buttonText: Be.fbt._("Mark as NSFW", null, {
						hk: "4yS4Hz"
					})
				}), c.a.createElement(pt, {
					isDisabled: Et(e.selectedItems),
					onClick: e.onUnmarkNSFW,
					buttonText: Be.fbt._("Unmark as NSFW", null, {
						hk: "ZzA74"
					})
				}))))), "StatusList", ut.a);
			var ft = Object(Xe.a)(xt);
			const vt = Object(l.c)({
				isDropdownOpen: (e, t) => {
					let {
						tooltipId: s
					} = t;
					return Object(dt.b)(s)(e)
				}
			});
			var Ct = Object(d.b)(vt)(Object(lt.b)(e => {
					const {
						className: t,
						isDropdownOpen: s,
						tooltipId: n
					} = e;
					return c.a.createElement("div", {
						id: n,
						className: t
					}, c.a.createElement(ft, {
						isOpen: s,
						tooltipId: n
					}))
				})),
				Ot = s("./src/reddit/components/ModQueueList/ModToolsBulkOperations/index.m.less"),
				jt = s.n(Ot);
			const yt = "BulkAction--BulkItemFilter",
				kt = "BulkActions--PostFlair--Modal",
				wt = Object(Xe.a)(tt.a),
				St = u.a.div("CheckboxContainer", jt.a),
				Nt = u.a.wrapped(H.a, "Checkbox", jt.a),
				Tt = u.a.wrapped(at.b, "DropdownTriangle", jt.a),
				_t = u.a.wrapped(e => c.a.createElement(st.b, {
					className: e.className,
					displayText: e.displayText,
					onClick: e.onClick
				}), "DropdownRow", jt.a),
				It = u.a.span("Bullet", jt.a),
				Pt = u.a.div("Text", jt.a),
				Mt = Object(l.c)({
					activeModalId: ot.a,
					dropdownIsOpen: Object(dt.b)(yt),
					flairData: it.d,
					isApiPending: ye.a,
					moderatorPermissions: rt.j,
					posts: ct.L,
					selectedItems: ye.f
				}),
				Rt = Object(d.b)(Mt, e => ({
					onApprove: () => e(Object(p.f)(Oe.a.Approve)),
					onFlair: (t, s) => e(Object(p.f)(Oe.a.Flair, t, s)),
					onOpenDropdown: () => e(Object(We.g)({
						tooltipId: yt
					})),
					onOpenModToolsDropdown: () => e(Object(We.g)({
						tooltipId: "BulkActions--ModTools"
					})),
					onRemove: () => e(Object(p.f)(Oe.a.Remove)),
					onSpam: () => e(Object(p.f)(Oe.a.Spam)),
					onToggleFlairModal: () => e(Object(Ye.i)(kt))
				})),
				Lt = (e, t) => {
					const s = He()(e.map(e => t[e].flair));
					if (s.length <= 1) return s;
					const n = [];
					return s.forEach(e => {
						if (e.type === ve.f.Text || e.type === ve.f.Richtext) {
							const t = Object(nt.g)(e);
							r()(n, t) || n.push(t)
						}
					}), n.length > 1 ? [{
						type: ve.f.Text,
						text: Be.fbt._("Multiple Flairs", null, {
							hk: "2WHsvc"
						})
					}] : s
				};
			var Dt = Rt(u.a.wrapped(e => {
					const {
						activeModalId: t,
						className: s,
						endNumItems: n,
						flairData: a,
						isAnyItemSelected: o,
						isApiPending: r,
						moderatorPermissions: d,
						numSelected: l,
						numShowing: m,
						onApprove: u,
						onFlair: p,
						onRemove: b,
						onSpam: h,
						onToggleFlairModal: g,
						posts: E,
						selectedItems: x,
						startNumItems: f,
						subredditId: v,
						toggleSelectAll: C,
						toggleSelectByFilter: O
					} = e, j = [{
						name: Be.fbt._("Spam filtered", null, {
							hk: "S0DJ9"
						}),
						filterType: "spamFiltered"
					}, {
						name: Be.fbt._("Has reports", null, {
							hk: "1x2hhv"
						}),
						filterType: "hasReports"
					}, {
						name: Be.fbt._("Self posts", null, {
							hk: "KFHYI"
						}),
						filterType: "selfPosts"
					}, {
						name: Be.fbt._("Posts with flair", null, {
							hk: "18cMZD"
						}),
						filterType: "postsWithFlair"
					}, {
						name: Be.fbt._("Posts", null, {
							hk: "gGGKv"
						}),
						filterType: "posts"
					}, {
						name: Be.fbt._("Comments", null, {
							hk: "1F1pwI"
						}),
						filterType: "comments"
					}], y = d && d.flair, k = v && a && a.displaySettings.isEnabled && y && !Et(x);
					return c.a.createElement("div", {
						className: s
					}, c.a.createElement(St, {
						id: yt
					}, c.a.createElement(Nt, {
						isHalfCheckboxSelected: e.isAnyItemSelected && !e.isSelectAll,
						isCheckboxSelected: e.isSelectAll,
						toggleCheckbox: C
					}), c.a.createElement(Tt, {
						onClick: t => {
							t.stopPropagation(), e.onOpenDropdown()
						}
					}), c.a.createElement(wt, {
						isOpen: e.dropdownIsOpen,
						isOverlay: !1,
						tooltipId: yt
					}, j.map(e => c.a.createElement(_t, {
						key: e.filterType,
						displayText: e.name,
						onClick: () => O(e.filterType)
					})))), o && c.a.createElement(i.Fragment, null, c.a.createElement(et.c, {
						disabled: r,
						text: Be.fbt._("approve", null, {
							hk: "4ib5o9"
						}),
						onClick: u
					}, c.a.createElement(qe.a, null)), c.a.createElement(et.c, {
						disabled: r,
						text: Be.fbt._("remove", null, {
							hk: "1ImNcF"
						}),
						onClick: b
					}, c.a.createElement(Ge.a, null)), c.a.createElement(et.c, {
						disabled: r,
						text: Be.fbt._("spam", null, {
							hk: "36ppaW"
						}),
						onClick: h
					}, c.a.createElement(Je.a, null)), c.a.createElement(et.c, {
						disabled: r,
						onClick: e.onOpenModToolsDropdown
					}, c.a.createElement(Ct, {
						tooltipId: "BulkActions--ModTools"
					}), c.a.createElement(Qe, null)), c.a.createElement("div", null, k && c.a.createElement(et.c, {
						disabled: r,
						onClick: g
					}, c.a.createElement(Ze.a, null)))), o && v && t === kt && c.a.createElement($e.a, {
						flairs: Lt(x, E),
						modalId: kt,
						onFlairChanged: e => {
							let {
								previewFlair: t,
								selectedTemplateId: s
							} = e;
							p(t, s)
						},
						subredditId: v
					}), m > 0 && c.a.createElement(Pt, null, Be.fbt._("Items {startNumItems}-{endNumItems}", [Be.fbt._param("startNumItems", "".concat(f)), Be.fbt._param("endNumItems", "".concat(n))], {
						hk: "1FkOkC"
					}), c.a.createElement(It, null, "•"), Be.fbt._("{numSelected} selected", [Be.fbt._param("numSelected", "".concat(l))], {
						hk: "4uf9Ow"
					})))
				}, "ModToolsBulkOperations", jt.a)),
				At = s("./src/reddit/components/ModQueueList/index.m.less"),
				Ft = s.n(At);
			const Bt = e => Object(w.a)(e.id),
				Ut = u.a.div("ItemContainer", Ft.a),
				Ht = u.a.div("ButtonContainer", Ft.a),
				Wt = Object(y.t)({
					currentProfileName: y.h,
					isCommentPermalink: y.v,
					isCommentsPage: y.w,
					isFrontpage: y.z,
					isProfilePostListing: y.I,
					queryParams: y.R,
					pageLayer: e => e
				}),
				qt = Object(l.c)({
					currentPage: e => e.platform.currentPage,
					isModQueueListingPending: ye.b,
					loadMore: ye.d,
					modQueueListingItems: ye.c,
					origin: je.g,
					selectedItems: ye.f,
					subredditId: (e, t) => t.subredditName ? Object(ke.G)(e, t.subredditName) : null
				}),
				Vt = Object(d.b)(qt, e => ({
					addSelectedItems: t => e(Object(p.a)({
						ids: t
					})),
					bulkSelectItems: t => e(Object(p.b)({
						ids: t
					})),
					bulkUnselectItems: t => e(Object(p.c)({
						ids: t
					})),
					openPost: t => e(Object(b.x)(t))
				})),
				zt = e => e.page ? parseInt(e.page, 10) : Oe.b,
				Kt = e => zt(e) + 1,
				Qt = e => Math.max(Oe.b, zt(e) - 1),
				Gt = e => {
					const t = e.modQueueListingItems ? e.modQueueListingItems.length : 0;
					return zt(e) === Oe.b ? t : 25 * Qt(e) + t
				},
				Jt = e => zt(e) === Oe.b ? Oe.b : 25 * Qt(e) + 1;
			var Zt;
			! function(e) {
				e.comments = "comments", e.hasReports = "hasReports", e.posts = "posts", e.postsWithFlair = "postsWithFlair", e.selfPosts = "selfPosts", e.spamFiltered = "spamFiltered"
			}(Zt || (Zt = {}));
			class Xt extends c.a.Component {
				constructor() {
					super(...arguments), this.isCheckboxSelected = e => r()(this.props.selectedItems, e), this.isAllSelected = e => {
						const t = a()(e, this.props.selectedItems);
						return e.length > 0 && this.props.selectedItems.length > 0 && 0 === t.length
					}, this.toggleSelectedItems = (e, t) => {
						e ? this.props.bulkUnselectItems(t) : this.props.addSelectedItems(t)
					}, this.toggleSelectByFilter = e => {
						const t = [];
						if (!this.props.modQueueListingItems || !this.props.modQueueListingItems.length) return t;
						switch (e) {
							case Zt.posts:
								this.props.modQueueListingItems.forEach(e => {
									Object(w.a)(e.id) && t.push(e.id)
								});
								break;
							case Zt.comments:
								this.props.modQueueListingItems.forEach(e => {
									Object(k.a)(e.id) && t.push(e.id)
								});
								break;
							case Zt.hasReports:
								this.props.modQueueListingItems.forEach(e => {
									e.numReports && e.numReports > 0 && t.push(e.id)
								});
								break;
							case Zt.postsWithFlair:
								this.props.modQueueListingItems.forEach(e => {
									if (Object(w.a)(e.id)) {
										const s = e;
										s.flair && s.flair.filter(e => e.type !== ve.f.Spoiler && e.type !== ve.f.Nsfw).length > 0 && t.push(s.id)
									}
								});
								break;
							case Zt.selfPosts:
								this.props.modQueueListingItems.forEach(e => {
									if (Object(w.a)(e.id)) {
										const s = e;
										s.media && s.media.type === Ce.n.TEXT && t.push(s.id)
									}
								});
								break;
							case Zt.spamFiltered:
								this.props.modQueueListingItems.forEach(e => {
									e.isSpam && t.push(e.id)
								})
						}
						this.props.bulkSelectItems(t)
					}, this.isAnyItemSelected = () => this.props.selectedItems.length > 0, this.renderItems = e => {
						let t;
						const s = !!e.page && "1" !== e.page,
							n = !!e.loadMore && !!e.modQueueListingItems && 25 === e.modQueueListingItems.length;
						return e.modQueueListingItems && e.modQueueListingItems.length && (t = e.modQueueListingItems.map(t => {
							const s = "modqueue-item-[layout: ".concat(e.layout, "]-[id: ").concat(t.id, "]");
							if (Bt(t)) {
								const n = t,
									a = Object(S.b)({
										layout: e.layout,
										post: n
									});
								return c.a.createElement(Ut, {
									key: s
								}, c.a.createElement(a, {
									currentProfileName: e.currentProfileName,
									eventFactory: T,
									forceLoadMedia: !0,
									isCommentPermalink: e.isCommentPermalink,
									isCommentsPage: e.isCommentsPage,
									isFrontpage: e.isFrontpage,
									isProfilePostListing: e.isProfilePostListing,
									isCheckboxSelected: this.isCheckboxSelected(n.id),
									last: !0,
									pageLayer: e.pageLayer,
									postId: n.id,
									onClickPost: Object(j.b)(n.id, e),
									showBulkActionCheckbox: !0,
									toggleCheckbox: () => this.toggleSelectedItems(this.isCheckboxSelected(n.id), [n.id])
								}))
							}
							const n = function(e, t) {
								const s = xe[t];
								return void 0 === s ? (Object(_.a)(void 0, "Could not find component for layout ".concat(t, ".")), fe) : s
							}(0, e.layout);
							return c.a.createElement(Ut, {
								key: s
							}, c.a.createElement(n, {
								commentId: t.id,
								hasReports: Object(h.c)(t),
								highlight: !1,
								isCheckboxSelected: this.isCheckboxSelected(t.id),
								showBulkActionCheckbox: !0,
								showModTools: !0,
								toggleCheckbox: () => this.toggleSelectedItems(this.isCheckboxSelected(t.id), [t.id]),
								trackClick: e.sendEventWithName
							}))
						})), c.a.createElement("div", null, c.a.createElement("div", null, t), c.a.createElement(Ht, null, c.a.createElement(O, {
							prevButtonEnabled: s,
							prevTo: Object(m.a)("".concat(e.origin).concat(e.currentPage.url), {
								page: Qt(e),
								after: null
							}),
							nextButtonEnabled: n,
							nextTo: Object(m.a)("".concat(e.origin).concat(e.currentPage.url), {
								page: Kt(e),
								after: e.loadMore
							})
						})))
					}
				}
				componentWillUnmount() {
					this.props.bulkUnselectItems(this.props.selectedItems)
				}
				componentWillUpdate(e) {
					e.pageName === this.props.pageName && e.page === this.props.page && e.profileName === this.props.profileName && e.subredditName === this.props.subredditName && e.postTypeFilter === this.props.postTypeFilter || this.props.bulkUnselectItems(this.props.selectedItems)
				}
				render() {
					const {
						props: e
					} = this, t = e.modQueueListingItems && e.modQueueListingItems.length ? e.modQueueListingItems.map(e => e.id) : [], s = e.selectedItems.length;
					return c.a.createElement("div", null, c.a.createElement(Dt, {
						endNumItems: Gt(e),
						numSelected: s,
						numShowing: t.length,
						isAnyItemSelected: this.isAnyItemSelected(),
						isSelectAll: this.isAllSelected(t),
						startNumItems: Jt(e),
						subredditId: e.subredditId,
						toggleSelectAll: () => this.toggleSelectedItems(this.isAllSelected(t), t),
						toggleSelectByFilter: this.toggleSelectByFilter
					}), e.modQueueListingItems && e.modQueueListingItems.length ? this.renderItems(e) : e.modQueueListingItems ? c.a.createElement(Re, null) : e.isModQueueListingPending ? c.a.createElement(Fe, null) : null)
				}
			}
			t.a = Wt(Vt(Xt))
		},
		"./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_3aaWXDPwVg-rhD0DvWeyIg",
				titleFontH2: "_3RrF8F_t0SfGrUYfrMwbPy",
				titleFontH3: "_36oA-I2A9k4cBPYs3kAlux",
				titleFontH4: "_1neT2k10waDvSZYxkd9bk8",
				titleFontH5: "_3oeJNjYGx_aLE6l4o6Jhcr",
				titleFontH6: "_2CsvILRAMCNlhcGlq7eAZF",
				metadataFont: "_2odnjtlqO4r8tdO5H9fwLW",
				flairFont: "k5rlVaQw1fQ4nW2C-cK8H",
				labelsFont: "_20rPk9VJ1JfA7IuzEuFf25",
				actionFont: "_1YoZx3mOGBx4yxG_aQD3dq",
				smallButtonFont: "_3eWaIQ1VVjPR_5vUm4bU74",
				largeButtonFont: "rBsu7j_nL4EsDsP9nsEx4",
				tabFont: "_3WOHej9q3BPonP3nmtGWrh",
				strongTextFont: "_1efJllSuh9p67WrocQmmWR",
				extraSmallFont: "_2B5dym5b8t8WiyyXuCfQqk",
				bodyFontH1: "_1m_v2MMDlDugLUDKRkPnPP",
				bodyFontH2: "uhtqruCImDdb6YMrply29",
				bodyFontH3: "oI7G9eYumAFmPy69WN078",
				bodyFontH4: "_3NN_fRjCSJGnly_ejXsz8m",
				bodyFontH5: "_1lK4S52h6Glz4-OysTx6SF",
				bodyFontH6: "BarCcSBvd2WaM4vhBY1_R",
				bodyFont: "RIX67Ch_ZE4SYGnQlkPWs",
				bodyFontSmall: "_1_FK7Ynr3eStBK-2Nbutbg",
				bodyFontMono: "_1mpZy47SxXNRDTLTEdCUmV",
				dropdownRow: "_3p4amLmnNdNRS9NcI_TnQm",
				filter: "_1LUEYTVtU-JweRiTGrVNn6",
				container: "_1GH53do8Ql17wdDC_i_NDf",
				containerText: "KiwwtIazAS77Aa_w3AdBE",
				listContainer: "FyBjuKMom1xYgTT7w5Dg1",
				selector: "_3fe64brTItATv48WIPt-Af"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1o6EpuTR_pbdKk4biOJFOD",
				titleFontH2: "_2scGKAM0oQo5UQ0sAeTYcJ",
				titleFontH3: "nZ8gtQ7wSBH1Ei4U88QyH",
				titleFontH4: "cWWmG8ptxDy68exgcmkxK",
				titleFontH5: "_2ltEgDFK7lEC55mqYn2t1k",
				titleFontH6: "_1wRduyAnZyUXSUvy0rPJ7E",
				metadataFont: "_3iKB3xohr95CjhTE-YrXL4",
				flairFont: "_2tIFOrubLwHvQfSpZ7MBvr",
				labelsFont: "_1Qc6zGFV60DgXsfeg4iK1-",
				actionFont: "bD7YA5ocXtmwPNG0x7gqi",
				smallButtonFont: "wa3Y6CP3s2WY-9hiMRcK6",
				largeButtonFont: "_1Td1TQRNZA20xRbI-LLHsA",
				tabFont: "_3Bdl5CdTghtfz5X9Qkn7y0",
				strongTextFont: "_2bBsKMYboYeah9nlKp4p8e",
				extraSmallFont: "tMQHWUqfGmxyzobTGzABZ",
				bodyFontH1: "_2b6RUiVz7aEMUoaiEalXki",
				bodyFontH2: "_1gD38a1FX6kmxcFvUyP8bB",
				bodyFontH3: "_20D34o21pcOy-JSvp0fq42",
				bodyFontH4: "_368KGbv676rMnmb_kPY7-A",
				bodyFontH5: "_2o6Gp_6yxl-T5p9MHsV3hI",
				bodyFontH6: "_2jp4S3tPdfLXU3FVoOvCWi",
				bodyFont: "O3aukKYU-BhYFQQgCIAcN",
				bodyFontSmall: "_10AKt1uw6lDYoTkaQ2Egu-",
				bodyFontMono: "_3tQKpxkireZBsmkNyZ5-0J",
				row: "_3sZTiywtJTK5dskqy0h2G2",
				modNameCell: "_1hV1AUW4J0YvMuEK7-Ph1H",
				usernameLink: "_25VIbQ9CpcAT2Uys4A2mFb",
				actionLink: "_2yXBXFFI2XxJRqd89Zwd25",
				createdAtTooltip: "zMBbz2oHRB9_15CBkQ3P4",
				detailsContainer: "_3pusa5HaB8VO3ODi63vjLl",
				detailsContent: "piNOo-es-o0F7rcLiUu0N",
				detailsType: "_3P62Ird8EqkkVbqN0bv1tU",
				icon: "VzgXNIgPGoNVtsv9-uwYE",
				iconWrapper: "_3cDZ1nhaOv-edC1Ixznjgd",
				negativeTreatment: "XqM6DP9JAGpvwgodvCcuI",
				positiveTreatment: "Ob5o1Q3oVSaizQinm6DD",
				tooltip: "_33OjvBwqb5PPwalXFSmAoy"
			}
		},
		"./src/reddit/components/ModerationLog/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_2OYuAlGNOY6MlJjEC6nWEY",
				titleFontH2: "_2cz1b71RqIGBP0q1sEpoc1",
				titleFontH3: "pNuW5Xi4qPFjDgkhE2utU",
				titleFontH4: "HnjsgzUiJm7Rz4yf-QTnU",
				titleFontH5: "_32jYSRMv-UqDvlwAZ9yI4P",
				titleFontH6: "WyhSydN2c9D7w_ikI_LsS",
				metadataFont: "klmtj4Euuox2ljWXOzJqz",
				flairFont: "_1XFZbbYMt1bMVk_65YaTug",
				labelsFont: "_2lbFHk9fPHfy-Pj2cQ56ef",
				actionFont: "_250q84vRQ0qeydB79AJun",
				smallButtonFont: "_3QKadDpX2GixU1usvLUiww",
				largeButtonFont: "_24SnRKi2v2z3Q8DfWx8Cfd",
				tabFont: "_1y1SLpqv4ViOdLE8d7R03R",
				strongTextFont: "_1bRU6ybRMZMA-zL-dR_BFc",
				extraSmallFont: "_2y1np6PG43SydahIYTHy95",
				bodyFontH1: "_2qrAJcHH1W18XK6K_iZjmY",
				bodyFontH2: "_2yInLfhO3hB7n5aflEa_Y5",
				bodyFontH3: "_31VlGQEcOO_KNq8afFO4lZ",
				bodyFontH4: "_13MU9oPUeX9-FTZJw6fEdd",
				bodyFontH5: "_3h1ag_p5AVxzseMoTk9Oee",
				bodyFontH6: "_2GA-IlakdRmzOgQVFN2Q_F",
				bodyFont: "_3W9ZZjex4uhC0x4j0tXUE8",
				bodyFontSmall: "_2wYhe0C_P9ON8nur1uwzBd",
				bodyFontMono: "Ygu6NDZ2VS1jqJxKuuJ67",
				contentContainer: "PLQrC-Lzmu2AHBmciLxW5",
				table: "_27_l-nXesULxjvqLhpd6Ie",
				timeColHeader: "_1qWSBc-O0drE3JbIiVNEqE",
				modNameColHeader: "_2vKvLM8vE2iV6p5T0b5J42",
				actionNameColHeader: "_3pOXEjq1uyvW71Pp3gS7yv",
				icon: "_2iiHYO0HlG5gGeXyf7S3_q",
				iconContainer: "_3leJW5B-x65UTDfhDAblD_",
				title: "_2pFg2GOWUWlkKFlSaV-iFq",
				tooltip: "jkeAqS2MNV7nCHZkp4vi9",
				actionTooltip: "p12QqrsFSXUXQXCVTreZ5",
				actionTooltipDescription: "_2SZhKngNXxQ-MnrDr17Fm-",
				allIconsContainer: "_2zekEhqxlIqb4STkFCskIT",
				detailTooltip: "_20tDXbrpUnXW12ZXmRZdKa",
				bottomBarRow: "_28pYv3DHnyqXo6lJwzAOcG"
			}
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.m.less": function(e, t, s) {
			e.exports = {
				NoResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				noResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				NoResultsText: "_3V0T64xptTp5xLaY-1nsaz",
				noResultsText: "_3V0T64xptTp5xLaY-1nsaz"
			}
		},
		"./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "TOhrvfHoucDPr36mCCzXd",
				titleFontH2: "_3brDTRw250hGX1o5_C0hbB",
				titleFontH3: "_1wry80KT9v8gZ-OR85HxZU",
				titleFontH4: "_3UyiSE-qM-508iK8v3J9VE",
				titleFontH5: "_1X7-zzcj5Xf8vTf2xtYjK5",
				titleFontH6: "_2o19XEin0G5ad6iDvABrhH",
				metadataFont: "_1IpedXmIlnKyWpICNENnHX",
				flairFont: "_17kIb-dmfAlFCaIsLz34ar",
				labelsFont: "_3IrRBgoth_MxadAqzwGE2p",
				actionFont: "_1F_YPbXlF7ItI0z0j2Kdvy",
				smallButtonFont: "Irj9r66tO2hdWqbJx-vWa",
				largeButtonFont: "_26FBjOBHlTgNO9o-fMxWOX",
				tabFont: "_1DLO-Qu2r3PHt-swAklwVx",
				strongTextFont: "_2umiFjo_kHT370YVhqkBUV",
				extraSmallFont: "_1-tBC17ClgWOQWXO69y61J",
				bodyFontH1: "czPuE4HoIQInpzrURaqrX",
				bodyFontH2: "_1RMqo3EKzteTfSdM5Q-OSg",
				bodyFontH3: "_1SHo5_8OixTqxTjJ466mw1",
				bodyFontH4: "_3_zdAqdo55tnx5RHhyuGVr",
				bodyFontH5: "_22jno3ihRm-Ef63KN0Wuxa",
				bodyFontH6: "_28OREyYTHZDHgLjcK4pt_d",
				bodyFont: "_38nKHi6IDujIOM7SuazWPd",
				bodyFontSmall: "_1lPuNthSPFYSROqTVgJlNG",
				bodyFontMono: "_3C9ynyJ6Z174Fb3-8O20xa",
				footer: "_1a_UtwKPW009WQq9JDInTY",
				checkbox: "hXaFasafnItuHCckiO50p",
				checkboxContainer: "_15zz-Q8aRGCDeqROyYsa6f",
				primaryButton: "h4QlBfFmd6UnAtiNaOhcR",
				SecondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				secondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				ModalBody: "_2UK71LqBvNes-Kto-uSxfU",
				modalBody: "_2UK71LqBvNes-Kto-uSxfU"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitePendingModal.m.less": function(e, t, s) {
			e.exports = {
				ModalText: "LuEOOX6cpsihxJHcF5aDv",
				modalText: "LuEOOX6cpsihxJHcF5aDv",
				ModalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				modalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				PrimaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				primaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				SecondaryButton: "_31o7G_2349tIzHKunBJEua",
				secondaryButton: "_31o7G_2349tIzHKunBJEua",
				Section: "K3DxSh_MxIy1lMkeHIPMc",
				section: "K3DxSh_MxIy1lMkeHIPMc",
				Image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				ModalMain: "_3Nec6X3UqKJgLUGDaw4NCq",
				modalMain: "_3Nec6X3UqKJgLUGDaw4NCq"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less": function(e, t, s) {
			e.exports = {
				ListTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				listTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				ListContainer: "_1IFQy3zyz-Lgs7iYZtQaPI",
				listContainer: "_1IFQy3zyz-Lgs7iYZtQaPI"
			}
		},
		"./src/reddit/components/ModeratorsList/Moderator.m.less": function(e, t, s) {
			e.exports = {
				PencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				pencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				TrashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				trashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				InteractiveDiv: "qaNZ40bbce8HBshNk04f0",
				interactiveDiv: "qaNZ40bbce8HBshNk04f0"
			}
		},
		"./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less": function(e, t, s) {
			e.exports = {
				PrimaryButton: "_3j2WCnh8ZjDRHIILJwKzkx",
				primaryButton: "_3j2WCnh8ZjDRHIILJwKzkx"
			}
		},
		"./src/reddit/components/ModeratorsList/index.m.less": function(e, t, s) {
			e.exports = {
				ListContainer: "_3s9PIWHO5f49Yj01FelAkk",
				listContainer: "_3s9PIWHO5f49Yj01FelAkk",
				SecondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				secondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				EditableTitle: "_1IBuDqoejky7tmj25quCUh",
				editableTitle: "_1IBuDqoejky7tmj25quCUh",
				UsersLoading: "_1oLmt3eyMItCQozx1nTk1E",
				usersLoading: "_1oLmt3eyMItCQozx1nTk1E"
			}
		},
		"./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less": function(e, t, s) {
			e.exports = {
				optionSearchBarContainer: "_3eVrzdp5khbz6W2NhQv7kl",
				optionSearchBarError: "_3va8RfTnDLBo2hfMm5URpu",
				optionSearchBarReadOnly: "_2siJVLOBn72IxBt8i_A1gZ",
				loadingIcon: "_3UsfWdV2CKiIs_EOeGhVxv",
				input: "_1OEtZmrYX2ct3ycV1AaUZS",
				hiddenInput: "_3WSlf55CAQYRdOxtxENgA7",
				optionsOverflowIndication: "_2qfFc8Ix-QpBqu8UNEXeH3"
			}
		},
		"./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less": function(e, t, s) {
			e.exports = {
				activeOption: "_2Kg5EXAuLcqhsBbdEr4SGZ",
				option: "_1xWVaijFIih7uj-n4FXzH2",
				freeTextOption: "_2H29-4MOHAslt1eKYtcGaV",
				lastFixedOption: "_1ClyNNAK4vP9o_uoSwKe0Q",
				availableOptionContainer: "T2jLhmuhOy8DeOHjz6WRG",
				addText: "_1OqThwyrfhl2eJ9YhWoy2I",
				optionsContainer: "_1ZmC1GBXYnksnMU9IrTAHd",
				relativeContainer: "_3SrGeaD5FxXfpWjhSAFBD-",
				dropdown: "_2dqCXnStO_Dc8Srt_lJqVj",
				dropdownHeaderText: "_2EaXrPilAtjz6VRh_xvOGU"
			}
		},
		"./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less": function(e, t, s) {
			e.exports = {
				selectedOptionComponentContainer: "_3nUaRUcJJfrvOWldA3i10S",
				closeIcon: "_1RvgsgnXdbtv2cwTTTbT7o",
				selectedOptionComponentContainerError: "_2Qpr0YORGp3CmDjJW9Txrf"
			}
		},
		"./src/reddit/components/MultiOptionSelect/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = s("./node_modules/lodash/some.js"),
				a = s.n(n),
				o = s("./node_modules/react/index.js"),
				r = s.n(o),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/constants/keycodes.ts"),
				d = (s("./node_modules/core-js/modules/es6.symbol.js"), s("./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less")),
				l = s.n(d);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			class p extends r.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.handleOptionSelected(this.props.index)
					}, this.handleMouseEnter = () => {
						this.props.handleOnMouseEnter(this.props.index)
					}
				}
				shouldComponentUpdate(e) {
					return e.className !== this.props.className || e.divRef !== this.props.divRef || e.displayText !== this.props.displayText
				}
				render() {
					const e = this.props,
						{
							addText: t,
							displayText: s,
							divRef: n,
							handleOnMouseEnter: a,
							handleOptionSelected: o,
							index: c,
							className: d
						} = e,
						p = u(e, ["addText", "displayText", "divRef", "handleOnMouseEnter", "handleOptionSelected", "index", "className"]);
					return r.a.createElement("div", m({
						className: Object(i.a)(l.a.availableOptionContainer, d)
					}, p, {
						onMouseEnter: this.handleMouseEnter,
						onClick: this.handleClick,
						ref: n
					}), t && r.a.createElement("span", {
						className: l.a.addText
					}, t, " "), s)
				}
			}
			class b extends r.a.Component {
				constructor(e) {
					super(e), this.handleOptionSelectedByIndex = e => {
						this.props.selectableOptions[e] && this.handleOptionSelected(this.props.selectableOptions[e])
					}, this.handleFreeTextOptionSelected = () => {
						this.handleOptionSelected({
							id: null,
							displayText: this.props.currentInput,
							selected: !0
						})
					}, this.clearSelectedIndex = () => {
						this.setSelectedIndex(-1)
					}, this.setOptionActiveByIndex = e => {
						"number" == typeof e && e > -1 && this.setSelectedIndex(e)
					}, this.setFreeTextOptionActive = () => {
						this.setSelectedIndex(this.getOptionsLength() - 1)
					}, this.state = {
						selectedIndex: -1
					}, this.scrollContainer = r.a.createRef(), this.optionsContainer = r.a.createRef(), this.activeOptionDOMRef = r.a.createRef()
				}
				focus() {
					this.optionsContainer.current && this.optionsContainer.current.focus()
				}
				matchesDOMElement(e) {
					return this.optionsContainer.current === e
				}
				handleOptionSelected(e) {
					this.handleOptionsSelected([e])
				}
				handleOptionsSelected(e) {
					this.props.onOptionsChanged(e.map(e => Object.assign({}, e, {
						selected: !0
					})))
				}
				setSelectedIndex(e) {
					this.setState({
						selectedIndex: e
					})
				}
				freeTextEntryActive() {
					return this.props.allowFreeTextEntry && this.props.currentInput
				}
				getOptionsLength() {
					return this.freeTextEntryActive() ? this.props.selectableOptions.length + 1 : this.props.selectableOptions.length
				}
				freeTextOptionSelected() {
					return this.freeTextEntryActive() && this.state.selectedIndex === this.getOptionsLength() - 1
				}
				validOptionSelected() {
					return this.state.selectedIndex > -1 && this.state.selectedIndex < this.getOptionsLength()
				}
				handlePaste(e) {
					if (e.clipboardData.types.includes("text/plain")) return e.preventDefault(), e.stopPropagation(), void this.handleOptionsSelected(e.clipboardData.getData("text/plain").split(c.b.Comma).filter(e => !!e).map(e => ({
						id: null,
						displayText: e.trim(),
						selected: !0
					})))
				}
				handleKeyPress(e) {
					const {
						splitOnCommaPress: t
					} = this.props;
					return e.which === c.a.ArrowUp ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex - 1 > -1 ? this.state.selectedIndex - 1 : this.getOptionsLength() - 1)) : e.which === c.a.ArrowDown ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex + 1 < this.getOptionsLength() ? this.state.selectedIndex + 1 : 0)) : e.which === c.a.Comma && t ? (e.preventDefault(), e.stopPropagation(), this.handleFreeTextOptionSelected()) : e.which === c.a.Enter ? (e.preventDefault(), e.stopPropagation(), !this.validOptionSelected() || this.freeTextOptionSelected() ? this.handleFreeTextOptionSelected() : this.handleOptionSelected(this.props.selectableOptions[this.state.selectedIndex])) : void 0
				}
				componentDidUpdate() {
					if (!this.activeOptionDOMRef.current || !this.scrollContainer.current) return;
					const e = this.activeOptionDOMRef.current.getBoundingClientRect(),
						t = this.scrollContainer.current.getBoundingClientRect();
					if (e.top < t.top || e.bottom > t.bottom) {
						if (0 === this.state.selectedIndex) return void(this.scrollContainer.current.scrollTop = 0);
						if (e.top < t.top) return void(this.scrollContainer.current.scrollTop = this.activeOptionDOMRef.current.offsetTop);
						this.scrollContainer.current.scrollTop += e.bottom - t.bottom
					}
				}
				shouldRenderDropdownHeaderText() {
					return !!this.props.dropdownHeaderText && (!this.freeTextEntryActive() || this.props.selectableOptions.length > 0)
				}
				render() {
					return r.a.createElement("div", {
						className: l.a.relativeContainer
					}, r.a.createElement("div", {
						className: Object(i.a)(l.a.dropdown, this.props.className),
						ref: this.scrollContainer
					}, r.a.createElement("div", {
						ref: this.optionsContainer,
						tabIndex: -1,
						className: l.a.optionsContainer,
						onMouseOut: this.clearSelectedIndex
					}, this.shouldRenderDropdownHeaderText() && r.a.createElement("h3", {
						className: l.a.dropdownHeaderText
					}, this.props.dropdownHeaderText), this.props.selectableOptions.map((e, t) => {
						const s = [this.state.selectedIndex === t ? l.a.activeOption : l.a.option];
						return this.freeTextEntryActive() && t === this.props.selectableOptions.length - 1 && s.push(l.a.lastFixedOption), r.a.createElement(p, {
							key: e.id,
							className: Object(i.a)(...s),
							index: t,
							handleOptionSelected: this.handleOptionSelectedByIndex,
							handleOnMouseEnter: this.setOptionActiveByIndex,
							divRef: t === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
							displayText: e.displayText
						})
					}), this.freeTextEntryActive() && r.a.createElement(p, {
						key: "options-list-dropdown-free-text-option",
						className: Object(i.a)(l.a.freeTextOption, this.state.selectedIndex === this.getOptionsLength() - 1 ? l.a.activeOption : l.a.option),
						handleOptionSelected: () => this.handleFreeTextOptionSelected(),
						handleOnMouseEnter: this.setFreeTextOptionActive,
						divRef: this.getOptionsLength() - 1 === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
						addText: this.props.addText,
						displayText: this.props.currentInput
					}))))
				}
			}
			var h = s("./src/reddit/icons/svgs/Close/index.tsx"),
				g = s("./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less"),
				E = s.n(g);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var f = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			var v = e => {
					const {
						className: t,
						innerRef: s,
						onClickHandler: n,
						option: a,
						maxLength: o
					} = e, c = f(e, ["className", "innerRef", "onClickHandler", "option", "maxLength"]), d = [E.a.selectedOptionComponentContainer, t];
					return o && o < a.displayText.length && d.push(E.a.selectedOptionComponentContainerError), r.a.createElement("div", x({
						className: Object(i.a)(...d),
						ref: s
					}, c, {
						onClick: n
					}), a.displayText, r.a.createElement(h.a, {
						className: E.a.closeIcon
					}))
				},
				C = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				O = s("./src/reddit/helpers/readOnlyMode/index.ts"),
				j = s("./src/reddit/i18n/components.tsx"),
				y = s("./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less"),
				k = s.n(y);

			function w() {
				return (w = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const S = 10,
				N = e => e.stopPropagation();
			class T extends r.a.Component {
				constructor(e) {
					super(e), this.handleKeyPress = e => {
						e.which !== c.a.Delete && e.which !== c.a.Backspace || !this.lastSelectedOptionComponentRef.current || "" !== this.props.value || (this.lastSelectedOptionComponentRef.current.focus(), e.preventDefault(), e.stopPropagation())
					}, this.handleMouseEnterSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !0
						})
					}, this.handleMouseLeaveSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !1
						})
					}, this.onSearchBarFocus = e => {
						Object(O.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
							isFocused: !0
						}), this.props.onFocus && this.inputRef.current === e.target && this.props.onFocus())
					}, this.onSearchBarBlur = e => {
						if (this.containerRef.current && e.relatedTarget && this.containerRef.current.contains(e.relatedTarget)) return e.preventDefault(), void e.stopPropagation();
						this.props.onBlur && this.props.onBlur(e), this.setState({
							isFocused: !1
						})
					}, this.inputRef = r.a.createRef(), this.containerRef = r.a.createRef(), this.lastSelectedOptionComponentRef = r.a.createRef(), this.state = {
						isHoveringOverSelectedOption: !1,
						isFocused: !1
					}
				}
				focus() {
					Object(O.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
						isFocused: !0
					}))
				}
				reset() {
					this.inputRef.current && (this.inputRef.current.value = "")
				}
				deselectOption(e) {
					this.props.onOptionsChanged([Object.assign({}, e, {
						selected: !1
					})]), this.setState({
						isHoveringOverSelectedOption: !1
					})
				}
				onSelectedOptionComponentKeyDown(e, t) {
					this.state.isHoveringOverSelectedOption || e.which !== c.a.Delete && e.which !== c.a.Backspace || (e.preventDefault(), e.stopPropagation(), this.deselectOption(t), this.focus())
				}
				render() {
					const e = {};
					Object(O.c)(this.props.readOnlyMode) || (e.tabIndex = 0);
					const t = this.props.selectedOptionComponent || v,
						s = "number" == typeof this.props.maxOptionsToDisplay && this.props.options.length > this.props.maxOptionsToDisplay;
					return r.a.createElement("div", w({
						"aria-invalid": this.props.isError,
						className: Object(i.a)(this.props.className, k.a.optionSearchBarContainer, {
							[k.a.optionSearchBarError]: this.props.isError,
							[k.a.optionSearchBarReadOnly]: Object(O.c)(this.props.readOnlyMode)
						}),
						ref: this.containerRef,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur
					}, e), this.props.options.map((e, n) => {
						if (!(s && n >= (this.props.maxOptionsToDisplay || 0))) return r.a.createElement(t, {
							tabIndex: 0,
							onFocus: N,
							key: e.id || e.displayText,
							option: e,
							onKeyDown: t => this.onSelectedOptionComponentKeyDown(t, e),
							onClickHandler: () => {
								this.deselectOption(e), this.focus()
							},
							onMouseEnter: this.handleMouseEnterSelectedOptionComponent,
							onMouseLeave: this.handleMouseLeaveSelectedOptionComponent,
							maxLength: this.props.maxLength,
							innerRef: n === this.props.options.length - 1 ? this.lastSelectedOptionComponentRef : void 0
						})
					}), s && r.a.createElement("span", {
						className: k.a.optionsOverflowIndication
					}, r.a.createElement(j.c, null, "+".concat(this.props.options.length - (this.props.maxOptionsToDisplay || 0)))), this.props.children, !Object(O.c)(this.props.readOnlyMode) && r.a.createElement("input", {
						className: Object(i.a)(k.a.input, {
							[k.a.hiddenInput]: Object(O.b)(this.props.readOnlyMode)
						}),
						ref: this.inputRef,
						type: "text",
						onKeyDown: this.handleKeyPress,
						value: this.props.value,
						onChange: this.props.onInputChanged,
						maxLength: this.props.maxLength
					}), this.props.isLoading && r.a.createElement(C.a, {
						className: k.a.loadingIcon,
						sizePx: S
					}), this.state.isFocused && r.a.createElement(b, {
						className: this.props.dropdownClassName,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						selectableOptions: this.props.selectableOptions,
						onOptionsChanged: this.props.onOptionsChanged,
						ref: this.props.dropdownRef,
						currentInput: this.props.value,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						splitOnCommaPress: this.props.splitOnCommaPress
					}))
				}
			}
			var _ = s("./node_modules/reselect/es/index.js");
			const I = [],
				P = {};
			class M extends r.a.Component {
				constructor(e) {
					super(e), this._selectableOptionsSelector = Object(_.a)(e => e.availableOptions || I, e => e.input, (e, t) => e.filter(e => {
						const s = e.displayText.toLowerCase(),
							n = t.toLowerCase();
						return 0 === s.indexOf(n) || a()(s.split(/[\s\/]+/), e => 0 === e.indexOf(n))
					})), this.onSearchBarFocus = () => {
						Object(O.c)(this.props.readOnlyMode) || this.state.searchBarIsFocused || (this.setState({
							searchBarIsFocused: !0
						}), this.props.onSearchBarFocus && this.props.onSearchBarFocus())
					}, this.onSearchBarBlur = e => {
						if (!Object(O.c)(this.props.readOnlyMode)) return this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.matchesDOMElement(e.relatedTarget) ? (e.stopPropagation(), e.preventDefault(), void setTimeout(() => {
							this.optionSearchBarRef.current && this.optionSearchBarRef.current.focus()
						}, 0)) : (this.setState({
							searchBarIsFocused: !1
						}), void(this.props.onSearchBarBlur && this.props.onSearchBarBlur(e)))
					}, this.setInput = e => {
						Object(O.b)(this.props.readOnlyMode) || this.props.input !== e && this.props.onInputChanged(e)
					}, this.onOptionChanged = e => {
						this.onOptionsChanged([e])
					}, this.onOptionsChanged = e => {
						this.props.onOptionsChanged(e), a()(e, e => !!e.selected) && this.setInput("")
					}, this.onInputChanged = e => {
						Object(O.b)(this.props.readOnlyMode) || this.setInput(e.currentTarget.value)
					}, this.onKeyDown = e => {
						Object(O.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handleKeyPress(e)
					}, this.onPaste = e => {
						Object(O.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handlePaste(e)
					}, this.state = {
						searchBarIsFocused: !1
					}, this.optionsListDropdownRef = r.a.createRef(), this.optionSearchBarRef = r.a.createRef()
				}
				getSelectableOptions() {
					return this._selectableOptionsSelector(this.props)
				}
				render() {
					const {
						childClassNames: e = P
					} = this.props;
					return r.a.createElement("div", {
						className: this.props.className,
						onKeyDown: this.onKeyDown,
						onPaste: this.onPaste
					}, r.a.createElement(T, {
						className: e.searchBarClassName,
						dropdownClassName: e.optionsListDropdownClassName,
						isError: this.props.isError,
						readOnlyMode: this.props.readOnlyMode || O.a.editable,
						isLoading: this.props.isLoading,
						ref: this.optionSearchBarRef,
						options: this.props.selectedOptions,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur,
						onOptionsChanged: this.onOptionsChanged,
						onInputChanged: this.onInputChanged,
						maxLength: this.props.maxOptionLength,
						maxOptionsToDisplay: this.props.maxOptionsToDisplay,
						value: this.props.input,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						selectableOptions: this.getSelectableOptions(),
						dropdownRef: this.optionsListDropdownRef,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: this.props.splitOnCommaPress
					}, this.props.children))
				}
			}
			t.a = M
		},
		"./src/reddit/components/MutedUserList/ExpandedComponent.m.less": function(e, t, s) {
			e.exports = {
				BannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				bannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				EmptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				emptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				ExpandedContainer: "_1EEdKUOD4OiTBBQQkot-L9",
				expandedContainer: "_1EEdKUOD4OiTBBQQkot-L9"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less": function(e, t, s) {
			e.exports = {
				PrimaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				primaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				ModalText: "_3P1niYqJc2au-fmA-xIl7i",
				modalText: "_3P1niYqJc2au-fmA-xIl7i"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./src/higherOrderComponents/asModal/index.tsx"),
				i = s("./src/lib/lessComponent.tsx"),
				c = s("./src/reddit/actions/subredditModeration.ts"),
				d = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				l = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				u = s("./src/reddit/controls/Button/index.tsx"),
				p = s("./src/reddit/controls/TextButton/index.tsx"),
				b = s("./src/reddit/helpers/isValidUsername/index.tsx"),
				h = s("./src/reddit/i18n/utils.ts"),
				g = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				E = s("./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less"),
				x = s.n(E);
			const f = 300,
				v = Object(o.b)(null, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						onMuteUser: (t, n) => e(Object(c.hb)(s, t, n))
					}
				}),
				C = i.a.wrapped(u.f, "PrimaryButton", x.a),
				O = i.a.wrapped(l.m, "ModalText", x.a);
			class j extends a.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onReasonChange = e => {
						this.setState({
							reason: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const e = this.state.username;
						this.props.onMuteUser(e, this.state.reason), this.props.trackAddEvent(), this.props.toggleModal()
					}, this.state = {
						username: this.props.username || "",
						reason: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(l.c, null, a.a.createElement(l.g, null, a.a.createElement(g.a, null, a.a.createElement(l.n, null, Object(h.c)("Mute user"), e.username && ": u/".concat(e.username)), a.a.createElement(p.a, {
						onClick: e.toggleModal
					}, a.a.createElement(l.b, null)))), a.a.createElement(l.j, null, !e.username && a.a.createElement(l.f, null, a.a.createElement(m.d, {
						autoFocus: !0,
						placeholder: Object(h.c)("Username to mute"),
						onChange: this.onUsernameChange,
						value: this.state.username,
						"data-redditstyle": !0
					})), a.a.createElement(l.f, null, a.a.createElement(O, null, Object(h.c)("Note about why they are muted")), a.a.createElement(l.d, null, Object(h.c)("Only visible to other moderators. Not visible to user"))), a.a.createElement(l.q, {
						maxLength: f,
						onChange: this.onReasonChange,
						placeholder: Object(h.c)("Reason they were muted"),
						value: this.state.reason,
						"data-redditstyle": !0
					}), a.a.createElement(d.a, {
						maxChars: f,
						text: this.state.reason
					})), a.a.createElement(l.e, null, a.a.createElement(l.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Object(h.c)("Cancel")), a.a.createElement(C, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(b.a)(t.username)
					}, Object(h.c)("Mute user"))))
				}
			}
			t.default = Object(r.a)(v(j))
		},
		"./src/reddit/components/MutedUserList/index.m.less": function(e, t, s) {
			e.exports = {
				MuteIcon: "XHViv8EEjdjsATc3T66r9",
				muteIcon: "XHViv8EEjdjsATc3T66r9"
			}
		},
		"./src/reddit/components/PaginationButtons/index.m.less": function(e, t, s) {
			e.exports = {
				buttonContainer: "_1kLu6euoyZ3I2dqDVrxoZD",
				routerLink: "_3k7SslJt4xhPIXKtoe8DFf",
				mDisabled: "_1VgBJV1BqaXyZVPBXEv-KC"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.m.less": function(e, t, s) {
			e.exports = {
				backgroundWrapper: "_1poyrkZ7g36PawDueRza-J",
				badge: "_1lLKAbRNH1mm32sVm7yCzQ"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				c = s("./src/reddit/components/PostBackgroundWrapper/index.m.less"),
				d = s.n(c);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var m = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			t.a = Object(r.a)(e => {
				const {
					children: t,
					className: s,
					flairStyleTemplate: n,
					onClick: r,
					post: c,
					redditStyle: u,
					theme: p
				} = e, b = m(e, ["children", "className", "flairStyleTemplate", "onClick", "post", "redditStyle", "theme"]);
				return a.a.createElement("div", l({
					className: Object(o.a)(d.a.backgroundWrapper, s),
					style: Object(i.c)(n, e),
					onClick: r
				}, b), t)
			})
		},
		"./src/reddit/components/PostFollow/index.m.less": function(e, t, s) {
			e.exports = {
				collectionFollow: "_1yF34mDRcD_ii0n-Ak0OdI",
				isFollowed: "gBrTiaH_Z7HT5D96vnUfJ",
				isEventFollow: "_1iTFEDTdpF-KFmOZvDuGHH"
			}
		},
		"./src/reddit/components/PostFollow/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return h
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/actions/post.ts"),
				d = s("./src/reddit/components/TrackingHelper/index.tsx"),
				l = s("./src/reddit/components/Translated/index.tsx"),
				m = s("./src/reddit/helpers/trackers/postCollection.ts"),
				u = s("./src/reddit/components/PostFollow/index.m.less"),
				p = s.n(u);
			class b extends a.a.Component {
				constructor(e) {
					super(e), this.onFollowClick = () => {
						const {
							isEventFollow: e,
							onFollow: t,
							post: {
								id: s,
								isFollowed: n
							},
							sendEvent: a
						} = this.props, o = !!n;
						a(e ? Object(m.o)({
							postId: s,
							isFollowed: o
						}) : Object(m.g)({
							postId: s,
							isFollowed: o
						})), t && t()
					}, this.onMouseEnter = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !1
						})
					}, this.state = {
						isHovered: !1
					}
				}
				render() {
					const {
						className: e,
						isEventFollow: t,
						post: s
					} = this.props, n = this.state.isHovered, o = s.isFollowed;
					let r = o ? "collection.follow.followed" : "collection.follow.follow";
					return o && n && (r = "collection.follow.unfollow"), a.a.createElement("button", {
						className: Object(i.a)(p.a.collectionFollow, {
							[p.a.isFollowed]: !!s.isFollowed,
							[p.a.isEventFollow]: t
						}, e),
						onClick: this.onFollowClick,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, a.a.createElement(l.a, {
						msgId: r
					}))
				}
			}
			const h = Object(o.b)(() => Object(r.c)({}), (e, t) => {
				let {
					post: s
				} = t;
				return {
					onFollow: () => e(Object(c.s)(s.isSponsored ? s.postId : s.id))
				}
			})(Object(d.b)(b))
		},
		"./src/reddit/components/PostLeftRail/index.m.less": function(e, t, s) {
			e.exports = {
				postLeftRail: "_23h0-EcaBUorIHC-JZyh6J"
			}
		},
		"./src/reddit/components/PostLeftRail/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			})), s.d(t, "c", (function() {
				return g
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = s("./src/reddit/constants/colors.ts"),
				l = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				m = s("./src/reddit/selectors/experiments/adSidebar.ts"),
				u = s("./src/reddit/components/PostLeftRail/index.m.less"),
				p = s.n(u);
			const b = 40,
				h = Object(o.b)(() => Object(r.c)({
					isInAdLeftSidebarExperiment: m.a
				})),
				g = e => e.isSponsored && !e.isInAdLeftSidebarExperiment ? Object(l.a)(e).button : e.isRemoved ? d.a.removed : e.isReported ? d.a.reported : "transparent",
				E = Object(c.a)(e => {
					const t = g(e),
						s = {
							width: "".concat(b, "px"),
							borderLeft: "4px solid ".concat(t)
						};
					return a.a.createElement("div", {
						className: Object(i.a)(p.a.postLeftRail, e.className),
						style: e.withoutComputedStyles ? {} : s
					}, e.children)
				});
			t.b = h(E)
		},
		"./src/reddit/components/PostList/LoadMore.m.less": function(e, t, s) {
			e.exports = {
				Component: "_3tBFh6Ty3gSaxW4gcm6hZ_",
				component: "_3tBFh6Ty3gSaxW4gcm6hZ_"
			}
		},
		"./src/reddit/components/PostList/LoadMore.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/components/PostList/Placeholder.tsx"),
				o = s("./src/reddit/components/PostList/LoadMore.m.less"),
				r = s.n(o);
			t.a = n.a.wrapped(a.a, "Component", r.a)
		},
		"./src/reddit/components/PostList/Placeholder.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/constant.js"),
				a = s.n(n),
				o = s("./node_modules/lodash/times.js"),
				r = s.n(o),
				i = s("./node_modules/react/index.js"),
				c = s.n(i),
				d = s("./node_modules/react-redux/es/index.js"),
				l = s("./node_modules/reselect/es/index.js"),
				m = s("./src/lib/fastdom/index.ts"),
				u = s("./src/lib/intersectionObserver/index.ts"),
				p = s("./src/reddit/constants/postLayout.ts"),
				b = s("./src/reddit/components/ClassicPost/Placeholder.tsx"),
				h = s("./src/reddit/components/CompactPost/Placeholder/index.tsx"),
				g = (s("./node_modules/core-js/modules/es6.symbol.js"), s("./src/lib/classNames/index.ts")),
				E = s("./src/reddit/components/PostLeftRail/index.tsx"),
				x = s("./src/reddit/components/SubredditIcon/index.tsx"),
				f = s("./src/reddit/components/VerticalVotes/votes.tsx"),
				v = s("./src/reddit/contexts/PageLayer/index.tsx"),
				C = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				O = s("./src/reddit/models/Vote/index.ts"),
				j = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				y = s.n(j),
				k = s("./src/reddit/components/LargePost/placeholder.m.less"),
				w = s.n(k);

			function S() {
				return (S = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var N = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const T = Object(v.t)(),
				_ = Object(l.c)({
					isFakeSubreddit: v.y
				}),
				I = Object(d.b)(_),
				P = e => {
					const t = {
						interactive: !1,
						voteState: O.a.notVoted
					};
					return c.a.createElement("div", {
						className: w.a.emptyVerticalVotes
					}, c.a.createElement(f.d, S({
						key: "u"
					}, t)), c.a.createElement("div", {
						className: w.a.emptyScore,
						key: "s"
					}), c.a.createElement(f.c, S({
						key: "d"
					}, t)))
				},
				M = e => {
					var {
						isLoading: t
					} = e, s = N(e, ["isLoading"]);
					return c.a.createElement(x.b, S({
						className: Object(C.a)({
							isLoading: t
						})
					}, s))
				};
			var R = T(I(e => {
				var {
					className: t,
					dispatch: s,
					pageLayer: n
				} = e, a = N(e, ["className", "dispatch", "pageLayer"]);
				return c.a.createElement("div", {
					className: Object(g.a)(y.a.baseLargeAndMediumPostStyles, t)
				}, c.a.createElement(E.b, {
					key: "a"
				}, c.a.createElement(P, a)), c.a.createElement("div", {
					className: w.a.content,
					key: "b"
				}, c.a.createElement("div", {
					className: w.a.topLine,
					key: "ba"
				}, a.isFakeSubreddit && c.a.createElement(M, {
					key: "baa",
					isLoading: !1
				}), c.a.createElement("div", {
					key: "bab",
					className: Object(g.a)(w.a.topMetaOne, Object(C.b)(a))
				}), c.a.createElement("div", {
					key: "bac",
					className: Object(g.a)(w.a.topMetaTwo, Object(C.b)(a))
				})), c.a.createElement("div", {
					key: "bb",
					className: Object(g.a)(w.a.title, Object(C.b)(a))
				})), c.a.createElement("div", {
					key: "c",
					className: Object(g.a)(w.a.media, Object(C.a)(a))
				}), c.a.createElement("div", {
					className: w.a.content,
					key: "d"
				}, c.a.createElement("div", {
					className: w.a.flatlist
				}, c.a.createElement("div", {
					className: Object(g.a)(w.a.flatlistItemOne, Object(C.b)(a))
				}), c.a.createElement("div", {
					className: Object(g.a)(w.a.flatListItemTwo, Object(C.b)(a))
				}))))
			}));
			const L = {
				[p.g.Large]: [R, 2],
				[p.g.Classic]: [b.b, 10],
				[p.g.Compact]: [h.a, 30]
			};

			function D(e) {
				return L[e]
			}
			const A = .1,
				F = Object(l.c)({
					loadingPostComponentForLayout: () => D
				}),
				B = Object(d.b)(F);
			class U extends c.a.Component {
				constructor() {
					super(...arguments), this.mounted = !1, this.state = {
						visible: !1
					}, this.setWrapperRef = e => {
						e !== this.wrapperRef && (this.wrapperRef && u.b(this.wrapperRef), e && u.a(e, this.updateVisibleState)), this.wrapperRef = e
					}, this.updateVisibleState = e => {
						const t = e.intersectionRatio >= A;
						m.a.write(() => {
							this.mounted && this.setState(e => e.visible !== t ? {
								visible: t
							} : null)
						})
					}
				}
				componentDidMount() {
					document.documentElement.scrollTop = document.body.scrollTop = 0, this.mounted = !0
				}
				componentWillUnmount() {
					this.mounted = !1, this.wrapperRef && u.b(this.wrapperRef)
				}
				render() {
					const {
						className: e,
						countOverride: t,
						isLoading: s,
						layout: n,
						loadingPostComponentForLayout: o
					} = this.props, {
						visible: i
					} = this.state, [d, l] = o(n), m = t || l, u = a()(c.a.createElement(d, {
						isLoading: s && i
					})), p = r()(m, u);
					return c.a.createElement("div", {
						className: e,
						ref: this.setWrapperRef
					}, c.a.Children.toArray(p))
				}
			}
			t.a = B(U)
		},
		"./src/reddit/components/PostList/SomethingWrong.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./src/reddit/connectors/connectToLanguage.ts"),
				i = s("./src/reddit/controls/Button/index.tsx"),
				c = s("./src/reddit/helpers/describeApiError/index.ts"),
				d = s("./src/reddit/components/PostList/index.m.less"),
				l = s.n(d);
			t.a = Object(r.a)(e => {
				const {
					language: t,
					onTryAgain: s,
					apiError: a
				} = e;
				let r = n.fbt._("Something went wrong while loading.", null, {
					hk: "1ijaef"
				});
				return a && (r = Object(c.a)({
					apiError: a,
					language: t,
					isLoggedOut: !1
				})), o.a.createElement("div", {
					className: l.a.somethingWrong
				}, o.a.createElement("div", {
					className: l.a.somethingWrongText
				}, r), s && o.a.createElement(i.f, {
					onClick: s
				}, n.fbt._("Try again", null, {
					hk: "3JPIhw"
				})))
			})
		},
		"./src/reddit/components/PostList/index.m.less": function(e, t, s) {
			e.exports = {
				placeholder: "FohHGMokxXLkon1aacMoi",
				seeMoreButton: "_1Uj2L1UhJuirkaXINcf9S8",
				seeMorePostsText: "_2DB_2VI3a-y6nk57R2aWVo",
				somethingWrong: "zfoxmi0VvZvMZu1rHVbMX",
				somethingWrongText: "Ii7DEkcMDxQHElTHeeaci",
				postList: "rpBJOHq2PR60pnwJlUyP0",
				truncatedPostList: "QBfRw7Rj8UkxybFpX-USO",
				SeeMore: "_1yJOfuD_qgqaaG8ZIFbQVc",
				seeMore: "_1yJOfuD_qgqaaG8ZIFbQVc",
				ArrowRight: "wakXAw7uCIqmSRV84RKMW",
				arrowRight: "wakXAw7uCIqmSRV84RKMW"
			}
		},
		"./src/reddit/components/PostList/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return K
			})), s.d(t, "a", (function() {
				return J
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.array.sort.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/history/esm/history.js"),
				a = s("./node_modules/lodash/debounce.js"),
				o = s.n(a),
				r = s("./node_modules/lodash/last.js"),
				i = s.n(r),
				c = s("./node_modules/react/index.js"),
				d = s.n(c),
				l = s("./node_modules/react-dom/index.js"),
				m = s("./src/lib/addQueryParams/index.ts"),
				u = s("./src/lib/classNames/index.ts"),
				p = s("./src/lib/constants/index.ts"),
				b = s("./src/lib/fastdom/index.ts"),
				h = s("./src/lib/lessComponent.tsx"),
				g = s("./src/lib/opener/index.ts"),
				E = s("./src/lib/sentry/index.ts"),
				x = s("./src/reddit/components/PostList/LoadMore.tsx"),
				f = s("./src/reddit/components/PostList/SomethingWrong.tsx"),
				v = s("./src/reddit/components/Scroller/Simple.tsx"),
				C = s("./src/reddit/components/Translated/index.tsx"),
				O = s("./src/reddit/constants/adEvents.ts"),
				j = s("./src/reddit/constants/componentSizes.ts"),
				y = s("./src/reddit/constants/postLayout.ts"),
				k = s("./src/reddit/controls/InternalLink/index.tsx"),
				w = s("./src/reddit/helpers/getClickInfo.ts"),
				S = s("./src/reddit/helpers/pixels.ts"),
				N = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				T = s("./src/reddit/models/Media/index.ts"),
				_ = s("./src/reddit/helpers/brandSafety/index.ts"),
				I = s("./src/lib/LRUCache/index.ts"),
				P = s("./src/telemetry/index.ts"),
				M = s("./src/telemetry/models/Timer.ts"),
				R = s("./src/reddit/components/PostList/index.m.less"),
				L = s.n(R),
				D = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var a = 0;
						for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
					}
					return s
				};
			const A = 500,
				F = new I.a(A),
				B = new I.a(A),
				U = new I.a(A),
				H = {
					LARGE: 1,
					MEDIUM: 1,
					CLASSIC: 3,
					COMPACT: 5
				},
				W = h.a.div("SeeMore", L.a),
				q = h.a.wrapped(N.a, "ArrowRight", L.a),
				V = (e, t, s, n, a, o, r, i) => {
					const c = s ? "last-".concat(n, "-").concat(a) : "",
						d = "entered-".concat(e, "-").concat(t, "-").concat(c, "-").concat(o);
					let l = F.get(d);
					return void 0 === l && (l = () => {
						s && r.onBottomViewed(n, a), r.trackOnPostEnteredViewport(e, t, i)
					}, F.set(d, l)), l
				},
				z = (e, t, s, n) => {
					const a = "left-".concat(e, "-").concat(t);
					let o = B.get(a);
					return void 0 === o && (o = a => {
						s.trackOnPostExitedViewport(e, t, a, n)
					}, B.set(a, o)), o
				},
				K = (e, t) => {
					const s = "click-".concat(e);
					let n = U.get(s);
					return void 0 === n && (n = (e, s) => {
						s.isSponsored && Object(S.a)(s.events, O.a.Click), s.isSponsored && s.source && s.source.outboundUrl ? Object(g.d)(s.source.outboundUrl, g.c.BLANK) : t.openPost({
							postOrComment: s,
							clickInfo: Object(w.a)(e)
						})
					}, U.set(s, n)), n
				},
				Q = (e, t) => {
					if (e.isBlank) return 0;
					switch (t) {
						case y.g.Medium:
							return 188;
						case y.g.Classic:
							return 96;
						case y.g.Compact:
							return 32;
						default:
							return 200
					}
				},
				G = (e, t) => {
					const s = [...e];
					return Object.keys(t).map(e => parseInt(e, 10)).sort((e, t) => t - e).forEach(e => {
						s.splice(e, 0, t[e])
					}), s
				};
			class J extends d.a.Component {
				constructor() {
					super(...arguments), this.didRenderLastVisibleChild = !1, this.renderingEmpty = !1, this.renderingPlaceholder = !1, this.scrollChildCache = new I.a(A), this.updateScrollerRef = e => {
						const t = e && Object(l.findDOMNode)(e);
						this.scrollerRef = t instanceof Element ? t : void 0
					}, this.setLastVisibleChildRendered = () => {
						this.didRenderLastVisibleChild = !0, this.checkAndSendScreenview()
					}, this.onScrollPause = e => {
						this.dispatchBrandSafety(e)
					}, this.dispatchBrandSafety = o()(e => {
						let {
							getVisibleItemsInViewport: t
						} = e;
						const {
							postsById: s,
							subredditsById: n
						} = this.props, a = t(), o = [];
						a.forEach(e => o.push(e.id));
						const r = o.map(e => s[e]).filter(Boolean),
							i = r.map(e => n[e.belongsTo.id]).filter(e => void 0 !== e);
						this.props.adBrandSafetyStatusReceived(Object(_.a)(r, i))
					}, p.d, {
						leading: !0
					})
				}
				componentWillMount() {
					this.timerId && P.c.cancel(this.timerId), this.props.postIds.length && (this.timerId = P.c.start())
				}
				componentDidMount() {
					if (this.checkAndSendScreenview(), this.timerId) {
						const e = P.c.end(this.timerId);
						setTimeout(() => Object(P.b)(p.l.Redesign, {
							type: "mount",
							component: "postList",
							duration: e
						}), 0)
					}
				}
				componentWillUpdate(e) {
					this.timerId && P.c.cancel(this.timerId), e.postIds.length && (this.timerId = P.c.start()), (e.listingKey !== this.props.listingKey || e.postIds.length !== this.props.postIds.length && !this.isListLongEnough()) && (this.didRenderLastVisibleChild = !1)
				}
				componentDidUpdate(e) {
					if (b.a.read(() => this.checkAndSendScreenview()), this.timerId && P.c.has(this.timerId)) {
						const e = P.c.end(this.timerId);
						if (e < 10) return;
						setTimeout(() => Object(P.b)(p.l.Redesign, {
							duration: e,
							type: "mount",
							component: "postList"
						}), 0)
					}
				}
				componentWillUnmount() {
					this.timerId && P.c.cancel(this.timerId), this.scrollerRef = null, this.didRenderLastVisibleChild = !1
				}
				isListLongEnough() {
					const e = this.scrollerRef && Array.from(this.scrollerRef.children),
						t = e && i()(e);
					return t && t.getBoundingClientRect().bottom > window.innerHeight
				}
				shouldSendScreenview() {
					const {
						apiError: e,
						listingKey: t,
						viewportDataLoaded: s
					} = this.props;
					return P.c.has(t) && (e || !this.renderingPlaceholder && (this.renderingEmpty || this.didRenderLastVisibleChild && (s || this.isListLongEnough())))
				}
				checkAndSendScreenview() {
					const {
						listingKey: e,
						listingViewed: t,
						sendEvent: s
					} = this.props;
					if (!this.shouldSendScreenview()) return;
					const n = P.c.end(e);
					setTimeout(() => {
						s(t(n, M.TimerType.InApp))
					}, 0)
				}
				showPlaceholder() {
					const {
						apiError: e,
						apiPending: t,
						disablePlaceholder: s
					} = this.props;
					return !s && (Boolean(e) || !1 !== t)
				}
				hasPosts() {
					return this.props.postIds.length > 0
				}
				isLoadingMore() {
					const {
						loadMore: e,
						postIds: t
					} = this.props;
					return Boolean(e && e.token) && t.length > 0
				}
				shouldComponentUpdate(e) {
					const t = this.props,
						{
							postsById: s
						} = t,
						n = D(t, ["postsById"]),
						{
							postsById: a
						} = e,
						o = D(e, ["postsById"]),
						r = Object.keys(n),
						i = Object.keys(o);
					if (i.length !== r.length) return !0;
					if (i.some(e => n[e] !== o[e])) return !0;
					if (s === a) return !1;
					if (this.props.postIds && this.props.postIds.length) {
						const {
							layout: e,
							postComponentForLayout: t
						} = this.props;
						return this.props.postIds.some((n, o) => {
							const r = 0 === o;
							return t({
								isFirstPost: r,
								layout: e,
								post: s[n]
							}) !== t({
								isFirstPost: r,
								layout: e,
								post: a[n]
							})
						})
					}
					return !1
				}
				scrollChildForPost(e, t, s, n) {
					const {
						currentProfileName: a,
						isCommentPermalink: o,
						isCommentsPage: r,
						isFrontpage: i,
						isProfilePostListing: c,
						listingKey: l,
						listingName: m,
						pageLayer: u,
						pageReferrer: b,
						postClickEvent: h,
						redditStyle: g
					} = this.props, x = 0 === t, f = s ? "last-index" : "", v = "post-".concat(n, "-").concat(e, "-").concat(t, "-").concat(f, "-").concat(m, "-").concat(l, "-").concat(b);
					let C;
					if (void 0 === (C = this.scrollChildCache.get(v))) {
						const {
							inSubredditOrProfile: f,
							postsById: O
						} = this.props, j = O[e], k = j.crosspostRootId && O[j.crosspostRootId] ? O[j.crosspostRootId] : j;
						j.crosspostRootId && !O[j.crosspostRootId] && E.c.withScope(e => {
							e.setExtra("errorType", p.p.API), e.setExtra("description", "Post ".concat(j.id, " is crosspost of ").concat(j.crosspostRootId, ", but ") + "".concat(j.crosspostRootId, " details are missing in the state")), E.c.captureMessage("Crosspost parent details are missing")
						});
						const w = this.props.postComponentForLayout({
								isCrosspost: !!j.crosspostRootId,
								isFirstPost: x,
								layout: n,
								post: k
							}),
							S = "post-list-item-[layout: ".concat(n, "]-[postId: ").concat(e, "]"),
							N = V(e, n, s, l, m, b, this.props, t),
							_ = z(e, n, this.props, t),
							I = K(e, this.props),
							P = k.media && k.media.type === T.n.EMBED ? k.media.provider : null;
						C = {
							estHeight: Q(j, n),
							id: e,
							isFocusable: !(!k.media || n !== y.g.Large) && (T.d.has(k.media.type) && (!P || !T.q.has(P)) && !k.isSpoiler && !k.isNSFW),
							trackOnEnteredViewport: N,
							trackOnExitedViewport: _,
							render: t => {
								let {
									className: n,
									height: p,
									width: b,
									remeasure: E,
									setScrollerChildRef: v,
									shouldLoadInitially: C
								} = t;
								return d.a.createElement(w, {
									className: n,
									currentProfileName: a,
									key: S,
									availableWidth: b,
									eventFactory: h,
									first: x,
									forceLoadMedia: C,
									inSubredditOrProfile: f,
									isCommentPermalink: o,
									isCommentsPage: r,
									isFrontpage: i,
									isProfilePostListing: c,
									listingKey: l,
									listingName: m,
									pageLayer: u,
									last: s,
									onClickPost: I,
									onSizeChanged: E,
									postId: e,
									redditStyle: g,
									sendEvent: this.props.sendEvent,
									scrollerItemRef: v
								})
							}
						}, this.scrollChildCache.set(v, C)
					}
					return C
				}
				render() {
					return this.hasPosts() ? (this.renderingEmpty = !1, this.renderingPlaceholder = !1, this.renderList()) : this.showPlaceholder() ? (this.renderingEmpty = !1, this.renderingPlaceholder = !0, this.renderPlaceholder()) : (this.renderingEmpty = !0, this.renderingPlaceholder = !1, this.renderEmpty())
				}
				renderEmpty() {
					const e = this.props.noPostsComponent;
					return d.a.createElement(e, null)
				}
				renderPlaceholder() {
					const {
						apiError: e,
						className: t,
						disablePlaceholder: s,
						layout: n,
						onTryAgain: a,
						postListPlaceholderComponent: o
					} = this.props;
					if (s) return;
					const r = o;
					return d.a.createElement("div", {
						className: L.a.placeholder
					}, d.a.createElement(r, {
						className: t,
						isLoading: !e,
						layout: n
					}), !!e && d.a.createElement(f.a, {
						apiError: e,
						onTryAgain: a
					}))
				}
				renderLoadMore() {
					const {
						apiError: e,
						apiPending: t,
						disablePlaceholder: s,
						layout: n,
						loadMoreClassName: a,
						onLoadMore: o
					} = this.props;
					if (!s) return d.a.createElement("div", {
						className: L.a.placeholder
					}, d.a.createElement(x.a, {
						className: a,
						isLoading: !!t,
						layout: n,
						countOverride: H[n]
					}), !!e && d.a.createElement(f.a, {
						apiError: e,
						onTryAgain: o
					}))
				}
				renderList() {
					const {
						scrollContentContainerRef: e,
						enableElementHiding: t,
						getScrollContainer: s,
						injectChildren: a,
						isTruncated: o,
						layout: r,
						location: i,
						loadMore: l,
						postIds: b,
						onLoadMore: h
					} = this.props;
					let g = b.map((e, t, s) => {
						const n = t === b.length - 1;
						return this.scrollChildForPost(e, t, n, r)
					});
					a && (g = G(g, a));
					const E = this.props.measureScrollFPS ? "post-listings-".concat(r) : void 0,
						x = i ? Object(n.e)(i) : null,
						f = x || o;
					return d.a.createElement(c.Fragment, null, d.a.createElement(v.b, {
						innerRef: this.updateScrollerRef,
						className: f ? L.a.truncatedPostList : Object(u.a)(L.a.postList, this.props.className),
						contentContainerRef: e,
						dataKey: this.props.listingKey,
						disableScrollCache: !0,
						getContainer: s,
						enableElementHiding: t,
						key: this.props.listingKey,
						layoutKey: this.props.layout,
						loadMoreToken: l && l.token ? l.token : void 0,
						onLastVisibleChildRendered: this.setLastVisibleChildRendered,
						onLoadMore: h,
						onScroll: this.onScrollPause,
						preventScrollOnMount: this.props.preventScrollOnMount,
						trackingName: E,
						viewportTopPadding: j.g
					}, g), x && d.a.createElement(W, {
						className: L.a.seeMoreButton
					}, d.a.createElement(k.a, {
						className: L.a.seeMorePostsText,
						to: Object(m.a)(x, {
							type: p.Kb.Posts
						})
					}, d.a.createElement(C.a, {
						msgId: "search.seeMorePosts"
					}), d.a.createElement(q, null))), this.isLoadingMore() && this.renderLoadMore())
				}
			}
			J.defaultProps = {
				enableElementHiding: !0,
				listingKey: "",
				listingName: "",
				listingViewed: () => () => ({}),
				noPostsComponent: d.a.Fragment
			}
		},
		"./src/reddit/components/PostModModeDropdown/DropdownHelpers.m.less": function(e, t, s) {
			e.exports = {
				ListContainer: "VHCAEHBEuD8bln8MDFl35",
				listContainer: "VHCAEHBEuD8bln8MDFl35",
				Icon: "_3WbGqnEpw_ds1P508Qawma",
				icon: "_3WbGqnEpw_ds1P508Qawma",
				DropdownRow: "x_9o8pHUgKrlsT51QhLnG",
				dropdownRow: "x_9o8pHUgKrlsT51QhLnG",
				CheckboxMenuItem: "_9csa2XobkeFZUX8Fc_FNY",
				checkboxMenuItem: "_9csa2XobkeFZUX8Fc_FNY"
			}
		},
		"./src/reddit/components/PostModModeDropdown/DropdownHelpers.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return p
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "g", (function() {
				return g
			})), s.d(t, "h", (function() {
				return E
			})), s.d(t, "b", (function() {
				return x
			})), s.d(t, "c", (function() {
				return f
			})), s.d(t, "d", (function() {
				return v
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/controls/CheckboxMenuItem/index.tsx"),
				o = s("./src/reddit/controls/Dropdown/Row.tsx"),
				r = s("./src/reddit/icons/fonts/Approve/index.tsx"),
				i = s("./src/reddit/icons/fonts/Lock/index.tsx"),
				c = s("./src/reddit/icons/fonts/Remove/index.tsx"),
				d = s("./src/reddit/icons/fonts/Spam/index.tsx"),
				l = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				m = s("./src/reddit/components/PostModModeDropdown/DropdownHelpers.m.less"),
				u = s.n(m);
			const p = n.a.wrapped(r.a, "Icon", u.a),
				b = n.a.wrapped(i.a, "Icon", u.a),
				h = n.a.wrapped(c.a, "Icon", u.a),
				g = n.a.wrapped(d.a, "Icon", u.a),
				E = n.a.wrapped(l.a, "Icon", u.a),
				x = n.a.wrapped(a.b, "CheckboxMenuItem", u.a),
				f = n.a.wrapped(o.b, "DropdownRow", u.a),
				v = n.a.div("ListContainer", u.a)
		},
		"./src/reddit/components/PostRailAndVotes/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/components/PostLeftRail/index.tsx"),
				r = s("./src/reddit/components/VerticalVotes/index.tsx"),
				i = s("./src/reddit/controls/Checkbox/index.tsx"),
				c = s("./src/reddit/helpers/isPost.ts"),
				d = s("./src/reddit/helpers/showReportIndicator/index.ts");
			t.a = e => {
				const {
					model: t,
					handleVote: s,
					showBulkActionCheckbox: n = !1,
					isCheckboxSelected: l = !1,
					toggleCheckbox: m = (() => {}),
					flairStyleTemplate: u,
					redditStyle: p
				} = e, b = "upvote-button-".concat(t.id);
				return a.a.createElement(o.b, {
					isRemoved: !!t.bannedBy,
					isReported: Object(d.a)(t),
					isSponsored: !!Object(c.b)(t) && t.isSponsored,
					redditStyle: p
				}, n && a.a.createElement(i.a, {
					isCheckboxSelected: l,
					toggleCheckbox: m
				}), a.a.createElement(r.a, {
					flairStyleTemplate: u,
					model: t,
					onVoteClick: s,
					redditStyle: p,
					upvoteTooltipId: b
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/config.ts"),
				c = s("./src/lib/prettyPrintNumber/index.ts"),
				d = s("./src/reddit/selectors/experiments/goldProfileGildedAwards.ts"),
				l = s("./src/reddit/i18n/components.tsx"),
				m = s("./src/reddit/components/ProfileIdCard/index.m.less"),
				u = s.n(m);
			const p = Object(r.c)({
				isInGoldProfileGildedExperiment: d.a
			});
			class b extends a.a.PureComponent {
				render() {
					const {
						isInGoldProfileGildedExperiment: e,
						recentAwardings: t,
						username: s
					} = this.props;
					if (!t.topAward) return null;
					const {
						topAward: n,
						totalCount: o
					} = t, r = n.icon32 ? n.icon32.url : n.icon.url, d = n.description ? n.description : n.name;
					return a.a.createElement("a", {
						className: u.a.AwardedLastMonth,
						href: e ? "/user/".concat(s, "/gilded") : "".concat(i.a.oldRedditUrl, "/user/").concat(s, "/gilded")
					}, a.a.createElement("div", {
						className: u.a.iconColumn
					}, a.a.createElement("img", {
						alt: d,
						className: u.a.icon,
						src: r
					}), o > 1 && a.a.createElement("span", {
						className: u.a.count
					}, "+".concat(Object(c.b)(o - 1)))), a.a.createElement("div", {
						className: u.a.textColumn
					}, o > 1 ? a.a.createElement(l.c, null, "Received the ", a.a.createElement(l.b, {
						name: "award-name"
					}, n.name), " Award and more in the past 30 days") : a.a.createElement(l.c, null, "Received the ", a.a.createElement(l.b, {
						name: "award-name"
					}, n.name), " Award in the past 30 days")))
				}
			}
			t.a = Object(o.b)(p)(b)
		},
		"./src/reddit/components/ProfileIdCard/index.m.less": function(e, t, s) {
			e.exports = {
				SnooIconWrapper: "_308WM6C-yV5iwS0Iy8nOfI",
				snooIconWrapper: "_308WM6C-yV5iwS0Iy8nOfI",
				actionItem: "_1l7CTV4NjDjmzX8DiiSgTL",
				AwardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				awardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				textColumn: "_wi1DtT7oN7k_x5oIV8zm",
				iconColumn: "_32tzMaZn7x3dfQC5MXndJn",
				icon: "_12jN4wdttUosp76WHzuieI",
				count: "_6xPPP5HdELF-SZJL8layH",
				awardIcon: "_2Eq8z6UD7I0ul3wnZ-YT80",
				adminIcon: "_1sNQxemH_0rq1jtZAMyAZd",
				button: "_2q1wcTx60QKM_bQ1Maev7b"
			}
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, s) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/ProgressBar/index.m.less"),
				i = s.n(r);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: s,
					percent: n
				} = e;
				return a.a.createElement("div", {
					className: Object(o.a)(i.a.outerBar, t)
				}, a.a.createElement("div", {
					className: Object(o.a)(i.a.innerBar, s),
					style: {
						width: "".concat(n.toFixed(2), "%")
					}
				}))
			}
		},
		"./src/reddit/components/RawHTMLDisplay/Listing.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				r = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				i = s("./src/reddit/components/RawHTMLDisplay/index.tsx");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(o.a)(e => a.a.createElement(i.a, c({
				style: {
					color: Object(r.a)(e).post
				}
			}, e)))
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less": function(e, t, s) {
			e.exports = {
				DisplayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				displayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				DropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				dropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				ReasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				reasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				Dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				DropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				dropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				DropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				dropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				DropdownContainer: "_33sg6HoBYll4rCDqRzRUdu",
				dropdownContainer: "_33sg6HoBYll4rCDqRzRUdu"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less": function(e, t, s) {
			e.exports = {
				CharacterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				characterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				EmptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				emptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				ModNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				modNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				PrimaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				primaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				RadioOption: "_30JuaHooKBU-I9UQwxEwhL",
				radioOption: "_30JuaHooKBU-I9UQwxEwhL",
				BoldText: "_22_ggqyuhsjDD3F2auyNjc",
				boldText: "_22_ggqyuhsjDD3F2auyNjc",
				ModNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				modNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				MessageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				messageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				Info: "_3Bf1PCbZnJJBM391IWRv8D",
				info: "_3Bf1PCbZnJJBM391IWRv8D",
				SmallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				smallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				FormOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				formOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				ModalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				modalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				FooterRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				footerRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				ButtonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				buttonRow: "_3zZmX0EjloIkzwt2-sRI2_"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/higherOrderComponents/asModal/index.tsx"),
				c = s("./src/lib/lessComponent.tsx"),
				d = s("./src/reddit/actions/removalReasons/index.ts"),
				l = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = s("./src/reddit/controls/Button/index.tsx"),
				p = s("./src/reddit/controls/InternalLink/index.tsx"),
				b = s("./src/reddit/controls/RadioInput/index.tsx"),
				h = s("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				g = s("./src/reddit/controls/TextButton/index.tsx"),
				E = s("./src/reddit/i18n/utils.ts"),
				x = s("./src/reddit/icons/fonts/Info/index.tsx"),
				f = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				v = s("./src/reddit/models/RemovalReason/index.ts"),
				C = s("./src/reddit/selectors/removalReasons.ts"),
				O = s("./src/reddit/selectors/subreddit.ts"),
				j = s("./src/reddit/selectors/user.ts"),
				y = s("./src/reddit/controls/Dropdown/index.tsx"),
				k = s("./src/reddit/controls/Dropdown/Row.tsx"),
				w = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				S = s("./src/reddit/layout/row/Inline/index.tsx"),
				N = s("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less"),
				T = s.n(N);
			const _ = c.a.wrapped(S.a, "DisplayContainer", T.a),
				I = c.a.div("DropdownLabel", T.a),
				P = c.a.div("ReasonTitle", T.a),
				M = e => a.a.createElement(_, null, a.a.createElement(I, null, e.dropdownLabel), e.selectedReason && a.a.createElement(P, null, e.selectedReason)),
				R = c.a.wrapped(y.a, "Dropdown", T.a),
				L = c.a.wrapped(w.b, "DropdownTriangle", T.a),
				D = c.a.wrapped(k.b, "DropdownRow", T.a),
				A = c.a.button("DropdownContainer", T.a);
			var F = e => a.a.createElement(A, {
					onClick: e.onToggleDropdown
				}, a.a.createElement(M, {
					dropdownLabel: e.isLoading ? Object(E.c)("Loading...") : Object(E.c)("Reason for removal"),
					selectedReason: e.selectedReason ? e.selectedReason.title : null
				}), a.a.createElement(L, null), e.isDropdownOpen && a.a.createElement(R, {
					isOverlay: !0
				}, a.a.createElement(D, {
					displayText: Object(E.c)("None"),
					onClick: () => e.onSelectReason(null)
				}), e.subredditRemovalReasons.map((t, s) => a.a.createElement(D, {
					displayText: "".concat(s + 1, ". ").concat(t.title),
					onClick: () => e.onSelectReason(t)
				})))),
				B = s("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less"),
				U = s.n(B);
			const H = e => {
					switch (e) {
						case v.f.Private:
							return "private_subreddit";
						case v.f.PrivateExposed:
							return "private_personal";
						default:
							return e
					}
				},
				W = {
					isDropdownOpen: !1,
					message: "",
					modNote: "",
					removalType: v.f.Public,
					selectedReason: null
				},
				q = Object(r.c)({
					currentUserName: e => {
						const t = Object(j.i)(e);
						if (t) return t.displayText
					},
					isLoading: C.a,
					removalReasons: C.c,
					subredditName: (e, t) => {
						let {
							subredditId: s
						} = t;
						return Object(O.S)(e, {
							subredditId: s
						}).name
					}
				}),
				V = Object(o.b)(q, e => ({
					submitBulkRemovalReason: (t, s, n, a, o) => e(Object(d.submitBulkRemovalReason)(t, s, n, a, o)),
					submitRemovalReason: (t, s, n, a, o) => e(Object(d.submitRemovalReason)(t, s, n, a, o))
				})),
				z = c.a.wrapped(l.a, "CharacterCountdown", U.a),
				K = c.a.div("EmptyState", U.a),
				Q = c.a.wrapped(m.l, "ModNoteDescription", U.a),
				G = c.a.wrapped(u.f, "PrimaryButton", U.a),
				J = c.a.wrapped(h.a, "RadioOption", U.a),
				Z = c.a.span("BoldText", U.a),
				X = c.a.wrapped(m.q, "ModNoteInput", U.a),
				Y = c.a.wrapped(m.q, "MessageInput", U.a),
				$ = c.a.wrapped(x.a, "Info", U.a),
				ee = c.a.div("SmallInfoText", U.a),
				te = c.a.div("FormOptionsContainer", U.a),
				se = c.a.wrapped(m.e, "ModalFooter", U.a),
				ne = c.a.div("FooterRow", U.a),
				ae = c.a.wrapped(ne, "ButtonRow", U.a);
			class oe extends a.a.Component {
				constructor(e) {
					super(e), this.onSelectRemovalType = e => {
						this.setState({
							removalType: e
						}), this.props.trackClick("type_".concat(H(e)))()
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onUpdateModNote = e => {
						this.setState({
							modNote: e.currentTarget.value
						})
					}, this.handleToggleDropdown = () => this.setState({
						isDropdownOpen: !this.state.isDropdownOpen
					}), this.closeDropdown = () => {
						this.state.isDropdownOpen && this.setState({
							isDropdownOpen: !1
						})
					}, this.onSelectReason = e => {
						this.setState({
							selectedReason: e
						}), this.props.trackClick("reason")(), e && this.setState({
							message: e.message
						}), this.closeDropdown()
					}, this.canSave = () => !(this.state.message.length > v.a || this.state.modNote.length > v.b) && (this.state.selectedReason ? this.state.message.trim().length > 0 : this.state.modNote.trim().length > 0), this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.canSave()) {
							(t.removalContextType === v.e.Bulk ? e.submitBulkRemovalReason : e.submitRemovalReason)(e.itemIds, t.selectedReason, t.message.trim(), t.removalType, t.modNote.trim()), e.trackClick("sent")(), t.selectedReason && e.trackClick("sent_".concat(H(t.removalType)))(), t.modNote && e.trackClick("sent_modnote")(), e.toggleModal()
						}
					}, this.onCancel = () => {
						this.props.toggleModal(), this.props.trackClick("cancel")()
					}, this.renderRemovalTypeOptions = () => {
						const {
							props: e,
							state: t
						} = this, s = [];
						return t.removalContextType !== v.e.Bulk && s.push(a.a.createElement(J, {
							key: v.f.Public,
							showButton: !0,
							tabIndex: 0,
							value: v.f.Public
						}, a.a.createElement("div", null, t.removalContextType === v.e.Post ? Object(E.c)("Public: Write a sticky comment on the post") : Object(E.c)("Public: Write a reply to the comment")))), s.push(a.a.createElement(J, {
							key: v.f.Private,
							showButton: !0,
							tabIndex: 0,
							value: v.f.Private
						}, a.a.createElement("div", null, Object(E.c)("Private: send a Modmail from"), a.a.createElement(Z, null, " r/".concat(e.subredditName, " ")), Object(E.c)("to the user")))), e.currentUserName && s.push(a.a.createElement(J, {
							key: v.f.PrivateExposed,
							showButton: !0,
							tabIndex: 0,
							value: v.f.PrivateExposed
						}, a.a.createElement("div", null, Object(E.c)("Private: send a Modmail from"), a.a.createElement(Z, null, " u/".concat(e.currentUserName, " ")), Object(E.c)("to the user")))), s
					}, this.state = Object.assign({}, W, {
						removalContextType: Object(v.g)(e.itemIds)
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(m.c, {
						onClick: this.closeDropdown
					}, e.isLoading || e.removalReasons.length > 0 && a.a.createElement(m.g, null, a.a.createElement(f.a, null, a.a.createElement(m.n, null, Object(E.c)("Add a removal reason"), e.itemIds.length > 1 && " (".concat(e.itemIds.length, " posts/comments)")), a.a.createElement(g.a, {
						onClick: this.onCancel
					}, a.a.createElement(m.b, null)))), a.a.createElement(m.j, null, e.isLoading || e.removalReasons.length > 0 ? a.a.createElement(F, {
						isDropdownOpen: t.isDropdownOpen,
						isLoading: e.isLoading,
						onSelectReason: this.onSelectReason,
						onToggleDropdown: this.handleToggleDropdown,
						selectedReason: t.selectedReason,
						subredditRemovalReasons: e.removalReasons
					}) : a.a.createElement(K, null, Object(E.c)("You don't have any removal reasons yet"), a.a.createElement(p.a, {
						to: "/r/".concat(e.subredditName, "/about/removal"),
						target: "_blank"
					}, a.a.createElement(u.n, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Object(E.c)("Add a removal reason")))), t.selectedReason && a.a.createElement(te, null, a.a.createElement(m.f, null, a.a.createElement(b.a, {
						name: "REMOVAL_REASON_INPUT",
						onChange: this.onSelectRemovalType,
						children: this.renderRemovalTypeOptions(),
						value: t.removalType
					})), a.a.createElement(Y, {
						value: t.message,
						onChange: this.onMessageInputChange
					}), a.a.createElement(z, {
						maxChars: v.a,
						text: t.message.trim()
					}), a.a.createElement(ee, null, t.removalType !== v.f.Public && a.a.createElement(a.a.Fragment, null, a.a.createElement($, null), Object(E.c)("A link to the removed content will be appended to your message"))))), a.a.createElement(se, null, a.a.createElement(ne, null, a.a.createElement(Q, null, Object(E.c)("Mod note (Only mods will see this note)"))), a.a.createElement(ne, null, a.a.createElement(X, {
						placeholder: Object(E.c)("This is a short note to your mod team on why the content was removed."),
						value: t.modNote,
						onChange: this.onUpdateModNote
					})), a.a.createElement(ne, null, a.a.createElement(z, {
						maxChars: v.b,
						text: t.modNote.trim()
					})), a.a.createElement(ae, null, a.a.createElement(u.i, {
						onClick: this.onCancel,
						"data-redditstyle": !0
					}, Object(E.c)("Cancel")), a.a.createElement(G, {
						onClick: this.onSubmit,
						disabled: !this.canSave(),
						"data-redditstyle": !0
					}, Object(E.c)("Submit")))))
				}
			}
			t.default = Object(i.a)(V(oe))
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less": function(e, t, s) {
			e.exports = {
				GenericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				genericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				DeleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				deleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				PrimaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				primaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				TextArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				textArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				ModalFooter: "a8KANZ6wvta1y_8QSZmeS",
				modalFooter: "a8KANZ6wvta1y_8QSZmeS",
				Input: "tWupUgopHVvjD9_bZZVy0",
				input: "tWupUgopHVvjD9_bZZVy0"
			}
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less": function(e, t, s) {
			e.exports = {
				EditButton: "_3Z3niHttcaJCxThBE2-eNN",
				editButton: "_3Z3niHttcaJCxThBE2-eNN",
				Row: "_1ERpdeakuaRdyW5OEGvV_a",
				row: "_1ERpdeakuaRdyW5OEGvV_a",
				ReasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				reasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				ReasonText: "_3Vv7n3XK-P5uslyAy7Li0w",
				reasonText: "_3Vv7n3XK-P5uslyAy7Li0w"
			}
		},
		"./src/reddit/components/RemovalReasons/index.m.less": function(e, t, s) {
			e.exports = {
				Rules: "-z_XjylM-4VxXIVlUJupm",
				rules: "-z_XjylM-4VxXIVlUJupm"
			}
		},
		"./src/reddit/components/ResizableAutosizeTextarea/index.m.less": function(e, t, s) {
			e.exports = {
				editorWrapper: "VBa-xDMEbFi3vsO4id4OC",
				textareaAutosize: "_6Ej82J4aTDK36LLOcpFbC",
				mIsFullHeight: "aZb6a46diyLdUQJynW3aD"
			}
		},
		"./src/reddit/components/ResizableAutosizeTextarea/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-autosize-textarea/lib/index.js"),
				r = s.n(o),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/components/ResizableAutosizeTextarea/index.m.less"),
				d = s.n(c);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var m = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const u = e => {
					let {
						className: t,
						children: s,
						editorWrapperRef: n,
						initialHeight: o
					} = e;
					return a.a.createElement("div", {
						className: Object(i.a)(d.a.editorWrapper, t),
						style: o ? {
							height: o
						} : void 0,
						ref: n
					}, s)
				},
				p = e => {
					var {
						isFullHeight: t,
						textAreaRef: s
					} = e, n = m(e, ["isFullHeight", "textAreaRef"]);
					return a.a.createElement(r.a, l({
						className: Object(i.a)(d.a.textareaAutosize, {
							[d.a.mIsFullHeight]: t
						}),
						innerRef: s
					}, n))
				};
			class b extends a.a.Component {
				constructor(e) {
					super(e), this.editorHeight = null, this.editorRef = null, this.editorStyleMutationObserver = null, this.onEditorStyleChanged = () => {
						if (!this.editorRef) return;
						const {
							isResized: e
						} = this.state;
						e || this.setState({
							isResized: !0
						});
						const t = this.editorRef.style.height ? Number.parseInt(this.editorRef.style.height) : null;
						this.editorHeight !== t && (this.editorHeight = t, t && this.props.onEditorResize && this.props.onEditorResize(t))
					}, this.setEditorWrapperRef = e => this.editorRef = e, this.state = {
						initialHeight: e.initialHeight,
						isResized: !!e.initialHeight
					}
				}
				componentDidMount() {
					this.editorRef && (this.editorStyleMutationObserver = new MutationObserver(this.onEditorStyleChanged), this.editorStyleMutationObserver.observe(this.editorRef, {
						attributes: !0,
						attributeFilter: ["style"]
					}))
				}
				componentWillUnmount() {
					this.editorStyleMutationObserver && (this.editorStyleMutationObserver.disconnect(), this.editorStyleMutationObserver = null)
				}
				render() {
					const e = this.props,
						{
							className: t,
							initialHeight: s,
							innerRef: n,
							onEditorResize: o
						} = e,
						r = m(e, ["className", "initialHeight", "innerRef", "onEditorResize"]),
						{
							isResized: i
						} = this.state;
					return a.a.createElement(u, {
						className: t,
						editorWrapperRef: this.setEditorWrapperRef,
						initialHeight: s
					}, a.a.createElement(p, l({}, r, {
						children: !0,
						isFullHeight: !!i,
						textAreaRef: n
					})))
				}
			}
			t.a = b
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, s) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				c = s.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			t.a = r.a.wrapped(e => {
				const {
					children: t,
					className: s,
					renderBelow: n,
					text: r,
					tooltipContentClass: i
				} = e, m = l(e, ["children", "className", "renderBelow", "text", "tooltipContentClass"]);
				return a.a.createElement("div", d({}, m, {
					className: Object(o.a)(c.a.container, s)
				}), r ? a.a.createElement("div", {
					className: Object(o.a)(c.a.tooltip, i, n ? c.a.below : c.a.above)
				}, r) : null, t)
			}, "HoverTooltip", c.a)
		},
		"./src/reddit/components/SaveIndicator/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_13ubiSSjUBWaeyJM-itH7X",
				titleFontH2: "_2V4_0G0gJO4R1v-_sO5D_j",
				titleFontH3: "_32Uo9qgINsZX5CSOtFM0e2",
				titleFontH4: "_2AWEwOuuK5wBnQGyiB5sSq",
				titleFontH5: "_8460KZXLwbKYkuLfDNr_-",
				titleFontH6: "_7GhKEQrcNu3JuSHqj9pJc",
				metadataFont: "qilOmvvpr4iY8iiHxuV5Y",
				flairFont: "SovT7HaLHcqz1BM9MWXPA",
				labelsFont: "_3Ngpaj84VwPqy3s6Tr3GEJ",
				actionFont: "_3RLwRjy5tGM8nl4kID8Tfg",
				smallButtonFont: "nb_OfRzzHKNkGteZC-TyY",
				largeButtonFont: "_2fhzAdDCEdDseFevwE6mBQ",
				tabFont: "_3E-egg7Cy7bL6JzsZuFTcn",
				strongTextFont: "_2vvi6WI_4yX2H2H-b2aBCF",
				extraSmallFont: "_184pJ8mtAMSFdkEH49LLrY",
				bodyFontH1: "_2_nWm6krUlDJnEF9pk7xNK",
				bodyFontH2: "_3zzd4vTmfrG1aK91i6m2j9",
				bodyFontH3: "_3tFwmsoGmyp52EFCoZ0GCV",
				bodyFontH4: "MdKdTVjxUaPPkDvG_msXr",
				bodyFontH5: "_2dNFOZceckCrwGYG8Avi-k",
				bodyFontH6: "_3sSb6LvOgvwy7eawwX4Gtq",
				bodyFont: "_2fiuzofxgtB6yu9nAHLuqW",
				bodyFontSmall: "_2IcqO4djjAVsOalbW_Zpa9",
				bodyFontMono: "_2i_EmKzaFJfCskmkHdmmgJ",
				icon: "cO908rcinWKz894i8I5jJ",
				pendingIcon: "U2dgL2i9_EJN8R_MLFTjS",
				savedIcon: "_1iGcF7LdvT-OMRgF7xKWqm",
				saveErrorIcon: "kWS-87C-v-iTlGGxQOmxu",
				caption: "_1MAESVWNqu44JbWmHGJsuI"
			}
		},
		"./src/reddit/components/ScheduledPost/ControlRow/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_1xM2tjm8c7LuqnoEJG1Ws1",
				controlRow: "P7KCCrRfT4TO2wcnk_Kjv",
				controlRowItem: "_1AkGbjxtRpq3ZhKADdUTU3"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.m.less": function(e, t, s) {
			e.exports = {
				content: "_297_pyPlxmqBF0tLkUhTME",
				icon: "_1n_ojuNDT8JeH9DxmHJZt9",
				author: "_1k9D_vEsQ8odWCNERbDOxX",
				modIcon: "_3ryKOTfQ_vqgap0EZsZHAl",
				stickyIcon: "qfjbZcX6-FZK2BGrOXezD"
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.m.less": function(e, t, s) {
			e.exports = {
				title: "_3jA9JBnv4bqmmiAw3Akmug"
			}
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1YrhJ0z1RfTXg7jHYgApSr",
				error: "_2_f_ecVpbx4yoMzazJYkDP",
				retryButton: "_1KbjdUJVdbZQOJN8d6LTsX"
			}
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less": function(e, t, s) {
			e.exports = {
				container: "qDE3oDok1392-t8IDOBfk",
				clock: "_2sfIhl6E6vfZCwxx54EUNB",
				timeMetaData: "_3ZqmD_fQ-lxmvQJVOuIgP1"
			}
		},
		"./src/reddit/components/ScheduledPost/index.m.less": function(e, t, s) {
			e.exports = {
				body: "_320l2eVngsr4Ord9dXc2er",
				container: "_26zeT5d9JKXWbWzOT4ncpg",
				thumbnailContainer: "_2UwJRJuqEbkRCV8O6REq8h",
				mainBody: "_3pHV3zwe-Q9-xNEB0iM3WT",
				backgroundWrapper: "_2KWv8ukh9RMgpOturAiV9z",
				content: "hAQclO6xLNG3WDMgkywGo",
				flairList: "_1-tY_25z_pkhbFvUz2-AqS",
				Icon: "_3XIOnqmz8vxSaPmPEY11Wh",
				icon: "_3XIOnqmz8vxSaPmPEY11Wh"
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.m.less": function(e, t, s) {
			e.exports = {
				Component: "BotIImuktRA9aFAPP0O4Z",
				component: "BotIImuktRA9aFAPP0O4Z"
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/components/Settings/shared/SectionHeading.m.less"),
				a = s.n(n),
				o = s("./src/lib/lessComponent.tsx");
			t.a = o.a.h3("Component", a.a)
		},
		"./src/reddit/components/Settings/shared/Widgets.m.less": function(e, t, s) {
			e.exports = {
				Label: "asxizthf5kZpmoY27VBKd",
				label: "asxizthf5kZpmoY27VBKd",
				HoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				hoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				ControlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				controlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				TextContainer: "_3dLmvT0hpACHFxhncqzCOr",
				textContainer: "_3dLmvT0hpACHFxhncqzCOr",
				ActionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				actionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				Wrapper: "_2f63as5b5FASHMqGd5P1o0",
				wrapper: "_2f63as5b5FASHMqGd5P1o0",
				isCreateCommunity: "_38bDTwLcytTCF-174R0UXB",
				mColumn: "_1HH_g-CLQB1BPcqOhZcakt",
				mLast: "_3Lu6XJyVbSLDVKDx-wue2g",
				mIndent: "_2D65jEbgD16ae_sJ8BG4AD",
				mDisabled: "LvI7FSBTGgYo2skaf18Zv",
				Subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				Link: "oFObIzV6ZJDQuG09BXh8u",
				link: "oFObIzV6ZJDQuG09BXh8u",
				SubtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				subtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				LinkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				linkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				LinkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				linkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				ArrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				arrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				StyledFlair: "_1F2irboi-xRChkhyndP6ct",
				styledFlair: "_1F2irboi-xRChkhyndP6ct",
				SpoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				spoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				NSFWFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				nsfwFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				DropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				dropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				DropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				dropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				Row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				DropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				dropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				DescriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				descriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				Circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				RangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				rangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				RangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				rangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				Ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				TickText: "_1hEYjTFCxEu2ILobPvatAp",
				tickText: "_1hEYjTFCxEu2ILobPvatAp",
				PreSubText: "_2_hv6QgJ151j9WmCyETVfC",
				preSubText: "_2_hv6QgJ151j9WmCyETVfC",
				MultiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				multiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				ActionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				actionLinkContainer: "e4RehzaESS5nfk-O6pYoK"
			}
		},
		"./src/reddit/components/Settings/shared/Widgets.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "l", (function() {
				return D
			})), s.d(t, "i", (function() {
				return H
			})), s.d(t, "m", (function() {
				return q
			})), s.d(t, "j", (function() {
				return Q
			})), s.d(t, "k", (function() {
				return X
			})), s.d(t, "n", (function() {
				return Y
			})), s.d(t, "h", (function() {
				return ae
			})), s.d(t, "b", (function() {
				return oe
			})), s.d(t, "f", (function() {
				return re
			})), s.d(t, "a", (function() {
				return ie
			})), s.d(t, "d", (function() {
				return be
			})), s.d(t, "c", (function() {
				return he
			})), s.d(t, "e", (function() {
				return ge
			})), s.d(t, "g", (function() {
				return Ee
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js"), s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/actions/tooltip.ts"),
				d = s("./src/higherOrderComponents/asTooltip.tsx"),
				l = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = s("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				u = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				p = s("./src/reddit/controls/Dropdown/index.tsx"),
				b = s("./src/reddit/controls/Dropdown/Row.tsx"),
				h = s("./src/reddit/controls/FormFields/index.tsx"),
				g = s("./src/reddit/controls/ToggleSwitch/index.tsx"),
				E = s("./src/reddit/controls/Typography/index.tsx"),
				x = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				f = s("./src/reddit/icons/svgs/Circle/index.tsx"),
				v = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				C = s("./src/reddit/icons/svgs/OutboundLink/index.tsx"),
				O = s("./node_modules/lodash/range.js"),
				j = s.n(O),
				y = s("./src/reddit/controls/Button/index.tsx"),
				k = s("./src/reddit/layout/row/Inline/index.tsx"),
				w = s("./src/reddit/models/Flair/index.ts"),
				S = s("./src/reddit/selectors/tooltip.ts"),
				N = s("./src/reddit/components/Settings/shared/Widgets.m.less"),
				T = s.n(N),
				_ = s("./src/lib/lessComponent.tsx");

			function I() {
				return (I = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var P = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const M = Object(d.a)(p.a),
				R = _.a.wrapped(f.a, "Circle", T.a),
				L = _.a.h3("Label", T.a),
				D = _.a.wrapped(E.f, "Subtext", T.a),
				A = _.a.wrapped(m.a, "HoverTooltip", T.a),
				F = _.a.div("ControlContainer", T.a),
				B = _.a.div("TextContainer", T.a),
				U = _.a.div("ActionContainer", T.a),
				H = e => {
					var {
						className: t,
						direction: s,
						disabled: n,
						indent: o,
						last: r
					} = e, c = P(e, ["className", "direction", "disabled", "indent", "last"]);
					return a.a.createElement("div", I({}, c, {
						className: Object(i.a)(T.a.Wrapper, t, {
							[T.a.mColumn]: "column" === s,
							[T.a.mDisabled]: !!n,
							[T.a.mIndent]: !!o,
							[T.a.mLast]: !!r,
							[T.a.isCreateCommunity]: c.isCreateCommunity
						})
					}))
				},
				W = _.a.a("Link", T.a),
				q = _.a.wrapped(W, "SubtextLink", T.a),
				V = _.a.wrapped(C.a, "LinkIcon", T.a),
				z = _.a.button("LinkButton", T.a),
				K = _.a.wrapped(x.a, "ArrowRight", T.a),
				Q = e => a.a.createElement(H, {
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					isCreateCommunity: e.isCreateCommunity,
					last: e.last
				}, a.a.createElement(B, {
					className: e.textContainerClassName
				}, a.a.createElement(L, null, e.label, e.isRequired && a.a.createElement(R, null)), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, e.children)),
				G = _.a.div("StyledFlair", T.a),
				J = _.a.wrapped(G, "SpoilerFlair", T.a),
				Z = _.a.wrapped(G, "NSFWFlair", T.a),
				X = e => {
					switch (e.flair) {
						case w.f.Nsfw:
							return a.a.createElement(Z, null, "NSFW");
						case w.f.Spoiler:
							return a.a.createElement(J, null, "SPOILER");
						default:
							return null
					}
				},
				Y = e => a.a.createElement(H, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, a.a.createElement(B, null, a.a.createElement(k.a, null, a.a.createElement(L, null, e.label)), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, a.a.createElement(F, null, e.tooltip && a.a.createElement(A, {
					text: e.tooltip
				}), a.a.createElement(g.a, {
					on: e.on,
					onToggle: e.onClick,
					disabled: e.disabled
				})))),
				$ = _.a.input("RangeSliderInput", T.a),
				ee = _.a.div("RangeSlider", T.a),
				te = _.a.div("Ticks", T.a),
				se = _.a.div("TickText", T.a),
				ne = _.a.div("PreSubText", T.a),
				ae = e => a.a.createElement(H, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, a.a.createElement(B, {
					style: {
						flex: 5
					}
				}, a.a.createElement(k.a, null, a.a.createElement(L, null, e.label)), a.a.createElement(D, null, " ", a.a.createElement(ne, {
					style: {
						color: e.ticks[e.value].color
					}
				}, " ", e.ticks[e.value].text + ": ", " "), " ", e.subtext)), a.a.createElement(U, {
					style: {
						flex: 3,
						margin: "20px 20px 0 0"
					}
				}, a.a.createElement(ee, null, a.a.createElement($, {
					style: {
						background: "linear-gradient(to right, " + e.ticks[e.value].color + " " + e.value / e.max * 100 + "%,#C5C5C5 " + e.value / e.max * 100 + "%," + j()(Number(e.value) + 1, e.max + 1).map((t, s) => t === e.max ? "" : "#C5C5C5 " + (t / e.max * 100 - 1) + "%,#FFFFFF " + (t / e.max * 100 - 1) + "%,#FFFFFF " + t / e.max * 100 + "%,#C5C5C5 " + t / e.max * 100 + "%") + "#C5C5C5 100%)"
					},
					className: "range-slider-input",
					type: "range",
					min: e.min,
					max: e.max,
					step: e.step,
					value: e.value,
					onChange: e.onChange,
					onInput: e.onChange
				}), a.a.createElement(te, null, Object.keys(e.ticks).map((t, s) => a.a.createElement(se, {
					style: {
						color: t === e.value.toString() ? e.ticks[t].color : "#878A8C"
					}
				}, e.ticks[t].text)))))),
				oe = e => a.a.createElement(H, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, a.a.createElement(B, null, a.a.createElement(k.a, null, a.a.createElement(L, null, e.label)), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, a.a.createElement(F, null, a.a.createElement(y.i, {
					onClick: e.onClick
				}, e.actionText)))),
				re = e => a.a.createElement(H, {
					className: e.className,
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, a.a.createElement(B, null, a.a.createElement(W, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, e.label, a.a.createElement(V, null)), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, a.a.createElement(W, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, a.a.createElement(K, null)))),
				ie = e => a.a.createElement(H, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, a.a.createElement(B, null, a.a.createElement(z, {
					onClick: e.onClick
				}, e.label), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, a.a.createElement(z, {
					onClick: e.onClick
				}, a.a.createElement(K, null)))),
				ce = _.a.div("DropdownWrapper", T.a),
				de = _.a.wrapped(b.b, "DropdownRow", T.a),
				le = _.a.span("Row", T.a),
				me = _.a.wrapped(v.b, "DropdownTriangle", T.a),
				ue = _.a.div("DescriptionsRow", T.a),
				pe = Object(r.c)({
					isOpen: (e, t) => Object(S.b)(t.id)(e)
				}),
				be = Object(o.b)(pe, (e, t) => ({
					openDropdown: () => {
						e(Object(c.g)({
							tooltipId: t.id
						}))
					}
				}))(e => a.a.createElement(H, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, a.a.createElement(B, null, a.a.createElement(L, null, e.label), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, (e => a.a.createElement(ce, {
					onClick: e.openDropdown
				}, a.a.createElement(le, {
					id: "".concat("SettingDropdown--").concat(e.id)
				}, e.selected), a.a.createElement(me, null), a.a.createElement(M, {
					container: void 0,
					isOpen: e.isOpen,
					renderContentsHidden: !0,
					isOverlay: !1,
					tooltipId: "".concat("SettingDropdown--").concat(e.id)
				}, e.items.map((t, s) => a.a.createElement(de, {
					displayText: t,
					isSelected: e.selected === t,
					onClick: () => e.onClick(t),
					key: s
				}))), e.descriptions && a.a.createElement(ue, null, e.descriptions[e.items.indexOf(e.selected)])))(e)))),
				he = e => a.a.createElement(H, {
					className: e.className,
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, a.a.createElement(B, null, a.a.createElement(L, null, e.label), a.a.createElement(D, null, e.subtext)), a.a.createElement(U, null, e.children)),
				ge = e => a.a.createElement(Q, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, a.a.createElement(h.a, {
					disabled: !1,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					type: "text",
					value: e.value,
					onBlur: e.onBlur
				}), !e.hideCountdown && a.a.createElement(l.a, {
					maxChars: e.maxChars,
					text: e.value
				})),
				Ee = e => a.a.createElement(Q, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, a.a.createElement(u.i, {
					disabled: !1,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					rows: e.rows || 4,
					style: {
						marginBottom: e.isCreateCommunity ? "4px" : 0,
						resize: e.isCreateCommunity ? "vertical" : "both"
					},
					value: e.value,
					onBlur: e.onBlur
				}), a.a.createElement("div", {
					className: T.a.MultiLineInputSettingsBottomRow
				}, !e.hideCountdown && a.a.createElement(l.a, {
					maxChars: e.maxChars,
					text: e.value || ""
				}), !!e.actionLink && a.a.createElement("div", {
					className: T.a.ActionLinkContainer
				}, e.actionLink)))
		},
		"./src/reddit/components/Streaming/ModSettings/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_16pMBJPhtfeyyncMfo7aDr",
				topBar: "_1DEjdLJpmb7fufFzhwqQm0",
				contentContainer: "ZV-o_W-prpE7EI4zyZ1hr",
				formBody: "_3xfSWCFu_alfjEX12_hBAB"
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less": function(e, t, s) {
			e.exports = {
				StyledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				styledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				BreadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				breadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				BreadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe"
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/lessComponent.tsx"),
				r = s("./src/reddit/components/TrackingHelper/index.tsx"),
				i = s("./src/reddit/helpers/trackers/blade.ts"),
				c = s("./src/reddit/icons/svgs/Chevron/index.tsx"),
				d = s("./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less"),
				l = s.n(d);
			const m = o.a.wrapped(c.a, "StyledChevron", l.a),
				u = o.a.div("BreadcrumbElement", l.a),
				p = o.a.div("BreadcrumbContainer", l.a);
			t.b = Object(r.b)(e => a.a.createElement(p, null, e.breadcrumbs.map(t => a.a.createElement(u, {
				key: t.title,
				onClick: () => {
					e.sendEvent(Object(i.a)()), e.onNavigate(t)
				}
			}, a.a.createElement(m, null), t.title))))
		},
		"./src/reddit/components/StructuredStyles/ColorPicker/BaseColorPicker.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/polished/dist/polished.es.js"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = s("./src/reddit/helpers/isValidHexColor/index.ts"),
				d = s("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				l = s("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				m = s("./src/reddit/models/StructuredStyles/index.ts"),
				u = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				p = s("./src/reddit/components/StructuredStyles/ColorPicker/index.m.less"),
				b = s.n(p),
				h = s("./src/higherOrderComponents/makeAsync.tsx"),
				g = s("./src/lib/loadWithRetries/index.ts");
			const E = () => null;
			var x = Object(h.a)({
				ErrorComponent: E,
				getComponent: () => Object(g.a)(() => s.e("ColorPickerDropdown").then(s.bind(null, "./src/reddit/components/StructuredStyles/ColorPicker/_ColorPickerDropdown.tsx"))).then(e => e.default),
				LoadingComponent: E
			});
			const f = e => "#" === e[0] ? e : "#".concat(e),
				v = Object(i.a)(e => o.a.createElement("div", {
					className: Object(r.a)(b.a.DropdownColorSwatch, e.isTransparent && b.a.isTransparent),
					style: {
						backgroundColor: e.isTransparent ? Object(u.a)(e).body : e.color,
						fill: Object(n.h)(e.color)
					}
				}, e.isDropdownOpen ? o.a.createElement(l.a, {
					className: b.a.ChevronUp
				}) : o.a.createElement(d.a, {
					className: b.a.ChevronDown
				})));
			class C extends o.a.Component {
				constructor(e) {
					super(e), this.onChangeProp = e => {
						this.setState({
							value: e,
							inputValue: e
						}), this.props.onChange(e, !0)
					}, this.onChangeHexColor = e => {
						const {
							value: t
						} = e.currentTarget;
						if (this.setState({
								inputValue: t
							}), Object(c.b)(t, !0)) {
							const e = f(t);
							this.setState({
								value: e
							}), this.props.onChange(e, !1)
						}
					}, this.handleUseSystemColorPickerClicked = () => {
						this.props.onSystemInputOpened && this.props.onSystemInputOpened()
					};
					const {
						value: t
					} = e;
					this.state = {
						inputValue: t,
						value: t
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						value: e.value,
						inputValue: e.value
					})), !this.props.isDropdownOpen && e.isDropdownOpen && this.props.onColorPickerOpened && this.props.onColorPickerOpened()
				}
				componentWillUnmount() {
					this.props.isDropdownOpen && this.props.onToggleDropdown()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = e.containerId ? document.getElementById(e.containerId) : void 0;
					return o.a.createElement("div", {
						onClick: e.onToggleDropdown
					}, o.a.createElement(v, {
						color: e.value || m.d,
						isDropdownOpen: e.isDropdownOpen,
						isTransparent: e.includeTransparent && !e.value
					}), o.a.createElement(x, {
						container: s,
						inputValue: t.inputValue,
						includeTransparent: e.includeTransparent,
						isOpen: e.isDropdownOpen,
						language: e.language,
						onChangeHexColor: this.onChangeHexColor,
						onSelectColor: this.onChangeProp,
						onToggleDropdown: e.onToggleDropdown,
						onClickUseSystemColorPicker: this.handleUseSystemColorPickerClicked,
						tooltipId: e.tooltipId,
						tooltipPosition: e.dropdownPosition,
						value: t.value
					}))
				}
			}
			t.a = C
		},
		"./src/reddit/components/StructuredStyles/ColorPicker/index.m.less": function(e, t, s) {
			e.exports = {
				Inline: "C1u8RDjnECGK1LWfSsACT",
				inline: "C1u8RDjnECGK1LWfSsACT",
				ColorInput: "_11x--06UcYLDYS16wXb8-q",
				colorInput: "_11x--06UcYLDYS16wXb8-q",
				ColorSwatchContainer: "_1oW-7sYYlQS4GeHmj1ubBp",
				colorSwatchContainer: "_1oW-7sYYlQS4GeHmj1ubBp",
				ColorSwatchOption: "_35Suh6FFPv_wB32f8XV32",
				colorSwatchOption: "_35Suh6FFPv_wB32f8XV32",
				isTransparent: "WD7seokSY2Kgg9EUdkfox",
				isSelected: "Awb-CJoYiNZr5FUKWbmCQ",
				ColorSwatchPreview: "_2U2EDHI9LC1nsjVIA7rIV7",
				colorSwatchPreview: "_2U2EDHI9LC1nsjVIA7rIV7",
				HexColorInput: "_2J9PudeZtimxGXSP0A_G-l",
				hexColorInput: "_2J9PudeZtimxGXSP0A_G-l",
				isInvalid: "_1AtMqIr_4QichwnCYnGiCf",
				ErrorMarker: "_1niA4R0pkgQEg3RkfWiORi",
				errorMarker: "_1niA4R0pkgQEg3RkfWiORi",
				SectionTitle: "_2fiXR9OAoHzIVFLLcS7W8u",
				sectionTitle: "_2fiXR9OAoHzIVFLLcS7W8u",
				StyledLabel: "_3tm-97fb8noV8kwxNOON_9",
				styledLabel: "_3tm-97fb8noV8kwxNOON_9",
				ColorPickerDropdown: "_1i-ndNsTQtNr82sMJ0renj",
				colorPickerDropdown: "_1i-ndNsTQtNr82sMJ0renj",
				DropdownColorSwatch: "_2uwkPlP_LglpLTAm6dfFmd",
				dropdownColorSwatch: "_2uwkPlP_LglpLTAm6dfFmd",
				ChevronDown: "V07CUWayujZ6pmjzCKitD",
				chevronDown: "V07CUWayujZ6pmjzCKitD",
				ChevronUp: "_1PTgp4tTpJn4UDPY-Uo-e4",
				chevronUp: "_1PTgp4tTpJn4UDPY-Uo-e4"
			}
		},
		"./src/reddit/components/StructuredStyles/DragItem/index.m.less": function(e, t, s) {
			e.exports = {
				Grapple: "_1RWZwK3K1uM6lSH8uK5DdB",
				grapple: "_1RWZwK3K1uM6lSH8uK5DdB",
				LockIcon: "_1vzrWUGrBGAJS_EeyJ4Ct0",
				lockIcon: "_1vzrWUGrBGAJS_EeyJ4Ct0",
				ExpandLeft: "_10Jk0eCPxa9SanBQsJlfGa",
				expandLeft: "_10Jk0eCPxa9SanBQsJlfGa"
			}
		},
		"./src/reddit/components/StructuredStyles/DragItem/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/lessComponent.tsx"),
				r = s("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				i = s("./src/reddit/icons/svgs/Grapple/index.tsx"),
				c = s("./src/reddit/icons/svgs/Lock/index.tsx"),
				d = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				l = s("./src/reddit/components/StructuredStyles/DragItem/index.m.less"),
				m = s.n(l);
			const u = o.a.wrapped(i.a, "Grapple", m.a),
				p = o.a.wrapped(c.a, "LockIcon", m.a),
				b = o.a.wrapped(d.a, "ExpandLeft", m.a);
			t.a = e => a.a.createElement(r.a, {
				className: e.className,
				isDragging: e.isDragging,
				isOver: e.isOver,
				canDrop: e.canDrop,
				disabled: e.disabled
			}, a.a.createElement(b, null, e.children, e.disabled ? a.a.createElement(p, {
				className: e.iconClassName
			}) : a.a.createElement(u, {
				className: e.iconClassName
			})))
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.m.less": function(e, t, s) {
			e.exports = {
				ImageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				imageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				ImageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				imageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				ImageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				imageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				FileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				fileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				ContainerUploading: "rOyNUbZnjJvWxtyInd1T8",
				containerUploading: "rOyNUbZnjJvWxtyInd1T8",
				Label: "_2ZFG2IQMaso9iA14qjicA_",
				label: "_2ZFG2IQMaso9iA14qjicA_",
				isOver: "_1B5UKMPaEBX3HOKKEBfp7o",
				ImageInput: "_362HLUlCiz7UbtVPniNjjW",
				imageInput: "_362HLUlCiz7UbtVPniNjjW"
			}
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return v
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/connectors/connectToLanguage.ts"),
				c = s("./src/reddit/controls/FileDrop/index.tsx"),
				d = s("./src/reddit/controls/ImageInput/index.tsx"),
				l = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				m = s("./src/reddit/icons/svgs/ImageUpload/index.tsx"),
				u = s("./src/reddit/i18n/components.tsx"),
				p = s("./src/reddit/components/StructuredStyles/ImageUpload/index.m.less"),
				b = s.n(p);
			const h = r.a.wrapped(m.a, "ImageUploadIcon", b.a),
				g = r.a.div("ImageIconRow", b.a),
				E = r.a.div("ImageUploadText", b.a),
				x = r.a.wrapped(c.a, "FileDrop", b.a),
				f = r.a.div("ContainerUploading", b.a),
				v = Object(i.a)(e => a.a.createElement(f, {
					className: e.className
				}, a.a.createElement(g, null, a.a.createElement(l.a, {
					sizePx: 40,
					center: !0
				})), a.a.createElement(E, null, a.a.createElement(u.c, null, "Uploading...")))),
				C = r.a.label("Label", b.a);
			t.b = e => a.a.createElement(x, {
				className: e.className,
				onDrop: e.onChange,
				render: t => a.a.createElement(C, {
					className: Object(o.a)({
						[b.a.isOver]: t
					})
				}, a.a.createElement(g, null, a.a.createElement(h, null)), a.a.createElement(E, null, e.label), a.a.createElement(d.a, {
					className: b.a.ImageInput,
					name: e.name,
					value: e.value,
					onChange: e.onChange,
					multiple: e.multiple,
					tabIndex: e.tabIndex
				}))
			})
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less": function(e, t, s) {
			e.exports = {
				FormPage: "_9ZuQyDXhFth1qKJF4KNm8",
				formPage: "_9ZuQyDXhFth1qKJF4KNm8",
				HomePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				homePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				HomePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				homePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				HomePageGroup: "_306gA2lxjCHX44ssikUp3O",
				homePageGroup: "_306gA2lxjCHX44ssikUp3O",
				FormPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				formPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				FormPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				formPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				FormGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				formGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				FormGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				formGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				FormElement: "c5RWd-O3CYE-XSLdTyjtI",
				formElement: "c5RWd-O3CYE-XSLdTyjtI",
				FormGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				formGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				FormItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				formItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				FormElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				formElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				FormElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				formElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				FormElementError: "horIoLCod23xkzt7MmTpC",
				formElementError: "horIoLCod23xkzt7MmTpC",
				FormElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				formElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				FormListItem: "_2M7LQbQxH40ingJ9h9RslL",
				formListItem: "_2M7LQbQxH40ingJ9h9RslL"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.ts": function(e, t, s) {
			"use strict";
			s.d(t, "k", (function() {
				return r
			})), s.d(t, "p", (function() {
				return i
			})), s.d(t, "n", (function() {
				return c
			})), s.d(t, "o", (function() {
				return d
			})), s.d(t, "m", (function() {
				return l
			})), s.d(t, "l", (function() {
				return m
			})), s.d(t, "f", (function() {
				return u
			})), s.d(t, "h", (function() {
				return p
			})), s.d(t, "a", (function() {
				return b
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "i", (function() {
				return g
			})), s.d(t, "e", (function() {
				return E
			})), s.d(t, "b", (function() {
				return x
			})), s.d(t, "c", (function() {
				return f
			})), s.d(t, "d", (function() {
				return v
			})), s.d(t, "j", (function() {
				return C
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less"),
				o = s.n(a);
			const r = n.a.section("FormPage", o.a),
				i = n.a.h1("HomePageTitle", o.a),
				c = n.a.button("HomePageBreadcrumb", o.a),
				d = n.a.div("HomePageGroup", o.a),
				l = n.a.h1("FormPageTitle", o.a),
				m = n.a.div("FormPageSection", o.a),
				u = n.a.div("FormGroup", o.a),
				p = n.a.h2("FormGroupTitle", o.a),
				b = n.a.div("FormElement", o.a),
				h = n.a.div("FormGroupDescription", o.a),
				g = n.a.div("FormItem", o.a),
				E = n.a.h3("FormElementTitle", o.a),
				x = n.a.div("FormElementDescription", o.a),
				f = n.a.div("FormElementError", o.a),
				v = n.a.div("FormElementSubGroup", o.a),
				C = n.a.li("FormListItem", o.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less": function(e, t, s) {
			e.exports = {
				ModalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				modalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				Input: "_1BJV17HgWhhC-BxrpqGjM",
				input: "_1BJV17HgWhhC-BxrpqGjM",
				iconStyles: "_349rJ1BueyeldYiZniwYOz",
				RadioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				radioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				RadioOff: "_23-RdhX276B0bg5nrt0cpf",
				radioOff: "_23-RdhX276B0bg5nrt0cpf",
				Checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				CheckboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				checkboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				Textarea: "_2gchCc4pmLk-CHEErYmFaP",
				textarea: "_2gchCc4pmLk-CHEErYmFaP",
				StyledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				styledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				StyledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN",
				styledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return m
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "f", (function() {
				return p
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "a", (function() {
				return h
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "h", (function() {
				return x
			})), s.d(t, "g", (function() {
				return f
			}));
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/controls/Input/ModalInput.tsx"),
				o = s("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				r = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				i = s("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				c = s("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				d = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less"),
				l = s.n(d);
			const m = n.a.wrapped(a.a, "ModalInput", l.a),
				u = n.a.input("Input", l.a),
				p = n.a.wrapped(c.a, "RadioOn", l.a),
				b = n.a.wrapped(i.a, "RadioOff", l.a),
				h = n.a.wrapped(o.a, "Checkbox", l.a),
				g = n.a.wrapped(r.a, "CheckboxSelected", l.a),
				E = n.a.textarea("Textarea", l.a),
				x = n.a.label("StyledLabel", l.a),
				f = n.a.input("StyledFileInput", l.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, s) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return l
			})), s.d(t, "a", (function() {
				return m
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				i = s.n(r);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var d = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const l = e => {
					var {
						disabled: t
					} = e, s = d(e, ["disabled"]);
					return a.a.createElement("div", c({}, s, {
						className: Object(o.a)(i.a.FormNavElement, {
							[i.a.disabled]: t
						})
					}), s.children)
				},
				m = e => {
					var {
						canDrop: t,
						className: s,
						isDragging: n,
						isOver: r,
						disabled: l
					} = e, m = d(e, ["canDrop", "className", "isDragging", "isOver", "disabled"]);
					return a.a.createElement("div", c({}, m, {
						className: Object(o.a)(i.a.DragCard, {
							[i.a.disabled]: l,
							[i.a.isDraffing]: n,
							[i.a.isOverAndCanDrop]: r && t
						}, s)
					}))
				}
		},
		"./src/reddit/components/StructuredStyles/UploadedImage/index.m.less": function(e, t, s) {
			e.exports = {
				TrashIcon: "_369jaOfOFcc4zl3BotOKV0",
				trashIcon: "_369jaOfOFcc4zl3BotOKV0",
				BottomRow: "_3wDzoF7M_TFAMlJ37cLSkW",
				bottomRow: "_3wDzoF7M_TFAMlJ37cLSkW",
				isHiding: "_3IxVc-07C4GUtQhhxc8MI0",
				imageDisplay: "_6FUPzkTsqrEot5SsYJeha",
				ErrorText: "_3ctJAQq7nR8klJsurOmHQg",
				errorText: "_3ctJAQq7nR8klJsurOmHQg"
			}
		},
		"./src/reddit/components/StructuredStyles/UploadedImage/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return g
			})), s.d(t, "d", (function() {
				return E
			})), s.d(t, "a", (function() {
				return x
			})), s.d(t, "b", (function() {
				return f
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/i18n/utils.ts"),
				i = s("./src/reddit/models/Image/index.tsx"),
				c = s("./src/reddit/components/Media/LoadingIcon/index.tsx"),
				d = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				l = s("./src/reddit/controls/ImageDisplay/index.tsx"),
				m = s("./src/reddit/controls/TextButton/index.tsx"),
				u = s("./src/reddit/icons/svgs/Trash/index.tsx"),
				p = s("./src/reddit/components/StructuredStyles/UploadedImage/index.m.less"),
				b = s.n(p),
				h = s("./src/lib/lessComponent.tsx");
			const g = c.a,
				E = h.a.wrapped(u.a, "TrashIcon", b.a),
				x = e => a.a.createElement("div", {
					className: Object(o.a)(b.a.BottomRow, {
						[b.a.isHiding]: e.isHiding
					})
				}, e.children),
				f = h.a.wrapped(d.c, "ErrorText", b.a);
			t.e = e => {
				const t = e.imageData && e.imageData.kind === i.b.FailedToUpload ? e.imageData.error : "",
					s = !t && e.imageData.kind === i.b.NotUploaded,
					n = e.isRequestInProgress && e.imageData.kind === i.b.TempUploaded,
					c = s || n;
				return a.a.createElement(l.a, {
					backgroundImage: e.imageData.url,
					className: Object(o.a)(e.className, b.a.imageDisplay)
				}, c && a.a.createElement(g, null), a.a.createElement(x, {
					isHiding: !!c
				}, t && a.a.createElement(f, null, Object(r.c)("Something went wrong")), a.a.createElement(m.a, {
					onClick: e.onRemove
				}, a.a.createElement(E, null))))
			}
		},
		"./src/reddit/components/SubredditContent/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1N366WahaKnCqUlSezl6CQ",
				titleFontH2: "_2ySCAslCokkxUasLc4m7l0",
				titleFontH3: "_3Na_u-vwpkuPZfuuvUROk-",
				titleFontH4: "_30jImFPUovcaQMWasU-Ohq",
				titleFontH5: "_1fkIEAH9a9eCt2B8XAaUbq",
				titleFontH6: "bHSjFLbSCNEywMorkTrqn",
				metadataFont: "_2Qe8DvvY_RxPEkj-mRpX65",
				flairFont: "_1TXuHKPD3YeZiCgMqyoBBe",
				labelsFont: "_1MiMOmZyBl0g5x8oLzodW8",
				actionFont: "_3USAKL0kbrc0ZhCvZS-J4j",
				smallButtonFont: "_2JaNUow_hy9X8yw0QFNOSg",
				largeButtonFont: "_2QdyaDMXRLLL3gChJ0NOE9",
				tabFont: "_1bq9fxhlMVaxA2GQdVomf4",
				strongTextFont: "_3qauH8UCZvDtHIr65uebN5",
				extraSmallFont: "_6sQQlcsD8mbHbQlhAEMft",
				bodyFontH1: "_2qU2oh77HnIxSqTey1ZezW",
				bodyFontH2: "_2XZkZ1zrfSvpi64O-KP4IB",
				bodyFontH3: "_1icF_z4wcZT687-ao6Mzr7",
				bodyFontH4: "ZRi07Zo9aba1n7XQY_Xio",
				bodyFontH5: "_1dhvcwu2KcypL8_En9Aa7I",
				bodyFontH6: "_1FGIk1pK7xZjRbWXhruioE",
				bodyFont: "_3xTpswgMylBeM6Y-XFNTUD",
				bodyFontSmall: "_3U8U5anYwaLfjJvSrrhIKo",
				bodyFontMono: "_1VL2XaMyhrq5PiMxCa8tkv",
				clockIcon: "_1prYFtcJNM7O7OVecg3B_b",
				schedulePostLink: "_3hO2emEyTZ-txWczRsI6lb",
				betaIndicator: "q9zqS5nIMgIr22a55zflg",
				pageTitle: "_2HS4U5X7Rt3fT__Kpgmp9M"
			}
		},
		"./src/reddit/components/SubredditModerationSearch/index.m.less": function(e, t, s) {
			e.exports = {
				SearchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				searchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				NoResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				noResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				Container: "_3RNapyf_4ZQOEfoJhVRMEO",
				container: "_3RNapyf_4ZQOEfoJhVRMEO",
				SearchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				searchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				SearchStatus: "uTK2QKUebu8hg0gYZWTI7",
				searchStatus: "uTK2QKUebu8hg0gYZWTI7",
				Bold: "_2u65S50DJfsU-z8bR0G2DQ",
				bold: "_2u65S50DJfsU-z8bR0G2DQ"
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.m.less": function(e, t, s) {
			e.exports = {
				topBarRow: "_3H6HwkSZ2zUC1pwaIMv-EY",
				searchIcon: "_1lo1uHsqx3-EkgYDL4xKEB",
				searchInput: "_1ox94KT4YX0mmZgLO51PG_",
				searchButton: "_3-3xbjG4pcuzlB7SzgBvzg"
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.m.less": function(e, t, s) {
			e.exports = {
				Row: "_2O5kmPXewMHlCcrRWrjEB_",
				row: "_2O5kmPXewMHlCcrRWrjEB_",
				Username: "_1sIhmckJjyRyuR_z7M5kbI",
				username: "_1sIhmckJjyRyuR_z7M5kbI",
				RightAlign: "_3f00u5KR-M4rdaonscLX8k",
				rightAlign: "_3f00u5KR-M4rdaonscLX8k",
				Description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				AdditionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				additionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				ChevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				chevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				ChevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				chevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				ExpandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				expandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				Bullet: "_1VQtDRh-JtZQghS8jetaHR",
				bullet: "_1VQtDRh-JtZQghS8jetaHR",
				PlaceholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				placeholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				EmptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				emptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				EmptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				emptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				UsersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg",
				usersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg"
			}
		},
		"./src/reddit/components/SubredditRules/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_1fQ3jmS7djNiAnk2kVsPko",
				titleFontH2: "_39dtESYDu10VI6hZlt8jT_",
				titleFontH3: "_2_Ya84laiZ_AK4zBLZeXmE",
				titleFontH4: "_2k9S2SK_mdrMw9dXzIJka3",
				titleFontH5: "_3hrj37O_iGAZk7ssKstspL",
				titleFontH6: "_2KYRCY7gyTJjBx_Vr5pjqd",
				metadataFont: "_2hHNLn3quM7R0Znfoal7Wi",
				flairFont: "KkD9-eQEXAm_GdJAbixZ5",
				labelsFont: "_1xgXWixwTrYRf6JjxPm7ft",
				actionFont: "_1HQtdMEzh4gag8do4e9j7Z",
				smallButtonFont: "zWcRyj2-0oiXHbpM-5L1A",
				largeButtonFont: "_2PIOcp6QTxVygtl2u9ji_a",
				tabFont: "UtQUA6_scmmMeiLaweTg2",
				strongTextFont: "_2adE8ldKa4w_dETRAs-vdP",
				extraSmallFont: "_3IZpwOEq3g8-lJDQSU4FIM",
				bodyFontH1: "_3lbK38dxFajKo78JrAEtIe",
				bodyFontH2: "_1CH0HVqZd3qMaT2gzU5mYn",
				bodyFontH3: "xk7ESbG2cmLPdln3D1fVi",
				bodyFontH4: "_29_oVfDyKoOggix5Gj6kah",
				bodyFontH5: "_1RoE8VrwOjvkyDDc-a8RZ_",
				bodyFontH6: "_3jwZ9V_jg7YZ4T-0cmGzxY",
				bodyFont: "_2iji_FM7kTNPRlaRGrPpq8",
				bodyFontSmall: "oJpqQ5hwA0NwwwlDu-EZH",
				bodyFontMono: "_2nUMbdZlQ1fQpJ_LaDNrbn",
				duplicateName: "_31Visb7b2S-tj09Ls_2Acy",
				emptyDetails: "_8PDfWWfcYPlmlmOr2Notr",
				emptyIcon: "_2tEWDkQudqJGiBAQsXSYXE",
				emptyRightIcon: "aF9GyLBXjDrRFO_7BTOYU",
				expandDetails: "_19etb4qzR1xpaHDy7AVdRr",
				header: "_2Xb_1g-T9iGzHDDy3_XpMD",
				DragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragIcon: "RR4AdUs4L9geua2bjCoqQ",
				icon: "PbUpiwMGWTjzrcYfCTdc0",
				iconButton: "_138C3cC0PAtIwsXoIAfGvJ",
				iconWrapper: "Ep3vJhfng2q2-wfiIgstP",
				loadingContainer: "ve35wYJQyEHavtRQYDY7V",
				metadata: "_1xQ_DrqnJXDZq1ptXHxYIB",
				middleMeta: "_2OWUxJA0Dhi0onvygJk3_i",
				middleMetaBlock: "n1lY8o9sGnqcqSfVzm5Vs",
				modalCloseButton: "zKQ8lyAF3pYyDoSlTpTjA",
				modalDescriptionBlock: "_26a81Mk5bsppGjI9AXbmWS",
				modalDescriptionField: "_1brIoxFWlohWpvu34OwZQP",
				modalFooter: "R-9ebJbU9igzPDfUi4Txg",
				modalRadioButton: "_1KFGHoJGHbU05yh6-sQIr5",
				modalRadioText: "_360Lh4DKj256s8RdElARFo",
				modalReasonField: "_1hdSGf--gQDRwsU96bzao1",
				modalRemoveButton: "_2yAePObDkhgZql3P1FHRu1",
				modalReportMeta: "_21sqmEi4OnC4uXlcUGDT_T",
				modalReportTitle: "_1y0X9006mE_5nlHfol1nc2",
				modalRule: "_1AlCnggMuPLxxDUbWWhG2q",
				modalRuleField: "QP-_TXfrh6G1-IRJif4Cy",
				modalRuleTitle: "_2I1A_fyvhaC7TYrYwA047Y",
				modalSubmitButton: "hHFW3BkgX7tSn5Nev-ooY",
				placeholderRow: "hv6YY1IfCww5loDzbkuMS",
				row: "_1LfPdWXylWmVTmLinhd4xl",
				rulesHeader: "_3MOq7UPqtI4o9EnAyCWkEQ",
				rulesIcon: "_29Fl8s_IvZwHxUPNV2ARiW",
				rulesInfo: "KTZ0Ir6xknUXuN4WMI7RN",
				ruleMetaText: "iVYauV_t6_ChREoxhNGsU",
				ruleMetaTitle: "ffGjaCMPoTUkhkVp6rHw5",
				ruleNumber: "_3DEhjnxmn1BzXcJ_ml7kSQ",
				emptyWrapper: "_2-xwKK1EqJlzI2dO7SIrbF",
				ruleText: "_1ZwBW5sLL75ZAZvQreMjn-",
				PrimaryButton: "_3GOmWOjCh6hPWZg1j-zPkr",
				primaryButton: "_3GOmWOjCh6hPWZg1j-zPkr"
			}
		},
		"./src/reddit/components/SubscribeButton/Base.m.less": function(e, t, s) {
			e.exports = {
				IconButton: "_1zyZUfB30L-DDI98CCLJlQ",
				iconButton: "_1zyZUfB30L-DDI98CCLJlQ",
				active: "_2FebEA49ReODemDlwzYHSR",
				SubscribeIcon: "_1O2i-ToERP3a0i4GSL0QwU",
				subscribeIcon: "_1O2i-ToERP3a0i4GSL0QwU",
				UnsubscribeIcon: "_1uBzAtenMgErKev3G7oXru",
				unsubscribeIcon: "_1uBzAtenMgErKev3G7oXru",
				isSmall: "_2ilDLNSvkCHD3Cs9duy9Q_",
				SubscribeIconButton: "_2kBlhw4LJXNnk73IJcwWsT",
				subscribeIconButton: "_2kBlhw4LJXNnk73IJcwWsT",
				UnsubscribeIconButton: "_1kRJoT0CagEmHsFjl2VT4R",
				unsubscribeIconButton: "_1kRJoT0CagEmHsFjl2VT4R",
				SubscribeInternalButton: "_3VgTjAJVNNV7jzlnwY-OFY",
				subscribeInternalButton: "_3VgTjAJVNNV7jzlnwY-OFY",
				UnsubscribeButton: "_2QmHYFeMADTpuXJtd36LQs",
				unsubscribeButton: "_2QmHYFeMADTpuXJtd36LQs",
				UnsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				unsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				UnsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW",
				unsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW"
			}
		},
		"./src/reddit/components/SubscribeButton/Base.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return S
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/app/strings/index.ts"),
				r = s("./src/reddit/constants/elementClassNames.ts"),
				i = s("./src/reddit/controls/Button/index.tsx"),
				c = s("./src/reddit/i18n/utils.ts"),
				d = s("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				l = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				m = s("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				u = s("./src/reddit/components/SubscribeButton/Base.m.less"),
				p = s.n(u),
				b = s("./src/lib/classNames/index.ts"),
				h = s("./src/lib/lessComponent.tsx");

			function g() {
				return (g = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var E = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const x = h.a.button("IconButton", p.a),
				f = h.a.wrapped(l.a, "SubscribeIcon", p.a),
				v = h.a.wrapped(d.a, "UnsubscribeIcon", p.a),
				C = h.a.wrapped(e => {
					var {
						border: t,
						small: s
					} = e, n = E(e, ["border", "small"]);
					return a.a.createElement(x, n, a.a.createElement(f, {
						className: Object(b.a)(n.className, {
							[p.a.isSmall]: s
						})
					}))
				}, "SubscribeIconButton", p.a),
				O = h.a.wrapped(e => {
					var {
						border: t,
						small: s
					} = e, n = E(e, ["border", "small"]);
					return t ? a.a.createElement(i.f, g({}, n, {
						className: Object(b.a)(n.className, {
							[p.a.isSmall]: s
						})
					})) : a.a.createElement(i.n, g({}, n, {
						className: Object(b.a)(n.className, {
							[p.a.isSmall]: s
						})
					}))
				}, "SubscribeInternalButton", p.a),
				j = e => {
					var {
						icon: t
					} = e, s = E(e, ["icon"]);
					return t ? a.a.createElement(C, g({}, s, {
						className: Object(b.a)(s.className, {
							[p.a.isSmall]: s.small
						})
					})) : a.a.createElement(O, g({}, s, {
						className: Object(b.a)(s.className, {
							[p.a.isSmall]: s.small
						})
					}))
				},
				y = h.a.wrapped(e => {
					var {
						border: t,
						language: s,
						small: n,
						type: o
					} = e, i = E(e, ["border", "language", "small", "type"]);
					return a.a.createElement(x, i, a.a.createElement(v, {
						className: Object(b.a)(r.o, i.className, {
							[p.a.isSmall]: n
						})
					}))
				}, "UnsubscribeIconButton", p.a),
				k = h.a.wrapped(e => {
					var {
						border: t,
						language: s,
						small: n,
						type: o
					} = e, r = E(e, ["border", "language", "small", "type"]);
					const d = a.a.createElement(a.a.Fragment, null, a.a.createElement("span", {
							className: p.a.UnsubscribeButtonDefault
						}, "subreddit" === o ? Object(c.c)("Joined") : Object(c.c)("Following")), a.a.createElement("span", {
							className: p.a.UnsubscribeButtonHover
						}, "subreddit" === o ? Object(c.c)("Leave") : Object(c.c)("Unfollow"))),
						l = Object(b.a)(r.className, {
							[p.a.isSmall]: n
						});
					return t ? a.a.createElement(i.i, g({}, r, {
						className: l,
						children: d
					})) : a.a.createElement(i.n, g({}, r, {
						className: l,
						children: d
					}))
				}, "UnsubscribeButton", p.a),
				w = e => {
					var {
						icon: t
					} = e, s = E(e, ["icon"]);
					return t ? a.a.createElement(y, g({}, s, {
						className: Object(b.a)(s.className, {
							[p.a.isSmall]: s.small
						})
					})) : a.a.createElement(k, g({}, s, {
						className: Object(b.a)(s.className, {
							[p.a.isSmall]: s.small
						})
					}))
				};
			class S extends a.a.Component {
				constructor() {
					super(...arguments), this.onClick = e => {
						if (this.props.userIsSubscriber ? this.props.onUnsubscribe() : this.props.onSubscribe(), this.props.onClick && this.props.onClick(e), this.props.getEventFactory) {
							const e = this.props.getEventFactory(this.props.userIsSubscriber);
							e && this.props.sendEvent(e)
						}
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						border: e = !0,
						className: t,
						icon: s = !1,
						id: n,
						language: r,
						small: i = !1
					} = this.props, c = {
						border: e,
						className: t,
						icon: s,
						onClick: this.onClick,
						small: i
					};
					return this.props.userIsSubscriber ? a.a.createElement(w, g({}, c, {
						language: r,
						type: this.props.identifier.type
					})) : a.a.createElement(j, g({}, c, {
						id: n
					}), this.props.children, Object(o.a)(r, "subscriptions.".concat(Object(m.a)({
						type: this.props.identifier.type
					}), ".subscribe")))
				}
			}
		},
		"./src/reddit/components/SubscribeButton/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/components/TrackingHelper/index.tsx"),
				a = s("./src/reddit/connectors/SubscribeButton/index.ts"),
				o = s("./src/reddit/components/SubscribeButton/Base.tsx");
			t.a = Object(a.a)(Object(n.b)(o.a))
		},
		"./src/reddit/components/UserNameAndIcon/index.m.less": function(e, t, s) {
			e.exports = {
				UserIcon: "_1utZNH6IItbNzgdnUBW-Bp",
				userIcon: "_1utZNH6IItbNzgdnUBW-Bp",
				UserLink: "_2Q3rLIRb_ij54AEsabVm9L",
				userLink: "_2Q3rLIRb_ij54AEsabVm9L"
			}
		},
		"./src/reddit/components/UserNameAndIcon/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/config.ts"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				c = s("./src/reddit/controls/InternalLink/index.tsx"),
				d = s("./src/reddit/components/UserNameAndIcon/index.m.less"),
				l = s.n(d);
			const m = r.a.img("UserIcon", l.a),
				u = r.a.wrapped(c.a, "UserLink", l.a);
			t.a = e => o.a.createElement(u, {
				className: e.className,
				to: "".concat(n.a.redditUrl, "/user/").concat(e.username)
			}, o.a.createElement(i.a, {
				user: e.username,
				sendHoverCardEvent: e.sendHoverCardEvent,
				subredditId: e.subredditId,
				tooltipId: e.tooltipId
			}, o.a.createElement(m, {
				src: e.userIcon || "".concat(n.a.assetPath, "/img/placeholder_gradient_light-280.png"),
				style: {
					height: e.iconSize || "32px",
					width: e.iconSize || "32px"
				}
			}), e.username))
		},
		"./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less": function(e, t, s) {
			e.exports = {
				modalBody: "_1bgWTt9jbjzFmQBe0xzfBc",
				notice: "_19wd_7K0Gqdp6cf0Pno6jX",
				sectionTitle: "_2eB-lbdBJ7yGnpy9iCXf27",
				primaryButton: "_1Wp9oAwAZieyVMe4wA5SeL",
				dropdownContainer: "_2-waVlosIHdWwUa_OBavKm",
				dropdownTarget: "_1mcRpBQSnN5ALeKix2x4Py",
				targetText: "_3QRCCOc1SfjMkk4bZCW5lD",
				dropdown: "_1Uq_MgLQhUk4iL9iHGz3qL",
				dropdownRow: "_2UfNC6z3v6GQsT_TQn-eoZ",
				errorText: "_31tw_6Xr1vH0KRVUnoJEdv"
			}
		},
		"./src/reddit/components/Wiki/ModHubWikiManagement/ModHubWikiPage/index.m.less": function(e, t, s) {
			e.exports = {
				container: "mGNUz0KqvrWsrn1xlqXf_",
				pageContent: "_25IEQYEH40hsAC5r5LkR19"
			}
		},
		"./src/reddit/components/Wiki/ModHubWikiManagement/WikiBannedContributors/index.m.less": function(e, t, s) {
			e.exports = {
				primaryButton: "_2r3vT9CCyiwTgSeXf6RtHn"
			}
		},
		"./src/reddit/components/Wiki/ModHubWikiManagement/WikiContributors/index.m.less": function(e, t, s) {
			e.exports = {
				inputLabel: "_1nDjMIzhiCt7HWgRXFrc1R",
				primaryButton: "_3k1glSv6XSy5A0En7LZYHW"
			}
		},
		"./src/reddit/components/Wiki/ModHubWikiManagement/WikiPageSettings/index.m.less": function(e, t, s) {
			e.exports = {
				pageTitle: "_3K9b9vWaE9TuDvOHKsnpxZ",
				cancelButton: "tbuAQl_rbaDSz9IxcnXTR",
				alertBanner: "_3L8Gz5eTr8NgBeJTKk9kiI",
				alertIcon: "_3E4tZufYfJczm55lxiwRkQ",
				content: "Dt_lgwYyjEtbT77GZCi30",
				sectionTitle: "_3BWDhLBCtVqogIc3xGlpE7",
				radioOption: "bYPvzPxaH0T9q-tlg6PNB",
				checkboxInput: "_2TLP8aUCkEOCat2JwsRRRg",
				inputOptionText: "_2GRGQ2mqbZ8bQ7eYspBxAg",
				formGroup: "_1Z7vhGPbRejo38K3k8dTqe",
				contributorsForm: "_3CjUYMONOw114l3U1STBgv",
				contributorInput: "_32godwr0kHXTC5KEQCxyzM",
				addButton: "_3bNA4nqHfh47uG_lar-cr-",
				buttonRow: "_3PCi42qV44IhFfKgdv3ZMM",
				contributorRow: "_3PMSnq_s_rryQTVUy7P_Aa",
				removeButton: "_3kMtQQJGQZPLQhxTuHwe1e",
				loadingUserIcon: "_1Xt2gzEEN0ITln7Q9Vi7Gc",
				loadingUserName: "_2wDJm1c05PrtcJSjqQk6gI"
			}
		},
		"./src/reddit/components/Wiki/ModHubWikiManagement/index.m.less": function(e, t, s) {
			e.exports = {
				modHubTopBar: "_1ooZMJIDxapoXK4WpulOUj",
				modHubPageEditorContent: "_1uuCFa_ObMyUwixW3reghL"
			}
		},
		"./src/reddit/components/Wiki/RevisionsHistory/index.m.less": function(e, t, s) {
			e.exports = {
				container: "ce8AyHVPoXK2ammlk4dfU",
				mModHub: "lPFQHGq7ZJKxOjbVRcUdL",
				content: "_1VN7jDMwPO-3f4G4d4Uy64",
				pageTitle: "V22-y0iI914ak74zxkV1a",
				pageTitleText: "_3BCuy1seZbIJ-Vw-iWJCTG",
				compareBar: "sT-SyQpGKrzgwl4yACquP",
				compareButton: "_1Mw_9r88mDyglkMA5Pp5Ms",
				table: "_2Lg_uTkZH6amYWXVr49IWM",
				colHeaderCheckbox: "_3qPtBJYDKp7pfTfAUKAzlI",
				colHeaderTime: "_3pBaYFkqpMeop0hSx3HG-b",
				colHeaderPage: "_1n5DuAwDmS92cPgdXSZ0VO",
				colHeaderUser: "_1hHgxs8vZyaUp-aaXVfveR",
				colHeaderReason: "_2eOOtPq7Dwb8YjxxasuXgN",
				colHeaderActions: "_2KyULn42zdubuWRRe3ofMX",
				row: "_1n6bCdFzFTcMb8nbcUVbiz",
				mHidden: "_3MGUJlnTJODLOgfuo6ps3N",
				revertButton: "r_5uSGcfTRKw2BrjrMAR6",
				cellPage: "RApPXNo2Wc734CFMKUP9W",
				wikiPageLink: "_3CiqT117augUjPWWrx2TW0",
				usernameLink: "RxzK_7t17mU6YV5lKPTX-",
				cellReason: "_181zFMPLOrQCybR7mpAjDS",
				reasonTextWrapper: "_2k1ikYAtkuItWLnM2v1FoJ",
				mExpanded: "_2Ek11A--oU1fiuOX4icZFo",
				reasonText: "_3rkoZiwX9xBWbnUj8KdDg_",
				moreButton: "MlwbIZHA-n0l6pJotytjr",
				buttons: "_2NPnlVPBDNk-5rZwESZ9B9",
				viewButton: "_1QQV3g6raY4DMIZmGWf_EB",
				cellCheckbox: "_2jHe0kuo-s2zjj9AFEoKIR",
				checkbox: "_2z1fkA5gXEWTIixh5mc5Mu",
				loadingRow: "_1twsCmeo_Rv87GnJLkvjOG",
				loadingShimmer: "_2OTytxS0mfmxAGAw4qKI6K",
				mShowActionButtons: "_3ZOwuRsjzzqragH4DDY3Au"
			}
		},
		"./src/reddit/components/Wiki/RevisionsHistory/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				d = s("./src/reddit/actions/wiki/wikiRevisions/index.ts"),
				l = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				m = s("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				u = s("./src/reddit/components/TrackingHelper/index.tsx"),
				p = s("./src/reddit/components/Wiki/common/PageTitle/index.tsx"),
				b = s("./src/reddit/controls/Button/index.tsx"),
				h = s("./src/reddit/helpers/trackers/subredditWiki.ts"),
				g = s("./src/lib/addQueryParams/index.ts"),
				E = s("./src/reddit/constants/parameters.ts"),
				x = s("./src/reddit/helpers/wiki/wikiRevision.ts");

			function f(e, t) {
				const {
					revision: s,
					revisionToCompare: n
				} = t;
				if (!s && !n) return e;
				const a = {};
				return s && (a[E.w] = Object(x.b)(s)), n && (a[E.x] = Object(x.b)(n)), Object(g.a)(e, a)
			}
			var v = s("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				C = s("./src/reddit/helpers/wiki/makeWikiPath.ts"),
				O = s("./src/reddit/i18n/utils.ts"),
				j = s("./src/reddit/selectors/activeModalId.ts"),
				y = s("./src/reddit/selectors/moderatorPermissions.ts"),
				k = s("./src/reddit/selectors/subreddit.ts"),
				w = s("./src/reddit/selectors/subredditWiki.ts"),
				S = s("./node_modules/lodash/times.js"),
				N = s.n(S),
				T = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				_ = s("./src/reddit/components/Wiki/RevisionsHistory/index.m.less"),
				I = s.n(_);
			var P = () => {
					const e = n.createElement("div", {
						className: Object(i.a)(I.a.loadingShimmer, Object(T.b)({
							isLoading: !0
						}))
					});
					return n.createElement("div", null, N()(4, t => n.createElement("div", {
						key: t,
						className: I.a.loadingRow
					}, e)))
				},
				M = s("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js");
			class R extends a.a.Component {
				constructor() {
					super(...arguments), this.isIntersecting = !1, this.handleChange = e => {
						this.isIntersecting = e.isIntersecting, this.triggerLoadMoreIfNeeded()
					}, this.triggerLoadMoreIfNeeded = () => {
						const {
							isLoading: e,
							hasError: t
						} = this.props;
						!this.isIntersecting || e || t || this.props.onLoadMore()
					}
				}
				componentDidMount() {
					this.triggerLoadMoreIfNeeded()
				}
				componentDidUpdate() {
					this.triggerLoadMoreIfNeeded()
				}
				render() {
					return a.a.createElement(M.a, {
						onChange: this.handleChange
					}, a.a.createElement("div", null))
				}
			}
			s("./node_modules/core-js/modules/es6.regexp.split.js");
			var L = s("./node_modules/lodash/noop.js"),
				D = s.n(L),
				A = s("./src/reddit/components/AuthorLink/index.tsx"),
				F = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				B = s("./src/reddit/components/Wiki/common/RevisionInfo/index.tsx"),
				U = s("./src/reddit/controls/Checkbox/index.tsx"),
				H = s("./src/reddit/controls/InternalLink/index.tsx"),
				W = s("./node_modules/lodash/forEach.js"),
				q = s.n(W),
				V = s("./src/lib/fastdom/index.ts");

			function z(e) {
				V.a.read(() => {
					q()(e, e => {
						if (e instanceof HTMLElement && e.parentElement) {
							const t = e.offsetWidth < e.scrollWidth,
								s = e.parentElement,
								n = "true" === s.dataset.textOverflow;
							t !== n && V.a.write(() => {
								s.dataset.textOverflow = String(t)
							})
						}
					})
				})
			}
			const K = Object(r.c)({
				revision: w.n
			});
			class Q extends a.a.Component {
				constructor() {
					super(...arguments), this.reasonElementRef = a.a.createRef(), this.state = {}, this.onToggleHiddenClick = async () => {
						const {
							revision: e,
							revisionId: t,
							subredditName: s
						} = this.props, n = e.isHidden;
						this.props.sendEvent(Object(h.l)(n)), this.setState({
							isHideRequestPending: !0
						}), await this.props.toggleIsHidden({
							revisionId: t,
							subredditName: s,
							wikiPageName: e.page.name
						}), this.setState({
							isHideRequestPending: !1
						})
					}, this.onRevertClick = () => {
						this.props.onRevertClick(this.props.revision)
					}, this.onShowMoreButtonClick = () => {
						this.setState({
							expanded: !0
						})
					}, this.onCheckboxToggle = () => {
						this.props.onCheckboxToggle(this.props.revisionId)
					}, this.onViewClick = () => {
						this.props.sendEvent(h.q)
					}
				}
				componentDidMount() {
					this.reasonElementRef.current && z([this.reasonElementRef.current])
				}
				render() {
					const {
						hasWikiModPerms: e,
						isCheckboxSelected: t,
						isModHub: s,
						isRecentRevisionMode: n,
						revision: o,
						subredditName: r
					} = this.props, c = o.page.name, d = o.isHidden, {
						expanded: l
					} = this.state, m = o.authorInfo && o.authorInfo.name, u = Object(C.a)({
						subredditName: r,
						wikiPageName: c
					}, s), p = f(u, {
						revision: o.id
					}), h = !n && e, g = c.split("/").slice(-1)[0];
					return a.a.createElement("tr", {
						className: Object(i.a)(I.a.row, d ? I.a.mHidden : null)
					}, !n && a.a.createElement("td", {
						className: I.a.cellCheckbox
					}, a.a.createElement(U.a, {
						className: I.a.checkbox,
						isCheckboxSelected: t,
						toggleCheckbox: this.onCheckboxToggle
					})), a.a.createElement("td", {
						className: I.a.cellTime
					}, Object(B.b)(o)), n && a.a.createElement("td", {
						className: I.a.cellPage
					}, a.a.createElement(H.a, {
						className: I.a.wikiPageLink,
						title: "/".concat(c),
						to: u
					}, g)), a.a.createElement("td", {
						className: I.a.cellUser
					}, m && a.a.createElement(F.a, {
						sendHoverCardEvent: D.a,
						tooltipId: "revision-".concat(o.id),
						user: m
					}, a.a.createElement(A.a, {
						author: m,
						className: I.a.usernameLink
					}, m))), a.a.createElement("td", {
						className: I.a.cellReason
					}, a.a.createElement("div", {
						className: Object(i.a)(I.a.reasonTextWrapper, l ? I.a.mExpanded : null)
					}, a.a.createElement("div", {
						ref: this.reasonElementRef,
						className: I.a.reasonText
					}, o.reason), !l && a.a.createElement(b.d, {
						className: I.a.moreButton,
						onClick: this.onShowMoreButtonClick
					}, Object(O.c)("more")))), a.a.createElement("td", null, a.a.createElement("div", {
						className: I.a.buttons
					}, a.a.createElement(b.o, {
						className: I.a.viewButton,
						onClick: this.onViewClick,
						to: p
					}, Object(O.c)("View")), h && a.a.createElement(a.a.Fragment, null, a.a.createElement(b.n, {
						className: I.a.hideShowButton,
						disabled: this.state.isHideRequestPending,
						onClick: this.onToggleHiddenClick
					}, d ? Object(O.c)("Show") : Object(O.c)("Hide")), a.a.createElement(b.n, {
						className: I.a.revertButton,
						onClick: this.onRevertClick
					}, Object(O.c)("Revert"))))))
				}
			}
			var G = Object(o.b)(K, e => ({
				toggleIsHidden: t => e(Object(d.b)(t))
			}))(Q);

			function J() {
				return (J = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const Z = Object(r.c)({
				hasError: w.o,
				hasWikiModPerms: (e, t) => {
					const s = Object(k.B)(e, t);
					return !!s && Object(y.f)(e, {
						subredditId: s.id
					})
				},
				isPending: w.q,
				isRevertConfirmationModalOpen: Object(j.b)("wiki-revert-confirmation"),
				listingInfo: w.p
			});
			class X extends a.a.Component {
				constructor() {
					super(...arguments), this.containerRef = a.a.createRef(), this.state = {
						selectedRevisions: []
					}, this.onRevertConfirmed = () => {
						const {
							subredditName: e
						} = this.props, {
							revertRevision: t
						} = this.state;
						t && (this.props.sendEvent(h.k), this.props.onRevertToRevision({
							revisionId: t.id,
							subredditName: e,
							wikiPageName: t.page.name
						}))
					}, this.onCompareClick = () => {
						this.props.sendEvent(h.d)
					}, this.onRevertButtonClick = e => {
						this.setState({
							revertRevision: e
						}), this.props.toggleRevetConfirmationModal()
					}, this.handleResize = () => {
						this.containerRef.current && function(e) {
							z(e.getElementsByClassName(I.a.reasonText))
						}(this.containerRef.current)
					}, this.onLoadMore = () => {
						this.props.onLoadMoreRevisions()
					}, this.onCheckboxToggle = e => {
						const {
							listingInfo: t
						} = this.props, s = t && t.ids || [];
						this.setState(t => {
							let n = t.selectedRevisions;
							return 2 === (n = n.includes(e) ? n.filter(t => t !== e) : n.length < 2 ? [...n, e] : [e]).length && s.indexOf(n[0]) < s.indexOf(n[1]) && n.reverse(), {
								selectedRevisions: n
							}
						})
					}, this.renderRowItem = (e, t) => {
						const {
							hasWikiModPerms: s,
							subredditName: n
						} = this.props, {
							selectedRevisions: o
						} = this.state;
						return a.a.createElement(G, {
							key: e,
							hasWikiModPerms: s,
							isCheckboxSelected: o.includes(e),
							isModHub: this.props.isModHub,
							isRecentRevisionMode: this.props.isRecentRevisionsMode,
							onCheckboxToggle: this.onCheckboxToggle,
							onRevertClick: this.onRevertButtonClick,
							revisionId: e,
							sendEvent: this.props.sendEvent,
							subredditName: n
						})
					}
				}
				componentDidMount() {
					window.addEventListener("resize", this.handleResize)
				}
				componentWillUnmount() {
					window.removeEventListener("resize", this.handleResize)
				}
				render() {
					const {
						hasError: e,
						hasWikiModPerms: t,
						isModHub: s,
						isPending: n,
						isRecentRevisionsMode: o,
						isRevertConfirmationModalOpen: r,
						listingInfo: c,
						subredditName: d,
						wikiPageName: u
					} = this.props, {
						selectedRevisions: h
					} = this.state, g = c && c.ids || [], E = c && c.pageInfo.hasNextPage;
					let x = "",
						v = "#";
					u && (x = Object(C.a)({
						subredditName: d,
						wikiPageName: u
					}, s), 2 === h.length && (v = f(x, {
						revision: h[0],
						revisionToCompare: h[1]
					})));
					const j = !o && t;
					return a.a.createElement("div", {
						ref: this.containerRef,
						className: Object(i.a)(I.a.container, {
							[I.a.mModHub]: s,
							[I.a.mShowActionButtons]: j
						})
					}, a.a.createElement(p.a, {
						buttonText: o ? void 0 : Object(O.c)("Go to wiki page"),
						buttonLink: x,
						className: I.a.pageTitle,
						title: a.a.createElement("span", {
							className: I.a.pageTitleText
						}, o ? Object(O.c)("Recent revisions") : Object(O.c)("Page history for ".concat(Object(O.b)("pageName", "/".concat(u)))))
					}), a.a.createElement("div", {
						className: I.a.content
					}, !o && a.a.createElement("div", {
						className: I.a.compareBar
					}, a.a.createElement(b.o, {
						className: I.a.compareButton,
						disabled: h.length < 2,
						onClick: this.onCompareClick,
						to: v
					}, Object(O.c)("Compare")), Object(O.c)("".concat(Object(O.b)("selectedCnt", h.length), "/2 selected to compare"))), a.a.createElement("table", {
						className: I.a.table
					}, a.a.createElement("thead", null, a.a.createElement("tr", null, !o && a.a.createElement("th", {
						className: I.a.colHeaderCheckbox
					}), a.a.createElement("th", {
						className: I.a.colHeaderTime
					}, Object(O.c)("time")), o && a.a.createElement("th", {
						className: I.a.colHeaderPage
					}, Object(O.c)("Wiki page")), a.a.createElement("th", {
						className: I.a.colHeaderUser
					}, Object(O.c)("Username")), a.a.createElement("th", {
						className: I.a.colHeaderReason
					}, Object(O.c)("Revision Reason")), a.a.createElement("th", {
						className: I.a.colHeaderActions
					}, j && a.a.createElement(a.a.Fragment, null, Object(O.c)("Actions"), a.a.createElement(m.a, {
						text: Object(O.c)("View: View current version\nHide: Hide revision from page history\nRevert: Revert page to an older version")
					}))))), a.a.createElement("tbody", {
						className: I.a.tableBody
					}, g.map(this.renderRowItem))), n && a.a.createElement(P, null), E && a.a.createElement(R, {
						hasError: e,
						isLoading: n,
						onLoadMore: this.onLoadMore
					})), r && a.a.createElement(l.a, {
						actionText: Object(O.c)("Revert"),
						headerText: Object(O.c)("Revert wiki page"),
						modalText: Object(O.c)("Are you sure you wish to change this wiki page to a previously saved version?"),
						onConfirm: this.onRevertConfirmed,
						toggleModal: this.props.toggleRevetConfirmationModal,
						withOverlay: !0
					}))
				}
			}
			const Y = Object(o.b)(Z, (e, t) => ({
				toggleRevetConfirmationModal: () => e(Object(c.i)("wiki-revert-confirmation")),
				onRevertToRevision: t => e(Object(d.a)(t)),
				onLoadMoreRevisions: () => e(Object(d.c)(Object.assign({}, t, {
					canLoadMore: !0,
					canShowFailToast: !0,
					isRecent: !!t.isRecentRevisionsMode
				})))
			}))(Object(u.b)(X));
			t.a = e => {
				const t = !!e.isRecentRevisionsMode,
					s = Object(v.a)(Object.assign({}, e, {
						isRecent: t
					}));
				return a.a.createElement(Y, J({
					key: s,
					listingKey: s
				}, e))
			}
		},
		"./src/reddit/components/Wiki/WikiPageContent/PageContent/index.m.less": function(e, t, s) {
			e.exports = {
				container: "kuIrk7ySqHYuv5Gt8MVk7",
				automodContent: "_1FI4zcF0t1ECf8oc18uKd0",
				automodInfoBanner: "_2cLJCh1PnBUPaTO1HveGgo",
				wikiHtmlContent: "_1r4JJnDJUTKPWFmsi-Is_u",
				revisionInfo: "_3n6jRoJzvGVG7cvZDrvW1G"
			}
		},
		"./src/reddit/components/Wiki/WikiPageContent/PagesListing/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2knUS3S97xMYycQVxOi0Yd",
				link: "_2uut3Ijozr0WkSh-oLVTkt"
			}
		},
		"./src/reddit/components/Wiki/WikiPageContent/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_3kIjxjzGVq5UfR6Bjiovd",
				hideIcon: "_2G1CaoG-VN3IjmyXMjpIfp"
			}
		},
		"./src/reddit/components/Wiki/WikiPageContent/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s("./node_modules/react-redux/es/index.js"),
				o = s("./node_modules/reselect/es/index.js"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/TrackingHelper/index.tsx"),
				c = s("./src/reddit/components/Wiki/common/ContentPlaceholder/index.tsx"),
				d = s("./src/reddit/components/Wiki/common/LoadingPlaceholder/index.tsx"),
				l = s("./src/reddit/constants/componentSizes.ts"),
				m = s("./src/reddit/constants/wiki.ts"),
				u = s("./src/reddit/contexts/PageLayer/index.tsx"),
				p = s("./src/reddit/helpers/trackers/subredditWiki.ts"),
				b = s("./src/reddit/helpers/wiki/validatePageName.ts"),
				h = s("./src/reddit/i18n/utils.ts"),
				g = s("./src/reddit/icons/svgs/Hide/index.tsx"),
				E = s("./src/reddit/models/SubredditWikiPage/index.ts"),
				x = s("./src/reddit/selectors/subredditWiki.ts"),
				f = s("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				v = s("./src/reddit/components/Wiki/common/RevisionInfo/index.tsx"),
				C = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				O = s("./src/reddit/helpers/wiki/buildWikiPagesTree.ts"),
				j = s("./src/reddit/helpers/wiki/makeWikiPath.ts"),
				y = s("./src/reddit/components/Wiki/WikiPageContent/PagesListing/index.m.less"),
				k = s.n(y);
			const w = e => {
				const {
					item: t,
					subredditName: s,
					isModHub: a
				} = e, o = t.isPagePresent && Object(j.a)({
					subredditName: s,
					wikiPageName: t.path
				}, a);
				return n.createElement("li", null, o ? n.createElement(C.a, {
					className: k.a.link,
					to: o
				}, t.name) : n.createElement("span", null, t.name), !!t.children.length && n.createElement("ul", null, t.children.map(e => n.createElement(w, {
					isModHub: a,
					item: e,
					key: e.path,
					subredditName: s
				}))))
			};
			var S = e => {
					const {
						isModHub: t,
						subredditName: s,
						wikiDirectory: a
					} = e, o = Object(O.a)(a.pageTree || []);
					return n.createElement("div", {
						className: k.a.container
					}, n.createElement("h1", null, Object(h.c)("Viewing pages for ".concat(Object(h.b)("subredditName", s)))), n.createElement("h2", null, Object(h.c)("Below is a list of pages in this wiki visible to you in this subreddit.")), n.createElement("ul", null, o.map(e => n.createElement(w, {
						isModHub: t,
						item: e,
						key: e.path,
						subredditName: s
					}))))
				},
				N = s("./src/reddit/components/Wiki/WikiPageContent/PageContent/index.m.less"),
				T = s.n(N),
				_ = e => {
					const {
						className: t,
						isModHub: s,
						showRevisionInfo: a,
						subredditName: o,
						wikiDirectory: i,
						wikiPage: c,
						wikiPageName: d
					} = e;
					let l = null;
					return i && d === m.j ? l = n.createElement(S, {
						isModHub: s,
						subredditName: o,
						wikiDirectory: i
					}) : c && c.content && d === m.h ? l = n.createElement("div", {
						className: T.a.automodContent
					}, c.content.markdown) : c && c.content && (l = n.createElement(f.a, {
						className: T.a.wikiHtmlContent,
						html: c.content.html
					})), n.createElement("div", {
						className: Object(r.a)(t, T.a.container)
					}, d === m.h && n.createElement("div", {
						className: T.a.automodInfoBanner
					}, Object(h.c)("This page is used to configure AutoModerator for the subreddit, please see the "), n.createElement("a", {
						href: "/wiki/automoderator/full-documentation"
					}, Object(h.c)("full documentation")), Object(h.c)(" for information")), l, a && c && c.revision && n.createElement("div", {
						className: T.a.revisionInfo
					}, n.createElement(v.a, {
						showTimeAgo: !0,
						isLastRevision: !0,
						revision: c.revision
					})))
				},
				I = s("./src/reddit/components/Wiki/WikiPageContent/index.m.less"),
				P = s.n(I);
			const M = Object(a.b)(() => Object(o.c)({
					pending: x.a,
					wikiDirectory: x.b,
					wikiPage: x.c
				})),
				R = Object(u.t)();
			class L extends n.Component {
				constructor() {
					super(...arguments), this.onEditButtonClick = () => {
						this.props.sendEvent(Object(p.f)())
					}, this.isListingPage = () => this.props.wikiPageName === m.j, this.reloadPage = () => {
						window.location.reload()
					}
				}
				componentDidMount() {
					this.scrollToHash()
				}
				componentDidUpdate(e) {
					const t = this.props.pageLayer !== e.pageLayer,
						s = this.props.wikiPage !== e.wikiPage;
					(t || s) && this.scrollToHash()
				}
				scrollToHash() {
					const e = window.location.hash.slice(1),
						t = e ? document.getElementById(e) : null;
					if (t) {
						let e = l.g + 10;
						this.props.isModHub && (e += l.k + l.l);
						const s = window.scrollY + t.getBoundingClientRect().top - e;
						window.scrollTo(0, s)
					}
				}
				getWikiPageStatus() {
					const {
						wikiDirectory: e,
						wikiPage: t
					} = this.props;
					return this.isListingPage() ? e && e.status : t && t.status
				}
				renderPageContents() {
					const {
						isModHub: e = !1,
						pending: t,
						showRevisionInfo: s,
						subredditName: a,
						wikiDirectory: o,
						wikiPage: r,
						wikiPageName: i
					} = this.props, l = this.getWikiPageStatus(), u = i === m.i, p = this.props.isModHub ? "/r/".concat(this.props.subredditName, "/about/wiki") : "/r/".concat(this.props.subredditName, "/wiki"), x = "".concat(p, "/index"), f = u ? void 0 : Object(h.c)("Wiki home");
					if (t || !l) return n.createElement(d.a, {
						showTitle: !0
					});
					if (l === E.b.Unknown || l === E.b.PageNotCreated) {
						if (Object(b.b)(i)) return n.createElement(c.a, {
							buttonLink: x,
							buttonText: f,
							description: Object(h.c)("This page uses a restricted URL and can not be used as a wiki page"),
							title: Object(h.c)('"'.concat(Object(h.b)("pageName", i), '" does not exist'))
						})
					}
					switch (l) {
						case E.b.Valid:
							return !(!r || !r.content || r.content.markdown) ? n.createElement(c.a, {
								buttonLink: "".concat(p, "/edit/").concat(i),
								buttonText: Object(h.c)("Edit page"),
								description: Object(h.c)("Edit it to add some content"),
								title: Object(h.c)("This page is empty")
							}) : n.createElement(_, {
								isModHub: e,
								showRevisionInfo: s,
								subredditName: a,
								wikiDirectory: o,
								wikiPage: r,
								wikiPageName: i
							});
						case E.b.PageNotCreated:
							return n.createElement(c.a, {
								buttonLink: "".concat(p, "/create/").concat(i),
								buttonText: Object(h.c)("Create page"),
								description: Object(h.c)("Create a wiki page from this URL"),
								title: Object(h.c)('"'.concat(Object(h.b)("pageName", i), '" does not exist'))
							});
						case E.b.Unknown:
							return n.createElement(c.a, {
								buttonText: Object(h.c)("Reload page"),
								onButtonClick: this.reloadPage,
								title: Object(h.c)("An unknown error occurred")
							});
						case E.b.RestrictedPage:
							return n.createElement(c.a, {
								buttonLink: x,
								buttonText: f,
								description: Object(h.c)("This page uses a restricted URL and can not be used as a wiki page"),
								title: Object(h.c)('"'.concat(Object(h.b)("pageName", i), '" does not exist'))
							});
						case E.b.MayNotView:
							return n.createElement(c.a, {
								buttonLink: x,
								buttonText: f,
								description: Object(h.c)("The mods of this community have disabled this wiki page"),
								icon: n.createElement(g.a, {
									className: P.a.hideIcon
								}),
								title: Object(h.c)("This page has been disabled")
							});
						case E.b.WikiDisabled:
							return n.createElement(c.a, {
								buttonLink: "/r/".concat(a, "/"),
								buttonText: Object(h.c)("Continue to r/".concat(Object(h.b)("subredditName", a))),
								description: "The mods of this community have disabled their wiki",
								icon: n.createElement(g.a, {
									className: P.a.hideIcon
								}),
								title: Object(h.c)("This wiki has been disabled")
							});
						case E.b.PageNotFound:
							return n.createElement(c.a, {
								buttonLink: x,
								buttonText: f,
								title: Object(h.c)('"'.concat(Object(h.b)("pageName", i), '" does not exist'))
							});
						default:
							return null
					}
				}
				render() {
					const {
						className: e
					} = this.props;
					return n.createElement("div", {
						className: Object(r.a)(e, P.a.container)
					}, this.renderPageContents())
				}
			}
			t.a = R(M(Object(i.b)(L)))
		},
		"./src/reddit/components/Wiki/WikiPageDiff/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_38GE9wiaoDeBwytESxgurW",
				mModHub: "FOp_mrprAjmysKAwsxZhy",
				content: "_1FDDEmz6LhrlUvB4ha670Y",
				pageTitle: "_1M_2BWIe9pJyTSD3ZNzB2C",
				loadingPlaceholder: "_2eJGN5qzU3dzM10INVODCG",
				loadingSection: "_97ug2ZsHOzZBsGZ98Mqwl",
				diffWrapper: "_1EwbfNO_skwriCJJeOOslG"
			}
		},
		"./src/reddit/components/Wiki/WikiPageDiff/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s("./node_modules/react-redux/es/index.js"),
				o = s("./node_modules/reselect/es/index.js"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/Wiki/common/PageTitle/index.tsx"),
				c = s("./src/reddit/constants/wiki.ts"),
				d = s("./src/reddit/helpers/wiki/makeComparisonDiffKey.ts"),
				l = s("./src/reddit/helpers/wiki/makeWikiPath.ts"),
				m = s("./src/reddit/i18n/utils.ts"),
				u = s("./src/reddit/selectors/subredditWiki.ts"),
				p = s("./src/reddit/components/Wiki/common/LoadingPlaceholder/index.tsx"),
				b = s("./src/reddit/components/Wiki/WikiPageDiff/index.m.less"),
				h = s.n(b),
				g = () => n.createElement("div", {
					className: h.a.loadingPlaceholder
				}, n.createElement("div", {
					className: h.a.loadingSection
				}, n.createElement(p.a, {
					paragraphsCount: 1
				})), n.createElement("div", {
					className: h.a.loadingSection
				}, n.createElement(p.a, {
					paragraphsCount: 1
				})));
			const E = Object(o.c)({
					diffInfo: (e, t) => {
						const s = Object(d.a)(t);
						return Object(u.i)(e, {
							key: s
						})
					}
				}),
				x = Object(a.b)(E);
			class f extends n.Component {
				render() {
					const {
						className: e,
						isModHub: t = !1,
						subredditName: s,
						diffInfo: a,
						wikiPageName: o
					} = this.props;
					let d = null;
					d = !a || a.pending ? n.createElement(g, null) : a.error ? Object(m.c)("Could not load comparison diff") : n.createElement("div", {
						className: h.a.diffWrapper,
						dangerouslySetInnerHTML: {
							__html: a.htmlDiff || ""
						}
					});
					const u = Object(l.a)({
						subredditName: s,
						wikiPageName: o,
						wikiSubRoute: c.l.Revisions
					}, t);
					return n.createElement("div", {
						className: Object(r.a)(e, h.a.container, t ? h.a.mModHub : null)
					}, n.createElement(i.a, {
						buttonText: Object(m.c)("Go to page history"),
						buttonLink: u,
						className: h.a.pageTitle,
						title: Object(m.c)("Comparing revisions for /".concat(Object(m.b)("pageName", o)))
					}), n.createElement("div", {
						className: h.a.content
					}, d))
				}
			}
			t.a = x(f)
		},
		"./src/reddit/components/Wiki/WikiPageEditor/AddRevisionReasonModal/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_1pXEnZ4uzz3OUpnXwRJCtz",
				modalHeader: "_3K-huH_Qa4D32ZPqAH9Ky",
				contentBlock: "N3HQ_fD9TZ7_Mk0iUMrkY",
				labelText: "_12y9PvK2L1LCL-P6PdoQ_B",
				reasonInput: "_3ZAhhe9gmKBwxW31xEmhKG",
				details: "_28OX1xAAmItegIE7yXUOxo",
				modalFooter: "NGYee0xeXDoBFshm7Ad-A",
				loadingIcon: "_2dRNmLURJShL28WViqaeCk"
			}
		},
		"./src/reddit/components/Wiki/WikiPageEditor/index.m.less": function(e, t, s) {
			e.exports = {
				topBar: "an_IeG33-UK9pts_JjqgQ",
				content: "_38SkvHzrhjQ7cSy7R0Lar1",
				resizableTextarea: "jtUB91J6tX7NTsovNabut"
			}
		},
		"./src/reddit/components/Wiki/WikiPageEditor/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/actions/modal.ts"),
				d = s("./node_modules/react-router-redux/es/index.js"),
				l = s("./src/lib/makeActionCreator/index.ts"),
				m = s("./src/reddit/actions/pages/subredditWiki/index.ts"),
				u = s("./src/reddit/actions/toaster.ts"),
				p = s("./src/reddit/constants/wiki.ts"),
				b = s("./src/lib/constants/index.ts"),
				h = s("./src/lib/makeApiRequest/index.ts"),
				g = s("./src/lib/omitHeaders/index.ts"),
				E = s("./src/reddit/constants/headers.ts");
			var x = e => Object(h.b)(Object(g.a)(e.context, [E.a]), {
					endpoint: "".concat(e.context.apiUrl, "/r/").concat(e.subredditName, "/api/wiki/edit"),
					method: b.bb.POST,
					data: {
						content: e.pageContent,
						page: e.wikiPageName,
						previous: e.previousRevision,
						reason: e.revisionReason
					}
				}),
				f = s("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				v = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				C = s("./src/reddit/i18n/utils.ts"),
				O = s("./src/reddit/models/Toast/index.ts"),
				j = s("./src/reddit/routes/subredditWiki/normalizeWikiUrl.ts"),
				y = s("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const k = Object(l.a)(y.a);
			var w = s("./src/reddit/components/BlockNavigation/index.tsx"),
				S = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				N = s("./src/reddit/components/ResizableAutosizeTextarea/index.tsx"),
				T = s("./src/reddit/components/TrackingHelper/index.tsx"),
				_ = s("./src/reddit/components/Wiki/common/ContentPlaceholder/index.tsx"),
				I = s("./src/reddit/components/Wiki/common/LoadingPlaceholder/index.tsx"),
				P = s("./src/reddit/controls/Button/index.tsx"),
				M = s("./src/reddit/helpers/trackers/subredditWiki.ts"),
				R = s("./src/reddit/helpers/wiki/validatePageName.ts"),
				L = s("./src/reddit/models/SubredditWikiPage/index.ts"),
				D = s("./src/reddit/selectors/activeModalId.ts"),
				A = s("./src/reddit/selectors/platform.ts"),
				F = s("./src/reddit/selectors/subredditWiki.ts"),
				B = s("./src/higherOrderComponents/asModal/index.tsx"),
				U = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				H = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				W = s("./src/reddit/controls/TextButton/index.tsx"),
				q = s("./src/reddit/components/Wiki/WikiPageEditor/AddRevisionReasonModal/index.m.less"),
				V = s.n(q);
			class z extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						text: ""
					}, this.onSaveButtonClick = async () => {
						const {
							text: e
						} = this.state;
						this.props.onSave(e)
					}, this.onTextChange = e => {
						this.setState({
							text: e.target.value
						})
					}
				}
				render() {
					const {
						isPending: e
					} = this.props, {
						text: t
					} = this.state, s = p.g - t.length;
					return a.a.createElement("div", {
						className: V.a.container
					}, a.a.createElement(U.g, {
						className: V.a.modalHeader
					}, a.a.createElement(U.n, null, Object(C.c)("Add a reason for your revision")), a.a.createElement(W.a, {
						onClick: this.props.onCancel
					}, a.a.createElement(U.b, null))), a.a.createElement("div", {
						className: V.a.contentBlock
					}, a.a.createElement("label", null, a.a.createElement("span", {
						className: V.a.labelText
					}, Object(C.c)("Revision reason")), a.a.createElement("input", {
						autoFocus: !0,
						className: V.a.reasonInput,
						maxLength: p.g,
						onChange: this.onTextChange,
						placeholder: Object(C.c)("Ex: Added source to appendix"),
						value: t
					})), a.a.createElement("div", {
						className: V.a.details
					}, Object(C.c)("".concat(Object(C.b)("count", s), " ").concat(Object(C.a)("chars", ["character", "characters"], s), " left")))), a.a.createElement(U.e, {
						className: V.a.modalFooter
					}, a.a.createElement(U.a, {
						onClick: this.props.onCancel
					}, Object(C.c)("Cancel")), a.a.createElement(P.f, {
						onClick: this.onSaveButtonClick,
						disabled: e
					}, e ? a.a.createElement(H.a, {
						className: V.a.loadingIcon,
						sizePx: 10
					}) : Object(C.c)("Save"))))
				}
			}
			var K = Object(B.a)(z),
				Q = s("./src/reddit/components/Wiki/WikiPageEditor/index.m.less"),
				G = s.n(Q);
			const J = "Discard-wiki-page-changes",
				Z = "Add-wiki-revision-reason",
				X = 2,
				Y = {
					[R.a.InvalidPageName]: Object(C.c)("Page name is invalid"),
					[R.a.MaxLengthExceed]: Object(C.c)("Page name must be shorter than ".concat(Object(C.b)("maxPageLen", p.d), " characters")),
					[R.a.PageAlreadyExists]: Object(C.c)("Page with this name already exists"),
					[R.a.RestrictedPageName]: Object(C.c)("This page uses a restricted URL and can not be used as a wiki page")
				},
				$ = (e, t, s) => {
					const n = t.status;
					if (e) {
						if (n === L.b.Valid) return Y[R.a.PageAlreadyExists];
						if (n === L.b.PageNotFound) return Object(C.c)("You do not have permission to create this page");
						if (s) return Y[s]
					} else if (n === L.b.Valid && !t.isRevisable) return Object(C.c)("You do not have permission to edit this page")
				},
				ee = Object(r.c)({
					allowNavigationCallback: A.a,
					isRevisionReasonModalOpen: Object(D.b)(Z),
					isSaveBeforeLeaveModalOpen: Object(D.b)(J),
					wikiPage: F.c
				}),
				te = Object(o.b)(ee, (e, t) => ({
					onSaveWikiPage: (s, n) => e((e => {
						let {
							pageContent: t,
							wikiPageName: s,
							revisionReason: n,
							subredditName: a
						} = e;
						return async (e, o, r) => {
							const i = await x({
								context: r.apiContext(),
								pageContent: t,
								revisionReason: n,
								subredditName: a,
								wikiPageName: s
							});
							if (i.ok) e(k({
								pageKey: Object(v.a)({
									subredditName: a,
									wikiPageName: s
								}),
								pageRevisionsListingKey: Object(f.a)({
									subredditName: a,
									wikiPageName: s,
									isRecent: !1
								}),
								recentRevisionsListingKey: Object(f.a)({
									subredditName: a,
									wikiPageName: s,
									isRecent: !0
								})
							})), await e(Object(m.fetchSubredditWikiData)({
								includeDirectory: !0,
								includePageData: !0,
								subredditName: a,
								wikiPageName: s
							}));
							else {
								let t = Object(C.c)("Something went wrong");
								i.body && "RESTRICTED_PAGE" === i.body.reason && (t = Object(C.c)("Cannot create/edit restricted page")), e(Object(u.e)({
									kind: O.b.Error,
									text: t
								}))
							}
							return i.ok
						}
					})({
						pageContent: s,
						revisionReason: n,
						subredditName: t.subredditName,
						wikiPageName: t.wikiPageName
					})),
					onFinishWikiEdit: t => e(function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						return async (t, s) => {
							const n = s().platform.currentPage,
								a = n.locationState && n.locationState[p.a];
							if (e && a) t(Object(d.a)());
							else {
								const {
									subredditName: e,
									wikiPageName: s
								} = n.urlParams, a = Object(j.a)(n.url, {
									subredditName: e,
									wikiPageName: s
								});
								t(Object(d.c)(a))
							}
						}
					}(t)),
					closeAllModals: () => e(Object(c.f)()),
					toggleModal: t => e(Object(c.i)(t))
				}));
			class se extends a.a.Component {
				constructor(e) {
					super(e), this.isUnmounted = !1, this.onSaveWithReason = async e => {
						const {
							markdown: t
						} = this.state;
						this.setState({
							isSavePending: !0
						}), this.props.sendEvent(Object(M.m)(this.props.isCreation));
						const s = await this.props.onSaveWikiPage(t, e);
						this.isUnmounted || (this.setState({
							isSavePending: !1
						}), s ? this.setState({
							disableBlocking: !0
						}, () => {
							this.props.onFinishWikiEdit()
						}) : this.finishPendingNavTransition(!1))
					}, this.onLeavePageConfirmed = () => {
						this.finishPendingNavTransition(!0)
					}, this.onAbortLeavingPage = () => {
						this.finishPendingNavTransition(!1), this.props.closeAllModals()
					}, this.onCancelAddingRevisionReason = () => {
						this.finishPendingNavTransition(!1), this.props.closeAllModals()
					}, this.showRevisionReasonModal = () => {
						this.props.isRevisionReasonModalOpen || this.props.toggleModal(Z)
					}, this.onCancel = () => {
						this.props.onFinishWikiEdit(!0)
					}, this.onTextChange = e => {
						this.setState({
							markdown: e.target.value
						})
					};
					const t = e.wikiPage && e.wikiPage.content ? e.wikiPage.content.markdown : "";
					this.state = {
						isSavePending: !1,
						markdown: t
					}
				}
				componentDidUpdate(e) {
					const {
						wikiPage: t
					} = this.props;
					if (t && !e.wikiPage) {
						const e = t.content && t.content.markdown || "";
						this.setState({
							markdown: e
						})
					}
				}
				componentWillUnmount() {
					this.isUnmounted = !0, this.finishPendingNavTransition(!1)
				}
				finishPendingNavTransition(e) {
					this.props.allowNavigationCallback && this.props.allowNavigationCallback(e)
				}
				render() {
					const {
						isCreation: e,
						isRevisionReasonModalOpen: t,
						isSaveBeforeLeaveModalOpen: s,
						wikiPage: n,
						wikiPageName: o
					} = this.props, {
						disableBlocking: r,
						isSavePending: c,
						markdown: d
					} = this.state, l = n && n.content && n.content.markdown || "", m = !d.trim(), u = d !== l, p = e && n ? Object(R.b)(n.name) : void 0, b = !(!n || n.status !== L.b.PageNotCreated || p), h = !(!n || n.status !== L.b.Valid || !n.isRevisable), g = e ? b : h, E = g && u && !m && !c && !p;
					return a.a.createElement("div", {
						className: Object(i.a)(G.a.container, this.props.className)
					}, a.a.createElement("div", {
						className: Object(i.a)(this.props.topBarClassName, G.a.topBar)
					}, a.a.createElement(P.i, {
						onClick: this.onCancel,
						disabled: c
					}, Object(C.c)("Cancel")), a.a.createElement(P.f, {
						disabled: !E,
						onClick: this.showRevisionReasonModal
					}, Object(C.c)("Save"))), a.a.createElement("div", {
						className: Object(i.a)(this.props.contentClassName, G.a.content)
					}, n ? g ? a.a.createElement(N.a, {
						autoFocus: !0,
						className: G.a.resizableTextarea,
						disabled: c,
						onChange: this.onTextChange,
						placeholder: Object(C.c)("Add page content here"),
						value: d
					}) : a.a.createElement(_.a, {
						description: $(e, n, p),
						title: e ? Object(C.c)('"'.concat(Object(C.b)("pageName", o), '" cannot be created')) : Object(C.c)('"'.concat(Object(C.b)("pageName", o), '" cannot be edited'))
					}) : a.a.createElement(I.a, {
						paragraphsCount: X
					})), t && a.a.createElement(K, {
						withOverlay: !0,
						onCancel: this.onCancelAddingRevisionReason,
						onSave: this.onSaveWithReason,
						isPending: c
					}), a.a.createElement(w.a, {
						blockOnBeforeUnload: !0,
						dialogId: J,
						enabled: u && !r
					}), s && a.a.createElement(S.a, {
						actionText: Object(C.c)("Discard"),
						headerText: Object(C.c)("Discard changes before leaving?"),
						modalText: Object(C.c)("You have made some changes to your wiki page, do you wish to discard the changes?"),
						onCancel: this.onAbortLeavingPage,
						onClose: this.onAbortLeavingPage,
						onConfirm: this.onLeavePageConfirmed,
						withOverlay: !0
					}))
				}
			}
			t.a = te(Object(T.b)(se))
		},
		"./src/reddit/components/Wiki/WikiPageSource/index.m.less": function(e, t, s) {
			e.exports = {
				container: "hFkZVSvr5ZCDtsUNvUe0t",
				mModHub: "OTGEcq8eHMW4w8Jk_xUB_",
				content: "jB-E_8PuDLsGMGUcJ38Ed",
				pageTitle: "_7mpqbmAh_bdv9eJPLzJkl",
				headerRow: "_24xr0pCtEq8smcGh9hy-iC",
				pageSource: "_3FGoxkytIqYAnG5hdqa8Uq"
			}
		},
		"./src/reddit/components/Wiki/WikiPageSource/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s("./node_modules/react-redux/es/index.js"),
				o = s("./node_modules/reselect/es/index.js"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/components/Wiki/common/LoadingPlaceholder/index.tsx"),
				c = s("./src/reddit/components/Wiki/common/PageTitle/index.tsx"),
				d = s("./src/reddit/components/Wiki/common/RevisionInfo/index.tsx"),
				l = s("./src/reddit/constants/wiki.ts"),
				m = s("./src/reddit/helpers/wiki/makeWikiPath.ts"),
				u = s("./src/reddit/i18n/utils.ts"),
				p = s("./src/reddit/models/SubredditWikiPage/index.ts"),
				b = s("./src/reddit/selectors/subredditWiki.ts"),
				h = s("./src/reddit/components/Wiki/WikiPageSource/index.m.less"),
				g = s.n(h);
			const E = Object(o.c)({
					pending: b.a,
					revision: (e, t) => {
						let {
							revisionId: s
						} = t;
						return s ? Object(b.n)(e, {
							revisionId: s
						}) : void 0
					},
					wikiPage: b.c
				}),
				x = Object(a.b)(E);
			class f extends n.Component {
				render() {
					const {
						className: e,
						isModHub: t = !1,
						pending: s,
						revision: a,
						revisionId: o,
						subredditName: b,
						wikiPage: h,
						wikiPageName: E
					} = this.props;
					let x = null;
					x = s ? n.createElement(i.a, null) : h ? h.status === p.b.Valid ? h.content && h.content.markdown : Object(u.c)("Cannot show page content") : Object(u.c)("Page not found");
					const f = a || h && h.revision,
						v = !o,
						C = Object(m.a)({
							subredditName: b,
							wikiPageName: E,
							wikiSubRoute: v ? void 0 : l.l.Revisions
						}, t);
					return n.createElement("div", {
						className: Object(r.a)(e, g.a.container, t ? g.a.mModHub : null)
					}, n.createElement(c.a, {
						buttonText: v ? Object(u.c)("Go to wiki page") : Object(u.c)("Go to page history"),
						buttonLink: C,
						className: g.a.pageTitle,
						title: !v && f ? Object(u.c)("Revision from ".concat(Object(u.b)("timeAgo", Object(d.b)(f)))) : Object(u.c)("Page source")
					}), n.createElement("div", {
						className: g.a.content
					}, n.createElement("div", {
						className: g.a.headerRow
					}, f && n.createElement(d.a, {
						isLastRevision: v,
						revision: f,
						showReason: !0,
						showTimeAgo: !1
					})), n.createElement("div", {
						className: g.a.pageSource
					}, x)))
				}
			}
			t.a = x(f)
		},
		"./src/reddit/components/Wiki/WikiPageTopBar/OverflowMenu/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_3m-pL3lGJRyo7pWckPUL_d",
				dropdown: "_3IUuipl8jTmMnjXR0NDisP",
				row: "_25Y1JThsMmw5VNvhFFLb0j"
			}
		},
		"./src/reddit/components/Wiki/WikiPageTopBar/index.m.less": function(e, t, s) {
			e.exports = {
				container: "I0T583ZtOWVEpRWsa0kbu",
				button: "_2IOi-lonN6Hy4pTcjFTLBp",
				revisionInfo: "Ln6UHsxFeDZdhv1yRUL0F",
				flexSpacer: "meAs5YnW58CX9i8rWjZQL"
			}
		},
		"./src/reddit/components/Wiki/WikiPageTopBar/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/history/esm/history.js"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/reselect/es/index.js"),
				c = s("./src/lib/classNames/index.ts"),
				d = s("./src/lib/copyToClipboard/index.ts"),
				l = s("./src/reddit/actions/toaster.ts"),
				m = s("./src/reddit/components/TrackingHelper/index.tsx"),
				u = s("./src/reddit/components/Wiki/common/RevisionInfo/index.tsx"),
				p = s("./src/reddit/constants/wiki.ts"),
				b = s("./src/reddit/controls/Button/index.tsx"),
				h = s("./src/reddit/i18n/utils.ts"),
				g = s("./src/reddit/models/SubredditWikiPage/index.ts"),
				E = s("./src/reddit/models/Toast/index.ts"),
				x = s("./src/reddit/selectors/moderatorPermissions.ts"),
				f = s("./src/reddit/selectors/subreddit.ts"),
				v = s("./src/reddit/selectors/subredditWiki.ts"),
				C = s("./src/config.ts"),
				O = s("./src/reddit/components/OverflowMenu/index.tsx"),
				j = s("./src/reddit/constants/parameters.ts"),
				y = s("./src/reddit/controls/Dropdown/Row.tsx"),
				k = s("./src/reddit/helpers/trackers/subredditWiki.ts"),
				w = s("./src/reddit/components/Wiki/WikiPageTopBar/OverflowMenu/index.m.less"),
				S = s.n(w);
			const N = ["right", "bottom"],
				T = ["right", "top"];
			class _ extends o.a.Component {
				constructor() {
					super(...arguments), this.onViewPageSourceClick = () => {
						this.props.sendEvent(k.r)
					}, this.onCopyPageUrl = () => {
						const {
							subredditName: e,
							wikiPageName: t
						} = this.props, s = "".concat(C.a.redditUrl, "/r/").concat(e, "/wiki/").concat(t);
						this.props.onCopyPageUrl(s), this.props.sendEvent(k.e)
					}
				}
				render() {
					const {
						className: e,
						dropdownId: t,
						isModHub: s,
						subredditName: n,
						wikiPage: a,
						wikiPageName: r
					} = this.props, i = "/r/".concat(n, s ? "/about/wiki" : "/wiki");
					return o.a.createElement(O.b, {
						className: Object(c.a)(e, S.a.container),
						dropdownClassName: S.a.dropdown,
						dropdownId: t,
						targetPosition: N,
						tooltipPosition: T
					}, a && o.a.createElement(y.b, {
						className: S.a.row,
						displayText: Object(h.c)("View page history"),
						href: "".concat(i, "/revisions/").concat(r)
					}), a && o.a.createElement(y.b, {
						className: S.a.row,
						displayText: Object(h.c)("View page source"),
						href: "".concat(i, "/").concat(r, "?").concat(j.y),
						onClick: this.onViewPageSourceClick
					}), s && o.a.createElement(y.b, {
						className: S.a.row,
						displayText: Object(h.c)("View in community"),
						href: "/r/".concat(n, "/wiki/").concat(r)
					}), o.a.createElement(y.b, {
						className: S.a.row,
						displayText: Object(h.c)("Copy URL"),
						onClick: this.onCopyPageUrl
					}))
				}
			}
			var I = _,
				P = s("./src/reddit/components/Wiki/WikiPageTopBar/index.m.less"),
				M = s.n(P);
			const R = Object(i.c)({
					hasWikiModPerms: (e, t) => {
						const s = Object(f.B)(e, t);
						return !!s && Object(x.f)(e, {
							subredditId: s.id
						})
					},
					wikiPage: v.c
				}),
				L = Object(r.b)(R, e => ({
					onCopyPageUrl: t => e((e => async t => {
						Object(d.a)(e) && t(Object(l.e)(Object(l.d)(Object(h.c)("Copied page URL"), E.b.SuccessCommunity)))
					})(t))
				}));
			class D extends o.a.Component {
				render() {
					const {
						hasWikiModPerms: e,
						isModHub: t,
						wikiPage: s,
						wikiPageName: a,
						subredditName: r,
						className: i
					} = this.props, d = !!s && s.status === g.b.Valid, l = !!s && s.isRevisable, m = e && l && d, E = t ? "/r/".concat(r, "/about/wiki/edit/").concat(a) : "/r/".concat(r, "/wiki/edit/").concat(a);
					return o.a.createElement("div", {
						className: Object(c.a)(i, M.a.container)
					}, t && s && s.revision && o.a.createElement(u.a, {
						showTimeAgo: !0,
						className: M.a.revisionInfo,
						isLastRevision: !0,
						revision: s.revision
					}), o.a.createElement("div", {
						className: M.a.flexSpacer
					}), m && o.a.createElement(b.k, {
						className: M.a.button,
						to: "/r/".concat(r, "/about/wiki/settings/").concat(a)
					}, Object(h.c)("Page settings")), d && l && o.a.createElement(b.h, {
						className: M.a.button,
						to: Object(n.c)(E, {
							[p.a]: !0
						})
					}, Object(h.c)("Edit")), d && o.a.createElement(I, {
						className: M.a.overflowMenu,
						dropdownId: "wikiPage-OverflowMenu-".concat(a, "-").concat(t),
						isModHub: t,
						onCopyPageUrl: this.props.onCopyPageUrl,
						sendEvent: this.props.sendEvent,
						subredditName: r,
						wikiPage: s,
						wikiPageName: a
					}))
				}
			}
			t.a = L(Object(m.b)(D))
		},
		"./src/reddit/components/Wiki/common/ContentPlaceholder/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_3Av0UmXioR3Vgw-lpzfBWu",
				button: "_2hFu9bCtEjS60NjZM3F_UE",
				description: "_2c02P9rTnnEw2KuDpY8JxB",
				title: "_3rol4SGAf0n5-e8EENfrur"
			}
		},
		"./src/reddit/components/Wiki/common/ContentPlaceholder/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s("./src/reddit/controls/Button/index.tsx"),
				o = s("./src/reddit/components/Wiki/common/ContentPlaceholder/index.m.less"),
				r = s.n(o);
			t.a = e => {
				const {
					buttonLink: t,
					buttonText: s,
					description: o,
					icon: i,
					onButtonClick: c,
					title: d
				} = e;
				let l = null;
				return s && t ? l = n.createElement(a.h, {
					className: r.a.button,
					onClick: e.onButtonClick,
					to: t
				}, s) : s && c && (l = n.createElement(a.f, {
					className: r.a.button,
					onClick: e.onButtonClick
				}, s)), n.createElement("div", {
					className: r.a.container
				}, i, d && n.createElement("div", {
					className: r.a.title
				}, d), o && n.createElement("div", {
					className: r.a.description
				}, o), l)
			}
		},
		"./src/reddit/components/Wiki/common/LoadingPlaceholder/index.m.less": function(e, t, s) {
			e.exports = {
				placeholderTitle: "XK5I3_2arHFpfmDn6iUGt",
				placeholderParagraph: "_3Rhsg99h5kjE-u1Pp-Uk8P",
				placeholderTextLine: "_5pG9RcI-AYalqG5z6osMT"
			}
		},
		"./src/reddit/components/Wiki/common/LoadingPlaceholder/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/range.js"),
				a = s.n(n),
				o = s("./node_modules/react/index.js"),
				r = s("./src/lib/classNames/index.ts"),
				i = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				c = s("./src/reddit/components/Wiki/common/LoadingPlaceholder/index.m.less"),
				d = s.n(c);
			const l = e => o.createElement("div", {
				className: Object(r.a)(e.className, Object(i.b)({
					isLoading: !0
				}))
			});
			t.a = e => o.createElement(o.Fragment, null, e.showTitle && o.createElement(l, {
				className: d.a.placeholderTitle
			}), a()(e.paragraphsCount || 6).map(e => o.createElement("div", {
				className: d.a.placeholderParagraph,
				key: e
			}, a()(10).map(e => o.createElement(l, {
				className: d.a.placeholderTextLine,
				key: e
			})))))
		},
		"./src/reddit/components/Wiki/common/PageTitle/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2NCACehu2vXVQzdHocg7Rq",
				linkButton: "_28uXMdKULX2ygqCKM5Apfz"
			}
		},
		"./src/reddit/components/Wiki/common/PageTitle/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/controls/Button/index.tsx"),
				i = s("./src/reddit/components/Wiki/common/PageTitle/index.m.less"),
				c = s.n(i);
			t.a = e => {
				const {
					buttonLink: t,
					buttonText: s,
					className: n,
					title: i
				} = e;
				return a.a.createElement("div", {
					className: Object(o.a)(n, c.a.container)
				}, i, s && t && a.a.createElement(r.o, {
					className: c.a.linkButton,
					to: t
				}, s))
			}
		},
		"./src/reddit/components/Wiki/common/RevisionInfo/index.m.less": function(e, t, s) {
			e.exports = {
				container: "_2b8IWktp8nbHqDKTRFWebW",
				authorLink: "IY5BT71vlrhwNnwInSc2f"
			}
		},
		"./src/reddit/components/Wiki/common/RevisionInfo/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return j
			})), s.d(t, "a", (function() {
				return y
			}));
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./node_modules/lodash/noop.js"),
				a = s.n(n),
				o = s("./node_modules/react/index.js"),
				r = s.n(o),
				i = s("./src/higherOrderComponents/asTooltip.tsx"),
				c = s("./src/lib/classNames/index.ts"),
				d = s("./src/lib/constants/index.ts"),
				l = s("./src/lib/timeAgo/index.ts"),
				m = s("./src/reddit/components/AuthorLink/index.tsx"),
				u = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				p = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				b = s("./src/reddit/contexts/Language.tsx"),
				h = s("./src/reddit/helpers/graphql/helpers.ts"),
				g = s("./src/reddit/i18n/utils.ts"),
				E = s("./src/reddit/models/Post/index.ts"),
				x = s("./src/reddit/components/Wiki/common/RevisionInfo/index.m.less"),
				f = s.n(x);
			const v = ["center", "top"],
				C = ["center", "bottom"],
				O = Object(i.a)(p.b),
				j = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en";
					const s = new Date(Object(h.j)(e.revisedAt));
					return Object(l.d)(t, s.valueOf() / 1e3)
				};
			class y extends r.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						className: e,
						isLastRevision: t,
						revision: s,
						showReason: n = !1,
						showTimeAgo: o = !1
					} = this.props, {
						showTooltip: i
					} = this.state, l = s.authorInfo && s.authorInfo.name || d.z, p = new Date(Object(h.j)(s.revisedAt));
					return r.a.createElement("span", {
						className: Object(c.a)(e, f.a.container)
					}, t ? Object(g.c)("Last revised by ") : Object(g.c)("Revised by "), r.a.createElement(u.a, {
						tooltipId: "wikipage-revision-author",
						user: l,
						sendHoverCardEvent: a.a
					}, r.a.createElement(m.a, {
						className: f.a.authorLink,
						author: l,
						isAuthorDeleted: Object(E.h)(l),
						isUnstyled: !0
					}, l)), o && r.a.createElement("span", {
						ref: this.setTooltipTargetRef,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip
					}, " - ", r.a.createElement(b.a.Consumer, null, e => j(s, e)), r.a.createElement(O, {
						text: p.toString(),
						isOpen: i,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: v,
						tooltipPosition: C
					})), n && s.reason && r.a.createElement("span", null, " - ", s.reason))
				}
			}
		},
		"./src/reddit/connectors/connectToLanguage.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return i
			}));
			var n = s("./node_modules/react-redux/es/index.js"),
				a = s("./node_modules/reselect/es/index.js"),
				o = s("./src/reddit/selectors/user.ts");
			const r = Object(a.c)({
				language: o.S
			});

			function i(e) {
				return Object(n.b)(r)(e)
			}
		},
		"./src/reddit/controls/Checkbox/index.m.less": function(e, t, s) {
			e.exports = {
				Checkbox: "_2nBuBcqz2x0pSPNZfAPkF",
				checkbox: "_2nBuBcqz2x0pSPNZfAPkF",
				mActive: "tLupTGll01Uj0qzkNAjEB",
				mActiveRedditStyle: "_3zu1ZycuCQZ6UeSogWYVka",
				mDisabled: "_2hst4PduZ_m486CeR0rkEm",
				mDisabledRedditStyle: "_2MFHixazvnGgoOmoOzwbIu",
				CheckboxSizing: "_1yJa2uREsO-mxGPj5tbxXy",
				checkboxSizing: "_1yJa2uREsO-mxGPj5tbxXy"
			}
		},
		"./src/reddit/controls/Checkbox/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Checkbox/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var c = e => a.a.createElement("svg", i({
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, e), a.a.createElement("g", {
					transform: "translate(-32.000000, -173.000000)"
				}, a.a.createElement("g", {
					transform: "translate(32.000000, 173.000000)"
				}, a.a.createElement("path", {
					d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M4.5,8.5 C4.22385763,8.5 4,8.72385763 4,9 L4,11 C4,11.2761424 4.22385763,11.5 4.5,11.5 L15.5,11.5 C15.7761424,11.5 16,11.2761424 16,11 L16,9 C16,8.72385763 15.7761424,8.5 15.5,8.5 L4.5,8.5 Z"
				})))),
				d = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				l = s("./src/reddit/controls/Checkbox/index.m.less"),
				m = s.n(l);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const b = e => t => {
					const {
						className: s,
						disabled: n,
						redditStyle: r,
						"data-redditstyle": i
					} = t, c = p(t, ["className", "disabled", "redditStyle", "data-redditstyle"]), d = ((e, t, s) => {
						const n = !(!t && !s);
						let a = "";
						return a = e ? n ? m.a.mDisabledRedditStyle : m.a.mDisabled : n ? m.a.mActiveRedditStyle : m.a.mActive
					})(n, r, i);
					return a.a.createElement(e, u({
						className: Object(o.a)(m.a.Checkbox, d, s)
					}, c))
				},
				h = b(d.a),
				g = b(c);
			t.a = e => {
				const t = e.isHalfCheckboxSelected ? g : e.isCheckboxSelected ? h : r.a;
				return a.a.createElement("button", {
					"aria-checked": e.isHalfCheckboxSelected ? "mixed" : e.isCheckboxSelected,
					className: e.className,
					onClick: t => {
						e.toggleCheckbox && (t.stopPropagation(), e.toggleCheckbox())
					},
					disabled: e.disabled
				}, a.a.createElement(t, {
					className: Object(o.a)(m.a.CheckboxSizing, e.className),
					"data-redditstyle": e.redditStyle,
					disabled: e.disabled,
					style: e.checkBoxStyle
				}))
			}
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, s) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = s("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				c = s("./src/reddit/layout/row/Inline/index.tsx"),
				d = s("./src/reddit/controls/CheckboxInput/index.m.less"),
				l = s.n(d);
			t.a = e => a.a.createElement(c.a, {
				"aria-checked": !!e.value,
				"aria-disabled": e.disabled,
				"aria-labelledby": e.name,
				className: Object(o.a)(e.className, l.a.checkboxInput, e.disabled ? l.a.disabled : null),
				onClick: e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0,
				role: "checkbox"
			}, a.a.createElement("input", {
				value: e.value ? e.value.toString() : "",
				type: "hidden"
			}), e.value ? a.a.createElement(i.a, {
				className: l.a.checkboxSelected
			}) : a.a.createElement(r.a, null), e.children)
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return E
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/lodash/throttle.js"),
				a = s.n(n),
				o = s("./node_modules/react/index.js"),
				r = s.n(o),
				i = s("./src/lib/classNames/index.ts"),
				c = s("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				d = s("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				l = s("./src/reddit/layout/row/InlineButton/index.tsx"),
				m = s("./src/reddit/controls/Dropdown/index.m.less"),
				u = s.n(m),
				p = s("./src/reddit/controls/Dropdown/row.m.less"),
				b = s.n(p);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var g = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			class E extends r.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = a()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, s = Object(i.a)(b.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? r.a.createElement(c.a, h({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href
					}), e.children && r.a.createElement("span", {
						className: s
					}, e.children), r.a.createElement("span", {
						className: Object(i.a)(b.a.text, e.textClassName)
					}, e.displayText)) : r.a.createElement(l.a, h({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: a()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? r.a.createElement("div", null, e.children) : r.a.createElement("span", {
						className: s
					}, e.children)), e.displayText && r.a.createElement("span", {
						className: Object(i.a)(b.a.text, e.textClassName)
					}, e.displayText), e.showDropdownTriangle && r.a.createElement(d.a, {
						className: u.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				var {
					className: t
				} = e, s = g(e, ["className"]);
				const n = Object(i.a)(b.a.row, t, {
					[b.a.mIsInteractive]: !s.noHover,
					[b.a.mIsSelected]: s.isSelected
				});
				return r.a.createElement(E, h({
					className: n
				}, s))
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, s) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				iconStyles: "_2XOVBjNLHjJIznEsn35vs2",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.m.less": function(e, t, s) {
			e.exports = {
				dropdownMenu: "_1PLoXiZH4WKzHTfmYIt34X",
				selector: "apk_M-7ks6NcaiMN8cotM",
				selectorContent: "Ot99igbaJ5id3P1tw6wow",
				compact: "_1qaMsHCBrTmejbIUPjsRVI",
				caretDown: "_2i4dyr-iTBOmkZ4fL_M70P",
				menuItems: "_3ssvFhIB2HAXL261eWf7G0",
				menuOption: "_1Qm1phX3yfiJHnjgi_O_9V"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return p
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-dom/index.js"),
				r = s.n(o),
				i = s("./src/reddit/controls/DropdownSelector/index.m.less"),
				c = s.n(i),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/reddit/controls/Dropdown/Row.tsx"),
				m = s("./src/reddit/icons/svgs/Dropdown/index.tsx");
			const u = e => {
				e.preventDefault()
			};
			class p extends a.a.Component {
				constructor() {
					super(...arguments), this.dropdownButton = a.a.createRef(), this.menuItems = a.a.createRef(), this.state = {
						isOpen: !1
					}, this.handleDocumentClick = e => {
						const t = r.a.findDOMNode(this);
						t && (t.contains(e.target) || this.setState({
							isOpen: !1
						}))
					}, this.onSelectOption = (e, t, s) => {
						const {
							onSelect: n
						} = this.props;
						e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopPropagation(), n(t), s && this.dropdownButton.current && this.dropdownButton.current.focus(), this.setState({
							isOpen: !1
						})
					}, this.onOptionClick = (e, t) => {
						this.onSelectOption(e, t)
					}, this.handleDropdownClick = e => {
						e.preventDefault(), this.props.onOpen && this.props.onOpen(), this.setState({
							isOpen: !this.state.isOpen
						})
					}, this.handleDropdownBlur = e => {
						let t = !1;
						if (e.relatedTarget === this.dropdownButton.current) t = !0;
						else {
							if (!this.menuItems.current) return;
							const s = this.menuItems.current.getElementsByClassName(c.a.menuOption);
							for (let n = 0; n < s.length; n++) e.relatedTarget === s[n] && (t = !0)
						}
						this.setState({
							isOpen: t
						})
					}, this.handleDropdownKeyDown = e => {
						if (!this.state.isOpen && [40, 32, 13].includes(e.keyCode)) return e.preventDefault(), void this.setState({
							isOpen: !0
						}, this.focusOnFirstOption);
						40 === e.keyCode && (e.preventDefault(), this.focusOnFirstOption()), 27 === e.keyCode && this.state.isOpen && (e.stopPropagation(), e.nativeEvent.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), this.setState({
							isOpen: !1
						}))
					}, this.handleOptionKeyDown = (e, t) => {
						if (32 === e.keyCode || 13 === e.keyCode) this.onSelectOption(e, t, !0);
						else if (38 === e.keyCode || 40 === e.keyCode) {
							if (e.preventDefault(), !this.menuItems.current) return;
							const t = this.menuItems.current.getElementsByClassName(c.a.menuOption);
							for (let s = 0; s < t.length; s++) t[s] === e.target && (38 === e.keyCode && s > 0 && t[s - 1].focus(), 40 === e.keyCode && s < t.length - 1 && t[s + 1].focus())
						}
					}
				}
				componentDidMount() {
					document.body.addEventListener("click", this.handleDocumentClick, !1)
				}
				componentWillUnmount() {
					document.body.removeEventListener("click", this.handleDocumentClick, !1)
				}
				focusOnFirstOption() {
					if (!this.menuItems.current) return;
					const e = this.menuItems.current.getElementsByClassName(c.a.menuOption);
					e.length && e[0].focus()
				}
				getDropdownMenuItems() {
					const {
						options: e
					} = this.props;
					return e.map((e, t) => a.a.createElement(l.b, {
						key: t + e.displayText,
						className: c.a.menuOption,
						noIcon: !0,
						onKeydown: t => this.handleOptionKeyDown(t, e),
						onMouseDown: t => this.onOptionClick(t, e),
						onBlur: this.handleDropdownBlur
					}, e.displayText))
				}
				render() {
					const {
						buttonClassName: e,
						className: t,
						displayText: s,
						isCompactStyle: n,
						name: o
					} = this.props, {
						isOpen: r
					} = this.state;
					return a.a.createElement("div", {
						className: Object(d.a)(c.a.dropdownMenu, t)
					}, a.a.createElement("button", {
						onClick: this.handleDropdownClick,
						className: Object(d.a)(e, c.a.selector, {
							[c.a.compact]: n
						}),
						name: o,
						role: "menu",
						ref: this.dropdownButton,
						onBlur: this.handleDropdownBlur,
						onKeyDown: this.handleDropdownKeyDown
					}, a.a.createElement("span", {
						className: c.a.selectorContent,
						tabIndex: -1
					}, s), a.a.createElement(m.b, {
						className: c.a.caretDown
					})), a.a.createElement("div", {
						className: c.a.menuItems,
						onMouseDown: u,
						ref: this.menuItems
					}, r && this.getDropdownMenuItems()))
				}
			}
			t.b = p
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/lodash/flow.js"),
				a = s.n(n),
				o = s("./node_modules/react/index.js"),
				r = s.n(o),
				i = s("./node_modules/react-dnd/lib/index.js"),
				c = s("./node_modules/react-dnd-html5-backend/lib/index.js"),
				d = s("./src/reddit/helpers/dragDropContext/index.ts");
			const l = c.NativeTypes.FILE,
				m = a()(Object(i.DropTarget)(l, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const s = t.getItem();
						s.files && e.onDrop(s.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), d.a);
			class u extends r.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(r.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = m(u)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, s) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return b
			})), s.d(t, "b", (function() {
				return g
			})), s.d(t, "c", (function() {
				return E
			})), s.d(t, "d", (function() {
				return v
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/reddit/controls/ErrorText/index.tsx"),
				c = s("./src/reddit/icons/svgs/Plus/index.tsx"),
				d = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				l = s("./src/reddit/controls/FormFields/index.m.less"),
				m = s.n(l);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const b = r.a.input("input", m.a),
				h = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				g = e => {
					const {
						label: t,
						children: s,
						inputRef: n,
						className: r
					} = e, i = p(e, ["label", "children", "inputRef", "className"]), c = void 0 !== e.value && "" !== e.value;
					return a.a.createElement("div", {
						className: Object(o.a)(m.a.inputWrapper, r, {
							[m.a.mIsInvalid]: e.isInvalid
						}),
						onClick: h
					}, a.a.createElement(b, u({
						"aria-invalid": e.isInvalid,
						innerRef: n
					}, i)), e.label && a.a.createElement("label", {
						className: Object(o.a)(m.a.label, {
							[m.a.mHasValue]: c
						})
					}, e.label), e.children)
				},
				E = e => {
					const {
						label: t,
						children: s,
						inputRef: n,
						className: r,
						redditStyle: i
					} = e, c = p(e, ["label", "children", "inputRef", "className", "redditStyle"]), d = void 0 !== e.value && "" !== e.value;
					return a.a.createElement("div", {
						className: Object(o.a)(m.a.inputMovingLabelWrapper, r, {
							[m.a.mIsRedditStyle]: i
						}),
						onClick: h
					}, a.a.createElement(b, u({
						innerRef: n
					}, c)), e.label && a.a.createElement("label", {
						className: Object(o.a)(m.a.label, {
							[m.a.mHasValue]: d
						})
					}, e.label), e.children)
				},
				x = e => a.a.createElement("div", {
					className: Object(o.a)(m.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", a.a.createElement(c.a, {
					className: m.a.plus
				}));
			var f;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(f || (f = {}));
			class v extends a.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: f.ADD
						})
					}, this.updateValue = (e, t) => {
						const s = this.props.values.slice();
						s[t] = e.target.value, this.props.onChange(s)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							s = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: f.REMOVE,
							value: s,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: s,
						placeholder: n,
						errors: o = []
					} = this.props;
					return e.map((e, r) => a.a.createElement(g, {
						inputRef: e => this.setInputRef(e, r),
						isInvalid: !!o[r],
						disabled: t,
						type: "text",
						label: s,
						onChange: e => this.updateValue(e, r),
						placeholder: n,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, a.a.createElement("div", {
						className: m.a.trashContainer,
						onClick: () => this.removeValue(r)
					}, a.a.createElement(d.b, {
						className: m.a.trash
					})), !!o[r] && a.a.createElement(i.b, {
						className: m.a.errorText
					}, o[r])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: s,
						maxLength: n,
						addValueText: r,
						disabled: i
					} = this.props;
					this.focusedInput = null;
					const c = !(!!n && s.length >= n) && !i;
					return a.a.createElement("div", {
						className: Object(o.a)(m.a.multiInputWrapper, e)
					}, t && c && a.a.createElement(x, {
						onClick: this.addValue,
						text: r
					}), this.renderFields(), !t && c && a.a.createElement(x, {
						onClick: this.addValue,
						text: r
					}))
				}
			}
		},
		"./src/reddit/controls/ImageDisplay/index.m.less": function(e, t, s) {
			e.exports = {
				imageDisplay: "_1OSym2TYADlQNpSDWNxtjB"
			}
		},
		"./src/reddit/controls/ImageDisplay/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/controls/ImageDisplay/index.m.less"),
				i = s.n(r);
			t.a = e => {
				let {
					backgroundImage: t,
					children: s,
					className: n
				} = e;
				return a.a.createElement("div", {
					className: Object(o.a)(i.a.imageDisplay, n),
					style: {
						backgroundImage: "url('".concat(t, "')")
					},
					children: s
				})
			}
		},
		"./src/reddit/controls/ImageInput/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			class o extends a.a.Component {
				constructor(e) {
					super(e), this.onFileInput = e => {
						const t = e.currentTarget.files,
							s = this.props.multiple ? [...t] : t[0];
						this.props.onChange(s), this.setState(() => ({
							value: s
						}))
					}, this.state = {
						value: e.value || ""
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						value: e.value || ""
					}))
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = "string" == typeof t.value ? t.value : "", n = "object" == typeof t.value ? t.value : null, o = s || n;
					return a.a.createElement("div", {
						className: e.className
					}, s && a.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						readOnly: !0,
						type: "text",
						value: s,
						tabIndex: e.tabIndex
					}), !o && a.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						type: "file",
						onChange: this.onFileInput,
						accept: "image/x-png,image/jpeg",
						multiple: e.multiple || !1,
						tabIndex: e.tabIndex
					}))
				}
			}
		},
		"./src/reddit/controls/LayoutSwitch/index.m.less": function(e, t, s) {
			e.exports = {
				title: "_3gualOXr9lNla8__xISVq_",
				iconStyles: "_35qsI3TFFX54FD3PjwpLCv",
				mDisabled: "_2D3JNnADc6N28qHblqs-qW",
				mRedditStyle: "_1Y3PuNdUp_ye6oQQPIkE2Y",
				iconContainer: "_2Q-tHVfuqqIQLbMlSTJrlV",
				tooltip: "vCHkhDAaK6nnJdqEpMGq-",
				layoutButton: "_2KZsg_1r4DJcaP-Ug1LhsQ",
				mIsActive: "_70bDvpoC4B21zobSGUMe6",
				layoutSwitch: "_1o9Wtqx2f_wpqeyceGTV5w"
			}
		},
		"./src/reddit/controls/LayoutSwitch/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/app/strings/index.ts"),
				c = s("./src/lib/classNames/index.ts"),
				d = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				l = s("./src/reddit/actions/preferences.ts"),
				m = s("./src/reddit/actions/tooltip.ts"),
				u = s("./src/reddit/constants/postLayout.ts"),
				p = s("./src/reddit/icons/svgs/ClassicPosts/index.tsx"),
				b = s("./src/reddit/icons/svgs/CompactPosts/index.tsx"),
				h = s("./src/reddit/icons/svgs/LargePosts/index.tsx"),
				g = s("./src/reddit/components/TrackingHelper/index.tsx"),
				E = s("./src/reddit/contexts/PageLayer/index.tsx"),
				x = s("./src/reddit/selectors/telemetry.ts"),
				f = s("./src/reddit/selectors/user.ts"),
				v = s("./src/reddit/controls/LayoutSwitch/index.m.less"),
				C = s.n(v);

			function O() {
				return (O = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var j = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const y = e => Object(c.a)(C.a.iconStyles, e.className, {
					[C.a.mDisabled]: e.disabled,
					[C.a.mRedditStyle]: e.redditStyle
				}),
				k = e => {
					var {
						isActive: t
					} = e, s = j(e, ["isActive"]);
					return a.a.createElement("button", O({
						className: Object(c.a)(C.a.layoutButton, {
							[C.a.mIsActive]: t
						})
					}, s))
				},
				w = Object(i.e)("listings.layoutSwitcher.label"),
				S = Object(i.e)("listings.layoutSwitcher.card"),
				N = Object(i.e)("listings.layoutSwitcher.classic"),
				T = Object(i.e)("listings.layoutSwitcher.compact"),
				_ = [{
					layout: u.d.Card,
					Icon: e => {
						var {
							className: t,
							disabled: s,
							redditStyle: n
						} = e, o = j(e, ["className", "disabled", "redditStyle"]);
						return a.a.createElement(h.a, O({
							className: y({
								className: t,
								disabled: s,
								redditStyle: n
							})
						}, o))
					},
					tooltipTranslation: S
				}, {
					layout: u.d.Classic,
					Icon: e => {
						var {
							className: t,
							disabled: s,
							redditStyle: n
						} = e, o = j(e, ["className", "disabled", "redditStyle"]);
						return a.a.createElement(p.a, O({
							className: y({
								className: t,
								disabled: s,
								redditStyle: n
							})
						}, o))
					},
					tooltipTranslation: N
				}, {
					layout: u.d.Compact,
					Icon: e => {
						var {
							className: t,
							disabled: s,
							redditStyle: n
						} = e, o = j(e, ["className", "disabled", "redditStyle"]);
						return a.a.createElement(b.a, O({
							className: y({
								className: t,
								disabled: s,
								redditStyle: n
							})
						}, o))
					},
					tooltipTranslation: T
				}],
				I = Object(E.t)(),
				P = Object(r.c)({
					language: f.S,
					postLayout: E.M,
					redditStyle: E.B
				}),
				M = Object(o.b)(P, e => ({
					onListingLayoutChange: (t, s) => e(Object(l.v)(t, s)),
					toggleTooltip: t => e(Object(m.g)({
						tooltipId: t
					}))
				}), (e, t, s) => Object.assign({}, e, t, s, {
					toggleTooltip: e => t.toggleTooltip(e)
				}));
			t.a = I(M(Object(g.b)(e => {
				const {
					sendEvent: t,
					subredditId: s
				} = e, n = e.layout || u.e[e.postLayout];
				return a.a.createElement("div", {
					className: Object(c.a)(C.a.layoutSwitch, e.className),
					id: "view--layout--FUE"
				}, a.a.createElement("div", {
					className: C.a.title
				}, w(e.language)), a.a.createElement("div", {
					className: C.a.iconContainer
				}, _.map(o => {
					const r = () => (n => {
							e.onChange ? e.onChange(n) : (e.onListingLayoutChange(n, s), t(e => ({
								source: "layout_switch",
								action: "click",
								noun: n,
								screen: Object(x.screen)(e),
								subreddit: Object(x.subreddit)(e)
							})))
						})(o.layout),
						i = () => e.toggleTooltip(c),
						c = "layoutSwitch--" + o.layout,
						l = o.layout === n;
					return a.a.createElement(k, {
						"aria-label": o.tooltipTranslation(e.language),
						"aria-pressed": l,
						id: c,
						isActive: l,
						key: o.layout,
						onClick: r,
						onMouseEnter: i,
						onMouseLeave: i,
						onTouchStart: r
					}, a.a.createElement(o.Icon, {
						disabled: !l,
						onClick: l ? void 0 : e.onLayoutClick,
						redditStyle: e.redditStyle
					}), a.a.createElement(d.c, {
						className: C.a.tooltip,
						tooltipId: c,
						text: o.tooltipTranslation(e.language)
					}))
				})))
			})))
		},
		"./src/reddit/controls/MetaData/index.m.less": function(e, t, s) {
			e.exports = {
				metaText: "_2ETuFsVzMBxiHia6HfJCTQ"
			}
		},
		"./src/reddit/controls/MetaData/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "b", (function() {
				return h
			})), s.d(t, "d", (function() {
				return g
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/app/strings/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				i = s("./src/lib/prettyPrintNumber/index.ts"),
				c = (s("./src/lib/timeAgo/index.ts"), s("./src/reddit/i18n/utils.ts")),
				d = s("./src/reddit/controls/MetaData/index.m.less"),
				l = s.n(d),
				m = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var a = 0;
						for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
					}
					return s
				};
			const u = r.a.span("metaText", l.a),
				p = e => a.a.createElement(u, e, " · "),
				b = Object(o.d)("comment.point"),
				h = e => {
					var {
						isScoreHidden: t,
						language: s,
						score: n,
						useUpvotes: o
					} = e, r = m(e, ["isScoreHidden", "language", "score", "useUpvotes"]);
					const d = Object(i.b)(n),
						l = Object(c.c)("\n    ".concat(Object(c.b)("score", d), " ").concat(Object(c.a)("upvotes", ["upvote", "upvotes"], n), "\n  ")),
						p = t ? Object(c.c)("Score hidden") : o ? l : b(s, n, {
							count: d
						});
					return a.a.createElement(u, r, p)
				},
				g = (e, t) => {
					const s = Object(o.c)(t, "posts.comments.noun", e, {
						count: Object(i.b)(e)
					});
					return a.a.createElement(u, null, s)
				}
		},
		"./src/reddit/controls/SearchBar/index.m.less": function(e, t, s) {
			e.exports = {
				searchContainer: "_13yLxNALfY3_F48PYybgUr",
				search: "RxQA71ktKLBiPThTT7ita",
				mRightAlignedIcon: "_1NR83qzzPFX9KcVm-fxGFg",
				searchIconContainer: "_1IUrembT3LfQzzy388S8eF",
				mClickable: "_1K9n38-jQENV0_njgPIo_x",
				mRightAligned: "_1fLhMe5y6XbNg-lgHQrh5e"
			}
		},
		"./src/reddit/controls/SearchBar/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Search/index.tsx"),
				i = s("./src/reddit/controls/SearchBar/index.m.less"),
				c = s.n(i);
			t.a = e => a.a.createElement("div", {
				className: Object(o.a)(c.a.searchContainer, e.className)
			}, a.a.createElement("input", {
				className: Object(o.a)(c.a.search, {
					[c.a.mRightAlignedIcon]: e.rightAlignedIcon
				}),
				autoFocus: e.autoFocus,
				type: "text",
				onChange: e.onTextChange,
				onKeyPress: e.onKeyPress,
				placeholder: e.placeholder,
				ref: e.innerRef,
				value: e.value
			}), a.a.createElement("div", {
				className: Object(o.a)(c.a.searchIconContainer, {
					[c.a.mClickable]: !!e.onSearch,
					[c.a.mRightAligned]: e.rightAlignedIcon
				}),
				onClick: e.onSearch
			}, a.a.createElement(r.a, null)))
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, s) {
			"use strict";
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/helpers/dragDropContext/index.ts"),
				r = s("./node_modules/lodash/flow.js"),
				i = s.n(r),
				c = s("./node_modules/react-dnd/lib/index.js");
			class d extends a.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? i()(e.connectDropTarget, e.connectDragSource)(a.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var l = i()(Object(c.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const s = t.getDropResult();
						e.onDrop(e.id, s.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(c.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const s = t.getItem();
					return e.id !== s.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(d);
			class m extends a.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(s => {
							const n = s.values.slice(),
								a = n.indexOf(e),
								o = n.splice(a, 1)[0];
							let r = n.indexOf(t);
							return a <= r && (r += 1), n.splice(r, 0, o), this.props.onDrop(e, t, n), {
								values: n
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: s,
						render: n
					} = this.props;
					return a.a.createElement("div", {
						className: e
					}, this.state.values.map((e, o) => a.a.createElement(l, {
						id: e,
						key: t && t(e),
						index: o,
						render: n,
						onDrop: this.onDrop,
						onClick: s
					})))
				}
			}
			t.a = Object(o.a)(m)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, s) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/controls/InternalLink/index.tsx"),
				o = s("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				r = s.n(o);
			t.a = n.a.wrapped(a.a, "unstyledInternalLink", r.a)
		},
		"./src/reddit/endpoints/economics/uploadedAssets.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "d", (function() {
				return d
			}));
			var n, a, o = s("./src/config.ts"),
				r = s("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t, s, n) {
				const a = "assetType=".concat(s, "&assetStatus=").concat(n);
				return Object(r.a)(e, {
					method: "get",
					endpoint: "".concat(o.a.metaUrl, "/modtools/").concat(t, "/assets?").concat(a)
				})
			}

			function c(e, t, s) {
				const a = new FormData;
				return a.append("assetType", s.assetType), a.append("assetName", s.assetName), a.append("upfile", s.imageFile), s.assetType === n.Badge && (a.append("badgeColor", s.badgeColor || ""), a.append("badgeDescription", s.badgeDescription || "")), Object(r.a)(e, {
					endpoint: "".concat(o.a.metaUrl, "/modtools/").concat(t, "/assets"),
					method: "post",
					type: null,
					data: a
				})
			}

			function d(e, t, s, n, a) {
				return Object(r.a)(e, {
					endpoint: "".concat(o.a.metaUrl, "/modtools/").concat(t, "/assets/").concat(s, "s/").concat(n),
					method: "patch",
					data: a
				})
			}! function(e) {
				e.Badge = "badge", e.Emote = "emote"
			}(n || (n = {})),
			function(e) {
				e.Uploaded = "uploaded", e.Approved = "approved", e.Rejected = "rejected"
			}(a || (a = {}))
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "d", (function() {
				return i
			})), s.d(t, "e", (function() {
				return c
			})), s.d(t, "b", (function() {
				return d
			}));
			var n, a = s("./src/config.ts"),
				o = s("./src/reddit/endpoints/governance/requester.ts");

			function r(e) {
				switch (e) {
					case n.Ethereum:
						return "Ethereum Main Network";
					case n.Rinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}
			async function i(e, t, s) {
				return Object(o.a)(e, {
					method: "post",
					endpoint: "".concat(a.a.metaUrl, "/crypto/").concat(t, "/challenges"),
					data: {
						challengeType: "registration-challenge-EIP712",
						address: s
					}
				})
			}
			async function c(e, t, s) {
				return await Object(o.a)(e, {
					method: "post",
					endpoint: "".concat(a.a.metaUrl, "/crypto/").concat(t, "/registrations"),
					data: s
				})
			}
			async function d(e, t, s) {
				return await Object(o.a)(e, {
					method: "delete",
					endpoint: "".concat(a.a.metaUrl, "/crypto/").concat(t, "/registrations/").concat(s)
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.Stellar = "stellar"
			}(n || (n = {}))
		},
		"./src/reddit/endpoints/governance/poll.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return m
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "a", (function() {
				return p
			}));
			var n = s("./node_modules/lodash/get.js"),
				a = s.n(n),
				o = s("./src/config.ts"),
				r = s("./src/graphql/operations/PollVote.json"),
				i = s("./src/lib/makeGqlRequest/index.ts"),
				c = s("./src/lib/omitHeaders/index.ts"),
				d = s("./src/reddit/constants/headers.ts"),
				l = (s("./src/reddit/models/Poll/index.ts"), s("./src/reddit/endpoints/governance/requester.ts"));

			function m(e, t, s, n) {
				return Object(l.a)(e, {
					method: "put",
					endpoint: "".concat(o.a.metaUrl, "/polls/").concat(t, "/").concat(s, "/votes/me/").concat(n)
				})
			}
			const u = (e, t, s) => Object(i.a)(e, Object.assign({}, r, {
				variables: {
					input: {
						postId: t,
						optionId: s
					}
				}
			}));

			function p(e, t) {
				return Object(l.a)(Object(c.a)(e, [d.a]), {
					method: "get",
					endpoint: "".concat(e.apiUrl, "/by_id/").concat(t, ".json")
				}).then(e => e.ok ? Object.assign({}, e, {
					body: {
						title: a()(e.body, ["data", "children", 0, "data", "title"], ""),
						url: a()(e.body, ["data", "children", 0, "data", "permalink"], "")
					}
				}) : e)
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/config.ts"),
				a = (s("./src/lib/bigNumberUtils/percent.ts"), s("./src/lib/constants/index.ts")),
				o = s("./src/reddit/endpoints/governance/requester.ts");

			function r(e, t) {
				return Object(o.a)(e, {
					endpoint: "".concat(n.a.metaUrl, "/wallets/").concat(t.subredditId, "/me"),
					method: a.bb.GET
				}).then(e => {
					if (e.ok) {
						const s = e.body,
							n = {
								[t.subredditId]: s
							};
						return Object.assign({}, e, {
							body: n
						})
					}
					return e
				})
			}

			function i(e, t) {
				return Object(o.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: "".concat(n.a.metaUrl, "/wallets/").concat(t.subredditId),
					method: a.bb.POST,
					data: t.userIds
				}).then(e => e.ok ? Object.assign({}, e, {
					body: {
						wallets: e.body
					}
				}) : e)
			}
		},
		"./src/reddit/endpoints/page/subredditWiki.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/lib/makeGqlRequest/index.ts"),
				a = s("./src/graphql/operations/SubredditWiki.json");
			const o = (e, t) => Object(n.a)(e, Object.assign({}, a, {
				variables: t
			}))
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return c
			})), s.d(t, "c", (function() {
				return d
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "a", (function() {
				return p
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/graphql/operations/CreateScheduledPost.json"),
				a = s("./src/graphql/operations/SubredditScheduledPosts.json"),
				o = s("./src/lib/makeGqlRequest/index.ts"),
				r = s("./src/reddit/helpers/flair.ts"),
				i = s("./src/reddit/models/PostCreationForm/index.ts");
			const c = (e, t) => {
					let {
						subredditId: s,
						after: n,
						first: r
					} = t;
					return Object(o.a)(e, Object.assign({}, a, {
						variables: {
							subredditId: s,
							after: n,
							first: r
						}
					}))
				},
				d = (e, t, s) => Object.assign({
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNSFW,
					title: e.title,
					isOriginalContent: e.isOC,
					flair: e.flair ? {
						id: e.flair.templateId,
						text: Object(r.g)(e.flair)
					} : {},
					subredditId: s,
					isSendReplies: e.sendReplies,
					scheduling: {
						publishAt: t.submitDate,
						clientTimezone: t.timezoneName,
						frequency: t.frequencyOption,
						interval: t.recurrenceInfo ? t.recurrenceInfo.interval : void 0,
						byMonthDays: t.recurrenceInfo ? t.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: t.recurrenceInfo ? t.recurrenceInfo.byWeekDays : void 0
					}
				}, u(e)),
				l = e => {
					const t = d(e.submission, e.schedule, e.subredditId);
					return Object.assign({
						id: e.scheduledPostId
					}, t, {
						flair: Object.keys(t.flair || {}).length ? Object.assign({}, t.flair) : {
							id: "",
							text: ""
						}
					})
				},
				m = e => /^https?:\/\//i.test(e) ? e : "http://".concat(e),
				u = e => {
					switch (e.kind) {
						case i.p.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case i.p.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case i.p.LINK:
							return {
								content: {}, link: {
									url: m(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				p = (e, t) => Object(o.a)(e, Object.assign({}, n, {
					variables: {
						input: t
					}
				}))
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/graphql/operations/UpdateScheduledPost.json"),
				a = s("./src/lib/makeGqlRequest/index.ts");
			const o = (e, t) => Object(a.a)(e, Object.assign({}, n, {
				variables: {
					input: t
				}
			}))
		},
		"./src/reddit/endpoints/subredditModeration/moderationLog.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			}));
			var n = s("./src/graphql/operations/AllModerators.json"),
				a = s("./src/graphql/operations/FetchModerationLogActions.json"),
				o = s("./src/lib/makeGqlRequest/index.ts");
			const r = (e, t, s) => Object(o.a)(e, Object.assign({}, a, {
					variables: Object.assign({
						subredditName: t
					}, s)
				})),
				i = (e, t) => Object(o.a)(e, Object.assign({}, n, {
					variables: {
						subredditName: t
					}
				}))
		},
		"./src/reddit/featureFlags/component.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			}));
			s("./node_modules/core-js/modules/es6.symbol.js");
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./node_modules/react-redux/es/index.js"),
				r = s("./node_modules/reselect/es/index.js"),
				i = s("./src/reddit/featureFlags/index.ts"),
				c = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var a = 0;
						for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
					}
					return s
				};

			function d(e, t, s) {
				const n = Object(r.c)({
					featureEnabled: t => i.d[e](t)
				});
				return Object(o.b)(n)(e => {
					const {
						featureEnabled: n,
						dispatch: o
					} = e, r = c(e, ["featureEnabled", "dispatch"]);
					return n ? a.a.createElement(t, r) : void 0 !== s ? a.a.createElement(s, r) : null
				})
			}
		},
		"./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/reddit/models/Subreddit/index.ts");
			const a = new Set(["goins", "gold_testing", "inthesoulstone", "lounge", "lssgoldnormal", "maymodsguide1", "maymodsguide2", "megalounge", "pan2", "pan3", "venkman_bookclub", "whatssnoo"]),
				o = new Set([n.c.Private]),
				r = e => !(!e || !e.name) && (!!a.has(e.name.toLowerCase()) || !e.isNSFW && !e.isQuarantined && !o.has(e.type))
		},
		"./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = new Set(["t5_q0gj4", "t5_z5gli", "t5_22cerq", "t5_3j0kj"]),
				a = e => n.has(e)
		},
		"./src/reddit/helpers/brandSafety/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return a
			}));
			var n = s("./src/reddit/models/WhitelistStatus/index.ts");
			const a = (e, t) => {
				const s = e.some(e => e.isNSFW),
					a = t.some(e => e.wls === n.a.NO_ADS);
				return !s && !a
			}
		},
		"./src/reddit/helpers/canAccessModerationPage/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/constants/index.ts");
			t.a = (e, t, s, a, o, r) => {
				switch (e) {
					case n.Nb.Awards:
						return !!t && !!s;
					case n.Nb.SubredditRules:
					case n.Nb.Moderators:
						return !0;
					case n.Nb.Modlog:
						return !!t;
					case n.Nb.Muted:
						return !!(t && t.access && t.mail);
					case n.Nb.Banned:
					case n.Nb.Contributors:
						return !(!t || !t.access);
					case n.Nb.Flair:
					case n.Nb.PostFlair:
					case n.Nb.UserFlair:
						return !(!t || !t.flair);
					case n.Nb.CommunitySettings:
						return !(!t || !t.config);
					case n.Nb.Modqueue:
					case n.Nb.Reports:
					case n.Nb.Edited:
					case n.Nb.Spam:
					case n.Nb.Unmoderated:
					case n.Nb.PostRequirements:
					case n.Nb.Removal:
						return !(!t || !t.posts);
					case n.Nb.Badges:
					case n.Nb.Emojis:
						return !!t;
					case n.Nb.Emotes:
						return !(!t || !t.config);
					case n.Nb.Streaming:
						return !!(r && t && t.config);
					case n.Nb.Wiki:
					case n.Nb.WikiBanned:
					case n.Nb.WikiContributors:
						return !(!t || !t.wiki);
					case n.Nb.Traffic:
						return o || !!t;
					case n.Nb.SubredditContent:
						return !!a;
					default:
						return !1
				}
			}
		},
		"./src/reddit/helpers/describeApiError/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/app/strings/index.ts"),
				a = s("./src/lib/constants/index.ts");

			function o(e) {
				let {
					apiError: t,
					isLoggedOut: s,
					language: o
				} = e;
				switch (t.type) {
					case a.D.AUTHORIZATION_ERROR:
						return s ? Object(n.a)(o, "error.type.notLoggedIn") : Object(n.a)(o, "error.type.notAuthorized");
					case a.D.VALIDATION_ERROR:
						return Object(n.a)(o, "error.type.validation");
					case a.D.NOT_FOUND_ERROR:
						return Object(n.a)(o, "error.type.notFound");
					case a.D.SERVER_ERROR:
						return Object(n.a)(o, "error.type.server");
					case a.D.LIKELY_UBLOCK_ERROR:
						return Object(n.a)(o, "error.type.blocked");
					default:
						return Object(n.a)(o, "error.type.generic")
				}
			}
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react-dnd/lib/index.js"),
				a = s("./node_modules/react-dnd-html5-backend/lib/index.js"),
				o = s.n(a);
			t.a = Object(n.DragDropContext)(o.a)
		},
		"./src/reddit/helpers/getClickInfo.ts": function(e, t, s) {
			"use strict";
			t.a = e => ({
				hasNewTabModifier: !(!e.metaKey && !e.ctrlKey && 1 !== e.button)
			})
		},
		"./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return a
			})), s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/reddit/helpers/graphql/helpers.ts");
			const a = e => {
					const t = [];
					for (const {
							node: s
						} of e.edges) {
						const {
							action: e,
							actionNotes: a,
							createdAt: o,
							details: r,
							id: i,
							moderator: c,
							subredditName: d,
							target: l
						} = s, m = {
							action: e,
							actionNotes: a,
							createdAt: Object(n.j)(o),
							details: r,
							id: i,
							moderator: c,
							subredditName: d,
							target: l
						};
						t.push(m)
					}
					return t
				},
				o = e => {
					const t = [];
					for (const {
							node: s
						} of e.edges) {
						const {
							id: e,
							name: n
						} = s, a = {
							id: e,
							name: n
						};
						t.push(a)
					}
					return t
				}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return o
			}));
			const n = e => Object.assign({}, e, {
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: {
							standalonePosts: {
								pageInfo: Object.assign({}, e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo),
								models: a(e.subredditInfoById.scheduledPosts.standalonePosts.edges)
							},
							standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
						}
					}
				}),
				a = e => e.map(e => o(e.node)),
				o = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					subreddit: Object.assign({}, e.subreddit),
					owner: Object.assign({}, e.owner),
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt,
					state: e.state,
					flair: e.flair ? Object.assign({}, e.flair) : void 0,
					isSticky: "NONE" !== e.sticky && !!e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				})
		},
		"./src/reddit/helpers/isValidHexColor/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			const n = /^#[0-9a-f]{6}$/i,
				a = /^#?[0-9a-f]{6}$/i,
				o = 7;
			t.b = (e, t) => {
				return !!e && (t ? a : n).test(e)
			}
		},
		"./src/reddit/helpers/isValidUsername/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/reddit/helpers/normalizeUsername/index.tsx");
			t.a = e => {
				const t = Object(n.a)(e.trim());
				return t.length > 2 && t.length <= 20
			}
		},
		"./src/reddit/helpers/makeModQueueListingKey/index.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				const {
					profile: t,
					subreddit: s
				} = e;
				let n = s && "r/".concat(s) || t && "u/".concat(t) || "all";
				return "comments" !== e.onlyOfType && "links" !== e.onlyOfType || (n += "--[".concat(e.onlyOfType, "]")), n
			}
		},
		"./src/reddit/helpers/postComponentForLayout/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return g
			})), s.d(t, "b", (function() {
				return v
			}));
			var n = s("./node_modules/@loadable/component/dist/loadable.esm.js"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./src/lib/isUrl/index.ts"),
				i = s("./src/lib/logs/console.ts"),
				c = s("./src/reddit/constants/postLayout.ts"),
				d = s("./src/reddit/models/Media/index.ts");
			const l = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-BlankPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => s.e("reddit-components-BlankPost").then(s.bind(null, "./src/reddit/components/BlankPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/BlankPost/index.tsx"
					}
				}),
				m = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-ClassicPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("ChatPost~CollectionCommentsPage~CommentsPage~Frontpage~ModQueuePages~ModerationPages~Poll~PostCreati~84248ed7"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~GovernanceReleaseNotesModal~InFeedChaining~Mod~20a7252d"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~PostDraft~Pr~17e24337"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~ProfileComme~ccaebd21"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOv~53fee4bd"), s.e("CollectionCommentsPage~CommentsPage~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOverview~P~d01aa6d4"), s.e("Poll~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~~da5a0d34"), s.e("reddit-components-ClassicPost")]).then(s.bind(null, "./src/reddit/components/ClassicPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/ClassicPost/index.tsx"
					}
				}),
				u = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-CompactPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("ChatPost~CollectionCommentsPage~CommentsPage~Frontpage~ModQueuePages~ModerationPages~Poll~PostCreati~84248ed7"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~GovernanceReleaseNotesModal~InFeedChaining~Mod~20a7252d"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~PostDraft~Pr~17e24337"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~ProfileComme~ccaebd21"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOv~53fee4bd"), s.e("CollectionCommentsPage~CommentsPage~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOverview~P~d01aa6d4"), s.e("Poll~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~~da5a0d34"), s.e("reddit-components-CompactPost")]).then(s.bind(null, "./src/reddit/components/CompactPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/CompactPost/index.tsx"
					}
				}),
				p = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-LargePost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("ChatPost~CollectionCommentsPage~CommentsPage~Frontpage~ModQueuePages~ModerationPages~Poll~PostCreati~84248ed7"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~GovernanceReleaseNotesModal~InFeedChaining~Mod~20a7252d"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~PostDraft~Pr~17e24337"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~ProfileComme~ccaebd21"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOv~53fee4bd"), s.e("CollectionCommentsPage~CommentsPage~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOverview~P~d01aa6d4"), s.e("Poll~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~~da5a0d34"), s.e("reddit-components-LargePost")]).then(s.bind(null, "./src/reddit/components/LargePost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/LargePost/index.tsx"
					}
				}),
				b = Object(n.a)({
					resolved: {},
					chunkName: () => "reddit-components-MediumPost",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!s.m[t]
					},
					importAsync: () => Promise.all([s.e("ChatPost~CollectionCommentsPage~CommentsPage~Frontpage~ModQueuePages~ModerationPages~Poll~PostCreati~84248ed7"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~PostDraft~Pr~17e24337"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~PostCreation~ProfileComme~ccaebd21"), s.e("CollectionCommentsPage~CommentsPage~Explore~Frontpage~ModerationPages~Poll~ProfileComments~ProfileOv~53fee4bd"), s.e("Poll~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-LargePost~~da5a0d34"), s.e("reddit-components-MediumPost")]).then(s.bind(null, "./src/reddit/components/MediumPost/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return s(t)
					},
					resolve() {
						return "./src/reddit/components/MediumPost/index.tsx"
					}
				}),
				h = {
					[c.g.Large]: p,
					[c.g.Medium]: b,
					[c.g.Classic]: m,
					[c.g.Compact]: u
				},
				g = e => o.a.createElement(l, e),
				E = ["https://www.mcdonalds.com", "https://d2n94wep25xhn0.cloudfront.net", "https://www.dyson.com", "https://dyson.com"],
				x = e => e.source && e.source.url && e.isSponsored && E.some(t => e.source.url.startsWith(t)),
				f = e => !e.media || e.media.type === d.n.EMBED && !(d.b.has(e.media.provider) || x(e));

			function v(e) {
				let {
					isCrosspost: t,
					isFirstPost: s,
					layout: n,
					post: a
				} = e;
				if (a.isBlank) return g;
				const o = !a.media && !!a.source && Object(r.a)(a.source.url),
					d = t && o;
				n === c.g.Large && f(a) && !d && (n = c.g.Medium);
				const l = h[n];
				return void 0 === l ? (Object(i.a)(void 0, "Could not find component for layout ".concat(n, ".")), g) : s && a.isSponsored && n === c.g.Large ? b : l
			}
		},
		"./src/reddit/helpers/readOnlyMode/index.ts": function(e, t, s) {
			"use strict";
			var n;
			s.d(t, "a", (function() {
					return n
				})), s.d(t, "b", (function() {
					return a
				})), s.d(t, "c", (function() {
					return o
				})),
				function(e) {
					e.editable = "editable", e.focusableReadOnly = "focusablereadonly", e.readOnly = "readonly"
				}(n || (n = {}));
			const a = e => o(e) || e === n.focusableReadOnly,
				o = e => e === n.readOnly
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "c", (function() {
				return l
			})), s.d(t, "d", (function() {
				return m
			})), s.d(t, "e", (function() {
				return u
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = s("./src/app/strings/index.ts"),
				a = s("./src/lib/timezone/index.ts");
			const o = (e, t) => {
					const s = e.toLocaleDateString(t, {
							month: "numeric",
							day: "numeric"
						}),
						n = e.toLocaleTimeString(t, {
							hour: "numeric",
							minute: "numeric"
						});
					return "".concat(s, " @ ").concat(n.replace(" ", "").toLowerCase())
				},
				r = (e, t, s) => {
					if (e && t) {
						const r = Object(a.f)(c(e, t)),
							i = o(r, s);
						return Object(n.a)(s, "postCreation.schedulePicker.submitAtTime", {
							time: i
						})
					}
					return Object(n.a)(s, "postCreation.schedulePicker.submitAtTimeScheduleTime")
				},
				i = e => e.slice(0, 5),
				c = (e, t) => "".concat(e, "T").concat(i(t), ":00"),
				d = e => {
					const [t, s] = e.split("T");
					return [t, i(s)]
				},
				l = (e, t) => {
					const [s, n] = d(e);
					if (s && n) {
						const e = Object(a.f)(c(s, n));
						return o(e, t)
					}
					return ""
				},
				m = e => {
					const t = Object(a.d)(e);
					let s, n = e;
					if (t) {
						s = t.offset;
						const o = Object(a.e)(t.offset),
							r = e.replace("/", " - ").replace(/_/g, " ");
						n = "(GMT".concat(o, ") ").concat(r)
					}
					return {
						name: e,
						displayText: n,
						offset: s
					}
				},
				u = e => "string" == typeof e
		},
		"./src/reddit/helpers/styles/mixins/index.m.less": function(e, t, s) {
			e.exports = {
				basePostStyles: "REwsaLIz5u3DhM7zbbzIU",
				classicPostStyles: "bE7JgM2ex7W3aF3zci5bm",
				compactPostStyles: "FeLWdhOO-cVXowAo3Rndk",
				baseLargeAndMediumPostStyles: "_2lHXa-mLMsRfm1Q5JxgU4r",
				largeAndMediumPostStyles: "_3Qkp11fjcAw9I9wtLo8frE",
				baseClassicAndCompactPostStyles: "_2yN8L-c8UBoKxHn0-vg_dS",
				baseSubredditStyles: "_2zRMh6o0BucltCL6o64pa4",
				classicAndCompactActiveStyles: "_1Accc3h2AW0sB8E4CcEz2n",
				mIsActive: "_1LmKpEAguLZV4jQMgQSFVL",
				classicAndCompactPlaceholderStyles: "_3joKifdh6j3tG_vsgFS85R",
				mUseRedditTheme: "_1nQXomgzQ2rnBsRU2iZ00l",
				largeAndMediumActiveStyles: "_1qftyZQ2bhqP62lbPjoGAh"
			}
		},
		"./src/reddit/helpers/styles/mixins/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			})), s.d(t, "b", (function() {
				return h
			})), s.d(t, "a", (function() {
				return g
			})), s.d(t, "d", (function() {
				return E
			}));
			var n = s("./node_modules/polished/dist/polished.es.js"),
				a = s("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				o = s("./src/reddit/helpers/styles/smartTextColor.ts"),
				r = s("./src/reddit/models/NewStructuredStyles/index.ts"),
				i = s("./src/reddit/models/Theme/index.ts"),
				c = s("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				d = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				l = s.n(d);
			const m = {},
				u = e => Object(i.g)(Object(c.a)(e).post, Object(c.a)(e).backgroundImage, Object(c.a)(e).backgroundImagePosition),
				p = (e, t) => {
					if (e) {
						if (e.postBackgroundImage) return {
							background: Object(i.g)(e.postBackgroundColor || Object(c.a)(t).post, e.postBackgroundImage, Object(c.a)(t).backgroundImagePosition)
						};
						if (e.postBackgroundColor) return {
							background: Object(i.g)(e.postBackgroundColor, null, null)
						}
					}
					return {
						background: u(t)
					}
				},
				b = e => Object(n.o)(.2, e),
				h = e => e && e.postBackgroundColor ? {
					backgroundColor: b(e.postBackgroundColor)
				} : m,
				g = e => e.isActive ? l.a.mIsActive : void 0,
				E = e => {
					const t = Object(o.a)(Object(a.a)(e), r.a.actionIcon, r.b.actionIcon);
					return {
						color: t,
						cursor: "pointer",
						fill: t
					}
				}
		},
		"./src/reddit/helpers/trackers/communityAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "d", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "b", (function() {
				return l
			})), s.d(t, "e", (function() {
				return m
			})), s.d(t, "a", (function() {
				return u
			})), s.d(t, "c", (function() {
				return p
			}));
			var n = s("./src/reddit/models/Gold/Award.ts"),
				a = s("./src/reddit/selectors/telemetry.ts"),
				o = s("./src/reddit/helpers/correlationIdTracker.ts");
			const r = e => Object.assign({}, a.defaults(e), {
					screen: a.screen(e),
					subreddit: a.subreddit(e),
					userSubreddit: a.userSubreddit(e)
				}),
				i = e => ({
					awardId: e.id,
					awardName: e.name,
					isModAward: e.awardType === n.c.Moderator,
					numberCoins: e.coinPrice,
					numberMonths: Math.floor((e.daysOfPremium || 0) / 30),
					numberCoinsToRecipient: e.coinReward || 0,
					numberCoinsToCommunity: e.subredditCoinReward || 0
				}),
				c = () => e => Object.assign({}, r(e), {
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create"
				}),
				d = e => t => Object.assign({}, r(t), {
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardDeletionFlow),
					noun: "delete",
					goldPurchase: e ? i(e) : null,
					media: e ? {
						url: e.icon.url
					} : null
				}),
				l = (e, t, s) => n => Object.assign({}, r(n), {
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: s
				}),
				m = (e, t, s, n) => a => Object.assign({}, r(a), {
					source: "create_award",
					action: "upload",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "image",
					actionInfo: n ? {
						reason: n
					} : {
						success: !0
					},
					media: t ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						uploadDuration: s,
						url: e,
						width: t.width
					} : null
				}),
				u = (e, t, s) => n => Object.assign({}, r(n), {
					source: "create_award",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create",
					media: t && e ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						url: e,
						width: t.width
					} : null,
					goldPurchase: s ? i(s) : null
				}),
				p = (e, t, s) => n => Object.assign({}, r(n), {
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: s ? i(s) : null
				})
		},
		"./src/reddit/helpers/trackers/modHub.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return o
			})), s.d(t, "c", (function() {
				return r
			})), s.d(t, "a", (function() {
				return i
			}));
			var n = s("./src/reddit/selectors/telemetry.ts");
			const a = e => ({
					screen: n.screen(e),
					subreddit: n.subreddit(e),
					userSubreddit: n.userSubreddit(e)
				}),
				o = e => t => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: e
				}, a(t)),
				r = () => e => Object.assign({
					source: "breadcrumb",
					action: "click",
					noun: "subreddit"
				}, a(e)),
				i = () => e => Object.assign({
					source: "id_card",
					action: "click",
					noun: "mod_hub_nav"
				}, a(e))
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, s) {
			"use strict";
			s.d(t, "e", (function() {
				return r
			})), s.d(t, "n", (function() {
				return i
			})), s.d(t, "g", (function() {
				return c
			})), s.d(t, "j", (function() {
				return d
			})), s.d(t, "k", (function() {
				return l
			})), s.d(t, "a", (function() {
				return m
			})), s.d(t, "b", (function() {
				return u
			})), s.d(t, "i", (function() {
				return p
			})), s.d(t, "l", (function() {
				return b
			})), s.d(t, "f", (function() {
				return h
			})), s.d(t, "o", (function() {
				return g
			})), s.d(t, "c", (function() {
				return E
			})), s.d(t, "h", (function() {
				return x
			})), s.d(t, "d", (function() {
				return f
			})), s.d(t, "m", (function() {
				return v
			}));
			var n = s("./src/reddit/selectors/telemetry.ts");
			const a = e => Object.assign({}, n.defaults(e), {
					screen: n.screen(e),
					subreddit: n.subreddit(e),
					userSubreddit: n.userSubreddit(e)
				}),
				o = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone
				}),
				r = () => e => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post"
				}, a(e)),
				i = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer"
				}, a(e)),
				c = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date"
				}, a(e)),
				d = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time"
				}, a(e)),
				l = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone"
				}, a(e)),
				m = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply"
				}, a(e)),
				u = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel"
				}, a(e)),
				p = e => t => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit"
				}, a(t), {
					scheduledPost: o(e)
				}),
				b = e => t => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit"
				}, a(t), {
					scheduledPost: o(e)
				}),
				h = () => e => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts"
				}, a(e)),
				g = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, a(e)),
				E = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "edit_post"
				}, a(e)),
				x = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "submit_post_now"
				}, a(e)),
				f = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "overflow_menu"
				}, a(e)),
				v = () => (e, t) => {
					const s = a(e);
					return Object.assign({
						source: "post",
						action: "view",
						noun: "error"
					}, s, {
						actionInfo: Object.assign({}, s.actionInfo, {
							reason: "failed_post"
						}),
						scheduledPost: o(t)
					})
				}
		},
		"./src/reddit/helpers/trackers/subredditWiki.ts": function(e, t, s) {
			"use strict";
			s.d(t, "f", (function() {
				return r
			})), s.d(t, "g", (function() {
				return i
			})), s.d(t, "m", (function() {
				return d
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "k", (function() {
				return m
			})), s.d(t, "q", (function() {
				return u
			})), s.d(t, "r", (function() {
				return p
			})), s.d(t, "c", (function() {
				return b
			})), s.d(t, "j", (function() {
				return h
			})), s.d(t, "p", (function() {
				return g
			})), s.d(t, "e", (function() {
				return E
			})), s.d(t, "b", (function() {
				return x
			})), s.d(t, "i", (function() {
				return f
			})), s.d(t, "a", (function() {
				return v
			})), s.d(t, "h", (function() {
				return C
			})), s.d(t, "l", (function() {
				return O
			})), s.d(t, "n", (function() {
				return y
			})), s.d(t, "o", (function() {
				return k
			}));
			var n = s("./src/reddit/models/SubredditWikiPage/index.ts"),
				a = s("./src/reddit/selectors/telemetry.ts");
			const o = e => Object.assign({}, a.defaults(e), {
					subreddit: a.subreddit(e),
					userSubreddit: a.userSubreddit(e)
				}),
				r = () => e => Object.assign({
					source: "wiki",
					action: "click",
					noun: "edit"
				}, o(e)),
				i = () => e => Object.assign({
					source: "menu_links_bar",
					action: "click",
					noun: "wiki"
				}, o(e)),
				c = e => t => Object.assign({
					source: "wiki",
					action: "click",
					noun: e
				}, o(t)),
				d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					return c(e ? "create_wiki_page" : "save_wiki_page")
				},
				l = c("compare_wiki_pages"),
				m = c("revert_wiki_page"),
				u = c("view_wiki_page"),
				p = c("view_source"),
				b = c("add_wiki_page_contributor"),
				h = c("remove_wiki_page_contributor"),
				g = c("save_wiki_page_settings"),
				E = c("copy_url"),
				x = c("add_wiki_subreddit_contributor"),
				f = c("remove_wiki_subreddit_contributor"),
				v = c("ban_wiki_contributor"),
				C = c("unban_wiki_contributor"),
				O = e => c(e ? "show_wiki_revision" : "hide_wiki_revision"),
				j = {
					[n.a.Inherit]: "subreddit_wiki_perms",
					[n.a.Contributors]: "only_wiki_contributors",
					[n.a.Mods]: "only_mods"
				},
				y = e => t => Object.assign({}, o(t), {
					source: "wiki",
					action: "click",
					noun: "hide_show_page",
					actionInfo: a.actionInfo(t, {
						settingValue: e ? "show" : "hide"
					})
				}),
				k = e => t => Object.assign({}, o(t), {
					source: "wiki",
					action: "click",
					noun: "editing_permissions",
					actionInfo: a.actionInfo(t, {
						settingValue: j[e]
					})
				})
		},
		"./src/reddit/helpers/wiki/buildWikiPagesTree.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./node_modules/lodash/sortBy.js"),
				a = s.n(n),
				o = s("./src/reddit/constants/wiki.ts");
			const r = e => {
				return a()(e, e => "".concat(e.path, "/").startsWith("".concat(o.i, "/")) ? "\0".concat(e.path) : e.path).filter(e => !o.k.includes(e.path))
			};
			t.a = e => {
				const t = new Map,
					s = [];
				return r(e).forEach(e => {
					const n = Object.assign({}, e, {
							children: []
						}),
						a = n.parent ? t.get(n.parent) : null;
					a ? a.children.push(n) : s.push(n), t.set(n.path, n)
				}), s
			}
		},
		"./src/reddit/helpers/wiki/makeComparisonDiffKey.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				const {
					comparisonRevisionId: t,
					revisionId: s,
					subredditName: n,
					wikiPageName: a
				} = e;
				return "[".concat(n, "]--[").concat(a, "]--[rev1:").concat(s, "]--[rev2:").concat(t, "]").toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeRevisionsListingKey.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				const t = e.isRecent ? "(recent)" : e.wikiPageName;
				return "[".concat(e.subredditName, "]--[").concat(t, "]").toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeWikiPageKey.ts": function(e, t, s) {
			"use strict";
			t.a = e => {
				let t = "[".concat(e.subredditName, "]--[").concat(e.wikiPageName, "]");
				return e.revisionId && (t += "--[rev:".concat(e.revisionId, "]")), t.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/validatePageName.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			})), s.d(t, "c", (function() {
				return i
			})), s.d(t, "b", (function() {
				return c
			}));
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var n = s("./src/reddit/constants/wiki.ts");
			const a = new RegExp("^[-\\w]+(?:\\/[-\\w]+){0,".concat(n.c, "}$")),
				o = /^[-\w]+$/;
			var r;
			! function(e) {
				e[e.InvalidPageName = 1] = "InvalidPageName", e[e.RestrictedPageName = 2] = "RestrictedPageName", e[e.MaxLengthExceed = 3] = "MaxLengthExceed", e[e.PageAlreadyExists = 4] = "PageAlreadyExists"
			}(r || (r = {}));
			const i = e => {
					if (!o.test(e.toLowerCase())) return r.InvalidPageName
				},
				c = (e, t) => {
					const s = e.toLowerCase(),
						o = s.split("/")[0],
						i = n.b.has(o),
						c = n.f.has(o) && s !== n.h;
					if (i || c) return r.RestrictedPageName;
					if (!a.test(s)) return r.InvalidPageName;
					if (t) {
						if (t.some(e => e.path.toLowerCase() === s)) return r.PageAlreadyExists
					}
					return s.length > n.d ? r.MaxLengthExceed : void 0
				}
		},
		"./src/reddit/helpers/wiki/wikiRevision.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			})), s.d(t, "b", (function() {
				return a
			}));
			const n = e => e.startsWith("WikiRevision_") ? e : "WikiRevision_" + e,
				a = e => e.startsWith("WikiRevision_") ? e.slice("WikiRevision_".length) : e
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.m.less": function(e, t, s) {
			e.exports = {
				DropdownTriangle: "_28O0gzb6GMS8lbDeySdpwp",
				dropdownTriangle: "_28O0gzb6GMS8lbDeySdpwp"
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/DropdownTriangle/index.m.less"),
				i = s.n(r);
			const c = s("./src/lib/lessComponent.tsx").a.wrapped(e => a.a.createElement("i", {
				className: "".concat(Object(o.b)("dropdownTriangle"), " ").concat(e.className)
			}), "DropdownTriangle", i.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less": function(e, t, s) {
			e.exports = {
				CollapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI",
				collapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less"),
				i = s.n(r);
			const c = s("./src/lib/lessComponent.tsx").a.wrapped(e => a.a.createElement("i", {
				className: "".concat(Object(o.b)("expandoArrowCollapse"), " ").concat(e.className),
				onClick: e.onClick,
				title: e.title
			}), "CollapseIcon", i.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less": function(e, t, s) {
			e.exports = {
				ExpandIcon: "QOwFub52NskNmv0MdMa2_",
				expandIcon: "QOwFub52NskNmv0MdMa2_"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less"),
				i = s.n(r);
			const c = s("./src/lib/lessComponent.tsx").a.wrapped(e => a.a.createElement("i", {
				className: "".concat(Object(o.b)("expandoArrowExpand"), " ").concat(e.className),
				onClick: e.onClick,
				title: e.title
			}), "ExpandIcon", i.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Expandos/Media/Lightbox/index.m.less": function(e, t, s) {
			e.exports = {
				LightboxIcon: "_1RQFWa5zHMcVoJ2MvnnGM3",
				lightboxIcon: "_1RQFWa5zHMcVoJ2MvnnGM3"
			}
		},
		"./src/reddit/icons/fonts/Info/index.m.less": function(e, t, s) {
			e.exports = {
				InfoIcon: "_3nKAYOml-oSgh4pKL20-sC",
				infoIcon: "_3nKAYOml-oSgh4pKL20-sC"
			}
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/reddit/icons/fonts/helpers.tsx"),
				r = s("./src/reddit/icons/fonts/Info/index.m.less"),
				i = s.n(r);
			const c = s("./src/lib/lessComponent.tsx").a.wrapped(e => a.a.createElement("i", {
				className: "".concat(Object(o.b)("info"), " ").concat(e.className)
			}), "InfoIcon", i.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/List/index.m.less": function(e, t, s) {
			e.exports = {
				ListIcon: "t3UrRpUFSigA4IRW8iMLv",
				listIcon: "t3UrRpUFSigA4IRW8iMLv"
			}
		},
		"./src/reddit/icons/fonts/Op/index.m.less": function(e, t, s) {
			e.exports = {
				OpIcon: "_3mrrZsVUDI2b3p1rpkjbph",
				opIcon: "_3mrrZsVUDI2b3p1rpkjbph"
			}
		},
		"./src/reddit/icons/svgs/Admin/index.m.less": function(e, t, s) {
			e.exports = {
				admin: "_1PeZajQI0Wm8P3B45yshR",
				mEnabled: "_3axV0unm-cpsxoKWYwKh2x"
			}
		},
		"./src/reddit/icons/svgs/Admin/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Admin/index.m.less"),
				i = s.n(r);
			t.a = e => a.a.createElement("svg", {
				className: Object(o.a)(e.className, i.a.admin, {
					[i.a.mEnabled]: e.enabled
				}),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 -0.75 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && a.a.createElement("title", null, e.title), e.desc && a.a.createElement("desc", null, e.desc), a.a.createElement("g", null, a.a.createElement("path", {
				fill: "inherit",
				d: "M19.99,9.3125 C19.99,8.104375 19.010625,7.125 17.8025,7.125 C17.213125,7.125 16.67875,7.359375 16.285625,7.73875 C14.8075,6.6725 12.776875,5.98 10.514375,5.886875 L11.491875,1.2875 L14.695625,1.96875 C14.775,2.756875 15.433125,3.375 16.2425,3.375 C17.105625,3.375 17.805,2.675625 17.805,1.8125 C17.805,0.949375 17.105625,0.25 16.2425,0.25 C15.6575,0.25 15.154375,0.575 14.88625,1.050625 L11.228125,0.273125 C11.10625,0.24625 10.98,0.270625 10.875625,0.338125 C10.77125,0.40625 10.698125,0.5125 10.6725,0.63375 L9.556875,5.8825 C7.26,5.960625 5.1975,6.65625 3.7,7.735 C3.306875,7.358125 2.775,7.125 2.1875,7.125 C0.979375,7.125 0,8.104375 0,9.3125 C0,10.20125 0.530625,10.965 1.2925,11.306875 C1.25875,11.524375 1.24,11.745 1.24,11.96875 C1.24,15.334375 5.1575,18.0625 9.99,18.0625 C14.8225,18.0625 18.74,15.334375 18.74,11.96875 C18.74,11.746875 18.721875,11.5275 18.68875,11.31125 C19.455,10.97125 19.99,10.205 19.99,9.3125"
			})), a.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, a.a.createElement("polygon", {
				points: "0 20 20 20 20 0 0 0"
			}), a.a.createElement("g", {
				transform: "translate(0 1)"
			})))
		},
		"./src/reddit/icons/svgs/ArrowRight/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 11.4 11.4",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				fill: "inherit",
				d: "m11.17929,5.99479c0.08081,-0.19519 0.08081,-0.41599 0,-0.61118c-0.0408,-0.0984 -0.0992,-0.1864 -0.17361,-0.2608l-4.79963,-4.79911c-0.31283,-0.3128 -0.81847,-0.3128 -1.1313,0c-0.31283,0.31279 -0.31283,0.81918 0,1.13118l3.43471,3.43433l-7.66949,0c-0.44244,0 -0.80007,0.3584 -0.80007,0.79999c0,0.44159 0.35763,0.79999 0.80007,0.79999l7.66949,0l-3.43471,3.43433c-0.31283,0.3128 -0.31283,0.81919 0,1.13118c0.15601,0.156 0.36083,0.2344 0.56565,0.2344c0.20482,0 0.40964,-0.0784 0.56565,-0.2344l4.79963,-4.79911c0.07441,-0.0744 0.13281,-0.1624 0.17361,-0.2608"
			})))
		},
		"./src/reddit/icons/svgs/Ban/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M12.8172,7.49104 C12.8172,7.70304 12.7332,7.90704 12.5828,8.05664 L9.5196,11.11984 C9.3636,11.27584 9.1588,11.35424 8.954,11.35424 C8.7492,11.35424 8.5444,11.27584 8.3884,11.11984 L7.2572,9.98784 L2.966,14.27904 C2.8092,14.43584 2.6044,14.51344 2.4004,14.51344 C2.1956,14.51344 1.9908,14.43584 1.834,14.27904 C1.522,13.96704 1.522,13.46064 1.834,13.14784 L6.126,8.85664 L4.9948,7.72544 C4.682,7.41264 4.682,6.90704 4.9948,6.59424 L8.0572,3.53104 C8.3572,3.23104 8.8884,3.23104 9.1884,3.53104 L12.5828,6.92544 C12.7332,7.07504 12.8172,7.27904 12.8172,7.49104 Z M3.86328,6.26288 C3.65848,6.26288 3.45368,6.18448 3.29768,6.02848 C2.98488,5.71568 2.98488,5.21008 3.29768,4.89728 L6.36008,1.83408 C6.67288,1.52208 7.17928,1.52208 7.49128,1.83408 C7.80408,2.14688 7.80408,2.65328 7.49128,2.96528 L4.42888,6.02848 C4.27288,6.18448 4.06808,6.26288 3.86328,6.26288 Z M14.27968,8.62264 C14.59248,8.93544 14.59248,9.44104 14.27968,9.75384 L11.21728,12.81624 C11.06128,12.97224 10.85648,13.05064 10.65168,13.05064 C10.44688,13.05064 10.24208,12.97224 10.08608,12.81624 C9.77328,12.50424 9.77328,11.99784 10.08608,11.68504 L13.14848,8.62264 C13.46128,8.30984 13.96688,8.30984 14.27968,8.62264 Z"
			})))
		},
		"./src/reddit/icons/svgs/Cake/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				className: e.className,
				viewBox: "0 0 40 40",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M37.5,22.5V20h-35v15c0,1.4,1.1,2.5,2.5,2.5h30c1.4,0,2.5-1.1,2.5-2.5v0H6.2C5.6,35,5,34.5,5,33.8l0,0c0-0.7,0.6-1.2,1.2-1.2h31.3V30H6.2C5.6,30,5,29.5,5,28.8v0c0-0.7,0.6-1.2,1.2-1.2h31.3V25H6.2C5.6,25,5,24.5,5,23.8v0c0-0.7,0.6-1.2,1.2-1.2H37.5z"
			}), a.a.createElement("path", {
				d: "M22.5,6c0,1.4-1.1,2.5-2.5,2.5S17.5,7.4,17.5,6S20,0,20,0S22.5,4.6,22.5,6z"
			}), a.a.createElement("path", {
				d: "M20,15L20,15c-0.7,0-1.3-0.6-1.3-1.2v-2.5c0-0.7,0.6-1.2,1.2-1.2h0c0.7,0,1.2,0.6,1.2,1.2v2.5C21.2,14.5,20.7,15,20,15z"
			}), a.a.createElement("path", {
				d: "M22.8,11.3v2.3c0,1.4-1,2.7-2.5,2.9c-1.6,0.2-3-1.1-3-2.7v-5c0,0,0-0.1,0-0.1l-0.8-0.4c-0.9-0.4-2-0.3-2.7,0.4L2.5,18.5h35L22.8,11.3z"
			}))))
		},
		"./src/reddit/icons/svgs/Chevron/index.m.less": function(e, t, s) {
			e.exports = {
				chevron: "_1c_YBKkiW4FhhLJPkq9c1v"
			}
		},
		"./src/reddit/icons/svgs/Chevron/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Chevron/index.m.less"),
				i = s.n(r);
			t.a = e => a.a.createElement("svg", {
				className: Object(o.a)(i.a.chevron, e.className),
				viewBox: "0 0 9 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", {
				transform: "translate(-6.000000, -3.000000)"
			}, a.a.createElement("polygon", {
				fill: "none",
				points: "0 20 20 20 20 0 0 0"
			}), a.a.createElement("polygon", {
				fill: "inherit",
				points: "7.47566213 3 14.4756621 10 7.47566213 17 6 15.5239203 11.5239203 10 6 4.47566213"
			})))
		},
		"./src/reddit/icons/svgs/ChevronUp/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("polygon", {
				fill: "inherit",
				transform: "translate(6.029200, 6.044700) scale(1, -1) translate(-6.029200, -6.044700)",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/Circle/index.m.less": function(e, t, s) {
			e.exports = {
				circle: "_17IuRdA-NY8vFk-Tt991sn"
			}
		},
		"./src/reddit/icons/svgs/Circle/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Circle/index.m.less"),
				i = s.n(r);
			t.a = e => a.a.createElement("svg", {
				className: Object(o.a)(i.a.circle, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 8 8"
			}, a.a.createElement("g", {
				fill: "inherit",
				stroke: "none"
			}, a.a.createElement("circle", {
				r: "4",
				cy: "4",
				cx: "4"
			})))
		},
		"./src/reddit/icons/svgs/ClassicPosts/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => a.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), a.a.createElement("path", {
				d: "M1.75,6.6V1.75h16.5V6.6Zm0,5.83V7.57h16.5v4.86Zm0,5.82V13.4h16.5v4.85Z"
			}))
		},
		"./src/reddit/icons/svgs/Clock/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 11 11"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M5 3.75C5 3.47388 5.22363 3.25 5.5 3.25C5.77637 3.25 6 3.47388 6 3.75V5.53735L7.81689 6.58643C8.05615 6.72449 8.13818 7.03027 8 7.26941C7.86182 7.50861 7.55615 7.59052 7.31689 7.45245L5.25049 6.25934C5.07861 6.16028 4.98779 5.97504 5.00146 5.78992L5 5.75V3.75Z",
				fill: "inherit"
			}), a.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M11 5.5C11 8.53754 8.5376 11 5.5 11C2.4624 11 0 8.53754 0 5.5C0 2.46246 2.4624 0 5.5 0C8.5376 0 11 2.46246 11 5.5ZM10 5.5C10 7.98529 7.98535 10 5.5 10C3.01465 10 1 7.98529 1 5.5C1 3.01471 3.01465 1 5.5 1C7.98535 1 10 3.01471 10 5.5Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/CompactPosts/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => a.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), a.a.createElement("path", {
				d: "M1.75,5V1.75h16.5V5Zm0,4.43V6.18h16.5v3.2Zm0,8.87v-3.2h16.5v3.2Zm0-4.43v-3.2h16.5v3.2Z"
			}))
		},
		"./src/reddit/icons/svgs/Eye/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);

			function o(e) {
				return a.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 40 40"
				}, a.a.createElement("g", null, a.a.createElement("path", {
					d: "M20,8C9.1,8,0.5,14,0.5,21.7h4c0-3.6,3.4-6.9,8.2-8.5C11,15,10,17.4,10,20c0,5.5,4.5,10,10,10s10-4.5,10-10c0-2.6-1-5-2.7-6.8c4.8,1.7,8.2,4.9,8.2,8.5h4C39.5,14,30.9,8,20,8z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Gild/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && a.a.createElement("desc", null, e.desc), a.a.createElement("g", {
				stroke: "none",
				strokeWidth: "1",
				fillRule: "evenodd"
			}, a.a.createElement("g", {
				fill: "inherit"
			}, a.a.createElement("path", {
				d: "m15.1275768 8.9935-2.059 2.204.371 2.992c.022.181-.055.359-.203.466-.087.064-.19.096-.294.096-.072 0-.144-.016-.211-.047l-2.73200003-1.277-2.731 1.277c-.164.076-.359.059-.506-.049-.148-.107-.225-.285-.202-.466l.37-2.992-2.059-2.204c-.124-.133-.166-.323-.11-.496s.202-.302.381-.336l2.96-.573 1.46-2.639c.175-.318.69900003-.318.87500003 0l1.46 2.639 2.959.573c.179.034.325.163.381.336s.014.363-.11.496m2.911-2.985-6.586-4.786c-.869-.63-2.03700003-.63-2.90600003 0v.001l-6.586 4.785c-.869.631-1.23 1.742-.898 2.764l2.515 7.743c.332 1.021 1.278 1.708 2.352 1.708h8.14000003c1.075 0 2.02-.687 2.352-1.708l2.516-7.743c.332-1.022-.03-2.133-.899-2.764"
			}))))
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, s) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/Grapple/index.m.less"),
				i = s.n(r);
			t.a = e => a.a.createElement("svg", {
				className: Object(o.a)(e.className, i.a.grapple, {
					[i.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, a.a.createElement("title", {
				id: "".concat(e.title, "-title")
			}, e.title), a.a.createElement("g", null, a.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/Hide/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M10,16.25 C8.728,16.25 7.544,15.867 6.556,15.212 L15.212,6.556 C15.867,7.544 16.25,8.728 16.25,10 C16.25,13.4465 13.446,16.25 10,16.25 M3.75,10 C3.75,6.5535 6.554,3.75 10,3.75 C11.272,3.75 12.456,4.133 13.444,4.788 L4.788,13.444 C4.133,12.456 3.75,11.272 3.75,10 M10,1.25 C5.1675,1.25 1.25,5.1675 1.25,10 C1.25,14.8325 5.1675,18.75 10,18.75 C14.8325,18.75 18.75,14.8325 18.75,10 C18.75,5.1675 14.8325,1.25 10,1.25"
			})))
		},
		"./src/reddit/icons/svgs/ImageUpload/index.m.less": function(e, t, s) {
			e.exports = {
				icon: "_2irXdPA4C5flwkupsFkN9-"
			}
		},
		"./src/reddit/icons/svgs/ImageUpload/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n),
				o = s("./src/lib/classNames/index.ts"),
				r = s("./src/reddit/icons/svgs/ImageUpload/index.m.less"),
				i = s.n(r);
			t.a = e => a.a.createElement("svg", {
				className: Object(o.a)(i.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("polygon", {
				fill: "inherit",
				opacity: "0",
				points: "0.610673352 20 20.625 20 20.625 0 0.610673352 0"
			}), a.a.createElement("path", {
				d: "M17.451,9.14823765 C17.03,5.40791696 13.8555,2.5 10,2.5 C6.1445,2.5 2.97,5.40791696 2.549,9.14823765 C1.0455,9.84024195 0,11.3551568 0,13.1173944 C0,15.531665 1.959,17.4892627 4.375,17.4892627 L7.8125,17.4892627 L7.8125,12.8051181 L5,12.8051181 C4.8735,12.8051181 4.7595,12.7291725 4.7115,12.6122563 C4.6625,12.49534 4.6895,12.3614359 4.779,12.272 L9.779,7.2755791 C9.901,7.15366643 10.099,7.15366643 10.221,7.2755791 L15.187,12.2375247 C15.2665,12.2944839 15.3185,12.3874173 15.3185,12.4928418 C15.3185,12.6652183 15.1785,12.8051181 15.006,12.8051181 L15,12.8051181 L12.1875,12.8051181 L12.1875,17.4892627 L15.625,17.4892627 C18.041,17.4892627 20,15.531665 20,13.1173944 C20,11.3551568 18.954,9.84024195 17.451,9.14823765",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Karma/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M6.42528593,9.54562407 C4.41043013,8.02026355 3.10790651,5.60355545 3.10790651,2.88165092 L3.10790651,2.79711586 L3.19244157,2.79711586 C5.9143461,2.79711586 8.33136499,4.09963948 9.85641472,6.11449528 C8.02399304,6.25279712 6.56358777,7.7128916 6.42528593,9.54562407 Z M6.42528593,10.2560915 C6.56358777,12.088824 8.02399304,13.5489184 9.85641472,13.6872203 C8.33136499,15.7020761 5.9143461,17.0045997 3.19244157,17.0045997 L3.10790651,17.0045997 L3.10790651,16.9200646 C3.10790651,14.1981601 4.41043013,11.781452 6.42528593,10.2560915 Z M13.6872203,10.2560915 C15.7020761,11.781452 17.0045997,14.1981601 17.0045997,16.9200646 L17.0045997,17.0045997 L16.9200646,17.0045997 C14.1981601,17.0045997 11.7811412,15.7020761 10.2560915,13.6872203 C12.0885132,13.5489184 13.5486077,12.088824 13.6872203,10.2560915 Z M16.9200646,2.79711586 L17.0045997,2.79711586 L17.0045997,2.88165092 C17.0045997,5.60324465 15.7020761,8.02026355 13.6872203,9.54562407 C13.5489184,7.7128916 12.0885132,6.25279712 10.2560915,6.11449528 C11.7811412,4.09963948 14.1981601,2.79711586 16.9200646,2.79711586 Z M19.9403282,9.84895574 L20,9.90862755 L19.9403282,9.96829935 C18.9346096,10.9740179 17.7346469,11.6624192 16.46227,12.0474888 C15.9659373,11.2534187 15.3446668,10.5308304 14.6071606,9.90862755 C15.3446668,9.28642466 15.9659373,8.5638364 16.46227,7.76976629 C17.7346469,8.1548359 18.9346096,8.8432372 19.9403282,9.84895574 Z M9.90862755,5.39283938 C9.28642466,4.65533317 8.5638364,4.03406266 7.76976629,3.53772999 C8.1548359,2.26535306 8.8432372,1.06539035 9.84895574,0.0596718051 L9.90862755,0 L9.96829935,0.0596718051 C10.9740179,1.06539035 11.6624192,2.26535306 12.0474888,3.53772999 C11.2534187,4.03406266 10.5308304,4.65533317 9.90862755,5.39283938 Z M5.39283938,9.90862755 C4.65533317,10.5308304 4.03406266,11.2534187 3.53772999,12.0474888 C2.26535306,11.6624192 1.06539035,10.9740179 0.0596718051,9.96829935 L0,9.90862755 L0.0596718051,9.84895574 C1.06539035,8.8432372 2.26535306,8.1548359 3.53772999,7.76976629 C4.03406266,8.5638364 4.65533317,9.28642466 5.39283938,9.90862755 Z M9.90862755,14.6071606 C10.5308304,15.3446668 11.2534187,15.9659373 12.0474888,16.46227 C11.6624192,17.7346469 10.9740179,18.9346096 9.96829935,19.9403282 L9.90862755,20 L9.84895574,19.9403282 C8.8432372,18.9346096 8.1548359,17.7346469 7.76976629,16.46227 C8.5638364,15.9659373 9.28642466,15.3446668 9.90862755,14.6071606 Z"
			})))
		},
		"./src/reddit/icons/svgs/LargePosts/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => a.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), a.a.createElement("path", {
				d: "M1.75,9.38V1.75h16.5V9.38Zm0,8.87V10.62h16.5v7.63Z"
			}))
		},
		"./src/reddit/icons/svgs/Lock/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 40 40",
				xmlns: "http://www.w3.org/2000/svg",
				fill: e.fill
			}, a.a.createElement("g", null, a.a.createElement("rect", {
				x: "7.5",
				y: "12.5",
				width: "0",
				height: "0"
			}), a.a.createElement("path", {
				fill: "inherit",
				d: "M32.5,17.5v-2.6c0-6.8-5.6-12.4-12.4-12.4h-0.2c-6.8,0-12.4,5.6-12.4,12.4v2.6C6.1,17.5,5,18.6,5,20v10c0,5.5,4.5,10,10,10h10c5.5,0,10-4.5,10-10V20C35,18.6,33.9,17.5,32.5,17.5z M12.5,17.5v-2.6c0-4.1,3.3-7.4,7.4-7.4h0.2c4.1,0,7.4,3.3,7.4,7.4v2.6H12.5z"
			})))
		},
		"./src/reddit/icons/svgs/Mute/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M9.97968,8.20936 C10.13568,8.36536 10.13568,8.61896 9.97968,8.77496 C9.90128,8.85336 9.79888,8.89256 9.69648,8.89256 C9.59488,8.89256 9.49248,8.85336 9.41408,8.77496 L7.99968,7.36056 L6.58608,8.77496 C6.50768,8.85336 6.40528,8.89256 6.30288,8.89256 C6.20048,8.89256 6.09808,8.85336 6.02048,8.77496 C5.86368,8.61896 5.86368,8.36536 6.02048,8.20936 L7.43408,6.79496 L6.02048,5.38136 C5.86368,5.22536 5.86368,4.97176 6.02048,4.81576 C6.17648,4.65976 6.43008,4.65976 6.58608,4.81576 L7.99968,6.22936 L9.41408,4.81576 C9.57008,4.65976 9.82368,4.65976 9.97968,4.81576 C10.13568,4.97176 10.13568,5.22536 9.97968,5.38136 L8.56528,6.79496 L9.97968,8.20936 Z M12.79968,1.59976 L3.19968,1.59976 C2.31808,1.59976 1.59968,2.31816 1.59968,3.19976 L1.59968,10.59496 C1.59968,11.47736 2.31808,12.19496 3.19968,12.19496 L6.10528,12.19496 L7.33408,14.03896 C7.48288,14.26136 7.73248,14.39496 7.99968,14.39496 C8.26688,14.39496 8.51728,14.26136 8.66528,14.03896 L9.89488,12.19496 L12.79968,12.19496 C13.68208,12.19496 14.39968,11.47736 14.39968,10.59496 L14.39968,3.19976 C14.39968,2.31816 13.68208,1.59976 12.79968,1.59976 L12.79968,1.59976 Z",
				id: "path-1"
			})))
		},
		"./src/reddit/icons/svgs/Remove/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				id: e.id,
				tabIndex: e.tabIndex,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, a.a.createElement("g", null, a.a.createElement("path", {
				fillRule: "evenodd",
				d: "M13.5559061,14.5 C13.5559061,14.776 13.3283409,15 13.0479481,15 C12.7675552,15 12.53999,14.776 12.53999,14.5 L12.53999,9 C12.53999,8.724 12.7675552,8.5 13.0479481,8.5 C13.3283409,8.5 13.5559061,8.724 13.5559061,9 L13.5559061,14.5 Z M10.508158,14.5 C10.508158,14.776 10.2805928,15 10.0002,15 C9.71980718,15 9.49224199,14.776 9.49224199,14.5 L9.49224199,9 C9.49224199,8.724 9.71980718,8.5 10.0002,8.5 C10.2805928,8.5 10.508158,8.724 10.508158,9 L10.508158,14.5 Z M7.46040996,14.5 C7.46040996,14.776 7.23284477,15 6.95245195,15 C6.67205913,15 6.44449394,14.776 6.44449394,14.5 L6.44449394,9 C6.44449394,8.724 6.67205913,8.5 6.95245195,8.5 C7.23284477,8.5 7.46040996,8.724 7.46040996,9 L7.46040996,14.5 Z M15.492242,6 C15.7736507,6 16.0002,6.224 16.0002,6.5 L16.0002,16.5 C16.0002,17.327 15.3164885,18 14.476326,18 L5.52407403,18 C4.68391148,18 4.0002,17.327 4.0002,16.5 L4.0002,6.5 C4.0002,6.224 4.22674927,6 4.50815801,6 L15.492242,6 Z M15.491585,3 C15.7719541,3 15.9995,3.224 15.9995,3.5 L15.9995,4.5 C15.9995,4.776 15.7719541,5 15.491585,5 L4.50741501,5 C4.22704592,5 3.9995,4.776 3.9995,4.5 L3.9995,3.5 C3.9995,3.224 4.22704592,3 4.50741501,3 L7.51325603,3 L8.26598607,2.167 C8.36248993,2.061 8.50064281,2 8.6459065,2 L11.3541093,2 C11.4983572,2 11.6365101,2.061 11.7340298,2.167 L12.485744,3 L15.491585,3 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => a.a.createElement("svg", o({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), a.a.createElement("g", null, a.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Rules/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 30 30",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M20.7094669,9.4275 L9.29053307,9.4275 C8.86319398,9.4275 8.51636806,9.0915 8.51636806,8.6775 C8.51636806,8.2635 8.86319398,7.9275 9.29053307,7.9275 L20.7094669,7.9275 C21.136806,7.9275 21.4836319,8.2635 21.4836319,8.6775 C21.4836319,9.0915 21.136806,9.4275 20.7094669,9.4275 M20.7094669,14.142 L9.29053307,14.142 C8.86319398,14.142 8.51636806,13.806 8.51636806,13.392 C8.51636806,12.978 8.86319398,12.642 9.29053307,12.642 L20.7094669,12.642 C21.136806,12.642 21.4836319,12.978 21.4836319,13.392 C21.4836319,13.806 21.136806,14.142 20.7094669,14.142 M20.7094669,18.858 L9.29053307,18.858 C8.86319398,18.858 8.51636806,18.522 8.51636806,18.108 C8.51636806,17.6925 8.86319398,17.358 9.29053307,17.358 L20.7094669,17.358 C21.136806,17.358 21.4836319,17.6925 21.4836319,18.108 C21.4836319,18.522 21.136806,18.858 20.7094669,18.858 M20.7094669,23.5725 L9.29053307,23.5725 C8.86319398,23.5725 8.51636806,23.2365 8.51636806,22.8225 C8.51636806,22.407 8.86319398,22.0725 9.29053307,22.0725 L20.7094669,22.0725 C21.136806,22.0725 21.4836319,22.407 21.4836319,22.8225 C21.4836319,23.2365 21.136806,23.5725 20.7094669,23.5725 M23.95167,4.5 L20.4570891,4.5 C19.9198186,3.6075 18.9335324,3 17.7893165,3 L12.2106835,3 C11.0664676,3 10.0801814,3.6075 9.54291086,4.5 L6.04833002,4.5 C5.19365185,4.5 4.5,5.172 4.5,6 L4.5,25.5 C4.5,26.328 5.19365185,27 6.04833002,27 L23.95167,27 C24.8063482,27 25.5,26.328 25.5,25.5 L25.5,6 C25.5,5.172 24.8063482,4.5 23.95167,4.5"
			})))
		},
		"./src/reddit/icons/svgs/Tag/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				style: e.style,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				fill: "inherit",
				d: "M5.14293863,3.38188919 C5.75317178,3.99212234 5.75317178,4.98136473 5.14293863,5.59159788 C4.53270548,6.20183104 3.54346309,6.20183104 2.93322994,5.59159788 C2.32299679,4.98136473 2.32299679,3.99212234 2.93322994,3.38188919 C3.54346309,2.77165604 4.53270548,2.77165604 5.14293863,3.38188919 Z M1.01449569,2.94595786 L1,9.03662212 C1.00035355,9.55457784 1.19162594,10.0654625 1.55790725,10.4317438 L9.89929239,18.7731289 C10.6622606,19.5360972 11.8989904,19.5360972 12.661605,18.7734825 L18.7381272,12.6969604 C19.5007418,11.9343457 19.5007418,10.697616 18.7377736,9.93464773 L10.3963885,1.59326259 C10.0301071,1.22698128 9.54786032,1.00707107 9.02955105,1.00707107 L2.96045355,1 C1.8814086,1 1.01414214,1.86726647 1.01449569,2.94595786 Z"
			})))
		},
		"./src/reddit/icons/svgs/Trash/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40",
				onClick: e.onClick
			}, a.a.createElement("g", null, a.a.createElement("g", {
				fill: "inherit"
			}, a.a.createElement("polygon", {
				points: "10,38.8 30,38.8 31.2,10.9 8.7,10.9"
			}), a.a.createElement("path", {
				d: "M27.5,3.8H25c0-1.4-1.1-2.5-2.5-2.5h-5c-1.4,0-2.5,1.1-2.5,2.5h-2.5c-2.8,0-5,2.2-5,5h25C32.5,6,30.3,3.8,27.5,3.8z"
			}))))
		},
		"./src/reddit/icons/svgs/Unban/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, a.a.createElement("g", null, a.a.createElement("path", {
				d: "M8,6.77247619 L8,6.27380952 L7.5072,6.27380952 L8,6.77247619 Z M7,5.76057143 L7,0.80952381 L11,0.80952381 L11,6.27380952 L10,6.27380952 L10,8.79628571 L15.9072,14.7738095 L15.2,15.4894286 L1,1.12038095 L1.7072,0.404761905 L3,1.71295238 L3,1.00178571 C3,0.44847619 3.4432,0 3.99,0 L4.01,0 C4.5568,0 5,0.44847619 5,1.00178571 L5,3.7367619 L5.8,4.54628571 L5.8,0.80952381 C5.8,0.585690476 5.9792,0.404761905 6.2,0.404761905 C6.4208,0.404761905 6.6,0.585690476 6.6,0.80952381 L6.6,5.35580952 L7,5.76057143 Z M8.2,8.9047619 L10.2,10.9285714 L10.2,14.2706905 C10.2,14.824 9.7568,15.2724762 9.21,15.2724762 L9.19,15.2724762 C8.6432,15.2724762 8.2,14.824 8.2,14.2706905 L8.2,8.9047619 Z M5.8,6.47619048 L6.284,6.96595238 C6.2568,6.97161905 6.2288,6.97485714 6.2,6.97485714 C5.9792,6.97485714 5.8,6.79392857 5.8,6.57009524 L5.8,6.47619048 Z M12.2,0.404761905 C12.4208,0.404761905 12.6,0.586095238 12.6,0.80952381 L12.6,6.67857143 C12.6,6.902 12.4208,7.08333333 12.2,7.08333333 C11.9792,7.08333333 11.8,6.902 11.8,6.67857143 L11.8,0.80952381 C11.8,0.586095238 11.9792,0.404761905 12.2,0.404761905 Z M14.01,0 C14.5568,0 15,0.44847619 15,1.00178571 L15,6.08154762 C15,6.63485714 14.5568,7.08333333 14.01,7.08333333 L13.99,7.08333333 C13.4432,7.08333333 13,6.63485714 13,6.08154762 L13,1.00178571 C13,0.44847619 13.4432,0 13.99,0 L14.01,0 Z M3,4.04761905 L5,6.07142857 L5,6.37783333 C5,6.93114286 4.5568,7.37961905 4.01,7.37961905 L3.99,7.37961905 C3.4432,7.37961905 3,6.93114286 3,6.37783333 L3,4.04761905 Z"
			})))
		},
		"./src/reddit/icons/svgs/User/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./node_modules/react/index.js"),
				a = s.n(n);
			t.a = e => a.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, a.a.createElement("path", {
				d: "M12,11 C15.309,11 18,13.691 18,17 C18,17.553 17.552,18 17,18 L3,18 C2.448,18 2,17.553 2,17 C2,13.691 4.691,11 8,11 L12,11 Z M10,9.7334 C7.868,9.7334 6.133,7.9994 6.133,5.8664 L6.133,4.8664 C6.133,2.7344 7.868,1.0004 10,1.0004 C12.132,1.0004 13.867,2.7344 13.867,4.8664 L13.867,5.8664 C13.867,7.9994 12.132,9.7334 10,9.7334 Z"
			}))
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, s) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, s) {
			"use strict";
			var n = s("./src/lib/lessComponent.tsx"),
				a = s("./src/reddit/layout/row/RightAlign/index.m.less"),
				o = s.n(a);
			t.a = n.a.div("rightAligned", o.a)
		},
		"./src/reddit/models/RemovalReason/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return a
			})), s.d(t, "d", (function() {
				return o
			})), s.d(t, "a", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "f", (function() {
				return c
			})), s.d(t, "e", (function() {
				return d
			})), s.d(t, "g", (function() {
				return l
			})), s.d(t, "h", (function() {
				return m
			}));
			var n = s("./src/reddit/helpers/isPost.ts");
			const a = 20,
				o = 50,
				r = 1e4,
				i = 100;
			var c, d;
			! function(e) {
				e.Private = "private", e.PrivateExposed = "private_exposed", e.Public = "public"
			}(c || (c = {})),
			function(e) {
				e.Bulk = "bulk", e.Comment = "comment", e.Post = "link"
			}(d || (d = {}));
			const l = e => 1 === e.length ? Object(n.a)(e[0]) ? d.Post : d.Comment : d.Bulk,
				m = (e, t) => {
					return {
						[t === d.Bulk ? "item_ids" : "item_id"]: e.itemId,
						message: e.message,
						title: e.title,
						type: e.type
					}
				}
		},
		"./src/reddit/models/SubredditModeration/ModerationLog/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return n
			}));
			const n = (e, t, s) => "".concat(e, "-").concat(((e, t) => t || e || "1")(s, t))
		},
		"./src/reddit/models/SubredditWikiPage/index.ts": function(e, t, s) {
			"use strict";
			var n, a;
			s.d(t, "b", (function() {
					return n
				})), s.d(t, "a", (function() {
					return a
				})),
				function(e) {
					e.MayNotView = "MAY_NOT_VIEW", e.PageNotCreated = "PAGE_NOT_CREATED", e.PageNotFound = "PAGE_NOT_FOUND", e.RestrictedPage = "RESTRICTED_PAGE", e.Unknown = "UNKNOWN", e.Valid = "VALID", e.WikiDisabled = "WIKI_DISABLED"
				}(n || (n = {})),
				function(e) {
					e.Inherit = "INHERIT_SUBREDDIT_PERMS", e.Contributors = "CONTRIBUTORS", e.Mods = "MODS"
				}(a || (a = {}))
		},
		"./src/reddit/models/TrafficStats/index.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return n
			})), s.d(t, "a", (function() {
				return a
			})), s.d(t, "c", (function() {
				return o
			})), s.d(t, "d", (function() {
				return r
			}));
			const n = 97,
				a = 57,
				o = 12;
			var r;
			! function(e) {
				e.TOTAL = "total", e.DESKTOP = "desktop", e.OLD_REDDIT = "oldReddit", e.IOS = "apps", e.ANDROID = "apps", e.MOBILE_WEB = "mWeb"
			}(r || (r = {}))
		},
		"./src/reddit/pages/ModHub/index.m.less": function(e, t, s) {
			e.exports = {
				titleFontH1: "_2WsiFpk8Yr5G2mp45qaGCa",
				titleFontH2: "_3oXE2EKQ3PsqyyApE-s3aj",
				titleFontH3: "_17o-6Y7vVLdL6oVMkFWo0m",
				titleFontH4: "uPBfC6MDaNJ-ozFZg2PFk",
				titleFontH5: "si3j-_p1olO8M1E2zoXjC",
				titleFontH6: "_14LzReKyHQwLHa-Rye3bAv",
				metadataFont: "_2NmVHGIdF8GNcMPPaHtwzz",
				flairFont: "D_gevKcOJSKbb6VlvHPj_",
				labelsFont: "_27eE-dU25b8hwKWg4bTqFz",
				actionFont: "_2dfa5IRwlqKVb61Lr36T98",
				smallButtonFont: "_20OTyO3PvAmgnQP4SoJgGt",
				largeButtonFont: "_2nrHVa4dyedAaDcfRLLE5z",
				tabFont: "_3Bpld0JoC9VmYlZZ5Dyms1",
				strongTextFont: "_25hN89q-zD6Y-U11Y_e4aZ",
				extraSmallFont: "_3Et6b3H1cjQ0kXDoPsJBA4",
				bodyFontH1: "bhfIpkByfOrflj2uqeOu3",
				bodyFontH2: "_3xwPD6mwo8KG7WQa3W8njG",
				bodyFontH3: "_1o3ciR8XDGZ_1S7FR7rmrb",
				bodyFontH4: "KyspXVcxKfpH-yrxxQ4EY",
				bodyFontH5: "_20z_x36tiklZi1W-Z3uqvJ",
				bodyFontH6: "_14VGsHSpx6uKHLlJqMng5B",
				bodyFont: "_3ejsRrJq-hN84OvmuolQYo",
				bodyFontSmall: "_1c--mrP_57nHX86Jy6YDjW",
				bodyFontMono: "_2jHXa8pmE696zxLXFfT4I0",
				contentWrapper: "_2Z3MiFrgj2rofHXrH1YVKn",
				isModerator: "_1haViLcso0RRPvkDGZgDLJ",
				BackgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				backgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				SubredditLink: "_3u_4BK4_gVwVyX1YIZjFft",
				subredditLink: "_3u_4BK4_gVwVyX1YIZjFft",
				Header: "_12UrKOfuM441n-zHotruas",
				header: "_12UrKOfuM441n-zHotruas",
				SubredditIcon: "_2N81CG8WsdJLudQQiSy8oZ",
				subredditIcon: "_2N81CG8WsdJLudQQiSy8oZ",
				Body: "_3hAOyl8ThaUgCBqiNvN_sN",
				body: "_3hAOyl8ThaUgCBqiNvN_sN"
			}
		},
		"./src/reddit/pages/ModHub/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			s("./node_modules/core-js/modules/es6.regexp.search.js"), s("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = s("./node_modules/lodash/fromPairs.js"),
				a = s.n(n),
				o = s("./node_modules/react/index.js"),
				r = s.n(o),
				i = s("./node_modules/react-redux/es/index.js"),
				c = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/extractQueryParams/index.ts"),
				m = s("./src/lib/lessComponent.tsx"),
				u = s("./src/reddit/components/ContentGate/index.tsx"),
				p = s("./node_modules/fbt/lib/FbtPublic.js"),
				b = s("./src/lib/assertNever.ts"),
				h = s("./src/lib/constants/index.ts");
			const g = e => {
				switch (e) {
					case h.Nb.Awards:
						return p.fbt._("Awards", null, {
							hk: "EiSXW"
						});
					case h.Nb.Banned:
						return p.fbt._("Banned", null, {
							hk: "35R8OD"
						});
					case h.Nb.Muted:
						return p.fbt._("Muted", null, {
							hk: "f2nJu"
						});
					case h.Nb.Contributors:
						return p.fbt._("Approved", null, {
							hk: "180AS9"
						});
					case h.Nb.Moderators:
						return p.fbt._("Moderators", null, {
							hk: "4qdV8t"
						});
					case h.Nb.SubredditRules:
						return p.fbt._("Rules", null, {
							hk: "2SNdd8"
						});
					case h.Nb.Removal:
						return p.fbt._("Removal reasons", null, {
							hk: "1smDUM"
						});
					case h.Nb.Modqueue:
						return p.fbt._("Mod queue", null, {
							hk: "yEBGb"
						});
					case h.Nb.Reports:
						return p.fbt._("Reports", null, {
							hk: "4Ctcb1"
						});
					case h.Nb.Spam:
						return p.fbt._("Spam", null, {
							hk: "1D73Vp"
						});
					case h.Nb.Unmoderated:
						return p.fbt._("Unmoderated", null, {
							hk: "3TOaeD"
						});
					case h.Nb.Edited:
						return p.fbt._("Edited", null, {
							hk: "OLtvW"
						});
					case h.Nb.PostRequirements:
						return p.fbt._("Post requirements", null, {
							hk: "3UBlR0"
						});
					case h.Nb.Modlog:
						return p.fbt._("Mod log", null, {
							hk: "3uy7LL"
						});
					case h.Nb.Flair:
						return p.fbt._("Grant user flair", null, {
							hk: "2B8sTJ"
						});
					case h.Nb.CommunitySettings:
						return p.fbt._("Community settings", null, {
							hk: "XbHzi"
						});
					case h.Nb.Emojis:
						return p.fbt._("Emojis", null, {
							hk: "3mPnxe"
						});
					case h.Nb.UserFlair:
						return p.fbt._("User flair", null, {
							hk: "3kleCv"
						});
					case h.Nb.PostFlair:
						return p.fbt._("Post flair", null, {
							hk: "2Y1FKb"
						});
					case h.Nb.Badges:
						return p.fbt._("Badges", null, {
							hk: "3vM0lt"
						});
					case h.Nb.Emotes:
						return p.fbt._("Emotes", null, {
							hk: "2Ivxxq"
						});
					case h.Nb.Wiki:
					case h.Nb.WikiContributors:
					case h.Nb.WikiBanned:
						return p.fbt._("Wiki pages", null, {
							hk: "WdSXv"
						});
					case h.Nb.Traffic:
						return p.fbt._("Traffic stats", null, {
							hk: "3mcw71"
						});
					case h.Nb.SubredditContent:
						return p.fbt._("Content", null, {
							hk: "4t5X2e"
						});
					case h.Nb.Streaming:
						return p.fbt._("Streaming", null, {
							hk: "OF6K8"
						});
					default:
						return Object(b.a)(e)
				}
			};
			var E = s("./src/reddit/components/SubredditIcon/index.tsx"),
				x = s("./src/reddit/components/TrackingHelper/index.tsx"),
				f = s("./src/reddit/contexts/PageLayer/index.tsx"),
				v = s("./src/reddit/controls/InternalLink/index.tsx"),
				C = s("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				O = s("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				j = s("./src/reddit/helpers/getSubredditErrorProps/index.ts"),
				y = s("./src/reddit/selectors/telemetry.ts");
			const k = e => ({
					screen: y.screen(e),
					profile: y.profile(e),
					subreddit: y.subreddit(e)
				}),
				w = e => {
					switch (e) {
						case h.Nb.Banned:
							return "banned";
						case h.Nb.Muted:
							return "muted";
						case h.Nb.Contributors:
							return "contributors";
						case h.Nb.Moderators:
							return "modmanagement";
						case h.Nb.Removal:
							return "set_removal_reasons";
						case h.Nb.CommunitySettings:
							return "edit";
						default:
							return e
					}
				},
				S = (e, t) => s => Object.assign({
					source: w(t),
					noun: e,
					action: "click"
				}, k(s)),
				N = e => t => Object.assign({
					source: w(e),
					noun: "hover_user_hovercard",
					action: "view"
				}, k(t));
			var T = s("./src/reddit/helpers/trackers/modHub.ts"),
				_ = s("./src/reddit/models/ModQueue/index.ts"),
				I = s("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				P = s("./src/reddit/selectors/moderatorPermissions.ts"),
				M = s("./src/reddit/selectors/postCreations.ts"),
				R = s("./src/reddit/selectors/subreddit.ts"),
				L = s("./src/reddit/selectors/user.ts"),
				D = (s("./node_modules/core-js/modules/es6.symbol.js"), s("./src/config.ts")),
				A = s("./src/lib/timeAgo/index.ts"),
				F = s("./src/reddit/actions/modal.ts"),
				B = s("./src/reddit/actions/subredditModeration.ts"),
				U = s("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				H = s("./src/reddit/components/ModerationPagesEmptyList/index.m.less"),
				W = s.n(H);
			const q = m.a.div("NoResultsContainer", W.a),
				V = m.a.div("NoResultsText", W.a);
			var z = e => r.a.createElement(q, null, e.children, r.a.createElement(V, null, e.text)),
				K = s("./src/higherOrderComponents/asTooltip.tsx"),
				Q = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				G = s("./src/reddit/i18n/utils.ts"),
				J = s("./src/reddit/icons/fonts/Info/index.tsx"),
				Z = s("./src/reddit/components/ModHub/InfoLink/index.m.less"),
				X = s.n(Z);
			const Y = Object(K.a)(Q.b),
				$ = ["center", "top"],
				ee = ["center", "bottom"];
			class te extends r.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					return r.a.createElement("a", {
						className: X.a.linkContainer,
						href: this.props.linkUrl,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef,
						target: "_blank"
					}, r.a.createElement(J.a, {
						className: X.a.infoIcon
					}), r.a.createElement(Y, {
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: $,
						text: Object(G.c)("Learn more"),
						tooltipPosition: ee
					}))
				}
			}
			var se = te,
				ne = s("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				ae = s.n(ne);
			const oe = m.a.div("ContentContainer", ae.a),
				re = m.a.div("PageTitle", ae.a),
				ie = m.a.div("TopBar", ae.a);
			var ce = s("./src/reddit/components/Scroller/Simple.tsx"),
				de = s("./src/reddit/controls/Button/index.tsx"),
				le = s("./src/reddit/helpers/normalizeUsername/index.tsx"),
				me = s("./src/reddit/layout/row/Inline/index.tsx"),
				ue = s("./src/reddit/layout/row/RightAlign/index.tsx"),
				pe = s("./src/reddit/icons/svgs/Search/index.tsx"),
				be = s("./src/reddit/components/SubredditModerationSearch/index.m.less"),
				he = s.n(be);
			const ge = m.a.wrapped(pe.a, "SearchIcon", he.a),
				Ee = m.a.wrapped(q, "NoResultsContainer", he.a),
				xe = m.a.div("Container", he.a),
				fe = m.a.wrapped(me.a, "SearchStatusBar", he.a),
				ve = m.a.div("SearchStatus", he.a),
				Ce = m.a.span("Bold", he.a);
			var Oe = e => {
					if (e.searchPending) return null;
					const t = Object(le.a)(e.searchTerm);
					return e.noResultsFound ? r.a.createElement(Ee, null, r.a.createElement(ge, null), r.a.createElement(V, null, Object(G.c)("No results for u/".concat(Object(G.b)("searchTerm", t)))), r.a.createElement(de.n, {
						onClick: e.cancelSearch
					}, Object(G.c)("See all"))) : r.a.createElement(xe, null, r.a.createElement(fe, null, r.a.createElement(ve, null, Object(G.c)("1 search result for "), r.a.createElement(Ce, {
						"data-redditstyle": !0
					}, "'".concat(t, "'")), ":"), r.a.createElement(ue.a, null, r.a.createElement(de.n, {
						onClick: e.cancelSearch
					}, Object(G.c)("See all")))), e.children)
				},
				je = s("./src/reddit/components/SubredditModerationTopBar/index.m.less"),
				ye = s.n(je);
			const ke = m.a.div("topBarRow", ye.a);
			class we extends r.a.Component {
				constructor(e) {
					super(e), this.onSearchChange = e => {
						Object(le.a)(e.currentTarget.value).length < 21 && this.setState({
							searchInputText: e.currentTarget.value
						})
					}, this.onKeyPress = e => {
						"Enter" === e.key && this.onSearch()
					}, this.onSearch = () => {
						this.props.onSearch(this.state.searchInputText)
					}, this.state = {
						searchInputText: ""
					}
				}
				componentWillReceiveProps(e) {
					this.props.activeSearchQuery && null === e.activeSearchQuery && this.setState({
						searchInputText: ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement("div", {
						className: ye.a.topBarRow
					}, r.a.createElement("input", {
						className: ye.a.searchInput,
						onChange: this.onSearchChange,
						onKeyPress: this.onKeyPress,
						placeholder: Object(G.c)("Search for a user"),
						type: "text",
						value: t.searchInputText
					}), r.a.createElement("button", {
						className: ye.a.searchButton,
						onClick: this.onSearch
					}, r.a.createElement(pe.a, {
						className: ye.a.searchIcon
					})), e.children)
				}
			}
			var Se = s("./node_modules/lodash/times.js"),
				Ne = s.n(Se),
				Te = s("./src/reddit/components/UserNameAndIcon/index.tsx"),
				_e = s("./src/reddit/i18n/components.tsx"),
				Ie = s("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				Pe = s("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				Me = s("./src/reddit/components/SubredditModerationUserItem/index.m.less"),
				Re = s.n(Me);
			const Le = (e, t) => {
					const s = "UserInfoTooltip--".concat(e);
					return t ? "".concat(s, "--").concat(t) : s
				},
				De = m.a.wrapped(me.a, "Row", Re.a),
				Ae = m.a.div("Username", Re.a),
				Fe = m.a.wrapped(ue.a, "RightAlign", Re.a),
				Be = m.a.div("Description", Re.a),
				Ue = m.a.div("AdditionalText", Re.a),
				He = m.a.wrapped(Ie.a, "ChevronDown", Re.a),
				We = m.a.wrapped(Pe.a, "ChevronUp", Re.a),
				qe = m.a.div("ExpandoContainer", Re.a),
				Ve = m.a.span("Bullet", Re.a),
				ze = m.a.div("PlaceholderItem", Re.a),
				Ke = m.a.wrapped(ze, "EmptyUserIcon", Re.a),
				Qe = m.a.wrapped(ze, "EmptyDetails", Re.a),
				Ge = m.a.div("UsersLoadingContainer", Re.a),
				Je = () => r.a.createElement(De, null, r.a.createElement(Ke, null), r.a.createElement(Qe, null), r.a.createElement(Qe, null)),
				Ze = e => r.a.createElement(Ge, {
					className: e.className
				}, Ne()(e.rows || 10, e => r.a.createElement(Je, {
					key: e
				})));
			class Xe extends r.a.Component {
				constructor(e) {
					super(e), this.onToggleExpandedComponent = () => {
						this.props.pageName && !this.state.isExpanded && this.props.sendEvent(S("more_detail", this.props.pageName)), this.setState({
							isExpanded: !this.state.isExpanded
						})
					}, this.sendHoverCardEvent = () => {
						this.props.pageName && this.props.sendEvent(N(this.props.pageName))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(De, null, r.a.createElement(Ae, null, r.a.createElement(Te.a, {
						username: e.username,
						userIcon: e.userIcon,
						tooltipId: Le(e.username, e.moderatorType),
						subredditId: e.subredditId,
						sendHoverCardEvent: this.sendHoverCardEvent
					})), r.a.createElement(Be, null, e.timeAgo, e.description && r.a.createElement(r.a.Fragment, null, r.a.createElement(Ve, null, "•"), e.description)), r.a.createElement(Fe, null, e.additionalText && r.a.createElement(Ue, null, e.additionalText), e.primaryButton, e.secondaryButton, e.tertiaryButton, e.expandedComponent && r.a.createElement(de.n, {
						onClick: this.onToggleExpandedComponent
					}, r.a.createElement(_e.c, null, "More Details"), t.isExpanded ? r.a.createElement(We, null) : r.a.createElement(He, null)))), t.isExpanded && r.a.createElement(qe, null, e.expandedComponent))
				}
			}
			var Ye = Object(x.b)(Xe),
				$e = s("./src/reddit/icons/svgs/Pencil/index.tsx"),
				et = s("./src/reddit/models/SubredditModeration/index.ts"),
				tt = s("./src/reddit/selectors/activeModalId.ts"),
				st = s("./src/reddit/selectors/subredditModeration.ts"),
				nt = s("./src/higherOrderComponents/asModal/index.tsx"),
				at = s("./src/reddit/components/ModalStyledComponents/index.tsx"),
				ot = s("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				rt = s("./src/reddit/controls/TextButton/index.tsx"),
				it = s("./src/reddit/helpers/isValidUsername/index.tsx"),
				ct = s("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				dt = s("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less"),
				lt = s.n(dt);
			const mt = m.a.wrapped(de.f, "PrimaryButton", lt.a);
			class ut extends r.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						e.onAddSubmitter(e.subredditId, t.username), e.sendEventWithName("add")(), e.toggleModal()
					}, this.state = {
						username: ""
					}
				}
				componentDidMount() {
					this.setState({
						username: this.props.username || ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(at.c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, Object(G.c)("Add approved user")), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, r.a.createElement(ot.d, {
						placeholder: Object(G.c)("Enter username"),
						onChange: this.onInputChange,
						value: this.state.username,
						autoFocus: !0
					})), r.a.createElement(at.e, null, r.a.createElement(at.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Object(G.c)("Cancel")), r.a.createElement(mt, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !Object(it.a)(t.username)
					}, Object(G.c)("Add user"))))
				}
			}
			var pt = Object(nt.a)(ut),
				bt = s("./src/reddit/components/ApprovedSubmitterList/index.m.less"),
				ht = s.n(bt);
			const gt = 24,
				Et = m.a.wrapped($e.a, "PencilIcon", ht.a),
				xt = Object(f.t)({
					username: e => Object(f.R)(e).user
				}),
				ft = Object(c.c)({
					approvedSubmitters: st.e,
					approvedSubmittersListPending: st.a,
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(tt.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(tt.a)(e),
					language: L.S,
					loadMoreToken: st.b,
					searchPending: st.c,
					searchResult: st.d
				});
			class vt extends r.a.Component {
				constructor(e) {
					super(e), this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveUserModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeSubmitter(this.props.subredditId, this.state.userId)
					}, this.onSearch = e => {
						this.props.searchForSubmitter(this.props.subredditId, e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveSubmitter = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddUserModal()
					}, this.renderUser = e => r.a.createElement(Ye, {
						timeAgo: Object(A.d)(this.props.language, e.approvedAtUTC),
						pageName: h.Nb.Contributors,
						primaryButton: r.a.createElement("a", {
							href: "".concat(D.a.redditUrl, "/message/compose/?to=").concat(e.username),
							target: "_blank"
						}, r.a.createElement(de.n, null, Object(G.c)("Send message"))),
						secondaryButton: r.a.createElement(de.n, {
							onClick: () => this.handleRemoveToggled(e.id, e.username)
						}, Object(G.c)("Remove")),
						subredditId: this.props.subredditId,
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderAddUserModal = () => r.a.createElement(pt, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.props.addSubmitter,
						sendEventWithName: this.props.sendEventWithName,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: this.props.username,
						withOverlay: !0
					}), this.state = et.a
				}
				componentDidMount() {
					this.props.username && this.approveSubmitter()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = e.approvedSubmitters.length ? e.approvedSubmitters[e.approvedSubmitters.length - 1].id : void 0;
					return e.approvedSubmitters.length ? r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.approveSubmitter
					}, Object(G.c)("Approve user"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Approved users"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009164452")
					})), r.a.createElement(we, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), t.searchTerm ? r.a.createElement(Oe, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !e.searchResult,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm
					}, e.searchResult && this.renderUser(e.searchResult)) : r.a.createElement(ce.b, {
						loadMoreToken: s,
						onLoadMore: this.onLoadMore
					}, e.approvedSubmitters.map((e, t) => ({
						estHeight: gt,
						id: e.id,
						render: () => this.renderUser(e)
					})))), e.isAddUserModalOpen && this.renderAddUserModal(), e.isConfirmModalOpen && t.userId && t.username && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						modalText: Object(G.c)("Are you sure you want to remove ".concat(Object(G.b)("username", t.username), " as an approved user?")),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: e.toggleRemoveUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.approveSubmitter
					}, Object(G.c)("Approve user"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Approved users"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009164452")
					})), e.approvedSubmittersListPending ? r.a.createElement(Ze, null) : r.a.createElement(z, {
						text: Object(G.c)("No approved users in ".concat(Object(G.b)("subredditName", e.subreddit.displayText), " "))
					}, r.a.createElement(Et, null))), e.isAddUserModalOpen && this.renderAddUserModal())
				}
			}
			var Ct = xt(Object(i.b)(ft, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						addSubmitter: (t, s) => e(Object(B.U)(t, s)),
						loadMore: t => e(Object(B.V)(s, {
							after: t
						})),
						removeSubmitter: (t, s) => e(Object(B.mb)(t, s)),
						searchForSubmitter: (t, s) => e(Object(B.W)(t, s)),
						toggleRemoveUserModal: () => e(Object(F.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						toggleAddUserModal: () => e(Object(F.i)("ModerationPage--Modal--AddUser"))
					}
				})(vt)),
				Ot = s("./src/app/strings/index.ts"),
				jt = s("./node_modules/lodash/find.js"),
				yt = s.n(jt);
			const kt = [{
				ms: h.Xb,
				unit: "years"
			}, {
				ms: h.db,
				unit: "months"
			}, {
				ms: h.w,
				unit: "days"
			}, {
				ms: h.I,
				unit: "hours"
			}, {
				ms: h.cb,
				unit: "minutes"
			}, {
				ms: h.Cb,
				unit: "seconds"
			}, {
				ms: 1,
				unit: "milliseconds"
			}];
			var wt = s("./src/reddit/icons/svgs/Ban/index.tsx"),
				St = s("./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx"),
				Nt = s("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				Tt = s("./src/reddit/components/CompactPost/index.tsx"),
				_t = s("./src/reddit/components/BannedUserList/ExpandedComponent.m.less"),
				It = s.n(_t);
			const Pt = Object(f.t)({
					currentProfileName: f.h,
					isCommentsPage: f.w,
					isCommentPermalink: f.v,
					isProfilePostListing: f.I,
					pageLayer: e => e
				}),
				Mt = m.a.wrapped(Nt.c, "UnthreadedComment", It.a),
				Rt = m.a.div("BanReason", It.a),
				Lt = m.a.div("ExpandedComponentContainer", It.a),
				Dt = m.a.div("ModNote", It.a),
				At = m.a.div("ModNoteContainer", It.a),
				Ft = m.a.div("SectionTitle", It.a),
				Bt = m.a.div("ContextContainer", It.a),
				Ut = e => () => {};
			var Ht = Pt(e => {
					const {
						currentProfileName: t,
						isCommentPermalink: s,
						isCommentsPage: n,
						isProfilePostListing: a,
						pageLayer: o,
						user: i
					} = e;
					return r.a.createElement(Lt, null, i.modNote && r.a.createElement(At, null, r.a.createElement(Ft, null, "Mod note:"), r.a.createElement(Dt, null, i.modNote)), r.a.createElement("div", null, r.a.createElement(Ft, null, "Banned For:"), r.a.createElement(Rt, null, i.reason), (i.postId || i.commentId) && r.a.createElement(Bt, null, i.postId && r.a.createElement(Tt.default, {
						currentProfileName: t,
						isCommentsPage: n,
						isCommentPermalink: s,
						isProfilePostListing: a,
						pageLayer: o,
						last: !0,
						postId: i.postId,
						hideModTools: !0,
						inSubredditOrProfile: !0
					}), i.commentId && r.a.createElement(Mt, {
						commentId: i.commentId,
						highlight: !1,
						trackClick: Ut
					}))))
				}),
				Wt = s("./src/reddit/components/BannedUserList/index.m.less"),
				qt = s.n(Wt);
			const Vt = 48,
				zt = (e, t) => {
					if (null == t) return Object(G.c)("Permanent"); {
						const s = function(e) {
							const t = yt()(kt, t => e >= t.ms);
							return t ? {
								amount: Math.floor(e / t.ms),
								unit: t.unit
							} : {
								amount: 0,
								unit: "justNow"
							}
						}(864e5 * t);
						0 === s.amount && (s.unit = "days");
						const n = Object(Ot.c)(e, "time.".concat(s.unit), s.amount);
						return Object(G.c)("".concat(Object(G.b)("time", n), " left"))
					}
				},
				Kt = (e, t) => {
					const s = Object(A.d)(e, t.bannedAtUTC),
						n = zt(e, t.duration);
					return "".concat(s, " (").concat(n, ")")
				},
				Qt = m.a.wrapped(wt.a, "BanIcon", qt.a),
				Gt = Object(c.c)({
					bannedUsers: st.m,
					bannedUsersList: st.i,
					bannedUsersListPending: st.h,
					language: L.S,
					loadMoreToken: st.j,
					isBanUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(tt.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--BanUserConfirmation" === Object(tt.a)(e),
					searchPending: st.k,
					searchResult: st.l
				});
			class Jt extends r.a.Component {
				constructor(e) {
					super(e), this.handleBanUserToggled = e => {
						if (e) {
							const {
								id: t,
								username: s
							} = e;
							this.setState({
								userId: t,
								username: s
							})
						} else this.setState(Object.assign({}, et.a, {
							searchTerm: this.state.searchTerm
						}));
						this.props.isBanUserModalOpen || this.props.sendEventWithName(e ? "edit_user" : "ban_dialog_banpage")(), this.props.toggleBanUserModal()
					}, this.addBannedUser = () => this.handleBanUserToggled(null), this.onSearch = e => {
						this.props.searchForBannedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.renderBannedUser = e => {
						const t = this.props.bannedUsers[e] || this.props.searchResult;
						return t ? r.a.createElement(Ye, {
							description: t.reason,
							expandedComponent: r.a.createElement(Ht, {
								user: t
							}),
							pageName: h.Nb.Banned,
							primaryButton: r.a.createElement(de.n, {
								onClick: () => this.handleBanUserToggled(t),
								"data-redditstyle": !0
							}, Object(G.c)("Edit")),
							subredditId: this.props.subredditId,
							timeAgo: Kt(this.props.language, t),
							userIcon: t.accountIcon,
							username: t.username
						}) : r.a.createElement("div", null)
					}, this.renderAddBannedUserModal = () => r.a.createElement(St.a, {
						ignoreDefaultFocus: !0,
						onUnbanUser: this.state.userId ? this.props.onUnbanUser(this.state.userId) : void 0,
						subredditId: this.props.subredditId,
						toggleModal: () => this.handleBanUserToggled(null),
						trackAddEvent: this.props.sendEventWithName("add_banpage"),
						trackEventWithName: this.props.sendEventWithName,
						user: this.state.userId ? this.state.searchTerm ? this.props.searchResult || null : this.props.bannedUsers[this.state.userId] : null,
						withOverlay: !0
					}), this.state = et.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = e.bannedUsersList.length ? e.bannedUsersList[e.bannedUsersList.length - 1].id : void 0;
					return e.bannedUsersList.length ? r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, Object(G.c)("Ban user"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Banned users"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), r.a.createElement(we, {
						onSearch: this.onSearch,
						activeSearchQuery: this.state.searchTerm
					}), t.searchTerm ? r.a.createElement(Oe, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderBannedUser(e.searchResult.id)) : r.a.createElement(ce.b, {
						loadMoreToken: s,
						onLoadMore: this.onLoadMore
					}, e.bannedUsersList.map(e => ({
						estHeight: Vt,
						id: e.id,
						render: () => this.renderBannedUser(e.id)
					})))), e.isBanUserModalOpen && this.renderAddBannedUserModal(), e.isConfirmModalOpen && t.userId && t.username && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						modalText: Object(G.c)("Are you sure you want to ban ".concat(Object(G.b)("username", t.username), "?")),
						onConfirm: () => {},
						toggleModal: e.toggleBanUserModal,
						trackClick: e.sendEventWithName("remove")
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, " ", Object(G.c)("Ban user"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Banned users"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), e.bannedUsersListPending ? r.a.createElement(Ze, null) : r.a.createElement(z, {
						text: Object(G.c)("No banned users in ".concat(Object(G.b)("subredditName", e.subreddit.displayText)))
					}, r.a.createElement(Qt, null))), e.isBanUserModalOpen && this.renderAddBannedUserModal())
				}
			}
			var Zt = Object(i.b)(Gt, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						loadMore: t => e(Object(B.Z)(s, {
							after: t
						})),
						onUnbanUser: t => () => e(Object(B.nb)(s, t)),
						searchForBannedUser: t => e(Object(B.ab)(s, t)),
						toggleBanUserModal: () => e(Object(F.i)("ModerationPage--Modal--AddUser"))
					}
				})(Jt),
				Xt = (s("./node_modules/core-js/modules/es6.array.sort.js"), s("./src/reddit/actions/gold/communityAwards.ts")),
				Yt = s("./src/reddit/actions/tooltip.ts"),
				$t = s("./src/reddit/constants/gold.ts"),
				es = s("./src/reddit/helpers/correlationIdTracker.ts"),
				ts = s("./src/reddit/helpers/trackers/communityAwards.ts"),
				ss = (s("./node_modules/core-js/modules/web.dom.iterable.js"), s("./src/higherOrderComponents/makeAsync.tsx")),
				ns = s("./src/lib/loadWithRetries/index.ts");
			var as = Object(ss.a)({
					getComponent: () => Object(ns.a)(() => Promise.all([s.e("CommunityAwardCreationModal").then(s.bind(null, "./src/reddit/components/CommunityAwardCreationModal/index.tsx"))])).then(e => e[0].default),
					ErrorComponent: () => null,
					LoadingComponent: () => null
				}),
				os = s("./src/reddit/models/Gold/Award.ts"),
				rs = s("./src/reddit/components/ConfirmModal/index.tsx"),
				is = s("./src/reddit/icons/svgs/Gild/index.tsx"),
				cs = s("./src/reddit/icons/svgs/Info/index.tsx"),
				ds = s("./src/reddit/icons/svgs/Trash2/index.tsx"),
				ls = s("./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts"),
				ms = s("./src/reddit/components/CommunityAwardList/AwardRow/index.m.less"),
				us = s.n(ms);
			const ps = () => r.a.createElement("div", {
					className: us.a.row
				}, r.a.createElement("div", {
					className: us.a.awardName
				}, r.a.createElement("div", {
					className: us.a.emptyDetails
				})), r.a.createElement("div", {
					className: us.a.awardDetail
				}, r.a.createElement("div", {
					className: us.a.emptyIcon
				})), r.a.createElement("div", {
					className: us.a.awardDetail
				}, r.a.createElement("div", {
					className: us.a.emptyDetails
				})), r.a.createElement("div", {
					className: us.a.awardDetail
				}, r.a.createElement("div", {
					className: us.a.emptyDetails
				}))),
				bs = e => r.a.createElement("div", {
					className: Object(d.a)(e.className, us.a.awardLoadingContainer)
				}, Ne()(10, e => r.a.createElement(ps, {
					key: e
				}))),
				hs = e => {
					let {
						subredditId: t
					} = e;
					return r.a.createElement("div", {
						className: us.a.headerRow
					}, r.a.createElement("div", {
						className: us.a.awardName
					}, r.a.createElement(_e.c, null, "Name")), r.a.createElement("div", {
						className: us.a.awardDetail
					}, r.a.createElement(_e.c, null, "Icon")), r.a.createElement("div", {
						className: us.a.awardDetail
					}, r.a.createElement(_e.c, null, "Coins")), r.a.createElement("div", {
						className: us.a.awardDetail
					}, r.a.createElement(_e.c, null, "Type")), Object(ls.a)(t) && r.a.createElement("div", {
						className: us.a.awardDetail
					}, r.a.createElement(_e.c, null, "Starts")), Object(ls.a)(t) && r.a.createElement("div", {
						className: us.a.awardDetail
					}, r.a.createElement(_e.c, null, "Expires")))
				},
				gs = e => {
					let {
						date: t
					} = e;
					return r.a.createElement("div", {
						className: us.a.awardExpiresDetail
					}, t && t.toLocaleString())
				},
				Es = e => r.a.createElement("div", {
					className: us.a.row
				}, r.a.createElement("div", {
					className: Object(d.a)(us.a.awardName, us.a.unfilledAward)
				}, r.a.createElement(_e.c, null, "Create up to ", r.a.createElement(_e.b, {
					name: "quantity"
				}, e.quantity), " more ", r.a.createElement(_e.b, {
					name: "coin-price"
				}, e.coinPrice), " Coin ", r.a.createElement(_e.a, {
					name: "award",
					singular: "Award",
					plural: "Awards",
					count: e.quantity
				}))), r.a.createElement(ue.a, {
					className: us.a.rightAlign
				}, r.a.createElement(de.f, {
					className: us.a.createButton,
					onClick: e.onCreate
				}, r.a.createElement(_e.c, null, "Create")))),
				xs = e => r.a.createElement("div", {
					className: us.a.row
				}, r.a.createElement("div", {
					className: Object(d.a)(us.a.awardName, us.a.unfilledAward)
				}, r.a.createElement(_e.c, null, "Create a Moderator-Only Award")), r.a.createElement(ue.a, {
					className: us.a.rightAlign
				}, r.a.createElement(de.f, {
					className: us.a.createButton,
					onClick: e.onCreate
				}, r.a.createElement(_e.c, null, "Create"))));
			class fs extends r.a.Component {
				constructor() {
					super(...arguments), this.onDelete = e => {
						e.preventDefault(), this.props.onDelete(this.props.award.id)
					}
				}
				render() {
					const {
						award: e,
						canDelete: t,
						subredditId: s
					} = this.props, n = e.icon32 ? e.icon32.url : e.icon.url, a = Object(ls.a)(s), o = e.startsAt ? new Date(e.startsAt) : void 0, i = e.endsAt ? new Date(e.endsAt) : void 0;
					return r.a.createElement("div", {
						className: us.a.row
					}, r.a.createElement("div", {
						className: us.a.awardName
					}, e.name), r.a.createElement("div", {
						className: us.a.awardDetail
					}, r.a.createElement("img", {
						className: us.a.awardIconImage,
						src: n,
						title: e.name
					})), r.a.createElement("div", {
						className: us.a.awardDetail
					}, e.coinPrice || 0), r.a.createElement("div", {
						className: us.a.awardDetail
					}, e.awardType === os.c.Moderator ? r.a.createElement(_e.c, null, "Mod only") : r.a.createElement(_e.c, null, "All")), a && [r.a.createElement(gs, {
						date: o
					}), r.a.createElement(gs, {
						date: i
					})], r.a.createElement(ue.a, {
						className: us.a.rightAlign
					}, t && r.a.createElement("a", {
						href: ".",
						onClick: this.onDelete
					}, r.a.createElement(ds.b, {
						className: us.a.deleteIcon
					}))))
				}
			}
			var vs = fs,
				Cs = s("./src/reddit/selectors/communityAwards.ts"),
				Os = s("./src/reddit/components/CommunityAwardList/index.m.less"),
				js = s.n(Os);
			const ys = Object(c.c)({
					awards: Cs.e,
					awardsPending: Cs.d,
					communityAwardsDisabled: Cs.b,
					isAddAwardModalOpen: e => Object(tt.a)(e) === $t.a,
					isConfirmModalOpen: e => Object(tt.a)(e) === $t.b
				}),
				ks = Object(i.b)(ys, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						deleteAward: t => e(Object(Xt.f)(s, t)),
						toggleAddAwardModal: () => e(Object(F.i)($t.a)),
						toggleConfirmModal: () => e(Object(F.i)($t.b)),
						toggleTooltip: t => e(Object(Yt.g)({
							tooltipId: t
						}))
					}
				}),
				ws = {
					awardId: null,
					selectedCoinPrice: void 0,
					selectedModOnly: void 0
				};
			class Ss extends r.a.Component {
				constructor(e) {
					super(e), this.openAddAwardModal = (e, t) => {
						Object(es.d)(es.a.AwardCreationFlow), this.props.sendEvent(Object(ts.d)()), this.setState({
							selectedCoinPrice: e,
							selectedModOnly: t
						}, this.props.toggleAddAwardModal)
					}, this.openDeleteAwardModal = e => {
						Object(es.d)(es.a.AwardDeletionFlow), this.props.toggleConfirmModal(), this.setState({
							awardId: e
						})
					}, this.confirmDeleteAward = () => {
						const {
							awardId: e
						} = this.state, {
							awards: t
						} = this.props;
						if (this.props.toggleConfirmModal(), e) {
							const s = t.filter(t => t.id === e)[0];
							s && this.props.sendEvent(Object(ts.f)(s)), this.props.deleteAward(e), Object(es.b)(es.a.AwardDeletionFlow)
						}
					}, this.renderAwardSlotRow = e => {
						const {
							awards: t,
							moderatorPermissions: s,
							subredditId: n
						} = this.props, a = !(!s || !s.all);
						if (!e.filled && t.length < $t.d) return r.a.createElement(Es, {
							coinPrice: e.price,
							key: e.price,
							onCreate: () => this.openAddAwardModal(e.price),
							quantity: e.quantity
						});
						if (!e.filled) return null;
						const {
							award: o
						} = e;
						return r.a.createElement(vs, {
							key: o.id,
							award: o,
							canDelete: a,
							onDelete: this.openDeleteAwardModal,
							subredditId: n
						})
					}, this.renderAwardToDelete = () => {
						const {
							awards: e
						} = this.props, {
							awardId: t
						} = this.state;
						if (!t) return null;
						const s = e.filter(e => e.id === t)[0];
						return s ? r.a.createElement("div", {
							className: js.a.awardToDelete
						}, r.a.createElement("span", null, r.a.createElement(_e.c, null, "Remove: ")), r.a.createElement("img", {
							src: s.icon.url,
							className: js.a.awardToDeleteIcon
						}), r.a.createElement("span", null, s.name)) : null
					}, this.renderInfo = () => r.a.createElement("div", {
						className: js.a.pageInfo
					}, r.a.createElement(cs.a, {
						className: js.a.infoIcon
					}), r.a.createElement("p", null, r.a.createElement(_e.c, null, "Community Awards are unique to each community, and members can give them to each other. Moderators can design and name the Awards however they want.")), r.a.createElement("p", null, r.a.createElement(_e.c, null, "A portion of Coins from Community Award purchases will be deposited to the community’s Coin balance. Moderators can use Coins from that balance to reward members with Mod Awards. The Coin balance is shown only to moderators in the community’s sidebar"))), this.state = ws
				}
				renderAwardsList() {
					const {
						awards: e,
						awardsPending: t,
						moderatorPermissions: s,
						subredditId: n
					} = this.props;
					if (t) return r.a.createElement(bs, null);
					const a = s && s.all,
						o = this.getAwardSlots().filter(e => a || e.filled),
						i = e.filter(e => e.awardType === os.c.Moderator),
						c = e.length < $t.d && i.length < $t.e && a;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(hs, {
						subredditId: n
					}), o.map(this.renderAwardSlotRow), c && r.a.createElement(xs, {
						onCreate: () => this.openAddAwardModal(void 0, !0)
					}))
				}
				getAwardSlots() {
					const {
						awards: e
					} = this.props, t = Object(os.f)(e), s = e => e.filled && e.award.awardType === os.c.Moderator;
					return t.sort((e, t) => s(e) && !s(t) ? 1 : s(t) && !s(e) ? -1 : e.price !== t.price ? e.price - t.price : e.filled && !t.filled ? -1 : (t.filled && e.filled, 1))
				}
				render() {
					const {
						communityAwardsDisabled: e,
						isAddAwardModalOpen: t,
						isConfirmModalOpen: s,
						subreddit: n,
						subredditId: a,
						toggleAddAwardModal: o,
						toggleConfirmModal: i
					} = this.props, {
						awardId: c,
						selectedCoinPrice: d,
						selectedModOnly: l
					} = this.state;
					return n.isNSFW || n.isQuarantined || e ? this.renderBlacklistedView() : r.a.createElement(r.a.Fragment, null, r.a.createElement(oe, {
						className: js.a.contentContainer
					}, r.a.createElement(re, null, r.a.createElement(_e.c, null, "Awards")), this.renderAwardsList()), this.renderInfo(), t && r.a.createElement(as, {
						defaultCoinPrice: d,
						defaultModOnly: l,
						subredditId: a,
						toggleModal: () => {
							o(), Object(es.b)(es.a.AwardCreationFlow)
						}
					}), s && c && r.a.createElement(rs.a, {
						acceptText: Object(G.c)("Delete"),
						cancelText: Object(G.c)("Cancel"),
						headerText: Object(G.c)("Delete Award"),
						message: Object(G.c)("Deleting an Award will remove the option for members of your community to give the Award. Existing Awards will remain on the posts and comments that have received them."),
						onAccept: this.confirmDeleteAward,
						onCancel: i,
						onClose: i,
						onOverlayClick: i,
						withOverlay: !0
					}, this.renderAwardToDelete()))
				}
				renderBlacklistedView() {
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(oe, {
						className: js.a.contentContainer
					}, r.a.createElement(re, null, r.a.createElement(_e.c, null, "Awards")), r.a.createElement(z, {
						text: Object(G.c)("Community Awards have been disabled for this community.")
					}, r.a.createElement(is.a, {
						className: js.a.gildIcon
					}))))
				}
			}
			var Ns = ks(Object(x.b)(Ss)),
				Ts = s("./node_modules/lodash/isEqual.js"),
				_s = s.n(Ts),
				Is = s("./src/reddit/actions/pages/shared.ts"),
				Ps = s("./src/reddit/actions/subredditSettings.ts"),
				Ms = s("./src/reddit/actions/tags/index.ts"),
				Rs = s("./src/reddit/featureFlags/index.ts"),
				Ls = s("./node_modules/lodash/snakeCase.js"),
				Ds = s.n(Ls);
			const As = {
					contentOptions: "link_type",
					contentVisible: "allow_top",
					subredditType: "type",
					welcomeMessageText: "welcome_message"
				},
				Fs = {
					allowChatPostCreation: h.Ob.Posts,
					allowDiscovery: h.Ob.Safety,
					allowImages: h.Ob.Posts,
					allowPolls: h.Ob.Posts,
					allowPostCrossposts: h.Ob.Posts,
					collapseDeletedComments: h.Ob.Posts,
					commentScoreHideMins: h.Ob.Posts,
					contentOptions: h.Ob.Posts,
					contentVisible: h.Ob.Safety,
					crowdControlChatLevel: h.Ob.Safety,
					crowdControlLevel: h.Ob.Safety,
					crowdControlMode: h.Ob.Safety,
					disableContributorRequests: h.Ob.Community,
					excludeBannedModqueue: h.Ob.Safety,
					over18: h.Ob.Community,
					publicDescription: h.Ob.Community,
					restrictCommenting: h.Ob.Community,
					restrictPosting: h.Ob.Community,
					spamComments: h.Ob.Posts,
					spamLinks: h.Ob.Posts,
					spamSelfposts: h.Ob.Posts,
					spoilersEnabled: h.Ob.Posts,
					subredditType: h.Ob.Community,
					suggestedCommentSort: h.Ob.Posts,
					welcomeMessageEnabled: h.Ob.Community,
					welcomeMessageText: h.Ob.Community,
					wikiEditAge: h.Ob.Wikis,
					wikiEditKarma: h.Ob.Wikis,
					wikimode: h.Ob.Wikis
				},
				Bs = {
					[h.Ob.Community]: "community_settings_details",
					[h.Ob.Safety]: "community_settings_safety",
					[h.Ob.Posts]: "community_settings_content",
					[h.Ob.Wikis]: "community_settings_wiki"
				},
				Us = e => As[e] || Ds()(e),
				Hs = e => {
					const t = Fs[e];
					return t && Bs[t] || "community_settings"
				},
				Ws = (e, t, s) => n => Object.assign({
					source: Hs(e),
					action: "click",
					noun: Us(e),
					setting: {
						value: String(t),
						oldValue: String(s)
					},
					subreddit: y.subreddit(n)
				}, y.defaults(n)),
				qs = (e, t, s) => n => Object.assign({
					source: Hs(e),
					action: "save",
					noun: Us(e),
					setting: {
						value: String(t),
						oldValue: String(s)
					},
					subreddit: y.subreddit(n)
				}, y.defaults(n)),
				Vs = e => t => Object.assign({
					source: "community_settings",
					action: "click",
					noun: Bs[e]
				}, y.defaults(t)),
				zs = e => t => Object.assign({
					source: Bs[e],
					action: "click",
					noun: "r2_community_settings"
				}, y.defaults(t));
			var Ks = s("./src/reddit/helpers/trackers/communityTopics.ts"),
				Qs = s("./src/reddit/selectors/experiments/chatPost.ts"),
				Gs = s("./src/reddit/selectors/experiments/pollsGA.ts"),
				Js = s("./src/reddit/components/CommunityTopics/index.tsx"),
				Zs = s("./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx"),
				Xs = s("./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx"),
				Ys = s("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				$s = s("./src/reddit/components/Settings/shared/Widgets.tsx"),
				en = s("./src/reddit/controls/Link/index.tsx"),
				tn = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				sn = s("./src/reddit/controls/RadioInput/index.tsx"),
				nn = s("./src/reddit/models/Flair/index.ts"),
				an = s("./src/reddit/models/SubredditRestrictions/index.ts"),
				on = s("./src/reddit/pages/SubredditCreation/index.tsx"),
				rn = s("./src/reddit/controls/FormFields/index.tsx"),
				cn = s("./src/reddit/components/CommunitySettings/components.m.less"),
				dn = s.n(cn);
			const ln = m.a.wrapped(rn.b, "InputField", dn.a),
				mn = m.a.div("FormContainer", dn.a);
			var un = s("./src/reddit/components/CommunitySettings/helpers.ts"),
				pn = s("./src/reddit/components/CommunitySettings/index.m.less"),
				bn = s.n(pn);
			const hn = {
				[an.e.Post]: {
					short: Object(G.c)("Post only (default)"),
					long: Object(G.c)("Only approved users can post. Anyone can comment.")
				},
				[an.e.Comment]: {
					short: Object(G.c)("Comment only"),
					long: Object(G.c)("Only approved users can comment. Anyone can post.")
				},
				[an.e.PostAndComment]: {
					short: Object(G.c)("Post & Comment"),
					long: Object(G.c)("Only approved users can post and comment.")
				}
			};
			var gn = e => {
				const {
					communityTopicsEnabled: t,
					isEmployee: s,
					language: n,
					restrictions: a,
					settings: o,
					subreddit: i,
					subredditId: c,
					subredditName: d,
					testWelcomeMessage: l,
					update: m
				} = e, {
					disableContributorRequests: u,
					over18: b,
					publicDescription: g,
					restrictCommenting: E,
					restrictPosting: x,
					subredditType: f,
					title: v,
					welcomeMessageEnabled: C,
					welcomeMessageText: O
				} = o, j = [], y = [];
				for (const r of Object.keys(hn)) y.push(hn[r].short), j.push(hn[r].long);
				const k = i.subscribers < un.k || !!O;
				return r.a.createElement(oe, null, r.a.createElement(mn, null, r.a.createElement(re, null, r.a.createElement(_e.c, null, "Community settings")), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Community Profile")), r.a.createElement($s.e, {
					label: p.fbt._("Community name", null, {
						hk: "260EEx"
					}),
					maxChars: un.d,
					onChange: e => m(e.currentTarget.value, "title"),
					textContainerClassName: bn.a.fullWidthTextContainer,
					value: v || ""
				}), t && r.a.createElement($s.j, {
					label: Object(G.c)("Community topics"),
					textContainerClassName: bn.a.fullWidthTextContainer,
					subtext: r.a.createElement("span", {
						className: bn.a.subtextContainer
					}, r.a.createElement(_e.c, null, "This will help Reddit recommend your community to relevant users and other discovery experiences."), " ", r.a.createElement(tn.a, {
						className: bn.a.communityTopicsHelpLink,
						isSponsored: !1,
						source: null,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360024518712",
						target: "_blank"
					}, Object(G.c)("Learn more.")), "  ", r.a.createElement("span", {
						className: bn.a.numCommunityTopicsSelected
					}, r.a.createElement(Zs.a, {
						subredditId: c
					}))),
					direction: "column"
				}, r.a.createElement(Js.b, {
					context: Ks.a.communitySettings,
					subredditId: c
				}), r.a.createElement(Xs.a, {
					context: Ks.a.communitySettings,
					subredditId: c
				})), r.a.createElement($s.g, {
					label: Object(G.c)("Community description"),
					onChange: e => m(e.currentTarget.value, "publicDescription", !1),
					maxChars: un.c,
					rows: 2,
					subtext: Object(G.c)("This is how new members come to understand your community."),
					value: g || ""
				}), k && r.a.createElement($s.n, {
					className: C ? bn.a.welcomeMessageEnabled : void 0,
					on: C,
					onClick: () => m(!C, "welcomeMessageEnabled"),
					label: Object(G.c)("Send welcome message to new members"),
					subtext: r.a.createElement("span", null, r.a.createElement(_e.c, null, "Create a custom welcome message to greet people when they join your community. People who receive a welcome message are more likely to participate in your community. This field supports markdown."), " ", r.a.createElement(tn.a, {
						className: bn.a.welcomeMessageHelpLink,
						isSponsored: !1,
						source: null,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360002551551-Welcoming-new-members"
					}, Object(G.c)("Learn more.")))
				}), k && C && r.a.createElement(r.a.Fragment, null, r.a.createElement($s.g, {
					actionLink: r.a.createElement(en.a, {
						onClick: () => l(d, O)
					}, p.fbt._("Send me a test message", null, {
						hk: "4iE1go"
					})),
					label: null,
					onChange: e => {
						m(e.currentTarget.value, "welcomeMessageText")
					},
					maxChars: un.e,
					rows: 2,
					value: O || ""
				})), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "community type")), r.a.createElement($s.j, {
					label: Object(G.c)("Type of Community"),
					direction: "column"
				}, r.a.createElement(sn.a, {
					value: f,
					name: "type",
					onChange: e => m(e, "subredditType")
				}, Object(on.radioOptions)(n, s, a))), r.a.createElement($s.n, {
					on: b,
					onClick: () => m(!b, "over18"),
					label: r.a.createElement("span", null, r.a.createElement(_e.c, null, "18+ year old community"), r.a.createElement($s.k, {
						flair: nn.f.Nsfw
					})),
					subtext: Object(G.c)("When your community is marked as an 18+ community, users must be flagged as 18+ in their user settings")
				}), "restricted" === f && r.a.createElement(r.a.Fragment, null, r.a.createElement(Ys.a, null, Object(G.c)("Restricted Community Settings")), r.a.createElement($s.d, {
					label: Object(G.c)("Approved users have the ability to"),
					items: y,
					selected: (() => {
						let e = an.e.Post;
						return E && x ? e = an.e.PostAndComment : E && (e = an.e.Comment), hn[e].short
					})(),
					onClick: e => {
						e === hn[an.e.PostAndComment].short ? (m(!0, an.f.Comment), m(!0, an.f.Post)) : e === hn[an.e.Comment].short ? (m(!1, an.f.Post), m(!0, an.f.Comment)) : e === hn[an.e.Post].short && (m(!0, an.f.Post), m(!1, an.f.Comment))
					},
					id: "restrictionOptions",
					descriptions: j
				}), r.a.createElement($s.n, {
					on: !u,
					onClick: () => m(!u, "disableContributorRequests"),
					label: Object(G.c)("Accepting new requests to post")
				})), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Advanced Settings")), r.a.createElement($s.f, {
					label: Object(G.c)("Settings for old site"),
					subtext: Object(G.c)("To change settings that influence the old site, you must go to the old settings page"),
					link: "".concat(D.a.oldRedditUrl, "/r/").concat(d, "/about/edit"),
					onClick: () => e.sendEvent(zs(h.Ob.Posts)),
					openInNewTab: !0,
					last: !0
				})))
			};
			var En = e => {
					const {
						settings: t,
						showAllowPolls: s,
						subredditName: n,
						update: a,
						isChatPostsCreationEnabled: o
					} = e, {
						allowChatPostCreation: i,
						allowImages: c,
						allowPolls: d,
						allowPostCrossposts: l,
						collapseDeletedComments: m,
						commentScoreHideMins: u,
						contentOptions: b,
						spamComments: g,
						spamLinks: E,
						spamSelfposts: x,
						spoilersEnabled: f,
						suggestedCommentSort: v
					} = t;
					return r.a.createElement(oe, null, r.a.createElement(mn, null, r.a.createElement(re, null, r.a.createElement(_e.c, null, "Post and Comment settings")), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Posts")), r.a.createElement($s.d, {
						label: Object(G.c)("Post type options"),
						items: Object.keys(un.h),
						selected: Object(un.p)(un.h, b),
						onClick: e => a(un.h[e], "contentOptions"),
						id: "contentOptions",
						descriptions: un.g
					}), r.a.createElement($s.n, {
						on: l,
						onClick: () => a(!l, "allowPostCrossposts"),
						label: Object(G.c)("Allow crossposting of posts.")
					}), o && r.a.createElement($s.n, {
						on: i,
						onClick: () => a(!i, "allowChatPostCreation"),
						label: Object(G.c)("Allow chat posts creation by users.")
					}), r.a.createElement($s.n, {
						on: f,
						onClick: () => a(!f, "spoilersEnabled"),
						label: r.a.createElement("span", null, r.a.createElement(_e.c, null, "Enable spoiler tag"), r.a.createElement($s.k, {
							flair: nn.f.Spoiler
						})),
						subtext: Object(G.c)("Media on posts with the spoiler tag are blurred")
					}), r.a.createElement($s.n, {
						on: c,
						onClick: () => a(!c, "allowImages"),
						label: Object(G.c)("Allow image uploads and links to image hosting sites")
					}), s && r.a.createElement($s.n, {
						on: d,
						onClick: () => a(!d, "allowPolls"),
						label: p.fbt._("Allow polls", null, {
							hk: "15LXRO"
						})
					}), r.a.createElement($s.j, {
						label: Object(G.c)("Spam filter strength"),
						subtext: Object(G.c)("'HIGH' is the standard filter, 'LOW' disables most filtering, 'ALL' will filter every post initially and they will need to be approved manually to be visible")
					}), r.a.createElement($s.d, {
						label: Object(G.c)("Posts"),
						items: Object.keys(un.j),
						id: "spamSelfposts",
						selected: Object(un.p)(un.j, x),
						onClick: e => a(un.j[e], "spamSelfposts"),
						indent: !0
					}), r.a.createElement($s.d, {
						label: Object(G.c)("Links"),
						items: Object.keys(un.j),
						id: "spamLinks",
						selected: Object(un.p)(un.j, E),
						onClick: e => a(un.j[e], "spamLinks"),
						indent: !0
					}), r.a.createElement($s.d, {
						label: Object(G.c)("Comments"),
						items: Object.keys(un.b),
						selected: Object(un.p)(un.b, g),
						onClick: e => a(un.b[e], "spamComments"),
						indent: !0,
						id: "spamComments"
					}), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Comments")), r.a.createElement($s.d, {
						label: Object(G.c)("Suggested sort"),
						subtext: Object(G.c)("All comment feeds in community will default to this sort setting"),
						items: Object.keys(un.i),
						selected: Object(un.p)(un.i, v),
						onClick: e => a(un.i[e], "suggestedCommentSort"),
						id: "suggestedCommentSort"
					}), r.a.createElement($s.n, {
						on: m,
						onClick: () => a(!m, "collapseDeletedComments"),
						label: Object(G.c)("Collapse deleted and removed comments")
					}), r.a.createElement($s.j, {
						label: Object(G.c)("Minutes to hide comment scores"),
						direction: "column"
					}, r.a.createElement(ln, {
						onChange: e => a(e.currentTarget.value, "commentScoreHideMins"),
						isInvalid: !(u >= un.f && u <= un.a),
						min: un.f,
						max: un.a,
						type: "number",
						value: u
					})), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Advanced Settings")), r.a.createElement($s.f, {
						label: Object(G.c)("Settings for old site"),
						subtext: Object(G.c)("To change settings that influence the old site, you must go to the old settings page"),
						link: "".concat(D.a.oldRedditUrl, "/r/").concat(n, "/about/edit"),
						onClick: () => e.sendEvent(zs(h.Ob.Posts)),
						openInNewTab: !0,
						last: !0
					})))
				},
				xn = e => {
					const {
						crowdControlModeEnabled: t,
						crowdControlLevelEnabled: s,
						isChatPostsCreationEnabled: n,
						settings: a,
						subredditName: o,
						update: i
					} = e, {
						allowDiscovery: c,
						contentVisible: d,
						crowdControlMode: l,
						crowdControlLevel: m,
						crowdControlChatLevel: u,
						excludeBannedModqueue: p
					} = a, b = {
						0: {
							text: "Off",
							color: "#787C7E",
							subText: "Use Crowd Control to automatically collapse comments from users you’re not sure about."
						},
						1: {
							text: "Lenient",
							color: "#46D160",
							subText: "Comments from users who have negative karma in your community are automatically collapsed."
						},
						2: {
							text: "Moderate",
							color: "#FFB000",
							subText: "Comments from new users and users with negative karma in your community are automatically collapsed."
						},
						3: {
							text: "Strict",
							color: "#FF4500",
							subText: "Comments from users who haven’t joined your community, new users, and users with negative karma in your community are automatically collapsed."
						}
					};
					return r.a.createElement(oe, null, r.a.createElement(mn, null, r.a.createElement(re, null, r.a.createElement(_e.c, null, "Safety & privacy settings")), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Safety")), r.a.createElement($s.n, {
						on: p,
						onClick: () => i(!p, "excludeBannedModqueue"),
						label: Object(G.c)("Exclude posts by site-wide banned users"),
						subtext: Object(G.c)("Posts are excluded from modqueue/unmoderated")
					}), t && r.a.createElement($s.n, {
						on: l,
						onClick: () => i(!l, "crowdControlMode"),
						label: Object(G.c)("Turn on crowd control mode"),
						subtext: Object(G.c)("When crowd control is enabled, comments from users who aren't yet fully trusted in your community (including new users) will display as collapsed by default ")
					}), s && r.a.createElement($s.h, {
						ticks: b,
						min: 0,
						max: Object.keys(b).length - 1,
						step: 1,
						value: m,
						onChange: e => i(e.target.value, "crowdControlLevel"),
						label: Object(G.c)("Adjust Crowd Control"),
						subtext: Object(G.c)(b[m].subText)
					}), n && r.a.createElement($s.h, {
						ticks: b,
						min: 0,
						max: Object.keys(b).length - 1,
						step: 1,
						value: u,
						onChange: e => i(e.target.value, "crowdControlChatLevel"),
						label: Object(G.c)("Adjust Crowd Control for Chat Posts"),
						subtext: Object(G.c)(b[u].subText)
					}), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Privacy")), r.a.createElement($s.n, {
						on: d,
						onClick: () => i(!d, "contentVisible"),
						label: Object(G.c)("Allow posts in /r/all, /r/popular, default, and trending lists")
					}), r.a.createElement($s.n, {
						on: c,
						onClick: () => i(!c, "allowDiscovery"),
						label: Object(G.c)("Allow community in discovery and onboarding")
					}), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Advanced Settings")), r.a.createElement($s.f, {
						label: Object(G.c)("Settings for old site"),
						subtext: Object(G.c)("To change settings that influence the old site, you must go to the old settings page"),
						link: "".concat(D.a.oldRedditUrl, "/r/").concat(o, "/about/edit"),
						onClick: () => e.sendEvent(zs(h.Ob.Safety)),
						openInNewTab: !0,
						last: !0
					})))
				},
				fn = e => {
					const {
						settings: t,
						subredditName: s,
						update: n
					} = e, {
						wikiEditAge: a,
						wikiEditKarma: o,
						wikimode: i
					} = t;
					return r.a.createElement(oe, null, r.a.createElement(mn, null, r.a.createElement(re, null, r.a.createElement(_e.c, null, "Wiki settings")), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Community wiki pages")), r.a.createElement($s.d, {
						label: Object(G.c)("Wikis can be edited by"),
						items: Object.keys(un.o),
						selected: Object(un.p)(un.o, i),
						onClick: e => n(un.o[e], "wikimode"),
						id: "wikimode",
						descriptions: un.n
					}), r.a.createElement($s.j, {
						label: Object(G.c)("Karma required to edit and create wiki pages"),
						direction: "column"
					}, r.a.createElement(ln, {
						onChange: e => n(e.currentTarget.value, "wikiEditKarma"),
						isInvalid: !(o >= un.f && o <= un.m),
						min: un.f,
						max: un.m,
						type: "number",
						value: o
					})), r.a.createElement($s.j, {
						label: Object(G.c)("Age of Reddit account required to edit and create wiki pages"),
						direction: "column"
					}, r.a.createElement(ln, {
						onChange: e => n(e.currentTarget.value, "wikiEditAge"),
						isInvalid: !(a >= un.f && a <= un.l),
						min: un.f,
						max: un.l,
						type: "number",
						value: a
					})), r.a.createElement(Ys.a, null, r.a.createElement(_e.c, null, "Advanced Settings")), r.a.createElement($s.f, {
						label: Object(G.c)("Settings for old site"),
						subtext: Object(G.c)("To change settings that influence the old site, you must go to the old settings page"),
						link: "".concat(D.a.oldRedditUrl, "/r/").concat(s, "/about/edit"),
						onClick: () => e.sendEvent(zs(h.Ob.Wikis)),
						openInNewTab: !0,
						last: !0
					})))
				};
			const vn = Object(c.c)({
				allowChatPostCreation: (e, t) => Object(Qs.b)(e, t.subredditId),
				communityTopicsEnabled: Rs.d.communityTopics,
				crowdControlModeEnabled: Rs.d.enableCrowdControlMode,
				crowdControlLevelEnabled: Rs.d.enableCrowdControlLevel,
				isChatPostsCreationEnabled: (e, t) => Object(Qs.c)(e, t.subredditId),
				isEmployee: L.G,
				language: L.S,
				restrictions: R.o,
				settings: (e, t) => Object(R.U)(e, t.subredditId),
				showAllowPolls: (e, t) => Object(Gs.a)(t.subredditName),
				subreddit: R.S
			});
			class Cn extends r.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.saveSettings = () => {
						this.props.save(this.state.changed, this.props.subredditId), this.props.saveCommunityTopics(this.props.subredditId);
						for (const e in this.state.changed) this.props.sendEvent(qs(e, this.state.changed[e], this.props.settings[e]));
						this.setState({
							settings: this.state.settings,
							changed: {}
						})
					}, this.update = function(e, s) {
						let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						n && t.props.sendEvent(Ws(s, e, t.state.settings[s])), t.setState(t => ({
							changed: Object.assign({}, t.changed, {
								[s]: e
							}),
							settings: Object.assign({}, t.settings, {
								[s]: e
							})
						}))
					}, this.renderSubpage = () => {
						const e = Object.assign({}, this.props, {
							settings: this.state.settings,
							update: this.update
						});
						if (!this.state.settings) return null;
						switch (this.props.subpageName) {
							case h.Ob.Safety:
								return r.a.createElement(xn, e);
							case h.Ob.Posts:
								return r.a.createElement(En, e);
							case h.Ob.Wikis:
								return r.a.createElement(fn, e);
							default:
								return r.a.createElement(gn, e)
						}
					}, this.state = {
						settings: e.settings,
						changed: {}
					}
				}
				componentDidMount() {
					this.props.onViewPageEvent()
				}
				componentDidUpdate(e) {
					!this.props.settings || _s()(e.settings, this.props.settings) || _s()(this.state.settings, this.props.settings) || this.setState({
						settings: this.props.settings
					})
				}
				render() {
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.saveSettings,
						"data-redditstyle": !0
					}, r.a.createElement(_e.c, null, "Save changes"))), this.renderSubpage())
				}
			}
			var On = Object(i.b)(vn, e => ({
					onViewPageEvent: () => e(Object(Is.a)()),
					testWelcomeMessage: (t, s) => e(Object(Ps.g)(t, s)),
					save: (t, s) => e(Object(Ps.h)(s, t)),
					saveCommunityTopics: t => e(Object(Ms.h)(t, Ks.a.communitySettings))
				}))(Object(x.b)(Cn)),
				jn = s("./src/lib/addQueryParams/index.ts"),
				yn = s("./src/lib/omitKey/index.ts"),
				kn = s("./node_modules/url/url.js"),
				wn = s.n(kn);
			var Sn = e => {
					const t = wn.a.parse(e);
					return t.search = void 0, t.query = null, wn.a.format(t)
				},
				Nn = s("./src/reddit/actions/grantUserFlair/index.ts"),
				Tn = s("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				_n = s("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				In = s("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				Pn = s("./src/reddit/components/ModHub/PaginationButtons/index.m.less"),
				Mn = s.n(Pn);
			var Rn = e => r.a.createElement("div", {
					className: Mn.a.container
				}, e.prevButtonEnabled && r.a.createElement(v.a, {
					to: e.prevTo,
					onClick: e.prevButtonOnClick
				}, r.a.createElement(In.a, {
					className: Object(d.a)(Mn.a.iconStyles, Mn.a.arrowLeft)
				})), e.nextButtonEnabled && r.a.createElement(v.a, {
					to: e.nextTo,
					onClick: e.nextButtonOnClick
				}, r.a.createElement(In.a, {
					className: Mn.a.iconStyles
				}))),
				Ln = s("./src/reddit/components/SaveIndicator/index.m.less"),
				Dn = s.n(Ln),
				An = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "3 4 14 14",
					xmlns: "http://www.w3.org/2000/svg"
				}, r.a.createElement("g", null, r.a.createElement("path", {
					d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
					fill: "inherit"
				}))),
				Fn = s("./src/reddit/icons/svgs/Clear/index.tsx"),
				Bn = s("./src/reddit/icons/svgs/Replay/index.tsx"),
				Un = s("./src/reddit/models/ApiRequestState/index.ts");
			const Hn = {
				[Un.a.Pending]: "Saving",
				[Un.a.Complete]: "Saved",
				[Un.a.Failed]: "Save error"
			};
			var Wn = e => r.a.createElement(r.a.Fragment, null, e.status === Un.a.Pending && r.a.createElement(Bn.a, {
					className: Object(d.a)(Dn.a.icon, Dn.a.pendingIcon)
				}), e.status === Un.a.Complete && r.a.createElement(An, {
					className: Object(d.a)(Dn.a.icon, Dn.a.savedIcon)
				}), e.status === Un.a.Failed && r.a.createElement(Fn.a, {
					className: Object(d.a)(Dn.a.icon, Dn.a.saveErrorIcon)
				}), r.a.createElement("span", {
					className: Dn.a.caption
				}, Object(G.c)(Hn[e.status]))),
				qn = s("./src/reddit/constants/colors.ts"),
				Vn = s("./src/reddit/helpers/flair.ts");
			const zn = e => ({
					subreddit: y.subreddit(e),
					profile: y.profile(e),
					userSubreddit: y.userSubreddit(e)
				}),
				Kn = e => t => Object.assign({
					source: "grant_user_flair",
					action: "click",
					noun: e
				}, zn(t)),
				Qn = () => Kn("search_username"),
				Gn = () => Kn("page_forward"),
				Jn = () => Kn("page_back"),
				Zn = () => Kn("remove_granted_user_flair"),
				Xn = (e, t) => s => Object.assign({
					source: "grant_user_flair",
					action: "autosave",
					noun: e,
					actionInfo: Object.assign({}, y.actionInfo(s), {
						settingValue: t
					})
				}, zn(s)),
				Yn = () => Xn("flair_text"),
				$n = e => Xn("flair_template", e || "none"),
				ea = e => Xn("css_class", e);
			var ta = s("./src/reddit/icons/svgs/Moderate/index.tsx"),
				sa = s("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				na = s("./src/reddit/icons/svgs/User/index.tsx");
			const aa = [];
			var oa = s("./src/reddit/selectors/meta.ts"),
				ra = s("./src/reddit/selectors/userFlair.ts"),
				ia = s("./src/reddit/icons/fonts/Tag/index.tsx"),
				ca = s("./src/reddit/components/GrantUserFlair/index.m.less"),
				da = s.n(ca);
			var la = () => r.a.createElement("div", {
					className: da.a.emptyList
				}, r.a.createElement(ia.a, {
					className: da.a.flairIcon
				}), r.a.createElement("div", {
					className: da.a.mainText
				}, Object(G.c)("You do not have any users with user flair")), r.a.createElement("div", null, Object(G.c)("Search for a user to assign a user flair"))),
				ma = s("./node_modules/lodash/filter.js"),
				ua = s.n(ma),
				pa = s("./node_modules/lodash/omit.js"),
				ba = s.n(pa),
				ha = s("./src/reddit/constants/flair.ts");
			s("./node_modules/core-js/modules/es6.regexp.split.js"), s("./node_modules/core-js/modules/es6.regexp.constructor.js");
			const ga = new RegExp("^[a-zA-Z0-9-]{1,".concat(ha.f, "}$"));
			var Ea = e => {
				if (!e) return;
				const t = e.split(" ").filter(Boolean);
				if (t.length > ha.c) return Object(G.c)("Too many class names");
				const s = t.find(e => !e.match(ga));
				return s ? s.length > ha.f ? Object(G.c)("Class name should not be longer than 100 characters") : Object(G.c)("Class name contains an invalid character") : void 0
			};
			const xa = 200;
			var fa;
			! function(e) {
				e[e.Save = 0] = "Save", e[e.Delete = 1] = "Delete"
			}(fa || (fa = {}));
			const va = e => null === e.flair,
				Ca = e => !(!e.apiError && !e.clientValidationError),
				Oa = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					const s = Date.now();
					return ua()(e, e => {
						if (!e || e.clientValidationError) return !1;
						if (e.apiError && !t) return !1;
						if (va(e)) return !0;
						return s - e.changedAt > 2e3 || t
					})
				},
				ja = (e, t, s) => {
					const n = Object.keys(e).filter(n => {
						const a = e[n],
							o = t[n] || null;
						return !(!!o || n === s || !Ca(a)) || !!_s()(o, a.flair)
					});
					return n.length ? ba()(e, n) : e
				},
				ya = (e, t) => {
					const s = t || ha.a;
					return (e ? Object(Vn.m)(e, s) || Ea(e.cssClass || "") : "") || void 0
				};
			var ka = s("./node_modules/lodash/noop.js"),
				wa = s.n(ka),
				Sa = s("./src/reddit/components/Flair/index.tsx"),
				Na = s("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				Ta = s("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				_a = s("./src/reddit/icons/svgs/Remove/index.tsx"),
				Ia = s("./src/reddit/constants/keycodes.ts"),
				Pa = s("./src/reddit/controls/Dropdown/index.tsx"),
				Ma = s("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				Ra = s("./src/reddit/selectors/tooltip.ts");
			const La = e => "UserFlairPicker--".concat(e),
				Da = Object(K.a)(Pa.a),
				Aa = e => {
					let {
						flair: t
					} = e;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(Sa.b, {
						flair: Object(Vn.c)(t),
						forceSmallEmojis: !0
					}), t.textEditable && r.a.createElement(na.a, {
						className: da.a.userIcon
					}), t.modOnly && r.a.createElement(ta.a, {
						className: da.a.modIcon
					}))
				},
				Fa = Object(c.c)({
					isDropdownOpen: (e, t) => Object(Ra.b)(La(t.userName))(e)
				});
			class Ba extends r.a.Component {
				constructor(e) {
					super(e), this.onSetFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.findNextFocusableItem = () => {
						if (void 0 === this.state.focusedIndex) return -1; {
							const e = this.state.focusedIndex + 1;
							if (e <= this.props.templateIds.length - 1) return e
						}
					}, this.onMouseEnter = e => {
						const t = document.getElementById("focus-".concat(e));
						t && (t.focus(), this.onSetFocus(e))
					}, this.findPreviousFocusableItem = () => {
						if (void 0 !== this.state.focusedIndex && -1 !== this.state.focusedIndex) return this.state.focusedIndex - 1
					}, this.onKeyDown = e => {
						if (e.keyCode === Ia.a.ArrowDown)
							if (e.preventDefault(), this.props.isDropdownOpen) {
								const e = this.findNextFocusableItem();
								if (void 0 !== e) {
									const t = document.getElementById("focus-".concat(e));
									t && (t.focus(), t.scrollIntoView({
										block: "nearest"
									})), this.onSetFocus(e)
								}
							} else this.props.onToggleDropdown();
						if (e.keyCode === Ia.a.ArrowUp) {
							e.preventDefault();
							const t = this.findPreviousFocusableItem();
							if (void 0 !== t) {
								const e = document.getElementById("focus-".concat(t));
								e && (e.focus(), e.scrollIntoView({
									block: "nearest"
								})), this.onSetFocus(t)
							}
						}
						if (e.keyCode === Ia.a.Tab && this.props.isDropdownOpen && e.preventDefault(), e.keyCode === Ia.a.Enter) {
							if (e.preventDefault(), e.stopPropagation(), this.props.isDropdownOpen && void 0 !== this.state.focusedIndex) {
								const e = this.props.templateIds[this.state.focusedIndex];
								this.props.onSelectFlairTemplate(e)
							}
							this.props.onToggleDropdown()
						}
					}, this.state = {}
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement("button", {
						className: da.a.dropdownTarget,
						id: La(e.userName),
						onClick: e.onToggleDropdown,
						onKeyDown: this.onKeyDown
					}, e.selectedTemplateId && e.userFlairTemplates[e.selectedTemplateId] ? r.a.createElement(Aa, {
						flair: e.userFlairTemplates[e.selectedTemplateId]
					}) : Object(G.c)("none"), r.a.createElement(Ma.a, {
						className: da.a.dropdownTriangle
					}), r.a.createElement(Da, {
						className: da.a.dropdownContainer,
						isOpen: e.isDropdownOpen,
						tooltipId: La(e.userName)
					}, r.a.createElement("button", {
						className: da.a.dropdownRow,
						id: "focus-".concat(-1),
						onClick: () => e.onSelectFlairTemplate(void 0),
						onMouseEnter: () => this.onMouseEnter(-1),
						tabIndex: -1
					}, Object(G.c)("none")), e.templateIds.map((t, s) => {
						const n = e.userFlairTemplates[t];
						return r.a.createElement("button", {
							className: da.a.dropdownRow,
							id: "focus-".concat(s),
							key: t,
							onClick: () => e.onSelectFlairTemplate(t),
							onMouseEnter: () => this.onMouseEnter(s),
							tabIndex: -1
						}, r.a.createElement(Aa, {
							flair: n
						}))
					})))
				}
			}
			var Ua = Object(i.b)(Fa, (e, t) => ({
				onToggleDropdown: () => e(Object(Yt.g)({
					tooltipId: La(t.userName)
				}))
			}))(Ba);
			const Ha = e => "emoji-picker-".concat(e),
				Wa = Object(Vn.b)();
			class qa extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.onSelectFlairTemplate = e => {
						const t = e && this.props.userFlairTemplates[e],
							s = t ? Object(Vn.c)(t) : Wa;
						this.props.onChange(this.props.username, s)
					}, this.onFlairContentChanged = e => {
						this.props.onChange(this.props.username, e)
					}, this.onChangeCssClass = e => {
						const t = e.target.value,
							s = this.props.flair || Wa;
						this.props.onChange(this.props.username, Object.assign({}, s, {
							cssClass: t
						}))
					}, this.removeFlair = () => {
						this.props.onChange(this.props.username, null)
					}
				}
				render() {
					const {
						props: e
					} = this, {
						hasError: t
					} = e, s = e.flair || Wa, n = Object(Na.a)(), a = s.templateId, o = a && e.userFlairTemplates[a] || ha.a, i = !!o && o.modOnly, c = !Ea(s.cssClass || "");
					return r.a.createElement("div", {
						className: Object(d.a)(da.a.row, t ? da.a.hasError : null)
					}, r.a.createElement("div", {
						className: da.a.errorIndicator
					}, r.a.createElement(Fn.a, null)), r.a.createElement(v.a, {
						className: da.a.userLink,
						to: "/user/".concat(e.username)
					}, r.a.createElement(Ta.a, {
						user: e.username,
						tooltipId: "grantuserflair--userhovercard--".concat(e.username),
						subredditId: e.subredditId,
						sendHoverCardEvent: wa.a
					}, e.username, r.a.createElement("div", {
						className: da.a.flairContainer
					}, r.a.createElement(Sa.b, {
						flair: s
					})))), r.a.createElement("div", {
						className: da.a.flairDetails
					}, r.a.createElement("div", {
						className: da.a.column
					}, r.a.createElement(Ua, {
						onSelectFlairTemplate: this.onSelectFlairTemplate,
						selectedTemplateId: a,
						templateIds: e.templateIds,
						userFlairTemplates: e.userFlairTemplates,
						userName: this.props.username
					})), r.a.createElement("div", {
						className: da.a.flairEditColumn
					}, r.a.createElement(n, {
						allowBlank: !e.isChanged,
						emojiPickerId: Ha(e.username),
						flair: s,
						flairTemplateType: nn.d.UserFlair,
						flairTemplate: o,
						helperTextClass: da.a.flairEditHelperText,
						isCompact: !0,
						isFlairModOnly: i,
						onChange: this.onFlairContentChanged,
						subredditId: e.subredditId
					})), r.a.createElement("div", {
						className: da.a.column
					}, r.a.createElement("input", {
						className: Object(d.a)(da.a.textInput, {
							[da.a.cssInputError]: !c
						}),
						value: s.cssClass || "",
						onChange: this.onChangeCssClass,
						disabled: !!o.id
					})), r.a.createElement("button", {
						className: da.a.removeButton,
						onClick: this.removeFlair
					}, r.a.createElement(_a.a, {
						className: da.a.removeIcon
					}))))
				}
			}
			var Va = qa;
			const za = {},
				Ka = Object(f.t)({
					currentPageUrl: f.e
				}),
				Qa = Object(c.c)({
					flairedUserOrder: (e, t) => {
						const s = Object(et.d)(t.subredditId, t.after, t.before);
						return e.flairedUsers.userOrder[s] || aa
					},
					flairedUsers: (e, t) => e.flairedUsers.models[t.subredditId],
					isFlairedUsersListPending: e => e.flairedUsers.api.pending,
					isSearchPending: e => e.flairedUsers.search.api.pending,
					isUserFlairEnabled: ra.a,
					origin: oa.g,
					pageInfo: (e, t) => {
						const s = Object(et.d)(t.subredditId, t.after, t.before);
						return e.flairedUsers.pageInfo[s]
					},
					searchResult: (e, t) => e.flairedUsers.search.result,
					userFlairData: ra.c
				});
			class Ga extends r.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.isUnmounted = !1, this.pendingRequestsMap = new Map, this.autoSaveIntervalId = 0, this.processChanges = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						t.autoSaveIntervalId || (t.autoSaveIntervalId = window.setInterval(t.processChanges, xa));
						const {
							flairedUsers: s
						} = t.props, {
							unsavedChanges: n,
							searchTerm: a
						} = t.state, o = ja(n, s, a), r = Oa(o, e);
						r.forEach(t.sendChangeToServer), o !== n && t.setState({
							unsavedChanges: o
						})
					}, this.sendChangeToServer = async e => {
						const t = e.username;
						if (this.pendingRequestsMap.get(t)) return;
						const s = this.props.flairedUsers[t] || null;
						this.sendTelemetryEvents(s, e.flair);
						const n = e.flair ? {
							type: fa.Save,
							promise: this.props.saveFlairedUser(t, e.flair)
						} : {
							type: fa.Delete,
							promise: this.props.deleteUserFlair(t, this.props.subredditId)
						};
						this.pendingRequestsMap.set(t, n);
						const a = await n.promise;
						this.pendingRequestsMap.delete(t), this.isUnmounted || this.setState(s => {
							const n = s.unsavedChanges[t];
							return e !== n ? null : {
								unsavedChanges: !0 === a ? Object(yn.a)(s.unsavedChanges, t) : Object.assign({}, this.state.unsavedChanges, {
									[t]: Object.assign({}, e, {
										apiError: a
									})
								})
							}
						})
					}, this.onFlairChanged = (e, t) => {
						const {
							templates: s
						} = this.props.userFlairData, n = t && t.templateId ? s[t.templateId] : void 0;
						this.setState(s => {
							return {
								unsavedChanges: Object.assign({}, s.unsavedChanges, {
									[e]: {
										flair: t,
										username: e,
										changedAt: Date.now(),
										clientValidationError: ya(t, n)
									}
								})
							}
						})
					}, this.onSearch = e => {
						this.props.searchFlairedUser(e), this.setState({
							searchTerm: e
						}), this.props.sendEvent(Qn())
					}, this.onCancelSearch = () => {
						this.setState({
							searchTerm: null
						})
					}, this.onClickNextPage = () => this.props.sendEvent(Gn()), this.onClickPrevPage = () => this.props.sendEvent(Jn()), this.renderUserRow = e => {
						const {
							state: t,
							props: s
						} = this, n = s.flairedUsers[e] || null, a = t.unsavedChanges[e], o = a && !va(a) ? a.flair : n;
						return r.a.createElement(Va, {
							flair: o,
							hasError: !!a && Ca(a),
							isChanged: !!a,
							key: e,
							onChange: this.onFlairChanged,
							subredditId: s.subredditId,
							templateIds: s.userFlairData.templateIds,
							userFlairTemplates: s.userFlairData.templates,
							username: e
						})
					}, this.state = {
						searchTerm: null,
						unsavedChanges: za
					}
				}
				componentDidUpdate() {
					this.processChanges()
				}
				componentWillUnmount() {
					this.isUnmounted = !0, this.processChanges(!0), window.clearInterval(this.autoSaveIntervalId)
				}
				sendTelemetryEvents(e, t) {
					if (!t) return void this.props.sendEvent(Zn());
					let s = e || Object(Vn.b)();
					const n = s.templateId || void 0,
						a = t.templateId || void 0;
					if (a !== n) {
						this.props.sendEvent($n(a));
						const e = t.templateId && this.props.userFlairData.templates[t.templateId];
						s = e ? Object(Vn.c)(e) : s
					}
					Object(Vn.o)(t, s) || this.props.sendEvent(Yn()), t.cssClass !== s.cssClass && this.props.sendEvent(ea(t.cssClass || ""))
				}
				getIndicatorStatus() {
					const {
						unsavedChanges: e
					} = this.state;
					if (e === za) return null;
					const t = !!yt()(e, e => Ca(e));
					return !!yt()(e, e => !Ca(e)) ? Un.a.Pending : t ? Un.a.Failed : Un.a.Complete
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = this.getIndicatorStatus(), n = e.pageInfo && (e.pageInfo.hasNextPage || e.pageInfo.hasPreviousPage), a = !e.flairedUserOrder.length && !n;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, {
						className: da.a.topBar
					}, null !== s && r.a.createElement(Wn, {
						status: s
					})), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Grant user flair"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360028091332")
					})), !e.isUserFlairEnabled && r.a.createElement(Tn.a, {
						className: da.a.disabledBanner,
						color: qn.a.quarantine,
						icon: r.a.createElement(sa.a, {
							className: da.a.warningIcon
						}),
						title: Object(G.c)("User flair has been disabled for this community"),
						subtitle: Object(G.c)("User flair will not be displayed in posts or comments")
					}), r.a.createElement(we, {
						activeSearchQuery: t.searchTerm,
						onSearch: this.onSearch
					}, e.pageInfo && !t.searchTerm && r.a.createElement(Rn, {
						prevTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
							before: e.pageInfo.startCursor
						}),
						prevButtonEnabled: e.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: e.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
							after: e.pageInfo.endCursor
						})
					})), r.a.createElement("div", {
						className: da.a.titleRow
					}, Object(G.c)("Username with preview"), r.a.createElement("div", {
						className: da.a.flairDetails
					}, r.a.createElement("div", {
						className: da.a.column
					}, Object(G.c)("Flair template"), r.a.createElement(_n.a, {
						className: da.a.infoTooltip
					}, r.a.createElement("div", {
						className: da.a.tooltipText
					}, Object(G.c)("Flair templates determine the flair's background colors, text colors, and permissions")), r.a.createElement("div", {
						className: da.a.tooltipIconContainer
					}, r.a.createElement("div", {
						className: da.a.tooltipIconRow
					}, r.a.createElement(ta.a, {
						className: da.a.modIcon
					}), r.a.createElement("span", {
						className: da.a.tooltipIconText
					}, Object(G.c)("Available only to mods"))), r.a.createElement("div", {
						className: da.a.tooltipIconRow
					}, r.a.createElement(na.a, {
						className: da.a.userIcon
					}), r.a.createElement("span", {
						className: da.a.tooltipIconText
					}, Object(G.c)("User editable")))))), r.a.createElement("div", {
						className: da.a.flairEditColumn
					}, Object(G.c)("Flair text"), r.a.createElement(_n.a, {
						text: Object(G.c)("Changes the text and emojis within the user flair")
					})), r.a.createElement("div", {
						className: da.a.column
					}, Object(G.c)("Css class"), r.a.createElement(_n.a, {
						text: Object(G.c)("CSS classes determine styling for flair in old Reddit")
					})))), t.searchTerm ? r.a.createElement(Oe, {
						cancelSearch: this.onCancelSearch,
						noResultsFound: !e.searchResult,
						searchTerm: t.searchTerm,
						searchPending: e.isSearchPending
					}, e.searchResult && this.renderUserRow(e.searchResult)) : e.isFlairedUsersListPending ? r.a.createElement(Ze, null) : a ? r.a.createElement(la, null) : e.flairedUserOrder.map(this.renderUserRow), e.pageInfo && !t.searchTerm && r.a.createElement("div", {
						className: da.a.bottomBarRow
					}, r.a.createElement(Rn, {
						prevTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
							before: e.pageInfo.startCursor
						}),
						prevButtonEnabled: e.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: e.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
							after: e.pageInfo.endCursor
						})
					}))))
				}
			}
			var Ja = Ka(Object(i.b)(Qa, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						deleteUserFlair: (t, s) => e(Object(Nn.a)(t, s)),
						saveFlairedUser: (t, n) => e(Object(Nn.c)(t, s, n)),
						searchFlairedUser: t => e(Object(Nn.d)(s, t))
					}
				})(Object(x.b)(Ga))),
				Za = s("./src/lib/makeActionCreator/index.ts"),
				Xa = s("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				Ya = s("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				$a = s("./src/reddit/actions/moderationLog/constants.ts");
			const eo = Object(Za.a)($a.a);
			var to = s("./node_modules/react-router-redux/es/index.js");
			s("./node_modules/core-js/modules/es6.regexp.to-string.js");
			const so = ["Anti-Evil Operations", "Reddit Legal"];
			var no;
			! function(e) {
				e.ACTION = "action", e.MODERATOR = "moderator"
			}(no || (no = {}));
			const ao = {
					ALL_ACTIONS: () => p.fbt._("All actions", null, {
						hk: "3sHzD4"
					}),
					ACCEPT_MODERATOR_INVITE: () => p.fbt._("Accept moderator invite", null, {
						hk: "3WJot2"
					}),
					ADD_COMMUNITY_TOPICS: () => p.fbt._("Add community topics", null, {
						hk: "4xgglk"
					}),
					ADD_CONTRIBUTOR: () => p.fbt._("Add contributor", null, {
						hk: "444ZK"
					}),
					ADD_MODERATOR: () => p.fbt._("Add moderator", null, {
						hk: "4rRghF"
					}),
					APPROVE_COMMENT: () => p.fbt._("Approve comment", null, {
						hk: "1gvHWC"
					}),
					APPROVE_LINK: () => p.fbt._("Approve link", null, {
						hk: "2LqFt4"
					}),
					BAN_USER: () => p.fbt._("Ban user", null, {
						hk: "4DmPqi"
					}),
					COLLECTIONS: () => p.fbt._("Collections", null, {
						hk: "3a39Wa"
					}),
					COMMUNITY_STYLING: () => p.fbt._("Community styling", null, {
						hk: "386ps9"
					}),
					COMMUNITY_WIDGETS: () => p.fbt._("Community widgets", null, {
						hk: "4ml45n"
					}),
					CREATE_AWARD: () => p.fbt._("Create award", null, {
						hk: "bWa9w"
					}),
					CREATE_RULE: () => p.fbt._("Create rule", null, {
						hk: "28uE69"
					}),
					CREATE_SCHEDULED_POST: () => p.fbt._("Create scheduled post", null, {
						hk: "mVbI1"
					}),
					DELETE_AWARD: () => p.fbt._("Delete award", null, {
						hk: "3xYaZ7"
					}),
					DELETE_RULE: () => p.fbt._("Delete rule", null, {
						hk: "2lWdRL"
					}),
					DELETE_SCHEDULED_POST: () => p.fbt._("Delete scheduled post", null, {
						hk: "MhwRy"
					}),
					DISABLE_AWARD: () => p.fbt._("Disable award", null, {
						hk: "2yFBt7"
					}),
					DISTINGUISH: () => p.fbt._("Distinguish", null, {
						hk: "3cWniK"
					}),
					EDIT_FLAIR: () => p.fbt._("Edit flair", null, {
						hk: "mD0CV"
					}),
					EDIT_RULE: () => p.fbt._("Edit rule", null, {
						hk: "2T4TJx"
					}),
					EDIT_SCHEDULED_POST: () => p.fbt._("Edit scheduled post", null, {
						hk: "1XCmsI"
					}),
					EDIT_SETTINGS: () => p.fbt._("Edit settings", null, {
						hk: "3o8q46"
					}),
					EVENTS: () => p.fbt._("Events", null, {
						hk: "4Bq9wt"
					}),
					IGNORE_REPORTS: () => p.fbt._("Ignore reports", null, {
						hk: "1defIy"
					}),
					INVITE_MODERATOR: () => p.fbt._("Invite moderator", null, {
						hk: "1DbgL5"
					}),
					LOCK: () => p.fbt._("Lock", null, {
						hk: "39hTi5"
					}),
					MARK_NSFW: () => p.fbt._("Mark nsfw", null, {
						hk: "3bo45o"
					}),
					MARK_ORIGINAL_CONTENT: () => p.fbt._("Mark original content", null, {
						hk: "SadHO"
					}),
					MOD_AWARD_GIVEN: () => p.fbt._("Mod award given by moderators", null, {
						hk: "35cQgR"
					}),
					MODMAIL_ENROLLMENT: () => p.fbt._("Modmail enrollment", null, {
						hk: "4ee1XK"
					}),
					MUTE_USER: () => p.fbt._("Mute user", null, {
						hk: "3kPYe4"
					}),
					REMOVE_COMMENT: () => p.fbt._("Remove comment", null, {
						hk: "vEI4S"
					}),
					REMOVE_COMMUNITY_TOPICS: () => p.fbt._("Remove community topics", null, {
						hk: "1tLjxQ"
					}),
					REMOVE_CONTRIBUTOR: () => p.fbt._("Remove contributor", null, {
						hk: "4FMLz6"
					}),
					REMOVE_LINK: () => p.fbt._("Remove link", null, {
						hk: "tmjch"
					}),
					REMOVE_MODERATOR: () => p.fbt._("Remove moderator", null, {
						hk: "1FHVTB"
					}),
					REMOVE_WIKI_CONTRIBUTOR: () => p.fbt._("Remove wiki contributor", null, {
						hk: "1PcCja"
					}),
					REORDER_RULES: () => p.fbt._("Reorder rules", null, {
						hk: "306Bqx"
					}),
					SET_CONTEST_MODE: () => p.fbt._("Set contest mode", null, {
						hk: "1pERnU"
					}),
					SET_PERMISSIONS: () => p.fbt._("Set permissions", null, {
						hk: "3UzkKU"
					}),
					SET_SUGGESTEDSORT: () => p.fbt._("Set suggested sort", null, {
						hk: "208T6K"
					}),
					SHOW_COMMENT: () => p.fbt._("Show comment", null, {
						hk: "n5M3i"
					}),
					SPAM_COMMENT: () => p.fbt._("Spam comment", null, {
						hk: "2ROyTD"
					}),
					SPAM_LINK: () => p.fbt._("Spam link", null, {
						hk: "2G5xg3"
					}),
					SPOILER: () => p.fbt._("Spoiler", null, {
						hk: "2nfv1a"
					}),
					STICKY: () => p.fbt._("Sticky", null, {
						hk: "1W6JrJ"
					}),
					SUBMIT_SCHEDULED_POST: () => p.fbt._("Submit scheduled post", null, {
						hk: "1i2VUH"
					}),
					UNBAN_USER: () => p.fbt._("Unban user", null, {
						hk: "4m2iNP"
					}),
					UNIGNORE_REPORTS: () => p.fbt._("Unignore reports", null, {
						hk: "1wfp99"
					}),
					UNINVITE_MODERATOR: () => p.fbt._("Uninvite moderator", null, {
						hk: "3E6UkD"
					}),
					UNLOCK: () => p.fbt._("Unlock", null, {
						hk: "2BHnOC"
					}),
					UNMUTE_USER: () => p.fbt._("Unmute user", null, {
						hk: "25tct2"
					}),
					UNSET_CONTEST_MODE: () => p.fbt._("Unset contest mode", null, {
						hk: "AxsDk"
					}),
					UNSPOILER: () => p.fbt._("Unspoiler", null, {
						hk: "2gE1K1"
					}),
					UNSTICKY: () => p.fbt._("Unsticky", null, {
						hk: "U5tvd"
					}),
					WIKI_BANNED: () => p.fbt._("Wiki banned", null, {
						hk: "1nk4H7"
					}),
					WIKI_CONTRIBUTOR: () => p.fbt._("Wiki contributor", null, {
						hk: "1W6zn3"
					}),
					WIKI_PAGE_LISTED: () => p.fbt._("Wiki page listed", null, {
						hk: "4aghdO"
					}),
					WIKI_PERM_LEVEL: () => p.fbt._("Wiki perm level", null, {
						hk: "4waHE"
					}),
					WIKI_REVISE: () => p.fbt._("Wiki revise", null, {
						hk: "3FZuIJ"
					}),
					WIKI_UNBANNED: () => p.fbt._("Wiki unbanned", null, {
						hk: "1fAtKd"
					})
				},
				oo = {
					added_event_times: "moderationLog.actions.details.addedEventTimes",
					added_flair_styling: "moderationLog.actions.details.addedFlairStyling",
					added_styling: "moderationLog.actions.details.addedStyling",
					added_to_collection: "moderationLog.actions.details.addedToCollection",
					added_widget: "moderationLog.actions.details.addedWidget",
					allow_discovery: "moderationLog.actions.details.allowDiscovery",
					allow_top: "moderationLog.actions.details.allowTop",
					collapse_deleted_comments: "moderationLog.actions.details.collapseDeletedComments",
					comment_score_hide_mins: "moderationLog.actions.details.commentScoreHideMins",
					confirm_ham: "moderationLog.actions.details.approved",
					confirm_spam: "moderationLog.actions.details.confirmSpam",
					created_collection: "moderationLog.actions.details.createdCollection",
					css_on_cname: "moderationLog.actions.details.cssOnCname",
					del_banner: "moderationLog.actions.details.deleteBanner",
					del_header: "moderationLog.actions.details.deleteHeader",
					del_icon: "moderationLog.actions.details.deleteIcon",
					del_image: "moderationLog.actions.details.deleteImage",
					deleted_collection: "moderationLog.actions.details.deletedCollection",
					description: "moderationLog.actions.details.description",
					domain: "moderationLog.actions.details.domain",
					edited_collection_description: "moderationLog.actions.details.editedCollectionDescription",
					edited_collection_display_layout: "moderationLog.actions.details.editedCollectionDisplayLayout",
					edited_collection_title: "moderationLog.actions.details.editedCollectionTitle",
					edited_event_body: "moderationLog.actions.details.editedEventBody",
					edited_event_times: "moderationLog.actions.details.editedEventTimes",
					edited_event_title: "moderationLog.actions.details.editedEventTitle",
					edited_widget: "moderationLog.actions.details.editedWidget",
					exclude_banned_modqueue: "moderationLog.actions.details.excludeBannedModqueue",
					flair_clear_template: "moderationLog.actions.details.flairClearTemplate",
					flair_csv: "moderationLog.actions.details.flairCsv",
					flair_delete_template: "moderationLog.actions.details.flairDeleteTemplate",
					flair_add: "moderationLog.actions.details.flairAdd",
					flair_delete: "moderationLog.actions.details.flairDelete",
					flair_edit: "moderationLog.actions.details.flairEdit",
					flair_enabled: "moderationLog.actions.details.flairEnabled",
					flair_position: "moderationLog.actions.details.flairPosition",
					flair_self_enabled: "moderationLog.actions.details.flairSelfEnabled",
					flair_template: "moderationLog.actions.details.flairTemplate",
					free_form_reports: "moderationLog.actions.details.freeFormReports",
					header_title: "moderationLog.actions.details.headerTitle",
					ignore_reports: "moderationLog.actions.details.ignoreReports",
					lang: "moderationLog.actions.details.lang",
					link_flair_position: "moderationLog.actions.details.linkFlairPosition",
					link_flair_self_enabled: "moderationLog.actions.details.linkFlairSelfEnabled",
					link_type: "moderationLog.actions.details.linkType",
					over_18: "moderationLog.actions.details.over18",
					permanent: "moderationLog.actions.details.permanentBan",
					permission_moderator_invite: "moderationLog.actions.details.permissionModeratorInvite",
					permission_moderator: "moderationLog.actions.details.permissionModerator",
					public_description: "moderationLog.actions.details.publicDescription",
					public_traffic: "moderationLog.actions.details.publicTraffic",
					remove_self: "moderationLog.actions.details.removeSelf",
					remove: "moderationLog.actions.details.remove",
					removed_from_collection: "moderationLog.actions.details.removedFromCollection",
					removed_styling: "moderationLog.actions.details.removedStyling",
					removed_widget: "moderationLog.actions.details.removedWidget",
					show_cname_sidebar: "moderationLog.actions.details.showCnameSidebar",
					show_media: "moderationLog.actions.details.showMedia",
					spam: "moderationLog.actions.details.spam",
					stylesheet: "moderationLog.actions.details.stylesheet",
					submit_link_label: "moderationLog.actions.details.submitLinkLabel",
					submit_text_label: "moderationLog.actions.details.submitTextLabel",
					title: "moderationLog.actions.details.title",
					type: "moderationLog.actions.details.type",
					unspam: "moderationLog.actions.details.unspam",
					upload_image_banner: "moderationLog.actions.details.uploadImageBanner",
					upload_image_header: "moderationLog.actions.details.uploadImageHeader",
					upload_image_icon: "moderationLog.actions.details.uploadImageIcon",
					upload_image: "moderationLog.actions.details.uploadImage",
					copyright_removal: "moderationLog.actions.details.copyrightRemoval",
					copyright_restoration: "moderationLog.actions.details.copyrightRestoration"
				};
			var ro, io;
			! function(e) {
				e.AWARD = "Award", e.COMMENT = "Comment", e.FLAIR = "Flair", e.MULTIPLE = "Multiple", e.POST = "Post", e.REDDITOR = "Redditor", e.SETTINGS = "Settings", e.WIKI = "Wiki", e.COLLECTION = "Collection", e.EVENT = "Event"
			}(ro || (ro = {})),
			function(e) {
				e.NONE = "none", e.POSITIVE = "positive", e.NEGATIVE = "negative"
			}(io || (io = {}));
			const co = e => {
					const t = e.action && "ALL_ACTIONS" !== e.action ? e.action : null,
						s = e.moderator || null,
						n = e.endCursor || null,
						a = e.startCursor || null;
					return Object(jn.a)(Sn(e.currentPageUrl), {
						action: t,
						moderator: s,
						after: n,
						before: a
					})
				},
				lo = e => ({
					subreddit: y.subreddit(e),
					userSubreddit: y.userSubreddit(e)
				}),
				mo = () => e => Object.assign({
					source: "mod_log",
					action: "click",
					noun: "mod_filter_dropdown"
				}, lo(e)),
				uo = () => e => Object.assign({
					source: "mod_filter_dropdown",
					action: "click",
					noun: "moderator"
				}, lo(e)),
				po = () => e => Object.assign({
					source: "mod_log",
					action: "click",
					noun: "mod_action_dropdown"
				}, lo(e)),
				bo = e => t => Object.assign({
					source: "mod_action_dropdown",
					action: "click",
					noun: e.toLowerCase()
				}, lo(t));
			var ho = s("./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less"),
				go = s.n(ho);
			class Eo extends r.a.Component {
				constructor(e) {
					super(e), this.buildModLogUrlForAction = e => {
						const {
							currentPageUrl: t,
							moderator: s
						} = this.props;
						return co({
							currentPageUrl: t,
							moderator: s,
							action: e
						})
					}, this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							s = this.getFilteredActions(t);
						this.setState({
							currentInputText: t,
							filteredActions: s
						})
					}, this.onKeyDown = e => {
						if (e.which === Ia.a.Enter) {
							const {
								filteredActions: t
							} = this.state, s = t.length ? this.buildModLogUrlForAction(t[0]) : null;
							s && (this.props.onChangeUrl(s), e.preventDefault())
						}
					}, this.onActionClick = e => {
						this.props.sendEvent(bo(e))
					}, this.state = {
						currentInputText: "",
						filteredActions: this.getFilteredActions("")
					}
				}
				getFilteredActions(e) {
					let t = Object.keys(ao);
					if (e) {
						const s = e.toLowerCase();
						t = t.filter(e => ao[e]().toString().toLowerCase().includes(s))
					}
					return t
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredActions: t
					} = this.state;
					return r.a.createElement("div", {
						role: "menu",
						className: e
					}, r.a.createElement("input", {
						"aria-label": Object(G.c)("Filter"),
						className: go.a.filter,
						placeholder: Object(G.c)("Filter"),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map(e => r.a.createElement(v.a, {
						className: go.a.dropdownRow,
						onClick: () => this.onActionClick(e),
						to: this.buildModLogUrlForAction(e)
					}, ao[e]())))
				}
			}
			var xo = Eo,
				fo = s("./src/lib/objectSelector/index.ts"),
				vo = s("./src/reddit/models/SubredditModeration/ModerationLog/index.ts");
			const Co = Object(fo.a)((e, t) => {
					let {
						subredditId: s
					} = t, n = [];
					const a = Oo(e),
						o = jo(e);
					if (a && o) {
						const t = Object(vo.a)(s, a, o),
							r = e.moderationLog.actions.itemOrder[s] && e.moderationLog.actions.itemOrder[s][t];
						r && (n = r.map(t => e.moderationLog.actions.models[s][t]))
					}
					return n
				}),
				Oo = e => e.moderationLog.endCursor,
				jo = e => e.moderationLog.startCursor,
				yo = e => {
					let {
						name: t,
						urlPath: s
					} = e;
					return r.a.createElement(v.a, {
						className: go.a.dropdownRow,
						to: s
					}, t)
				},
				ko = "a",
				wo = "AutoModerator",
				So = Object(c.c)({
					allModerators: (e, t) => {
						let {
							subredditId: s
						} = t;
						return ((e, t) => e.moderationLog.moderators[t] || [])(e, s)
					},
					language: L.S
				});
			class No extends r.a.Component {
				constructor(e) {
					super(e), this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							s = this.getList(t);
						this.setState({
							currentInputText: t,
							filteredList: s
						})
					}, this.onKeyDown = e => {
						if (e.which === Ia.a.Enter) {
							const {
								filteredList: t
							} = this.state, s = t.length ? t[0].url : "";
							s && (this.props.onChangeUrl(s), e.preventDefault())
						}
					}, this.onDropdownClick = e => {
						e.target instanceof HTMLAnchorElement && this.props.sendEvent(uo())
					}, this.state = {
						currentInputText: "",
						filteredList: this.getList("")
					}
				}
				getList(e) {
					const {
						action: t,
						currentPageUrl: s
					} = this.props, n = e => co({
						currentPageUrl: s,
						action: t,
						moderator: e
					}), a = [{
						url: n(""),
						displayText: Object(G.c)("All Moderators")
					}, {
						url: n(ko),
						displayText: Object(G.c)("Admins")
					}, {
						url: n(wo),
						displayText: Object(G.c)("AutoModerator")
					}, ...this.props.allModerators.map(e => ({
						url: n(e.name),
						displayText: e.name
					}))];
					if (e) {
						const t = e.toLowerCase();
						return a.filter(e => e.displayText.toLowerCase().includes(t))
					}
					return a
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredList: t
					} = this.state;
					return r.a.createElement("div", {
						role: "menu",
						className: e,
						onClick: this.onDropdownClick
					}, r.a.createElement("input", {
						"aria-label": Object(G.c)("Filter"),
						className: go.a.filter,
						placeholder: Object(G.c)("Filter"),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map((e, t) => r.a.createElement(yo, {
						key: t,
						name: e.displayText,
						urlPath: e.url
					})))
				}
			}
			var To = Object(i.b)(So)(No);
			const _o = "mod-log-action-filter-dropdown",
				Io = "mod-log-moderator-filter-dropdown",
				Po = Object(K.a)(Pa.a),
				Mo = Object(c.c)({
					isActionFilterDropdownOpen: Object(Ra.b)(_o),
					isModeratorFilterDropdownOpen: Object(Ra.b)(Io)
				});
			class Ro extends r.a.Component {
				constructor() {
					super(...arguments), this.getContainerText = e => {
						const {
							action: t,
							moderator: s
						} = this.props;
						if (e === no.MODERATOR) {
							let e = s;
							return s === ko && (e = p.fbt._("Admins", null, {
								hk: "1qJDMA"
							})), e || p.fbt._("All Moderators", null, {
								hk: "18DhaK"
							})
						}
						if (e === no.ACTION) {
							return t && ao[t] && ao[t]() || p.fbt._("Actions", null, {
								hk: "1s4OJD"
							})
						}
					}, this.openModFilterDropdown = () => {
						this.props.onOpenDropdown(Io), this.props.sendEvent(mo())
					}, this.openActionFilterDropdown = () => {
						this.props.onOpenDropdown(_o), this.props.sendEvent(po())
					}
				}
				stopPropagation(e) {
					e.nativeEvent.stopImmediatePropagation()
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						isActionFilterDropdownOpen: s,
						isModeratorFilterDropdownOpen: n,
						moderator: a,
						subredditId: o
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement("div", {
						className: go.a.container,
						onClickCapture: this.stopPropagation
					}, r.a.createElement("button", {
						"aria-expanded": n,
						"aria-label": p.fbt._("Start typing to filter moderators or use up and down to select.", null, {
							hk: "4ff0MW"
						}),
						className: go.a.selector,
						id: Io,
						onClick: this.openModFilterDropdown,
						role: "navigation"
					}, r.a.createElement("span", {
						className: go.a.containerText
					}, this.getContainerText(no.MODERATOR)), r.a.createElement(Ma.a, null)), r.a.createElement(Po, {
						tooltipId: Io,
						isOpen: n
					}, r.a.createElement(To, {
						action: e,
						className: go.a.listContainer,
						currentPageUrl: t,
						moderator: a,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent,
						subredditId: o
					}))), r.a.createElement("div", {
						className: go.a.container,
						onClickCapture: this.stopPropagation
					}, r.a.createElement("button", {
						"aria-expanded": s,
						"aria-label": p.fbt._("Start typing to filter the mod actions or use up and down to select.", null, {
							hk: "32A4KB"
						}),
						className: go.a.selector,
						id: _o,
						onClick: this.openActionFilterDropdown,
						role: "navigation"
					}, r.a.createElement("span", {
						className: go.a.containerText
					}, this.getContainerText(no.ACTION)), r.a.createElement(Ma.a, null)), r.a.createElement(Po, {
						tooltipId: _o,
						isOpen: s
					}, r.a.createElement(xo, {
						action: e,
						className: go.a.listContainer,
						currentPageUrl: t,
						moderator: a,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent
					}))))
				}
			}
			var Lo = Object(i.b)(Mo, e => ({
					onOpenDropdown: t => e(Object(Yt.g)({
						tooltipId: t
					})),
					pushUrl: t => e(Object(to.b)(t))
				}))(Object(x.b)(Ro)),
				Do = s("./src/reddit/components/AuthorLink/index.tsx"),
				Ao = s("./src/reddit/models/User/index.ts");
			var Fo = s("./src/reddit/icons/fonts/Comment/index.tsx"),
				Bo = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M14 0H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 2h12c.77 0 1.468.301 2 .78V2a2 2 0 0 0-2-2zm0 3H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 5h12c.77 0 1.468.301 2 .78V5a2 2 0 0 0-2-2zM2 6h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2z"
				}))),
				Uo = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M4 16h12V9H4v7zM17 4h-2V3a1 1 0 0 0-2 0v1H7V3a1 1 0 0 0-2 0v1H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"
				}))),
				Ho = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M15.5,7.75 L12.5,7.75 C12.224,7.75 12,7.526 12,7.25 C12,6.974 12.224,6.75 12.5,6.75 L15.5,6.75 C15.776,6.75 16,6.974 16,7.25 C16,7.526 15.776,7.75 15.5,7.75 Z M15.5,10.5 L12.5,10.5 C12.224,10.5 12,10.276 12,10 C12,9.724 12.224,9.5 12.5,9.5 L15.5,9.5 C15.776,9.5 16,9.724 16,10 C16,10.276 15.776,10.5 15.5,10.5 Z M15.5,13.25 L4.5,13.25 C4.224,13.25 4,13.026 4,12.75 C4,12.474 4.224,12.25 4.5,12.25 L15.5,12.25 C15.776,12.25 16,12.474 16,12.75 C16,13.026 15.776,13.25 15.5,13.25 Z M4.5,16 C4.224,16 4,15.776 4,15.5 C4,15.224 4.224,15 4.5,15 L15.5,15 C15.776,15 16,15.224 16,15.5 C16,15.776 15.776,16 15.5,16 L4.5,16 Z M4,4.5 C4,4.224 4.224,4 4.5,4 L9.813,4 C10.089,4 10.313,4.224 10.313,4.5 L10.313,10 C10.313,10.276 10.089,10.5 9.813,10.5 L4.5,10.5 C4.224,10.5 4,10.276 4,10 L4,4.5 Z M3,2 C2.447,2 2,2.447 2,3 L2,17 C2,17.553 2.447,18 3,18 L17,18 C17.553,18 18,17.553 18,17 L18,3 C18,2.447 17.553,2 17,2 L3,2 Z"
				}))),
				Wo = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 10 10"
				}, r.a.createElement("path", {
					d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M6.2103,5.78636 C6.3275,5.90356 6.3275,6.09356 6.2103,6.21076 C6.1519,6.26916 6.0751,6.29836 5.9983,6.29836 C5.9211,6.29836 5.8447,6.26916 5.7859,6.21076 L4.9983,5.42276 L4.2103,6.21076 C4.1519,6.26916 4.0751,6.29836 3.9983,6.29836 C3.9211,6.29836 3.8447,6.26916 3.7859,6.21076 C3.6687,6.09356 3.6687,5.90356 3.7859,5.78636 L4.5739,4.99836 L3.7859,4.21076 C3.6687,4.09356 3.6687,3.90356 3.7859,3.78636 C3.9031,3.66916 4.0931,3.66916 4.2103,3.78636 L4.9983,4.57436 L5.7859,3.78636 C5.9031,3.66916 6.0931,3.66916 6.2103,3.78636 C6.3275,3.90356 6.3275,4.09356 6.2103,4.21076 L5.4223,4.99836 L6.2103,5.78636 Z M7.4023,2.59436 C6.0767,1.26836 3.9195,1.26916 2.5939,2.59436 C1.2687,3.91996 1.2687,6.07716 2.5939,7.40276 C3.2567,8.06556 4.1275,8.39676 4.9983,8.39676 C5.8687,8.39676 6.7395,8.06556 7.4023,7.40276 C8.7279,6.07716 8.7279,3.91996 7.4023,2.59436 Z"
				})),
				qo = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 10 10"
				}, r.a.createElement("path", {
					d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M8.0828,3.27736 L7.5232,2.71736 C7.448,2.64216 7.3464,2.60016 7.2404,2.60016 C7.134,2.60016 7.0324,2.64216 6.9576,2.71736 L4.16,5.51456 L3.0428,4.39736 C2.8868,4.24096 2.6336,4.24096 2.4772,4.39736 L1.9172,4.95736 C1.7608,5.11376 1.7608,5.36696 1.9172,5.52296 L3.8772,7.48296 C3.9556,7.56096 4.0576,7.60016 4.16,7.60016 C4.2624,7.60016 4.3648,7.56096 4.4428,7.48296 L8.0828,3.84296 C8.2392,3.68656 8.2392,3.43376 8.0828,3.27736 Z"
				})),
				Vo = s("./src/reddit/icons/svgs/Redditor/index.tsx"),
				zo = s("./src/reddit/icons/svgs/Settings/index.tsx"),
				Ko = s("./src/reddit/icons/svgs/Tag/index.tsx"),
				Qo = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit",
					fillRule: "evenodd"
				}, r.a.createElement("path", {
					d: "M13.8711,6 L5.8711,6 C5.5951,6 5.3711,5.776 5.3711,5.5 C5.3711,5.224 5.5951,5 5.8711,5 L13.8711,5 C14.1471,5 14.3711,5.224 14.3711,5.5 C14.3711,5.776 14.1471,6 13.8711,6 M13.8711,9 L5.8711,9 C5.5951,9 5.3711,8.776 5.3711,8.5 C5.3711,8.224 5.5951,8 5.8711,8 L13.8711,8 C14.1471,8 14.3711,8.224 14.3711,8.5 C14.3711,8.776 14.1471,9 13.8711,9 M13.8711,12 L5.8711,12 C5.5951,12 5.3711,11.776 5.3711,11.5 C5.3711,11.224 5.5951,11 5.8711,11 L13.8711,11 C14.1471,11 14.3711,11.224 14.3711,11.5 C14.3711,11.776 14.1471,12 13.8711,12 M13.8711,15 L5.8711,15 C5.5951,15 5.3711,14.776 5.3711,14.5 C5.3711,14.224 5.5951,14 5.8711,14 L13.8711,14 C14.1471,14 14.3711,14.224 14.3711,14.5 C14.3711,14.776 14.1471,15 13.8711,15 M16.0001,2 L4.0001,2 C3.4471,2 3.0001,2.448 3.0001,3 L3.0001,17 C3.0001,17.552 3.4471,18 4.0001,18 L16.0001,18 C16.5531,18 17.0001,17.552 17.0001,17 L17.0001,3 C17.0001,2.448 16.5531,2 16.0001,2"
				}))),
				Go = s("./src/reddit/models/Comment/index.ts"),
				Jo = s("./src/reddit/models/Post/index.ts"),
				Zo = s("./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less"),
				Xo = s.n(Zo);
			const Yo = e => {
					let {
						action: t,
						urlPath: s
					} = e;
					const n = (e => {
							switch (e) {
								case "ALL_ACTIONS":
									return;
								case "ADD_CONTRIBUTOR":
								case "ADD_MODERATOR":
									return {
										type: ro.REDDITOR, treatment: io.POSITIVE
									};
								case "BAN_USER":
								case "MUTE_USER":
								case "REMOVE_CONTRIBUTOR":
								case "REMOVE_MODERATOR":
									return {
										type: ro.REDDITOR, treatment: io.NEGATIVE
									};
								case "CREATE_AWARD":
								case "MOD_AWARD_GIVEN":
									return {
										type: ro.AWARD, treatment: io.POSITIVE
									};
								case "DELETE_AWARD":
								case "DISABLE_AWARD":
									return {
										type: ro.AWARD, treatment: io.NEGATIVE
									};
								case "ACCEPT_MODERATOR_INVITE":
								case "INVITE_MODERATOR":
								case "SET_PERMISSIONS":
								case "UNBAN_USER":
								case "UNINVITE_MODERATOR":
								case "UNMUTE_USER":
									return {
										type: ro.REDDITOR, treatment: io.NONE
									};
								case "APPROVE_COMMENT":
								case "SHOW_COMMENT":
									return {
										type: ro.COMMENT, treatment: io.POSITIVE
									};
								case "REMOVE_COMMENT":
								case "SPAM_COMMENT":
									return {
										type: ro.COMMENT, treatment: io.NEGATIVE
									};
								case "EDIT_FLAIR":
									return {
										type: ro.FLAIR, treatment: io.NONE
									};
								case "APPROVE_LINK":
									return {
										type: ro.POST, treatment: io.POSITIVE
									};
								case "REMOVE_LINK":
								case "SPAM_LINK":
									return {
										type: ro.POST, treatment: io.NEGATIVE
									};
								case "LOCK":
								case "MARK_NSFW":
								case "MARK_ORIGINAL_CONTENT":
								case "SET_CONTEST_MODE":
								case "SET_SUGGESTEDSORT":
								case "SPOILER":
								case "UNLOCK":
								case "UNSET_CONTEST_MODE":
								case "UNSPOILER":
									return {
										type: ro.POST, treatment: io.NONE
									};
								case "DISTINGUISH":
								case "IGNORE_REPORTS":
								case "STICKY":
								case "UNIGNORE_REPORTS":
								case "UNSTICKY":
									return {
										type: ro.MULTIPLE, treatment: io.NONE
									};
								case "ADD_COMMUNITY_TOPICS":
								case "REMOVE_COMMUNITY_TOPICS":
								case "COMMUNITY_STYLING":
								case "COMMUNITY_WIDGETS":
								case "CREATE_RULE":
								case "DELETE_RULE":
								case "EDIT_RULE":
								case "REORDER_RULES":
								case "EDIT_SETTINGS":
								case "MODMAIL_ENROLLMENT":
									return {
										type: ro.SETTINGS, treatment: io.NONE
									};
								case "REMOVE_WIKI_CONTRIBUTOR":
								case "WIKI_BANNED":
									return {
										type: ro.WIKI, treatment: io.NEGATIVE
									};
								case "WIKI_CONTRIBUTOR":
								case "WIKI_PAGE_LISTED":
								case "WIKI_PERM_LEVEL":
								case "WIKI_REVISE":
								case "WIKI_UNBANNED":
									return {
										type: ro.WIKI, treatment: io.NONE
									};
								case "COLLECTIONS":
									return {
										type: ro.COLLECTION, treatment: io.NONE
									};
								case "EVENTS":
									return {
										type: ro.EVENT, treatment: io.NONE
									};
								case "CREATE_SCHEDULED_POST":
								case "EDIT_SCHEDULED_POST":
								case "DELETE_SCHEDULED_POST":
								case "SUBMIT_SCHEDULED_POST":
									return {
										type: ro.POST, treatment: io.NONE
									};
								default:
									Object(b.a)(e)
							}
						})(t.action),
						a = t.target && t.target.__typename,
						o = a === Go.b.Comment || Go.b.DeletedComment;
					let i;
					switch (n && n.type) {
						case ro.AWARD:
							i = r.a.createElement(is.a, {
								className: Xo.a.icon
							});
							break;
						case ro.COMMENT:
							i = r.a.createElement(Fo.a, null);
							break;
						case ro.FLAIR:
							i = r.a.createElement(Ko.a, {
								className: Xo.a.icon
							});
							break;
						case ro.POST:
							i = r.a.createElement(Ho, {
								className: Xo.a.icon
							});
							break;
						case ro.REDDITOR:
							i = r.a.createElement(Vo.a, {
								className: Xo.a.icon
							});
							break;
						case ro.SETTINGS:
							i = r.a.createElement(zo.a, {
								className: Xo.a.icon
							});
							break;
						case ro.WIKI:
							i = r.a.createElement(Qo, {
								className: Xo.a.icon
							});
							break;
						case ro.COLLECTION:
							i = r.a.createElement(Bo, {
								className: Xo.a.icon
							});
							break;
						case ro.EVENT:
							i = r.a.createElement(Uo, {
								className: Xo.a.icon
							});
							break;
						case ro.MULTIPLE:
							o && (i = r.a.createElement(Fo.a, null)), a === Jo.f.SubredditPost && (i = r.a.createElement(Ho, {
								className: Xo.a.icon
							}))
					}
					const c = ao[t.action];
					return r.a.createElement(v.a, {
						className: Xo.a.actionLink,
						to: s
					}, r.a.createElement("span", {
						className: Xo.a.iconWrapper
					}, i, n && n.treatment === io.POSITIVE ? r.a.createElement(qo, {
						className: Xo.a.positiveTreatment
					}) : n && n.treatment === io.NEGATIVE ? r.a.createElement(Wo, {
						className: Xo.a.negativeTreatment
					}) : null), c && c())
				},
				$o = e => {
					let {
						action: t,
						language: s
					} = e;
					const n = t.target && t.target.__typename;
					let a, o, i, c = t.target;
					switch (n) {
						case Jo.f.SubredditPost:
							a = (c = c).authorInfo && c.authorInfo.__typename === Ao.d.AvailableRedditor && c.authorInfo.name || null, o = c.title, i = c.permalink;
							break;
						case Jo.f.DeletedSubredditPost:
							a = null, o = (c = c).title, i = c.permalink;
							break;
						case Ao.d.AvailableRedditor:
							a = (c = c) && c.name || null, o = null;
							break;
						case Go.b.Comment:
							a = (c = c).authorInfo && c.authorInfo.__typename === Ao.d.AvailableRedditor && c.authorInfo.name || null, o = c.content && c.content.markdown, i = c.permalink;
							break;
						case Go.b.DeletedComment:
							a = null, o = (c = c).postInfo && c.postInfo.title, i = c.postInfo && c.postInfo.permalink;
							break;
						default:
							a = null, o = null, i = void 0
					}
					let d = t.details;
					oo[t.details] && (d = t.details && Object(Ot.a)(s, oo[t.details]));
					let l = t.actionNotes || d;
					return t.actionNotes && d && (l = "".concat(d, ": ").concat(t.actionNotes)), r.a.createElement("div", {
						className: Xo.a.detailsContainer
					}, a && !so.includes(a) ? r.a.createElement(Ta.a, {
						tooltipId: "userlink-".concat(t.id),
						user: a,
						sendHoverCardEvent: wa.a
					}, r.a.createElement(Do.a, {
						className: Xo.a.usernameLink,
						author: a
					}, "u/".concat(a))) : a, o && i && r.a.createElement("a", {
						className: Xo.a.detailsContent,
						target: "_blank",
						href: i
					}, o), l && r.a.createElement("span", {
						className: Xo.a.detailsType
					}, "(".concat(l, ")")))
				},
				er = "mod-log-timestamp-";
			class tr extends r.a.Component {
				constructor() {
					super(...arguments), this.createTimestamp = e => {
						return new Date(e).toString()
					}, this.getTooltipId = e => "".concat(er).concat(e), this.getActionModeratorName = e => e && e.__typename === Ao.d.AvailableRedditor ? e.name : null
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						language: s,
						moderator: n,
						onHideTooltip: a,
						onShowTooltip: o
					} = this.props, i = this.getTooltipId(e.id), c = this.getActionModeratorName(e.moderator);
					return r.a.createElement("tr", {
						className: Xo.a.row
					}, r.a.createElement("td", null, r.a.createElement("span", {
						id: i,
						onMouseEnter: () => o(i),
						onMouseLeave: a,
						className: Xo.a.tooltip
					}, Object(A.d)(s, e.createdAt / 1e3), r.a.createElement(Q.c, {
						className: Xo.a.createdAtTooltip,
						tooltipId: i,
						text: this.createTimestamp(e.createdAt)
					}))), r.a.createElement("td", {
						className: Xo.a.modNameCell
					}, c && !so.includes(c) ? r.a.createElement(Ta.a, {
						tooltipId: "modlink-".concat(e.id),
						user: c,
						sendHoverCardEvent: wa.a
					}, r.a.createElement(Do.a, {
						author: c,
						className: Xo.a.usernameLink
					}, c)) : c), r.a.createElement("td", null, r.a.createElement(Yo, {
						action: e,
						urlPath: co({
							currentPageUrl: t,
							action: e.action,
							moderator: n
						})
					})), r.a.createElement("td", null, r.a.createElement($o, {
						action: e,
						language: s
					})))
				}
			}
			var sr = Object(i.b)(null, e => ({
					onHideTooltip: () => e(Object(Yt.h)()),
					onShowTooltip: t => e(Object(Yt.f)({
						tooltipId: t
					}))
				}))(tr),
				nr = s("./src/reddit/constants/parameters.ts"),
				ar = s("./src/reddit/components/ModerationLog/index.m.less"),
				or = s.n(ar);
			const rr = Object(f.t)({
					currentPageUrl: f.e,
					queryParams: f.R
				}),
				ir = Object(c.c)({
					actionsList: Co,
					endCursor: Oo,
					language: L.S,
					nextPage: (e, t) => {
						let {
							subredditId: s
						} = t;
						return e.moderationLog.hasNextPage[s]
					},
					previousPage: (e, t) => {
						let {
							subredditId: s
						} = t;
						return e.moderationLog.hasPreviousPage[s]
					},
					startCursor: jo
				});
			class cr extends r.a.Component {
				componentDidMount() {
					"complete" === document.readyState ? this.props.fetchAllModerators() : window.addEventListener("load", this.props.fetchAllModerators)
				}
				render() {
					const {
						actionsList: e,
						currentPageUrl: t,
						endCursor: s,
						language: n,
						nextPage: a,
						previousPage: o,
						queryParams: i,
						startCursor: c,
						subredditId: d
					} = this.props, l = i[nr.m] || null, m = i[nr.l] || null, u = {
						currentPageUrl: t,
						action: l,
						moderator: m,
						startCursor: c
					}, b = {
						currentPageUrl: t,
						endCursor: s,
						action: l,
						moderator: m
					};
					return r.a.createElement(oe, {
						className: or.a.contentContainer
					}, r.a.createElement(re, null, p.fbt._("Mod log", null, {
						hk: "UdwRO"
					}), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360022402312")
					})), r.a.createElement(ke, null, r.a.createElement("span", {
						className: or.a.title
					}, p.fbt._("Filter by", null, {
						hk: "3RkGvd"
					})), r.a.createElement(Lo, {
						action: l,
						currentPageUrl: t,
						moderator: m,
						subredditId: d
					}), r.a.createElement(Rn, {
						prevButtonEnabled: o,
						prevTo: co(u),
						nextButtonEnabled: a,
						nextTo: co(b)
					})), r.a.createElement("table", {
						className: or.a.table
					}, r.a.createElement("thead", null, r.a.createElement("tr", null, r.a.createElement("th", {
						className: or.a.timeColHeader
					}, p.fbt._("time", null, {
						hk: "1EnamY"
					})), r.a.createElement("th", {
						className: or.a.modNameColHeader
					}, p.fbt._("moderator", null, {
						hk: "22lRDF"
					})), r.a.createElement("th", {
						className: or.a.actionNameColHeader
					}, r.a.createElement("span", {
						className: or.a.tooltip
					}, p.fbt._("action", null, {
						hk: "243Ltb"
					}), r.a.createElement(_n.a, {
						className: or.a.actionTooltip
					}, r.a.createElement("div", {
						className: or.a.actionTooltipDescription
					}, p.fbt._("Actions performed within your community", null, {
						hk: "3RTNED"
					})), r.a.createElement("div", {
						className: or.a.allIconsContainer
					}, r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Ho, {
						className: or.a.icon
					}), p.fbt._("Post", null, {
						hk: "9rK7i"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Fo.a, null), p.fbt._("Comment", null, {
						hk: "1N3Vo2"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Ko.a, {
						className: or.a.icon
					}), p.fbt._("Flair", null, {
						hk: "roX9r"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Qo, {
						className: or.a.icon
					}), p.fbt._("Wiki", null, {
						hk: "27Czfb"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Vo.a, {
						className: or.a.icon
					}), p.fbt._("User management", null, {
						hk: "NIFnh"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(zo.a, {
						className: or.a.icon
					}), p.fbt._("Community settings", null, {
						hk: "139FAy"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Bo, {
						className: or.a.icon
					}), p.fbt._("Collection", null, {
						hk: "3a6W4E"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(Uo, {
						className: or.a.icon
					}), p.fbt._("Event", null, {
						hk: "2odtv8"
					})), r.a.createElement("div", {
						className: or.a.iconContainer
					}, r.a.createElement(is.a, {
						className: or.a.icon
					}), p.fbt._("Award", null, {
						hk: "1wcAOA"
					})))))), r.a.createElement("th", null, r.a.createElement("span", {
						className: or.a.tooltip
					}, p.fbt._("details", null, {
						hk: "1hCsar"
					}), r.a.createElement(_n.a, {
						text: p.fbt._("Displays the author, post or comment link, and any additional information", null, {
							hk: "1EN2HF"
						})
					}))))), r.a.createElement("tbody", null, e.map(e => r.a.createElement(sr, {
						key: e.id,
						action: e,
						currentPageUrl: t,
						language: n,
						moderator: m
					})))), r.a.createElement("div", {
						className: or.a.bottomBarRow
					}, r.a.createElement(Rn, {
						prevButtonEnabled: o,
						prevTo: co(u),
						nextButtonEnabled: a,
						nextTo: co(b)
					})))
				}
			}
			var dr = rr(Object(i.b)(ir, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						fetchAllModerators: () => e((e => async (t, s, n) => {
							let {
								gqlContext: a
							} = n;
							const o = s(),
								r = Object(R.G)(o, e);
							if (o.moderationLog.moderators[r]) return;
							const i = await Object(Xa.b)(a(), e);
							if (i.body) {
								const e = i.body.data.subreddit.moderators;
								if (e) {
									const s = Object(Ya.a)(e);
									t(eo({
										normalizedModerators: s,
										subredditId: r
									}))
								}
							}
						})(s.name))
					}
				})(cr)),
				lr = e => !!e && !!e.all,
				mr = s("./src/reddit/controls/CheckboxWithLabel/index.tsx"),
				ur = s("./src/reddit/models/ModeratingSubreddits/index.ts"),
				pr = s("./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less"),
				br = s.n(pr);
			const hr = Object(c.c)({
					language: L.S
				}),
				gr = Object(i.b)(hr, (e, t) => {
					let {
						subredditId: s,
						after: n,
						before: a
					} = t;
					return {
						addModerator: (t, n) => e(Object(B.T)(s, t, n)),
						editModerator: (t, n, a) => e(Object(B.cb)(s, t, n, a)),
						removeModerator: t => e(Object(B.lb)(s, t, n, a))
					}
				}),
				Er = m.a.span("SecondaryText", br.a),
				xr = m.a.wrapped(at.c, "ModalBody", br.a);
			class fr extends r.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.toggleSelect = (e, t) => {
						if (this.props.isEditingSelf) return;
						const s = Object.assign({}, this.state.permissions, {
							[e]: !t
						});
						"all" === e && s.all ? Object.keys(s).forEach(e => s[e] = !0) : s[e] || (s.all = !1), this.setState({
							permissions: s
						}), this.props.sendEventWithName("permission")()
					}, this.onSubmit = e => {
						e.preventDefault();
						const {
							props: t,
							state: s
						} = this;
						t.isEditingSelf ? t.toggleModal() : (t.isEditingPerms && t.user ? (t.editModerator(s.username, s.permissions, t.user.id), t.sendEventWithName("edit")()) : (t.addModerator(s.username, s.permissions), t.sendEventWithName("invite_moderator")()), t.toggleModal())
					}, this.onRemove = () => {
						this.props.user && (this.props.removeModerator(this.props.user.id), this.props.sendEventWithName("remove")()), this.props.toggleModal()
					}, this.state = {
						username: e.user ? e.user.username : "",
						permissions: e.user ? e.user.modPermissions : ur.a
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = ["all", ...Object.keys(t.permissions).filter(e => "all" !== e)];
					return r.a.createElement(xr, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, Object(Ot.a)(e.language, e.isEditingPerms ? "subredditModeration.buttons.edit" : "subredditModeration.moderators.invite"), e.username && ": u/".concat(e.username)), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement("form", {
						onSubmit: this.onSubmit
					}, r.a.createElement(at.j, null, !e.isEditingPerms && r.a.createElement(at.f, null, r.a.createElement(ot.d, {
						autoFocus: !0,
						placeholder: Object(G.c)("Enter Username"),
						onChange: this.onUsernameChange
					})), r.a.createElement(at.n, null, r.a.createElement(_e.c, null, "Permissions"), e.isEditingSelf && r.a.createElement(Er, null, " (".concat(Object(G.c)("can't edit"), ")"))), t.permissions && s.map((s, n) => r.a.createElement("div", {
						className: br.a.checkboxContainer,
						key: s
					}, r.a.createElement(mr.a, {
						autoFocus: !(!e.isEditingPerms || 0 !== n) || void 0,
						className: br.a.checkbox,
						disabled: e.isEditingSelf,
						isSelected: t.permissions[s],
						onClick: () => this.toggleSelect(s, t.permissions[s]),
						text: Object(Ot.a)(this.props.language, "subredditModeration.permissions.".concat(s))
					})))), r.a.createElement(at.e, {
						className: br.a.footer
					}, r.a.createElement(de.f, {
						className: br.a.primaryButton,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(it.a)(t.username),
						type: "submit"
					}, Object(Ot.a)(e.language, e.isEditingPerms ? "subredditModeration.buttons.save" : "subredditModeration.buttons.invite")), r.a.createElement(at.a, {
						autoFocus: !!e.isEditingSelf || void 0,
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.a.createElement(_e.c, null, "Cancel")), e.isEditingPerms && !e.isEditingSelf && r.a.createElement(at.p, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, r.a.createElement(_e.c, null, "Remove")))))
				}
			}
			var vr = Object(nt.a)(gr(fr));
			const Cr = e => t => Object.assign({
				source: "remove_mod_invite",
				action: "click",
				noun: e
			}, (e => ({
				screen: y.screen(e),
				subreddit: y.subreddit(e)
			}))(t));
			var Or = s("./src/reddit/icons/svgs/Trash/index.tsx"),
				jr = s("./src/reddit/components/ModeratorsList/Moderator.m.less"),
				yr = s.n(jr);
			const kr = (e, t) => {
					const s = [],
						n = Object.keys(t);
					return t.all ? Object(Ot.a)(e, "subredditModeration.permissions.all") : (n.forEach((function(n) {
						t[n] && s.push(Object(Ot.a)(e, "subredditModeration.permissions.".concat(n)))
					})), 0 === s.length ? Object(Ot.a)(e, "subredditModeration.moderators.noPermissions") : s.join(", "))
				},
				wr = m.a.wrapped($e.a, "PencilIcon", yr.a),
				Sr = m.a.wrapped(Or.a, "TrashIcon", yr.a),
				Nr = m.a.div("InteractiveDiv", yr.a),
				Tr = e => r.a.createElement(Nr, {
					onClick: e.onClick
				}, e.moderatorType === et.c.Editable ? r.a.createElement(wr, null) : r.a.createElement(Sr, null));
			var _r = e => r.a.createElement(Ye, {
					additionalText: kr(e.language, e.moderator.modPermissions),
					pageName: h.Nb.Moderators,
					primaryButton: e.moderatorType && e.onClick && r.a.createElement(Tr, {
						onClick: e.onClick,
						moderatorType: e.moderatorType
					}),
					timeAgo: Object(A.d)(e.language, e.moderator.moddedAtUTC),
					subredditId: e.subredditId,
					userIcon: e.moderator.accountIcon,
					username: e.moderator.username,
					moderatorType: e.moderatorType
				}),
				Ir = s("./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less"),
				Pr = s.n(Ir);
			const Mr = m.a.div("ListTitle", Pr.a),
				Rr = m.a.div("ListContainer", Pr.a),
				Lr = Object(c.c)({
					invitedModeratorsList: st.s,
					isConfirmModalOpen: Object(tt.b)("ModerationPage--Modal--RemoveModeratorConfirmation")
				});
			class Dr extends r.a.Component {
				constructor(e) {
					super(e), this.onToggleRemovalModal = e => {
						this.setState({
							selectedModerator: e
						}), this.props.toggleConfirmUserActionModal(), e && this.props.sendEventWithName("remove_mod_invite")()
					}, this.state = {
						selectedModerator: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					if (0 === e.invitedModeratorsList.length) return null;
					const s = () => this.props.sendEvent(Cr("cancel"));
					return r.a.createElement("div", null, r.a.createElement(Mr, null, r.a.createElement(_e.c, null, "Invited moderators")), r.a.createElement(Rr, null, e.invitedModeratorsList.map(t => r.a.createElement(_r, {
						key: t.id,
						language: e.language,
						moderator: t,
						moderatorType: et.c.Invited,
						onClick: () => this.onToggleRemovalModal(t),
						subredditId: e.subredditId
					}))), e.isConfirmModalOpen && t.selectedModerator && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						modalText: Object(Ot.a)(e.language, "subredditModeration.moderators.areYouSure", {
							username: "u/".concat(t.selectedModerator.username)
						}),
						onConfirm: () => e.removeInvitedModerator(t.selectedModerator.id),
						toggleModal: this.onToggleRemovalModal,
						onCancel: s,
						onClose: s,
						trackClick: () => this.props.sendEvent(Cr("remove"))
					}))
				}
			}
			var Ar = Object(i.b)(Lr, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						removeInvitedModerator: t => e(Object(B.kb)(s, t)),
						toggleConfirmUserActionModal: () => e(Object(F.i)("ModerationPage--Modal--RemoveModeratorConfirmation"))
					}
				})(Object(x.b)(Dr)),
				Fr = s("./src/reddit/components/ModeratorsList/InvitePendingModal.m.less"),
				Br = s.n(Fr);
			const Ur = Object(c.c)({
					language: L.S
				}),
				Hr = Object(i.b)(Ur, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						acceptInvite: () => e(Object(B.S)(s)),
						declineInvite: () => e(Object(B.bb)(s))
					}
				}),
				Wr = m.a.wrapped(at.m, "ModalText", Br.a),
				qr = m.a.wrapped(Wr, "ModalTextBold", Br.a),
				Vr = m.a.wrapped(de.f, "PrimaryButton", Br.a),
				zr = m.a.wrapped(de.i, "SecondaryButton", Br.a),
				Kr = m.a.div("Section", Br.a),
				Qr = m.a.img("Image", Br.a),
				Gr = m.a.wrapped(at.j, "ModalMain", Br.a);
			var Jr = Object(nt.a)(Hr(e => r.a.createElement(at.c, null, r.a.createElement(Gr, null, r.a.createElement(ct.a, null, r.a.createElement("div", null), r.a.createElement(rt.a, {
					onClick: e.toggleModal
				}, r.a.createElement(at.b, null))), r.a.createElement(Kr, null, r.a.createElement(Qr, {
					src: "".concat(D.a.assetPath, "/img/snoo-success@2x.png")
				})), r.a.createElement(qr, null, r.a.createElement(_e.c, null, "Congrats!")), r.a.createElement(Wr, null, r.a.createElement(_e.c, null, "You are invited to become a moderator!"))), r.a.createElement(at.e, null, r.a.createElement(zr, {
					onClick: t => {
						e.toggleModal(), e.declineInvite(), e.sendEventWithName("declineinvite")()
					},
					"data-redditstyle": !0
				}, r.a.createElement(_e.c, null, "Decline")), r.a.createElement(Vr, {
					onClick: t => {
						e.toggleModal(), e.acceptInvite(), e.sendEventWithName("acceptinvite")()
					},
					"data-redditstyle": !0
				}, r.a.createElement(_e.c, null, "Accept")))))),
				Zr = s("./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less"),
				Xr = s.n(Zr);
			const Yr = Object(c.c)({
					language: L.S
				}),
				$r = Object(i.b)(Yr, (e, t) => {
					let {
						subredditId: s,
						userId: n,
						after: a,
						before: o
					} = t;
					return {
						removeModerator: () => e(Object(B.lb)(s, n, a, o))
					}
				}),
				ei = m.a.wrapped(de.f, "PrimaryButton", Xr.a);
			class ti extends r.a.Component {
				constructor() {
					super(...arguments), this.onRemove = () => {
						this.props.removeModerator(), this.props.sendEventWithName("resign")(), this.props.toggleModal()
					}
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement(at.c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, r.a.createElement(_e.c, null, "Leave as mod")), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, r.a.createElement(at.m, null, r.a.createElement(_e.c, null, "Once you leave as a mod, you will lose mod permissions and will be unable to access any mod tools for this community. Are you sure you wish to leave as a mod of this community?"))), r.a.createElement(at.e, null, r.a.createElement(at.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.a.createElement(_e.c, null, "Cancel")), r.a.createElement(ei, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, r.a.createElement(_e.c, null, "Leave"))))
				}
			}
			var si = Object(nt.a)($r(ti)),
				ni = s("./src/reddit/components/ModeratorsList/index.m.less"),
				ai = s.n(ni);
			const oi = m.a.div("ListContainer", ai.a),
				ri = m.a.wrapped(de.i, "SecondaryButton", ai.a),
				ii = Object(f.t)({
					currentPageUrl: f.e
				}),
				ci = Object(c.c)({
					currentUser: L.i,
					nextAfterToken: st.x,
					nextAfterEditableToken: st.p,
					nextBeforeToken: st.y,
					nextBeforeEditableToken: st.q,
					editableModerators: st.r,
					editableModeratorsList: st.o,
					isInvitePending: st.u,
					moderators: st.B,
					moderatorsList: st.w,
					moderatorPermissions: P.j,
					isAddUserModalOpen: Object(tt.b)("ModerationPage--Modal--AddModerator"),
					isEditableListPending: st.n,
					isInvitePendingModalOpen: Object(tt.b)("ModerationPage--Modal--InvitePending"),
					isModeratorListPending: st.v,
					isResignAsModeratorModalOpen: Object(tt.b)("ModerationPage--Modal--Resign"),
					language: L.S,
					origin: oa.g,
					searchPending: st.z,
					searchResult: st.A
				}),
				di = Object(i.b)(ci, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						searchForModerator: t => e(Object(B.gb)(s, t)),
						toggleAddModeratorModal: () => e(Object(F.i)("ModerationPage--Modal--AddModerator")),
						toggleInvitePendingModal: () => e(Object(F.i)("ModerationPage--Modal--InvitePending")),
						toggleResignAsModModal: () => e(Object(F.i)("ModerationPage--Modal--Resign"))
					}
				}),
				li = m.a.div("EditableTitle", ai.a),
				mi = m.a.wrapped(Ze, "UsersLoading", ai.a);
			class ui extends r.a.Component {
				constructor() {
					super(...arguments), this.state = et.a, this.toggleModal = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.isAddUserModalOpen || t || this.props.sendEventWithName("open_invite_dialog")(), this.props.toggleAddModeratorModal()
					}, this.onSearch = e => {
						this.props.searchForModerator(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.isButtonEnabled = (e, t) => !!(e && e.length > 0 && t), this.isModeratorsListPaginated = () => !(!this.props.nextBeforeToken && !this.props.nextAfterToken), this.renderEditableList = e => {
						const t = !(!e.nextBeforeEditableToken && !e.nextAfterEditableToken),
							s = e.isEditableListPending || e.isModeratorListPending;
						return r.a.createElement(r.a.Fragment, null, r.a.createElement(li, null, r.a.createElement(_e.c, null, "You can edit these moderators")), t && r.a.createElement(ke, null, r.a.createElement(Rn, {
							prevButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextBeforeEditableToken),
							prevTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
								before: e.before,
								beforeEditable: e.nextBeforeEditableToken,
								after: e.after
							}),
							nextButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextAfterEditableToken),
							nextTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
								after: e.after,
								afterEditable: e.nextAfterEditableToken,
								before: e.before
							})
						})), r.a.createElement(oi, null, e.editableModeratorsList && e.editableModeratorsList.length > 0 ? e.editableModeratorsList.map(e => r.a.createElement(_r, {
							key: e.id,
							language: this.props.language,
							moderator: e,
							moderatorType: et.c.Editable,
							onClick: this.toggleModal(e.id, e.username),
							subredditId: this.props.subredditId
						})) : s ? r.a.createElement(mi, null) : null))
					}
				}
				componentDidMount() {
					this.props.isInvitePending && !this.props.isInvitePendingModalOpen && this.props.toggleInvitePendingModal()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = !!e.moderatorPermissions, n = lr(e.moderatorPermissions);
					return r.a.createElement(r.a.Fragment, null, s && r.a.createElement(ie, null, r.a.createElement(ri, {
						onClick: e.toggleResignAsModModal
					}, r.a.createElement(_e.c, null, "Leave as mod")), n && r.a.createElement(de.f, {
						onClick: this.toggleModal(null, null)
					}, r.a.createElement(_e.c, null, "Invite user as mod"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(Ot.a)(e.language, "subredditModeration.moderators.title", {
						subredditName: e.subreddit.displayText
					}), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009381491")
					})), r.a.createElement(we, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}, !t.searchTerm && this.isModeratorsListPaginated() && r.a.createElement(Rn, {
						prevButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextBeforeToken),
						prevTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
							afterEditable: e.afterEditable,
							before: e.nextBeforeToken,
							beforeEditable: e.beforeEditable
						}),
						nextButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextAfterToken),
						nextTo: Object(jn.a)(Sn("".concat(e.origin).concat(e.currentPageUrl)), {
							after: e.nextAfterToken,
							afterEditable: e.afterEditable,
							beforeEditable: e.beforeEditable
						})
					})), t.searchTerm ? r.a.createElement(Oe, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && r.a.createElement(_r, {
						language: e.language,
						moderator: e.searchResult,
						moderatorType: e.searchResult.isEditable ? et.c.Editable : void 0,
						onClick: e.searchResult.isEditable ? this.toggleModal(e.searchResult.id, e.searchResult.username) : void 0,
						subredditId: e.subredditId
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(oi, null, e.moderatorsList && e.moderatorsList.length > 0 ? e.moderatorsList.map(e => r.a.createElement(_r, {
						key: e.id,
						language: this.props.language,
						moderator: e,
						subredditId: this.props.subredditId
					})) : e.isModeratorListPending ? r.a.createElement(mi, null) : null), n && r.a.createElement(r.a.Fragment, null, this.renderEditableList(e), r.a.createElement(Ar, {
						language: e.language,
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId
					})))), e.isAddUserModalOpen && r.a.createElement(vr, {
						ignoreDefaultFocus: !0,
						after: e.afterEditable,
						before: e.beforeEditable,
						subredditId: e.subredditId,
						sendEventWithName: e.sendEventWithName,
						toggleModal: this.toggleModal(null, null),
						isEditingPerms: !!t.username,
						isEditingSelf: !(!t.userId || !e.currentUser) && t.userId === e.currentUser.id,
						username: t.username,
						user: t.userId && e.editableModerators ? e.editableModerators[t.userId] : null,
						withOverlay: !0
					}), e.currentUser && e.isResignAsModeratorModalOpen && r.a.createElement(si, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleResignAsModModal,
						userId: e.currentUser.id,
						withOverlay: !0
					}), e.isInvitePendingModalOpen && r.a.createElement(Jr, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleInvitePendingModal,
						withOverlay: !0
					}))
				}
			}
			var pi = ii(di(ui)),
				bi = s("./src/reddit/actions/governance/errorToast.ts"),
				hi = s("./src/reddit/actions/toaster.ts"),
				gi = s("./src/reddit/contexts/ApiContext.tsx"),
				Ei = s("./src/reddit/endpoints/economics/uploadedAssets.ts"),
				xi = s("./src/reddit/models/Toast/index.ts"),
				fi = s("./src/reddit/icons/svgs/SnooHappy/index.tsx"),
				vi = s("./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less"),
				Ci = s.n(vi);
			const Oi = {
				[Ei.a.Uploaded]: {
					title: Object(G.c)("No more to review!"),
					subtitle: Object(G.c)("There are no new submissions")
				},
				[Ei.a.Approved]: {
					title: Object(G.c)("Nothing approved yet"),
					subtitle: Object(G.c)("Submissions will be here once you approve them")
				},
				[Ei.a.Rejected]: {
					title: Object(G.c)("Nothing rejected yet"),
					subtitle: Object(G.c)("Submissions will be here once you reject them")
				}
			};
			var ji = e => {
					const t = Oi[e.selectedStatus];
					return r.a.createElement("div", {
						className: Ci.a.container
					}, r.a.createElement(fi.a, {
						className: Ci.a.icon
					}), r.a.createElement("h3", {
						className: Ci.a.title
					}, t.title), r.a.createElement("p", {
						className: Ci.a.subtitle
					}, t.subtitle))
				},
				yi = s("./src/reddit/controls/DropdownSelector/index.tsx"),
				ki = s("./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less"),
				wi = s.n(ki);
			const Si = m.a.div("cell", wi.a),
				Ni = [{
					displayText: Object(G.c)("New"),
					value: Ei.a.Uploaded
				}, {
					displayText: Object(G.c)("Approved"),
					value: Ei.a.Approved
				}, {
					displayText: Object(G.c)("Rejected"),
					value: Ei.a.Rejected
				}],
				Ti = Ni.slice(1, 3),
				_i = new Intl.DateTimeFormat(void 0, {
					month: "numeric",
					day: "numeric",
					year: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric"
				}).format;

			function Ii(e) {
				const {
					item: t,
					onItemAction: s
				} = e, n = Ni.find(e => e.value === t.status);
				let a = t.type === Ei.b.Badge ? t.extra.description : void 0;
				return a && a.endsWith(" u/" + t.uploader) && (a = a.slice(0, a.length - t.uploader.length - 3)), r.a.createElement(r.a.Fragment, null, r.a.createElement(Si, {
					className: wi.a.imageCell
				}, r.a.createElement("div", {
					className: wi.a.image,
					style: {
						backgroundImage: "url(".concat(t.url, ")")
					}
				})), r.a.createElement(Si, {
					className: wi.a.nameCell
				}, r.a.createElement("div", {
					className: wi.a.title
				}, t.type === Ei.b.Emote ? ":".concat(t.name, ":") : t.name), r.a.createElement("div", {
					className: wi.a.caption
				}, a, " ", r.a.createElement(Do.a, {
					author: t.uploader,
					style: {
						color: t.type === Ei.b.Badge ? t.extra.color : void 0
					}
				}, "u/", t.uploader))), r.a.createElement(Si, {
					className: wi.a.timeCell
				}, _i(t.createdAt)), r.a.createElement(Si, {
					className: wi.a.actionCell
				}, r.a.createElement(yi.a, {
					className: wi.a.dropdownSelector,
					displayText: n ? n.displayText : "",
					options: Ti,
					onSelect: e => s(t, e.value),
					isCompactStyle: !0
				}), t.status !== Ei.a.Uploaded && !!t.moderator && !!t.modifiedAt && r.a.createElement("div", {
					className: wi.a.byModerator
				}, r.a.createElement(_e.c, null, "by u/", r.a.createElement(_e.b, {
					name: "moderator"
				}, t.moderator), ", ", r.a.createElement(_e.b, {
					name: "time-modified"
				}, _i(t.modifiedAt))))), r.a.createElement("div", {
					className: wi.a.line
				}))
			}
			const Pi = m.a.div("cell", wi.a),
				Mi = () => r.a.createElement(r.a.Fragment, null, r.a.createElement(Pi, {
					className: wi.a.imageCell
				}, r.a.createElement("div", {
					className: Object(d.a)(wi.a.image, wi.a.imagePlaceholder)
				})), r.a.createElement(Pi, {
					className: wi.a.nameCell
				}, r.a.createElement("div", {
					className: wi.a.loadingTextLong
				})), r.a.createElement(Pi, null, r.a.createElement("div", {
					className: wi.a.loadingTextShort
				})), r.a.createElement(Pi, {
					className: wi.a.actionCell
				}, r.a.createElement("div", {
					className: wi.a.loadingTextShort
				})), r.a.createElement("div", {
					className: wi.a.line
				}));
			var Ri = () => r.a.createElement(r.a.Fragment, null, r.a.createElement(Mi, null), r.a.createElement(Mi, null), r.a.createElement(Mi, null), r.a.createElement(Mi, null));
			const Li = m.a.div("header", wi.a);
			var Di = e => {
					const {
						onAssetAction: t,
						assets: s,
						selectedStatus: n
					} = e;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement("div", {
						className: wi.a.grid
					}, r.a.createElement(Li, null, r.a.createElement(_e.c, null, "Image")), r.a.createElement(Li, null, r.a.createElement(_e.c, null, "Name and Description")), r.a.createElement(Li, null, r.a.createElement(_e.c, null, "Submission Time")), r.a.createElement(Li, {
						className: wi.a.actionHeader
					}, r.a.createElement(_e.c, null, "Action")), !s && r.a.createElement(Ri, null), s && !!s.length && s.map(e => r.a.createElement(Ii, {
						item: e,
						key: e.name,
						onItemAction: t
					}))), s && !s.length && r.a.createElement(ji, {
						selectedStatus: n
					}))
				},
				Ai = s("./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less"),
				Fi = s.n(Ai);
			const Bi = {
					[Ei.a.Uploaded]: Object(G.c)("Uploaded"),
					[Ei.a.Approved]: Object(G.c)("Approved"),
					[Ei.a.Rejected]: Object(G.c)("Rejected")
				},
				Ui = e => r.a.createElement("button", {
					className: Object(d.a)(Fi.a.tab, {
						[Fi.a.selected]: e.selected
					}),
					onClick: e.onClick
				}, e.children),
				Hi = e => r.a.createElement("div", {
					className: Fi.a.tabBar
				}, [Ei.a.Uploaded, Ei.a.Approved, Ei.a.Rejected].map(t => r.a.createElement(Ui, {
					onClick: () => e.onTabSelected(t),
					selected: t === e.value,
					value: t,
					key: t
				}, Bi[t])));

			function Wi() {
				return (Wi = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			class qi extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						selectedStatus: Ei.a.Uploaded
					}, this.onTabChange = async e => {
						this.setState({
							assets: void 0,
							selectedStatus: e
						});
						const t = await Object(Ei.c)(this.props.apiContext(), this.props.subredditId, this.props.assetType, e);
						t.ok ? this.setState({
							assets: t.body.assets || []
						}) : this.props.onGovernanceError(t.error)
					}, this.onAssetAction = async (e, t) => {
						if (e.status === t) return;
						const s = this.props.assetType,
							n = await Object(Ei.d)(this.props.apiContext(), this.props.subredditId, s, e.id, {
								status: t
							});
						if (n.ok) {
							const n = this.state.assets;
							this.setState({
								assets: n && n.filter(t => t !== e)
							}), t === Ei.a.Approved ? this.props.onApproved(s) : t === Ei.a.Rejected && this.props.onRejected(s)
						} else this.props.onGovernanceError(n.error)
					}
				}
				componentDidMount() {
					this.onTabChange(this.state.selectedStatus)
				}
				render() {
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(oe, {
						className: wi.a.contentContainer
					}, r.a.createElement(re, null, this.props.assetType === Ei.b.Badge ? r.a.createElement(_e.c, null, "User uploaded badges") : r.a.createElement(_e.c, null, "User uploaded emotes")), r.a.createElement("div", {
						className: wi.a.content
					}, r.a.createElement(Hi, {
						onTabSelected: this.onTabChange,
						value: this.state.selectedStatus
					}), r.a.createElement(Di, {
						selectedStatus: this.state.selectedStatus,
						assets: this.state.assets,
						onAssetAction: this.onAssetAction
					}))))
				}
			}
			const Vi = Object(gi.b)(Object(i.b)(void 0, (e, t) => ({
					onGovernanceError: t => Object(bi.a)(e, t),
					onApproved: t => e(Object(hi.e)({
						kind: xi.b.SuccessCommunity,
						text: t === Ei.b.Badge ? Object(G.c)("Approved badge!") : Object(G.c)("Approved emote!")
					})),
					onRejected: t => e(Object(hi.e)({
						kind: xi.b.SuccessCommunity,
						text: t === Ei.b.Badge ? Object(G.c)("Rejected badge") : Object(G.c)("Rejected emote")
					}))
				}))(qi)),
				zi = e => r.a.createElement(Vi, Wi({
					assetType: Ei.b.Badge
				}, e)),
				Ki = e => r.a.createElement(Vi, Wi({
					assetType: Ei.b.Emote
				}, e));
			var Qi = s("./node_modules/lodash/map.js"),
				Gi = s.n(Qi),
				Ji = s("./src/reddit/actions/emoji.ts");
			const Zi = e => ({
					subreddit: y.subreddit(e),
					profile: y.profile(e),
					userSubreddit: y.userSubreddit(e)
				}),
				Xi = (e, t) => s => Object.assign({
					source: "emoji",
					action: "toggle",
					noun: e,
					actionInfo: {
						settingValue: t ? "on" : "off"
					}
				}, Zi(s)),
				Yi = e => t => Object.assign({
					source: "emoji",
					action: "click",
					noun: e
				}, Zi(t)),
				$i = (e, t) => s => Object.assign({
					source: "emoji",
					action: "click",
					noun: e,
					actionInfo: y.actionInfo(s, {
						count: t
					})
				}, Zi(s));
			var ec = s("./src/reddit/selectors/emojis.ts"),
				tc = s("./src/reddit/components/ModHub/Emojis/index.m.less"),
				sc = s.n(tc),
				nc = s("./src/reddit/controls/ImageDisplay/index.tsx");
			const ac = m.a.span("appears", sc.a),
				oc = m.a.span("buttonWrapper", sc.a),
				rc = m.a.span("displayWrapper", sc.a),
				ic = m.a.wrapped(nc.a, "emojiDisplay", sc.a),
				cc = m.a.span("emojiName", sc.a),
				dc = m.a.span("permissions", sc.a),
				lc = m.a.wrapped(me.a, "row", sc.a),
				mc = m.a.wrapped(ds.b, "trashIcon", sc.a);
			var uc = e => r.a.createElement(lc, null, r.a.createElement(rc, null, r.a.createElement(ic, {
					backgroundImage: e.emoji.url
				})), r.a.createElement(cc, null, e.emoji.name), r.a.createElement(ac, null, ((e, t) => e && t ? Object(G.c)("Post flair, user flair") : e ? Object(G.c)("Post flair") : t ? Object(G.c)("User flair") : "")(e.emoji.postFlairAllowed, e.emoji.userFlairAllowed)), r.a.createElement(dc, null, e.emoji.modFlairOnly && Object(G.c)("Mod only")), r.a.createElement(oc, null, r.a.createElement(de.n, {
					className: e.isSnoomoji ? sc.a.editSnoomoji : sc.a.editEmoji,
					onClick: () => e.onEdit(e.emoji, e.isSnoomoji)
				}, Object(G.c)("Edit")), !e.isSnoomoji && r.a.createElement("button", {
					onClick: () => e.onRemove(e.emoji.name)
				}, r.a.createElement(mc, null)))),
				pc = s("./node_modules/lodash/clamp.js"),
				bc = s.n(pc),
				hc = s("./src/reddit/controls/ToggleSwitch/index.tsx");
			const gc = m.a.span("labelDescription", sc.a),
				Ec = m.a.span("labelTitle", sc.a),
				xc = m.a.div("leftForm", sc.a),
				fc = m.a.div("rightForm", sc.a),
				vc = m.a.wrapped(hc.a, "toggleSwitch", sc.a);
			var Cc = e => r.a.createElement("div", {
				className: e.className
			}, r.a.createElement(xc, null, r.a.createElement(Ec, null, Object(G.c)("".concat(Object(G.b)("title", e.title)))), r.a.createElement(gc, null, Object(G.c)("".concat(Object(G.b)("description", e.description))))), r.a.createElement(fc, null, r.a.createElement(vc, {
				on: e.on,
				onToggle: e.onToggle
			})));
			const Oc = 40,
				jc = 16,
				yc = {
					width: 32,
					height: 32
				},
				kc = e => {
					const t = parseInt(e, 10) || 0;
					return bc()(t, 1, Oc)
				},
				wc = m.a.wrapped(ot.c, "emojiDimensionInput", sc.a),
				Sc = m.a.span("emojiDimensions", sc.a),
				Nc = m.a.span("emojiSizeBlock", sc.a),
				Tc = m.a.wrapped(Cc, "modalEnableSection", sc.a),
				_c = m.a.wrapped(at.c, "modalBody", sc.a),
				Ic = m.a.wrapped(at.a, "modalCancelButton", sc.a),
				Pc = m.a.wrapped(rt.a, "modalCloseButton", sc.a),
				Mc = m.a.wrapped(at.e, "modalFooter", sc.a),
				Rc = m.a.wrapped(de.f, "modalSubmitButton", sc.a),
				Lc = Object(c.c)({
					emojisCustomSize: (e, t) => Object(R.y)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize,
					isEmojisEnabled: (e, t) => Object(R.y)(e, {
						subredditName: t.subreddit.name
					}).emojisEnabled
				}),
				Dc = Object(i.b)(Lc, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						setCustomSize: t => e(Object(Ji.n)(s.id, t)),
						toggleEnableEmojis: t => e(Object(Ji.k)(s.id, t))
					}
				});
			class Ac extends r.a.Component {
				constructor(e) {
					super(e), this.handleEmojiSizesToggle = () => this.setState({
						customSizeEnabled: !this.state.customSizeEnabled
					}), this.handleEnableEmojisToggle = () => this.setState({
						emojisEnabled: !this.state.emojisEnabled
					}), this.handleWidthChange = e => {
						const t = kc(e.target.value);
						this.setState({
							width: t
						})
					}, this.handleHeightChange = e => {
						const t = kc(e.target.value);
						this.setState({
							height: t
						})
					}, this.enableHasBeenToggled = () => this.props.isEmojisEnabled !== this.state.emojisEnabled, this.sizeHasBeenToggled = () => !!this.props.emojisCustomSize !== this.state.customSizeEnabled, this.sizeHasBeenEdited = () => !(!this.props.emojisCustomSize || !this.state.customSizeEnabled) && (this.props.emojisCustomSize[0] !== this.state.width || this.props.emojisCustomSize[1] !== this.state.height), this.canSave = () => this.enableHasBeenToggled() || this.sizeHasBeenToggled() || this.sizeHasBeenEdited(), this.onSave = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.enableHasBeenToggled() && (e.toggleEnableEmojis(t.emojisEnabled), e.sendEvent(Xi("enable", t.emojisEnabled))), this.sizeHasBeenToggled() || this.sizeHasBeenEdited()) {
							const s = t.customSizeEnabled ? {
								width: Math.max(t.width, jc),
								height: Math.max(t.height, jc)
							} : void 0;
							e.setCustomSize(s), e.sendEvent(Xi("custom_sizing", t.customSizeEnabled))
						}
						e.toggleModal(), e.sendEvent(Yi("save_emoji_settings"))
					}, this.state = {
						customSizeEnabled: !!e.emojisCustomSize,
						emojisEnabled: e.isEmojisEnabled,
						height: e.emojisCustomSize ? e.emojisCustomSize[1] : yc.height,
						width: e.emojisCustomSize ? e.emojisCustomSize[0] : yc.width
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = t.customSizeEnabled && (t.width < jc || t.height < jc), n = s ? Object(G.c)("Invalid number, must be between ".concat(Object(G.b)("minSize", jc), " to ").concat(Object(G.b)("maxSize", Oc), "px")) : Object(G.c)("Must be between ".concat(Object(G.b)("minSize", jc), " to ").concat(Object(G.b)("maxSize", Oc), "px"));
					return r.a.createElement(_c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, Object(G.c)("Emoji settings")), r.a.createElement(Pc, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, r.a.createElement(Tc, {
						description: "Allow emojis to be used in post and user flair within your community",
						on: t.emojisEnabled,
						onToggle: this.handleEnableEmojisToggle,
						title: "Enable emojis in this community"
					}), r.a.createElement(Cc, {
						className: t.emojisEnabled ? sc.a.modalEmojiSizeSection : Object(d.a)(sc.a.modalEmojiSizeSection, sc.a.disabledSection),
						description: "Enables emojis to be displayed at custom sizes for user flair in comments. Emojis will be displayed 16 x 16px everywhere else.",
						on: t.customSizeEnabled,
						onToggle: this.handleEmojiSizesToggle,
						title: "Custom sized emojis"
					}), r.a.createElement("span", {
						className: t.emojisEnabled && t.customSizeEnabled ? sc.a.customSizesForm : Object(d.a)(sc.a.customSizesForm, sc.a.disabledSection)
					}, r.a.createElement(Nc, null, r.a.createElement(Sc, null, Object(G.c)("Width")), r.a.createElement(wc, {
						disabled: !t.customSizeEnabled || !t.emojisEnabled,
						name: "width",
						onChange: this.handleWidthChange,
						value: t.width
					})), r.a.createElement(Nc, null, r.a.createElement(Sc, null, Object(G.c)("Height")), r.a.createElement(wc, {
						disabled: !t.customSizeEnabled || !t.emojisEnabled,
						name: "height",
						onChange: this.handleHeightChange,
						value: t.height
					})), r.a.createElement("div", {
						className: s ? sc.a.sizeLimitTextWarning : sc.a.sizeLimitText
					}, n))), r.a.createElement(Mc, null, r.a.createElement(Ic, {
						onClick: e.toggleModal
					}, Object(G.c)("Cancel")), r.a.createElement(Rc, {
						disabled: !this.canSave() || s,
						onClick: this.onSave
					}, Object(G.c)("Save"))))
				}
			}
			var Fc = Object(nt.a)(Dc(Ac)),
				Bc = s("./src/reddit/components/StructuredStyles/ImageUpload/index.tsx"),
				Uc = s("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				Hc = s("./src/reddit/controls/CheckboxInput/index.tsx"),
				Wc = s("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				qc = s("./src/reddit/models/Image/index.tsx"),
				Vc = s("./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less"),
				zc = s.n(Vc),
				Kc = s("./src/higherOrderComponents/withImageUploads.tsx"),
				Qc = s("./src/reddit/models/Emoji/index.ts"),
				Gc = s("./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less"),
				Jc = s.n(Gc),
				Zc = s("./src/reddit/components/CharacterCountdown/index.tsx"),
				Xc = s("./src/reddit/components/ProgressBar/index.tsx"),
				Yc = s("./src/reddit/controls/ErrorText/index.tsx");
			const $c = 5,
				ed = 95,
				td = 600,
				sd = 100;
			class nd extends r.a.Component {
				constructor() {
					super(...arguments), this.intervalToken = 0, this.state = {
						timeStarted: Date.now(),
						percent: $c
					}, this.tick = () => {
						const e = function(e) {
							const t = e / td,
								s = (Math.log(t / 10) + 3) / 2.1;
							return Math.max(ed, Math.min($c, 100 * s))
						}(Date.now() - this.state.timeStarted);
						this.setState({
							percent: e
						}), e === ed && this.intervalToken && window.clearInterval(this.intervalToken)
					}
				}
				componentDidMount() {
					this.intervalToken = window.setInterval(this.tick, sd)
				}
				componentWillUnmount() {
					this.intervalToken && window.clearInterval(this.intervalToken)
				}
				render() {
					return r.a.createElement(Xc.a, {
						className: Jc.a.progressBar,
						innerBarClassName: Jc.a.innerBarClassName,
						percent: this.state.percent
					})
				}
			}
			var ad = nd;
			const od = m.a.wrapped(Zc.a, "characterCountdown", Jc.a),
				rd = m.a.wrapped(Fn.a, "clearIcon", Jc.a),
				id = m.a.wrapped(Yc.b, "errorText", Jc.a),
				cd = m.a.wrapped(ct.a, "expandLeft", Jc.a),
				dd = m.a.div("iconSpacer", Jc.a),
				ld = m.a.wrapped(nc.a, "imageDisplay", Jc.a),
				md = m.a.div("inputPlaceholder", Jc.a),
				ud = m.a.wrapped(ct.a, "inputPlaceholder", Jc.a),
				pd = m.a.wrapped(rt.a, "textButton", Jc.a);
			class bd extends r.a.Component {
				constructor() {
					super(...arguments), this.handleChangeEmojiName = e => {
						this.props.onChangeEmojiName && this.props.onChangeEmojiName(this.props.index, e.target.value)
					}, this.handleRemove = e => {
						this.props.onCancel(this.props.index)
					}, this.renderContent = () => {
						const {
							emojiName: e,
							errorText: t,
							fileName: s,
							handleRetry: n,
							imageData: a,
							isDuplicate: o,
							language: i
						} = this.props;
						switch (a.kind) {
							case qc.b.NotUploaded:
							case qc.b.Pending:
								return r.a.createElement("div", null, r.a.createElement(ud, null, a.kind === qc.b.NotUploaded ? r.a.createElement(ad, null) : r.a.createElement(Xc.a, {
									className: Jc.a.progressBar,
									innerBarClassName: Jc.a.innerBarClassName,
									percent: 0
								}), r.a.createElement(pd, {
									onClick: this.handleRemove
								}, Object(G.c)("Cancel"))), r.a.createElement(Uc.b, null, Object(G.c)("Uploading ".concat(Object(G.b)("fileName", s)))));
							case qc.b.FailedToUpload:
							case qc.b.Invalid:
								return r.a.createElement("div", null, r.a.createElement(ud, null, Object(G.c)("Failed to upload"), n ? r.a.createElement(pd, {
									onClick: n
								}, Object(G.c)("Retry")) : r.a.createElement(pd, {
									onClick: this.handleRemove
								}, Object(G.c)("Remove"))), t && r.a.createElement(id, {
									language: i
								}, t));
							case qc.b.Uploaded:
								return r.a.createElement(md, null, Object(G.c)("Saved"));
							default:
								return r.a.createElement("div", null, r.a.createElement(ot.c, {
									className: o ? Jc.a.duplicateInput : Jc.a.input,
									onChange: this.handleChangeEmojiName,
									placeholder: Object(G.c)("Emoji name"),
									value: e
								}), r.a.createElement(cd, null, r.a.createElement(od, {
									maxChars: Qc.d,
									text: e
								}), r.a.createElement(pd, {
									onClick: this.handleRemove
								}, Object(G.c)("Remove"))), t && r.a.createElement(id, {
									language: i
								}, t))
						}
					}
				}
				render() {
					const {
						emojiName: e,
						imageData: t,
						isSaving: s
					} = this.props;
					return s ? r.a.createElement(r.a.Fragment, null, r.a.createElement(md, null, r.a.createElement(ad, null)), r.a.createElement(Uc.b, null, Object(G.c)("Saving ".concat(Object(G.b)("emojiName", e))))) : r.a.createElement(Wc.a, null, t.kind === qc.b.FailedToUpload || t.kind === qc.b.Invalid ? r.a.createElement(dd, null, r.a.createElement(rd, null)) : r.a.createElement(ld, {
						backgroundImage: t.url
					}), this.renderContent())
				}
			}
			var hd = bd,
				gd = (s("./node_modules/core-js/modules/es6.regexp.replace.js"), s("./node_modules/lodash/countBy.js")),
				Ed = s.n(gd),
				xd = s("./node_modules/lodash/includes.js"),
				fd = s.n(xd),
				vd = s("./node_modules/lodash/transform.js"),
				Cd = s.n(vd);
			const Od = /^[A-Za-z0-9_-]{1,24}$/,
				jd = ["reddit", "snoo", "spez"],
				yd = (e, t, s) => !Od.test(e) || !s && (e => {
					const t = e.toLowerCase();
					return jd.reduce((e, s) => e || -1 !== t.indexOf(s), !1)
				})(e) ? Object(G.c)("Invalid emoji name") : fd()(t, e) ? Object(G.c)("This name is already taken") : "",
				kd = e => e.name ? e.name.replace(/\.[^.]*$/, "").replace(/[^A-Za-z0-9_-]/g, " ").trim().replace(/ +/g, "_").slice(0, 24) : "",
				wd = (e, t) => (t.kind !== qc.b.TempUploaded || !e.emojiNameError && !e.isNameMissing) && (t.kind !== qc.b.NotUploaded && t.kind !== qc.b.Pending),
				Sd = e => {
					let t = "";
					return e.file.size > Qc.a ? t = "file-size-error" : (e.height > Qc.b || e.width > Qc.c) && (t = "image-size-error"), {
						emojiNameError: "",
						imageError: t,
						name: kd(e.file),
						fileName: e.file.name,
						isNameMissing: !1
					}
				},
				Nd = (e, t) => t.reduce((t, s) => s.kind === e ? t + 1 : t, 0),
				Td = (e, t) => {
					const {
						emojiNameError: s,
						imageError: n,
						isNameMissing: a
					} = t;
					let o = "";
					e.kind === qc.b.FailedToUpload && (o = e.error.fields && e.error.fields.length ? e.error.fields[0].msg : Object(G.c)("Something went wrong"));
					const r = o || !1,
						i = s || !!a && Object(G.c)("Emoji name is required");
					let c = "";
					return "file-size-error" === n ? c = Object(G.c)("File size too large") : "image-size-error" === n && (c = Object(G.c)("Image size too large")), c || r || i || ""
				},
				_d = e => {
					const t = ua()(e, e => !e.emojiNameError && !e.imageError),
						s = Ed()(t, e => e.name);
					return Cd()(s, (e, t, s) => {
						t > 1 && e.push(s)
					}, [])
				},
				Id = 500,
				Pd = m.a.div("UploaderContainer", Jc.a),
				Md = m.a.wrapped(sa.a, "alertIcon", Jc.a),
				Rd = m.a.wrapped(Fn.a, "duplicatesIcon", Jc.a),
				Ld = m.a.wrapped(at.m, "duplicateWarning", Jc.a),
				Dd = m.a.wrapped(de.f, "modalAddButton", Jc.a),
				Ad = m.a.wrapped(at.a, "modalCancelButton", Jc.a),
				Fd = m.a.div("uploaderContainer", Jc.a),
				Bd = m.a.wrapped(at.m, "modProTip", Jc.a),
				Ud = m.a.div("progressText", Jc.a),
				Hd = m.a.wrapped(at.m, "replacingDescription", Jc.a),
				Wd = m.a.div("replacingTitle", Jc.a),
				qd = m.a.div("uploadingTitle", Jc.a),
				Vd = Object(c.c)({
					emojis: ec.d,
					isSnoomojiSubreddit: R.m,
					language: L.S,
					reservedEmojiNames: ec.e
				}),
				zd = Object(i.b)(Vd, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						emojisUploadedToast: () => e(hi.e({
							kind: xi.b.SuccessCommunityGreen,
							text: Object(G.c)("New emojis added!")
						})),
						saveEmoji: (t, n, a) => e(Object(Ji.p)({
							imageData: t,
							subredditId: s,
							emojiName: n,
							settings: a
						}))
					}
				});
			class Kd extends r.a.Component {
				constructor(e) {
					super(e), this.timeoutToken = 0, this.loadIndex = 0, this.tempUploadNext = async () => {
						const e = this.getNextPendingImageToLoad();
						if (!e) return this.timeoutToken = 0, void(this.loadIndex = 0);
						const {
							subredditId: t
						} = this.props, s = this.state.emojiData[e.id], n = Object(qc.m)(e);
						await this.props.uploadImage({
							imageData: n,
							subredditId: t,
							emojiName: s.name,
							settings: this.props.emojiSettings
						}), this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(this.tempUploadNext, Id) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.emojiIsADuplicate = (e, t) => e && t && t.some(t => t.id === e.id), this.saveNext = e => {
						const t = this.getNextTempUploadedImageToSave();
						if (!t) return this.timeoutToken = 0, void(this.loadIndex = 0);
						if (!this.emojiIsADuplicate(t, e)) {
							const e = this.state.emojiData[t.id],
								s = this.props.saveEmoji(t, e.name, this.props.emojiSettings);
							this.setState({
								emojisUploaded: this.state.emojisUploaded || s
							})
						}
						this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(() => this.saveNext(e), Id) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.onChangeEmojiName = (e, t) => {
						const {
							isSnoomojiSubreddit: s,
							reservedEmojiNames: n
						} = this.props;
						if (t.length > Qc.d) return;
						const a = this.state.isReplacing ? this.state.replacingEmoji && this.state.replacingEmoji[e] : this.state.localData[e];
						if (!a) return;
						const o = this.state.emojiData,
							r = o[a.id],
							i = t ? yd(t, n, s) : "";
						o[a.id].emojiNameError = i, o[a.id].name = t;
						const c = _d(o);
						this.setState({
							duplicateNames: c,
							emojiData: Object.assign({}, this.state.emojiData, {
								[a.id]: Object.assign({}, r, {
									emojiNameError: i,
									isNameMissing: !t,
									name: t
								})
							})
						})
					}, this.canSave = () => {
						let e = !1;
						for (const t of this.state.localData) {
							if (!wd(this.state.emojiData[t.id], t)) return !1;
							t.kind === qc.b.TempUploaded && (e = !0)
						}
						return e
					}, this.getValidatedState = () => {
						const {
							isSnoomojiSubreddit: e,
							reservedEmojiNames: t
						} = this.props, s = {};
						for (const n of this.state.localData) {
							let a = this.state.emojiData[n.id];
							const o = yd(a.name, t, e);
							a.name && !o || (a = Object.assign({}, a, {
								emojiNameError: o,
								isNameMissing: !a.name
							})), s[n.id] = a
						}
						return {
							emojiData: s
						}
					}, this.onApply = () => {
						const e = this.getValidatedState();
						this.setState(e, () => {
							if (this.canSave()) {
								const e = this.props.emojis[this.props.subredditId].emojis,
									t = [];
								for (const n of this.state.localData) {
									if (n.kind !== qc.b.TempUploaded) continue;
									this.state.emojiData[n.id].name in e && t.push(n)
								}
								t.length ? (this.setState({
									replacingEmoji: t,
									isReplacing: !0
								}), this.saveNext(t)) : (this.setState({
									isSavingImage: !0
								}), this.props.setIsSaving(!0), this.saveNext());
								const s = Nd(qc.b.TempUploaded, this.state.localData) - t.length;
								s > 0 && (this.props.sendEvent($i("add", s)), this.sendSettingsEvent())
							}
						})
					}, this.sendSettingsEvent = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: s
						} = this.props.emojiSettings;
						this.props.sendEvent(Xi("mods_only", e)), this.props.sendEvent(Xi("appear_user_flair", t)), this.props.sendEvent(Xi("appear_post_flair", s))
					}, this.handleSaveAndReplace = () => {
						this.setState({
							isReplacing: !1,
							isSavingImage: !0
						}), this.props.setIsSaving(!0);
						const {
							replacingEmoji: e
						} = this.state, t = e ? e.length : 0;
						this.saveNext(), t > 0 && (this.props.sendEvent($i("replace", t)), this.sendSettingsEvent())
					}, this.handleCancelReplace = () => {
						this.setState({
							isReplacing: !1,
							replacingEmoji: null
						}), this.props.stopEditing(), this.props.sendEvent(Yi("dont_replace"))
					}, this.findEmojiIndexById = e => this.state.localData.findIndex(t => t.id === e), this.removeEmoji = e => {
						const {
							isReplacing: t,
							localData: s,
							replacingEmoji: n
						} = this.state;
						let a, o = e;
						t && n && n[e] && (o = this.findEmojiIndexById(n[e].id), (a = n.slice(0)).splice(e, 1), this.setState({
							replacingEmoji: a
						}));
						const r = s[o],
							i = s.slice(0);
						i.splice(o, 1);
						const c = Object.assign({}, this.state.emojiData);
						delete c[r.id], this.setState({
							duplicateNames: _d(c),
							emojiData: c,
							localData: i
						}), t && n ? 0 === a.length && this.props.returnToAddState() : 0 === i.length && this.props.returnToAddState()
					}, this.retryEmojiUpload = () => {
						this.props.returnToAddState()
					};
					const t = {},
						s = [];
					for (const n of e.images) {
						const e = Sd(n);
						t[n.id] = e, e.imageError ? s.push(Object(qc.l)(n, e.imageError)) : s.push(n)
					}
					this.state = {
						duplicateNames: _d(t),
						emojiData: t,
						emojisUploaded: !1,
						isReplacing: !1,
						isSavingImage: !1,
						localData: s,
						replacingEmoji: null
					}
				}
				componentWillMount() {
					this.loadIndex = 0, this.tempUploadNext()
				}
				getNextPendingImageToLoad() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const s = this.state.localData[e];
						if (s.kind === qc.b.Pending) {
							t = s;
							break
						}
					}
					return this.loadIndex = e, t
				}
				getNextTempUploadedImageToSave() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const s = this.state.localData[e];
						if (s.kind === qc.b.TempUploaded) {
							t = s;
							break
						}
					}
					return this.loadIndex = e, t
				}
				componentWillReceiveProps(e) {
					const t = e.getImageUploadsIfModified(this.state.localData);
					if (!t) return;
					let s = !1;
					const {
						isSavingImage: n
					} = this.state, a = {};
					for (const o of t) a[o.id] = this.state.emojiData[o.id], s = s || o.kind === qc.b.TempUploaded;
					!n || s ? (this.props.setIsSaving(n), this.setState({
						emojiData: a,
						isSavingImage: n,
						localData: t
					})) : this.props.stopEditing()
				}
				componentWillUnmount() {
					for (const e of this.state.localData) this.props.cancelUpload(e);
					this.timeoutToken && window.clearTimeout(this.timeoutToken), this.state.emojisUploaded && this.props.emojisUploadedToast(), this.setState({
						emojisUploaded: !1,
						isReplacing: !1
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = t.isReplacing ? t.replacingEmoji || [] : t.localData;
					return r.a.createElement(Pd, null, r.a.createElement(Fd, null, t.duplicateNames.length > 0 ? r.a.createElement(Ld, null, r.a.createElement(Rd, null), Object(G.c)("Duplicate names")) : !t.isReplacing && r.a.createElement(Bd, null, r.a.createElement(Md, null), Object(G.c)("Names cannot be edited once added")), r.a.createElement(at.j, null, t.isReplacing ? r.a.createElement(r.a.Fragment, null, r.a.createElement(Wd, null, Object(G.c)("Replacing emojis")), r.a.createElement(Hd, null, Object(G.c)("These emoji names already exist in your community. Replacing these emojis will not change pre-existing permissions. Do you want to replace them?"))) : r.a.createElement(qd, null, Object(G.c)("Uploading emojis")), r.a.createElement("div", {
						className: !t.isReplacing && Jc.a.emojiDisplays
					}, s.map((s, n) => {
						const a = this.state.emojiData[s.id],
							o = s.kind === qc.b.FailedToUpload || s.kind === qc.b.Invalid,
							i = t.replacingEmoji && !t.replacingEmoji.find(e => e.id === s.id);
						if (t.isSavingImage && (o || i)) return;
						const c = Td(s, a);
						return r.a.createElement(Uc.a, {
							key: s.id
						}, r.a.createElement(hd, {
							emojiName: a.name,
							errorText: c,
							fileName: a.fileName,
							imageData: s,
							index: n,
							isDuplicate: t.duplicateNames.includes(a.name),
							isSaving: t.isSavingImage,
							language: e.language,
							onCancel: this.removeEmoji,
							onChangeEmojiName: this.onChangeEmojiName
						}))
					})), !t.isReplacing && r.a.createElement(Ud, null, t.isSavingImage ? Object(G.c)("".concat(Object(G.b)("savedCount", Nd(qc.b.Uploaded, t.localData)), "                       out of ").concat(Object(G.b)("savedTotal", t.localData.length), " saved")) : Object(G.c)("".concat(Object(G.b)("uploadedCount", Nd(qc.b.TempUploaded, t.localData)), "                       out of ").concat(Object(G.b)("uploadedTotal", t.localData.length), " uploaded"))))), r.a.createElement(at.e, null, r.a.createElement(Ad, {
						disabled: t.isSavingImage,
						onClick: t.isReplacing ? this.handleCancelReplace : e.stopEditing
					}, t.isReplacing ? Object(G.c)("Don't replace") : Object(G.c)("Cancel")), r.a.createElement(Dd, {
						disabled: t.isSavingImage || !this.canSave() || t.duplicateNames.length > 0,
						onClick: t.isReplacing ? this.handleSaveAndReplace : this.onApply
					}, t.isReplacing ? Object(G.c)("Replace") : Object(G.c)("Add"))))
				}
			}
			var Qd = Object(Kc.a)(zd(Kd), Ji.q),
				Gd = s("./src/reddit/actions/imageUploads.ts"),
				Jd = s("./src/reddit/selectors/imageUploads.ts");
			const Zd = m.a.div("UploaderContainer", Jc.a),
				Xd = m.a.wrapped(Zd, "editEmojiDisplay", Jc.a),
				Yd = Object(c.c)({
					language: L.S,
					reduxImage: (e, t) => {
						let {
							pendingImage: s
						} = t;
						const n = Object(Jd.a)(e),
							a = s && s.id;
						return a && n[a] || void 0
					}
				});
			class $d extends r.a.Component {
				constructor(e) {
					super(e), this.onCancelAndRetry = () => {
						this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage), this.props.onRetryUpload()
					}
				}
				componentDidMount() {
					const e = Object(qc.m)(this.props.pendingImage);
					this.props.uploadImage({
						imageData: e,
						subredditId: this.props.subredditId,
						emojiName: this.props.emoji.name,
						settings: this.props.emojiSettings
					})
				}
				componentDidUpdate(e) {
					this.props.reduxImage && this.props.reduxImage !== e.reduxImage && this.props.onImageChange(this.props.reduxImage)
				}
				componentWillUnmount() {
					this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage)
				}
				render() {
					const {
						language: e,
						pendingImage: t,
						reduxImage: s,
						emoji: n
					} = this.props, a = Sd(t), o = Object(qc.l)(t, a.imageError), i = a.imageError ? o : s || t, c = Td(i, a);
					return !c && i.kind === qc.b.TempUploaded || i.kind === qc.b.Uploaded ? null : r.a.createElement(Xd, null, r.a.createElement(hd, {
						emojiName: n.name,
						errorText: c,
						fileName: a.fileName,
						handleRetry: this.onCancelAndRetry,
						imageData: i,
						index: 0,
						isSaving: !1,
						language: e,
						onCancel: this.onCancelAndRetry
					}))
				}
			}
			var el = Object(i.b)(Yd, e => ({
				uploadImage: t => e(Object(Ji.q)(t)),
				cancelUpload: t => e(Object(Gd.h)(t))
			}))($d);

			function tl() {
				return (tl = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const sl = 32,
				nl = 128,
				al = 64,
				ol = 100,
				rl = m.a.div("appearsIn", zc.a),
				il = m.a.wrapped(Hc.a, "checkbox", zc.a),
				cl = m.a.span("checkboxText", zc.a),
				dl = m.a.wrapped(rt.a, "closeButton", zc.a),
				ll = m.a.div("imageTitle", zc.a),
				ml = m.a.wrapped(de.f, "modalAddButton", zc.a),
				ul = m.a.wrapped(at.c, "modalBody", zc.a),
				pl = m.a.wrapped(at.a, "modalCancelButton", zc.a),
				bl = m.a.wrapped(at.j, "modalMain", zc.a),
				hl = m.a.wrapped(Cc, "modFlairOnlyToggle", zc.a),
				gl = m.a.wrapped(ta.a, "modIcon", zc.a),
				El = m.a.li("modProTip", zc.a),
				xl = m.a.div("modProTips", zc.a),
				fl = m.a.div("modProTipTitle", zc.a),
				vl = m.a.div("proTip", zc.a),
				Cl = m.a.ul("tipList", zc.a),
				Ol = e => !!e && (e.kind === qc.b.Pending ? !!Sd(e).imageError : e.kind === qc.b.FailedToUpload);
			var jl;
			! function(e) {
				e[e.AddState = 0] = "AddState", e[e.SingleEmojiEditState = 1] = "SingleEmojiEditState", e[e.BulkUploadState = 2] = "BulkUploadState"
			}(jl || (jl = {}));
			const yl = m.a.wrapped(Wc.a, "emojiDisplay", zc.a),
				kl = m.a.div("emojiNameDisplay", zc.a),
				wl = m.a.wrapped(nc.a, "imageDisplay", zc.a),
				Sl = e => r.a.createElement(yl, null, r.a.createElement(wl, {
					backgroundImage: e.url
				}), r.a.createElement(kl, null, e.emojiName)),
				Nl = Object(c.c)({
					emojisCustomSize: (e, t) => Object(R.y)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize
				}),
				Tl = Object(i.b)(Nl, (e, t) => {
					let {
						emoji: s,
						isSnoomoji: n,
						subreddit: a
					} = t;
					return {
						saveEmoji: (t, s, n) => e(Ji.p({
							imageData: n,
							subredditId: a.id,
							emojiName: t,
							settings: s
						})),
						saveEmojiSettings: t => {
							s && e(Ji.o(s.name, n, t, a.id))
						},
						saveEmojiSuccessToast: () => e(hi.e({
							kind: xi.b.SuccessCommunityGreen,
							text: Object(G.c)("Emoji edits saved!")
						}))
					}
				});
			class _l extends r.a.Component {
				constructor(e) {
					super(e), this.closeModal = () => {
						this.props.toggleModal()
					}, this.clearImageData = () => {
						this.setState({
							imageData: [],
							emojiDraftImage: void 0
						})
					}, this.onEditingImageChange = e => {
						this.setState({
							emojiDraftImage: e
						})
					}, this.handleMultiImageInput = async e => {
						let t;
						const s = this.state.emojiState === jl.SingleEmojiEditState;
						s && this.clearImageData(), t = Array.isArray(e) ? s ? e.slice(0, 1) : e.slice(0, ol) : [e];
						const n = await Promise.all(t.map(qc.f));
						s ? this.setState({
							imageData: n
						}) : this.setState({
							emojiState: jl.BulkUploadState,
							imageData: n
						})
					}, this.handleModExclusiveToggle = () => this.setState({
						settings: Object.assign({}, this.state.settings, {
							modFlairOnly: !this.state.settings.modFlairOnly
						})
					}), this.handleTogglePostFlair = () => this.setState({
						settings: Object.assign({}, this.state.settings, {
							postFlairAllowed: !this.state.settings.postFlairAllowed
						})
					}), this.handleToggleUserFlair = () => this.setState({
						settings: Object.assign({}, this.state.settings, {
							userFlairAllowed: !this.state.settings.userFlairAllowed
						})
					}), this.returnToAdd = () => {
						this.setState({
							emojiState: jl.AddState
						}), this.clearImageData()
					}, this.sendToggleEvent = (e, t) => this.props.sendEvent(Xi(e, t)), this.modFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.modFlairOnly !== this.state.settings.modFlairOnly, this.userFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.userFlairAllowed !== this.state.settings.userFlairAllowed, this.postFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.postFlairAllowed !== this.state.settings.postFlairAllowed, this.settingsHaveBeenChanged = () => this.modFlairSettingHasChanged() || this.userFlairSettingHasChanged() || this.postFlairSettingHasChanged(), this.sendTelemetryEvents = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: s
						} = this.state.settings;
						this.modFlairSettingHasChanged() && this.sendToggleEvent("mods_only", e), this.userFlairSettingHasChanged() && this.sendToggleEvent("appear_user_flair", t), this.postFlairSettingHasChanged() && this.sendToggleEvent("appear_post_flair", s)
					}, this.saveEmoji = async () => {
						const {
							props: e,
							state: t
						} = this, s = {
							modFlairOnly: t.settings.modFlairOnly,
							postFlairAllowed: t.settings.postFlairAllowed,
							userFlairAllowed: t.settings.userFlairAllowed
						};
						if (this.setIsSaving(!0), e.emoji) {
							if (e.isSnoomoji || e.emoji && !t.emojiDraftImage) e.saveEmojiSettings(s);
							else if (e.emoji && t.emojiDraftImage && t.emojiDraftImage.kind === qc.b.TempUploaded) {
								await e.saveEmoji(e.emoji.name, s, t.emojiDraftImage) && e.saveEmojiSuccessToast()
							}
							this.sendTelemetryEvents()
						}
						this.closeModal(), this.setIsSaving(!1)
					}, this.setIsSaving = e => this.setState({
						isSaving: e
					}), this.state = {
						emojiState: e.emoji ? jl.SingleEmojiEditState : jl.AddState,
						imageData: [],
						isSaving: !1,
						settings: {
							modFlairOnly: !!e.emoji && e.emoji.modFlairOnly,
							postFlairAllowed: !e.emoji || e.emoji.postFlairAllowed,
							userFlairAllowed: !e.emoji || e.emoji.userFlairAllowed
						}
					}
				}
				render() {
					const {
						emoji: e,
						emojisCustomSize: t,
						isSnoomoji: s,
						sendEvent: n,
						subreddit: a
					} = this.props, {
						emojiDraftImage: o,
						emojiState: i,
						imageData: c,
						isSaving: d,
						settings: l
					} = this.state, m = {
						emojiSettings: l,
						stopEditing: this.closeModal,
						subredditId: a.id
					}, u = 2 * (t ? t[0] : sl), p = 2 * (t ? t[1] : sl), b = c.length > 0 ? c[0] : void 0, h = b && b.url, g = o && o.url, E = h || g, x = o && o.kind === qc.b.TempUploaded, f = Ol(b || o), v = i !== jl.SingleEmojiEditState || (!this.settingsHaveBeenChanged() && !x || f);
					return r.a.createElement(ul, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, e ? Object(G.c)("Edit emoji") : Object(G.c)("Add new emojis")), r.a.createElement(dl, {
						disabled: d,
						onClick: this.closeModal
					}, r.a.createElement(at.b, null)))), (i === jl.AddState || i === jl.SingleEmojiEditState) && r.a.createElement(r.a.Fragment, null, i === jl.AddState && r.a.createElement(xl, null, r.a.createElement(fl, null, r.a.createElement(gl, null), Object(G.c)("Mod pro tips!")), r.a.createElement(Cl, null, r.a.createElement(El, null, Object(G.c)("Emoji names will use the image file name and will be editable once uploaded")), r.a.createElement(El, null, Object(G.c)("You can upload up to ".concat(Object(G.b)("maxUpload", ol), " emojis at once"))))), r.a.createElement(bl, null, i === jl.SingleEmojiEditState && e && r.a.createElement(Sl, {
						emojiName: e.name,
						url: E || e.url
					}), !s && r.a.createElement(r.a.Fragment, null, r.a.createElement(Uc.i, null, r.a.createElement(ll, null, e ? Object(G.c)("Image") : Object(G.c)("Images")), e && i === jl.SingleEmojiEditState && b && r.a.createElement(el, tl({}, m, {
						emoji: e,
						onRetryUpload: this.clearImageData,
						pendingImage: b,
						onImageChange: this.onEditingImageChange
					})), (!c.length || x) && !(e && f) && r.a.createElement(Bc.b, {
						label: Object(G.c)("Drag and Drop or Upload Image"),
						onChange: this.handleMultiImageInput,
						multiple: !0
					}), r.a.createElement(Uc.b, null, Object(G.c)("Max upload dimensions ".concat(Object(G.b)("MAX_EMOJI_DIMENSION", nl), " x ").concat(Object(G.b)("MAX_EMOJI_DIMENSION", nl), "px"))), r.a.createElement(Uc.b, null, Object(G.c)("Max file size ".concat(Object(G.b)("MAX_FILE_SIZE", al), "KB")))), r.a.createElement(vl, null, Object(G.c)("Recommended upload dimensions: ".concat(Object(G.b)("recommendedWidth", u), " x ").concat(Object(G.b)("recommendedHeight", p), "px")))), r.a.createElement(rl, null, Object(G.c)("Appears in:")), r.a.createElement(il, {
						name: "postFlair",
						onChange: this.handleTogglePostFlair,
						value: l.postFlairAllowed
					}, r.a.createElement(cl, null, Object(G.c)("Post flair"))), r.a.createElement(il, {
						name: "userFlair",
						onChange: this.handleToggleUserFlair,
						value: l.userFlairAllowed
					}, r.a.createElement(cl, null, Object(G.c)("User flair"))), r.a.createElement(hl, {
						description: "Only appears in post and user flair that are restricted for mod use.",
						on: l.modFlairOnly,
						onToggle: this.handleModExclusiveToggle,
						title: "Mod only"
					})), r.a.createElement(at.e, null, r.a.createElement(pl, {
						disabled: d,
						onClick: this.closeModal
					}, Object(G.c)("Cancel")), r.a.createElement(ml, {
						disabled: v,
						onClick: this.saveEmoji
					}, e ? Object(G.c)("Save") : Object(G.c)("Add")))), i === jl.BulkUploadState && r.a.createElement(Qd, tl({}, m, {
						images: c,
						returnToAddState: this.returnToAdd,
						sendEvent: n,
						setIsSaving: this.setIsSaving
					})))
				}
			}
			var Il = Object(nt.a)(Tl(_l));
			const Pl = m.a.wrapped(sa.a, "alertIcon", sc.a),
				Ml = m.a.span("appearsTitle", sc.a),
				Rl = m.a.span("imageTitle", sc.a),
				Ll = m.a.span("nameTitle", sc.a),
				Dl = m.a.span("permissionsTitle", sc.a),
				Al = m.a.wrapped(de.i, "settingsButton", sc.a),
				Fl = m.a.wrapped(_n.a, "titleTooltip", sc.a),
				Bl = m.a.wrapped(ke, "topRow", sc.a),
				Ul = Object(c.c)({
					emojis: ec.d,
					isConfirmModalOpen: Object(tt.b)("EmojiManager--DeleteEmojiConfirmation--Modal"),
					isEmojisEnabled: (e, t) => Object(ec.b)(e, t.subreddit.name),
					isEmojiSettingsModalOpen: Object(tt.b)("EmojiManager--Settings--Modal"),
					isUploadEmojisModalOpen: Object(tt.b)("EmojiManager--UploadEmojis--Modal")
				});
			class Hl extends r.a.Component {
				constructor(e) {
					super(e), this.onClickEditEmoji = (e, t) => {
						this.props.toggleUploadEmojisModal(), this.setState({
							emojiToEdit: e,
							isSnoomoji: t
						})
					}, this.onConfirmDelete = () => {
						this.props.deleteEmoji(this.state.emojiNameToDelete), this.setState({
							emojiNameToDelete: ""
						}), this.props.sendEvent(Yi("delete"))
					}, this.handleRemoveEmoji = e => {
						this.setState({
							emojiNameToDelete: e
						}), this.props.toggleDeleteConfirmationModal()
					}, this.state = {
						emojiNameToDelete: "",
						emojiToEdit: null,
						isSnoomoji: !1
					}
				}
				static getDerivedStateFromProps(e, t) {
					return t.emojiToEdit && !e.isUploadEmojisModalOpen ? {
						emojiToEdit: null,
						isSnoomoji: !1
					} : null
				}
				render() {
					const {
						emojis: e,
						isConfirmModalOpen: t,
						isEmojisEnabled: s,
						isEmojiSettingsModalOpen: n,
						isUploadEmojisModalOpen: a,
						sendEvent: o,
						subreddit: i,
						toggleDeleteConfirmationModal: c,
						toggleSettingsModal: d,
						toggleUploadEmojisModal: l
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(Al, {
						onClick: d
					}, Object(G.c)("Emoji settings")), r.a.createElement(de.f, {
						onClick: l
					}, Object(G.c)("Add emoji"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Emoji management"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360010560371")
					})), !s && r.a.createElement(Tn.a, {
						className: sc.a.emojisDisabled,
						color: qn.a.quarantine,
						icon: r.a.createElement(Pl, null),
						subtitle: Object(G.c)("Emojis in flairs will not be displayed, and existing emojis will appear as plain text."),
						title: Object(G.c)("Emojis have been disabled for this community")
					}), r.a.createElement(Bl, null, r.a.createElement(Rl, null, Object(G.c)("Image")), r.a.createElement(Ll, null, Object(G.c)("Name")), r.a.createElement(Ml, null, Object(G.c)("Appears in"), r.a.createElement(Fl, {
						text: Object(G.c)("Set emoji to appear in post flair or user flair")
					})), r.a.createElement(Dl, null, Object(G.c)("Settings"), r.a.createElement(Fl, {
						text: Object(G.c)("Set emoji to only appear in mod-only flair")
					}))), e[i.id] && Gi()(e[i.id].emojis, e => r.a.createElement(uc, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !1,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), e[i.id] && Gi()(e[i.id].snoomojis, e => r.a.createElement(uc, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !0,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), t && r.a.createElement(U.a, {
						toggleModal: c,
						onConfirm: this.onConfirmDelete,
						actionText: Object(G.c)("Delete"),
						headerText: Object(G.c)("Delete emoji?"),
						modalText: Object(G.c)("Do you wish to delete this emoji?"),
						trackClick: () => {},
						withOverlay: !0
					}), n && r.a.createElement(Fc, {
						sendEvent: o,
						subreddit: i,
						toggleModal: d,
						withOverlay: !0
					}), a && r.a.createElement(Il, {
						emoji: this.state.emojiToEdit,
						isSnoomoji: this.state.isSnoomoji,
						sendEvent: o,
						subreddit: i,
						toggleModal: l,
						withOverlay: !0
					})))
				}
			}
			var Wl = Object(i.b)(Ul, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						deleteEmoji: t => e(Ji.j(t, s.id)),
						toggleDeleteConfirmationModal: () => e(Object(F.i)("EmojiManager--DeleteEmojiConfirmation--Modal")),
						toggleSettingsModal: () => e(Object(F.i)("EmojiManager--Settings--Modal")),
						toggleUploadEmojisModal: () => e(Object(F.i)("EmojiManager--UploadEmojis--Modal"))
					}
				})(Object(x.b)(Hl)),
				ql = s("./src/reddit/actions/postFlair.ts"),
				Vl = s("./src/reddit/selectors/postFlair.ts"),
				zl = s("./src/reddit/selectors/structuredStyles.ts"),
				Kl = s("./src/reddit/components/BlockNavigation/index.tsx"),
				Ql = s("./src/reddit/components/StructuredStyles/DragItem/index.tsx"),
				Gl = s("./src/reddit/controls/Sortable/index.tsx");
			const Jl = e => e === nn.d.LinkFlair ? "postflairmanagement" : "userflairmanagement",
				Zl = e => Object.assign({}, y.defaults(e), {
					subreddit: y.subreddit(e),
					userSubreddit: y.userSubreddit(e)
				}),
				Xl = e => t => s => Object.assign({}, Zl(s), {
					source: Jl(t),
					action: "click",
					noun: e
				}),
				Yl = e => (t, s) => n => Object.assign({}, Zl(n), {
					source: Jl(t),
					action: "toggle",
					noun: e,
					actionInfo: y.actionInfo(n, {
						settingValue: s ? "on" : "off"
					})
				}),
				$l = Xl("remove"),
				em = Xl("edit"),
				tm = Xl("save_settings"),
				sm = Xl("add"),
				nm = Yl("assign_own"),
				am = Yl("enable"),
				om = Yl("mods_only"),
				rm = Yl("edit_text"),
				im = (e, t) => t ? sm(e) : em(e),
				cm = e => Yl("post_flair_template")(nn.d.LinkFlair, e),
				dm = (e, t) => s => Object.assign({}, Zl(s), {
					source: Jl(e),
					action: "click",
					noun: "reorder",
					actionInfo: y.actionInfo(s, {
						count: t
					})
				}),
				lm = {
					[nn.a.All]: "text_and_emoji",
					[nn.a.Emoji]: "emoji_only",
					[nn.a.Text]: "text_only"
				},
				mm = (e, t) => {
					return Xl(lm[t] || "text_and_emoji")(e)
				},
				um = (e, t) => s => Object.assign({}, Zl(s), {
					source: Jl(e),
					action: "click",
					noun: "limit_number_emojis",
					actionInfo: y.actionInfo(s, {
						settingValue: t
					})
				});
			var pm, bm = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairsDisabledBanner/index.m.less"),
				hm = s.n(bm),
				gm = e => r.a.createElement(Tn.a, {
					className: e.className,
					color: qn.a.quarantine,
					icon: r.a.createElement(sa.a, {
						className: hm.a.icon
					}),
					subtitle: e.flairTemplateType === nn.d.UserFlair ? Object(G.c)("User flairs will not be visible until feature is enabled") : Object(G.c)("Post flairs will not be visible until feature is enabled"),
					title: e.flairTemplateType === nn.d.UserFlair ? Object(G.c)("User flair is disabled") : Object(G.c)("Post flair is disabled")
				}),
				Em = s("./src/reddit/controls/LoadingIcon/index.tsx"),
				xm = s("./src/reddit/components/ModHub/flairs/FlairManagement/LabeledControl/index.m.less"),
				fm = s.n(xm);
			! function(e) {
				e[e.Top = 0] = "Top", e[e.Left = 1] = "Left"
			}(pm || (pm = {}));
			const vm = e => e.preventDefault();
			var Cm = e => r.a.createElement("div", {
					className: Object(d.a)(e.className, fm.a.container)
				}, r.a.createElement("label", {
					className: e.labelPosition === pm.Top ? fm.a.topLabel : fm.a.leftLabel,
					onClick: e.preventDefaultLabelClick ? vm : void 0
				}, r.a.createElement("span", {
					className: Object(d.a)(fm.a.labelText, e.labelClassName)
				}, e.label), e.children)),
				Om = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairSettingsModal/index.m.less"),
				jm = s.n(Om);
			class ym extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.isUnmounted = !1, this.state = {
						settings: this.props.settings,
						isPending: !1
					}, this.onSaveButtonClick = async () => {
						const {
							settings: e
						} = this.state;
						if (_s()(this.props.settings, e)) return void this.props.onClose();
						this.setState({
							isPending: !0
						}), this.sendOnSaveEvents();
						const t = await this.props.onSave(e);
						this.isUnmounted || (this.setState({
							isPending: !1
						}), t && this.props.onClose())
					}, this.sendOnSaveEvents = () => {
						const e = this.props.settings,
							t = this.state.settings,
							s = t.type;
						t.displaySettings.isEnabled !== e.displaySettings.isEnabled && this.props.sendEvent(am(s, t.displaySettings.isEnabled)), t.permissions.canAssignOwn !== e.permissions.canAssignOwn && this.props.sendEvent(nm(s, t.permissions.canAssignOwn)), this.props.sendEvent(tm(s))
					}, this.onToggleIsEnabled = () => {
						const {
							settings: e
						} = this.state, t = !e.displaySettings.isEnabled, s = Object.assign({}, e, {
							displaySettings: Object.assign({}, e.displaySettings, {
								isEnabled: t
							})
						}, !t && {
							permissions: Object.assign({}, e.permissions, {
								canAssignOwn: !1
							})
						});
						this.setState({
							settings: s
						})
					}, this.onToggleCanAssignOwn = () => {
						const {
							settings: e
						} = this.state, t = !e.permissions.canAssignOwn, s = Object.assign({}, e, {
							permissions: Object.assign({}, e.permissions, {
								canAssignOwn: t
							})
						});
						this.setState({
							settings: s
						})
					}
				}
				componentWillUnmount() {
					this.isUnmounted = !0
				}
				render() {
					const e = this.props.settings.type === nn.d.UserFlair,
						{
							settings: t
						} = this.state,
						s = t !== this.props.settings;
					return r.a.createElement("div", {
						className: jm.a.container
					}, r.a.createElement(at.g, {
						className: jm.a.modalHeader
					}, r.a.createElement(at.n, null, e ? Object(G.c)("User flair settings") : Object(G.c)("Post flair settings")), r.a.createElement(rt.a, {
						className: jm.a.modalCloseButton,
						onClick: this.props.onClose
					}, r.a.createElement(at.b, null))), r.a.createElement("div", {
						className: jm.a.contentBlock
					}, r.a.createElement(Cm, {
						label: e ? Object(G.c)("Enable user flair in this community") : Object(G.c)("Enable post flair in this community")
					}, r.a.createElement(hc.a, {
						on: t.displaySettings.isEnabled,
						onToggle: this.onToggleIsEnabled
					})), r.a.createElement(Cm, {
						className: jm.a.assignOwnControl,
						label: Object(G.c)("Allow users to assign their own"),
						labelClassName: t.displaySettings.isEnabled ? void 0 : jm.a.disabled
					}, r.a.createElement(hc.a, {
						disabled: !t.displaySettings.isEnabled,
						on: t.permissions.canAssignOwn,
						onToggle: this.onToggleCanAssignOwn
					})), r.a.createElement("div", {
						className: jm.a.details
					}, e ? Object(G.c)("This will let users select, edit, and clear user flair for their usernames in this community. This does not allow users to select or edit mod-only user flair.") : Object(G.c)("This will let users select, edit, and clear post flair for their posts in this community. This does not allow users to select or edit mod-only post flair."))), r.a.createElement(at.e, {
						className: jm.a.modalFooter
					}, r.a.createElement(at.a, {
						onClick: this.props.onClose
					}, r.a.createElement(_e.c, null, "Cancel")), r.a.createElement(de.f, {
						onClick: this.onSaveButtonClick,
						disabled: this.state.isPending || !s
					}, this.state.isPending ? r.a.createElement(Em.a, {
						className: jm.a.loadingIcon,
						sizePx: 10
					}) : r.a.createElement(_e.c, null, "Save"))))
				}
			}
			var km = Object(nt.a)(ym);
			const wm = e => !e || e === qn.b,
				Sm = e => Object.assign({}, e, {
					backgroundColor: wm(e.backgroundColor) ? qn.a.defaultFlair : qn.b
				}),
				Nm = e => !(!e.textEditable || e.modOnly),
				Tm = e => {
					const t = Object.assign({}, e);
					return t.modOnly && (t.textEditable = !1), t.textEditable || (t.allowableContent = nn.a.All, t.maxEmojis = void 0), t.allowableContent === nn.a.Text && (t.maxEmojis = void 0), t
				},
				_m = e => e.userFlairAllowed,
				Im = e => e.postFlairAllowed,
				Pm = function(e, t, s) {
					let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					const a = Object.assign({}, e);
					let o = Object(Vn.c)(a, !1);
					if (Object(Vn.a)(a)) {
						const e = t === nn.d.UserFlair ? _m : Im;
						o = Object(Vn.r)(o, s, e)
					}
					return o = Object(Vn.d)({
						flair: o,
						template: a,
						ignoreTextAllowance: n
					}), a.type = o.type, o.type === nn.f.Richtext ? a.richtext = o.richtext : a.text = o.text, a
				},
				Mm = e => {
					const t = Object(Vn.n)(e) && !Object(Vn.q)(e),
						s = e.text.length > ha.g,
						n = !e.text,
						a = Ea(e.cssClass || "");
					return {
						isBlank: n,
						cssClassErrorMessage: a,
						hasFieldError: !!(t || n || s || a),
						isFlairTextTooLong: s,
						shouldRemoveFlairText: t
					}
				};
			var Rm = s("./node_modules/lodash/range.js"),
				Lm = s.n(Rm),
				Dm = s("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				Am = s("./src/reddit/components/StructuredStyles/ColorPicker/BaseColorPicker.tsx");
			const Fm = ["right", "top"],
				Bm = Object(c.c)({
					isDropdownOpen: (e, t) => {
						let {
							tooltipId: s
						} = t;
						return Object(Ra.b)(s)(e)
					},
					language: L.S
				});
			var Um = Object(i.b)(Bm, (e, t) => ({
					onToggleDropdown: () => e(Object(Yt.g)(t))
				}))(e => r.a.createElement("div", {
					id: e.tooltipId
				}, r.a.createElement(Am.a, {
					dropdownPosition: Fm,
					isDropdownOpen: e.isDropdownOpen,
					language: e.language,
					onChange: e.onChange,
					onToggleDropdown: e.onToggleDropdown,
					tooltipId: e.tooltipId,
					value: e.value
				}))),
				Hm = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/ColorSwitch/index.m.less"),
				Wm = s.n(Hm);
			class qm extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.onChange = () => {
						this.props.onChange(!this.props.isDark)
					}
				}
				render() {
					const {
						isDark: e
					} = this.props;
					return r.a.createElement("button", {
						className: Object(d.a)(Wm.a.switch, e ? Wm.a.dark : Wm.a.light),
						onClick: this.onChange
					}, "Aa")
				}
			}
			var Vm = s("./src/lib/copyToClipboard/index.ts"),
				zm = s("./src/reddit/actions/userFlair.ts"),
				Km = s("./src/reddit/constants/posts.ts"),
				Qm = s("./src/reddit/models/Vote/index.ts"),
				Gm = s("./src/reddit/actions/flairManagement/constants.ts");
			const Jm = Object(Za.a)(Gm.a),
				Zm = Object(Za.a)(Gm.b),
				Xm = (e, t) => async (s, n) => {
					const a = (e => {
						const {
							postId: t
						} = e, s = t.slice(3);
						return Object.assign({
							id: t,
							postId: t,
							allAwardings: [],
							approvedAtUTC: void 0,
							approvedBy: void 0,
							author: "reddit",
							authorId: "t2_1qwk",
							awardCountsById: {},
							bannedAtUTC: void 0,
							bannedBy: void 0,
							contestMode: !1,
							created: Date.now() - h.I,
							crosspostParentId: null,
							crosspostRootId: null,
							discussionType: null,
							distinguishType: null,
							domain: "reddit.com",
							events: [],
							flair: [],
							ignoreReports: !0,
							isApproved: !1,
							isArchived: !1,
							isAuthorPremium: !1,
							isBlank: !1,
							isCrosspostable: !0,
							isGildable: !0,
							isLocked: !1,
							isMediaOnly: !1,
							isMeta: !1,
							isNSFW: !1,
							isOriginalContent: !1,
							isPinned: !1,
							isRemoved: !1,
							isScoreHidden: !1,
							isSpam: !1,
							isSpoiler: !1,
							isSponsored: !1,
							isStickied: !1,
							liveCommentsWebsocket: null,
							media: null,
							modReports: [],
							numComments: 100,
							numCrossposts: 0,
							numReports: 0,
							permalink: "/comments/".concat(s),
							postCategories: null,
							previewComments: [],
							removedBy: null,
							removedByCategory: null,
							score: 11111,
							sendReplies: !1,
							source: {
								displayText: "reddit.com",
								outboundUrl: "https://www.reddit.com",
								url: "https://www.reddit.com"
							},
							suggestedSort: void 0,
							thumbnail: {
								url: "default",
								width: null,
								height: null
							},
							title: "This is an example post",
							upvoteRatio: .1,
							userReports: [],
							viewCount: 12345,
							voteState: Qm.a.notVoted
						}, e)
					})({
						belongsTo: {
							id: e,
							type: Km.a.SUBREDDIT
						},
						flair: [t],
						postId: ha.e
					});
					s(Jm(a))
				};
			var Ym = s("./src/reddit/actions/post.ts"),
				$m = s("./src/reddit/components/ThemeProvider/index.tsx"),
				eu = s("./src/reddit/constants/postLayout.ts"),
				tu = s("./src/reddit/controls/LayoutSwitch/index.tsx"),
				su = s("./src/reddit/helpers/dom/index.ts"),
				nu = s("./src/reddit/helpers/postComponentForLayout/index.tsx"),
				au = s("./src/reddit/selectors/posts.ts"),
				ou = s("./src/reddit/models/StructuredStyles/index.ts"),
				ru = s("./src/reddit/components/StructuredStyles/UploadedImage/index.tsx");
			var iu = e => e.imageData ? r.a.createElement(ru.e, {
					imageData: e.imageData,
					isRequestInProgress: e.isRequestInProgress,
					onRemove: e.onRemove
				}) : r.a.createElement(Bc.b, {
					label: Object(G.c)("Drag and Drop or Upload Image"),
					onChange: e.onChange
				}),
				cu = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/PostAppearanceEditor/PostFlairStyleTemplateEditor/index.m.less"),
				du = s.n(cu);
			const lu = e => Array.isArray(e) ? e[0] : e,
				mu = e => (t, s) => {
					const n = ((e, t) => {
						const {
							pendingImages: s
						} = e, n = s && s[t];
						return n ? n.id : void 0
					})(s.styleTemplate, e);
					return n ? t.imageUploads[n] : void 0
				},
				uu = Object(c.c)({
					subredditDefaultStyles: zl.p,
					postBackgroundImage: mu(ou.e),
					postPlaceholderImage: mu(ou.f)
				}),
				pu = {
					cancelUpload: Gd.h
				};
			class bu extends r.a.Component {
				constructor() {
					super(...arguments), this.onChangePostTitleColor = e => {
						const t = Object.assign({}, this.props.styleTemplate, {
							postTitleColor: e
						});
						this.props.onChange(t)
					}, this.onChangePostBackgroundColor = e => {
						const t = Object.assign({}, this.props.styleTemplate, {
							postBackgroundColor: e
						});
						this.props.onChange(t)
					}, this.onPostBackgroundImageInput = e => {
						this.addImage(lu(e), ou.e)
					}, this.onPostPlaceholderImageInput = e => {
						this.addImage(lu(e), ou.f)
					}, this.onRemoveBackgroundImage = () => this.removeImage(ou.e), this.onRemovePlaceholderImage = () => this.removeImage(ou.f), this.addImage = async (e, t) => {
						const {
							styleTemplate: s
						} = this.props, n = await Object(qc.f)(e);
						this.props.onChange(Object.assign({}, s, {
							[t]: n.url,
							pendingImages: Object.assign({}, s.pendingImages, {
								[t]: n
							})
						}))
					}, this.cancelUpload = e => {
						const t = this.props[e];
						t && this.props.cancelUpload(t)
					}, this.removeImage = e => {
						const {
							styleTemplate: t
						} = this.props, s = t.pendingImages || {};
						this.cancelUpload(e), this.props.onChange(Object.assign({}, Object(yn.a)(t, e), {
							pendingImages: Object(yn.a)(s, e)
						}))
					}, this.getImageUpload = e => {
						const {
							styleTemplate: t
						} = this.props, {
							pendingImages: s = {}
						} = t, n = this.props[e] || s[e];
						if (n) return n;
						const a = this.props.styleTemplate[e];
						if (a) {
							const e = {
								url: a,
								width: 0,
								height: 0
							};
							return Object(qc.g)(e)
						}
					}
				}
				componentWillUnmount() {
					this.cancelUpload(ou.e), this.cancelUpload(ou.f)
				}
				render() {
					const {
						className: e,
						styleTemplate: t,
						subredditDefaultStyles: s,
						templateId: n
					} = this.props, {
						postTitleColor: a = s.postTitleColor,
						postBackgroundColor: o = s.postBackgroundColor
					} = t, i = this.getImageUpload(ou.e), c = this.getImageUpload(ou.f);
					return r.a.createElement("div", {
						className: Object(d.a)(e, du.a.container)
					}, r.a.createElement("fieldset", {
						className: du.a.leftFieldset
					}, r.a.createElement(Cm, {
						label: Object(G.c)("Post title color")
					}, r.a.createElement(Um, {
						onChange: this.onChangePostTitleColor,
						tooltipId: "flair-postTitleColor-" + n,
						value: a
					})), r.a.createElement(Cm, {
						label: Object(G.c)("Thumbnail placeholder"),
						labelPosition: pm.Top,
						preventDefaultLabelClick: !!c
					}, r.a.createElement(iu, {
						imageData: c,
						isRequestInProgress: this.props.isSavePending,
						onChange: this.onPostPlaceholderImageInput,
						onRemove: this.onRemovePlaceholderImage
					}), r.a.createElement("div", {
						className: du.a.imageUploadHelpText
					}, Object(G.c)("Required Size: 256 x 256px\n Appears in Classic and Card views")))), r.a.createElement("fieldset", {
						className: du.a.rightFieldset
					}, r.a.createElement(Cm, {
						label: Object(G.c)("Post background color")
					}, r.a.createElement(Um, {
						onChange: this.onChangePostBackgroundColor,
						tooltipId: "flair-postBackgroundColor-" + n,
						value: o
					})), r.a.createElement(Cm, {
						labelPosition: pm.Top,
						label: Object(G.c)("Post background image"),
						preventDefaultLabelClick: !!i
					}, r.a.createElement(iu, {
						imageData: i,
						isRequestInProgress: this.props.isSavePending,
						onChange: this.onPostBackgroundImageInput,
						onRemove: this.onRemoveBackgroundImage
					}), r.a.createElement("div", {
						className: du.a.imageUploadHelpText
					}, Object(G.c)("Jpeg or png files up to 10 MB\n Recommended image size: 864 x 120px")))))
				}
			}
			var hu = Object(i.b)(uu, pu)(bu),
				gu = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/PostAppearanceEditor/index.m.less"),
				Eu = s.n(gu);
			const xu = Object(c.c)({
					examplePost: e => Object(au.I)(e, {
						postId: ha.e
					})
				}),
				fu = Object(i.b)(xu, (e, t) => ({
					deleteExamplePost: () => e(Zm(ha.e)),
					makeExamplePost: s => e(Xm(t.subredditId, s)),
					updateExamplePost: t => e(Object(Ym.E)({
						[ha.e]: {
							flair: [t]
						}
					}))
				}));
			class vu extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.postWrapperRef = r.a.createRef(), this.state = {
						previewLayout: eu.d.Classic
					}, this.onPostStyleTemplateChange = e => {
						const {
							templateDraft: t
						} = this.props;
						this.props.onChange(Object.assign({}, t, {
							styleTemplate: e
						}))
					}, this.onChangePreviewLayout = e => {
						this.setState({
							previewLayout: e
						})
					}, this.onPostPreviewClickCapture = e => {
						e.preventDefault(), e.stopPropagation()
					}
				}
				componentDidMount() {
					const {
						templateDraft: e
					} = this.props, t = Object(Vn.c)(e);
					this.props.makeExamplePost(t), this.disableTabNavigationForPreviewPost()
				}
				componentDidUpdate(e) {
					const t = Object(Vn.c)(this.props.templateDraft),
						s = Object(Vn.c)(e.templateDraft);
					_s()(t, s) || this.props.updateExamplePost(t), this.disableTabNavigationForPreviewPost()
				}
				componentWillUnmount() {
					this.props.deleteExamplePost()
				}
				disableTabNavigationForPreviewPost() {
					this.postWrapperRef.current && Object(su.a)(this.postWrapperRef.current)
				}
				render() {
					const {
						subredditId: e,
						templateDraft: t,
						examplePost: s
					} = this.props;
					if (!s) return null;
					const {
						previewLayout: n
					} = this.state, a = t.styleTemplate || {}, o = eu.b[n], i = Object(nu.b)({
						isFirstPost: !1,
						layout: o,
						post: s
					});
					return r.a.createElement("div", {
						className: Object(d.a)(this.props.className, Eu.a.container)
					}, r.a.createElement("div", null, r.a.createElement(tu.a, {
						className: Eu.a.layoutSwitch,
						layout: n,
						onChange: this.onChangePreviewLayout
					}), r.a.createElement("div", {
						className: Eu.a.postPreview
					}, r.a.createElement("div", {
						ref: this.postWrapperRef,
						onClickCapture: this.onPostPreviewClickCapture,
						className: Object(d.a)(Eu.a.postWrapper, Eu.a[n])
					}, r.a.createElement($m.a, {
						forceDayMode: !0
					}, r.a.createElement(i, {
						className: Eu.a.postComponent,
						flairStyleTemplateDraft: a,
						inSubredditOrProfile: !0,
						pageLayer: this.props.pageLayer,
						postId: s.postId
					}))))), r.a.createElement(hu, {
						className: Eu.a.postFlairStyleTemplateEditor,
						isSavePending: this.props.isSavePending,
						onChange: this.onPostStyleTemplateChange,
						styleTemplate: a,
						subredditId: e,
						templateId: t.id
					}))
				}
			}
			var Cu = Object(f.t)()(fu(vu)),
				Ou = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateEditor/index.m.less"),
				ju = s.n(Ou);
			const yu = "flair-management-emoji-picker",
				ku = {},
				wu = 250,
				Su = Lm()(ha.d, 0).map(e => ({
					value: e,
					displayText: e.toString()
				}));
			class Nu extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.containerRef = r.a.createRef(), this.initialTemplate = this.props.templateDraft, this.state = {
						flairEditHadFocus: !1
					}, this.normalizeTemplate = e => {
						const {
							flairTemplateType: t,
							subredditEmojiData: s
						} = this.props;
						let n = Tm(e);
						return n = Pm(n, t, s, !0)
					}, this.onSave = () => {
						this.props.onChange(this.normalizeTemplate(this.props.templateDraft))
					}, this.onFlairEditBlur = () => {
						this.setState({
							flairEditHadFocus: !0
						})
					}, this.onToggleBackgroundTransparency = () => {
						this.props.onChange(Sm(this.props.templateDraft))
					}, this.onToggleFlairTextColor = () => {
						const {
							templateDraft: e
						} = this.props;
						this.props.onChange(Object.assign({}, e, {
							textColor: e.textColor === nn.e.Light ? nn.e.Dark : nn.e.Light
						}))
					}, this.onToggleModOnly = () => {
						const {
							templateDraft: e
						} = this.props, t = !e.modOnly;
						this.props.onChange(this.normalizeTemplate(Object.assign({}, e, {
							modOnly: t
						})))
					}, this.onToggleAllowUserEdits = () => {
						const {
							templateDraft: e
						} = this.props, t = !e.textEditable;
						this.props.onChange(this.normalizeTemplate(Object.assign({}, e, {
							textEditable: t
						})))
					}, this.onTogglePostAppearanceSettings = () => {
						const {
							templateDraft: e
						} = this.props, t = e.styleTemplate ? void 0 : ku;
						this.props.onChange(Object.assign({}, e, {
							styleTemplate: t
						}))
					}, this.onChangeBackgroundColor = e => {
						const {
							templateDraft: t
						} = this.props;
						this.props.onChange(Object.assign({}, t, {
							backgroundColor: e
						}))
					}, this.onChangeTextColor = e => {
						const {
							templateDraft: t
						} = this.props;
						this.props.onChange(Object.assign({}, t, {
							textColor: e ? nn.e.Dark : nn.e.Light
						}))
					}, this.onCSSClassValueChange = e => {
						const {
							templateDraft: t
						} = this.props;
						this.props.onChange(Object.assign({}, t, {
							cssClass: e.target.value
						}))
					}, this.onFlairContentChanged = e => {
						const {
							templateDraft: t
						} = this.props, s = Object(Vn.d)({
							flair: e,
							template: t,
							ignoreTextAllowance: !0
						});
						this.props.onChange(Object(Vn.f)(s, this.props.templateDraft))
					}, this.onAllowableContentChange = e => {
						const {
							templateDraft: t
						} = this.props, s = Object.assign({}, t, {
							allowableContent: e
						});
						this.props.onChange(this.normalizeTemplate(s))
					}, this.onEmojiLimitChange = e => {
						const {
							templateDraft: t
						} = this.props, s = Object.assign({}, t, {
							maxEmojis: e.value
						});
						this.props.onChange(this.normalizeTemplate(s))
					}
				}
				componentDidMount() {
					this.scrollIntoView()
				}
				scrollIntoView() {
					const e = this.containerRef.current;
					if (!e) return;
					const t = e.getBoundingClientRect().top,
						s = window.scrollY + t - wu;
					window.scrollTo(0, s)
				}
				render() {
					const {
						areFlairRestrictionsEnabled: e,
						subredditId: t,
						templateDraft: s,
						flairTemplateType: n
					} = this.props, a = n === nn.d.UserFlair, o = n === nn.d.LinkFlair, i = s !== this.initialTemplate, {
						hasFieldError: c,
						cssClassErrorMessage: d
					} = Mm(s), l = this.state.flairEditHadFocus || i, m = Object(Na.a)(), u = Object(Vn.c)(s, !1), p = wm(s.backgroundColor), b = o || !p, h = p ? qn.a.defaultFlair : s.backgroundColor, g = Object(Vn.l)(s);
					return r.a.createElement("div", {
						className: ju.a.container,
						ref: this.containerRef
					}, r.a.createElement("div", {
						className: ju.a.mainContent
					}, r.a.createElement("fieldset", {
						className: ju.a.leftFieldset
					}, r.a.createElement("legend", null, r.a.createElement(_e.c, null, "Flair appearance")), r.a.createElement(Cm, {
						labelPosition: pm.Top,
						label: Object(G.c)("Flair text")
					}, r.a.createElement(m, {
						allowBlank: !l,
						autofocus: !0,
						className: ju.a.flairEdit,
						emojiPickerId: yu,
						flair: u,
						flairTemplate: s,
						flairTemplateType: n,
						isFlairModOnly: s.modOnly,
						onChange: this.onFlairContentChanged,
						subredditId: t,
						onBlur: this.onFlairEditBlur
					})), r.a.createElement(Cm, {
						labelPosition: pm.Top,
						label: Object(G.c)("CSS class")
					}, r.a.createElement(ot.c, {
						className: ju.a.cssClassInput,
						maxLength: ha.b,
						onChange: this.onCSSClassValueChange,
						placeholder: Object(G.c)("none"),
						spellCheck: !1,
						value: s.cssClass || ""
					}), r.a.createElement("div", {
						className: d ? ju.a.cssClassErrorText : ju.a.cssClassInfoText
					}, d || r.a.createElement(_e.c, null, "Optional"))), a && r.a.createElement(Cm, {
						label: Object(G.c)("Add flair background")
					}, r.a.createElement(hc.a, {
						on: b,
						onToggle: this.onToggleBackgroundTransparency
					})), b && r.a.createElement(r.a.Fragment, null, r.a.createElement(Cm, {
						label: Object(G.c)("Flair background color")
					}, r.a.createElement(Um, {
						onChange: this.onChangeBackgroundColor,
						tooltipId: "flair-background-color-" + s.id,
						value: h
					})), r.a.createElement(Cm, {
						label: Object(G.c)("Flair text color")
					}, r.a.createElement(qm, {
						isDark: s.textColor === nn.e.Dark,
						onChange: this.onChangeTextColor
					}))), o && r.a.createElement(Cm, {
						label: Object(G.c)("Edit post appearance")
					}, r.a.createElement(hc.a, {
						on: !!s.styleTemplate,
						onToggle: this.onTogglePostAppearanceSettings
					}))), r.a.createElement("fieldset", {
						className: ju.a.rightFieldset
					}, r.a.createElement("legend", null, r.a.createElement(_e.c, null, "Flair settings")), r.a.createElement(Cm, {
						label: r.a.createElement("span", {
							className: ju.a.labelWithTooltip
						}, r.a.createElement(_e.c, null, "Mod only"), r.a.createElement(_n.a, {
							text: Object(G.c)("Flair is only available for mods to select")
						}))
					}, r.a.createElement(hc.a, {
						on: !!s.modOnly,
						onToggle: this.onToggleModOnly
					})), r.a.createElement(Cm, {
						className: s.modOnly ? ju.a.disabledControl : void 0,
						label: r.a.createElement("span", {
							className: ju.a.labelWithTooltip
						}, r.a.createElement(_e.c, null, "Allow user edits"), r.a.createElement(_n.a, {
							text: Object(G.c)("Users will be able to edit flair text")
						}))
					}, r.a.createElement(hc.a, {
						disabled: s.modOnly,
						on: Nm(s),
						onToggle: this.onToggleAllowUserEdits
					})), Nm(s) && e && r.a.createElement(Cm, {
						label: Object(G.c)("This flair allows"),
						labelPosition: pm.Top
					}, r.a.createElement(sn.a, {
						value: s.allowableContent || nn.a.All,
						name: "allowable_content",
						onChange: this.onAllowableContentChange
					}, r.a.createElement(Dm.a, {
						className: ju.a.radioOption,
						showButton: !0,
						value: nn.a.All
					}, r.a.createElement(_e.c, null, "Text & Emojis")), r.a.createElement(Dm.a, {
						className: ju.a.radioOption,
						showButton: !0,
						value: nn.a.Emoji
					}, r.a.createElement(_e.c, null, "Emoji only")), r.a.createElement(Dm.a, {
						className: ju.a.radioOption,
						showButton: !0,
						value: nn.a.Text
					}, r.a.createElement(_e.c, null, "Text only")))), Nm(s) && s.allowableContent !== nn.a.Text && e && r.a.createElement(Cm, {
						label: Object(G.c)("Limit number of emojis"),
						labelPosition: pm.Top
					}, r.a.createElement(yi.a, {
						buttonClassName: ju.a.dropdownSelectorButton,
						className: ju.a.dropdownSelector,
						displayText: String(g),
						name: "max_emojis",
						options: Su,
						onSelect: this.onEmojiLimitChange
					})))), o && s.styleTemplate && r.a.createElement(Cu, {
						className: ju.a.postAppearanceEditor,
						isSavePending: !!this.props.isSavePending,
						onChange: this.props.onChange,
						subredditId: t,
						templateDraft: s
					}), r.a.createElement("div", {
						className: ju.a.buttonsRow
					}, r.a.createElement(de.i, {
						onClick: this.props.onCancel
					}, r.a.createElement(_e.c, null, "Cancel")), r.a.createElement(de.f, {
						disabled: this.props.isSavePending || c,
						onClick: this.props.onSave
					}, this.props.isSavePending ? r.a.createElement(Em.a, {
						className: ju.a.loadingIcon,
						sizePx: 10
					}) : r.a.createElement(_e.c, null, "Save"))))
				}
			}
			const Tu = (e, t) => e.modOnly ? Object(G.c)("Mod only") : e.textEditable ? t ? Object(G.c)("Editable, ".concat(Object(G.b)("restrictions", Object(Vn.k)(e).toLowerCase()))) : Object(G.c)("Editable") : "",
				_u = e => Object.assign({}, ha.a, {
					backgroundColor: e === nn.d.UserFlair ? qn.b : qn.a.defaultFlair
				});
			var Iu = s("./src/reddit/components/ModHub/flairs/FlairManagement/FlairTemplateRow/index.m.less"),
				Pu = s.n(Iu);
			class Mu extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.onStartEditButtonClick = () => {
						this.props.onStartEditing && this.props.onStartEditing(this.props.flairTemplate.id)
					}, this.onCopyIdButtonClick = () => {
						this.props.onCopyTemplateId(this.props.flairTemplate.id)
					}, this.onRemoveButtonClick = () => {
						this.props.onRemove(this.props.flairTemplate.id)
					}, this.onCancelEditButtonClick = () => {
						this.props.onCancel()
					}
				}
				render() {
					const {
						areFlairRestrictionsEnabled: e,
						disableEditButton: t,
						flairTemplate: s,
						isEditing: n,
						isReordering: a
					} = this.props, o = Object(Vn.c)(s);
					return r.a.createElement(r.a.Fragment, null, r.a.createElement("div", {
						className: Object(d.a)(Pu.a.row, a ? Pu.a.reordering : null)
					}, r.a.createElement("div", {
						className: Pu.a.flairPreviewCell
					}, r.a.createElement(Sa.b, {
						className: Pu.a.flairComponent,
						flair: o,
						forceSmallEmojis: !0
					})), r.a.createElement("div", {
						className: Pu.a.cssClassCell
					}, s.cssClass), r.a.createElement("div", {
						className: Pu.a.settingsCell
					}, Tu(s, e)), r.a.createElement("div", {
						className: Pu.a.flairIdCell
					}, r.a.createElement(de.n, {
						disabled: !this.props.flairTemplate.id,
						onClick: this.onCopyIdButtonClick
					}, r.a.createElement(_e.c, null, "Copy Id")), r.a.createElement(de.n, {
						disabled: t || n,
						onClick: this.onStartEditButtonClick
					}, r.a.createElement(_e.c, null, "Edit")), r.a.createElement(de.n, {
						className: Pu.a.removeButton,
						disabled: n,
						onClick: this.onRemoveButtonClick
					}, r.a.createElement(ds.b, null)))), n && r.a.createElement(Nu, {
						areFlairRestrictionsEnabled: e,
						flairTemplateType: this.props.flairTemplateType,
						isSavePending: this.props.isSavePending,
						onCancel: this.onCancelEditButtonClick,
						onChange: this.props.onChange,
						onSave: this.props.onSave,
						subredditEmojiData: this.props.subredditEmojiData,
						subredditId: this.props.subredditId,
						templateDraft: s
					}))
				}
			}
			var Ru = s("./src/reddit/components/ModHub/flairs/FlairManagement/Placeholder/index.m.less"),
				Lu = s.n(Ru),
				Du = e => r.a.createElement("div", {
					className: Lu.a.container
				}, r.a.createElement(Ko.a, {
					className: Lu.a.icon
				}), r.a.createElement("h3", {
					className: Lu.a.header
				}, e.flairTemplateType === nn.d.UserFlair ? Object(G.c)("You do not have any user flair") : Object(G.c)("You do not have any post flair")), r.a.createElement("p", {
					className: Lu.a.details
				}, e.flairTemplateType === nn.d.UserFlair ? Object(G.c)("Create user flair in your community today") : Object(G.c)("Create post flair in your community today"))),
				Au = s("./src/reddit/components/ModHub/flairs/FlairManagement/index.m.less"),
				Fu = s.n(Au);

			function Bu() {
				return (Bu = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const Uu = "Flair-discard-changes-confirmation",
				Hu = "Flair-remove-confirmation",
				Wu = "Flair-settings-modal";
			var qu;
			! function(e) {
				e[e.Default = 0] = "Default", e[e.AddingTemplate = 1] = "AddingTemplate", e[e.EditingTemplate = 2] = "EditingTemplate", e[e.Reordering = 3] = "Reordering"
			}(qu || (qu = {}));
			const Vu = {
				isTemplateSavePending: !1,
				mode: qu.Default,
				numTemplatesReordered: 0,
				templateBeforeEditing: void 0,
				templateDraft: void 0,
				templateIdsNewOrder: [],
				templateIdToRemove: void 0
			};
			class zu extends r.a.Component {
				constructor() {
					super(...arguments), this.isUnmounted = !1, this.state = Object.assign({}, Vu), this.hasUnsavedChanges = () => {
						return this.state.templateDraft !== this.state.templateBeforeEditing
					}, this.saveCurrentTemplateDraft = async () => {
						const {
							templateDraft: e
						} = this.state;
						if (!e) return;
						this.setState({
							isTemplateSavePending: !0
						}), this.sendOnSaveEvents(e);
						const t = await this.props.onSaveTemplate(e);
						this.isUnmounted || (this.setState({
							isTemplateSavePending: !1
						}), t && this.setState(Vu))
					}, this.resetPendingNavigation = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!1)
					}, this.performPendingNavigationIfNeeded = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!0)
					}, this.onSettingsButtonClick = () => {
						this.props.toggleModal(Wu)
					}, this.onCloseModal = () => {
						this.props.closeAllModals(), this.resetPendingNavigation()
					}, this.onAddNewTemplateButtonClick = () => {
						const e = _u(this.props.flairTemplateType);
						this.setState({
							mode: qu.AddingTemplate,
							templateDraft: e,
							templateBeforeEditing: e
						})
					}, this.onRemoveTemplateButtonClick = e => {
						this.setState({
							templateIdToRemove: e
						}), this.props.toggleModal(Hu)
					}, this.onRemoveTemplateConfirmed = () => {
						this.props.onRemoveTemplate(this.state.templateIdToRemove), this.props.sendEvent($l(this.props.flairTemplateType))
					}, this.onStartEditingExistingTemplate = e => {
						if (this.hasUnsavedChanges()) return void this.props.toggleModal(Uu);
						const t = Pm(Object.assign({}, this.props.templates[e], {
							styleTemplate: this.props.styleTemplates && this.props.styleTemplates[e]
						}), this.props.flairTemplateType, this.props.subredditEmojiData);
						this.setState({
							mode: qu.EditingTemplate,
							templateDraft: t,
							templateBeforeEditing: t
						})
					}, this.onTemplateDraftChange = e => {
						this.setState({
							templateDraft: e
						})
					}, this.onReorderButtonClick = () => {
						this.setState({
							mode: qu.Reordering,
							numTemplatesReordered: 0,
							templateIdsNewOrder: [...this.props.templateIds]
						})
					}, this.onTemplatesOrderChange = (e, t, s) => {
						const {
							numTemplatesReordered: n
						} = this.state;
						this.setState({
							numTemplatesReordered: n + 1,
							templateIdsNewOrder: s
						})
					}, this.onSaveCurrentOrderClick = () => {
						const {
							numTemplatesReordered: e,
							templateIdsNewOrder: t
						} = this.state;
						this.props.onReorderTemplates(t), this.props.sendEvent(dm(this.props.flairTemplateType, e)), this.setState(Vu)
					}, this.onCancelReorderingClick = () => {
						this.setState(Vu)
					}, this.onCancelEditingTemplateClick = () => {
						this.hasUnsavedChanges() ? this.props.toggleModal(Uu) : this.setState(Vu)
					}, this.onDiscardUnsavedChangesConfirmed = () => {
						this.setState(Vu), this.performPendingNavigationIfNeeded()
					}
				}
				componentDidMount() {
					this.props.onGetSubredditEmojisIfNeeded()
				}
				componentWillUnmount() {
					this.isUnmounted = !0
				}
				sendOnSaveEvents(e) {
					const {
						templateBeforeEditing: t
					} = this.state, {
						flairTemplateType: s
					} = this.props, n = !e.id;
					if (!t) return;
					e.modOnly !== t.modOnly && this.props.sendEvent(om(s, !!e.modOnly)), e.textEditable !== t.textEditable && this.props.sendEvent(rm(s, !!e.textEditable)), !!e.styleTemplate != !!t.styleTemplate && this.props.sendEvent(cm(!!e.styleTemplate));
					const a = e.allowableContent || nn.a.All;
					a !== (t.allowableContent || nn.a.All) && this.props.sendEvent(mm(s, a)), Object(Vn.l)(e) !== Object(Vn.l)(t) && this.props.sendEvent(um(s, Object(Vn.l)(e))), this.props.sendEvent(im(s, n))
				}
				render() {
					const {
						areFlairRestrictionsEnabled: e,
						templateIds: t
					} = this.props, {
						mode: s,
						templateDraft: n
					} = this.state, a = this.props.flairTemplateType === nn.d.UserFlair, o = this.hasUnsavedChanges(), i = n && n.id, c = {
						areFlairRestrictionsEnabled: e,
						disableEditButton: s !== qu.Default,
						flairTemplateType: this.props.flairTemplateType,
						onCancel: this.onCancelEditingTemplateClick,
						onChange: this.onTemplateDraftChange,
						onCopyTemplateId: this.props.onCopyTemplateId,
						onRemove: this.onRemoveTemplateButtonClick,
						onSave: this.saveCurrentTemplateDraft,
						onStartEditing: this.onStartEditingExistingTemplate,
						subredditEmojiData: this.props.subredditEmojiData,
						subredditId: this.props.subredditId
					}, d = t.length >= ha.h;
					return r.a.createElement("div", {
						className: Fu.a.container
					}, r.a.createElement(ie, {
						className: Fu.a.topBar
					}, s === qu.Reordering ? r.a.createElement(r.a.Fragment, null, r.a.createElement(de.i, {
						onClick: this.onCancelReorderingClick
					}, r.a.createElement(_e.c, null, "Cancel")), r.a.createElement(de.f, {
						disabled: !this.state.numTemplatesReordered,
						onClick: this.onSaveCurrentOrderClick
					}, r.a.createElement(_e.c, null, "Save"))) : r.a.createElement(r.a.Fragment, null, r.a.createElement(de.i, {
						className: Fu.a.settingsButton,
						onClick: this.onSettingsButtonClick
					}, a ? Object(G.c)("User flair settings") : Object(G.c)("Post flair settings")), r.a.createElement(de.i, {
						disabled: s !== qu.Default || t.length < 2,
						onClick: this.onReorderButtonClick
					}, r.a.createElement(_e.c, null, "Reorder")), r.a.createElement(de.f, {
						disabled: s !== qu.Default || d,
						onClick: this.onAddNewTemplateButtonClick,
						title: d ? Object(G.c)("Maximum number of templates reached") : void 0
					}, r.a.createElement(_e.c, null, "Add flair")))), r.a.createElement(oe, {
						className: Fu.a.contentContainer
					}, r.a.createElement(re, null, a ? Object(G.c)("User flair management") : Object(G.c)("Post flair management"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter).concat(this.props.helpCenterLink)
					})), !this.props.flairSettings.displaySettings.isEnabled && r.a.createElement(gm, {
						className: Fu.a.disabledBanner,
						flairTemplateType: this.props.flairTemplateType
					}), r.a.createElement("div", {
						className: Fu.a.table
					}, r.a.createElement("div", {
						className: Fu.a.tableHead
					}, r.a.createElement("div", {
						className: Fu.a.flairPreviewColHeader
					}, a ? Object(G.c)("User flair preview") : Object(G.c)("Post flair preview")), r.a.createElement("div", {
						className: Fu.a.cssClassColHeader
					}, r.a.createElement(_e.c, null, "CSS class"), r.a.createElement(_n.a, {
						text: Object(G.c)("CSS classes determine the styling for flair in old Reddit")
					})), r.a.createElement("div", {
						className: Fu.a.settingsColHeader
					}, r.a.createElement(_e.c, null, "Settings"), r.a.createElement(_n.a, {
						text: e ? Object(G.c)("Shows if flair is mod-only, user editable, allows text, or allows emojis") : Object(G.c)("Set flair to be user editable or mod-only")
					})), r.a.createElement("div", {
						className: Fu.a.flairIdColHeader
					}, r.a.createElement(_e.c, null, "Flair ID"), r.a.createElement(_n.a, {
						text: Object(G.c)("Use this ID when configuring automod to assign flair")
					}))), r.a.createElement("div", {
						className: Fu.a.tableBody
					}, s === qu.Default && !t.length && r.a.createElement(Du, {
						flairTemplateType: this.props.flairTemplateType
					}), s === qu.Reordering ? r.a.createElement(Gl.a, {
						values: this.state.templateIdsNewOrder,
						onDrop: this.onTemplatesOrderChange,
						render: (e, t, s, n, a) => r.a.createElement(Ql.a, {
							canDrop: a,
							className: Fu.a.dragItem,
							iconClassName: Fu.a.dragIcon,
							isDragging: s,
							isOver: n
						}, r.a.createElement(Mu, Bu({}, c, {
							flairTemplate: this.props.templates[e],
							isReordering: !0
						})))
					}) : t.map(e => r.a.createElement(Mu, Bu({}, c, {
						key: e,
						flairTemplate: e === i ? n : this.props.templates[e],
						isEditing: e === i,
						isSavePending: this.state.isTemplateSavePending && e === i
					}))), s === qu.AddingTemplate && r.a.createElement(Mu, Bu({}, c, {
						flairTemplate: n,
						isSavePending: this.state.isTemplateSavePending,
						isEditing: !0
					}))))), r.a.createElement(Kl.a, {
						blockOnBeforeUnload: !0,
						dialogId: Uu,
						enabled: o
					}), this.props.activeModalId === Uu && r.a.createElement(U.a, {
						actionText: Object(G.c)("Discard"),
						headerText: i ? Object(G.c)("Discard changes before leaving?") : Object(G.c)("Discard new flair?"),
						modalText: i ? Object(G.c)("You have made some changes to your flair, do you wish to discard the changes to the flair you are editing?") : Object(G.c)("You have a new flair that has not been saved, do you wish to discard this new flair?"),
						onConfirm: this.onDiscardUnsavedChangesConfirmed,
						toggleModal: this.onCloseModal,
						withOverlay: !0
					}), this.props.activeModalId === Hu && r.a.createElement(U.a, {
						actionText: Object(G.c)("Delete"),
						headerText: a ? Object(G.c)("Delete user flair?") : Object(G.c)("Delete post flair?"),
						modalText: a ? Object(G.c)("Do you wish to delete this user flair?") : Object(G.c)("Do you wish to delete this post flair?"),
						onConfirm: this.onRemoveTemplateConfirmed,
						toggleModal: this.onCloseModal,
						withOverlay: !0
					}), this.props.activeModalId === Wu && r.a.createElement(km, {
						onClose: this.onCloseModal,
						onSave: this.props.onSaveSettings,
						sendEvent: this.props.sendEvent,
						settings: this.props.flairSettings,
						subredditId: this.props.subredditId,
						withOverlay: !0
					}))
				}
			}
			var Ku = Object(x.b)(zu),
				Qu = s("./src/reddit/selectors/platform.ts");
			const Gu = {
					activeModalId: tt.a,
					allowNavigationCallback: Qu.a,
					areFlairRestrictionsEnabled: Rs.d.flairRestrictions,
					subredditEmojiData: ec.f
				},
				Ju = (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						closeAllModals: () => e(Object(F.f)()),
						onCopyTemplateId: t => e((e => async (t, s) => {
							t(Object(Vm.a)(e) ? Object(hi.e)(Object(hi.d)(Object(G.c)("Copied flair ID!"), xi.b.SuccessCommunity)) : Object(hi.e)(Object(hi.d)(Object(G.c)("Something went wrong"), xi.b.Error)))
						})(t)),
						onGetSubredditEmojisIfNeeded: () => e(Object(Ji.m)(s)),
						onSaveSettings: t => e(((e, t) => async (s, n) => {
							const a = t.type === nn.d.UserFlair,
								o = a ? ra.e : Vl.e,
								r = a ? zm.n : ql.l,
								i = a ? zm.m : ql.k,
								c = o(n(), {
									subredditId: e
								});
							if (!c) throw new Error("Cannot update settings!");
							const d = [],
								l = t.displaySettings.isEnabled,
								m = t.permissions.canAssignOwn;
							l !== c.displaySettings.isEnabled && d.push(s(r(e, l)));
							const u = l && !c.displaySettings.isEnabled && !c.permissions.canAssignOwn;
							(m !== c.permissions.canAssignOwn || u) && d.push(s(i(e, m)));
							const p = (await Promise.all(d)).every(Boolean);
							return p || s(Object(hi.e)({
								kind: xi.b.Error,
								text: Object(G.c)("Something went wrong")
							})), p
						})(s, t)),
						toggleModal: t => e(Object(F.i)(t))
					}
				};

			function Zu() {
				return (Zu = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var Xu = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const Yu = Object(c.c)(Object.assign({}, Gu, {
				postFlairData: Vl.d,
				postFlairSettings: Vl.e,
				styleTemplates: zl.f
			}));
			var $u = Object(i.b)(Yu, (e, t) => Object.assign({}, Ju(e, t), {
				onRemoveTemplate: s => e(Object(ql.g)(s, t.subredditId)),
				onReorderTemplates: s => e(Object(ql.i)(s, t.subredditId)),
				onSaveTemplate: s => e(Object(ql.j)(s, t.subredditId))
			}))(e => {
				const {
					postFlairData: t,
					postFlairSettings: s
				} = e, n = Xu(e, ["postFlairData", "postFlairSettings"]);
				return t && s ? r.a.createElement(Ku, Zu({
					flairSettings: s,
					flairTemplateType: nn.d.LinkFlair,
					helpCenterLink: "hc/en-us/articles/360010513191-Post-Flair",
					templateIds: t.templateIds,
					templates: t.templates
				}, n)) : null
			});

			function ep() {
				return (ep = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var tp = function(e, t) {
				var s = {};
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var a = 0;
					for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
				}
				return s
			};
			const sp = Object(c.c)(Object.assign({}, Gu, {
				userFlairData: ra.c,
				userFlairSettings: ra.e
			}));
			var np = Object(i.b)(sp, (e, t) => Object.assign({}, Ju(e, t), {
					onRemoveTemplate: s => e(Object(zm.j)(s, t.subredditId)),
					onReorderTemplates: s => e(Object(zm.k)(s, t.subredditId)),
					onSaveTemplate: s => e(Object(zm.l)(s, t.subredditId))
				}))(e => {
					const {
						userFlairData: t,
						userFlairSettings: s
					} = e, n = tp(e, ["userFlairData", "userFlairSettings"]);
					return t && s ? r.a.createElement(Ku, ep({
						flairSettings: s,
						flairTemplateType: nn.d.UserFlair,
						helpCenterLink: "hc/en-us/articles/360010541651-User-Flair",
						templateIds: t.templateIds,
						templates: t.templates
					}, n)) : null
				}),
				ap = s("./node_modules/lodash/debounce.js"),
				op = s.n(ap),
				rp = s("./node_modules/lodash/isEmpty.js"),
				ip = s.n(rp),
				cp = s("./src/reddit/actions/postRequirements/index.ts"),
				dp = s("./node_modules/lodash/omitBy.js"),
				lp = s.n(dp),
				mp = s("./src/reddit/models/PostRequirements/index.ts"),
				up = s("./src/telemetry/models/PostRequirement.ts");
			const pp = {
					[mp.a.None]: up.BodyRestrictionPolicy.Optional,
					[mp.a.NotAllowed]: up.BodyRestrictionPolicy.Disabled,
					[mp.a.Required]: up.BodyRestrictionPolicy.Required
				},
				bp = e => {
					const t = {
						bodyBlacklistedStrings: e.bodyBlacklistedStrings,
						bodyRegexPatterns: e.bodyRegexes,
						bodyRequiredStrings: e.bodyRequiredStrings,
						bodyRestrictionPolicy: pp[e.bodyRestrictionPolicy],
						linkBlacklistedDomainsLength: e.domainBlacklist.length,
						linkWhitelistedDomainsLength: e.domainWhitelist.length,
						numberRepostFrequencyDays: e.linkRepostAge || void 0,
						requirePostFlair: e.isFlairRequired,
						titleBlacklistedStrings: e.titleBlacklistedStrings,
						titleRegexPatterns: e.titleRegexes,
						titleRequiredStrings: e.titleRequiredStrings,
						titleTextMaxLength: e.titleTextMaxLength || void 0,
						titleTextMinLength: e.titleTextMinLength || void 0
					};
					return lp()(t, e => Array.isArray(e) && !e.length)
				},
				hp = e => t => Object.assign({
					source: "post_requirements",
					action: "save",
					noun: "settings"
				}, y.defaults(t), {
					postRequirement: bp(e),
					subreddit: y.subreddit(t),
					userSubreddit: y.userSubreddit(t)
				});
			var gp = s("./src/reddit/selectors/postRequirements.ts");
			const Ep = "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360010322091"),
				xp = 15,
				fp = 40,
				vp = {
					guidelines: {
						enabled: !1,
						guidelineText: "",
						clientErrors: []
					},
					titleRequiredStrings: {
						enabled: !1,
						strings: [],
						clientErrors: []
					},
					titleBlacklistedStrings: {
						enabled: !1,
						strings: [],
						clientErrors: []
					},
					titleLength: {
						enabled: !1,
						min: null,
						max: null,
						clientErrors: []
					},
					titleRegexes: {
						enabled: !1,
						regexes: [],
						serverErrors: []
					},
					bodyRequirement: {
						enabled: !0,
						restrictionPolicy: mp.a.None
					},
					bodyRequiredStrings: {
						enabled: !1,
						strings: [],
						clientErrors: []
					},
					bodyBlacklistedStrings: {
						enabled: !1,
						strings: [],
						clientErrors: []
					},
					bodyRegexes: {
						enabled: !1,
						regexes: [],
						serverErrors: []
					},
					linkDomains: {
						enabled: !1,
						restrictionPolicy: mp.b.Whitelist,
						domainsText: "",
						clientErrors: [],
						serverErrors: []
					},
					repostFrequency: {
						enabled: !1,
						days: null
					},
					flairRequirement: {
						enabled: !1
					}
				};
			var Cp = s("./src/reddit/components/ModHub/PostRequirements/ExperimentalWarning/index.m.less"),
				Op = s.n(Cp),
				jp = () => r.a.createElement(Tn.a, {
					className: Op.a.container,
					color: qn.a.notice,
					icon: r.a.createElement(J.a, {
						className: Op.a.icon
					}),
					subtitle: Object(G.c)("This feature is experimental and only works for users posting on the redesign"),
					title: Object(G.c)("This feature is experimental")
				}),
				yp = s("./src/reddit/helpers/styles/mixins/loading.ts"),
				kp = s("./src/reddit/components/ModHub/PostRequirements/FormPlaceholder/index.m.less"),
				wp = s.n(kp);
			var Sp = e => {
					let {
						isLoading: t
					} = e;
					return o.createElement("div", {
						className: Object(d.a)(wp.a.container, Object(yp.a)({
							isLoading: !1
						}))
					}, Ne()(3).map(e => o.createElement("div", {
						key: e,
						className: wp.a.section
					}, o.createElement("div", {
						className: Object(d.a)(wp.a.sectionTitle, Object(yp.b)({
							isLoading: t
						}))
					}), o.createElement("div", {
						className: wp.a.line
					}), Ne()(2).map(e => o.createElement("div", {
						key: e,
						className: Object(d.a)(wp.a.sectionBodyRow, Object(yp.b)({
							isLoading: t
						}))
					})))))
				},
				Np = s("./src/reddit/components/ModHub/PostRequirements/LabeledControl/index.m.less"),
				Tp = s.n(Np);
			const _p = e => e.preventDefault();
			var Ip = e => r.a.createElement("div", {
					className: Object(d.a)(e.className, Tp.a.container)
				}, r.a.createElement("label", {
					className: Tp.a.label,
					onClick: _p
				}, r.a.createElement("div", {
					className: Tp.a.labelText
				}, e.label), e.children)),
				Pp = s("./src/reddit/featureFlags/component.tsx"),
				Mp = s("./src/reddit/components/ModHub/PostRequirements/index.m.less"),
				Rp = s.n(Mp);
			const Lp = m.a.wrapped($s.n, "toggleSetting", Rp.a),
				Dp = Object(Pp.a)("newPostRequirements", r.a.Fragment),
				Ap = r.a.createElement("a", {
					className: Rp.a.externalLink,
					href: "https://docs.python.org/2/library/re.html#regular-expression-syntax",
					target: "_blank"
				}, Object(G.c)("Python RegEx syntax")),
				Fp = e => e.regexes.map(t => {
					const s = e.serverErrors.find(e => e.regex === t);
					return s ? s.message : ""
				}),
				Bp = e => e.serverErrors.filter(e => null === e.regex).map(e => e.message);
			var Up = class extends r.a.Component {
					constructor() {
						super(...arguments), this.onToggleTitleRegex = () => {
							const {
								titleRegexes: e
							} = this.props.formState;
							this.props.onChange({
								titleRegexes: Object.assign({}, e, {
									enabled: !e.enabled
								})
							})
						}, this.onToggleBodyRegex = () => {
							const {
								bodyRegexes: e
							} = this.props.formState;
							this.props.onChange({
								bodyRegexes: Object.assign({}, e, {
									enabled: !e.enabled
								})
							})
						}, this.onTitleRegexChange = e => {
							const {
								titleRegexes: t
							} = this.props.formState;
							this.props.onChange({
								titleRegexes: Object.assign({}, t, {
									regexes: e,
									serverErrors: []
								})
							})
						}, this.onBodyRegexChange = e => {
							const {
								bodyRegexes: t
							} = this.props.formState;
							this.props.onChange({
								bodyRegexes: Object.assign({}, t, {
									regexes: e,
									serverErrors: []
								})
							})
						}
					}
					render() {
						const {
							formState: e
						} = this.props, t = e.bodyRequirement.restrictionPolicy === mp.a.NotAllowed;
						return r.a.createElement("fieldset", null, r.a.createElement("legend", {
							className: Rp.a.sectionLegend
						}, Object(G.c)("Advanced tools")), r.a.createElement(Lp, {
							on: e.titleRegexes.enabled,
							onClick: this.onToggleTitleRegex,
							label: Object(G.c)("Title text RegEx requirements"),
							subtext: r.a.createElement(r.a.Fragment, null, Object(G.c)("Use regular expressions for more advanced title matching. These use the "), Ap)
						}), e.titleRegexes.enabled && r.a.createElement(Ip, {
							label: Object(G.c)("Title must match one of:")
						}, r.a.createElement(rn.d, {
							className: Rp.a.multipleInput,
							disabled: !1,
							errors: Fp(e.titleRegexes),
							values: e.titleRegexes.regexes,
							onChange: this.onTitleRegexChange,
							maxLength: 5,
							addValueText: Object(G.c)("Add regex")
						}), r.a.createElement(Yc.a, {
							messages: Bp(e.titleRegexes)
						})), r.a.createElement(Dp, null, r.a.createElement(Lp, {
							disabled: t,
							on: e.bodyRegexes.enabled,
							onClick: this.onToggleBodyRegex,
							label: Object(G.c)("Body text RegEx requirements"),
							subtext: r.a.createElement(r.a.Fragment, null, Object(G.c)("Use regular expressions for more advanced body text matching. These use the "), Ap)
						}), !t && e.bodyRegexes.enabled && r.a.createElement(Ip, {
							label: Object(G.c)("Body must match one of:")
						}, r.a.createElement(rn.d, {
							className: Rp.a.multipleInput,
							disabled: !1,
							errors: Fp(e.bodyRegexes),
							values: e.bodyRegexes.regexes,
							onChange: this.onBodyRegexChange,
							maxLength: 5,
							addValueText: Object(G.c)("Add regex")
						}), r.a.createElement(Yc.a, {
							messages: Bp(e.bodyRegexes)
						}))))
					}
				},
				Hp = class extends r.a.Component {
					constructor() {
						super(...arguments), this.onToggleFlairRequirement = () => {
							const {
								formState: e
							} = this.props;
							this.props.onChange({
								flairRequirement: Object.assign({}, e.flairRequirement, {
									enabled: !e.flairRequirement.enabled
								})
							})
						}
					}
					render() {
						const {
							formState: e
						} = this.props;
						return r.a.createElement("fieldset", null, r.a.createElement("legend", {
							className: Rp.a.sectionLegend
						}, Object(G.c)("Post flair")), r.a.createElement(Lp, {
							on: e.flairRequirement.enabled,
							onClick: this.onToggleFlairRequirement,
							label: Object(G.c)("Require post flair"),
							subtext: p.fbt._("All posts must have a post flair attached to the post. Note that this requirement is ignored if subreddit doesn't have flairs available for users to select.", null, {
								hk: "KxyFE"
							})
						}))
					}
				},
				Wp = s("./node_modules/lodash/mapValues.js"),
				qp = s.n(Wp);
			const Vp = e => e.split(/[,;\s]/).filter(Boolean),
				zp = e => e.join(", "),
				Kp = ["i.redd.it", "v.redd.it"],
				Qp = /^(?:[\w-]+\.)+[\w]+$/,
				Gp = e => Kp.includes(e.toLowerCase());
			var Jp = e => {
					const t = Vp(e),
						s = [],
						n = t.find(e => !(e => Qp.test(e))(e));
					return n && s.push(Object(G.c)('Invalid domain: "'.concat(Object(G.b)("domainName", n), '"'))), t.some(Gp) && s.push(Object(G.c)("Domains cannot include reddit hosted content.")), s
				},
				Zp = e => {
					const {
						min: t,
						max: s,
						minLimit: n,
						maxLimit: a
					} = e, o = [];
					return null !== t && (t < n || t > a) && o.push({
						field: "min",
						message: Object(G.c)("Minimum must be between ".concat(Object(G.b)("min", n), " and ").concat(Object(G.b)("max", a)))
					}), null !== s && (s < n || s > a) && o.push({
						field: "max",
						message: Object(G.c)("Maximum must be between ".concat(Object(G.b)("min", n), " and ").concat(Object(G.b)("max", a)))
					}), !o.length && null !== t && null !== s && t > s && o.push({
						field: "both",
						message: Object(G.c)("Maximum must be greater than or equal to minimum")
					}), o
				};
			const Xp = e => null !== e ? e.toString() : "",
				Yp = e => e.map(e => e.trim().toLowerCase()).filter(Boolean),
				$p = (e, t) => {
					const s = new Set(Yp(e)),
						n = Yp(t).find(e => s.has(e));
					return n ? [p.fbt._('Word "{word}" is required and banned at the same time', [p.fbt._param("word", n)], {
						hk: "2Hyh3c"
					}).toString()] : []
				},
				eb = (e, t) => {
					if (!t) return [];
					const s = e.find(e => e.length > t);
					return s ? [p.fbt._('Word "{word}" is longer than maximum title length', [p.fbt._param("word", s)], {
						hk: "48duSv"
					}).toString()] : []
				},
				tb = e => {
					const t = e.titleRequiredStrings.enabled ? e.titleRequiredStrings.strings : [];
					return {
						blacklistedStrings: e.titleBlacklistedStrings.enabled ? e.titleBlacklistedStrings.strings : [],
						maxTitleLength: e.titleLength.enabled ? e.titleLength.max : null,
						requiredStrings: t
					}
				},
				sb = e => {
					const {
						bodyRequirement: t,
						bodyRequiredStrings: s,
						bodyBlacklistedStrings: n
					} = e, a = t.restrictionPolicy !== mp.a.NotAllowed, o = t.restrictionPolicy === mp.a.Required;
					return $p(o && s.enabled ? s.strings : [], a && n.enabled ? n.strings : [])
				},
				nb = sb,
				ab = e => qp()(e, e => Object.assign({}, e)),
				ob = (e, t) => {
					const s = t.filter(Boolean);
					return 1 === s.length ? s[0] : null
				},
				rb = (e, t) => {
					if (!t.length) return e;
					const s = ab(e);
					return t.forEach(e => {
						switch (e.field) {
							case "titleRegexes":
							case "bodyRegexes": {
								const t = s[e.field];
								t.serverErrors.push({
									regex: ob(e.message, t.regexes),
									message: e.message
								});
								break
							}
							case "domainBlacklist":
							case "domainWhitelist":
								s.linkDomains.serverErrors.push(e.message)
						}
					}), s
				},
				ib = e => e.enabled && !e.guidelineText.trim() ? [Object(G.c)("Guideline text cannot be empty")] : [],
				cb = e => {
					const t = ab(e);
					return t.guidelines.clientErrors = ib(t.guidelines), t.linkDomains.clientErrors = Jp(t.linkDomains.domainsText), t.titleLength.clientErrors = (e => {
						let {
							min: t,
							max: s
						} = e;
						return Zp({
							min: t,
							max: s,
							minLimit: 2,
							maxLimit: 300
						})
					})(t.titleLength), t.bodyBlacklistedStrings.clientErrors = nb(t), t.bodyRequiredStrings.clientErrors = sb(t), t.titleBlacklistedStrings.clientErrors = (e => {
						const t = tb(e);
						return [...$p(t.requiredStrings, t.blacklistedStrings), ...eb(t.blacklistedStrings, t.maxTitleLength)]
					})(t), t.titleRequiredStrings.clientErrors = (e => {
						const t = tb(e);
						return [...$p(t.requiredStrings, t.blacklistedStrings), ...eb(t.requiredStrings, t.maxTitleLength)]
					})(t), t
				},
				db = e => Object.keys(e).some(t => {
					const s = e[t];
					return s.enabled && !(ip()(s.clientErrors) && ip()(s.serverErrors))
				});
			var lb = class extends r.a.Component {
					constructor() {
						super(...arguments), this.onToggleGuidelines = () => {
							const {
								formState: e
							} = this.props;
							this.props.onChange({
								guidelines: Object.assign({}, e.guidelines, {
									enabled: !e.guidelines.enabled
								})
							})
						}, this.onGuidelineTextChange = e => {
							const t = e.target.value,
								{
									formState: s
								} = this.props;
							this.props.onChange({
								guidelines: Object.assign({}, s.guidelines, {
									guidelineText: t,
									clientErrors: ib(Object.assign({}, s.guidelines, {
										guidelineText: t
									}))
								})
							})
						}
					}
					render() {
						const {
							formState: e
						} = this.props;
						return r.a.createElement("fieldset", null, r.a.createElement("legend", {
							className: Rp.a.sectionLegend
						}, Object(G.c)("General")), r.a.createElement(Lp, {
							on: e.guidelines.enabled,
							onClick: this.onToggleGuidelines,
							label: Object(G.c)("Posting guidelines"),
							subtext: Object(G.c)("Give a quick sentence or two on how to successfully post in your community. Try not to just put “read the rules”. Instead, give them a positive guideline on what they can do correctly. This field supports plain text.")
						}), e.guidelines.enabled && r.a.createElement(Ip, {
							label: Object(G.c)("Guideline text")
						}, r.a.createElement("textarea", {
							"aria-invalid": !!e.guidelines.clientErrors.length,
							className: Rp.a.textarea,
							maxLength: 400,
							onChange: this.onGuidelineTextChange,
							placeholder: Object(G.c)("Example: Only make post about dogs"),
							required: !0,
							value: e.guidelines.guidelineText
						}), e.guidelines.clientErrors.length ? r.a.createElement(Yc.a, {
							messages: e.guidelines.clientErrors
						}) : r.a.createElement(Zc.a, {
							className: Rp.a.characterCountdown,
							maxChars: 400,
							text: e.guidelines.guidelineText
						})))
					}
				},
				mb = (e, t, s) => {
					let n = Math.abs(parseInt(e, 10));
					return Number.isInteger(n) ? (void 0 !== t && n < t && (n = t), void 0 !== s && n > s && (n = s), n) : null
				},
				ub = class extends r.a.Component {
					constructor() {
						super(...arguments), this.onToggleLinkDomains = () => {
							const {
								formState: e
							} = this.props;
							this.props.onChange({
								linkDomains: Object.assign({}, e.linkDomains, {
									enabled: !e.linkDomains.enabled
								})
							})
						}, this.onToggleRepostFrequency = () => {
							const {
								formState: e
							} = this.props;
							this.props.onChange({
								repostFrequency: Object.assign({}, e.repostFrequency, {
									enabled: !e.repostFrequency.enabled
								})
							})
						}, this.onRepostFrequencyChange = e => {
							const {
								formState: t
							} = this.props, s = mb(e.target.value, 1, 90);
							this.props.onChange({
								repostFrequency: Object.assign({}, t.repostFrequency, {
									days: s
								})
							})
						}, this.onRestrictionPolicyChange = e => {
							const {
								formState: t
							} = this.props;
							this.props.onChange({
								linkDomains: Object.assign({}, t.linkDomains, {
									restrictionPolicy: e
								})
							})
						}, this.onLinkDomainsTextChange = e => {
							const {
								formState: t
							} = this.props, s = e.target.value;
							this.props.onChange({
								linkDomains: Object.assign({}, t.linkDomains, {
									domainsText: s,
									serverErrors: []
								})
							})
						}, this.onLinkDomainsBlur = () => {
							const {
								linkDomains: e
							} = this.props.formState, t = (e => zp(Vp(e)))(e.domainsText), s = Jp(t);
							this.props.onChange({
								linkDomains: Object.assign({}, e, {
									domainsText: t,
									clientErrors: s
								})
							})
						}
					}
					render() {
						const {
							formState: e,
							isLoading: t
						} = this.props, s = e.linkDomains.serverErrors.length ? e.linkDomains.serverErrors : e.linkDomains.clientErrors;
						return r.a.createElement("fieldset", null, r.a.createElement("legend", {
							className: Rp.a.sectionLegend
						}, Object(G.c)("Link posts")), r.a.createElement(Lp, {
							on: e.linkDomains.enabled,
							onClick: this.onToggleLinkDomains,
							label: Object(G.c)("Link domain restrictions"),
							subtext: Object(G.c)("Require or block links from certain domains")
						}), e.linkDomains.enabled && r.a.createElement(r.a.Fragment, null, r.a.createElement(Ip, {
							label: Object(G.c)("Restriction type")
						}, r.a.createElement(sn.a, {
							value: e.linkDomains.restrictionPolicy,
							name: "restrictionType",
							onChange: this.onRestrictionPolicyChange
						}, r.a.createElement(Dm.a, {
							className: Rp.a.radioOption,
							showButton: !0,
							value: mp.b.Whitelist
						}, Object(G.c)("Required domains")), r.a.createElement(Dm.a, {
							className: Rp.a.radioOption,
							showButton: !0,
							value: mp.b.Blacklist
						}, Object(G.c)("Blocked domains")))), r.a.createElement(Ip, {
							label: e.linkDomains.restrictionPolicy === mp.b.Whitelist ? Object(G.c)("Only allow link posts with these domains") : Object(G.c)("Block link posts with these domains")
						}, r.a.createElement("textarea", {
							"aria-invalid": !!s.length,
							className: Rp.a.domainsTextarea,
							maxLength: 1e5,
							onBlur: this.onLinkDomainsBlur,
							onChange: this.onLinkDomainsTextChange,
							placeholder: Object(G.c)("Example: website.com"),
							required: !0,
							spellCheck: !1,
							value: e.linkDomains.domainsText
						}), r.a.createElement(Yc.a, {
							messages: s
						}))), r.a.createElement(Lp, {
							on: e.repostFrequency.enabled,
							onClick: this.onToggleRepostFrequency,
							label: Object(G.c)("Repost frequency"),
							subtext: Object(G.c)("Prevent users from posting a link that was already posted to your community within x days of the original")
						}), e.repostFrequency.enabled && r.a.createElement(rn.b, {
							className: Rp.a.repostFrequencyInput,
							disabled: t,
							label: Object(G.c)("number of days"),
							max: 90,
							min: 1,
							onChange: this.onRepostFrequencyChange,
							type: "number",
							value: Xp(e.repostFrequency.days)
						}))
					}
				},
				pb = s("./src/lib/memoizeByReference/index.ts"),
				bb = s("./src/reddit/components/MultiOptionSelect/index.tsx"),
				hb = s("./src/reddit/components/ModHub/PostRequirements/MultiStringsInput/index.m.less"),
				gb = s.n(hb);
			class Eb extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						pendingItemText: ""
					}, this.onInputChanged = e => {
						this.setState({
							pendingItemText: e
						})
					}, this.getOptions = Object(pb.a)(e => e.map(e => ({
						id: e,
						displayText: e,
						selected: !0
					}))), this.onOptionsChanged = e => {
						const t = this.getOptions(this.props.strings),
							s = new Map;
						t.forEach(e => s.set(e.displayText, e)), e.forEach(e => s.set(e.displayText, e));
						const n = [...s.values()].filter(e => e.selected && !!e.displayText.trim()).map(e => e.displayText.slice(0, fp).toLowerCase()).slice(0, xp);
						this.props.onChange(n)
					}
				}
				render() {
					const e = this.getOptions(this.props.strings),
						t = e.length < xp;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(bb.a, {
						className: gb.a.control,
						addText: Object(G.c)("Add"),
						allowFreeTextEntry: !0,
						input: this.state.pendingItemText,
						isError: this.props.errors.length > 0,
						isLoading: !1,
						maxOptionLength: t ? fp : 0,
						onInputChanged: this.onInputChanged,
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: e
					}), r.a.createElement(Yc.a, {
						messages: this.props.errors
					}), r.a.createElement("div", {
						className: gb.a.wordsCountdown
					}, Object(G.c)("".concat(e.length, "/").concat(Object(G.b)("maxOptions", xp), " words"))))
				}
			}
			var xb = class extends r.a.Component {
					constructor() {
						super(...arguments), this.onToggleBodyRequiredStrings = () => {
							const {
								formState: e
							} = this.props;
							this.props.onChange({
								bodyRequiredStrings: Object.assign({}, e.bodyRequiredStrings, {
									enabled: !e.bodyRequiredStrings.enabled
								})
							})
						}, this.onToggleBodyBlacklistedStrings = () => {
							const {
								formState: e
							} = this.props;
							this.props.onChange({
								bodyBlacklistedStrings: Object.assign({}, e.bodyBlacklistedStrings, {
									enabled: !e.bodyBlacklistedStrings.enabled
								})
							})
						}, this.onBodyRestrictionPolicyChange = e => {
							const {
								bodyRequirement: t
							} = this.props.formState;
							this.props.onChange({
								bodyRequirement: Object.assign({}, t, {
									restrictionPolicy: e
								})
							})
						}, this.onBodyRequiredStringsChange = e => {
							const {
								bodyRequiredStrings: t
							} = this.props.formState;
							this.props.onChange({
								bodyRequiredStrings: Object.assign({}, t, {
									strings: e
								})
							}, !0)
						}, this.onBodyBlacklistedStringsChange = e => {
							const {
								bodyBlacklistedStrings: t
							} = this.props.formState;
							this.props.onChange({
								bodyBlacklistedStrings: Object.assign({}, t, {
									strings: e
								})
							}, !0)
						}
					}
					render() {
						const {
							formState: e,
							isLoading: t
						} = this.props;
						return r.a.createElement("fieldset", null, r.a.createElement("legend", {
							className: Rp.a.sectionLegend
						}, Object(G.c)("Text posts")), r.a.createElement($s.c, {
							className: Rp.a.bodyRestrictionSetting,
							direction: "column",
							label: Object(G.c)("Text post body"),
							subtext: Object(G.c)("Allow text posts to have body text")
						}, r.a.createElement(sn.a, {
							disabled: t,
							name: "body_restriction",
							onChange: this.onBodyRestrictionPolicyChange,
							value: e.bodyRequirement.restrictionPolicy
						}, r.a.createElement(Dm.a, {
							className: Rp.a.radioOption,
							showButton: !0,
							value: mp.a.None
						}, Object(G.c)("Post body is optional")), r.a.createElement(Dm.a, {
							className: Rp.a.radioOption,
							showButton: !0,
							value: mp.a.Required
						}, Object(G.c)("Post body is required")), r.a.createElement(Dm.a, {
							className: Rp.a.radioOption,
							showButton: !0,
							value: mp.a.NotAllowed
						}, Object(G.c)("Post body is disabled")))), e.bodyRequirement.restrictionPolicy === mp.a.Required && r.a.createElement(Dp, null, r.a.createElement(Lp, {
							on: e.bodyRequiredStrings.enabled,
							onClick: this.onToggleBodyRequiredStrings,
							label: Object(G.c)("Required words"),
							subtext: Object(G.c)("Require at least one of these words in the body (up to 15 words of 40 characters each)")
						}), e.bodyRequiredStrings.enabled && r.a.createElement(Ip, {
							label: Object(G.c)("Add required words")
						}, r.a.createElement(Eb, {
							errors: e.bodyRequiredStrings.clientErrors,
							onChange: this.onBodyRequiredStringsChange,
							strings: e.bodyRequiredStrings.strings
						}))), e.bodyRequirement.restrictionPolicy !== mp.a.NotAllowed && r.a.createElement(Dp, null, r.a.createElement(Lp, {
							on: e.bodyBlacklistedStrings.enabled,
							onClick: this.onToggleBodyBlacklistedStrings,
							label: Object(G.c)("Banned words"),
							subtext: Object(G.c)("Do not allow any of these words in the body (up to 15 words of 40 characters each)")
						}), e.bodyBlacklistedStrings.enabled && r.a.createElement(Ip, {
							label: Object(G.c)("Add banned words")
						}, r.a.createElement(Eb, {
							errors: e.bodyBlacklistedStrings.clientErrors,
							onChange: this.onBodyBlacklistedStringsChange,
							strings: e.bodyBlacklistedStrings.strings
						}))))
					}
				},
				fb = s("./src/reddit/components/ModHub/PostRequirements/MinMaxInput/index.m.less"),
				vb = s.n(fb);
			class Cb extends r.a.Component {
				constructor() {
					super(...arguments), this.minInputRef = r.a.createRef(), this.maxInputRef = r.a.createRef(), this.onChange = (e, t) => {
						const {
							min: s,
							max: n,
							minLimit: a,
							maxLimit: o
						} = this.props, r = Math.min(a, 1), i = mb(e.target.value, r, o), c = {
							min: "min" === t ? i : s,
							max: "max" === t ? i : n
						};
						this.props.onChange(Object.assign({}, c, {
							clientErrors: Zp(Object.assign({}, c, {
								maxLimit: o,
								minLimit: a
							}))
						}))
					}, this.onMinChange = e => this.onChange(e, "min"), this.onMaxChange = e => this.onChange(e, "max"), this.onBlur = () => {
						const {
							min: e,
							max: t
						} = this.props, s = this.minInputRef.current, n = this.maxInputRef.current;
						s.value = Xp(e), n.value = Xp(t)
					}
				}
				render() {
					const {
						errors: e,
						max: t,
						maxLimit: s,
						min: n,
						minLimit: a
					} = this.props, o = e.map(e => e.message), i = e.some(e => "both" === e.field), c = i || e.some(e => "min" === e.field), d = i || e.some(e => "max" === e.field);
					return r.a.createElement("div", {
						onBlur: this.onBlur
					}, r.a.createElement("div", null, r.a.createElement(rn.b, {
						className: vb.a.minInput,
						inputRef: this.minInputRef,
						isInvalid: c,
						label: Object(G.c)("min"),
						max: s,
						min: a,
						onChange: this.onMinChange,
						type: "number",
						value: Xp(n)
					}), r.a.createElement(rn.b, {
						className: vb.a.maxInput,
						inputRef: this.maxInputRef,
						isInvalid: d,
						label: Object(G.c)("max"),
						max: s,
						min: a,
						onChange: this.onMaxChange,
						type: "number",
						value: Xp(t)
					})), r.a.createElement(Yc.a, {
						className: vb.a.errorMessages,
						messages: o
					}))
				}
			}

			function Ob() {
				return (Ob = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			const jb = [lb, class extends r.a.Component {
				constructor() {
					super(...arguments), this.onToggleTitleRequiredStrings = () => {
						const {
							formState: e
						} = this.props;
						this.props.onChange({
							titleRequiredStrings: Object.assign({}, e.titleRequiredStrings, {
								enabled: !e.titleRequiredStrings.enabled
							})
						})
					}, this.onToggleTitleBlacklistedStrings = () => {
						const {
							formState: e
						} = this.props;
						this.props.onChange({
							titleBlacklistedStrings: Object.assign({}, e.titleBlacklistedStrings, {
								enabled: !e.titleBlacklistedStrings.enabled
							})
						})
					}, this.onToggleTitleLength = () => {
						const {
							formState: e
						} = this.props;
						this.props.onChange({
							titleLength: Object.assign({}, e.titleLength, {
								enabled: !e.titleLength.enabled
							})
						})
					}, this.onTitleRequiredStringsChange = e => {
						const {
							titleRequiredStrings: t
						} = this.props.formState;
						this.props.onChange({
							titleRequiredStrings: Object.assign({}, t, {
								strings: e
							})
						}, !0)
					}, this.onTitleBlacklistedStringsChange = e => {
						const {
							titleBlacklistedStrings: t
						} = this.props.formState;
						this.props.onChange({
							titleBlacklistedStrings: Object.assign({}, t, {
								strings: e
							})
						}, !0)
					}, this.onTitleLengthChange = e => {
						const {
							titleLength: t
						} = this.props.formState;
						this.props.onChange({
							titleLength: Object.assign({}, t, e)
						})
					}
				}
				render() {
					const {
						formState: e
					} = this.props;
					return r.a.createElement("fieldset", null, r.a.createElement("legend", {
						className: Rp.a.sectionLegend
					}, Object(G.c)("Title")), r.a.createElement(Lp, {
						on: e.titleRequiredStrings.enabled,
						onClick: this.onToggleTitleRequiredStrings,
						label: Object(G.c)("Required words"),
						subtext: Object(G.c)("Require at least one of these words in the title (up to 15 words of 40 characters each)")
					}), e.titleRequiredStrings.enabled && r.a.createElement(Ip, {
						label: Object(G.c)("Add required words")
					}, r.a.createElement(Eb, {
						errors: e.titleRequiredStrings.clientErrors,
						onChange: this.onTitleRequiredStringsChange,
						strings: e.titleRequiredStrings.strings
					})), r.a.createElement(Dp, null, r.a.createElement(Lp, {
						on: e.titleBlacklistedStrings.enabled,
						onClick: this.onToggleTitleBlacklistedStrings,
						label: Object(G.c)("Banned words"),
						subtext: Object(G.c)("Do not allow any of these words in the title (up to 15 words of 40 characters each)")
					}), e.titleBlacklistedStrings.enabled && r.a.createElement(Ip, {
						label: Object(G.c)("Add banned words")
					}, r.a.createElement(Eb, {
						errors: e.titleBlacklistedStrings.clientErrors,
						onChange: this.onTitleBlacklistedStringsChange,
						strings: e.titleBlacklistedStrings.strings
					}))), r.a.createElement(Lp, {
						on: e.titleLength.enabled,
						onClick: this.onToggleTitleLength,
						label: Object(G.c)("Length restrictions"),
						subtext: Object(G.c)("Set a minimum and/or maximum title length (empty is no restriction)")
					}), e.titleLength.enabled && r.a.createElement(Ip, {
						label: Object(G.c)("Character length")
					}, r.a.createElement(Cb, {
						onChange: this.onTitleLengthChange,
						min: e.titleLength.min,
						max: e.titleLength.max,
						minLimit: 2,
						maxLimit: 300,
						errors: e.titleLength.clientErrors
					})))
				}
			}, xb, ub, Hp, Up];
			var yb = e => r.a.createElement(r.a.Fragment, null, jb.map((t, s) => r.a.createElement(t, Ob({
				key: s
			}, e))));
			const kb = {
					bodyBlacklistedStrings: [],
					bodyRegexes: [],
					bodyRequiredStrings: [],
					bodyRestrictionPolicy: mp.a.None,
					domainBlacklist: [],
					domainWhitelist: [],
					guidelinesText: null,
					isFlairRequired: !1,
					linkRepostAge: null,
					linkRestrictionPolicy: mp.b.None,
					titleBlacklistedStrings: [],
					titleRegexes: [],
					titleRequiredStrings: [],
					titleTextMaxLength: null,
					titleTextMinLength: null
				},
				wb = e => e.filter(e => !!e);
			var Sb = e => {
					const t = Object.assign({}, kb, {
							bodyRestrictionPolicy: e.bodyRequirement.restrictionPolicy,
							guidelinesText: e.guidelines.enabled ? e.guidelines.guidelineText : null,
							isFlairRequired: e.flairRequirement.enabled,
							linkRepostAge: e.repostFrequency.enabled ? e.repostFrequency.days : null,
							linkRestrictionPolicy: e.linkDomains.enabled ? e.linkDomains.restrictionPolicy : mp.b.None,
							titleBlacklistedStrings: e.titleBlacklistedStrings.enabled ? e.titleBlacklistedStrings.strings : [],
							titleRegexes: e.titleRegexes.enabled ? wb(e.titleRegexes.regexes) : [],
							titleRequiredStrings: e.titleRequiredStrings.enabled ? e.titleRequiredStrings.strings : [],
							titleTextMaxLength: e.titleLength.enabled ? e.titleLength.max : null,
							titleTextMinLength: e.titleLength.enabled ? e.titleLength.min : null
						}),
						s = e.bodyRequirement.restrictionPolicy !== mp.a.NotAllowed,
						n = e.bodyRequirement.restrictionPolicy === mp.a.Required;
					if (s && (t.bodyBlacklistedStrings = e.bodyBlacklistedStrings.enabled ? e.bodyBlacklistedStrings.strings : [], t.bodyRequiredStrings = n && e.bodyRequiredStrings.enabled ? e.bodyRequiredStrings.strings : [], t.bodyRegexes = e.bodyRegexes.enabled ? wb(e.bodyRegexes.regexes) : []), e.linkDomains.enabled) {
						const s = Vp(e.linkDomains.domainsText);
						e.linkDomains.restrictionPolicy === mp.b.Whitelist ? t.domainWhitelist = s : e.linkDomains.restrictionPolicy === mp.b.Blacklist && (t.domainBlacklist = s)
					}
					return t
				},
				Nb = (e, t) => {
					if (_s()(e, t)) return {};
					const s = Sb(e),
						n = Sb(t);
					return lp()(s, (e, t) => _s()(e, n[t]))
				},
				Tb = e => {
					const {
						bodyBlacklistedStrings: t,
						bodyRegexes: s,
						bodyRequiredStrings: n,
						bodyRestrictionPolicy: a,
						domainBlacklist: o,
						domainWhitelist: r,
						guidelinesText: i,
						isFlairRequired: c,
						linkRepostAge: d,
						linkRestrictionPolicy: l,
						titleBlacklistedStrings: m,
						titleRegexes: u,
						titleRequiredStrings: p,
						titleTextMaxLength: b,
						titleTextMinLength: h
					} = e;
					return Object.assign({}, vp, {
						guidelines: {
							enabled: !(!i || !i.trim()),
							guidelineText: i || "",
							clientErrors: []
						},
						titleRequiredStrings: {
							enabled: !!p.length,
							strings: p,
							clientErrors: []
						},
						titleBlacklistedStrings: {
							enabled: !!m.length,
							strings: m,
							clientErrors: []
						},
						titleLength: {
							enabled: null !== h || null !== b,
							min: h,
							max: b,
							clientErrors: []
						},
						bodyRequirement: {
							enabled: !0,
							restrictionPolicy: a
						}
					}, a !== mp.a.NotAllowed ? {
						bodyRequiredStrings: {
							enabled: !!n.length,
							strings: n,
							clientErrors: []
						},
						bodyBlacklistedStrings: {
							enabled: !!t.length,
							strings: t,
							clientErrors: []
						},
						bodyRegexes: {
							enabled: !!s.length,
							regexes: s,
							serverErrors: []
						}
					} : null, {
						titleRegexes: {
							enabled: !!u.length,
							regexes: u,
							serverErrors: []
						},
						linkDomains: {
							enabled: l !== mp.b.None,
							restrictionPolicy: l === mp.b.None ? mp.b.Whitelist : l,
							domainsText: l !== mp.b.None ? zp(l === mp.b.Whitelist ? r : o) : "",
							clientErrors: [],
							serverErrors: []
						},
						repostFrequency: {
							enabled: null !== d,
							days: d
						},
						flairRequirement: {
							enabled: c
						}
					})
				};
			const _b = "PostReq-discard-confirmation",
				Ib = 150,
				Pb = Object(c.c)({
					allowNavigationCallback: Qu.a,
					isDiscardModalOpen: Object(tt.b)(_b),
					isLoading: gp.a,
					requirements: gp.b
				});
			class Mb extends r.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.formBodyRef = r.a.createRef(), this.isUnmounted = !1, this.resetPendingNavigation = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!1)
					}, this.performPendingNavigationIfNeeded = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!0)
					}, this.saveFormState = async () => {
						const {
							requirements: e
						} = this.props, {
							initialFormState: t
						} = this.state;
						if (!e) return;
						const s = cb(this.state.formState);
						if (db(s)) return void this.setState({
							formState: s
						}, this.focusErrorField);
						const n = Nb(s, t);
						if (ip()(n)) return;
						this.setState({
							isSavePending: !0
						});
						const a = await this.props.onSave(n);
						if (!this.isUnmounted)
							if (this.setState({
									isSavePending: !1
								}), a.success) this.props.sendEvent(hp(Sb(s))), this.setState({
								formState: s,
								initialFormState: s,
								hasJustSaved: !0
							});
							else if (a.errors) {
							const e = rb(s, a.errors);
							this.setState({
								formState: e
							}, this.focusErrorField)
						}
					}, this.updateHasUnsavedChanges = op()(() => {
						this.setState(e => {
							const {
								formState: t,
								initialFormState: s
							} = e, n = Nb(t, s), a = !ip()(n);
							return a !== e.hasUnsavedChanges ? {
								hasUnsavedChanges: a
							} : null
						})
					}, 200, {
						maxWait: 500
					}), this.focusErrorField = () => {
						const e = this.formBodyRef.current.querySelector('[aria-invalid="true"]');
						e instanceof HTMLElement && (e.focus(), e.getBoundingClientRect().top < Ib && (e.scrollIntoView(), window.scroll(0, window.scrollY - Ib)))
					}, this.onFormFieldBlur = () => {
						this.updateHasUnsavedChanges(), this.updateHasUnsavedChanges.flush()
					}, this.onSaveClick = () => {
						this.saveFormState()
					}, this.onDiscardUnsavedChangesConfirmed = () => {
						this.performPendingNavigationIfNeeded()
					}, this.onCloseModal = () => {
						this.props.closeAllModals(), this.resetPendingNavigation()
					}, this.onFormStateChange = function(e) {
						let s = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						t.setState(t => {
							let n = Object.assign({}, t.formState, e);
							return s && (n = cb(n)), {
								formState: n,
								hasJustSaved: !1
							}
						})
					};
					const s = e.requirements ? Tb(e.requirements) : vp;
					this.state = {
						areRequirementsLoaded: !!e.requirements,
						formState: s,
						hasJustSaved: !1,
						hasUnsavedChanges: !1,
						initialFormState: s,
						isSavePending: !1
					}
				}
				componentWillUnmount() {
					this.isUnmounted = !0
				}
				componentDidUpdate(e, t) {
					const {
						requirements: s
					} = this.props;
					if (s && !this.state.areRequirementsLoaded) {
						const e = Tb(s);
						this.setState({
							areRequirementsLoaded: !0,
							formState: e,
							initialFormState: e
						})
					}
					this.updateHasUnsavedChanges()
				}
				render() {
					const {
						state: e
					} = this, {
						isLoading: t
					} = this.props, {
						areRequirementsLoaded: s,
						hasUnsavedChanges: n
					} = e;
					return r.a.createElement("div", {
						className: Rp.a.container
					}, r.a.createElement(ie, {
						className: Rp.a.topBar
					}, r.a.createElement(de.f, {
						disabled: t || !n,
						onClick: this.onSaveClick
					}, e.hasJustSaved ? Object(G.c)("Saved") : e.isSavePending ? r.a.createElement(Em.a, {
						className: Rp.a.loadingIcon,
						sizePx: 10
					}) : Object(G.c)("Save changes"))), r.a.createElement(oe, {
						className: Rp.a.contentContainer
					}, r.a.createElement(re, null, Object(G.c)("Post requirements"), r.a.createElement(se, {
						linkUrl: Ep
					})), r.a.createElement("div", {
						className: Rp.a.pageDetailText
					}, Object(G.c)("Add guidance so users can correctly post to your community")), s ? r.a.createElement("div", {
						className: Rp.a.formBody,
						onBlur: this.onFormFieldBlur,
						ref: this.formBodyRef
					}, r.a.createElement(jp, null), r.a.createElement(yb, {
						formState: this.state.formState,
						isLoading: t,
						onChange: this.onFormStateChange
					})) : r.a.createElement(Sp, {
						isLoading: t
					})), r.a.createElement(Kl.a, {
						blockOnBeforeUnload: !0,
						dialogId: _b,
						enabled: n
					}), this.props.isDiscardModalOpen && r.a.createElement(U.a, {
						actionText: Object(G.c)("Discard"),
						headerText: Object(G.c)("Discard changes before leaving?"),
						modalText: Object(G.c)("You have made some changes to post requirements, do you wish to discard the changes?"),
						onConfirm: this.onDiscardUnsavedChangesConfirmed,
						toggleModal: this.onCloseModal,
						withOverlay: !0
					}))
				}
			}
			var Rb = Object(i.b)(Pb, (e, t) => ({
				closeAllModals: () => e(Object(F.f)()),
				onSave: s => e(Object(cp.b)(t.subredditName, s)),
				toggleModal: t => e(Object(F.i)(t))
			}))(Object(x.b)(Mb));
			var Lb = s("./src/reddit/components/ModHub/TrafficStats/helpers.ts");
			const Db = {
					[Lb.d.Uniques]: "uniques",
					[Lb.d.Pageviews]: "pageviews"
				},
				Ab = (e, t) => s => Object.assign({
					source: t ? Db[t] : "traffic",
					action: "click",
					noun: e.toLowerCase(),
					actionInfo: {
						pageType: "moderation_pages_traffic"
					}
				}, (e => ({
					subreddit: y.subreddit(e),
					profile: y.profile(e),
					userSubreddit: y.userSubreddit(e)
				}))(s));
			var Fb = Object(ss.a)({
					getComponent: () => Object(ns.a)(() => Promise.all([s.e("vendors~ModStatsChart"), s.e("ModStatsChart")]).then(s.bind(null, "./src/reddit/components/ModHub/TrafficStats/ModStatsChart/index.tsx"))).then(e => e.default),
					LoadingComponent: () => null,
					ErrorComponent: () => null
				}),
				Bb = e => r.a.createElement("button", {
					className: Object(d.a)(e.className, {
						[e.isSelectedStyles]: e.isSelected
					}),
					onClick: e.onClick
				}, Object(G.c)(e.label)),
				Ub = s("./src/lib/prettyPrintNumber/index.ts"),
				Hb = s("./src/reddit/components/ModHub/TrafficStats/ChartStats/StatBlock/index.m.less"),
				Wb = s.n(Hb);
			var qb = e => r.a.createElement("span", {
					className: Wb.a.StatBlock
				}, r.a.createElement("div", {
					className: Wb.a.contentContainer
				}, r.a.createElement("div", {
					className: Wb.a.value
				}, e.trafficStats ? Object(Ub.a)(((e, t, s) => {
					if (t === Lb.d.Members && e === Lb.b.Hour) return "N/A";
					const n = t === Lb.d.Members ? s[Lb.e.Members] : s[Lb.e[t]][Lb.c[e]].total;
					let a;
					if (e === Lb.b.Hour) a = 24;
					else if (e === Lb.b.Day) a = 7;
					else if (e === Lb.b.Month) {
						if (t !== Lb.d.Members) {
							return n[Lb.a[e] - 1]
						} {
							const e = new Date;
							a = new Date(e.getFullYear(), e.getMonth(), 0).getDate()
						}
					}
					return ((e, t) => {
						const s = e.length;
						return e.slice(s - t - 1, s).reduce((e, t) => e + t, 0)
					})(n, a)
				})(e.statsTime, e.statsView, e.trafficStats).toString()) : "-"), r.a.createElement("div", {
					className: Wb.a.timeFrame
				}, Object(G.c)("Total - ".concat(Object(G.b)("timeFrame", e.timeFrame)))))),
				Vb = s("./src/reddit/components/ModHub/TrafficStats/ChartStats/index.m.less"),
				zb = s.n(Vb);
			const Kb = {
				[Lb.b.Hour]: 54,
				[Lb.b.Day]: 7,
				[Lb.b.Month]: 12
			};
			class Qb extends r.a.Component {
				constructor(e) {
					super(e), this.changeTime = e => {
						const t = Lb.a[e],
							s = Kb[e];
						this.setState({
							statsTime: e,
							windowSize: s,
							windowEnd: t,
							windowStart: t - s
						}), this.props.sendEvent(Ab(e, this.state.statsView))
					}, this.changeView = e => {
						const t = e === Lb.d.Members ? Lb.b.Day : this.state.statsTime,
							s = Lb.a[t],
							n = Kb[t];
						this.setState({
							statsTime: t,
							statsView: e,
							windowSize: n,
							windowEnd: s,
							windowStart: s - n
						}), this.props.sendEvent(Ab(e))
					}, this.shiftWindowLeft = () => {
						const e = Math.max(0, this.state.windowStart - this.state.windowSize),
							t = Math.max(this.state.windowSize, this.state.windowEnd - this.state.windowSize);
						this.setState({
							windowStart: e,
							windowEnd: t
						})
					}, this.shiftWindowRight = () => {
						const e = Lb.a[this.state.statsTime],
							t = Math.min(e - this.state.windowSize, this.state.windowStart + this.state.windowSize),
							s = Math.min(e, this.state.windowEnd + this.state.windowSize);
						this.setState({
							windowStart: t,
							windowEnd: s
						})
					};
					const t = Kb[Lb.b.Day],
						s = Lb.a[Lb.b.Day];
					this.state = {
						statsTime: Lb.b.Day,
						statsView: Lb.d.Pageviews,
						windowSize: t,
						windowEnd: s,
						windowStart: s - t
					}
				}
				render() {
					const {
						statsTime: e,
						statsView: t
					} = this.state, s = Lb.a[e], n = 0 === this.state.windowStart || e === Lb.b.Month, a = this.state.windowEnd === s || e === Lb.b.Month;
					return r.a.createElement("div", {
						className: zb.a.contentContainer
					}, r.a.createElement("div", {
						className: zb.a.viewNav
					}, r.a.createElement(Bb, {
						className: zb.a.NavItem,
						label: Lb.d.Pageviews,
						isSelected: t === Lb.d.Pageviews,
						isSelectedStyles: zb.a.NavItemSelected,
						onClick: () => this.changeView(Lb.d.Pageviews)
					}), r.a.createElement(Bb, {
						className: zb.a.NavItem,
						label: Lb.d.Uniques,
						isSelected: t === Lb.d.Uniques,
						isSelectedStyles: zb.a.NavItemSelected,
						onClick: () => this.changeView(Lb.d.Uniques)
					}), r.a.createElement(Bb, {
						className: zb.a.NavItem,
						label: Lb.d.Members,
						isSelected: t === Lb.d.Members,
						isSelectedStyles: zb.a.NavItemSelected,
						onClick: () => this.changeView(Lb.d.Members)
					})), r.a.createElement("div", {
						className: zb.a.statContainer
					}, r.a.createElement(qb, {
						statsTime: Lb.b.Hour,
						statsView: t,
						timeFrame: Object(G.c)("Last 24 hours"),
						trafficStats: this.props.trafficStats
					}), r.a.createElement(qb, {
						statsTime: Lb.b.Day,
						statsView: t,
						timeFrame: Object(G.c)("Last 7 days"),
						trafficStats: this.props.trafficStats
					}), r.a.createElement(qb, {
						statsTime: Lb.b.Month,
						statsView: t,
						timeFrame: Object(G.c)("Last month"),
						trafficStats: this.props.trafficStats
					})), r.a.createElement("div", {
						className: zb.a.chartContainer
					}, r.a.createElement("span", {
						className: zb.a.yAxis
					}, Object(G.c)(t)), (this.props.isTrafficStatsPending || !this.props.trafficStats) && r.a.createElement("div", {
						className: zb.a.chartPlaceholder
					}), this.props.trafficStats && r.a.createElement(Fb, {
						data: this.props.trafficStats,
						statsView: t,
						statsTime: e,
						windowEnd: this.state.windowEnd,
						windowStart: this.state.windowStart
					})), r.a.createElement("div", {
						className: zb.a.chartNav
					}, e !== Lb.b.Month && r.a.createElement("button", {
						className: zb.a.buttonLeft,
						disabled: n,
						onClick: this.shiftWindowLeft
					}, r.a.createElement(In.a, {
						className: Object(d.a)(zb.a.ArrowLeft, {
							[zb.a.isDisabled]: n
						})
					})), t !== Lb.d.Members && r.a.createElement("span", {
						className: Object(d.a)(zb.a.buttonGroup, {
							[zb.a.hideNavArrows]: e === Lb.b.Month
						})
					}, r.a.createElement(Bb, {
						className: zb.a.navButton,
						label: Lb.b.Hour,
						isSelected: e === Lb.b.Hour,
						isSelectedStyles: zb.a.navButtonSelected,
						onClick: () => this.changeTime(Lb.b.Hour)
					}), r.a.createElement(Bb, {
						className: zb.a.navButton,
						label: Lb.b.Day,
						isSelected: e === Lb.b.Day,
						isSelectedStyles: zb.a.navButtonSelected,
						onClick: () => this.changeTime(Lb.b.Day)
					}), r.a.createElement(Bb, {
						className: zb.a.navButton,
						label: Lb.b.Month,
						isSelected: e === Lb.b.Month,
						isSelectedStyles: zb.a.navButtonSelected,
						onClick: () => this.changeTime(Lb.b.Month)
					})), e !== Lb.b.Month && r.a.createElement("button", {
						className: Object(d.a)(zb.a.buttonRight, {
							[zb.a.hideButtons]: t === Lb.d.Members
						}),
						disabled: a,
						onClick: this.shiftWindowRight
					}, r.a.createElement(In.a, {
						className: Object(d.a)(zb.a.ArrowRight, {
							[zb.a.isDisabled]: a
						})
					}))))
				}
			}
			var Gb = Object(x.b)(Qb),
				Jb = s("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				Zb = s("./src/reddit/components/ModHub/TrafficStats/DataTable/index.m.less"),
				Xb = s.n(Zb);
			const Yb = e => r.a.createElement("div", {
				className: Xb.a.dataRow
			}, r.a.createElement("span", {
				className: Xb.a.date
			}, e.date), r.a.createElement("span", {
				className: Xb.a.pageviews
			}, Object(Ub.a)(e.pageViews.toString())), r.a.createElement("span", {
				className: Xb.a.uniques
			}, Object(Ub.a)(e.uniques.toString())), r.a.createElement("span", {
				className: Xb.a.members
			}, Object(Ub.a)(e.members.toString())));
			var $b;
			! function(e) {
				e.Day = "Day", e.DayOfWeek = "Day of week", e.Month = "Month"
			}($b || ($b = {}));
			class eh extends r.a.PureComponent {
				constructor(e) {
					super(e), this.changeDataDirection = () => this.setState({
						isDirectionReversed: !this.state.isDirectionReversed
					}), this.changeTimeFrame = e => {
						this.setState({
							timeFrame: e,
							isDirectionReversed: !1
						});
						const t = e === $b.Day ? Lb.b.Day : e === $b.Month ? Lb.b.Month : "day_of_week";
						this.props.sendEvent(Ab(t))
					}, this.getDataArray = (e, t, s) => {
						const {
							trafficStats: n
						} = this.props;
						if (!n) return;
						if (t === $b.Month && e === Lb.d.Members) return new Array(Lb.n.length).fill(Object(G.c)("N/A"));
						const a = Lb.e[e];
						let o = e === Lb.d.Members ? n[a] : n[a][s].total;
						return o = t === $b.DayOfWeek ? Object(Lb.h)(o) : Object(Lb.o)(o), this.state.isDirectionReversed ? Object(Lb.o)(o) : o
					}, this.getDateArray = () => {
						const {
							timeFrame: e,
							isDirectionReversed: t
						} = this.state;
						let s;
						if (e === $b.Day) s = Object(Lb.m)(Lb.b.Day, !1).map(e => Object(Lb.i)(e, Lb.b.Day, !0));
						else if (e === $b.DayOfWeek) s = Lb.g;
						else {
							const e = (new Date).getMonth() + 1;
							s = Object(Lb.o)(Object(Lb.p)(Lb.n, e))
						}
						return t ? Object(Lb.o)(s) : s
					}, this.state = {
						isDirectionReversed: !1,
						timeFrame: $b.Day
					}
				}
				render() {
					const {
						isDirectionReversed: e,
						timeFrame: t
					} = this.state, s = t === $b.Month ? Lb.c.Month : Lb.c.Day, n = this.getDataArray(Lb.d.Members, t, s), a = this.getDataArray(Lb.d.Pageviews, t, s), o = this.getDataArray(Lb.d.Uniques, t, s), i = this.getDateArray();
					return r.a.createElement("div", {
						className: Xb.a.contentContainer
					}, r.a.createElement("div", {
						className: Xb.a.viewNav
					}, r.a.createElement(Bb, {
						className: Xb.a.NavItem,
						label: $b.Day,
						isSelected: t === $b.Day,
						isSelectedStyles: Xb.a.NavItemSelected,
						onClick: () => this.changeTimeFrame($b.Day)
					}), r.a.createElement(Bb, {
						className: Xb.a.NavItem,
						label: $b.DayOfWeek,
						isSelected: t === $b.DayOfWeek,
						isSelectedStyles: Xb.a.NavItemSelected,
						onClick: () => this.changeTimeFrame($b.DayOfWeek)
					}), r.a.createElement(Bb, {
						className: Xb.a.NavItem,
						label: $b.Month,
						isSelected: t === $b.Month,
						isSelectedStyles: Xb.a.NavItemSelected,
						onClick: () => this.changeTimeFrame($b.Month)
					})), r.a.createElement("div", {
						className: Xb.a.dataBar
					}, r.a.createElement("button", {
						className: Xb.a.dropdownButton,
						onClick: this.changeDataDirection
					}, r.a.createElement(ct.a, {
						className: Xb.a.timeDropdown
					}, r.a.createElement("span", {
						className: Xb.a.timeLabel
					}, Object(G.c)(t)), r.a.createElement(Jb.b, {
						className: Object(d.a)(Xb.a.dropdownIcon, {
							[Xb.a.iconUp]: e
						})
					}))), r.a.createElement("span", {
						className: Xb.a.pageviewsCol
					}, Object(G.c)("Pageviews")), r.a.createElement("span", {
						className: Xb.a.uniquesCol
					}, Object(G.c)("Uniques")), r.a.createElement("span", {
						className: Xb.a.membersCol
					}, Object(G.c)("Members joined"))), this.props.trafficStats && i.map((e, t) => r.a.createElement(Yb, {
						date: e,
						key: e,
						pageViews: a[t],
						uniques: o[t],
						members: n[t]
					})))
				}
			}
			var th = Object(x.b)(eh),
				sh = s("./src/reddit/components/ModHub/TrafficStats/index.m.less"),
				nh = s.n(sh);
			const ah = Object(c.c)({
				trafficStats: e => e.trafficStats ? e.trafficStats.trafficStats : null,
				isTrafficStatsPending: e => e.trafficStats.pending
			});
			var oh = Object(i.b)(ah)(e => r.a.createElement("div", {
					className: nh.a.trafficStats
				}, r.a.createElement("span", {
					className: nh.a.titleText
				}, r.a.createElement(re, null, Object(G.c)("Traffic Stats")), r.a.createElement("span", {
					className: nh.a.updateText
				}, Object(G.c)("updating every hour"))), r.a.createElement(Gb, {
					isTrafficStatsPending: e.isTrafficStatsPending,
					trafficStats: e.trafficStats
				}), r.a.createElement(th, {
					trafficStats: e.trafficStats
				}))),
				rh = s("./src/reddit/icons/svgs/Mute/index.tsx"),
				ih = s("./src/reddit/components/MutedUserList/ExpandedComponent.m.less"),
				ch = s.n(ih);
			const dh = m.a.span("BannedBy", ch.a),
				lh = m.a.span("EmptyState", ch.a),
				mh = m.a.div("ExpandedContainer", ch.a);
			var uh = e => r.a.createElement(mh, null, e.reason ? r.a.createElement(dh, null, "".concat(Object(G.c)("Mod note"), " (u/").concat(e.mutedBy, "): ")) : r.a.createElement(lh, null, Object(G.c)("No mod note.")), e.reason),
				ph = s("./src/reddit/components/MutedUserList/MuteUserModal/index.tsx"),
				bh = s("./src/reddit/components/MutedUserList/index.m.less"),
				hh = s.n(bh);
			const gh = 24,
				Eh = m.a.wrapped(rh.a, "MuteIcon", hh.a),
				xh = Object(c.c)({
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(tt.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(tt.a)(e),
					language: L.S,
					loadMoreToken: st.E,
					mutedUsers: st.H,
					mutedUsersListPending: st.D,
					searchPending: st.F,
					searchResult: st.G
				});
			class fh extends r.a.Component {
				constructor(e) {
					super(e), this.onSearch = e => {
						this.props.searchForMutedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.unmuteToggled = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.sendEventWithName("edit_user")(), this.props.toggleUnmuteUserModal()
					}, this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.muteUser = () => {
						this.props.toggleAddUserModal(), this.props.sendEventWithName("mute_dialog_mutepage")()
					}, this.renderMutedUser = e => r.a.createElement(Ye, {
						description: e.reason,
						expandedComponent: r.a.createElement(uh, {
							language: this.props.language,
							mutedBy: e.mutedBy,
							reason: e.reason
						}),
						pageName: h.Nb.Muted,
						primaryButton: r.a.createElement(de.n, {
							onClick: this.unmuteToggled(e.id, e.username)
						}, Object(G.c)("Unmute")),
						subredditId: this.props.subredditId,
						timeAgo: Object(A.d)(this.props.language, e.mutedAtUTC),
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderMuteUserModal = () => r.a.createElement(ph.a, {
						ignoreDefaultFocus: !0,
						trackAddEvent: this.props.sendEventWithName("add_mutepage"),
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						withOverlay: !0
					}), this.state = et.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, {
						mutedUsers: s
					} = e;
					let n;
					return s.length && (n = s[s.length - 1].id), e.mutedUsers.length ? r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.muteUser
					}, Object(G.c)("Mute user"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Muted users"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), r.a.createElement(we, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}), t.searchTerm ? r.a.createElement(Oe, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderMutedUser(e.searchResult)) : r.a.createElement(ce.b, {
						loadMoreToken: n,
						onLoadMore: this.onLoadMore
					}, e.mutedUsers.map((e, t) => ({
						estHeight: gh,
						id: e.id,
						render: () => this.renderMutedUser(e)
					})))), e.isAddUserModalOpen && this.renderMuteUserModal(), e.isConfirmModalOpen && t.userId && t.username && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						modalText: Object(G.c)("Are you sure you want to unmute ".concat(Object(G.b)("username", t.username), "?")),
						onConfirm: e.unmuteUser(t.userId),
						toggleModal: e.toggleUnmuteUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.muteUser
					}, Object(G.c)("Mute user"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Muted users"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360009161872")
					})), e.mutedUsersListPending ? r.a.createElement(Ze, null) : r.a.createElement(z, {
						text: Object(G.c)("No muted users in ".concat(Object(G.b)("subredditName", e.subreddit.displayText)))
					}, r.a.createElement(Eh, null)), e.isAddUserModalOpen && this.renderMuteUserModal()))
				}
			}
			var vh = Object(i.b)(xh, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						loadMore: t => e(Object(B.ib)(s, {
							after: t
						})),
						searchForMutedUser: t => e(Object(B.jb)(s, t)),
						toggleAddUserModal: () => e(Object(F.i)("ModerationPage--Modal--AddUser")),
						toggleUnmuteUserModal: () => e(Object(F.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						unmuteUser: t => () => e(Object(B.ob)(s, t))
					}
				})(fh),
				Ch = s("./src/reddit/actions/removalReasons/index.ts"),
				Oh = s("./src/reddit/icons/svgs/Rules/index.tsx"),
				jh = s("./src/reddit/models/RemovalReason/index.ts"),
				yh = s("./src/reddit/selectors/removalReasons.ts"),
				kh = s("./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less"),
				wh = s.n(kh);
			const Sh = {
					message: "",
					title: ""
				},
				Nh = m.a.wrapped(at.d, "GenericGreetingText", wh.a),
				Th = m.a.wrapped(at.p, "DeleteReasonButton", wh.a),
				_h = m.a.wrapped(de.f, "PrimaryButton", wh.a),
				Ih = m.a.wrapped(at.q, "TextArea", wh.a),
				Ph = m.a.wrapped(at.e, "ModalFooter", wh.a),
				Mh = m.a.wrapped(ot.c, "Input", wh.a);
			class Rh extends r.a.Component {
				constructor(e) {
					super(e), this.onTitleInputChange = e => {
						e.currentTarget.value.length <= jh.d && this.setState({
							title: e.currentTarget.value
						})
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onSave = () => {
						const e = {
							title: this.state.title.trim(),
							message: this.state.message.trim()
						};
						this.props.removalReason && (e.id = this.props.removalReason.id), this.props.onSubmit(e), this.props.sendEvent(), this.props.toggleModal()
					}, this.canSave = () => this.state.title.trim().length > 0 && this.state.title.trim().length <= jh.d && this.state.message.trim().length > 0 && this.state.message.trim().length <= jh.a, this.state = e.removalReason ? {
						title: e.removalReason.title,
						message: e.removalReason.message
					} : Sh
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(at.c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, e.removalReason ? Object(G.c)("Edit removal reason") : Object(G.c)("Add new reason")), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, r.a.createElement(at.f, null, r.a.createElement(Mh, {
						placeholder: Object(G.c)("Removal reason title"),
						value: t.title,
						onChange: this.onTitleInputChange
					}), r.a.createElement(Zc.a, {
						text: t.title.trim(),
						maxChars: jh.d
					})), r.a.createElement(at.l, null, Object(G.c)("Reason message:")), r.a.createElement(Nh, null, Object(G.c)("Hi u/username,")), r.a.createElement(Ih, {
						placeholder: Object(G.c)("Write a message that will communicate to the user why their post was removed."),
						value: t.message,
						onChange: this.onMessageInputChange,
						"data-redditstyle": !0
					}), r.a.createElement(Zc.a, {
						text: t.message.trim(),
						maxChars: jh.a
					})), r.a.createElement(Ph, null, r.a.createElement(_h, {
						onClick: this.onSave,
						"data-redditstyle": !0,
						disabled: !this.canSave()
					}, e.removalReason ? Object(G.c)("Save") : Object(G.c)("Add new reason")), r.a.createElement(at.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Object(G.c)("Cancel")), e.removalReason && r.a.createElement(Th, {
						onClick: e.onDeleteReason
					}, Object(G.c)("Delete"))))
				}
			}
			var Lh = Object(nt.a)(Rh),
				Dh = s("./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less"),
				Ah = s.n(Dh);
			const Fh = m.a.wrapped(de.n, "EditButton", Ah.a),
				Bh = m.a.wrapped(me.a, "Row", Ah.a),
				Uh = m.a.div("ReasonNumber", Ah.a),
				Hh = m.a.div("ReasonText", Ah.a);
			var Wh = e => r.a.createElement(Bh, null, r.a.createElement(Uh, null, e.index + 1), r.a.createElement(Hh, null, e.removalReason.title), r.a.createElement(Fh, {
					onClick: e.onEdit,
					"data-redditstyle": !0
				}, r.a.createElement(_e.c, null, "Edit"))),
				qh = s("./src/reddit/components/RemovalReasons/index.m.less"),
				Vh = s.n(qh);
			const zh = {
					reasonToEdit: null
				},
				Kh = m.a.wrapped(Oh.a, "Rules", Vh.a),
				Qh = Object(c.c)({
					isConfirmModalOpen: e => "RemovalReasons--Modal--DeleteConfirmation" === Object(tt.a)(e),
					isRemovalReasonEditorModalOpen: e => "RemovalReasons--Editor--Modal" === Object(tt.a)(e),
					removalReasons: yh.c
				});
			class Gh extends r.a.Component {
				constructor(e) {
					super(e), this.onAddReason = () => {
						this.setState({
							reasonToEdit: null
						}), this.props.toggleReasonEditorModal(), this.props.sendEventWithName("add_new")()
					}, this.onEditReason = e => () => {
						this.setState({
							reasonToEdit: e
						}), this.props.toggleReasonEditorModal(), e && this.props.sendEventWithName("edit")()
					}, this.renderReasonEditorModal = () => r.a.createElement(Lh, {
						onDeleteReason: () => {
							this.props.toggleReasonEditorModal(), this.props.toggleConfirmationModal()
						},
						onSubmit: this.state.reasonToEdit ? this.props.editRemovalReason : this.props.addRemovalReason,
						removalReason: this.state.reasonToEdit,
						sendEvent: this.state.reasonToEdit ? this.props.sendEventWithName("edit_save") : this.props.sendEventWithName("new_save"),
						subredditId: this.props.subredditId,
						toggleModal: this.onEditReason(null),
						withOverlay: !0
					}), this.state = zh
				}
				render() {
					const {
						deleteRemovalReason: e,
						isConfirmModalOpen: t,
						isRemovalReasonEditorModalOpen: s,
						removalReasons: n,
						sendEventWithName: a,
						toggleConfirmationModal: o
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.onAddReason,
						disabled: n.length >= jh.c || s,
						"data-redditstyle": !0
					}, Object(G.c)("Add removal reason"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Removal reasons"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360010094892")
					})), n.length > 0 ? n.map((e, t) => r.a.createElement(Wh, {
						index: t,
						onEdit: this.onEditReason(e),
						removalReason: e
					})) : r.a.createElement(z, {
						text: Object(G.c)("No removal reasons yet")
					}, r.a.createElement(Kh, null))), s && this.renderReasonEditorModal(), t && this.state.reasonToEdit && r.a.createElement(U.a, {
						actionText: Object(G.c)("Delete"),
						headerText: Object(G.c)("Delete reason"),
						modalText: Object(G.c)("Are you sure you want to delete this reason?"),
						onConfirm: () => {
							this.state.reasonToEdit && e(this.state.reasonToEdit.id)
						},
						toggleModal: () => {
							o(), this.setState({
								reasonToEdit: null
							})
						},
						trackClick: a("delete"),
						withOverlay: !0
					}))
				}
			}
			var Jh = Object(i.b)(Qh, (e, t) => {
					let {
						subredditId: s
					} = t;
					return {
						addRemovalReason: t => e(Object(Ch.addRemovalReason)(s, t)),
						deleteRemovalReason: t => e(Object(Ch.deleteRemovalReason)(s, t)),
						editRemovalReason: t => e(Object(Ch.editRemovalReason)(s, t)),
						toggleConfirmationModal: () => e(Object(F.i)("RemovalReasons--Modal--DeleteConfirmation")),
						toggleReasonEditorModal: () => e(Object(F.i)("RemovalReasons--Editor--Modal"))
					}
				})(Gh),
				Zh = s("./src/reddit/actions/streaming/modSettings.ts");
			const Xh = {
					startTime: "",
					endTime: ""
				},
				Yh = {
					isLiveStreamingEnabled: !1,
					maxLiveStreams: void 0,
					minKarma: void 0,
					minAccountAgeDays: void 0,
					durationLimitSeconds: void 0,
					schedule: {
						sunday: Xh,
						monday: Xh,
						tuesday: Xh,
						wednesday: Xh,
						thursday: Xh,
						friday: Xh,
						saturday: Xh
					}
				},
				$h = e => Object.assign({}, Xh, e[0]);
			var eg = s("./src/reddit/components/Streaming/ModSettings/index.m.less"),
				tg = s.n(eg);
			const sg = Object(c.c)({
					modSettings: (e, t) => {
						const s = e.streaming.modSettings[t.subredditId];
						return s ? {
							isLiveStreamingEnabled: s.isLiveStreamingEnabled,
							maxLiveStreams: s.maxLiveStreams,
							minKarma: s.minKarma,
							minAccountAgeDays: s.minAccountAgeDays,
							durationLimitSeconds: s.durationLimitSeconds,
							schedule: {
								sunday: $h(s.weeklySchedule.sunday),
								monday: $h(s.weeklySchedule.monday),
								tuesday: $h(s.weeklySchedule.tuesday),
								wednesday: $h(s.weeklySchedule.wednesday),
								thursday: $h(s.weeklySchedule.thursday),
								friday: $h(s.weeklySchedule.friday),
								saturday: $h(s.weeklySchedule.saturday)
							}
						} : Yh
					}
				}),
				ng = Object(i.b)(sg, (e, t) => ({
					onSave: s => e(Object(Zh.b)(t.subredditId, s || {})),
					showToast: t => e(Object(hi.e)(Object.assign({}, t, {
						duration: hi.a
					})))
				})),
				ag = e => parseInt(e, 10),
				og = e => {
					const t = p.fbt._("Successfully updated settings for '{subredditName}'", [p.fbt._param("subredditName", e)], {
						hk: "2Lvaxf"
					});
					return Object(hi.d)(t, xi.b.SuccessMod)
				},
				rg = e => {
					const t = p.fbt._("Could not update settings for '{subredditName}'", [p.fbt._param("subredditName", e)], {
						hk: "43hdN"
					});
					return Object(hi.d)(t, xi.b.Error)
				};
			class ig extends r.a.Component {
				constructor(e) {
					super(e), this.onChange = e => {
						const t = Object.assign({}, this.state.changedModSettings, e);
						this.setState({
							changedModSettings: t
						})
					}, this.onSaveClick = async () => {
						const e = await this.props.onSave(this.state.changedModSettings);
						e.success && this.setState({
							changedModSettings: {}
						});
						const t = e.success ? og(this.props.subredditName) : rg(this.props.subredditName);
						await this.props.showToast(t)
					}, this.state = {
						changedModSettings: {}
					}
				}
				render() {
					const e = Object.assign({}, this.props.modSettings, this.state.changedModSettings),
						{
							isLiveStreamingEnabled: t,
							maxLiveStreams: s,
							minKarma: n,
							minAccountAgeDays: a,
							durationLimitSeconds: o
						} = e;
					return r.a.createElement("div", {
						className: tg.a.container
					}, r.a.createElement(ie, {
						className: tg.a.topBar
					}, r.a.createElement(de.f, {
						onClick: this.onSaveClick
					}, p.fbt._("Save changes", null, {
						hk: "EpN8h"
					}))), r.a.createElement(oe, {
						className: tg.a.contentContainer
					}, r.a.createElement(re, null, p.fbt._("Streaming", null, {
						hk: "5Mflz"
					})), r.a.createElement("div", {
						className: tg.a.formBody
					}, r.a.createElement($s.n, {
						on: t,
						disabled: !0,
						label: p.fbt._("Is Enabled:", null, {
							hk: "2ztPKl"
						})
					}), r.a.createElement($s.j, {
						label: p.fbt._("Max Streams:", null, {
							hk: "2ZhEgd"
						}),
						direction: "row"
					}, r.a.createElement(rn.b, {
						onChange: e => this.onChange({
							maxLiveStreams: ag(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 1e3,
						value: s
					})), r.a.createElement($s.j, {
						label: p.fbt._("Min Karma:", null, {
							hk: "4hiTvg"
						}),
						direction: "row"
					}, r.a.createElement(rn.b, {
						onChange: e => this.onChange({
							minKarma: ag(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						value: n
					})), r.a.createElement($s.j, {
						label: p.fbt._("Min Account Age:", null, {
							hk: "HygdJ"
						}),
						direction: "row"
					}, r.a.createElement(rn.b, {
						onChange: e => this.onChange({
							minAccountAgeDays: ag(e.currentTarget.value)
						}),
						min: 0,
						type: "number",
						value: a
					})), r.a.createElement($s.j, {
						label: p.fbt._("Duration limit(seconds):", null, {
							hk: "eqRL7"
						}),
						direction: "row"
					}, r.a.createElement(rn.b, {
						onChange: e => this.onChange({
							durationLimitSeconds: ag(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 86400,
						value: o
					})))))
				}
			}
			var cg = ng(ig),
				dg = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				lg = s("./src/telemetry/index.ts"),
				mg = s("./src/reddit/actions/scheduledPosts/index.ts"),
				ug = s("./src/reddit/components/ClassicPost/Placeholder.tsx"),
				pg = s("./src/reddit/selectors/scheduledPosts/index.ts"),
				bg = s("./src/lib/CSSVariableProvider/withTheme.tsx"),
				hg = s("./src/reddit/actions/scheduledPosts/constants.ts"),
				gg = s("./src/graphql/operations/DeleteScheduledPost.json"),
				Eg = s("./src/lib/makeGqlRequest/index.ts");
			const xg = Object(Za.a)(hg.e),
				fg = (e, t) => async (s, n, a) => {
					let {
						gqlContext: o
					} = a;
					const r = Object(pg.h)(n(), {
						subredditId: e,
						scheduledPostId: t
					});
					r ? (await ((e, t) => Object(Eg.a)(e, Object.assign({}, gg, {
						variables: t
					})))(o(), {
						input: {
							id: r.id
						}
					})).ok ? (s(Object(hi.e)(Object(hi.d)(hg.k(), xi.b.SuccessCommunity))), s(xg({
						subredditId: e,
						scheduledPostId: t
					}))) : s(Object(hi.e)(Object(hi.d)(hg.j(), xi.b.Error))) : s(Object(hi.e)(Object(hi.d)(hg.n(), xi.b.Error)))
				};
			var vg = s("./src/reddit/routes/postCreation/index.ts");
			const Cg = Object(Za.a)(hg.f);
			var Og = s("./src/reddit/actions/page.ts"),
				jg = s("./src/graphql/operations/SubmitScheduledPost.json");
			const yg = Object(Za.a)(hg.i),
				kg = (e, t) => async (s, n, a) => {
					let {
						gqlContext: o
					} = a;
					const r = Object(pg.h)(n(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (!r) return void s(Object(hi.e)(Object(hi.d)(hg.n(), xi.b.Error)));
					const i = await ((e, t) => Object(Eg.a)(e, Object.assign({}, jg, {
						variables: t
					})))(o(), {
						input: {
							id: r.id
						}
					});
					if (!i.ok) return void s(Object(hi.e)(Object(hi.d)(hg.o(), xi.b.Error, hg.m(), kg(e, t))));
					const c = i.body.data.submitScheduledPost.post.permalink;
					s(Object(Og.I)(c, !1)), s(Object(hi.e)(Object(hi.d)(hg.p(), xi.b.SuccessCommunity))), s(yg({
						subredditId: e,
						scheduledPostId: t
					}))
				};
			var wg = s("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				Sg = s("./src/reddit/components/FlairList/index.tsx"),
				Ng = s("./src/reddit/components/PostLeftRail/index.tsx"),
				Tg = s("./src/reddit/components/VerticalVotes/votes.tsx"),
				_g = s("./src/reddit/controls/Score/index.tsx"),
				Ig = s("./src/reddit/components/VerticalVotes/index.m.less"),
				Pg = s.n(Ig);
			class Mg extends r.a.PureComponent {
				render() {
					return r.a.createElement("div", {
						className: Pg.a.votesContainer
					}, r.a.createElement("button", {
						className: Pg.a.disabledVoteIcon,
						"aria-label": Object(G.c)("upvote"),
						"aria-pressed": !1,
						disabled: !0
					}, r.a.createElement(Tg.d, {
						compact: !1,
						voteState: Qm.a.notVoted,
						interactive: !1
					})), r.a.createElement(_g.a, {
						disableInlineColor: !0,
						className: Pg.a.disabledScore,
						score: 0,
						voteState: Qm.a.notVoted,
						isScoreHidden: !0
					}), r.a.createElement("button", {
						className: Pg.a.disabledVoteIcon,
						"aria-label": Object(G.c)("downvote"),
						"aria-pressed": !1,
						disabled: !0
					}, r.a.createElement(Tg.c, {
						compact: !1,
						voteState: Qm.a.notVoted,
						interactive: !1
					})))
				}
			}
			var Rg = Mg,
				Lg = s("./src/reddit/constants/thumbnails.ts"),
				Dg = s("./src/reddit/helpers/styles/mixins/index.tsx"),
				Ag = s("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				Fg = s("./src/reddit/models/PostCreationForm/index.ts"),
				Bg = s("./src/reddit/models/ScheduledPost/index.ts"),
				Ug = s("./src/reddit/components/OverflowMenu/index.tsx"),
				Hg = s("./src/reddit/components/PostModModeDropdown/DropdownHelpers.tsx"),
				Wg = s("./src/reddit/icons/svgs/Post/index.tsx"),
				qg = s("./src/reddit/components/ScheduledPost/ControlRow/index.m.less"),
				Vg = s.n(qg);
			const zg = e => {
					const {
						icon: t,
						onClick: s
					} = e;
					return r.a.createElement("span", {
						onClick: s,
						className: Object(d.a)(Vg.a.controlRowItem, e.className)
					}, r.a.createElement(t, {
						className: Vg.a.icon
					}), " ", e.text)
				},
				Kg = Object(c.c)({
					isLoading: pg.e
				}),
				Qg = "SCHEDULED_POST_DROPDOWN";
			class Gg extends r.a.Component {
				constructor(e) {
					super(e), this.isSaving = !1, this.onToggleMetadata = e => {
						this.setState(Object.assign({}, this.state, {
							[e]: !this.state[e]
						})), this.isSaving = !0, this.props.onUpdateMetadata(e)
					}, this.state = {
						isModDistinguished: this.props.scheduledPost.isModDistinguished || !1,
						isNsfw: this.props.scheduledPost.isNsfw || !1,
						isOriginalContent: this.props.scheduledPost.isOriginalContent || !1,
						isSpoiler: this.props.scheduledPost.isSpoiler || !1,
						isSticky: this.props.scheduledPost.isSticky || !1
					}
				}
				componentDidUpdate() {
					!this.props.isLoading && this.isSaving && (this.isSaving = !1, this.setState({
						isModDistinguished: this.props.scheduledPost.isModDistinguished,
						isNsfw: this.props.scheduledPost.isNsfw,
						isOriginalContent: this.props.scheduledPost.isOriginalContent,
						isSpoiler: this.props.scheduledPost.isSpoiler,
						isSticky: this.props.scheduledPost.isSticky
					}))
				}
				renderOverflowMenu() {
					return r.a.createElement(Ug.b, {
						dropdownId: "".concat(Qg).concat(this.props.scheduledPost.id),
						onClick: this.props.onOpenOverflow
					}, r.a.createElement(Hg.b, {
						isSelected: this.props.scheduledPost.isSticky,
						onClick: () => this.onToggleMetadata("isSticky"),
						text: p.fbt._("Sticky post", null, {
							hk: "UOShB"
						})
					}), r.a.createElement(Hg.b, {
						isSelected: this.state.isModDistinguished,
						onClick: () => this.onToggleMetadata("isModDistinguished"),
						text: p.fbt._("Distinguish as Mod", null, {
							hk: "3opu7K"
						})
					}), r.a.createElement(Hg.b, {
						isSelected: this.state.isOriginalContent,
						onClick: () => this.onToggleMetadata("isOriginalContent"),
						text: p.fbt._("Mark as OC", null, {
							hk: "32LGcQ"
						})
					}), r.a.createElement(Hg.b, {
						isSelected: this.state.isNsfw,
						onClick: () => this.onToggleMetadata("isNsfw"),
						text: p.fbt._("Mark as NSFW", null, {
							hk: "2qBIcp"
						})
					}), r.a.createElement(Hg.b, {
						isSelected: this.state.isSpoiler,
						onClick: () => this.onToggleMetadata("isSpoiler"),
						text: p.fbt._("Mark as Spoiler", null, {
							hk: "rOev9"
						})
					}))
				}
				render() {
					return r.a.createElement("span", {
						className: Vg.a.controlRow
					}, this.props.onSubmitPostNow && r.a.createElement(zg, {
						icon: Wg.a,
						text: p.fbt._("Submit post now", null, {
							hk: "QkS4y"
						}),
						onClick: this.props.onSubmitPostNow
					}), r.a.createElement(zg, {
						icon: $e.a,
						text: p.fbt._("Edit", null, {
							hk: "jXXcs"
						}),
						onClick: this.props.onEditScheduledPost
					}), r.a.createElement(zg, {
						icon: ds.b,
						text: p.fbt._("Delete", null, {
							hk: "1uVY7w"
						}),
						onClick: this.props.onDeleteScheduledPost
					}), this.renderOverflowMenu())
				}
			}
			var Jg = Object(i.b)(Kg, {})(Gg),
				Zg = s("./src/reddit/components/SubredditNameLink/index.tsx"),
				Xg = s("./src/reddit/controls/MetaSeparator/index.tsx"),
				Yg = s("./src/reddit/icons/fonts/Sticky/index.tsx"),
				$g = s("./src/reddit/components/ScheduledPost/MetaLine/index.m.less"),
				eE = s.n($g);
			class tE extends r.a.PureComponent {
				render() {
					if (!Object(Bg.g)(this.props.subreddit)) return null;
					const {
						isModDistinguished: e,
						subreddit: t,
						owner: s,
						isSticky: n
					} = this.props;
					return r.a.createElement("span", {
						className: eE.a.content
					}, r.a.createElement(Zg.a, {
						to: t.path
					}, t.prefixedName), Object(Bg.f)(s) && r.a.createElement(r.a.Fragment, null, r.a.createElement(Xg.a, null), r.a.createElement(Do.a, {
						className: eE.a.author,
						author: s.name,
						isUnstyled: !0
					}, s.prefixedName)), e && r.a.createElement(ta.a, {
						className: eE.a.modIcon
					}), n && r.a.createElement(Yg.a, {
						className: eE.a.stickyIcon
					}))
				}
			}
			var sE = tE,
				nE = s("./src/reddit/components/ScheduledPost/PostTitle/index.m.less"),
				aE = s.n(nE);
			class oE extends r.a.PureComponent {
				render() {
					return r.a.createElement("span", {
						className: aE.a.title
					}, this.props.title)
				}
			}
			var rE = oE,
				iE = s("./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less"),
				cE = s.n(iE);
			const {
				fbt: dE
			} = s("./node_modules/fbt/lib/FbtPublic.js");
			class lE extends r.a.PureComponent {
				componentDidMount() {
					this.props.onViewFailedPost()
				}
				render() {
					return r.a.createElement("div", {
						className: cE.a.container
					}, r.a.createElement(Fn.a, {
						className: cE.a.error
					}), dE._("Post failed to submit! Please {=retry}", [dE._param("=retry", r.a.createElement("button", {
						className: cE.a.retryButton,
						onClick: this.props.onSubmitPostNow
					}, dE._("retry", null, {
						hk: "hER94"
					})))], {
						hk: "4yOnl8"
					}))
				}
			}
			var mE = Object(i.b)(null, (e, t) => {
					let {
						scheduledPost: s
					} = t;
					return {
						onSubmitPostNow: () => {
							e(kg(s.subreddit.id, s.id)), e((e, t) => Object(lg.a)(Object(Ag.h)()(t())))
						},
						onViewFailedPost: () => e((e, t) => Object(lg.a)(Object(Ag.m)()(t(), s)))
					}
				})(lE),
				uE = s("./src/reddit/connectors/connectToLanguage.ts"),
				pE = s("./src/reddit/helpers/scheduledPosts/index.ts"),
				bE = s("./src/reddit/icons/svgs/Clock/index.tsx"),
				hE = s("./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less"),
				gE = s.n(hE);
			const {
				fbt: EE
			} = s("./node_modules/fbt/lib/FbtPublic.js"), xE = (e, t) => {
				const s = Object(pE.c)(e.publishAt, t),
					n = Object(pE.d)(e.clientTimezone).displayText;
				return "".concat(s, " ").concat(n)
			};
			class fE extends r.a.PureComponent {
				render() {
					return r.a.createElement("div", {
						className: gE.a.container
					}, r.a.createElement(bE.a, {
						className: gE.a.clock
					}), EE._("This post is scheduled for {=[time]}", [EE._param("=[time]", r.a.createElement("span", {
						className: gE.a.timeMetaData
					}, EE._("{time}", [EE._param("time", xE(this.props.scheduledPost, this.props.language))], {
						hk: "JrMs3"
					})))], {
						hk: "4gFrnr"
					}))
				}
			}
			var vE = Object(uE.a)(fE);
			class CE extends r.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props;
					switch (e.state) {
						case Bg.e.FAILED:
							return r.a.createElement(mE, {
								scheduledPost: e
							});
						case Bg.e.PROCESSING:
						case Bg.e.CREATED:
						default:
							return r.a.createElement(vE, {
								scheduledPost: e
							})
					}
				}
			}
			var OE = CE,
				jE = s("./src/reddit/helpers/styles/mixins/index.m.less"),
				yE = s.n(jE),
				kE = s("./src/reddit/components/ScheduledPost/index.m.less"),
				wE = s.n(kE);
			const SE = {
					isNSFW: !1,
					media: {
						content: "",
						markdownContent: "",
						isRichtextPreview: !0,
						mediaMetadata: null,
						obfuscated: null,
						richtextContent: {
							document: []
						},
						rteMode: Fg.h.RICH_TEXT,
						type: "rtjson"
					},
					thumbnail: {
						url: Lg.a.DEFAULT,
						width: null,
						height: null
					},
					title: "",
					source: null,
					isSponsored: !1
				},
				NE = Object(c.c)({
					media: (e, t) => {
						let {
							scheduledPostId: s,
							subredditId: n
						} = t;
						const a = Object(pg.h)(e, {
							scheduledPostId: s,
							subredditId: n
						});
						return a ? Object.assign({}, SE, {
							isNSFW: a.isNsfw,
							title: a.title
						}) : null
					},
					flair: (e, t) => {
						let {
							scheduledPostId: s,
							subredditId: n
						} = t;
						const a = Object(pg.h)(e, {
							scheduledPostId: s,
							subredditId: n
						});
						return a ? Object(pg.f)({
							scheduledPost: a
						}) : null
					},
					scheduledPost: (e, t) => {
						let {
							scheduledPostId: s,
							subredditId: n
						} = t;
						return Object(pg.h)(e, {
							scheduledPostId: s,
							subredditId: n
						})
					}
				}),
				TE = Object(i.b)(NE, (e, t) => {
					let {
						scheduledPostId: s,
						subredditId: n
					} = t;
					return {
						onSubmitPostNow: () => {
							e(kg(n, s)), e((e, t) => Object(lg.a)(Object(Ag.h)()(t())))
						},
						onEditScheduledPost: () => {
							e(((e, t) => async (s, n, a) => {
								const o = Object(pg.h)(n(), {
									subredditId: e,
									scheduledPostId: t
								});
								o && (await s(Object(to.b)(Object(vg.c)(o.subreddit.name))), s(Cg(o)))
							})(n, s)), e((e, t) => Object(lg.a)(Object(Ag.c)()(t())))
						},
						onDeleteScheduledPost: () => e(fg(n, s)),
						onOpenOverflow: () => e((e, t) => Object(lg.a)(Object(Ag.d)()(t()))),
						onUpdateMetadata: t => e((e, a) => {
							const o = Object(pg.h)(a(), {
								scheduledPostId: s,
								subredditId: n
							});
							o && e(Object(mg.b)(t, o))
						})
					}
				});
			class _E extends r.a.PureComponent {
				constructor(e) {
					super(e), this.onSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !0
					}), this.onCancelSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !1
					}), this.onConfirmSubmitPostNow = () => this.props.onSubmitPostNow(), this.onEditScheduledPost = () => {
						this.props.onEditScheduledPost()
					}, this.onDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !0
					}), this.onCancelDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !1
					}), this.onConfirmDeleteScheduledPost = () => this.props.onDeleteScheduledPost(), this.state = {
						deleteConfirmModalIsOpen: !1,
						submitConfirmModalIsOpen: !1
					}
				}
				render() {
					const {
						media: e,
						flair: t,
						scheduledPost: s
					} = this.props;
					return e && t && s ? r.a.createElement("div", {
						className: wE.a.container
					}, r.a.createElement(OE, {
						scheduledPost: s
					}), r.a.createElement("div", {
						className: yE.a.classicPostStyles
					}, r.a.createElement(Ng.b, null, r.a.createElement(Rg, null)), r.a.createElement("div", {
						style: Object(Dg.c)(void 0, this.props),
						className: wE.a.backgroundWrapper
					}, r.a.createElement("div", {
						className: wE.a.mainBody
					}, r.a.createElement("div", {
						className: wE.a.thumbnailContainer
					}, r.a.createElement(wg.a, {
						post: e
					})), r.a.createElement("div", {
						className: wE.a.content
					}, r.a.createElement("div", null, r.a.createElement(rE, {
						title: s.title
					}), r.a.createElement(Sg.a, {
						className: wE.a.flairList,
						flair: t
					})), r.a.createElement(sE, {
						isModDistinguished: s.isModDistinguished,
						isSticky: s.isSticky,
						subreddit: s.subreddit,
						owner: s.owner
					}), r.a.createElement(Jg, {
						onSubmitPostNow: s.state === Bg.e.FAILED ? void 0 : this.onSubmitPostNow,
						onEditScheduledPost: this.onEditScheduledPost,
						onDeleteScheduledPost: this.onDeleteScheduledPost,
						onUpdateMetadata: this.props.onUpdateMetadata,
						scheduledPost: s,
						onOpenOverflow: this.props.onOpenOverflow
					}))))), this.state.deleteConfirmModalIsOpen && r.a.createElement(U.a, {
						onClose: this.onCancelDeleteScheduledPost,
						onCancel: this.onCancelDeleteScheduledPost,
						onConfirm: this.onConfirmDeleteScheduledPost,
						actionText: p.fbt._("Delete", null, {
							hk: "1WN0R6"
						}),
						modalText: p.fbt._("Are you sure you want to delete this scheduled post? This action cannot be undone.", null, {
							hk: "1EdQC7"
						}),
						withOverlay: !0
					}), this.state.submitConfirmModalIsOpen && r.a.createElement(U.a, {
						onClose: this.onCancelSubmitPostNow,
						onCancel: this.onCancelSubmitPostNow,
						onConfirm: this.onConfirmSubmitPostNow,
						actionText: p.fbt._("Submit", null, {
							hk: "3kl12J"
						}),
						modalText: p.fbt._("Are you sure you want to submit this scheduled post now? This action cannot be undone.", null, {
							hk: "18O8dB"
						}),
						withOverlay: !0
					})) : null
				}
			}
			var IE = Object(bg.a)(TE(_E)),
				PE = s("./src/reddit/components/SubredditContent/index.m.less"),
				ME = s.n(PE);
			const RE = Object(c.c)({
				isLoading: pg.d,
				hasData: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(pg.b)(e, {
						subredditId: s.id
					})
				},
				scheduledPosts: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(pg.i)(e, {
						subredditId: s.id
					})
				},
				loadMoreToken: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(pg.a)(e, {
						subredditId: s.id
					})
				}
			});
			class LE extends r.a.PureComponent {
				componentDidMount() {
					this.props.onViewScheduledPostsQueue()
				}
				renderLoadingState() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3;
					const t = [];
					for (let s = 0; s < e; s++) t.push(r.a.createElement(ug.b, {
						isLoading: !0
					}));
					return r.a.createElement(r.a.Fragment, null, t)
				}
				renderEmptyState() {
					const {
						subreddit: e
					} = this.props;
					return r.a.createElement(z, {
						text: Object(G.c)("No scheduled posts in r/".concat(e.name))
					}, r.a.createElement(bE.a, {
						className: ME.a.clockIcon
					}), r.a.createElement(dg.a, {
						className: ME.a.schedulePostLink,
						to: "/".concat(e.displayText, "/submit")
					}, Object(G.c)("Schedule Post")))
				}
				renderBody() {
					const {
						hasData: e,
						loadMoreToken: t,
						onLoadMoreScheduledPosts: s,
						scheduledPosts: n
					} = this.props;
					return e && n.length ? r.a.createElement(ce.b, {
						onLoadMore: s,
						loadMoreToken: t || void 0
					}, n.map(e => ({
						id: e.id,
						estHeight: 112,
						render: t => r.a.createElement(IE, {
							key: "scheduled-post-id-".concat(e.id),
							scheduledPostId: e.id,
							subredditId: e.subreddit.id
						})
					}))) : this.renderEmptyState()
				}
				render() {
					const {
						isLoading: e,
						hasData: t,
						subreddit: s
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(dg.a, {
						to: "/".concat(s.displayText, "/submit")
					}, r.a.createElement(de.f, null, p.fbt._("Schedule post", null, {
						hk: "4cBcW6"
					})))), r.a.createElement(oe, null, r.a.createElement(re, {
						className: ME.a.pageTitle
					}, p.fbt._("Scheduled posts", null, {
						hk: "4fWGI4"
					}), r.a.createElement("span", {
						className: ME.a.betaIndicator
					}, p.fbt._("Beta", null, {
						hk: "z4XPh"
					}))), !t && e ? this.renderLoadingState() : this.renderBody(), t && e && this.renderLoadingState(1)))
				}
			}
			var DE = Object(i.b)(RE, (e, t) => {
					let {
						subreddit: s
					} = t;
					return {
						onLoadMoreScheduledPosts: () => e(Object(mg.a)(s.id)),
						onViewScheduledPostsQueue: () => e((e, t) => Object(lg.a)(Object(Ag.o)()(t())))
					}
				})(LE),
				AE = s("./src/reddit/actions/subredditRules/constants.ts"),
				FE = s("./src/reddit/endpoints/subreddit/rules.ts");
			const BE = Object(Za.a)(AE.e),
				UE = (e, t) => async (s, n, a) => {
					let {
						apiContext: o
					} = a;
					const r = Object(R.S)(n(), {
							subredditId: e
						}).name,
						i = Object(L.S)(n()),
						c = "success-block-".concat(t.rule),
						d = "error-block-".concat(t.rule),
						l = await Object(FE.a)(o(), r, t);
					if (l.ok) {
						const t = l.body;
						s(BE({
							rules: t,
							subredditId: e
						})), s(hi.e({
							id: c,
							kind: xi.b.SuccessCommunityGreen,
							text: Object(Ot.a)(i, "subredditModeration.subredditRules.toast.ruleAdded")
						}))
					} else s(hi.e({
						id: d,
						kind: xi.b.Error,
						text: l.json.errors ? l.json.errors[0][1] : Object(Ot.a)(i, "error.tryAgainLater")
					}))
				}, HE = Object(Za.a)(AE.f), WE = Object(Za.a)(AE.g), qE = Object(Za.a)(AE.d), VE = (e, t) => async (s, n, a) => {
					let {
						apiContext: o
					} = a;
					const r = Object(R.S)(n(), {
							subredditId: e
						}).name,
						i = Object(L.S)(n()),
						c = Object(R.O)(n(), {
							subredditId: e
						}),
						d = "success-block-".concat(e),
						l = "error-block-".concat(e),
						m = await Object(FE.e)(o(), r, t);
					if (m.ok) {
						const t = m.body;
						s(qE({
							rules: t,
							subredditId: e
						})), s(hi.e({
							id: d,
							kind: xi.b.SuccessCommunityGreen,
							text: Object(Ot.a)(i, "subredditModeration.subredditRules.toast.ruleOrdered"),
							buttonText: Object(Ot.a)(i, "subredditModeration.subredditRules.toast.ruleUndo"),
							buttonAction: VE(e, c)
						}))
					} else s(hi.e({
						id: l,
						kind: xi.b.Error,
						text: "explanation" in m ? m.explanation : m.json && "errors" in m.json ? m.json.errors[0][1] : Object(Ot.a)(i, "error.tryAgainLater")
					}))
				}, zE = e => ({
					subreddit: y.subreddit(e),
					profile: y.profile(e),
					userSubreddit: y.userSubreddit(e)
				}), KE = e => t => Object.assign({
					source: "rules",
					action: "click",
					noun: e
				}, zE(t)), QE = (e, t) => s => Object.assign({
					source: "rules",
					action: "click",
					noun: e,
					actionInfo: y.actionInfo(s, {
						count: t
					})
				}, zE(s));
			var GE = s("./src/reddit/models/Rule/index.ts"),
				JE = s("./src/reddit/components/SubredditRules/index.m.less"),
				ZE = s.n(JE),
				XE = s("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				YE = s("./src/reddit/icons/svgs/Grapple/index.tsx");
			const $E = m.a.wrapped(XE.a, "DragCard", ZE.a);
			var ex = e => r.a.createElement($E, {
				isDragging: e.isDragging,
				isOver: e.isOver,
				canDrop: e.canDrop
			}, r.a.createElement(me.a, {
				className: ZE.a.row
			}, r.a.createElement("span", {
				className: ZE.a.ruleNumber
			}, e.index + 1), r.a.createElement("span", {
				className: ZE.a.ruleText
			}, e.shortName), r.a.createElement("span", {
				className: ZE.a.iconWrapper
			}, r.a.createElement(YE.a, {
				className: ZE.a.dragIcon,
				title: Object(G.c)("Drag")
			}))));
			const tx = {
					rule: "",
					kind: "all",
					reportReason: "",
					description: ""
				},
				sx = Object(i.b)(null, (e, t) => ({
					createRule: s => e(UE(t.subredditId, s)),
					updateRule: (s, n) => e(((e, t, s) => async (n, a, o) => {
						let {
							apiContext: r
						} = o;
						const i = Object(R.S)(a(), {
								subredditId: e
							}).name,
							c = Object(L.S)(a()),
							d = "success-block-".concat(t.rule),
							l = "error-block-".concat(t.rule),
							m = await Object(FE.f)(r(), i, t, s);
						if (m.ok) {
							const t = m.body;
							n(HE({
								rules: t,
								subredditId: e,
								oldName: s
							})), n(hi.e({
								id: d,
								kind: xi.b.SuccessCommunityGreen,
								text: Object(Ot.a)(c, "subredditModeration.subredditRules.toast.ruleUpdated")
							}))
						} else n(hi.e({
							id: l,
							kind: xi.b.Error,
							text: m.json.errors ? m.json.errors[0][1] : Object(Ot.a)(c, "error.tryAgainLater")
						}))
					})(t.subredditId, s, n))
				}));
			class nx extends r.a.Component {
				constructor(e) {
					super(e), this.onRuleInputChange = e => {
						e.currentTarget.value.trim().length <= GE.f && this.setState({
							rule: e.currentTarget.value
						})
					}, this.onReportReasonInputChange = e => {
						e.currentTarget.value.trim().length <= GE.e && this.setState({
							reportReason: e.currentTarget.value
						})
					}, this.onDescriptionInputChange = e => {
						e.currentTarget.value.trim().length <= GE.c && this.setState({
							description: e.currentTarget.value
						})
					}, this.onSave = () => {
						const {
							props: e,
							state: t
						} = this, s = {
							rule: t.rule.trim(),
							kind: t.kind,
							reason: t.reportReason.trim(),
							description: t.description.trim()
						};
						e.rule ? e.updateRule(s, e.rule.shortName) : e.createRule(s), e.toggleModal(), e.sendEvent()
					}, this.canSave = () => {
						const {
							props: e,
							state: t
						} = this, s = t.rule.trim(), n = t.reportReason.trim(), a = t.description.trim(), o = !e.ruleNames.includes(s) || e.ruleNames.includes(s) && e.rule && e.rule.shortName === s, r = !e.rule || (e.rule.shortName !== s || e.rule.violationReason !== t.reportReason || e.rule.kind !== t.kind || e.rule.description !== a);
						return o && r && s.length > 0 && s.length <= GE.f && n.length <= GE.e && a.length <= GE.c && t.kind
					}, this.selectRuleKind = e => {
						this.setState({
							kind: e
						})
					}, this.isDuplicateRuleName = () => {
						const {
							props: e,
							state: t
						} = this, s = !e.rule || e.rule.shortName !== t.rule.trim(), n = e.ruleNames.includes(t.rule.trim());
						return 0 !== t.rule.trim().length && s && n
					}, this.state = e.rule ? {
						rule: e.rule.shortName,
						kind: e.rule.kind,
						reportReason: e.rule.violationReason || "",
						description: e.rule.description || ""
					} : tx
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(at.c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, e.rule ? Object(G.c)("Edit rule") : Object(G.c)("Add rule")), r.a.createElement(rt.a, {
						className: ZE.a.modalCloseButton,
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, r.a.createElement(at.f, null, r.a.createElement(at.m, {
						className: ZE.a.modalRule
					}, Object(G.c)("Rule")), r.a.createElement(at.q, {
						className: ZE.a.modalRuleField,
						onChange: this.onRuleInputChange,
						placeholder: Object(G.c)('Rule displayed (e.g. "No photos")'),
						value: t.rule
					}), this.isDuplicateRuleName() && r.a.createElement("span", {
						className: ZE.a.duplicateName
					}, Object(G.c)("You have another rule with this title. Please change.")), r.a.createElement(Zc.a, {
						maxChars: GE.f,
						text: t.rule.trim()
					})), r.a.createElement(at.f, null, r.a.createElement(at.m, {
						className: ZE.a.modalRuleTitle
					}, Object(G.c)("Applies to")), r.a.createElement(sn.a, {
						name: "RULE_KIND_PICKER",
						onChange: this.selectRuleKind,
						value: t.kind,
						children: [r.a.createElement(Dm.a, {
							className: ZE.a.modalRadioButton,
							key: GE.a.all,
							value: GE.a.all,
							selected: t.kind === GE.a.all,
							showButton: !0,
							tabIndex: t.kind === GE.a.all ? 0 : -1
						}, r.a.createElement(at.m, {
							className: ZE.a.modalRadioText
						}, Object(G.c)("Posts & comments"))), r.a.createElement(Dm.a, {
							className: ZE.a.modalRadioButton,
							key: GE.a.post,
							value: GE.a.post,
							selected: t.kind === GE.a.post,
							showButton: !0,
							tabIndex: t.kind === GE.a.post ? 0 : -1
						}, r.a.createElement(at.m, {
							className: ZE.a.modalRadioText
						}, Object(G.c)("Posts only"))), r.a.createElement(Dm.a, {
							className: ZE.a.modalRadioButton,
							key: GE.a.comment,
							value: GE.a.comment,
							selected: t.kind === GE.a.comment,
							showButton: !0,
							tabIndex: t.kind === GE.a.comment ? 0 : -1
						}, r.a.createElement(at.m, {
							className: ZE.a.modalRadioText
						}, Object(G.c)("Comments only")))]
					})), r.a.createElement(at.f, null, r.a.createElement(at.m, {
						className: ZE.a.modalReportTitle
					}, Object(G.c)("Report reason")), r.a.createElement(at.k, {
						className: ZE.a.modalReportMeta
					}, Object(G.c)("Defaults to rule name if left blank")), r.a.createElement(at.q, {
						className: ZE.a.modalReasonField,
						onChange: this.onReportReasonInputChange,
						placeholder: t.rule.trim().length > 0 && 0 === t.reportReason.trim().length ? t.rule : Object(G.c)('Reason rule is broken (e.g. "This is a photo")'),
						value: t.reportReason
					}), r.a.createElement(Zc.a, {
						maxChars: GE.e,
						text: t.reportReason.trim()
					})), r.a.createElement("div", {
						className: ZE.a.modalDescriptionBlock
					}, r.a.createElement(at.m, {
						className: ZE.a.modalRuleTitle
					}, Object(G.c)("Full description")), r.a.createElement(at.q, {
						className: ZE.a.modalDescriptionField,
						onChange: this.onDescriptionInputChange,
						placeholder: Object(G.c)("Enter the full description of the rule."),
						value: t.description
					}), r.a.createElement(Zc.a, {
						maxChars: GE.c,
						text: t.description.trim()
					}))), r.a.createElement(at.e, {
						className: ZE.a.modalFooter
					}, r.a.createElement(de.f, {
						className: ZE.a.modalSubmitButton,
						onClick: this.onSave,
						disabled: !this.canSave()
					}, e.rule ? Object(G.c)("Save") : Object(G.c)("Add new rule")), r.a.createElement(at.a, {
						onClick: e.toggleModal
					}, Object(G.c)("Cancel")), e.rule && r.a.createElement(at.p, {
						className: ZE.a.modalRemoveButton,
						onClick: e.onDelete
					}, Object(G.c)("Delete"))))
				}
			}
			var ax = Object(nt.a)(sx(nx)),
				ox = s("./src/reddit/components/RawHTMLDisplay/Listing.tsx"),
				rx = s("./src/reddit/components/RichTextJson/index.tsx"),
				ix = s("./src/lib/humanizeUTCDate/index.tsx");
			var cx = (e, t) => {
					const s = (e => e - 8 * h.I / h.Cb)(e);
					return Object(A.c)(s) >= 1 ? Object(ix.a)(s) : Object(A.d)(t, s)
				},
				dx = s("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				lx = s("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				mx = s("./src/reddit/models/RichTextJson/index.ts");
			const ux = {};
			class px extends r.a.Component {
				constructor(e) {
					super(e), this.toggleExpandDetails = () => {
						this.setState(e => ({
							isExpanded: !e.isExpanded
						}))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						hasConfigPerms: e,
						index: t,
						language: s,
						onEdit: n,
						subredditRule: a
					} = this.props, o = a.descriptionRichText ? JSON.parse(a.descriptionRichText).document : void 0, i = a.kind === GE.a.all ? "Posts & comments" : a.kind === GE.a.post ? "Posts only" : "Comments only";
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(me.a, {
						className: ZE.a.row
					}, r.a.createElement("span", {
						className: ZE.a.ruleNumber
					}, t + 1), r.a.createElement("span", {
						className: ZE.a.ruleText
					}, a.shortName), r.a.createElement("span", {
						className: ZE.a.iconWrapper
					}, e && r.a.createElement("button", {
						className: ZE.a.iconButton,
						onClick: n
					}, r.a.createElement($e.a, {
						className: ZE.a.icon,
						title: Object(G.c)("Edit")
					})), r.a.createElement("button", {
						className: ZE.a.iconButton,
						onClick: this.toggleExpandDetails
					}, this.state.isExpanded ? r.a.createElement(dx.a, {
						className: ZE.a.icon,
						title: Object(G.c)("Collapse")
					}) : r.a.createElement(lx.a, {
						className: ZE.a.icon,
						title: Object(G.c)("Expand")
					})))), this.state.isExpanded && r.a.createElement(me.a, {
						className: ZE.a.expandDetails
					}, r.a.createElement("span", {
						className: ZE.a.metadata
					}, r.a.createElement("span", {
						className: ZE.a.ruleMetaTitle
					}, Object(G.c)("Report reason")), r.a.createElement("span", {
						className: ZE.a.ruleMetaText
					}, a.violationReason && 0 !== a.violationReason.length ? a.violationReason : a.shortName)), r.a.createElement("span", {
						className: ZE.a.middleMeta
					}, r.a.createElement("div", {
						className: ZE.a.middleMetaBlock
					}, r.a.createElement("div", {
						className: ZE.a.ruleMetaTitle
					}, Object(G.c)("Applies to")), r.a.createElement("div", {
						className: ZE.a.ruleMetaText
					}, Object(G.c)(i))), r.a.createElement("div", {
						className: ZE.a.middleMetaBlock
					}, r.a.createElement("div", {
						className: ZE.a.ruleMetaTitle
					}, Object(G.c)("Created")), r.a.createElement("div", {
						className: ZE.a.ruleMetaText
					}, cx(a.createdUtc, s)))), r.a.createElement("span", {
						className: ZE.a.metadata
					}, r.a.createElement("span", {
						className: ZE.a.ruleMetaTitle
					}, Object(G.c)("Full description")), r.a.createElement("span", {
						className: ZE.a.ruleMetaText
					}, o && !Object(mx.F)({
						document: o
					}) ? r.a.createElement(rx.a, {
						className: ZE.a.ruleMetaText,
						content: {
							document: o
						},
						rtJsonElementProps: ux
					}) : a.descriptionHtml ? r.a.createElement(ox.a, {
						className: ZE.a.ruleMetaText,
						html: a.descriptionHtml
					}) : a.description))))
				}
			}
			var bx = px;
			const hx = m.a.wrapped(de.f, "PrimaryButton", ZE.a),
				gx = () => r.a.createElement(me.a, {
					className: ZE.a.placeholderRow
				}, r.a.createElement("span", {
					className: ZE.a.emptyWrapper
				}, r.a.createElement("span", {
					className: ZE.a.emptyIcon
				})), r.a.createElement("span", {
					className: ZE.a.emptyDetails
				}), r.a.createElement("span", {
					className: ZE.a.iconWrapper
				}, r.a.createElement("span", {
					className: ZE.a.emptyRightIcon
				}), r.a.createElement("span", {
					className: ZE.a.emptyRightIcon
				}))),
				Ex = () => r.a.createElement("div", {
					className: ZE.a.loadingContainer
				}, Ne()(15, e => r.a.createElement(gx, {
					key: e
				}))),
				xx = Object(c.c)({
					hasModConfigPerms: (e, t) => Object(P.a)(ur.c.config)(e, {
						subredditId: t.subreddit.id
					}),
					isConfirmModalOpen: e => "SubredditRule--Modal--DeleteConfirmation" === Object(tt.a)(e),
					isRuleEditorOpen: e => "SubredditRule--Editor--Modal" === Object(tt.a)(e),
					isSubredditRulesPending: e => Object(R.Q)(e),
					language: L.S,
					ruleOrder: (e, t) => Object(R.O)(e, {
						subredditId: t.subreddit.id
					}),
					subredditRules: (e, t) => Object(R.R)(e, {
						subredditId: t.subreddit.id
					})
				});
			class fx extends r.a.Component {
				constructor(e) {
					super(e), this.deleteRule = () => {
						const e = this.state.ruleToEdit;
						e && this.props.removeRule(e.shortName, e.priority)
					}, this.onConfirmDeleteRule = () => {
						this.props.toggleConfirmationModal()
					}, this.onEditRule = e => {
						this.setState({
							ruleToEdit: e
						}), this.props.toggleRuleEditorModal()
					}, this.handleDrop = (e, t, s) => this.setState({
						ruleOrder: s,
						numRulesMoved: this.state.numRulesMoved + 1
					}), this.reorderRules = () => {
						this.props.reorderRules(this.state.ruleOrder), this.props.sendEvent(QE("save_reorder", this.state.numRulesMoved)), this.stopReorder()
					}, this.startReorder = () => {
						this.setState({
							isReordering: !0,
							ruleOrder: this.props.ruleOrder
						})
					}, this.stopReorder = () => this.setState({
						isReordering: !1,
						numRulesMoved: 0
					}), this.toggleConfirmationModal = () => {
						this.props.toggleConfirmationModal(), this.setState({
							ruleToEdit: null
						})
					}, this.toggleEditorModal = () => {
						this.props.toggleRuleEditorModal(), this.setState({
							ruleToEdit: null
						})
					}, this.trackClick = e => this.props.sendEvent(KE(e)), this.trackEdit = () => this.state.ruleToEdit ? this.trackClick("save_edit") : this.trackClick("save_new"), this.trackDelete = () => this.trackClick("delete"), this.state = {
						numRulesMoved: 0,
						ruleToEdit: null,
						ruleOrder: e.ruleOrder,
						isReordering: !1
					}
				}
				render() {
					const {
						hasModConfigPerms: e,
						isConfirmModalOpen: t,
						isRuleEditorOpen: s,
						isSubredditRulesPending: n,
						language: a,
						subreddit: o,
						subredditRules: i
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, e && r.a.createElement(ie, null, this.state.isReordering ? r.a.createElement(de.i, {
						onClick: this.stopReorder
					}, Object(G.c)("Cancel")) : r.a.createElement(de.n, {
						onClick: this.startReorder,
						disabled: i.length <= 1
					}, Object(G.c)("Reorder rules")), this.state.isReordering ? r.a.createElement(hx, {
						onClick: this.reorderRules,
						disabled: _s()(i.map(e => e.shortName), this.state.ruleOrder)
					}, Object(G.c)("Save")) : r.a.createElement(hx, {
						onClick: this.toggleEditorModal,
						disabled: n || i.length >= GE.d
					}, Object(G.c)("Add rule"))), i.length ? r.a.createElement(oe, null, r.a.createElement("div", {
						className: ZE.a.header
					}, r.a.createElement(re, {
						className: ZE.a.rulesHeader
					}, Object(G.c)("Rules"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360023379211")
					})), !this.state.isReordering && r.a.createElement("div", {
						className: ZE.a.rulesInfo
					}, Object(G.c)("These are rules that visitors must follow to participate. They can       be used as reasons to report or ban posts, comments, and users. Communities can have       a maximum of 15 rules."))), this.state.isReordering ? r.a.createElement(Gl.a, {
						values: this.state.ruleOrder,
						render: (e, t, s, n, a) => r.a.createElement(ex, {
							isDragging: s,
							isOver: n,
							canDrop: a,
							index: t,
							shortName: e
						}),
						onDrop: this.handleDrop
					}) : i.map((t, s) => r.a.createElement(bx, {
						hasConfigPerms: e,
						index: s,
						key: "".concat(o.name, "-").concat(t.shortName),
						language: a,
						onEdit: () => this.onEditRule(t),
						subredditRule: t
					}))) : r.a.createElement(oe, null, r.a.createElement("div", {
						className: ZE.a.header
					}, r.a.createElement(re, {
						className: ZE.a.rulesHeader
					}, Object(G.c)("Rules"), r.a.createElement(se, {
						linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360023379211")
					}))), n ? r.a.createElement(Ex, null) : r.a.createElement(z, {
						text: Object(G.c)("No rules yet")
					}, r.a.createElement(Oh.a, {
						className: ZE.a.rulesIcon
					}))), s && r.a.createElement(ax, {
						onDelete: this.onConfirmDeleteRule,
						rule: this.state.ruleToEdit,
						ruleNames: i.map(e => e.shortName),
						sendEvent: this.trackEdit,
						subredditId: o.id,
						toggleModal: this.toggleEditorModal,
						withOverlay: !0
					}), t && this.state.ruleToEdit && r.a.createElement(U.a, {
						actionText: Object(G.c)("Delete"),
						headerText: Object(G.c)("Delete rule"),
						modalText: Object(G.c)("Are you sure you want to delete this rule?"),
						onConfirm: this.deleteRule,
						toggleModal: this.toggleConfirmationModal,
						trackClick: this.trackDelete,
						withOverlay: !0
					}))
				}
			}
			var vx = Object(i.b)(xx, (e, t) => ({
					removeRule: (s, n) => e(((e, t, s) => async (n, a, o) => {
						let {
							apiContext: r
						} = o;
						const i = Object(R.S)(a(), {
								subredditId: e
							}).name,
							c = Object(L.S)(a()),
							d = Object(R.R)(a(), {
								subredditId: e
							})[s],
							l = "success-block-".concat(t),
							m = "error-block-".concat(t),
							u = await Object(FE.d)(r(), i, t);
						if (u.ok) {
							const t = u.body;
							n(WE({
								rules: t,
								subredditId: e
							})), n(hi.e({
								id: l,
								kind: xi.b.SuccessCommunityGreen,
								text: Object(Ot.a)(c, "subredditModeration.subredditRules.toast.ruleDeleted"),
								buttonText: Object(Ot.a)(c, "subredditModeration.subredditRules.toast.ruleUndo"),
								buttonAction: UE(e, {
									rule: d.shortName,
									kind: d.kind,
									reason: d.violationReason,
									description: d.description
								})
							}))
						} else n(hi.e({
							id: m,
							kind: xi.b.Error,
							text: u.json.errors ? u.json.errors[0][1] : Object(Ot.a)(c, "error.tryAgainLater")
						}))
					})(t.subreddit.id, s, n)),
					reorderRules: s => {
						e(VE(t.subreddit.id, s))
					},
					toggleConfirmationModal: () => e(Object(F.i)("SubredditRule--Modal--DeleteConfirmation")),
					toggleRuleEditorModal: () => e(Object(F.i)("SubredditRule--Editor--Modal"))
				}))(Object(x.b)(fx)),
				Cx = s("./src/reddit/components/Wiki/WikiPageDiff/index.tsx"),
				Ox = s("./src/reddit/components/Wiki/WikiPageEditor/index.tsx"),
				jx = s("./src/reddit/components/Wiki/WikiPageSource/index.tsx"),
				yx = s("./src/reddit/constants/wiki.ts"),
				kx = s("./src/reddit/helpers/wiki/wikiRevision.ts"),
				wx = s("./src/reddit/components/Wiki/RevisionsHistory/index.tsx"),
				Sx = s("./src/reddit/components/Wiki/WikiPageContent/index.tsx"),
				Nx = s("./src/reddit/components/Wiki/WikiPageTopBar/index.tsx"),
				Tx = s("./src/reddit/components/Wiki/ModHubWikiManagement/ModHubWikiPage/index.m.less"),
				_x = s.n(Tx),
				Ix = e => {
					const {
						wikiPageName: t,
						subredditName: s
					} = e;
					return o.createElement("div", {
						className: _x.a.container
					}, o.createElement(ie, null, o.createElement(Nx.a, {
						isModHub: !0,
						wikiPageName: t,
						subredditName: s
					})), o.createElement(Sx.a, {
						className: _x.a.pageContent,
						isModHub: !0,
						subredditName: s,
						wikiPageName: t
					}))
				},
				Px = s("./src/reddit/actions/wiki/wikiBannedContributors/index.ts"),
				Mx = s("./src/reddit/constants/componentSizes.ts"),
				Rx = s("./src/reddit/helpers/trackers/subredditWiki.ts"),
				Lx = s("./src/reddit/selectors/subredditWiki.ts"),
				Dx = s("./src/reddit/components/BannedUserList/AddBannedUserModal/DaysInput.tsx"),
				Ax = s("./src/reddit/components/BannedUserList/AddBannedUserModal/RulesDropdown.tsx"),
				Fx = s("./src/reddit/components/Wiki/ModHubWikiManagement/WikiBannedContributors/index.m.less"),
				Bx = s.n(Fx);
			const Ux = 300,
				Hx = Object(i.b)(null, (e, t) => {
					let {
						subredditName: s
					} = t;
					return {
						addBannedWikiContributor: t => e(Object(Px.a)(s, t))
					}
				});
			class Wx extends r.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onChangeModNote = e => {
						e.currentTarget.value.length <= Ux && this.setState({
							note: e.currentTarget.value
						})
					}, this.onSelectReason = e => {
						this.setState({
							banReason: e
						})
					}, this.onChangeBanDuration = e => {
						const t = Number(e.currentTarget.value);
						"number" == typeof t && (t < 0 || t > et.b || this.setState({
							duration: t
						}))
					}, this.togglePermanent = e => {
						e.key && "Enter" !== e.key || this.setState({
							isDurationPermanent: !this.state.isDurationPermanent,
							duration: void 0
						})
					}, this.onSubmit = () => {
						const e = Object(le.a)(this.state.username),
							{
								note: t,
								banReason: s,
								isDurationPermanent: n,
								duration: a
							} = this.state;
						let o = n ? void 0 : a;
						const r = this.props.bannedUser && null != this.props.bannedUser.daysRemaining && this.props.bannedUser.daysRemaining === a;
						null != o && r && (o += 1), this.props.addBannedWikiContributor({
							note: t,
							username: e,
							banReason: s,
							duration: o
						}), this.props.sendEvent(Rx.a), this.props.toggleModal()
					}, this.state = {
						duration: e.bannedUser ? e.bannedUser.daysRemaining : void 0,
						isDurationPermanent: !e.bannedUser || !e.bannedUser.daysRemaining,
						note: e.bannedUser ? e.bannedUser.note : "",
						username: e.bannedUser ? e.bannedUser.username : ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(at.c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, Object(G.c)("Ban wiki contributor"), e.bannedUser && ": u/".concat(e.bannedUser.username)), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, !e.bannedUser && r.a.createElement(r.a.Fragment, null, r.a.createElement(at.f, null, r.a.createElement(at.i, null, Object(G.c)("Enter username")), r.a.createElement(at.h, {
						onChange: this.onInputChange,
						placeholder: Object(G.c)("u/username"),
						value: this.state.username
					})), r.a.createElement(at.f, null, r.a.createElement(at.i, null, Object(G.c)("Reason for ban")), r.a.createElement(Ax.a, {
						onSelectReason: this.onSelectReason,
						reason: t.banReason,
						subredditId: e.subredditId
					}))), r.a.createElement(at.f, null, r.a.createElement(at.i, null, Object(G.c)("Mod note")), r.a.createElement(at.h, {
						onChange: this.onChangeModNote,
						placeholder: Object(G.c)("Mod note"),
						value: t.note
					}), r.a.createElement(Zc.a, {
						maxChars: Ux,
						text: t.note
					})), r.a.createElement(Dx.a, {
						duration: t.duration,
						isDurationPermanent: t.isDurationPermanent,
						onChangeDuration: this.onChangeBanDuration,
						togglePermanent: this.togglePermanent
					})), r.a.createElement(at.e, null, r.a.createElement(de.i, {
						onClick: e.toggleModal
					}, Object(G.c)("Cancel")), r.a.createElement(de.f, {
						className: Bx.a.primaryButton,
						onClick: this.onSubmit,
						disabled: !Object(it.a)(t.username)
					}, Object(G.c)("Ban user"))))
				}
			}
			var qx = Object(nt.a)(Hx(Wx));
			const Vx = Object(c.c)({
				isAddBannedContributorModalOpen: e => "WikiBannedContributers--BanContributorModal" === Object(tt.a)(e),
				isConfirmModalOpen: e => "WikiBannedContributers--RemoveBannedWikiContributor" === Object(tt.a)(e),
				isWikiBannedContributorsListPending: Lx.e,
				loadMoreToken: Lx.f,
				searchResult: Lx.g,
				wikiContributors: Lx.h
			});
			class zx extends r.a.Component {
				constructor(e) {
					super(e), this.onSearch = async e => {
						this.setState({
							isSearchPending: !0,
							searchTerm: e
						}), await this.props.searchWikiBannedContributorByName(e), this.setState({
							isSearchPending: !1
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: void 0
					}), this.onClickEditUser = e => {
						this.setState({
							userToEdit: e
						}), this.props.toggleAddBannedContributorModal()
					}, this.onCloseBannedContributorModal = () => {
						this.props.toggleAddBannedContributorModal(), this.setState({
							userToEdit: void 0
						})
					}, this.onClickRemove = e => {
						this.setState({
							userToRemove: e
						}), this.props.toggleConfirmModal()
					}, this.onRemoveContributor = () => {
						this.state.userToRemove && (this.props.removeWikiBannedContributor(this.state.userToRemove), this.props.sendEvent(Rx.h))
					}, this.onLoadMore = async () => {
						this.props.loadMoreToken && !this.state.isFetchMoreBannedContributorsPending && (this.setState({
							isFetchMoreBannedContributorsPending: !0
						}), await this.props.moreWikiBannedContributorsRequested(this.props.loadMoreToken), this.setState({
							isFetchMoreBannedContributorsPending: !1
						}))
					}, this.renderBannedContributor = e => {
						const t = this.props.wikiContributors.find(t => t.id === e);
						if (!t) return r.a.createElement(r.a.Fragment, null);
						const s = new Date(t.date),
							n = Object(A.d)("en", s),
							a = zt("en", t.daysRemaining);
						return r.a.createElement(Ye, {
							description: t.note,
							username: t.username,
							userIcon: t.iconUrl,
							primaryButton: r.a.createElement("a", {
								href: "".concat(D.a.redditUrl, "/message/compose/?to=").concat(t.username),
								target: "_blank"
							}, r.a.createElement(de.n, null, Object(G.c)("Send message"))),
							secondaryButton: r.a.createElement(de.n, {
								onClick: () => this.onClickEditUser(t)
							}, Object(G.c)("Edit")),
							tertiaryButton: r.a.createElement(de.n, {
								onClick: () => this.onClickRemove(t.id)
							}, Object(G.c)("Remove")),
							timeAgo: "".concat(n, " (").concat(a, ")"),
							key: t.id
						})
					}, this.renderNoContent = () => this.props.isWikiBannedContributorsListPending ? r.a.createElement(Ze, null) : r.a.createElement(z, {
						text: Object(G.c)("No banned wiki contributors in ".concat(Object(G.b)("subredditName", this.props.subredditName)))
					}), this.renderSearchState = () => r.a.createElement(Oe, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !this.props.searchResult,
						searchPending: this.state.isSearchPending,
						searchTerm: this.state.searchTerm || ""
					}, this.props.searchResult && this.renderBannedContributor(this.props.searchResult.id)), this.state = {
						isFetchMoreBannedContributorsPending: !1,
						isSearchPending: !1,
						searchTerm: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.props.toggleAddBannedContributorModal
					}, Object(G.c)("Ban contributor"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Banned wiki contributors")), r.a.createElement(we, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), e.wikiContributors.length ? t.searchTerm ? this.renderSearchState() : r.a.createElement(ce.b, {
						loadMoreToken: e.loadMoreToken || void 0,
						onLoadMore: this.onLoadMore,
						viewportTopPadding: Mx.g + Mx.k
					}, e.wikiContributors.map(e => ({
						estHeight: 40,
						id: e.id,
						render: () => this.renderBannedContributor(e.id)
					}))) : this.renderNoContent(), t.isFetchMoreBannedContributorsPending && r.a.createElement(Ze, {
						rows: 3
					})), e.isAddBannedContributorModalOpen && r.a.createElement(qx, {
						bannedUser: t.userToEdit,
						subredditId: e.subredditId,
						sendEvent: e.sendEvent,
						subredditName: e.subredditName,
						toggleModal: this.onCloseBannedContributorModal,
						withOverlay: !0
					}), t.userToRemove && e.isConfirmModalOpen && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						headerText: Object(G.c)("Remove banned wiki contributor?"),
						modalText: Object(G.c)("Do you wish to unban this user as a wiki contributor?"),
						onConfirm: this.onRemoveContributor,
						toggleModal: this.props.toggleConfirmModal,
						withOverlay: !0
					}))
				}
			}
			var Kx = Object(i.b)(Vx, (e, t) => {
					let {
						subredditName: s
					} = t;
					return {
						moreWikiBannedContributorsRequested: t => e(Object(Px.b)(s, t)),
						removeWikiBannedContributor: t => e(Object(Px.c)(s, t)),
						searchWikiBannedContributorByName: t => e(Object(Px.d)(s, t)),
						toggleAddBannedContributorModal: () => e(Object(F.i)("WikiBannedContributers--BanContributorModal")),
						toggleConfirmModal: () => e(Object(F.i)("WikiBannedContributers--RemoveBannedWikiContributor"))
					}
				})(Object(x.b)(zx)),
				Qx = s("./src/reddit/actions/wiki/wikiContributors/index.ts"),
				Gx = s("./src/reddit/components/Wiki/ModHubWikiManagement/WikiContributors/index.m.less"),
				Jx = s.n(Gx);
			const Zx = Object(i.b)(null, (e, t) => {
				let {
					subredditName: s
				} = t;
				return {
					addWikiContributor: t => e(Object(Qx.a)(s, t))
				}
			});
			class Xx extends r.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const e = Object(le.a)(this.state.username);
						this.props.addWikiContributor(e), this.props.sendEvent(Rx.b), this.props.toggleModal()
					}, this.state = {
						username: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(at.c, null, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, Object(G.c)("Add wiki contributor")), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement(at.j, null, r.a.createElement("div", {
						className: Jx.a.inputLabel
					}, Object(G.c)("Enter username")), r.a.createElement(ot.d, {
						placeholder: Object(G.c)("u/username"),
						onChange: this.onInputChange,
						value: this.state.username,
						autoFocus: !0
					})), r.a.createElement(at.e, null, r.a.createElement(de.i, {
						onClick: e.toggleModal
					}, Object(G.c)("Cancel")), r.a.createElement(de.f, {
						className: Jx.a.primaryButton,
						onClick: this.onSubmit,
						disabled: !Object(it.a)(t.username)
					}, Object(G.c)("Add user"))))
				}
			}
			var Yx = Object(nt.a)(Zx(Xx));
			const $x = Object(c.c)({
				isAddContributorModalOpen: e => "WikiContributers--AddContributorModal" === Object(tt.a)(e),
				isConfirmModalOpen: e => "WikiContributers--RemoveContributor" === Object(tt.a)(e),
				isWikiContributorsListPending: Lx.j,
				loadMoreToken: Lx.k,
				searchResult: Lx.l,
				wikiContributors: Lx.m
			});
			class ef extends r.a.Component {
				constructor(e) {
					super(e), this.onSearch = async e => {
						this.setState({
							isSearchPending: !0,
							searchTerm: e
						}), await this.props.searchWikiContributorByName(e), this.setState({
							isSearchPending: !1
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: void 0
					}), this.onClickRemove = e => {
						this.setState({
							userToRemove: e
						}), this.props.toggleConfirmModal()
					}, this.onRemoveContributor = () => {
						this.state.userToRemove && (this.props.removeWikiContributor(this.state.userToRemove), this.props.sendEvent(Rx.i))
					}, this.onLoadMore = async () => {
						this.props.loadMoreToken && !this.state.isFetchMoreContributorsPending && (this.setState({
							isFetchMoreContributorsPending: !0
						}), await this.props.moreWikiContributorsRequested(this.props.loadMoreToken), this.setState({
							isFetchMoreContributorsPending: !1
						}))
					}, this.renderContributor = e => {
						const t = new Date(e.date),
							s = Object(A.d)("en", t);
						return r.a.createElement(Ye, {
							username: e.username,
							userIcon: e.iconUrl,
							primaryButton: r.a.createElement("a", {
								href: "".concat(D.a.redditUrl, "/message/compose/?to=").concat(e.username),
								target: "_blank"
							}, r.a.createElement(de.n, null, Object(G.c)("Send message"))),
							secondaryButton: r.a.createElement(de.n, {
								onClick: () => this.onClickRemove(e.id)
							}, Object(G.c)("Remove")),
							timeAgo: s
						})
					}, this.renderNoContent = () => this.props.isWikiContributorsListPending ? r.a.createElement(Ze, null) : r.a.createElement(z, {
						text: Object(G.c)("No wiki contributors in ".concat(Object(G.b)("subredditName", this.props.subredditName)))
					}), this.renderSearchState = () => r.a.createElement(Oe, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !this.props.searchResult,
						searchPending: this.state.isSearchPending,
						searchTerm: this.state.searchTerm || ""
					}, this.props.searchResult && this.renderContributor(this.props.searchResult)), this.state = {
						isFetchMoreContributorsPending: !1,
						isSearchPending: !1,
						searchTerm: "",
						userToRemove: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, r.a.createElement(de.f, {
						onClick: this.props.toggleAddContributorModal
					}, Object(G.c)("Add contributor"))), r.a.createElement(oe, null, r.a.createElement(re, null, Object(G.c)("Added wiki contributors")), r.a.createElement(we, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), e.wikiContributors.length ? t.searchTerm ? this.renderSearchState() : r.a.createElement(ce.b, {
						loadMoreToken: e.loadMoreToken || void 0,
						onLoadMore: this.onLoadMore,
						viewportTopPadding: Mx.g + Mx.k
					}, e.wikiContributors.map(e => ({
						estHeight: 40,
						id: e.id,
						render: () => this.renderContributor(e)
					}))) : this.renderNoContent(), t.isFetchMoreContributorsPending && r.a.createElement(Ze, {
						rows: 3
					})), e.isAddContributorModalOpen && r.a.createElement(Yx, {
						sendEvent: e.sendEvent,
						subredditName: e.subredditName,
						toggleModal: e.toggleAddContributorModal,
						withOverlay: !0
					}), t.userToRemove && e.isConfirmModalOpen && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						headerText: Object(G.c)("Remove wiki contributor?"),
						modalText: Object(G.c)("Do you wish to remove this user as a wiki contributor?"),
						onConfirm: this.onRemoveContributor,
						toggleModal: this.props.toggleConfirmModal,
						withOverlay: !0
					}))
				}
			}
			var tf = Object(i.b)($x, (e, t) => {
					let {
						subredditName: s
					} = t;
					return {
						moreWikiContributorsRequested: t => e(Object(Qx.b)(s, t)),
						removeWikiContributor: t => e(Object(Qx.c)(s, t)),
						searchWikiContributorByName: t => e(Object(Qx.d)(s, t)),
						toggleAddContributorModal: () => e(Object(F.i)("WikiContributers--AddContributorModal")),
						toggleConfirmModal: () => e(Object(F.i)("WikiContributers--RemoveContributor"))
					}
				})(Object(x.b)(ef)),
				sf = s("./src/reddit/actions/wiki/wikiPageSettings/index.tsx"),
				nf = s("./src/reddit/components/Wiki/common/PageTitle/index.tsx"),
				af = s("./src/reddit/models/SubredditWikiPage/index.ts"),
				of = s("./src/reddit/components/Wiki/ModHubWikiManagement/WikiPageSettings/index.m.less"),
				rf = s.n( of );
			const cf = Object(c.c)({
					isConfirmModalOpen: e => "WikiPageSettings--RemoveContributor" === Object(tt.a)(e)
				}),
				df = Object(i.b)(cf, (e, t) => {
					let {
						subredditName: s,
						wikiPageName: n
					} = t;
					return {
						addWikiPageContributor: t => e(Object(sf.a)({
							username: t,
							wikiPageName: n,
							subredditName: s
						})),
						fetchMoreWikiPageContributors: t => e(Object(sf.b)(s, n, t)),
						removeWikiPageContributor: t => e(Object(sf.d)({
							username: t,
							wikiPageName: n,
							subredditName: s
						})),
						toggleConfirmModal: () => e(Object(F.i)("WikiPageSettings--RemoveContributor"))
					}
				}),
				lf = e => r.a.createElement("div", {
					className: Object(d.a)(e.className, Object(yp.b)({
						isLoading: !0
					}))
				}),
				mf = () => r.a.createElement(r.a.Fragment, null, Ne()(3, e => r.a.createElement("div", {
					className: rf.a.contributorRow,
					key: e
				}, r.a.createElement(lf, {
					className: rf.a.loadingUserIcon
				}), r.a.createElement(lf, {
					className: rf.a.loadingUserName
				}))));
			class uf extends r.a.Component {
				constructor(e) {
					super(e), this.onChangeNewContributorInput = e => {
						this.setState({
							newContributor: e.target.value
						})
					}, this.onKeyDown = e => {
						e.keyCode === Ia.a.Enter && this.canAdd() && this.onAddContributor()
					}, this.canAdd = () => !!this.state.newContributor, this.onAddContributor = () => {
						const e = Object(le.a)(this.state.newContributor);
						this.props.addWikiPageContributor(e), this.props.sendEvent(Rx.c), this.setState({
							newContributor: ""
						})
					}, this.onClickRemove = e => {
						this.setState({
							userToRemove: e
						}), this.props.toggleConfirmModal()
					}, this.onRemoveWikiContributor = () => {
						this.state.userToRemove && (this.props.removeWikiPageContributor(this.state.userToRemove), this.props.sendEvent(Rx.j))
					}, this.renderContributor = e => r.a.createElement("div", {
						className: rf.a.contributorRow
					}, r.a.createElement(Te.a, {
						username: e.username,
						iconSize: 24,
						sendHoverCardEvent: wa.a,
						tooltipId: "wikiPageContributor--".concat(e.username),
						userIcon: e.iconUrl
					}), r.a.createElement(de.n, {
						className: rf.a.removeButton,
						onClick: () => this.onClickRemove(e.username)
					}, Object(G.c)("Remove"))), this.onLoadMore = async () => {
						this.props.afterToken && !this.state.isFetchMoreContributorsPending && (this.setState({
							isFetchMoreContributorsPending: !0
						}), await this.props.fetchMoreWikiPageContributors(this.props.afterToken), this.setState({
							isFetchMoreContributorsPending: !1
						}))
					}, this.state = {
						isFetchMoreContributorsPending: !1,
						newContributor: "",
						userToRemove: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement("div", {
						className: Object(d.a)(rf.a.formGroup, rf.a.contributorsForm)
					}, r.a.createElement("div", {
						className: rf.a.sectionTitle
					}, Object(G.c)("Add approved wiki contributor for this page")), r.a.createElement(ot.c, {
						className: rf.a.contributorInput,
						placeholder: Object(G.c)("u/username"),
						value: t.newContributor,
						onChange: this.onChangeNewContributorInput,
						onKeyDown: this.onKeyDown,
						maxLength: 22
					}), r.a.createElement("div", {
						className: rf.a.buttonRow
					}, r.a.createElement(de.f, {
						className: rf.a.addButton,
						disabled: !this.canAdd(),
						onClick: this.onAddContributor
					}, Object(G.c)("Add"))), r.a.createElement(ce.b, {
						loadMoreToken: e.afterToken ? e.afterToken : void 0,
						onLoadMore: this.onLoadMore,
						viewportTopPadding: Mx.g + Mx.k
					}, e.editorsInfo.map((e, t) => ({
						estHeight: 40,
						id: e.username,
						render: () => this.renderContributor(e)
					}))), t.isFetchMoreContributorsPending && r.a.createElement(mf, null), t.userToRemove && e.isConfirmModalOpen && r.a.createElement(U.a, {
						actionText: Object(G.c)("Remove"),
						headerText: Object(G.c)("Remove wiki contributor?"),
						modalText: Object(G.c)("Do you wish to remove this user as a wiki contributor?"),
						onConfirm: this.onRemoveWikiContributor,
						toggleModal: this.props.toggleConfirmModal,
						withOverlay: !0
					}))
				}
			}
			var pf = df(uf);
			const bf = Object(c.c)({
				subredditSettings: (e, t) => {
					const s = Object(R.G)(e, t.subredditName);
					return Object(R.U)(e, s)
				},
				wikiPageSettings: Lx.d
			});
			class hf extends r.a.Component {
				constructor(e) {
					super(e), this.onChangeEditPermissions = e => {
						this.setState({
							editPermissions: e
						})
					}, this.onChangeVisibilitySettings = e => {
						this.setState({
							isVisible: e
						})
					}, this.onSave = async () => {
						this.sendOnSaveEvents(), this.setState({
							isSavePending: !0
						}), await this.props.saveWikiPageSettings(this.state.editPermissions, this.state.isVisible), this.setState({
							isSavePending: !1
						})
					}, this.sendOnSaveEvents = () => {
						const e = this.props.wikiPageSettings;
						e && (this.state.isVisible !== e.isVisible && this.props.sendEvent(Object(Rx.n)(!!this.state.isVisible)), this.state.editPermissions !== e.editPermissions && this.props.sendEvent(Object(Rx.o)(this.state.editPermissions)), this.props.sendEvent(Rx.p))
					}, this.onCancel = () => {
						this.props.wikiPageSettings && this.setState({
							editPermissions: this.props.wikiPageSettings.editPermissions,
							isVisible: this.props.wikiPageSettings.isVisible
						})
					}, this.state = {
						isSavePending: !1,
						isVisible: e.wikiPageSettings ? e.wikiPageSettings.isVisible : void 0,
						editPermissions: e.wikiPageSettings ? e.wikiPageSettings.editPermissions : void 0
					}
				}
				componentDidUpdate(e) {
					!e.wikiPageSettings && this.props.wikiPageSettings && this.setState({
						editPermissions: this.props.wikiPageSettings.editPermissions,
						isVisible: this.props.wikiPageSettings.isVisible
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					if (!e.wikiPageSettings) return null;
					const s = e.subredditSettings && "disabled" === e.subredditSettings.wikimode,
						n = t.editPermissions !== e.wikiPageSettings.editPermissions || t.isVisible !== e.wikiPageSettings.isVisible,
						a = t.editPermissions === af.a.Contributors || t.editPermissions === af.a.Inherit;
					return r.a.createElement(r.a.Fragment, null, r.a.createElement(ie, null, n && r.a.createElement(r.a.Fragment, null, r.a.createElement(de.i, {
						className: rf.a.cancelButton,
						onClick: this.onCancel
					}, Object(G.c)("Cancel")), r.a.createElement(de.f, {
						disabled: t.isSavePending,
						onClick: this.onSave
					}, Object(G.c)("Save")))), r.a.createElement(nf.a, {
						title: Object(G.c)("Wiki page settings"),
						className: rf.a.pageTitle,
						buttonText: Object(G.c)("Go to wiki page"),
						buttonLink: "/r/".concat(e.subredditName, "/about/wiki/").concat(e.wikiPageName)
					}), s && r.a.createElement(Tn.a, {
						className: rf.a.alertBanner,
						color: qn.a.quarantine,
						icon: r.a.createElement(sa.a, {
							className: rf.a.alertIcon
						}),
						subtitle: Object(G.c)("Only mods may interact with this wiki"),
						title: Object(G.c)("This wiki is currently disabled")
					}), r.a.createElement("div", {
						className: rf.a.content
					}, r.a.createElement("div", {
						className: rf.a.sectionTitle
					}, Object(G.c)("Add to wiki home")), r.a.createElement(Hc.a, {
						className: rf.a.checkboxInput,
						value: t.isVisible,
						name: "listed",
						onChange: this.onChangeVisibilitySettings
					}, r.a.createElement("span", {
						className: rf.a.inputOptionText
					}, Object(G.c)("Show this page in your wiki index"))), r.a.createElement("div", {
						className: rf.a.formGroup
					}, r.a.createElement("div", {
						className: rf.a.sectionTitle
					}, Object(G.c)("Who can edit this page?")), r.a.createElement(sn.a, {
						value: t.editPermissions,
						name: "permlevel",
						onChange: this.onChangeEditPermissions
					}, r.a.createElement(Dm.a, {
						className: rf.a.radioOption,
						showButton: !0,
						value: af.a.Inherit
					}, r.a.createElement("span", {
						className: rf.a.inputOptionText
					}, Object(G.c)("Use subreddit wiki permissions"))), r.a.createElement(Dm.a, {
						className: rf.a.radioOption,
						showButton: !0,
						value: af.a.Mods
					}, r.a.createElement("span", {
						className: rf.a.inputOptionText
					}, Object(G.c)("Only mods may edit and view"))), r.a.createElement(Dm.a, {
						className: rf.a.radioOption,
						showButton: !0,
						value: af.a.Contributors
					}, r.a.createElement("span", {
						className: rf.a.inputOptionText
					}, Object(G.c)("Only approved wiki contributors for this page may edit"))))), a && r.a.createElement(pf, {
						afterToken: e.wikiPageSettings.afterToken,
						sendEvent: this.props.sendEvent,
						subredditName: e.subredditName,
						wikiPageName: e.wikiPageName,
						editorsInfo: e.wikiPageSettings.editorsInfo
					})))
				}
			}
			var gf = Object(i.b)(bf, (e, t) => {
					let {
						subredditName: s,
						wikiPageName: n
					} = t;
					return {
						saveWikiPageSettings: (t, a) => e(Object(sf.e)({
							editPermissions: t,
							isVisible: a,
							subredditName: s,
							wikiPageName: n
						}))
					}
				})(Object(x.b)(hf)),
				Ef = s("./src/reddit/components/Wiki/ModHubWikiManagement/index.m.less"),
				xf = s.n(Ef);
			const ff = Object(f.t)(),
				vf = () => {
					document.body.scrollTop = 0, document.documentElement.scrollTop = 0
				};
			class Cf extends r.a.Component {
				scrollToTopIfNeeded() {
					location.hash || vf()
				}
				componentDidMount() {
					this.scrollToTopIfNeeded()
				}
				componentDidUpdate(e) {
					this.props.pageLayer !== e.pageLayer && this.scrollToTopIfNeeded()
				}
				render() {
					const {
						subreddit: e,
						pageLayer: t
					} = this.props;
					if (!t) return null;
					const {
						urlParams: s,
						queryParams: n
					} = t, {
						wikiSubRoute: a,
						wikiPageName: o,
						pageName: i
					} = s, c = n[nr.w], d = n[nr.x], l = nr.y in n;
					switch (a) {
						case yx.l.Create:
						case yx.l.Edit:
							return r.a.createElement(Ox.a, {
								contentClassName: xf.a.modHubPageEditorContent,
								isCreation: a === yx.l.Create,
								subredditName: e.name,
								topBarClassName: xf.a.modHubTopBar,
								wikiPageName: o
							});
						case yx.l.Revisions:
							return r.a.createElement(wx.a, {
								isModHub: !0,
								isRecentRevisionsMode: !o,
								key: o,
								subredditName: e.name,
								wikiPageName: o
							});
						case yx.l.Settings:
							if (o) return r.a.createElement(gf, {
								subredditName: e.name,
								wikiPageName: o
							});
							break;
						default:
							return i === h.Nb.WikiBanned ? r.a.createElement(Kx, {
								subredditId: e.id,
								subredditName: e.name
							}) : i === h.Nb.WikiContributors ? r.a.createElement(tf, {
								subredditName: e.name
							}) : o && c && d ? r.a.createElement(Cx.a, {
								comparisonRevisionId: Object(kx.a)(d),
								isModHub: !0,
								revisionId: Object(kx.a)(c),
								subredditName: e.name,
								wikiPageName: o
							}) : o && (c || l) ? r.a.createElement(jx.a, {
								isModHub: !0,
								revisionId: c ? Object(kx.a)(c) : void 0,
								subredditName: e.name,
								wikiPageName: o
							}) : o ? r.a.createElement(Ix, {
								wikiPageName: o,
								subredditName: e.name
							}) : null
					}
				}
			}
			var Of = ff(Cf),
				jf = s("./src/reddit/components/ModQueueList/index.tsx"),
				yf = s("./src/reddit/components/ModQueueList/LayoutNavigation.tsx"),
				kf = s("./src/reddit/components/ModHub/Content/index.m.less"),
				wf = s.n(kf);
			var Sf = e => r.a.createElement(oe, {
					className: Object(d.a)(wf.a.container, e.layout === eu.g.Large ? wf.a.isLargePostLayout : void 0)
				}, r.a.createElement(re, null, Object(Ot.a)(e.language, "subredditModeration.modQueue.".concat(e.pageName)), r.a.createElement(se, {
					linkUrl: "".concat(D.a.redditHelpUrl.modHelpCenter, "hc/en-us/articles/360010090132")
				})), r.a.createElement(yf.a, {
					hideSubredditFilter: !0,
					language: e.language,
					postTypeFilter: e.postTypeFilter,
					sendEventWithName: e.sendEventWithName,
					showTypeFilter: e.pageName !== h.Nb.Unmoderated,
					subredditName: e.subredditName
				}), r.a.createElement(jf.a, {
					after: e.after,
					layout: e.layout,
					sendEventWithName: e.sendEventWithName,
					subredditName: e.subredditName,
					page: e.page,
					pageName: e.pageName,
					postTypeFilter: e.postTypeFilter
				})),
				Nf = function(e, t) {
					var s = {};
					for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (s[n] = e[n]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var a = 0;
						for (n = Object.getOwnPropertySymbols(e); a < n.length; a++) t.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[a]) && (s[n[a]] = e[n[a]])
					}
					return s
				};
			var Tf = e => {
					const {
						language: t,
						layout: s,
						pageName: n,
						postTypeFilter: a,
						subpageName: o
					} = e, i = Nf(e, ["language", "layout", "pageName", "postTypeFilter", "subpageName"]), c = Object.assign({}, i, {
						subredditId: e.subreddit.id
					});
					switch (n) {
						case h.Nb.Removal:
							return r.a.createElement(Jh, {
								subredditId: e.subreddit.id,
								sendEventWithName: e.sendEventWithName
							});
						case h.Nb.Contributors:
							return r.a.createElement(Ct, c);
						case h.Nb.Banned:
							return r.a.createElement(Zt, c);
						case h.Nb.Streaming:
							return r.a.createElement(cg, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case h.Nb.Muted:
							return r.a.createElement(vh, c);
						case h.Nb.Moderators:
							return r.a.createElement(pi, c);
						case h.Nb.Modlog:
							return r.a.createElement(dr, c);
						case h.Nb.PostRequirements:
							return r.a.createElement(Rb, {
								subredditName: e.subreddit.name
							});
						case h.Nb.Flair:
							return r.a.createElement(Ja, {
								after: e.after,
								before: e.before,
								subredditId: e.subreddit.id
							});
						case h.Nb.PostFlair:
							return r.a.createElement($u, {
								subredditId: e.subreddit.id
							});
						case h.Nb.UserFlair:
							return r.a.createElement(np, {
								subredditId: e.subreddit.id
							});
						case h.Nb.Badges:
							return r.a.createElement(zi, {
								subredditId: e.subreddit.id
							});
						case h.Nb.Emotes:
							return r.a.createElement(Ki, {
								subredditId: e.subreddit.id
							});
						case h.Nb.SubredditRules:
							return r.a.createElement(vx, {
								subreddit: e.subreddit
							});
						case h.Nb.CommunitySettings:
							return r.a.createElement(On, {
								subredditId: e.subreddit.id,
								subpageName: e.subpageName,
								subredditName: e.subreddit.name
							});
						case h.Nb.Modqueue:
						case h.Nb.Reports:
						case h.Nb.Spam:
						case h.Nb.Edited:
						case h.Nb.Unmoderated:
							return r.a.createElement(Sf, {
								after: e.after,
								language: t,
								layout: s,
								page: e.page,
								pageName: n,
								postTypeFilter: a,
								sendEventWithName: e.sendEventWithName,
								subredditName: e.subreddit.name
							});
						case h.Nb.Awards:
							return r.a.createElement(Ns, c);
						case h.Nb.Emojis:
							return r.a.createElement(Wl, {
								subreddit: e.subreddit
							});
						case h.Nb.Wiki:
						case h.Nb.WikiContributors:
						case h.Nb.WikiBanned:
							return r.a.createElement(Of, {
								subreddit: e.subreddit
							});
						case h.Nb.Traffic:
							return r.a.createElement(oh, {
								subreddit: e.subreddit
							});
						case h.Nb.SubredditContent:
							return r.a.createElement(DE, {
								subreddit: e.subreddit
							});
						default:
							return Object(b.a)(n)
					}
				},
				_f = s("./src/reddit/components/ModHub/Content/NoPermissions.tsx"),
				If = s("./src/reddit/components/ModHub/Content/WelcomeMessage.m.less"),
				Pf = s.n(If);
			const Mf = m.a.wrapped(ta.a, "ModerateIcon", Pf.a),
				Rf = m.a.div("ModHubWelcomeMessage", Pf.a);
			var Lf = e => r.a.createElement(Rf, null, r.a.createElement(Mf, null), Object(Ot.a)(e.language, "subredditModeration.modHub.welcome", {
					subredditName: e.subredditDisplayText
				})),
				Df = s("./src/reddit/constants/modals.ts"),
				Af = s("./src/reddit/icons/svgs/Chat/index.tsx"),
				Ff = s("./src/reddit/icons/svgs/Help/index.tsx"),
				Bf = e => r.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", null, r.a.createElement("path", {
					fillRule: "evenodd",
					d: "M17,9.4802 C17.553,9.4802 18,9.9272 18,10.4802 C18,11.0332 17.553,11.4802 17,11.4802 L8,11.4802 C7.447,11.4802 7,11.0332 7,10.4802 C7,9.9272 7.447,9.4802 8,9.4802 L17,9.4802 Z M17,15.4802 C17.553,15.4802 18,15.9272 18,16.4802 C18,17.0332 17.553,17.4802 17,17.4802 L8,17.4802 C7.447,17.4802 7,17.0332 7,16.4802 C7,15.9272 7.447,15.4802 8,15.4802 L17,15.4802 Z M8,5.4802 C7.447,5.4802 7,5.0332 7,4.4802 C7,3.9272 7.447,3.4802 8,3.4802 L13.161,3.4802 L17,3.4802 C17.553,3.4802 18,3.9272 18,4.4802 C18,5.0332 17.553,5.4802 17,5.4802 L13.161,5.4802 L8,5.4802 Z M4.8799,9.9099 C4.9199,9.9999 4.9499,10.0899 4.9699,10.1899 C4.9899,10.2799 4.9999,10.3799 4.9999,10.4799 C4.9999,10.8799 4.8399,11.2609 4.5599,11.5399 C4.4199,11.6809 4.2599,11.7899 4.0689,11.8699 C3.8899,11.9399 3.6999,11.9799 3.4999,11.9799 C3.0999,11.9799 2.7199,11.8199 2.4399,11.5399 C2.1599,11.2609 1.9999,10.8799 1.9999,10.4799 C1.9999,10.3799 2.0099,10.2799 2.0299,10.1899 C2.0499,10.0899 2.0799,9.9999 2.1089,9.9099 C2.1499,9.8199 2.1999,9.7299 2.2499,9.6499 C2.3099,9.5699 2.3699,9.4899 2.4399,9.4199 C2.9999,8.8599 4.0099,8.8599 4.5599,9.4199 C4.6299,9.4899 4.6899,9.5699 4.7499,9.6499 C4.7999,9.7299 4.8499,9.8199 4.8799,9.9099 Z M4.3301,15.2302 C4.4101,15.2902 4.4901,15.3502 4.5591,15.4192 C4.8401,15.7002 5.0001,16.0802 5.0001,16.4802 C5.0001,16.8792 4.8401,17.2502 4.5591,17.5402 C4.4201,17.6802 4.2501,17.7902 4.0691,17.8702 C3.8901,17.9402 3.7001,17.9802 3.5001,17.9802 C3.3001,17.9802 3.1091,17.9402 2.9301,17.8702 C2.7401,17.7902 2.5801,17.6802 2.4391,17.5402 C2.1491,17.2502 2.0001,16.8792 2.0001,16.4802 C2.0001,16.0892 2.1601,15.7002 2.4391,15.4192 C2.5101,15.3502 2.5901,15.2902 2.6701,15.2302 C2.7501,15.1802 2.8401,15.1292 2.9301,15.0892 C3.0191,15.0602 3.1091,15.0302 3.2101,15.0102 C3.3991,14.9702 3.6001,14.9702 3.7901,15.0102 C3.8901,15.0302 3.9791,15.0602 4.0691,15.0892 C4.1601,15.1292 4.2501,15.1802 4.3301,15.2302 Z M2.4395,3.4197 C2.9905,2.8597 4.0095,2.8597 4.5595,3.4197 C4.8395,3.6997 5.0005,4.0897 5.0005,4.4807 C5.0005,4.8797 4.8395,5.2497 4.5595,5.5397 C4.4195,5.6807 4.2595,5.7897 4.0695,5.8697 C3.8895,5.9407 3.7005,5.9807 3.5005,5.9807 C3.2995,5.9807 3.1095,5.9407 2.9195,5.8697 C2.7405,5.7897 2.5805,5.6807 2.4395,5.5397 C2.1495,5.2497 2.0005,4.8797 2.0005,4.4807 C2.0005,4.0897 2.1605,3.6997 2.4395,3.4197 Z"
				}))),
				Uf = e => {
					let {
						className: t
					} = e;
					return r.a.createElement("svg", {
						className: t,
						xmlns: "http://www.w3.org/2000/svg",
						viewBox: "0 0 20 20"
					}, r.a.createElement("path", {
						d: "M15,12 C15,13.103 14.103,14 13,14 L7,14 C5.897,14 5,13.103 5,12 L5,8 C5,7.886 5.016,7.776 5.033,7.668 L9.063,10.891 C9.339,11.111 9.669,11.222 10,11.222 C10.331,11.222 10.661,11.111 10.938,10.891 L14.967,7.668 C14.984,7.776 15,7.886 15,8 L15,12 Z M7,6 L13,6 C13.619,6 14.167,6.289 14.534,6.732 L10.313,10.109 C10.131,10.254 9.869,10.254 9.688,10.109 L5.466,6.732 C5.833,6.289 6.381,6 7,6 Z M17.274,3.038 L10.274,1.038 C10.095,0.987 9.905,0.987 9.726,1.038 L2.726,3.038 C2.296,3.161 2,3.554 2,4 L2,11 C2,16.688 9.41,18.871 9.726,18.962 C9.815,18.987 9.907,19 10,19 C10.093,19 10.185,18.987 10.274,18.962 C10.59,18.871 18,16.688 18,11 L18,4 C18,3.554 17.704,3.161 17.274,3.038 Z"
					}))
				},
				Hf = e => r.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, r.a.createElement("path", {
					d: "M6.0156,4.0156 L15.4926,4.0156 C15.6686,4.0156 15.8366,4.0456 15.9996,4.0886 L15.9996,2.9996 C15.9996,2.4476 15.5526,1.9996 14.9996,1.9996 L2.9996,1.9996 C2.4476,1.9996 1.9996,2.4476 1.9996,2.9996 L1.9996,14.9996 C1.9996,15.5526 2.4476,15.9996 2.9996,15.9996 L4.0886,15.9996 C4.0456,15.8366 4.0156,15.6686 4.0156,15.4926 L4.0156,6.0156 C4.0156,4.9116 4.9116,4.0156 6.0156,4.0156 M17,5 C17.553,5 18,5.447 18,6 L18,17 C18,17.553 17.553,18 17,18 L6,18 C5.447,18 5,17.553 5,17 L5,6 C5,5.447 5.447,5 6,5 L17,5 Z M15.5,12 L15.5,8.5 C15.5,8.276 15.352,8.081 15.138,8.02 L11.638,7.02 C11.548,6.994 11.452,6.994 11.362,7.02 L7.862,8.02 C7.648,8.081 7.5,8.276 7.5,8.5 L7.5,12 C7.5,14.845 11.205,15.936 11.362,15.98 C11.407,15.993 11.454,16 11.5,16 C11.546,16 11.593,15.993 11.638,15.98 C11.795,15.936 15.5,14.845 15.5,12 Z"
				})),
				Wf = e => {
					let {
						className: t
					} = e;
					return r.a.createElement("svg", {
						className: t,
						xmlns: "http://www.w3.org/2000/svg",
						viewBox: "0 0 20 20"
					}, r.a.createElement("path", {
						d: "M1,8 C1.552,8 2,8.448 2,9 L2,14 C2,14.552 1.552,15 1,15 C0.448,15 0,14.552 0,14 L0,9 C0,8.448 0.448,8 1,8 Z M5.6665,5 C6.2185,5 6.6665,5.448 6.6665,6 L6.6665,14 C6.6665,14.552 6.2185,15 5.6665,15 C5.1145,15 4.6665,14.552 4.6665,14 L4.6665,6 C4.6665,5.448 5.1145,5 5.6665,5 Z M10.3335,3 C10.8855,3 11.3335,3.448 11.3335,4 L11.3335,14 C11.3335,14.552 10.8855,15 10.3335,15 C9.7815,15 9.3335,14.552 9.3335,14 L9.3335,4 C9.3335,3.448 9.7815,3 10.3335,3 Z M15,0 C15.552,0 16,0.448 16,1 L16,14 C16,14.552 15.552,15 15,15 C14.448,15 14,14.552 14,14 L14,1 C14,0.448 14.448,0 15,0 Z"
					}))
				},
				qf = s("./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx"),
				Vf = s("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				zf = s.n(Vf);

			function Kf() {
				return (Kf = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
					}
					return e
				}).apply(this, arguments)
			}
			var Qf = e => r.a.createElement("div", Kf({
					className: Object(d.a)(zf.a.breadcrumb, e.className)
				}, e), r.a.createElement("button", {
					className: zf.a.breadcrumbButton
				}, r.a.createElement(qf.a, null), Object(G.c)("Back to mod tools"))),
				Gf = s("./src/reddit/icons/fonts/OutboundLink/index.tsx");
			var Jf = e => e.path ? e.isExternal ? r.a.createElement("a", {
					className: zf.a.navLinkStyles,
					href: e.path,
					onClick: e.onClick,
					target: "_blank"
				}, e.label, r.a.createElement(Gf.a, {
					className: zf.a.outboundLinkIcon
				})) : r.a.createElement(v.a, {
					className: Object(d.a)(zf.a.navLinkStyles, {
						[zf.a.activeLink]: !!e.isActive
					}),
					to: e.path,
					onClick: e.onClick
				}, e.label, e.isNew && r.a.createElement("div", {
					className: zf.a.newLinkIndicator
				}, Object(G.c)("New")), e.isBeta && r.a.createElement("div", {
					className: zf.a.newLinkIndicator
				}, p.fbt._("Beta", null, {
					hk: "z4XPh"
				})), e.isUpdated && r.a.createElement("div", {
					className: zf.a.updatedLinkIndicator
				}, Object(G.c)("Updated")), e.showInboundArrow && r.a.createElement(In.a, {
					className: zf.a.inboundLinkIcon
				})) : r.a.createElement("button", {
					className: zf.a.navLinkStyles,
					onClick: e.onClick
				}, e.label),
				Zf = s("./src/reddit/helpers/wiki/buildWikiPagesTree.ts"),
				Xf = s("./src/reddit/helpers/wiki/validatePageName.ts"),
				Yf = s("./src/reddit/controls/Dropdown/Row.tsx"),
				$f = s("./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less"),
				ev = s.n($f);
			class tv extends r.a.Component {
				constructor(e) {
					super(e), this.onToggleDropdown = () => {
						this.setState({
							isDropdownOpen: !this.state.isDropdownOpen
						})
					}, this.onSelectParentPage = e => {
						this.props.onSelectParentPage(e), this.onToggleDropdown()
					}, this.state = {
						isDropdownOpen: !1
					}
				}
				render() {
					const {
						pageTree: e,
						parentPageName: t
					} = this.props, {
						isDropdownOpen: s
					} = this.state;
					return r.a.createElement("div", {
						className: ev.a.dropdownContainer
					}, r.a.createElement("button", {
						className: ev.a.dropdownTarget,
						onClick: this.onToggleDropdown
					}, r.a.createElement("div", {
						className: ev.a.targetText
					}, t || Object(G.c)("None")), r.a.createElement(Jb.b, null)), s && r.a.createElement(Pa.a, {
						className: ev.a.dropdown
					}, r.a.createElement(Yf.b, {
						className: ev.a.dropdownRow,
						displayText: Object(G.c)("None"),
						onClick: () => this.onSelectParentPage(void 0)
					}), e.map(e => e.depth >= yx.c ? null : yx.f.has(e.path.split("/")[0]) ? null : r.a.createElement(Yf.b, {
						className: ev.a.dropdownRow,
						displayText: e.path,
						key: e.path,
						onClick: () => this.onSelectParentPage(e.path)
					}))))
				}
			}
			var sv = tv;
			const nv = {
				[Xf.a.InvalidPageName]: Object(G.c)("Invalid page name"),
				[Xf.a.MaxLengthExceed]: Object(G.c)("Name exceeds character limit"),
				[Xf.a.PageAlreadyExists]: Object(G.c)("That page already exists"),
				[Xf.a.RestrictedPageName]: Object(G.c)("Restricted page name")
			};
			class av extends r.a.Component {
				constructor(e) {
					super(e), this.onChangePageName = e => {
						this.setState({
							partialPageName: e.currentTarget.value
						})
					}, this.onSelectParentPage = e => {
						this.setState({
							parentPageName: e
						})
					}, this.getNewPagePath = () => {
						let e = "";
						return this.state.parentPageName && (e += "".concat(this.state.parentPageName, "/")), (e += "".concat(this.state.partialPageName)).toLowerCase()
					}, this.state = {
						partialPageName: "",
						parentPageName: void 0
					}
				}
				hasError() {
					const {
						pageTree: e
					} = this.props, {
						partialPageName: t
					} = this.state;
					return Object(Xf.c)(t) || Object(Xf.b)(this.getNewPagePath(), e)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, s = this.hasError();
					return r.a.createElement(at.c, {
						className: ev.a.modalBody
					}, r.a.createElement(at.g, null, r.a.createElement(ct.a, null, r.a.createElement(at.n, null, Object(G.c)("Create a new wiki page")), r.a.createElement(rt.a, {
						onClick: e.toggleModal
					}, r.a.createElement(at.b, null)))), r.a.createElement("div", {
						className: ev.a.notice
					}, r.a.createElement(sa.a, null), Object(G.c)("Parent page and page URL cannot be edited once created")), r.a.createElement(at.j, null, r.a.createElement("div", {
						className: ev.a.sectionTitle
					}, Object(G.c)("Parent page")), r.a.createElement(sv, {
						onSelectParentPage: this.onSelectParentPage,
						pageTree: Object(Zf.b)(e.pageTree || []),
						parentPageName: t.parentPageName
					}), r.a.createElement("div", {
						className: ev.a.sectionTitle
					}, Object(G.c)("Page URL")), r.a.createElement(ot.d, {
						placeholder: Object(G.c)("ex: rules"),
						onChange: this.onChangePageName,
						value: t.partialPageName
					}), r.a.createElement(Zc.a, {
						text: this.getNewPagePath(),
						maxChars: yx.d
					}), r.a.createElement("div", {
						className: ev.a.errorText
					}, t.partialPageName && s ? nv[s] : null)), r.a.createElement(at.e, null, r.a.createElement(at.a, {
						onClick: e.toggleModal
					}, Object(G.c)("Cancel")), r.a.createElement(de.h, {
						disabled: !t.partialPageName || !!s,
						className: ev.a.primaryButton,
						to: "".concat(e.subredditUrl, "about/wiki/create/").concat(this.getNewPagePath())
					}, Object(G.c)("Create"))))
				}
			}
			var ov = Object(nt.a)(av),
				rv = s("./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less"),
				iv = s.n(rv);
			class cv extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.containerRef = r.a.createRef()
				}
				componentDidMount() {
					this.scrollToActiveItemIfNeeded()
				}
				scrollToActiveItemIfNeeded() {
					const e = this.containerRef.current,
						t = e && e.getElementsByClassName(iv.a.mActive)[0];
					if (!e || !t) return;
					const s = e.getBoundingClientRect(),
						n = t.getBoundingClientRect();
					n.top >= s.top && n.bottom <= s.bottom || t.scrollIntoView()
				}
				render() {
					const {
						activePageName: e,
						baseUrl: t,
						directory: s
					} = this.props, n = Object(Zf.b)(s && s.pageTree || []);
					return r.a.createElement("div", {
						ref: this.containerRef,
						className: iv.a.contentTree
					}, n.map(s => {
						const n = s.path === e;
						return r.a.createElement(v.a, {
							key: s.path,
							className: iv.a.pageNavLink,
							to: "".concat(t, "/").concat(s.path)
						}, r.a.createElement("div", {
							className: Object(d.a)(iv.a.pageNavItem, {
								[iv.a.mActive]: n,
								[iv.a.mExists]: s.isPagePresent
							})
						}, Ne()(s.depth, () => r.a.createElement("div", {
							className: iv.a.indentLine
						})), r.a.createElement("span", {
							className: iv.a.itemText
						}, "/".concat(s.name))))
					}))
				}
			}
			const dv = Object(c.c)({
				directory: (e, t) => Object(Lx.b)(e, {
					subredditName: t.subreddit.name
				}),
				isCreateWikiPageModalOpen: e => "CreateWikiPageModal" === Object(tt.a)(e)
			});
			class lv extends r.a.Component {
				constructor() {
					super(...arguments), this.onToggleCreateWikiModal = () => {
						this.props.toggleCreateWikiModal()
					}
				}
				render() {
					const {
						directory: e,
						isCreateWikiPageModalOpen: t,
						subreddit: s,
						toggleCreateWikiModal: n,
						pageLayer: a
					} = this.props;
					if (!a) return null;
					const {
						urlParams: o
					} = a, {
						wikiPageName: i,
						wikiSubRoute: c,
						pageName: d
					} = o;
					return r.a.createElement("div", {
						className: iv.a.wikiNavPanel
					}, r.a.createElement(de.f, {
						className: iv.a.primaryButton,
						onClick: this.onToggleCreateWikiModal
					}, Object(G.c)("Create new page")), r.a.createElement(cv, {
						activePageName: i,
						baseUrl: "".concat(s.url, "about/wiki"),
						directory: e
					}), r.a.createElement("div", {
						className: iv.a.footer
					}, r.a.createElement(Jf, {
						isActive: c === yx.l.Revisions && !i,
						label: Object(G.c)("Recent wiki revisions"),
						path: "".concat(s.url, "about/wiki/revisions")
					}), r.a.createElement(Jf, {
						isActive: d === h.Nb.WikiContributors,
						label: Object(G.c)("Add wiki contributors"),
						path: "".concat(s.url, "about/wikicontributors")
					}), r.a.createElement(Jf, {
						isActive: d === h.Nb.WikiBanned,
						label: Object(G.c)("Ban wiki contributors"),
						path: "".concat(s.url, "about/wikibanned")
					}), r.a.createElement(Jf, {
						label: Object(G.c)("Wiki settings"),
						path: "".concat(s.url, "about/edit?page=wikis")
					})), t && r.a.createElement(ov, {
						pageTree: e && e.pageTree,
						subredditUrl: s.url,
						toggleModal: n,
						withOverlay: !0
					}))
				}
			}
			var mv = Object(f.t)()(Object(i.b)(dv, e => ({
				toggleCreateWikiModal: () => e(Object(F.i)("CreateWikiPageModal"))
			}))(lv));
			const uv = Object(c.c)({
				isBadgesEnabled: Rs.d.spCustomBadges,
				isEligibleForCommunityAwards: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(C.a)(s)
				},
				isEmotesEnabled: Rs.d.spEmotesModTools,
				isUsingNewModMail: (e, t) => {
					let {
						subreddit: s
					} = t;
					return Object(R.n)(e, {
						subredditId: s.id
					})
				},
				isEligibleForScheduledPosts: Rs.d.scheduledPosts,
				isStreamingEnabled: I.b
			});
			class pv extends r.a.Component {
				constructor() {
					super(...arguments), this.trackClick = e => this.props.sendEvent(T.b(e)), this.trackCommunitySettingsNavItemClick = e => this.props.sendEvent(Vs(e)), this.onClickAwards = () => this.trackClick("awards"), this.onClickStreaming = () => this.trackClick("streaming"), this.onClickModQueue = () => this.trackClick("mod_queue"), this.onClickReports = () => this.trackClick("reports"), this.onClickSpam = () => this.trackClick("spam"), this.onClickEdited = () => this.trackClick("edited"), this.onClickUnmoderated = () => this.trackClick("unmoderated"), this.onClickBannedUsers = () => this.trackClick("ban_users"), this.onClickMutedUsers = () => this.trackClick("mute_users"), this.onClickApprovedSubmitters = () => this.trackClick("approved_submitters"), this.onClickEmojis = () => this.trackClick("emoji"), this.onClickModerators = () => this.trackClick("moderators"), this.onClickManageChatrooms = () => {
						this.props.toggleManageChatroomsModal(), this.trackClick("manage_chatrooms")
					}, this.onClickCommunitySettings = () => this.trackClick("community_settings"), this.onClickCommunityAppearance = () => this.trackClick("community_appearance"), this.onClickModMail = () => {
						const e = this.props.isUsingNewModMail ? "mod_mail" : "old_modmail";
						this.trackClick(e)
					}, this.onClickRemovalReasons = () => this.trackClick("removal_reasons"), this.onClickRules = () => this.trackClick("rules"), this.onClickPostRequirements = () => this.trackClick("post_requirements"), this.onClickAutomodConfig = () => this.trackClick("automod_config"), this.onClickWikiPages = () => this.trackClick("wiki"), this.onClickTraffic = () => this.trackClick("traffic"), this.onClickModLog = () => this.trackClick("mod_log"), this.onClickModSupport = () => this.trackClick("r_mod_support"), this.onClickModHelp = () => this.trackClick("mod_help"), this.onClickContactReddit = () => this.trackClick("contact_reddit"), this.onClickModGuidelines = () => this.trackClick("mod_guidelines"), this.onClickModHelpCenter = () => this.trackClick("mod_help_center"), this.onClickPostFlair = () => this.trackClick("post_flair"), this.onClickUserFlair = () => this.trackClick("user_flair"), this.onClickGrantUserFlair = () => this.trackClick("grant_user_flair"), this.onClickBadges = () => this.trackClick("badges"), this.onClickEmotes = () => this.trackClick("emotes"), this.onClickScheduledPosts = () => this.props.sendEvent(Object(Ag.f)()), this.onGoToModHub = () => {
						const e = this.props.moderatorPermissions && this.props.moderatorPermissions.posts,
							t = "".concat(this.props.subreddit.url, "about/"),
							s = e ? "".concat(t, "modqueue") : t;
						this.props.pushUrl(s)
					}
				}
				render() {
					const {
						props: e
					} = this;
					switch (e.pageName) {
						case h.Nb.CommunitySettings: {
							const t = !e.subpageName || !Object.values(h.Ob).includes(e.subpageName);
							return r.a.createElement("div", {
								className: zf.a.navContainer
							}, r.a.createElement(Qf, {
								onClick: this.onGoToModHub
							}), r.a.createElement(Jf, {
								label: Object(G.c)("Community"),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Ob.Community),
								path: "".concat(e.subreddit.url, "about/edit?page=community"),
								isActive: t || e.subpageName === h.Ob.Community
							}), r.a.createElement(Jf, {
								label: Object(G.c)("Safety and Privacy"),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Ob.Safety),
								path: "".concat(e.subreddit.url, "about/edit?page=safety"),
								isActive: e.subpageName === h.Ob.Safety
							}), r.a.createElement(Jf, {
								label: Object(G.c)("Posts and Comments"),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Ob.Posts),
								path: "".concat(e.subreddit.url, "about/edit?page=posts"),
								isActive: e.subpageName === h.Ob.Posts
							}), r.a.createElement(Jf, {
								label: Object(G.c)("Wikis"),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.Ob.Wikis),
								path: "".concat(e.subreddit.url, "about/edit?page=wikis"),
								isActive: e.subpageName === h.Ob.Wikis
							}))
						}
						case h.Nb.Wiki:
						case h.Nb.WikiContributors:
						case h.Nb.WikiBanned:
							return r.a.createElement("div", {
								className: Object(d.a)(zf.a.navContainer, zf.a.wikiNavContainer)
							}, r.a.createElement(Qf, {
								onClick: this.onGoToModHub
							}), e.moderatorPermissions.wiki && r.a.createElement(mv, {
								subreddit: e.subreddit
							}));
						default:
							return r.a.createElement("div", {
								className: zf.a.navContainer
							}, e.moderatorPermissions.posts && r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Hf, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Queues")), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Modqueue,
								label: g(h.Nb.Modqueue),
								onClick: this.onClickModQueue,
								path: "".concat(e.subreddit.url, "about/modqueue")
							}), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Reports,
								label: g(h.Nb.Reports),
								onClick: this.onClickReports,
								path: "".concat(e.subreddit.url, "about/reports")
							}), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Spam,
								label: g(h.Nb.Spam),
								onClick: this.onClickSpam,
								path: "".concat(e.subreddit.url, "about/spam")
							}), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Edited,
								label: g(h.Nb.Edited),
								onClick: this.onClickEdited,
								path: "".concat(e.subreddit.url, "about/edited")
							}), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Unmoderated,
								label: g(h.Nb.Unmoderated),
								onClick: this.onClickUnmoderated,
								path: "".concat(e.subreddit.url, "about/unmoderated")
							})), r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(na.a, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "User management")), e.moderatorPermissions.access && r.a.createElement(r.a.Fragment, null, r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Banned,
								label: g(h.Nb.Banned),
								onClick: this.onClickBannedUsers,
								path: "".concat(e.subreddit.url, "about/banned")
							}), e.moderatorPermissions.mail && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Muted,
								label: g(h.Nb.Muted),
								onClick: this.onClickMutedUsers,
								path: "".concat(e.subreddit.url, "about/muted")
							}), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Contributors,
								label: g(h.Nb.Contributors),
								onClick: this.onClickApprovedSubmitters,
								path: "".concat(e.subreddit.url, "about/contributors")
							})), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Moderators,
								label: g(h.Nb.Moderators),
								onClick: this.onClickModerators,
								path: "".concat(e.subreddit.url, "about/moderators")
							})), (e.moderatorPermissions.flair || e.moderatorPermissions.config) && r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Ko.a, {
								className: zf.a.iconStyles
							}), e.isBadgesEnabled ? r.a.createElement(_e.c, null, "Badges, flair & emojis") : r.a.createElement(_e.c, null, "Flair & emojis")), e.moderatorPermissions.flair && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Flair,
								label: g(h.Nb.Flair),
								onClick: this.onClickGrantUserFlair,
								path: "".concat(e.subreddit.url, "about/flair")
							}), e.moderatorPermissions.config && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Emojis,
								label: g(h.Nb.Emojis),
								onClick: this.onClickEmojis,
								path: "".concat(e.subreddit.url, "about/emojis")
							}), e.moderatorPermissions.flair && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.UserFlair,
								label: g(h.Nb.UserFlair),
								onClick: this.onClickUserFlair,
								path: "".concat(e.subreddit.url, "about/userflair")
							}), e.moderatorPermissions.flair && e.moderatorPermissions.config && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.PostFlair,
								label: g(h.Nb.PostFlair),
								onClick: this.onClickPostFlair,
								path: "".concat(e.subreddit.url, "about/postflair")
							}), e.isBadgesEnabled && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Badges,
								label: g(h.Nb.Badges),
								onClick: this.onClickBadges,
								path: "".concat(e.subreddit.url, "about/badges")
							}), e.isEmotesEnabled && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Emotes,
								label: g(h.Nb.Emotes),
								onClick: this.onClickEmotes,
								path: "".concat(e.subreddit.url, "about/emotes")
							})), (e.moderatorPermissions.config || e.moderatorPermissions.posts) && r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Oh.a, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Rules and regulations")), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.SubredditRules,
								label: g(h.Nb.SubredditRules),
								onClick: this.onClickRules,
								path: "".concat(e.subreddit.url, "about/rules")
							}), e.moderatorPermissions.posts && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Removal,
								label: g(h.Nb.Removal),
								onClick: this.onClickRemovalReasons,
								path: "".concat(e.subreddit.url, "about/removal")
							}), e.moderatorPermissions.config && r.a.createElement(r.a.Fragment, null, r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.PostRequirements,
								label: g(h.Nb.PostRequirements),
								onClick: this.onClickPostRequirements,
								path: "".concat(e.subreddit.url, "about/settings")
							}), r.a.createElement(Jf, {
								label: Object(G.c)("Automod"),
								onClick: this.onClickAutomodConfig,
								path: "".concat(e.subreddit.url, "about/wiki/config/automoderator")
							}))), e.isEligibleForScheduledPosts && r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Bf, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Content")), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.SubredditContent,
								label: Object(G.c)("Scheduled posts"),
								onClick: this.onClickScheduledPosts,
								path: "".concat(e.subreddit.url, "about/content"),
								isBeta: !0
							})), (e.moderatorPermissions.config || e.moderatorPermissions.wiki) && r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(zo.a, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Other")), e.isEligibleForCommunityAwards && r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Awards,
								label: Object(G.c)("Awards"),
								onClick: this.onClickAwards,
								path: "".concat(e.subreddit.url, "about/awards"),
								isNew: !0
							}), e.moderatorPermissions.config && e.isStreamingEnabled && r.a.createElement(Jf, {
								label: g(h.Nb.Streaming),
								onClick: this.onClickStreaming,
								path: "".concat(e.subreddit.url, "about/streaming"),
								isNew: !0
							}), e.moderatorPermissions.wiki && r.a.createElement(Jf, {
								label: Object(G.c)("Wiki pages"),
								onClick: this.onClickWikiPages,
								path: "".concat(D.a.redditUrl).concat(e.subreddit.url, "about/wiki/index")
							}), e.moderatorPermissions.config && r.a.createElement(Jf, {
								label: Object(G.c)("Community settings"),
								onClick: this.onClickCommunitySettings,
								path: "".concat(e.subreddit.url, "about/edit?page=community"),
								showInboundArrow: !0
							}), e.moderatorPermissions.config && r.a.createElement(Jf, {
								label: Object(G.c)("Community appearance"),
								path: "".concat(e.subreddit.url, "?styling=true"),
								onClick: this.onClickCommunityAppearance,
								showInboundArrow: !0
							})), e.moderatorPermissions.mail && r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Uf, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Modmail")), r.a.createElement(Jf, {
								isExternal: !0,
								label: Object(G.c)("Modmail"),
								onClick: this.onClickModMail,
								path: e.isUsingNewModMail ? "https://mod.reddit.com" : "".concat(D.a.redditUrl, "/messages/moderator/")
							})), r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Af.a, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Chat")), r.a.createElement(Jf, {
								label: Object(G.c)("Manage chatrooms"),
								onClick: this.onClickManageChatrooms
							})), r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Wf, {
								className: zf.a.iconStyles
							}), r.a.createElement(_e.c, null, "Community activity")), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Traffic,
								label: Object(G.c)("Traffic stats"),
								onClick: this.onClickTraffic,
								path: "".concat(e.subreddit.url, "about/traffic")
							}), r.a.createElement(Jf, {
								isActive: e.pageName === h.Nb.Modlog,
								label: g(h.Nb.Modlog),
								onClick: this.onClickModLog,
								path: "".concat(e.subreddit.url, "about/log")
							})), r.a.createElement("div", {
								className: zf.a.navSection
							}, r.a.createElement("div", {
								className: zf.a.sectionHeader
							}, r.a.createElement(Ff.a, {
								className: zf.a.iconStyles
							}), Object(G.c)("Mod help center")), r.a.createElement(Jf, {
								isExternal: !0,
								label: Object(G.c)("Mod help center"),
								onClick: this.onClickModHelpCenter,
								path: D.a.redditHelpUrl.modHelpCenter
							}), r.a.createElement(Jf, {
								isExternal: !0,
								label: Object(G.c)("Moderator guidelines"),
								onClick: this.onClickModGuidelines,
								path: "https://www.reddit.com/help/healthycommunities/"
							}), r.a.createElement(Jf, {
								isExternal: !0,
								label: "r/ModSupport",
								onClick: this.onClickModSupport,
								path: "/r/ModSupport/"
							}), r.a.createElement(Jf, {
								isExternal: !0,
								label: "r/ModHelp",
								onClick: this.onClickModHelp,
								path: "/r/modhelp/"
							}), r.a.createElement(Jf, {
								isExternal: !0,
								label: Object(G.c)("Contact Reddit"),
								onClick: this.onClickContactReddit,
								path: "https://www.reddithelp.com/en/submit-request/rusername"
							})))
					}
				}
			}
			var bv = Object(i.b)(uv, e => ({
					toggleManageChatroomsModal: () => e(Object(F.i)(Df.a.MANAGE_SUBREDDIT_CHAT)),
					pushUrl: t => e(Object(to.b)(t))
				}))(Object(x.b)(pv)),
				hv = s("./src/reddit/pages/ModHub/index.m.less"),
				gv = s.n(hv);
			const Ev = m.a.div("BackgroundContainer", gv.a),
				xv = m.a.wrapped(v.a, "SubredditLink", gv.a),
				fv = m.a.div("Header", gv.a),
				vv = m.a.wrapped(E.b, "SubredditIcon", gv.a),
				Cv = m.a.div("Body", gv.a),
				Ov = Object(c.c)({
					contentGateInfo: (e, t) => Object(L.f)(e, t.match.params.subredditName)
				}),
				jv = Object(c.c)({
					queryParams: (e, t) => {
						let {
							location: s
						} = t;
						return a()([...Object(l.a)(s.search)])
					}
				}),
				yv = Object(c.c)({
					moderatorPermissions: (e, t) => {
						const s = Object(R.G)(e, t.match.params.subredditName);
						if (s) return Object(P.j)(e, {
							subredditId: s
						})
					}
				}),
				kv = Object(c.c)({
					subreddit: (e, t) => Object(R.B)(e, {
						subredditName: t.match.params.subredditName
					})
				}),
				wv = Object(i.b)(() => Object(c.a)(Ov, L.G, I.b, L.S, f.M, yv, L.X, M.Y, kv, jv, (e, t) => t.match.params.pageName, (e, t, s, n, a, o, r, i, c, d, l) => {
					let {
						contentGateInfo: m
					} = e, {
						moderatorPermissions: u
					} = o, {
						subreddit: p
					} = c, {
						queryParams: b
					} = d;
					const {
						after: h,
						afterEditable: g,
						before: E,
						beforeEditable: x,
						only: f,
						page: v
					} = b;
					return {
						contentGateInfo: m,
						isEligibleForCommunityAwards: Object(C.a)(p),
						isEmployee: t,
						isStreamingEnabled: s,
						language: n,
						layout: a,
						moderatorPermissions: u,
						isScheduledPostsEnabled: i,
						subreddit: p,
						renderNSFWContentGate: p && p.isNSFW && !r,
						page: "".concat(v || _.b),
						pageName: l,
						postTypeFilter: f,
						after: h || "",
						afterEditable: g,
						before: E,
						beforeEditable: x
					}
				})),
				Sv = Object(f.t)();
			class Nv extends r.a.Component {
				constructor() {
					super(...arguments), this.sendEventWithName = e => () => {
						this.props.sendEvent(t => ({
							source: w(this.props.pageName),
							action: "click",
							noun: e
						}))
					}, this.onClickSubredditLink = () => {
						this.props.sendEvent(T.c())
					}
				}
				componentDidUpdate(e) {
					(this.props.pageName && this.props.pageName !== e.pageName || this.props.page && this.props.page !== e.page) && (document.documentElement.scrollTop = document.body.scrollTop = 0)
				}
				render() {
					const {
						props: e
					} = this;
					if (!e.subreddit) {
						const t = Object(j.a)(e.contentGateInfo, e.renderNSFWContentGate, e.match.params.subredditName);
						return t ? r.a.createElement(u.b, t) : null
					}
					const t = !!e.moderatorPermissions;
					return r.a.createElement(Ev, null, r.a.createElement(fv, null, r.a.createElement(vv, {
						subredditOrProfile: e.subreddit
					}), r.a.createElement(xv, {
						to: e.subreddit.url,
						onClick: this.onClickSubredditLink
					}, e.subreddit.displayText), e.pageName && "/ ".concat(g(e.pageName))), r.a.createElement(Cv, null, e.moderatorPermissions && r.a.createElement(bv, {
						language: e.language,
						moderatorPermissions: e.moderatorPermissions,
						pageName: e.pageName,
						subpageName: e.page,
						subreddit: e.subreddit
					}), r.a.createElement("div", {
						className: Object(d.a)(gv.a.contentWrapper, t && gv.a.isModerator)
					}, e.pageName && Object(O.a)(e.pageName, e.moderatorPermissions, e.isEligibleForCommunityAwards, e.isScheduledPostsEnabled, e.isEmployee, e.isStreamingEnabled) ? r.a.createElement(Tf, {
						after: e.after,
						afterEditable: e.afterEditable,
						before: e.before,
						beforeEditable: e.beforeEditable,
						language: e.language,
						layout: e.layout,
						moderatorPermissions: e.moderatorPermissions,
						page: e.page,
						pageName: e.pageName,
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: this.sendEventWithName,
						subpageName: e.page,
						subreddit: e.subreddit
					}) : e.moderatorPermissions ? r.a.createElement(Lf, {
						language: e.language,
						subredditDisplayText: e.subreddit.displayText
					}) : r.a.createElement(_f.a, {
						isModerator: t,
						language: e.language,
						subredditDisplayText: e.subreddit.displayText
					}))))
				}
			}
			t.default = Sv(wv(Object(x.b)(Nv)))
		},
		"./src/reddit/pages/SubredditCreation/Layout/index.m.less": function(e, t, s) {
			e.exports = {
				Sidebar: "_21QIcELhFLJ4T6uOUKqej7",
				sidebar: "_21QIcELhFLJ4T6uOUKqej7",
				isOverlay: "_3JejK3woZKuE7psWYzZMk-",
				Content: "_2wEvMk0HNO1vMRXR89R4YE",
				content: "_2wEvMk0HNO1vMRXR89R4YE",
				Container: "_3rOOumzhn2kQeSbQA1BtJI",
				container: "_3rOOumzhn2kQeSbQA1BtJI",
				OuterContainer: "_1t_20Pp0ozZf5JHADFW277",
				outerContainer: "_1t_20Pp0ozZf5JHADFW277"
			}
		},
		"./src/reddit/pages/SubredditCreation/index.m.less": function(e, t, s) {
			e.exports = {
				sublabel: "_3iEQMbJzyCJP7q0YQLg6j4",
				subtitle: "_1NkQ5U2m0s_6vOfhCgiIgT",
				radioDescription: "_2VfO_j9K0NqNwA6JyAl8Dk",
				metaFieldDescription: "fd5WCBCH7kTLTlNepW054",
				buttonContainer: "rktXqe6ilbY86M7UI5N0",
				isOverlay: "_2-RGOjReVDKqocc0lhfKCD",
				field: "lzEa7-AzGmC9abTt7-RJG",
				isCreatePending: "_3rxpxb7pMWAbGQ6_JA_my7",
				subredditCreation: "_3eSVsnKJOqAQo-ixxTeJcl",
				container: "_2oaybRT7snUp8XlyHlRiSP",
				title: "_19pYcIVThkZW5KMHTi8qsc",
				nsfw: "_hnZsl3c6qOjy4qOD9r0R",
				createButton: "rJOmFCS_DMZSRltlKtpyt",
				pendingText: "oXus6jwjzhkeznWdE45YL",
				numCommunityTopicsSelected: "_1QES7ND3zudXR2epk08OVa",
				subtextContainer: "_1V23LtWm6tqb0xlD1Xkh-W",
				radioContent: "luCqkz2vQaP-L_NeDD98b",
				radioContainer: "_3qUROz4qvkxCG-oEJTkW3x",
				fullWidthTextContainer: "_2jvToia6nJCdTHqp_Tw_fp",
				Info: "cP738yi9DxlBmCQTtFLop",
				info: "cP738yi9DxlBmCQTtFLop",
				RadioOption: "_2uqw2bfrk5pQeRVMtPVRUR",
				radioOption: "_2uqw2bfrk5pQeRVMtPVRUR",
				StyledTooltip: "_3mMji3dmYN3jsQ2Ri0owBm",
				styledTooltip: "_3mMji3dmYN3jsQ2Ri0owBm",
				RadioIcon: "_1vr9rsoGcISz-S6s7p_6s-",
				radioIcon: "_1vr9rsoGcISz-S6s7p_6s-",
				Public: "_3fiOvK-VXqZ9cZO0d912xA",
				public: "_3fiOvK-VXqZ9cZO0d912xA",
				Restricted: "_3RYKKCLydFkeZVJov0xebO",
				restricted: "_3RYKKCLydFkeZVJov0xebO",
				Private: "_19fLjAFVy42ZR2vocDvgUW",
				private: "_19fLjAFVy42ZR2vocDvgUW",
				Employee: "ExNY0v88NVrkWCfrt55XJ",
				employee: "ExNY0v88NVrkWCfrt55XJ",
				CloseButton: "_1I-ULJ_Pqw5ZwVbFuh5I6W",
				closeButton: "_1I-ULJ_Pqw5ZwVbFuh5I6W",
				ErrorText: "_2ay6MX8oi5mY0chgCSBVHO",
				errorText: "_2ay6MX8oi5mY0chgCSBVHO"
			}
		},
		"./src/reddit/pages/SubredditCreation/index.tsx": function(e, t, s) {
			"use strict";
			s.r(t);
			var n = s("./node_modules/fbt/lib/FbtPublic.js"),
				a = s("./node_modules/react/index.js"),
				o = s.n(a),
				r = s("./node_modules/react-redux/es/index.js"),
				i = s("./node_modules/react-router-redux/es/index.js"),
				c = s("./node_modules/reselect/es/index.js"),
				d = s("./src/lib/classNames/index.ts"),
				l = s("./src/lib/formatApiError/index.ts"),
				m = s("./src/reddit/actions/subredditCreation.ts"),
				u = s("./src/reddit/actions/tooltip.ts"),
				p = s("./src/app/strings/index.ts"),
				b = s("./src/reddit/actions/tags/index.ts"),
				h = s("./src/reddit/actions/toaster.ts"),
				g = s("./src/reddit/components/MultiOptionSelect/index.tsx"),
				E = s("./src/reddit/i18n/utils.ts"),
				x = s("./src/reddit/models/Tags/index.ts"),
				f = s("./src/reddit/models/Toast/index.ts"),
				v = s("./src/reddit/selectors/tags.ts"),
				C = s("./src/reddit/selectors/user.ts"),
				O = s("./src/reddit/components/CommunityTopics/index.m.less"),
				j = s.n(O);
			const y = Object(c.c)({
				availableGlobalOptions: v.f,
				selectedOptions: v.j,
				isLoading: v.x,
				currentInput: v.g,
				language: C.S
			});
			class k extends o.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							s = e.filter(e => !e.selected);
						this.onOptionsSelected(t), s.forEach(e => this.onOptionDeselected(e))
					}
				}
				onOptionsSelected(e) {
					const t = x.a - this.props.selectedOptions.length,
						s = e.filter(e => !!e.displayText.trim()),
						n = s.slice(0, t);
					n.forEach(e => {
						this.props.optionSelected(Object.assign({}, e, {
							displayText: e.displayText.trim()
						}))
					}), n.length !== s.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(Object.assign({}, e, {
						displayText: e.displayText.trim()
					}))
				}
				render() {
					return o.a.createElement("div", {
						className: j.a.communityTopicsContainer
					}, o.a.createElement(g.a, {
						addText: Object(E.c)("Add"),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						dropdownHeaderText: Object(E.c)("Suggested topics"),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > x.a,
						isLoading: this.props.isLoading,
						maxOptionLength: x.b,
						onSearchBarFocus: this.props.onSearchBarFocused,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						splitOnCommaPress: !0
					}))
				}
			}
			var w = Object(r.b)(y, e => ({
					optionSelected: t => {
						e(Object(b.c)({
							option: t
						}))
					},
					optionDeselected: t => {
						e(Object(b.b)({
							option: t
						}))
					},
					onInputChanged: t => e(Object(b.a)({
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(h.e)(Object.assign({}, Object(h.d)(Object(p.a)(Object(C.S)(t()), "communityTopics.maxTopicsHit", {
							max: x.a
						}), f.b.Error), {
							duration: h.a
						})))
					})
				}))(k),
				S = s("./src/reddit/components/InfoTextTooltip/index.tsx"),
				N = s("./src/reddit/components/Settings/shared/Widgets.tsx"),
				T = s("./src/reddit/components/TrackingHelper/index.tsx"),
				_ = s("./src/reddit/constants/history.ts"),
				I = s("./src/reddit/contexts/InsideOverlay.tsx"),
				P = s("./src/reddit/controls/Button/index.tsx"),
				M = s("./src/reddit/controls/CheckboxInput/index.tsx"),
				R = s("./src/reddit/controls/ErrorText/index.tsx"),
				L = s("./src/reddit/controls/RadioInput/index.tsx"),
				D = s("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				A = s("./src/reddit/helpers/trackers/screenview.ts"),
				F = s("./src/reddit/helpers/trackers/subredditCreation.ts"),
				B = s("./src/reddit/icons/svgs/Admin/index.tsx"),
				U = s("./src/reddit/icons/svgs/Close/index.tsx"),
				H = s("./src/reddit/icons/svgs/Eye/index.tsx"),
				W = s("./src/reddit/icons/svgs/Info/index.tsx"),
				q = s("./src/reddit/icons/svgs/Lock/index.tsx"),
				V = s("./src/reddit/icons/svgs/User/index.tsx"),
				z = s("./src/reddit/models/Subreddit/index.ts"),
				K = s("./src/reddit/models/SubredditRestrictions/index.ts"),
				Q = s("./src/config.ts"),
				G = s("./src/reddit/pages/SubredditCreation/Layout/index.m.less"),
				J = s.n(G);
			var Z = e => o.a.createElement("div", {
					className: J.a.OuterContainer
				}, o.a.createElement("div", {
					className: Object(d.a)(e.className, J.a.Container, {
						[J.a.isOverlay]: e.isOverlay
					})
				}, o.a.createElement("div", {
					className: Object(d.a)(J.a.Sidebar, {
						[J.a.isOverlay]: e.isOverlay
					}),
					style: {
						backgroundImage: "url(".concat(Q.a.assetPath, "/img/").concat(e.isOverlay ? "community-creation" : "partner-connection", ".png)")
					}
				}), o.a.createElement("div", {
					className: Object(d.a)(J.a.Content, {
						[J.a.isOverlay]: e.isOverlay
					})
				}, e.children))),
				X = s("./src/reddit/selectors/subreddit.ts"),
				Y = s("./src/reddit/pages/SubredditCreation/index.m.less"),
				$ = s.n(Y),
				ee = s("./src/lib/lessComponent.tsx");
			s.d(t, "radioOptions", (function() {
				return he
			}));
			const te = 21,
				se = 500,
				ne = "create-title-info",
				ae = ee.a.wrapped(W.a, "Info", $.a),
				oe = ee.a.wrapped(D.a, "RadioOption", $.a),
				re = ee.a.wrapped(S.c, "Tooltip", $.a),
				ie = ee.a.wrapped(V.a, "Public", $.a),
				ce = ee.a.wrapped(H.a, "Restricted", $.a),
				de = ee.a.wrapped(q.a, "Private", $.a),
				le = ee.a.wrapped(B.a, "Employee", $.a),
				me = ee.a.wrapped(U.a, "CloseButton", $.a),
				ue = ee.a.wrapped(R.b, "ErrorText", $.a),
				pe = Object(c.c)({
					error: X.i,
					isCreatePending: X.l,
					isEmployee: C.G,
					language: C.S,
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(C.db)(e),
					userIsSuspended: C.O,
					allTags: v.e,
					existingTags: v.h,
					newTags: v.i,
					selectedCommunityTopicsOptions: v.j
				}),
				be = Object(r.b)(pe, e => ({
					createCommunity: t => e(Object(m.f)(t)),
					clearErrors: () => e(Object(m.e)()),
					onCloseLocation: t => e(Object(i.b)(t)),
					onShowTooltip: () => e(Object(u.f)({
						tooltipId: ne
					})),
					onHideTooltip: () => e(Object(u.h)())
				})),
				he = (e, t, s) => [o.a.createElement(oe, {
					key: "public",
					showButton: !0,
					value: "public"
				}, o.a.createElement("div", {
					className: $.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(ie, null)), o.a.createElement("div", {
					className: $.a.radioContainer
				}, o.a.createElement("div", {
					className: $.a.sublabel
				}, n.fbt._("Public", null, {
					hk: "DK992"
				})), o.a.createElement("div", {
					className: Object(d.a)($.a.metafieldDescription, $.a.radioDescription)
				}, n.fbt._("Anyone can view, post, and comment to this community", null, {
					hk: "1PfFUA"
				}))))), o.a.createElement(oe, {
					key: "restricted",
					showButton: !0,
					value: "restricted"
				}, o.a.createElement("div", {
					className: $.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(ce, null)), o.a.createElement("div", {
					className: $.a.radioContainer
				}, o.a.createElement("div", {
					className: $.a.sublabel
				}, n.fbt._("Restricted", null, {
					hk: "1iBTDq"
				})), o.a.createElement("div", {
					className: Object(d.a)($.a.metafieldDescription, $.a.radioDescription)
				}, Object(K.g)(s))))), o.a.createElement(oe, {
					key: "private",
					showButton: !0,
					value: "private"
				}, o.a.createElement("div", {
					className: $.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(de, null)), o.a.createElement("div", {
					className: $.a.radioContainer
				}, o.a.createElement("div", {
					className: $.a.sublabel
				}, n.fbt._("Private", null, {
					hk: "3q5SYn"
				})), o.a.createElement("div", {
					className: Object(d.a)($.a.metafieldDescription, $.a.radioDescription)
				}, n.fbt._("Only approved users can view and submit to this community", null, {
					hk: "3z8OI6"
				}))))), o.a.createElement(oe, {
					key: "employees_only",
					showButton: !0,
					value: "employees_only",
					hidden: !t
				}, o.a.createElement("div", {
					className: $.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(le, null)), o.a.createElement("div", {
					className: $.a.radioContainer
				}, o.a.createElement("div", {
					className: $.a.sublabel
				}, n.fbt._("Employees only", null, {
					hk: "1arrQC"
				})), o.a.createElement("div", {
					className: Object(d.a)($.a.metafieldDescription, $.a.radioDescription)
				}, n.fbt._("Only Reddit employees can view and submit to this community", null, {
					hk: "3ty23C"
				})))))];
			class ge extends o.a.Component {
				constructor(e) {
					super(e), this.onNameChange = e => {
						this.setState({
							name: e.target.value
						})
					}, this.onDescriptionChange = e => {
						this.setState({
							description: e.target.value
						})
					}, this.update = (e, t) => this.setState({
						[t]: e
					}), this.onTypeChange = e => {
						this.setState({
							type: e
						})
					}, this.onCreateCommunityClick = () => {
						this.props.isCreatePending || (clearTimeout(this.timeout), this.props.createCommunity({
							name: this.state.name,
							publicDescription: this.state.description,
							type: this.state.type,
							over18: this.state.over18,
							restrictCommenting: this.state.restrictCommenting,
							restrictPosting: this.state.restrictPosting,
							allTags: this.props.allTags,
							newTags: this.props.newTags,
							existingTags: this.props.existingTags
						}), this.timeout = window.setTimeout(() => {
							this.props.isCreatePending && this.setState({
								waitingForSuccessfulCommunity: !0
							})
						}, 2e3))
					}, this.errorHelper = e => {
						if (!e) return {};
						const t = e.fields && e.fields.length && e.fields[0] && e.fields[0].field,
							s = e.type;
						if ("name" === t) {
							if ("NO_TEXT" === s) return {
								name: n.fbt._("A Community Name is required", null, {
									hk: "2ocQBg"
								})
							};
							if ("BAD_SR_NAME" === s) return {
								name: n.fbt._("Make sure your Community Name follows all of the formatting rules", null, {
									hk: "2pGksk"
								})
							};
							if ("SUBREDDIT_EXISTS" === s) return {
								name: n.fbt._("This Community Name is already taken", null, {
									hk: "1aiGKw"
								})
							};
							if ("SUBREDDIT_UNAVAILABLE" === s) return {
								name: n.fbt._("This Community Name is unavailable", null, {
									hk: "2Dl0j6"
								})
							}
						} else {
							if ("public_description" === t) return {
								publicDescription: n.fbt._("A Community Description is required", null, {
									hk: "tO1GW"
								})
							};
							if ("topics" === t && "TOPICS_MISSING" === s) return {
								topics: n.fbt._("Community Topics are required", null, {
									hk: "h3kx"
								})
							}
						}
						return {
							generic: Object(l.a)(this.props.language, e)
						}
					}, this.state = {
						name: "",
						description: "",
						type: z.c.Public,
						over18: !1,
						waitingForSuccessfulCommunity: !1,
						restrictCommenting: !1,
						restrictPosting: !0
					}
				}
				componentDidMount() {
					const {
						sendEvent: e
					} = this.props;
					e(Object(A.p)()), this.props.clearErrors()
				}
				componentWillUnmount() {
					clearTimeout(this.timeout)
				}
				render() {
					const {
						error: e,
						isCreatePending: t,
						isEmployee: s,
						isOverlay: a,
						language: r,
						onCloseLocation: i,
						onHideTooltip: c,
						onShowTooltip: l,
						sendEvent: m,
						userDoesNotHaveEnoughExpToCreateCommunity: u,
						userIsSuspended: p
					} = this.props, b = this.errorHelper(e), {
						over18: h,
						waitingForSuccessfulCommunity: g
					} = this.state, {
						location: E
					} = this.props;
					return o.a.createElement(Z, {
						className: Object(d.a)($.a.subredditCreation, {
							[$.a.isOverlay]: a
						}),
						isOverlay: a
					}, o.a.createElement("div", {
						className: $.a.container
					}, o.a.createElement("h1", {
						className: $.a.title
					}, n.fbt._("Create a community", null, {
						hk: "SlFa7"
					}), a && o.a.createElement(me, {
						onClick: () => {
							m(Object(F.a)()), i(E.state[_.a.CloseLocation])
						}
					})), u ? o.a.createElement("h2", {
						className: $.a.sublabel
					}, n.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "44qhJp"
					})) : p ? o.a.createElement("h2", {
						className: $.a.sublabel
					}, n.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "3trJMZ"
					})) : o.a.createElement(o.a.Fragment, null, o.a.createElement(N.e, {
						hideCountdown: !0,
						isCreateCommunity: !0,
						isRequired: !0,
						label: n.fbt._("Name", null, {
							hk: "3OIzgl"
						}),
						textContainerClassName: $.a.fullWidthTextContainer,
						onChange: this.onNameChange,
						maxChars: te,
						value: this.state.name,
						subtext: o.a.createElement("span", {
							className: $.a.subtextContainer
						}, n.fbt._("Community names including capitalization cannot be changed.", null, {
							hk: "VjrZg"
						}), o.a.createElement("span", {
							id: ne,
							onMouseEnter: l,
							onMouseLeave: c,
							className: $.a.info
						}, o.a.createElement(ae, null), o.a.createElement(re, {
							caretOnTop: !0,
							tooltipId: ne,
							text: n.fbt._('Names cannot have spaces (e.g., "r/bookclub" not "r/book club"), must be between 3-21 characters, and underscores ("_") are the only special characters allowed. Avoid using solely trademarked names (e.g., "r/FansOfAcme" not "r/Acme").', null, {
								hk: "3RsycS"
							})
						})))
					}), b.name && o.a.createElement(ue, {
						language: r
					}, b.name), o.a.createElement(N.j, {
						isRequired: !0,
						label: n.fbt._("Topics", null, {
							hk: "2iixv1"
						}),
						textContainerClassName: $.a.fullWidthTextContainer,
						subtext: o.a.createElement("span", {
							className: $.a.subtextContainer
						}, n.fbt._("This will help relevant users find your community.", null, {
							hk: "3LM2Jb"
						}), o.a.createElement("span", null, "".concat(this.props.selectedCommunityTopicsOptions.length, "/").concat(x.a))),
						direction: "column"
					}, o.a.createElement(w, null)), b.topics && o.a.createElement(ue, {
						language: r
					}, b.topics), o.a.createElement(N.g, {
						hideCountdown: !0,
						isCreateCommunity: !0,
						isRequired: !0,
						label: n.fbt._("Description", null, {
							hk: "4gli9v"
						}),
						onChange: this.onDescriptionChange,
						maxChars: se,
						rows: 2,
						subtext: n.fbt._("This is how new members come to understand your community.", null, {
							hk: "35Gh2u"
						}),
						textContainerClassName: $.a.fullWidthTextContainer,
						value: this.state.description
					}), b.publicDescription && o.a.createElement(ue, {
						language: r
					}, b.publicDescription), o.a.createElement(N.j, {
						label: n.fbt._("Community type", null, {
							hk: "152EhZ"
						}),
						direction: "column",
						isCreateCommunity: !0,
						textContainerClassName: $.a.fullWidthTextContainer
					}, o.a.createElement(L.a, {
						value: this.state.type,
						name: "type",
						onChange: this.onTypeChange
					}, he(r, s, "post"))), o.a.createElement("div", {
						className: Object(d.a)($.a.field, {
							[$.a.isCreatePending]: t
						})
					}, o.a.createElement("div", {
						className: $.a.subtitle
					}, n.fbt._("Adult content", null, {
						hk: "20arB"
					})), o.a.createElement(M.a, {
						name: "over18",
						value: h,
						onChange: () => this.update(!this.state.over18, "over18"),
						disabled: t
					}, o.a.createElement("div", {
						className: $.a.nsfw
					}, "NSFW"), o.a.createElement("div", {
						className: $.a.sublabel
					}, n.fbt._("18+ year old community", null, {
						hk: "1XxZMV"
					})))), b.generic && o.a.createElement(ue, {
						language: r
					}, b.generic), g && o.a.createElement("div", {
						className: $.a.pendingText
					}, n.fbt._("Your community is being created...", null, {
						hk: "3dSTrq"
					})), o.a.createElement("div", {
						className: Object(d.a)($.a.buttonContainer, {
							[$.a.isOverlay]: a
						})
					}, a && o.a.createElement(P.i, {
						disabled: t,
						className: $.a.createButton,
						onClick: () => {
							i(E.state[_.a.CloseLocation]), m(Object(F.a)())
						}
					}, n.fbt._("Cancel", null, {
						hk: "1L11X7"
					})), o.a.createElement(P.f, {
						disabled: t,
						className: $.a.createButton,
						onClick: this.onCreateCommunityClick
					}, n.fbt._("Create Community", null, {
						hk: "QE8Y3"
					}))))))
				}
			}
			t.default = Object(T.b)(be(Object(I.b)(ge)))
		},
		"./src/reddit/selectors/experiments/adSidebar.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				const t = Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: n.a
				});
				return !!t && !Object(n.Xb)(t)
			}
		},
		"./src/reddit/selectors/experiments/goldProfileGildedAwards.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return r
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/selectors/user.ts");
			const r = e => !!(e => {
				const t = Object(a.c)(e, {
					experimentEligibilitySelector: e => Object(o.J)(e),
					experimentName: n.N
				});
				return Object(n.Xb)(t) ? void 0 : t
			})(e)
		},
		"./src/reddit/selectors/experiments/pollsGA.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return d
			})), s.d(t, "b", (function() {
				return l
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts"),
				o = s("./src/reddit/selectors/platform.ts"),
				r = s("./src/reddit/selectors/user.ts");
			const i = new Set(["pollstest", "whatssnoo"]),
				c = new Set(["ps4", "casualconversation", "stardewvalley", "knitting", "dccomics", "premierleague", "zerocarb", "survivor", "supergirltv", "superman", "teenmfa", "whatssnoo", "poll_testing", "nfl"]),
				d = e => i.has(e.toLowerCase()) || c.has(e.toLowerCase()),
				l = e => i.has((Object(o.e)(e) || "").toLowerCase()) || c.has((Object(o.e)(e) || "").toLowerCase()) && Object(a.c)(e, {
					experimentEligibilitySelector: r.J,
					experimentName: n.hb
				}) === n.ob.Enabled
		},
		"./src/reddit/selectors/experiments/publicAwarding.ts": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return o
			}));
			var n = s("./src/reddit/constants/experiments.ts"),
				a = s("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				const t = Object(a.c)(e, {
					experimentEligibilitySelector: a.a,
					experimentName: n.nb
				});
				return Object(n.Xb)(t) ? void 0 : t
			}
		},
		"./src/reddit/selectors/gov.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return m
			})), s.d(t, "c", (function() {
				return u
			})), s.d(t, "d", (function() {
				return p
			})), s.d(t, "e", (function() {
				return b
			})), s.d(t, "g", (function() {
				return h
			})), s.d(t, "h", (function() {
				return g
			})), s.d(t, "i", (function() {
				return E
			})), s.d(t, "j", (function() {
				return x
			})), s.d(t, "o", (function() {
				return f
			})), s.d(t, "p", (function() {
				return v
			})), s.d(t, "n", (function() {
				return C
			})), s.d(t, "k", (function() {
				return O
			})), s.d(t, "l", (function() {
				return j
			})), s.d(t, "s", (function() {
				return y
			})), s.d(t, "a", (function() {
				return k
			})), s.d(t, "f", (function() {
				return w
			})), s.d(t, "q", (function() {
				return S
			})), s.d(t, "m", (function() {
				return N
			})), s.d(t, "r", (function() {
				return T
			}));
			var n = s("./src/reddit/contexts/PageLayer/index.tsx"),
				a = s("./src/reddit/endpoints/governance/crypto.ts"),
				o = s("./src/reddit/featureFlags/index.ts"),
				r = s("./src/reddit/selectors/experiments/pollsGA.ts"),
				i = s("./src/reddit/selectors/postCreations.ts");
			const c = [],
				d = {},
				l = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				},
				m = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = y(e, {
						subredditId: s
					});
					return n && n.extra && n.extra.contracts && n.extra.contracts.harberger ? n.extra.contracts.harberger : {
						address: void 0,
						decimals: void 0,
						image: void 0,
						taxRate: .01,
						token: void 0
					}
				},
				u = (e, t) => {
					const s = O(e, t);
					if (s) return s.mainHeader
				},
				p = (e, t) => {
					const s = O(e, t);
					return s && s.mainHeader ? s.mainHeader.price : "0"
				},
				b = (e, t) => {
					const s = O(e, t);
					return s && s.mainHeader ? {
						owner: s.mainHeader.owner,
						ownerId: s.mainHeader.ownerId
					} : d
				},
				h = (e, t) => t && t.subredditId ? (e.user.wallets[t.subredditId] || {}).latest : void 0,
				g = (e, t) => {
					if (Object(r.b)(e)) {
						const t = Object(i.g)(e);
						return !!t.allowedPostTypes && t.allowedPostTypes.polls
					}
					const s = o.d.spPolls(e) || o.d.spKarmaPoints(e),
						n = t && t.subredditId ? e.subreddits.gov.meta[t.subredditId] : void 0;
					if (n) {
						const e = !!n.polls && !1 === n.polls.canCreate;
						return s && !e
					}
					return s
				},
				E = (e, t) => {
					return (e.users.publicWallets[t.userId] || {})[t.subredditId]
				},
				x = (e, t) => {
					const s = Object(n.m)(e, t);
					return s && e.subreddits.gov.releaseNotes[s] || c
				},
				f = (e, t) => t && t.subredditId && (e.subreddits.gov.meta[t.subredditId] || {}).name || "Subreddit Points",
				v = (e, t) => t && t.subredditId && (e.subreddits.gov.meta[t.subredditId] || {}).images || l,
				C = (e, t) => {
					const s = S(e, t);
					return s && s.decimals ? "1" + "0".repeat(s.decimals) : "1"
				},
				O = (e, t) => t.subredditId ? e.subreddits.gov.assets[t.subredditId] : void 0,
				j = (e, t) => t && t.subredditId ? e.subreddits.gov.meta[t.subredditId] : void 0,
				y = (e, t) => {
					const s = j(e, t);
					return s && s.walletProvider
				},
				k = (e, t) => {
					const s = y(e, t),
						n = j(e, t);
					return s && s.provider || n && n.provider
				},
				w = (e, t) => {
					const s = k(e, t);
					return s === a.a.Ethereum || s === a.a.Rinkeby
				},
				S = (e, t) => {
					const s = y(e, t),
						n = k(e, t);
					if (s && !s.inTransition && n === a.a.Stellar) return {
						address: s.extra && s.extra.issuerAddress || "",
						decimals: s.extra && s.extra.decimals || 7,
						symbol: s.extra && s.extra.token || "PHOTON"
					};
					const o = s && s.extra && s.extra.contracts,
						r = o && o.unlocked;
					return r && {
						address: r.address,
						symbol: r.token || "",
						decimals: r.decimals || 18,
						image: r.image
					}
				},
				N = (e, t) => {
					let {
						subredditId: s
					} = t;
					const n = y(e, {
						subredditId: s
					});
					return n && n.extra && n.extra.contracts && n.extra.contracts.subscriptions ? n.extra.contracts.subscriptions : {
						address: void 0
					}
				},
				T = (e, t) => {
					const s = j(e, t);
					return !!s && !!s.walletProvider && !s.walletProvider.inTransition
				}
		},
		"./src/reddit/selectors/modQueue.ts": function(e, t, s) {
			"use strict";
			s.d(t, "c", (function() {
				return r
			})), s.d(t, "b", (function() {
				return i
			})), s.d(t, "d", (function() {
				return c
			})), s.d(t, "f", (function() {
				return d
			})), s.d(t, "a", (function() {
				return l
			})), s.d(t, "e", (function() {
				return m
			}));
			s("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = s("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				a = s("./src/lib/objectSelector/index.ts");
			const o = (e, t) => Object(n.a)({
					onlyOfType: t.queryParams.only,
					profile: t.profileName,
					subreddit: t.subredditName
				}),
				r = Object(a.a)((e, t) => {
					const {
						pageName: s,
						page: n
					} = t, a = o(0, t);
					if (!e.modQueue[s] || !e.modQueue[s].itemOrder[a] || !e.modQueue[s].itemOrder[a][n]) return;
					const r = e.modQueue[s].itemOrder[a][n];
					return r ? r.map(t => e.posts.models[t] || e.comments.models[t]) : []
				}),
				i = (e, t) => {
					const {
						pageName: s
					} = t;
					return !e.modQueue[s] || !e.modQueue[s].api || e.modQueue[s].api.pending
				},
				c = (e, t) => {
					const s = o(0, t);
					return e.modQueue[t.pageName].loadMore[s]
				},
				d = e => Object.keys(e.modQueue.bulkAction.selectedItems),
				l = e => e.modQueue.bulkAction.api.pending,
				m = e => e.modQueue.moderatedCommunitiesOrder.data
		},
		"./src/reddit/selectors/subredditWiki.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return r
			})), s.d(t, "a", (function() {
				return i
			})), s.d(t, "c", (function() {
				return c
			})), s.d(t, "p", (function() {
				return d
			})), s.d(t, "q", (function() {
				return l
			})), s.d(t, "o", (function() {
				return m
			})), s.d(t, "n", (function() {
				return u
			})), s.d(t, "i", (function() {
				return p
			})), s.d(t, "d", (function() {
				return b
			})), s.d(t, "j", (function() {
				return h
			})), s.d(t, "m", (function() {
				return g
			})), s.d(t, "k", (function() {
				return E
			})), s.d(t, "l", (function() {
				return x
			})), s.d(t, "e", (function() {
				return f
			})), s.d(t, "h", (function() {
				return v
			})), s.d(t, "f", (function() {
				return C
			})), s.d(t, "g", (function() {
				return O
			}));
			s("./node_modules/core-js/modules/es6.regexp.search.js");
			var n = s("./src/lib/objectSelector/index.ts"),
				a = s("./src/reddit/helpers/wiki/makeWikiPageKey.ts");
			const o = [],
				r = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.subreddits.subredditWiki.directory[s.toLowerCase()]
				},
				i = (e, t) => {
					const {
						subredditName: s
					} = t;
					return !!e.subreddits.api.wiki.pending[s.toLowerCase()]
				},
				c = (e, t) => {
					const s = Object(a.a)(t);
					return e.subreddits.subredditWiki.pages[s]
				},
				d = (e, t) => {
					let {
						listingKey: s
					} = t;
					return e.subreddits.subredditWiki.revisions.listings[s]
				},
				l = (e, t) => {
					let {
						listingKey: s
					} = t;
					return !!e.subreddits.subredditWiki.revisions.api.pending[s]
				},
				m = (e, t) => {
					let {
						listingKey: s
					} = t;
					return !!e.subreddits.subredditWiki.revisions.api.error[s]
				},
				u = (e, t) => {
					return (e => e.subreddits.subredditWiki.revisions.models)(e)[t.revisionId]
				},
				p = (e, t) => {
					let {
						key: s
					} = t;
					return e.subreddits.subredditWiki.diff[s]
				},
				b = (e, t) => {
					const s = Object(a.a)(t);
					return e.subreddits.subredditWiki.pageSettings[s]
				},
				h = (e, t) => {
					const {
						subredditName: s
					} = t;
					return !!e.subreddits.subredditWiki.wikiContributors.listing.api.pending[s.toLowerCase()]
				},
				g = Object(n.a)((e, t) => {
					let {
						subredditName: s
					} = t;
					const n = s.toLowerCase(),
						a = e.subreddits.subredditWiki.wikiContributors.listing,
						r = a.userOrder[n],
						i = a.models[n];
					return r ? r.map(e => i[e]) : o
				}),
				E = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.subreddits.subredditWiki.wikiContributors.listing.afterToken[s.toLowerCase()]
				},
				x = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.subreddits.subredditWiki.wikiContributors.search[s.toLowerCase()]
				},
				f = (e, t) => {
					const {
						subredditName: s
					} = t;
					return !!e.subreddits.subredditWiki.wikiBannedContributors.listing.api.pending[s.toLowerCase()]
				},
				v = Object(n.a)((e, t) => {
					let {
						subredditName: s
					} = t;
					const n = s.toLowerCase(),
						a = e.subreddits.subredditWiki.wikiBannedContributors.listing,
						r = a.userOrder[n],
						i = a.models[n];
					return r ? r.map(e => i[e]) : o
				}),
				C = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.subreddits.subredditWiki.wikiBannedContributors.listing.afterToken[s.toLowerCase()]
				},
				O = (e, t) => {
					const {
						subredditName: s
					} = t;
					return e.subreddits.subredditWiki.wikiBannedContributors.search[s.toLowerCase()]
				}
		}
	}
]);
//# sourceMappingURL=ModerationPages.dc5a96a37a300697b8ff.js.map