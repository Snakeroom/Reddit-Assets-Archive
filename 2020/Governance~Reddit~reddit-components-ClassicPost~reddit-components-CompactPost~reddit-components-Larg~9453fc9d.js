// https://www.redditstatic.com/desktop2x/Governance~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-Larg~9453fc9d.f4cf39a5ea1ed5a86b52.js
// Retrieved at 10/19/2020, 2:30:07 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["Governance~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-Larg~9453fc9d"], {
		"./src/graphql/operations/AwardSheetInfo.json": function(t) {
			t.exports = JSON.parse('{"id":"4fb406bbd0cf"}')
		},
		"./src/graphql/operations/AwardSheetInfoForProfile.json": function(t) {
			t.exports = JSON.parse('{"id":"c4be07fb0202"}')
		},
		"./src/graphql/operations/CommentToxicity.json": function(t) {
			t.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/graphql/operations/CreateCommunityAward.json": function(t) {
			t.exports = JSON.parse('{"id":"38852e4f82b0"}')
		},
		"./src/graphql/operations/CreateGlobalAward.json": function(t) {
			t.exports = JSON.parse('{"id":"c11324579f8c"}')
		},
		"./src/graphql/operations/CreateModAward.json": function(t) {
			t.exports = JSON.parse('{"id":"a04c85b4e964"}')
		},
		"./src/graphql/operations/CreateSubredditTags.json": function(t) {
			t.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/graphql/operations/DisableAwardInCommunity.json": function(t) {
			t.exports = JSON.parse('{"id":"689f37138ede"}')
		},
		"./src/graphql/operations/EnableAwardInCommunity.json": function(t) {
			t.exports = JSON.parse('{"id":"3c2210d8ba4b"}')
		},
		"./src/graphql/operations/FetchGlobalTags.json": function(t) {
			t.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/graphql/operations/FetchSubredditTags.json": function(t) {
			t.exports = JSON.parse('{"id":"bac623887684"}')
		},
		"./src/graphql/operations/FetchSubredditsNotificationSettings.json": function(t) {
			t.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/graphql/operations/GetSubredditQuestions.json": function(t) {
			t.exports = JSON.parse('{"id":"461753a8d2ae"}')
		},
		"./src/graphql/operations/GlobalAwards.json": function(t) {
			t.exports = JSON.parse('{"id":"06dccfbe114b"}')
		},
		"./src/graphql/operations/ManageableAwards.json": function(t) {
			t.exports = JSON.parse('{"id":"e8574be731d1"}')
		},
		"./src/graphql/operations/ManageableAwardsForProfile.json": function(t) {
			t.exports = JSON.parse('{"id":"ff403e6dac2b"}')
		},
		"./src/graphql/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(t) {
			t.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/graphql/operations/OtherDiscussions.json": function(t) {
			t.exports = JSON.parse('{"id":"14297124d6e4"}')
		},
		"./src/graphql/operations/PostFeedAndOtherDiscussions.json": function(t) {
			t.exports = JSON.parse('{"id":"4460a50c7363"}')
		},
		"./src/graphql/operations/ProductOffers.json": function(t) {
			t.exports = JSON.parse('{"id":"ddb1f9f5717c"}')
		},
		"./src/graphql/operations/ProfileModHubPage.json": function(t) {
			t.exports = JSON.parse('{"id":"113272b7cbb2"}')
		},
		"./src/graphql/operations/ReallocatePowerups.json": function(t) {
			t.exports = JSON.parse('{"id":"d02bf38ca840"}')
		},
		"./src/graphql/operations/RedditorKarma.json": function(t) {
			t.exports = JSON.parse('{"id":"db6eb1356b13"}')
		},
		"./src/graphql/operations/RedditorPowerups.json": function(t) {
			t.exports = JSON.parse('{"id":"e2bcd0fbaace"}')
		},
		"./src/graphql/operations/RemoveCommunityAward.json": function(t) {
			t.exports = JSON.parse('{"id":"973872832463"}')
		},
		"./src/graphql/operations/SubredditAbout.json": function(t) {
			t.exports = JSON.parse('{"id":"b85af9fd9703"}')
		},
		"./src/graphql/operations/SubredditLinks.json": function(t) {
			t.exports = JSON.parse('{"id":"e74dba05ccd0"}')
		},
		"./src/graphql/operations/SubredditPage.json": function(t) {
			t.exports = JSON.parse('{"id":"3de09ab3740b"}')
		},
		"./src/graphql/operations/SubredditPosts.json": function(t) {
			t.exports = JSON.parse('{"id":"0ea72f3caca5"}')
		},
		"./src/graphql/operations/SubredditPowerups.json": function(t) {
			t.exports = JSON.parse('{"id":"673c430fbc2a"}')
		},
		"./src/graphql/operations/SubredditPowerupsFull.json": function(t) {
			t.exports = JSON.parse('{"id":"4c0acc378909"}')
		},
		"./src/graphql/operations/SubredditRules.json": function(t) {
			t.exports = JSON.parse('{"id":"0df127946e72"}')
		},
		"./src/graphql/operations/SubredditsPosts.json": function(t) {
			t.exports = JSON.parse('{"id":"1e7a770e0bc7"}')
		},
		"./src/graphql/operations/SubscribedSubreddits.json": function(t) {
			t.exports = JSON.parse('{"id":"46c94140fba5"}')
		},
		"./src/graphql/operations/TopAwardedPosts.json": function(t) {
			t.exports = JSON.parse('{"id":"7540d45cf51a"}')
		},
		"./src/graphql/operations/TopAwardersLeaderboard.json": function(t) {
			t.exports = JSON.parse('{"id":"2a194e7926dd"}')
		},
		"./src/graphql/operations/UpdateSubredditNotificationSettings.json": function(t) {
			t.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		},
		"./src/graphql/operations/UpdateSubredditPrimaryTag.json": function(t) {
			t.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/graphql/operations/UpdateSubredditTagStatesRelevance.json": function(t) {
			t.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/graphql/operations/UsableAwards.json": function(t) {
			t.exports = JSON.parse('{"id":"a67569476052"}')
		},
		"./src/graphql/operations/UsableAwardsForProfile.json": function(t) {
			t.exports = JSON.parse('{"id":"d45610c1d3a6"}')
		},
		"./src/graphql/operations/UserPowerups.json": function(t) {
			t.exports = JSON.parse('{"id":"556b2d511693"}')
		},
		"./src/lib/constants/specialMembership.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			const n = "custom"
		},
		"./src/lib/makeDraftKey/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return s
			}));
			var n = r("./src/reddit/models/PostDraft/index.ts");

			function s(t, e) {
				return "".concat(n.c[t], "_").concat(e)
			}
		},
		"./src/lib/makeLinkedPostsListingKey/index.ts": function(t, e, r) {
			"use strict";
			e.a = t => {
				return "linkedPosts--[post:'".concat(t, "']")
			}
		},
		"./src/lib/makeProductOfferKey/index.ts": function(t, e, r) {
			"use strict";

			function n(t, e) {
				return "".concat(t, "_").concat(e)
			}
			r.d(e, "a", (function() {
				return n
			}))
		},
		"./src/lib/stringInterpolate/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			r("./node_modules/core-js/modules/es6.regexp.replace.js");

			function n(t, e) {
				return t && e ? t.replace(/%\{(\w+)\}/g, (t, r) => {
					const n = e[r];
					return null == n ? r : String(n)
				}) : t
			}
		},
		"./src/reddit/actions/category/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "a", (function() {
				return i
			})), r.d(e, "g", (function() {
				return o
			})), r.d(e, "f", (function() {
				return d
			})), r.d(e, "e", (function() {
				return c
			})), r.d(e, "d", (function() {
				return a
			}));
			const n = "CATEGORY__LIST_PENDING",
				s = "CATEGORY__LIST_LOADED",
				i = "CATEGORY__LIST_FAILED",
				o = "CATEGORY__SUBREDDITS_PENDING",
				d = "CATEGORY__SUBREDDITS_LOADED",
				c = "CATEGORY__SUBREDDITS_FAILED",
				a = "CATEGORY__RANK_SET"
		},
		"./src/reddit/actions/category/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return g
			})), r.d(e, "b", (function() {
				return S
			})), r.d(e, "c", (function() {
				return h
			}));
			var n = r("./src/lib/initializeClient/installReducer.ts"),
				s = r("./src/reddit/reducers/features/categories/index.ts"),
				i = (r("./node_modules/lodash/isEmpty.js"), r("./node_modules/react-router-redux/es/index.js"), r("./src/lib/makeActionCreator/index.ts")),
				o = r("./src/reddit/constants/categories.tsx"),
				d = r("./src/lib/constants/index.ts"),
				c = r("./src/lib/makeApiRequest/index.ts"),
				a = r("./src/lib/omitHeaders/index.ts"),
				u = r("./src/reddit/constants/headers.ts");
			var l = r("./src/reddit/endpoints/category/subreddits.ts"),
				b = r("./src/reddit/helpers/localStorage/index.ts"),
				p = r("./src/reddit/selectors/category.ts"),
				O = r("./src/reddit/actions/category/constants.ts");
			Object(n.a)({
				features: {
					categories: s.a
				}
			});
			const m = Object(i.a)(O.c),
				f = Object(i.a)(O.b),
				_ = Object(i.a)(O.a),
				g = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const s = e(),
						i = Object(p.i)(s),
						l = Object(p.h)(s);
					if (i || l) return;
					t(m());
					const b = await (t => Object(c.a)(Object(a.a)(t, [u.a]), {
						endpoint: "".concat(t.apiUrl, "/api/available_subreddit_categories.json?use_extended_categories=true"),
						method: d.db.GET
					}))(n());
					if (b.ok) {
						const {
							categories: e,
							categoryIds: r
						} = (t => {
							const e = {},
								r = [];
							return t.forEach((t, n) => {
								const s = {
									attr: t.category_attr,
									color: t.category_color || o.a[n % o.a.length],
									icon: t.category_icon,
									id: t.category_id,
									name: t.category_name
								};
								r.push(s.id), e[s.id] = s
							}), {
								categories: e,
								categoryIds: r
							}
						})(b.body);
						t(f({
							categories: e,
							categoryIds: r
						}))
					} else t(_(b.error))
				}, j = Object(i.a)(O.g), E = Object(i.a)(O.f), y = Object(i.a)(O.e), S = (t, e) => async (r, n, s) => {
					let {
						apiContext: i
					} = s;
					const o = n(),
						d = Object(p.n)(o, {
							id: t
						}),
						c = Object(p.m)(o, {
							id: t
						});
					if (d || c) return;
					r(j({
						categoryId: t
					}));
					const a = await Object(l.a)(i(), t, e);
					if (a.ok) {
						const e = Object(l.b)(a.body);
						r(E(Object.assign({
							categoryId: t
						}, e)))
					} else r(y({
						categoryId: t,
						error: a.error
					}))
				}, T = Object(i.a)(O.d), h = t => async (e, r) => {
					const n = Object(p.k)(r(), {
						id: t
					});
					e(T({
						categoryId: t,
						rank: n + 1
					})), Object(b.P)(Object(p.e)(r()))
				}
		},
		"./src/reddit/actions/comment/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "C", (function() {
				return lt
			})), r.d(e, "ib", (function() {
				return pt
			})), r.d(e, "n", (function() {
				return Ot
			})), r.d(e, "R", (function() {
				return mt
			})), r.d(e, "gb", (function() {
				return ft
			})), r.d(e, "L", (function() {
				return jt
			})), r.d(e, "Q", (function() {
				return Et
			})), r.d(e, "X", (function() {
				return yt
			})), r.d(e, "v", (function() {
				return St
			})), r.d(e, "u", (function() {
				return Tt
			})), r.d(e, "t", (function() {
				return ht
			})), r.d(e, "Z", (function() {
				return xt
			})), r.d(e, "rb", (function() {
				return Dt
			})), r.d(e, "T", (function() {
				return wt
			})), r.d(e, "i", (function() {
				return Rt
			})), r.d(e, "h", (function() {
				return Pt
			})), r.d(e, "d", (function() {
				return Nt
			})), r.d(e, "e", (function() {
				return kt
			})), r.d(e, "c", (function() {
				return vt
			})), r.d(e, "b", (function() {
				return Ut
			})), r.d(e, "j", (function() {
				return Lt
			})), r.d(e, "m", (function() {
				return Mt
			})), r.d(e, "N", (function() {
				return Gt
			})), r.d(e, "M", (function() {
				return Ft
			})), r.d(e, "W", (function() {
				return Yt
			})), r.d(e, "nb", (function() {
				return Vt
			})), r.d(e, "K", (function() {
				return Jt
			})), r.d(e, "H", (function() {
				return zt
			})), r.d(e, "cb", (function() {
				return Qt
			})), r.d(e, "pb", (function() {
				return Xt
			})), r.d(e, "S", (function() {
				return Zt
			})), r.d(e, "E", (function() {
				return $t
			})), r.d(e, "G", (function() {
				return te
			})), r.d(e, "F", (function() {
				return ee
			})), r.d(e, "D", (function() {
				return re
			})), r.d(e, "mb", (function() {
				return se
			})), r.d(e, "kb", (function() {
				return ie
			})), r.d(e, "qb", (function() {
				return ce
			})), r.d(e, "tb", (function() {
				return ae
			})), r.d(e, "lb", (function() {
				return le
			})), r.d(e, "sb", (function() {
				return be
			})), r.d(e, "jb", (function() {
				return pe
			})), r.d(e, "Y", (function() {
				return Oe
			})), r.d(e, "p", (function() {
				return me
			})), r.d(e, "o", (function() {
				return fe
			})), r.d(e, "k", (function() {
				return _e
			})), r.d(e, "f", (function() {
				return ge
			})), r.d(e, "l", (function() {
				return je
			})), r.d(e, "O", (function() {
				return ye
			})), r.d(e, "s", (function() {
				return he
			})), r.d(e, "P", (function() {
				return Ie
			})), r.d(e, "ob", (function() {
				return Ce
			})), r.d(e, "ab", (function() {
				return Ae
			})), r.d(e, "bb", (function() {
				return xe
			})), r.d(e, "fb", (function() {
				return De
			})), r.d(e, "q", (function() {
				return we
			})), r.d(e, "I", (function() {
				return Pe
			})), r.d(e, "r", (function() {
				return Ne
			})), r.d(e, "A", (function() {
				return ke
			})), r.d(e, "z", (function() {
				return ve
			})), r.d(e, "B", (function() {
				return Ue
			})), r.d(e, "g", (function() {
				return Le
			})), r.d(e, "V", (function() {
				return Ge
			})), r.d(e, "U", (function() {
				return Ke
			})), r.d(e, "eb", (function() {
				return He
			})), r.d(e, "x", (function() {
				return Ye
			})), r.d(e, "w", (function() {
				return Ve
			})), r.d(e, "y", (function() {
				return We
			})), r.d(e, "db", (function() {
				return Xe
			})), r.d(e, "hb", (function() {
				return Ze
			})), r.d(e, "a", (function() {
				return $e
			})), r.d(e, "J", (function() {
				return tr
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js"), r("./node_modules/core-js/modules/es6.regexp.match.js");
			var n = r("./src/config.ts"),
				s = r("./node_modules/fbt/lib/FbtPublic.js"),
				i = r("./src/telemetry/index.ts"),
				o = r("./src/lib/constants/index.ts"),
				d = r("./src/lib/makeActionCreator/index.ts"),
				c = r("./src/lib/makeCommentsPageKey/index.ts"),
				a = r("./src/lib/makeDraftKey/index.ts"),
				u = r("./src/reddit/actions/changeUsername.ts"),
				l = r("./src/reddit/actions/economics/helpers/async.ts"),
				b = r("./src/reddit/actions/login.ts"),
				p = r("./src/reddit/actions/modal.ts"),
				O = r("./src/reddit/actions/post.ts"),
				m = r("./src/reddit/actions/postCreation/editorContent.ts"),
				f = r("./src/reddit/actions/publicAccessNetwork/automute.ts"),
				_ = r("./src/reddit/actions/shortcuts/utils.ts"),
				g = r("./src/reddit/actions/toaster.ts"),
				j = r("./src/reddit/actions/vote.ts"),
				E = r("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				y = r("./src/reddit/constants/adEvents.ts"),
				S = r("./src/reddit/constants/modals.ts"),
				T = r("./src/lib/makeApiRequest/index.ts"),
				h = r("./src/lib/omitHeaders/index.ts"),
				I = r("./src/reddit/constants/headers.ts"),
				C = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				A = r("./src/reddit/models/Comment/addProfileImgParam.ts"),
				x = r("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				D = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const w = (t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
					endpoint: Object(C.a)("".concat(t.apiUrl, "/api/save")),
					method: o.db.POST,
					data: {
						id: e
					}
				}),
				R = (t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
					endpoint: Object(C.a)("".concat(t.apiUrl, "/api/unsave")),
					method: o.db.POST,
					data: {
						id: e
					}
				}),
				P = (t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
					endpoint: Object(C.a)("".concat(t.apiUrl, "/api/lock")),
					method: o.db.POST,
					data: {
						id: e
					}
				}),
				N = (t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
					endpoint: Object(C.a)("".concat(t.apiUrl, "/api/unlock")),
					method: o.db.POST,
					data: {
						id: e
					}
				}),
				k = (t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
					endpoint: "".concat(t.apiUrl, "/api/ignore_reports"),
					method: o.db.POST,
					data: {
						id: e
					}
				}),
				v = (t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
					endpoint: "".concat(t.apiUrl, "/api/unignore_reports"),
					method: o.db.POST,
					data: {
						id: e
					}
				});
			var U = r("./src/graphql/operations/CommentToxicity.json"),
				L = r("./src/lib/makeGqlRequest/index.ts"),
				M = r("./src/reddit/helpers/genericServerError/index.ts"),
				G = r("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				F = r("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				q = r("./src/reddit/models/PostCreationForm/index.ts");
			const B = (t, e, r, n) => {
					let s, i;
					if (n === q.h.MARKDOWN) s = r.text, i = null;
					else {
						s = null;
						let t = null;
						r.rteState && (t = E.a.toRichTextJSON(r.rteState).document), i = JSON.stringify({
							document: t
						})
					}
					return Object(L.a)(t, Object.assign(Object.assign({}, U), {
						variables: {
							subredditName: e,
							markdown: s,
							richText: i
						}
					})).then(t => !t.ok || t.body.data.isValidComment)
				},
				K = async (t, e, r, n, s) => {
					const i = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: e
					};
					if (s === q.h.MARKDOWN) i.text = r.text;
					else {
						i.text = null;
						let t = null;
						r.rteState && (t = E.a.toRichTextJSON(r.rteState).document), i.richtext_json = JSON.stringify({
							document: t
						})
					}
					return Object(T.a)(Object(h.a)(t, [I.a]), {
						method: o.db.POST,
						endpoint: Object(C.a)(Object(x.a)(Object(D.a)("".concat(t.apiUrl, "/api/comment.json")))),
						data: i
					}).then(t => t.ok ? t.body.json ? t.body.json.errors.length ? Object.assign(Object.assign({}, t), {
						ok: !1,
						error: Object(F.a)(t)
					}) : Object.assign(Object.assign({}, t), {
						body: {
							comment: Object(G.a)(t.body.json.data.things[0].data, n)
						}
					}) : Object.assign(Object.assign({}, t), {
						body: {
							comment: Object(G.a)(t.body, n)
						}
					}) : Object.assign(Object.assign({}, t), {
						error: t.error || Object(M.a)()
					}))
				};
			var H = r("./src/reddit/endpoints/post/index.tsx"),
				Y = r("./src/reddit/endpoints/post/convert.ts"),
				V = r("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				W = r("./src/reddit/featureFlags/index.ts"),
				J = r("./src/reddit/helpers/commentList/index.ts"),
				z = r("./src/reddit/helpers/dom/index.ts"),
				Q = r("./src/reddit/selectors/telemetry.ts");
			var X = r("./src/reddit/helpers/trackers/commentsPage.ts"),
				Z = r("./src/reddit/models/Comment/index.ts"),
				$ = r("./src/reddit/models/Post/index.ts"),
				tt = r("./src/reddit/models/PostDraft/index.ts"),
				et = r("./src/reddit/models/RichTextJson/index.ts"),
				rt = r("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				nt = r("./src/reddit/models/Toast/index.ts"),
				st = r("./src/reddit/models/Vote/index.ts"),
				it = r("./src/reddit/selectors/comments.ts"),
				ot = r("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				dt = r("./src/reddit/selectors/moderatingComments.ts"),
				ct = r("./src/reddit/selectors/platform.ts"),
				at = r("./src/reddit/selectors/posts.ts"),
				ut = r("./src/reddit/selectors/user.ts");
			const lt = "COMMENT__STICKIED_COMMENT_SUCCESS",
				bt = {},
				pt = Object(d.a)(lt),
				Ot = "COMMENT__MUTATED",
				mt = Object(d.a)(Ot),
				ft = t => async (e, r, n) => {
					let {
						apiContext: i
					} = n;
					if (!Object(ut.I)(r())) return e(Object(b.i)()), void e(Object(p.k)({
						actionSource: p.a.Save,
						redirectUrl: Object(it.m)(r(), {
							commentId: t
						})
					}));
					const o = r().comments.models[t];
					if (!o) return;
					const d = o.isSaved ? R : w;
					if (e(mt({
							[t]: {
								isSaved: !o.isSaved
							}
						})), (await d(i(), t)).ok) {
						const r = o.isSaved ? s.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : s.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							n = s.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						e(Object(g.e)({
							text: r,
							kind: nt.b.Undo,
							buttonText: n,
							buttonAction: ft(t)
						}))
					} else e(mt({
						[t]: {
							isSaved: o.isSaved
						}
					}))
				}, _t = t => "viewing-comment-".concat(t), gt = n.a.telemetry.commentConsumedThreshold, jt = t => async (e, r) => {
					const s = r();
					if (!Object(it.n)(s, {
							commentId: t
						}) || Math.random() > n.a.telemetry.commentSampleRate) return;
					(t => {
						let {
							state: e,
							commentId: r
						} = t;
						Object(i.a)(Object.assign(Object.assign({
							source: "comment",
							action: "view",
							noun: "comment"
						}, Q.defaults(e)), {
							profile: Q.profile(e),
							post: Q.post(e, r),
							media: Q.media(e, r),
							subreddit: Q.subreddit(e),
							comment: Q.comment(e, r)
						}))
					})({
						state: s,
						commentId: t
					}), i.c.start(_t(t));
					const o = setTimeout(() => (t => {
						let {
							state: e,
							commentId: r
						} = t;
						return Object(i.a)(Object.assign(Object.assign({
							source: "comment",
							action: "consume",
							noun: "comment"
						}, Q.defaults(e)), {
							profile: Q.profile(e),
							post: Q.post(e, r),
							media: Q.media(e, r),
							subreddit: Q.subreddit(e),
							comment: Q.comment(e, r)
						}))
					})({
						state: s,
						commentId: t
					}), gt);
					bt[t] = o
				}, Et = (t, e) => async (r, n) => {
					const s = n(),
						o = _t(t);
					if (Object(it.n)(s, {
							commentId: t
						}) && i.c.has(o)) {
						const r = i.c.end(o);
						!e && r < gt && (clearTimeout(bt[t]), delete bt[t])
					}
				}, yt = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					if (!Object(ut.I)(r())) return void e(Object(p.i)(S.a.LOGIN_MODAL_ID));
					const i = r().comments.models[t];
					if (!i) return;
					const o = i.isLocked ? N : P;
					e(mt({
						[t]: {
							isLocked: !i.isLocked
						}
					})), (await o(s(), t)).ok || e(mt({
						[t]: {
							isLocked: i.isLocked
						}
					}))
				}, St = "COMMENT__MORECOMMENTS_PENDING", Tt = "COMMENT__MORECOMMENTS_LOADED", ht = "COMMENT__MORECOMMENTS_FAILED", It = Object(d.a)(St), Ct = Object(d.a)(Tt), At = Object(d.a)(ht), xt = (t, e) => async (r, s, i) => {
					let {
						apiContext: d
					} = i;
					const c = s(),
						a = c.moreComments.models[e],
						u = c.platform.currentPage,
						b = u && u.routeMatch,
						p = b && b.match,
						{
							partialPostId: O
						} = p ? p.params : null;
					if (!O) return;
					const m = Object($.m)(O);
					r(It({
						moreCommentsId: a.id
					}));
					const f = await ((t, e, r, s) => {
						let i = Object(D.a)(Object(x.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/morecomments/").concat(e)));
						return s && (i = Object(A.a)(i)), Object(T.a)(t, {
							data: r,
							endpoint: i,
							method: o.db.POST,
							type: "json",
							traceRequestName: "more_comments"
						})
					})(d(), m, {
						token: a.token
					}, Object(ot.a)(c));
					if (f.ok) {
						const e = f.body,
							n = Object(J.a)(e, m, c);
						r(Ct(Object.assign({
							key: t,
							moreCommentsItem: a,
							shouldCollapse: n
						}, e)));
						const s = c.posts.models[m];
						s && "subreddit" === s.belongsTo.type && e.comments && await r(Object(l.a)({
							commentIds: Object.keys(f.body.comments),
							postIds: [s.id],
							skip: ["communityDetails", "subscription"],
							subredditId: s.belongsTo.id
						}))
					} else r(At(Object.assign({
						moreCommentsItem: a
					}, f.error)))
				}, Dt = Object(j.b)(J.b, st.a.upvoted), wt = Object(j.b)(J.b, st.a.downvoted), Rt = "COMMENT__FOCUSED_TOGGLED", Pt = "COMMENT__FOCUSED_SET", Nt = "COMMENT__COLLAPSED_TOGGLED", kt = "COMMENT__COLLAPSED_UNSET", vt = "COMMENTS__HIDDEN_TOGGLED", Ut = "COMMENTS__HIDDEN_SET", Lt = "COMMENT_FORM_FOCUS_CHANGED", Mt = "COMMENT_MARKED_UNCOLLAPSED", Gt = Object(d.a)(Rt), Ft = Object(d.a)(Pt), qt = Object(d.a)(Nt), Bt = Object(d.a)(kt), Kt = (Object(d.a)(Ut), Object(d.a)(vt), Object(d.a)(Lt)), Ht = Object(d.a)(Mt), Yt = t => {
					let {
						hasFocus: e,
						draftKey: r
					} = t;
					return async (t, n) => {
						const s = n();
						if (!!s.comments.drafts[r])
							if (Object(ut.K)(s) && e) {
								const n = Kt({
									hasFocus: e,
									draftKey: r
								});
								t(Object(u.f)(n))
							} else t(Kt({
								hasFocus: e,
								draftKey: r
							}))
					}
				}, Vt = t => {
					let {
						commentId: e,
						commentsPageKey: r,
						scrollToAndRemeasure: n
					} = t;
					return async (t, s) => {
						const i = s(),
							o = Object(Z.g)(e),
							d = Object(it.o)(i, {
								commentLink: o,
								commentsPageKey: r
							}),
							c = Object(dt.b)(i, {
								commentId: e,
								commentsPageKey: r
							}),
							a = d.depth;
						t(qt({
							commentId: e,
							commentsPageKey: r,
							isCollapsed: c
						})), c || 0 !== a || n(e, !0), Object(_.d)()
					}
				}, Wt = t => {
					let {
						commentId: e,
						commentsPageKey: r
					} = t;
					return async (t, n) => {
						t(Bt({
							commentId: e,
							commentsPageKey: r
						}))
					}
				}, Jt = t => {
					let {
						commentLink: e,
						commentsPageKey: r,
						lineDepth: n,
						scrollToAndRemeasure: s
					} = t;
					return async (t, i) => {
						const o = i(),
							d = Object(J.e)(r, e, n, o),
							c = Object(dt.b)(o, {
								commentId: e.id,
								commentsPageKey: r
							});
						t(qt({
							commentId: d,
							commentsPageKey: r,
							isCollapsed: c
						})), 0 === n && s(d, !0), Object(_.d)()
					}
				}, zt = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = r(),
						d = i.comments.models[t],
						c = i.user.account ? i.user.account.displayText : null;
					d && c && (e(mt({
						[t]: {
							isApproved: !0,
							approvedBy: c,
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (await ((t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
						endpoint: Object(C.a)("".concat(t.apiUrl, "/api/approve")),
						method: o.db.POST,
						data: {
							id: e
						}
					}))(s(), t)).ok || e(mt({
						[t]: {
							isApproved: d.isApproved,
							approvedBy: null,
							bannedBy: d.bannedBy,
							isRemoved: d.isRemoved,
							isSpam: d.isSpam,
							modNote: d.modNote,
							modReasonBy: d.modReasonBy,
							modRemovalReason: d.modRemovalReason,
							numReports: d.numReports || null
						}
					})), Object(_.d)())
				}, Qt = (t, e) => async (r, n, s) => {
					let {
						apiContext: i
					} = s;
					const d = n(),
						c = d.comments.models[t],
						a = d.user.account ? d.user.account.displayText : null;
					c && a && (r(mt({
						[t]: {
							approvedBy: null,
							bannedBy: a,
							isApproved: !1,
							isRemoved: !e,
							isSpam: e
						}
					})), (await ((t, e, r) => Object(T.a)(Object(h.a)(t, [I.a]), {
						endpoint: Object(C.a)("".concat(t.apiUrl, "/api/remove")),
						method: o.db.POST,
						data: {
							id: e,
							spam: r
						}
					}))(i(), t, e)).ok || r(mt({
						[t]: {
							approvedBy: c.approvedBy,
							bannedBy: c.bannedBy,
							isApproved: c.isApproved,
							isRemoved: c.isRemoved,
							isSpam: c.isSpam
						}
					})), Object(_.d)())
				}, Xt = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = r().comments.models[t];
					if (!i) return;
					const o = i.ignoreReports ? v : k;
					e(mt({
						[t]: {
							ignoreReports: !i.ignoreReports
						}
					})), (await o(s(), t)).ok || e(mt({
						[t]: {
							ignoreReports: i.ignoreReports
						}
					}))
				}, Zt = (t, e, r) => async (n, s, i) => {
					let {
						apiContext: d
					} = i;
					const a = s(),
						u = a.comments.models[t];
					if (!u) return;
					const l = u.postId,
						b = a.postStickiedComments.data[l],
						p = o.g[e];
					n(mt({
						[t]: {
							distinguishType: e,
							isAdmin: e === o.C.ADMIN,
							isMod: e === o.C.MODERATOR,
							isStickied: !!r
						}
					})), r && b && b !== t && n(mt({
						[b]: {
							isStickied: !1
						}
					})), (await ((t, e, r, n) => Object(T.a)(Object(h.a)(t, [I.a]), {
						endpoint: Object(C.a)("".concat(t.apiUrl, "/api/distinguish/").concat(r)),
						method: o.db.POST,
						data: {
							id: e,
							sticky: n
						}
					}))(d(), t, p, r || null)).ok ? r && n(pt({
						id: t,
						postId: l,
						commentsPageKey: Object(c.a)(l, null, Object.assign({
							sort: o.r.CONFIDENCE
						}, a.platform.currentPage.queryParams))
					})) : (n(mt({
						[t]: {
							distinguishType: u.distinguishType,
							isAdmin: u.isAdmin,
							isMod: u.isMod,
							isStickied: u.isStickied
						}
					})), n(mt({
						[b]: {
							isStickied: a.comments.models[b].isStickied
						}
					})))
				}, $t = "COMMENT__SUBMIT_COMMENT_PENDING", te = "COMMENT__SUBMIT_REPLY_TO_POST_SUCCESS", ee = "COMMENT__SUBMIT_REPLY_TO_COMMENT_SUCCESS", re = "COMMENT__SUBMIT_COMMENT_FAILURE", ne = Object(d.a)($t), se = Object(d.a)(te), ie = Object(d.a)(ee), oe = Object(d.a)(re), de = (t, e, r, n) => {
					const s = n.ok && n.body,
						i = s && s.comment && s.comment.id;
					X.f(t, r, e, i)
				}, ce = "Toxicity_Warning__Modal", ae = (t, e, r, n, s, i) => async (o, d, c) => {
					let {
						gqlContext: a
					} = c;
					const u = d(),
						l = Object(ct.f)(u);
					let b = "";
					if (l && (b = l.name), W.d.enableToxicityWarning(u)) {
						if (!(await B(a(), b, n, s))) return void o(Object(p.i)(ce))
					}
					o(le(t, e, r, n, s, i))
				}, ue = t => t.rteState ? E.a.toRichTextJSON(t.rteState) : t.rtJson || t.text, le = (t, e, r, n, i, d, c) => async (a, u, l) => {
					let {
						apiContext: b
					} = l;
					a(Object(p.g)(ce));
					const m = u(),
						j = m.comments.submit.pending[r];
					if (!m.user.account || j) return;
					a(ne({
						draftKey: r,
						draft: n
					}));
					const E = m.user.account.displayText,
						S = n.commentMode;
					let T;
					if (c ? (T = await Object(V.j)(b(), t, n, E), a(Object(f.a)({
							streamId: t,
							level: T.body.automuteLevel
						}))) : T = await K(b(), t, n, E, S), T.ok) {
						let n;
						n = T.body, a(se(Object.assign(Object.assign({}, n), {
							headCommentId: Object(it.x)(m, {
								commentsPageKey: e
							}),
							commentsPageKey: e,
							draftKey: r
						})));
						const s = Object(at.N)(u(), {
							postId: t
						});
						a(Object(O.t)(s, y.a.CommentSubmitted))
					} else {
						T.error && T.error.type === o.zb && X.g(m, ue(n), t);
						const e = T.error && T.error.fields && T.error.fields[0] ? T.error.fields[0].msg : s.fbt._("Something went wrong", null, {
							hk: "LWFS0"
						});
						a(oe({
							draftKey: r,
							error: T.error
						})), a(Object(g.e)({
							duration: g.a,
							kind: nt.b.Error,
							text: e
						}))
					}
					de(u(), e, i, T), d || Object(_.d)()
				}, be = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					const {
						parentCommentId: i,
						commentsPageKey: o,
						parentCommentDepth: d,
						draftKey: c,
						formData: a,
						editorMode: u
					} = t, l = r(), b = Object(ct.f)(l);
					let O = "";
					if (b && (O = b.name), W.d.enableToxicityWarning(l)) {
						if (!(await B(s(), O, a, u))) return void e(Object(p.i)(ce))
					}
					e(pe({
						commentsPageKey: o,
						draftKey: c,
						parentCommentDepth: d,
						parentCommentId: i,
						formData: a,
						editorMode: u
					}))
				}, pe = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const {
						parentCommentId: i,
						commentsPageKey: d,
						parentCommentDepth: c,
						draftKey: a,
						formData: u,
						editorMode: l
					} = t;
					e(Object(p.g)(ce));
					const b = r(),
						O = b.comments.submit.pending[a];
					if (!b.user.account || O) return;
					e(ne({
						draftKey: a,
						draft: u
					}));
					const m = b.user.account.displayText,
						f = u.commentMode,
						g = await K(s(), i, u, m, f);
					if (g.ok) e(ie(Object.assign(Object.assign({}, g.body), {
						parentCommentId: i,
						commentsPageKey: d,
						draftKey: a,
						depth: c + 1
					})));
					else {
						if (g.error && g.error.type === o.zb) {
							const t = Object(it.n)(b, {
								commentId: i
							});
							if (!t) return;
							X.g(b, ue(u), t.postId, i)
						}
						e(oe({
							draftKey: a,
							error: g.error
						}))
					}
					de(r(), d, l, g), Object(_.d)()
				}, Oe = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					r().comments.models[t] && (await ((t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
						endpoint: "".concat(t.apiUrl, "/api/show_comment"),
						method: o.db.POST,
						data: {
							id: e
						}
					}))(s(), t)).ok && e((t => async (e, r, n) => {
						let {
							apiContext: s
						} = n;
						e(Ht({
							commentId: t
						}))
					})(t))
				}, me = "COMMENT__COMMENT_REPLY_FORM_OPENED", fe = "COMMENT__COMMENT_REPLY_FORM_CANCELLED", _e = "COMMENT__COMMENT_FORM_MUTATED", ge = "COMMENT__COMMENT_DRAFT_CLEARED", je = "COMMENT__COMMENT_FORM_SWITCHED_MODE", Ee = Object(d.a)(me), ye = Object(d.a)(fe), Se = Object(d.a)(_e), Te = (Object(d.a)(ge), Object(d.a)(je)), he = "INITIALIZE_COMMENT_EDITOR_MODE", Ie = (Object(d.a)(he), (t, e, r) => async (n, i, o) => {
					let {
						apiContext: d
					} = o;
					const c = t === q.h.RICH_TEXT;
					if (!e || "object" == typeof e && Object(et.G)(e)) n(Te({
						editorMode: t,
						draftKey: r,
						content: c ? et.i : ""
					})), n(Object(m.c)(t));
					else {
						n(Object(m.b)(r));
						const i = await Object(Y.a)(d(), t, c ? e : JSON.stringify(e));
						if (i.ok) {
							const e = i.body.output;
							n(Object(m.a)(r)), n(Te({
								editorMode: t,
								draftKey: r,
								content: e
							})), n(Object(m.c)(t))
						} else n(Object(m.a)(r)), n(Object(g.e)({
							duration: g.a,
							kind: nt.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), Ce = t => {
					let {
						commentsPageKey: e,
						parentCommentId: r,
						singleOpen: n
					} = t;
					return async (t, s) => {
						const i = s(),
							o = Object(a.a)(tt.c.replyToComment, r);
						if (!Object(ut.I)(s())) return t(Object(b.i)()), void t(Object(p.k)({
							actionSource: p.a.Reply,
							redirectUrl: Object(it.m)(s(), {
								commentId: r
							})
						}));
						const d = i.comments.replyFormOpen[e],
							c = d && d[r];
						if ((c || d && n) && (Object.keys(d).forEach(r => d[r] && t(ye({
								parentCommentId: r,
								commentsPageKey: e
							}))), c)) return;
						let l = "",
							O = null;
						const m = i.user.prefs.commentMode,
							f = Object(z.d)();
						if (f) {
							const t = f.filter(t => !!t && 10 !== t.charCodeAt(0));
							if (m === q.h.MARKDOWN) l = t.map(t => "> ".concat(t, "\n")).join("");
							else {
								const e = t.map(t => rt.s(t, null)).map(t => rt.l([t])),
									r = rt.s("", null),
									n = rt.l([r]);
								O = {
									document: [rt.c(e), n]
								}
							}
						}
						const _ = i.comments.drafts[o];
						let g;
						if (g = f ? {
								commentMode: m,
								draftType: tt.c.replyToComment,
								rtJson: O,
								text: "".concat(l, "\n")
							} : _ || {
								commentMode: m,
								draftType: tt.c.replyToComment,
								rtJson: O,
								text: ""
							}, Object(ut.K)(i)) {
							const n = Ee({
								parentCommentId: r,
								commentsPageKey: e,
								draftKey: o,
								formData: g
							});
							t(Object(u.f)(n))
						} else t(Ee({
							parentCommentId: r,
							commentsPageKey: e,
							draftKey: o,
							formData: g
						}))
					}
				}, Ae = t => async (e, r) => {
					e(Wt(t)), e(Ge(t))
				}, xe = t => {
					let {
						parentCommentId: e,
						commentsPageKey: r
					} = t;
					return async (t, n) => {
						t(ye({
							parentCommentId: e,
							commentsPageKey: r
						})), t(Ce({
							parentCommentId: e,
							commentsPageKey: r
						})), t(Wt({
							commentId: e,
							commentsPageKey: r
						}))
					}
				}, De = (t, e) => r => r(Se({
					draftKey: t,
					formData: e
				})), we = "COMMENT__DISABLE_AUTOFOCUS", Re = Object(d.a)(we), Pe = t => e => e(Re({
					draftKey: t
				})), Ne = "COMMENT__EDIT_COMMENT_ENABLED", ke = "COMMENT__REQUEST_EDIT_PENDING", ve = "COMMENT__REQUEST_EDIT_FAILURE", Ue = "COMMENT__REQUEST_EDIT_SUCCESS", Le = "COMMENT__COMMENT_EDIT_FORM_CANCELLED", Me = Object(d.a)(Ne), Ge = t => {
					let {
						commentId: e,
						commentMode: r,
						commentsPageKey: n,
						draftKey: s,
						text: i
					} = t;
					return async (t, o) => {
						const d = o();
						d.user.account && (X.c(d), t(Me({
							commentId: e,
							commentsPageKey: n,
							draftKey: s,
							formData: {
								text: i,
								commentMode: r,
								rteState: null,
								draftType: tt.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Fe = Object(d.a)(ke), qe = Object(d.a)(ve), Be = Object(d.a)(Ue), Ke = Object(d.a)(Le), He = t => {
					let {
						id: e,
						commentsPageKey: r,
						depth: n,
						draftKey: s,
						formData: i
					} = t;
					return async (t, n, d) => {
						let {
							apiContext: c
						} = d;
						const a = n();
						if (!a.user.account) return;
						t(Fe({
							draftKey: s
						})), X.d(a);
						const u = a.user.account.displayText || "",
							l = i.commentMode,
							b = await (async (t, e, r, n, s, i) => {
								const d = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: e
								};
								if (i === q.h.MARKDOWN) d.text = n.text;
								else {
									d.text = null;
									let t = null;
									n.rteState && (t = E.a.toRichTextJSON(n.rteState).document), d.richtext_json = JSON.stringify({
										document: t
									})
								}
								return Object(T.a)(Object(h.a)(t, [I.a]), {
									endpoint: Object(C.a)(Object(D.a)(Object(x.a)("".concat(t.apiUrl, "/api/editusertext")))),
									method: o.db.POST,
									data: d
								}).then(t => t.ok ? t.body.json ? t.body.json.errors.length ? Object.assign(Object.assign({}, t), {
									ok: !1,
									error: Object(F.a)(t)
								}) : Object.assign(Object.assign({}, t), {
									body: {
										comment: Object(G.a)(t.body.json.data.things[0].data, s)
									}
								}) : Object.assign(Object.assign({}, t), {
									body: {
										comment: Object(G.a)(t.body, s)
									}
								}) : Object.assign(Object.assign({}, t), {
									error: t.error || Object(M.a)()
								}))
							})(c(), e, 0, i, u, l);
						if (b.ok) {
							const n = b.body;
							t(Be({
								commentId: e,
								commentsPageKey: r,
								draftKey: s
							})), t(mt({
								[e]: Object.assign({}, n.comment)
							}))
						} else t(qe({
							draftKey: s,
							error: b.error
						}))
					}
				}, Ye = "COMMENT__REQUEST_DELETE_PENDING", Ve = "COMMENT__REQUEST_DELETE_FAILURE", We = "COMMENT__REQUEST_DELETE_SUCCESS", Je = Object(d.a)(Ye), ze = Object(d.a)(Ve), Qe = Object(d.a)(We), Xe = (t, e) => async (r, n, s) => {
					let {
						apiContext: i
					} = s;
					const d = n();
					r(Je({
						id: t
					})), X.a(t, d);
					const c = await ((t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
						endpoint: Object(C.a)("".concat(t.apiUrl, "/api/del")),
						method: o.db.POST,
						data: {
							id: e
						}
					}).then(t => t.ok ? t.body.json && t.body.json.errors.length ? Object.assign(Object.assign({}, t), {
						ok: !1,
						error: Object(F.a)(t)
					}) : Object.assign(Object.assign({}, t), {
						body: {}
					}) : Object.assign(Object.assign({}, t), {
						error: t.error || Object(M.a)()
					})))(i(), t);
					c.ok ? r(Qe({
						id: t,
						postId: e
					})) : r(ze({
						id: t,
						error: c.error
					}))
				}, Ze = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = !r().comments.models[t].sendReplies;
					e(mt({
						[t]: {
							sendReplies: i
						}
					})), (await Object(H.q)(s(), t, i)).ok || e(mt({
						[t]: {
							sendReplies: !i
						}
					}))
				}, $e = "COMMENT__CHANGE_HIGHLIGHT_FILTER", tr = Object(d.a)($e)
		},
		"./src/reddit/actions/communityFlairs/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "c", (function() {
				return s
			})), r.d(e, "d", (function() {
				return i
			})), r.d(e, "a", (function() {
				return o
			}));
			const n = "TOP_COMMUNITY_FLAIR__FETCH_FAILURE",
				s = "TOP_COMMUNITY_FLAIR__FETCH_PENDING",
				i = "TOP_COMMUNITY_FLAIR__FETCH_SUCCESS",
				o = "COMMUNITY_FLAIR__ADD_FLAIRS"
		},
		"./src/reddit/actions/communityFlairs/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return y
			})), r.d(e, "e", (function() {
				return S
			})), r.d(e, "c", (function() {
				return T
			})), r.d(e, "b", (function() {
				return h
			})), r.d(e, "d", (function() {
				return I
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/camelCase.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/isEmpty.js"),
				o = r.n(i),
				d = r("./node_modules/lodash/omit.js"),
				c = r.n(d),
				a = r("./src/lib/makeActionCreator/index.ts"),
				u = r("./src/reddit/endpoints/flair/index.ts"),
				l = r("./src/reddit/helpers/flair.ts"),
				b = r("./src/reddit/models/Flair/index.ts"),
				p = r("./src/reddit/selectors/communityFlairs.ts"),
				O = r("./src/reddit/selectors/subreddit.ts"),
				m = r("./src/reddit/actions/communityFlairs/constants.ts");
			const f = Object(a.a)(m.c),
				_ = Object(a.a)(m.d),
				g = Object(a.a)(m.b),
				j = Object(a.a)(m.a),
				E = t => {
					const e = {};
					for (const r in t) {
						e[s()(r)] = t[r]
					}
					return e
				},
				y = (t, e) => async (r, n) => {
					const i = n(),
						d = Object(p.b)(i, e),
						a = Object(p.c)(i, e) || [],
						u = (t => {
							const e = {};
							return t.map(t => {
								const r = Object(l.g)(t),
									n = s()(r),
									i = n && e.hasOwnProperty(n);
								t.type !== b.f.Spoiler && t.type !== b.f.Nsfw && (i || (e[n] = Object.assign(Object.assign({}, t), {
									id: n
								})))
							}), e
						})(t),
						O = c()(u, a);
					if (o()(O)) return;
					const m = Object.keys(O),
						f = a ? a.concat(m) : m,
						_ = d ? Object.assign(Object.assign({}, d), O) : O;
					r(j({
						models: _,
						sortedKeys: f,
						subredditId: e
					}))
				}, S = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = Object(O.G)(r(), t);
					e(f());
					const o = await Object(u.c)(s(), t);
					if (o.ok) {
						const t = o.body.map(E).map(t => Object(l.c)(t));
						e(y(t, i)), e(_())
					} else e(g())
				}, T = (t, e) => {
					const r = [];
					for (const n in t) {
						const s = t[n],
							i = s.belongsTo && s.belongsTo.id === e;
						s.flair && s.flair.length && i && r.push(...s.flair)
					}
					return r
				}, h = t => {
					const e = t && t.data && t.data.content && t.data.content.widgets;
					if (e) {
						const t = e.items;
						for (const e in t) {
							const r = t[e];
							if ("post-flair" === r.kind) return r
						}
					}
				}, I = t => {
					const e = [],
						{
							templates: r
						} = t;
					for (const n in r) {
						const t = r[n];
						t && e.push(t)
					}
					return e
				}
		},
		"./src/reddit/actions/contentGate.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return a
			})), r.d(e, "b", (function() {
				return u
			})), r.d(e, "f", (function() {
				return l
			})), r.d(e, "g", (function() {
				return b
			})), r.d(e, "h", (function() {
				return p
			})), r.d(e, "i", (function() {
				return O
			})), r.d(e, "j", (function() {
				return m
			})), r.d(e, "d", (function() {
				return f
			})), r.d(e, "e", (function() {
				return _
			})), r.d(e, "c", (function() {
				return g
			})), r.d(e, "m", (function() {
				return E
			})), r.d(e, "n", (function() {
				return y
			})), r.d(e, "o", (function() {
				return S
			})), r.d(e, "q", (function() {
				return T
			})), r.d(e, "r", (function() {
				return h
			})), r.d(e, "t", (function() {
				return I
			})), r.d(e, "p", (function() {
				return C
			})), r.d(e, "u", (function() {
				return A
			})), r.d(e, "s", (function() {
				return x
			})), r.d(e, "k", (function() {
				return D
			})), r.d(e, "l", (function() {
				return w
			}));
			var n = r("./node_modules/@reddit/onetrust-integration/dist/esm/index.js"),
				s = r("./src/config.ts"),
				i = r("./src/lib/makeActionCreator/index.ts"),
				o = r("./src/reddit/constants/cookie.ts"),
				d = r("./src/reddit/endpoints/user/preferences.ts"),
				c = r("./src/reddit/selectors/user.ts");
			const a = "CONTENTGATE__VISITED_GOLD_SUBREDDIT",
				u = "CONTENTGATE__VISITED_PRIVATE_SUBREDDIT",
				l = "CONTENTGATE__VISITED_QUARANTINED_SUBREDDIT",
				b = "CONTENTGATE__SET_OVER_18_PREF",
				p = "CONTENTGATE__VISITED_BANNED_SUBREDDIT",
				O = "CONTENTGATE__VISITED_SUBREDDIT_BLOCKED_FOR_LEGAL_REASON",
				m = "CONTENTGATE__VISITED_NONEXISTENT_SUBREDDIT",
				f = "CONTENTGATE__VISITED_DELETED_PROFILE",
				_ = "CONTENTGATE__VISITED_SUSPENDED_PROFILE",
				g = "CONTENTGATE__VISITED_PROFILE_BLOCKED_FOR_LEGAL_REASON",
				j = Object(i.a)(b),
				E = Object(i.a)(p),
				y = Object(i.a)(O),
				S = Object(i.a)(m),
				T = Object(i.a)(a),
				h = Object(i.a)(u),
				I = Object(i.a)(l),
				C = Object(i.a)(f),
				A = Object(i.a)(_),
				x = Object(i.a)(g),
				D = () => {
					const t = new Date;
					t.setFullYear(t.getFullYear() + 2), Object(n.b)(o.f, "1", {
						expires: t,
						domain: s.a.cookieDomain
					})
				},
				w = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const s = e();
					Object(c.I)(s) && s.platform.currentPage && await Object(d.f)(n()), t(j({
						over18: !0
					}))
				}
		},
		"./src/reddit/actions/discoveryUnit.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return p
			})), r.d(e, "b", (function() {
				return O
			})), r.d(e, "a", (function() {
				return m
			})), r.d(e, "g", (function() {
				return j
			})), r.d(e, "f", (function() {
				return E
			})), r.d(e, "e", (function() {
				return y
			})), r.d(e, "d", (function() {
				return S
			})), r.d(e, "h", (function() {
				return C
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/makeListingKey/index.ts"),
				o = (r("./src/lib/addQueryParams/index.ts"), r("./src/lib/makeApiRequest/index.ts")),
				d = r("./src/lib/omitHeaders/index.ts"),
				c = (r("./src/lib/stringInterpolate/index.ts"), r("./src/reddit/constants/headers.ts")),
				a = r("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				u = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var l = r("./src/reddit/selectors/discoveryUnit.ts"),
				b = r("./src/reddit/selectors/listings.ts");
			const p = "DISCOVERY_UNIT__LIST_PENDING",
				O = "DISCOVERY_UNIT__LIST_LOADED",
				m = "DISCOVERY_UNIT__LIST_FAILED",
				f = Object(s.a)(p),
				_ = Object(s.a)(O),
				g = Object(s.a)(m),
				j = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const s = e(),
						i = Object(l.e)(s),
						o = Object(l.d)(s);
					if (i || o) return;
					t(f());
					const d = await (t => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_88",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Similar communities to %{subredditName}",
										unit_name: "chaining_similar_subreddits_posts",
										unit_type: "listing"
									}, {
										id: "xd_89",
										enabled: !0,
										layout: "large",
										surface: "front_page",
										title: "Mildy similar posts",
										unit_name: "chaining_similar_posts",
										unit_type: "listing"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(n());
					if (d.ok) {
						const {
							discoveryUnits: e
						} = (t => {
							return {
								discoveryUnits: t.global.discovery_config_v1.discovery_units.reduce((t, e) => {
									const r = {
										enabled: e.enabled,
										experiment: e.experiment,
										id: e.id,
										index: e.index,
										layout: e.layout,
										options: e.options,
										parameters: e.parameters,
										subtitle: e.subtitle,
										subtitleIcon: e.subtitle_icon,
										surface: e.surface,
										title: e.title,
										unitName: e.unit_name,
										unitType: e.unit_type,
										url: e.url
									};
									return t[r.id] = r, t
								}, {})
							}
						})(d.body);
						t(_({
							discoveryUnits: e
						}))
					} else t(g({
						error: d.error
					}))
				}, E = "DISCOVERY_UNIT__UNIT_DATA_PENDING", y = "DISCOVERY_UNIT__UNIT_DATA_LOADED", S = "DISCOVERY_UNIT__UNIT_DATA_FAILED", T = Object(s.a)(E), h = Object(s.a)(y), I = Object(s.a)(S), C = (t, e) => async (r, s, l) => {
					let {
						apiContext: p
					} = l;
					const O = s(),
						m = Object(i.a)(t, n.O.HOT, {
							category: e
						}),
						f = Object(b.h)(O, {
							listingKey: m
						}),
						_ = !!O.listings.listingOrder.fetchedTokens[m];
					if (f || _) return;
					r(T({
						key: m
					}));
					const g = await ((t, e) => Object(o.a)(Object(d.a)(t, [c.a]), {
						endpoint: Object(u.a)("".concat(t.apiUrl, "/api/posts_in_category.json?category=").concat(e)),
						method: n.db.GET
					}))(p(), e);
					if (g.ok) {
						const {
							postIds: t,
							posts: e
						} = (t => {
							const e = [],
								r = {};
							return t.data.children.forEach(t => {
								const n = Object(a.a)(t.data);
								e.push(n.id), r[n.id] = n
							}), {
								postIds: e,
								posts: r
							}
						})(g.body), n = t.length > 0 ? t.length - 1 : 0;
						r(h({
							key: m,
							meta: O.meta,
							postIds: t,
							posts: e,
							token: t[n]
						}))
					} else r(I({
						key: m,
						error: g.error
					}))
				}
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			const n = t => async e => {
				const n = await (() => Promise.all([r.e("vendors~EconHelperActions~SubredditPremiumBadgeManagement~reddit-components-Econ-Prediction"), r.e("EconHelperActions~reddit-components-Econ-Prediction"), r.e("EconHelperActions")]).then(r.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(t => t.fetchAll))();
				await e(n(t))
			}
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "e", (function() {
				return s
			})), r.d(e, "b", (function() {
				return i
			})), r.d(e, "c", (function() {
				return o
			})), r.d(e, "d", (function() {
				return d
			}));
			const n = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				s = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				d = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "c", (function() {
				return i
			})), r.d(e, "d", (function() {
				return o
			})), r.d(e, "e", (function() {
				return d
			})), r.d(e, "f", (function() {
				return c
			})), r.d(e, "g", (function() {
				return a
			})), r.d(e, "h", (function() {
				return u
			})), r.d(e, "i", (function() {
				return l
			})), r.d(e, "j", (function() {
				return b
			}));
			const n = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__ORDER_SUCCESS",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS",
				b = "ECONOMICS__SUBREDDIT_PREMIUM__UPLOAD_MODAL_OPENED"
		},
		"./src/reddit/actions/eventPosts/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "e", (function() {
				return i
			})), r.d(e, "d", (function() {
				return o
			})), r.d(e, "f", (function() {
				return d
			})), r.d(e, "a", (function() {
				return c
			}));
			const n = "MOD_PAGE_EVENT_POSTS_LOADED",
				s = "MOD_PAGE_EVENT_POSTS_FAILED",
				i = "MOD_PAGE_EVENT_POSTS_PENDING",
				o = "MOD_PAGE_EVENT_POSTS_MORE_LOADED",
				d = "START_EVENT_NOW_SUCCESS",
				c = "EDIT_EVENT_TIME_SUCCESS"
		},
		"./src/reddit/actions/externalAccount.ts": function(t, e, r) {
			"use strict";
			r.d(e, "l", (function() {
				return E
			})), r.d(e, "k", (function() {
				return y
			})), r.d(e, "j", (function() {
				return S
			})), r.d(e, "i", (function() {
				return T
			})), r.d(e, "h", (function() {
				return h
			})), r.d(e, "g", (function() {
				return I
			})), r.d(e, "o", (function() {
				return P
			})), r.d(e, "p", (function() {
				return N
			})), r.d(e, "b", (function() {
				return k
			})), r.d(e, "c", (function() {
				return v
			})), r.d(e, "a", (function() {
				return U
			})), r.d(e, "n", (function() {
				return F
			})), r.d(e, "e", (function() {
				return q
			})), r.d(e, "f", (function() {
				return B
			})), r.d(e, "d", (function() {
				return K
			})), r.d(e, "m", (function() {
				return W
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/addQueryParams/index.ts"),
				o = r("./src/reddit/actions/toaster.ts"),
				d = r("./src/reddit/constants/parameters.ts"),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/makeApiRequest/index.ts"),
				u = r("./src/lib/omitHeaders/index.ts"),
				l = r("./src/reddit/constants/headers.ts"),
				b = r("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = t => {
				return t.reduce((t, e) => (t[e.provider] = e, t), {})
			};
			var O = r("./src/reddit/models/Toast/index.ts"),
				m = r("./src/reddit/models/User/index.ts"),
				f = r("./src/reddit/selectors/externalAccount.ts"),
				_ = r("./src/reddit/selectors/platform.ts"),
				g = r("./src/reddit/selectors/subreddit.ts"),
				j = r("./src/reddit/selectors/user.ts");
			const E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				y = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				S = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				T = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				h = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				I = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				C = Object(s.a)(E),
				A = Object(s.a)(y),
				x = Object(s.a)(S),
				D = Object(s.a)(T),
				w = Object(s.a)(h),
				R = Object(s.a)(I),
				P = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = r(),
						o = Object(j.i)(i),
						d = t || o && Object(m.e)(o);
					if (!d) return;
					if (Object(f.d)(i, {
							username: d
						})) return;
					e(C(d));
					const O = await ((t, e) => Object(a.a)(Object(u.a)(t, [l.a]), {
						endpoint: Object(b.a)("".concat(t.apiUrl, "/api/v1/external_account/user/").concat(e, ".json")),
						traceRequestName: "get_external_accounts",
						method: c.db.GET
					}))(s(), d);
					if (O.ok) {
						const t = p(O.body);
						e(A({
							username: d,
							accountsData: t
						}))
					} else e(x(O.error))
				}, N = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const s = e(),
						i = Object(_.e)(s);
					if (!i) return;
					const o = s.externalAccount.api.subreddit.fetched[i],
						d = s.externalAccount.api.subreddit.pending[i];
					if (o || d) return;
					const O = Object(g.y)(s, {
						subredditName: i
					});
					if (!(O && O.hasExternalAccount)) return;
					t(D(i));
					const m = await ((t, e) => Object(a.a)(Object(u.a)(t, [l.a]), {
						endpoint: Object(b.a)("".concat(t.apiUrl, "/api/v1/external_account/subreddit/").concat(e, ".json")),
						method: c.db.GET
					}))(n(), i);
					if (m.ok) {
						const e = p(m.body);
						t(w({
							subredditName: i,
							accountsData: e
						}))
					} else t(R(m.error))
				}, k = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", v = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", U = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", L = Object(s.a)(k), M = Object(s.a)(v), G = Object(s.a)(U), F = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					e(L({
						provider: t
					}));
					const i = Object(j.i)(r()),
						o = Object(m.e)(i),
						d = await ((t, e) => Object(a.a)(Object(u.a)(t, [l.a]), {
							endpoint: Object(b.a)("".concat(t.apiUrl, "/api/v1/external_account/").concat(e, "/disconnect.json")),
							method: c.db.POST
						}))(s(), t);
					d.ok ? e(M({
						provider: t,
						username: o
					})) : e(G({
						provider: t,
						error: d.error
					}))
				}, q = "OAUTH_FLOW_URL_PENDING", B = "OAUTH_FLOW_URL_SUCCESS", K = "OAUTH_FLOW_URL_FAILED", H = Object(s.a)(q), Y = Object(s.a)(B), V = Object(s.a)(K), W = t => async (e, r, s) => {
					let {
						apiContext: p
					} = s;
					e(H({
						provider: t
					}));
					const m = Object(i.a)(window.location.href, {
							[d.d]: t
						}),
						f = await ((t, e, r) => Object(a.a)(Object(u.a)(t, [l.a]), {
							endpoint: Object(b.a)("".concat(t.apiUrl, "/api/v1/external_account/").concat(e, "/connect.json")),
							method: c.db.POST,
							data: {
								redirect_url: r
							}
						}))(p(), t, m);
					if (f.ok) {
						const {
							redirect_url: r
						} = f.body;
						e(Y({
							provider: t
						})), window.location.href = r
					} else e(V({
						provider: t,
						error: f.error
					})), e(Object(o.e)({
						kind: O.b.Error,
						text: n.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/global/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			const n = "LOCAL_STORAGE_LOADED"
		},
		"./src/reddit/actions/gold/communityAwards.ts": function(t, e, r) {
			"use strict";
			r.d(e, "d", (function() {
				return y
			})), r.d(e, "f", (function() {
				return S
			})), r.d(e, "e", (function() {
				return T
			})), r.d(e, "b", (function() {
				return C
			})), r.d(e, "c", (function() {
				return x
			})), r.d(e, "i", (function() {
				return D
			})), r.d(e, "a", (function() {
				return G
			})), r.d(e, "j", (function() {
				return K
			})), r.d(e, "g", (function() {
				return J
			})), r.d(e, "h", (function() {
				return Z
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/sentry/index.ts"),
				o = r("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				d = r("./src/reddit/actions/modal.ts"),
				c = r("./src/reddit/actions/toaster.ts"),
				a = r("./src/reddit/models/Toast/index.ts"),
				u = r("./src/reddit/selectors/activeModalId.ts"),
				l = r("./src/reddit/selectors/communityAwards.ts"),
				b = r("./src/reddit/selectors/experiments/econ/groupAwarding.ts"),
				p = r("./src/reddit/selectors/profile.ts"),
				O = r("./src/reddit/selectors/subreddit.ts"),
				m = r("./src/reddit/endpoints/gold/communityAwards.ts"),
				f = r("./src/reddit/constants/gold.ts"),
				_ = r("./src/reddit/actions/gold/constants.ts");
			const g = () => n.fbt._("There was an error creating the award. Please try again.", null, {
					hk: "3UtrTD"
				}),
				j = () => n.fbt._("There was an error loading awards list. Please try again.", null, {
					hk: "3fs6Y8"
				}),
				E = () => n.fbt._("There was an error removing the award. Please try again.", null, {
					hk: "1exAPF"
				}),
				y = (t, e, r, n, s, i, o, d) => async (c, a, u) => {
					let {
						gqlContext: l
					} = u;
					c(h());
					try {
						if ((await Object(m.a)(l(), t, e, r, n, s, i, o, d)).error) {
							const t = g();
							await c(C(t))
						}
					} catch (b) {
						const t = g();
						await c(C(t))
					}
				}, S = (t, e, r, n, s, i, o, d) => async (c, a, u) => {
					let {
						gqlContext: l
					} = u;
					c(h());
					try {
						if ((await Object(m.c)(l(), t, e, r, n, s, i, o, d)).error) {
							const t = g();
							await c(C(t))
						}
					} catch (b) {
						const t = g();
						await c(C(t))
					}
				}, T = t => {
					let {
						awardSubType: e,
						coinPrice: r,
						coinReward: n,
						daysOfDripExtension: s,
						daysOfPremium: i,
						description: o,
						endsAt: d,
						giverCoinReward: c,
						iconFormat: a,
						iconHeight: u,
						iconUrl: l,
						iconWidth: b,
						isNew: p,
						name: O,
						pennyPrice: f,
						pennyDonate: _,
						startsAt: j,
						subredditCoinReward: E
					} = t;
					return async (t, y, S) => {
						let {
							gqlContext: T
						} = S;
						t(h());
						try {
							if ((await Object(m.b)({
									awardSubType: e,
									coinPrice: r,
									coinReward: n,
									context: T(),
									daysOfDripExtension: s,
									daysOfPremium: i,
									description: o,
									endsAt: d,
									giverCoinReward: c,
									iconFormat: a,
									iconHeight: u,
									iconUrl: l,
									iconWidth: b,
									isNew: p,
									name: O,
									pennyPrice: f,
									pennyDonate: _,
									startsAt: j,
									subredditCoinReward: E
								})).error) {
								const e = g();
								await t(C(e))
							}
						} catch (I) {
							const e = g();
							await t(C(e))
						}
					}
				}, h = Object(s.a)(_.i), I = Object(s.a)(_.h), C = t => async (e, r) => {
					await e(I(t)), e(Object(c.e)({
						kind: a.b.Error,
						duration: c.a,
						text: t
					}))
				}, A = Object(s.a)(_.j), x = t => {
					let {
						award: e,
						subredditId: r
					} = t;
					return async (t, s) => {
						const i = s();
						t(A({
							award: e,
							subredditId: r
						})), Object(u.a)(i) === f.a && t(Object(d.i)(f.a));
						const o = n.fbt._("Community award successfully created!", null, {
							hk: "3UvmDa"
						});
						t(Object(c.e)({
							kind: a.b.SuccessCommunity,
							text: o
						}))
					}
				}, D = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					const i = r(),
						d = !!i.awards.manageable.order[t];
					if (Object(l.b)(i, {
							subredditOrProfileId: t
						}) || d) return;
					e(w({
						subredditOrProfileId: t
					}));
					const c = Object(o.a)(t),
						a = !!Object(O.ab)(i, {
							subredditIds: [t]
						})[0];
					let u;
					if (c) u = Object(m.j)(s());
					else if (a) u = Object(m.k)(s(), t);
					else {
						const e = Object(p.p)(i, {
							profileId: t
						}).name;
						u = Object(m.l)(s(), e)
					}
					try {
						const r = await u;
						if (!r.ok) {
							const t = j();
							return void(await e(k(t)))
						}
						let n = [];
						if (c) n = r.body.data.globalAwards;
						else {
							const s = a ? r.body.data.subreddit : r.body.data.profileByName;
							n = s.manageableAwards || [], e(P({
								awards: s.optionalAwards || [],
								subredditOrProfileId: t
							})), e(v({
								subredditOrProfileId: t,
								disabled: !s.isAwardCreationAllowed
							}))
						}
						await e(R({
							awards: n,
							subredditOrProfileId: t
						}))
					} catch (b) {
						const t = j();
						e(k(t))
					}
				}, w = Object(s.a)(_.K), R = Object(s.a)(_.J), P = Object(s.a)(_.O), N = Object(s.a)(_.I), k = t => async (e, r) => {
					await e(N(t)), e(Object(c.e)({
						kind: a.b.Error,
						duration: c.a,
						text: t
					}))
				}, v = Object(s.a)(_.e), U = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					const o = r();
					if (!!o.awards.usable.order[t]) return;
					const d = Object(b.a)(o);
					try {
						const r = Object(p.p)(o, {
							profileId: t
						});
						if (r) {
							const n = await Object(m.o)(s(), r.name, d);
							if (n.ok) {
								const r = n.body;
								return void(await e(L({
									awards: r.data.profile.usableAwards,
									subredditOrProfileId: t
								})))
							}
						} else {
							const r = await Object(m.n)(s(), t, d);
							if (r.ok) {
								const n = r.body;
								return void(await e(L({
									awards: n.data.subreddit.usableAwards,
									subredditOrProfileId: t
								})))
							}
						}
					} catch (c) {
						i.c.captureException(c)
					}
				}, L = Object(s.a)(_.ub), M = t => t.map(t => {
					let {
						tag: e,
						content: r
					} = t;
					return {
						tag: e,
						content: {
							richtext: JSON.parse(r.richtext),
							markdown: r.markdown
						}
					}
				}), G = (t, e) => async (r, n, s) => {
					let {
						gqlContext: o
					} = s;
					const d = n(),
						c = d.awards.sortedUsable.order[t];
					if (!!c && !!c[e]) return;
					const a = Object(b.a)(d);
					r(F({
						subredditOrProfileId: t,
						thingId: e
					}));
					try {
						const n = Object(p.p)(d, {
							profileId: t
						});
						if (n) {
							const s = await Object(m.g)(o(), n.name, e, a);
							if (s.ok) {
								const n = s.body,
									i = M(n.data.profileByName.awardingTray.sortedUsableTags);
								return void(await r(B({
									awards: n.data.profileByName.sortedUsableAwards,
									tags: i,
									subredditOrProfileId: t,
									thingId: e
								})))
							}
							r(U(t)), await r(q({
								subredditOrProfileId: t,
								thingId: e
							}))
						} else {
							const n = await Object(m.f)(o(), t, e, a);
							if (n.ok) {
								const s = n.body,
									i = M(s.data.subredditInfoById.awardingTray.sortedUsableTags);
								return void(await r(B({
									awards: s.data.subredditInfoById.sortedUsableAwards,
									tags: i,
									subredditOrProfileId: t,
									thingId: e
								})))
							}
							r(U(t)), await r(q({
								subredditOrProfileId: t,
								thingId: e
							}))
						}
					} catch (u) {
						i.c.captureException(u), r(U(t)), await r(q({
							subredditOrProfileId: t,
							thingId: e
						}))
					}
				}, F = Object(s.a)(_.d), q = Object(s.a)(_.b), B = Object(s.a)(_.c), K = (t, e) => async (r, s, o) => {
					let {
						gqlContext: d
					} = o;
					r(H());
					try {
						if ((await Object(m.m)(d(), e)).error) {
							const t = E();
							await r(W(t))
						} else {
							await r(Y({
								awardId: e,
								subredditId: t
							}));
							const i = Object(l.a)(s(), e);
							if (!i) return;
							const o = n.fbt._("{award name} Award successfully deleted!", [n.fbt._param("award name", i.name)], {
								hk: "3ZQs5u"
							});
							r(Object(c.e)({
								kind: a.b.SuccessCommunity,
								duration: c.a,
								text: o
							}))
						}
					} catch (u) {
						i.c.captureException(u);
						const t = E();
						await r(W(t))
					}
				}, H = Object(s.a)(_.eb), Y = Object(s.a)(_.fb), V = Object(s.a)(_.db), W = t => async (e, r) => {
					await e(V(t)), e(Object(c.e)({
						kind: a.b.Error,
						duration: c.a,
						text: t
					}))
				}, J = (t, e) => async (r, s, o) => {
					let {
						gqlContext: d
					} = o;
					r(z());
					let u = n.fbt._("There was a problem disabling the {award name} Award. Please try again.", [n.fbt._param("award name", e.name)], {
							hk: "3KNLaD"
						}),
						l = X(u),
						b = a.b.Error;
					try {
						(await Object(m.h)(d(), e.id, t.id)).ok && (l = Q({
							awardId: e.id,
							subredditId: t.id
						}), u = n.fbt._("{award name} Award successfully disabled in {subreddit or profile prefixed name}!", [n.fbt._param("award name", e.name), n.fbt._param("subreddit or profile prefixed name", t.displayText)], {
							hk: "26i191"
						}), b = a.b.SuccessCommunity)
					} catch (p) {
						i.c.captureException(p)
					} finally {
						await r(l), await r(Object(c.e)({
							text: u,
							duration: c.a,
							kind: b
						}))
					}
				}, z = Object(s.a)(_.l), Q = Object(s.a)(_.m), X = Object(s.a)(_.k), Z = (t, e) => async (r, s, o) => {
					let {
						gqlContext: d
					} = o;
					r($());
					let u = n.fbt._("There was a problem enabling the {award name} Award. Please try again.", [n.fbt._param("award name", e.name)], {
							hk: "2jdxBY"
						}),
						l = et(u),
						b = a.b.Error;
					try {
						(await Object(m.i)(d(), e.id, t.id)).ok && (l = tt({
							awardId: e.id,
							subredditId: t.id
						}), u = n.fbt._("{award name} Award successfully enabled in {subreddit name}!", [n.fbt._param("award name", e.name), n.fbt._param("subreddit name", "r/" + t.name)], {
							hk: "zGXlU"
						}), b = a.b.SuccessCommunity)
					} catch (p) {
						i.c.captureException(p)
					} finally {
						await r(l), await r(Object(c.e)({
							text: u,
							duration: c.a,
							kind: b
						}))
					}
				}, $ = Object(s.a)(_.o), tt = Object(s.a)(_.p), et = Object(s.a)(_.n)
		},
		"./src/reddit/actions/gold/modals.ts": function(t, e, r) {
			"use strict";
			r.d(e, "e", (function() {
				return f
			})), r.d(e, "b", (function() {
				return g
			})), r.d(e, "d", (function() {
				return E
			})), r.d(e, "c", (function() {
				return S
			})), r.d(e, "a", (function() {
				return T
			})), r.d(e, "f", (function() {
				return h
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/lib/postParentMessage/index.ts"),
				i = r("./src/reddit/helpers/isPost.ts"),
				o = r("./src/reddit/constants/modals.ts"),
				d = r("./src/reddit/selectors/gild.ts"),
				c = r("./src/reddit/helpers/correlationIdTracker.ts"),
				a = r("./src/reddit/actions/gold/communityAwards.ts"),
				u = r("./src/reddit/actions/modal.ts"),
				l = r("./src/reddit/selectors/communityAwards.ts"),
				b = r("./src/reddit/selectors/posts.ts"),
				p = r("./src/reddit/selectors/subreddit.ts"),
				O = r("./src/telemetry/index.ts"),
				m = r("./src/reddit/actions/gold/constants.ts");
			const f = Object(n.a)(m.N),
				_ = Object(n.a)(m.g),
				g = () => async (t, e) => {
					const n = e();
					t(_()), Object(c.b)(c.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: s
					} = await r.e("givePremiumTrackers").then(r.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(O.a)(s()(n))
				}, j = Object(n.a)(m.M), E = t => {
					let {
						awardId: e,
						correlationId: r,
						thingId: n
					} = t;
					return async (t, s) => {
						const d = s(),
							c = e ? Object(l.a)(d, e) : void 0;
						t(j({
							award: c && c.isEnabled ? c : void 0,
							thingId: n,
							correlationId: r
						})), t(Object(u.h)(o.a.GOLD_GILD_MODAL));
						const O = Object(p.K)(d, {
							thingId: n
						});
						let m = null;
						if (O) m = O.id;
						else if (Object(i.a)(n)) {
							const t = Object(b.N)(d, {
								postId: n
							});
							t && (m = t.belongsTo.id)
						}
						m && Object(a.a)(m, n)
					}
				}, y = Object(n.a)(m.f), S = Object(n.a)(m.L), T = () => async (t, e) => {
					const n = e(),
						i = Object(d.d)(n);
					if (Object(d.h)(n)) {
						const t = "close.gild";
						Object(s.a)({
							type: t
						})
					}
					t(y()), t(Object(u.g)(o.a.GOLD_GILD_MODAL));
					const {
						clickCloseGildModalEvent: a
					} = await Promise.resolve().then(r.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(O.a)(a(i)(n)), Object(c.b)(c.a.GildingFlow)
				}, h = () => async () => {
					Object(s.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/gold/powerups.ts": function(t, e, r) {
			"use strict";
			r.d(e, "g", (function() {
				return T
			})), r.d(e, "e", (function() {
				return x
			})), r.d(e, "f", (function() {
				return N
			})), r.d(e, "d", (function() {
				return K
			})), r.d(e, "a", (function() {
				return H
			})), r.d(e, "c", (function() {
				return Y
			})), r.d(e, "b", (function() {
				return V
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/sentry/index.ts"),
				o = r("./src/reddit/constants/modals.ts"),
				d = r("./src/reddit/helpers/localStorage/index.ts"),
				c = r("./src/reddit/actions/login.ts"),
				a = r("./src/reddit/actions/modal.ts"),
				u = r("./src/reddit/actions/toaster.ts"),
				l = r("./src/reddit/models/Toast/index.ts"),
				b = r("./src/graphql/operations/ReallocatePowerups.json"),
				p = r("./src/graphql/operations/RedditorPowerups.json"),
				O = r("./src/graphql/operations/SubredditPowerups.json"),
				m = r("./src/graphql/operations/SubredditPowerupsFull.json"),
				f = r("./src/graphql/operations/UserPowerups.json"),
				_ = r("./src/lib/makeGqlRequest/index.ts");
			const g = (t, e) => Object(_.a)(t, Object.assign(Object.assign({}, O), {
					variables: {
						subredditId: e
					}
				})),
				j = (t, e) => Object(_.a)(t, Object.assign(Object.assign({}, m), {
					variables: {
						subredditId: e
					}
				}));
			var E = r("./src/reddit/selectors/gold/powerups.ts"),
				y = r("./src/reddit/selectors/user.ts"),
				S = r("./src/reddit/actions/gold/constants.ts");
			const T = t => async (e, r, s) => {
				let {
					gqlContext: o
				} = s;
				if (!!r().user.powerups.fetched && !t) return;
				e(h());
				const d = n.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const t = await (t => Object(_.a)(t, f))(o());
					if (t.ok) {
						const r = t.body;
						if (r.errors && r.errors.length) return void(await e(A(d)));
						if (!r.data.identity) return void(await e(C(d)));
						await e(I({
							powerups: r.data.identity.powerups
						}))
					}
				} catch (c) {
					i.c.captureException(c), await e(A(d))
				}
			}, h = Object(s.a)(S.xb), I = Object(s.a)(S.wb), C = Object(s.a)(S.vb), A = t => async (e, r) => {
				await e(C(t)), e(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: t
				}))
			}, x = (t, e) => async (t, r, s) => {
				let {
					gqlContext: o
				} = s;
				var d;
				if (!!r().users.powerups.fetched) return;
				t(D());
				const c = n.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const r = await ((t, e) => Object(_.a)(t, Object.assign({
						variables: {
							id: e
						}
					}, p)))(o(), e);
					if (r.ok) {
						const n = r.body;
						if (n.errors && n.errors.length) return void(await t(P(c)));
						if (!n.data.redditorInfoById) return void(await t(R(c)));
						const s = (null === (d = n.data.redditorInfoById.powerups) || void 0 === d ? void 0 : d.supportedSubreddits) || [];
						await t(w({
							supportedSubreddits: s,
							userId: e
						}))
					}
				} catch (a) {
					i.c.captureException(a), await t(P(c))
				}
			}, D = Object(s.a)(S.cb), w = Object(s.a)(S.bb), R = Object(s.a)(S.ab), P = t => async (e, r) => {
				await e(R(t)), e(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: t
				}))
			}, N = (t, e) => async (r, s, o) => {
				let {
					gqlContext: d
				} = o;
				var c;
				const a = s();
				if (Object(E.f)(a, {
						subredditId: t
					}) && (!e.fullData || Object(E.g)(a, {
						subredditId: t
					})) && !e.forceLoad) return;
				r(k());
				const u = e.fullData ? j : g;
				try {
					const n = await u(d(), t);
					if (n.ok) {
						const s = n.body;
						if (null === (c = s.errors) || void 0 === c ? void 0 : c.length) return void(await r(M(s.errors[0].message)));
						if (e.fullData) {
							const {
								powerups: e = null,
								supporters: n = null
							} = s.data.subredditInfoById || {};
							await r(U({
								powerups: e,
								recentSupporters: n ? n.recentSupporters : [],
								subredditId: t,
								topSupporters: n ? n.topSupporters : []
							}))
						} else {
							const {
								powerups: e = null
							} = s.data.subredditInfoById || {};
							await r(v({
								powerups: e,
								subredditId: t
							}))
						}
					}
				} catch (l) {
					i.c.captureException(l), await r(M(n.fbt._("Something went wrong", null, {
						hk: "1IJNeH"
					})))
				}
			}, k = Object(s.a)(S.mb), v = Object(s.a)(S.lb), U = Object(s.a)(S.kb), L = Object(s.a)(S.jb), M = t => async (e, r) => {
				await e(L(t)), e(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: t
				}))
			}, G = Object(s.a)(S.U), F = Object(s.a)(S.V), q = Object(s.a)(S.W), B = t => async (e, r) => {
				await e(G(t)), e(Object(u.e)({
					kind: l.b.Error,
					duration: u.a,
					text: t
				}))
			}, K = (t, e, r, s) => async (d, c, p) => {
				let {
					gqlContext: O
				} = p;
				d(F({
					subredditId: t,
					powerupsCount: e,
					isAnonymous: r,
					allocatedAt: s
				}));
				try {
					const i = {
							subredditId: t,
							powerupsCount: e,
							isAnonymous: r
						},
						p = await ((t, e) => Object(_.a)(t, Object.assign(Object.assign({}, b), {
							variables: e
						})))(O(), {
							input: i
						});
					let m = !1,
						f = null;
					if (p.ok) {
						const t = p.body;
						m = t.data.reallocatePowerups.ok, f = t.data.reallocatePowerups.errors
					}
					const g = Object(y.i)(c());
					if (m && g) await d((t => async (e, r) => {
						e(q(t)), e(N(t.subredditId, {
							forceLoad: !0
						})), t.powerupsCount && (e(Object(a.g)(o.a.ECON_POWERUPS_PURCHASE)), e(Object(u.e)({
							kind: l.b.SuccessCommunityGreen,
							duration: u.a,
							text: n.fbt._("Your free Powerup is applied.", null, {
								hk: "3WY7KP"
							})
						})))
					})({
						subredditId: t,
						powerupsCount: e,
						isAnonymous: r,
						user: g,
						allocatedAt: s
					}));
					else {
						const t = f && f[0] && f[0].message || n.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
						await d(B(t))
					}
				} catch (m) {
					i.c.captureException(m);
					const t = m,
						e = t && t.message || n.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
					await d(B(e))
				}
			}, H = Object(s.a)(S.H), Y = Object(s.a)(S.S), V = () => async (t, e) => Object(y.i)(e()) ? Object(d.s)(o.a.ECON_POWERUPS_MARKETING) ? t(Object(a.h)(o.a.ECON_POWERUPS_PURCHASE)) : t(Object(a.h)(o.a.ECON_POWERUPS_MARKETING)) : t(Object(c.h)())
		},
		"./src/reddit/actions/gold/productOffers.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return m
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/toaster.ts"),
				o = r("./src/reddit/models/Toast/index.ts"),
				d = r("./src/graphql/operations/ProductOffers.json"),
				c = r("./src/lib/makeGqlRequest/index.ts");
			var a = r("./src/reddit/selectors/gold/productOffers.ts"),
				u = r("./src/reddit/actions/gold/constants.ts");
			const l = Object(s.a)(u.Z),
				b = Object(s.a)(u.Y),
				p = Object(s.a)(u.X),
				O = t => async (e, r) => {
					await e(p(t)), e(Object(i.e)({
						kind: o.b.Error,
						duration: i.a,
						text: t
					}))
				}, m = (t, e) => async (r, s, i) => {
					let {
						gqlContext: o
					} = i;
					const u = s();
					if (!Object(a.c)(u, {
							subredditId: t,
							type: e
						})) {
						r(l());
						try {
							const n = await ((t, e, r, n) => Object(c.a)(t, Object.assign(Object.assign({}, d), {
								variables: {
									subredditId: e,
									types: r,
									includeGlobal: n
								}
							})))(o(), t, [e], !0);
							if (n.ok) {
								const s = n.body;
								if (s.errors && s.errors.length) return void(await r(O(s.errors[0].message)));
								const i = s.data.subredditInfoById.productOffers ? s.data.subredditInfoById.productOffers.offers : [];
								return void(await r(b({
									productOffers: i || [],
									subredditId: t,
									type: e
								})))
							}
						} catch (p) {
							await r(O(n.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})))
						}
					}
				}
		},
		"./src/reddit/actions/imageOCRAltText/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "a", (function() {
				return s
			}));
			const n = "IMAGE_OCR_ALT_TEXT__LOADED",
				s = "IMAGE_OCR_ALT_TEXT__FAILED"
		},
		"./src/reddit/actions/jsApi.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return s
			})), r.d(e, "b", (function() {
				return i
			}));
			var n = r("./src/lib/makeActionCreator/index.ts");
			const s = "JSAPI__CONSUMER_SUBSCRIBED",
				i = Object(n.a)(s)
		},
		"./src/reddit/actions/linkedPosts/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "a", (function() {
				return s
			}));
			const n = "LINKED_POSTS__POSTS_LOADED",
				s = "LINKED_POSTS__POSTS_FAILED"
		},
		"./src/reddit/actions/oldSiteRules.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return c
			})), r.d(e, "b", (function() {
				return u
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeApiRequest/index.ts"),
				o = r("./src/lib/omitHeaders/index.ts"),
				d = r("./src/reddit/constants/headers.ts");
			const c = "OLD_SITE_RULES_LOADED",
				a = Object(n.a)(c),
				u = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const c = await (t => Object(i.a)(Object(o.a)(t, [d.a]), {
						endpoint: "".concat(t.apiUrl, "/api/site_rules.json"),
						method: s.db.GET
					}))(n());
					if (c.ok) {
						const {
							site_rules: e
						} = c.body;
						t(a({
							oldSiteRules: e
						}))
					}
				}
		},
		"./src/reddit/actions/pages/search.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return h
			})), r.d(e, "c", (function() {
				return I
			})), r.d(e, "a", (function() {
				return C
			})), r.d(e, "d", (function() {
				return R
			})), r.d(e, "e", (function() {
				return P
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/pick.js"),
				i = r.n(s),
				o = r("./src/lib/constants/index.ts"),
				d = r("./src/lib/makeActionCreator/index.ts"),
				c = r("./src/lib/makeSearchKey/index.ts"),
				a = r("./src/lib/pageTitle.ts"),
				u = r("./src/reddit/actions/ads/index.ts"),
				l = r("./src/reddit/actions/category/index.ts"),
				b = r("./src/reddit/actions/communityFlairs/index.ts"),
				p = r("./src/reddit/actions/discoveryUnit.ts"),
				O = r("./src/reddit/actions/platform.ts"),
				m = r("./src/reddit/actions/search.ts"),
				f = r("./src/reddit/actions/toaster.ts"),
				_ = r("./src/reddit/constants/parameters.ts"),
				g = r("./src/reddit/endpoints/page/search.ts"),
				j = r("./src/reddit/helpers/timeApiRoute/index.ts"),
				E = r("./src/reddit/models/DiscoveryUnit/index.ts"),
				y = r("./src/reddit/models/Toast/index.ts"),
				S = r("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				T = r("./src/reddit/selectors/subreddit.ts");
			const h = "SEARCH__SEARCH_PENDING",
				I = "SEARCH__SEARCH_RESULTS_RECEIVED",
				C = "SEARCH__SEARCH_FAILED",
				A = Object(d.a)(h),
				x = Object(d.a)(I),
				D = Object(d.a)(C),
				w = t => n.fbt._("reddit.com: search results - {query}", [n.fbt._param("query", t || "None")], {
					hk: "1XOKAg"
				}),
				R = (t, e, r, s) => async (i, d, c) => {
					let {
						apiContext: a
					} = c;
					const O = d(),
						h = e[_.c],
						I = e.category;
					(h || I) && (await Promise.all([i(p.g()), i(l.a())]), I && await Promise.all([i(l.b(I, 10)), i(p.h(E.g, I))]));
					const {
						q: C
					} = e, w = !!C && o.Cb.some(t => C.includes("".concat(t, ":")));
					let P = e.type.indexOf(o.Nb.Posts) > -1 || !(!r || !e.restrict_sr) || w;
					if (P) {
						const e = O.listings.postOrder.ids[t],
							r = O.listings.postOrder.api.error[t];
						P = !(O.listings.postOrder.api.pending[t] || e && !r)
					}
					let N = e.type.indexOf(o.Nb.Subreddits) > -1 || e.type.indexOf(o.Nb.Users) > -1;
					if (N) {
						const e = O.listings.listingOrder.identifiers[t],
							r = O.listings.listingOrder.api.error[t];
						N = !(O.listings.listingOrder.api.pending[t] || e && !r)
					}
					if (!P && !N) return void(O.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						i(Object(u.b)(S.a.SEARCH_RESULTS))
					}));
					e.q && i(Object(m.h)(e.q));
					const k = "error-".concat(t),
						{
							type: v
						} = e;
					i(A({
						key: t,
						type: v
					}));
					const U = await Object(j.a)("searchResults", () => Object(g.a)(a(), r, s, Object.assign(Object.assign({}, e), {
						type: (e.type || []).join(","),
						b: !w
					})));
					if (U.ok) {
						const n = {
								key: t,
								type: v,
								meta: O.meta,
								searchQuery: e.q,
								subredditName: r,
								username: s
							},
							o = U.body;
						if (i(x(Object.assign(Object.assign({
								categoryName: h
							}, n), o))), i(f.f(k)), i(Object(u.b)(S.a.SEARCH_RESULTS)), r) {
							const t = Object(T.G)(d(), r),
								e = Object(b.c)(o.posts, t),
								n = Object(b.b)(o.structuredStyles || {}),
								s = (n ? Object(b.d)(n) : []).concat(e);
							i(Object(b.a)(s, t))
						}
					} else i(D(Object.assign({
						key: t,
						error: U.error,
						type: v
					}, U.body))), i(f.e({
						id: k,
						kind: y.b.Error,
						text: n.fbt._("Sorry, we couldn't load search results.", null, {
							hk: "QgweL"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "jld4g"
						}),
						buttonAction: R(t, e, r, s)
					}))
				}, P = t => async (e, r, n) => {
					const s = Object(c.c)(i()(t.queryParams, _.t)),
						d = t.params.subredditName || t.params.multiredditName,
						{
							username: u
						} = t.params,
						l = Object(c.b)(d, u, s);
					await e(R(l, s, d, u));
					const b = r();
					let p = !1;
					const {
						type: m = []
					} = s, f = m.indexOf(o.Nb.Posts) > -1, g = m.indexOf(o.Nb.Subreddits) > -1 || m.indexOf(o.Nb.Users) > -1;
					f && b.listings.postOrder.api.error[l] && (p = !0), g && b.listings.listingOrder.api.error[l] && (p = !0), e(p ? O.l({
						title: Object(a.c)()
					}) : O.l({
						title: w(s.q)
					}))
				}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(t, e, r) {
			"use strict";
			r.d(e, "f", (function() {
				return jt
			})), r.d(e, "d", (function() {
				return Et
			})), r.d(e, "c", (function() {
				return yt
			})), r.d(e, "a", (function() {
				return St
			})), r.d(e, "k", (function() {
				return Tt
			})), r.d(e, "i", (function() {
				return Ct
			})), r.d(e, "e", (function() {
				return xt
			})), r.d(e, "g", (function() {
				return Dt
			})), r.d(e, "h", (function() {
				return wt
			})), r.d(e, "l", (function() {
				return Rt
			})), r.d(e, "b", (function() {
				return Pt
			})), r.d(e, "j", (function() {
				return Nt
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js"), r("./node_modules/core-js/modules/es6.array.sort.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/pick.js"),
				i = r.n(s),
				o = r("./node_modules/lodash/some.js"),
				d = r.n(o),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/isAdHocMultireddit/index.ts"),
				u = r("./src/lib/isFakeSubreddit/index.ts"),
				l = r("./src/lib/makeActionCreator/index.ts"),
				b = r("./src/lib/makeListingKey/index.ts"),
				p = r("./src/lib/makeSearchKey/index.ts"),
				O = r("./src/reddit/actions/ads/index.ts"),
				m = r("./src/reddit/actions/communityFlairs/index.ts"),
				f = r("./src/reddit/actions/contentGate.ts"),
				_ = r("./src/reddit/actions/discoveryUnit.ts"),
				g = r("./src/reddit/actions/economics/helpers/async.ts"),
				j = r("./src/reddit/actions/externalAccount.ts"),
				E = r("./src/reddit/actions/gold/powerups.ts"),
				y = r("./src/reddit/actions/gold/productOffers.ts"),
				S = r("./src/reddit/actions/pages/search.ts"),
				T = r("./src/reddit/actions/platform.ts"),
				h = r("./src/reddit/actions/seo/linksModule.ts"),
				I = r("./src/reddit/actions/structuredStyles/index.ts"),
				C = r("./src/reddit/actions/subreddit.ts"),
				A = (r("./node_modules/core-js/modules/es6.regexp.to-string.js"), r("./node_modules/react-router-redux/es/index.js")),
				x = r("./src/reddit/actions/toaster.ts"),
				D = r("./src/reddit/helpers/localStorage/index.ts"),
				w = r("./src/reddit/models/Subreddit/index.ts"),
				R = r("./src/reddit/models/Toast/index.ts"),
				P = r("./src/reddit/routes/postCreation/constants.ts"),
				N = r("./src/reddit/selectors/moderatorPermissions.ts"),
				k = r("./src/reddit/selectors/platform.ts"),
				v = r("./src/reddit/selectors/subreddit.ts"),
				U = r("./src/reddit/selectors/user.ts"),
				L = r("./src/reddit/selectors/widgets.ts");
			const M = () => async (t, e, r) => {
				const n = e(),
					s = Object(k.f)(n);
				if (!s || s.type !== w.e.Public) return;
				const i = s.name,
					o = Object(k.m)(n),
					d = Object(v.y)(n, {
						subredditName: i
					});
				if (!d) return;
				const {
					activity7Day: c
				} = d, a = !!c && c >= 51 && c <= 100, l = !i || Object(u.a)(i), b = o && o.urlParams.subredditName === i, p = Object(U.I)(n), O = Object(N.g)(n, {
					subredditId: Object(v.G)(n, i)
				});
				if (l || b || Object(D.q)() || !a || !p || O) return;
				const m = Object(L.d)(e(), {
					subredditName: i
				});
				if (!m || !m.currentlyViewingCount) return;
				const f = (24 * m.currentlyViewingCount * 7).toString(),
					_ = f[0].padEnd(f.length, "0");
				t(Object(x.e)({
					buttonAction: async () => t(Object(A.b)("/r/".concat(i).concat(P.b))),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: R.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(D.ab)(),
					secondButtonText: "Dismiss",
					text: "There have been over ".concat(_, " visits to r/").concat(i, " in the past week. Create a new post and start the next conversation.")
				}))
			};
			var G = r("./src/reddit/actions/subreddit/questions.ts"),
				F = r("./src/reddit/actions/subredditSettings.ts"),
				q = r("./src/reddit/actions/tags/index.ts"),
				B = r("./src/reddit/constants/page.ts"),
				K = r("./src/reddit/constants/parameters.ts"),
				H = r("./src/reddit/constants/postLayout.ts"),
				Y = r("./src/reddit/contexts/PageLayer/index.tsx"),
				V = r("./src/reddit/endpoints/gold/topAwarded.ts"),
				W = r("./src/reddit/endpoints/governance/posts.ts"),
				J = r("./src/reddit/endpoints/page/subredditPage.ts"),
				z = r("./src/reddit/endpoints/profile/info.ts"),
				Q = r("./src/reddit/helpers/canonicalUrls.ts"),
				X = r("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				Z = r("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				$ = r("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts");

			function tt(t) {
				let {
					econLeaderboards: e,
					identity: r,
					trendingSubreddits: n
				} = t;
				const s = e.topAwardedPosts.map(t => t.post).filter(t => !t.removedBy && !t.isNsfw);
				return Object($.b)(s, n, r)
			}
			var et = r("./src/reddit/helpers/timeApiRoute/index.ts"),
				rt = r("./src/reddit/helpers/trackers/communityTopics.ts"),
				nt = r("./src/reddit/models/Gold/ProductOffer.ts"),
				st = r("./src/reddit/models/ModeratingSubreddits/index.ts"),
				it = r("./src/reddit/models/RichTextJson/index.ts"),
				ot = r("./src/reddit/models/User/index.ts"),
				dt = r("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				ct = r("./src/reddit/selectors/communityFlairs.ts"),
				at = r("./src/reddit/selectors/experiments/goldSubredditPowerups.ts"),
				ut = r("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				lt = r("./node_modules/reselect/es/index.js"),
				bt = r("./src/reddit/constants/experiments.ts"),
				pt = r("./src/reddit/helpers/chooseVariant/index.ts");
			const Ot = Object(lt.a)(t => {
				return !!Object(pt.c)(t, {
					experimentEligibilitySelector: pt.a,
					experimentName: bt.qb,
					expEventOverride: !1
				})
			}, U.I, v.S, L.j, (t, e, r, n) => t && !e && !r.isNSFW && !n.some(t => "community-list" === t));
			var mt = r("./src/reddit/selectors/experiments/topPosts.ts"),
				ft = r("./src/reddit/selectors/inlineSubredditEditing.ts"),
				_t = r("./src/reddit/selectors/multireddit.ts"),
				gt = (r("./src/reddit/selectors/posts.ts"), r("./src/reddit/actions/publicAccessNetwork/api.ts"));
			const jt = (t, e) => async r => {
				if (!t.ok && t.body && (t => !!t.reason)(t.body)) {
					const {
						body: {
							data: n,
							reason: s
						}
					} = t, i = n ? n.account : void 0, o = n && n.features || void 0, d = e ? e.toLowerCase() : "";
					if (404 === t.status)
						if (s === w.d.NotFoundSubreddit) r(f.o({
							account: i,
							features: o,
							subredditName: d
						}));
						else if (s === w.d.BannedSubreddit) {
						const t = n ? n.banMessage || n.ban_message : void 0;
						r(f.m({
							banMessage: t,
							account: i,
							features: o,
							subredditName: d
						}))
					}
					if (451 === t.status && r(f.n({
							account: i,
							features: o,
							subredditName: d
						})), 403 === t.status)
						if (s === w.d.GoldSubreddit) r(f.q({
							account: i,
							features: o,
							subredditName: d
						}));
						else if (s === w.d.PrivateSubreddit) r(f.r({
						account: i,
						features: o,
						subredditDescription: n.description || "",
						subredditName: d
					}));
					else if (s === w.d.QuarantinedSubreddit) {
						const t = !n || void 0 === n.quarantineRequiresEmailOptin || n.quarantineRequiresEmailOptin;
						r(f.t({
							account: i,
							features: o,
							subredditName: d,
							quarantineRequiresEmail: t,
							quarantineMessage: n.quarantineMessage,
							quarantineMessageHtml: n.quarantineMessageHtml || "",
							quarantineMessageRTJson: n.quarantineMessageRTJson || it.i
						}))
					}
				}
			}, Et = "PAGE__SUBREDDIT_PENDING", yt = "PAGE__SUBREDDIT_LOADED", St = "PAGE__SUBREDDIT_FAILED", Tt = Object(l.a)(Et), ht = Object(l.a)(yt), It = Object(l.a)(St), Ct = (t, e, r, s) => async (i, o, a) => {
				var l;
				const b = o(),
					p = Object(U.I)(b),
					f = b.listings.postOrder.api.pending[t],
					_ = Object(U.i)(b);
				if (f) return;
				const S = e !== B.c.All && e !== B.c.Popular || !b.posts.recent.length ? r : Object.assign(Object.assign({}, r), {
					recentPostIds: b.posts.recent
				});
				S.layout = H.e[Object(Y.N)(b, {})], i(Tt({
					key: t
				}));
				const I = Object(ut.b)(b);
				let A;
				if (r.sort === c.O.AWARDED && e === B.c.Popular) A = Object(V.a)(a.gqlContext(), {
					top: 0,
					includeListingMetadata: !0
				}).then(t => {
					const e = t.body;
					return Object.assign(Object.assign({}, t), {
						body: tt(e.data)
					})
				});
				else {
					const t = I ? () => Object(J.b)(a.gqlContext(), Object(J.c)(b, e, S), p) : () => Object(J.a)(a.apiContext(), e, S);
					A = Object(et.a)("subreddit", t)
				}
				const D = p && _ && !I ? Object(z.d)(a.gqlContext(), Object(ot.e)(_)) : null,
					[w, P] = await Promise.all([A, D]),
					N = w.body;
				i(T.m(w.status));
				const k = "error-".concat(t),
					L = Object(u.a)(e) || d()(N.subreddits, t => t.name.toLowerCase() === e.toLowerCase());
				if (w.ok && L) {
					if (!Object(u.a)(e) && Object(at.a)(b)) {
						const t = Object.keys(N.subredditAboutInfo)[0];
						await Promise.all([i(Object(E.g)()), i(Object(E.f)(t, {
							fullData: !0
						})), i(Object(y.a)(t, nt.a.Powerups))])
					}
					let r;
					const n = N.postIds.filter(t => !!N.posts[t].isMeta);
					if (n.length) {
						const t = Object.keys(N.subreddits).reduce((t, r) => {
							const n = N.subreddits[r];
							return n.name.toLowerCase() === e.toLowerCase() ? n.id : t
						}, null);
						if (t) {
							const e = await Object(W.a)(a.apiContext(), t, n);
							e.ok && (r = e.body)
						}
					}
					if (P && P.ok) {
						const t = null === (l = P.body.data.redditorInfoByName) || void 0 === l ? void 0 : l.karma,
							e = t ? {
								awardeeKarma: t.fromAwardsReceived,
								awarderKarma: t.fromAwardsGiven,
								commentKarma: t.fromComments,
								postKarma: t.fromPosts,
								totalKarma: t.total
							} : z.a;
						N.account && Object.assign(N.account, e)
					}
					if (i(ht(Object.assign(Object.assign({
							key: t,
							meta: b.meta,
							governance: r
						}, N), {
							postIds: N.postIds
						}))), !Object(u.a)(e)) {
						const t = Object(v.G)(o(), e);
						!!Object(v.R)(b, {
							subredditId: t
						}) || await C.o(e)(i, o, a);
						const r = Object(m.c)(N.posts, t),
							n = Object(m.b)(N.structuredStyles),
							s = (n ? Object(m.d)(n) : []).concat(r);
						i(Object(m.a)(s, t))
					}
					s && i(x.f(k)), i(Object(O.b)(dt.a.SUBREDDIT)), i(Object(j.p)());
					const d = Object(v.G)(o(), e);
					if (d) {
						const t = [i(Object(g.a)({
							subredditId: d,
							postIds: N.postIds,
							skip: ["subscription"]
						}))];
						I || t.push(i(Object(G.c)(d))), Ot(o(), {
							subredditId: d
						}) && t.push(i(Object(h.d)(d))), Object(ft.a)(o(), {
							subredditId: d
						}) && t.push(i(Object(F.h)(e, d)), i(Object(q.k)(d, rt.a.idCard))), await Promise.all(t)
					}
				} else {
					if (403 === w.status || 404 === w.status || 451 === w.status) return void i(jt(w, e));
					i(It(Object.assign({
						error: !w.ok && w.error || {
							type: c.E.NOT_FOUND_ERROR
						},
						key: t
					}, N))), s && i(x.e({
						id: k,
						kind: R.b.Error,
						text: n.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: Ct(t, e, r, s)
					}))
				}
			}, At = (t, e) => {
				if (Object(u.a)(e)) {
					if (Object(a.a)(e)) {
						return Object(_t.a)(t, {
							listingName: e
						}).displayText
					}
					switch (e.toLowerCase()) {
						case B.c.Popular:
							return "r/popular";
						case B.c.All:
							return "r/all"
					}
				}
				return Object(v.V)(t, {
					subredditName: e
				})
			}, xt = (t, e) => {
				const r = t.f;
				if (r) return {
					[K.p]: r,
					[K.s]: "1",
					[K.i]: e ? "1" : "",
					sort: c.Lb.New
				}
			}, Dt = (t, e) => {
				const r = xt(t, e);
				return r && Object(p.c)(r)
			}, wt = (t, e, r, n) => n ? Object(p.b)(t, void 0, n) : Object(b.a)(t, e, r), Rt = (t, e) => async (r, n, s) => {
				const {
					subredditName: o
				} = t.params, {
					styling: d
				} = t.queryParams, a = n(), l = Object(X.a)(t.params, a), p = Dt(t.queryParams, Object(U.Y)(a)), f = wt(o, l, t.queryParams, p), g = l, E = a.listings.postOrder.api.error[f], y = a.listings.postOrder.api.pending[f];
				let h = !!a.listings.postOrder.ids[f];
				const C = a.listings.postOrder.listingSort[f];
				C && C.hasChanged && (h = !1);
				let A = Object(v.G)(a, o);
				const x = (t, e) => "true" === d && ((t, e) => Object(N.a)(st.c.config)(t, {
						subredditId: e
					}) || Object(N.a)(st.c.flair)(t, {
						subredditId: e
					}))(t, e),
					D = K.x in t.queryParams && t.queryParams[K.x].toUpperCase() || "",
					w = D in c.Sb && c.Sb[D];
				if (y || h && !E && !e) {
					if (x(a, A) && r(I.i(A)), h) {
						const e = At(n(), o);
						r(T.l({
							title: e
						})), Object(Q.e)(n(), r, t), window.addEventListener("load", () => {
							r(Object(j.p)())
						}), a.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							r(Object(O.b)(dt.a.SUBREDDIT))
						}), r(M())
					}
					return
				}
				r(_.g());
				const R = r(Object(gt.c)("r/".concat(o)));
				if (p) await r(Object(S.d)(f, p, o));
				else {
					const e = Object.assign(Object.assign({}, i()(t.queryParams, [...K.l, ...K.k, K.h])), {
							sort: g,
							t: Object(Z.a)(g, w)
						}),
						n = a.user.prefs.geopopular || a.meta.country;
					!e[K.h] && n && (e[K.h] = n), await r(Ct(f, o, e, !0))
				}
				const P = a.platform.currentPage,
					k = Object(mt.d)(a, {
						pageLayer: P
					});
				if (Object(mt.a)(k) || Object(mt.b)(k) || Object(mt.c)(k)) {
					const t = Object(b.a)(o, c.O.TOP, {
							t: c.Sb.WEEK
						}),
						e = {
							sort: c.O.TOP,
							t: c.Sb.WEEK
						};
					await r(Ct(t, o, e, !1))
				}
				A = A || Object(v.G)(n(), o), Object(ct.a)(a, A) || Object(u.a)(o) || await r(Object(m.e)(o)), x(n(), A) && r(I.i(A)), Object(Q.e)(n(), r, t);
				const L = At(n(), o);
				r(T.l({
					title: L
				})), r(M()), await R
			}, Pt = "PAGE__SUBREDDIT_INVALIDATE_LISTING", Nt = Object(l.a)(Pt)
		},
		"./src/reddit/actions/pinnedPost.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return p
			})), r.d(e, "h", (function() {
				return O
			})), r.d(e, "d", (function() {
				return m
			})), r.d(e, "g", (function() {
				return f
			})), r.d(e, "c", (function() {
				return j
			})), r.d(e, "f", (function() {
				return E
			})), r.d(e, "b", (function() {
				return T
			})), r.d(e, "e", (function() {
				return h
			})), r.d(e, "i", (function() {
				return P
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeActionCreator/index.ts"),
				o = r("./src/reddit/actions/modal.ts"),
				d = r("./src/reddit/actions/toaster.ts"),
				c = r("./src/reddit/constants/modals.ts"),
				a = r("./src/reddit/endpoints/post/index.tsx"),
				u = r("./src/reddit/models/Toast/index.ts"),
				l = r("./src/reddit/selectors/posts.ts"),
				b = r("./src/reddit/selectors/profile.ts");
			const p = "PINNEDPOST__PINNED_POSTS_LOADED",
				O = Object(i.a)(p),
				m = "PINNEDPOST__PIN_POST_SUCCESS",
				f = "PINNEDPOST__UNPIN_POST_SUCCESS",
				_ = Object(i.a)(m),
				g = Object(i.a)(f),
				j = "PINNEDPOST__PIN_POST_PENDING",
				E = "PINNEDPOST__UNPIN_POST_PENDING",
				y = Object(i.a)(j),
				S = Object(i.a)(E),
				T = "PINNEDPOST__PIN_POST_FAILURE",
				h = "PINNEDPOST__UNPIN_POST_FAILURE",
				I = Object(i.a)(T),
				C = Object(i.a)(h),
				A = t => Object(d.e)({
					buttonAction: P(t, !0),
					buttonText: n.fbt._("UNDO", null, {
						hk: "1O9LWh"
					}),
					kind: u.b.SuccessMod,
					text: n.fbt._("Post pinned to profile!", null, {
						hk: "1hbHLt"
					})
				}),
				x = (t, e) => Object(d.e)({
					buttonAction: P(t, !0),
					buttonText: n.fbt._("UNDO", null, {
						hk: "3YtcK2"
					}),
					kind: u.b.SuccessMod,
					text: e ? n.fbt._("Post unpinned, reload to see changes", null, {
						hk: "5FF1g"
					}) : n.fbt._("Post unpinned.", null, {
						hk: "2BgT0h"
					})
				}),
				D = () => Object(d.e)({
					kind: u.b.Error,
					text: n.fbt._("Could not pin post", null, {
						hk: "3uNHEh"
					})
				}),
				w = () => Object(d.e)({
					kind: u.b.Error,
					text: n.fbt._("You can't pin a removed post", null, {
						hk: "3bdn2y"
					})
				}),
				R = () => Object(d.e)({
					kind: u.b.Error,
					text: n.fbt._("Could not unpin post", null, {
						hk: "o8HG0"
					})
				}),
				P = function(t) {
					let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (r, n, i) => {
						let {
							apiContext: d
						} = i;
						const u = n(),
							p = u.posts.models[t];
						if (!p) return;
						const O = !Object(l.w)(u, {
							postId: t
						});
						if (O && p.isRemoved) return r(w());
						const m = p.author,
							f = Object(b.m)(u, m),
							[j, E, T, h, P] = O ? [y, _, I, A, D] : [S, g, C, x, R];
						if (O) {
							if (Object(l.V)(u, {
									profileName: m
								}).length >= s.V) return void r(Object(o.i)(c.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const N = Object(l.q)(u, t, m),
							k = !O && N;
						r(j({
							postId: t,
							profileId: f
						})), (await Object(a.t)(d(), t, O, !0)).ok ? (r(E({
							postId: t,
							profileId: f
						})), e || r(h(t, k))) : (r(T({
							postId: t,
							profileId: f
						})), r(P()))
					}
				}
		},
		"./src/reddit/actions/postCollection/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return n
			})), r.d(e, "d", (function() {
				return s
			})), r.d(e, "b", (function() {
				return i
			})), r.d(e, "f", (function() {
				return o
			})), r.d(e, "g", (function() {
				return d
			})), r.d(e, "a", (function() {
				return c
			})), r.d(e, "t", (function() {
				return a
			})), r.d(e, "e", (function() {
				return u
			})), r.d(e, "r", (function() {
				return l
			})), r.d(e, "s", (function() {
				return b
			})), r.d(e, "n", (function() {
				return p
			})), r.d(e, "l", (function() {
				return O
			})), r.d(e, "m", (function() {
				return m
			})), r.d(e, "k", (function() {
				return f
			})), r.d(e, "i", (function() {
				return _
			})), r.d(e, "j", (function() {
				return g
			})), r.d(e, "h", (function() {
				return j
			})), r.d(e, "p", (function() {
				return E
			})), r.d(e, "q", (function() {
				return y
			})), r.d(e, "o", (function() {
				return S
			}));
			const n = "CREATE_COLLECTION_PENDING",
				s = "CREATE_COLLECTION_SUCCESS",
				i = "CREATE_COLLECTION_FAILED",
				o = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				d = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				c = "ADD_POST_TO_COLLECTION_SUCCESS",
				a = "UPDATE_POST_WITH_COLLECTION_ID",
				u = "DELETE_COLLECTION_SUCCESS",
				l = "UPDATE_COLLECTION_PENDING",
				b = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				O = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				m = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				f = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				_ = "REORDER_COLLECTION_PENDING",
				g = "REORDER_COLLECTION_SUCCESS",
				j = "REORDER_COLLECTION_FAILED",
				E = "UPDATE_COLLECTION_LAYOUT_PENDING",
				y = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				S = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCreation/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "H", (function() {
				return n
			})), r.d(e, "I", (function() {
				return s
			})), r.d(e, "l", (function() {
				return i
			})), r.d(e, "m", (function() {
				return o
			})), r.d(e, "y", (function() {
				return d
			})), r.d(e, "E", (function() {
				return c
			})), r.d(e, "F", (function() {
				return a
			})), r.d(e, "k", (function() {
				return u
			})), r.d(e, "D", (function() {
				return l
			})), r.d(e, "p", (function() {
				return b
			})), r.d(e, "N", (function() {
				return p
			})), r.d(e, "n", (function() {
				return O
			})), r.d(e, "A", (function() {
				return m
			})), r.d(e, "s", (function() {
				return f
			})), r.d(e, "c", (function() {
				return _
			})), r.d(e, "b", (function() {
				return g
			})), r.d(e, "d", (function() {
				return j
			})), r.d(e, "e", (function() {
				return E
			})), r.d(e, "f", (function() {
				return y
			})), r.d(e, "g", (function() {
				return S
			})), r.d(e, "h", (function() {
				return T
			})), r.d(e, "i", (function() {
				return h
			})), r.d(e, "j", (function() {
				return I
			})), r.d(e, "q", (function() {
				return C
			})), r.d(e, "P", (function() {
				return A
			})), r.d(e, "O", (function() {
				return x
			})), r.d(e, "Q", (function() {
				return D
			})), r.d(e, "R", (function() {
				return w
			})), r.d(e, "S", (function() {
				return R
			})), r.d(e, "T", (function() {
				return P
			})), r.d(e, "U", (function() {
				return N
			})), r.d(e, "V", (function() {
				return k
			})), r.d(e, "W", (function() {
				return v
			})), r.d(e, "r", (function() {
				return U
			})), r.d(e, "B", (function() {
				return L
			})), r.d(e, "w", (function() {
				return M
			})), r.d(e, "u", (function() {
				return G
			})), r.d(e, "v", (function() {
				return F
			})), r.d(e, "t", (function() {
				return q
			})), r.d(e, "x", (function() {
				return B
			})), r.d(e, "M", (function() {
				return K
			})), r.d(e, "o", (function() {
				return H
			})), r.d(e, "z", (function() {
				return Y
			})), r.d(e, "Y", (function() {
				return V
			})), r.d(e, "G", (function() {
				return W
			})), r.d(e, "a", (function() {
				return J
			})), r.d(e, "C", (function() {
				return z
			})), r.d(e, "K", (function() {
				return Q
			})), r.d(e, "L", (function() {
				return X
			})), r.d(e, "J", (function() {
				return Z
			})), r.d(e, "X", (function() {
				return $
			}));
			const n = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				s = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				i = "POST_CREATION_EDIT_COMPLETE",
				o = "POST_CREATION_EDIT_FAILED",
				d = "POST_CREATION_PENDING_EDIT",
				c = "POST_CREATION_START_EDITING_POST",
				a = "POST_CREATION_STOP_EDITING_POST",
				u = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				l = "STARTED_CONVERTING_EDITOR_CONTENT",
				b = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				O = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				m = "POST_TITLE_FETCHED",
				f = "INITIALIZE_EDITOR_MODE",
				_ = "POST_CREATION__CHANGE_FLAIR",
				g = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				j = "POST_CREATION__CHANGE_LINK_BODY",
				E = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				y = "POST_CREATION__CHANGE_MEDIA_BODY",
				S = "POST_CREATION__CHANGE_RECAPTCHA",
				T = "POST_CREATION__CHANGE_RTE_STATE",
				h = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				I = "POST_CREATION__CHANGE_TITLE",
				C = "POST_CREATION__GOV_TYPE_CHANGED",
				A = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				x = "POST_CREATION__TOGGLE_IS_CHANGED",
				D = "POST_CREATION__TOGGLE_IS_GOV",
				w = "POST_CREATION__TOGGLE_IS_NSFW",
				R = "POST_CREATION__TOGGLE_IS_OC",
				P = "POST_CREATION__TOGGLE_IS_POLL",
				N = "POST_CREATION__TOGGLE_IS_SPOILER",
				k = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				v = "POST_CREATION__TOGGLE_SEND_REPLIES",
				U = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				L = "POST_CREATION__RESET_FORM",
				M = "POST_CREATION__MODAL_TOGGLED",
				G = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				F = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				q = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				B = "POST_CREATION__PENDING",
				K = "POST_CREATION__SUCCEEDED",
				H = "POST_CREATION__FAILED",
				Y = "POST_CREATION__POLL_FAILED",
				V = "POST_CREATION__VALIDATION_FAILED",
				W = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				J = "POST_CREATION__CAPTCHA_REQUIRED",
				z = "POST_CREATION__SET_SUBMIT_MODE",
				Q = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				X = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				Z = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED",
				$ = "POST_CREATION__UPDATE_SCHEDULED_POST_ADVANCED_SETTINGS"
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return p
			})), r.d(e, "a", (function() {
				return O
			})), r.d(e, "d", (function() {
				return f
			})), r.d(e, "c", (function() {
				return _
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/toaster.ts"),
				o = r("./src/reddit/endpoints/post/convert.ts"),
				d = r("./src/reddit/helpers/localStorage/index.ts"),
				c = r("./src/reddit/helpers/trackers/postComposer.ts"),
				a = r("./src/reddit/models/PostCreationForm/index.ts"),
				u = r("./src/reddit/models/RichTextJson/index.ts"),
				l = r("./src/reddit/models/Toast/index.ts"),
				b = r("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(s.a)(b.D),
				O = Object(s.a)(b.p),
				m = Object(s.a)(b.N),
				f = (t, e, r) => async (s, d, f) => {
					let {
						apiContext: g
					} = f;
					c.i(d(), e);
					const j = e === a.h.MARKDOWN,
						E = e === a.h.RICH_TEXT,
						y = b.k;
					if (j && Object(u.G)(r)) return s(m({
						editorKey: t,
						editorMode: a.h.MARKDOWN,
						content: ""
					})), void s(_(e));
					if (E && !r) return s(m({
						editorKey: t,
						editorMode: a.h.RICH_TEXT,
						content: u.i
					})), void s(_(e));
					s(p(y));
					const S = await Object(o.a)(g(), e, j ? JSON.stringify(r) : r);
					S.ok ? (s(O(y)), s(m({
						editorKey: t,
						editorMode: e,
						content: S.body.output
					})), s(_(e))) : (s(O(y)), s(Object(i.e)({
						duration: i.a,
						kind: l.b.Error,
						text: n.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, _ = t => async (e, r) => {
					const s = Object(d.i)();
					if (s >= 3) return;
					const o = r().user.prefs.useMarkdown ? a.h.MARKDOWN : a.h.RICH_TEXT;
					if (t === o) return;
					const c = t === a.h.MARKDOWN ? n.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : n.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					e(Object(i.e)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: n.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: l.b.SuccessCommunity,
						text: c
					})), Object(d.T)(s + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(t, e, r) {
			"use strict";
			r.d(e, "i", (function() {
				return O
			})), r.d(e, "n", (function() {
				return f
			})), r.d(e, "a", (function() {
				return _
			})), r.d(e, "b", (function() {
				return g
			})), r.d(e, "c", (function() {
				return E
			})), r.d(e, "d", (function() {
				return y
			})), r.d(e, "f", (function() {
				return S
			})), r.d(e, "e", (function() {
				return T
			})), r.d(e, "g", (function() {
				return h
			})), r.d(e, "h", (function() {
				return I
			})), r.d(e, "j", (function() {
				return C
			})), r.d(e, "s", (function() {
				return A
			})), r.d(e, "r", (function() {
				return x
			})), r.d(e, "t", (function() {
				return D
			})), r.d(e, "u", (function() {
				return w
			})), r.d(e, "v", (function() {
				return R
			})), r.d(e, "w", (function() {
				return P
			})), r.d(e, "y", (function() {
				return N
			})), r.d(e, "z", (function() {
				return k
			})), r.d(e, "A", (function() {
				return v
			})), r.d(e, "k", (function() {
				return U
			})), r.d(e, "q", (function() {
				return L
			})), r.d(e, "p", (function() {
				return G
			})), r.d(e, "l", (function() {
				return F
			})), r.d(e, "x", (function() {
				return q
			})), r.d(e, "o", (function() {
				return B
			})), r.d(e, "m", (function() {
				return K
			}));
			var n = r("./node_modules/react-router-redux/es/index.js"),
				s = r("./src/lib/isUrl/index.ts"),
				i = r("./src/lib/makeActionCreator/index.ts"),
				o = r("./src/reddit/actions/modal.ts"),
				d = r("./src/reddit/contexts/PageLayer/index.tsx"),
				c = r("./src/reddit/endpoints/post/index.tsx"),
				a = r("./src/reddit/models/PostCreationForm/index.ts"),
				u = r("./src/reddit/routes/postCreation/constants.ts"),
				l = r("./src/reddit/selectors/postCollection.ts"),
				b = r("./src/reddit/selectors/postCreations.ts"),
				p = r("./src/reddit/actions/postCreation/constants.ts");
			const O = Object(i.a)(p.n),
				m = Object(i.a)(p.A),
				f = (Object(i.a)(p.s), t => {
					switch (t) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				_ = Object(i.a)(p.b),
				g = Object(i.a)(p.c),
				j = Object(i.a)(p.d),
				E = Object(i.a)(p.e),
				y = Object(i.a)(p.f),
				S = Object(i.a)(p.g),
				T = Object(i.a)(p.h),
				h = Object(i.a)(p.i),
				I = Object(i.a)(p.j),
				C = Object(i.a)(p.q),
				A = Object(i.a)(p.P),
				x = Object(i.a)(p.O),
				D = (Object(i.a)(p.Q), Object(i.a)(p.R)),
				w = Object(i.a)(p.S),
				R = Object(i.a)(p.T),
				P = Object(i.a)(p.U),
				N = Object(i.a)(p.V),
				k = Object(i.a)(p.W),
				v = Object(i.a)(p.X),
				U = Object(i.a)(p.r),
				L = t => async (e, r, n) => {
					let {
						apiContext: i
					} = n;
					e(j(t)), Object(s.a)(t) && e((t => async (e, r, n) => {
						let {
							apiContext: s
						} = n;
						const i = await Object(c.f)(s(), t);
						i.ok && i.body && i.body.json && i.body.json.data && e(m(i.body.json.data))
					})(t))
				}, M = Object(i.a)(p.B), G = (t, e) => async (r, s) => {
					r(M()), r(t ? Object(n.b)(u.b) : Object(n.b)(Object(b.X)(s(), {
						pageLayer: e
					})))
				}, F = Object(i.a)(o.c), q = t => async e => {
					t ? t === a.d ? e(F(t)) : e(o.i(t)) : (e(F(t)), e(o.i(t)))
				}, B = t => async (e, r) => {
					const n = r(),
						s = Object(d.D)(t),
						i = Object(b.C)(n);
					if (s && i) {
						Object(b.S)(n) !== a.c && e(q(a.c))
					} else e(G(!1, t))
				}, K = t => async (e, r) => {
					const n = r();
					Object(l.n)(n, {
						subredditId: t
					}) ? e(o.i(a.a)) : e(o.i(a.b))
				}
		},
		"./src/reddit/actions/postFlair.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return O
			})), r.d(e, "a", (function() {
				return g
			})), r.d(e, "f", (function() {
				return S
			})), r.d(e, "b", (function() {
				return C
			})), r.d(e, "e", (function() {
				return w
			})), r.d(e, "d", (function() {
				return R
			})), r.d(e, "l", (function() {
				return v
			})), r.d(e, "k", (function() {
				return U
			})), r.d(e, "j", (function() {
				return L
			})), r.d(e, "g", (function() {
				return M
			})), r.d(e, "i", (function() {
				return G
			})), r.d(e, "h", (function() {
				return F
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/post.ts"),
				o = r("./src/reddit/actions/postFlairStyleTemplate.ts"),
				d = r("./src/reddit/actions/toaster.ts"),
				c = r("./src/reddit/endpoints/flair/index.ts"),
				a = r("./src/reddit/helpers/flair.ts"),
				u = r("./src/reddit/models/Flair/index.ts"),
				l = r("./src/reddit/models/Toast/index.ts"),
				b = r("./src/reddit/selectors/postFlair.ts"),
				p = r("./src/reddit/selectors/subreddit.ts");
			const O = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				m = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				f = Object(s.a)(O),
				_ = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				g = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				j = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				E = Object(s.a)(g),
				y = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				S = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				T = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				h = Object(s.a)(S),
				I = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				C = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				A = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				x = Object(s.a)(C),
				D = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				w = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				R = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				P = Object(s.a)(w),
				N = Object(s.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				k = Object(s.a)(R),
				v = (t, e) => async (r, n, s) => {
					let {
						apiContext: i
					} = s;
					const o = n(),
						d = Object(p.S)(o, {
							subredditId: t
						}).name;
					r(m());
					const a = await Object(c.k)(i(), d, e);
					if (a.ok) {
						r(f({
							subredditId: t,
							isEnabled: e
						}))
					} else r(_());
					return a.ok
				}, U = (t, e) => async (r, n, s) => {
					let {
						apiContext: i
					} = s;
					const o = n(),
						d = Object(p.S)(o, {
							subredditId: t
						}).name;
					r(j());
					const a = await Object(c.j)(i(), e, u.d.LinkFlair, d);
					if (a.ok) {
						r(E({
							subredditId: t,
							canAssignOwn: e
						}))
					} else r(y());
					return a.ok
				}, L = (t, e) => async (r, s, i) => {
					let {
						apiContext: a
					} = i;
					const b = s(),
						O = Object(p.S)(b, {
							subredditId: e
						}).name;
					r(T());
					const m = await Object(c.f)(a(), t, O, u.d.LinkFlair);
					let f = m.ok && !(m.body && !1 === m.body.success);
					if (f) {
						const n = m.body;
						if (r(h({
								subredditId: e,
								template: n
							})), n.id) {
							const s = t.styleTemplate,
								i = b.structuredStyles.flairTemplate.models[n.id];
							s ? f = await r(Object(o.d)(e, n.id, s)) : i && (f = await r(Object(o.c)(e, n.id)))
						}
					}
					if (f) {
						const t = Object(d.d)(n.fbt._("Flair saved!", null, {
							hk: "3MQuUt"
						}), l.b.SuccessMod);
						r(Object(d.e)(t))
					} else {
						r(I());
						const s = Object(d.d)(n.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "1yf1Ne"
						}), l.b.Error, n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), L(t, e));
						r(Object(d.e)(s))
					}
					return f
				}, M = (t, e) => async (r, s, i) => {
					let {
						apiContext: o
					} = i;
					const a = s(),
						u = Object(p.S)(a, {
							subredditId: e
						}).name;
					if (r(A()), (await Object(c.b)(o(), t, u)).ok) {
						r(x({
							subredditId: e,
							templateId: t
						}));
						const s = Object(d.d)(n.fbt._("Flair deleted!", null, {
							hk: "44T1il"
						}), l.b.SuccessMod);
						r(Object(d.e)(s))
					} else {
						r(D());
						const s = Object(d.d)(n.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "1nwT0G"
						}), l.b.Error, n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), M(t, e));
						r(Object(d.e)(s))
					}
				}, G = (t, e) => async (r, s, i) => {
					let {
						apiContext: o
					} = i;
					const a = s(),
						O = Object(b.d)(a, {
							subredditId: e
						}).templateIds,
						m = Object(p.S)(a, {
							subredditId: e
						}).name;
					if (r(P({
							subredditId: e,
							templateIds: t
						})), (await Object(c.e)(o(), m, u.d.LinkFlair, t)).ok) {
						r(N());
						const t = Object(d.d)(n.fbt._("Flair reorder saved.", null, {
							hk: "1Xbuan"
						}), l.b.SuccessMod);
						r(Object(d.e)(t))
					} else {
						r(k({
							subredditId: e,
							templateIds: O
						}));
						const s = Object(d.d)(n.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "4ohwNd"
						}), l.b.Error, n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), G(t, e));
						r(Object(d.e)(s))
					}
				}, F = t => {
					let {
						post: e,
						previewFlair: r,
						selectedTemplateId: n
					} = t;
					return async (t, s, o) => {
						let {
							apiContext: d
						} = o;
						const u = e.flair.filter(t => !Object(a.p)(t.type));
						if (r && u.unshift(r), t(Object(i.J)({
								[e.id]: {
									flair: u
								}
							})), r) {
							const t = Object(a.g)(r);
							Object(c.h)(d(), e.id, n, t)
						} else Object(c.h)(d(), e.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return S
			})), r.d(e, "d", (function() {
				return h
			})), r.d(e, "a", (function() {
				return I
			})), r.d(e, "c", (function() {
				return A
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js"), r("./node_modules/core-js/modules/es6.symbol.js");
			var n = r("./node_modules/lodash/forEach.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/isEqual.js"),
				o = r.n(i),
				d = r("./node_modules/lodash/values.js"),
				c = r.n(d),
				a = r("./src/lib/makeActionCreator/index.ts"),
				u = r("./src/reddit/actions/imageUploads.ts"),
				l = r("./src/reddit/helpers/media/index.ts"),
				b = r("./src/lib/constants/index.ts"),
				p = r("./src/lib/makeApiRequest/index.ts"),
				O = r("./src/lib/omitHeaders/index.ts"),
				m = r("./src/reddit/constants/headers.ts");
			var f = r("./src/reddit/helpers/trackers/blade.ts"),
				_ = r("./src/reddit/models/Image/index.tsx"),
				g = r("./src/reddit/selectors/subreddit.ts"),
				j = r("./src/telemetry/index.ts"),
				E = function(t, e) {
					var r = {};
					for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
					if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]])
					}
					return r
				};
			const y = t => {
					let {
						subredditId: e,
						flairId: r,
						imageKey: n,
						imageData: s
					} = t;
					return async (t, i, o) => {
						const d = i(),
							c = Object(g.S)(d, {
								subredditId: e
							});
						if (!c) return !1;
						t(Object(u.k)(s));
						const a = await (async (t, e, r, n, s, i) => Object(p.a)(Object(O.a)(t, [m.a]), {
							endpoint: "".concat(t.apiUrl, "/api/v1/").concat(e, "/flair_style_asset_upload_s3/").concat(r),
							method: b.db.POST,
							data: {
								filepath: n,
								imagetype: s,
								mimetype: i
							}
						}))(o.apiContext(), c.name, r, s.file.name, n, await Object(l.g)(s.file));
						let f = !1;
						try {
							const e = await Object(u.g)(i(), a, s, _.a.FlairTemplates);
							e && t(Object(u.j)(e)), f = !0
						} catch (j) {
							if (j instanceof Error) throw j;
							t(Object(u.i)(j))
						}
						return f
					}
				},
				S = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				T = Object(a.a)(S),
				h = (t, e, r) => async (n, i, d) => {
					const {
						apiContext: a
					} = d;
					let l = i();
					const {
						pendingImages: S
					} = r;
					let h = E(r, ["pendingImages"]);
					const I = Object(g.S)(l, {
						subredditId: t
					});
					if (!I) return !1;
					const C = l.structuredStyles.flairTemplate.models[e];
					if (C && o()(C, h)) return !0;
					if (S) {
						const r = [];
						if (s()(S, (s, i) => {
								s && r.push(n(y({
									flairId: e,
									imageData: Object(_.m)(s),
									imageKey: i,
									subredditId: t
								})))
							}), !(await Promise.all(r)).every(t => t)) return !1;
						h = ((t, e, r) => {
							const n = Object.assign({}, t);
							return s()(e, (t, e) => {
								const s = t && r.imageUploads[t.id];
								s && s.kind === _.b.TempUploaded && (n[e] = s.url)
							}), n
						})(h, S, i())
					}
					l = i();
					let A = null,
						x = null;
					const D = [];
					try {
						(A = await Object(u.f)(l, _.a.FlairTemplates)) && (x = Object(u.m)(A)(n, i, d), D.push(...c()(A.imagesByKey)))
					} catch (N) {
						return !1
					}
					const w = await (async (t, e, r, n) => Object(p.a)(Object(O.a)(t, [m.a]), {
							endpoint: "".concat(t.apiUrl, "/api/v1/").concat(e, "/flair_styles/").concat(r),
							method: b.db.PUT,
							data: n
						}))(a(), I.name, e, h),
						R = C ? "edit_post_flair_template" : "save_post_flair_template",
						P = Object(f.e)(l, R);
					if (w.ok) {
						let t;
						if (x) try {
							await x, t = ((t, e, r) => {
								const n = Object.assign({}, t);
								return e.forEach(t => {
									const e = r.imageUploads[t.id];
									e && e.kind === _.b.Uploaded && (t.url === n.postBackgroundImage ? n.postBackgroundImage = e.url : t.url === n.postPlaceholderImage && (n.postPlaceholderImage = e.url))
								}), n
							})(h, D, i())
						} catch (N) {
							t = null
						} else t = h;
						n(T({
							flairId: e,
							template: t || h
						}))
					} else A && A.websocket.close();
					return Object(j.a)(Object.assign(Object.assign({}, P), {
						actionInfo: Object.assign(Object.assign({}, P.actionInfo), {
							success: w.ok
						})
					})), w.ok
				}, I = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", C = Object(a.a)(I), A = (t, e) => async (r, n, s) => {
					let {
						apiContext: i
					} = s;
					const o = n(),
						d = Object(g.S)(o, {
							subredditId: t
						});
					if (!d) return !1;
					const c = await (async (t, e, r) => Object(p.a)(Object(O.a)(t, [m.a]), {
							endpoint: "".concat(t.apiUrl, "/api/v1/").concat(e, "/flair_styles/").concat(r),
							method: b.db.DELETE
						}))(i(), d.name, e),
						a = Object(f.e)(o, "delete_flair_template");
					return c.ok && r(C({
						flairId: e
					})), Object(j.a)(Object.assign(Object.assign({}, a), {
						actionInfo: Object.assign(Object.assign({}, a.actionInfo), {
							success: c.ok
						})
					})), c.ok
				}
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return O
			})), r.d(e, "d", (function() {
				return f
			})), r.d(e, "a", (function() {
				return _
			})), r.d(e, "b", (function() {
				return y
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/reddit/actions/post.ts"),
				i = r("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = r("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				d = r("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				c = r("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const a = Object(n.a)(i.w),
				u = Object(n.a)(i.x),
				l = Object(n.a)(i.G),
				b = (Object(n.a)(i.H), Object(n.a)(i.I)),
				p = Object(n.a)(i.T),
				O = t => async (e, r) => {
					if (Object(d.a)(r())) return Object(d.d)(r()) ? e(m(t)) : e((() => async (t, e, r) => {
						let {
							gqlContext: n
						} = r;
						const s = Object(c.k)(e()),
							i = s.global.lastUpdated || 0,
							d = 1e3 * s.global.rpan_config_refresh_rate;
						if (s.isPending || Date.now() < i + d) return;
						t(l());
						const u = await Object(o.b)(n());
						u.ok && u.body ? t(a(Object.assign(Object.assign({}, u.body), {
							lastUpdated: Date.now()
						}))) : t(b())
					})())
				}, m = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					const i = Object(c.k)(r()),
						d = Object(c.m)(r(), {
							subreddit: t
						}),
						p = d && d.lastUpdated || 0,
						O = 1e3 * i.global.rpan_config_refresh_rate;
					if (i.isPending || i.isPermanentlyCanceled || Date.now() < p + O) return;
					e(l());
					const m = await Object(o.c)(s(), t);
					if (!m.ok) return void e(b());
					const f = m.body;
					e(a(Object.assign(Object.assign({}, f.global), {
						lastUpdated: Date.now()
					}))), e(u({
						name: t,
						config: Object.assign(Object.assign({}, f.listing_info), {
							lastUpdated: Date.now()
						})
					}))
				}, f = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					e(p()), await Object(o.i)(s(), t)
				}, _ = t => async (e, r, n) => {
					let {
						apiContext: i
					} = n;
					r().posts.models[t] || await e(Object(s.D)(t))
				}, g = Object(n.a)(i.v), j = Object(n.a)(i.J), E = Object(n.a)(i.K), y = () => async (t, e, r) => {
					let {
						gqlContext: n
					} = r;
					const s = e();
					if (!Object(d.d)(s) || Object(c.h)(s)) return;
					t(j());
					const i = await Object(o.d)(n());
					i.ok && i.body && i.body.data ? t(g({
						subreddits: i.body.data
					})) : t(E({
						error: i.error
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/automute.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return o
			})), r.d(e, "b", (function() {
				return c
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				i = r("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const o = Object(n.a)(i.r),
				d = Object(n.a)(i.F),
				c = t => async (e, r, n) => {
					let {
						apiContext: i
					} = n;
					const c = await Object(s.a)(i(), t);
					c && c.ok ? e(o({
						streamId: t,
						level: c.body.data.auto_mute_status.level
					})) : e(d(t))
				}
		},
		"./src/reddit/actions/reportFlow.ts": function(t, e, r) {
			"use strict";
			r.d(e, "e", (function() {
				return j
			})), r.d(e, "d", (function() {
				return E
			})), r.d(e, "c", (function() {
				return y
			})), r.d(e, "h", (function() {
				return I
			})), r.d(e, "f", (function() {
				return C
			})), r.d(e, "a", (function() {
				return A
			})), r.d(e, "b", (function() {
				return x
			})), r.d(e, "j", (function() {
				return P
			})), r.d(e, "g", (function() {
				return N
			})), r.d(e, "i", (function() {
				return U
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/login.ts"),
				o = r("./src/reddit/actions/modal.ts"),
				d = r("./src/reddit/actions/reportRules.ts"),
				c = r("./src/reddit/actions/subreddit.ts"),
				a = r("./src/reddit/actions/toaster.ts"),
				u = r("./src/reddit/actions/users.ts"),
				l = r("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"),
				b = r("./src/reddit/endpoints/post/index.tsx"),
				p = r("./src/reddit/helpers/isComment.ts"),
				O = r("./src/reddit/helpers/isPost.ts"),
				m = r("./src/reddit/models/Post/index.ts"),
				f = r("./src/reddit/models/Toast/index.ts"),
				_ = r("./src/reddit/selectors/posts.ts"),
				g = r("./src/reddit/selectors/user.ts");
			const j = "REPORT__PENDING",
				E = "REPORT__LOADED",
				y = "REPORT__FAILED",
				S = Object(s.a)(j),
				T = Object(s.a)(E),
				h = Object(s.a)(y),
				I = (t, e) => async (r, s, i) => {
					let {
						apiContext: o
					} = i;
					const d = t.id,
						c = s(),
						u = c.reportFlow.api.pending[d],
						l = c.reportFlow.userIsMod;
					if (u) return;
					r(S({
						id: d
					}));
					const p = await Object(b.n)(o(), t),
						O = "error-report-".concat(d);
					if (p.ok) r(T({
						id: d
					})), r(a.f(O)), !e.isAbuseOfReportButton && l && r(U());
					else {
						r(h({
							id: d
						}));
						const s = p.error && p.error.fields && p.error.fields.length ? p.error.fields[0].msg : "";
						r(a.e({
							id: O,
							kind: f.b.Error,
							text: s || n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: I(t, e)
						}))
					}
				}, C = "REPORT_FLOW__TARGET_SET", A = "REPORT_FLOW__OPENED_FROM_MODAL_PAGE", x = "REPORT_FLOW__OPEN_CATEGORY", D = Object(s.a)(C), w = Object(s.a)(A), R = Object(s.a)(x), P = (t, e, r) => async (n, s, a) => {
					let {
						apiContext: l
					} = a;
					const b = s(),
						f = Object(p.a)(t),
						j = Object(O.a)(t);
					if (!j && !f) return;
					const E = f ? b.comments.models[t] : b.posts.models[t];
					if (!E) return;
					if (!Object(g.I)(s())) return n(Object(i.i)()), void n(Object(o.k)({
						actionSource: o.a.Report,
						redirectUrl: E.permalink
					}));
					n(Object(u.y)(E.author));
					const y = Object(_.ab)(b, {
							postId: f ? b.comments.models[t].postId : b.posts.models[t].id
						}),
						S = j && Object(m.i)(E) || f && L(E, b);
					S || b.reportRules.sitewideRules && b.reportRules.sitewideRules.length || n(Object(d.d)()), !S || b.reportRules.liveStreamingRules && b.reportRules.liveStreamingRules.length || n(Object(d.c)()), y && n(Object(c.o)(y.name, y.type)), n(D(t)), n(w(!!e)), r && n(R(r)), y && n(v(y.name))
				}, N = "REPORT_FLOW__USER_IS_MOD_SET", k = Object(s.a)(N), v = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = await Object(l.a)(s());
					e(k(i.ok && !!i.body[t]))
				}, U = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					t(D(null))
				}, L = (t, e) => {
					const r = t.postId,
						n = r && e.posts.models[r];
					return !!n && Object(m.i)(n)
				}
		},
		"./src/reddit/actions/reportRules.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return a
			})), r.d(e, "a", (function() {
				return u
			})), r.d(e, "d", (function() {
				return p
			})), r.d(e, "c", (function() {
				return O
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/constants/index.ts"),
				o = r("./src/lib/makeApiRequest/index.ts"),
				d = r("./src/lib/omitHeaders/index.ts"),
				c = r("./src/reddit/constants/headers.ts");
			const a = "SITEWIDE_RULES_LOADED",
				u = "LIVESTREAMING_RULES_LOADED",
				l = Object(s.a)(a),
				b = Object(s.a)(u),
				p = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					if (!e().user) return;
					const s = await (t => Object(o.a)(Object(d.a)(t, [c.a]), {
						endpoint: "".concat(t.apiUrl, "/api/sitewide_rules.json"),
						method: i.db.GET
					}))(n());
					if (s.ok) {
						const e = s.body,
							r = m(e.sitewide_rules);
						t(l(r))
					}
				}, O = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					if (!e().user) return;
					const s = await (t => Object(o.a)(Object(d.a)(t, [c.a]), {
						endpoint: "".concat(t.apiUrl, "/api/livestream_rules.json"),
						method: i.db.GET
					}))(n());
					if (s.ok) {
						const e = s.body,
							r = m(e.livestream_rules);
						t(b(r))
					}
				}, m = t => {
					let e = [];
					if (t && t.length > 2) {
						const r = {
							reasonTextToShow: n.fbt._("It's spam or abuse", null, {
								hk: "21rHqk"
							}),
							nextStepReasons: [t[0], t[1], t[2]]
						};
						4 === t.length && r.nextStepReasons && r.nextStepReasons.push(t[3]), e.push(r), e = e.concat(t.slice(t.length - 1))
					}
					return e
				}
		},
		"./src/reddit/actions/search.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return E
			})), r.d(e, "c", (function() {
				return y
			})), r.d(e, "a", (function() {
				return S
			})), r.d(e, "d", (function() {
				return T
			})), r.d(e, "f", (function() {
				return h
			})), r.d(e, "j", (function() {
				return I
			})), r.d(e, "h", (function() {
				return w
			})), r.d(e, "g", (function() {
				return R
			})), r.d(e, "e", (function() {
				return P
			})), r.d(e, "i", (function() {
				return N
			}));
			r("./node_modules/core-js/modules/es6.array.sort.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/pick.js"),
				i = r.n(s),
				o = r("./src/lib/constants/index.ts"),
				d = r("./src/lib/makeActionCreator/index.ts"),
				c = r("./src/lib/makeSearchKey/index.ts"),
				a = r("./src/reddit/actions/toaster.ts"),
				u = r("./src/reddit/constants/parameters.ts"),
				l = r("./src/reddit/actions/pages/subreddit.ts"),
				b = r("./src/reddit/endpoints/page/search.ts"),
				p = r("./src/lib/makeApiRequest/index.ts"),
				O = r("./src/lib/omitHeaders/index.ts"),
				m = r("./src/reddit/constants/headers.ts");
			var f = async (t, e) => Object(p.a)(Object(O.a)(t, [m.a]), {
				endpoint: "".concat(t.apiUrl, "/api/related_queries_v1.json?query=").concat(e),
				method: o.db.GET
			}), _ = r("./src/reddit/models/Toast/index.ts"), g = r("./src/reddit/selectors/searchResults.ts"), j = r("./src/reddit/selectors/user.ts");
			const E = "SEARCH__MORE_RESULTS_PENDING",
				y = "SEARCH__MORE_RESULTS_RECEIVED",
				S = "SEARCH__MORE_RESULTS_FAILED",
				T = "SEARCH__RELATED_QUERIES_RECEIVED",
				h = "SEARCH__UPDATE_SEARCH_QUERY",
				I = Object(d.a)(h),
				C = Object(d.a)(E),
				A = Object(d.a)(y),
				x = Object(d.a)(S),
				D = Object(d.a)(T),
				w = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = r(),
						o = Object(g.g)(i, t);
					if (o && o.length > 0) return;
					const d = await f(s(), t);
					if (d.ok) {
						const r = (t => ({
							relatedQueries: t.body.related_queries
						}))(d);
						e(D({
							query: t,
							relatedQueries: r.relatedQueries
						}))
					}
				}, R = t => async (e, r, s) => {
					let {
						apiContext: d
					} = s;
					const p = r(),
						{
							queryParams: O
						} = p.platform.currentPage,
						m = Object(l.e)(O, Object(j.Y)(p)),
						f = p.platform.currentPage.urlParams.subredditName || p.platform.currentPage.urlParams.multiredditName,
						{
							username: g
						} = p.platform.currentPage.urlParams,
						E = m || i()(O, u.t),
						y = Object(c.c)(E),
						S = Object.assign(Object.assign({}, y), {
							sort: y.category ? o.Lb.Relevance : y.sort,
							t: y.category ? o.Sb.DAY : y.t
						}),
						T = Object(c.b)(f, g, S);
					let h;
					if (t.indexOf(o.Nb.Posts) > -1) {
						const t = p.listings.postOrder.loadMore[T];
						if (!t) return;
						const e = p.listings.postOrder.api.pending[T],
							r = p.listings.postOrder.fetchedTokens,
							n = r[T] && r[T][t.token];
						if (e || n) return;
						h = t.token
					} else {
						if (!(t.indexOf(o.Nb.Subreddits) > -1 || t.indexOf(o.Nb.Users) > -1)) throw new Error("Should not attempt to fetch more results without a search type"); {
							const t = p.listings.listingOrder.loadMore[T];
							if (!t) return;
							const e = p.listings.listingOrder.api.pending[T],
								r = p.listings.listingOrder.fetchedTokens,
								n = r[T] && r[T][t.token];
							if (e || n) return;
							h = t.token
						}
					}
					const I = "error-".concat(T);
					e(C({
						fetchedToken: h,
						key: T,
						type: t
					}));
					const D = await Object(b.a)(d(), f, g, Object.assign(Object.assign({}, S), {
						after: h,
						type: (y.type || []).join(","),
						b: !0
					}));
					D.ok ? (e(A(Object.assign({
						key: T,
						fetchedToken: h,
						meta: p.meta,
						subredditOrMultiName: f,
						type: t
					}, D.body))), e(a.f(I))) : (e(x(Object.assign({
						key: T,
						error: D.error,
						fetchedToken: h,
						meta: p.meta,
						type: t
					}, D.body))), e(a.e({
						id: I,
						kind: _.b.Error,
						text: n.fbt._("Sorry, we couldn't load more search results.", null, {
							hk: "3IDePs"
						}),
						buttonText: n.fbt._("Retry", null, {
							hk: "1XMjgA"
						}),
						buttonAction: R(t)
					})))
				}, P = "SEARCH__TYPEAHEAD_SUCCESS", N = Object(d.a)(P)
		},
		"./src/reddit/actions/seo/linksModule.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return u
			})), r.d(e, "b", (function() {
				return l
			})), r.d(e, "c", (function() {
				return f
			})), r.d(e, "d", (function() {
				return _
			}));
			var n = r("./src/lib/makeActionCreator/index.ts"),
				s = r("./src/lib/loadWithRetries/index.ts");
			var i = r("./src/lib/makeGqlRequest/index.ts"),
				o = r("./src/graphql/operations/SubredditLinks.json");
			const d = t => ({
				communityIcon: t.styles && t.styles.icon || void 0,
				iconUrl: t.styles && t.styles.legacyIcon && t.styles.legacyIcon.url || void 0,
				id: t.id,
				isNSFW: t.isNSFW || !1,
				isSubscribed: t.isSubscribed,
				name: t.name,
				primaryColor: t.styles && t.styles.primaryColor || void 0,
				subscribers: t.subscribers,
				type: "subreddit"
			});
			var c = t => ({
					subreddits: t.data.subredditInfoById.linkedSubreddits ? t.data.subredditInfoById.linkedSubreddits.map(d) : []
				}),
				a = r("./src/reddit/selectors/seo/linksModule.ts");
			const u = "FRONTPAGE_LINKS__REQUEST_LOADED",
				l = "SUBREDDIT_LINKS_LOADED",
				b = Object(n.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				p = Object(n.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				O = Object(n.a)(u),
				m = Object(n.a)(l),
				f = () => async t => {
					t(b());
					const e = await (async () => (await Object(s.a)(() => r.e("FrontpageLinks").then(r.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default)();
					t(e ? O(e) : p())
				}, _ = (t, e) => async (r, n, s) => {
					let {
						gqlContext: d
					} = s;
					if (t) {
						if (Object(a.c)(n(), {
								subredditId: t
							})) return;
						const s = await ((t, e) => Object(i.a)(t, Object.assign(Object.assign({}, o), {
							variables: e
						})))(d(), {
							subredditId: t,
							includeSubreddits: !0,
							subredditsLimit: e || 10
						});
						if (s.ok) {
							const e = c(s.body);
							e && r(m({
								id: t,
								data: e
							}))
						}
					}
				}
		},
		"./src/reddit/actions/subreddit.ts": function(t, e, r) {
			"use strict";
			r.d(e, "m", (function() {
				return Y
			})), r.d(e, "l", (function() {
				return V
			})), r.d(e, "k", (function() {
				return W
			})), r.d(e, "j", (function() {
				return J
			})), r.d(e, "i", (function() {
				return z
			})), r.d(e, "h", (function() {
				return Q
			})), r.d(e, "d", (function() {
				return X
			})), r.d(e, "p", (function() {
				return et
			})), r.d(e, "o", (function() {
				return it
			})), r.d(e, "r", (function() {
				return ct
			})), r.d(e, "g", (function() {
				return at
			})), r.d(e, "f", (function() {
				return ut
			})), r.d(e, "e", (function() {
				return lt
			})), r.d(e, "q", (function() {
				return mt
			})), r.d(e, "b", (function() {
				return ft
			})), r.d(e, "c", (function() {
				return _t
			})), r.d(e, "a", (function() {
				return gt
			})), r.d(e, "t", (function() {
				return St
			})), r.d(e, "n", (function() {
				return Tt
			})), r.d(e, "s", (function() {
				return ht
			}));
			r("./node_modules/core-js/modules/es6.array.sort.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/pick.js"),
				i = r.n(s),
				o = r("./src/lib/constants/index.ts"),
				d = r("./src/lib/listingSort/index.ts"),
				c = r("./src/lib/makeActionCreator/index.ts"),
				a = r("./src/lib/makeListingKey/index.ts"),
				u = r("./src/reddit/actions/economics/helpers/async.ts"),
				l = r("./src/reddit/actions/modal.ts"),
				b = r("./src/reddit/actions/oldSiteRules.ts"),
				p = r("./src/reddit/actions/pages/subreddit.ts"),
				O = r("./src/reddit/actions/preferences.ts"),
				m = r("./src/reddit/actions/subredditRules/constants.ts"),
				f = r("./src/reddit/actions/toaster.ts"),
				_ = r("./src/reddit/constants/modals.ts"),
				g = r("./src/reddit/constants/page.ts"),
				j = r("./src/reddit/constants/parameters.ts"),
				E = r("./src/reddit/constants/postLayout.ts"),
				y = r("./src/reddit/contexts/PageLayer/index.tsx"),
				S = r("./src/reddit/endpoints/governance/posts.ts"),
				T = r("./src/lib/makeApiRequest/index.ts"),
				h = r("./src/lib/omitHeaders/index.ts"),
				I = r("./src/reddit/constants/headers.ts"),
				C = r("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var A = r("./src/reddit/endpoints/modQueue/index.ts"),
				x = r("./src/reddit/endpoints/page/subredditPage.ts"),
				D = r("./src/reddit/endpoints/subreddit/about.ts"),
				w = r("./src/reddit/endpoints/subreddit/rules.ts"),
				R = r("./src/reddit/endpoints/user/preferences.ts"),
				P = r("./src/reddit/helpers/filterListingResponse/index.ts"),
				N = r("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				k = r("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				v = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				U = r("./src/reddit/models/Subreddit/index.ts"),
				L = r("./src/reddit/models/Toast/index.ts"),
				M = r("./src/reddit/models/User/index.ts"),
				G = r("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				F = r("./src/reddit/selectors/oldSiteRules.ts"),
				q = r("./src/reddit/selectors/profile.ts"),
				B = r("./src/reddit/selectors/subreddit.ts"),
				K = r("./src/reddit/selectors/user.ts");
			const H = {},
				Y = "SUBREDDIT__MODEL_SUCCEEDED",
				V = "SUBREDDIT__MODEL_PENDING",
				W = "SUBREDDIT__MODEL_FAILED",
				J = "SUBREDDIT__MORE_POSTS_PENDING",
				z = "SUBREDDIT__MORE_POSTS_LOADED",
				Q = "SUBREDDIT__MORE_POSTS_FAILED",
				X = "SUBREDDIT__META_FILTER_TOGGLED",
				Z = Object(c.a)(J),
				$ = Object(c.a)(z),
				tt = Object(c.a)(Q),
				et = Object(c.a)(X),
				rt = Object(c.a)(m.b),
				nt = Object(c.a)(m.c),
				st = Object(c.a)(m.a),
				it = (t, e) => async (r, n) => {
					await (e === U.e.User ? r(ot(t)) : r(dt(t))), 0 === Object(F.a)(n()).length && r(Object(b.b)())
				}, ot = t => async (e, r, n) => {
					let {
						apiContext: s
					} = n;
					const i = Object(q.m)(r(), t),
						o = await Object(w.c)(s(), t);
					if (o.ok) {
						const t = o.body;
						e(rt({
							rules: t,
							subredditId: i
						}))
					}
				}, dt = t => async (e, r, s) => {
					let {
						gqlContext: i
					} = s;
					const o = Object(B.G)(r(), t);
					e(nt());
					const d = await Object(w.b)(i(), t);
					if (d.ok) {
						const t = d.body;
						e(rt({
							rules: t,
							subredditId: o
						}))
					} else {
						e(st());
						const r = "error-block-".concat(t);
						e(f.e({
							id: r,
							kind: L.b.Error,
							text: n.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, ct = t => async (e, r, n) => {
					let {
						apiContext: s,
						gqlContext: c
					} = n;
					const {
						subredditName: l
					} = t;
					let b = t.t;
					const p = r(),
						O = Object(N.a)(t, p),
						m = p.platform.currentPage ? p.platform.currentPage.queryParams : {},
						f = Object(a.a)(l, O, Object.assign({
							t: b
						}, m)),
						_ = p.listings.postOrder.loadMore[f],
						T = p.listings.postOrder.listingSort[f];
					let h = O;
					if (T && !h) {
						const t = Object(d.d)(T.sort);
						h = t.sort, b = t.timeSort
					}
					const I = p.listings.postOrder.api.pending[f],
						{
							fetchedTokens: C
						} = p.listings.postOrder,
						A = !(!C[f] || !C[f][_.token]);
					if (I || A) return;
					if (h === o.O.AWARDED && l === g.f) return;
					e(Z({
						key: f,
						fetchedToken: _.token
					}));
					const D = Object.assign({
						after: _.token,
						dist: _.dist,
						layout: E.e[Object(y.N)(p, {})],
						sort: h,
						t: b
					}, i()(m, [...j.l, j.h]));
					D[j.h] || (D[j.h] = p.user.prefs.geopopular || p.meta.country);
					const w = Object(G.a)(p) ? () => Object(x.b)(c(), Object(x.c)(p, l, Object.assign(Object.assign({}, D), {
							limit: E.a
						})), Object(K.P)(p)) : () => Object(x.a)(s(), l, D),
						R = await w(),
						k = Object.assign(Object.assign({}, R.body), Object(P.a)(p, f, R.body));
					if (R.ok) {
						let t;
						const n = k.postIds.filter(t => !!k.posts[t].isMeta),
							i = Object(B.G)(r(), l);
						if (n.length) {
							const e = await Object(S.a)(s(), i, n);
							e.ok && (t = e.body)
						}
						e($(Object.assign({
							fetchedToken: _.token,
							key: f,
							meta: p.meta,
							governance: t
						}, k))), await e(Object(u.a)({
							subredditId: i,
							postIds: k.postIds,
							skip: ["communityDetails", "subscription"]
						}))
					} else e(tt(Object.assign({
						error: R.error,
						fetchedToken: _.token,
						key: f
					}, k)))
				}, at = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", ut = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", lt = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", bt = Object(c.a)(at), pt = Object(c.a)(ut), Ot = Object(c.a)(lt), mt = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const s = e();
					if (!s.user.account || s.subreddits.moderated.api.fetched) return;
					t(bt());
					const i = await Object(A.b)(n(), o.hb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					i.ok ? t(pt(i.body)) : t(Ot({
						error: i.error
					}))
				}, ft = "SUBREDDIT__ABOUT_PENDING", _t = "SUBREDDIT__ABOUT_SUCCEEDED", gt = "SUBREDDIT__ABOUT_FAILED", jt = Object(c.a)(ft), Et = Object(c.a)(_t), yt = Object(c.a)(gt), St = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					const i = r();
					if (Object(B.y)(i, {
							subredditName: t
						}) || i.subreddits.api.about.error[t.toLowerCase()] || i.subreddits.api.about.pending[t.toLowerCase()]) return;
					e(jt({
						subredditName: t
					}));
					const o = !Object(B.G)(i, t),
						d = await Object(D.a)(s(), t, o);
					if (d.ok) {
						const r = d.body.data.subreddit,
							n = Object(k.a)(r),
							s = o ? Object(v.a)(r) : void 0;
						e(Et({
							subredditName: t,
							subreddits: s ? {
								[s.id]: s
							} : void 0,
							data: n
						}))
					} else e(yt({
						subredditName: t,
						error: d.error
					}))
				}, Tt = (t, e, r) => async (n, s, i) => {
					let {
						apiContext: d
					} = i;
					const c = Object(B.G)(s(), t.substring(2)),
						a = Object(K.i)(s());
					if (a) {
						const s = Object(M.e)(a),
							i = e + "\n\n   *To approve this user*, visit [the approved users page for " + t + "](https://www.reddit.com/" + t + "/about/contributors?user=" + s + ') and click "ADD USER".\n    Approving this user gives them permission to ' + r + ". You can change these community restrictions from the [community settings](/" + t + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + s + "](/u/" + s + ") or reply to this message to start a conversation.",
							u = {
								to: "/".concat(t),
								subject: "I would like to join ".concat(t),
								text: i
							};
						if ((await ((t, e) => Object(T.a)(Object(h.a)(t, [I.a]), {
								endpoint: Object(C.a)("".concat(t.apiUrl, "/api/compose")),
								method: o.db.POST,
								data: e
							}))(d(), u)).ok) {
							const t = new Date,
								e = {
									isContributorRequestTimestamp: t.setDate(t.getDate())
								};
							n(Object(O.E)({
								subredditId: c,
								prefs: e
							})), Object(R.h)(c, e, d()), n(Object(l.i)(_.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, ht = t => async (e, r) => {
					const n = r(),
						{
							subredditName: s
						} = t,
						i = t.t,
						o = Object(N.a)(t, n),
						d = n.platform.currentPage ? n.platform.currentPage.queryParams : H,
						c = Object(a.a)(s, o, Object.assign({
							t: i
						}, d)),
						u = Object.assign({
							t: i,
							sort: o
						}, d);
					await e(Object(p.i)(c, s, u, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "c", (function() {
				return i
			})), r.d(e, "h", (function() {
				return o
			})), r.d(e, "g", (function() {
				return d
			})), r.d(e, "p", (function() {
				return c
			})), r.d(e, "o", (function() {
				return a
			})), r.d(e, "k", (function() {
				return u
			})), r.d(e, "j", (function() {
				return l
			})), r.d(e, "i", (function() {
				return b
			})), r.d(e, "n", (function() {
				return p
			})), r.d(e, "m", (function() {
				return O
			})), r.d(e, "l", (function() {
				return m
			})), r.d(e, "f", (function() {
				return f
			})), r.d(e, "e", (function() {
				return _
			})), r.d(e, "d", (function() {
				return g
			})), r.d(e, "r", (function() {
				return j
			})), r.d(e, "q", (function() {
				return E
			})), r.d(e, "s", (function() {
				return y
			}));
			const n = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				s = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				i = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				o = "SUBREDDIT__POSTS_LOADED",
				d = "SUBREDDIT__POSTS_SET_FAILED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				a = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				u = "SUBREDDIT__RANKINGS_PENDING",
				l = "SUBREDDIT__RANKINGS_LOADED",
				b = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				O = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				m = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				f = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				_ = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				g = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				j = "SUBREDDIT__EDIT_REQUESTED",
				E = "SUBREDDIT__EDIT_FAILED",
				y = "SUBREDDIT__EDIT_SUCCESS"
		},
		"./src/reddit/actions/subreddit/questions.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			})), r.d(e, "b", (function() {
				return o
			})), r.d(e, "c", (function() {
				return d
			}));
			var n = r("./src/graphql/operations/GetSubredditQuestions.json"),
				s = r("./src/lib/makeGqlRequest/index.ts");
			const i = "SUBREDDIT_QUESTIONS_LOADED",
				o = "SUBREDDIT_SURVEY_ANSWERED",
				d = t => async (e, r, o) => {
					let {
						gqlContext: d
					} = o;
					var c, a, u, l;
					const b = (await ((t, e) => Object(s.a)(t, Object.assign(Object.assign({}, n), {
							variables: e
						})))(d(), {
							id: t
						})).body,
						p = null === (a = null === (c = b.data) || void 0 === c ? void 0 : c.subredditInfoById) || void 0 === a ? void 0 : a.answerableQuestions,
						O = null === (l = null === (u = b.data) || void 0 === u ? void 0 : u.subredditInfoById) || void 0 === l ? void 0 : l.contentRatingSurvey;
					(p || O) && e({
						type: i,
						payload: {
							id: t,
							questions: p,
							survey: O
						}
					})
				}
		},
		"./src/reddit/actions/subreddit/subredditPosts.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return G
			})), r.d(e, "a", (function() {
				return F
			}));
			r("./node_modules/core-js/modules/es6.symbol.js");
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/lib/makeLinkedPostsListingKey/index.ts"),
				o = r("./src/lib/makeListingKey/index.ts"),
				d = r("./src/reddit/actions/linkedPosts/constants.ts");
			const c = Object(s.a)(d.b),
				a = Object(s.a)(d.a);
			var u = r("./src/reddit/actions/otherDiscussions/constants.ts"),
				l = r("./src/lib/makeGqlRequest/index.ts"),
				b = (r("./src/graphql/operations/OtherDiscussions.json"), r("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts")),
				p = r("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				O = r("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				m = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				f = r("./src/reddit/models/Post/index.ts");
			var _ = t => {
				let {
					getState: e,
					onFailure: r,
					onSuccess: n,
					postId: s,
					response: i
				} = t;
				if (!i.ok) return void r(i.error);
				const d = i.body,
					{
						post: c
					} = d && d.data,
					a = e(),
					u = Object(o.a)(s, null, {
						isOtherDiscussions: !0
					});
				if (c) {
					if (c.otherDiscussions && c.otherDiscussionsCount) {
						const {
							otherDiscussions: t,
							otherDiscussionsCount: e
						} = c, {
							postFlair: r,
							postIds: i,
							posts: o,
							profiles: d,
							subreddits: l
						} = (t => {
							const e = {
									postFlair: {},
									postIds: [],
									posts: {},
									profiles: {},
									subreddits: {}
								},
								r = t => {
									const r = Object(p.e)(t);
									e.posts[r.id] = r;
									const {
										crosspostRoot: n
									} = t;
									if (n && n.type === f.a.Post && n.postInfo) {
										const t = Object(p.e)(n.postInfo);
										e.posts[t.id] = t
									}
									switch (t.__typename) {
										case f.f.ProfilePost:
											e.profiles[t.profile.id] || (e.profiles[t.profile.id] = Object(O.a)(t.profile));
											break;
										case f.f.SubredditPost:
											e.subreddits[t.subreddit.id] || (e.subreddits[t.subreddit.id] = Object(m.a)(t.subreddit)), e.postFlair[t.subreddit.id] || (e.postFlair[t.subreddit.id] = Object(b.a)(t.subreddit))
									}
									return r.id
								};
							if (t && t.edges)
								for (const {
										node: n
									} of t.edges) {
									const t = r(n);
									t && e.postIds.push(t)
								}
							return e
						})(t);
						n({
							count: e,
							key: u,
							meta: a.meta,
							postFlair: r,
							postId: s,
							postIds: i,
							posts: o,
							profiles: d,
							subreddits: l
						})
					}
				} else n({
					count: 0,
					key: u,
					meta: a.meta,
					postFlair: {},
					postId: s,
					postIds: [],
					posts: {},
					profiles: {},
					subreddits: {}
				})
			};
			const g = Object(s.a)(u.a),
				j = Object(s.a)(u.b),
				E = Object(s.a)(u.c);
			var y = r("./src/reddit/actions/subreddit/constants.ts"),
				S = r("./src/graphql/operations/PostFeedAndOtherDiscussions.json"),
				T = (r("./src/graphql/operations/SubredditPosts.json"), r("./src/graphql/operations/SubredditsPosts.json"));
			var h = t => {
				let {
					getState: e,
					onSuccess: r,
					onFailure: n,
					postId: s,
					post: i
				} = t;
				try {
					r({
						altText: i && i.media && (i.media.still && i.media.still.altText || i.media.obfuscated && i.media.obfuscated.altText) || null,
						postId: s
					})
				} catch (o) {
					n(o)
				}
			};
			var I = t => {
					let {
						getState: e,
						onSuccess: r,
						onFailure: n,
						postId: s,
						post: o
					} = t;
					try {
						const t = [],
							n = {},
							d = {};
						if (!o || !o.linked) return;
						const c = e(),
							a = c.posts && c.posts.models,
							u = Object(i.a)(s),
							l = o.linked.posts && o.linked.posts.edges || [];
						for (const {
								node: e
							} of l) {
							if (!e) break;
							if (e.id && !a.hasOwnProperty(e.id) && (t.push(e.id), n[e.id] = Object(p.e)(e)), e.__typename === f.f.SubredditPost && e.subreddit && e.subreddit.id) {
								const {
									subreddit: t
								} = e;
								d[t.id] = Object(m.a)(t)
							}
						}
						r({
							dist: o.linked.posts && o.linked.posts.dist || null,
							key: u,
							meta: c.meta,
							posts: n,
							postIds: t,
							subreddits: d
						})
					} catch (d) {
						n(d)
					}
				},
				C = r("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts");
			var A = t => t.reduce((t, e) => (t[e.id] = e, t), {});
			var x = t => {
					let {
						getState: e,
						onSuccess: r,
						onFailure: s,
						options: i,
						subreddit: d
					} = t;
					try {
						if (!d) return;
						const {
							posts: t
						} = d, s = e(), c = ((t, e) => {
							const {
								edges: r
							} = t, n = r.filter(t => (t => !t.node.crosspostRoot)(t) && ((t, e) => !e.hasOwnProperty(t.node.id))(t, e));
							return Object.assign(Object.assign({}, t), {
								edges: n
							})
						})(t, s.posts && s.posts.models);
						if (!c.edges.length) return;
						const a = Object(C.a)(c),
							{
								range: u,
								sort: l,
								subredditName: b
							} = i,
							p = Object(o.a)(b, n.O[l], {
								t: u
							}),
							O = A(a),
							m = a.map(t => t.id);
						r({
							dist: t.dist,
							key: p,
							meta: s.meta,
							postIds: m,
							posts: O
						})
					} catch (c) {
						s(c)
					}
				},
				D = r("./src/reddit/models/Media/index.ts"),
				w = r("./src/reddit/selectors/posts.ts"),
				R = r("./src/reddit/actions/imageOCRAltText/constants.ts");
			const P = Object(s.a)(R.b),
				N = Object(s.a)(R.a);
			var k = function(t, e) {
				var r = {};
				for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
				if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
					var s = 0;
					for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]])
				}
				return r
			};
			const v = Object(s.a)(y.h),
				U = Object(s.a)(y.g),
				L = Object(s.a)(y.p),
				M = Object(s.a)(y.o),
				G = t => async (e, r, n) => {
					let {
						gqlContext: s
					} = n;
					const i = (await ((t, e) => Object(l.a)(t, Object.assign(Object.assign({}, T), {
							variables: e
						})))(s(), t)).body,
						{
							subredditNames: o
						} = t,
						d = k(t, ["subredditNames"]),
						c = [];
					try {
						for (const t of i.data.subredditsInfoByNames) {
							const e = t.posts.edges[0];
							e && e.node.__typename === f.f.SubredditPost && x({
								getState: r,
								onFailure: t => {
									throw t
								},
								onSuccess: t => c.push(t),
								options: Object.assign(Object.assign({}, d), {
									subredditName: e.node.subreddit.name
								}),
								subreddit: t
							})
						}
						e(L(c))
					} catch (a) {
						e(M(a))
					}
				}, F = t => async (e, r, s) => {
					let {
						gqlContext: d
					} = s;
					const {
						includePostImageOCRAltText: u,
						includeListingBelowExperiment: b,
						includeOtherDiscussions: p,
						includePostFeed: O,
						postId: m,
						range: f,
						sort: y,
						subredditName: T
					} = t, C = Object(o.a)(m, null, {
						isOtherDiscussions: !0
					}), A = Object(w.H)(r(), {
						listingKey: C
					}), R = p && (!A || 0 === A.length), k = Object(o.a)(T, n.O[y], {
						t: f
					}), L = Object(w.H)(r(), {
						listingKey: k
					}), M = O && (!L || 0 === L.length), G = Object(i.a)(m), F = Object(w.H)(r(), {
						listingKey: G
					}), q = b && (!F || 0 === F.length), B = Object(w.N)(r(), {
						postId: m
					}), K = u && !!B && !!B.media && (Object(D.I)(B.media) || Object(D.G)(B.media)) && !B.media.altText;
					if (!(R || M || q || K)) return;
					R && e(E({
						key: C
					}));
					const H = await ((t, e) => Object(l.a)(t, Object.assign(Object.assign({}, S), {
							variables: e
						})))(d(), t),
						Y = H.body;
					R && _({
						getState: r,
						onFailure: t => e(g(t)),
						onSuccess: t => e(j(t)),
						postId: m,
						response: H
					}), M && (H.ok ? Y.data && x({
						getState: r,
						onFailure: t => e(U(t)),
						onSuccess: t => e(v(t)),
						options: t,
						subreddit: Y.data.subreddit
					}) : e(U(H.error))), q && H.ok && I({
						getState: r,
						onFailure: t => e(a(t)),
						onSuccess: t => e(c(t)),
						postId: m,
						post: Y.data.post
					}), K && H.ok && h({
						getState: r,
						onFailure: t => e(N(t)),
						onSuccess: t => e(P(t)),
						postId: m,
						post: Y.data.post
					})
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "c", (function() {
				return s
			})), r.d(e, "a", (function() {
				return i
			})), r.d(e, "e", (function() {
				return o
			})), r.d(e, "f", (function() {
				return d
			})), r.d(e, "g", (function() {
				return c
			})), r.d(e, "d", (function() {
				return a
			}));
			const n = "SUBREDDIT__RULES_LOADED",
				s = "SUBREDDIT__RULES_PENDING",
				i = "SUBREDDIT__RULES_FAILED",
				o = "SUBREDDIT__RULE_ADDED",
				d = "SUBREDDIT__RULE_EDITED",
				c = "SUBREDDIT__RULE_REMOVED",
				a = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return A
			})), r.d(e, "a", (function() {
				return D
			})), r.d(e, "b", (function() {
				return R
			})), r.d(e, "h", (function() {
				return N
			})), r.d(e, "g", (function() {
				return k
			})), r.d(e, "e", (function() {
				return v
			})), r.d(e, "f", (function() {
				return U
			})), r.d(e, "d", (function() {
				return L
			})), r.d(e, "j", (function() {
				return q
			})), r.d(e, "i", (function() {
				return B
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/invert.js"),
				i = r.n(s),
				o = r("./node_modules/lodash/pick.js"),
				d = r.n(o),
				c = r("./node_modules/lodash/xor.js"),
				a = r.n(c),
				u = r("./src/lib/constants/index.ts"),
				l = r("./src/lib/makeActionCreator/index.ts"),
				b = r("./src/reddit/endpoints/subreddit/settings.ts"),
				p = r("./src/telemetry/index.ts"),
				O = r("./src/reddit/actions/toaster.ts"),
				m = r("./src/graphql/operations/FetchSubredditsNotificationSettings.json"),
				f = r("./src/graphql/operations/UpdateSubredditNotificationSettings.json"),
				_ = r("./src/lib/makeGqlRequest/index.ts");
			const g = (t, e, r) => Object(_.a)(t, Object.assign(Object.assign({}, f), {
				variables: {
					input: Object.assign(Object.assign({}, r), {
						subredditId: e
					})
				}
			}));
			var j = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				E = r("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				y = r("./src/reddit/models/Toast/index.ts"),
				S = r("./src/reddit/models/User/index.ts"),
				T = r("./src/reddit/selectors/subreddit.ts"),
				h = r("./src/reddit/selectors/subredditSettings.ts"),
				I = r("./src/reddit/selectors/user.ts"),
				C = r("./src/reddit/selectors/widgets.ts");
			const A = "SUBREDDIT_SETTINGS_LOADED",
				x = Object(l.a)(A),
				D = "SUBREDDIT_NOTIFICATION_SETTINGS_LOADED",
				w = Object(l.a)(D),
				R = "SUBREDDIT_NOTIFICATION_SETTINGS_UPDATED",
				P = Object(l.a)(R),
				N = (t, e) => async (r, n, s) => {
					let {
						apiContext: i,
						gqlContext: o
					} = s;
					if (!e || !Object(T.U)(n(), e)) {
						const e = await Object(b.c)(i(), t);
						e && e.ok && r(x(e.body))
					}
					if (e && !Object(h.b)(n(), {
							subredditId: e
						})) {
						const t = await ((t, e) => Object(_.a)(t, Object.assign(Object.assign({}, m), {
							variables: {
								subredditIds: [e]
							}
						})))(o(), e);
						if (t && t.ok) {
							const e = t.body,
								n = Object(j.e)(e.data);
							r(w(n))
						}
					}
				}, k = () => async (t, e, r) => {
					let {
						apiContext: n
					} = r;
					const s = Object(I.i)(e());
					s && await t(N(u.Ub + Object(S.e)(s)))
				}, v = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", U = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", L = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", M = Object(l.a)(v), G = Object(l.a)(U), F = Object(l.a)(L), q = function t(e, r) {
					let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
						o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (c, u, l) => {
						let {
							apiContext: m,
							gqlContext: f
						} = l;
						c(M());
						const _ = u(),
							j = d()(Object(T.U)(_, e), ...Object.keys(r)),
							S = d()(Object(h.b)(_, {
								subredditId: e
							}), ...Object.keys(s)),
							I = await Object(b.g)(m(), e, r),
							A = Object.keys(s).length > 0;
						let x = !0;
						if (A) {
							x = (await g(f(), e, s)).ok
						}
						if (!I.ok || A && !x) c(F()), c(Object(O.e)({
							kind: y.b.Error,
							text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: n.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: t(e, r, S)
						})), o && Object(p.a)(Object(E.c)(_, "BE returned an error:"));
						else {
							const d = Object(b.d)(I.body, i()(b.a));
							c(G({
								settings: Object.assign(Object.assign({}, d), {
									subredditId: e
								}),
								idCardWidgetId: Object(C.c)(_, {
									subredditId: e
								})
							})), A && c(P({
								notificationSettings: s,
								subredditId: e
							}));
							const u = {};
							o && 0 === a()(Object.keys(r), Object.keys(j)).length && (u.buttonText = n.fbt._("Undo", null, {
								hk: "1Gskii"
							}), u.buttonAction = t(e, j, S, o)), c(Object(O.e)(Object.assign({
								kind: y.b.SuccessCommunity,
								text: n.fbt._("Subreddit settings updated successfully", null, {
									hk: "2fmdlZ"
								})
							}, u)))
						}
					}
				}, B = (t, e) => async (r, s, i) => {
					let {
						apiContext: o
					} = i;
					(await Object(b.e)(o(), t, e)).ok ? r(Object(O.e)({
						kind: y.b.SuccessCommunity,
						text: n.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : r(Object(O.e)({
						kind: y.b.Error,
						text: n.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "c", (function() {
				return s
			})), r.d(e, "a", (function() {
				return i
			})), r.d(e, "h", (function() {
				return o
			})), r.d(e, "i", (function() {
				return d
			})), r.d(e, "g", (function() {
				return c
			})), r.d(e, "f", (function() {
				return a
			})), r.d(e, "d", (function() {
				return u
			})), r.d(e, "e", (function() {
				return l
			}));
			const n = "SUBSCRIPTION__FETCH_DATA_PENDING",
				s = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				i = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				o = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				d = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				c = "SUBSCRIPTION__ORDER_LOADED",
				a = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "e", (function() {
				return N
			})), r.d(e, "d", (function() {
				return v
			})), r.d(e, "c", (function() {
				return L
			})), r.d(e, "a", (function() {
				return G
			})), r.d(e, "b", (function() {
				return q
			}));
			r("./node_modules/core-js/modules/es6.regexp.replace.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeActionCreator/index.ts"),
				o = r("./src/lib/linkMatchers/customLinks.ts"),
				d = r("./src/reddit/actions/login.ts"),
				c = r("./src/reddit/actions/modal.ts"),
				a = r("./src/reddit/actions/subscription/constants.ts"),
				u = r("./src/reddit/actions/toaster.ts"),
				l = r("./src/reddit/constants/posts.ts"),
				b = r("./src/lib/makeApiRequest/index.ts"),
				p = r("./src/lib/omitHeaders/index.ts"),
				O = r("./src/reddit/constants/headers.ts");
			var m = r("./src/graphql/operations/SubscribedSubreddits.json"),
				f = r("./src/lib/makeGqlRequest/index.ts"),
				_ = r("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var g = r("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				j = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				E = r("./src/reddit/models/GqlTopLevelField.ts"),
				y = r("./src/reddit/models/User/index.ts");

			function S(t) {
				const e = [],
					r = [],
					n = {},
					s = {},
					{
						followedRedditorsInfo: i
					} = t.identity;
				for (const d of i.edges) {
					if (d.node.__typename !== y.c.AvailableRedditor) continue;
					const t = Object(g.a)(d.node.profile);
					n[t.id] = t;
					const {
						isFavorite: r
					} = d.node.profile;
					r && e.push(t.id)
				}
				const {
					subscribedSubreddits: o
				} = t.identity;
				for (const d of o.edges) {
					if (d.node.__typename !== E.a.Subreddit) continue;
					const t = Object(j.a)(d.node);
					s[t.id] = t;
					const {
						isFavorite: e
					} = d.node;
					e && r.push(t.id)
				}
				return {
					favoriteProfileIds: e,
					favoriteSubredditIds: r,
					profiles: n,
					subreddits: s
				}
			}
			var T = r("./src/reddit/models/Toast/index.ts"),
				h = r("./src/reddit/selectors/profile.ts"),
				I = r("./src/reddit/selectors/subreddit.ts"),
				C = r("./src/reddit/selectors/subscriptions.ts"),
				A = r("./src/reddit/selectors/user.ts");
			const x = () => n.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				D = Object(i.a)(a.c),
				w = Object(i.a)(a.b),
				R = Object(i.a)(a.a),
				P = Object(i.a)(a.h),
				N = (Object(i.a)(a.i), Object(i.a)(a.g), () => async (t, e, r) => {
					let {
						gqlContext: n
					} = r;
					const s = e();
					if (!s.user.account || s.subscriptions.api.fetched) return;
					t(w());
					const i = await (t => Object(f.a)(t, m))(n());
					if (i.ok) {
						const e = S(i.body.data);
						t(D(e))
					} else t(R({
						error: i.error
					}))
				}),
				k = (t, e) => e.type === l.a.PROFILE && t.displayText === e.name.replace("u_", ""),
				v = (t, e, r) => async (i, a, m) => {
					let {
						apiContext: f
					} = m, g = t.map(t => t.type === l.a.SUBREDDIT ? {
						id: Object(I.G)(a(), t.name),
						name: t.name,
						type: t.type
					} : {
						id: Object(h.m)(a(), t.name),
						name: "".concat(s.Ub).concat(t.name),
						type: t.type
					});
					if (!Object(A.I)(a())) return i(Object(c.k)({
						actionSource: c.a.Subscribe
					})), void i(Object(d.i)());
					const j = Object(A.i)(a());
					if (j) {
						const e = g.length,
							r = t.length;
						if (g = g.filter(t => !k(j, t)), (t = t.filter(t => !k(j, t))).length !== r || g.length !== e) {
							const t = n.fbt._("You cannot follow yourself!", null, {
								hk: "3tfSaq"
							});
							i(Object(u.e)(Object(u.d)(t, T.b.Error)))
						}
						if (!t.length && !g.length) return
					}
					if (i(P({
							identifiers: g,
							nameIdentifiers: t,
							profileModels: a().profiles.models,
							subredditModels: a().subreddits.models,
							subscriptionsCount: Object(C.b)(a()),
							userIsSubscriber: e,
							widgetId: r
						})), (await ((t, e) => {
							let {
								subredditIds: r,
								subredditNames: n,
								subscribe: i
							} = e;
							return Object(b.a)(Object(p.a)(t, [O.a]), {
								method: s.db.POST,
								endpoint: Object(_.a)("".concat(t.apiUrl, "/api/subscribe")),
								data: {
									action: i ? "sub" : "unsub",
									sr: r && r.join(",") || void 0,
									sr_name: n && n.join(",") || void 0,
									api_type: "json"
								}
							})
						})(f(), {
							subredditNames: g.map(t => {
								let {
									name: e
								} = t;
								return e
							}),
							subscribe: e
						})).ok) {
						const r = 1 === t.length ? "".concat("subreddit" === t[0].type ? o.d.subreddit : o.d.profile).concat(t[0].name) : "".concat(n.fbt.plural("community", t.length, {
							many: "communities",
							name: "communities",
							showCount: "yes"
						}));
						i(Object(u.e)({
							text: 1 === t.length && "profile" === t[0].type ? n.fbt._("Sucessfully {verb} {communityname}", [n.fbt._param("verb", e ? "followed" : "unfollowed"), n.fbt._param("communityname", r)], {
								hk: "1hY5KX"
							}) : n.fbt._("Sucessfully {verb} {communityname}", [n.fbt._param("verb", e ? "joined" : "left"), n.fbt._param("communityname", r)], {
								hk: "1hY5KX"
							})
						}))
					} else {
						i(P({
							identifiers: g,
							nameIdentifiers: t,
							profileModels: a().profiles.models,
							subredditModels: a().subreddits.models,
							subscriptionsCount: Object(C.b)(a()),
							userIsSubscriber: !e,
							widgetId: r
						}));
						const s = n.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						i(Object(u.e)(Object(u.d)(s, T.b.Error)))
					}
				}, U = Object(i.a)(a.f), L = t => async (e, r, n) => {
					let {
						apiContext: i
					} = n;
					const o = r(),
						d = Object(I.M)(o, {
							identifier: t
						});
					if (!d) throw new Error("actions.subscription -- No subreddit or profile found with id ".concat(t.id));
					const c = t.type === l.a.SUBREDDIT ? d.name : "u_".concat(d.name),
						a = o.subscriptions.favoriteSubredditOrder || [],
						m = o.subscriptions.favoriteProfileOrder || [],
						f = a.indexOf(t.id),
						_ = m.indexOf(t.id),
						g = -1 === f && -1 === _,
						j = o.subreddits.models,
						E = o.profiles.models;
					e(U({
						makeFavorite: g,
						identifier: t,
						subredditModels: j,
						profileModels: E
					}));
					const y = {
							type: t.type,
							name: d.name
						},
						S = () => Object(I.fb)(r(), {
							identifier: y
						});
					(S() || (await e(v([y], !0)), S())) && ((await ((t, e, r) => Object(b.a)(Object(p.a)(t, [O.a]), {
						method: s.db.POST,
						endpoint: "".concat(t.apiUrl, "/api/favorite"),
						data: {
							make_favorite: r ? "true" : "false",
							sr_name: e,
							api_type: "json"
						}
					}))(i(), c, g)).ok || (e(U({
						makeFavorite: !g,
						identifier: t,
						subredditModels: j,
						profileModels: E
					})), e(Object(u.e)({
						text: x(),
						kind: T.b.Error
					}))))
				}, M = Object(i.a)(a.d), G = t => async (e, r, n) => {
					let {
						apiContext: i
					} = n;
					const o = r().multireddits.models,
						d = () => {
							e(Object(u.e)({
								text: x(),
								kind: T.b.Error
							}))
						},
						c = o[t];
					if (!c) return void d();
					const a = !c.isFavorited;
					e(M({
						makeFavorite: a,
						multiredditPath: t,
						multiredditsModelsState: o
					})), (await ((t, e, r) => Object(b.a)(Object(p.a)(t, [O.a]), {
						method: s.db.POST,
						endpoint: "".concat(t.apiUrl, "/api/multi/favorite"),
						data: {
							make_favorite: r ? "true" : "false",
							multipath: e,
							api_type: "json"
						}
					}))(i(), t, a)).ok || (e(M({
						makeFavorite: !a,
						multiredditPath: t,
						multiredditsModelsState: o
					})), d())
				}, F = Object(i.a)(a.e), q = t => async (e, r, i) => {
					let {
						apiContext: o
					} = i;
					const d = r(),
						c = d.multireddits.models;
					if (!Object(A.I)(d)) return;
					const a = function() {
							let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							e(Object(u.e)({
								text: n.fbt._("Sorry, failed to {followAction}", [n.fbt._param("followAction", t ? n.fbt._("follow", null, {
									hk: "2I4uia"
								}) : n.fbt._("unfollow", null, {
									hk: "1ZDqgR"
								}))], {
									hk: "1ufRSl"
								}),
								kind: T.b.Error
							}))
						},
						l = c[t];
					if (!l) return void a();
					const m = !l.isFollowed;
					e(F({
						follow: m,
						multiredditPath: t,
						multiredditsModelsState: c
					})), (await ((t, e, r) => Object(b.a)(Object(p.a)(t, [O.a]), {
						method: s.db.POST,
						endpoint: "".concat(t.apiUrl, "/api/multi/subscribe"),
						data: {
							action: r ? "sub" : "unsub",
							path: e,
							api_type: "json"
						},
						type: "json"
					}))(o(), t, m)).ok || (e(F({
						follow: !m,
						multiredditPath: t,
						multiredditsModelsState: c
					})), a(m))
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(t, e, r) {
			"use strict";
			r.d(e, "t", (function() {
				return n
			})), r.d(e, "j", (function() {
				return s
			})), r.d(e, "r", (function() {
				return i
			})), r.d(e, "q", (function() {
				return o
			})), r.d(e, "s", (function() {
				return d
			})), r.d(e, "l", (function() {
				return c
			})), r.d(e, "m", (function() {
				return a
			})), r.d(e, "k", (function() {
				return u
			})), r.d(e, "o", (function() {
				return l
			})), r.d(e, "p", (function() {
				return b
			})), r.d(e, "n", (function() {
				return p
			})), r.d(e, "v", (function() {
				return O
			})), r.d(e, "w", (function() {
				return m
			})), r.d(e, "u", (function() {
				return f
			})), r.d(e, "g", (function() {
				return _
			})), r.d(e, "h", (function() {
				return g
			})), r.d(e, "f", (function() {
				return j
			})), r.d(e, "A", (function() {
				return E
			})), r.d(e, "z", (function() {
				return y
			})), r.d(e, "D", (function() {
				return S
			})), r.d(e, "y", (function() {
				return T
			})), r.d(e, "C", (function() {
				return h
			})), r.d(e, "x", (function() {
				return I
			})), r.d(e, "B", (function() {
				return C
			})), r.d(e, "e", (function() {
				return A
			})), r.d(e, "b", (function() {
				return x
			})), r.d(e, "d", (function() {
				return D
			})), r.d(e, "c", (function() {
				return w
			})), r.d(e, "a", (function() {
				return R
			})), r.d(e, "i", (function() {
				return P
			}));
			const n = "TAGS__REQUESTED",
				s = "TAGS__AVAILABLE_LOADED",
				i = "TAGS__LOADED",
				o = "TAGS__FAILURE",
				d = "TAGS__RELEVANCE_LOADED",
				c = "TAGS__CREATE_REQUESTED",
				a = "TAGS__CREATE_SUCCESS",
				u = "TAGS__CREATE_FAILURE",
				l = "TAGS__DELETE_REQUESTED",
				b = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				O = "TAGS__UPDATE_STATE_REQUESTED",
				m = "TAGS__UPDATE_STATE_SUCCESS",
				f = "TAGS__UPDATE_STATE_FAILURE",
				_ = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				g = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				j = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				E = "TAGS__OPTIONS_CANCELLED",
				y = "TAGS__OPTION_SELECTED",
				S = "TAGS__SUGGESTED_OPTION_SELECTED",
				T = "TAGS__OPTION_DESELECTED",
				h = "TAGS__SUGGESTED_OPTION_DESELECTED",
				I = "TAGS__INPUT_CHANGED",
				C = "TAGS__SUGGESTED_INPUT_CHANGED",
				A = "GLOBAL__TAGS__LOADED",
				x = "CREATION__TAGS_INPUT_CHANGED",
				D = "CREATION__TAGS_OPTION_SELECTED",
				w = "CREATION__TAGS_OPTION_DESELECTED",
				R = "CREATION__PRIMARY_TAG_SELECTED",
				P = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "n", (function() {
				return M
			})), r.d(e, "q", (function() {
				return G
			})), r.d(e, "m", (function() {
				return F
			})), r.d(e, "p", (function() {
				return q
			})), r.d(e, "l", (function() {
				return B
			})), r.d(e, "o", (function() {
				return K
			})), r.d(e, "c", (function() {
				return H
			})), r.d(e, "b", (function() {
				return Y
			})), r.d(e, "a", (function() {
				return V
			})), r.d(e, "d", (function() {
				return Q
			})), r.d(e, "j", (function() {
				return X
			})), r.d(e, "k", (function() {
				return $
			})), r.d(e, "f", (function() {
				return et
			})), r.d(e, "i", (function() {
				return st
			})), r.d(e, "h", (function() {
				return it
			})), r.d(e, "e", (function() {
				return ot
			})), r.d(e, "r", (function() {
				return dt
			})), r.d(e, "g", (function() {
				return ct
			})), r.d(e, "s", (function() {
				return at
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/makeActionCreator/index.ts"),
				i = r("./src/reddit/actions/tags/constants.ts"),
				o = r("./src/reddit/actions/toaster.ts");
			const d = t => {
				const {
					subredditInfoById: e
				} = t, r = {
					global: {},
					[e.id]: {}
				};
				e.availableTags && e.availableTags.edges.reduce((t, e) => {
					let {
						node: r
					} = e;
					return t[r.subreddit && r.subreddit.id || "global"][r.id] = r, t
				}, r);
				const n = {
					[e.id]: {}
				};
				e.secondaryTags && e.secondaryTags.edges.reduce((t, r) => {
					let {
						node: n
					} = r;
					return t[e.id][n.tag.id] = n, t
				}, n);
				const s = {
					[e.id]: {}
				};
				return e.suggestedTags && e.suggestedTags.edges.reduce((t, r) => {
					let {
						node: n
					} = r;
					return t[e.id][n.tag.id] = n, t
				}, s), {
					primaryTag: e.primaryTag,
					globalSubredditTags: r.global,
					subredditScopedTags: {
						[e.id]: r[e.id]
					},
					subredditId: e.id,
					itemTags: n,
					suggestedItemTags: s,
					geoPlace: e.geoPlace
				}
			};
			var c = r("./src/graphql/operations/CreateSubredditTags.json"),
				a = r("./src/lib/makeGqlRequest/index.ts");
			var u = r("./src/graphql/operations/FetchGlobalTags.json"),
				l = r("./src/graphql/operations/FetchSubredditTags.json");
			const b = 1050,
				p = (t, e) => {
					let {
						subredditId: r,
						pageSize: n = b,
						after: s,
						includeAvailableTags: i
					} = e;
					return Object(a.a)(t, Object.assign(Object.assign({}, l), {
						variables: {
							subredditId: r,
							pageSize: n,
							after: s,
							includeAvailableTags: i
						}
					}))
				};
			var O = r("./src/graphql/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			const m = (t, e) => Object(a.a)(t, Object.assign(Object.assign({}, O), {
				variables: Object.assign(Object.assign({}, e), {
					deleteTags: 0 !== e.deleteTagsInput.length,
					pageSize: b
				})
			}));
			var f = r("./src/graphql/operations/UpdateSubredditTagStatesRelevance.json");
			const _ = (t, e) => Object(a.a)(t, Object.assign(Object.assign({}, f), {
				variables: e
			}));
			var g = r("./src/graphql/operations/UpdateSubredditPrimaryTag.json");
			const j = t => {
					const {
						secondaryTags: e,
						id: r,
						primaryTag: n
					} = t.updateSubredditTagStates.subreddit, s = e && e.edges || [];
					return {
						subredditId: r,
						primaryTagId: n && n.tag.id || null,
						secondaryTags: s.reduce((t, e) => {
							let {
								node: r
							} = e;
							return t[r.tag.id] = r, t
						}, {})
					}
				},
				E = (t, e) => Object(a.a)(t, Object.assign(Object.assign({}, g), {
					variables: e
				}));
			var y = r("./src/reddit/helpers/tags/index.ts"),
				S = r("./src/reddit/helpers/trackers/communityTopics.ts"),
				T = r("./src/reddit/models/Tags/index.ts"),
				h = r("./src/reddit/models/Toast/index.ts"),
				I = r("./src/reddit/reducers/tags/selected/index.ts"),
				C = r("./src/reddit/selectors/tags.ts");
			const A = Object(s.a)(i.e),
				x = Object(s.a)(i.t),
				D = Object(s.a)(i.r),
				w = Object(s.a)(i.s),
				R = Object(s.a)(i.q),
				P = Object(s.a)(i.l),
				N = Object(s.a)(i.m),
				k = Object(s.a)(i.k),
				v = Object(s.a)(i.v),
				U = Object(s.a)(i.w),
				L = Object(s.a)(i.u),
				M = Object(s.a)(i.z),
				G = Object(s.a)(i.D),
				F = Object(s.a)(i.y),
				q = Object(s.a)(i.C),
				B = Object(s.a)(i.x),
				K = Object(s.a)(i.B),
				H = Object(s.a)(i.d),
				Y = Object(s.a)(i.c),
				V = Object(s.a)(i.b),
				W = Object(s.a)(i.g),
				J = Object(s.a)(i.h),
				z = Object(s.a)(i.f),
				Q = Object(s.a)(i.a),
				X = Object(s.a)(i.i),
				Z = Object(s.a)(i.A),
				$ = function t(e, r) {
					let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (i, c, a) => {
						let {
							gqlContext: u
						} = a;
						const l = c();
						i(x());
						const b = await p(u(), {
								subredditId: e
							}),
							O = b.body;
						if (b.ok && O.data.subredditInfoById.secondaryTags && O.data.subredditInfoById.availableTags && O.data.subredditInfoById.suggestedTags) i(D(d(O.data))), s && S.h(c(), e, {
							context: r
						});
						else {
							i(R());
							const d = s ? "topics_save" : "topics_load";
							S.g(l, e, d, {
								context: r
							}), i(Object(o.e)(Object(o.d)(n.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
								hk: "2DUkWX"
							}), h.b.Error, n.fbt._("Retry", null, {
								hk: "1c2xrJ"
							}), t(e, r, s))))
						}
					}
				},
				tt = t => async (e, r, s) => {
					let {
						gqlContext: i
					} = s;
					e(x());
					const c = await p(i(), {
						subredditId: t
					});
					if (c.ok) {
						const t = c.body;
						e(w(d(t.data)))
					} else e(R()), e(Object(o.e)(Object(o.d)(n.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), h.b.Error, n.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), w(t))))
				}, et = () => async (t, e, r) => {
					let {
						gqlContext: n
					} = r;
					const s = e();
					if (Object(C.r)(s)) return;
					t(x());
					const i = await ((t, e) => {
						let {
							pageSize: r = b,
							after: n
						} = e;
						return Object(a.a)(t, Object.assign(Object.assign({}, u), {
							variables: {
								pageSize: r,
								after: n
							}
						}))
					})(n(), {});
					if (i.ok) {
						const e = i.body;
						t(A((t => {
							return {
								globalSubredditTags: t.globalTags.edges.reduce((t, e) => (t[e.node.id] = e.node, t), {})
							}
						})(e.data)))
					}
				}, rt = (t, e) => async (r, n, s) => {
					let {
						gqlContext: i
					} = s;
					if (!e.length) return null;
					r(P());
					const o = e.map(e => Object.assign({
							subredditId: t
						}, e)),
						d = await ((t, e) => Object(a.a)(t, Object.assign(Object.assign({}, c), {
							variables: e
						})))(i(), {
							input: o
						}),
						u = d.body && d.body.data || null;
					return d.ok && u && u.createSubredditTags && u.createSubredditTags.ok ? (r(N()), u.createSubredditTags.createdTags || []) : (r(k()), null)
				}, nt = function(t, e) {
					let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (n, s, i) => {
						let {
							gqlContext: o
						} = i;
						if (!e.length && !r.length) return;
						n(v());
						const c = s(),
							a = Object(C.d)(c, {
								subredditId: t
							}),
							u = Object(C.s)(c, {
								itemId: t
							}),
							l = Object(C.C)(c, {
								itemId: t
							}),
							b = new Set;
						for (const t of e)
							if (t.state === T.d.NONE && a[t.tagId] && !l[t.tagId]) {
								!!r.find(e => e.state === T.d.TAGGED && e.tagId === t.tagId) || b.add(t.tagId)
							} for (const t of r)
							if (t.state === T.d.NONE && a[t.tagId] && !u[t.tagId]) {
								!!e.find(e => e.state === T.d.TAGGED && e.tagId === t.tagId) || b.add(t.tagId)
							} const p = await m(o(), {
								deleteTagsInput: [...b].map(t => ({
									tagId: t
								})),
								updateTagStatesInput: {
									subredditId: t,
									suggestedTagStates: r,
									tagStates: e
								}
							}),
							O = p.body && p.body.data || null;
						p.ok && O && O.updateSubredditTagStates && O.updateSubredditTagStates.ok && O.updateSubredditTagStates.subreddit ? n(U(d({
							subredditInfoById: O.updateSubredditTagStates.subreddit
						}))) : n(L())
					}
				}, st = function t(e, r) {
					let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (i, d, c) => {
						const a = d(),
							u = Object(C.u)(a, {
								subredditId: e
							}),
							l = Object(C.F)(a, {
								subredditId: e
							});
						let b = u.filter(t => !!t.id && !!t.action).map(t => ({
							tagId: t.id,
							state: t.action === I.a.ADD ? T.d.TAGGED : T.d.NONE
						}));
						if (l.length > 0) {
							const t = await rt(e, l)(i, d, c);
							b = b.concat((t || []).map(t => ({
								tagId: t.id,
								state: T.d.TAGGED
							})))
						}
						await nt(e, b)(i, d, c), Object(C.D)(d()) ? i(Object(o.e)(Object(o.d)(n.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
							hk: "2Jbh5V"
						}), h.b.Error, n.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), t(e, r, s)))) : s && i(Object(o.e)(Object(o.d)(n.fbt._("Community topics saved!", null, {
							hk: "3wtajT"
						}), h.b.SuccessCommunity)))
					}
				}, it = (t, e, r) => async (r, s, i) => {
					const d = {
						state: T.d.TAGGED
					};
					if (Object(y.b)(e)) {
						const n = await rt(t, [{
							text: e.displayText,
							type: T.c.CLASSIFICATION
						}])(r, s, i);
						n && 1 === n.length && (d.tagId = n[0].id)
					} else {
						if (!e.id) return void r(Object(o.e)(Object(o.d)(n.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), h.b.Error)));
						d.tagId = e.id
					}(t => !!t.tagId && !!t.state)(d) ? await nt(t, [], [d])(r, s, i): r(Object(o.e)(Object(o.d)(n.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), h.b.Error)))
				}, ot = (t, e, r) => async (n, s, i) => {
					e.id ? await nt(t, [], [{
						state: T.d.NONE,
						tagId: e.id
					}])(n, s, i) : n($(t, r, !1))
				}, dt = function t(e, r, s, i) {
					let d = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (c, a, u) => {
						let {
							gqlContext: l
						} = u;
						if (!(await _(l(), {
								input: {
									tagStatesRelevance: r,
									suggestedTagStatesRelevance: s
								}
							})).ok) return c(Object(o.e)(Object(o.d)(n.fbt._("Whoops! Unable to update topics relevance status", null, {
							hk: "17akdT"
						}), h.b.Error, n.fbt._("Retry", null, {
							hk: "1wqK2v"
						}), t(e, r, s, i, d)))), void c(tt(e));
						if (d)
							for (const t of s) S.f(a(), t, {
								context: i
							});
						c(Object(o.e)(Object(o.d)(n.fbt._("Successfully updated topics relevance!", null, {
							hk: "3KIYlz"
						}), h.b.SuccessCommunity, n.fbt._("Undo", null, {
							hk: "34apPL"
						}), t(e, r.map(t => Object.assign(Object.assign({}, t), {
							isRelevant: !t.isRelevant
						})), s.map(t => Object.assign(Object.assign({}, t), {
							isRelevant: !t.isRelevant
						})), i, d)))), c(tt(e))
					}
				}, ct = t => async (e, r) => {
					e(Z({
						itemTagsState: {
							[t]: Object(C.s)(r(), {
								itemId: t
							})
						}
					}))
				}, at = function t(e, r) {
					let s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (i, d, c) => {
						let {
							gqlContext: a
						} = c;
						i(W());
						const u = await E(a(), {
								input: {
									subredditId: e,
									primaryTagState: r
								}
							}),
							l = u.body && u.body.data || null;
						u.ok && l && l.updateSubredditTagStates && l.updateSubredditTagStates.ok ? (i(J(j(l))), s && i(Object(o.e)(Object(o.d)(n.fbt._("Successfully updated primary topic!", null, {
							hk: "1NL90v"
						}), h.b.SuccessCommunity)))) : (i(z()), i(Object(o.e)(Object(o.d)(n.fbt._("Whoops! Unable to update primary topic", null, {
							hk: "3ilZqp"
						}), h.b.Error, n.fbt._("Retry", null, {
							hk: "1dRYXW"
						}), t(e, r)))))
					}
				}
		},
		"./src/reddit/constants/gold.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "d", (function() {
				return i
			})), r.d(e, "e", (function() {
				return o
			})), r.d(e, "f", (function() {
				return d
			})), r.d(e, "c", (function() {
				return c
			})), r.d(e, "i", (function() {
				return a
			})), r.d(e, "h", (function() {
				return u
			})), r.d(e, "g", (function() {
				return l
			}));
			const n = "ModerationPage--Modal--AddAward",
				s = "ModerationPage--Modal--DeleteAwardConfirmation",
				i = 20,
				o = 4,
				d = 1e4,
				c = .2,
				a = .1,
				u = .1,
				l = 500
		},
		"./src/reddit/constants/graphql.ts": function(t, e, r) {
			"use strict";
			var n;
			r.d(e, "a", (function() {
					return n
				})),
				function(t) {
					t.Card = "CARD", t.Classic = "CLASSIC", t.Compact = "COMPACT"
				}(n || (n = {}))
		},
		"./src/reddit/endpoints/category/subreddits.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return a
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeApiRequest/index.ts"),
				i = r("./src/lib/omitHeaders/index.ts"),
				o = r("./src/reddit/constants/headers.ts"),
				d = r("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				c = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const a = t => {
				const e = [],
					r = [],
					n = {},
					s = {};
				return t.data.children.forEach(t => {
					let {
						data: i
					} = t;
					const o = Object(d.a)(i);
					e.push(o.id), r.push(o.name), n[o.id] = o, s[o.id] = {
						accountsActive: i.accounts_active,
						allOriginalContent: i.all_original_content,
						bannerBackgroundColor: i.banner_background_color,
						bannerBackgroundImage: i.banner_background_image,
						contentCategory: i.content_category,
						allowChatPostCreation: i.allow_chat_post_creation,
						keyColor: i.key_color,
						originalContentTagEnabled: i.original_content_tag_enabled,
						publicDescription: i.public_description,
						subscribers: i.subscribers,
						userIsSubscriber: i.user_is_subscriber
					}
				}), {
					subredditIds: e,
					subredditNames: r,
					subreddits: n,
					subredditsAboutInfo: s
				}
			};
			e.a = function(t, e) {
				let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
				return Object(s.a)(Object(i.a)(t, [o.a]), {
					endpoint: Object(c.a)("".concat(t.apiUrl, "/api/subreddits_in_category.json?category_id=").concat(e, "&limit=").concat(r)),
					method: n.db.GET
				})
			}
		},
		"./src/reddit/endpoints/flair/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "g", (function() {
				return a
			})), r.d(e, "h", (function() {
				return u
			})), r.d(e, "i", (function() {
				return l
			})), r.d(e, "l", (function() {
				return b
			})), r.d(e, "k", (function() {
				return p
			})), r.d(e, "j", (function() {
				return O
			})), r.d(e, "f", (function() {
				return m
			})), r.d(e, "b", (function() {
				return f
			})), r.d(e, "e", (function() {
				return _
			})), r.d(e, "d", (function() {
				return g
			})), r.d(e, "a", (function() {
				return j
			})), r.d(e, "c", (function() {
				return E
			}));
			var n = r("./src/config.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeApiRequest/index.ts"),
				o = r("./src/lib/omitHeaders/index.ts"),
				d = r("./src/reddit/constants/headers.ts"),
				c = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const a = (t, e, r, n, c, a) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/r/").concat(r, "/api/selectflair"),
					method: s.db.POST,
					data: {
						api_type: "json",
						flair_template_id: n,
						name: e,
						text: c,
						css_class: a
					}
				}),
				u = (t, e, r, n) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/selectflair"),
					method: s.db.POST,
					data: {
						api_type: "json",
						flair_template_id: r,
						link: e,
						text: n
					}
				}),
				l = (t, e, r) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/r/").concat(r, "/api/setflairenabled"),
					method: s.db.POST,
					data: {
						api_type: "json",
						flair_enabled: e
					}
				}),
				b = async (t, e, r) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/enable_sr_user_flair.json"),
					method: s.db.POST,
					data: {
						subreddit: e,
						enabled: r
					}
				}), p = async (t, e, r) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/enable_sr_link_flair.json"),
					method: s.db.POST,
					data: {
						subreddit: e,
						enabled: r
					}
				}), O = async (t, e, r, n) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/enable_sr_user_flair_self_assign.json"),
					method: s.db.POST,
					data: {
						subreddit: n,
						flair_type: r,
						enabled: e
					}
				}), m = async (t, e, r, n) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/flairtemplate_v2"),
					method: s.db.POST,
					data: {
						allowable_content: e.allowableContent,
						css_class: e.cssClass,
						flair_template_id: e.id,
						text: e.text,
						text_editable: e.textEditable,
						flair_type: n,
						text_color: e.textColor,
						background_color: e.backgroundColor,
						max_emojis: e.maxEmojis,
						mod_only: e.modOnly,
						r
					}
				}), f = async (t, e, r) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/deleteflairtemplate"),
					method: s.db.POST,
					data: {
						flair_template_id: e,
						r
					}
				}), _ = async (t, e, r, n) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/v1/").concat(e, "/flair_template_order/").concat(r),
					method: s.db.PATCH,
					type: "json",
					data: n
				}), g = async (t, e) => Object(i.a)(t, {
					endpoint: "".concat(n.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(e, "/userFlair"),
					method: s.db.GET,
					headers: {
						[d.a]: d.a
					}
				}), j = async (t, e, r) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/r/").concat(r, "/api/deleteflair"),
					method: s.db.POST,
					data: {
						api_type: "json",
						name: e
					}
				}), E = async (t, e) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: Object(c.a)("".concat(t.apiUrl, "/api/top_flair_in_subreddit.json?subreddit=").concat(e)),
					method: s.db.GET
				})
		},
		"./src/reddit/endpoints/gold/communityAwards.ts": function(t, e, r) {
			"use strict";
			r.d(e, "d", (function() {
				return T
			})), r.d(e, "p", (function() {
				return h
			})), r.d(e, "a", (function() {
				return I
			})), r.d(e, "c", (function() {
				return C
			})), r.d(e, "b", (function() {
				return A
			})), r.d(e, "k", (function() {
				return x
			})), r.d(e, "l", (function() {
				return D
			})), r.d(e, "j", (function() {
				return w
			})), r.d(e, "n", (function() {
				return R
			})), r.d(e, "o", (function() {
				return P
			})), r.d(e, "f", (function() {
				return N
			})), r.d(e, "g", (function() {
				return k
			})), r.d(e, "m", (function() {
				return v
			})), r.d(e, "h", (function() {
				return U
			})), r.d(e, "i", (function() {
				return L
			})), r.d(e, "e", (function() {
				return M
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeApiRequest/index.ts"),
				i = r("./src/lib/makeGqlRequest/index.ts"),
				o = r("./src/lib/omitHeaders/index.ts"),
				d = r("./src/lib/uploadToS3/index.ts"),
				c = r("./src/graphql/operations/AwardSheetInfo.json"),
				a = r("./src/graphql/operations/AwardSheetInfoForProfile.json"),
				u = r("./src/graphql/operations/CreateCommunityAward.json"),
				l = r("./src/graphql/operations/CreateGlobalAward.json"),
				b = r("./src/graphql/operations/CreateModAward.json"),
				p = r("./src/graphql/operations/DisableAwardInCommunity.json"),
				O = r("./src/graphql/operations/EnableAwardInCommunity.json"),
				m = r("./src/graphql/operations/GlobalAwards.json"),
				f = r("./src/graphql/operations/ManageableAwards.json"),
				_ = r("./src/graphql/operations/ManageableAwardsForProfile.json"),
				g = r("./src/graphql/operations/RemoveCommunityAward.json"),
				j = r("./src/graphql/operations/UsableAwards.json"),
				E = r("./src/graphql/operations/UsableAwardsForProfile.json"),
				y = r("./src/reddit/constants/headers.ts"),
				S = r("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts");
			const T = (t, e, r, i) => {
					const d = {
						subreddit: e,
						filepath: r,
						mimetype: i
					};
					return Object(s.a)(Object(o.a)(t, [y.a]), {
						method: n.db.POST,
						endpoint: "".concat(t.apiUrl, "/api/v1/community_awards/award_asset_upload_s3"),
						data: d
					})
				},
				h = async (t, e) => Object(d.a)(e, t), I = (t, e, r, n, s, o, d, c, a) => Object(i.a)(t, Object.assign(Object.assign({}, u), {
					variables: {
						coinPrice: d,
						iconHeight: o,
						iconWidth: s,
						iconUrl: n,
						name: r,
						subredditId: e,
						startsAt: c,
						endsAt: a
					}
				})), C = (t, e, r, n, s, o, d, c, a) => Object(i.a)(t, Object.assign(Object.assign({}, b), {
					variables: {
						iconHeight: o,
						iconWidth: s,
						iconUrl: n,
						monthsOfPremium: d,
						name: r,
						subredditId: e,
						startsAt: c,
						endsAt: a
					}
				})), A = t => {
					let {
						awardSubType: e,
						coinPrice: r,
						coinReward: n,
						context: s,
						daysOfDripExtension: o,
						daysOfPremium: d,
						description: c,
						endsAt: a,
						giverCoinReward: u,
						iconFormat: b,
						iconHeight: p,
						iconUrl: O,
						iconWidth: m,
						isNew: f,
						name: _,
						pennyPrice: g,
						pennyDonate: j,
						startsAt: E,
						subredditCoinReward: y
					} = t;
					return Object(i.a)(s, Object.assign(Object.assign({}, l), {
						variables: {
							awardSubType: e,
							iconFormat: b,
							iconHeight: p,
							iconWidth: m,
							iconUrl: O,
							isNew: f,
							daysOfPremium: d,
							daysOfDripExtension: o,
							description: c,
							coinPrice: r,
							coinReward: n,
							name: _,
							pennyPrice: g,
							pennyDonate: j,
							giverCoinReward: u,
							startsAt: E,
							endsAt: a,
							subredditCoinReward: y
						}
					}))
				}, x = (t, e) => Object(i.a)(t, Object.assign(Object.assign({}, f), {
					variables: {
						subredditId: e
					}
				})), D = (t, e) => Object(i.a)(t, Object.assign(Object.assign({}, _), {
					variables: {
						profileName: e
					}
				})), w = t => Object(i.a)(t, Object.assign({}, m)), R = (t, e, r) => Object(i.a)(t, Object.assign(Object.assign({}, j), {
					variables: {
						subredditId: e,
						includeAppreciation: !0,
						includePremium: !0,
						includeGroup: r
					}
				})), P = (t, e, r) => Object(i.a)(t, Object.assign(Object.assign({}, E), {
					variables: {
						profileName: e,
						includeAppreciation: !0,
						includePremium: !0,
						includeGroup: r
					}
				})), N = (t, e, r, n) => Object(i.a)(t, Object.assign(Object.assign({}, c), {
					variables: {
						subredditId: e,
						thingId: r,
						includeGroup: n
					}
				})), k = (t, e, r, n) => Object(i.a)(t, Object.assign(Object.assign({}, a), {
					variables: {
						profileName: e,
						thingId: r,
						includeGroup: n
					}
				})), v = (t, e) => Object(i.a)(t, Object.assign(Object.assign({}, g), {
					variables: {
						awardId: e
					}
				})), U = (t, e, r) => Object(i.a)(t, Object.assign(Object.assign({}, p), {
					variables: {
						awardId: e,
						subredditId: r
					}
				})), L = (t, e, r) => Object(i.a)(t, Object.assign(Object.assign({}, O), {
					variables: {
						awardId: e,
						subredditId: r
					}
				})), M = async (t, e, r) => {
					const i = {
						api_type: "json",
						award_id: e,
						raw_json: 1
					};
					return Object(s.a)(Object(o.a)(t, [y.a]), {
						method: n.db.POST,
						endpoint: "".concat(t.apiUrl, "/api/report_award"),
						data: i
					}).then(t => t.ok ? Object.assign({}, t) : Object.assign(Object.assign({}, t), {
						error: Object(S.a)(t)
					}))
				}
		},
		"./src/reddit/endpoints/gold/topAwarded.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return o
			})), r.d(e, "b", (function() {
				return d
			}));
			var n = r("./src/graphql/operations/TopAwardedPosts.json"),
				s = r("./src/graphql/operations/TopAwardersLeaderboard.json"),
				i = r("./src/lib/makeGqlRequest/index.ts");
			const o = (t, e) => Object(i.a)(t, Object.assign(Object.assign({}, n), {
					variables: Object.assign(Object.assign({}, e), {
						includeListingMetadata: !!e.includeListingMetadata
					})
				})),
				d = (t, e) => Object(i.a)(t, Object.assign(Object.assign({}, s), {
					variables: e
				}))
		},
		"./src/reddit/endpoints/governance/posts.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			}));
			var n = r("./src/config.ts"),
				s = (r("./src/reddit/models/Poll/index.ts"), r("./src/reddit/endpoints/governance/requester.ts"));

			function i(t, e, r) {
				return Object(s.a)(t, {
					method: "get",
					endpoint: "".concat(n.a.metaUrl, "/polls/").concat(e, "?postIds=").concat(r.join(","))
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return s
			}));
			var n = r("./src/lib/makeApiRequest/index.ts");

			function s(t, e) {
				return Object(n.a)(t, Object.assign({
					type: "json"
				}, e)).then(t => {
					if (t.ok) return {
						body: t.body,
						ok: !0,
						status: t.status
					};
					return {
						error: t.error && t.error.fields && t.error.fields[0] ? t.error.fields[0].msg : Object.assign(Object.assign({}, t.body), {
							code: t.status
						}),
						ok: !1,
						status: t.status
					}
				})
			}
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return a
			})), r.d(e, "a", (function() {
				return u
			}));
			var n = r("./src/config.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeApiRequest/index.ts"),
				o = r("./src/lib/omitHeaders/index.ts"),
				d = r("./src/reddit/constants/headers.ts"),
				c = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const a = (t, e, r) => Object(i.a)(t, {
					endpoint: Object(c.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/").concat(e)),
					method: s.db.GET,
					data: Object.assign({
						moderated_limit: 25
					}, r)
				}),
				u = (t, e, r) => Object(i.a)(Object(o.a)(t, [d.a]), {
					endpoint: "".concat(t.apiUrl, "/api/v1/modactions/").concat(e),
					method: s.db.POST,
					type: "json",
					data: r
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(t, e, r) {
			"use strict";
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeApiRequest/index.ts"),
				i = r("./src/lib/omitHeaders/index.ts"),
				o = r("./src/reddit/constants/headers.ts");
			e.a = async t => Object(s.a)(Object(i.a)(t, [o.a]), {
				endpoint: "".concat(t.apiUrl, "/subreddit_permissions"),
				method: n.db.GET,
				traceRequestName: "get_subreddit_permissions"
			})
		},
		"./src/reddit/endpoints/page/search.ts": function(t, e, r) {
			"use strict";
			var n = r("./src/config.ts"),
				s = r("./src/lib/constants/index.ts"),
				i = r("./src/lib/makeApiRequest/index.ts"),
				o = r("./src/lib/search/index.ts"),
				d = r("./src/reddit/helpers/correlationIdTracker.ts"),
				c = r("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const a = (t, e) => {
				let r = e ? Object.assign(Object.assign({}, t), {
					type: t.restrict_sr ? "link" : t.type
				}) : t;
				(r = r.type ? r : Object.assign(Object.assign({}, r), {
					type: "link,sr,user"
				})).q = Object(o.a)(t.q);
				const n = Object(d.c)(d.a.SearchResults);
				return n && (r.search_correlation_id = n), r
			};
			e.a = (t, e, r, o) => Object(i.a)(t, {
				data: a(o || {}, e),
				endpoint: Object(c.a)(r ? "".concat(n.a.gatewayUrl, "/desktopapi/v1/multireddits/").concat(r, "/").concat(e, "/search") : e ? "".concat(n.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(e, "/search") : "".concat(n.a.gatewayUrl, "/desktopapi/v1/search")),
				method: s.db.GET
			})
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return y
			})), r.d(e, "b", (function() {
				return S
			}));
			r("./node_modules/core-js/modules/es6.array.sort.js"), r("./node_modules/core-js/modules/es6.regexp.split.js"), r("./node_modules/core-js/modules/es6.symbol.js");
			var n = r("./src/config.ts"),
				s = r("./src/graphql/operations/SubredditPage.json"),
				i = r("./src/lib/constants/index.ts"),
				o = r("./src/lib/isAdHocMultireddit/index.ts"),
				d = r("./src/lib/isFakeSubreddit/index.ts"),
				c = r("./src/lib/makeApiRequest/index.ts"),
				a = r("./src/lib/makeGqlRequest/index.ts"),
				u = r("./src/lib/performanceTimings/index.tsx"),
				l = r("./src/reddit/constants/graphql.ts"),
				b = r("./src/reddit/constants/page.ts"),
				p = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				O = r("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				m = r("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				f = r("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				_ = r("./src/reddit/models/Subreddit/index.ts"),
				g = r("./src/reddit/selectors/platform.ts"),
				j = r("./src/reddit/selectors/user.ts"),
				E = function(t, e) {
					var r = {};
					for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
					if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]])
					}
					return r
				};
			const y = (t, e, r) => {
					const {
						after: n,
						geo_filter: s,
						isMobile: i,
						layout: c,
						limit: a,
						recentPostIds: u,
						sort: p,
						t: m
					} = r, f = Object(j.P)(t), _ = Object(g.q)(t), E = Object(o.a)(e), y = Object(d.a)(e), S = {
						name: e,
						includeIdentity: f && !t.user.account,
						adContext: {
							layout: c ? c.toUpperCase() : l.a.Card,
							reddaid: t.user.reddaid
						},
						isFake: y,
						includeRecents: y && u && u.length > 0 || !1,
						includeTrending: y,
						isAdHocMulti: E,
						isAll: e === b.c.All,
						isPopular: e === b.c.Popular,
						recentPostIds: u || [],
						subredditNames: E ? e.split("+") : []
					};
					return p && (S.sort = p.toUpperCase()), m && (S.range = m.toUpperCase()), i ? S.pageSize = Object(O.a)(c) : a && (S.pageSize = a), _ && _.ad && (S.forceAds = {
						ad: _.ad
					}), (_ && _.geo_filter || s) && (S.region = _ && _.geo_filter || s), n && (S.after = btoa(n)), S
				},
				S = async (t, e, r) => {
					const n = Date.now(),
						o = await ((t, e) => Object(a.a)(t, Object.assign(Object.assign({}, s), {
							variables: e
						})))(t, e),
						d = Date.now();
					if (!o.ok || !o.body) return o;
					const c = o.body,
						l = Date.now(),
						b = Object(m.a)(c.data),
						p = Date.now(),
						O = [{
							duration: d - n,
							logKeyType: u.a.gqlFetchTiming
						}, {
							duration: p - l,
							logKeyType: u.a.gqlNormalizationTiming
						}];
					return Object(u.h)({
						name: i.p.SUBREDDIT,
						isLoggedIn: r,
						metrics: O
					}), Object.assign(Object.assign({}, o), {
						ok: !!c.data.subredditInfoByName && !Object(_.h)(c.data.subredditInfoByName),
						status: T(c.data),
						body: b
					})
				}, T = t => {
					if (!t.subredditInfoByName) return 404;
					if (Object(_.h)(t.subredditInfoByName)) {
						if (t.subredditInfoByName.forbiddenReason === _.b.Banned) return 404;
						if (t.subredditInfoByName.forbiddenReason === _.b.GoldOnly || t.subredditInfoByName.forbiddenReason === _.b.Private || t.subredditInfoByName.forbiddenReason === _.b.Quarantined) return 403
					}
					return 200
				}, h = t => {
					var {
						recentPostIds: e
					} = t, r = E(t, ["recentPostIds"]);
					return e && e.length ? Object.assign(Object.assign({}, r), {
						recentPostIds: e.join(",")
					}) : r
				};
			e.a = (t, e, r) => Object(c.a)(t, {
				endpoint: Object(p.a)(Object(f.a)("".concat(n.a.gatewayUrl, "/desktopapi/v1/subreddits/").concat(e))),
				method: i.db.GET,
				data: r && h(r) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(t, e, r) {
			"use strict";
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeApiRequest/index.ts"),
				i = r("./src/lib/omitHeaders/index.ts"),
				o = r("./src/reddit/constants/headers.ts"),
				d = r("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = r("./src/reddit/models/PostCreationForm/index.ts");
			e.a = (t, e, r) => {
				const a = {
					output_mode: "markdown" === e ? e : "rtjson"
				};
				return e === c.h.MARKDOWN ? a.richtext_json = r : a.markdown_text = r, Object(s.a)(Object(i.a)(t, [o.a]), {
					endpoint: Object(d.a)("".concat(t.apiUrl, "/api/convert_rte_body_format")),
					method: n.db.POST,
					data: a
				})
			}
		},
		"./src/reddit/endpoints/profile/info.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return u
			})), r.d(e, "a", (function() {
				return l
			})), r.d(e, "d", (function() {
				return b
			})), r.d(e, "b", (function() {
				return p
			}));
			var n = r("./src/graphql/operations/ProfileModHubPage.json"),
				s = r("./src/graphql/operations/RedditorKarma.json"),
				i = r("./src/lib/constants/index.ts"),
				o = r("./src/lib/makeApiRequest/index.ts"),
				d = r("./src/lib/makeGqlRequest/index.ts"),
				c = r("./src/lib/omitHeaders/index.ts"),
				a = r("./src/reddit/constants/headers.ts");
			const u = (t, e) => Object(o.a)(Object(c.a)(t, [a.a]), {
					endpoint: "".concat(t.apiUrl, "/user/").concat(e, "/about.json"),
					method: i.db.GET,
					data: {
						gilding_detail: 1,
						awarded_detail: 1,
						raw_json: 1
					}
				}),
				l = {
					awardeeKarma: 0,
					awarderKarma: 0,
					commentKarma: 0,
					postKarma: 0,
					totalKarma: 0
				},
				b = (t, e) => Object(d.a)(t, Object.assign(Object.assign({}, s), {
					variables: {
						name: e
					}
				})),
				p = (t, e) => Object(d.a)(t, Object.assign(Object.assign({}, n), {
					variables: {
						name: e
					}
				}))
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return f
			})), r.d(e, "c", (function() {
				return _
			})), r.d(e, "e", (function() {
				return g
			})), r.d(e, "g", (function() {
				return j
			})), r.d(e, "f", (function() {
				return E
			})), r.d(e, "d", (function() {
				return y
			})), r.d(e, "h", (function() {
				return S
			})), r.d(e, "i", (function() {
				return T
			})), r.d(e, "j", (function() {
				return h
			})), r.d(e, "k", (function() {
				return D
			})), r.d(e, "a", (function() {
				return w
			}));
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./node_modules/lodash/omit.js"),
				i = r.n(s),
				o = r("./src/config.ts"),
				d = r("./src/lib/addQueryParams/index.ts"),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/constants/headers.ts"),
				u = r("./src/lib/makeRequest/index.ts"),
				l = r("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				b = r("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				p = r("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				O = r("./src/reddit/models/PostCreationForm/index.ts"),
				m = r("./src/reddit/models/Vote/index.ts");
			const f = async t => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/rpan_config_v1"),
				method: c.db.GET,
				headers: i()(t.headers(), [a.c, a.b]),
				timeoutMs: void 0
			}).then(A), _ = async (t, e) => {
				let r;
				return r = e === l.R ? "/config" : "/".concat(e, "/config"), Object(u.b)({
					endpoint: "".concat(o.a.streamingApiUrl).concat(r),
					method: c.db.GET,
					headers: i()(t.headers(), [a.c, a.b]),
					timeoutMs: void 0
				}).then(A)
			}, g = async (t, e) => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(e),
				method: c.db.GET,
				headers: i()(t.headers(), [a.c, a.b])
			}).then(A), j = async t => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos"),
				method: c.db.GET,
				headers: i()(t.headers(), [a.c, a.b])
			}).then(A), E = async (t, e, r) => {
				let n;
				n = e === l.R ? "/broadcasts" : "/".concat(e, "/broadcasts");
				const s = Object(d.a)(n, {
					cursor: null == r ? void 0 : r.cursor,
					page_size: null == r ? void 0 : r.pageSize
				});
				return Object(u.b)({
					endpoint: "".concat(o.a.streamingApiUrl).concat(s),
					method: c.db.GET,
					headers: i()(t.headers(), [a.c, a.b])
				}).then(A)
			}, y = async t => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/recommended_viewer_subreddits"),
				method: c.db.GET,
				headers: i()(t.headers(), [a.c, a.b])
			}).then(A), S = async (t, e, r) => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(e, "/vote/").concat(x(r)),
				method: c.db.POST,
				headers: i()(t.headers, [a.c, a.b])
			}).then(A), T = async (t, e) => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/videos/").concat(e, "/heartbeat"),
				method: c.db.POST,
				headers: i()(t.headers(), [a.c, a.b])
			}).then(A), h = async (t, e, r, n) => {
				const s = r.rteState;
				if (!s) return Promise.reject(new Error("Editor state is undefined"));
				const i = b.a.getRawText(s);
				return i ? I(t, e, i).then(t => t.ok && t.body && t.body.data ? Object.assign(Object.assign({}, t), {
					body: {
						parentId: e,
						comment: Object.assign(Object.assign({}, Object(p.a)(t.body.data.r2_comment, n)), {
							media: C(s)
						}),
						automuteLevel: t.body.data.auto_mute_status.level
					},
					error: void 0
				}) : t) : Promise.reject(new Error("Cannot send empty message"))
			}, I = async (t, e, r) => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/broadcasts/").concat(e, "/comment_v2"),
				method: c.db.POST,
				headers: i()(t.headers, [a.c, a.b]),
				data: {
					text: r
				},
				type: "json"
			}).then(A), C = t => ({
				type: "rtjson",
				richtextContent: {
					document: b.a.toRichTextJSON(t).document
				},
				rteMode: O.h.RICH_TEXT
			}), A = t => {
				if (t.ok) return Object.assign(Object.assign({}, t), {
					error: void 0
				}); {
					const e = {
						type: 404 === t.status ? c.E.NOT_FOUND_ERROR : c.E.SERVER_ERROR
					};
					return 429 === t.status && (e.fields = [{
						field: "",
						msg: n.fbt._("Try again later", null, {
							hk: "3BBLIU"
						})
					}]), Object.assign(Object.assign({}, t), {
						error: e
					})
				}
			}, x = t => t === m.a.upvoted ? "up" : t === m.a.downvoted ? "down" : "unset", D = async (t, e, r) => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/broadcasts/").concat(e),
				method: c.db.PUT,
				headers: i()(t.headers, [a.c, a.b]),
				data: {
					data: {
						chat_disabled: r
					}
				},
				type: "json"
			}).then(A), w = async (t, e) => Object(u.b)({
				endpoint: "".concat(o.a.streamingApiUrl, "/broadcasts/").concat(e, "/auto_mute_status"),
				method: c.db.GET,
				headers: i()(t.headers, [a.c, a.b])
			}).then(A)
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(t, e, r) {
			"use strict";
			var n = r("./src/graphql/operations/SubredditAbout.json"),
				s = r("./src/lib/makeGqlRequest/index.ts");
			e.a = (t, e, r) => Object(s.a)(t, Object.assign(Object.assign({}, n), {
				variables: {
					subredditName: e,
					includeSubreddit: r
				}
			}))
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return f
			})), r.d(e, "c", (function() {
				return _
			})), r.d(e, "a", (function() {
				return j
			})), r.d(e, "f", (function() {
				return E
			})), r.d(e, "d", (function() {
				return y
			})), r.d(e, "e", (function() {
				return T
			}));
			var n = r("./node_modules/lodash/camelCase.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/mapKeys.js"),
				o = r.n(i),
				d = r("./src/graphql/operations/SubredditRules.json"),
				c = r("./src/lib/constants/index.ts"),
				a = r("./src/lib/makeApiRequest/index.ts"),
				u = r("./src/lib/makeGqlRequest/index.ts"),
				l = r("./src/lib/omitHeaders/index.ts"),
				b = r("./src/reddit/constants/headers.ts"),
				p = r("./src/reddit/helpers/graphql/helpers.ts"),
				O = r("./src/reddit/models/Rule/index.ts");
			const m = t => {
					let {
						rules: e
					} = t;
					return {
						rules: e.map(t => Object.assign(Object.assign({}, o()(t, (t, e) => s()(e))), {
							kind: "link" === t.kind ? "post" : t.kind
						}))
					}
				},
				f = (t, e) => Object(u.a)(t, Object.assign(Object.assign({}, d), {
					variables: {
						subredditName: e
					}
				})).then(t => (t.ok && t.body && (t.body = (t => {
					return {
						rules: (t.data.subreddit && t.data.subreddit.rules || []).map(t => ({
							kind: O.c[t.kind],
							description: t.content.markdown,
							descriptionRichText: t.content.richtext,
							shortName: t.name,
							violationReason: t.violationReason || "",
							createdUtc: Object(p.d)(t.createdAt, p.a.Millis),
							priority: t.priority
						}))
					}
				})(t.body)), t)),
				_ = (t, e) => Object(a.a)(Object(l.a)(t, [b.a]), {
					endpoint: "".concat(t.apiUrl, "/user/").concat(e, "/about/rules.json"),
					method: c.db.GET
				}).then(t => (t.ok && t.body.rules && (t.body = m(t.body)), t)),
				g = t => t.ok ? (t.body = Object(O.h)(JSON.parse(t.body.json.data.rules)), t) : t.body,
				j = async (t, e, r) => Object(a.a)(Object(l.a)(t, [b.a]), {
					endpoint: "".concat(t.apiUrl, "/api/add_subreddit_rule"),
					method: c.db.POST,
					data: {
						r: e,
						short_name: r.rule,
						kind: r.kind === O.b.post ? "link" : r.kind,
						violation_reason: r.reason,
						description: r.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(t => g(t)), E = async (t, e, r, n) => Object(a.a)(Object(l.a)(t, [b.a]), {
					endpoint: "".concat(t.apiUrl, "/api/update_subreddit_rule"),
					method: c.db.POST,
					data: {
						r: e,
						short_name: r.rule,
						kind: r.kind === O.b.post ? "link" : r.kind,
						violation_reason: r.reason,
						description: r.description,
						old_short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(t => g(t)), y = async (t, e, r) => Object(a.a)(Object(l.a)(t, [b.a]), {
					endpoint: "".concat(t.apiUrl, "/api/remove_subreddit_rule"),
					method: c.db.POST,
					data: {
						r: e,
						short_name: r,
						api_type: "json",
						raw_json: 1
					}
				}).then(t => g(t)), S = t => t.map(t => encodeURIComponent(t)).join(), T = async (t, e, r) => Object(a.a)(Object(l.a)(t, [b.a]), {
					endpoint: "".concat(t.apiUrl, "/api/reorder_subreddit_rules"),
					method: c.db.POST,
					data: {
						r: e,
						new_rule_order: S(r),
						api_type: "json",
						raw_json: 1
					}
				}).then(t => g(t))
		},
		"./src/reddit/helpers/awards/getAwardItemId.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			const n = (t, e) => "awardItem__".concat(e, "-").concat(t)
		},
		"./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return s
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			const n = new Set(["t5_22cerq"]),
				s = t => n.has(t);
			e.a = s
		},
		"./src/reddit/helpers/commentList/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return d
			})), r.d(e, "c", (function() {
				return c
			})), r.d(e, "d", (function() {
				return a
			})), r.d(e, "e", (function() {
				return u
			})), r.d(e, "a", (function() {
				return l
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/reddit/constants/comments.ts"),
				s = r("./src/reddit/selectors/comments.ts"),
				i = r("./src/reddit/constants/experiments.ts"),
				o = r("./src/reddit/helpers/chooseVariant/index.ts");
			const d = (t, e) => e().comments.models[t],
				c = t => {
					switch (t.commentLink.type) {
						case n.a.Comment:
							return t.commentsDict[t.commentLink.id];
						case n.a.MoreComments:
							return t.moreCommentsDict[t.commentLink.id];
						case n.a.ContinueThread:
							return t.continueThreadDict[t.commentLink.id]
					}
				},
				a = (t, e) => t.type === n.a.MoreComments ? e[t.id].numComments : 1,
				u = (t, e, r, n) => {
					let i = Object(s.o)(n, {
							commentLink: e,
							commentsPageKey: t
						}),
						o = e;
					for (; i && i.depth > r && i.prev && (o = i.prev, (i = Object(s.o)(n, {
							commentLink: o,
							commentsPageKey: t
						})) && !(i.depth <= r)););
					return o.id
				},
				l = (t, e, r) => {
					const {
						commentLists: n,
						comments: s
					} = t, {
						head: d
					} = n[e];
					if (d) return Object.keys(s).filter(t => {
						const e = s[t];
						return !(!e.isStickied || !((t, e) => {
							const r = Object(o.c)(t, {
								experimentEligibilitySelector: o.a,
								experimentName: i.r,
								expEventOverride: e
							});
							return !!(Object(i.Nc)(r) ? void 0 : r)
						})(r)) || (t => !1 !== t.collapsed)(e)
					})
				}
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "a", (function() {
				return s
			}));
			r("./node_modules/core-js/modules/es6.array.sort.js");

			function n(t, e) {
				if (t.placement && !e.placement) return -1;
				if (e.placement && !t.placement) return 1;
				if (t.position && !e.position) return -1;
				if (e.position && !t.position) return 1;
				let r = 0;
				return t.placement && e.placement && (r = t.placement.localeCompare(e.placement)), 0 === r && t.position && e.position && (r = t.position - e.position), 0 === r && (r = t.title.localeCompare(e.title)), r
			}

			function s(t) {
				return [...t].sort(n)
			}
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(t, e, r) {
			"use strict";
			r("./node_modules/core-js/modules/es6.symbol.js");
			var n = r("./node_modules/lodash/findLastIndex.js"),
				s = r.n(n),
				i = r("./src/reddit/models/WhitelistStatus/index.ts"),
				o = r("./src/reddit/selectors/telemetry.ts"),
				d = r("./src/telemetry/index.ts"),
				c = function(t, e) {
					var r = {};
					for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
					if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]])
					}
					return r
				};
			const a = (t, e) => {
				let {
					subreddits: r,
					profiles: n
				} = e;
				const s = r[t.belongsTo.id] || n[t.belongsTo.id];
				return !t.isNSFW && s && i.a.has(s.wls || i.b.NO_ADS)
			};
			e.a = (t, e, r) => {
				var {
					postIds: n,
					posts: i,
					subreddits: u,
					profiles: l
				} = r, b = c(r, ["postIds", "posts", "subreddits", "profiles"]);
				const p = t.listings.postOrder.ids[e],
					O = (n || []).filter(t => !p || !p.includes(t)),
					m = p.map(e => t.posts.models[e]),
					f = m.length - (s()(m, t => t.isSponsored) + 1),
					_ = O.map(t => i[t]);
				let g;
				const j = [],
					E = {
						subreddits: u,
						profiles: l
					};
				for (let s = 0; s < _.length; s++) {
					const r = _[s];
					let n = !1;
					if (r.isSponsored) {
						const t = s > 0 && _[s - 1],
							e = s < _.length - 1 && _[s + 1];
						t && a(t, E) && e && a(e, E) && (n = !0)
					}
					r.isSponsored && n && (null == g && f + s >= 3 || s - g >= 3) ? (g = s, j.push(r.id)) : r.isSponsored ? r.isSponsored && Object(d.a)(Object.assign(Object.assign({
						source: "feed",
						action: "remove",
						noun: "ad"
					}, o.defaults(t)), {
						listing: o.listing(t, e)
					})) : j.push(r.id)
				}
				return Object.assign(Object.assign({}, b), {
					subreddits: u,
					profiles: l,
					posts: i,
					postIds: j
				})
			}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(t, e, r) {
			"use strict";
			var n = r("./node_modules/fbt/lib/FbtPublic.js"),
				s = r("./src/lib/constants/index.ts");
			e.a = () => ({
				type: s.E.SERVER_ERROR,
				fields: [{
					field: "",
					msg: n.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return s
			}));
			var n = r("./src/reddit/constants/postLayout.ts");

			function s(t) {
				return t ? n.c[t] : n.f
			}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts": function(t, e, r) {
			"use strict";
			var n = r("./src/reddit/models/Flair/index.ts");

			function s(t) {
				switch (t) {
					case n.g.LEFT:
						return n.b.Left;
					case n.g.RIGHT:
						return n.b.Right;
					default:
						return null
				}
			}

			function i(t) {
				let {
					isEnabled: e = !1,
					position: r
				} = t;
				return {
					isEnabled: e,
					position: s(r)
				}
			}
			e.a = t => {
				let {
					postFlairSettings: e
				} = t;
				return Object.assign({}, e && {
					displaySettings: e && i(e)
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return s
			}));
			var n = r("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const s = t => {
				let {
					edges: e
				} = t;
				const r = [];
				for (const {
						node: s
					} of e) r.push(Object(n.e)(s));
				return r
			}
		},
		"./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return d
			}));
			var n = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				s = r("./src/reddit/models/Subreddit/index.ts"),
				i = r("./src/reddit/models/User/index.ts"),
				o = r("./src/reddit/models/WhitelistStatus/index.ts");
			const d = t => {
				let {
					pageInfo: e,
					edges: r
				} = t;
				const s = {
					moderatedSubredditIds: [],
					pageInfo: e,
					subreddits: {}
				};
				for (const {
						node: i
					} of r) {
					const t = Object(n.a)(i);
					s.subreddits[t.id] = t, s.moderatedSubredditIds.push(t.id)
				}
				return s
			};
			e.a = t => {
				let {
					name: e,
					path: r,
					redditorInfo: n,
					styles: d,
					wls: c,
					id: a,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				} = t;
				const {
					height: O,
					icon: m,
					width: f
				} = d && d.legacyIcon && {
					height: d.legacyIcon.dimensions.height,
					icon: d.legacyIcon.url,
					width: d.legacyIcon.dimensions.width
				} || {
					height: null,
					icon: d && d.icon || "",
					width: null
				}, _ = d && d.legacyPrimaryColor, g = n && n.__typename === i.c.AvailableRedditor && n.prefixedName || "";
				return Object.assign(Object.assign(Object.assign({
					url: r,
					displayText: g,
					icon: {
						url: m,
						width: f,
						height: O
					},
					communityIcon: m,
					type: s.e.User,
					name: e.substr(2)
				}, _ && {
					primaryColor: _
				}), c && {
					whitelistStatus: c.toLowerCase(),
					wls: o.b[c]
				}), {
					id: a,
					title: u,
					isQuarantined: l,
					isNSFW: b,
					subscribers: p
				})
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts": function(t, e, r) {
			"use strict";
			e.a = t => {
				let {
					isAccessEnabled: e,
					isAllAllowed: r,
					isChatConfigEditingAllowed: n,
					isChatOperator: s,
					isConfigEditingAllowed: i,
					isFlairEditingAllowed: o,
					isMailEditingAllowed: d,
					isPostEditingAllowed: c,
					isWikiEditingAllowed: a
				} = t;
				return {
					access: !!e,
					all: !!r,
					chatConfig: !!n,
					chatOperator: !!s,
					config: !!i,
					flair: !!o,
					mail: !!d,
					posts: !!c,
					wiki: !!a
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return _
			}));
			var n = r("./src/reddit/models/Post/index.ts"),
				s = r("./src/reddit/models/RichTextJson/index.ts"),
				i = r("./src/reddit/models/Subreddit/index.ts"),
				o = r("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				d = r("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				c = r("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				a = r("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				u = r("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				l = r("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				b = r("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				p = r("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				O = r("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				m = r("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				f = r("./src/reddit/helpers/graphql/helpers.ts");
			const _ = (t, e, r) => {
				const s = {
						account: null,
						authorFlair: {},
						postIds: [],
						postInstances: {},
						posts: {},
						postFlair: {},
						preferences: null,
						profiles: {},
						recentPostIds: [],
						structuredStyles: {},
						subredditAboutInfo: {},
						subredditPermissions: {},
						subreddits: {},
						token: "",
						trendingSubredditIds: []
					},
					i = t => {
						if (t.__typename === n.f.DeletedProfilePost || t.__typename === n.f.DeletedSubredditPost) return null;
						if (s.posts[t.id]) return t.id;
						const e = Object(c.e)(t);
						s.posts[e.id] = e;
						const {
							crosspostRoot: r
						} = t;
						r && r.type === n.a.Post && r.postInfo && i(r.postInfo);
						let a = e.id;
						switch (t.authorFlair && (s.authorFlair[e.belongsTo.id] || (s.authorFlair[e.belongsTo.id] = {}), s.authorFlair[e.belongsTo.id][e.author] = Object(o.a)(t.authorFlair)[0]), t.__typename) {
							case n.f.ProfilePost:
								s.profiles[t.profile.id] || (s.profiles[t.profile.id] = Object(u.a)(t.profile));
								break;
							case n.f.SubredditPost:
								s.subreddits[t.subreddit.id] || (s.subreddits[t.subreddit.id] = Object(b.a)(t.subreddit)), s.postFlair[t.subreddit.id] || (s.postFlair[t.subreddit.id] = Object(d.a)(t.subreddit));
								break;
							case n.f.AdPost:
								const r = Object(c.b)(t);
								if (!r) {
									a = null;
									break
								}
								a = r, s.posts[r] = Object.assign(Object.assign({}, e), {
									id: r,
									permalink: "".concat(e.permalink, "?instanceId=").concat(encodeURIComponent(r))
								}), s.posts[e.id] || (s.posts[e.id] = Object.assign(Object.assign({}, e), {
									events: []
								})), s.postInstances[t.id] || (s.postInstances[t.id] = []), s.postInstances[t.id].push(r)
						}
						return a && s.postIds.push(a), a
					};
				if (t.forEach(t => i(t)), e) {
					s.trendingSubredditIds = e.map(t => t.id);
					for (const t of e) s.subreddits[t.id] = Object(b.a)(t)
				}
				const l = s.postIds.length - 1;
				return s.token = l >= 0 ? s.postIds[l] : "", r && (s.account = Object(m.a)(r), s.preferences = r.preferences && Object(a.a)(r.preferences, r.interactions) || null), s
			};
			e.a = t => {
				let {
					adhocMultiredditByNames: e,
					all: r,
					identity: n,
					popular: o,
					recentPosts: d,
					subredditInfoByName: c,
					trendingSubreddits: a
				} = t;
				if (!c) return {
					reason: i.d.NotFoundSubreddit,
					data: {
						account: n && Object(m.a)(n) || null
					}
				};
				if (Object(i.h)(c)) {
					const {
						banMessage: t,
						publicDescriptionText: e,
						quarantineMessage: r,
						isEmailRequiredForQuarantineOptin: i
					} = c;
					return {
						reason: g(c.forbiddenReason),
						data: Object.assign({
							account: n && Object(m.a)(n) || null,
							banMessage: t || void 0,
							description: e,
							quarantineRequiresEmailOptin: i
						}, r ? {
							quarantineMessage: r.markdown,
							quarantineMessageRTJson: Object(f.e)(r.richtext, s.i)
						} : {})
					}
				}
				const u = c || o || r || e,
					b = u.posts.edges.map(t => t.node);
				d && b.push(...d);
				const j = u.posts.dist,
					E = _(b, a, n);
				return c && c.styles && (E.structuredStyles = {
					data: {
						style: Object(O.a)(c.styles)
					}
				}), c && (E.subredditAboutInfo = Object(l.a)(c), c.modPermissions && (E.subredditPermissions = Object(p.a)(c.modPermissions))), Object.assign(Object.assign({}, E), null !== j && {
					dist: j
				})
			};
			const g = t => {
				switch (t) {
					case i.b.Banned:
						return i.d.BannedSubreddit;
					case i.b.GoldOnly:
						return i.d.GoldSubreddit;
					case i.b.Private:
						return i.d.PrivateSubreddit;
					case i.b.Quarantined:
						return i.d.QuarantinedSubreddit;
					case i.b.Unknown:
						return i.d.ForbiddenSubreddit
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return s
			})), r.d(e, "c", (function() {
				return i
			}));
			var n = r("./src/reddit/models/Gold/Award.ts");
			e.a = t => t.map(t => ({
				awardType: t.award_type,
				awardSubType: t.award_sub_type ? t.award_sub_type : n.b.Global,
				coinPrice: t.coin_price,
				coinReward: t.coin_reward,
				count: t.count,
				daysOfDripExtension: t.days_of_drip_extension,
				daysOfPremium: t.days_of_premium,
				description: t.description,
				iconUrl: t.icon_url,
				resizedIcons: t.resized_icons,
				resizedStaticIcons: t.resized_static_icons,
				id: t.id,
				isEnabled: t.is_enabled,
				isNew: !!t.is_new,
				name: t.name,
				staticIconUrl: t.static_icon_url,
				subredditCoinReward: t.subreddit_coin_reward,
				tags: t.tags,
				tiers: Object(n.n)(t.tiersByRequiredAwardings)
			}));
			const s = t => {
					const {
						icon_url: e,
						resized_icons: r,
						resized_static_icons: s,
						static_icon_url: i
					} = t;
					let o, d, c, a, u, l;
					for (const {
							url: n,
							width: b
						} of r || []) 32 === b && (o = {
						url: n
					}), 64 === b && (d = {
						url: n
					}), 128 === b && (c = {
						url: n
					});
					for (const {
							url: n,
							width: b
						} of s || []) 32 === b && (a = {
						url: n
					}), 64 === b && (u = {
						url: n
					}), 128 === b && (l = {
						url: n
					});
					return {
						awardType: t.award_type.toUpperCase(),
						awardSubType: t.award_sub_type ? t.award_sub_type.toUpperCase() : n.d.Global,
						coinPrice: t.coin_price,
						coinReward: t.coin_reward,
						daysOfDripExtension: t.days_of_drip_extension,
						daysOfPremium: t.days_of_premium,
						description: t.description,
						id: t.id,
						isEnabled: t.is_enabled,
						isNew: !!t.is_new,
						name: t.name,
						icon: {
							url: e
						},
						icon32: o,
						icon64: d,
						icon128: c,
						staticIcon: {
							url: i
						},
						staticIcon32: a,
						staticIcon64: u,
						staticIcon128: l,
						subredditCoinReward: t.subreddit_coin_reward,
						tags: t.tags,
						tiers: Object(n.n)(t.tiersByRequiredAwardings)
					}
				},
				i = t => {
					const {
						top_award: e,
						total_count: r
					} = t;
					return {
						topAward: e && s(e),
						totalCount: r
					}
				}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return a
			}));
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/reddit/helpers/isComment.ts"),
				i = r("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				o = r("./src/reddit/models/Vote/index.ts"),
				d = t => !0 === t ? o.a.upvoted : !1 === t ? o.a.downvoted : o.a.notVoted,
				c = r("./src/reddit/models/Comment/index.ts");
			e.a = (t, e) => {
				const r = {
					approvedAtUTC: t.approved_at_utc,
					approvedBy: t.approved_by,
					author: t.author,
					authorId: t.author_fullname,
					bannedAtUTC: t.banned_at_utc,
					bannedBy: t.banned_by,
					body: t.body_html,
					bodyMD: t.body,
					collapsed: t.collapsed,
					collapsedReason: t.collapsed_reason,
					collapsedBecauseCrowdControl: t.collapsed_because_crowd_control,
					commentType: t.comment_type,
					created: t.created_utc,
					deletedBy: u(t),
					distinguishType: t.distinguished || "",
					editedAt: null,
					id: t.name,
					ignoreReports: t.ignore_reports,
					isAdmin: "admin" === t.distinguished,
					isAuthorPremium: !!t.author_premium,
					isApproved: t.approved,
					isDeleted: t.author === n.A,
					isGildable: t.can_gild,
					isLocked: t.locked,
					isMod: "moderator" === t.distinguished,
					isOp: t.is_submitter,
					isRemoved: t.removed,
					isScoreHidden: t.score_hidden,
					isSpam: t.spam,
					isStickied: t.stickied,
					isSaved: t.isSaved,
					isSystem: !1,
					subredditId: t.subreddit_id,
					markdown: t.body,
					media: {
						mediaMetadata: t.media_metadata,
						type: "rtjson",
						richtextContent: a(t.rtjson),
						rteMode: t.rte_mode
					},
					modReports: t.mod_reports,
					modReportsDismissed: t.mod_reports_dismissed,
					numReports: t.num_reports,
					parentId: Object(s.a)(t.parent_id) ? t.parent_id : null,
					permalink: t.permalink,
					postAuthor: t.link_author || null,
					postId: t.link_id,
					postTitle: t.link_title || null,
					sendReplies: t.send_replies,
					score: t.score,
					treatmentTags: t.treatment_tags,
					userReports: t.user_reports,
					userReportsDismissed: t.user_reports_dismissed,
					voteState: d(t.likes)
				};
				return t.all_awardings && (r.allAwardings = Object(i.a)(t.all_awardings)), t.awarders && (r.awarders = t.awarders), t.associated_award && (r.associatedAwardId = t.associated_award.id, r.associatedAward = Object(i.b)(t.associated_award)), r
			};
			const a = t => "string" == typeof t ? JSON.parse(t) : t,
				u = t => t.author !== n.A ? null : t.body === n.B ? c.b.User : t.body === n.Ab ? c.b.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(t, e, r) {
			"use strict";
			var n = r("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				s = r("./src/reddit/models/Flair/index.ts"),
				i = r("./src/reddit/models/Media/index.ts"),
				o = r("./src/reddit/models/PostCreationForm/index.ts"),
				d = r("./src/reddit/models/Vote/index.ts");
			const c = t => {
					const e = [];
					return t.link_flair_richtext && t.link_flair_richtext.length && e.push({
						richtext: t.link_flair_richtext,
						type: s.f.Richtext,
						textColor: t.link_flair_text_color || "dark",
						backgroundColor: t.link_flair_background_color || "",
						templateId: t.link_flair_template_id
					}), t.link_flair_text && e.push({
						text: t.link_flair_text,
						type: s.f.Text,
						textColor: t.link_flair_text_color || "dark",
						backgroundColor: t.link_flair_background_color || "",
						templateId: t.link_flair_template_id
					}), t.spoiler && e.push({
						text: "spoiler",
						type: s.f.Spoiler
					}), t.over_18 && e.push({
						text: "nsfw",
						type: s.f.Nsfw
					}), e
				},
				a = t => t ? t.map(t => ({
					categoryId: t.category_id,
					categoryName: t.category_name
				})) : [],
				u = t => {
					const e = t.preview && t.preview.enabled;
					let r = !1,
						n = null,
						s = {},
						d = {};
					const c = t.over_18 || t.spoiler;
					if (t.preview && (r = !!(d = t.preview.images[0].variants).mp4, s = t.preview.images[0].source, c && (n = d.obfuscated.source.url)), t.is_self) return Object.assign({
						content: t.selftext_html,
						type: i.o.TEXT,
						markdownContent: t.selftext,
						obfuscated: n,
						rteMode: t.rte_mode || o.h.RICH_TEXT
					}, t.rtjson && {
						richtextContent: t.rtjson,
						type: i.o.RTJSON,
						mediaMetadata: t.media_metadata
					});
					if (t.media && t.media.reddit_video) {
						const e = t.media.reddit_video;
						return {
							hlsUrl: e.hls_url,
							dashUrl: e.dash_url,
							isGif: e.is_gif,
							scrubberThumbSource: e.scrubber_media_url,
							obfuscated: n,
							posterUrl: e.url,
							width: e.width,
							height: e.height,
							type: i.o.VIDEO
						}
					}
					if (t.media && t.media.rpan_video) {
						const e = t.media.rpan_video;
						return {
							hlsUrl: e.hls_url,
							scrubberThumbSource: e.scrubber_media_url,
							type: i.o.LIVEVIDEO
						}
					}
					if (t.secure_media && t.secure_media.oembed) {
						return {
							content: t.secure_media_embed.media_domain_url,
							type: i.o.EMBED,
							width: t.secure_media.oembed.width,
							height: t.secure_media.oembed.height,
							obfuscated: n,
							provider: t.secure_media.oembed.provider_name
						}
					}
					if (e && r) return {
						content: d.mp4.source.url,
						type: i.o.GIFVIDEO,
						width: d.mp4.source.width,
						height: d.mp4.source.height,
						gifBackgroundImage: s.url,
						gifBackgroundResolutions: t.preview.images[0].resolutions,
						obfuscated: n,
						resolutions: d.mp4.resolutions
					};
					if (e) {
						const e = d.gif ? d.gif.resolutions : t.preview.images[0].resolutions;
						return {
							content: s.url,
							type: i.o.IMAGE,
							width: s.width,
							height: s.height,
							obfuscated: n,
							resolutions: e
						}
					}
					return null
				},
				l = t => {
					const e = {};
					if (t.promoted && t.outbound_link || !t.is_self && !t.is_reddit_media_domain) {
						if (e.displayText = t.domain, e.url = t.url, t.outbound_link) {
							const r = t.outbound_link;
							e.outboundUrl = r.url, e.outboundUrlExpiration = r.expiration, e.outboundUrlCreated = r.created
						}
						return e
					}
					return null
				};
			e.a = t => {
				return {
					allAwardings: t.all_awardings ? Object(n.a)(t.all_awardings) : [],
					awarders: t.awarders,
					author: t.author,
					authorId: t.author_fullname,
					approvedAtUTC: t.approved_at_utc,
					approvedBy: t.approved_by,
					bannedAtUTC: t.banned_at_utc,
					bannedBy: t.banned_by,
					belongsTo: {
						type: "user" === t.subreddit_type ? "profile" : "subreddit",
						id: t.subreddit_id || ""
					},
					callToAction: t.call_to_action || null,
					contestMode: t.contest_mode,
					created: 1e3 * t.created,
					crosspostParentId: t.cross_post_parent_id || null,
					crosspostRootId: t.cross_post_root_id || null,
					discussionType: t.discussion_type || null,
					distinguishType: t.distinguish_type || null,
					domain: t.domain,
					domainOverride: t.domain_override || null,
					events: t.events || [],
					flair: c(t),
					hidden: t.hidden,
					id: t.name,
					ignoreReports: t.ignore_reports,
					isApproved: t.approved,
					isArchived: t.archived,
					isAuthorPremium: t.author_premium,
					isBlank: t.is_blank,
					isCrosspostable: t.is_crosspostable,
					isFollowed: t.is_followed || !1,
					isGildable: t.can_gild,
					isLocked: t.locked,
					isMediaOnly: t.media_only,
					isMeta: t.is_meta,
					isNSFW: t.over_18,
					isOriginalContent: t.is_original_content,
					isPinned: t.pinned,
					isRemoved: t.removed,
					isSpam: t.spam,
					isSpoiler: t.spoiler,
					isSponsored: t.promoted,
					isStickied: t.stickied,
					liveCommentsWebsocket: t.liveCommentsWebsocket || t.websocket_url,
					media: u(t),
					modNote: t.mod_note || null,
					modReports: t.mod_reports,
					numComments: t.num_comments,
					numCrossposts: t.num_crossposts || 0,
					numDuplicates: t.num_duplicates,
					numReports: t.num_reports || 0,
					permalink: "https://www.reddit.com".concat(t.permalink),
					postCategories: a(t.post_categories),
					preview: t.preview && t.preview.images && t.preview.images[0] && t.preview.images[0].source ? {
						url: t.preview.images[0].source.url,
						width: t.preview.images[0].source.width,
						height: t.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: t.previous_visits,
					postId: t.name,
					modRemovalReason: t.mod_reason_title,
					modReasonBy: t.mod_reason_by,
					removedBy: t.removed_by,
					removedByCategory: t.removed_by_category,
					saved: t.saved,
					score: t.score,
					topAwardedType: t.top_awarded_type && t.top_awarded_type.toUpperCase(),
					treatmentTags: t.treatment_tags,
					isScoreHidden: !!t.hide_score,
					sendReplies: t.send_replies,
					source: l(t),
					suggestedSort: t.suggested_sort,
					thumbnail: {
						url: t.thumbnail,
						width: t.thumbnail_width,
						height: t.thumbnail_height
					},
					title: t.title,
					userReports: t.user_reports,
					upvoteRatio: t.upvote_ratio,
					viewCount: t.view_count || 0,
					voteState: Object(d.d)(t.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return o
			}));
			var n = r("./src/lib/constants/index.ts");
			const s = t => {
					for (const e of t) {
						const t = e[0] || "";
						switch (t) {
							case n.E.NO_STRIPE_SUBSCRIPTION:
							case n.E.USER_DOESNT_EXIST:
							case n.E.USER_REQUIRED_ERROR:
							case n.E.VALIDATION_ERROR:
								return t;
							case n.E.NO_USER:
							case n.E.NO_TEXT:
							case n.E.NO_URL:
								return n.E.VALIDATION_ERROR;
							case n.E.CREDIT_CARD_FAILURE:
							case n.E.CREDIT_CARD_FAILURE_GENERIC:
								return n.E.CREDIT_CARD_FAILURE;
							default:
								if (t.startsWith("SUBMIT_VALIDATION")) return n.E.SUBMIT_VALIDATION_ERROR
						}
					}
					return n.E.VALIDATION_ERROR
				},
				i = t => {
					const e = t.body;
					return {
						type: s(e.json.errors),
						fields: e.json.errors.map(t => ({
							field: t[2] || "",
							msg: t[1]
						}))
					}
				},
				o = t => {
					const e = t.body;
					return !t.ok && e && e.json && e.json.errors ? Object.assign(Object.assign({}, t), {
						error: i(t)
					}) : t
				};
			e.a = i
		},
		"./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts": function(t, e, r) {
			"use strict";
			e.a = t => ({
				allowContractors: t.allow_contractors,
				communityIcon: t.community_icon,
				displayText: t.display_name_prefixed,
				icon: {
					height: t.icon_size ? t.icon_size[1] : 0,
					url: t.community_icon || t.icon_img || "",
					width: t.icon_size ? t.icon_size[0] : 0
				},
				id: t.name,
				isNSFW: t.over_18 || t.over18,
				isQuarantined: !!t.quarantine,
				name: t.display_name,
				primaryColor: t.primary_color,
				subscribers: t.subscribers,
				title: t.title,
				type: t.subreddit_type,
				url: t.url,
				wls: t.wls
			})
		},
		"./src/reddit/helpers/tags/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			})), r.d(e, "b", (function() {
				return o
			}));
			r("./node_modules/core-js/modules/es6.array.sort.js");
			var n = r("./node_modules/lodash/values.js"),
				s = r.n(n);
			const i = t => s()(t).sort((e, r) => {
					const n = t[e.tag.id].tag.text.toLowerCase(),
						s = t[r.tag.id].tag.text.toLowerCase();
					return n < s ? -1 : n > s ? 1 : 0
				}),
				o = t => !t.id && !!t.action
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(t, e, r) {
			"use strict";
			r.d(e, "f", (function() {
				return u
			})), r.d(e, "g", (function() {
				return l
			})), r.d(e, "b", (function() {
				return b
			})), r.d(e, "e", (function() {
				return p
			})), r.d(e, "a", (function() {
				return O
			})), r.d(e, "c", (function() {
				return m
			})), r.d(e, "d", (function() {
				return f
			}));
			var n = r("./src/telemetry/index.ts"),
				s = r("./src/reddit/constants/tracking.ts"),
				i = r("./src/reddit/models/PostDraft/index.ts"),
				o = r("./src/reddit/selectors/comments.ts"),
				d = r("./src/reddit/selectors/platform.ts"),
				c = r("./src/reddit/selectors/telemetry.ts");
			const a = t => {
					const e = Object(d.o)(t);
					return Object.assign(Object.assign({
						source: "comment_composer",
						action: s.c.CLICK
					}, Object(c.defaults)(t)), {
						screen: Object(c.screen)(t),
						subreddit: Object(c.subreddit)(t),
						post: e ? Object(c.post)(t, e) : null,
						profile: Object(c.profile)(t)
					})
				},
				u = (t, e, r, s) => {
					const i = {
							commentId: s,
							commentsPageKey: r
						},
						d = s && Object(o.j)(t, i) || 0;
					return Object(n.a)(Object.assign(Object.assign({
						noun: "comment"
					}, a(t)), {
						comment: s ? Object(c.comment)(t, s) : null,
						listing: Object(c.listing)(t, void 0, {
							depth: d
						}),
						commentComposer: {
							editorMode: e
						}
					}))
				},
				l = (t, e, r, s) => {
					const i = a(t);
					return Object(n.a)(Object.assign(Object.assign({}, i), {
						actionInfo: Object.assign(Object.assign({}, i.actionInfo), {
							reason: "karma_rate_limit"
						}),
						source: "backend",
						action: "error",
						noun: "comment",
						comment: {
							bodyText: e,
							parentId: s,
							postId: r
						}
					}))
				},
				b = t => Object(n.a)(Object.assign({
					noun: "cancel"
				}, a(t))),
				p = (t, e) => {
					e === i.c.replyToPost && Object(n.a)(Object.assign({
						noun: "input"
					}, a(t)))
				},
				O = (t, e) => Object(n.a)(Object.assign(Object.assign({
					source: "comment",
					noun: "delete",
					action: "click"
				}, Object(c.defaults)(e)), {
					screen: Object(c.screen)(e),
					subreddit: Object(c.subreddit)(e),
					post: Object(c.post)(e, t)
				})),
				m = t => Object(n.a)(Object.assign({
					noun: "edit"
				}, a(t))),
				f = t => Object(n.a)(Object.assign({
					noun: "save_edit"
				}, a(t)))
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "f", (function() {
				return b
			})), r.d(e, "c", (function() {
				return p
			})), r.d(e, "e", (function() {
				return O
			})), r.d(e, "d", (function() {
				return m
			})), r.d(e, "b", (function() {
				return f
			})), r.d(e, "h", (function() {
				return _
			})), r.d(e, "g", (function() {
				return g
			}));
			var n, s = r("./src/reddit/selectors/tags.ts"),
				i = r("./src/reddit/selectors/telemetry.ts"),
				o = r("./src/telemetry/index.ts");
			! function(t) {
				t.communitySettings = "community_settings", t.idCard = "id_card"
			}(n || (n = {}));
			const d = (t, e, r) => {
					const n = Object(s.A)(t, {
						subredditId: e
					});
					return !!n && n.id === r
				},
				c = (t, e) => Object(s.x)(t, {
					itemId: e
				}).reduce((t, e) => {
					let {
						topicTagIds: r,
						topicTagContents: n,
						topicTagTypes: s
					} = t;
					return r.push(e.tag.id), n.push(e.tag.text), s.push(e.tag.type), {
						topicTagIds: r,
						topicTagContents: n,
						topicTagTypes: s
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				a = (t, e, r) => {
					if (!r.id) return {
						content: r.displayText
					};
					const n = Object(s.b)(t)[r.id] || Object(s.d)(t, {
						subredditId: e
					})[r.id];
					return n ? {
						id: n.id,
						content: n.text,
						type: n.type,
						isPrimary: d(t, e, n.id)
					} : null
				},
				u = (t, e, r) => {
					if (!r) return null;
					const n = Object(s.b)(t)[r] || Object(s.d)(t, {
						subredditId: e
					})[r];
					return n ? {
						id: n.id,
						content: n.text,
						type: n.type,
						isPrimary: d(t, e, n.id)
					} : null
				},
				l = (t, e, r) => Object.assign(Object.assign({}, i.defaults(t)), {
					subreddit: Object.assign(Object.assign(Object.assign({}, i.subreddit(t) || {}), {
						id: e
					}), c(t, e)),
					source: r.context,
					action: "click"
				}),
				b = (t, e, r) => {
					Object(o.a)(((t, e, r) => Object.assign(Object.assign({}, l(t, e.subredditId, r)), {
						noun: e.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: u(t, e.subredditId, e.tagId)
					}))(t, e, r))
				},
				p = (t, e, r, n) => {
					Object(o.a)(Object.assign(Object.assign({}, l(t, e, n)), {
						topicTag: a(t, e, r),
						noun: "add_related_topic"
					}))
				},
				O = (t, e, r, n) => {
					return !Object(s.l)(t, {
						subredditId: e
					}) && r.id ? Object(o.a)(((t, e, r, n) => Object.assign(Object.assign({}, l(t, e, n)), {
						topicTag: a(t, e, r),
						noun: "topic_auto_suggest"
					}))(t, e, r, n)) : r.id ? Object(o.a)(((t, e, r, n) => Object.assign(Object.assign({}, l(t, e, n)), {
						topicTag: a(t, e, r),
						noun: "topic_auto_complete"
					}))(t, e, r, n)) : Object(o.a)(((t, e, r, n) => Object.assign(Object.assign({}, l(t, e, n)), {
						topicTag: a(t, e, r),
						noun: "topic_add_new"
					}))(t, e, r, n))
				},
				m = (t, e, r, n) => Object(o.a)(Object.assign(Object.assign({}, l(t, e, n)), {
					topicTag: a(t, e, r),
					noun: "topic_remove"
				})),
				f = (t, e, r) => Object(o.a)(Object.assign(Object.assign({}, l(t, e, r)), {
					noun: "topic_tag_field"
				})),
				_ = (t, e, r) => Object(o.a)(Object.assign(Object.assign({}, l(t, e, r)), {
					noun: r.context === n.communitySettings ? "save" : "save_community_topics"
				})),
				g = (t, e, r, n) => {
					const s = l(t, e, n);
					Object(o.a)(Object.assign(Object.assign({}, s), {
						action: "view",
						noun: "error",
						actionInfo: Object.assign(Object.assign({}, s.actionInfo), {
							reason: r
						})
					}))
				}
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(t, e, r) {
			"use strict";
			r.d(e, "e", (function() {
				return d
			})), r.d(e, "b", (function() {
				return c
			})), r.d(e, "a", (function() {
				return a
			})), r.d(e, "d", (function() {
				return u
			})), r.d(e, "c", (function() {
				return l
			}));
			var n, s = r("./src/reddit/constants/tracking.ts"),
				i = r("./src/reddit/selectors/telemetry.ts");
			! function(t) {
				t.SubredditInlineTooltip = "subreddit_inline_tooltip", t.EditSubredditIcon = "edit_subreddit_icon", t.EditSubredditDescription = "edit_subreddit_description", t.SaveDescription = "save_description", t.Error = "error"
			}(n || (n = {}));
			const o = t => ({
					subreddit: i.subreddit(t),
					userSubreddit: i.userSubreddit(t)
				}),
				d = t => Object.assign({
					source: "subreddit_tooltip",
					noun: n.SubredditInlineTooltip,
					action: s.c.VIEW
				}, o(t)),
				c = t => Object.assign({
					source: "id_card",
					noun: n.EditSubredditIcon,
					action: s.c.CLICK
				}, o(t)),
				a = t => Object.assign({
					source: "id_card",
					noun: n.EditSubredditDescription,
					action: s.c.CLICK
				}, o(t)),
				u = (t, e) => r => Object.assign({
					source: "id_card",
					noun: n.SaveDescription,
					action: s.c.CLICK,
					setting: {
						value: String(t),
						oldValue: String(e)
					}
				}, o(r)),
				l = (t, e) => Object.assign(Object.assign(Object.assign({
					source: "id_card",
					noun: n.Error,
					action: s.c.VIEW
				}, o(t)), i.defaults(t)), {
					actionInfo: i.actionInfo(t, {
						reason: e
					})
				})
		},
		"./src/reddit/models/Badge/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "c", (function() {
				return i
			})), r.d(e, "d", (function() {
				return o
			})), r.d(e, "b", (function() {
				return a
			}));
			r("./node_modules/core-js/modules/es6.regexp.split.js"), r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, s = r("./src/config.ts");

			function i(t) {
				return "userId" in t
			}

			function o(t) {
				return !(!t.extra || !t.extra.membership) && !!t.extra.membership.included
			}

			function d(t, e, r) {
				const n = r.media[0],
					s = Object.keys(n);
				if (n["0x0"]) return n["0x0"];
				let i = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (s.forEach(r => {
						const s = n[r],
							[o, d] = r.split("x").map(t => parseInt(t));
						(o < i.width && o >= t || d < i.height && d >= e) && (i = {
							height: d,
							width: o,
							url: s
						})
					}), !i.url && s.length) {
					const t = Object.keys(n)[0],
						e = n[t],
						[r, s] = t.split("x").map(t => parseInt(t));
					i = {
						height: s,
						width: r,
						url: e
					}
				}
				return i.url
			}

			function c(t) {
				return t.startsWith("https") ? t : "".concat(s.a.assetPath, "/").concat(t)
			}

			function a(t, e, r) {
				const n = d(t, e, r),
					s = d(2 * t, 2 * e, r);
				return {
					url: c(n),
					url2x: c(s)
				}
			}! function(t) {
				t.First = "p1", t.Second = "p2"
			}(n || (n = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "c", (function() {
				return s
			})), r.d(e, "b", (function() {
				return o
			})), r.d(e, "d", (function() {
				return d
			}));
			var n, s, i = r("./src/reddit/models/Badge/index.ts");
			! function(t) {
				t.Loyalty = "loyalty", t.Achievement = "achievement", t.Cosmetic = "cosmetic"
			}(n || (n = {})),
			function(t) {
				t.Gallery = "gallery", t.MyBadges = "my-badges"
			}(s || (s = {}));
			const o = {
					[n.Loyalty]: i.a.First,
					[n.Achievement]: i.a.Second,
					[n.Cosmetic]: void 0
				},
				d = t => t === i.a.First ? n.Loyalty : t === i.a.Second ? n.Achievement : n.Cosmetic
		},
		"./src/reddit/models/DiscoveryUnit/index.ts": function(t, e, r) {
			"use strict";
			var n, s, i, o;
			r.d(e, "f", (function() {
					return n
				})), r.d(e, "e", (function() {
					return s
				})), r.d(e, "d", (function() {
					return i
				})), r.d(e, "c", (function() {
					return d
				})), r.d(e, "g", (function() {
					return c
				})), r.d(e, "h", (function() {
					return a
				})), r.d(e, "l", (function() {
					return u
				})), r.d(e, "a", (function() {
					return l
				})), r.d(e, "b", (function() {
					return b
				})), r.d(e, "j", (function() {
					return p
				})), r.d(e, "k", (function() {
					return O
				})), r.d(e, "i", (function() {
					return m
				})),
				function(t) {
					t.Community = "community", t.CommunityCategory = "community_category", t.FavoriteSubreddits = "favorite_subreddits", t.Listing = "listing", t.RecentlyVisitedSubreddits = "recently_visited_subreddits", t.SubredditListing = "subreddit_listing"
				}(n || (n = {})),
				function(t) {
					t.Comments = "comments", t.Communities = "communities", t.Explore = "explore", t.Frontpage = "front_page", t.Popular = "popular", t.SubredditListing = "subreddit_listing", t.Topic = "topic"
				}(s || (s = {})),
				function(t) {
					t.Large = "large", t.Small = "small"
				}(i || (i = {})),
				function(t) {
					t.Wide = "wide", t.Description = "description", t.ActionButton = "action_button", t.SeeMore = "see_more", t.HideItems = "hide_items", t.HideUnit = "hide_unit", t.ShowLess = "show_less", t.PostShowSubredditHeader = "post_show_subreddit_header", t.UnitShowSubredditHeader = "unit_show_subreddit_header", t.PreviewMode = "preview_mode"
				}(o || (o = {}));
			const d = "community_banner_posts",
				c = "search_posts",
				a = "search_subreddits",
				u = "trending_on_popular",
				l = "best_of_community",
				b = "chaining_similar_subreddits_posts",
				p = "top_week_posts",
				O = "top_week_posts_large",
				m = "top_topic_communities_rails"
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(t, e, r) {
			"use strict";
			var n;
			r.d(e, "a", (function() {
					return n
				})),
				function(t) {
					t.Twitter = "twitter"
				}(n || (n = {}))
		},
		"./src/reddit/models/Gold/ProductOffer.ts": function(t, e, r) {
			"use strict";
			var n;
			r.d(e, "a", (function() {
					return n
				})), r.d(e, "b", (function() {
					return s
				})),
				function(t) {
					t.CoinConversion = "user-coins-in-subreddit", t.Powerups = "powerups"
				}(n || (n = {}));
			const s = (t, e) => {
				const r = t && t.dealInfo && t.dealInfo.type;
				return e ? "gild_flow" : "low_coin_upsell" === r ? "low_coin_balance" : "new_purchaser" === r ? "new_user_targeted_offer" : "repeat_purchaser" === r ? "repeat_user_targeted_offer" : void 0
			}
		},
		"./src/reddit/models/Option/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			}));
			const n = t => !t.id,
				s = t => !!t.id,
				i = (t, e) => n(t) && n(e) ? t.displayText.toLowerCase().trim() === e.displayText.toLowerCase().trim() : !(!s(t) || !s(e)) && t.id === e.id
		},
		"./src/reddit/models/Poll/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "g", (function() {
				return o
			})), r.d(e, "h", (function() {
				return d
			})), r.d(e, "f", (function() {
				return c
			})), r.d(e, "c", (function() {
				return a
			})), r.d(e, "d", (function() {
				return u
			})), r.d(e, "e", (function() {
				return l
			}));
			var n, s, i = r("./node_modules/bignumber.js/bignumber.js");
			! function(t) {
				t.GovGeneric = "governance:generic", t.ReplaceTopMod = "governance:replace-top-mod", t.Spinoff = "governance:spin-off", t.GA = "ga"
			}(n || (n = {})),
			function(t) {
				t.ByVoters = "byVoters", t.ByVotingPower = "byVotingPower"
			}(s || (s = {}));
			const o = {
				[n.ReplaceTopMod]: () => [{
					text: "Yes"
				}, {
					text: "No"
				}],
				[n.Spinoff]: t => [{
					text: t ? "Yes, I'd like to join r/".concat(t) : "Yes, I'd like to join the new community"
				}, {
					text: "No"
				}]
			};

			function d(t, e) {
				return !!t.options.filter(t => e.options[t.id].userSelected).length
			}

			function c(t, e) {
				return new Date(t.endsAt).getTime() < Date.now() || d(t, e)
			}

			function a(t, e) {
				let r = t.options[0],
					n = new i.BigNumber(e.options[r.id].votes);
				for (const s of t.options) {
					const t = new i.BigNumber(e.options[s.id].votes);
					t.isGreaterThan(n) && (r = s, n = t)
				}
				return r
			}

			function u(t) {
				switch (t.type) {
					case n.GovGeneric:
					case n.ReplaceTopMod:
					case n.Spinoff:
						return !0;
					default:
						return !1
				}
			}

			function l(t) {
				return !0 === t.isPrediction
			}
		},
		"./src/reddit/models/Rule/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "c", (function() {
				return i
			})), r.d(e, "e", (function() {
				return o
			})), r.d(e, "g", (function() {
				return d
			})), r.d(e, "f", (function() {
				return c
			})), r.d(e, "a", (function() {
				return a
			})), r.d(e, "d", (function() {
				return u
			})), r.d(e, "h", (function() {
				return l
			}));
			const n = {
					all: "all",
					post: "post",
					comment: "comment"
				},
				s = {
					all: "all",
					link: "post",
					comment: "comment"
				},
				i = {
					LINK_AND_COMMENT: "all",
					LINK: "post",
					COMMENT: "comment"
				},
				o = 15,
				d = 100,
				c = 100,
				a = 500,
				u = 2e3,
				l = t => ({
					rules: t.map(t => ({
						kind: s[t.kind],
						description: t.description,
						descriptionHtml: t.description_html,
						shortName: t.short_name,
						violationReason: t.violation_reason,
						createdUtc: t.created_utc,
						priority: t.priority
					}))
				})
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "q", (function() {
				return o
			})), r.d(e, "a", (function() {
				return c
			})), r.d(e, "e", (function() {
				return a
			})), r.d(e, "g", (function() {
				return u
			})), r.d(e, "m", (function() {
				return l
			})), r.d(e, "n", (function() {
				return b
			})), r.d(e, "f", (function() {
				return p
			})), r.d(e, "c", (function() {
				return m
			})), r.d(e, "p", (function() {
				return _
			})), r.d(e, "k", (function() {
				return g
			})), r.d(e, "j", (function() {
				return j
			})), r.d(e, "h", (function() {
				return E
			})), r.d(e, "i", (function() {
				return y
			})), r.d(e, "d", (function() {
				return S
			})), r.d(e, "b", (function() {
				return T
			})), r.d(e, "l", (function() {
				return h
			})), r.d(e, "o", (function() {
				return I
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/lib/assertNever.ts"),
				s = r("./src/reddit/models/GqlTopLevelField.ts"),
				i = r("./src/reddit/models/User/index.ts");
			const o = "scheduledposts";
			var d, c, a;
			! function(t) {
				t.LINK = "LINK", t.POLL = "POLL", t.SELF = "SELF"
			}(d || (d = {})),
			function(t) {
				t.RTJSON = "RTJSON", t.TEXT = "TEXT"
			}(c || (c = {})),
			function(t) {
				t.CREATED = "CREATED", t.PROCESSING = "PROCESSING", t.FAILED = "FAILED", t.SUCCESS = "SUCCESS"
			}(a || (a = {}));
			const u = (t, e) => {
					return (e ? new Set(["links", "text"]) : new Set(["links", "text", "polls"])).has(t)
				},
				l = t => t.__typename === i.c.AvailableRedditor,
				b = t => t.__typename === s.a.Subreddit;
			var p, O, m, f;
			! function(t) {
				t.standalonePosts = "standalonePosts", t.recurringPosts = "recurringPosts"
			}(p || (p = {})),
			function(t) {
				t.MONDAY = "MONDAY", t.TUESDAY = "TUESDAY", t.WEDNESDAY = "WEDNESDAY", t.THURSDAY = "THURSDAY", t.FRIDAY = "FRIDAY", t.SATURDAY = "SATURDAY", t.SUNDAY = "SUNDAY"
			}(O || (O = {})),
			function(t) {
				t[t.MONDAY = 0] = "MONDAY", t[t.TUESDAY = 1] = "TUESDAY", t[t.WEDNESDAY = 2] = "WEDNESDAY", t[t.THURSDAY = 3] = "THURSDAY", t[t.FRIDAY = 4] = "FRIDAY", t[t.SATURDAY = 5] = "SATURDAY", t[t.SUNDAY = 6] = "SUNDAY"
			}(m || (m = {})),
			function(t) {
				t[t.SUNDAY = 0] = "SUNDAY", t[t.MONDAY = 1] = "MONDAY", t[t.TUESDAY = 2] = "TUESDAY", t[t.WEDNESDAY = 3] = "WEDNESDAY", t[t.THURSDAY = 4] = "THURSDAY", t[t.FRIDAY = 5] = "FRIDAY", t[t.SATURDAY = 6] = "SATURDAY"
			}(f || (f = {}));
			const _ = t => O[f[t]],
				g = t => f[O[t]],
				j = t => m[O[t]],
				E = t => O[m[t]],
				y = t => f[m[t]];
			var S;
			! function(t) {
				t.Hourly = "HOURLY", t.Daily = "DAILY", t.Weekly = "WEEKLY", t.Monthly = "MONTHLY"
			}(S || (S = {}));
			const T = "custom",
				h = t => {
					switch (t) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						case "isContestMode":
							return "mark_as_contest_mode";
						case "isPostAsMetaMod":
							return "post_as_meta_mod";
						default:
							return Object(n.a)(t)
					}
				},
				I = t => "frequency" in t && !!t.frequency
		},
		"./src/reddit/models/Tags/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "c", (function() {
				return i
			})), r.d(e, "f", (function() {
				return o
			})), r.d(e, "e", (function() {
				return d
			})), r.d(e, "d", (function() {
				return c
			}));
			const n = 25,
				s = 64;
			var i;
			! function(t) {
				t.EVENT = "EVENT", t.COLLECTION = "COLLECTION", t.CLASSIFICATION = "CLASSIFICATION", t.POST_CLASSIFICATION = "POST_CLASSIFICATION", t.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", t.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(i || (i = {}));
			const o = function(t) {
					let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: t.id,
						displayText: t.text,
						selected: e
					}
				},
				d = function(t) {
					let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return o(t.tag, e)
				};
			var c;
			! function(t) {
				t.TAGGED = "TAGGED", t.NONE = "NONE"
			}(c || (c = {}))
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			r("./node_modules/core-js/modules/es6.symbol.js");
			var n, s = r("./src/reddit/actions/economics/paymentSystems/constants.ts"),
				i = function(t, e) {
					var r = {};
					for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
					if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
						var s = 0;
						for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]])
					}
					return r
				};
			! function(t) {
				t[t.Failure = 0] = "Failure", t[t.Fetched = 1] = "Fetched", t[t.NotFetched = 2] = "NotFetched", t[t.Pending = 3] = "Pending"
			}(n || (n = {}));
			const o = {
				status: n.NotFetched
			};
			e.b = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case s.a:
						if (t.status === n.Fetched && t.data.stripe && t.data.stripe.sources) {
							const r = e.payload.cardId,
								n = t.data.stripe.sources,
								s = r,
								o = (n[s], i(n, ["symbol" == typeof s ? s : s + ""]));
							return Object.assign(Object.assign({}, t), {
								data: Object.assign(Object.assign({}, t.data), {
									stripe: Object.assign(Object.assign({}, t.data.stripe), {
										sources: o
									})
								})
							})
						}
						return t;
					case s.e:
						if (t.status === n.Fetched && t.data.braintree && t.data.braintree.sources) {
							const r = e.payload.sourceId,
								n = t.data.braintree.sources,
								s = r,
								o = (n[s], i(n, ["symbol" == typeof s ? s : s + ""]));
							return Object.assign(Object.assign({}, t), {
								data: Object.assign(Object.assign({}, t.data), {
									braintree: Object.assign(Object.assign({}, t.data.braintree), {
										sources: o
									})
								})
							})
						}
						return t;
					case s.b:
						return {
							error: e.payload.error, status: n.Failure
						};
					case s.c:
						return {
							data: e.payload, status: n.Fetched
						};
					case s.d:
						return {
							status: n.Pending
						};
					default:
						return t
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			r("./node_modules/core-js/modules/es6.array.sort.js"), r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, s = r("./src/lib/constants/specialMembership.ts"),
				i = r("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				o = r("./src/reddit/helpers/economics/sortBadges.ts"),
				d = r("./src/reddit/models/Badge/index.ts"),
				c = r("./src/reddit/models/Badge/managementPage.ts");
			! function(t) {
				t[t.NotFetched = 0] = "NotFetched", t[t.Fetched = 1] = "Fetched"
			}(n || (n = {}));
			const a = {};

			function u(t) {
				return "userId" in t
			}

			function l(t, e, r, n) {
				t.forEach(t => {
					t.collections && Object.keys(t.collections).forEach(s => {
						let i;
						(i = t.placement ? t.placement === d.a.First ? n[c.a.Loyalty][s] : n[c.a.Achievement][s] : u(t) ? n[c.a.Cosmetic][c.c.MyBadges][s] : n[c.a.Cosmetic][c.c.Gallery][s]) && (u(t) ? r.has(t.id) && i.unlocked.push(t) : e.has(t.id) || i.locked.push(t))
					})
				})
			}

			function b(t) {
				const e = (t, e) => {
					const r = parseInt(t.price || "0"),
						n = parseInt(e.price || "0");
					return r === n ? Object(o.b)(t, e) : r - n
				};
				return t.locked.sort(e), t.unlocked.sort(e), t
			}

			function p(t, e) {
				return Object.keys(t).map(e => t[e]).filter(t => !!t.locked.length || !!t.unlocked.length || t.id === s.a).map(b).sort((t, r) => {
					const n = e[t.id],
						s = e[r.id];
					return Object(o.b)(n, s)
				})
			}

			function O(t) {
				const e = {
					[c.a.Loyalty]: {},
					[c.a.Achievement]: {},
					[c.a.Cosmetic]: {
						[c.c.Gallery]: {},
						[c.c.MyBadges]: {}
					}
				};
				Object.keys(t.collections).forEach(r => {
					const n = t.collections[r],
						s = {
							description: n.description,
							highlight: n.extra && n.extra.style && n.extra.style.color,
							id: n.id,
							locked: [],
							title: n.title,
							unlocked: []
						};
					e[c.a.Loyalty][r] = Object.assign(Object.assign({}, s), {
						locked: [],
						unlocked: []
					}), e[c.a.Achievement][r] = Object.assign(Object.assign({}, s), {
						locked: [],
						unlocked: []
					}), e[c.a.Cosmetic][c.c.Gallery][r] = Object.assign(Object.assign({}, s), {
						locked: [],
						unlocked: []
					}), e[c.a.Cosmetic][c.c.MyBadges][r] = Object.assign(Object.assign({}, s), {
						locked: [],
						unlocked: []
					})
				});
				const r = new Set;
				t.userOwnedBadges.forEach(e => {
					const n = t.badges[e];
					n && r.add(n.type)
				});
				const n = new Set(t.userOwnedBadges);
				return l(Object.keys(t.badges).map(e => t.badges[e]), r, n, e), l(Object.keys(t.products).map(e => t.products[e]), r, n, e), {
					collections: {
						[c.a.Loyalty]: p(e[c.a.Loyalty], t.collections),
						[c.a.Achievement]: p(e[c.a.Achievement], t.collections),
						[c.a.Cosmetic]: {
							[c.c.Gallery]: p(e[c.a.Cosmetic][c.c.Gallery], t.collections),
							[c.c.MyBadges]: p(e[c.a.Cosmetic][c.c.MyBadges], t.collections)
						}
					},
					subscription: t.subscription,
					userOwnedBadges: t.userOwnedBadges.map(e => t.badges[e]).filter(Boolean)
				}
			}
			e.b = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case i.a: {
						const {
							subredditId: r
						} = e.payload, s = t[r];
						return s && s.status === n.Fetched ? Object.assign(Object.assign({}, t), {
							[r]: Object.assign(Object.assign({}, s), {
								data: Object.assign({}, s.data),
								raw: Object.assign({}, s.raw)
							})
						}) : t
					}
					case i.h: {
						const {
							subredditId: r
						} = e.payload, s = t[r];
						return s && s.status === n.Fetched ? Object.assign(Object.assign({}, t), {
							[r]: Object.assign(Object.assign({}, s), {
								data: Object.assign(Object.assign({}, s.data), {
									subscription: Object.assign(Object.assign({}, s.data.subscription || {}), {
										settings: {
											renew: !1
										}
									})
								}),
								raw: Object.assign(Object.assign({}, s.raw), {
									subscription: Object.assign(Object.assign({}, s.raw.subscription || {}), {
										settings: {
											renew: !1
										}
									})
								})
							})
						}) : t
					}
					case i.i: {
						const r = e.payload;
						return Object.assign(Object.assign({}, t), {
							[r.subredditId]: {
								raw: r,
								data: O(r),
								status: n.Fetched
							}
						})
					}
					default:
						return t
				}
			}
		},
		"./src/reddit/reducers/features/categories/index.ts": function(t, e, r) {
			"use strict";
			var n = r("./node_modules/redux/es/redux.js"),
				s = r("./src/reddit/actions/category/constants.ts");
			var i = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case s.b:
					case s.c:
						return null;
					case s.a: {
						const {
							error: t
						} = e.payload;
						return t || null
					}
					default:
						return t
				}
			};
			var o = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case s.c:
						return !1;
					case s.b:
						return !0;
					default:
						return t
				}
			};
			var d = function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						e = arguments.length > 1 ? arguments[1] : void 0;
					switch (e.type) {
						case s.c:
							return !0;
						case s.b:
						case s.a:
							return !1;
						default:
							return t
					}
				},
				c = Object(n.c)({
					error: i,
					loaded: o,
					pending: d
				});
			const a = {};
			var u = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case s.g:
					case s.f: {
						const {
							categoryId: r
						} = e.payload, n = Object.assign({}, t);
						return delete n[r], n
					}
					case s.e: {
						const {
							categoryId: r,
							error: n
						} = e.payload;
						return Object.assign(Object.assign({}, t), {
							[r]: n
						})
					}
					default:
						return t
				}
			};
			const l = {};
			var b = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case s.g: {
						const {
							categoryId: r
						} = e.payload;
						return Object.assign(Object.assign({}, t), {
							[r]: !1
						})
					}
					case s.f: {
						const {
							categoryId: r
						} = e.payload;
						return Object.assign(Object.assign({}, t), {
							[r]: !0
						})
					}
					default:
						return t
				}
			};
			const p = {};
			var O = function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p,
						e = arguments.length > 1 ? arguments[1] : void 0;
					switch (e.type) {
						case s.g: {
							const {
								categoryId: r
							} = e.payload;
							return Object.assign(Object.assign({}, t), {
								[r]: !0
							})
						}
						case s.f:
						case s.e: {
							const {
								categoryId: r
							} = e.payload;
							return Object.assign(Object.assign({}, t), {
								[r]: !1
							})
						}
						default:
							return t
					}
				},
				m = Object(n.c)({
					error: u,
					loaded: b,
					pending: O
				}),
				f = Object(n.c)({
					list: c,
					subreddits: m
				}),
				_ = r("./node_modules/lodash/isEmpty.js"),
				g = r.n(_);
			const j = [];
			var E = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case s.b: {
						const {
							categoryIds: r
						} = e.payload;
						return g()(r) ? t : r
					}
					default:
						return t
				}
			};
			const y = {};
			var S = function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : y,
						e = arguments.length > 1 ? arguments[1] : void 0;
					switch (e.type) {
						case s.b: {
							const {
								categories: r
							} = e.payload;
							return g()(r) ? t : Object.assign(Object.assign({}, t), r)
						}
						default:
							return t
					}
				},
				T = r("./node_modules/lodash/forOwn.js"),
				h = r.n(T),
				I = r("./src/reddit/helpers/name/index.ts");
			const C = {};
			var A = function() {
					let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : C,
						e = arguments.length > 1 ? arguments[1] : void 0;
					switch (e.type) {
						case s.b: {
							const {
								categories: r
							} = e.payload;
							if (g()(r)) return t;
							const n = {};
							return h()(r, t => {
								n[Object(I.f)(t.name)] = t.id
							}), Object.assign(Object.assign({}, t), n)
						}
						default:
							return t
					}
				},
				x = r("./src/reddit/actions/global/constants.ts"),
				D = r("./src/reddit/constants/localStorage.ts");
			const w = {};
			var R = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case x.a:
						return e.payload[D.e] || t;
					case s.d: {
						const {
							categoryId: r,
							rank: n
						} = e.payload;
						return Object.assign(Object.assign({}, t), {
							[r]: n
						})
					}
					default:
						return t
				}
			};
			e.a = Object(n.c)({
				api: f,
				ids: E,
				models: S,
				nameToId: A,
				ranking: R
			})
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n, s = r("./node_modules/lodash/uniqWith.js"),
				i = r.n(s),
				o = r("./node_modules/lodash/values.js"),
				d = r.n(o),
				c = r("./src/reddit/actions/tags/constants.ts"),
				a = r("./src/reddit/models/Option/index.ts"),
				u = r("./src/reddit/models/Tags/index.ts");
			! function(t) {
				t.ADD = "ADD", t.REMOVE = "REMOVE"
			}(n || (n = {}));
			const l = {
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			e.b = function() {
				let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					e = arguments.length > 1 ? arguments[1] : void 0;
				switch (e.type) {
					case c.w:
					case c.r: {
						const {
							subredditId: r,
							itemTags: n,
							suggestedItemTags: s
						} = e.payload, o = i()([...(t.selectedOptions[r] || []).map(t => {
							if (!t.id) {
								const e = d()(n[r] || {}).find(e => t.displayText.toLowerCase().trim() === e.tag.text.toLowerCase().trim());
								if (e) return Object.assign(Object.assign({}, Object(u.e)(e, !0)), {
									action: null
								})
							}
							return t
						}), ...d()(n[r] || {}).map(t => Object.assign(Object.assign({}, Object(u.e)(t, !0)), {
							action: null
						}))], a.a);
						return Object.assign(Object.assign({}, t), {
							selectedOptions: Object.assign(Object.assign({}, t.selectedOptions), {
								[r]: o.map(t => Object.assign(Object.assign({}, t), {
									action: t.id ? null : t.action
								}))
							}),
							selectedSuggestedOptions: Object.assign(Object.assign({}, t.selectedSuggestedOptions), {
								[r]: d()(s[r] || {}).map(t => Object.assign(Object.assign({}, Object(u.e)(t, !0)), {
									action: null
								}))
							}),
							deselectedOptions: Object.assign(Object.assign({}, t.deselectedOptions), {
								[r]: []
							})
						})
					}
					case c.D:
					case c.z: {
						const {
							subredditId: r,
							option: s
						} = e.payload, o = e.type === c.z ? "selectedOptions" : "selectedSuggestedOptions", d = e.type === c.z ? "deselectedOptions" : "deselectedSuggestedOptions", u = (t[d][r] || []).slice(), l = u.findIndex(t => Object(a.a)(t, s));
						let b = n.ADD;
						return l > -1 && (b = null, u.splice(l, 1)), Object.assign(Object.assign({}, t), {
							[o]: Object.assign(Object.assign({}, t[o]), {
								[r]: i()([...t[o][r] || [], Object.assign(Object.assign({}, s), {
									action: b
								})], a.a)
							}),
							[d]: Object.assign(Object.assign({}, t[d]), {
								[r]: u
							})
						})
					}
					case c.C:
					case c.y: {
						const {
							subredditId: r,
							option: s
						} = e.payload, i = e.type === c.y ? "selectedOptions" : "selectedSuggestedOptions", o = e.type === c.y ? "deselectedOptions" : "deselectedSuggestedOptions", d = (t[o][r] || []).slice(), u = (t[i][r] || []).slice(), l = u.findIndex(t => Object(a.a)(t, s));
						return l > -1 && (null === u[l].action && d.push(Object.assign(Object.assign({}, u[l]), {
							action: n.REMOVE
						})), u.splice(l, 1)), Object.assign(Object.assign({}, t), {
							[i]: Object.assign(Object.assign({}, t[i]), {
								[r]: u
							}),
							[o]: Object.assign(Object.assign({}, t[o]), {
								[r]: d
							})
						})
					}
					case c.A: {
						const {
							itemTagsState: r
						} = e.payload, n = Object.keys(r);
						if (!n.length) return t;
						const s = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							i = n.reduce((t, e) => (t.selectedOptions[e] = d()(r[e]).map(t => Object.assign(Object.assign({}, Object(u.e)(t, !0)), {
								action: null
							})), t.deselectedOptions[e] = [], t.inputByItemId[e] = "", t), s);
						return Object.assign(Object.assign({}, t), {
							inputByItemId: Object.assign(Object.assign({}, t.inputByItemId), i.inputByItemId),
							selectedOptions: Object.assign(Object.assign({}, t.selectedOptions), i.selectedOptions),
							deselectedOptions: Object.assign(Object.assign({}, t.deselectedOptions), i.deselectedOptions)
						})
					}
					case c.B:
					case c.x: {
						const {
							subredditId: r,
							input: n
						} = e.payload, s = e.type === c.x ? "inputByItemId" : "suggestedInputByItemId";
						return Object.assign(Object.assign({}, t), {
							[s]: Object.assign(Object.assign({}, t[s]), {
								[r]: n
							})
						})
					}
					case c.i:
					case c.h: {
						const {
							subredditId: r,
							primaryTagId: n
						} = e.payload;
						if (!n || !r) return t;
						const s = t.selectedOptions[r];
						if (s) {
							const e = s.findIndex(t => t.id === n),
								i = [...s];
							return e >= 0 && i.splice(e, 1), Object.assign(Object.assign({}, t), {
								selectedOptions: Object.assign(Object.assign({}, t.selectedOptions), {
									[r]: i
								})
							})
						}
						return t
					}
					default:
						return t
				}
			}
		},
		"./src/reddit/selectors/PublicAccessNetwork/api.ts": function(t, e, r) {
			"use strict";
			r.d(e, "k", (function() {
				return d
			})), r.d(e, "c", (function() {
				return c
			})), r.d(e, "e", (function() {
				return a
			})), r.d(e, "d", (function() {
				return u
			})), r.d(e, "f", (function() {
				return l
			})), r.d(e, "i", (function() {
				return b
			})), r.d(e, "l", (function() {
				return p
			})), r.d(e, "m", (function() {
				return O
			})), r.d(e, "b", (function() {
				return m
			})), r.d(e, "o", (function() {
				return f
			})), r.d(e, "n", (function() {
				return _
			})), r.d(e, "g", (function() {
				return g
			})), r.d(e, "a", (function() {
				return j
			})), r.d(e, "h", (function() {
				return y
			})), r.d(e, "j", (function() {
				return T
			}));
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/lib/objectSelector/index.ts"),
				i = r("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				o = r("./src/reddit/helpers/publicAccessNetwork/index.ts");
			const d = t => t.publicAccessNetwork.api.config,
				c = (t, e) => !!e && !!t.publicAccessNetwork.api.error[Object(o.h)(e)],
				a = t => c(t, i.b),
				u = (t, e) => !!e && !!t.publicAccessNetwork.api.pending[Object(o.h)(e)] && t.publicAccessNetwork.api.pending[Object(o.h)(e)].isPending,
				l = t => u(t, i.b),
				b = t => t.publicAccessNetwork.api.pending[i.b] && t.publicAccessNetwork.api.pending[i.b].fetchedUtcTimeStamp,
				p = Object(n.a)(d, t => t.global),
				O = Object(n.a)((t, e) => {
					let {
						subreddit: r
					} = e;
					return r
				}, d, (t, e) => {
					const r = t.toLowerCase();
					return e.subreddits[r]
				}),
				m = Object(n.a)(d, t => t.global.rpan_intro_video_url),
				f = Object(n.a)(d, t => t.global.url_to_show_for_unavailable_video),
				_ = Object(n.a)(d, t => !1),
				g = Object(n.a)(d, t => t.isError),
				j = Object(n.a)(d, t => t.global.max_chat_comment_length),
				E = t => t.publicAccessNetwork.api.recommendedViewerSubreddits,
				y = (Object(n.a)(E, t => t.isError), Object(n.a)(E, t => t.isPending)),
				S = Object(s.a)(Object(n.a)(E, t => t.subreddits)),
				T = Object(n.a)(S, t => [{
					name: "All",
					prefixedName: "All",
					path: Object(o.e)()
				}, ...t.map(t => ({
					name: t,
					prefixedName: "r/".concat(t),
					path: Object(o.g)(t)
				}))])
		},
		"./src/reddit/selectors/communityAwards.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return i
			})), r.d(e, "e", (function() {
				return o
			})), r.d(e, "f", (function() {
				return d
			})), r.d(e, "d", (function() {
				return c
			})), r.d(e, "b", (function() {
				return a
			})), r.d(e, "a", (function() {
				return u
			})), r.d(e, "h", (function() {
				return p
			})), r.d(e, "g", (function() {
				return O
			})), r.d(e, "i", (function() {
				return m
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js"), r("./node_modules/core-js/modules/es6.array.sort.js");
			var n = r("./src/lib/objectSelector/index.ts"),
				s = r("./src/reddit/models/Gold/Award.ts");
			const i = t => t.awards.create.api.pending,
				o = Object(n.a)((t, e) => {
					let {
						subredditOrProfileId: r
					} = e;
					const n = t.awards.manageable.order[r];
					return n ? n.map(e => t.awards.models[e]).filter(t => t.isEnabled) : []
				}),
				d = Object(n.a)((t, e) => {
					let {
						subredditOrProfileId: r
					} = e;
					return Object.entries(t.awards.manageable.availability[r] || {}).map(e => {
						let [r, n] = e;
						return Object.assign(Object.assign({}, t.awards.models[r]), {
							isEnabled: n
						})
					}).sort((t, e) => t.name.localeCompare(e.name))
				}),
				c = (t, e) => {
					let {
						subredditOrProfileId: r
					} = e;
					return t.awards.manageable.api.pending[r]
				},
				a = (t, e) => {
					let {
						subredditOrProfileId: r
					} = e;
					return !!t.awards.blacklist[r]
				},
				u = (t, e) => t.awards.models[e],
				l = s.l.map(t => ({
					award: t,
					total: 0
				})),
				b = Object(n.a)((t, e) => {
					let {
						subredditId: r
					} = e;
					const n = t.awards.usable.order[r];
					return n ? n.map(e => ({
						award: t.awards.models[e],
						total: 0
					})).filter(t => t.award.isEnabled) : l
				}),
				p = Object(n.a)((t, e) => {
					let {
						subredditId: r,
						thingId: n
					} = e;
					const s = t.awards.sortedUsable.order[r];
					if (!s) return b(t, {
						subredditId: r
					});
					const i = s[n];
					return i ? i.map(e => {
						let {
							award: r,
							total: n
						} = e;
						return {
							total: n,
							award: t.awards.models[r.id]
						}
					}).filter(t => {
						let {
							award: e
						} = t;
						return e.isEnabled
					}) : l
				}),
				O = (t, e) => {
					let {
						subredditId: r,
						thingId: n
					} = e;
					const s = t.awards.sortedUsable.api.pending[r];
					return !!s && s[n]
				},
				m = Object(n.a)((t, e) => {
					let {
						subredditId: r
					} = e;
					return t.awards.tags.order[r] || []
				})
		},
		"./src/reddit/selectors/communityFlairs.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return i
			})), r.d(e, "b", (function() {
				return d
			})), r.d(e, "a", (function() {
				return c
			}));
			var n = r("./node_modules/reselect/es/index.js");
			const s = (t, e) => {
					const r = t.communityFlairs[e];
					return r && r.sortedKeys
				},
				i = Object(n.a)(s, t => t),
				o = (t, e) => {
					const r = t.communityFlairs[e];
					return r && r.models
				},
				d = Object(n.a)(o, t => t),
				c = (Object(n.a)((t, e) => o(t, e), (t, e) => s(t, e), (t, e) => {
					if (e && t) return e.map(e => t[e])
				}), (t, e) => t.communityFlairs.hasOwnProperty(e))
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(t, e, r) {
			"use strict";
			r.d(e, "d", (function() {
				return l
			})), r.d(e, "e", (function() {
				return b
			})), r.d(e, "c", (function() {
				return p
			})), r.d(e, "a", (function() {
				return m
			})), r.d(e, "b", (function() {
				return f
			})), r.d(e, "f", (function() {
				return g
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/lib/constants/index.ts"),
				s = r("./src/lib/makeListingKey/index.ts"),
				i = r("./src/lib/objectSelector/index.ts"),
				o = r("./src/reddit/helpers/name/index.ts"),
				d = r("./src/reddit/models/DiscoveryUnit/index.ts"),
				c = r("./src/reddit/selectors/category.ts"),
				a = (r("./src/reddit/selectors/listings.ts"), r("./src/reddit/selectors/posts.ts"));
			r("./src/reddit/selectors/subreddit.ts");
			const u = [],
				l = t => t.discoveryUnits.api.list.loaded,
				b = t => t.discoveryUnits.api.list.pending,
				p = (t, e) => {
					let {
						unitName: r
					} = e;
					const n = t.discoveryUnits.nameToId[Object(o.f)(r)];
					return t.discoveryUnits.models[n]
				},
				O = (t, e) => {
					let {
						listingKey: r
					} = e;
					const n = Object(a.Q)(t);
					return Object(a.H)(t, {
						listingKey: r
					}).filter(t => {
						const e = n[t];
						return e && !e.isStickied && !e.isSponsored
					})
				},
				m = () => Object(i.a)((t, e) => {
					let r, {
						categoryName: i,
						id: o,
						unitName: d
					} = e;
					if (i && !(r = Object(c.f)(t, {
							categoryName: i
						}))) return u;
					const a = o || r && r.id,
						l = Object(s.a)(d, n.O.HOT, {
							category: a
						});
					return O(t, {
						listingKey: l
					})
				}),
				f = t => p(t, {
					unitName: d.c
				}),
				_ = new Set(["sequence"]),
				g = t => {
					const e = t.platform.currentPage;
					if (e) {
						const {
							meta: t,
							urlParams: r
						} = e, n = t && t.name || "", s = r && r.subredditName || "", i = "subreddit" === n, o = _.has(s.toLowerCase());
						return i && o
					}
					return !1
				}
		},
		"./src/reddit/selectors/experiments/econ/groupAwarding.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			}));
			var n = r("./src/reddit/constants/experiments.ts"),
				s = r("./src/reddit/helpers/chooseVariant/index.ts");
			const i = (t => e => {
				const r = Object(s.c)(e, {
					experimentEligibilitySelector: s.a,
					experimentName: t
				});
				return !(!r || Object(n.Nc)(r))
			})(n.db)
		},
		"./src/reddit/selectors/experiments/goldSubredditPowerups.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			}));
			var n = r("./src/reddit/constants/experiments.ts"),
				s = r("./src/reddit/helpers/chooseVariant/index.ts");
			const i = t => {
				return Object(s.c)(t, {
					experimentEligibilitySelector: s.a,
					experimentName: n.ob
				}) === n.sb.Enabled
			}
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return i
			})), r.d(e, "a", (function() {
				return o
			}));
			var n = r("./src/reddit/constants/experiments.ts"),
				s = r("./src/reddit/helpers/chooseVariant/index.ts");
			const i = t => Object(s.c)(t, {
					experimentEligibilitySelector: s.a,
					experimentName: n.L
				}) === n.Q.Enabled,
				o = t => Object(s.c)(t, {
					experimentEligibilitySelector: s.a,
					experimentName: n.K
				}) === n.P.Enabled
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(t, e, r) {
			"use strict";
			r.d(e, "g", (function() {
				return o
			})), r.d(e, "h", (function() {
				return d
			})), r.d(e, "a", (function() {
				return c
			})), r.d(e, "d", (function() {
				return a
			})), r.d(e, "e", (function() {
				return u
			})), r.d(e, "f", (function() {
				return l
			})), r.d(e, "c", (function() {
				return b
			})), r.d(e, "b", (function() {
				return p
			}));
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/reddit/constants/experiments.ts"),
				i = r("./src/reddit/helpers/chooseVariant/index.ts");
			const o = t => s.mc.RulesAndWarnings === Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.fc
				}),
				d = t => s.mc.WarningsOnly === Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.fc
				}),
				c = t => s.bc.Enabled === Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.Ub
				}),
				a = t => s.vc.Enabled === Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.qc
				}),
				u = t => s.wc.Enabled === Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.rc
				}),
				l = (t, e, r) => {
					const n = r(t, e);
					return !(!n || !n.meter) && (n.meter.enabled && u(t) && s.Lc.Enabled === Object(i.c)(t, {
						experimentEligibilitySelector: i.a,
						experimentName: s.Hc
					}))
				},
				b = Object(n.a)(t => Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.hc
				}), t => t === s.nc.Enabled),
				p = t => s.bc.Enabled === Object(i.c)(t, {
					experimentEligibilitySelector: i.a,
					experimentName: s.gc
				})
		},
		"./src/reddit/selectors/externalAccount.ts": function(t, e, r) {
			"use strict";
			r.d(e, "d", (function() {
				return o
			})), r.d(e, "a", (function() {
				return c
			})), r.d(e, "b", (function() {
				return a
			})), r.d(e, "c", (function() {
				return u
			}));
			var n = r("./src/reddit/models/ExternalAccount/index.ts"),
				s = r("./src/reddit/models/User/index.ts"),
				i = r("./src/reddit/selectors/user.ts");
			const o = (t, e) => {
					let {
						username: r
					} = e;
					return !!t.externalAccount.api.user.pending[r]
				},
				d = (t, e) => {
					let {
						username: r
					} = e;
					return t.externalAccount.user[r]
				},
				c = t => {
					const e = Object(i.i)(t);
					if (!e) return;
					const r = Object(s.e)(e),
						n = d(t, {
							username: r
						});
					return n ? n.twitter : void 0
				},
				a = t => !!t.externalAccount.api.connect.pending[n.a.Twitter],
				u = (t, e) => {
					let {
						profileName: r
					} = e;
					if (!r) return null;
					const o = d(t, {
						username: r
					});
					if (!o) return null;
					const c = o[n.a.Twitter];
					if (!c) return null;
					const a = Object(i.i)(t);
					if (!(a && Object(s.e)(a).toLowerCase() === r.toLowerCase())) return c;
					const u = Object(i.hb)(t, {
						userName: r
					});
					return u ? u.prefShowTwitter ? c : null : c
				}
		},
		"./src/reddit/selectors/gold/awardIcon.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return O
			})), r.d(e, "a", (function() {
				return m
			})), r.d(e, "b", (function() {
				return f
			})), r.d(e, "e", (function() {
				return _
			})), r.d(e, "d", (function() {
				return g
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./src/reddit/models/Gold/Award.ts"),
				s = r("./src/reddit/selectors/comments.ts"),
				i = r("./src/reddit/selectors/experiments/econ/groupAwarding.ts"),
				o = r("./src/reddit/selectors/gold/giveAwards.ts"),
				d = r("./src/reddit/selectors/posts.ts"),
				c = r("./src/reddit/selectors/user.ts"),
				a = r("./src/reddit/selectors/userPrefs.ts");
			const u = [32, 48, 64, 128],
				l = (t, e, r) => {
					const n = e ? t["staticIcon".concat(r)] : t["icon".concat(r)];
					return (null == n ? void 0 : n.url) ? n.url : e ? t.staticIcon.url : t.icon.url
				},
				b = (t, e) => (null == e ? void 0 : e.awardCountsById) && (null == e ? void 0 : e.awardCountsById[t.id]) && t.awardSubType === n.d.Group && t.tiers && t.tiers.length > 1 && e.awardCountsById[t.id] >= t.tiers[1].awardingsRequired,
				p = t => {
					let {
						award: e,
						size: r,
						prefersReducedMotion: s,
						tierGroupAwardsEnabled: i,
						postOrComment: o
					} = t;
					return e.awardSubType === n.d.Group && i ? (t => {
						let {
							award: e,
							size: r,
							prefersReducedMotion: n,
							postOrComment: s
						} = t;
						if (!b(e, s)) return l(e, n, r);
						const i = s.awardCountsById[e.id],
							o = e.tiers.reduce((t, e) => i >= e.awardingsRequired ? e : t);
						return l(o, n, r)
					})({
						award: e,
						size: r,
						prefersReducedMotion: s,
						postOrComment: o
					}) : l(e, s, r)
				},
				O = (t, e) => {
					let {
						awards: r,
						minSize: n,
						postOrCommentId: o
					} = e;
					const c = Object(a.c)(t),
						l = u.find(t => t >= n),
						O = o ? Object(d.N)(t, {
							postId: o
						}) || Object(s.n)(t, {
							commentId: o
						}) : void 0,
						m = !(!((null == O ? void 0 : O.awardCountsById) && r.some(t => t && b(t, O))) || !Object(i.a)(t));
					return r.reduce((t, e) => (e && (t[e.id] = p({
						award: e,
						size: l,
						prefersReducedMotion: c,
						tierGroupAwardsEnabled: m,
						postOrComment: O
					})), t), {})
				},
				m = (t, e) => {
					let {
						award: r,
						minSize: n,
						postOrCommentId: s
					} = e;
					return r ? O(t, {
						awards: [r],
						minSize: n,
						postOrCommentId: s
					})[r.id] : void 0
				},
				f = (t, e) => {
					let {
						postOrComment: r,
						minSizes: n
					} = e;
					const s = Object.keys(r.awardCountsById || {}).reduce((e, r) => {
						const n = t.awards.models[r];
						return n && e.push(n), e
					}, []);
					return n.reduce((e, n) => {
						const i = O(t, {
							awards: s,
							minSize: n,
							postOrCommentId: r.id
						});
						return e["icon".concat(n)] = i, e
					}, {})
				},
				_ = (t, e) => {
					let {
						minSize: r,
						userName: n
					} = e;
					const s = Object(c.hb)(t, {
						userName: n
					});
					if (s && s.awardedLastMonth && s.awardedLastMonth.topAward) return m(t, {
						award: s.awardedLastMonth.topAward,
						minSize: r
					})
				},
				g = t => {
					const e = Object(o.b)(t),
						r = Object(o.a)(t);
					return m(t, {
						award: e,
						postOrCommentId: r || void 0,
						minSize: 512
					})
				}
		},
		"./src/reddit/selectors/gold/giveAwards.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "a", (function() {
				return s
			}));
			const n = t => t.gild.selectedAward,
				s = t => t.gild.gildedThing
		},
		"./src/reddit/selectors/gold/productOffers.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return i
			})), r.d(e, "c", (function() {
				return o
			})), r.d(e, "a", (function() {
				return d
			}));
			var n = r("./src/lib/makeProductOfferKey/index.ts"),
				s = r("./src/reddit/models/Gold/ProductOffer.ts");
			const i = t => t.subreddits.api.productOffers.pending,
				o = (t, e) => {
					let {
						subredditId: r,
						type: s
					} = e;
					return t.subreddits.productOffers[Object(n.a)(r, s)]
				},
				d = (t, e) => {
					let {
						subredditId: r
					} = e;
					const n = o(t, {
						subredditId: r,
						type: s.a.Powerups
					});
					return n && n[0]
				}
		},
		"./src/reddit/selectors/gold/purchaseCatalog.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			})), r.d(e, "b", (function() {
				return s
			})), r.d(e, "d", (function() {
				return i
			})), r.d(e, "c", (function() {
				return o
			})), r.d(e, "i", (function() {
				return d
			})), r.d(e, "e", (function() {
				return c
			})), r.d(e, "g", (function() {
				return a
			})), r.d(e, "f", (function() {
				return u
			})), r.d(e, "h", (function() {
				return l
			}));
			const n = t => t.goldPurchase.purchaseCatalog.activeSaleConfig,
				s = t => {
					return t.goldPurchase.purchaseCatalog.coinPackages.storefrontPackageIds.map(e => t.goldPurchase.purchaseCatalog.coinPackages.models[e])
				},
				i = t => {
					return t.goldPurchase.purchaseCatalog.coinPackages.dealPackageIds.map(e => t.goldPurchase.purchaseCatalog.coinPackages.models[e])
				},
				o = (t, e) => {
					return i(t).filter(t => t.mobileId === e)[0]
				},
				d = t => {
					return t.goldPurchase.purchaseCatalog.coinPackages.recommendedPackageIds.map(e => t.goldPurchase.purchaseCatalog.coinPackages.models[e])
				},
				c = t => t.goldPurchase.purchaseCatalog.premiumPackages,
				a = t => t.goldPurchase.purchaseCatalog.api.storefrontPending,
				u = t => t.goldPurchase.purchaseCatalog.api.errorMessage,
				l = t => t.goldPurchase.purchaseCatalog.api.recommendedPending
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(t, e, r) {
			"use strict";
			r.d(e, "n", (function() {
				return n
			})), r.d(e, "p", (function() {
				return s
			})), r.d(e, "o", (function() {
				return i
			})), r.d(e, "r", (function() {
				return o
			})), r.d(e, "q", (function() {
				return d
			})), r.d(e, "w", (function() {
				return c
			})), r.d(e, "l", (function() {
				return a
			})), r.d(e, "m", (function() {
				return u
			})), r.d(e, "x", (function() {
				return l
			})), r.d(e, "a", (function() {
				return b
			})), r.d(e, "f", (function() {
				return p
			})), r.d(e, "t", (function() {
				return O
			})), r.d(e, "u", (function() {
				return m
			})), r.d(e, "s", (function() {
				return f
			})), r.d(e, "v", (function() {
				return _
			})), r.d(e, "d", (function() {
				return g
			})), r.d(e, "e", (function() {
				return j
			})), r.d(e, "g", (function() {
				return E
			})), r.d(e, "i", (function() {
				return y
			})), r.d(e, "j", (function() {
				return S
			})), r.d(e, "h", (function() {
				return T
			})), r.d(e, "k", (function() {
				return h
			})), r.d(e, "c", (function() {
				return I
			})), r.d(e, "b", (function() {
				return C
			}));
			const n = t => t.goldPurchase.purchaseModal.activePage,
				s = t => t.goldPurchase.purchaseModal.gildThingId || void 0,
				i = t => t.goldPurchase.purchaseModal.correlationId || void 0,
				o = t => t.goldPurchase.purchaseModal.showModal,
				d = t => t.goldPurchase.purchaseModal.packageId,
				c = t => t.goldPurchase.targetedOffer.packageId,
				a = t => t.goldPurchase.premiumPurchaseModal.activePage,
				u = t => t.goldPurchase.premiumPurchaseModal.showModal,
				l = t => t.goldPurchase.updateCardModal.pending,
				b = t => t.goldPurchase.payment.paymentMethod,
				p = t => t.goldPurchase.payment.cardName,
				O = t => t.goldPurchase.payment.savedCardsPending,
				m = t => t.goldPurchase.payment.savedCards,
				f = t => t.goldPurchase.payment.rememberCard,
				_ = t => t.goldPurchase.payment.useSavedCard,
				g = t => t.goldPurchase.payment.cardValidation.cardCvc,
				j = t => t.goldPurchase.payment.cardValidation.cardExpiry,
				E = t => t.goldPurchase.payment.cardValidation.cardNumber,
				y = t => t.goldPurchase.payment.cardValidation.nameOnCard,
				S = t => t.goldPurchase.payment.cardValidation.postalCode,
				T = t => t.goldPurchase.payment.stripeToken.errorMessage,
				h = t => t.goldPurchase.payment.stripeToken.pending,
				I = t => t.goldPurchase.payment.paypal.passthrough,
				C = t => t.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			})), r.d(e, "b", (function() {
				return o
			}));
			var n = r("./src/reddit/featureFlags/index.ts"),
				s = r("./src/reddit/selectors/moderatorPermissions.ts");
			const i = (t, e) => {
					let {
						subredditId: r
					} = e;
					if (!n.d.subredditInlineEditing(t)) return !1;
					const i = r ? Object(s.j)(t, {
						subredditId: r
					}) : null;
					return !!i && (t => !!t && t.config)(i)
				},
				o = t => t.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/moderatingComments.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return n
			})), r.d(e, "a", (function() {
				return s
			}));
			const n = (t, e) => {
					let {
						commentId: r,
						commentsPageKey: n
					} = e;
					if (!r) return !1;
					if (t.comments.collapsed[n] && r in t.comments.collapsed[n]) return !!t.comments.collapsed[n][r];
					const s = t.comments.models[r];
					return !!s && ("computedCollapsed" in s ? !!s.computedCollapsed : s.collapsedBecauseCrowdControl ? !t.modModeEnabled : s.collapsed)
				},
				s = (t, e) => {
					let {
						commentId: r
					} = e;
					if (!r) return !1;
					const n = t.comments.models[r];
					return !(!n || !n.collapsedBecauseCrowdControl) && t.modModeEnabled
				}
		},
		"./src/reddit/selectors/oldSiteRules.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return n
			}));
			const n = t => t.oldSiteRules
		},
		"./src/reddit/selectors/searchResults.ts": function(t, e, r) {
			"use strict";
			r.d(e, "d", (function() {
				return s
			})), r.d(e, "e", (function() {
				return i
			})), r.d(e, "b", (function() {
				return o
			})), r.d(e, "f", (function() {
				return d
			})), r.d(e, "i", (function() {
				return c
			})), r.d(e, "c", (function() {
				return a
			})), r.d(e, "h", (function() {
				return u
			})), r.d(e, "a", (function() {
				return l
			})), r.d(e, "g", (function() {
				return b
			}));
			r("./node_modules/core-js/modules/es6.regexp.search.js");
			const n = [],
				s = (t, e) => {
					let {
						listingKey: r
					} = e;
					return t.listings.listingOrder.api.error[r]
				},
				i = (t, e) => {
					let {
						listingKey: r
					} = e;
					return t.listings.listingOrder.api.pending[r]
				},
				o = (t, e) => {
					let {
						listingKey: r
					} = e;
					return t.listings.listingOrder.identifiers[r] || []
				},
				d = (t, e) => {
					let {
						listingKey: r
					} = e;
					return t.listings.listingOrder.loadMore[r]
				},
				c = t => {
					const e = t.search.searchQuery;
					if (!e) return n;
					const r = t.search.typeahead.idsByQuery[e.toLowerCase()];
					if (!r) return n;
					const s = [];
					return r.forEach(e => {
						s.push(t.search.typeahead.models[e])
					}), s
				},
				a = t => t.search.typeahead.idsByQuery,
				u = t => {
					const e = t.listings.activeKey;
					return t.search.viewTreatment[e]
				},
				l = t => {
					const e = t.listings.activeKey;
					if (e) return t.searchDiscoveryUnits.headerContent[e]
				},
				b = (t, e) => e ? t.search.relatedQueries[e.toLowerCase()] : n
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return i
			})), r.d(e, "b", (function() {
				return c
			})), r.d(e, "c", (function() {
				return a
			}));
			r("./node_modules/core-js/modules/es6.regexp.split.js");
			var n = r("./node_modules/reselect/es/index.js"),
				s = r("./src/reddit/selectors/user.ts");
			const i = t => !Object(s.I)(t) && t.seo.linksModule.frontpage || null,
				o = t => {
					const e = t.split("/");
					if ("r" === e[1]) return e[2]
				},
				d = Object(n.a)(i, t => t ? t.map(t => Object.assign(Object.assign({}, t), {
					links: t.links.map(t => Object.assign(Object.assign({}, t), {
						title: o(t.url)
					})).filter(t => t.title)
				})) : null),
				c = Object(n.a)(d, t => t ? t.map(t => Object.assign(Object.assign({}, t), {
					links: t.links.filter(t => t.visible)
				})) : null),
				a = (t, e) => {
					let {
						subredditId: r
					} = e;
					const n = ((t, e) => {
						let {
							subredditId: r
						} = e;
						return t.seo.linksModule.subreddits && t.seo.linksModule.subreddits[r]
					})(t, {
						subredditId: r
					});
					return n && n.subreddits
				}
		},
		"./src/reddit/selectors/tags.ts": function(t, e, r) {
			"use strict";
			r.d(e, "f", (function() {
				return u
			})), r.d(e, "g", (function() {
				return l
			})), r.d(e, "k", (function() {
				return b
			})), r.d(e, "h", (function() {
				return p
			})), r.d(e, "e", (function() {
				return O
			})), r.d(e, "i", (function() {
				return m
			})), r.d(e, "r", (function() {
				return f
			})), r.d(e, "D", (function() {
				return _
			})), r.d(e, "E", (function() {
				return g
			})), r.d(e, "l", (function() {
				return j
			})), r.d(e, "m", (function() {
				return E
			})), r.d(e, "o", (function() {
				return S
			})), r.d(e, "v", (function() {
				return T
			})), r.d(e, "w", (function() {
				return h
			})), r.d(e, "t", (function() {
				return x
			})), r.d(e, "b", (function() {
				return D
			})), r.d(e, "d", (function() {
				return R
			})), r.d(e, "c", (function() {
				return P
			})), r.d(e, "s", (function() {
				return N
			})), r.d(e, "n", (function() {
				return k
			})), r.d(e, "C", (function() {
				return v
			})), r.d(e, "B", (function() {
				return U
			})), r.d(e, "x", (function() {
				return L
			})), r.d(e, "a", (function() {
				return M
			})), r.d(e, "u", (function() {
				return G
			})), r.d(e, "F", (function() {
				return F
			})), r.d(e, "z", (function() {
				return q
			})), r.d(e, "A", (function() {
				return K
			})), r.d(e, "j", (function() {
				return H
			})), r.d(e, "y", (function() {
				return Y
			})), r.d(e, "G", (function() {
				return V
			})), r.d(e, "p", (function() {
				return W
			})), r.d(e, "q", (function() {
				return J
			}));
			r("./node_modules/core-js/modules/web.dom.iterable.js");
			var n = r("./node_modules/lodash/some.js"),
				s = r.n(n),
				i = r("./node_modules/lodash/values.js"),
				o = r.n(i),
				d = r("./src/lib/objectSelector/index.ts"),
				c = r("./src/reddit/helpers/tags/index.ts"),
				a = r("./src/reddit/models/Tags/index.ts");
			const u = t => {
					const e = Y(t),
						r = e && e.id;
					return o()((t => {
						const e = l(t) ? w(t) : x(t),
							r = b(t),
							n = e.reduce((t, e) => (t[e.id] = Object(a.f)(e), t), {});
						return r.reduce((t, e) => (e.id && t[e.id] && (t[e.id].selected = !0), t), n)
					})(t)).filter(t => !t.selected && t.id !== r)
				},
				l = t => t.tags.creation.tagInput || "",
				b = t => t.tags.creation.selectedOptions || [],
				p = t => {
					const e = [];
					for (let r = 0; r < b(t).length; r++) b(t)[r].id && e.push(b(t)[r].id);
					return e || []
				},
				O = t => (b(t) || []).filter(t => !!t.displayText).map(t => t.displayText),
				m = t => {
					const e = [];
					for (let r = 0; r < b(t).length; r++) b(t)[r].id || e.push(b(t)[r].displayText);
					return e || []
				},
				f = t => Object.keys(t.tags.models.globalSubredditTags).length > 0,
				_ = t => t.tags.api.create.error || t.tags.api.deleteTag.error || t.tags.api.fetch.error || t.tags.api.update.error,
				g = t => t.tags.api.create.pending || t.tags.api.deleteTag.pending || t.tags.api.fetch.pending || t.tags.api.update.pending,
				j = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.selected.inputByItemId[r] || ""
				},
				E = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.selected.suggestedInputByItemId[r] || ""
				},
				y = [],
				S = (t, e) => {
					let {
						subredditId: r
					} = e;
					return s()(T(t, {
						subredditId: r
					}), t => !!t.action) || s()(I(t, {
						subredditId: r
					}), t => !!t.action)
				},
				T = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.selected.selectedOptions[r] || y
				},
				h = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.selected.selectedSuggestedOptions[r] || y
				},
				I = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.selected.deselectedOptions[r] || y
				},
				C = {},
				A = {},
				x = t => t.tags.availableGlobalTagOrder.recommendedGlobal.map(e => t.tags.models.globalSubredditTags[e]),
				D = t => t.tags.models.globalSubredditTags,
				w = t => t.tags.availableGlobalTagOrder.global.map(e => t.tags.models.globalSubredditTags[e]),
				R = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.models.subredditScopedTags[r] || A
				},
				P = (t, e) => {
					const r = o()(e);
					for (let n = 0; n < r.length; n++)
						if (r[n].text.toLowerCase().trim() === t.toLowerCase().trim()) return r[n];
					return null
				},
				N = (t, e) => {
					let {
						itemId: r
					} = e;
					return t.tags.models.itemTags[r] || C
				},
				k = (t, e) => {
					let {
						itemId: r
					} = e;
					return !!t.tags.models.itemTags[r]
				},
				v = (t, e) => {
					let {
						itemId: r
					} = e;
					return t.tags.models.suggestedItemTags[r] || C
				},
				U = (t, e) => {
					let {
						itemId: r
					} = e;
					return o()(v(t, {
						itemId: r
					})).filter(t => t.isRelevant).map(t => Object(a.e)(t, !0))
				},
				L = (t, e) => {
					let {
						itemId: r
					} = e;
					return t.tags.models.sortedItemTags[r] || []
				},
				M = Object(d.a)((t, e) => {
					let {
						thingId: r,
						suggested: n = !1
					} = e;
					const s = q(t, {
						subredditId: r
					});
					return o()(((t, e) => {
						let {
							thingId: r,
							suggested: n = !1
						} = e;
						const s = (n ? E(t, {
								subredditId: r
							}) : j(t, {
								subredditId: r
							})) ? w(t) : x(t),
							i = n ? h(t, {
								subredditId: r
							}) : T(t, {
								subredditId: r
							}),
							o = s.reduce((t, e) => (t[e.id] = Object(a.f)(e), t), {});
						return i.reduce((t, e) => (e.id && t[e.id] && (t[e.id].selected = !0), t), o)
					})(t, {
						thingId: r,
						suggested: n
					})).filter(t => !t.selected && t.id !== s)
				}),
				G = (t, e) => {
					let {
						subredditId: r
					} = e;
					return T(t, {
						subredditId: r
					}).concat(I(t, {
						subredditId: r
					}))
				},
				F = (t, e) => {
					let {
						subredditId: r
					} = e;
					return T(t, {
						subredditId: r
					}).filter(c.b).map(t => ({
						text: t.displayText,
						type: a.c.CLASSIFICATION
					}))
				},
				q = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.tags.models.subredditPrimaryTagId[r] || null
				},
				B = (t, e) => e && t.tags.models.globalSubredditTags[e] || null,
				K = (t, e) => {
					const r = q(t, e);
					return B(t, r)
				},
				H = t => t.tags.creation.selectedPrimaryTagId || null,
				Y = t => {
					const e = H(t);
					return B(t, e)
				},
				V = t => t.tags.api.updatePrimaryTag.pending,
				W = (t, e) => {
					let {
						subredditId: r
					} = e;
					return Object.keys(N(t, {
						itemId: r
					})).length > 0
				},
				J = t => b(t).length > 0
		},
		"./src/reddit/selectors/userFlair.ts": function(t, e, r) {
			"use strict";
			r.d(e, "c", (function() {
				return o
			})), r.d(e, "a", (function() {
				return d
			})), r.d(e, "d", (function() {
				return c
			})), r.d(e, "e", (function() {
				return a
			})), r.d(e, "b", (function() {
				return u
			}));
			var n = r("./src/lib/objectSelector/index.ts"),
				s = r("./src/reddit/models/Flair/index.ts"),
				i = r("./src/reddit/selectors/moderatorPermissions.ts");
			const o = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.userFlair[r]
				},
				d = (t, e) => {
					let {
						subredditId: r
					} = e;
					return !t.userFlair[r] || t.userFlair[r].displaySettings.isEnabled
				},
				c = (t, e) => {
					let {
						subredditId: r
					} = e;
					return t.userFlair[r] ? t.userFlair[r].displaySettings.position : s.b.Right
				},
				a = Object(n.a)((t, e) => {
					let {
						subredditId: r
					} = e;
					const n = o(t, {
						subredditId: r
					});
					if (n) return {
						type: s.d.UserFlair,
						displaySettings: n.displaySettings,
						permissions: n.permissions
					}
				}),
				u = (t, e) => {
					let {
						subredditId: r
					} = e;
					const n = d(t, {
							subredditId: r
						}),
						s = a(t, {
							subredditId: r
						}),
						c = o(t, {
							subredditId: r
						});
					if (!n || !s || !c) return !1;
					if (c.applied) return !0;
					const u = Object(i.d)(t, {
							subredditId: r
						}),
						{
							canUserChange: l
						} = s.permissions;
					return !!c.templateIds.find(t => {
						return !c.templates[t].modOnly || u
					}) && l
				}
		},
		"./src/reddit/selectors/userPrefs.ts": function(t, e, r) {
			"use strict";
			r.d(e, "b", (function() {
				return s
			})), r.d(e, "a", (function() {
				return i
			})), r.d(e, "c", (function() {
				return o
			}));
			var n = r("./src/lib/constants/index.ts");
			const s = t => !i(t) && !!t.user.prefs.subscriptionsPinned,
				i = t => !(!t.platform.currentPage || !t.platform.currentPage.meta || t.platform.currentPage.meta.name !== n.Bb.MODERATION_PAGES),
				o = t => t.user.prefs.reduceAnimationsFromAwards
		},
		"./src/reddit/selectors/widgets.ts": function(t, e, r) {
			"use strict";
			r.d(e, "a", (function() {
				return u
			})), r.d(e, "k", (function() {
				return l
			})), r.d(e, "c", (function() {
				return b
			})), r.d(e, "d", (function() {
				return p
			})), r.d(e, "i", (function() {
				return O
			})), r.d(e, "e", (function() {
				return m
			})), r.d(e, "f", (function() {
				return f
			})), r.d(e, "j", (function() {
				return _
			})), r.d(e, "h", (function() {
				return g
			})), r.d(e, "g", (function() {
				return j
			})), r.d(e, "b", (function() {
				return E
			}));
			var n = r("./src/lib/objectSelector/index.ts"),
				s = r("./src/reddit/constants/posts.ts"),
				i = r("./src/reddit/helpers/name/index.ts"),
				o = r("./src/reddit/models/Widgets/index.ts"),
				d = r("./src/reddit/selectors/profile.ts"),
				c = r("./src/reddit/selectors/subreddit.ts");
			const a = [],
				u = t => t.widgets.models,
				l = Object(n.a)((t, e) => Object(o.r)(e) ? t.widgets.models[e.widgetId] : Object(o.l)(e.widgetKind)),
				b = (t, e) => t.widgets.idCardIds[e.subredditId],
				p = (t, e) => {
					let r = e.subredditId;
					if (!r && e.subredditName && (r = Object(c.G)(t, e.subredditName)), r) {
						const e = b(t, {
							subredditId: r
						});
						if (e) return t.widgets.models[e]
					}
					return null
				},
				O = (t, e) => t.widgets.sidebar[e.subredditId] || [],
				m = (t, e) => t.widgets.menuIds[e.subredditId],
				f = (t, e) => {
					const r = m(t, e);
					return r ? t.widgets.models[r] : null
				},
				_ = (t, e) => {
					const r = t.widgets.sidebar[e.subredditId];
					return Array.isArray(r) ? r.reduce((e, r) => {
						const n = t.widgets.models[r];
						return n && e.push(n.kind), e
					}, []) : a
				},
				g = (t, e) => {
					const r = O(t, e);
					for (const n of r) {
						const e = t.widgets.models[n];
						if ("subreddit-rules" === e.kind) return e
					}
					return null
				},
				j = (t, e) => {
					const r = O(t, e).map(e => t.widgets.models[e]).filter(t => "post-flair" === t.kind);
					return r.length ? r : null
				},
				E = Object(n.a)((t, e) => {
					if (e.type === s.a.PROFILE) {
						const r = Object(d.j)(t, {
							profileName: e.name
						});
						return r ? {
							profile: {
								id: r.id,
								name: Object(i.f)(r.name)
							}
						} : {}
					}
					const r = Object(c.B)(t, {
							subredditName: e.name
						}),
						n = Object(c.y)(t, {
							subredditName: e.name
						});
					return {
						subreddit: {
							categoryName: n ? n.contentCategory : null,
							id: r.id,
							name: Object(i.f)(r.name)
						}
					}
				})
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/Governance~Reddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-components-Larg~9453fc9d.f4cf39a5ea1ed5a86b52.js.map