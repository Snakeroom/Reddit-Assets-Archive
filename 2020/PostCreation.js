// https://www.redditstatic.com/desktop2x/PostCreation.b0aaffaf1611712fa134.js
// Retrieved at 9/14/2020, 2:40:07 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["PostCreation", "ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Prof~d6dc9580", "CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~InFeedChaining~ModerationPages~Profi~dfd687ea", "ModerationPages~PostDraft~ProfileComments~ProfileOverview~ProfilePrivate~RpanListingUnit~SearchResul~972c7c49", "ChatMessageInput~MembershipPaywallPage~RichTextEditor"], {
		"./node_modules/brcast/dist/brcast.es.js": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				var t = {},
					n = 1,
					s = e;
				return {
					getState: function() {
						return s
					},
					setState: function(e) {
						s = e;
						for (var n = Object.keys(t), o = 0, r = n.length; o < r; o++) t[n[o]] && t[n[o]](e)
					},
					subscribe: function(e) {
						if ("function" != typeof e) throw new Error("listener must be a function.");
						var s = n;
						return t[s] = e, n += 1, s
					},
					unsubscribe: function(e) {
						t[e] = void 0
					}
				}
			}
		},
		"./node_modules/lodash/uniqueId.js": function(e, t, n) {
			var s = n("./node_modules/lodash/toString.js"),
				o = 0;
			e.exports = function(e) {
				var t = ++o;
				return s(e) + t
			}
		},
		"./node_modules/react-router-dom/esm/react-router-dom.js": function(e, t, n) {
			"use strict";

			function s(e, t) {
				e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
			}
			n.d(t, "a", (function() {
				return u
			}));
			var o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-router/esm/react-router.js"),
				a = n("./node_modules/history/esm/history.js");
			n("./node_modules/react-router-dom/node_modules/prop-types/index.js");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function l(e, t) {
				if (null == e) return {};
				var n, s, o = {},
					r = Object.keys(e);
				for (s = 0; s < r.length; s++) n = r[s], t.indexOf(n) >= 0 || (o[n] = e[n]);
				return o
			}
			var d = n("./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");
			r.a.Component;
			r.a.Component;
			var u = function(e) {
				function t() {
					return e.apply(this, arguments) || this
				}
				s(t, e);
				var n = t.prototype;
				return n.handleClick = function(e, t) {
					try {
						this.props.onClick && this.props.onClick(e)
					} catch (n) {
						throw e.preventDefault(), n
					}
					e.defaultPrevented || 0 !== e.button || this.props.target && "_self" !== this.props.target || function(e) {
						return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
					}(e) || (e.preventDefault(), (this.props.replace ? t.replace : t.push)(this.props.to))
				}, n.render = function() {
					var e = this,
						t = this.props,
						n = t.innerRef,
						s = (t.replace, t.to),
						o = l(t, ["innerRef", "replace", "to"]);
					return r.a.createElement(i.g.Consumer, null, (function(t) {
						t || Object(d.default)(!1);
						var i = "string" == typeof s ? Object(a.c)(s, null, null, t.location) : s,
							l = i ? t.history.createHref(i) : "";
						return r.a.createElement("a", c({}, o, {
							onClick: function(n) {
								return e.handleClick(n, t.history)
							},
							href: l,
							ref: n
						}))
					}))
				}, t
			}(r.a.Component)
		},
		"./node_modules/react-router-dom/node_modules/prop-types/factoryWithThrowingShims.js": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-router-dom/node_modules/prop-types/lib/ReactPropTypesSecret.js");

			function o() {}

			function r() {}
			r.resetWarningCache = o, e.exports = function() {
				function e(e, t, n, o, r, i) {
					if (i !== s) {
						var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
						throw a.name = "Invariant Violation", a
					}
				}

				function t() {
					return e
				}
				e.isRequired = e;
				var n = {
					array: e,
					bool: e,
					func: e,
					number: e,
					object: e,
					string: e,
					symbol: e,
					any: e,
					arrayOf: t,
					element: e,
					elementType: e,
					instanceOf: t,
					node: e,
					objectOf: t,
					oneOf: t,
					oneOfType: t,
					shape: t,
					exact: t,
					checkPropTypes: r,
					resetWarningCache: o
				};
				return n.PropTypes = n, n
			}
		},
		"./node_modules/react-router-dom/node_modules/prop-types/index.js": function(e, t, n) {
			e.exports = n("./node_modules/react-router-dom/node_modules/prop-types/factoryWithThrowingShims.js")()
		},
		"./node_modules/react-router-dom/node_modules/prop-types/lib/ReactPropTypesSecret.js": function(e, t, n) {
			"use strict";
			e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
		},
		"./src/graphql/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"c896863bf3cc"}')
		},
		"./src/graphql/operations/HideAwardOnTarget.json": function(e) {
			e.exports = JSON.parse('{"id":"4e43964bff6f"}')
		},
		"./src/graphql/operations/PollVote.json": function(e) {
			e.exports = JSON.parse('{"id":"a20cc8dd230d"}')
		},
		"./src/graphql/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"fd09f54393b2"}')
		},
		"./src/graphql/operations/TopAwardedPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"7f1ba87a9dd2"}')
		},
		"./src/graphql/operations/TopAwardersLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"2a194e7926dd"}')
		},
		"./src/graphql/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"df08261a60e8"}')
		},
		"./src/higherOrderComponents/addOverlayEvents.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return u
			}));
			var s, o = n("./node_modules/lodash/debounce.js"),
				r = n.n(o),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/actions/overlayEvents.ts");

			function u(e, t) {
				class n extends i.Component {
					constructor(e) {
						super(e), this.handleKeyDown = e => {
							e.keyCode === l.F && this.props.onKeyDown(e)
						}, this.handleMouseClick = e => {
							this.props.onMouseClick(e)
						}, this.handleResize = r()(e => {
							this.props.onResize(e)
						}, 250, {
							leading: !0
						})
					}
					componentDidMount() {
						t && -1 !== t.indexOf(s.Keydown) || document.addEventListener("keydown", this.handleKeyDown), t && -1 !== t.indexOf(s.Click) || document.addEventListener("click", this.handleMouseClick), t && -1 !== t.indexOf(s.Resize) || window.addEventListener("resize", this.handleResize)
					}
					componentWillUnmount() {
						document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("click", this.handleMouseClick), window.removeEventListener("resize", this.handleResize)
					}
					render() {
						return a.a.createElement(e, this.props)
					}
				}
				return Object(c.b)(null, e => ({
					onKeyDown: t => e(d.d({
						event: t
					})),
					onMouseClick: t => e(d.e({
						event: t
					})),
					onResize: t => e(d.f({
						event: t
					}))
				}))(n)
			}! function(e) {
				e.Click = "click", e.Keydown = "keydown", e.Resize = "resize"
			}(s || (s = {}))
		},
		"./src/higherOrderComponents/asModal/index.m.less": function(e, t, n) {
			e.exports = {
				overlay: "_1DK52RbaamLOWw5UPaht_S",
				mIsVisible: "_1acwN_tUhJ8w-n7oCp-Aw3",
				modal: "_2Bejocqb-InO8686E2ehf"
			}
		},
		"./src/higherOrderComponents/asModal/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/FocusTrap/index.ts"),
				a = n("./src/reddit/actions/shortcuts/utils.ts"),
				c = n("./src/reddit/components/Portal/index.tsx"),
				l = n("./src/reddit/constants/shortcuts.ts"),
				d = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				u = n("./src/higherOrderComponents/asModal/index.m.less"),
				p = n.n(u);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var h = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const b = e => {
				var {
					className: t,
					isVisible: n
				} = e, s = h(e, ["className", "isVisible"]);
				return o.a.createElement("div", m({
					className: Object(r.a)(p.a.overlay, t, {
						[p.a.mIsVisible]: n
					})
				}, s))
			};

			function f(e) {
				class t extends s.Component {
					constructor(e) {
						super(e), this.getRef = e => this.ref = e, this.onClick = e => e.stopPropagation(), this.onOverlayClick = e => {
							this.props.onOverlayClick && this.props.onOverlayClick(), e.stopPropagation()
						}, this.state = {
							mounted: !1
						}
					}
					componentDidMount() {
						this.props.ignoreDefaultFocus || this.ref && this.ref.focus(), this.setState({
							mounted: !0
						}), Object(d.a)(), this.ref && (this.focusTrap = new i.b(this.ref), this.focusTrap.activate())
					}
					componentWillUnmount() {
						this.setState({
							mounted: !1
						}), Object(d.b)(), Object(a.d)(), this.focusTrap && this.focusTrap.deactivate()
					}
					render() {
						const {
							props: t
						} = this, {
							className: n,
							ignoreDefaultFocus: s,
							onOverlayClick: i,
							overlayClassName: a,
							overlayCustomStyles: d,
							withOverlay: u
						} = t, m = h(t, ["className", "ignoreDefaultFocus", "onOverlayClick", "overlayClassName", "overlayCustomStyles", "withOverlay"]);
						return o.a.createElement(c.a, {
							container: document.getElementById(l.b)
						}, o.a.createElement(b, {
							className: a,
							isVisible: u,
							onClick: this.onOverlayClick,
							style: d
						}, o.a.createElement("div", {
							"aria-modal": !0,
							className: Object(r.a)(p.a.modal, n),
							onClick: this.onClick,
							ref: this.getRef,
							role: "dialog",
							tabIndex: -1
						}, o.a.createElement(e, m))))
					}
				}
				return t
			}
		},
		"./src/higherOrderComponents/asTooltip.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return g
			})), n.d(t, "a", (function() {
				return x
			}));
			var s = n("./node_modules/lodash/omit.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/lib/fastdom/index.ts"),
				c = n("./src/reddit/components/Portal/index.tsx"),
				l = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				d = n("./src/higherOrderComponents/sizeMe.tsx"),
				u = n("./src/reddit/components/HiddenDiv.m.less"),
				p = n.n(u),
				m = n("./src/lib/lessComponent.tsx").a.div("Component", p.a);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const b = ["left", "bottom"],
				f = ["left", "top"],
				g = e => {
					let {
						container: t,
						containerHeight: n,
						excludeContainerPosition: s,
						isFixed: o,
						targetBox: r,
						isOverlayOff: i,
						targetPosition: a,
						tooltipSize: c,
						tooltipPosition: l
					} = e;
					const d = document.body,
						u = d.clientTop || 0,
						p = d.clientLeft || 0,
						[m, h, b, f] = t ? [t.scrollLeft, t.scrollTop, t.scrollWidth, n || t.scrollHeight] : [window.pageXOffset, window.pageYOffset, window.innerWidth, document.body.scrollHeight],
						g = {
							bottom: r.bottom,
							center: r.top + r.height / 2,
							top: r.top
						} [a[1]] + {
							bottom: -c.height,
							center: -c.height / 2,
							top: 0
						} [l[1]],
						x = {
							left: r.left,
							center: r.left + r.width / 2,
							right: r.right
						} [a[0]] + {
							left: 0,
							center: -c.width / 2,
							right: -c.width
						} [l[0]];
					let y, v;
					o ? (y = g - u, v = x - p) : (v = m + p + x, y = h + u + g);
					const C = {
							left: v,
							top: y
						},
						E = {
							bottom: Math.max(0, y + c.height - f),
							left: Math.max(0, 0 - v),
							right: Math.max(0, v + c.width - b),
							top: Math.max(0, 0 - y)
						};
					if (b > 320 && f > 667 && !i && (Boolean(E.left) !== Boolean(E.right) && (E.left ? C.left = 0 : C.left -= E.right), Boolean(E.top) !== Boolean(E.bottom) && (E.top ? C.top = 0 : C.top -= E.bottom)), s && t) {
						const e = t.getBoundingClientRect();
						C.top = C.top - e.top, C.left = C.left - e.left
					}
					return {
						overflow: E,
						style: C
					}
				};

			function x(e, t) {
				const n = Object(l.b)(e, t),
					s = Object(d.a)(e => {
						const {
							container: t,
							containerHeight: s,
							domEl: r,
							excludeContainerPosition: a,
							isFixed: c,
							target: l,
							isOverlayOff: d,
							targetPosition: u,
							tooltipPosition: p
						} = e;
						if (!l || !r) return null;
						const m = r.getBoundingClientRect(),
							x = l.getBoundingClientRect(),
							y = g({
								container: t,
								containerHeight: s,
								excludeContainerPosition: a,
								isOverlayOff: d,
								isFixed: !!c,
								targetBox: x,
								targetPosition: u || b,
								tooltipSize: {
									height: m.height,
									width: m.width
								},
								tooltipPosition: p || f
							}),
							v = o()(e, "target", "targetPosition", "tooltipPosition"),
							C = e.style ? Object.assign(Object.assign({}, y.style), e.style) : y.style;
						return i.a.createElement(n, h({}, v, {
							overflow: y.overflow,
							style: C,
							targetBox: x
						}))
					});
				class u extends r.Component {
					constructor() {
						super(...arguments), this.state = {
							containerHeight: null,
							isOpen: !1,
							mounted: !1
						}, this.target = null
					}
					componentDidMount() {
						this.target = this.props.tooltipTarget || document.getElementById(this.props.tooltipId), this.props.isOpen && a.a.write(() => {
							this.setState({
								mounted: !0
							})
						})
					}
					componentDidUpdate() {
						this.target = this.props.tooltipTarget || document.getElementById(this.props.tooltipId)
					}
					static getDerivedStateFromProps(e, t) {
						if (t.isOpen === e.isOpen) return null;
						return {
							containerHeight: e.isOpen && !t.isOpen && e.container ? e.container.scrollHeight : null,
							isOpen: e.isOpen
						}
					}
					render() {
						if (!this.props.isOpen) return this.props.renderContentsHidden ? i.a.createElement(m, null, this.props.children) : null;
						const {
							isOpen: e,
							tooltipId: t,
							tooltipTarget: n
						} = this.props, {
							containerHeight: r,
							mounted: a
						} = this.state, l = o()(this.props, "isOpen"), d = t ? this.target : n, u = "".concat(e, "-").concat(a, "-").concat(t || "");
						return i.a.createElement(c.a, {
							key: u,
							container: this.props.container
						}, i.a.createElement(s, h({}, l, {
							containerHeight: r,
							target: d
						})))
					}
				}
				return u
			}
		},
		"./src/higherOrderComponents/makeAsync.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r(e) {
				var t;
				return (t = class t extends o.a.Component {
					constructor(e) {
						super(e), this.mounted = !1, this.state = {
							Component: t.Component
						}
					}
					componentDidMount() {
						this.mounted = !0, this.state.Component !== e.ErrorComponent && e.getComponent().then(e => {
							t.Component = e, this.mounted && this.setState({
								Component: e
							})
						}, t => (this.mounted && this.setState({
							Component: e.ErrorComponent
						}), Promise.reject(t)))
					}
					componentWillUnmount() {
						this.mounted = !1
					}
					render() {
						const t = this.state.Component || e.LoadingComponent;
						return o.a.createElement(t, this.props)
					}
				}).Component = null, t
			}
		},
		"./src/higherOrderComponents/sizeMe.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/omit.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-dom/index.js"),
				c = n.n(a);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function d(e) {
				return e.displayName || e.name || "Component"
			}
			class u extends r.Component {
				render() {
					return r.Children.only(this.props.children)
				}
			}
			u.displayName = "SizeMeReferenceWrapper";
			const p = e => {
				let {
					style: t
				} = e;
				const n = {
					style: t || {
						width: "100%",
						height: "100%"
					}
				};
				return i.a.createElement("div", n)
			};
			p.displayName = "SizeMePlaceholder", t.a = function(e) {
				const t = function(e) {
					const t = t => {
						const {
							domEl: n,
							explicitRef: s,
							placeholder: r,
							size: a,
							style: c
						} = t, d = o()(t, "explicitRef", "size", "style"), m = "object" != typeof a || "number" != typeof a.width && "number" != typeof a.height, h = {
							domEl: n,
							style: c
						};
						"object" == typeof a && (h.size = a);
						const b = m && !1 !== r ? i.a.createElement(p, {
							style: c
						}) : i.a.createElement(e, l({}, h, d));
						return i.a.createElement(u, {
							ref: s
						}, b)
					};
					return t.displayName = "SizeMeRenderer(".concat(d(e), ")"), t
				}(e);
				class n extends i.a.Component {
					constructor() {
						super(...arguments), this.state = {
							width: void 0,
							height: void 0
						}, this.refCallback = e => {
							this.reactInst = e
						}, this.hasSizeChanged = (e, t) => {
							const n = e,
								s = t;
							return Number(n.height).toFixed(0) !== Number(s.height).toFixed(0) || Number(n.width).toFixed(0) !== Number(s.width).toFixed(0)
						}, this.checkIfSizeChanged = e => {
							const {
								width: t,
								height: n
							} = e.getBoundingClientRect(), s = {
								width: t,
								height: n
							};
							this.hasSizeChanged(this.state, s) && this.setState(s)
						}
					}
					componentDidMount() {
						this.handleDOMNode()
					}
					componentDidUpdate() {
						this.handleDOMNode()
					}
					componentWillUnmount() {
						this.hasSizeChanged = () => !1, this.checkIfSizeChanged = e => void 0, this.domEl && (this.domEl = null)
					}
					handleDOMNode() {
						const e = this.reactInst && c.a.findDOMNode(this.reactInst);
						e ? (this.domEl = e, this.checkIfSizeChanged(this.domEl)) : this.domEl && (this.domEl = null)
					}
					render() {
						const e = Object.assign({}, this.state);
						return i.a.createElement(t, l({
							domEl: this.domEl,
							explicitRef: this.refCallback,
							size: e
						}, this.props))
					}
				}
				return n.displayName = "SizeMe(".concat(d(e), ")"), n
			}
		},
		"./src/higherOrderComponents/warnOnChildrenCount/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			n("./src/lib/logs/console.ts");
			t.a = function(e, t) {
				return t => o.a.createElement(e, t)
			}
		},
		"./src/higherOrderComponents/withMux/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/cache/localStorage/index.ts"),
				c = n("./src/lib/combineRefs/index.tsx"),
				l = n("./src/lib/loadWithRetries/index.ts"),
				d = () => Object(l.a)(() => n.e("vendors~MuxEmbed").then(n.t.bind(null, "./node_modules/mux-embed/dist/mux.js", 7))),
				u = n("./src/reddit/constants/experiments.ts"),
				p = n("./src/reddit/helpers/chooseVariant/index.ts");
			const m = Object(i.a)(e => {
				const t = Object(p.c)(e, {
					experimentEligibilitySelector: p.a,
					experimentName: u.Ab
				});
				return Object(u.Ec)(t) ? void 0 : t
			}, e => {
				const t = Object(p.c)(e, {
					experimentEligibilitySelector: p.a,
					experimentName: u.Bb
				});
				return Object(u.Ec)(t) ? void 0 : t
			}, (e, t) => e === u.Cb.Enabled && t === u.Cb.Enabled);
			var h = n("./src/config.ts");
			var b = n("./src/reddit/selectors/user.ts");
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/es6.regexp.replace.js");
			const f = e => {
					const t = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
						n = t.length,
						s = new Uint32Array(e);
					return crypto.getRandomValues(s), Array.from(s).map(e => t.charAt(e % n)).join("")
				},
				g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date;
					return new Date(e).toISOString().replace(/^(\d{4})-(\d{2})-(\d{2}).*/, "$1$2$3")
				},
				x = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					return Math.trunc(e).toString(16).padStart(t, "0")
				};
			var y;
			! function(e) {
				e.SHA1 = "SHA-1", e.SHA256 = "SHA-256", e.SHA384 = "SHA-384", e.SHA512 = "SHA-512"
			}(y || (y = {}));
			const v = async e => (async (e, t) => {
				const n = (new TextEncoder).encode(t),
					s = await crypto.subtle.digest(e, n);
				return Array.from(new Uint8Array(s)).map(x).join("")
			})(y.SHA1, e);

			function C() {
				return (C = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var E = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const O = (e => t => ((e, t) => "".concat(e, "(").concat((e => e.displayName || e.name || "Component")(t), ")"))(e, t))("WithMux"),
				j = Object({
					SENTRY_RELEASE_VERSION: "6cbf721-production"
				}),
				w = {
					anonymousUserId: "t2_anonymous",
					debug: !1,
					disableCookies: !0,
					envKey: h.a.muxApiKey,
					localStorageSaltKey: "muxSalt",
					localStorageViewerUserIdKey: "muxViewerUserId",
					playerVersion: "Reddit/Version Build ".concat(j.SENTRY_RELEASE_VERSION, " ").concat(h.a.appName),
					respectDoNotTrack: !0,
					saltLength: 20,
					saltTimeToLive: 2592e3,
					viewerUserIdLength: 20
				};
			t.a = function(e, t) {
				const {
					anonymousUserId: n,
					debug: l,
					disableCookies: u,
					envKey: p,
					localStorageSaltKey: h,
					localStorageViewerUserIdKey: x,
					playerName: y,
					playerVersion: j,
					respectDoNotTrack: S,
					saltLength: _,
					saltTimeToLive: k,
					viewerUserIdLength: T
				} = Object.assign(Object.assign({}, w), t);
				class I extends s.Component {
					constructor(e) {
						super(e), this.dashInstance = null, this.hlsInstance = null, this.isMonitoring = !1, this.playerInitTime = Date.now(), this.videoRef = Object(s.createRef)(), this.handleDashCreate = e => {
							this.setDashInstance(e)
						}, this.handleDashDestroy = () => {
							this.setDashInstance(null)
						}, this.handleHlsCreate = e => {
							this.setHlsInstance(e)
						}, this.handleHlsDestroy = () => {
							this.setHlsInstance(null)
						}, this.combinedVideoRefs = this.combineExternalVideoRef(e.videoRef)
					}
					get experimentName() {
						return ""
					}
					get video() {
						return this.videoRef.current
					}
					componentDidMount() {
						this.doMuxThings()
					}
					componentDidUpdate(e) {
						this.props.muxVideoId !== e.muxVideoId && this.doMuxThings(), this.props.videoRef !== e.videoRef && (this.combinedVideoRefs = this.combineExternalVideoRef(this.props.videoRef))
					}
					combineExternalVideoRef(e) {
						return e ? Object(c.a)(this.videoRef, e) : this.videoRef
					}
					render() {
						const t = this.props,
							{
								forwardedRef: n
							} = t,
							s = E(t, ["forwardedRef"]);
						return o.a.createElement(e, C({}, s, {
							onDashCreate: this.handleDashCreate,
							onDashDestroy: this.handleDashDestroy,
							onHlsCreate: this.handleHlsCreate,
							onHlsDestroy: this.handleHlsDestroy,
							ref: n,
							videoRef: this.combinedVideoRefs
						}))
					}
					async setDashInstance(e) {
						if (!this.props.isMuxEnabled) return;
						const t = e || null;
						if (t !== this.dashInstance && (this.dashInstance = t, this.isMonitoring)) try {
							const e = await d();
							e.removeDashJS(this.video), this.dashInstance && e.addDashJS(this.video, this.getDashInstanceData())
						} catch (n) {
							console.error(n)
						}
					}
					async setHlsInstance(e) {
						if (!this.props.isMuxEnabled) return;
						const t = e || null;
						if (t !== this.hlsInstance && (this.hlsInstance = t, this.isMonitoring)) try {
							const e = await d();
							e.removeHLSJS(this.video), this.hlsInstance && e.addHLSJS(this.video, this.getHlsInstanceData())
						} catch (n) {
							console.error(n)
						}
					}
					async doMuxThings() {
						if (this.props.isMuxEnabled) try {
							const e = await d();
							if (this.isMonitoring) {
								const t = this.getVideoData();
								e.emit(this.video, "videochange", t)
							} else {
								const t = await this.getMuxData();
								e.monitor(this.video, t), this.isMonitoring = !0
							}
						} catch (e) {
							console.error(e)
						}
					}
					async encryptViewerUserId() {
						const e = this.props.redditUserId || I.ANONYMOUS_USER_ID,
							t = this.getOrCreateSalt(),
							n = g(),
							s = "".concat(n).concat(e).concat(t);
						return (await v(s)).substr(0, I.VIEWER_USER_ID_LENGTH)
					}
					getDashInstanceData() {
						const {
							dashInstance: e
						} = this;
						return e ? {
							dashjs: e
						} : null
					}
					getHlsInstanceData() {
						const {
							hlsInstance: e
						} = this;
						return e ? {
							hlsjs: e,
							Hls: e.constructor
						} : null
					}
					async getMuxData() {
						const e = await this.encryptViewerUserId(),
							t = this.getVideoData(),
							n = this.getThirdPartyLibData();
						return Object.assign(Object.assign({
							debug: I.DEBUG,
							disableCookies: I.DISABLE_COOKIES,
							respectDoNotTrack: I.RESPECT_DO_NOT_TRACK
						}, n), {
							data: Object.assign(Object.assign({
								env_key: I.ENV_KEY,
								experiment_name: this.experimentName,
								player_init_time: this.playerInitTime,
								player_name: I.PLAYER_NAME,
								player_version: I.PLAYER_VERSION
							}, t), {
								viewer_user_id: e
							})
						})
					}
					getOrCreateSalt() {
						const e = I.LOCAL_STORAGE_SALT_KEY;
						let t = Object(a.a)(e);
						return t || (t = f(I.SALT_LENGTH), Object(a.b)(e, t, I.SALT_TIME_TO_LIVE)), t
					}
					getThirdPartyLibData() {
						return Object.assign(Object.assign({}, this.getDashInstanceData()), this.getHlsInstanceData())
					}
					getVideoData() {
						const {
							muxVideoDuration: e,
							muxVideoId: t,
							muxVideoIsLive: n,
							muxVideoTitle: s
						} = this.props;
						return {
							video_duration: n ? I.DURATION_LIVE : e,
							video_id: t,
							video_stream_type: n ? I.STREAM_TYPE_LIVE : I.STREAM_TYPE_ON_DEMAND,
							video_title: s
						}
					}
				}
				I.displayName = O(e), I.ANONYMOUS_USER_ID = n, I.DEBUG = l, I.DISABLE_COOKIES = u, I.DURATION_LIVE = 1 / 0, I.ENV_KEY = p, I.LOCAL_STORAGE_SALT_KEY = h, I.LOCAL_STORAGE_VIEWER_USER_ID_KEY = x, I.PLAYER_NAME = y, I.PLAYER_VERSION = j, I.RESPECT_DO_NOT_TRACK = S, I.SALT_LENGTH = _, I.SALT_TIME_TO_LIVE = k, I.STREAM_TYPE_LIVE = "live", I.STREAM_TYPE_ON_DEMAND = "on-demand", I.VIEWER_USER_ID_LENGTH = T;
				const P = Object(s.forwardRef)((e, t) => o.a.createElement(I, C({}, e, {
						forwardedRef: t
					}))),
					M = Object(i.c)({
						redditUserId: b.g,
						isMuxEnabled: m
					});
				return Object(r.b)(M, null, null, {
					forwardRef: !0
				})(P)
			}
		},
		"./src/lib/CSSVariableProvider/withTheme.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/CSSVariableProvider/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function a(e) {
				return t => o.a.createElement(r.b.Consumer, null, n => o.a.createElement(e, i({
					theme: n
				}, t)))
			}
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/bignumber.js/bignumber.js");

			function o(e, t) {
				const n = new s.BigNumber(e),
					o = new s.BigNumber(t),
					r = new s.BigNumber(n.dividedBy(o)),
					i = new s.BigNumber("100").multipliedBy(r);
				return new s.BigNumber(i).toNumber()
			}
		},
		"./src/lib/convertToCamelCase/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = e => {
				const t = {};
				for (const n in e) {
					t[n.replace(/_\w/g, e => e[1].toUpperCase())] = e[n]
				}
				return t
			}
		},
		"./src/lib/forEachGroup/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const s = e => e;

			function o(e, t, n) {
				const [o, r] = Array.isArray(e) ? [e.length, t => e[t]] : [e.size, t => e.get(t)], {
					keyFn: i = s
				} = t || {};
				let {
					start: a = 0,
					end: c = o
				} = t || {};
				if ((a = a < 0 ? 0 : a) >= (c = c > o ? o : c)) return;
				let l = r(a),
					d = i(l, a),
					u = a;
				for (let s = a + 1; s < c; s++) {
					const e = r(s),
						t = i(e, s);
					if (t !== d) {
						if (!1 === n(l, d, u, s)) return;
						d = t, u = s, l = e
					}
				}
				n(l, d, u, c)
			}
		},
		"./src/lib/getShortenedLink.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var s = n("./src/reddit/models/Media/index.ts"),
				o = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n.n(o);
			t.a = function(e) {
				const {
					source: t,
					isSponsored: n,
					domainOverride: o
				} = e;
				let i = "";
				if (n) {
					if (t && t.displayText) return t.displayText.length > 30 ? t.displayText.substring(0, 30) + "..." : t.displayText;
					i = o || Object(s.E)(e)
				} else i = Object(s.E)(e);
				const a = r.a.parse(i),
					c = a.path || "",
					l = c.length > 7 ? c.substring(0, 7) + "..." : c;
				return (a.hostname ? a.hostname.replace("www.", "") : "") + l
			}
		},
		"./src/lib/humanizeDateTime/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			const s = 9999999999;

			function o(e) {
				return e > s ? new Date(e).toString() : new Date(1e3 * e).toString()
			}
		},
		"./src/lib/humanizeUTCDate/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			t.a = e => {
				return new Date(1e3 * e).toUTCString().replace("GMT", "UTC")
			}
		},
		"./src/lib/intersectionObserver/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			let s;
			const o = new Map,
				r = new Map;
			"undefined" != typeof window && (n("./node_modules/intersection-observer/intersection-observer.js"), s = new IntersectionObserver(e => {
				e.forEach(e => {
					const t = e.target,
						n = e.intersectionRatio > 0;
					if (n !== !!r.get(t)) {
						r.set(t, n);
						const s = o.get(t);
						if (s) {
							s(e, n && !!r.get(t))
						}
					}
				})
			}, {
				threshold: [.001]
			}));
			const i = (e, t) => {
					try {
						o.set(e, t), s && s.observe(e)
					} catch (n) {
						0
					}
				},
				a = e => {
					try {
						o.delete(e), s && s.unobserve(e)
					} catch (t) {
						0
					}
				}
		},
		"./src/lib/lessComponent.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
					}
					return n
				};
			const a = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noindex", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "webview", "svg", "animate", "animateMotion", "animateTransform", "circle", "clipPath", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "switch", "symbol", "text", "textPath", "tspan", "use", "view"],
				c = (e, t, n) => {
					const s = n[t];
					class a extends o.a.PureComponent {
						render() {
							const t = this.props,
								{
									className: n,
									innerRef: a
								} = t,
								c = i(t, ["className", "innerRef"]);
							return o.a.createElement(e, Object.assign(Object.assign({}, c), {
								ref: a,
								className: Object(r.a)(s, n)
							}))
						}
					}
					return a.cssClassName = s, a.displayName = t, a
				},
				l = {};
			for (const d of a) l[d] = (e, t) => c(d, e, t);
			t.a = Object.assign(Object.assign({}, l), {
				wrapped: (e, t, n) => {
					const s = n[t];
					class a extends o.a.PureComponent {
						render() {
							const t = this.props,
								{
									className: n
								} = t,
								a = i(t, ["className"]);
							return o.a.createElement(e, Object.assign(Object.assign({}, a), {
								className: Object(r.a)(s, n)
							}))
						}
					}
					return a.cssClassName = s, a.displayName = t, a
				}
			})
		},
		"./src/lib/linkMatchers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "h", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./node_modules/linkify-it/index.js"),
				o = n.n(s),
				r = n("./node_modules/tlds/index.js"),
				i = n.n(r),
				a = n("./src/lib/linkMatchers/customLinks.ts"),
				c = n("./node_modules/lodash/values.js"),
				l = n.n(c);
			const d = e => l()(a.b).includes(e.substring(1)),
				u = ["//", "ftp:", "http:", "https:", "mailto:"],
				p = e => ((e, t) => (t.forEach(t => e.add(t, null)), e))(e, u),
				m = o()().tlds(i.a).set({
					fuzzyIP: !0
				}),
				h = o()().set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.mention.prefix, a.g.mention.config),
				b = p(o()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config),
				f = p(o()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config),
				g = o()().tlds(i.a).set({
					fuzzyIP: !0
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config).add(a.g.mention.prefix, a.g.mention.config),
				x = m.normalize;
			m.normalize = e => {
				x.call(m, e), !e.schema && e.url.startsWith("http:") && (e.url = "https:".concat(e.url.slice(5)))
			};
			const y = (e, t) => {
					return (g.match(e) || []).filter(e => {
						const n = d(e.text);
						return !n || n && t
					})
				},
				v = e => {
					return [...f.match(e) || [], ...h.match(e) || []].map(e => !d(e.text) && e.text.replace(a.a, "")).filter(e => e)
				},
				C = (e, t) => {
					const n = e.match(t);
					if (n && 1 === n.length && 0 === n[0].index && n[0].lastIndex === t.length) return n[0]
				},
				E = e => {
					const t = m.match(e);
					if (t && 1 === t.length && 0 === t[0].index) {
						const n = t[0];
						return n.lastIndex === e.length ? n : ((e, t) => {
							const n = e.substring(t.lastIndex);
							if (/.*\/\/.*\/.*/.test(t.url) && /^(\?|\!)+$/.test(n)) return t.lastIndex += n.length, t.url += n, t
						})(e, n)
					}
				}
		},
		"./src/lib/memoizeByReference/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/lodash/every.js"),
				o = n.n(s);

			function r(e) {
				let t = null,
					n = null;
				return function() {
					for (var s = arguments.length, r = new Array(s), i = 0; i < s; i++) r[i] = arguments[i];
					return null !== t && r.length === t.length && o()(r, (e, n) => e === t[n]) || (t = r, n = e(...r)), n
				}
			}
		},
		"./src/lib/onFocusAndVisibilityChange/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/brcast/dist/brcast.es.js");
			const o = () => "undefined" != typeof document,
				r = () => o() && "visible" === document.visibilityState,
				i = () => ({
					documentInFocus: r()
				}),
				{
					subscribe: a,
					unsubscribe: c,
					setState: l
				} = Object(s.a)(i()),
				d = {
					hidden: "visibilitychange",
					webkitHidden: "webkitvisibilitychange",
					mozHidden: "mozvisibilitychange",
					msHidden: "msvisibilitychange"
				},
				u = () => l(i());
			(() => {
				const e = (() => {
					if (!o()) return;
					const e = Object.keys(d).find(e => e in document);
					return e ? d[e] : void 0
				})();
				e && document.addEventListener(e, u)
			})(), t.a = {
				isDocumentHidden: () => !r(),
				isDocumentVisible: r,
				subscribe: a,
				unsubscribe: c
			}
		},
		"./src/lib/timeUntil/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/constants/index.ts");
			const r = [o.ac, o.fb, o.x, o.J, o.eb, o.Fb],
				i = {
					[o.Fb]: e => s.fbt._({
						"*": "{number} seconds",
						_1: "1 second"
					}, [s.fbt._plural(e, "number")], {
						hk: "3pTp9Z"
					}),
					[o.eb]: e => s.fbt._({
						"*": "{number} minutes",
						_1: "1 minute"
					}, [s.fbt._plural(e, "number")], {
						hk: "2gB3sf"
					}),
					[o.J]: e => s.fbt._({
						"*": "{number} hours",
						_1: "1 hour"
					}, [s.fbt._plural(e, "number")], {
						hk: "2w4n8B"
					}),
					[o.x]: e => s.fbt._({
						"*": "{number} days",
						_1: "1 day"
					}, [s.fbt._plural(e, "number")], {
						hk: "3zIGRH"
					}),
					[o.fb]: e => s.fbt._({
						"*": "{number} months",
						_1: "1 month"
					}, [s.fbt._plural(e, "number")], {
						hk: "28DQqD"
					}),
					[o.ac]: e => s.fbt._({
						"*": "{number} years",
						_1: "1 year"
					}, [s.fbt._plural(e, "number")], {
						hk: "Gqzh3"
					})
				},
				a = {
					[o.Fb]: e => s.fbt._("{amount}s", [s.fbt._param("amount", String(e))], {
						hk: "F4qog"
					}),
					[o.eb]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "43tM5H"
					}),
					[o.J]: e => s.fbt._("{amount}h", [s.fbt._param("amount", String(e))], {
						hk: "19NsxU"
					}),
					[o.x]: e => s.fbt._("{amount}d", [s.fbt._param("amount", String(e))], {
						hk: "39MDc9"
					})
				};

			function c(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				const n = Date.now(),
					c = new Date(e).getTime(),
					l = {
						[o.ac]: "",
						[o.fb]: "",
						[o.x]: "",
						[o.J]: "",
						[o.eb]: "",
						[o.Fb]: ""
					};
				let d = c - n;
				if (d <= 0) return s.fbt._("a moment", null, {
					hk: "3QLaye"
				}).toString();
				for (const s of r) {
					const e = Math.floor(d / s);
					e && (l[s] = (t ? a : i)[s](e).toString()), d -= e * s
				}
				const u = r.map(e => l[e]).filter(Boolean).slice(0, 2).join(" ");
				return t ? u : s.fbt._("{amount of time left} left", [s.fbt._param("amount of time left", u)], {
					hk: "7VjAI"
				}).toString()
			}
		},
		"./src/reddit/actions/economics/me/thunkedActions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeRequest/index.ts"),
				r = n("./src/config.ts"),
				i = n("./src/reddit/endpoints/governance/requester.ts");
			var a = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/economics/me/constants.ts");
			const l = Object(a.a)(c.a),
				d = Object(a.a)(c.b),
				u = Object(a.a)(c.c),
				p = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = e && e.includeMemberships || !1,
						c = e && e.forceFetch || !1,
						d = n();
					if (!d.economics.me.fetched || a && !d.economics.me.data.specialMemberships || c) {
						const e = await
						function(e, t) {
							return Object(i.a)(e, {
								method: "get",
								endpoint: "".concat(r.a.metaUrl, "/users/me").concat(t ? "?fields=specialMemberships" : "")
							})
						}(o(), a);
						if (e.ok) {
							const n = e.body;
							a && !n.specialMemberships && (n.specialMemberships = {}), t(l(n))
						}
					}
				}, m = () => async (e, t) => {
					const n = t(),
						r = n.economics.me.data;
					if (!r) throw new Error("me data required for copy to be fetched");
					if (!n.economics.pointsCopy.fetched) {
						e(d());
						const t = "https://".concat(r.pointsDocsBaseUrl, "v1.json?web"),
							n = await Object(o.b)({
								endpoint: t,
								method: s.db.GET
							});
						n.ok && n.body && e(u(n.body))
					}
				}
		},
		"./src/reddit/actions/economics/subredditPremium/actionCreators.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "j", (function() {
				return h
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/economics/subredditPremium/constants.ts");
			const r = Object(s.a)(o.a),
				i = Object(s.a)(o.b),
				a = Object(s.a)(o.c),
				c = Object(s.a)(o.d),
				l = Object(s.a)(o.e),
				d = Object(s.a)(o.f),
				u = (Object(s.a)(o.g), Object(s.a)(o.h)),
				p = Object(s.a)(o.i),
				m = Object(s.a)(o.j),
				h = Object(s.a)(o.k)
		},
		"./src/reddit/actions/economics/subredditPremium/thunkedActions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "b", (function() {
				return w
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "c", (function() {
				return k
			})), n.d(t, "f", (function() {
				return T
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/forOwn.js"),
				o = n.n(s),
				r = n("./src/reddit/actions/governance/errorToast.ts"),
				i = n("./src/reddit/endpoints/economics/emojis.ts"),
				a = n("./src/reddit/endpoints/economics/specialMembership.ts"),
				c = n("./src/reddit/endpoints/economics/subredditPremium.ts"),
				l = n("./src/reddit/endpoints/governance/badges.ts"),
				d = n("./src/config.ts"),
				u = n("./src/reddit/endpoints/governance/requester.ts");

			function p(e, t, n) {
				return Object(u.a)(e, {
					method: "get",
					endpoint: "".concat(d.a.metaUrl, "/products/").concat(t, "?owners=").concat(n) + "&types=emotes_pack,giphy"
				})
			}
			var m = n("./src/reddit/models/Badge/index.ts"),
				h = n("./src/reddit/models/Badge/managementPage.ts"),
				b = n("./src/reddit/models/Product/index.ts"),
				f = n("./src/reddit/reducers/economics/subredditPremium/index.ts"),
				g = n("./src/reddit/selectors/economics.ts"),
				x = n("./src/reddit/selectors/products.ts"),
				y = n("./src/reddit/actions/economics/me/thunkedActions.ts"),
				v = n("./src/reddit/actions/economics/subredditPremium/actionCreators.ts");

			function C(e) {
				return !!e && "removeBadge" === e.type
			}

			function E(e) {
				if (!C(e)) return e
			}
			const O = () => async (e, t, n) => {
				let {
					apiContext: s
				} = n;
				if (!t().user.account) return;
				await e(Object(y.b)({
					includeMemberships: !0
				}));
				const o = t().economics.me.data.specialMemberships || {},
					r = Object.keys(o);
				if (r.length) {
					const t = await Object(a.e)(s(), r);
					t.ok && e(Object(v.g)(t.body))
				}
			}, j = (e, t) => async (n, s, o) => {
				let {
					apiContext: r
				} = o;
				const i = s().user.account,
					a = s().economics.subredditPremium[e],
					l = !a || a.status !== f.a.Fetched || t;
				if (i && l) {
					const t = await Object(c.a)(r(), e, i.id);
					n(Object(v.i)(t))
				}
			}, w = e => async (t, n, s) => {
				let {
					apiContext: o
				} = s;
				const i = n(),
					a = i.user.account,
					c = Object(g.f)(i, e.subredditId),
					d = Object.keys(c).map(e => c[e]).filter(Boolean);
				if (a && e.badge) {
					let n, s;
					n = e.placement === m.a.First ? c[h.a.Loyalty] : e.placement === m.a.Second ? c[h.a.Achievement] : c[h.a.Cosmetic], t(Object(v.a)(Object.assign(Object.assign({}, e), {
						badge: E(e.badge),
						currentAppliedBadges: d,
						userId: a.id
					}))), C(e.badge) && n ? s = await Object(l.a)(o(), e.subredditId, n.id, !1) : C(e.badge) || (s = await Object(l.a)(o(), e.subredditId, e.badge.id)), s && !s.ok && (t(Object(v.a)(Object.assign(Object.assign({}, e), {
						badge: n,
						currentAppliedBadges: d,
						userId: a.id
					}))), Object(r.a)(t, s.error))
				}
			}, S = (e, t) => async (n, s, o) => {
				let {
					apiContext: r
				} = o;
				await n(j(e, !0));
				const i = s().economics.subredditPremium[e];
				if (i && i.status === f.a.Fetched) {
					const s = i.data.userOwnedBadges.find(e => e.type === t.id);
					s && (n(w({
						badge: s,
						subredditId: e,
						placement: s.placement
					})), n(Object(v.d)(h.c.MyBadges)))
				}
			}, _ = e => async (t, n, s) => {
				let {
					apiContext: a
				} = s;
				const c = n().user.account,
					l = !n().economics.emotes[e],
					d = !n().economics.gifs[e];
				if (c && (l || d)) {
					const [n, s] = await Promise.all([Object(i.b)(a(), e), p(a(), e, c.id)]);
					if (!s.ok) return void Object(r.a)(t, s.error);
					const l = {
						emotes: [],
						emoteCollections: n.ok ? n.body : {},
						giphy: []
					};
					o()(s.body, e => {
						e.type === b.a.EmotesPack ? l.emotes.push(e) : e.type === b.a.Giphy && l.giphy.push(e)
					}), t(Object(v.e)({
						subredditId: e,
						products: l
					}))
				}
			}, k = (e, t, n) => async (s, o, r) => {
				let {
					apiContext: i
				} = r;
				if (await s(j(e, !0)), n && t) {
					const n = o(),
						r = Object(g.f)(n, e),
						i = Object(x.a)(n, t);
					if (!r[Object(h.d)(i.placement)] && i) {
						const t = Object(g.m)(n, {
							subredditId: e,
							badge: i
						});
						t && await s(w({
							badge: t,
							subredditId: e
						}))
					}
					s(Object(v.c)({
						subredditId: e,
						initialView: h.c.MyBadges
					}))
				}
			}, T = e => async (t, n, s) => {
				let {
					apiContext: o
				} = s;
				const {
					wallet: r
				} = await Object(a.c)(o(), e);
				t(Object(v.f)({
					wallet: r
				})), await t(j(e.subredditId, !0))
			}
		},
		"./src/reddit/actions/gold/giveAward.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/modal.ts"),
				r = n("./src/reddit/constants/modals.ts"),
				i = n("./src/reddit/actions/gold/constants.ts");
			const a = Object(s.a)(i.hb),
				c = Object(s.a)(i.u),
				l = e => async t => {
					await t(c({
						id: e
					})), t(Object(o.h)(r.a.GOLD_GILD_ANIMATION_OVERLAY))
				}
		},
		"./src/reddit/actions/gold/reportAward.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/models/Toast/index.ts"),
				a = n("./src/reddit/endpoints/gold/communityAwards.ts"),
				c = n("./src/reddit/actions/gold/constants.ts");
			const l = Object(o.a)(c.gb),
				d = e => async (t, n, o) => {
					let {
						apiContext: c
					} = o;
					t(l());
					const d = s.fbt._("Something went wrong. The report could not be created at this time.", null, {
						hk: "1ewigu"
					});
					try {
						(await Object(a.e)(c(), e)).error && t(Object(r.e)({
							kind: i.b.Error,
							duration: r.a,
							text: d
						}))
					} catch (u) {
						t(Object(r.e)({
							kind: i.b.Error,
							duration: r.a,
							text: d
						}))
					}
				}
		},
		"./src/reddit/actions/gold/topAwarded.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "b", (function() {
				return g
			}));
			var s = n("./src/lib/env/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/constants/modals.ts"),
				a = (n("./src/graphql/operations/TopAwardedPosts.json"), n("./src/graphql/operations/TopAwardersLeaderboard.json")),
				c = n("./src/lib/makeGqlRequest/index.ts");
			const l = (e, t) => Object(c.a)(e, Object.assign(Object.assign({}, a), {
				variables: t
			}));
			var d = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/gold/constants.ts");
			Object(o.a)(u.ob), Object(o.a)(u.nb), Object(o.a)(u.mb);
			const p = Object(o.a)(u.rb),
				m = Object(o.a)(u.qb),
				h = Object(o.a)(u.pb),
				b = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 25;
					return async (n, o, i) => {
						let {
							gqlContext: a
						} = i;
						if (!o().users.topAwarders.list.length) {
							n(p());
							try {
								const s = await l(a(), {
										top: t,
										postId: e
									}),
									o = s.body;
								if (s.ok) await n(m(Object.assign({
									postId: e
								}, o.data.postInfoById.topAwarders)));
								else if (o.errors && o.errors.length) throw new Error(o.errors.map(e => e.message).join("; "))
							} catch (c) {
								Object(s.b)() || console.error(c), r.c.captureMessage(c), n(h(c.message))
							}
						}
					}
				},
				f = Object(o.a)(u.sb),
				g = e => async (t, n) => {
					t(f({
						postId: e
					})), t(Object(d.h)(i.a.ECON_TOP_AWARDERS))
				}
		},
		"./src/reddit/actions/governance/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "g", (function() {
				return N
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "h", (function() {
				return A
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/post.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/governance/poll.ts"),
				d = n("./src/config.ts"),
				u = n("./src/reddit/endpoints/governance/requester.ts");
			var p = n("./src/reddit/endpoints/governance/wallet.ts"),
				m = n("./src/reddit/models/Poll/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/models/Vote/index.ts"),
				f = n("./src/reddit/selectors/gov.ts"),
				g = n("./src/reddit/actions/governance/constants.ts"),
				x = n("./src/reddit/actions/governance/errorToast.ts");
			const y = Object(o.a)(g.b),
				v = Object(o.a)(g.c),
				C = Object(o.a)(g.e),
				E = (Object(o.a)(g.f), Object(o.a)(g.g), Object(o.a)(g.h)),
				O = Object(o.a)(g.i),
				j = Object(o.a)(g.j),
				w = Object(o.a)(g.k),
				S = Object(o.a)(g.q),
				_ = Object(o.a)(g.r),
				k = Object(o.a)(g.s),
				T = Object(o.a)(g.t),
				I = Object(o.a)(g.u),
				P = Object(o.a)(g.v),
				M = Object(o.a)(g.w),
				N = Object(o.a)(g.x),
				R = (e, t) => async (n, s, o) => {
					let r, {
							apiContext: i,
							gqlContext: c
						} = o,
						d = s().polls.models[e];
					if (n(j({
							pollId: e
						})), (r = d.type === m.a.GA ? await Object(l.c)(c(), e, t) : await Object(l.b)(i(), d.subredditId, e, t)).ok) {
						if (d.type === m.a.GA) {
							const {
								options: e
							} = r.body.data.updatePostPollVoteState.poll;
							n(C({
								pollId: d.id,
								optionId: t,
								options: e
							}))
						} else n(w(r.body));
						const o = s();
						if ((d = o.polls.models[e]) && Object(m.d)(d)) {
							const {
								postId: e
							} = d, t = o.posts.models[e];
							t && t.voteState === b.a.notVoted && n(Object(a.S)(e))
						}
					} else n(O({
						pollId: e,
						error: r.error || r.errors[0].message
					})), Object(x.a)(n, r.error || r.errors[0].messsage)
				}, L = (e, t) => async (n, o, a) => {
					let {
						apiContext: l
					} = a;
					n(k());
					const p = o().transfers.communityPoints.contentId || void 0,
						m = await
					function(e, t) {
						return Object(u.a)(e, {
							data: {
								amount: t.amount,
								contentId: t.contentId,
								description: t.message,
								receiveUserName: t.recipient
							},
							endpoint: "".concat(d.a.metaUrl, "/wallets/me/").concat(t.subredditId, "/transfers"),
							method: "post"
						})
					}(l(), Object.assign(Object.assign({}, e), {
						contentId: p
					}));
					m.ok ? (n(T(Object.assign(Object.assign({}, m.body), {
						subredditId: e.subredditId
					}))), n(Object(c.e)({
						kind: h.b.SuccessCommunity,
						text: s.fbt._("Success! You just transferred {amount} {tokenName} to {recipient}", [s.fbt._param("amount", Object(r.a)(e.amount)), s.fbt._param("tokenName", Object(f.q)(o(), {
							subredditId: e.subredditId
						})), s.fbt._param("recipient", e.recipient)], {
							hk: "3klrhq"
						})
					})), t && n(Object(i.f)())) : (n(S({
						error: m.error
					})), Object(x.a)(n, m.error))
				}, A = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					t(P());
					const r = await Object(p.a)(o(), e);
					r.ok ? t(M(r.body)) : t(I({
						error: r.error
					}))
				}
		},
		"./src/reddit/actions/postCollection/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return N
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "c", (function() {
				return H
			})), n.d(t, "h", (function() {
				return q
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return se
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/filterQueryParams/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/postCollection/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/history.ts"),
				d = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			var h = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/collections/add_post_to_collection.json"),
				method: d.db.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var b = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/collections/create_collection.json"),
				method: d.db.POST,
				data: {
					title: t,
					sr_fullname: n
				}
			});
			var f = (e, t) => Object(u.a)(Object(p.a)(e, [m.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/collections/delete_collection.json"),
					method: d.db.POST,
					data: {
						collection_id: t
					}
				}),
				g = n("./src/config.ts");
			var x = (e, t) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(g.a.gatewayUrl, "/desktopapi/v1/subreddit_collections/").concat(t),
				method: d.db.GET
			});
			var y = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/collections/remove_post_in_collection.json"),
				method: d.db.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var v = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/collections/update_collection_title.json"),
				method: d.db.POST,
				data: {
					collection_id: t,
					title: n
				}
			});
			var C = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/collections/reorder_collection.json"),
				method: d.db.POST,
				data: {
					collection_id: t,
					link_ids: n.join(",")
				}
			});
			var E = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
				endpoint: "".concat(e.apiUrl, "/api/v1/collections/update_collection_description.json"),
				method: d.db.POST,
				data: {
					collection_id: t,
					description: n
				}
			});
			var O = (e, t, n) => Object(u.a)(Object(p.a)(e, [m.a]), {
					endpoint: "".concat(e.apiUrl, "/api/v1/collections/update_collection_display_layout.json"),
					method: d.db.POST,
					data: {
						collection_id: t,
						display_layout: n
					}
				}),
				j = n("./src/reddit/helpers/overlay/index.ts"),
				w = n("./src/reddit/helpers/path/index.ts"),
				S = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/postCollection.ts"),
				k = n("./src/reddit/selectors/posts.ts"),
				T = n("./src/reddit/selectors/subreddit.ts");
			const I = Object(i.a)(a.c),
				P = Object(i.a)(a.b),
				M = Object(i.a)(a.d),
				N = (e, t) => async (n, s, o) => {
					let {
						apiContext: r
					} = o;
					n(I());
					const i = await b(r(), e, t);
					let a;
					if (i.ok) {
						const e = s().meta,
							t = (e => ({
								author: e.author_name || void 0,
								createdAtUTC: e.created_at_utc,
								description: e.description,
								displayLayout: e.display_layout,
								id: e.collection_id,
								lastUpdateUTC: e.last_update_utc,
								permalink: e.permalink,
								postIds: e.link_ids,
								primaryPostId: e.primary_link_id || void 0,
								subredditId: e.subreddit_id,
								title: e.title
							}))(i.body);
						n(M({
							collection: t,
							meta: e
						})), a = t
					} else {
						const e = i.error;
						n(P(e))
					}
					return a
				}, R = Object(i.a)(a.f), L = e => async (t, n, o) => {
					let {
						apiContext: r
					} = o;
					const i = n().postCollection.subredditToIds || {};
					if (Object.keys(i).length > 0) return;
					const a = await x(r(), e);
					a.ok ? t(R(a.body)) : t(Object(c.e)({
						kind: S.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, A = Object(i.a)(a.g), F = (e, t, n) => async (o, r, i) => {
					let {
						apiContext: a
					} = i;
					if ((await y(a(), e, t)).ok) {
						const i = r(),
							a = Object(k.N)(i, {
								postId: t
							}),
							l = a && a.title || "",
							d = Object(_.r)(i, {
								collectionId: e
							}),
							u = (d && d.postIds && d.postIds.indexOf(t) || -1) - 1;
						if (o(A({
								collectionId: e,
								postId: t
							})), n && u >= 0) {
							const t = r(),
								n = Object(_.r)(t, {
									collectionId: e
								}),
								s = n && n.postIds && n.postIds[u] || "",
								i = Object(k.N)(t, {
									postId: s
								});
							i && i.permalink && o(Object(j.a)(i.permalink))
						}
						o(Object(c.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Following post removed from collection successfully: {postTitle}", [s.fbt._param("postTitle", l)], {
								hk: "8e1lV"
							}),
							buttonText: s.fbt._("UNDO", null, {
								hk: "3KPLib"
							}),
							buttonAction: U(e, t)
						}))
					} else o(Object(c.e)({
						kind: S.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, D = Object(i.a)(a.a), B = Object(i.a)(a.t), U = (e, t) => async (n, o, r) => {
					let {
						apiContext: i
					} = r;
					const a = o();
					if ((await h(i(), e, t)).ok) {
						n(D({
							collectionId: e,
							postId: t
						})), n(B({
							collectionId: e,
							postId: t
						}));
						const o = Object(k.N)(a, {
								postId: t
							}),
							r = Object(_.r)(a, {
								collectionId: e
							}),
							i = r && r.title || "";
						n(Object(c.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Success! You added a post to the collection: {title}", [s.fbt._param("title", i)], {
								hk: "3KNJWi"
							}),
							buttonText: s.fbt._("VIEW", null, {
								hk: "1SSkgL"
							}),
							buttonAction: Object(j.a)(o.permalink)
						}))
					} else n(Object(c.e)({
						kind: S.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, K = Object(i.a)(a.e), H = (e, t) => async (n, i, a) => {
					let {
						apiContext: l
					} = a;
					const d = i();
					if ((await f(l(), e)).ok) {
						const {
							url: i
						} = d.platform.currentPage, a = Object(_.r)(d, {
							collectionId: e
						}), l = a && a.title || "", u = a && a.subredditId, p = u ? Object(T.c)(d, u) : "/";
						n(K({
							collectionId: e,
							collection: a
						})), n(t ? Object(o.c)(Object(r.a)(i, ["collection"])) : Object(o.b)(p)), n(Object(c.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Collection deleted successfully: {title}", [s.fbt._param("title", l)], {
								hk: "4tcOKB"
							})
						}))
					} else n(Object(c.e)({
						kind: S.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, V = Object(i.a)(a.r), W = Object(i.a)(a.n), z = Object(i.a)(a.s), q = (e, t) => async (n, o, r) => {
					let {
						apiContext: i
					} = r;
					n(V());
					const a = await v(i(), e, t);
					let l = !1;
					if (a.ok) n(z({
						collectionId: e,
						newTitle: t
					})), n(Object(c.e)({
						kind: S.b.SuccessMod,
						text: s.fbt._("Collection title updated successfully", null, {
							hk: "2hKzKl"
						})
					})), l = !0;
					else {
						const e = a.error;
						n(W(e)), n(Object(c.e)({
							kind: S.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))
					}
					return l
				}, G = Object(i.a)(a.l), J = Object(i.a)(a.m), Q = Object(i.a)(a.k), Z = e => async (t, n) => {
					const s = n().platform.currentPage.locationState;
					t(!(!s || !s[l.a.IsOverlay]) ? Object(j.a)(e.permalink) : Object(o.b)(Object(w.b)(e.permalink)))
				}, Y = Object(i.a)(a.i), X = Object(i.a)(a.j), $ = Object(i.a)(a.h), ee = Object(i.a)(a.p), te = Object(i.a)(a.o), ne = Object(i.a)(a.q), se = e => async t => {
					const n = [],
						{
							collectionId: o,
							description: r,
							displayLayout: i,
							postIds: a,
							title: l
						} = e;
					a && n.push(t(((e, t) => async (n, o, r) => {
						let {
							apiContext: i
						} = r;
						n(Y());
						const a = await C(i(), e, t);
						let l = !1;
						return a.ok ? (n(X({
							collectionId: e,
							postIds: t
						})), n(Object(c.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Collection order updated successfully", null, {
								hk: "4ccHEL"
							})
						})), l = !0) : (n($({
							error: a.error
						})), n(Object(c.e)({
							kind: S.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))), l
					})(o, a))), l && n.push(t(q(o, l))), void 0 !== r && n.push(t(((e, t) => async (n, o, r) => {
						let {
							apiContext: i
						} = r;
						n(G());
						const a = await E(i(), e, t);
						let l = !1;
						if (a.ok) n(J({
							collectionId: e,
							newDescription: t
						})), n(Object(c.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Collection description updated successfully", null, {
								hk: "1rIDCC"
							})
						})), l = !0;
						else {
							const e = a.error;
							n(Q(e)), n(Object(c.e)({
								kind: S.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return l
					})(o, r))), i && n.push(t(((e, t) => async (n, o, r) => {
						let {
							apiContext: i
						} = r;
						n(ee());
						const a = await O(i(), e, t);
						let l = !1;
						if (a.ok) n(ne({
							collectionId: e,
							newLayout: t
						})), n(Object(c.e)({
							kind: S.b.SuccessMod,
							text: s.fbt._("Collection layout updated successfully", null, {
								hk: "1Rs19j"
							})
						})), l = !0;
						else {
							const e = a.error;
							n(te(e)), n(Object(c.e)({
								kind: S.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return l
					})(o, i)));
					let d = !0;
					return await Promise.all(n).then(e => {
						e.forEach(e => {
							e || (d = !1)
						})
					}), d
				}
		},
		"./src/reddit/actions/postCreation/mediaUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return N
			})), n.d(t, "b", (function() {
				return L
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "c", (function() {
				return D
			})), n.d(t, "e", (function() {
				return B
			})), n.d(t, "d", (function() {
				return U
			}));
			n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/uuid/v4.js"),
				r = n.n(o),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/formatApiError/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/actions/upload.ts"),
				u = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts");
			var b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/imagePreview/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				x = n("./src/reddit/models/Upload/index.ts"),
				y = n("./src/reddit/selectors/telemetry.ts"),
				v = n("./src/telemetry/index.ts");
			const C = async e => {
				let {
					state: t,
					uploadKey: n,
					assetId: s,
					isCanceled: o,
					fileSource: r,
					uploadDuration: i,
					correlationId: a
				} = e;
				const c = t.uploads[n],
					l = o || c.status === x.a.CANCELED,
					{
						file: d,
						url: u,
						metadata: p,
						error: m
					} = c,
					h = p.mimetype || d.type,
					b = h.startsWith("video/"),
					f = c.status === x.a.SUCCESS;
				let g = "";
				m ? g = JSON.stringify(m) : l && (g = "canceled");
				const C = {
					width: p.width,
					height: p.height,
					duration: p.videoDuration && Math.round(1e3 * p.videoDuration)
				};
				Object(v.a)(Object.assign(Object.assign({
					source: b ? "videoupload" : "imageupload",
					action: "upload",
					correlationId: a,
					noun: b ? "video" : "image"
				}, (e => Object.assign(Object.assign({}, y.defaults(e)), {
					screen: y.screen(e),
					profile: y.profile(e),
					subreddit: y.subreddit(e)
				}))(t)), {
					actionInfo: Object.assign(Object.assign(Object.assign({}, y.actionInfo(t)), {
						success: f
					}), g ? {
						reason: g
					} : {}),
					media: Object.assign(Object.assign(Object.assign({
						mimetype: h,
						uploadDuration: i,
						source: r,
						fileName: d.name,
						size: d.size,
						type: b ? "video" : "image"
					}, s ? {
						id: s
					} : {}), u ? {
						url: u
					} : {}), C)
				}))
			};
			var E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				O = n("./src/reddit/models/Gold/Powerups/index.ts"),
				j = n("./src/reddit/models/PostCreationForm/index.ts"),
				w = n("./src/reddit/models/Toast/index.ts"),
				S = n("./src/reddit/selectors/gold/powerups.ts"),
				_ = n("./src/reddit/selectors/postCreations.ts"),
				k = n("./src/reddit/actions/postCreation/constants.ts"),
				T = n("./src/reddit/actions/postCreation/general.ts");
			const I = Object(c.a)(k.x),
				P = Object(c.a)(k.y),
				M = Object(c.a)(k.w),
				N = e => async (t, n) => {
					t(I());
					const s = e.map(e => {
						let {
							url: n,
							uploadKey: s
						} = e;
						const o = Object(g.a)(Object(g.c)(n), "poster.png");
						return t(F(o, s))
					});
					await Promise.all(s);
					const o = n().uploads,
						r = e.map(e => {
							let {
								uploadKey: t
							} = e;
							return o[t]
						}).find(e => e.status !== x.a.SUCCESS);
					t(r ? M(r.error) : P())
				}, R = (e, t) => ({
					error: t ? {
						type: e,
						fields: [{
							field: "",
							msg: t
						}]
					} : {
						type: e
					}
				});
			const L = "RTE",
				A = "GALLERY",
				F = (e, t, n, o) => async (r, a, c) => {
					let {
						apiContext: l
					} = c;
					const u = Object(_.g)(a()),
						x = Date.now();
					let y = null,
						v = !1,
						j = !1,
						w = !1;
					const k = e => {
						if (!w && n && v) {
							w = !0;
							const s = a(),
								o = Date.now() - x,
								r = Object(b.c)(b.a.PostComposer);
							j ? C({
								state: s,
								uploadKey: t,
								assetId: y,
								isCanceled: e,
								fileSource: n,
								uploadDuration: o,
								correlationId: r
							}) : E.t(s, t)
						}
					};
					return await r(Object(d.l)(e, t, async c => {
						v = !0, Object(d.k)(c.id, () => {
							k(!0)
						});
						const {
							error: b,
							metadata: x
						} = await async function(e, t, n) {
							const o = n && n.allowedPostTypes,
								r = n && n.name,
								a = await Object(g.g)(t) || t.type,
								c = Object(g.b)(t) || void 0;
							if (!c) return R("UNSUPPORTED_BROWSER");
							const l = {
								localUrl: c,
								mimetype: a
							};
							if (!a || !Object(g.i)(a)) return {
								error: {
									type: i.M
								}
							};
							if (a.startsWith("image/")) {
								if (o && !o.images) {
									const e = s.fbt._("Images are not allowed in r/{subredditName}", [s.fbt._param("subredditName", r)], {
										hk: "3C2E7Q"
									});
									return R(i.M, e)
								}
								if ("image/gif" === a) {
									if (t.size > i.R) return R(i.H)
								} else if (t.size > i.T) return R(i.K);
								const e = await Object(f.a)(c);
								l.width = e.width, l.height = e.height
							} else if (a.startsWith("video/")) {
								const a = !(null == n || !n.id) && Object(S.h)(e, {
										subredditId: n.id,
										benefit: O.a.HdVideo
									}),
									u = a ? 2 * i.Y : i.Y;
								if (t.size > u) return R(i.Yb);
								let p;
								try {
									p = await Object(g.h)(c, !0)
								} catch (d) {
									return R(i.M)
								}
								if (o) {
									const {
										videos: e,
										images: t
									} = o;
									if (t && !e && p.duration > i.Z) {
										const e = s.fbt._("Sorry, r/{subredditName} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF.", [s.fbt._param("subredditName", r)], {
											hk: "46ULiz"
										});
										return R(i.M, e)
									}
									if (!t && !e) {
										const e = s.fbt._("Videos are not allowed in r/{subredditName}", [s.fbt._param("subredditName", r)], {
											hk: "4uTUZb"
										});
										return R(i.M, e)
									}
								}
								const m = a ? 2 * i.X : i.X;
								if (p.duration > m) {
									const e = s.fbt._("Video is too long. Maximum video length is {duration} minutes.", [s.fbt._param("duration", (m / 60).toString())], {
										hk: "20nB6Q"
									});
									return R(i.M, e)
								}
								l.height = p.height, l.width = p.width, l.videoDuration = p.duration, l.videoFirstFrameUrl = p.firstFrame.dataUrl
							}
							return {
								metadata: l
							}
						}(a(), e, u);
						if (b || !x) return {
							error: b
						};
						r(Object(d.m)({
							key: t,
							metadata: Object.assign({
								fileSource: n
							}, x)
						})), j = !0, o && o();
						const C = e.name,
							E = await (async (e, t, n) => Object(p.a)(Object(m.a)(e, [h.a]), {
								endpoint: "".concat(e.apiUrl, "/api/media/asset.json"),
								method: i.db.POST,
								data: {
									filepath: t,
									mimetype: n
								}
							}))(l(), C, x.mimetype);
						return E.ok ? (y = E.body.asset.asset_id, {
							uploadLease: E.body.args
						}) : {
							error: E.error || void 0
						}
					}, !0)), k(!1), a().uploads[t] || null
				}, D = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const r = n().uploads[e];
					r && !Object(x.c)(r) && await t(F(r.file, r.key, r.metadata.fileSource, void 0))
				}, B = (e, t, n) => async (o, i) => {
					const c = e.map((e, s) => new Promise(async s => {
							const i = Object(x.d)(n, r()().slice(-6));
							await o(F(e, i, t, () => s({
								uploadKey: i,
								isValid: !0
							}))), s({
								uploadKey: i,
								isValid: !1
							})
						})),
						d = await Promise.all(c),
						u = d.map(e => e.uploadKey);
					return o(function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
						return async (n, o) => {
							const {
								uploads: r
							} = o(), i = e.map(e => r[e]).filter(e => e.status === x.a.FAILED && !e.metadata.mimetype).map(e => e.error), c = i.length > t ? t - 1 : i.length, d = i.length - c;
							i.slice(0, c).forEach(e => n(Object(l.e)({
								duration: l.a,
								kind: w.b.Error,
								text: Object(a.a)(e)
							}))), d > 0 && n(Object(l.e)({
								duration: l.a,
								kind: w.b.Error,
								text: s.fbt._({
									"*": "Couldn't add {number} more files",
									_1: "Couldn't add 1 more file"
								}, [s.fbt._plural(d, "number")], {
									hk: "2fQwvl"
								})
							}))
						}
					}(u)), d.filter(e => e.isValid).map(e => e.uploadKey)
				}, U = (e, t) => async (n, o) => {
					const r = o(),
						i = Object(_.O)(r),
						{
							items: a
						} = i,
						c = !a.length && 1 === e.length,
						p = Object(_.G)(r) && !c;
					let m = !1,
						h = e;
					if (p) {
						if (Object(j.v)(i)) return void n(Object(l.e)({
							kind: w.b.Error,
							text: s.fbt._("Please remove the existing video first. Videos aren't supported within galleries yet.", null, {
								hk: "3lGxp4"
							})
						}));
						h.some(e => Object(g.l)(e.type)) && n(Object(l.e)({
							kind: w.b.Error,
							text: s.fbt._("Videos aren’t supported within galleries...yet", null, {
								hk: "9Cl20"
							})
						})), h = h.filter(e => Object(g.k)(e.type));
						const e = Math.max(0, u.b - a.length);
						h.length > e && (n(Object(l.e)({
							kind: w.b.Error,
							text: s.fbt._("You have hit the limit of {images_limit} images", [s.fbt._param("images_limit", "".concat(u.b))], {
								hk: "6M4kX"
							})
						})), h = h.slice(0, e))
					} else h = h.slice(0, 1), m = !0, n(Object(d.j)(A, !0));
					const b = await n(B(h, t, A));
					if (!b.length) return;
					const f = b.map(e => ({
							uploadKey: e,
							caption: "",
							url: ""
						})),
						x = 0 === a.length;
					n(Object(T.d)(Object.assign(Object.assign({}, i), {
						items: m ? f : [...a, ...f],
						selectedKey: x ? b[0] : b[b.length - 1]
					})))
				}
		},
		"./src/reddit/actions/scheduledPosts/edit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/telemetry/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				p = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				m = n("./src/reddit/models/ScheduledPost/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/routes/postCreation/index.ts"),
				f = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const g = Object(i.a)(c.n),
				x = Object(i.a)(c.b),
				y = (e, t) => async (n, s, r) => {
					const i = Object(f.a)(s(), {
						scheduledPostId: t,
						subredditId: e
					});
					i && (await n(Object(o.b)(Object(b.c)(i.subreddit.name, i.collectionId))), n((Object(m.o)(i) ? x : g)(i)))
				}, v = (e, t) => {
					Object(m.o)(t) ? e(Object(a.d)({
						scheduledPost: t
					})) : e(Object(a.h)({
						scheduledPost: t
					}))
				}, C = (e, t, n) => async (o, i, b) => {
					let {
						gqlContext: g
					} = b;
					o(Object(a.g)());
					const x = Object(f.a)(i(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (x && Object(m.o)(x) && Object(r.a)(Object(p.z)()(i(), x)), !x) return void o(Object(a.f)({
						message: s.fbt._("Scheduled post not found", null, {
							hk: "2zjM55"
						})
					}));
					if (!Object.keys(n).length) return void v(o, x);
					const y = await Object(d.a)(g(), Object.assign(Object.assign({}, n), {
							id: t
						})),
						E = y.body;
					if (!(y.ok && E && E.data && E.data.updateScheduledPost && E.data.updateScheduledPost.ok && E.data.updateScheduledPost.scheduledPost)) return o(Object(a.f)({
						message: y.error && y.error.fields && y.error.fields.length && y.error.fields[0].msg || s.fbt._("Unknown error", null, {
							hk: "fXs5s"
						})
					})), void o(Object(l.e)(Object(l.d)(c.t(), h.b.Error, c.s(), C(e, t, n))));
					o(Object(l.e)(Object(l.d)(c.w(), h.b.SuccessCommunity))), v(o, Object(u.d)(E.data.updateScheduledPost.scheduledPost))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return y
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "i", (function() {
				return I
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "b", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./src/lib/assertNever.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				i = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				d = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				h = n("./src/telemetry/index.ts"),
				b = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
					}
					return n
				};
			const f = 25,
				g = 1e4,
				x = Object(o.a)(r.g),
				y = Object(o.a)(r.k),
				v = Object(o.a)(r.j),
				C = Object(o.a)(r.o),
				E = Object(o.a)(r.d),
				O = Object(o.a)(r.f),
				j = Object(o.a)(r.m),
				w = Object(o.a)(r.a),
				S = Object(o.a)(r.c),
				_ = Object(o.a)(r.e),
				k = Object(o.a)(r.h),
				T = (e, t) => {
					e(_()), e(Object(a.e)(Object(a.d)(r.r(), p.b.Error, r.s(), I(t))))
				},
				I = e => {
					var {
						subredditId: t,
						includeStandalone: n = {
							standaloneFirst: f
						},
						includeRecurring: s = {
							recurringFirst: g
						}
					} = e, o = b(e, ["subredditId", "includeStandalone", "includeRecurring"]);
					return async (e, r, i) => {
						let {
							gqlContext: a
						} = i;
						if (Object(m.h)(r(), {
								subredditId: t
							})) return;
						e(x());
						const d = Object.assign({
								subredditId: t,
								includeRecurring: s,
								includeStandalone: n
							}, o),
							u = await Object(c.b)(a(), d);
						Object(c.f)(u, d) ? M(e, Object(l.e)(u.body.data), d) : T(e, d)
					}
				},
				P = e => async (t, n, s) => {
					let {
						gqlContext: o
					} = s;
					const r = n();
					if (!Object(m.h)(r, {
							subredditId: e
						})) return t(I({
						subredditId: e
					}));
					if (!Object(m.g)(r, {
							subredditId: e,
							type: u.f.standalonePosts
						})) return;
					const i = Object(m.c)(r, {
						subredditId: e,
						type: u.f.standalonePosts
					});
					if (!i) return;
					t(x());
					const a = {
							subredditId: e,
							includeStandalone: {
								standaloneFirst: f,
								standaloneAfter: i
							}
						},
						d = await Object(c.b)(o(), a);
					d.ok ? M(t, Object(l.e)(d.body.data), a) : t(_())
				}, M = (e, t, n) => {
					Object(l.b)(t) ? e(O(t)) : Object(l.a)(t) ? e(w(t)) : Object(l.c)(t) ? e(j(t)) : T(e, n)
				}, N = (e, t) => async (n, o, r) => {
					const a = {},
						c = o();
					switch (e) {
						case "isModDistinguished":
						case "isNsfw":
						case "isOriginalContent":
						case "isContestMode":
						case "isSpoiler":
							a[e] = !t[e];
							break;
						case "isSticky":
							const n = !!t.sticky && "NONE" !== t.sticky;
							a.sticky = n ? "NONE" : "SECOND";
							break;
						default:
							return Object(s.a)(e)
					}
					Object(h.a)(Object(d.y)(e, a[e], Object(u.o)(t))(c)), n(Object(i.a)(t.subreddit.id, t.id, a))
				}
		},
		"./src/reddit/components/AdViewability/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				l = n("./src/lib/ads/index.ts"),
				d = n("./src/lib/ads/store.ts"),
				u = n("./src/lib/onFocusAndVisibilityChange/index.ts"),
				p = n("./src/reddit/connectors/PostViewable/index.ts"),
				m = n("./src/reddit/constants/viewabilityEvents.ts"),
				h = n("./src/reddit/selectors/media.ts"),
				b = n("./src/reddit/selectors/video.ts");
			const f = [{
					event: m.a.Viewable,
					threshold: l.k,
					viewabilityMinimum: l.l
				}, {
					event: m.a.Impression,
					threshold: l.b,
					viewabilityMinimum: l.c
				}, {
					event: m.a.VendorFullyViewable,
					threshold: l.a,
					viewabilityMinimum: l.e
				}, {
					event: m.a.GroupMViewable,
					threshold: l.a,
					viewabilityMinimum: l.l
				}, {
					event: m.a.VendorFullyViewableSeconds5,
					threshold: l.k,
					viewabilityMinimum: l.g,
					remainingTime: l.g,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}, {
					event: m.a.VendorFullyViewableSeconds15,
					threshold: l.k,
					viewabilityMinimum: l.f,
					remainingTime: l.f,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				g = [{
					event: m.a.VideoViewable,
					threshold: l.k,
					viewabilityMinimum: l.j,
					remainingTime: l.j,
					timeViewingInterrupted: 0
				}, {
					event: m.a.VideoFullyViewable,
					threshold: l.a,
					viewabilityMinimum: l.h,
					remainingTime: l.h,
					timeViewingInterrupted: 0
				}, {
					event: m.a.VideoGroupMViewable,
					threshold: void 0,
					viewabilityMinimum: l.j,
					remainingTime: l.j,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0,
					checkAudible: !0
				}, {
					event: m.a.VideoVendorFullyViewable50,
					threshold: l.a,
					viewabilityMinimum: void 0,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				x = e => e.map(e => {
					let {
						event: t,
						cumulative: n = !1,
						cumulativeElapsedTime: s,
						remainingTime: o,
						threshold: r = null,
						viewabilityMinimum: i,
						checkAudible: a = !1,
						timeViewingInterrupted: c
					} = e;
					return {
						event: t,
						cumulative: n,
						checkAudible: a,
						timer: null,
						fired: !1,
						threshold: r,
						remainingTime: o,
						cumulativeElapsedTime: 0,
						viewabilityMinimum: i,
						timeViewingInitialized: 0,
						timeViewingInterrupted: c
					}
				}),
				y = () => x(f),
				v = () => x(g),
				C = [l.b, l.d, l.k, l.i, l.a],
				E = [l.b, l.k, l.i, l.a],
				O = [l.b, l.d, l.k, l.a],
				j = e => "boolean" == typeof e.cumulative && e.cumulative,
				w = Object(a.c)({
					continuousViewingStartedAt: (e, t) => {
						let {
							post: n
						} = t;
						return Object(b.c)(e, {
							postId: n.id
						})
					},
					videoDuration: (e, t) => {
						let {
							post: n
						} = t;
						const s = Object(b.i)(e, {
							postId: n.id
						});
						if (s) return s.length
					},
					isAudible: e => !Object(h.c)(e) && !!Object(h.d)(e),
					isPlaying: (e, t) => {
						let {
							post: n
						} = t;
						return Object(b.e)(e, {
							postId: n.id
						})
					}
				}),
				S = Object(p.a)(w);
			class _ extends r.Component {
				constructor(e) {
					super(e), this.viewabilityStats = y(), this.videoStats = v(), this.pageInFocus = !0, this.inViewStats = [], this.outOfViewStats = [], this.handleViewabilityChange = e => {
						this.props.trackDisplay && this.handleThresholds(e, l.q), this.props.trackVideo && this.handleThresholds(e, l.o, !0), this.checkViewabilityByType(e)
					}, this.checkViewabilityByType = e => {
						o()(this.state.event, e) || this.setState({
							event: e
						}), this.props.trackDisplay && this.viewabilityStats.forEach(t => {
							this.checkViewability(e, t)
						}), this.props.isPlaying && this.props.trackVideo && this.videoStats.forEach(t => {
							t.checkAudible && !this.props.isAudible || this.checkViewability(e, t)
						})
					}, this.state = {
						event: null,
						currentContinuousViewingStartedAt: e.continuousViewingStartedAt
					}
				}
				componentDidMount() {
					this.visibilityChangeSubscriptionId = u.a.subscribe(e => {
						this.pageInFocus = e.documentInFocus, this.state.event && this.handleViewabilityChange(this.state.event)
					})
				}
				componentWillUnmount() {
					this.visibilityChangeSubscriptionId && u.a.unsubscribe(this.visibilityChangeSubscriptionId)
				}
				componentDidUpdate() {
					this.props.trackVideo && (this.state.currentContinuousViewingStartedAt === this.props.continuousViewingStartedAt ? (this.handleThresholds(this.state.event, l.o, !0), this.videoStats.forEach(e => {
						!this.props.isPlaying || e.checkAudible && !this.props.isAudible ? e.cumulative ? this.pauseCumulativeStats(e) : this.pauseViewableStats(e) : this.checkViewability(this.state.event, e)
					})) : this.resetTimers())
				}
				resetTimers() {
					this.videoStats.forEach(e => {
						e.cumulative || this.resetTimer(e)
					}), this.setState({
						currentContinuousViewingStartedAt: this.props.continuousViewingStartedAt
					})
				}
				resetTimer(e) {
					this.clearTimer(e), e.timeViewingInitialized = 0, void 0 !== e.viewabilityMinimum && (e.remainingTime = e.viewabilityMinimum)
				}
				pauseViewableStats(e) {
					let t;
					if (!e.timer || e.fired) return;
					e.timeViewingInterrupted = Date.now();
					const n = e.timeViewingInterrupted - e.timeViewingInitialized;
					t = (e.viewabilityMinimum || 0) - n, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e)
				}
				pauseCumulativeStats(e) {
					let t;
					e.timer && !e.fired && (e.timeViewingInterrupted = Date.now(), e.cumulativeElapsedTime += e.timeViewingInterrupted - e.timeViewingInitialized, t = (e.viewabilityMinimum || 0) - e.cumulativeElapsedTime, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e))
				}
				meetsViewabilityRequirements(e, t) {
					let n, s = !1,
						o = !1;
					return "object" == typeof t ? (n = t.threshold, s = !!t.playing, o = !!t.withSound) : n = t, this.isAdequatelyInView(e, n) && (!s || this.props.isPlaying) && (!o || this.props.isAudible)
				}
				handleThresholds(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const {
						post: s
					} = this.props, r = t.filter(t => this.meetsViewabilityRequirements(e, t));
					!o()(r, this.inViewStats) && r.length > 0 && d.b(s.id, r, n);
					const i = t.filter(t => !this.meetsViewabilityRequirements(e, t));
					!o()(i, this.outOfViewStats) && i.length > 0 && d.d(s.id, i, n), this.outOfViewStats = i, this.inViewStats = r
				}
				isAdequatelyInView(e, t) {
					return !!e && e.intersectionRatio >= t && this.pageInFocus
				}
				addDurationBasedViewabilityMinimum(e) {
					this.props.videoDuration ? e.viewabilityMinimum = Math.min(.5 * this.props.videoDuration, l.f) : e.viewabilityMinimum = l.f, e.remainingTime = e.viewabilityMinimum
				}
				adjustThreshold(e, t) {
					const {
						height: n,
						width: s
					} = e.boundingClientRect;
					return !t.threshold && t.event === m.a.VideoGroupMViewable && this.props.videoDuration && (t.threshold = s * n < 3e5 ? l.a : l.i, t.viewabilityMinimum = .5 * this.props.videoDuration), t.event === m.a.GroupMViewable && s * n > 242500 && (t.threshold = l.k), t
				}
				checkViewability(e, t) {
					if (j(t) && t.event === m.a.VideoVendorFullyViewable50 && this.addDurationBasedViewabilityMinimum(t), e && e.target && this.adjustThreshold(e, t), t.threshold && void 0 !== t.viewabilityMinimum) {
						if (this.isAdequatelyInView(e, t.threshold) && !t.fired) {
							if (t.timer) return;
							const e = this.getLengthForTimer(t);
							return e > 0 ? this.initTimer(t, e) : this.fireStat(t), void(t.timeViewingInitialized = Date.now())
						}
						j(t) && t.cumulative && this.pauseCumulativeStats(t), this.clearTimer(t)
					}
				}
				clearTimer(e) {
					e.timer && (clearTimeout(e.timer), e.timer = null)
				}
				getLengthForTimer(e) {
					return void 0 !== e.remainingTime ? e.remainingTime : e.viewabilityMinimum || 0
				}
				fireStat(e) {
					setTimeout(() => this.props.onPostViewable(this.props.post, e.event), 0), e.fired = !0
				}
				initTimer(e, t) {
					this.clearTimer(e), e.timer = window.setTimeout(() => {
						this.fireStat(e)
					}, t)
				}
				render() {
					const {
						trackDisplay: e,
						trackVideo: t
					} = this.props;
					let n = C;
					return e && !t ? n = O : !e && t && (n = E), i.a.createElement(c.a, {
						threshold: n,
						onChange: this.handleViewabilityChange
					}, this.props.children)
				}
			}
			t.a = S(_)
		},
		"./src/reddit/components/AuthorLink/index.m.less": function(e, t, n) {
			e.exports = {
				authorLinkStyles: "_23wugcdiaj44hdfugIAlnX",
				isUnstyled: "oQctV4n0yUb0uiHDdGnmE",
				isAdmin: "_1-wk-QXxJ0S4snrasETuaA",
				isAdminEmeritus: "sKTYSQHxlRLbA-0pCpguU",
				isMod: "_1VChcviPF84MLFsL2xfBCP",
				isOp: "_1uBAPhkb8ZOA-9p_B6inAR",
				isStrong: "_2YPMtQeUrWhVZuFXPpgmXz",
				isLivestreaming: "_3otDgT22VIln-JT-1XwFbr",
				deletedAuthorLink: "lizQBHVukyun2S2babj-l"
			}
		},
		"./src/reddit/components/AuthorLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/config.ts"),
				a = n("./src/reddit/controls/InternalLink/index.tsx"),
				c = n("./src/reddit/components/AuthorLink/index.m.less"),
				l = n.n(c);
			t.a = e => {
				const t = Object(r.a)(e.className, l.a.authorLinkStyles, {
					[l.a.isAdmin]: e.isAdmin,
					[l.a.isAdminEmeritus]: e.isAdminEmeritus,
					[l.a.isLivestreaming]: e.isLivestreaming,
					[l.a.isMod]: e.isMod,
					[l.a.isOp]: e.isOp,
					[l.a.isStrong]: e.isStrong,
					[l.a.isUnstyled]: e.isUnstyled
				});
				return e.isExternal || e.isLivestreaming ? o.a.createElement("a", {
					className: t,
					href: "".concat(i.a.redditUrl, "/user/").concat(e.author),
					rel: "nofollow",
					target: "_blank"
				}, e.children) : e.isAuthorDeleted ? o.a.createElement("span", {
					className: Object(r.a)(l.a.deletedAuthorLink, e.className)
				}, e.children) : o.a.createElement(a.a, {
					className: t,
					style: e.style,
					to: "/user/".concat(e.author, "/")
				}, e.children)
			}
		},
		"./src/reddit/components/AwardBadges/AddAwardPill/index.m.less": function(e, t, n) {
			e.exports = {
				addAwardPill: "_3Wf5TsmUR8Qf8nr0fDHjur",
				giftIcon: "eQZZIJf9NTq5MBV2285S2"
			}
		},
		"./src/reddit/components/AwardBadges/AwardPill/index.m.less": function(e, t, n) {
			e.exports = {
				awardPillContainer: "yW-ely1Ik8KTYTO9TSOSa",
				awardPill: "q2KM5tcmhqOBd4ElRihZQ",
				userGiven: "_1HqRbG571qt3Nk2zj_W3TS",
				imageContainer: "_1rwi4ljDNaPtYUiOiXomov",
				count: "_1YpK2GgjHXEnSEetPdXV17",
				awardIcon: "_2lnLb-ItT6LeziBNeQZx8I",
				hidden: "_3JxvBqAeBggcg7vHXhdVlS",
				animationIcon: "_2qKgWPWPiz4EnwPhDH9jaU",
				elasticShrink: "_1nKXGUCyFMbujKJCUr7v1F",
				fadeIn: "_3Unh28GaDqT2GLqHAD02_S"
			}
		},
		"./src/reddit/components/AwardBadges/AwardPlaqueBadges/index.m.less": function(e, t, n) {
			e.exports = {
				awardBadges: "_1wgnb6w6OJogtEV2N4B3lD",
				noAwards: "_1pZRAWakamwUD9Urx217oC",
				multiline: "_3c1kr0TjcknQSAP9naDKGv",
				spacer: "_1FZ8jCjLuxoHLtbgJDekEU",
				clickablePlaqueItem: "_2PVXBodfFt50jjk5ydPpWY",
				"focus-visible": "_3JCIceLNhOdJUR_ABw_M2V",
				focusVisible: "_3JCIceLNhOdJUR_ABw_M2V"
			}
		},
		"./src/reddit/components/AwardBadges/AwardPlaqueScrollButton/index.m.less": function(e, t, n) {
			e.exports = {
				buttonContainer: "DInSK-8C_3_wtp8rkyyk_",
				right: "_3h4h05agLr2A_NU_Rf3yCn",
				scrollButton: "_2MU8EpOTDEghV1ecmq37UZ",
				"focus-visible": "_38NFrOkGDKwQs4baFR_XWF",
				focusVisible: "_38NFrOkGDKwQs4baFR_XWF",
				chevronIcon: "uPrjAc1vFe8cn_-JitBDg"
			}
		},
		"./src/reddit/components/AwardBadges/ClassicAwardBadges/index.m.less": function(e, t, n) {
			e.exports = {
				awardBadges: "_3XoW0oYd5806XiOr24gGdb",
				badgeButton: "_1vpnHb2bSTD6BcgVKisnPT",
				visibilityEffect: "_3vGYJIJIswDD8YOAMWGC4N",
				icon: "_3zozqOs5cvNd2uvuIiu2_L",
				showAllButton: "_1tAFPduILh7Zse0gkxT4vj"
			}
		},
		"./src/reddit/components/AwardBadges/ClassicAwardItem/index.m.less": function(e, t, n) {
			e.exports = {
				awardItem: "_2OYwDdghtXEuTF67C95YLY",
				awardIcon: "n08B7PrU01wzgZYIh-s7N",
				animate: "f18KwJcHh9SCfKw_W3Dm2",
				awardBounce: "_3bDgD_5hXKabLRqOe9sXRi"
			}
		},
		"./src/reddit/components/AwardBadges/FlagAwardModal/index.m.less": function(e, t, n) {
			e.exports = {
				reportStepButton: "_2ke5Q4KsrJWi6sCDENRwI2"
			}
		},
		"./src/reddit/components/AwardBadges/TopAwardedPill/index.m.less": function(e, t, n) {
			e.exports = {
				pill: "AavtiP0APDAhqwl7opcvC",
				iconContainer: "_2NhWk2-d-tn8oC0A-k_Ss-",
				awardIcon: "_20LMDg4_PtezakicbNPSfn",
				awardsPlaqueStyle: "qntP0rU06Z8LVP6TKmQHQ",
				"focus-visible": "qbP9Qnm2Qru28YDgfefpw",
				focusVisible: "qbP9Qnm2Qru28YDgfefpw"
			}
		},
		"./src/reddit/components/AwardBadges/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/actions/gold/giveAward.ts"),
				l = n("./src/graphql/operations/HideAwardOnTarget.json"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/reddit/actions/gold/constants.ts"),
				m = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/models/Toast/index.ts");
			const b = Object(d.a)(p.G),
				f = e => {
					let {
						awardId: t,
						thingId: n
					} = e;
					return async (e, o, r) => {
						let {
							gqlContext: i
						} = r;
						e(b({
							awardId: t,
							thingId: n
						}));
						const a = s.fbt._("Something went wrong. The Award could not be hidden at this time.", null, {
							hk: "10OvOz"
						});
						try {
							(await ((e, t, n) => Object(u.a)(e, Object.assign(Object.assign({}, l), {
								variables: {
									awardId: t,
									targetId: n
								}
							})))(i(), t, n)).error && e(Object(m.e)({
								kind: h.b.Error,
								duration: m.a,
								text: a
							}))
						} catch (c) {
							e(Object(m.e)({
								kind: h.b.Error,
								duration: m.a,
								text: a
							}))
						}
					}
				};
			var g = n("./src/reddit/actions/gold/modals.ts"),
				x = n("./src/reddit/actions/modal.ts"),
				y = n("./src/reddit/actions/tooltip.ts"),
				v = n("./src/reddit/helpers/correlationIdTracker.ts"),
				C = n("./src/reddit/helpers/isPost.ts"),
				E = n("./src/reddit/helpers/trackers/gild.ts"),
				O = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				j = n("./src/reddit/components/TrackingHelper/index.tsx"),
				w = n("./src/reddit/models/Gold/Award.ts"),
				S = n("./src/reddit/selectors/activeModalId.ts"),
				_ = n("./src/reddit/constants/experiments.ts"),
				k = n("./src/reddit/helpers/chooseVariant/index.ts"),
				T = n("./src/reddit/selectors/user.ts");
			var I = n("./src/reddit/selectors/gold/awardIcon.ts"),
				P = n("./src/reddit/selectors/userPrefs.ts"),
				M = n("./node_modules/lodash/debounce.js"),
				N = n.n(M),
				R = n("./src/lib/classNames/index.ts"),
				L = n("./src/lib/fastdom/index.ts"),
				A = n("./src/reddit/models/Gold/TopAwarded/index.ts"),
				F = n("./src/reddit/icons/fonts/Gift/index.tsx"),
				D = n("./src/reddit/components/AwardBadges/AddAwardPill/index.m.less"),
				B = n.n(D);
			var U = r.a.memo(e => r.a.createElement("button", {
					className: Object(R.a)(e.className, B.a.addAwardPill),
					name: s.fbt._("Give award", null, {
						hk: "dQR06"
					}),
					onClick: e.onAddAward
				}, r.a.createElement(F.a, {
					className: B.a.giftIcon
				}))),
				K = n("./src/reddit/helpers/awards/getAwardItemId.ts"),
				H = n("./src/higherOrderComponents/makeAsync.tsx"),
				V = n("./src/lib/loadWithRetries/index.ts");
			var W = Object(H.a)({
					getComponent: () => Object(V.a)(() => n.e("AwardTooltip").then(n.bind(null, "./src/reddit/components/AwardTooltip/index.tsx"))).then(e => e.default),
					ErrorComponent: () => null,
					LoadingComponent: () => null
				}),
				z = n("./src/reddit/components/AwardBadges/AwardPill/index.m.less"),
				q = n.n(z);
			const G = 3500,
				J = 500;
			class Q extends r.a.PureComponent {
				constructor(e) {
					super(e), this.imageRef = r.a.createRef(), this.triggerAnimation = () => {
						const {
							award: e,
							prefersReducedMotion: t,
							tooltipId: n,
							triggerOverlayAnimation: s
						} = this.props;
						e.id !== w.g && (this.setState({
							userGiven: !0,
							shouldAnimate: !t
						}), t || (s(n), setTimeout(() => {
							this.setState({
								shouldAnimate: !1
							})
						}, G)))
					}, this.handleOnClick = () => {
						const {
							onAddAward: e,
							award: t
						} = this.props;
						e(t.id === w.g ? void 0 : t.id)
					}, this.handleMouseEnter = () => {
						const {
							onShowTooltip: e,
							tooltipId: t
						} = this.props;
						this.hoverTimer = setTimeout(() => {
							e(t), this.setState({
								hoverStateTriggered: !0
							})
						}, J)
					}, this.handleMouseLeave = () => {
						const {
							onHideTooltip: e
						} = this.props;
						this.state.hoverStateTriggered && (e(), this.setState({
							hoverStateTriggered: !1
						})), this.hoverTimer && (clearTimeout(this.hoverTimer), this.hoverTimer = void 0)
					}, this.handleHideAward = () => {
						const {
							onHideAward: e,
							award: t
						} = this.props;
						e(t)
					}, this.handleOpenReportFlow = () => {
						const {
							onOpenReportFlow: e,
							award: t
						} = this.props;
						e(t)
					}, this.state = {
						hoverStateTriggered: !1,
						shouldAnimate: !1,
						userGiven: !1
					}
				}
				componentDidMount() {
					const e = this.imageRef ? this.imageRef.current : null;
					e && e.addEventListener("awardAdded", this.triggerAnimation)
				}
				componentWillUnmount() {
					const e = this.imageRef ? this.imageRef.current : null;
					e && e.removeEventListener("awardAdded", this.triggerAnimation)
				}
				render() {
					const {
						award: e,
						className: t,
						count: n,
						giveAwardAnimationIconUrl: s,
						pillIconUrl: o,
						post: i,
						tooltipId: a
					} = this.props, {
						userGiven: c,
						shouldAnimate: l
					} = this.state, d = Object(K.a)(e.id, i.id);
					return r.a.createElement("span", {
						className: q.a.awardPillContainer,
						id: a,
						onMouseEnter: this.handleMouseEnter,
						onMouseLeave: this.handleMouseLeave
					}, r.a.createElement("button", {
						className: Object(R.a)(t, q.a.awardPill, {
							[q.a.userGiven]: c
						}),
						onClick: this.handleOnClick
					}, r.a.createElement("span", {
						className: q.a.imageContainer
					}, r.a.createElement("img", {
						alt: e.name,
						className: Object(R.a)(q.a.awardIcon, {
							[q.a.hidden]: l
						}),
						id: d,
						ref: this.imageRef,
						src: o
					}), l && r.a.createElement("img", {
						alt: e.name,
						className: q.a.animationIcon,
						src: s
					})), r.a.createElement("span", {
						className: q.a.count
					}, n.toLocaleString())), r.a.createElement(W, {
						award: e,
						onOpenReportFlow: this.handleOpenReportFlow,
						onHideAward: this.handleHideAward,
						postOrComment: i,
						tooltipId: a
					}))
				}
			}
			var Z = Q,
				Y = n("./src/reddit/icons/svgs/Chevron/index.tsx"),
				X = n("./src/reddit/components/AwardBadges/AwardPlaqueScrollButton/index.m.less"),
				$ = n.n(X);
			var ee = r.a.memo(e => {
				const {
					className: t,
					direction: n,
					onClick: o
				} = e, i = "right" === n, a = s.fbt._("Scroll left", null, {
					hk: "3MibS1"
				}), c = s.fbt._("Scroll right", null, {
					hk: "3xdEc5"
				});
				return r.a.createElement("div", {
					className: Object(R.a)($.a.buttonContainer, {
						[$.a.right]: i
					}, t)
				}, r.a.createElement("button", {
					className: $.a.scrollButton,
					name: i ? c : a,
					onClick: o
				}, r.a.createElement(Y.a, {
					className: $.a.chevronIcon
				})))
			});
			const te = (e, t) => {
				const n = Object(C.a)(e) ? "Post" : "Comment";
				let s = "".concat(n, "AwardBadges--").concat(e);
				return t && (s = "".concat(s, "--").concat(t)), s
			};
			var ne = n("./src/reddit/helpers/trackers/topAwarded.ts"),
				se = n("./src/reddit/hooks/useTracking.ts"),
				oe = n("./src/reddit/actions/gold/topAwarded.ts"),
				re = n("./src/reddit/icons/svgs/TopAwarded/index.tsx"),
				ie = n("./src/reddit/components/AwardBadges/TopAwardedPill/index.m.less"),
				ae = n.n(ie);
			const {
				fbt: ce
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var le = e => {
					const t = Object(i.c)(),
						n = Object(se.a)();
					return r.a.createElement("button", {
						className: Object(R.a)(ae.a.pill, e.className, {
							[ae.a.awardsPlaqueStyle]: !!e.awardsPlaqueStyle
						}),
						onClick: () => {
							const {
								postId: s
							} = e.post;
							n(Object(ne.a)(s)), t(Object(oe.b)(s))
						}
					}, r.a.createElement("span", {
						className: ae.a.iconContainer
					}, r.a.createElement(re.a, {
						className: ae.a.awardIcon
					})), r.a.createElement("span", null, ce._("Top Awarded", null, {
						hk: "49Ol5i"
					})))
				},
				de = n("./src/reddit/components/AwardBadges/AwardPlaqueBadges/index.m.less"),
				ue = n.n(de);
			const pe = 11,
				me = 100;
			class he extends r.a.Component {
				constructor(e) {
					super(e), this.plaqueRef = r.a.createRef(), this.handleResize = N()(() => {
						this.handlePlaquePositionChange()
					}, 300), this.handlePlaquePositionChange = () => {
						const {
							awards: e,
							awardsCountInView: t,
							multiline: n
						} = this.props, s = t || pe;
						if (e.length < s - 4) return;
						if (n) return;
						const o = this.plaqueRef.current;
						if (!o) return;
						const r = o.scrollLeft > 0,
							i = o.scrollLeft < o.scrollWidth - o.clientWidth;
						this.setState({
							canScrollLeft: r,
							canScrollRight: i
						})
					}, this.handleScrollLeft = () => {
						const e = this.plaqueRef.current;
						if (!e) return;
						const t = e.clientWidth,
							n = e.scrollLeft - (t - me);
						this.scrollPlaqueTo(n)
					}, this.handleScrollRight = () => {
						const e = this.plaqueRef.current;
						if (!e) return;
						const t = e.clientWidth,
							n = e.scrollLeft + (t - me);
						this.scrollPlaqueTo(n)
					}, this.handleTriggerAnimation = e => {
						this.props.triggerOverlayAnimation(), L.a.read(() => {
							const t = this.plaqueRef.current;
							if (!t) return;
							const n = document.getElementById(e);
							if (!n) return;
							const s = t.getBoundingClientRect(),
								o = n.getBoundingClientRect();
							if (o.left < s.left || o.right > s.right) {
								const e = o.left + (t.scrollLeft - s.left) - me;
								this.scrollPlaqueTo(e)
							}
						})
					};
					const t = e.awardsCountInView || pe,
						n = e.awards.length > t;
					this.state = {
						canScrollLeft: !1,
						canScrollRight: n && !e.multiline
					}
				}
				shouldComponentUpdate(e, t) {
					if (this.props.awards !== e.awards) {
						const t = this.props.awards.reduce((e, t) => (e[t.id] = (this.props.post.awardCountsById || {})[t.id], e), {});
						if (e.awards.reduce((n, s) => {
								const o = t[s.id],
									r = (e.post.awardCountsById || {})[s.id];
								return n || o !== r
							}, !1)) return !0
					}
					if (this.props.post.id !== e.post.id) return !0;
					for (const n in this.state)
						if (this.state[n] !== t[n]) return !0;
					return this.props.post.topAwardedType !== e.post.topAwardedType
				}
				componentDidUpdate(e) {
					this.props.awards.length !== e.awards.length && this.handlePlaquePositionChange()
				}
				componentDidMount() {
					window.addEventListener("resize", this.handleResize)
				}
				componentWillUnmount() {
					window.removeEventListener("resize", this.handleResize)
				}
				scrollPlaqueTo(e) {
					const {
						prefersReducedMotion: t
					} = this.props, n = t ? "auto" : "smooth", s = this.plaqueRef.current;
					if (!s) return;
					const o = s.clientWidth,
						r = s.scrollWidth - o,
						i = Math.min(Math.max(0, e), r);
					this.setState({
						canScrollLeft: i > 0,
						canScrollRight: i < r
					}), s.scrollTo({
						left: i,
						top: 0,
						behavior: n
					})
				}
				render() {
					const {
						awards: e,
						className: t,
						hideAddAwardButton: n,
						hideTopAwardedBadge: s,
						icons: o,
						isInEconLeaderboardsExperiment: i,
						multiline: a,
						post: c,
						prefersReducedMotion: l,
						onAddAward: d,
						onHideAward: u,
						onHideTooltip: p,
						onOpenReportFlow: m,
						onShowTooltip: h,
						tooltipType: b
					} = this.props, {
						canScrollLeft: f,
						canScrollRight: g
					} = this.state, x = e.length > 0, y = te(c.id, b);
					return r.a.createElement("div", {
						className: Object(R.a)(ue.a.awardBadges, t, {
							[ue.a.noAwards]: !x,
							[ue.a.multiline]: a
						}),
						ref: this.plaqueRef
					}, f && r.a.createElement(ee, {
						direction: "left",
						onClick: this.handleScrollLeft
					}), (c.topAwardedType === A.a.Active || c.topAwardedType === A.a.Inactive) && !s && i && r.a.createElement(le, {
						awardsPlaqueStyle: !0,
						post: c
					}), e.map(e => {
						const {
							awardCountsById: t = {}
						} = c, n = t[e.id], s = o.icon32[e.id], i = o.icon128[e.id];
						return r.a.createElement(Z, {
							award: e,
							className: ue.a.clickablePlaqueItem,
							count: n,
							giveAwardAnimationIconUrl: i,
							key: e.id,
							onAddAward: d,
							onHideAward: u,
							onOpenReportFlow: m,
							onHideTooltip: p,
							onShowTooltip: h,
							pillIconUrl: s,
							post: c,
							prefersReducedMotion: l,
							tooltipId: "".concat(y, "-").concat(e.id),
							triggerOverlayAnimation: this.handleTriggerAnimation
						})
					}), !n && r.a.createElement(U, {
						className: ue.a.clickablePlaqueItem,
						onAddAward: d
					}), !a && r.a.createElement("div", {
						className: ue.a.spacer
					}), g && r.a.createElement(ee, {
						direction: "right",
						onClick: this.handleScrollRight
					}))
				}
			}
			var be = he,
				fe = n("./src/reddit/components/AwardBadges/ClassicAwardItem/index.m.less"),
				ge = n.n(fe);
			const {
				fbt: xe
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class ye extends r.a.PureComponent {
				constructor(e) {
					super(e), this.imageRef = r.a.createRef(), this.handleAwardAddedEvent = () => {
						this.setState({
							animate: !0
						}), setTimeout(() => this.setState({
							animate: !1
						}), 1e3)
					}, this.onShowTooltip = () => {
						const {
							onShowTooltip: e,
							tooltipId: t
						} = this.props;
						return e(t)
					}, this.state = {
						animate: !1
					}
				}
				componentDidMount() {
					const e = this.imageRef ? this.imageRef.current : null;
					e && e.addEventListener("awardAdded", this.handleAwardAddedEvent)
				}
				componentWillUnmount() {
					const e = this.imageRef ? this.imageRef.current : null;
					e && e.removeEventListener("awardAdded", this.handleAwardAddedEvent)
				}
				renderModAwardName() {
					const {
						award: e,
						count: t
					} = this.props;
					return r.a.createElement(r.a.Fragment, null, t > 1 && " • ", xe._("{award-name} Award", [xe._param("award-name", e.name)], {
						hk: "2QpjYF"
					}))
				}
				render() {
					const {
						award: e,
						className: t,
						count: n,
						iconClassName: s,
						iconUrl: o,
						onHideAward: i,
						onHideTooltip: a,
						onOpenReportFlow: c,
						postOrComment: l,
						tooltipId: d,
						tooltipLocation: u
					} = this.props;
					if (n <= 0) return null;
					const p = e.awardType === w.f.Moderator,
						m = Object(K.a)(e.id, l.id),
						h = "container" === u;
					return r.a.createElement("span", {
						className: Object(R.a)(ge.a.awardItem, t),
						id: h ? d : "",
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: a
					}, r.a.createElement("span", {
						id: h ? "" : d
					}, r.a.createElement("img", {
						alt: e.name,
						className: Object(R.a)(ge.a.awardIcon, {
							[ge.a.animate]: this.state.animate
						}, s),
						id: m,
						ref: this.imageRef,
						src: o
					})), r.a.createElement("span", null, n > 1 && n, p && this.renderModAwardName()), r.a.createElement(W, {
						award: e,
						onHideAward: () => i(e),
						postOrComment: l,
						tooltipId: d,
						onOpenReportFlow: () => c(e)
					}))
				}
			}
			var ve = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				Ce = n("./src/reddit/icons/fonts/helpers.tsx");
			var Ee = e => r.a.createElement("i", {
				className: Object(R.a)(Object(Ce.b)("addGild"), e.className)
			});
			var Oe = e => r.a.createElement("i", {
					className: Object(R.a)(Object(Ce.b)("addGildDashed"), e.className)
				}),
				je = n("./src/reddit/components/AwardBadges/ClassicAwardBadges/index.m.less"),
				we = n.n(je);
			class Se extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						isHovered: !1
					}, this.handleMouseEnter = () => {
						this.setState({
							isHovered: !0
						})
					}, this.handleMouseLeave = () => {
						this.setState({
							isHovered: !1
						})
					}
				}
				render() {
					const {
						className: e,
						onClick: t
					} = this.props, n = this.state.isHovered ? Ee : Oe;
					return r.a.createElement("button", {
						className: Object(R.a)(e, we.a.badgeButton, we.a.visibilityEffect),
						onClick: t,
						onBlur: this.handleMouseLeave,
						onFocus: this.handleMouseEnter,
						onMouseEnter: this.handleMouseEnter,
						onMouseLeave: this.handleMouseLeave
					}, r.a.createElement(n, {
						className: we.a.icon
					}))
				}
			}
			var _e = Se;
			var ke, Te = e => {
					const {
						awards: t,
						className: n,
						hideBadgeButton: o,
						hideTopAwardedBadge: i,
						icons: a,
						isInEconLeaderboardsExperiment: c,
						onAddAward: l,
						onHideAward: d,
						onOpenReportFlow: u,
						onHideTooltip: p,
						onShowAllAwards: m,
						onShowTooltip: h,
						showAllAwards: b,
						tooltipType: f,
						thing: g
					} = e, x = te(g.id, f), y = "".concat(x, "-view-all");
					let v = [];
					v = b ? t : t.length > 5 ? t.slice(0, 4) : t;
					const E = !o && g.isGildable && t.length > 0,
						O = t.length > v.length ? t.slice(v.length).reduce((e, t) => e + (g.awardCountsById && g.awardCountsById[t.id] || 0), 0) : 0,
						j = s.fbt._("& {hidden award count} More", [s.fbt._param("hidden award count", O.toLocaleString())], {
							hk: "1OnmAi"
						});
					return r.a.createElement("div", {
						className: Object(R.a)(we.a.awardBadges, n)
					}, Object(C.a)(g.id) && (g.topAwardedType === A.a.Active || g.topAwardedType === A.a.Inactive) && !i && c && r.a.createElement(le, {
						post: g
					}), v.map(e => {
						const t = g.awardCountsById ? g.awardCountsById[e.id] : 0,
							n = a.icon32[e.id];
						return r.a.createElement(ye, {
							award: e,
							count: t,
							iconUrl: n,
							key: e.id,
							onHideAward: d,
							onOpenReportFlow: u,
							onHideTooltip: p,
							onShowTooltip: h,
							postOrComment: g,
							tooltipId: "".concat(x, "-").concat(e.id),
							tooltipLocation: "icon"
						})
					}), O > 0 && r.a.createElement(r.a.Fragment, null, r.a.createElement("button", {
						"data-click-id": "awards",
						id: y,
						className: we.a.showAllButton,
						onClick: m,
						onMouseEnter: () => h(y),
						onMouseLeave: p
					}, j), r.a.createElement(ve.c, {
						tooltipId: y,
						text: "View all Awards"
					})), E && r.a.createElement(_e, {
						onClick: l
					}))
				},
				Ie = n("./src/reddit/actions/gold/reportAward.ts"),
				Pe = n("./src/reddit/controls/Button/index.tsx"),
				Me = n("./src/reddit/components/AwardBadges/FlagAwardModal/index.m.less"),
				Ne = n.n(Me);
			! function(e) {
				e[e.BEGIN = 0] = "BEGIN", e[e.REPORT_COMMUNITY_AWARD = 1] = "REPORT_COMMUNITY_AWARD", e[e.FLAG_USAGE = 2] = "FLAG_USAGE"
			}(ke || (ke = {}));
			var Re = e => {
				const t = Object(se.a)(),
					[n, a] = Object(o.useState)(e.award.awardType === w.f.Global ? ke.FLAG_USAGE : ke.BEGIN),
					c = Object(i.c)(),
					l = () => {
						n === ke.BEGIN ? t(Object(E.clickCancelAwardReportFlow)(e.award, e.thing.id)) : n === ke.REPORT_COMMUNITY_AWARD ? t(Object(E.clickCancelReportAward)(e.award, e.thing.id)) : n === ke.FLAG_USAGE && t(Object(E.clickCancelFlagAwardUsage)(e.award, e.thing.id)), e.onClose()
					},
					d = () => {
						t(Object(E.clickConfirmReportAward)(e.award, e.thing.id)), c(Object(Ie.a)(e.award.id)), e.onClose()
					},
					u = () => {
						t(Object(E.clickConfirmFlagAwardUsage)(e.award, e.thing.id)), c(Object(m.e)(Object(m.d)(s.fbt._("{award name} Award successfully flagged for review.", [s.fbt._param("award name", e.award.name)], {
							hk: "24QeOL"
						}), h.b.SuccessAward))), e.onClose()
					},
					p = r.a.createElement(r.a.Fragment, null, r.a.createElement(Pe.i, {
						onClick: () => {
							t(Object(E.clickReportAward)(e.award, e.thing.id)), a(ke.REPORT_COMMUNITY_AWARD)
						},
						className: Ne.a.reportStepButton
					}, s.fbt._("This community award violates Reddit's rules.", null, {
						hk: "2ObuGq"
					})), r.a.createElement(Pe.i, {
						onClick: () => {
							t(Object(E.clickFlagAwardUsage)(e.award, e.thing.id)), a(ke.FLAG_USAGE)
						},
						className: Ne.a.reportStepButton
					}, s.fbt._("This award is being used inappropriately.", null, {
						hk: "Y8giW"
					})));
				switch (n) {
					case ke.BEGIN:
						return r.a.createElement(O.a, {
							withOverlay: !0,
							hideCancelButton: !0,
							onConfirm: l,
							onCancel: l,
							onClose: l,
							headerText: s.fbt._("What's Wrong?", null, {
								hk: "JqSAe"
							}),
							actionText: s.fbt._("Cancel", null, {
								hk: "370pdF"
							}),
							modalText: p
						});
					case ke.REPORT_COMMUNITY_AWARD:
						return r.a.createElement(O.a, {
							withOverlay: !0,
							onConfirm: d,
							onCancel: l,
							onClose: l,
							headerText: s.fbt._("Report Community Award", null, {
								hk: "3T6dhH"
							}),
							actionText: s.fbt._("Report Award", null, {
								hk: "dHwed"
							}),
							modalText: s.fbt._("Do you want to report the {award name} Award?", [s.fbt._param("award name", e.award.name)], {
								hk: "4by1t"
							})
						});
					case ke.FLAG_USAGE:
						return r.a.createElement(O.a, {
							withOverlay: !0,
							onConfirm: u,
							onCancel: l,
							onClose: l,
							headerText: s.fbt._("Flag Award Usage", null, {
								hk: "395heU"
							}),
							actionText: s.fbt._("Flag Award Usage", null, {
								hk: "24B1WV"
							}),
							modalText: s.fbt._("Is the {award name} Award inappropriate on this content? Reddit uses this information to improve the awarding experience and remove awards that are being misused.", [s.fbt._param("award name", e.award.name)], {
								hk: "3P3dMP"
							})
						})
				}
			};
			const Le = Object(a.c)({
					allAwards: e => e.awards.models,
					icons: (e, t) => Object(I.b)(e, {
						postOrComment: t.thing,
						minSizes: [32, 128]
					}),
					currentUser: T.i,
					isConfirmModalOpen: e => "AwardBadges--Modal--HideAwardConfirmation" === Object(S.a)(e),
					isInEconLeaderboardsExperiment: e => {
						const t = Object(k.c)(e, {
							experimentEligibilitySelector: T.H,
							experimentName: _.eb
						});
						return !(!t || Object(_.Ec)(t))
					},
					isLoggedIn: T.H,
					prefersReducedAnimations: P.c
				}),
				Ae = e => Object(C.a)(e.id) ? e.postId : e.id,
				Fe = Object(i.b)(Le, (e, t) => {
					let {
						thing: n
					} = t;
					return {
						hideAward: t => e(f({
							awardId: t,
							thingId: Ae(n)
						})),
						onAddAward: (t, s) => {
							const o = Ae(n);
							return e(Object(g.d)({
								awardId: s,
								correlationId: t,
								thingId: o
							}))
						},
						onHideTooltip: () => e(Object(y.i)()),
						onShowTooltip: t => e(Object(y.f)({
							tooltipId: t
						})),
						onToggleHideAwardModal: () => e(Object(x.i)("AwardBadges--Modal--HideAwardConfirmation")),
						triggerOverlayAnimation: () => e(Object(c.b)(Ae(n)))
					}
				});
			class De extends r.a.Component {
				constructor(e) {
					super(e), this.handleAddAward = async e => {
						const t = Object(v.d)(v.a.GildingFlow, !0),
							{
								onAddAward: s,
								sendEvent: o,
								thing: r
							} = this.props;
						s(t, e);
						const {
							clickAddAward: i
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						o(i(r.id))
					}, this.handleShowAllAwards = () => {
						this.setState({
							showAllAwards: !0
						})
					}, this.handleHideAward = async e => {
						const {
							sendEvent: t,
							onToggleHideAwardModal: s,
							thing: o
						} = this.props;
						this.setState({
							selectedAward: e
						});
						const {
							clickHideAward: r
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						t(r(e, o.id)), s()
					}, this.handleHideAwardConfirmed = async () => {
						const {
							sendEvent: e,
							thing: t
						} = this.props, {
							selectedAward: s
						} = this.state, {
							clickConfirmHideAward: o
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						s && (e(o(s, t.id)), this.props.hideAward(s.id))
					}, this.handleHideAwardCanceled = async () => {
						const {
							sendEvent: e,
							thing: t
						} = this.props, {
							selectedAward: s
						} = this.state, {
							clickCancelHideAward: o
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						s && e(o(s, t.id))
					}, this.handleShowTooltip = e => {
						const {
							onShowTooltip: t
						} = this.props;
						t(e)
					}, this.handleHideTooltip = () => {
						const {
							onHideTooltip: e
						} = this.props;
						e()
					}, this.handleOpenReportFlow = e => {
						this.props.sendEvent(Object(E.clickAwardReportFlow)(e, this.props.thing.id)), this.setState({
							reportingAward: e
						})
					}, this.state = {
						selectedAward: null,
						showAllAwards: !1,
						reportingAward: null
					}
				}
				render() {
					const {
						allAwards: e,
						awardsCountInView: t,
						awardsPlaqueStyle: n,
						className: o,
						currentUser: i,
						hideCta: a,
						hideTopAwardedBadge: c,
						icons: l,
						isConfirmModalOpen: d,
						isInEconLeaderboardsExperiment: u,
						isLoggedIn: p,
						isPostDetail: m,
						onHideTooltip: h,
						onShowTooltip: b,
						onToggleHideAwardModal: f,
						prefersReducedAnimations: g,
						thing: x,
						triggerOverlayAnimation: y,
						tooltipType: v
					} = this.props, {
						showAllAwards: E
					} = this.state, j = g || "undefined" != typeof window && !!window.matchMedia("(prefers-reduced-motion)").matches, S = Object(w.q)(Object.keys(x.awardCountsById || {}).map(t => e[t]).filter(Boolean)), _ = !!i && i.id === x.authorId;
					return r.a.createElement(r.a.Fragment, null, n ? r.a.createElement(be, {
						awards: S,
						awardsCountInView: t,
						className: o,
						hideAddAwardButton: a || !x.isGildable || _,
						hideTopAwardedBadge: c,
						icons: l,
						isInEconLeaderboardsExperiment: u,
						multiline: !!m,
						onAddAward: this.handleAddAward,
						onHideAward: this.handleHideAward,
						onOpenReportFlow: this.handleOpenReportFlow,
						onHideTooltip: this.handleHideTooltip,
						onShowTooltip: this.handleShowTooltip,
						post: x,
						prefersReducedMotion: j,
						tooltipType: v,
						triggerOverlayAnimation: y
					}) : r.a.createElement(Te, {
						awards: S,
						className: o,
						hideBadgeButton: a || !p,
						hideTopAwardedBadge: c,
						icons: l,
						isInEconLeaderboardsExperiment: u,
						onAddAward: this.handleAddAward,
						onHideAward: this.handleHideAward,
						onOpenReportFlow: this.handleOpenReportFlow,
						onHideTooltip: h,
						onShowAllAwards: this.handleShowAllAwards,
						onShowTooltip: b,
						showAllAwards: E || !!m,
						thing: x,
						tooltipType: v
					}), d && i && this.state.selectedAward && r.a.createElement(O.a, {
						actionText: s.fbt._("Hide", null, {
							hk: "4FKnfB"
						}),
						modalText: _ ? Object(C.a)(x.id) ? s.fbt._("The award giver(s) will be notified that you have hidden their {awardName} award. This action cannot be undone. Are you sure you want to hide awards of this type from your post?", [s.fbt._param("awardName", this.state.selectedAward.name)], {
							hk: "4a7Cbu"
						}) : s.fbt._("The award giver(s) will be notified that you have hidden their {awardName} award. This action cannot be undone. Are you sure you want to hide awards of this type from your comment?", [s.fbt._param("awardName", this.state.selectedAward.name)], {
							hk: "294BlY"
						}) : Object(C.a)(x.id) ? s.fbt._("The award giver(s) and recipient will be notified that a moderator has hidden the {awardName} award. Are you sure you want to hide this award from the post?", [s.fbt._param("awardName", this.state.selectedAward.name)], {
							hk: "3LQVs7"
						}) : s.fbt._("The award giver(s) and recipient will be notified that a moderator has hidden the {awardName} award. Are you sure you want to hide this award from the comment?", [s.fbt._param("awardName", this.state.selectedAward.name)], {
							hk: "qlfga"
						}),
						onConfirm: this.handleHideAwardConfirmed,
						onCancel: this.handleHideAwardCanceled,
						toggleModal: f,
						withOverlay: !0
					}), this.state.reportingAward && r.a.createElement(Re, {
						award: this.state.reportingAward,
						thing: x,
						onClose: () => this.setState({
							reportingAward: null
						})
					}))
				}
			}
			t.a = Fe(Object(j.c)(De))
		},
		"./src/reddit/components/Badges/UserDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				addCustom: "LalRrQILNjt65y-p-QlWH",
				addCustomLink: "_3J2-xIxxxP9ISzeLWCOUVc",
				badgeHovercard: "FyLpt0kIWG1bTDWZ8HIL1",
				image: "_2ntJEAiwKXBGvxrJiqxx_2",
				wrapper: "_1SqBC7PQ5dMOdF0MhPIkA8"
			}
		},
		"./src/reddit/components/Badges/UserDisplay/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return j
			})), n.d(t, "c", (function() {
				return k
			})), n.d(t, "a", (function() {
				return T
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/config.ts"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/actions/economics/subredditPremium/actionCreators.ts"),
				d = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/higherOrderComponents/makeAsync.tsx");
			var p = Object(u.a)({
					ErrorComponent: () => null,
					LoadingComponent: () => null,
					getComponent: () => Promise.all([n.e("vendors~InFeedChaining~PostCreation~Reddit~StandalonePostPage~SubredditPremiumBadgeHovercardTooltip"), n.e("EconomicsSubredditPremiumSidebarCards~SubredditPremiumBadgeHovercardTooltip"), n.e("SubredditPremiumBadgeHovercardTooltip")]).then(n.bind(null, "./src/reddit/components/Economics/SubredditPremium/Badges/HoverCard/tooltip.tsx")).then(e => e.default)
				}),
				m = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				h = n("./src/reddit/featureFlags/index.ts"),
				b = n("./src/reddit/helpers/economics/sortBadges.ts"),
				f = n("./src/reddit/icons/svgs/AddSquare/index.tsx"),
				g = n("./src/reddit/models/Badge/index.ts");
			var x = Object(u.a)({
					ErrorComponent: () => null,
					LoadingComponent: () => null,
					getComponent: () => n.e("CustomBadgeHovercardTooltip").then(n.bind(null, "./src/reddit/components/Badges/UserDisplay/AddCustomTooltip/tooltip.tsx")).then(e => e.default)
				}),
				y = n("./src/reddit/components/Badges/UserDisplay/index.m.less"),
				v = n.n(y);
			const C = "add-custom-badge-tooltip",
				E = 100,
				O = 2 * E;
			class j extends o.a.Component {
				constructor() {
					super(...arguments), this.mouseOverTooltip = void 0, this.enterTimeout = void 0, this.exitTimeout = void 0, this.handleMouseEnter = e => {
						this.mouseOverTooltip && this.mouseOverTooltip !== e ? this.props.onShowTooltip(e) : (clearTimeout(this.enterTimeout), this.enterTimeout = window.setTimeout(() => {
							this.mouseOverTooltip === e && this.props.onShowTooltip(e)
						}, E)), this.mouseOverTooltip = e
					}, this.handleMouseLeave = () => {
						clearTimeout(this.exitTimeout), clearTimeout(this.enterTimeout), this.mouseOverTooltip = void 0, this.exitTimeout = window.setTimeout(() => {
							this.mouseOverTooltip || (clearTimeout(this.enterTimeout), this.props.onHideTooltip())
						}, O)
					}
				}
				render() {
					if (this.props.usePlaceholder && !this.props.badges.length) return o.a.createElement("img", {
						className: Object(c.a)(v.a.image, this.props.className),
						src: "".concat(a.a.assetPath, "/img/badges/placeholder.png")
					});
					const e = "".concat(C, "-").concat(this.props.uniqueIdentifier);
					return o.a.createElement(s.Fragment, null, this.props.showAddCustom && o.a.createElement("div", {
						className: v.a.wrapper,
						id: e,
						onMouseEnter: () => this.handleMouseEnter(e),
						onMouseLeave: () => this.handleMouseLeave()
					}, o.a.createElement("button", {
						className: v.a.addCustomLink,
						onClick: this.props.onOpenUploadDialog
					}, o.a.createElement(f.a, {
						className: v.a.addCustom
					})), o.a.createElement(x, {
						className: v.a.badgeHovercard,
						subredditId: this.props.subredditId,
						targetPosition: ["left", "bottom"],
						tooltipId: e,
						tooltipPosition: ["left", "top"],
						onHideTooltip: () => this.props.onHideTooltip()
					})), Object(b.a)(this.props.badges).map(e => {
						const t = Object(g.b)(24, 24, e),
							n = "badges-display-".concat(e.id, "-").concat(this.props.uniqueIdentifier);
						return o.a.createElement(s.Fragment, {
							key: "badges-fragement-".concat(e.id)
						}, o.a.createElement("div", {
							className: Object(c.a)(v.a.wrapper, this.props.className),
							key: "wrapper-".concat(e.id),
							onMouseEnter: () => this.handleMouseEnter(n),
							onMouseLeave: () => this.handleMouseLeave()
						}, o.a.createElement("img", {
							className: v.a.image,
							id: n,
							key: e.id,
							src: t.url2x,
							srcSet: "".concat(t.url, ", ").concat(t.url2x, " 2x")
						}), this.props.useHovercard ? o.a.createElement(p, {
							badge: e,
							correlationId: this.props.correlationId,
							className: v.a.badgeHovercard,
							key: "tooltip-".concat(e.id),
							subredditId: this.props.subredditId,
							targetPosition: ["left", "bottom"],
							tooltipId: n,
							tooltipPosition: ["left", "top"],
							userId: "userId" in this.props ? this.props.userId : void 0
						}) : o.a.createElement(m.c, {
							caretOnTop: !0,
							key: "tooltip-".concat(e.id),
							tooltipId: n,
							text: e.title
						})))
					}))
				}
			}
			const w = Object(i.c)({
					badges: (e, t) => {
						let {
							subredditId: n,
							userId: s
						} = t;
						return ((e.users.appliedBadges[s] || {})[n] || []).map(t => e.badges.models[t]).filter(Boolean)
					},
					useHovercard: h.d.spSpecialMemberships
				}),
				S = Object(i.c)({
					badges: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = e.user.account;
						if (s) {
							return ((e.users.appliedBadges[s.id] || {})[n] || []).map(t => e.badges.models[t]).filter(Boolean)
						}
						return []
					},
					useHovercard: h.d.spSpecialMemberships
				}),
				_ = e => ({
					onShowTooltip: t => e(Object(d.f)({
						tooltipId: t
					})),
					onHideTooltip: () => e(Object(d.i)()),
					onOpenUploadDialog: () => e(Object(l.j)())
				}),
				k = Object(r.b)(w, _)(j),
				T = Object(r.b)(S, _)(j)
		},
		"./src/reddit/components/CategoryTag/index.m.less": function(e, t, n) {
			e.exports = {
				metaFlair: "_7_d4sJjd2oYzaJuU_QpOI",
				"m-lightboxHeader": "_1rtoCmW_7bFJWYffSOwt4R",
				mLightboxHeader: "_1rtoCmW_7bFJWYffSOwt4R"
			}
		},
		"./src/reddit/components/CategoryTagList/index.m.less": function(e, t, n) {
			e.exports = {
				categoryTagWrapper: "_13jLUpnQtcA8FXyw5Kv06q"
			}
		},
		"./src/reddit/components/CategoryTagList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/selectors/user.ts"),
				l = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/constants/posts.ts"),
				p = n("./src/reddit/controls/InternalLink/index.tsx"),
				m = n("./src/lib/addQueryParams/index.ts");
			const h = (e, t, n, s, o) => {
				const r = o || "*:*",
					i = n || d.P;
				return Object(m.a)("/search", {
					q: r,
					sort: i,
					t: s,
					category_name: e,
					category: t
				})
			};
			var b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/selectors/telemetry.ts");
			const g = (e, t) => n => Object.assign(Object.assign({
				source: "post",
				action: "click",
				noun: "meta_flair"
			}, f.defaults(n)), {
				correlationId: Object(b.c)(b.a.SearchResults),
				post: f.post(n, e),
				search: f.postFlairClickToSearch(n, t),
				subreddit: f.subreddit(n)
			});
			var x = n("./src/reddit/components/CategoryTag/index.m.less"),
				y = n.n(x);
			class v extends o.a.Component {
				constructor() {
					super(...arguments), this.onClick = () => {
						const e = {
							id: this.props.category.categoryId,
							title: this.props.category.categoryName,
							eventType: u.a.SUBREDDIT,
							originElement: "meta_flair"
						};
						this.props.sendEvent(g(this.props.postId, e))
					}
				}
				render() {
					const e = this.props.category,
						t = this.props.inLightboxHeader,
						n = e.categoryId,
						s = e.categoryName,
						r = o.a.createElement("span", null, s);
					return o.a.createElement("span", {
						className: Object(l.a)(y.a.metaFlair, {
							[y.a["m-lightboxHeader"]]: t
						})
					}, o.a.createElement(p.a, {
						onClick: this.onClick,
						to: h(s, n, d.Lb.Relevance, d.Sb.DAY),
						children: r
					}))
				}
			}
			var C = n("./src/reddit/components/CategoryTagList/index.m.less"),
				E = n.n(C);
			const O = Object(r.b)(() => Object(i.c)({
				labelNSFW: c.P
			}));
			t.a = O(Object(a.c)(e => {
				let {
					postCategories: t,
					postId: n,
					inLightboxHeader: s,
					sendEvent: r
				} = e;
				return o.a.createElement("span", {
					className: s ? null : E.a.categoryTagWrapper
				}, t.map(e => o.a.createElement(v, {
					postId: n,
					category: e,
					key: e.categoryId,
					inLightboxHeader: s,
					sendEvent: r
				})))
			}))
		},
		"./src/reddit/components/CommentCreation/ExpandingFormDiv.m.less": function(e, t, n) {
			e.exports = {
				breakout: "_1VBLErIxAjOke05q8yLOyf"
			}
		},
		"./src/reddit/components/CommentCreation/ExpandingFormDiv.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/CommentCreation/ExpandingFormDiv.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const d = (e, t) => 21 * e + 33 + (t ? 10 : 0);
			t.a = e => {
				var {
					breakOut: t,
					depth: n,
					isEditing: s
				} = e, i = l(e, ["breakOut", "depth", "isEditing"]);
				return o.a.createElement("div", c({
					className: Object(r.a)({
						[a.a.breakout]: t
					}),
					style: {
						left: d(n, s)
					}
				}, i))
			}
		},
		"./src/reddit/components/CommentCreation/FormFooter/index.m.less": function(e, t, n) {
			e.exports = {
				SubmitButton: "_22S4OsoDdOqiM-hPTeOURa",
				submitButton: "_22S4OsoDdOqiM-hPTeOURa",
				LoadingIcon: "_2qsMO_C_HwxgUgktaOeqZ2",
				loadingIcon: "_2qsMO_C_HwxgUgktaOeqZ2",
				CancelButton: "cZz52cPDbNgzrR1Oo1k27",
				cancelButton: "cZz52cPDbNgzrR1Oo1k27",
				ButtonWrapper: "_3SNMf5ZJL_5F1qxcZkD0Cp",
				buttonWrapper: "_3SNMf5ZJL_5F1qxcZkD0Cp",
				FormFooterWrapper: "_17TqawK-44tH0psnHPIhzS",
				formFooterWrapper: "_17TqawK-44tH0psnHPIhzS",
				pending: "_5p2VqxvUAZTtPIXr7XU5p"
			}
		},
		"./src/reddit/components/CommentCreation/FormFooter/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/components/CommentCreation/FormFooter/index.m.less"),
				d = n.n(l);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js"), p = i.a.div("FormFooterWrapper", d.a), m = i.a.wrapped(a.f, "SubmitButton", d.a), h = i.a.wrapped(c.a, "LoadingIcon", d.a), b = i.a.wrapped(a.i, "CancelButton", d.a), f = i.a.div("ButtonWrapper", d.a), g = e => e.preventDefault();
			t.a = e => {
				let {
					pending: t,
					cancelButtonEnabled: n = !0,
					children: s,
					className: i,
					submitButtonText: a,
					canSubmit: c,
					onSubmit: l,
					onCancel: x
				} = e;
				return o.a.createElement(p, {
					className: Object(r.a)(i, {
						[d.a.pending]: t
					})
				}, o.a.createElement(f, null, o.a.createElement(m, {
					type: "submit",
					disabled: !c,
					onClick: l,
					onMouseDown: g
				}, t ? o.a.createElement(h, {
					sizePx: 10
				}) : a), n && o.a.createElement(b, {
					type: "reset",
					disabled: t,
					onClick: x,
					onMouseDown: g
				}, u._("Cancel", null, {
					hk: "2TSLl5"
				}))), s)
			}
		},
		"./src/reddit/components/CommentCreation/MarkdownCommentForm/MarkdownModeButton.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3oZ5XBWSc3x7cXsvdt3fJ",
				wrapper: "_3oZ5XBWSc3x7cXsvdt3fJ",
				MarkdownModeIcon: "_1EifMLRAKpii4eqciAhY4q",
				markdownModeIcon: "_1EifMLRAKpii4eqciAhY4q",
				Button: "_1Q2Vq3gesOWZA73NbspEiQ",
				button: "_1Q2Vq3gesOWZA73NbspEiQ"
			}
		},
		"./src/reddit/components/CommentCreation/MarkdownCommentForm/index.m.less": function(e, t, n) {
			e.exports = {
				LoadingIcon: "_2izw1tRcQRvnfuR1E05Cy4",
				loadingIcon: "_2izw1tRcQRvnfuR1E05Cy4",
				CommentHeader: "PN-j_b1WdWATQha3fOgkV",
				commentHeader: "PN-j_b1WdWATQha3fOgkV",
				HelpButton: "MQruKnjMvMoDlmee_nF40",
				helpButton: "MQruKnjMvMoDlmee_nF40",
				SwitchModeButton: "_2UH-_HmB6X-2cCsOZVDtC5",
				switchModeButton: "_2UH-_HmB6X-2cCsOZVDtC5",
				FormHeaderText: "_1EQf9w-o91arfThHA8fn-N",
				formHeaderText: "_1EQf9w-o91arfThHA8fn-N",
				HelpIcon: "_3TI2tdRj3loY834ns393zu",
				helpIcon: "_3TI2tdRj3loY834ns393zu",
				Wrapper: "B0932G-wzdOKwoaSaKsKU",
				wrapper: "B0932G-wzdOKwoaSaKsKU",
				isTopLevelComment: "_3-O087Fe8Gpv51vkui03iG",
				mRedesign: "dDb_knwHdpaUGniyi2rvM",
				FormWrapper: "_2LoNYeXgOQfq1adQ3jWSbi",
				formWrapper: "_2LoNYeXgOQfq1adQ3jWSbi",
				ResizableAutosizeTextarea: "AISc5olsWsxMr-ZvG8ywU",
				resizableAutosizeTextarea: "AISc5olsWsxMr-ZvG8ywU",
				mExpanded: "_2FiN5dLqiHVqs1l1NeoU-W",
				FormFooter: "OQubMtSYxy2qH2Q1upQvp",
				formFooter: "OQubMtSYxy2qH2Q1upQvp",
				userIcon: "_1LJWM5yPEtZv26nvbB_mvr",
				CurrentUserIcon: "_6R8kWvljXn9F_7IAh1RG4",
				currentUserIcon: "_6R8kWvljXn9F_7IAh1RG4",
				pending: "_1N53zdZlGyvjHMUoXkJa42",
				focused: "_2sPOgUISlhUYTMcHhUPCTP"
			}
		},
		"./src/reddit/components/CommentCreation/MarkdownCommentForm/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return ce
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-dom/index.js"),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/reddit/actions/comment/index.ts"),
				d = n("./src/reddit/components/AuthorLink/index.tsx"),
				u = n("./src/reddit/components/CommentCreation/NavigationModule/index.ts"),
				p = n("./src/reddit/components/CommentCreation/ToxicityWarningModal.tsx"),
				m = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = n("./src/reddit/components/MarkdownHelp/index.tsx"),
				b = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				f = n("./src/reddit/controls/ErrorText/index.tsx"),
				g = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				x = n("./src/reddit/icons/svgs/Help/index.tsx"),
				y = n("./src/reddit/components/CommentCreation/ExpandingFormDiv.tsx"),
				v = n("./src/reddit/components/CommentCreation/FormFooter/index.tsx"),
				C = n("./src/lib/fastdom/index.ts"),
				E = n("./src/reddit/components/CommentCreation/ToolbarSelector.m.less"),
				O = n.n(E),
				j = n("./src/lib/lessComponent.tsx");
			const w = 310,
				S = j.a.div("Container", O.a);
			class _ extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						toolbarType: null
					}, this.setContainerRef = e => this.container = e, this.selectToolbar = () => {
						const e = this.container && this.container.parentElement;
						if (!e) return;
						const {
							width: t
						} = e.getBoundingClientRect(), n = t < w ? "compact" : "full";
						n !== this.state.toolbarType && C.a.write(() => {
							this.setState({
								toolbarType: n
							})
						})
					}
				}
				componentDidMount() {
					C.a.read(this.selectToolbar), window.addEventListener("resize", this.selectToolbar)
				}
				componentWillUnmount() {
					window.removeEventListener("resize", this.selectToolbar)
				}
				render() {
					return r.a.createElement(S, {
						innerRef: this.setContainerRef
					}, this.state.toolbarType ? this.props.children(this.state.toolbarType) : null)
				}
			}
			var k = n("./src/reddit/icons/svgs/MarkdownMode/index.tsx"),
				T = n("./src/reddit/components/PostCreationForm/DivButton/index.tsx"),
				I = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				P = n("./src/reddit/components/CommentCreation/MarkdownCommentForm/MarkdownModeButton.m.less"),
				M = n.n(P);
			const N = j.a.wrapped(g.a, "LoadingIcon", M.a),
				R = j.a.div("Wrapper", M.a),
				L = j.a.wrapped(k.a, "MarkdownModeIcon", M.a),
				A = j.a.wrapped(T.a, "Button", M.a);

			function F(e) {
				const t = s.fbt._("Switch to fancy pants editor", null, {
					hk: "1XOb4H"
				});
				return r.a.createElement(R, null, r.a.createElement(A, {
					"aria-label": t,
					setRef: e.buttonRef,
					className: e.className,
					onClick: e.onClick
				}, e.isConverting && r.a.createElement(N, {
					sizePx: 12
				}), r.a.createElement(I.a, {
					text: t
				}), !e.isConverting && r.a.createElement(L, null)))
			}
			var D = n("./src/lib/classNames/index.ts"),
				B = n("./src/reddit/constants/keycodes.ts"),
				U = n("./src/reddit/components/CommentCreation/getCancelModalId.ts"),
				K = n("./src/reddit/constants/componentSizes.ts"),
				H = n("./src/reddit/constants/componentTestIds.ts"),
				V = n("./src/reddit/selectors/activeModalId.ts"),
				W = n("./src/reddit/selectors/comments.ts"),
				z = n("./src/reddit/selectors/editorContent.ts"),
				q = n("./src/reddit/actions/modal.ts"),
				G = n("./src/reddit/components/ResizableAutosizeTextarea/index.tsx"),
				J = n("./src/reddit/models/PostCreationForm/index.ts"),
				Q = n("./src/reddit/models/PostDraft/index.ts"),
				Z = n("./src/reddit/models/User/index.ts"),
				Y = n("./src/reddit/components/CommentCreation/MarkdownCommentForm/index.m.less"),
				X = n.n(Y);
			const $ = j.a.button("SwitchModeButton", X.a),
				ee = j.a.wrapped(g.a, "LoadingIcon", X.a),
				te = j.a.div("CommentHeader", X.a),
				ne = j.a.span("FormHeaderText", X.a),
				se = j.a.button("HelpButton", X.a),
				oe = j.a.wrapped(x.a, "HelpIcon", X.a),
				re = j.a.wrapped(G.a, "ResizableAutosizeTextarea", X.a),
				ie = j.a.wrapped(v.a, "FormFooter", X.a),
				ae = j.a.wrapped(b.a, "CurrentUserIcon", X.a),
				ce = e => r.a.createElement(se, {
					className: e.className,
					onClick: e.onClick
				}, r.a.createElement(oe, null)),
				le = 8,
				de = 16,
				ue = j.a.div("Wrapper", X.a),
				pe = j.a.div("FormWrapper", X.a),
				me = Object(a.b)(() => Object(c.c)({
					activeModalId: V.a,
					userName: e => e.user.account ? Object(Z.e)(e.user.account) : "",
					pending: (e, t) => e.comments.submit.pending[t.draftKey],
					draft: W.i,
					isConverting: (e, t) => Object(z.a)(e, t.draftKey)
				}), (e, t) => ({
					cancelModalToggled: () => e(Object(q.i)(Object(U.a)(t.draftKey))),
					helpModalToggled: () => e(Object(q.i)(h.b))
				}));
			class he extends r.a.Component {
				constructor(e) {
					super(e), this.textAreaRef = null, this.cancelForm = () => {
						this.props.onCancel(), this.onBlur()
					}, this.detectBreakout = () => {
						if (!this.wrapperEl || !this.wrapperEl.parentElement || this.props.isTopLevelComment) return;
						const e = this.wrapperEl.parentElement.getBoundingClientRect().width < K.c,
							t = this.getWrapperHeight();
						e === this.state.breakOut && t === this.state.wrapperHeight || C.a.write(() => {
							this.setState({
								breakOut: e,
								wrapperHeight: t
							})
						})
					}, this.focus = () => {
						this.textAreaRef && this.textAreaRef.focus()
					}, this.onChange = e => {
						const {
							value: t
						} = e.currentTarget;
						this.props.onChange && this.props.onChange({
							text: t,
							editorState: null
						}), this.setState(() => ({
							text: t,
							hasChanged: !0,
							showError: !1
						}), () => {
							C.a.read(this.detectBreakout)
						})
					}, this.shouldConfirmCancel = () => this.userHasEnteredText() && this.state.hasChanged && this.props.draftType === Q.c.edit, this.onCancel = () => {
						this.shouldConfirmCancel() ? this.props.cancelModalToggled() : this.cancelForm()
					}, this.onBlur = e => {
						(!e || e && e.relatedTarget !== this.switchModeBtn) && (this.textAreaRef && this.textAreaRef.blur(), this.props.onFocusChanged(!1))
					}, this.onFocus = () => {
						this.props.onFocus(), this.props.onFocusChanged(!0)
					}, this.handleKeyDown = e => {
						const {
							ctrlKey: t,
							metaKey: n,
							keyCode: s
						} = e;
						(t || n) && s === B.a.Enter && this.onSubmit()
					}, this.onSubmit = () => {
						this.props.onSubmit({
							commentMode: J.h.MARKDOWN,
							draftType: this.props.draftType,
							editorState: null,
							text: this.getCurrentText(),
							validate: this.props.showWarningModal
						}), this.onBlur()
					}, this.userHasEnteredText = () => {
						const {
							text: e
						} = this.state;
						return !!e.trim()
					}, this.setWrapperRef = e => {
						this.wrapperEl = e, this.props.editorElementRef && this.props.editorElementRef(e)
					}, this.setTextAreaRef = e => this.textAreaRef = e;
					const {
						draftType: t,
						hasError: n,
						initialText: o
					} = e;
					this.state = {
						text: o || "",
						autofocusDisabled: !1,
						hasChanged: !1,
						showError: n,
						breakOut: !1,
						wrapperHeight: void 0,
						formHeight: null,
						cancelModalText: t === Q.c.edit ? s.fbt._("Are you sure that you want to discard your edits?", null, {
							hk: "1ZfaWW"
						}) : s.fbt._("Are you sure that you want to discard your comment?", null, {
							hk: "3d8gJY"
						})
					}
				}
				componentDidMount() {
					this.props.onMount(), window.addEventListener("resize", this.detectBreakout), C.a.read(this.detectBreakout), C.a.write(() => {
						this.props.draft.hasFocus && this.textAreaRef && this.textAreaRef.focus()
					}), this.props.instanceRef && this.props.instanceRef(this)
				}
				componentWillUnmount() {
					this.props.onUnmount({
						text: this.getCurrentText()
					}), window.removeEventListener("resize", this.detectBreakout), this.props.instanceRef && this.props.instanceRef(null)
				}
				componentDidUpdate(e) {
					const t = e.pending,
						{
							hasError: n,
							pending: s
						} = this.props;
					t && !s && !n ? this.setState({
						text: "",
						showError: !1
					}) : e.hasError !== this.props.hasError && this.setState({
						showError: this.props.hasError
					})
				}
				getCurrentText() {
					const {
						draft: e
					} = this.props, t = e && e.text;
					return this.state.text || t
				}
				getWrapperHeight() {
					if (!this.textAreaRef) return;
					const e = Object(i.findDOMNode)(this.textAreaRef);
					return e instanceof Element ? e.getBoundingClientRect().height + le + de + K.o : void 0
				}
				render() {
					const {
						activeModalId: e,
						autofocus: t,
						cancelModalToggled: n,
						className: o,
						disableAutofocus: i,
						depth: a,
						draft: c,
						draftKey: b,
						draftType: g,
						errorMsgs: x,
						pending: v,
						modalSeen: C,
						submitButtonText: E,
						isCommentBoxDesignEnabled: O,
						isExpanded: j,
						isTopLevelComment: w,
						onSwitchMode: S,
						userName: k
					} = this.props, {
						cancelModalText: T,
						showError: I,
						text: P,
						breakOut: M,
						wrapperHeight: N
					} = this.state, R = Object(U.a)(b), L = c.draftType === Q.c.edit;
					return r.a.createElement(ue, {
						"data-test-id": H.b,
						className: Object(D.a)(o, {
							[X.a.isTopLevelComment]: w,
							[X.a.mExpanded]: j,
							[X.a.mRedesign]: O
						}),
						ref: this.setWrapperRef,
						style: {
							height: M ? N : void 0
						}
					}, !O && w && r.a.createElement(te, null, r.a.createElement(ne, null, s.fbt._("Comment as {authorLink}", [s.fbt._param("authorLink", r.a.createElement(d.a, {
						author: k,
						isAdmin: !1,
						isAdminEmeritus: !1,
						isAuthorDeleted: !1,
						isMod: !1,
						isOp: !1
					}, k))], {
						hk: "4pMWAk"
					}))), r.a.createElement(y.a, {
						breakOut: M,
						depth: a,
						isEditing: L
					}, O && r.a.createElement("div", {
						className: X.a.userIcon
					}, r.a.createElement(ae, null)), r.a.createElement(pe, {
						className: Object(D.a)({
							[X.a.pending]: v,
							[X.a.focused]: c.hasFocus
						})
					}, r.a.createElement(re, {
						innerRef: this.setTextAreaRef,
						autoFocus: t && !i,
						disabled: v,
						initialHeight: this.props.initialHeight,
						onBlur: this.onBlur,
						onChange: this.onChange,
						onEditorResize: this.props.onEditorResize,
						onFocus: this.onFocus,
						onKeyDown: this.handleKeyDown,
						placeholder: O ? s.fbt._("Add a comment", null, {
							hk: "39ZBm0"
						}) : s.fbt._("What are your thoughts?", null, {
							hk: "4or1AH"
						}),
						value: P
					}), (!O || j) && r.a.createElement(ie, {
						cancelButtonEnabled: g !== Q.c.replyToPost,
						onSubmit: this.onSubmit,
						onCancel: this.onCancel,
						pending: v,
						submitButtonText: E,
						canSubmit: this.userHasEnteredText()
					}, r.a.createElement(_, null, e => "compact" === e ? r.a.createElement(F, {
						buttonRef: e => this.switchModeBtn = e,
						onClick: () => S(J.h.RICH_TEXT, P, b),
						isConverting: this.props.isConverting
					}) : r.a.createElement("div", null, r.a.createElement($, {
						innerRef: e => this.switchModeBtn = e,
						onClick: () => S(J.h.RICH_TEXT, P, b)
					}, "Switch to Fancy Pants Editor", this.props.isConverting && r.a.createElement(ee, {
						sizePx: 12
					})))), r.a.createElement(ce, {
						onClick: this.props.helpModalToggled
					})))), I && Object(f.c)(x), e === R && r.a.createElement(m.a, {
						actionText: s.fbt._("Discard", null, {
							hk: "1kJ5PR"
						}),
						cancelActionText: s.fbt._("keep", null, {
							hk: "J0ER1"
						}),
						modalText: T,
						onConfirm: () => this.cancelForm(),
						toggleModal: n,
						trackClick: () => {}
					}), e === h.b && r.a.createElement(h.a, null), e === l.qb && r.a.createElement(p.a, {
						onSubmit: this.onSubmit,
						modalSeen: C,
						withOverlay: !0
					}), r.a.createElement(u.a, {
						editKey: b,
						hasValue: !!P
					}))
				}
			}
			t.b = me(he)
		},
		"./src/reddit/components/CommentCreation/NavigationModule/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-router/esm/react-router.js");
			let a = null;
			class c extends r.a.PureComponent {
				constructor() {
					super(...arguments), this.unblock = e => {
						c.blockers.delete(e), c.blockers.size || (a && a(), a = null, window.removeEventListener("beforeunload", c.navigationBlocker))
					}
				}
				componentDidUpdate(e) {
					!e.hasValue && this.props.hasValue ? this.block(this.props.editKey) : e.hasValue && !this.props.hasValue && this.unblock(this.props.editKey)
				}
				componentWillUnmount() {
					this.unblock(this.props.editKey)
				}
				componentDidMount() {
					this.props.hasValue && this.block(this.props.editKey)
				}
				block(e) {
					c.blockers.add(e), a || (window.addEventListener("beforeunload", c.navigationBlocker), a = this.props.history.block(() => {
						const e = this.props.isPostEdit ? s.fbt._("You have a post edit in progress, are you sure you want to discard it?", null, {
							hk: "4u5L7p"
						}) : s.fbt._("You have a comment in progress, are you sure you want to discard it?", null, {
							hk: "rgscd"
						});
						return window.confirm(e) ? void 0 : s.fbt._("Are you sure you want to leave?", null, {
							hk: "1Ua5kc"
						})
					}))
				}
				render() {
					return null
				}
			}
			c.blockers = new Set, c.navigationBlocker = e => {
				const t = "Are you sure you want to leave?";
				return e.returnValue = t, t
			}, t.a = Object(i.i)(c)
		},
		"./src/reddit/components/CommentCreation/ToolbarSelector.m.less": function(e, t, n) {
			e.exports = {
				Container: "_1XC-wMQsKPqfaPcfWQCZdW",
				container: "_1XC-wMQsKPqfaPcfWQCZdW"
			}
		},
		"./src/reddit/components/CommentCreation/ToxicityWarningModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/uuid/v4.js"),
				a = n.n(i),
				c = n("./src/higherOrderComponents/asModal/index.tsx"),
				l = n("./src/reddit/actions/comment/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				p = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/controls/TextButton/index.tsx"),
				h = n("./src/reddit/constants/tracking.ts"),
				b = n("./src/reddit/selectors/telemetry.ts");
			const f = e => Object.assign(Object.assign({
					source: "toxicity_modal"
				}, b.defaults(e)), {
					screen: b.screen(e),
					subreddit: b.subreddit(e)
				}),
				g = e => t => Object.assign({
					action: h.c.VIEW,
					noun: "modal",
					correlationId: e
				}, f(t)),
				x = e => t => Object.assign({
					action: h.c.CLICK,
					noun: "submit",
					correlationId: e
				}, f(t)),
				y = e => t => Object.assign({
					action: h.c.CLICK,
					noun: "edit",
					correlationId: e
				}, f(t)),
				v = e => t => Object.assign({
					action: h.c.CLICK,
					noun: "close",
					correlationId: e
				}, f(t));
			var C = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");
			const {
				fbt: E
			} = n("./node_modules/fbt/lib/FbtPublic.js"), O = Object(r.b)(null, (e, t) => ({
				closeModal: () => {
					e(Object(d.g)(l.qb))
				},
				continue: () => {
					t.onSubmit()
				}
			}));
			class j extends o.a.Component {
				constructor(e) {
					super(e), this.state = {
						correlationId: a()()
					}
				}
				componentDidMount() {
					this.props.modalSeen(), this.props.sendEvent(g(this.state.correlationId))
				}
				render() {
					return o.a.createElement(u.d, null, o.a.createElement(u.h, null, o.a.createElement(C.a, null, o.a.createElement(u.p, null, E._("Are you sure you want to post that?", null, {
						hk: "4yXqtu"
					})), o.a.createElement(m.a, {
						onClick: () => {
							this.props.sendEvent(v(this.state.correlationId)), this.props.closeModal()
						}
					}, o.a.createElement(u.b, null)))), o.a.createElement(u.k, null, o.a.createElement(u.o, null, E._("A reminder from the mods: Please follow community rules when commenting.", null, {
						hk: "Hdi9f"
					}))), o.a.createElement(u.f, null, o.a.createElement(u.a, {
						onClick: () => {
							this.props.sendEvent(y(this.state.correlationId)), this.props.closeModal()
						},
						"data-redditstyle": !0
					}, E._("Go back and edit", null, {
						hk: "3nGNI7"
					})), o.a.createElement(u.q, {
						onClick: () => {
							this.props.sendEvent(x(this.state.correlationId)), this.props.continue()
						},
						"data-redditstyle": !0
					}, E._("Comment", null, {
						hk: "1leYg7"
					}))))
				}
			}
			t.a = Object(c.a)(O(Object(p.c)(j)))
		},
		"./src/reddit/components/CommentCreation/getCancelModalId.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => "Comment-cancelModal__".concat(e)
		},
		"./src/reddit/components/ConfirmUserActionModal/index.m.less": function(e, t, n) {
			e.exports = {
				buttonWidth: "ogOEj4x-0BpDZWeccJwxx",
				ModalText: "_2YxEi97B6Nm7NCgLG6pCud",
				modalText: "_2YxEi97B6Nm7NCgLG6pCud"
			}
		},
		"./src/reddit/components/ConfirmUserActionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = n("./src/reddit/controls/TextButton/index.tsx"),
				l = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				d = n("./src/reddit/components/ConfirmUserActionModal/index.m.less"),
				u = n.n(d);
			const p = e => e.preventDefault();
			t.a = Object(i.a)(e => r.a.createElement(a.d, null, r.a.createElement(a.h, null, r.a.createElement(l.a, null, r.a.createElement(a.p, null, e.headerText || s.fbt._("Confirm", null, {
				hk: "2zlvKa"
			})), r.a.createElement(c.a, {
				onClick: () => {
					e.onClose && e.onClose(), e.toggleModal && e.toggleModal()
				}
			}, r.a.createElement(a.b, null)))), r.a.createElement(a.k, null, r.a.createElement(a.o, {
				className: u.a.ModalText
			}, e.modalText)), r.a.createElement(a.f, null, !e.hideCancelButton && r.a.createElement(a.a, {
				className: u.a.buttonWidth,
				onMouseDown: p,
				onClick: () => {
					e.onCancel && e.onCancel(), e.toggleModal && e.toggleModal()
				},
				"data-redditstyle": !e.disableRedditStyle
			}, e.cancelActionText || s.fbt._("Cancel", null, {
				hk: "2TSLl5"
			})), r.a.createElement(a.t, {
				className: u.a.buttonWidth,
				onMouseDown: p,
				onClick: t => {
					e.onConfirm(), e.toggleModal && e.toggleModal(), e.trackClick && e.trackClick()
				},
				"data-redditstyle": !e.disableRedditStyle
			}, e.actionText))))
		},
		"./src/reddit/components/ContributorRequestFlow/ContributorRequestButton.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/constants/modals.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/helpers/trackers/restrictedCommunity.ts"),
				h = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				f = n("./src/reddit/components/ContributorRequestFlow/index.m.less"),
				g = n.n(f);
			const x = Object(a.c)({
				restrictions: b.q
			});
			class y extends r.a.Component {
				constructor() {
					super(...arguments), this.onRequest = () => {
						this.props.sendEvent(Object(m.a)(this.props.eventSource)), this.props.openContributorRequestModal()
					}
				}
				render() {
					return r.a.createElement(p.f, {
						className: Object(c.a)(this.props.smallButton ? null : g.a.RequestButton, this.props.className),
						onClick: this.onRequest
					}, this.props.eventSource === h.b.Comment ? s.fbt._("Request to comment", null, {
						hk: "3KqraC"
					}) : s.fbt._("Request to post", null, {
						hk: "3rSHPr"
					}))
				}
			}
			t.a = Object(i.b)(x, e => ({
				openContributorRequestModal: () => e(Object(l.i)(u.a.CONTRIBUTOR_REQUEST))
			}))(Object(d.c)(y))
		},
		"./src/reddit/components/ContributorRequestFlow/index.m.less": function(e, t, n) {
			e.exports = {
				RequestButton: "_33axOHPa8DzNnTmwzen-wO",
				requestButton: "_33axOHPa8DzNnTmwzen-wO"
			}
		},
		"./src/reddit/components/CrosspostBox/index.m.less": function(e, t, n) {
			e.exports = {
				mediaContainer: "P8p9Nku0-ZbYCsaCOSE2t",
				Container: "_2ED-O3JtIcOqp8iIL1G5cg",
				container: "_2ED-O3JtIcOqp8iIL1G5cg",
				PostMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				postMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				PostTitle: "_2akYJO5RtMK_ptA408seyG",
				postTitle: "_2akYJO5RtMK_ptA408seyG",
				FlatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				flatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				FlatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				flatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				FlatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				flatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				LinkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				linkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				Content: "_379A_08LTBsR4c8POTldR_",
				content: "_379A_08LTBsR4c8POTldR_",
				ThumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX",
				thumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX"
			}
		},
		"./src/reddit/components/CrosspostBox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				d = n("./src/lib/prettyPrintNumber/index.ts"),
				u = n("./src/reddit/components/Media/index.tsx"),
				p = n("./src/reddit/components/PostMeta/index.tsx"),
				m = n("./src/reddit/components/PostTitle/index.tsx"),
				h = n("./src/reddit/components/SourceLink/index.tsx"),
				b = n("./src/reddit/components/Thumbnail/index.tsx"),
				f = n("./src/lib/constants/index.ts"),
				g = n("./src/reddit/selectors/posts.ts"),
				x = n("./src/reddit/selectors/user.ts"),
				y = n("./src/reddit/components/CrosspostBox/index.m.less"),
				v = n.n(y),
				C = n("./src/lib/lessComponent.tsx");

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const O = C.a.div("Container", v.a),
				j = C.a.div("PostMetaWrapper", v.a),
				w = C.a.wrapped(m.c, "PostTitle", v.a),
				S = C.a.div("FlatList", v.a),
				_ = C.a.div("FlatItem", v.a),
				k = C.a.span("FlatListDotSpacer", v.a),
				T = C.a.wrapped(O, "LinkContainer", v.a),
				I = C.a.div("Content", v.a),
				P = C.a.div("ThumbnailContainer", v.a),
				M = Object(c.c)({
					isCurrentUserProfilePost: g.k,
					isTopicPage: e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== f.Bb.TOPIC),
					post: g.N,
					shouldOpenPostInNewTab: x.U,
					subreddit: g.ab
				}),
				N = Object(i.b)(M);
			t.a = N(e => {
				const {
					className: t,
					isCurrentUserProfilePost: n,
					isTopicPage: s,
					mediaProps: o,
					post: i,
					subreddit: a
				} = e;
				if (!i) return null;
				const c = {
						post: i,
						hideGildCta: !0,
						inSubredditOrProfile: !1,
						isCurrentUserProfilePost: n,
						isTopicPage: s,
						shouldShowSubscribeButton: !1,
						subredditOrProfile: a,
						tooltipType: "".concat("CrosspostBox", "--").concat(o.isListing)
					},
					l = t;
				return i && !i.media ? r.a.createElement(T, {
					className: l
				}, r.a.createElement(I, null, r.a.createElement(j, null, r.a.createElement(p.a, c)), R(i), i.source && r.a.createElement(h.a, {
					post: i
				}), A(e)), D(e)) : r.a.createElement(O, {
					className: l
				}, r.a.createElement(j, null, r.a.createElement(p.a, c)), R(i), L(e), A(e))
			});
			const R = e => r.a.createElement(w, {
					isCrosspost: !0,
					post: e,
					shouldLinkWrap: !0,
					size: m.b.Small
				}),
				L = e => {
					const {
						mediaProps: t,
						post: n
					} = e, s = Object.assign(Object.assign({}, t), {
						post: n,
						crosspost: t.post
					});
					return r.a.createElement("div", null, r.a.createElement(u.a, E({}, s, {
						className: v.a.mediaContainer
					})))
				},
				A = e => {
					const {
						post: t
					} = e, {
						score: n
					} = t;
					return r.a.createElement(S, null, r.a.createElement(_, null, s.fbt._({
						"*": "{point count} points",
						_1: "1 point"
					}, [s.fbt._plural(n, "point count", Object(d.b)(n))], {
						hk: "PNZhd"
					})), r.a.createElement(k, null), r.a.createElement(_, null, F(e)))
				},
				F = e => {
					const {
						post: t,
						shouldOpenPostInNewTab: n
					} = e, {
						numComments: o
					} = t;
					return r.a.createElement(a.a, {
						"data-click-id": "comments",
						to: Object(l.a)(t.permalink, !0),
						target: n ? "_blank" : void 0
					}, s.fbt._({
						"*": "{comment count} comments",
						_1: "1 comment"
					}, [s.fbt._plural(o, "comment count", Object(d.b)(o))], {
						hk: "xPYWL"
					}))
				},
				D = e => r.a.createElement(P, null, r.a.createElement(b.a, {
					post: e.post
				}))
		},
		"./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				badge: "ekl2maIRbrCrsYFt1OwaE"
			}
		},
		"./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/economics/subredditPremium/actionCreators.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				d = n("./src/reddit/components/Badges/UserDisplay/index.tsx"),
				u = n("./src/reddit/featureFlags/index.ts"),
				p = n("./src/reddit/selectors/economics.ts"),
				m = n("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.m.less"),
				h = n.n(m);

			function b(e) {
				const {
					badges: t
				} = e;
				return t.length ? o.a.createElement(d.b, {
					useHovercard: !0,
					badges: t,
					className: Object(a.a)(e.className, h.a.badge),
					uniqueIdentifier: e.uniqueIdentifier,
					showAddCustom: e.customBadgesEnabled && e.premiumEnabled && e.showAddCustom && t.length < 2 && e.accountId === e.userId,
					subredditId: e.subredditId,
					userId: e.userId,
					onShowTooltip: e.onShowTooltip,
					onHideTooltip: e.onHideTooltip,
					onOpenUploadDialog: e.onOpenUploadDialog
				}) : null
			}
			t.b = Object(r.b)(() => Object(i.c)({
				accountId: e => e.user.account ? e.user.account.id : void 0,
				badges: (e, t) => {
					let {
						subredditId: n,
						userId: s
					} = t;
					return Object(p.r)(e, n, s)
				},
				customBadgesEnabled: u.d.spCustomBadgesAndEmotes,
				premiumEnabled: e => u.d.spSpecialMemberships(e)
			}), e => ({
				onShowTooltip: t => e(Object(l.f)({
					tooltipId: t
				})),
				onHideTooltip: () => e(Object(l.i)()),
				onOpenUploadDialog: () => e(Object(c.j)())
			}))(b)
		},
		"./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/selectors/economics.ts");

			function c(e) {
				const {
					badges: t
				} = e, n = t[t.length - 1];
				return n && !e.ignore ? o.a.cloneElement(e.children, {
					style: n.extra && n.extra.style && n.extra.style.color ? Object.assign(Object.assign({}, e.children.props.style || {}), {
						color: n.extra.style.color,
						fontWeight: 700
					}) : e.children.props.style
				}) : e.children
			}
			t.b = Object(r.b)(() => Object(i.c)({
				badges: (e, t) => {
					let {
						subredditId: n,
						userId: s
					} = t;
					return Object(a.r)(e, n, s)
				}
			}))(c)
		},
		"./src/reddit/components/Emoji/index.m.less": function(e, t, n) {
			e.exports = {
				EmojiDisplay: "_2Gt13AX94UlLxkluAMsZqP",
				emojiDisplay: "_2Gt13AX94UlLxkluAMsZqP"
			}
		},
		"./src/reddit/components/Flair/index.m.less": function(e, t, n) {
			e.exports = {
				FlairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				flairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				FlairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				flairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				TextFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				textFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				transparentBackgroundColor: "_39BEcWjOlYi1QGcJil6-yl",
				RichTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				richTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				MetaFlair: "_1wzhGvvafQFOWAyA157okr",
				metaFlair: "_1wzhGvvafQFOWAyA157okr",
				CloseButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				closeButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				CloseIcon: "_2cvySYWkqJfynvXFOpNc5L",
				closeIcon: "_2cvySYWkqJfynvXFOpNc5L",
				small: "aJrgrewN9C8x1Fusdx4hh",
				large: "_1wj6zoMi6hRP5YhJ8nXWXE",
				flairVariant: "_2VqfzH0dZ9dIl3XWNxs42y"
			}
		},
		"./src/reddit/components/Flair/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return H
			})), n.d(t, "a", (function() {
				return V
			})), n.d(t, "b", (function() {
				return G
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/pick.js"),
				r = n.n(o),
				i = n("./node_modules/polished/dist/polished.es.js"),
				a = n("./node_modules/react/index.js"),
				c = n.n(a),
				l = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				p = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				m = n("./src/lib/lessComponent.tsx"),
				h = n("./src/reddit/components/Emoji/index.m.less"),
				b = n.n(h);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var g = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const x = m.a.wrapped(e => {
				var {
					backgroundImage: t,
					style: n
				} = e, s = g(e, ["backgroundImage", "style"]);
				return c.a.createElement("div", f({
					style: Object.assign(Object.assign({}, n || {}), {
						backgroundImage: "url('".concat(t, "')")
					})
				}, s))
			}, "EmojiDisplay", b.a);
			var y = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				v = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				C = n("./src/reddit/constants/colors.ts"),
				E = n("./src/reddit/constants/parameters.ts"),
				O = n("./src/reddit/controls/InternalLink/index.tsx"),
				j = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				w = n("./src/reddit/icons/svgs/Close/index.tsx"),
				S = n("./src/reddit/models/Flair/index.ts"),
				_ = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				k = n("./src/reddit/components/Flair/index.m.less"),
				T = n.n(k);

			function I() {
				return (I = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var P = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const M = Object(v.a)(y.b),
				N = m.a.div("FlairWrapper", T.a),
				R = m.a.wrapped(l.a, "CloseButton", T.a),
				L = m.a.wrapped(Object(p.a)(e => {
					var {
						forceSmallEmojis: t,
						theme: n
					} = e, s = P(e, ["forceSmallEmojis", "theme"]);
					const o = n;
					return c.a.createElement(x, I({
						style: Object.assign({}, A(!!t, o) || {})
					}, s))
				}), "FlairEmojiDisplay", T.a),
				A = (e, t) => {
					if (!e && !!t.subredditContext.emojiHeight && !!t.subredditContext.emojiWidth) return {
						height: "".concat(t.subredditContext.emojiHeight, "px"),
						width: "".concat(t.subredditContext.emojiWidth, "px")
					}
				},
				F = (e, t) => {
					const n = t ? "/r/".concat(t, "/search") : "/search",
						s = "".concat(t ? "flair_name" : "flair", ':"').concat(e, '"');
					return Object(d.a)(n, {
						[E.p]: s,
						[E.q]: t ? "1" : ""
					})
				},
				D = e => e.isFlairFilter ? c.a.createElement(O.a, {
					onMouseDown: e.onMouseDown,
					to: e.to || ""
				}, e.flair) : e.onClick ? c.a.createElement(O.a, {
					onClick: () => e.onClick(e.searchableTerm),
					to: F(e.searchableTerm, e.subredditName)
				}, e.flair) : e.flair;
			class B extends c.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.state = {
						isTooltipOpen: !1
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							isTooltipOpen: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							isTooltipOpen: !1
						})
					}
				}
				render() {
					const e = c.a.createElement("span", {
						className: Object(u.a)(this.props.className, {
							[T.a.transparentBackgroundColor]: "transparent" === this.props.backgroundColor
						}),
						onMouseEnter: this.props.tooltip ? this.onShowTooltip : void 0,
						onMouseLeave: this.props.tooltip ? this.onHideTooltip : void 0,
						ref: this.setTooltipTargetRef,
						style: {
							backgroundColor: this.props.backgroundColor || Object(_.a)(this.props).flair,
							color: "".concat(H(this.props))
						}
					}, this.props.text, this.props.isSelected && c.a.createElement(R, {
						to: "./",
						onClick: this.props.onCloseClick
					}, c.a.createElement(w.a, {
						className: T.a.CloseIcon,
						style: {
							fill: this.props.backgroundColor || Object(_.a)(this.props).flair
						}
					})), !!this.props.tooltip && c.a.createElement(M, {
						text: this.props.tooltip,
						isOpen: this.state.isTooltipOpen,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: ["center", "top"],
						tooltipPosition: ["center", "bottom"]
					}));
					return c.a.createElement(D, {
						flair: e,
						isFlairFilter: this.props.isFlairFilter,
						onClick: this.props.onClick,
						onMouseDown: this.props.onMouseDown,
						searchableTerm: this.props.text,
						subredditName: this.props.subredditName,
						to: this.props.to
					})
				}
			}
			const U = Object(p.a)(B),
				K = Object(p.a)(e => {
					let t = "",
						n = !1;
					const s = e.richtext.map((s, o) => {
						if (s.e === S.c.Emoji) {
							const r = s;
							return t += r.a, n = !0, c.a.createElement(L, {
								forceSmallEmojis: e.forceSmallEmojis,
								backgroundImage: r.u,
								key: o,
								title: r.a
							})
						} {
							const e = s;
							return t += e.t, c.a.createElement("span", {
								key: o
							}, e.t)
						}
					});
					let o;
					n && !e.forceSmallEmojis && e.theme && e.theme.subredditContext.emojiWidth && e.theme.subredditContext.emojiHeight && e.theme.subredditContext.emojiHeight > 16 && (o = {
						marginTop: "-".concat(e.theme.subredditContext.emojiHeight - 16, "px")
					});
					const r = c.a.createElement(N, {
						className: Object(u.a)(e.className, {
							[T.a.transparentBackgroundColor]: "transparent" === e.backgroundColor
						}),
						style: Object.assign(Object.assign({}, o), {
							backgroundColor: e.backgroundColor || Object(_.a)(e).flair,
							color: "".concat(H(e))
						})
					}, s, e.isSelected && c.a.createElement(R, {
						to: "./",
						onClick: e.onCloseClick
					}, c.a.createElement(w.a, {
						className: T.a.CloseIcon,
						style: {
							fill: e.backgroundColor || Object(_.a)(e).flair
						}
					})));
					return c.a.createElement(D, {
						flair: r,
						isFlairFilter: e.isFlairFilter,
						onClick: e.onClick ? () => {
							e.onClick(t)
						} : void 0,
						onMouseDown: e.onMouseDown,
						searchableTerm: t,
						subredditName: e.subredditName,
						to: e.to
					})
				}),
				H = e => !e.textColor || e.textColor && !e.backgroundColor ? Object(_.a)(e).postFlairText : "transparent" === e.backgroundColor ? Object(j.a)(Object(_.a)(e).post, C.a.black, C.a.white) : e.textColor === S.e.Dark ? C.a.black : C.a.white,
				V = m.a.wrapped(U, "TextFlair", T.a),
				W = m.a.wrapped(K, "RichTextFlair", T.a),
				z = e => {
					switch (e.type) {
						case "spoiler":
							return "#A4A7A8";
						case "nsfw":
							return "#FF585B";
						default:
							return Object(i.j)(.1, Object(_.a)(r()(e, "theme", "redditStyle", "data-redditstyle")).button)
					}
				},
				q = m.a.wrapped(e => {
					const t = z(e),
						n = c.a.createElement("span", {
							className: e.className,
							style: {
								border: "1px solid ".concat(t),
								color: t
							}
						}, e.text);
					return c.a.createElement(D, {
						flair: n,
						searchableTerm: e.text
					})
				}, "MetaFlair", T.a);

			function G(e) {
				const {
					className: t,
					disabled: n = !1,
					flair: o,
					isFlairFilter: r,
					isSelected: i,
					onClick: a,
					onCloseClick: l,
					onMouseDown: d,
					subredditName: p,
					usesCommunityStyles: m,
					forceSmallEmojis: h,
					to: b
				} = e, f = Object(u.a)({
					[T.a.flairVariant]: r,
					[T.a.small]: r && !e.large,
					[T.a.large]: r && e.large
				}, t);
				switch (o.type) {
					case S.f.Richtext:
						return n || !o.richtext ? null : c.a.createElement(W, {
							backgroundColor: o.backgroundColor,
							className: f,
							forceSmallEmojis: h,
							isFlairFilter: r,
							isSelected: i,
							onClick: a,
							onCloseClick: l,
							onMouseDown: d,
							redditStyle: !m,
							richtext: o.richtext,
							subredditName: p,
							textColor: o.textColor,
							to: b
						});
					case S.f.Text:
						return n || !o.text ? null : c.a.createElement(V, {
							backgroundColor: o.backgroundColor,
							className: f,
							isFlairFilter: r,
							isSelected: i,
							onClick: a,
							onCloseClick: l,
							onMouseDown: d,
							subredditName: p,
							text: o.text,
							textColor: o.textColor,
							redditStyle: !m,
							to: b
						});
					case S.f.Meta:
						return c.a.createElement(V, {
							backgroundColor: o.backgroundColor,
							className: t,
							isFlairFilter: r,
							subredditName: p,
							text: o.text,
							textColor: o.textColor,
							redditStyle: !m,
							to: b
						});
					case S.f.Nsfw:
					case S.f.Spoiler:
						return c.a.createElement(q, {
							className: t,
							text: o.text,
							type: o.type
						});
					case S.f.Quarantined:
						return null;
					case S.f.Oc:
						return c.a.createElement(V, {
							backgroundColor: C.a.alienblue,
							text: o.text,
							textColor: S.e.Light,
							tooltip: s.fbt._("This post is marked as Original Content [OC]", null, {
								hk: "h7je6"
							})
						});
					default:
						return o.text ? c.a.createElement(V, {
							backgroundColor: o.backgroundColor,
							className: f,
							isFlairFilter: r,
							onClick: a,
							onCloseClick: l,
							onMouseDown: d,
							subredditName: p,
							text: o.text,
							redditStyle: !m,
							to: b
						}) : null
				}
			}
		},
		"./src/reddit/components/FlairList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/reddit/components/Flair/index.tsx"),
				d = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const m = Object(c.c)({
					labelNSFW: p.P
				}),
				h = Object(a.b)(m),
				b = e => {
					if (e.type === u.f.Richtext && e.richtext) {
						const t = e.richtext.map(e => e.e === u.c.Emoji ? e.u : e.t).join("-");
						return "".concat(e.type, "--").concat(t)
					}
					return "".concat(e.type, "--").concat(e.text)
				};
			t.a = h(e => {
				let {
					className: t,
					isFlairFilter: n,
					onClick: s,
					onMouseDown: r,
					disabled: a = !1,
					flair: c,
					labelNSFW: p,
					subredditName: m
				} = e;
				const h = !!c.find(e => e.type === u.f.Richtext),
					f = c.map(e => {
						if (e.type === u.f.Text && h) return null;
						if (!p && e.type === u.f.Nsfw) return null;
						const t = Object(d.j)(e),
							c = "/r/".concat(m, "/"),
							f = r ? () => r(e) : o.a;
						return i.a.createElement(l.b, {
							isFlairFilter: n,
							key: b(e),
							onClick: s,
							onMouseDown: f,
							disabled: a,
							flair: e,
							forceSmallEmojis: !0,
							subredditName: m,
							to: Object(d.e)(c, t)
						})
					});
				return i.a.createElement("div", {
					className: t
				}, f)
			})
		},
		"./src/reddit/components/FlairPickerTitle/index.m.less": function(e, t, n) {
			e.exports = {
				modalHeader: "_26bOTAKvGixX5tMC3vGfTv"
			}
		},
		"./src/reddit/components/FlairPickerTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = n("./src/reddit/controls/TextButton/index.tsx"),
				l = n("./src/reddit/components/FlairPickerTitle/index.m.less"),
				d = n.n(l);
			t.a = e => i.a.createElement(a.h, {
				className: d.a.modalHeader
			}, i.a.createElement(a.p, null, e.title), i.a.createElement(c.a, {
				onClick: e.onClosePressed || o.a
			}, i.a.createElement(a.b, null)))
		},
		"./src/reddit/components/FlairPickerWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3nRJIwLuth2pKYrXnr2jPN",
				wrapper: "_3nRJIwLuth2pKYrXnr2jPN"
			}
		},
		"./src/reddit/components/FlairPickerWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/components/FlairPickerWrapper/index.m.less"),
				r = n.n(o);
			const i = s.a.div("Wrapper", r.a);
			t.a = i
		},
		"./src/reddit/components/FlairPreview/index.m.less": function(e, t, n) {
			e.exports = {
				Placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				SelectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				selectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				FlairComponent: "vynkb69RQyUY-PA6bCaW0",
				flairComponent: "vynkb69RQyUY-PA6bCaW0"
			}
		},
		"./src/reddit/components/FlairPreview/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Flair/index.tsx"),
				c = n("./src/reddit/components/FlairPreview/index.m.less"),
				l = n.n(c);
			const d = i.a.span("Placeholder", l.a),
				u = i.a.div("SelectedFlair", l.a),
				p = i.a.wrapped(a.b, "FlairComponent", l.a);
			t.a = e => e.flair ? r.a.createElement(u, null, r.a.createElement(d, null, s.fbt._("{placeholder}", [s.fbt._param("placeholder", e.placeholderText)], {
				hk: "4G6VRy"
			})), r.a.createElement(p, {
				flair: e.flair,
				forceSmallEmojis: !0
			})) : r.a.createElement(u, null, s.fbt._("No flair selected", null, {
				hk: "1XPXbv"
			}))
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.m.less": function(e, t, n) {
			e.exports = {
				FlairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				flairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				isCompact: "_3YjPWOd9tK9O_DN50RI_FN"
			}
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/lodash/once.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/higherOrderComponents/makeAsync.tsx"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				d = n("./src/lib/loadWithRetries/index.ts"),
				u = n("./src/reddit/components/FlairSearch/FlairEdit/helper.m.less"),
				p = n.n(u);
			const m = l.a.wrapped(e => i.a.createElement("div", {
					className: Object(c.a)(e.className, {
						[p.a.isCompact]: e.isCompact
					})
				}), "FlairEditStub", p.a),
				h = o()((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m;
					return Object(a.a)({
						getComponent: () => Object(d.a)(() => Promise.all([n.e("vendors~ChatMessageInput~FlairEdit~MembershipPaywallPage~PostCreation~RichTextEditor"), n.e("FlairEdit")]).then(n.bind(null, "./src/reddit/components/FlairSearch/FlairEdit/index.tsx")).then(e => e.default)),
						ErrorComponent: e,
						LoadingComponent: e
					})
				}))
		},
		"./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1bdAduczElF9-gLoCvHz-p",
				flairComponent: "_2leID3tMN8hpvVd4XhEqTl",
				radioOption: "FJIE5E2gciCA8q3Jzvcyg",
				pencil: "_3H_wwe03-Fkrm6oWGakXI8",
				searchBoxWrapper: "_18cuM8Uu7RcIFu1bCT0r4t",
				searchIcon: "_2bECVWL_WJ9RGBx7-RnzfO",
				searchInput: "_1nQbRaoAvb6Uy0oI-OfDtZ"
			}
		},
		"./src/reddit/components/FlairSearch/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2AKP6aCod0Z6TuXXfc1ZqL",
				buttonsRow: "_3w7b_fPwMuVD17J7epjTXi",
				clearButton: "_3WykjMvdVO5xibqd5xlfTC",
				flairEditSection: "SVd7IxchgiWetdYbftTHx",
				editLabel: "KTa3kg9lzGPUeLuhAHMT_",
				restrictionHintText: "_1fV9kJfKnED9qQ2AF8f3iT"
			}
		},
		"./src/reddit/components/FlairSearch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/memoizeByReference/index.ts"),
				d = n("./src/reddit/featureFlags/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				p = n("./src/reddit/selectors/moderatorPermissions.ts"),
				m = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				h = n("./src/reddit/components/Flair/index.tsx"),
				b = n("./src/reddit/controls/RadioInput/index.tsx"),
				f = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				g = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				x = n("./src/reddit/icons/svgs/Search/index.tsx"),
				y = n("./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less"),
				v = n.n(y);
			class C extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						searchQuery: ""
					}, this.onSearchChange = e => {
						this.setState({
							searchQuery: e.target.value
						})
					}
				}
				render() {
					const {
						templates: e,
						templateIds: t,
						selectedTemplateId: n
					} = this.props, {
						searchQuery: o
					} = this.state, i = t.map(t => e[t]).filter(e => e.text.toLowerCase().includes(o)), a = !!n && i.some(e => e.id === n);
					return r.a.createElement("div", {
						className: v.a.container
					}, r.a.createElement("div", {
						className: v.a.searchBoxWrapper
					}, r.a.createElement("input", {
						className: v.a.searchInput,
						onChange: this.onSearchChange,
						type: "text",
						placeholder: s.fbt._("Search for flair", null, {
							hk: "jQdqA"
						}),
						value: o
					}), r.a.createElement(x.a, {
						className: v.a.searchIcon
					})), r.a.createElement(b.a, {
						name: "flair_picker",
						onChange: this.props.onChange,
						value: n
					}, i.map((e, t) => {
						const s = Object(u.c)(e),
							o = n === e.id || !a && 0 === t;
						return r.a.createElement(f.a, {
							className: v.a.radioOption,
							key: e.id,
							showButton: !0,
							tabIndex: o ? 0 : -1,
							value: e.id
						}, r.a.createElement(h.b, {
							className: v.a.flairComponent,
							flair: s,
							forceSmallEmojis: !0
						}), e.textEditable && r.a.createElement(g.a, {
							className: v.a.pencil
						}))
					})))
				}
			}
			var E = n("./src/reddit/components/FlairSearch/index.m.less"),
				O = n.n(E);
			const j = "FlairSearch-EmojiPicker-DropdownId",
				w = Object(l.a)(e => e && Object(u.c)(e)),
				S = Object(a.c)({
					areFlairRestrictionsEnabled: d.d.flairRestrictions,
					isModerator: p.d
				}),
				_ = Object(i.b)(S);
			class k extends r.a.Component {
				constructor() {
					super(...arguments), this.onFlairEdit = e => {
						const {
							templates: t
						} = this.props, n = t && e.templateId ? t[e.templateId] : void 0;
						let s = e;
						n && (s = Object(u.d)({
							flair: e,
							template: n,
							ignoreTextAllowance: !0
						})), this.props.onChange(s)
					}, this.onTemplateSelected = e => {
						const {
							templates: t
						} = this.props;
						if (t) {
							const n = t[e],
								s = Object(u.c)(n);
							this.props.onChange(s)
						}
					}
				}
				render() {
					const {
						props: e
					} = this, {
						isModerator: t,
						templates: n,
						templateIds: o,
						subredditId: i
					} = e, a = n && e.flair && e.flair.templateId && n[e.flair.templateId] || void 0, l = Object(m.a)(), d = e.flair || w(a);
					return r.a.createElement("div", {
						className: Object(c.a)(e.className, O.a.container)
					}, n && o && r.a.createElement(C, {
						flairTemplateType: e.flairTemplateType,
						onChange: this.onTemplateSelected,
						selectedTemplateId: a ? a.id : "",
						templateIds: o,
						templates: n
					}), d && a && (t || a.textEditable) ? r.a.createElement("div", {
						className: O.a.flairEditSection
					}, r.a.createElement("div", {
						className: O.a.editLabel
					}, s.fbt._("Edit flair", null, {
						hk: "1APWWu"
					})), e.areFlairRestrictionsEnabled && r.a.createElement("div", {
						className: O.a.restrictionHintText
					}, Object(u.k)(a)), r.a.createElement(l, {
						autofocus: !0,
						emojiPickerId: j,
						flair: d,
						flairTemplate: a,
						flairTemplateType: e.flairTemplateType,
						isFlairModOnly: a.modOnly,
						onChange: this.onFlairEdit,
						subredditId: i
					})) : null)
				}
			}
			t.a = _(k)
		},
		"./src/reddit/components/FlairWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				flairList: "lrzZ8b0L6AzLkQj5Ww7H1",
				flairWrapper: "_2fiIRtMpITeCAzXc4cANKp",
				flairNoWrap: "_2xu1HuBz1Yx6SP10AGVx_I"
			}
		},
		"./src/reddit/components/FlairWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return E
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/components/CategoryTagList/index.tsx"),
				d = n("./src/reddit/components/FlairList/index.tsx"),
				u = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/correlationIdTracker.ts"),
				m = n("./src/reddit/helpers/flair.ts"),
				h = n("./src/reddit/helpers/trackers/postFlair.ts"),
				b = n("./src/reddit/models/Flair/index.ts"),
				f = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/posts.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/components/FlairWrapper/index.m.less"),
				v = n.n(y);
			const C = Object(i.b)(() => Object(a.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(u.p)(e, {
							pageLayer: n
						})
					},
					isMeta: (e, t) => {
						let {
							post: n
						} = t;
						return Object(g.r)(e, {
							postId: n.id
						})
					},
					isPostFlairEnabled: (e, t) => Object(f.c)(e, {
						subredditId: t.post.belongsTo.id
					}),
					postCategories: (e, t) => {
						let {
							post: n
						} = t;
						return Object(g.E)(e, n)
					},
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(x.S)(e, {
							subredditId: n.belongsTo.id
						}).name
					}
				})),
				E = (e, t) => {
					const n = [];
					return t.isOriginalContent && n.push({
						text: s.fbt._("OC", null, {
							hk: "1i721p"
						}),
						type: b.f.Oc
					}), e && n.push({
						text: s.fbt._("Poll", null, {
							hk: "1scdU1"
						}),
						type: b.f.Meta
					}), n.push(...t.flair), n
				};
			t.a = C(e => {
				let {
					className: t,
					disableFlair: n,
					flairPosition: s,
					isFlairFilter: o,
					isPostFlairEnabled: i,
					isMeta: a,
					nowrap: u,
					post: f,
					postCategories: g,
					sendEvent: x,
					showCategoryTag: y,
					subredditName: C,
					titleFlair: O
				} = e;
				const j = s === b.b.Left,
					w = O || E(a, f),
					S = [];
				let _ = [];
				j ? w.map(e => {
					Object(m.p)(e.type) ? S.push(e) : _.push(e)
				}) : _ = w;
				const k = u ? v.a.flairNoWrap : S.length > 0 || _.length > 0 || g && y ? v.a.flairWrapper : null,
					T = e => {
						const t = {
							id: f.belongsTo.id,
							eventType: f.belongsTo.type,
							originElement: "post_flair",
							postFlairName: e
						};
						Object(p.d)(p.a.SearchResults), x && x(Object(h.a)(f.id, t))
					},
					I = e => {
						Object(p.d)(p.a.SearchResults), x && x(Object(h.e)(e, f.id))
					},
					P = !(n || !w || !w.length),
					M = !!(y && g && g.length);
				return P || M ? r.a.createElement("div", {
					className: Object(c.a)(k, t)
				}, P && S && r.a.createElement(d.a, {
					className: v.a.flairList,
					isFlairFilter: o,
					key: "leftFlair",
					onClick: T,
					onMouseDown: I,
					flair: S,
					disabled: !i,
					subredditName: C
				}), P && r.a.createElement(d.a, {
					className: v.a.flairList,
					isFlairFilter: o,
					key: "rightFlair",
					onClick: T,
					onMouseDown: I,
					flair: _,
					disabled: !i,
					subredditName: C
				}), M && r.a.createElement(l.a, {
					inLightboxHeader: u,
					postId: f.id,
					postCategories: g
				})) : null
			})
		},
		"./src/reddit/components/FocusableContent/index.m.less": function(e, t, n) {
			e.exports = {
				FocusableContent: "_3MknXZVbkWU8JL9XGlzASi",
				focusableContent: "_3MknXZVbkWU8JL9XGlzASi",
				isFocused: "_3F2J0fSnCI3ZvF_tBSaV0s",
				noBorder: "_1CpUVAt2tGEwaaBV3nZNJs"
			}
		},
		"./src/reddit/components/FocusableContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/FocusableContent/index.m.less"),
				c = n.n(a);
			t.a = i.a.wrapped(e => o.a.createElement("div", {
				className: Object(r.a)(e.className, {
					[c.a.isFocused]: e.isFocused,
					[c.a.noBorder]: e.noBorder
				})
			}, e.children), "FocusableContent", c.a)
		},
		"./src/reddit/components/Governance/PollHelpText/index.m.less": function(e, t, n) {
			e.exports = {
				decisionThreholdAmount: "_2c1NZvJKkI6yBivC77FPD4",
				decisionThresholdExplanation: "_1GSbrVpv76_yXM2VcUM3zK",
				decisionThresholdTitle: "_3awYIQIHL4ztIb5nZDL46P",
				token: "_1tH1qzK9P2ZqDx3iQ6Apge"
			}
		},
		"./src/reddit/components/Governance/PostPollMetaData/index.m.less": function(e, t, n) {
			e.exports = {
				proposalMetaData: "_2uZcUQgumllsYgn5TxSizG",
				proposalMetaDataTime: "_1u5ghYiKbGasP3ORCsbasV"
			}
		},
		"./src/reddit/components/Governance/Proposal/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-Governance-Proposal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-Governance-Proposal").then(n.bind(null, "./src/reddit/components/Governance/Proposal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Governance/Proposal/index.tsx"
				}
			})
		},
		"./src/reddit/components/Governance/ProposalTemplates/Generic/index.m.less": function(e, t, n) {
			e.exports = {
				hintText: "_1iTDa11Wj-8Ogp0kHlXhus",
				text: "_3Q86vH6B2mMSV8rHtZq4H9",
				topline: "_12_7Q434C71LJVJC_6GX71"
			}
		},
		"./src/reddit/components/Governance/ProposalTemplates/Spinoff/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_2clkG943bEk_52p-4FBzwJ"
			}
		},
		"./src/reddit/components/Governance/ProposalTemplates/TopModReplacement/index.m.less": function(e, t, n) {
			e.exports = {
				input: "AyMlaMkumG28uV6ZIz9ed"
			}
		},
		"./src/reddit/components/Governance/Token/index.m.less": function(e, t, n) {
			e.exports = {
				grey: "_3oUx7R2UEz3llZLsIONH4x"
			}
		},
		"./src/reddit/components/Governance/Token/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/config.ts"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/selectors/gov.ts"),
				d = n("./src/reddit/components/Governance/Token/index.m.less"),
				u = n.n(d);
			const p = Object(i.c)({
				tokenSymbol: l.r
			});
			t.a = Object(r.b)(p)((function(e) {
				const t = e.grey ? e.tokenSymbol.greyVector || e.tokenSymbol.grey : e.tokenSymbol.filledVector || e.tokenSymbol.filled,
					n = "".concat(a.a.assetPath, "/").concat(t);
				if (e.grey && n.endsWith(".svg")) {
					const t = "url(".concat(n, ") center/cover");
					return o.a.createElement("div", {
						className: Object(c.a)(u.a.grey, e.className),
						style: {
							mask: t,
							WebkitMask: t
						}
					})
				}
				return o.a.createElement("img", {
					className: e.className,
					src: n
				})
			}))
		},
		"./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx");
			const o = Object(s.a)({
				ErrorComponent: () => null,
				LoadingComponent: () => null,
				getComponent: () => n.e("GovernanceUserPublicPointsDisplay").then(n.bind(null, "./src/reddit/components/Governance/UserPublicPointsDisplay/index.tsx")).then(e => e.default)
			});
			t.a = o
		},
		"./src/reddit/components/HiddenDiv.m.less": function(e, t, n) {
			e.exports = {
				Component: "_1VhYfuKTAdUU_3j4cMjkr5",
				component: "_1VhYfuKTAdUU_3j4cMjkr5"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/higherOrderComponents/makeAsync.tsx"),
				i = n("./src/lib/loadWithRetries/index.ts");
			const a = "UserInfoTooltip",
				c = e => e.alwaysShowChildren ? o.a.createElement(o.a.Fragment, null, e.children) : null;
			t.b = Object(r.a)({
				ErrorComponent: c,
				getComponent: () => Object(i.a)(() => Promise.all([n.e("AuthorHovercard~EconTopAwardersModal~Settings~SubredditWiki"), n.e("AuthorHovercard")]).then(n.bind(null, "./src/reddit/components/Hovercards/AuthorHovercard/_AuthorHovercard.tsx"))).then(e => e.default),
				LoadingComponent: c
			})
		},
		"./src/reddit/components/Hovercards/SubredditHovercard/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				o = n("./src/lib/loadWithRetries/index.ts");
			const r = () => null;
			t.a = Object(s.a)({
				ErrorComponent: r,
				getComponent: () => Object(o.a)(() => n.e("SubredditHovercard").then(n.bind(null, "./src/reddit/components/Hovercards/SubredditHovercard/_SubredditHovercard.tsx"))).then(e => e.default),
				LoadingComponent: r
			})
		},
		"./src/reddit/components/IdCard/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "IdCard",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("IdCard~SubredditWiki"), n.e("IdCard")]).then(n.bind(null, "./src/reddit/components/IdCard/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/IdCard/index.tsx"
				}
			})
		},
		"./src/reddit/components/ImageWithFallback/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/react/index.js");
			const s = e => new Promise((t, n) => {
				const s = new Image;
				s.onload = () => t(s), s.onerror = n, s.src = e
			})
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, n) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				a = n.n(i),
				c = n("./src/lib/lessComponent.tsx");
			const l = c.a.div("IconWrapper", a.a),
				d = c.a.div("TextWrapper", a.a);

			function u(e) {
				const {
					className: t,
					color: n,
					icon: s,
					subtitle: i,
					title: c
				} = e;
				return o.a.createElement("div", {
					className: Object(r.a)(t, a.a.wrapper),
					style: n && {
						borderColor: n
					} || {}
				}, o.a.createElement("div", {
					className: a.a.leftSideRectangle,
					style: n && {
						backgroundColor: n
					} || {}
				}), s ? o.a.createElement(l, null, s) : o.a.createElement(l, null), o.a.createElement(d, null, o.a.createElement("div", {
					className: a.a.title
				}, c), i && o.a.createElement("div", {
					className: a.a.subtitle
				}, i)))
			}
		},
		"./src/reddit/components/InfoTextTooltip/Hooked.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoTextTooltip/hooked.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			t.a = o.a.memo((function(e) {
				var {
					visible: t
				} = e, n = l(e, ["visible"]);
				const [i, d] = Object(s.useState)(t);
				return Object(s.useEffect)(() => {
					let e = window.setTimeout(() => {
						e = void 0, d(t)
					}, 0);
					return () => {
						e && window.clearTimeout(e), d(!1)
					}
				}, [t]), t ? o.a.createElement("div", c({
					className: Object(r.a)(a.a.tooltip, {
						[a.a.visible]: i
					})
				}, n.popperProps), n.children, i && o.a.createElement("div", c({
					className: a.a.arrow
				}, n.arrowProps))) : null
			}))
		},
		"./src/reddit/components/InfoTextTooltip/hooked.m.less": function(e, t, n) {
			e.exports = {
				arrow: "_1jsc29CjRXZWjd2tr0Ji0Y",
				tooltip: "_2J_zB4R1FH2EjGMkQjedwc",
				visible: "u6HtAZu8_LKL721-EnKuR"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				BottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				bottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				Text: "HQ2VJViRjokXpRbJzPvvc",
				text: "HQ2VJViRjokXpRbJzPvvc",
				"fade-in": "_1tIZttmhLdrIGrB-6VvZcT",
				fadeIn: "_1tIZttmhLdrIGrB-6VvZcT"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				c = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				l = n("./src/reddit/selectors/tooltip.ts"),
				d = n("./src/reddit/components/InfoTextTooltip/index.m.less"),
				u = n.n(d),
				p = n("./src/lib/lessComponent.tsx");

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const h = p.a.div("Text", u.a),
				b = p.a.div("BottomText", u.a),
				f = e => o.a.createElement(h, {
					className: e.className,
					style: e.style
				}, e.text, e.children),
				g = e => {
					const t = e.overflow ? e.overflow.left : 0;
					return o.a.createElement(b, {
						className: e.className,
						style: Object.assign(Object.assign({}, e.style), {
							"--infoTextTooltip-overflow-left": "".concat(t, "px")
						})
					}, e.text, e.children)
				},
				x = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(l.b)(n)(e)
					}
				}),
				y = Object(c.a)(g, [a.a.Click, a.a.Keydown]),
				v = Object(c.a)(f, [a.a.Click, a.a.Keydown]),
				C = Object(r.b)(x);
			t.c = C(e => {
				const {
					caretOnTop: t
				} = e;
				return t ? o.a.createElement(y, m({}, e, {
					targetPosition: ["center", "bottom"],
					tooltipPosition: ["center", "top"]
				})) : o.a.createElement(v, m({}, e, {
					targetPosition: ["center", "top"],
					tooltipPosition: ["center", "bottom"]
				}))
			})
		},
		"./src/reddit/components/JSAPIContainers/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return w
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "i", (function() {
				return k
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = (n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/lodash/isNil.js")),
				c = n.n(a),
				l = n("./src/reddit/constants/jsapiEvents.ts");
			var d = n("./src/reddit/singleton/EventSystem.ts"),
				u = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
					}
					return n
				};
			const p = Object(i.c)({
				consumers: e => e.jsApi
			});
			class m extends s.Component {
				constructor() {
					super(...arguments), this.el = void 0, this.fireEvent = e => {
						const t = this.props,
							{
								className: n,
								consumers: s
							} = t,
							o = u(t, ["className", "consumers"]);
						d.a.publish(l.a, o, e)
					}, this.setRef = e => this.el = e
				}
				componentDidMount() {
					c()(this.el) || this.fireEvent(this.el)
				}
				componentDidUpdate() {
					c()(this.el) || this.fireEvent(this.el)
				}
				render() {
					const {
						props: e
					} = this;
					return e.consumers.length ? o.a.createElement("span", {
						className: this.props.className,
						ref: this.setRef
					}, e.consumers.map(e => e && o.a.createElement("span", {
						"data-name": e,
						key: e
					}))) : null
				}
			}
			var h = Object(r.b)(p, {})(m),
				b = n("./src/reddit/selectors/comments.ts"),
				f = n("./src/reddit/selectors/subreddit.ts");
			const g = (e, t) => {
				const n = Object(b.n)(e, t),
					s = Object(f.J)(e, t);
				return {
					comment: n,
					isModerator: !(!s || !s.name) && !!e.moderatingSubreddits[s.name],
					subredditOrProfile: s
				}
			};
			var x = Object(r.b)(() => Object(i.a)(g, b.j, (e, t) => Object.assign(Object.assign({}, e), {
				depth: t
			})))(e => o.a.createElement(h, {
				type: "comment",
				data: {
					author: e.comment.author,
					approvedAtUTC: e.comment.approvedAtUTC,
					approvedBy: e.comment.approvedBy,
					bannedAtUTC: e.comment.bannedAtUTC,
					body: e.comment.body,
					created: e.comment.created,
					distinguishType: e.comment.distinguishType,
					id: e.comment.id,
					isApproved: e.comment.isApproved,
					isRemoved: e.comment.isRemoved,
					isSpam: e.comment.isSpam,
					isStickied: e.comment.isStickied,
					isTopLevel: 0 === e.depth,
					post: {
						id: e.comment.postId
					},
					removedBy: e.comment.bannedBy,
					subreddit: {
						id: e.subredditOrProfile ? e.subredditOrProfile.id : "",
						name: e.subredditOrProfile ? e.subredditOrProfile.name : "",
						type: e.subredditOrProfile ? e.subredditOrProfile.type : ""
					}
				}
			}));
			const y = (e, t) => {
				const n = Object(b.n)(e, t),
					s = Object(f.J)(e, t);
				return {
					comment: n,
					isModerator: !(!s || !s.name) && !!e.moderatingSubreddits[s.name],
					subredditOrProfile: s
				}
			};
			var v = Object(r.b)(() => Object(i.a)(y, e => e))(e => o.a.createElement(h, {
				type: "commentAuthor",
				data: {
					author: e.comment.author,
					comment: {
						id: e.commentId
					},
					isModerator: e.isModerator,
					post: {
						id: e.comment.postId
					},
					subreddit: {
						id: e.subredditOrProfile ? e.subredditOrProfile.id : "",
						name: e.subredditOrProfile ? e.subredditOrProfile.name : "",
						type: e.subredditOrProfile ? e.subredditOrProfile.type : ""
					}
				}
			}));
			var C = Object(r.b)(() => Object(i.c)({
					subreddit: f.S
				}))(e => o.a.createElement(h, {
					className: e.className,
					type: "communityTools",
					data: {
						sectionName: e.sectionName,
						subreddit: e.subreddit ? {
							id: e.subreddit.id,
							name: e.subreddit.name,
							type: e.subreddit.type
						} : {}
					}
				})),
				E = n("./src/reddit/selectors/posts.ts");
			var O = Object(r.b)(() => Object(i.c)({
				post: E.N,
				subredditOrProfile: E.ab,
				isModerator: (e, t) => {
					const n = Object(E.ab)(e, t);
					return n && !!e.moderatingSubreddits[n.name] || !1
				}
			}))(e => o.a.createElement(h, {
				className: e.className,
				type: "post",
				data: {
					author: e.post.author,
					approvedAtUTC: e.post.approvedAtUTC,
					approvedBy: e.post.approvedBy,
					bannedAtUTC: e.post.bannedAtUTC,
					created: e.post.created,
					numComments: e.post.numComments,
					distinguishType: e.post.distinguishType,
					domain: e.post.source && e.post.source.displayText,
					flair: e.post.flair,
					id: e.post.id,
					isApproved: e.post.isApproved,
					isRemoved: e.post.isRemoved,
					isSpam: e.post.isSpam,
					media: e.post.media,
					permalink: e.post.permalink,
					removedBy: e.post.bannedBy,
					sourceUrl: e.post.source && e.post.source.url,
					subreddit: e.subredditOrProfile ? {
						id: e.subredditOrProfile.id,
						name: e.subredditOrProfile.name,
						type: e.subredditOrProfile.type
					} : {},
					title: e.post.title,
					voteState: e.post.voteState
				}
			}));
			var j = Object(r.b)(() => Object(i.c)({
				subredditOrProfile: (e, t) => Object(E.ab)(e, {
					postId: t.post.id
				}),
				isModerator: (e, t) => {
					const n = Object(E.ab)(e, {
						postId: t.post.id
					});
					return n && !!e.moderatingSubreddits[n.name] || !1
				}
			}))(e => o.a.createElement(h, {
				className: e.className,
				type: "postAuthor",
				data: {
					author: e.post.author,
					isModerator: e.isModerator,
					post: {
						id: e.post.id
					},
					subreddit: e.subredditOrProfile ? {
						id: e.subredditOrProfile.id,
						name: e.subredditOrProfile.name,
						type: e.subredditOrProfile.type
					} : {}
				}
			}));
			var w = Object(r.b)(() => Object(i.c)({
				post: E.N,
				subredditOrProfile: E.ab,
				isModerator: (e, t) => {
					const n = Object(E.ab)(e, t);
					return n && !!e.moderatingSubreddits[n.name] || !1
				}
			}))(e => o.a.createElement(h, {
				className: e.className,
				type: "postModTools",
				data: {
					author: e.post.author,
					approvedAtUTC: e.post.approvedAtUTC,
					approvedBy: e.post.approvedBy,
					bannedAtUTC: e.post.bannedAtUTC,
					distinguishType: e.post.distinguishType,
					flair: e.post.flair,
					id: e.post.id,
					isApproved: e.post.isApproved,
					isRemoved: e.post.isRemoved,
					isSpam: e.post.isSpam,
					media: e.post.media,
					numComments: e.post.numComments,
					permalink: e.post.permalink,
					removedBy: e.post.bannedBy,
					subreddit: e.subredditOrProfile ? {
						id: e.subredditOrProfile.id,
						name: e.subredditOrProfile.name,
						type: e.subredditOrProfile.type
					} : {},
					title: e.post.title,
					voteState: e.post.voteState
				}
			}));
			var S = Object(r.b)(() => Object(i.c)({
				subreddit: f.S
			}))(e => o.a.createElement(h, {
				className: e.className,
				type: "sidebar",
				data: {
					subreddit: e.subreddit ? {
						id: e.subreddit.id,
						name: e.subreddit.name,
						type: e.subreddit.type
					} : {}
				}
			}));
			var _ = Object(r.b)(() => Object(i.c)({
				subredditOrProfile: (e, t) => Object(f.M)(e, {
					identifier: t
				})
			}))(e => o.a.createElement(h, {
				className: e.className,
				type: "subreddit",
				data: {
					id: e.subredditOrProfile.id,
					displayText: e.subredditOrProfile.displayText,
					name: e.subredditOrProfile.name,
					title: e.subredditOrProfile.title,
					url: e.subredditOrProfile.title
				}
			}));
			var k = Object(r.b)(() => Object(i.c)({
				subreddit: (e, t) => {
					let {
						subredditId: n
					} = t;
					return n ? Object(f.S)(e, {
						subredditId: n
					}) : null
				}
			}))(e => o.a.createElement(h, {
				className: e.className,
				type: "userHovercard",
				data: {
					user: e.user,
					contextId: e.contextId,
					subreddit: e.subreddit ? {
						id: e.subreddit.id,
						name: e.subreddit.name,
						type: e.subreddit.type
					} : {}
				}
			}))
		},
		"./src/reddit/components/JumpToContent/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_3KaTO_3YaHK3SMocnu8jV9",
				rightBorder: "_1Bt_cwKVUG30M9eNB-9rU4",
				wrapper: "_32Xa3voy05uAFz3ZnopP_S"
			}
		},
		"./src/reddit/components/JumpToContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/reddit/constants/componentSizes.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/components/JumpToContent/index.m.less"),
				l = n.n(c);
			const d = Object(o.createContext)(null),
				u = Object(o.createContext)(null);
			class p extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						handleRef: null
					}, this.setHandleRef = e => {
						this.state.handleRef !== e && this.setState({
							handleRef: e
						})
					}
				}
				render() {
					return r.a.createElement(d.Provider, {
						value: this.props.isOverlayOpen ? null : this.state.handleRef
					}, r.a.createElement(u.Provider, {
						value: this.setHandleRef
					}, this.props.children))
				}
			}
			const m = i.f + 10,
				h = r.a.memo(() => r.a.createElement(d.Consumer, null, e => e && r.a.createElement("div", {
					className: l.a.wrapper
				}, r.a.createElement(a.n, {
					className: l.a.button,
					onClick: () => {
						e.focus(), e.scrollIntoView(), window.scrollBy(0, -m)
					}
				}, s.fbt._("Jump to content", null, {
					hk: "2zWOmQ"
				})), r.a.createElement("div", {
					className: l.a.rightBorder
				})))),
				b = r.a.memo(() => r.a.createElement(u.Consumer, null, e => r.a.createElement("div", {
					ref: e,
					tabIndex: 0
				})))
		},
		"./src/reddit/components/LinkOrOverlayLink/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				a = n("./src/reddit/helpers/overlay/index.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};

			function d(e) {
				const {
					children: t,
					className: n,
					to: s
				} = e, r = l(e, ["children", "className", "to"]), d = Object(a.b)(s);
				return o.a.createElement(i.a, c({
					className: n,
					to: d
				}, r), t)
			}

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			t.a = e => {
				const {
					isOverlay: t
				} = e, n = p(e, ["isOverlay"]), s = t ? d : r.a;
				return o.a.createElement(s, u({}, n, {
					children: n.children,
					className: n.className,
					onClick: n.onClick,
					to: n.to
				}))
			}
		},
		"./src/reddit/components/MakeGifToggle/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1iRy5EPCLqSx8I0k9OT0wW",
				content: "NfjQg3srQXRhyOxLBwXrS",
				toggleSwitch: "_1fUmirx6e9tUDs04TQq6A1",
				mCompactSwitch: "_3Cx_YBpXo1s1iy7oA-4s6R",
				mDisabled: "_1M5N6DrrQQCQJs3JctDSu8",
				hoverTooltip: "_9qS60cx9uxyt1k4eZF_0w",
				tooltipContentClass: "_21DP8j-B-UkVKGJONbrTmX"
			}
		},
		"./src/reddit/components/MakeGifToggle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				c = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				d = n("./src/reddit/components/MakeGifToggle/index.m.less"),
				u = n.n(d);
			t.a = e => r.a.createElement(l.a, {
				className: Object(i.a)(u.a.container, e.disabled ? u.a.mDisabled : null, e.isCompact ? u.a.mCompactSwitch : null),
				onMouseDown: e => e.preventDefault(),
				onClick: t => {
					t.stopPropagation(), !e.disabled && e.onClick()
				}
			}, r.a.createElement(l.a, {
				className: u.a.content
			}, r.a.createElement(c.a, {
				className: u.a.toggleSwitch,
				on: e.on
			}), r.a.createElement("label", null, s.fbt._("Make GIF", null, {
				hk: "2ig2GG"
			}))), e.tooltip ? r.a.createElement(a.a, {
				className: u.a.hoverTooltip,
				tooltipContentClass: u.a.tooltipContentClass,
				text: e.tooltip
			}) : null)
		},
		"./src/reddit/components/MarkdownHelp/index.m.less": function(e, t, n) {
			e.exports = {
				Section: "_1gF-JM2Md5QrEmUiEkRvLZ",
				section: "_1gF-JM2Md5QrEmUiEkRvLZ",
				Container: "C8uCM4XqGMA6xiIu7zfJl",
				container: "C8uCM4XqGMA6xiIu7zfJl",
				helpTable: "_3E7k-M4lVIYGW6Z7QoiPc9",
				Table: "_1t5z5ubOp-UUzTGLJr43d0",
				table: "_1t5z5ubOp-UUzTGLJr43d0",
				P: "_3MhMubukVABghyvZNN2X65",
				p: "_3MhMubukVABghyvZNN2X65"
			}
		},
		"./src/reddit/components/MarkdownHelp/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				c = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				l = n("./src/reddit/components/RichTextJson/elements.tsx"),
				d = n("./src/reddit/components/RichTextJson/SpoilerText.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/higherOrderComponents/asModal/index.tsx"),
				m = n("./src/reddit/actions/modal.ts"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/layout/row/Inline/index.tsx"),
				f = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				g = n("./src/reddit/components/MarkdownHelp/index.m.less"),
				x = n.n(g),
				y = n("./src/lib/lessComponent.tsx");
			const v = "Markdown_Help__Modal",
				C = y.a.wrapped(b.a, "Section", x.a),
				E = y.a.div("Container", x.a),
				O = y.a.table("Table", x.a),
				j = y.a.p("P", x.a);
			class w extends r.a.Component {
				render() {
					return r.a.createElement(c.a, null, r.a.createElement(a.a, {
						onClosePressed: this.props.closeModal,
						title: "Markdown Help"
					}), r.a.createElement(E, null, r.a.createElement(O, {
						className: x.a.helpTable
					}, r.a.createElement("tr", null, r.a.createElement(l.s, null, r.a.createElement(l.j, null, "Type this:")), r.a.createElement(l.s, null, r.a.createElement(l.j, null, "to get this:"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "*italics*")), r.a.createElement(l.p, null, r.a.createElement(l.f, null, "italics"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "**bold**")), r.a.createElement(l.p, null, r.a.createElement(l.b, null, "bold"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "[reddit!](https://reddit.com)")), r.a.createElement(l.p, null, r.a.createElement(l.a, {
						href: "https://www.reddit.com"
					}, "reddit!"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "* item 1"), r.a.createElement(l.j, null, "* item 2"), r.a.createElement(l.j, null, "* item 3")), r.a.createElement(l.p, null, r.a.createElement(l.v, null, r.a.createElement(l.g, null, "item 1"), r.a.createElement(l.g, null, "item 2"), r.a.createElement(l.g, null, "item 3")))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "> quoted text")), r.a.createElement(l.p, null, r.a.createElement(l.c, null, "quoted text"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "~~strikethrough~~")), r.a.createElement(l.p, null, r.a.createElement(l.d, null, "strikethrough"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, "super^script")), r.a.createElement(l.p, null, "super", r.a.createElement(l.m, null, "script"))), r.a.createElement("tr", null, r.a.createElement(l.p, null, r.a.createElement(l.j, null, ">!spoilers!<")), r.a.createElement(l.p, null, r.a.createElement(d.a, null, "spoilers")))), r.a.createElement(j, null, "Check the", r.a.createElement(l.a, {
						href: "https://www.reddit.com/wiki/commenting"
					}, " commenting wiki page "), "for more help")), r.a.createElement(C, null, r.a.createElement(f.a, null, r.a.createElement(h.f, {
						onClick: this.props.closeModal,
						"data-redditstyle": !0
					}, s.fbt._("Close", null, {
						hk: "4gbyAA"
					})))))
				}
			}
			const S = Object(i.b)(null, (e, t) => ({
				closeModal: () => e(Object(m.i)(v))
			}))(w);
			t.a = Object(p.a)(Object(u.c)(S))
		},
		"./src/reddit/components/Media/GalleryBox/index.m.less": function(e, t, n) {
			e.exports = {
				outerContainer: "kcerW9lbT-se3SXd-wp2i",
				nextButton: "_38uXo2TofvhEuLKeH-rRcV",
				icon: "_32kofHIEwuARK_15MrzAuT",
				seeMore: "_3b8u2OJXaSDdBWoRB7zUoK",
				iconImage: "_3PkAZ5W4aDQ7cujQ426UiB",
				prevIcon: "CxV9u12DiN4nfOLEzaWGg",
				nextIcon: "Qfn6RihWXp6riuP88alpI",
				imageLink: "iUP9nbvcaxfwKrQTgt0sw",
				tallImage: "_1ti9kvv_PMZEF2phzAjsGW",
				commonImage: "_3BxRNDoASi9FbGX01ewiLg",
				navigationUnderlay: "_1fSFPkxZ9pToLETLQT2dmc",
				hasMoreSlides: "_3-JCOd-nY76g29C7ZVX_kl",
				slideshowContainer: "KVyBaj7FjzElWsqJDmw7v",
				slideImageMainDiv: "_35oEP5zLnhKEbj5BlkTBUA",
				slideImage: "_1dwExqTGJH2jnA-MYGkEL-",
				slide: "_28TEYBuEdOuE3kN6UyoKMa",
				imagesWrapper: "_2Ev7WJU0f45KxlmClce9t8",
				slideWrapper: "_1apobczT0TzIKMWpza0OhL",
				figure: "_3o5Vzct5tn9PE7e-emdDmf",
				imageMetaData: "_26daP6nhhW7BT-CMzL0ijs",
				imageUrl: "_1JvpVe-IA894KlEuAn5i9c",
				outboundUrlWrapper: "_2ZUcZqGYDSM0BMbiracglV",
				linkIcon: "_2pA6COv2OLOcG3Ma_ZAzLs",
				urlText: "G960looU9eqiZ1POYed8r",
				emptyCaptionBlock: "cKdLDCF6ney9RBLRzJt8j",
				imageCaption: "_15nNdGlBIgryHV04IfAfpA",
				slideIndicator: "_61i6grM3um1yuw4GrN97P",
				unblurButtonContainer: "XU8P4L1nSifowaG9_gEQu",
				unblurButton: "_2xd9ygloNjk8lC1O8LrxPo",
				tilesWrapper: "bVildkms0x9XcY2qrG0Mr",
				tileImage: "_1ynfiEQPXyJqwL8az8sG71",
				blurredContent: "kYRcqD1CH-tXu0xGsAOLH",
				tilePlaceholder: "Qazqk11mIzZph1VMsNMtk",
				tileIcon: "_3VAoQueUjpnNBtHAZRjo_0"
			}
		},
		"./src/reddit/components/Media/GalleryBox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/helpers/trackers/gallery.ts");
			var c = (e, t, n) => {
					const o = Object(s.useCallback)(t => {
						t.isComposing || e !== t.keyCode || n()
					}, [e, n]);
					Object(s.useEffect)(() => {
						if (t) return t.addEventListener("keydown", o), () => {
							t && t.removeEventListener("keydown", o)
						}
					}, [t, o])
				},
				l = n("./src/reddit/hooks/useTracking.ts"),
				d = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				u = n("./src/reddit/icons/svgs/OutboundLink/index.tsx"),
				p = n("./src/reddit/icons/svgs/Tile/index.tsx"),
				m = n("./src/reddit/actions/media.ts"),
				h = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/helpers/mediaGallery/index.tsx"),
				f = n("./src/reddit/models/Media/index.ts"),
				g = n("./src/reddit/selectors/media.ts"),
				x = n("./src/reddit/components/Media/blurredContent.ts"),
				y = n("./src/reddit/components/Media/GalleryBox/index.m.less"),
				v = n.n(y);
			const {
				fbt: C
			} = n("./node_modules/fbt/lib/FbtPublic.js"), E = e => {
				const {
					displayImage: t,
					style: n,
					showSeeMore: s
				} = e;
				return o.a.createElement("div", {
					className: Object(i.a)({
						[v.a.slideImageMainDiv]: !s
					})
				}, o.a.createElement("img", {
					src: "u" in t ? t.u : t.gif,
					className: v.a.slideImage,
					style: n
				}), s && o.a.createElement("div", {
					className: v.a.seeMore
				}, C._("see full image", null, {
					hk: "1Qygw5"
				})))
			}, O = e => {
				const {
					slideIndex: t,
					currentIndex: n,
					obfuscatedImage: s,
					optimalImage: r,
					originalImage: a,
					isListing: c,
					isSponsored: l
				} = e, d = n === t ? {
					left: "0px"
				} : {
					left: n > t ? "-100%" : "100%"
				}, u = Object(b.c)(c), p = a.y > u && Object(f.J)(a.y, a.x), m = p ? {} : {
					maxHeight: "100%"
				};
				let h;
				return h = s || (p ? a : r), o.a.createElement("li", {
					style: d,
					className: v.a.slide
				}, o.a.createElement("figure", {
					className: Object(i.a)({
						[v.a.tallImage]: p,
						[v.a.commonImage]: !p
					}, v.a.figure)
				}, c || l ? o.a.createElement(E, {
					displayImage: h,
					style: m,
					showSeeMore: p
				}) : o.a.createElement("a", {
					href: "u" in a ? a.u : a.gif,
					rel: "noopener noreferrer",
					target: "_blank",
					className: Object(i.a)({
						[v.a.tallImage]: p,
						[v.a.commonImage]: !p
					}, v.a.imageLink)
				}, o.a.createElement(E, {
					displayImage: h,
					style: m,
					showSeeMore: p
				}))))
			}, j = e => o.a.createElement("a", {
				className: Object(i.a)(e.className, v.a.navigationUnderlay, {
					[v.a.hasMoreSlides]: e.hasMoreSlides
				}),
				onClick: t => {
					e.onClick(), t.stopPropagation()
				},
				onMouseDown: t => {
					e.setFocusTo.current && e.setFocusTo.current.focus({
						preventScroll: !0
					}), t.preventDefault()
				},
				title: e.hasMoreSlides ? e.title : void 0
			}, e.hasMoreSlides && o.a.createElement("i", {
				className: Object(i.a)(e.iconClassName, v.a.icon)
			}, o.a.createElement(d.a, {
				className: v.a.iconImage
			}))), w = e => o.a.createElement("div", {
				className: v.a.imageMetaData,
				style: {
					height: e.captionHeight,
					justifyContent: e.caption ? "space-between" : "flex-end"
				}
			}, e.caption && o.a.createElement("span", {
				className: v.a.imageCaption,
				title: e.caption
			}, e.caption), e.outboundUrl && o.a.createElement("span", {
				className: v.a.imageUrl
			}, o.a.createElement("a", {
				className: v.a.outboundUrlWrapper,
				href: e.outboundUrl,
				onClick: e.onClickEvent,
				rel: "noopener noreferrer",
				target: "'_blank'"
			}, o.a.createElement("span", {
				className: v.a.urlText
			}, Object(b.e)(e.outboundUrl)), o.a.createElement(u.a, {
				className: v.a.linkIcon
			})))), S = e => o.a.createElement("div", {
				className: v.a.slideIndicator,
				onClick: e.toggleTileLayout ? t => {
					t.preventDefault(), t.stopPropagation(), e.toggleTileLayout()
				} : void 0
			}, e.toggleTileLayout && o.a.createElement(p.a, {
				className: v.a.tileIcon
			}), e.currentSlide, "/", e.totalSlides);
			t.a = e => {
				const t = Object(r.c)(),
					{
						captionHeight: n,
						galleryItems: d,
						imageHeight: u,
						isListing: p,
						isTileLayout: y,
						mediaMetadata: C = {},
						postId: E,
						shouldShowTileLayoutOption: _,
						isSponsored: k
					} = e,
					T = Object(r.d)(e => Object(g.a)(e, E)),
					I = T > 0,
					P = T < d.length - 1,
					M = Object(l.a)(),
					N = Object(s.useCallback)(e => {
						t(Object(m.f)({
							postId: E,
							index: e
						}))
					}, [t, E]),
					R = Object(s.useCallback)(() => {
						t(Object(m.i)({
							postId: E,
							isTileLayout: !y
						}))
					}, [t, E, y]),
					L = Object(s.useCallback)(() => {
						if (!P) return;
						const e = T + 1;
						N(e), M(a.b(E, e)), M(a.d(E, e + 1))
					}, [P, T, N, M, E]),
					A = Object(s.useCallback)(() => {
						if (!I) return;
						const e = T + 1;
						N(T - 1), M(a.a(E, e)), M(a.d(E, e - 1))
					}, [I, T, N, M, E]),
					F = Object(s.useCallback)(() => {
						const e = d[T] && d[T].outboundUrl,
							t = T + 1;
						e && M(a.c(E, e, t))
					}, [M, E, T, d]),
					D = Object(s.useRef)(null),
					B = Object(s.useRef)(null);
				c(h.a.ArrowLeft, D.current, A), c(h.a.ArrowRight, D.current, L);
				const U = d[T] && d[T].caption,
					K = d[T] && d[T].outboundUrl,
					H = ((e, t, n) => {
						const s = Object(b.f)(e),
							o = Object(b.g)(s),
							r = o.x / o.y < 1,
							i = Object(b.h)(e),
							a = Object(b.i)(e || {}, Object(b.c)(n), f.p);
						if (n || a || i || r) return {
							height: t
						};
						const c = Object(f.C)(o.y, o.x);
						return {
							paddingBottom: "".concat(c, "%")
						}
					})(C, u, p);
				return o.a.createElement("div", {
					className: Object(i.a)(v.a.outerContainer),
					ref: D,
					tabIndex: 0
				}, y ? o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: Object(i.a)(v.a.tilesWrapper, {
						[v.a.blurredContent]: e.shouldBlur
					}),
					onClick: e.onClickRevealBlurred
				}, d.map((t, n) => {
					const s = t.mediaId,
						r = C && C[s];
					if (!r || !r.s) return null;
					const i = [...r && r.s ? [r.s] : [], ...r && r.p ? r.p : []],
						a = Object(b.d)(f.z, i);
					if (!a) return null;
					const c = r.s;
					return o.a.createElement("div", {
						style: {
							backgroundImage: "url(".concat("gif" in c ? c.gif : "u" in a && a.u, ")")
						},
						className: v.a.tileImage,
						onClick: e.shouldBlur ? void 0 : e => {
							e.preventDefault(), e.stopPropagation(), R(), N(n)
						},
						key: s
					})
				}), [1, 2, 3].map(e => o.a.createElement("div", {
					key: e,
					className: v.a.tilePlaceholder
				}))), e.shouldBlur && o.a.createElement("div", {
					className: v.a.unblurButtonContainer
				}, o.a.createElement("button", {
					className: v.a.unblurButton
				}, Object(x.a)(!!e.isNSFW, !!e.isSpoiler)))) : o.a.createElement("div", {
					className: v.a.slideshowContainer,
					tabIndex: -1,
					ref: B,
					onClick: e.onClickRevealBlurred,
					style: H
				}, o.a.createElement("div", {
					className: v.a.imagesWrapper
				}, o.a.createElement("ul", {
					className: v.a.slideWrapper
				}, d.map((t, n) => {
					const s = t.mediaId,
						r = C && C[s];
					if (!r || !r.s) return null;
					const i = [...r && r.s ? [r.s] : [], ...r && r.p ? r.p : []],
						a = Object(b.d)(u, i);
					if (!a) return null;
					const c = e.shouldBlur && Object(b.d)(u, r.o || []) || void 0;
					return o.a.createElement(O, {
						slideIndex: n,
						currentIndex: T,
						obfuscatedImage: c,
						optimalImage: a,
						originalImage: r.s,
						isListing: e.isListing,
						isSponsored: k,
						key: s
					})
				})), e.shouldBlur && !e.isListing && o.a.createElement("div", {
					className: v.a.unblurButtonContainer
				}, o.a.createElement("button", {
					className: v.a.unblurButton
				}, Object(x.a)(!!e.isNSFW, !!e.isSpoiler))), !e.shouldBlur && o.a.createElement(o.a.Fragment, null, o.a.createElement(j, {
					onClick: A,
					setFocusTo: B,
					hasMoreSlides: I,
					title: "Previous",
					iconClassName: v.a.prevIcon,
					className: v.a.prevButton
				}), o.a.createElement(j, {
					onClick: L,
					setFocusTo: B,
					hasMoreSlides: P,
					title: "Next",
					iconClassName: v.a.nextIcon,
					className: v.a.nextButton
				}))), d.length > 1 ? o.a.createElement(S, {
					currentSlide: T + 1,
					totalSlides: d.length,
					toggleTileLayout: _ && R || void 0
				}) : ""), !U && !K || y || k ? !!n && !y && !k && o.a.createElement("div", {
					className: v.a.emptyCaptionBlock,
					style: {
						height: n
					}
				}) : o.a.createElement(w, {
					caption: U,
					onClickEvent: F,
					outboundUrl: K,
					captionHeight: n
				}))
			}
		},
		"./src/reddit/components/Media/RichTextContainer/index.m.less": function(e, t, n) {
			e.exports = {
				richTextContainer: "Chtkt3BCZQruf0LtmFg2c",
				richTextContainerTitleOnly: "_2XNPI46MXRfDdsSoDqaksI",
				richTextContainerFull: "_3xX726aBn29LDbsDtzr_6E",
				placeholder: "_1aLU7RPNLdvfcbaNdcN11x",
				placeholderParagraph: "Owi9iYzjyVpDq_0YbCdJY"
			}
		},
		"./src/reddit/components/Media/RichTextContainer/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/componentSizes.ts"),
				a = n("./src/reddit/models/Media/index.ts"),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				u = n("./src/reddit/components/Media/RichTextContainer/index.m.less"),
				p = n.n(u);
			class m extends o.a.Component {
				componentDidMount() {
					this.loadRichTextContentIfNeeded()
				}
				loadRichTextContentIfNeeded() {
					this.props.canLoadContent && this.props.isExpando && this.props.onLoadRichTextContentIfNeeded(this.props.postId)
				}
				render() {
					const e = Object(d.a)({
						isLoading: !0
					});
					return o.a.createElement("div", {
						className: p.a.placeholder
					}, [1, 2, 3].map(t => o.a.createElement("div", {
						key: t,
						className: p.a.placeholderParagraph
					}, o.a.createElement("div", {
						className: e
					}), o.a.createElement("div", {
						className: e
					}), o.a.createElement("div", {
						className: e
					}))))
				}
			}
			var h = Object(c.b)(null, e => ({
				onLoadRichTextContentIfNeeded: t => e(Object(l.s)(t))
			}))(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var f = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			t.a = e => {
				var {
					canLoadContent: t,
					children: n,
					className: s,
					isCommentsPage: c,
					isMediumHeight: l,
					isRichTextTruncated: d,
					isExpando: u,
					isTitleOnly: m,
					postId: g,
					showFull: x
				} = e, y = f(e, ["canLoadContent", "children", "className", "isCommentsPage", "isMediumHeight", "isRichTextTruncated", "isExpando", "isTitleOnly", "postId", "showFull"]);
				const v = {
						[p.a.richTextContainerFull]: x,
						[p.a.richTextContainerTitleOnly]: m && !x,
						[p.a.richTextContainer]: !x && !m
					},
					C = {};
				x || (C.maxHeight = "".concat(m ? a.m : l ? a.l : a.k, "px")), c && (C.maxWidth = "".concat(i.d, "px"));
				const E = d && x;
				return o.a.createElement("div", b({
					className: Object(r.a)(v, s),
					style: C
				}, y), n, E && o.a.createElement(h, {
					canLoadContent: !!t,
					isExpando: u,
					postId: g
				}))
			}
		},
		"./src/reddit/components/Media/TwitterEmbed/index.m.less": function(e, t, n) {
			e.exports = {
				tweetPlaceholder: "q0jsD_ZcQRuuUQzXawr8J",
				tweetEmbedBox: "_3pYTJO5FjsoQWRUsIFQASN",
				isInvisible: "_3xICr9rbunMOudN40P1GgI",
				tweetDeleted: "sIgL7k1Lz6YLL146KNk8k",
				seeMore: "_2f5uYHvlfzs2DngQsiCdvB"
			}
		},
		"./src/reddit/components/Media/TwitterEmbed/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/intersectionObserver/index.ts"),
				d = n("./src/reddit/components/Media/constants.ts"),
				u = n("./src/reddit/components/Media/EmbedBox/index.tsx"),
				p = n("./src/reddit/components/Media/MediaContainer/index.tsx"),
				m = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				h = n("./src/reddit/models/Media/index.ts"),
				b = n("./src/reddit/selectors/experiments/video.ts"),
				f = n("./src/reddit/components/Media/TwitterEmbed/index.m.less"),
				g = n.n(f);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const y = 350,
				v = 100,
				C = 300,
				E = Object(a.c)({
					inVideoUnmountContent: b.c
				}),
				O = Object(i.b)(E);
			class j extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						isFullyLoaded: !1
					}, this.iframe = null, this.onWindowMessage = e => {
						!this.state.isFullyLoaded && this.iframe && this.iframe.contentWindow === e.source && "tweet-measured" === e.data.action && this.setState({
							isFullyLoaded: !0
						})
					}, this.embedBoxChildRef = e => {
						this.iframe = e, e && l.a(e, (t, n) => {
							e && e.contentWindow && !this.props.media.height && n && e.contentWindow.postMessage("twitter-measure-requested", d.a)
						}), this.props.embedBoxChildRef(e)
					}
				}
				componentDidMount() {
					window.addEventListener("message", this.onWindowMessage)
				}
				componentDidUpdate(e) {
					this.props.inVideoUnmountContent && !this.props.canLoadContent && e.canLoadContent && this.setState(e => {
						let {
							isFullyLoaded: t
						} = e;
						return t ? {
							isFullyLoaded: !1
						} : null
					})
				}
				componentWillUnmount() {
					this.iframe && l.b(this.iframe), window.removeEventListener("message", this.onWindowMessage)
				}
				render() {
					const {
						canLoadContent: e,
						media: t,
						mediaContainerProps: n,
						onIframeLoaded: o,
						source: i,
						title: a
					} = this.props, {
						isFullyLoaded: l
					} = this.state, d = n.height || (t.isDeleted ? v : C);
					return r.a.createElement(p.a, x({}, n, {
						alwaysWrapMedia: !0,
						height: d,
						showFull: !n.isListing,
						width: y
					}), e && r.a.createElement(r.a.Fragment, null, (!n.height || !l) && (t.isDeleted ? r.a.createElement("p", {
						className: g.a.tweetDeleted
					}, s.fbt._("This Tweet has been deleted.", null, {
						hk: "1LhcOw"
					})) : r.a.createElement("div", {
						className: Object(c.a)(Object(m.a)({
							isLoading: !0
						}), g.a.tweetPlaceholder)
					})), r.a.createElement(u.a, {
						childRef: this.embedBoxChildRef,
						className: Object(c.a)(g.a.tweetEmbedBox, {
							[g.a.isInvisible]: !n.height || !l
						}),
						height: d,
						isListing: n.isListing,
						isResponsive: !0,
						maxHeight: n.isListing ? h.j : null,
						onLoad: o,
						showCentered: n.showCentered,
						showFull: !0,
						source: i,
						title: a,
						width: y
					}), n.isListing && d > h.j && r.a.createElement("div", {
						className: g.a.seeMore
					}, s.fbt._("See full tweet", null, {
						hk: "1bxtrd"
					}))))
				}
			}
			t.a = O(j)
		},
		"./src/reddit/components/Media/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "https://www.redditmedia.com"
		},
		"./src/reddit/components/Media/getResolution.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/models/Media/index.ts");
			const o = (e, t, n, s) => {
					const o = e / t,
						r = n / s;
					return Math.abs(o - r) < .03
				},
				r = (e, t) => {
					for (let n = 0; n < t.length; n++) {
						const s = t[n];
						if (s.width >= e) return s
					}
				},
				i = (e, t, n) => {
					for (let r = 0; r < n.length; r++) {
						const i = n[r];
						if (i.width >= s.e / 2 && o(e, t, i.height, i.width)) return i
					}
				},
				a = e => {
					for (let t = 0; t < e.length; t++) {
						const n = e[t];
						if (n.height >= s.e || n.width >= s.f) return n
					}
				}
		},
		"./src/reddit/components/Media/index.m.less": function(e, t, n) {
			e.exports = {
				hiddenLink: "_3dhFVFchWAAFXfLFTa94n9",
				displayNone: "_1Q2mF3u7v9hBVu_4bkC7R4",
				galleryMediaContainer: "_3ozFpM1W8BRdrzkr_ssGxZ"
			}
		},
		"./src/reddit/components/Media/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				o = n.n(s),
				r = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./node_modules/lodash/debounce.js"),
				a = n.n(i),
				c = n("./node_modules/react/index.js"),
				l = n.n(c),
				d = n("./node_modules/react-redux/es/index.js"),
				u = n("./node_modules/reselect/es/index.js"),
				p = n("./src/higherOrderComponents/withMux/index.tsx"),
				m = n("./src/lib/constants/index.ts"),
				h = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				b = n("./src/lib/env/index.ts"),
				f = n("./src/lib/isUrl/index.ts"),
				g = n("./src/lib/objectSelector/index.ts"),
				x = n("./src/lib/onFocusAndVisibilityChange/index.ts"),
				y = n("./src/lib/sentry/index.ts"),
				v = n("./src/lib/truncateText/index.ts"),
				C = n("./src/reddit/components/AdViewability/index.tsx"),
				E = n("./src/reddit/components/Governance/Proposal/async.ts"),
				O = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				j = n("./src/reddit/components/Media/constants.ts"),
				w = n("./src/reddit/components/Media/EmbedBox/index.tsx"),
				S = n("./src/reddit/components/Media/GalleryBox/index.tsx"),
				_ = n("./src/reddit/components/Media/ImageBox/index.tsx"),
				k = n("./src/reddit/components/Media/MediaContainer/index.tsx"),
				T = n("./src/reddit/components/Media/RichTextContainer/index.tsx"),
				I = n("./src/reddit/components/Media/TwitterEmbed/index.tsx"),
				P = n("./src/reddit/components/Media/VideoBox/index.tsx"),
				M = n("./src/reddit/components/PlayButton/index.tsx"),
				N = n("./src/reddit/components/RawHTMLDisplay/Media.tsx"),
				R = n("./src/reddit/components/RichTextJson/index.tsx"),
				L = n("./src/reddit/constants/componentSizes.ts"),
				A = n("./src/reddit/constants/experiments.ts"),
				F = n("./src/reddit/constants/screenWidths.ts"),
				D = n("./src/reddit/contexts/PageLayer/index.tsx"),
				B = n("./src/reddit/helpers/canPreviewSelfText/index.ts"),
				U = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				K = n("./src/reddit/helpers/mediaGallery/index.tsx"),
				H = n("./src/reddit/helpers/postHasSelfText/index.ts"),
				V = n("./src/reddit/helpers/stripMetaLinks/fromRawHtml.ts"),
				W = n("./src/reddit/helpers/stripMetaLinks/fromRTJ.ts"),
				z = n("./src/reddit/models/Media/index.ts"),
				q = n("./src/reddit/selectors/experiments/postSeo.ts"),
				G = n("./src/reddit/selectors/experiments/video.ts"),
				J = n("./src/reddit/selectors/media.ts"),
				Q = n("./src/reddit/selectors/postCreations.ts"),
				Z = n("./src/reddit/selectors/posts.ts"),
				Y = n("./src/reddit/selectors/seo/index.ts"),
				X = n("./src/reddit/components/Media/getResolution.ts"),
				$ = n("./src/reddit/components/Media/index.m.less"),
				ee = n.n($);

			function te() {
				return (te = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const ne = Object(r.a)({
					resolved: {},
					chunkName: () => "LiveVideoPlayer",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~LiveVideoPlayer~PublicAccessNetwork~RpanListingUnit"), n.e("LiveVideoPlayer~PublicAccessNetwork"), n.e("LiveVideoPlayer")]).then(n.bind(null, "./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/index.tsx"
					}
				}, {
					ssr: !1
				}),
				se = Object(p.a)(O.b, {
					playerName: "Reddit Player"
				}),
				oe = 300,
				re = " - ",
				ie = 1200,
				ae = 75,
				ce = "player.js",
				le = L.r + L.q,
				de = e => e.isVisible ? e.children : l.a.createElement("div", {
					className: ee.a.displayNone
				}, e.children),
				ue = new Set([z.o.EMBED, z.o.GIFVIDEO, z.o.LIVEVIDEO, z.o.VIDEO]),
				pe = e => !!e.media && ue.has(e.media.type),
				me = new Set([z.o.EMBED, z.o.GALLERY, z.o.GIFVIDEO, z.o.IMAGE, z.o.LIVEVIDEO, z.o.VIDEO]),
				he = e => {
					let {
						post: t
					} = e;
					return !!t.media && me.has(t.media.type)
				},
				be = Object(D.t)(),
				fe = Object(u.c)({
					imgOCRAltTextVariant: (e, t) => Object(Y.c)(e, t) ? Object(q.b)(e, t.post, !0) : void 0,
					OCRAltText: (e, t) => {
						let {
							post: n
						} = t;
						return Object(q.a)(e, n.id)
					},
					subredditOrProfileDisplayText: (e, t) => Object(q.i)(e, t),
					subredditOrProfile: (e, t) => {
						let {
							post: n
						} = t;
						return Object(Z.ab)(e, {
							postId: n.id
						})
					},
					isEditing: (e, t) => {
						let {
							post: n
						} = t;
						return Object(Q.F)(e, {
							postId: n.id
						})
					},
					shouldShowAltText: (e, t) => Object(Y.c)(e, t),
					isGalleryTileLayout: (e, t) => {
						let {
							shouldShowGalleryTileOption: n,
							post: s,
							isGalleryTileLayoutDefault: o
						} = t;
						if (!n) return !1;
						const r = Object(J.b)(e, s.id);
						return !(void 0 !== r || !o) || !!r
					},
					inVideoUnmountContent: G.c
				}),
				ge = Object(d.b)(fe),
				xe = Object(g.b)(e => ({
					renderingObjectInfo: e.post,
					pageLayer: e.pageLayer
				}));
			class ye extends l.a.Component {
				constructor(e) {
					super(e), this.pauseContent = () => {
						this.shouldFocusContentDebouncer(!1)
					}, this.stopContent = () => {
						const {
							media: e
						} = this.props.post;
						if (e && z.d.has(e.type)) {
							if (this.iframe) {
								const t = e.type === z.o.EMBED ? e.provider : null;
								this.pauseEmbed(this.iframe, t)
							}
							this.setState(e => e.shouldStop ? null : {
								shouldStop: !0
							})
						}
					}, this.handleVisibilityChange = e => {
						const {
							shouldPause: t
						} = this.state, {
							autoplayPref: n
						} = this.props;
						this.iframe && (t || !n && e.documentInFocus || this.toggleEmbedAutoplay(this.iframe, !e.documentInFocus)), this.setState({
							forcePause: !e.documentInFocus
						})
					}, this.focusContent = () => {
						this.shouldFocusContentDebouncer(!0)
					}, this.loadContent = () => {
						this.setState(e => e.canLoadContent ? null : {
							canLoadContent: !0
						})
					}, this.unmountContent = () => {
						if (this.props.inVideoUnmountContent) {
							if (!this.iframe) return;
							this.setState(e => {
								let {
									canLoadContent: t
								} = e;
								return t ? {
									canLoadContent: !1
								} : null
							})
						}
					}, this.contentIsHeavyToMount = () => {
						const {
							media: e
						} = this.props.post;
						return !!e && z.d.has(e.type)
					}, this.shouldFocusContentDebouncer = a()(e => {
						const {
							media: t
						} = this.props.post, {
							autoplayPref: n
						} = this.props;
						if (t && z.d.has(t.type)) {
							if (this.iframe) {
								const s = t.type === z.o.EMBED ? t.provider : null;
								s && !z.s.has(s) ? !n && e || this.toggleEmbedAutoplay(this.iframe, !e) : e || this.pauseEmbed(this.iframe, s)
							}
							e ? this.setState(e => e.shouldPause || !e.canLoadContent ? {
								canLoadContent: !0,
								shouldPause: !1,
								shouldStop: !1
							} : null) : this.setState(e => e.shouldPause ? null : {
								shouldPause: !0
							})
						}
					}, 250, {
						leading: !0
					}), this.toggleEmbedAutoplay = (e, t) => {
						if (e.contentWindow) {
							const n = t ? z.g.Pause : z.g.Play;
							e.contentWindow.postMessage({
								context: ce,
								method: n
							}, j.a), e.contentWindow.postMessage({
								context: ce,
								method: z.g.Mute
							}, j.a)
						}
					}, this.pauseEmbed = (e, t) => {
						e.contentWindow && (t === z.v.YouTube ? e.contentWindow.postMessage(JSON.stringify({
							event: "command",
							func: z.B.Pause
						}), j.a) : e.contentWindow.postMessage({
							context: ce,
							method: z.g.Pause
						}, j.a))
					}, this.onIframeLoaded = () => {
						const {
							media: e
						} = this.props.post, {
							autoplayPref: t
						} = this.props, n = e && e.type === z.o.EMBED ? e.provider : null;
						if (this.iframe && n && !z.s.has(n)) {
							const {
								shouldPause: e
							} = this.state;
							(t || e) && this.toggleEmbedAutoplay(this.iframe, e)
						}
					}, this.onClickRevealBlurred = e => {
						this.props.isListing && !this.props.isGalleryTileLayout || !this.shouldBlur() || this.state.isRevealed || (this.setState({
							isRevealed: !0
						}), e.preventDefault(), e.stopPropagation())
					}, this.storeChildRef = e => {
						this.iframe = e
					}, this.updateDimensions = () => {
						this.setState({
							viewportHeight: window.innerHeight,
							viewportWidth: window.innerWidth
						})
					}, this.isSpoiler = () => this.props.post.isSpoiler || !(!this.props.crosspost || !this.props.crosspost.isSpoiler), this.isNSFW = () => this.props.post.isNSFW || !(!this.props.crosspost || !this.props.crosspost.isNSFW), this.state = {
						canLoadContent: e.shouldLoad || !1,
						forcePause: !1,
						isRevealed: !1,
						shouldPause: void 0 === e.shouldPause || e.shouldPause,
						shouldStop: void 0 === e.shouldStop || e.shouldStop,
						viewportHeight: z.e,
						viewportWidth: z.f
					}
				}
				UNSAFE_componentWillMount() {
					"undefined" != typeof window && (this.updateDimensions(), window.addEventListener("resize", this.updateDimensions))
				}
				componentDidMount() {
					pe(this.props.post) && (this.visibilityChangeSubscriptionId = x.a.subscribe(e => {
						this.handleVisibilityChange(e)
					})), this.props.scrollerItemRef && he(this.props) && this.props.scrollerItemRef(this, this.state.canLoadContent)
				}
				componentWillUnmount() {
					this.visibilityChangeSubscriptionId && x.a.unsubscribe(this.visibilityChangeSubscriptionId), this.props.scrollerItemRef && he(this.props) && this.props.scrollerItemRef(void 0), window.removeEventListener("resize", this.updateDimensions)
				}
				UNSAFE_componentWillReceiveProps(e) {
					!this.state.canLoadContent && e.shouldLoad && this.setState({
						canLoadContent: !0
					}), void 0 !== e.shouldPause && e.shouldPause !== this.props.shouldPause && this.shouldFocusContentDebouncer(!e.shouldPause)
				}
				getAltText() {
					const {
						imgOCRAltTextVariant: e,
						OCRAltText: t,
						post: n,
						subredditOrProfileDisplayText: s,
						shouldShowAltText: o
					} = this.props;
					if (!o) return;
					let r = "";
					return s && (r += s), e === A.wb.OCR ? r += "".concat(re).concat(t) : n.title && (r += "".concat(re).concat(n.title)), e === A.wb.ShortPostTitleOCR && (r += "".concat(re).concat(t)), r.length > oe ? Object(v.a)(r, oe, m.cb) : r
				}
				getVideoExpandoMaxDimensions() {
					let e, t = Math.max(z.j, this.state.viewportHeight),
						n = Math.min(ie, 16 * t / 9);
					n === ie && (t = 9 * ie / 16), e = this.state.viewportWidth >= F.c ? this.state.viewportWidth < L.l ? this.state.viewportWidth - le - 2 * ae : this.state.viewportWidth - le - L.e - 2 * ae : this.state.viewportWidth - 2 * ae;
					const s = this.state.viewportHeight - 2 * ae;
					if (n > e) {
						t *= e / n, n = e
					} else if (t > s) {
						const e = s / t;
						t = s, n *= e
					}
					return {
						maxVideoHeight: t,
						maxVideoWidth: n
					}
				}
				getVideoMaxDimensions(e, t) {
					let n = z.j,
						s = z.n;
					return e.isExpando ? this.getVideoExpandoMaxDimensions() : (e.isPromotedTrend && (n = z.t, s = z.u), {
						maxVideoHeight: n,
						maxVideoWidth: s
					})
				}
				getMediaInfo(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
					const {
						availableWidth: n,
						isListing: s,
						post: o
					} = e;
					if (Object(z.H)(o.media)) return {
						source: o.media.scrubberThumbSource,
						width: this.state.viewportWidth - 2 * ae,
						height: this.state.viewportHeight - 2 * ae
					};
					const r = o.media && o.media.obfuscated || "";
					let i = !o.media || Object(z.L)(o.media) || Object(z.F)(o.media) ? "" : o.media.content,
						[a, c] = !o.media || Object(z.I)(o.media) || Object(z.K)(o.media) || Object(z.F)(o.media) ? [0, 0] : [o.media.height, o.media.width];
					if (n && o.media && Object(z.F)(o.media)) {
						a = Object(K.b)(o.media.mediaMetadata || {}, Object(K.c)(s), z.p, n) + z.i, c = n
					}
					if (n && o.media && (o.media.type === z.o.IMAGE || o.media.type === z.o.GIFVIDEO)) {
						const e = X.b(n, o.media.resolutions);
						e && (i = e.url, c = e.width, a = e.height)
					} else if (o && o.media && (!e.isListing || e.isExpando) && (o.media.type === z.o.IMAGE || o.media.type === z.o.GIFVIDEO)) {
						let e;
						(e = Object(z.J)(o.media.height, o.media.width) && Object(_.b)(o.media.height) ? X.c(o.media.height, o.media.width, o.media.resolutions) : X.a(o.media.resolutions)) && (i = e.url, c = e.width, a = e.height)
					}
					if (e.isExpando)
						if (c > t.viewportWidth) {
							a *= t.viewportWidth / c, c = t.viewportWidth
						} else if (a > t.viewportHeight) {
						const e = t.viewportHeight / a;
						a = t.viewportHeight, c *= e
					}
					const {
						maxVideoHeight: l,
						maxVideoWidth: d
					} = this.getVideoMaxDimensions(e, t);
					if (o.media && o.media.type === z.o.VIDEO) {
						const t = a / c;
						e.isExpando ? (a = l, c = d) : t > z.c ? (a = l, c = Math.min(Math.max(l / t, z.r), d)) : (a = Math.min(Math.max(d * t, z.q), l), c = d)
					}
					o.media && o.media.type === z.o.EMBED && e.isExpando && o.media.provider !== z.v.Twitter && (a = l, c = d);
					let u = !1;
					if (e.isMiniCard) {
						const e = a / c;
						u = Math.abs(e - z.c) > .01
					}
					return {
						source: i,
						obfuscated: r,
						width: c,
						height: a,
						needsBackgroundBlur: u
					}
				}
				shouldBlur() {
					const {
						isExpando: e,
						isOverlay: t,
						theme: n
					} = this.props, s = this.isNSFW(), o = this.isSpoiler();
					return !(e || this.state.isRevealed || t) && (s && !n.subredditContext.shouldShowNSFWContent || o)
				}
				render() {
					const {
						className: e,
						crosspost: t,
						flairStyleTemplate: n,
						forceAspectRatio: s,
						isCommentsPage: o,
						isExpando: r,
						isGalleryTileLayout: i,
						isListing: a,
						isMediumHeight: c,
						isNotCardView: d,
						isTitleOnly: u,
						post: p,
						showCentered: m,
						showFull: h = !1
					} = this.props, {
						canLoadContent: g,
						forcePause: x,
						shouldPause: v,
						shouldStop: O,
						viewportWidth: j
					} = this.state;
					if (!p.media) return null;
					const L = x || v,
						A = O,
						{
							source: F,
							obfuscated: D,
							height: q,
							width: G,
							needsBackgroundBlur: J
						} = this.getMediaInfo(this.props, this.state),
						Q = {
							showCentered: m,
							isListing: a,
							showFull: h,
							height: q,
							width: G
						},
						Z = Object.assign(Object.assign({}, Q), {
							className: e,
							forceAspectRatio: s,
							viewportWidth: j
						}),
						Y = this.shouldBlur(),
						X = !(!p.isSponsored || !p.source);
					if (D && Y) return l.a.createElement(k.a, te({}, Z, {
						blurSrc: D
					}), l.a.createElement(de, {
						isVisible: g
					}, l.a.createElement(_.a, te({}, Q, {
						altText: this.getAltText(),
						className: this.props.imageBoxClassName,
						contentImageClassName: this.props.imageBoxContentImageClassName,
						imageClassName: this.props.imageBoxClassName,
						isListing: a,
						isNSFW: this.isNSFW(),
						isSpoiler: this.isSpoiler(),
						isVideoThumbnail: !!p.media && p.media.type === z.o.VIDEO,
						onClick: this.onClickRevealBlurred,
						postId: p.id,
						shouldBlur: Y,
						source: D,
						outboundUrl: X && p.source.outboundUrl || void 0,
						originalSource: F
					}))));
					if (!p.media) return null;
					switch (p.media.type) {
						case z.o.RTJSON:
							const s = Object(U.a)(p, null);
							if (null === s) return;
							return h || Object(B.a)(p) ? l.a.createElement(l.a.Fragment, null, l.a.createElement(T.a, {
								canLoadContent: g,
								className: e,
								"data-click-id": "text",
								isCommentsPage: o,
								isExpando: r,
								isMediumHeight: c,
								isRichTextTruncated: p.media.isRichtextPreview,
								isTitleOnly: u,
								postId: p.id,
								showFull: h
							}, l.a.createElement(R.a, {
								altText: this.getAltText(),
								flairStyleTemplate: n,
								content: p.isMeta ? Object(W.a)(s, p.id) : s,
								mediaMetadata: p.media.mediaMetadata,
								postId: p.id,
								rtJsonElementProps: xe(this.props),
								renderMediaAsLinks: a
							})), l.a.createElement(E.a, {
								postId: p.id,
								isCommentsPage: !!o
							})) : null;
						case z.o.TEXT:
							if (Object(H.a)(p)) {
								const t = "Text post should not include body content";
								return y.c.withScope(e => {
									e.setExtra("info", {
										post: p,
										isListing: a,
										isCommentsPage: o
									}), y.c.captureMessage(t)
								}), Object(b.a)() && console.log("".concat(p.id, ": ").concat(t)), l.a.createElement(T.a, {
									postId: p.id,
									className: e,
									"data-click-id": "text",
									isCommentsPage: o,
									showFull: h
								}, l.a.createElement(N.a, {
									flairStyleTemplate: n,
									html: p.isMeta ? Object(V.a)(p.media.content, p.id, ee.a.hiddenLink) : p.media.content
								}))
							}
							return null;
						case z.o.EMBED:
							return this.props.isMiniCard && p.preview && p.preview.url ? l.a.createElement(k.a, te({}, Z, {
								alwaysWrapMedia: !0
							}), l.a.createElement(de, {
								isVisible: g
							}, l.a.createElement(l.a.Fragment, null, l.a.createElement(_.a, te({}, Q, {
								className: this.props.imageBoxClassName,
								contentImageClassName: this.props.imageBoxContentImageClassName,
								imageClassName: this.props.imageBoxClassName,
								isExpando: r,
								isListing: a,
								isNSFW: this.isNSFW(),
								isCrosspost: !!t,
								isSpoiler: this.isSpoiler(),
								postId: p.id,
								shouldBlur: Y,
								source: p.preview.url,
								originalSource: p.preview.url
							})), l.a.createElement(M.a, null)))) : z.h.has(p.media.provider) ? p.media.provider === z.v.Twitter ? l.a.createElement(I.a, {
								canLoadContent: g,
								embedBoxChildRef: this.storeChildRef,
								media: p.media,
								mediaContainerProps: Z,
								onIframeLoaded: this.onIframeLoaded,
								source: F,
								title: p.title
							}) : l.a.createElement(k.a, te({}, Z, {
								alwaysWrapMedia: !0,
								height: r ? q : z.j,
								width: r ? G : z.j * (16 / 9)
							}), g && l.a.createElement(w.a, {
								childRef: this.storeChildRef,
								height: r ? q : z.j,
								width: r ? G : void 0,
								isListing: a,
								isResponsive: !0,
								onLoad: this.onIframeLoaded,
								showCentered: m,
								showFull: h,
								source: F,
								title: p.title
							})) : l.a.createElement(k.a, te({}, Z, {
								alwaysWrapMedia: !0
							}), g && l.a.createElement(w.a, te({}, Q, {
								isResponsive: r || p.media.provider === z.v.IFrameEmbed,
								title: p.title,
								childRef: this.storeChildRef,
								onLoad: this.onIframeLoaded,
								source: F,
								fullWidth: p.media.provider === z.v.IFrameEmbed
							})));
						case z.o.GIFVIDEO: {
							let e = q,
								t = G;
							return e > z.j && (t = G / q * (e = z.j)), l.a.createElement(k.a, te({}, Z, {
								blurSrc: J ? p.media.gifBackgroundImage : void 0
							}), l.a.createElement(de, {
								isVisible: g
							}, l.a.createElement(P.a, te({}, Q, {
								isNotCardView: d,
								height: r ? void 0 : e,
								width: r ? void 0 : t,
								postId: p.id,
								shouldLoad: !0,
								shouldPause: L,
								source: F,
								originalSource: p.media.content
							}))))
						}
						case z.o.VIDEO: {
							const e = p.media.posterUrl || p.preview && p.preview.url;
							if (this.props.isMiniCard && e) return l.a.createElement(k.a, te({}, Z, {
								alwaysWrapMedia: !0
							}), l.a.createElement(de, {
								isVisible: g
							}, l.a.createElement(l.a.Fragment, null, l.a.createElement(_.a, te({}, Q, {
								className: this.props.imageBoxClassName,
								contentImageClassName: this.props.imageBoxContentImageClassName,
								imageClassName: this.props.imageBoxClassName,
								isExpando: r,
								isListing: a,
								isNSFW: this.isNSFW(),
								isCrosspost: !!t,
								isSpoiler: this.isSpoiler(),
								postId: p.id,
								shouldBlur: Y,
								source: e,
								originalSource: e
							})), l.a.createElement(M.a, null))));
							const n = l.a.createElement(k.a, te({}, Z, {
								alwaysWrapMedia: !0,
								isVideo: !0
							}), g && l.a.createElement(se, {
								autoPlay: "boolean" == typeof v ? !v : void 0,
								isExpando: r,
								shouldLoad: !0,
								shouldPause: L,
								shouldStop: A,
								hlsSource: p.media.hlsUrl,
								mpegDashSource: p.media.dashUrl,
								isGif: p.media.isGif,
								scrubberThumbSource: p.media.scrubberThumbSource,
								postId: p.id,
								callToActionSource: p.source || void 0,
								callToActionText: p.callToAction,
								isListing: a,
								posterUrl: p.media.posterUrl,
								muxVideoDuration: void 0,
								muxVideoId: p.id,
								muxVideoIsLive: !1,
								muxVideoTitle: p.title
							}));
							return p.isSponsored ? l.a.createElement(C.a, {
								post: p,
								trackVideo: !0
							}, n) : n
						}
						case z.o.LIVEVIDEO:
							return l.a.createElement(de, {
								isVisible: g
							}, l.a.createElement(ne, {
								canLoad: g,
								postId: p.id,
								postTitle: p.title,
								shouldPause: L || A,
								url: p.media.hlsUrl
							}));
						case z.o.IMAGE:
							const x = this.state.viewportHeight - 2 * ae,
								O = this.state.viewportWidth - 2 * ae;
							let j = F;
							return this.props.isMiniCard && !this.props.isMiniCardHQPreviews && (p.thumbnail && Object(f.a)(p.thumbnail.url) ? j = p.thumbnail.url : p.preview && Object(f.a)(p.preview.url) && (j = p.preview.url)), l.a.createElement(k.a, te({}, Z, {
								blurSrc: J ? j : void 0,
								isExpando: !!r
							}), l.a.createElement(de, {
								isVisible: g
							}, l.a.createElement(_.a, te({}, Q, {
								altText: this.getAltText(),
								className: this.props.imageBoxClassName,
								contentImageClassName: this.props.imageBoxContentImageClassName,
								imageClassName: this.props.imageBoxClassName,
								isExpando: r,
								isListing: a,
								isNSFW: this.isNSFW(),
								isCrosspost: !!t,
								isSpoiler: this.isSpoiler(),
								maxHeight: r ? x : void 0,
								maxWidth: r ? O : void 0,
								postId: p.id,
								shouldBlur: Y,
								source: j,
								outboundUrl: X && p.source.outboundUrl || void 0,
								isSponsored: p.isSponsored,
								originalSource: p.media.content
							}))));
						case z.o.GALLERY:
							const D = Object(K.b)(p.media.mediaMetadata || {}, Object(K.c)(a), z.p, G),
								$ = Object(K.a)(p.media.gallery, p.isSponsored);
							return l.a.createElement(k.a, te({}, Z, {
								blurSrc: J ? F : void 0,
								isExpando: !!r,
								maxGalleryHeight: D + $,
								className: ee.a.galleryMediaContainer,
								isGalleryTileLayout: i
							}), l.a.createElement(de, {
								isVisible: g
							}, l.a.createElement(S.a, {
								postId: p.id,
								galleryItems: p.media.gallery ? p.media.gallery.items : [],
								mediaMetadata: p.media.mediaMetadata || {},
								imageHeight: D,
								captionHeight: $,
								isSponsored: p.isSponsored,
								className: this.props.imageBoxClassName,
								isListing: a,
								isNSFW: this.isNSFW(),
								isSpoiler: this.isSpoiler(),
								shouldBlur: Y,
								onClickRevealBlurred: this.onClickRevealBlurred,
								isTileLayout: !!i,
								shouldShowTileLayoutOption: this.props.shouldShowGalleryTileOption
							})));
						default:
							return null
					}
				}
			}
			t.a = be(ge(Object(h.a)(ye)))
		},
		"./src/reddit/components/ModalStyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				CloseIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				closeIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				ModalBody: "_2R3RlhymCOkPrz9TusvcPq",
				modalBody: "_2R3RlhymCOkPrz9TusvcPq",
				ModalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				modalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				ModalText: "mFTHPdbEAklUs8yhT4Xm7",
				modalText: "mFTHPdbEAklUs8yhT4Xm7",
				ModalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				modalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				ModalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				modalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				ModalMetaText: "_27eskYssCs-urVW1uHI4YI",
				modalMetaText: "_27eskYssCs-urVW1uHI4YI",
				ModalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				modalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				ModalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				modalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				ModalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				modalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				ModalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				modalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				ModalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				modalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				ModalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				modalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				ModalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				modalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				ModalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				modalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				TextArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				textArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				WarningButton: "_17UyTSs2atqnKg9dIq5ERg",
				warningButton: "_17UyTSs2atqnKg9dIq5ERg",
				PrimaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				primaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				CancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				cancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				RemoveButton: "_2ulRgczjI5SWCMgSA1CNLj",
				removeButton: "_2ulRgczjI5SWCMgSA1CNLj"
			}
		},
		"./src/reddit/components/ModalStyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "p", (function() {
				return C
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "s", (function() {
				return j
			})), n.d(t, "t", (function() {
				return w
			})), n.d(t, "q", (function() {
				return S
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "r", (function() {
				return k
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/controls/Button/index.tsx"),
				r = n("./src/reddit/controls/Input/ModalInput.tsx"),
				i = n("./src/reddit/icons/svgs/Close/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.m.less"),
				c = n.n(a);
			const l = s.a.wrapped(i.a, "CloseIcon", c.a),
				d = s.a.section("ModalBody", c.a),
				u = s.a.section("ModalPostPreview", c.a),
				p = s.a.p("ModalText", c.a),
				m = s.a.div("ModalSmallText", c.a),
				h = s.a.div("ModalDescriptionText", c.a),
				b = s.a.div("ModalMetaText", c.a),
				f = s.a.label("ModalFormItem", c.a),
				g = s.a.wrapped(r.a, "ModalInput", c.a),
				x = s.a.label("ModalInputLabel", c.a),
				y = s.a.footer("ModalFooter", c.a),
				v = s.a.header("ModalHeader", c.a),
				C = s.a.div("ModalTitle", c.a),
				E = s.a.div("ModalAnnotation", c.a),
				O = s.a.div("ModalMain", c.a),
				j = s.a.textarea("TextArea", c.a),
				w = s.a.wrapped(o.f, "WarningButton", c.a),
				S = s.a.wrapped(o.f, "PrimaryButton", c.a),
				_ = s.a.wrapped(o.i, "CancelButton", c.a),
				k = s.a.wrapped(o.n, "RemoveButton", c.a)
		},
		"./src/reddit/components/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				_Dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				MenuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				menuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				mIsEnabled: "uMPgOFYlCc5uvpa2Lbteu",
				MenuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				menuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				DropdownRow: "_2DO72U0b_6CUw3msKGrnnT",
				dropdownRow: "_2DO72U0b_6CUw3msKGrnnT"
			}
		},
		"./src/reddit/components/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/Row.tsx"),
				h = n("./src/reddit/icons/fonts/Menu/index.tsx"),
				b = n("./src/reddit/selectors/tooltip.ts"),
				f = n("./src/reddit/components/OverflowMenu/index.m.less"),
				g = n.n(f);
			const x = l.a.wrapped(p.a, "_Dropdown", g.a),
				y = Object(u.a)(x),
				v = l.a.button("MenuButton", g.a),
				C = l.a.wrapped(h.a, "MenuIcon", g.a),
				E = l.a.wrapped(m.b, "DropdownRow", g.a),
				O = Object(a.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(b.b)(n)(e)
					}
				}),
				j = Object(i.b)(O, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(d.h)({
							tooltipId: n
						}))
					}
				}),
				w = e => t => {
					e.onClick && e.onClick(), e.toggleDropdown(), t.stopPropagation()
				};
			t.b = j(e => r.a.createElement(v, {
				"aria-expanded": e.dropdownIsOpen,
				"aria-haspopup": !0,
				"aria-label": s.fbt._("more options", null, {
					hk: "2EnY1x"
				}),
				className: Object(c.a)(e.className, {
					[g.a.mIsEnabled]: !e.disabled && !e.defaultButtonOutline
				}),
				disabled: e.disabled,
				onClick: w(e),
				onMouseDown: e.handleMouseDown,
				id: e.dropdownId
			}, e.icon ? e.icon : r.a.createElement(C, null), r.a.createElement(y, {
				className: e.dropdownClassName,
				isOpen: e.dropdownIsOpen,
				tooltipId: e.dropdownId,
				isFixed: e.isFixed,
				targetPosition: e.targetPosition,
				tooltipPosition: e.tooltipPosition
			}, e.children)))
		},
		"./src/reddit/components/OverlayAwareTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/reddit/constants/elementIds.ts"),
				a = n("./src/reddit/contexts/InsideOverlay.tsx");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function l(e, t) {
				const n = Object(r.a)(e, t);
				class s extends o.a.PureComponent {
					constructor() {
						super(...arguments), this.state = {
							container: null
						}
					}
					componentDidMount() {
						if (this.props.isOverlay) {
							const e = document.getElementById(i.d);
							this.setState({
								container: e
							})
						}
					}
					render() {
						return o.a.createElement(n, c({}, this.props, {
							container: this.state.container,
							excludeContainerPosition: this.props.isOverlay
						}))
					}
				}
				return Object(a.b)(s)
			}
		},
		"./src/reddit/components/Poll/MetaData/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/timeAgo/index.ts"),
				r = n("./src/lib/timeUntil/index.ts"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i);

			function c(e) {
				const t = new Date(e.poll.endsAt).getTime() - Date.now() <= 0;
				return a.a.createElement("span", {
					className: e.className
				}, t ? s.fbt._("Voting closed {timeAgo}", [s.fbt._param("timeAgo", Object(o.d)(e.poll.endsAt / 1e3))], {
					hk: "3OERID"
				}) : Object(r.a)(new Date(e.poll.endsAt)))
			}
		},
		"./src/reddit/components/PollCreator/DefaultHintText/index.m.less": function(e, t, n) {
			e.exports = {
				helpTextItem: "wYdL1V7fxOtMwgvL8gt4a",
				helpTextList: "_23_RY8_TK404O0hdN7zpNn",
				helpTitle: "_3qXjOYMFBOO47HoteguQiz",
				helpTitleText: "_1NjVVC7kcVvJTLxxbNEi0S",
				infoIcon: "_2EKnk91_WzE7ao5vX6K5cC"
			}
		},
		"./src/reddit/components/PollCreator/Option/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1RbFYzRB1jybmSRJ1VD_3f",
				grapple: "_3uUTBg1zNH9BKBOP3vVw6R",
				input: "CdINWDy27JLWIBXz488aN",
				trash: "_3AvADfaxGi-rnV-WFuWxTA"
			}
		},
		"./src/reddit/components/PollCreator/index.m.less": function(e, t, n) {
			e.exports = {
				flexRow: "_2G4E6Ja1LjN3lvEFdvCAMM",
				addButton: "_1MW4m9_ojHA4AO_I1MhQf3",
				container: "_3S9C536IVs6t9fXO2fE_Yq",
				controls: "_2RaOqu97VZrV7eSMAd--Fj",
				help: "_1kYOBe87AO-Ly-PkWe8yd8",
				options: "_26J8Tm1n-2QR6K2VOyZvJk",
				votingLengthCaret: "ekKR9rTD5h3p7yQ4SaLoa",
				votingLengthDropdown: "_1Sbl_DKDMJM71lJ_1GQgbB",
				votingLengthDropdownContainer: "_24W8XLxQSgwVVFneYfHsJR",
				votingLengthSelector: "_3TH3dFaVjJ2OSx-B_N3pDU",
				votingLengthSelector__disabled: "_2Wc5VFPksdxez0HQRlpdeE",
				votingLengthSelectorDisabled: "_2Wc5VFPksdxez0HQRlpdeE",
				votingLengthTitleText: "_1-ozAll8fJXOJ9tr9TwS1r",
				votingLengthDisplay: "gj1NXudk861pHzMz3jvCj"
			}
		},
		"./src/reddit/components/Portal/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js"),
				o = n("./src/lib/CSSVariableProvider/index.tsx");
			class r extends s.PureComponent {
				render() {
					const {
						children: e,
						container: t
					} = this.props;
					return Object(o.d)(e, t || document.body)
				}
			}
		},
		"./src/reddit/components/PostBadges/index.m.less": function(e, t, n) {
			e.exports = {
				adminIcon: "_1cje4rrmwL0yZgCOlGyBJ-",
				approveIcon: "_1knR9NIIXdSFC9IeFN11JL",
				automoderator: "_2etEb_0bRB9axAqF3uX28S",
				icon: "_3vju76MdF2FaGmELBeiJ_r",
				lockIcon: "_3wTfn3Meg1rXJ-qd2jUWMt",
				modIcon: "_SMl46gACTEszA_4A0Qfs",
				removeIcon: "_3yuF1RnBRJL4OS_STsoXcC",
				reportIcon: "_3guZWUAROueft8TPPGDZ-R",
				spamIcon: "_2BWw37nLL0rX6n7xcXciyD",
				stickyIcon: "NI8uZ-19oHf9gPO8jOvFu",
				isRemoved: "_27iLVqax1FuPWTymkSkKAq",
				archivedIcon: "_2WSiH2JwZq4bXuvrDn-cgU",
				addRemovalReason: "COGitU-ItwLZG_fP5rsdE",
				removalReason: "_16Ih3bzeELRlI6AWeW-nFy"
			}
		},
		"./src/reddit/components/PostBadges/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				p = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				m = n("./src/reddit/constants/posts.ts"),
				h = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/helpers/isRemoved.ts"),
				f = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				g = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				x = n("./src/reddit/models/Post/index.ts"),
				y = n("./src/reddit/selectors/posts.ts"),
				v = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				C = n("./src/reddit/icons/fonts/Archived/index.tsx"),
				E = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				O = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				j = n("./src/reddit/icons/fonts/Report/index.tsx"),
				w = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				S = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				_ = n("./src/reddit/icons/svgs/Automoderator/index.tsx"),
				k = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				T = n("./src/reddit/components/PostBadges/index.m.less"),
				I = n.n(T);

			function P() {
				return (P = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const M = e => r.a.createElement("span", P({
					className: I.a.removalReason
				}, e), e.children),
				N = () => s.fbt._("Archived", null, {
					hk: "zv3q3"
				}),
				R = () => s.fbt._("Comments are locked", null, {
					hk: "8HjJ9"
				}),
				L = e => s.fbt._("Moderator of {community name}", [s.fbt._param("community name", e)], {
					hk: "nJqIB"
				}),
				A = () => s.fbt._("Stickied post", null, {
					hk: "3qSaBs"
				}),
				F = () => s.fbt._("Pinned post", null, {
					hk: "2oxErI"
				}),
				D = (e, t, n) => {
					const s = "PostBadges--".concat(e, "--").concat(t);
					return n ? "".concat(s, "--").concat(n) : s
				},
				B = Object(h.t)({
					isProfilePostListing: h.I,
					isSubreddit: h.K,
					pageLayer: e => e
				}),
				U = Object(a.c)({
					isPinned: (e, t) => {
						let {
							post: n
						} = t;
						return Object(y.u)(e, {
							postId: n.id
						})
					},
					modModeEnabled: h.P
				}),
				K = Object(i.b)(U, (e, t) => ({
					onHideTooltip: () => e(Object(d.i)()),
					onOpenRemovalReasonModal: () => {
						n.e("removalReasonActions").then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(n => e(n.fetchReasonsAndOpenModal(t.post.belongsTo.id, [t.post.id])))
					},
					onShowTooltip: t => () => e(Object(d.f)({
						tooltipId: t
					}))
				}));
			t.a = B(K(e => {
				let {
					className: t,
					displayText: n,
					isSubreddit: i,
					inSubredditOrProfile: a,
					isCompactPinnedPost: d,
					isPinned: h,
					isProfilePostListing: y,
					modModeEnabled: T,
					onHideTooltip: B,
					onOpenRemovalReasonModal: U,
					onShowTooltip: K,
					post: H,
					tooltipType: V
				} = e;
				const W = {
						caretOnTop: !1
					},
					z = H.isRemoved && !H.modRemovalReason && !H.modNote && H.belongsTo.type === m.a.SUBREDDIT,
					q = D("Approve", H.id, V),
					G = D("Archived", H.id, V),
					J = D("Automod", H.id, V),
					Q = D("Lock", H.id, V),
					Z = D("Mod", H.id, V),
					Y = D("Remove", H.id, V),
					X = D("Report", H.id, V),
					$ = D("Spam", H.id, V),
					ee = D("Sticky", H.id, V),
					te = D("Pinned", H.id, V);
				return r.a.createElement("div", {
					className: t
				}, a && n && H.distinguishType === l.C.MODERATOR && r.a.createElement(o.Fragment, null, r.a.createElement(k.a, {
					className: I.a.modIcon,
					desc: L(n),
					id: Z,
					onMouseEnter: K(Z),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: Z,
					text: L(n)
				}, W))), H.isArchived && r.a.createElement(o.Fragment, null, r.a.createElement(C.a, {
					className: I.a.archivedIcon,
					desc: N(),
					id: G,
					onMouseEnter: K(G),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: G,
					text: N()
				}, W))), H.isLocked && r.a.createElement(o.Fragment, null, r.a.createElement(E.a, {
					className: I.a.lockIcon,
					desc: R(),
					id: Q,
					onMouseEnter: K(Q),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: Q,
					text: R()
				}, W))), i && Object(x.k)(H) && !d && r.a.createElement(o.Fragment, null, r.a.createElement(S.a, {
					className: I.a.stickyIcon,
					desc: A(),
					id: ee,
					onMouseEnter: K(ee),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: ee,
					text: A()
				}, W))), y && h && r.a.createElement(o.Fragment, null, r.a.createElement(S.a, {
					className: I.a.stickyIcon,
					desc: F(),
					id: te,
					onMouseEnter: K(te),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: te,
					text: F()
				}, W))), (H.isApproved || H.approvedBy) && r.a.createElement(o.Fragment, null, r.a.createElement(v.a, {
					className: I.a.approveIcon,
					desc: Object(f.a)(H),
					id: q,
					onMouseEnter: K(q),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: q,
					text: Object(f.a)(H)
				}, W))), Object(b.a)(H) && r.a.createElement(o.Fragment, null, r.a.createElement(O.a, {
					className: I.a.removeIcon,
					desc: Object(f.c)(H),
					id: Y,
					onMouseEnter: K(Y),
					onMouseLeave: B
				}), z && r.a.createElement(p.a, {
					className: I.a.addRemovalReason,
					onClick: U,
					text: s.fbt._("Add a removal reason", null, {
						hk: "1YDo3"
					})
				}), (H.modRemovalReason || H.modNote) && r.a.createElement(M, {
					onMouseEnter: K(Y),
					onMouseLeave: B
				}, s.fbt._("Removal reason", null, {
					hk: "2DhKVZ"
				})), r.a.createElement(u.c, P({
					tooltipId: Y,
					text: Object(f.c)(H)
				}, W))), H.bannedBy && H.isSpam && r.a.createElement(o.Fragment, null, r.a.createElement(w.a, {
					className: I.a.spamIcon,
					desc: Object(f.e)(H),
					id: $,
					onMouseEnter: K($),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: $,
					text: Object(f.e)(H)
				}, W))), ("AutoModerator" === H.approvedBy || "AutoModerator" === H.bannedBy) && r.a.createElement(o.Fragment, null, r.a.createElement(_.a, {
					className: Object(c.a)(I.a.automoderator, !!H.bannedBy && I.a.isRemoved),
					desc: f.b,
					id: J,
					onMouseEnter: K(J),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: J,
					text: f.b
				}, W))), Object(g.a)(H) && !T && r.a.createElement(o.Fragment, null, r.a.createElement(j.a, {
					className: I.a.reportIcon,
					desc: Object(f.d)(H.numReports),
					id: X,
					onMouseEnter: K(X),
					onMouseLeave: B
				}), r.a.createElement(u.c, P({
					tooltipId: X,
					text: Object(f.d)(H.numReports)
				}, W))))
			}))
		},
		"./src/reddit/components/PostCreationForm/Button/index.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_18Bo5Wuo3tMV-RDB8-kh8Z",
				primaryButton: "_18Bo5Wuo3tMV-RDB8-kh8Z",
				SecondaryButton: "lUsjLveKkZWUAgDDyU1rD",
				secondaryButton: "lUsjLveKkZWUAgDDyU1rD"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1IZotn_IQQ1fgtUjaFYbkd",
				onHoverActionText: "_1Zlk1VrZ8puYZy5lJOfz--",
				Container: "_1IZotn_IQQ1fgtUjaFYbkd",
				PostTitle: "_1hzDym_NpIlizkTDXc_rQj",
				postTitle: "_1hzDym_NpIlizkTDXc_rQj",
				MetaLine: "_67JuJTdFwIJPLPDkyPX-f",
				metaLine: "_67JuJTdFwIJPLPDkyPX-f",
				SubredditName: "_88OYON0K3w_tpnmCSWlUX",
				subredditName: "_88OYON0K3w_tpnmCSWlUX",
				InfoSpan: "_3DFfW-OG-MvCLiiEN18mpq",
				infoSpan: "_3DFfW-OG-MvCLiiEN18mpq"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				TopRow: "vuQEtla32r0kemmh11Hov",
				topRow: "vuQEtla32r0kemmh11Hov",
				TitleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				titleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				DetailsContainer: "_87UrrqUro4oVpXFAElZUX",
				detailsContainer: "_87UrrqUro4oVpXFAElZUX",
				ButtonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				buttonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				CloseWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				closeWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				Close: "_1TaKYhB80ExuTPoLaQZMRE",
				close: "_1TaKYhB80ExuTPoLaQZMRE",
				Empty: "_20K7F6rAgXGH5z83v7Ifiv",
				empty: "_20K7F6rAgXGH5z83v7Ifiv",
				EmptyImage: "_2eLeResic3Gc77W_edgNGt",
				emptyImage: "_2eLeResic3Gc77W_edgNGt",
				EmptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				emptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				FilterWrapper: "pKfhphFBuya82DYP2Q90X",
				filterWrapper: "pKfhphFBuya82DYP2Q90X",
				FilterInput: "_3W5cary86KmYWrVgEpGKPb",
				filterInput: "_3W5cary86KmYWrVgEpGKPb",
				SearchIcon: "_9T_dguVcd795c_vOyl9s4",
				searchIcon: "_9T_dguVcd795c_vOyl9s4",
				PlusIcon: "hfmgzmXCLe3hvSyZad9WP",
				plusIcon: "hfmgzmXCLe3hvSyZad9WP",
				CreateCollectionButton: "_34_h0zRV3AgFr_0sh99pKz",
				createCollectionButton: "_34_h0zRV3AgFr_0sh99pKz"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/memoizeByReference/index.ts"),
				u = n("./src/reddit/actions/postCreation/general.ts"),
				p = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/constants/keycodes.ts"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/Input/index.tsx"),
				f = n("./src/reddit/icons/svgs/Close/index.tsx"),
				g = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				x = n("./src/reddit/icons/svgs/Search/index.tsx"),
				y = n("./src/reddit/layout/row/Inline/index.tsx"),
				v = n("./src/reddit/models/PostCreationForm/index.ts"),
				C = n("./src/reddit/selectors/postCollection.ts"),
				E = n("./src/lib/timeAgo/index.ts"),
				O = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				j = n("./src/reddit/helpers/name/index.ts"),
				w = n("./src/reddit/models/Subreddit/index.ts"),
				S = n("./src/reddit/models/User/index.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/selectors/user.ts"),
				T = n("./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less"),
				I = n.n(T),
				P = n("./src/lib/lessComponent.tsx");
			const {
				fbt: M
			} = n("./node_modules/fbt/lib/FbtPublic.js"), N = P.a.div("Container", I.a), R = P.a.h2("PostTitle", I.a), L = P.a.div("MetaLine", I.a), A = P.a.span("SubredditName", I.a), F = P.a.time("InfoSpan", I.a), D = Object(c.c)({
				subreddit: (e, t) => {
					let {
						collection: {
							subredditId: n
						}
					} = t;
					return n ? Object(_.S)(e, {
						subredditId: n
					}) : void 0
				},
				user: k.i
			});
			class B extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onClick = () => {
						this.props.onClick(this.props.collection.id)
					}
				}
				render() {
					const {
						collection: e,
						subreddit: t,
						user: n,
						onHoverActionText: s
					} = this.props, o = t && Object(w.g)(t) && n ? Object(j.c)(Object(S.e)(n)) : t ? t.displayText : "", r = e.postIds.length;
					return i.a.createElement(N, {
						onClick: this.onClick,
						className: I.a.container
					}, i.a.createElement(R, {
						"data-redditstyle": !0
					}, e.title), i.a.createElement(L, {
						"data-redditstyle": !0
					}, o && i.a.createElement(A, {
						"data-redditstyle": !0
					}, o), o && i.a.createElement(O.b, null), i.a.createElement(F, null, M._({
						"*": "{number of posts} posts",
						_1: "1 post"
					}, [M._plural(r, "number of posts")], {
						hk: "1Uy96U"
					})), i.a.createElement(O.b, null), i.a.createElement(F, null, M._("created {time}", [M._param("time", Object(E.d)(e.createdAtUTC))], {
						hk: "2cUc5m"
					}))), s && i.a.createElement("div", {
						className: I.a.onHoverActionText
					}, i.a.createElement("span", null, s)))
				}
			}
			var U = Object(a.b)(D)(B),
				K = n("./src/reddit/helpers/trackers/postCollection.ts"),
				H = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less"),
				V = n.n(H);
			const W = "".concat(s.a.assetPath, "/img/snoo-drafts.png"),
				z = P.a.div("TopRow", V.a),
				q = P.a.div("TitleRow", V.a),
				G = P.a.div("DetailsContainer", V.a),
				J = P.a.wrapped(y.a, "ButtonRow", V.a),
				Q = P.a.div("CloseWrapper", V.a),
				Z = P.a.wrapped(f.a, "Close", V.a),
				Y = P.a.div("Empty", V.a),
				X = P.a.img("EmptyImage", V.a),
				$ = P.a.p("EmptyText", V.a),
				ee = P.a.div("FilterWrapper", V.a),
				te = P.a.wrapped(b.a, "FilterInput", V.a),
				ne = P.a.wrapped(x.a, "SearchIcon", V.a),
				se = P.a.wrapped(g.a, "PlusIcon", V.a),
				oe = P.a.wrapped(h.j, "CreateCollectionButton", V.a),
				re = Object(d.a)((e, t) => {
					const n = t.toLowerCase();
					return e.filter(e => e.title.toLowerCase().includes(n))
				}),
				ie = Object(c.c)({
					collections: C.w
				}),
				ae = Object(a.b)(ie, (e, t) => {
					let {
						postId: n,
						isOverlay: s
					} = t;
					return {
						onOpenCreateCollectionModal: () => {
							let t = v.b;
							n && (t = Object(v.t)(n, !!s)), e(Object(u.x)(t))
						}
					}
				});
			class ce extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						filterStr: ""
					}, this.close = () => {
						this.props.sendEvent(Object(K.c)()), this.props.onClose()
					}, this.handleEscapeKey = e => {
						e.keyCode === m.a.Escape && this.close()
					}, this.handleCreateCollectionClicked = () => {
						this.props.onOpenCreateCollectionModal(), this.props.sendEvent(Object(K.j)())
					}, this.handleCollectionSelected = e => {
						this.props.onSelectCollection(e), this.props.sendEvent(Object(K.q)())
					}, this.onFilterStringChange = e => {
						this.setState({
							filterStr: e.target.value
						})
					}, this.renderItem = e => i.a.createElement(U, {
						key: e.id,
						collection: e,
						onClick: () => this.handleCollectionSelected(e),
						onHoverActionText: this.props.onItemHoverActionText
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey), this.props.sendEvent(Object(K.d)())
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderNoCollections() {
					return i.a.createElement(Y, null, i.a.createElement(X, {
						src: W
					}), i.a.createElement($, null, o.fbt._("Your collections will live here", null, {
						hk: "FCxWg"
					})))
				}
				renderNoFilterMatches() {
					return i.a.createElement(Y, null, i.a.createElement($, null, o.fbt._("No collection matching filter", null, {
						hk: "2vawdK"
					}), ";"))
				}
				render() {
					const {
						collections: e,
						titleText: t
					} = this.props;
					let n;
					if (0 === e.length) n = this.renderNoCollections();
					else {
						const t = re(e, this.state.filterStr);
						n = 0 === t.length ? this.renderNoFilterMatches() : t.map(this.renderItem)
					}
					return i.a.createElement("div", {
						className: V.a.wrapper,
						"data-redditstyle": !0
					}, i.a.createElement(z, null, i.a.createElement(q, {
						"data-redditstyle": !0
					}, t || o.fbt._("My collections", null, {
						hk: "3yKovS"
					}), i.a.createElement(Q, {
						onClick: this.close
					}, i.a.createElement(Z, {
						"data-redditstyle": !0
					}))), i.a.createElement(ee, null, i.a.createElement(ne, null), i.a.createElement(te, {
						placeholder: o.fbt._("Find a collection", null, {
							hk: "3DbFBU"
						}),
						value: this.state.filterStr,
						onChange: this.onFilterStringChange
					}))), i.a.createElement(G, null, n), i.a.createElement(J, null, i.a.createElement(oe, {
						onClick: this.handleCreateCollectionClicked
					}, i.a.createElement(se, null), o.fbt._("Create a collection", null, {
						hk: "37xJVm"
					}))))
				}
			}
			const le = Object(l.a)(ae(Object(p.c)(ce)));
			t.a = le
		},
		"./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/OCDisclaimer/index.m.less": function(e, t, n) {
			e.exports = {
				DontShowButton: "_1GOEXFnWfJy7WEF43f7RJk",
				dontShowButton: "_1GOEXFnWfJy7WEF43f7RJk",
				Component: "w3m9FyPsy2phDlWxoznhq",
				component: "w3m9FyPsy2phDlWxoznhq"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/PostModifierButton/index.m.less": function(e, t, n) {
			e.exports = {
				PostModifierButton: "_5x1WjCc4HQF6tqnODOql0",
				postModifierButton: "_5x1WjCc4HQF6tqnODOql0",
				TintOverlay: "stbc2Exoq0W4ZkGltglct",
				tintOverlay: "stbc2Exoq0W4ZkGltglct",
				isDisabled: "_3rEHSruwAvICnPAngYiIW1",
				HoverTooltip: "zprH8YpG-gVpFuEr-eQJw",
				hoverTooltip: "zprH8YpG-gVpFuEr-eQJw",
				mShiftTooltipToTheRight: "gceWvjO6tPHW1sEDhwkGK"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/index.m.less": function(e, t, n) {
			e.exports = {
				CalendarIcon: "_2EMgBR7XXJPBqzlciwA5q-",
				calendarIcon: "_2EMgBR7XXJPBqzlciwA5q-",
				ChatIcon: "Tb5Juq1WzFvhLo_xE7E0U",
				chatIcon: "Tb5Juq1WzFvhLo_xE7E0U",
				PencilIcon: "_3fLEcC4lV7R4T0nWSix8gz",
				pencilIcon: "_3fLEcC4lV7R4T0nWSix8gz",
				CheckmarkIcon: "_1UzslKYEQzOzo6YjHnE2g",
				checkmarkIcon: "_1UzslKYEQzOzo6YjHnE2g",
				PlusIcon: "_3KTRWtVakNSggrbPPnHkHf",
				plusIcon: "_3KTRWtVakNSggrbPPnHkHf",
				FlairComponent: "_2YM79GnDqrRjQQcFtEokkY",
				flairComponent: "_2YM79GnDqrRjQQcFtEokkY",
				FlairTextWrapper: "_1pXTTYLLHHqfgwyMuCqT6T",
				flairTextWrapper: "_1pXTTYLLHHqfgwyMuCqT6T",
				ModifierRow: "_2_rA2mCdhHc1Lr7Ff1ygvH",
				modifierRow: "_2_rA2mCdhHc1Lr7Ff1ygvH",
				AddFlair: "_1LD2Xsr3fioSkWZ13vMORC",
				addFlair: "_1LD2Xsr3fioSkWZ13vMORC",
				TintOverlay: "_2vWD8kW1_iU4dc3CgY9_gH",
				tintOverlay: "_2vWD8kW1_iU4dc3CgY9_gH",
				FlairIcon: "_2U5dhGN1LkTGmvfDSXp7Pn",
				flairIcon: "_2U5dhGN1LkTGmvfDSXp7Pn",
				StyledCaretIcon: "MZjVSHyz_JYuVJV8JeezH",
				styledCaretIcon: "MZjVSHyz_JYuVJV8JeezH",
				mHasError: "_12W0J-fwDQQ6_tQ9fdpzqG",
				errorMessages: "_29DzChs2ytJ2zOxDSU_YZZ"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/ToggleDestCollectionButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_1FASP6jHc95Gr8_JE5NtRM",
				disabled: "GOi-au9bPIVJ6WnD6RD6y",
				DivButton: "_1KdMCiMK7eff1VYAo9JUDh",
				divButton: "_1KdMCiMK7eff1VYAo9JUDh"
			}
		},
		"./src/reddit/components/PostCreationForm/ControlRow/index.m.less": function(e, t, n) {
			e.exports = {
				ButtonLayout: "_1T0P_YQg7fOYLCRoKl_xxO",
				buttonLayout: "_1T0P_YQg7fOYLCRoKl_xxO",
				buttonLayoutStyles: "_1BOItL6vmZFDKOuaOKKJHf",
				SaveDraftButtonLayout: "_2qdAvPbBMsK4TpwNnVe-pj",
				saveDraftButtonLayout: "_2qdAvPbBMsK4TpwNnVe-pj",
				Container: "_1d1--0DMy_jAIxCCoYMo1k",
				container: "_1d1--0DMy_jAIxCCoYMo1k",
				ButtonsAndErrors: "_2DHDj0dbS1TkKD3fMqSbHy",
				buttonsAndErrors: "_2DHDj0dbS1TkKD3fMqSbHy",
				ButtonRow: "_2RmKGBRP9puAMQITZ7HMaB",
				buttonRow: "_2RmKGBRP9puAMQITZ7HMaB",
				autoWidth: "_2lg9-dlsll34oz__8Kmxk7",
				errorMessages: "_2kLLxn1y9vaTeT0OAc-Ikc",
				PostLoadingIcon: "_2QZRXSFrX2qcSjZIV5mRzK",
				postLoadingIcon: "_2QZRXSFrX2qcSjZIV5mRzK",
				DraftLoadingIcon: "_4S5sqoV61IY7tpZqBwoKQ",
				draftLoadingIcon: "_4S5sqoV61IY7tpZqBwoKQ",
				Token: "_1TIes8fbwL-i8e6hUlw5jF",
				token: "_1TIes8fbwL-i8e6hUlw5jF",
				postModifiers: "_2pAQpGYEPAVsPmV5uVmGGU",
				clockIcon: "_1z-5BtMZ_1-gl9JLssX5SJ",
				postScheduleButton: "_2cMg4VsPGSoc_OwPOPRAie",
				postScheduleIcon: "_1ND9PCHVFG_UrSPdlJqv5W",
				removeRightBorderRadius: "_1_Xn_Na9NfUSd_yoc1w2Eb"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3vV_tKesULQ5WMGh38lX4b",
				container: "_3vV_tKesULQ5WMGh38lX4b",
				Content: "_11JSvybbRhcX_cfoagpne_",
				content: "_11JSvybbRhcX_cfoagpne_",
				TitleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				titleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				Details: "_3Uw02TWwSQhLfCJkPsihqr",
				details: "_3Uw02TWwSQhLfCJkPsihqr",
				Footer: "_25MDqXgOCWDBjtAEBi2cmy",
				footer: "_25MDqXgOCWDBjtAEBi2cmy",
				CancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				cancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				CloseWrapper: "_GVnqGyX40oKfgIS56Q-k",
				closeWrapper: "_GVnqGyX40oKfgIS56Q-k",
				CloseIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				closeIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				Label: "_3QPFKpxsmu6j_gbiAuVgfW",
				label: "_3QPFKpxsmu6j_gbiAuVgfW",
				TitleInput: "ZEfw7a99aHsmkl4fx38l5",
				titleInput: "ZEfw7a99aHsmkl4fx38l5",
				AddCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				addCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				PrimaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				primaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				LoadingIcon: "_3cD2qECfUUTwega16qDhBc",
				loadingIcon: "_3cD2qECfUUTwega16qDhBc",
				ErrorText: "GIQ2YnBHQtY1QM1yPEhCR",
				errorText: "GIQ2YnBHQtY1QM1yPEhCR"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/asModal/index.tsx"),
				l = n("./src/lib/formatApiError/index.ts"),
				d = n("./src/reddit/actions/postCollection/index.ts"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				p = n("./src/reddit/constants/postCreation.ts"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/controls/ErrorText/index.tsx"),
				b = n("./src/reddit/controls/Input/index.tsx"),
				f = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				g = n("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				x = n("./src/reddit/icons/svgs/Close/index.tsx"),
				y = n("./src/reddit/layout/row/Inline/index.tsx"),
				v = n("./src/reddit/selectors/postCollection.ts"),
				C = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less"),
				E = n.n(C),
				O = n("./src/lib/lessComponent.tsx");
			const j = O.a.div("Container", E.a),
				w = O.a.div("Content", E.a),
				S = O.a.div("TitleRow", E.a),
				_ = O.a.div("Details", E.a),
				k = O.a.wrapped(u.f, "Footer", E.a),
				T = O.a.wrapped(m.i, "CancelButton", E.a),
				I = O.a.div("CloseWrapper", E.a),
				P = O.a.wrapped(x.a, "CloseIcon", E.a),
				M = O.a.label("Label", E.a),
				N = O.a.wrapped(b.a, "TitleInput", E.a),
				R = O.a.wrapped(g.a, "AddCollectionIcon", E.a),
				L = O.a.wrapped(m.f, "PrimaryActionButton", E.a),
				A = O.a.wrapped(f.a, "LoadingIcon", E.a),
				F = O.a.wrapped(h.b, "ErrorText", E.a),
				D = Object(a.c)({
					collection: v.r,
					error: v.c,
					isPending: v.h
				}),
				B = Object(i.b)(D, (e, t) => ({
					onCreate: (t, n) => e(Object(d.b)(t, n)),
					onUpdate: n => e(Object(d.h)(t.collectionId, n))
				}));
			class U extends r.a.PureComponent {
				constructor(e) {
					super(e), this.onTitleChange = e => {
						this.setState({
							collectionTitle: e.target.value
						})
					}, this.onPrimaryButtonClick = async () => {
						const {
							collectionId: e,
							subredditId: t
						} = this.props, {
							collectionTitle: n
						} = this.state;
						if (e) {
							await this.props.onUpdate(n) && this.props.onCollectionUpdated && this.props.onCollectionUpdated()
						} else {
							const e = await this.props.onCreate(n, t);
							e && this.props.onCollectionCreated && this.props.onCollectionCreated(e)
						}
					}, this.onClose = () => {
						this.props.onCancel()
					};
					const {
						collection: t
					} = e;
					this.state = {
						collectionTitle: t ? t.title : ""
					}
				}
				render() {
					const {
						collectionId: e,
						error: t,
						isPending: n
					} = this.props, o = !e, i = !!this.state.collectionTitle.trim(), a = o ? s.fbt._("Create", null, {
						hk: "Ijp7n"
					}) : s.fbt._("Save", null, {
						hk: "2Onrrv"
					});
					return r.a.createElement(j, null, r.a.createElement(I, {
						onClick: this.props.onCancel
					}, r.a.createElement(P, null)), r.a.createElement(w, null, o && r.a.createElement(r.a.Fragment, null, r.a.createElement(S, null, r.a.createElement(R, null), s.fbt._("Create a collection", null, {
						hk: "3ndxk5"
					})), r.a.createElement(_, null, s.fbt._("Group posts into one feed. Create a series of events or just a group of random things. Make something awesome!", null, {
						hk: "2eCAQw"
					}))), r.a.createElement(M, null, o ? s.fbt._("Give a title for your collection", null, {
						hk: "Uaqbe"
					}) : s.fbt._("Edit title", null, {
						hk: "1jzweg"
					}), r.a.createElement(N, {
						maxLength: p.e,
						onChange: this.onTitleChange,
						placeholder: s.fbt._("Enter title", null, {
							hk: "3B0iRI"
						}),
						value: this.state.collectionTitle
					}))), r.a.createElement(k, null, r.a.createElement(y.a, null, r.a.createElement(T, {
						onClick: this.props.onCancel
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(L, {
						onClick: this.onPrimaryButtonClick,
						disabled: n || !i
					}, n ? r.a.createElement(A, {
						sizePx: 10
					}) : a)), t && r.a.createElement(F, null, Object(l.a)(t))))
				}
			}
			t.a = Object(c.a)(B(U))
		},
		"./src/reddit/components/PostCreationForm/CreationControls/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditPicker: "k3D4EVssJ1w-8irx6jW6k",
				subredditPicker: "k3D4EVssJ1w-8irx6jW6k",
				ControlRow: "i0kJNtq5ma1uzbOX9_mM4",
				controlRow: "i0kJNtq5ma1uzbOX9_mM4"
			}
		},
		"./src/reddit/components/PostCreationForm/DivButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "ypAk-GyDXsczk_xkC7Eq_",
				disabled: "_3hBIa9WhGl-wxARDDgBvSE"
			}
		},
		"./src/reddit/components/PostCreationForm/DivButton/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/components/PostCreationForm/DivButton/index.m.less"),
				c = n.n(a);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var d = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const u = (e, t, n) => {
					!t && n && n(e)
				},
				p = (e, t, n) => {
					t || (n && n(e), e.defaultPrevented || e.which !== i.a.Enter && e.which !== i.a.Space || e.currentTarget.click())
				};
			t.a = e => {
				var {
					className: t,
					disabled: n,
					onClick: s,
					onKeyPress: i,
					setRef: a,
					tabIndex: m
				} = e, h = d(e, ["className", "disabled", "onClick", "onKeyPress", "setRef", "tabIndex"]);
				return o.a.createElement("div", l({
					"aria-disabled": !!n,
					className: Object(r.a)(t, c.a.button, n ? c.a.disabled : null),
					onClick: e => u(e, n, s),
					onKeyPress: e => p(e, n, i),
					role: "button",
					ref: a,
					tabIndex: m || 0
				}, h))
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Icon.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2zmE2mxeSGThXfrD20TENk",
				component: "_2zmE2mxeSGThXfrD20TENk"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Placeholder.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3s9TqP-_YHesViWXcd4cMj",
				container: "_3s9TqP-_YHesViWXcd4cMj",
				LeftBlock: "_3ZfLmI01IKam1zqUNiCCY6",
				leftBlock: "_3ZfLmI01IKam1zqUNiCCY6",
				Content: "_3GIbVaHf4QKOhABI3DhSMo",
				content: "_3GIbVaHf4QKOhABI3DhSMo",
				MediaIcon: "_31VuujawtoKX7A_ykq786h",
				mediaIcon: "_31VuujawtoKX7A_ykq786h",
				Title: "_24WZEeSSq6ekrxl4oZMhB3",
				title: "_24WZEeSSq6ekrxl4oZMhB3",
				Secondary: "_1a6BjjqFgWMfDd1GftKY3a",
				secondary: "_1a6BjjqFgWMfDd1GftKY3a"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_2mGd4F9ksQ8wRlvFjnL0wz",
				container: "_2mGd4F9ksQ8wRlvFjnL0wz",
				LeftBlock: "_32kTNEqb0vEW5J0BmJdwnn",
				leftBlock: "_32kTNEqb0vEW5J0BmJdwnn",
				Content: "wrG0DeMFlU8RmFoT1gUDM",
				content: "wrG0DeMFlU8RmFoT1gUDM",
				RightBlock: "AnY3sJDM9Z2aUfyXs2Hfl",
				rightBlock: "AnY3sJDM9Z2aUfyXs2Hfl",
				PostTitle: "_25WWHqf4udQb0G9Wa_ar6s",
				postTitle: "_25WWHqf4udQb0G9Wa_ar6s",
				EditingPostTitle: "_3kH-PKnEjv45UIFAwY_XwK",
				editingPostTitle: "_3kH-PKnEjv45UIFAwY_XwK",
				MetaLine: "_1P65-c5DlnBqJL1jOa9TFr",
				metaLine: "_1P65-c5DlnBqJL1jOa9TFr",
				SubredditName: "_2cQKCpCLQTg1gPnnhEqZ6z",
				subredditName: "_2cQKCpCLQTg1gPnnhEqZ6z",
				DraftSavedTime: "Aegaj4-SLZNjFEolptURF",
				draftSavedTime: "Aegaj4-SLZNjFEolptURF",
				TrashIcon: "lWsFaDYxW8Sc4sqVTxVGv",
				trashIcon: "lWsFaDYxW8Sc4sqVTxVGv",
				InteractiveDiv: "_1nhwaUh9TlWeM5H9a_E18l",
				interactiveDiv: "_1nhwaUh9TlWeM5H9a_E18l",
				ConfirmDelete: "_3lIfF-MBpq24PJLxdGfIWQ",
				confirmDelete: "_3lIfF-MBpq24PJLxdGfIWQ"
			}
		},
		"./src/reddit/components/PostCreationForm/DraftListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_29SuZj4Q_M_-p6FwlKJw2V",
				wrapper: "_29SuZj4Q_M_-p6FwlKJw2V",
				TitleRow: "_1t9vurufwtvAZm6k-7T1N0",
				titleRow: "_1t9vurufwtvAZm6k-7T1N0",
				DraftsNumber: "VA7GC_5VP6Yx4VSLaCW7T",
				draftsNumber: "VA7GC_5VP6Yx4VSLaCW7T",
				DetailsContainer: "_2ffvzlYi6yd1I-j5ndDKFm",
				detailsContainer: "_2ffvzlYi6yd1I-j5ndDKFm",
				ButtonRow: "_3JS6XDYnB0zNhQRfV4rLl0",
				buttonRow: "_3JS6XDYnB0zNhQRfV4rLl0",
				CancelButton: "_2AHvxdRmdK6Dve6_MNs6YW",
				cancelButton: "_2AHvxdRmdK6Dve6_MNs6YW",
				CloseWrapper: "_2put2qtgUIjmVIlQlZxeTb",
				closeWrapper: "_2put2qtgUIjmVIlQlZxeTb",
				Close: "_1Ojj3n0SwnEevN0xKAhtFi",
				close: "_1Ojj3n0SwnEevN0xKAhtFi",
				Empty: "_3j6Qa8OS7J6clTSNxqrADq",
				empty: "_3j6Qa8OS7J6clTSNxqrADq",
				EmptyImage: "_13SmMRVwMLfOrhzEqQQXrJ",
				emptyImage: "_13SmMRVwMLfOrhzEqQQXrJ",
				EmptyText: "_2OF81CBhfbV9gjOU-5n9Dr",
				emptyText: "_2OF81CBhfbV9gjOU-5n9Dr",
				DraftListModal: "_2bMp7e8oHvukp1hKtlg1r-",
				draftListModal: "_2bMp7e8oHvukp1hKtlg1r-"
			}
		},
		"./src/reddit/components/PostCreationForm/EduTooltips/BaseEduTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1LVDV1pks4den73WWY46GI",
				contentContainer: "_3v3OHx0_DIBm8WcTKrQ_Vj",
				description: "_1ZyYR40qdR1KVaYW3JJnFF",
				gotIt: "_31UHkJmzR05A-oHijI9dsj",
				hero: "_3KJU9tTmfe-f0PGdg1hJ6O",
				icon: "_1TqYQFIF_2oaFDavvx7TEE",
				iconExplanation: "_2gaQgwvoc2dROc2Uramfat",
				iconsExplanations: "_1IKgmmXb6LA2blrkyfqnxx",
				title: "_1ZeryymPzBgAm7zK9oPs3l",
				Container: "_1LVDV1pks4den73WWY46GI",
				OuterContainer: "_3cH-rE_yhLIp3GscF-WShj",
				outerContainer: "_3cH-rE_yhLIp3GscF-WShj"
			}
		},
		"./src/reddit/components/PostCreationForm/EduTooltips/CollectionButtonTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3zSOhojke1hMymIth30Ue"
			}
		},
		"./src/reddit/components/PostCreationForm/EduTooltips/EventButtonTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_RsSSHM-K9MvWN3u6Jxnf"
			}
		},
		"./src/reddit/components/PostCreationForm/LinkEditor/index.m.less": function(e, t, n) {
			e.exports = {
				URLInput: "_3zY6b4QJpSz1067ahq73_K",
				urlInput: "_3zY6b4QJpSz1067ahq73_K",
				mHasError: "_1WipnslOO1oVfOEMxsrYU3"
			}
		},
		"./src/reddit/components/PostCreationForm/MarkdownEditor/index.m.less": function(e, t, n) {
			e.exports = {
				LoadingIcon: "dyBWJSV5slC_6_q-avEAz",
				loadingIcon: "dyBWJSV5slC_6_q-avEAz",
				ModeDescription: "_2wjlEqW6Mz7pFfwBHVpPEA",
				modeDescription: "_2wjlEqW6Mz7pFfwBHVpPEA",
				ModeWrapper: "_2IWlVWhYLpVswet-ElQ9xx",
				modeWrapper: "_2IWlVWhYLpVswet-ElQ9xx",
				SwitchModeButton: "_2POD_tWc9UVvI3zBwPH9Yu",
				switchModeButton: "_2POD_tWc9UVvI3zBwPH9Yu",
				MarkdownHelpButton: "oqXBQCZarmL4V15c4Izxm",
				markdownHelpButton: "oqXBQCZarmL4V15c4Izxm",
				Toolbar: "_1HVLi6b9dq2O2gkgGAO1Fa",
				toolbar: "_1HVLi6b9dq2O2gkgGAO1Fa"
			}
		},
		"./src/reddit/components/PostCreationForm/MarkdownEditor/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/postCreation/general.ts"),
				c = n("./src/reddit/components/CommentCreation/MarkdownCommentForm/index.tsx"),
				l = n("./src/reddit/components/FocusableContent/index.tsx"),
				d = n("./src/reddit/components/MarkdownHelp/index.tsx"),
				u = n("./src/reddit/components/PostCreationForm/Prompt/index.tsx"),
				p = n("./src/reddit/components/ResizableAutosizeTextarea/index.tsx"),
				m = n("./src/reddit/constants/keycodes.ts"),
				h = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				b = n("./src/reddit/models/PostCreationForm/index.ts"),
				f = n("./src/reddit/selectors/activeModalId.ts"),
				g = n("./src/reddit/selectors/editorContent.ts"),
				x = n("./src/reddit/components/PostCreationForm/MarkdownEditor/index.m.less"),
				y = n.n(x),
				v = n("./src/lib/lessComponent.tsx");
			const C = v.a.wrapped(h.a, "LoadingIcon", y.a),
				E = v.a.span("ModeDescription", y.a),
				O = v.a.div("ModeWrapper", y.a),
				j = v.a.button("SwitchModeButton", y.a),
				w = v.a.wrapped(c.a, "MarkdownHelpButton", y.a),
				S = v.a.div("Toolbar", y.a),
				_ = Object(i.c)({
					activeModalId: f.a,
					isConverting: e => Object(g.a)(e)
				}),
				k = Object(r.b)(_, (e, t) => ({
					onChange: n => {
						e(Object(a.c)(n)), t.onChange && t.onChange(n)
					},
					helpModalToggled: () => e(Object(a.x)(d.b)),
					switchToRTEModalToggled: () => e(Object(a.x)(u.a.SWITCH_TO_RTE_MODAL_ID))
				}));
			class T extends o.a.Component {
				constructor(e) {
					super(e), this.textAreaRef = null, this.onChange = e => {
						const {
							value: t
						} = e.currentTarget;
						this.props.onChange(t)
					}, this.onBlur = () => {
						this.setState({
							isFocused: !1
						}), this.props.onBlur && this.props.onBlur()
					}, this.onFocus = () => {
						const {
							onFocus: e
						} = this.props;
						e && e(), this.setState({
							isFocused: !0
						})
					}, this.handleKeyDown = e => {
						const {
							ctrlKey: t,
							metaKey: n,
							keyCode: s
						} = e;
						(t || n) && s === m.a.Enter && this.props.onSubmit()
					}, this.handleSwitchModeClick = () => {
						this.props.value ? this.props.switchToRTEModalToggled() : this.props.onSwitchEditorMode(b.h.RICH_TEXT, this.props.value)
					}, this.handleSwitchToRTEConfirm = () => {
						this.props.switchToRTEModalToggled(), this.props.onSwitchEditorMode(b.h.RICH_TEXT, this.props.value)
					}, this.setTextAreaRef = e => this.textAreaRef = e, this.state = {
						isFocused: !1
					}
				}
				componentDidMount() {
					const {
						instanceRef: e
					} = this.props;
					e && e(this)
				}
				componentWillUnmount() {
					const {
						instanceRef: e
					} = this.props;
					e && e(null)
				}
				focus() {
					this.textAreaRef && this.textAreaRef.focus()
				}
				render() {
					const {
						className: e,
						isConverting: t,
						placeholderText: n,
						focusableContentMarkdownClassName: s,
						value: r
					} = this.props, {
						isFocused: i
					} = this.state;
					return o.a.createElement("div", {
						className: e
					}, o.a.createElement(l.a, {
						className: s,
						isFocused: i
					}, o.a.createElement(S, null, o.a.createElement(O, null, o.a.createElement(E, null, "Markdown"), o.a.createElement(w, {
						onClick: this.props.helpModalToggled
					})), o.a.createElement(j, {
						onClick: this.handleSwitchModeClick
					}, t && o.a.createElement(C, {
						sizePx: 12
					}), "Switch to Fancy Pants Editor")), o.a.createElement(p.a, {
						disabled: !!this.props.disabled,
						initialHeight: this.props.initialHeight,
						innerRef: this.setTextAreaRef,
						onBlur: this.onBlur,
						onChange: this.onChange,
						onEditorResize: this.props.onEditorResize,
						onFocus: this.onFocus,
						onKeyDown: this.handleKeyDown,
						placeholder: n,
						value: r
					})), this.props.activeModalId === d.b && o.a.createElement(d.a, null), this.props.activeModalId === u.a.SWITCH_TO_RTE_MODAL_ID && o.a.createElement(u.b, {
						modalId: u.a.SWITCH_TO_RTE_MODAL_ID,
						onCancel: this.props.switchToRTEModalToggled,
						onConfirm: this.handleSwitchToRTEConfirm
					}))
				}
			}
			t.a = k(T)
		},
		"./src/reddit/components/PostCreationForm/MediaInput/DropArea/index.m.less": function(e, t, n) {
			e.exports = {
				HiddenInput: "sU2P34us34ODfjtvAFHEh",
				hiddenInput: "sU2P34us34ODfjtvAFHEh",
				UploadButton: "_3O09Fh0CTb1KXH9g--pyTm",
				uploadButton: "_3O09Fh0CTb1KXH9g--pyTm",
				HamsterSmall: "_2O_N8Ef-BG5Cfd4rpYn2gC",
				hamsterSmall: "_2O_N8Ef-BG5Cfd4rpYn2gC",
				HamsterLarge: "wV8IXIxvKm8PPZrR4ID63",
				hamsterLarge: "wV8IXIxvKm8PPZrR4ID63",
				Container: "_1Ts5GUNze2r03Hs4YNM7R7",
				container: "_1Ts5GUNze2r03Hs4YNM7R7",
				DropArea: "_1U5lLS9mQzBY-ItvbtGGLz",
				dropArea: "_1U5lLS9mQzBY-ItvbtGGLz",
				DropAreaActive: "_3dk8Anard_IzanCLoEOxwY",
				dropAreaActive: "_3dk8Anard_IzanCLoEOxwY",
				DropAreaOver: "_2u00X-QMmF0nCuc0JgGiPG",
				dropAreaOver: "_2u00X-QMmF0nCuc0JgGiPG",
				Paragraph: "_23Ktfv_B7IB6GfAwZ1n5KM",
				paragraph: "_23Ktfv_B7IB6GfAwZ1n5KM",
				ErrorMsg: "_1g07w9noInEjzrHqFqXu7p",
				errorMsg: "_1g07w9noInEjzrHqFqXu7p",
				Box: "_2bMJxWQqwzcVG4QCyh3UhG",
				box: "_2bMJxWQqwzcVG4QCyh3UhG"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/MultipleUploadStatusBar/index.m.less": function(e, t, n) {
			e.exports = {
				ControlRow: "XAYmQCRZd6pa1gK4J2Irv",
				controlRow: "XAYmQCRZd6pa1gK4J2Irv",
				OuterDivProgressBar: "_3lnXFUS1rk-i2bmQ9tBVAg",
				outerDivProgressBar: "_3lnXFUS1rk-i2bmQ9tBVAg",
				ProgressBar: "_2h9OzlkpNau2hE61muUCcM",
				progressBar: "_2h9OzlkpNau2hE61muUCcM",
				Status: "_2QlfNrUATpUf8fxWF3xLUc",
				status: "_2QlfNrUATpUf8fxWF3xLUc"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/AddImageItem.m.less": function(e, t, n) {
			e.exports = {
				AddImageWrapper: "_3mOObaE2qUuGBwPZt06QMP",
				addImageWrapper: "_3mOObaE2qUuGBwPZt06QMP",
				AddImageItem: "_1PHeBCrOhYxisqmUW-NOTZ",
				addImageItem: "_1PHeBCrOhYxisqmUW-NOTZ",
				plusIcon: "_3fjztH0o3WW8ugsD8VUpdG",
				hiddenInput: "_8GGSjoMJRi3bIAaFgk5VT"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItem.m.less": function(e, t, n) {
			e.exports = {
				GalleryMediaUpload: "_3cm8_J6ytCvL4Z0YkUO6fO",
				galleryMediaUpload: "_3cm8_J6ytCvL4Z0YkUO6fO",
				isDragging: "_1hQY_UY2EioccXnSHJuH2j",
				isSelected: "_3mV402dYSBG5F3rfKzCHih",
				isError: "_10Cb6hifpOfnmfdg7Zetit",
				galleryImage: "-_ofbVTDK5uSQ60HcXH2-",
				deleteButton: "_3611iw8TKLU1FFCTSMHMWl",
				deleteIcon: "_1RI3AZPuym8dOTJt-TRI38",
				showDeleteNormal: "_2LKMLYT_7bo_5rfh9705Pg"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItemsWrapper.m.less": function(e, t, n) {
			e.exports = {
				itemsWrapper: "_3BGk3QOycswdTTmIh9R56y",
				sortableImages: "_7eeHxLESKnWVh8uefc7iN",
				imageStyles: "_2175QbehBw28eJRKOGrVKp",
				hoverMarker: "_1q50A238Zq0unVV8sFYvEm",
				pendingItem: "_1liymuUZSLP_05fSC0_0iQ"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/InputWrapper.m.less": function(e, t, n) {
			e.exports = {
				inputWrapper: "_1ZgKdgcmpiQuMxVOb36gpi",
				inputStyles: "_3QhJ8Am-icOjVUrut4LpNH",
				urlInputStyles: "_2P6NoGE4s1hTODn5PMPuIh",
				charsCounter: "_18XDqj2Sr9Pi7101fkIdE3"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/Layout.m.less": function(e, t, n) {
			e.exports = {
				Layout: "_3uExMaQ9CE8L0F97PE7ESO",
				layout: "_3uExMaQ9CE8L0F97PE7ESO",
				hero: "_3cjkwfQbHf5cGuN_2K1uvN",
				mainContent: "D_D1mksZjLSJKHZf-qFgh",
				sideMetaContent: "_3s8GQtCSn-VS8biCUpM7QQ",
				bottomContent: "_1ipt9uyZjJ4fiF29YsWqgy"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/SelectedImage.m.less": function(e, t, n) {
			e.exports = {
				selectedImage: "_1HQ9Q4NlQY-2w_yLQXa4MW",
				pendingImage: "_16rNFI0ovowGxjX85OoDQ7"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = 20,
				o = 180
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/index.m.less": function(e, t, n) {
			e.exports = {
				dropArea: "_37BTO6li-OWodKOMQsps09",
				isDropAreaActive: "OPoLiV8gJNj-kgaS3TA6s",
				isDropAreaOver: "_2dpUJvIRjH1lQlhWr9Ln7B",
				errorMessage: "_1geBZyOTOcY8e2hp9dLJBb"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/Preview/index.m.less": function(e, t, n) {
			e.exports = {
				Img: "_2CZpGuT-0gMB2CW-1Z4Rzr",
				img: "_2CZpGuT-0gMB2CW-1Z4Rzr",
				BlurImg: "_3lXopXY4SQ5xn1DGFU-6mv",
				blurImg: "_3lXopXY4SQ5xn1DGFU-6mv",
				ImagePreview: "_1x86R_C1SXWhk5Ta6ZwgCE",
				imagePreview: "_1x86R_C1SXWhk5Ta6ZwgCE",
				VideoPreview: "_1qFo28RpDjnwvvZFYuoYw1",
				videoPreview: "_1qFo28RpDjnwvvZFYuoYw1",
				Component: "_32O_ZBzCA0KWydc-ydD4Ut",
				component: "_32O_ZBzCA0KWydc-ydD4Ut"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/UploadStatusBar/index.m.less": function(e, t, n) {
			e.exports = {
				ControlRow: "_2UeBgPJSAh_VteJrmt29jr",
				controlRow: "_2UeBgPJSAh_VteJrmt29jr",
				Button: "mU3hHnDkWt1Fu4t0MzJ3D",
				button: "mU3hHnDkWt1Fu4t0MzJ3D",
				Status: "_2tgT4LseX3Xg9TNczoQt_8",
				status: "_2tgT4LseX3Xg9TNczoQt_8",
				Component: "_1ou_efVZQLBrztRrswvRdK",
				component: "_1ou_efVZQLBrztRrswvRdK"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_2WJ7xvGE_xrehqTKCrcVpN",
				wrapper: "_2WJ7xvGE_xrehqTKCrcVpN",
				UploadStatusBar: "_1cAEFWtInMytYP6NpKBxK7",
				uploadStatusBar: "_1cAEFWtInMytYP6NpKBxK7",
				Controls: "_2Hg3aAL1qjiKtlSICSWx59",
				controls: "_2Hg3aAL1qjiKtlSICSWx59",
				ThumbnailSelect: "_3Beo1Ag8mmirgP8ObHTty9",
				thumbnailSelect: "_3Beo1Ag8mmirgP8ObHTty9",
				Trash: "_18Z2AbfCvCglpgZoyExSaS",
				trash: "_18Z2AbfCvCglpgZoyExSaS"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/RemovePrompt/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "RbI4r-xLIZTGjyNNqMkc2",
				wrapper: "RbI4r-xLIZTGjyNNqMkc2",
				TitleRow: "_3KkK2UFvbWMkRb887z28Ay",
				titleRow: "_3KkK2UFvbWMkRb887z28Ay",
				DetailsContainer: "_3x1u7rU-TVemMtzZVifQk",
				detailsContainer: "_3x1u7rU-TVemMtzZVifQk",
				ButtonRow: "_1rR3d9OXZt1cL70vCFunZP",
				buttonRow: "_1rR3d9OXZt1cL70vCFunZP",
				CancelButton: "_2JpoeseNULOIs1m0HM_FkJ",
				cancelButton: "_2JpoeseNULOIs1m0HM_FkJ",
				ConfirmButton: "_1-56PBUj1A-mgJh4Uhz5Jd",
				confirmButton: "_1-56PBUj1A-mgJh4Uhz5Jd"
			}
		},
		"./src/reddit/components/PostCreationForm/MediaInput/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_1UbcPNs4A8n5PIWX0H5sGt",
				container: "_1UbcPNs4A8n5PIWX0H5sGt"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/Hint/index.m.less": function(e, t, n) {
			e.exports = {
				Info: "_2kALbPZ2PwY7w-w3Mtrxpl",
				info: "_2kALbPZ2PwY7w-w3Mtrxpl",
				TooltipContent: "c_vthvCq93OKrS5BGZYdr",
				tooltipContent: "c_vthvCq93OKrS5BGZYdr",
				Hint: "_2yxSY9022XfAJtQVxxa1lL",
				hint: "_2yxSY9022XfAJtQVxxa1lL",
				HoverTooltip: "_3M5yvX2tFyuTet4AEPmVDL",
				hoverTooltip: "_3M5yvX2tFyuTet4AEPmVDL",
				tooltipContentClass: "_2AY8LM9XpfuTjCMB4PF1mj"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/index.m.less": function(e, t, n) {
			e.exports = {
				CheckboxInput: "rLLDF6zuY7gDPdOpDtryW",
				checkboxInput: "rLLDF6zuY7gDPdOpDtryW",
				ConnectAccountLink: "_2XixtsvkuzAkwuKe93t7Bd",
				connectAccountLink: "_2XixtsvkuzAkwuKe93t7Bd",
				Container: "_1WZBFo38dOAZ_-qyyA6sNh",
				container: "_1WZBFo38dOAZ_-qyyA6sNh",
				ContainerLeft: "ncWlnJtypP1_Mwohv06zd",
				containerLeft: "ncWlnJtypP1_Mwohv06zd",
				ContainerRight: "_1rdhEwGT1578MFV4zdgyXX",
				containerRight: "_1rdhEwGT1578MFV4zdgyXX",
				CheckboxText: "_1sBmqB8geWKIW5Nt8svFgc",
				checkboxText: "_1sBmqB8geWKIW5Nt8svFgc",
				Option: "_367d1mrPAvSzXPXQZfPXq5",
				option: "_367d1mrPAvSzXPXQZfPXq5",
				TextButton: "_5SJ8wEtj0ehde_UTuEUJL",
				textButton: "_5SJ8wEtj0ehde_UTuEUJL",
				TextBox: "_1TBGkOAQIuFnbqFv3ePDxT",
				textBox: "_1TBGkOAQIuFnbqFv3ePDxT",
				Wrapper: "_2CXYv7vwpCTLV6wKUwqkBz",
				wrapper: "_2CXYv7vwpCTLV6wKUwqkBz"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/ScheduledTimeInfo/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3iy2yiZt_m40oq7tdW_klw",
				container: "_3iy2yiZt_m40oq7tdW_klw",
				replayIcon: "_2ks2fE4UUmcEWL1vQnR7wp"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationFooter/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_22Te0a5VxZnLITkTavQh95",
				container: "_22Te0a5VxZnLITkTavQh95"
			}
		},
		"./src/reddit/components/PostCreationForm/PostCreationHeader/index.m.less": function(e, t, n) {
			e.exports = {
				CreateLabel: "_3M6BmdyQcCEQZu-MylN14",
				createLabel: "_3M6BmdyQcCEQZu-MylN14",
				CountIndicator: "_3-lCASba1yl0jeRpeQ5jwm",
				countIndicator: "_3-lCASba1yl0jeRpeQ5jwm",
				LinkButton: "_3KQDVc4kBIwA5u7S9n99NQ",
				linkButton: "_3KQDVc4kBIwA5u7S9n99NQ",
				CreatePostHeader: "_1HWpiNu6dkOnZixxwDYTVJ",
				createPostHeader: "_1HWpiNu6dkOnZixxwDYTVJ"
			}
		},
		"./src/reddit/components/PostCreationForm/PostEditor/GovTypeSelector/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1kR_hX_PP5udhk-mtPuavx",
				currentSelection: "_1ZxmKr4SrkV__KWvI2gxKt",
				flexRow: "wIleinjtpdijasCWI_jCU",
				dropdownIcon: "oK9t9SNnOOCu-BraimNJE",
				newLabel: "_1pi_9nWsspppnkpr0Km1Hl",
				pollTypeIcon: "_1ZEeQaLhgbqgxX5zvvM2OO",
				text: "_3BIAW_hHKHgVyTnhczBT4A"
			}
		},
		"./src/reddit/components/PostCreationForm/PostEditor/index.m.less": function(e, t, n) {
			e.exports = {
				focusableContent: "Mb0x12Cu8JKRJRJCcf9_K",
				mPollBorder: "_3tqYz5xeUZo9em1LrxMZOB",
				mHasError: "_24RennTZzi_jyZ_kdBt9U2",
				govToggle: "_2VmXXwMxyQk230gkKvJTzF",
				pollCreator: "_3GqK73QyFc10CoXE2bReko"
			}
		},
		"./src/reddit/components/PostCreationForm/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3zkbHfhLbXp21FwGj_kNZV",
				inputWrapper: "_2wyvfFW3oNcCs5GVkmcJ8z",
				PostTitleInput: "_1ec_Oj5SWdypd8L-VELKg-",
				postTitleInput: "_1ec_Oj5SWdypd8L-VELKg-",
				mHasError: "_1dItJbdjTchVLwC0krCsr3",
				charsCounter: "_10vnCUi_uRLhIdKnPglWAw"
			}
		},
		"./src/reddit/components/PostCreationForm/Prompt/PromptModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_35XIX8S5eAkigMxHxx98TS",
				primaryButton: "_35XIX8S5eAkigMxHxx98TS",
				ModalText: "_1ShPAP1uGnX3ZkiyNiigAA",
				modalText: "_1ShPAP1uGnX3ZkiyNiigAA"
			}
		},
		"./src/reddit/components/PostCreationForm/Prompt/PromptModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				a = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/controls/TextButton/index.tsx"),
				d = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				u = n("./src/reddit/components/PostCreationForm/Prompt/PromptModal.m.less"),
				p = n.n(u),
				m = n("./src/lib/lessComponent.tsx");
			const h = m.a.wrapped(c.f, "PrimaryButton", p.a),
				b = m.a.wrapped(i.o, "ModalText", p.a);
			class f extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.handleEscapeKey = e => {
						e.keyCode === a.a.Escape && this.props.onClose()
					}
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey)
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				render() {
					return o.a.createElement(i.d, null, o.a.createElement(i.h, null, o.a.createElement(d.a, null, o.a.createElement(i.p, null, this.props.titleText), o.a.createElement(l.a, {
						onClick: this.props.onClose
					}, o.a.createElement(i.b, null)))), o.a.createElement(i.k, null, o.a.createElement(b, null, this.props.bodyText)), o.a.createElement(i.f, null, o.a.createElement(i.a, {
						onClick: this.props.onSecondaryAction
					}, this.props.secondaryButtonText), o.a.createElement(h, {
						onClick: this.props.onPrimaryAction
					}, this.props.primaryButtonText)))
				}
			}
			t.a = Object(r.a)(f)
		},
		"./src/reddit/components/PostCreationForm/Prompt/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/reddit/components/PostCreationForm/Prompt/PromptModal.tsx");
			! function(e) {
				e.LOAD_DRAFT_MODAL_ID = "POST_CREATION__LOAD_DRAFT_MODAL_ID", e.MAX_DRAFTS_MODAL_ID = "POST_CREATION__MAX_DRAFTS_MODAL_ID", e.SWITCH_TO_RTE_MODAL_ID = "MARKDOWN_EDITOR__SWITCH_TO_RTE_MODAL_ID"
			}(s || (s = {}));
			const c = {
					title: () => o.fbt._("Load draft", null, {
						hk: "VQ7SS"
					}),
					body: () => o.fbt._("Loading this draft will discard your current post.", null, {
						hk: "49vMci"
					}),
					confirm: () => o.fbt._("Load draft", null, {
						hk: "1gZRcm"
					}),
					cancel: () => o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})
				},
				l = {
					title: () => o.fbt._("Save draft", null, {
						hk: "36SGct"
					}),
					body: () => o.fbt._("Looks like you’ve hit your max number of drafts. Please delete one to make room.", null, {
						hk: "4g9gOF"
					}),
					confirm: () => o.fbt._("Manage drafts", null, {
						hk: "1nFlZw"
					}),
					cancel: () => o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})
				},
				d = {
					title: () => o.fbt._("Switch to Fancy Pants Editor", null, {
						hk: "22mr8J"
					}),
					body: () => o.fbt._("Switching to Fancy Pants Editor may result in a loss of content", null, {
						hk: "1cWryd"
					}),
					confirm: () => o.fbt._("Switch", null, {
						hk: "36pRzE"
					}),
					cancel: () => o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})
				},
				u = {
					[s.LOAD_DRAFT_MODAL_ID]: c,
					[s.MAX_DRAFTS_MODAL_ID]: l,
					[s.SWITCH_TO_RTE_MODAL_ID]: d
				};
			class p extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onCancel = () => {
						this.props.onCancel(this.props.modalId)
					}, this.onConfirm = () => {
						this.props.onConfirm(this.props.modalId)
					}
				}
				render() {
					const {
						modalId: e
					} = this.props, t = u[e];
					return i.a.createElement(a.a, {
						bodyText: t.body(),
						secondaryButtonText: t.cancel(),
						primaryButtonText: t.confirm(),
						titleText: t.title(),
						onClose: this.onCancel,
						onPrimaryAction: this.onConfirm,
						onSecondaryAction: this.onCancel
					})
				}
			}
			t.b = p
		},
		"./src/reddit/components/PostCreationForm/RecaptchaOverlay/index.m.less": function(e, t, n) {
			e.exports = {
				OverlayWrapper: "_36HnnNoO8oBJDJnOgDiENG",
				overlayWrapper: "_36HnnNoO8oBJDJnOgDiENG",
				OverlayContent: "_3Ye_87oAzGPJr-7DymIhl0",
				overlayContent: "_3Ye_87oAzGPJr-7DymIhl0",
				ExplanationText: "_17qYQd3F9TbaKxu_Q0ssNq",
				explanationText: "_17qYQd3F9TbaKxu_Q0ssNq"
			}
		},
		"./src/reddit/components/PostCreationForm/SafeHarborText/index.m.less": function(e, t, n) {
			e.exports = {
				TextContainer: "_3sXblbCnnsbtHR0izSxX-Q",
				textContainer: "_3sXblbCnnsbtHR0izSxX-Q"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/FallbackDateInput/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3A53iTDZ6H1L--Ky3qNCTO",
				container: "_3A53iTDZ6H1L--Ky3qNCTO",
				Select: "_2ryUqzbCnNhx8nbFXg9-c0",
				select: "_2ryUqzbCnNhx8nbFXg9-c0",
				Delimiter: "_1X2oFpzvpth9SVe2-xCR9D",
				delimiter: "_1X2oFpzvpth9SVe2-xCR9D"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.m.less": function(e, t, n) {
			e.exports = {
				Input: "_1Css-vhkiry0RZJBBPrnRI",
				input: "_1Css-vhkiry0RZJBBPrnRI"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return w
			}));
			var s = n("./node_modules/lodash/once.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = (n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/lodash/range.js")),
				c = n.n(a),
				l = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/FallbackDateInput/index.m.less"),
				d = n.n(l),
				u = n("./src/lib/lessComponent.tsx");
			const p = u.a.div("Container", d.a),
				m = u.a.select("Select", d.a),
				h = u.a.span("Delimiter", d.a),
				b = 2018,
				f = e => {
					const t = new Date;
					return new Date(t.getFullYear(), e).toLocaleDateString([], {
						month: "short"
					})
				},
				g = e => {
					const [t, n, s] = e.split("-").map(Number);
					return {
						year: t,
						month: n - 1,
						day: s
					}
				};
			class x extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onChange = e => {
						const t = Object.assign(Object.assign({}, g(this.props.value)), e),
							{
								year: n,
								month: s,
								day: o
							} = t,
							r = new Date(Date.UTC(n, s, o)).toISOString().slice(0, 10);
						this.props.onChange(r)
					}, this.onChangeYear = e => {
						const t = +e.target.value;
						this.onChange({
							year: t
						})
					}, this.onChangeMonth = e => {
						const t = +e.target.value;
						this.onChange({
							month: t
						})
					}, this.onChangeDay = e => {
						const t = +e.target.value;
						this.onChange({
							day: t
						})
					}
				}
				render() {
					const {
						year: e,
						month: t,
						day: n
					} = g(this.props.value);
					return i.a.createElement(p, {
						className: this.props.className
					}, i.a.createElement(m, {
						onChange: this.onChangeMonth,
						value: t
					}, c()(12).map(e => i.a.createElement("option", {
						key: e,
						value: e
					}, f(e)))), i.a.createElement(h, null, "/"), i.a.createElement(m, {
						onChange: this.onChangeDay,
						value: n
					}, c()(1, 32).map(e => i.a.createElement("option", {
						key: e,
						value: e
					}, ("0" + e).slice(-2)))), i.a.createElement(h, null, "/"), i.a.createElement(m, {
						onChange: this.onChangeYear,
						value: e
					}, c()(b, b + 10).map(e => i.a.createElement("option", {
						key: e,
						value: e
					}, e))))
				}
			}
			var y = x,
				v = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.m.less"),
				C = n.n(v);

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const O = o()(() => {
					const e = document.createElement("input");
					return e.setAttribute("type", "date"), e.setAttribute("value", "not-a-date"), "not-a-date" !== e.value
				}),
				j = u.a.input("Input", C.a);

			function w(e) {
				return O() ? i.a.createElement(j, E({
					type: "date"
				}, e, {
					onChange: t => e.onChange(t.target.value)
				})) : i.a.createElement(y, e)
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/FallbackTimeInput/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "Q-u1MdpyF-DbsLmmseQmg",
				container: "Q-u1MdpyF-DbsLmmseQmg",
				Input: "_2UYlo-ZbVNGY329O9jwCzC",
				input: "_2UYlo-ZbVNGY329O9jwCzC",
				Delimiter: "_2a_r5Jp8FH3k8flNGKLy5f",
				delimiter: "_2a_r5Jp8FH3k8flNGKLy5f"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.m.less": function(e, t, n) {
			e.exports = {
				TimeInput: "gRgwdQKTQf9yT3db3ACAy",
				timeInput: "gRgwdQKTQf9yT3db3ACAy"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return w
			}));
			var s = n("./node_modules/lodash/once.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = (n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/lodash/clamp.js")),
				c = n.n(a),
				l = n("./src/reddit/components/FocusableContent/index.tsx"),
				d = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/FallbackTimeInput/index.m.less"),
				u = n.n(d),
				p = n("./src/lib/lessComponent.tsx");
			const m = p.a.wrapped(l.a, "Container", u.a),
				h = p.a.input("Input", u.a),
				b = p.a.span("Delimiter", u.a),
				f = e => ("0" + e).slice(-2),
				g = (e, t) => {
					const n = +e.slice(-2);
					if (Number.isInteger(n)) return n > t ? 0 : n
				};
			class x extends i.a.PureComponent {
				constructor(e) {
					super(e), this.callOnChange = () => {
						let e = c()(+this.state.hour, 0, 24);
						const t = c()(+this.state.minute, 0, 59);
						24 === e && t > 0 && (e = 0), this.setState({
							hour: e,
							minute: t
						});
						const n = "".concat(f(e), ":").concat(f(t));
						this.props.onChange(n)
					}, this.onChangeHour = e => {
						const t = g(e.target.value, 24);
						void 0 !== t && this.setState({
							hour: t
						}, this.callOnChange)
					}, this.onChangeMinute = e => {
						const t = g(e.target.value, 59);
						void 0 !== t && this.setState({
							minute: t
						}, this.callOnChange)
					}, this.onHourInputBlur = () => this.setState({
						isHourInputFocused: !1
					}), this.onHourInputFocus = () => this.setState({
						isHourInputFocused: !0
					}), this.onMinuteInputBlur = () => this.setState({
						isMinuteInputFocused: !1
					}), this.onMinuteInputFocus = () => this.setState({
						isMinuteInputFocused: !0
					});
					const [t, n] = e.value.split(":").map(Number);
					this.state = {
						hour: t,
						minute: n,
						isHourInputFocused: !1,
						isMinuteInputFocused: !1
					}
				}
				componentWillReceiveProps(e) {
					const [t, n] = e.value.split(":").map(Number);
					this.setState({
						hour: t,
						minute: n
					})
				}
				render() {
					const e = this.state.isHourInputFocused || this.state.isMinuteInputFocused;
					return i.a.createElement(m, {
						className: this.props.className,
						isFocused: e
					}, i.a.createElement(h, {
						type: "number",
						onChange: this.onChangeHour,
						onFocus: this.onHourInputFocus,
						onBlur: this.onHourInputBlur,
						value: f(this.state.hour)
					}), i.a.createElement(b, null, ":"), i.a.createElement(h, {
						type: "number",
						onChange: this.onChangeMinute,
						onFocus: this.onMinuteInputFocus,
						onBlur: this.onMinuteInputBlur,
						value: f(this.state.minute)
					}))
				}
			}
			var y = x,
				v = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.m.less"),
				C = n.n(v);

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const O = o()(() => {
					const e = document.createElement("input");
					return e.setAttribute("type", "time"), e.setAttribute("value", "not-a-time"), "not-a-time" !== e.value
				}),
				j = p.a.input("TimeInput", C.a);

			function w(e) {
				return O() ? i.a.createElement(j, E({
					type: "time"
				}, e, {
					onChange: t => e.onChange(t.target.value)
				})) : i.a.createElement(y, e)
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.m.less": function(e, t, n) {
			e.exports = {
				select: "_1gQeiuYndtyKo6Or5iS8xL"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/loadWithRetries/index.ts"),
				a = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				c = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.m.less"),
				l = n.n(c);
			const d = e => {
				const t = e.map(a.d);
				return t.sort((e, t) => {
					const n = -1440,
						{
							offset: s = n
						} = e,
						{
							offset: o = n
						} = t;
					return o - s || (e.displayText < t.displayText ? -1 : 1) || 0
				}), t
			};
			class u extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onSelect = e => {
						const t = e.target.value;
						this.props.onChange(t)
					};
					const t = u.cachedTimezoneOptions || d([this.props.selectedTimezoneName]);
					this.state = {
						timezoneOptions: t
					}
				}
				async loadTimezones() {
					const e = (await Object(i.a)(() => n.e("TimezoneList").then(n.bind(null, "./src/lib/timezone/timezoneList.ts")))).default,
						t = d(e);
					this.setState({
						timezoneOptions: t
					}), u.cachedTimezoneOptions = t
				}
				componentDidMount() {
					u.cachedTimezoneOptions || this.loadTimezones()
				}
				render() {
					return o.a.createElement("select", {
						onChange: this.onSelect,
						value: this.props.selectedTimezoneName,
						className: Object(r.a)(l.a.select, this.props.className)
					}, this.state.timezoneOptions.map(e => {
						let {
							name: t,
							displayText: n
						} = e;
						return o.a.createElement("option", {
							key: t,
							value: t
						}, n)
					}))
				}
			}
			t.a = u
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "ppLwDvFzc7jVTiV_5euUj",
				container: "ppLwDvFzc7jVTiV_5euUj",
				Content: "_3VbwtRsayHUBLVMtjkul4u",
				content: "_3VbwtRsayHUBLVMtjkul4u",
				TitleRow: "_2aRE3m6KuLAhRIDmdmFKaY",
				titleRow: "_2aRE3m6KuLAhRIDmdmFKaY",
				Hr: "_1aShcxrllO1loaDr49TUUo",
				hr: "_1aShcxrllO1loaDr49TUUo",
				TimeInput: "_1bu7h4vK0WEgtRzSz-_mbA",
				timeInput: "_1bu7h4vK0WEgtRzSz-_mbA",
				TimeSelectionRow: "BUT684iT0_upDm6a1x4q_",
				timeSelectionRow: "BUT684iT0_upDm6a1x4q_",
				RadioOptionContent: "_3Ry1zpEULyeAACzRNZgIHN",
				radioOptionContent: "_3Ry1zpEULyeAACzRNZgIHN",
				OptionDetails: "_3imVLMudY3hxD1tq8KO6MB",
				optionDetails: "_3imVLMudY3hxD1tq8KO6MB",
				RadioInput: "_3VPprBv9bGCEm-hzjVWKmd",
				radioInput: "_3VPprBv9bGCEm-hzjVWKmd",
				RadioOption: "V4Tm9i9X2Co6LU8ez1zlw",
				radioOption: "V4Tm9i9X2Co6LU8ez1zlw",
				Delimiter: "_2bajvlJVcTANoHFRcmq7lu",
				delimiter: "_2bajvlJVcTANoHFRcmq7lu",
				Footer: "_3KeMI-XaG-5bILTvrCkaGS",
				footer: "_3KeMI-XaG-5bILTvrCkaGS",
				CancelButton: "_2NvAutu3QQJ9DwGHa83msC",
				cancelButton: "_2NvAutu3QQJ9DwGHa83msC",
				DeleteButton: "_3mKiK6bFRKi6y6Wkk1xLyp",
				deleteButton: "_3mKiK6bFRKi6y6Wkk1xLyp",
				ErrorMessage: "ZK5-SDSIvd4eGlmmbaRoO",
				errorMessage: "ZK5-SDSIvd4eGlmmbaRoO",
				ClearIcon: "E0CXpIVd8SDvRSwZFAmCn",
				clearIcon: "E0CXpIVd8SDvRSwZFAmCn"
			}
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/timezone/index.ts"),
				d = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				u = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/utils.ts"),
				p = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/controls/RadioInput/index.tsx"),
				b = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				f = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				g = n("./src/reddit/helpers/trackers/postEvent.ts"),
				x = n("./src/reddit/icons/svgs/Clear/index.tsx"),
				y = n("./src/reddit/layout/row/Inline/index.tsx"),
				v = n("./src/reddit/models/PostCreationForm/index.ts"),
				C = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/DateInput/index.tsx"),
				E = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimeInput/index.tsx"),
				O = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/TimezoneSelector/index.tsx"),
				j = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/index.m.less"),
				w = n.n(j);
			const S = 240,
				_ = () => {
					const e = new Date;
					e.setMinutes(60);
					const t = Object(l.g)(e);
					return e.setMinutes(e.getMinutes() + S), {
						startDate: t,
						endDate: Object(l.g)(e),
						submitTime: v.i.Now,
						timezoneName: Object(l.b)() || l.a
					}
				},
				k = c.a.div("Container", w.a),
				T = c.a.div("Content", w.a),
				I = c.a.div("TitleRow", w.a),
				P = c.a.hr("Hr", w.a),
				M = c.a.wrapped(E.a, "TimeInput", w.a),
				N = c.a.div("TimeSelectionRow", w.a),
				R = c.a.div("RadioOptionContent", w.a),
				L = c.a.span("OptionDetails", w.a),
				A = c.a.wrapped(h.a, "RadioInput", w.a),
				F = c.a.wrapped(b.a, "RadioOption", w.a),
				D = c.a.span("Delimiter", w.a),
				B = c.a.wrapped(d.f, "Footer", w.a),
				U = c.a.wrapped(m.i, "CancelButton", w.a),
				K = c.a.wrapped(m.i, "DeleteButton", w.a),
				H = c.a.div("ErrorMessage", w.a),
				V = c.a.wrapped(x.a, "ClearIcon", w.a);
			class W extends r.a.PureComponent {
				constructor(e) {
					super(e), this.currentTimezone = Object(l.b)(), this.maxDate = Object(u.a)(), this.buildEventSchedule = () => ({
						startDate: Object(f.a)(this.state.startDate, this.state.startTime),
						endDate: Object(f.a)(this.state.endDate, this.state.endTime),
						timezoneName: this.state.timezoneName,
						submitTime: this.state.submitTime
					}), this.onStartDateChange = e => {
						this.setState({
							startDate: e
						}, this.updateEndDatetime)
					}, this.onStartTimeChange = e => {
						this.setState({
							startTime: e
						}, this.updateEndDatetime)
					}, this.updateEndDatetime = () => {
						if (this.state.isEndTimeTouched) return;
						const {
							startDate: e,
							startTime: t
						} = this.state;
						if (e && t) {
							const n = Object(l.f)(Object(f.a)(e, t));
							n.setMinutes(n.getMinutes() + S);
							const [s, o] = Object(f.i)(Object(l.g)(n));
							this.setState({
								endDate: s,
								endTime: o
							})
						}
					}, this.onEndDateChange = e => {
						this.setState({
							endDate: e,
							isEndTimeTouched: !0
						})
					}, this.onEndTimeChange = e => {
						this.setState({
							endTime: e,
							isEndTimeTouched: !0
						})
					}, this.onTimezoneChange = e => {
						this.setState({
							timezoneName: e
						})
					}, this.onSubmitTimeChange = e => {
						this.setState({
							submitTime: e
						})
					}, this.onApplyClick = () => {
						const e = this.buildEventSchedule();
						this.props.sendEvent(Object(g.b)(e)), this.props.onChange(e), this.props.onClose()
					}, this.onDeleteButtonClick = () => {
						const e = this.buildEventSchedule();
						this.props.sendEvent(Object(g.d)(e)), this.props.onChange(null), this.props.onClose()
					}, this.onCancelButtonClick = () => {
						this.props.sendEvent(Object(g.c)()), this.props.onClose()
					}, this.getValidationError = () => {
						const {
							endDate: e,
							endTime: t,
							startDate: n,
							startTime: o
						} = this.state;
						if (!(n && o && e && t)) return s.fbt._("Please enter valid start and end time", null, {
							hk: "2IyBsT"
						});
						const r = Object(l.f)(Object(f.a)(n, o)),
							i = Object(l.f)(Object(f.a)(e, t));
						return r < (this.currentTimezone === this.state.timezoneName ? new Date : new Date(Date.now() - a.x)) ? s.fbt._("Event start time needs to be in the future", null, {
							hk: "3oL3LM"
						}) : i < r ? s.fbt._("End time must be after start time", null, {
							hk: "3C3TKE"
						}) : null
					}, this.getSubmitAtLabel = () => {
						const {
							startDate: e,
							startTime: t
						} = this.state;
						return Object(f.b)(e, t)
					}, this.renderSubmitTimeRadio = () => r.a.createElement(A, {
						value: this.state.submitTime,
						name: "submit_time",
						onChange: this.onSubmitTimeChange
					}, r.a.createElement(F, {
						showButton: !0,
						value: v.i.Now
					}, r.a.createElement(R, null, r.a.createElement("span", null, s.fbt._("Submit post now", null, {
						hk: "2ueTnc"
					})), r.a.createElement(L, null, s.fbt._("Submitting post before your event allows people to follow your event and come back at the event time", null, {
						hk: "3LTavv"
					})))), r.a.createElement(F, {
						showButton: !0,
						value: v.i.AtEventTime
					}, r.a.createElement(R, null, r.a.createElement("span", null, this.getSubmitAtLabel()), r.a.createElement(L, null, s.fbt._("This post will be visible to only Mods and editable until the event time.", null, {
						hk: "1Hm60w"
					})))));
					const t = e.schedule || _(),
						[n, o] = Object(f.i)(t.startDate),
						[i, c] = Object(f.i)(t.endDate);
					this.state = {
						startDate: n,
						startTime: o,
						endDate: i,
						endTime: c,
						timezoneName: t.timezoneName,
						submitTime: t.submitTime,
						isEndTimeTouched: !!e.schedule
					}
				}
				componentDidMount() {
					this.props.sendEvent(Object(g.e)())
				}
				render() {
					const {
						shouldShowSubmitTime: e
					} = this.props, t = this.getValidationError();
					return r.a.createElement(k, null, r.a.createElement(T, null, r.a.createElement(I, null, s.fbt._("When is the event?", null, {
						hk: "2fTD7f"
					})), r.a.createElement(N, null, s.fbt._("{start time}{to}{end time}", [s.fbt._param("start time", r.a.createElement("fieldset", null, r.a.createElement("legend", null, s.fbt._("Start time", null, {
						hk: "3nqplI"
					})), r.a.createElement(C.a, {
						max: this.maxDate,
						onChange: this.onStartDateChange,
						value: this.state.startDate
					}), r.a.createElement(M, {
						onChange: this.onStartTimeChange,
						value: this.state.startTime
					}))), s.fbt._param("to", r.a.createElement(D, null, s.fbt._("to", null, {
						hk: "2tWTBK"
					}))), s.fbt._param("end time", r.a.createElement("fieldset", {
						style: {
							opacity: this.state.isEndTimeTouched ? 1 : .5
						}
					}, r.a.createElement("legend", null, s.fbt._("End time (optional)", null, {
						hk: "2XKdsz"
					})), r.a.createElement(C.a, {
						max: this.maxDate,
						onChange: this.onEndDateChange,
						value: this.state.endDate
					}), r.a.createElement(M, {
						onChange: this.onEndTimeChange,
						value: this.state.endTime
					})))], {
						hk: "3MRWfF"
					})), r.a.createElement("div", null, r.a.createElement("label", null, s.fbt._("Time zone", null, {
						hk: "3F7Bko"
					}), r.a.createElement(O.a, {
						selectedTimezoneName: this.state.timezoneName,
						onChange: this.onTimezoneChange
					}))), e && r.a.createElement(r.a.Fragment, null, r.a.createElement(P, null), r.a.createElement("fieldset", null, r.a.createElement("legend", null, s.fbt._("When do you want to submit this post?", null, {
						hk: "3kBgxg"
					})), this.renderSubmitTimeRadio()))), r.a.createElement(B, null, r.a.createElement(y.a, null, this.props.schedule && this.props.shouldShowDeleteButton && r.a.createElement(K, {
						onClick: this.onDeleteButtonClick
					}, r.a.createElement(V, null), s.fbt._("Clear", null, {
						hk: "npkgK"
					})), r.a.createElement(U, {
						onClick: this.onCancelButtonClick
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(m.f, {
						onClick: this.onApplyClick,
						disabled: !!t
					}, s.fbt._("Apply", null, {
						hk: "2TE8JD"
					}))), t && r.a.createElement(H, null, t)))
				}
			}
			t.default = Object(i.a)(Object(p.c)(W))
		},
		"./src/reddit/components/PostCreationForm/SchedulePickerModal/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/timezone/index.ts"),
				o = n("./src/reddit/helpers/scheduledPosts/index.ts");
			const r = () => {
				const e = new Date;
				e.setFullYear(e.getFullYear() + 1);
				const [t] = Object(o.i)(Object(s.g)(e));
				return t
			}
		},
		"./src/reddit/components/PostCreationForm/SubredditChangePrompt/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1elQqozWN8v7kNb3-2JJnv",
				wrapper: "_1elQqozWN8v7kNb3-2JJnv",
				TitleRow: "_21ZJQglqJoGvKPVrE1g6y4",
				titleRow: "_21ZJQglqJoGvKPVrE1g6y4",
				DetailsContainer: "_2BCyPW29meUC7c2ZvAIF6O",
				detailsContainer: "_2BCyPW29meUC7c2ZvAIF6O",
				ButtonRow: "_3-rBvo8wMI4G0IKFdRF5et",
				buttonRow: "_3-rBvo8wMI4G0IKFdRF5et",
				CancelButton: "_12whVTuRHmPsEJZdopRGQN",
				cancelButton: "_12whVTuRHmPsEJZdopRGQN",
				ConfirmButton: "ERUkO2xr-Jto7MQoScSJG",
				confirmButton: "ERUkO2xr-Jto7MQoScSJG"
			}
		},
		"./src/reddit/components/PostCreationForm/Tabs/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2rS9BNjL3uxg61zOx2zyOH",
				component: "_2rS9BNjL3uxg61zOx2zyOH",
				PollIcon: "_1wjrzsZm0XSDAKK8PykcNE",
				pollIcon: "_1wjrzsZm0XSDAKK8PykcNE",
				Container: "_3vyt9N_0jfZuOwByiKDi9x",
				container: "_3vyt9N_0jfZuOwByiKDi9x",
				Tab: "Z1w8VkpQ23E1Wdq_My3U4",
				tab: "Z1w8VkpQ23E1Wdq_My3U4",
				isActive: "j1Q89sB76i7EBRDhnQhlr"
			}
		},
		"./src/reddit/components/PostCreationForm/index.m.less": function(e, t, n) {
			e.exports = {
				FormContent: "_3w_665DK_NH7yIsRMuZkqB",
				formContent: "_3w_665DK_NH7yIsRMuZkqB",
				CrosspostBox: "QQaE6143-4kvEuZSTBX7_",
				crosspostBox: "QQaE6143-4kvEuZSTBX7_",
				FormContainer: "HOFZo2X7Fr6JVBztpsByj",
				formContainer: "HOFZo2X7Fr6JVBztpsByj",
				TabContent: "_1zq6UabIEJJ-z9grsiCJY7",
				tabContent: "_1zq6UabIEJJ-z9grsiCJY7",
				PostingGuidelines: "_2vcPDTxC76PPQ70AdMkN0C",
				postingGuidelines: "_2vcPDTxC76PPQ70AdMkN0C"
			}
		},
		"./src/reddit/components/PostFlairPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/lodash/isEqual.js"),
				o = n.n(s),
				r = n("./src/reddit/constants/flair.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/models/Flair/index.ts");
			const c = e => (e || []).find(e => e.type === a.f.Text || e.type === a.f.Image || e.type === a.f.Richtext);
			var l;
			! function(e) {
				e[e.InvalidTemplate = 0] = "InvalidTemplate", e[e.NoChanges = 1] = "NoChanges", e[e.NotSelected = 2] = "NotSelected", e[e.TextIsNotAllowed = 3] = "TextIsNotAllowed", e[e.TextIsEmpty = 4] = "TextIsEmpty", e[e.TextIsTooLong = 5] = "TextIsTooLong"
			}(l || (l = {}));
			const d = (e, t, n) => {
				if (n && !t) return {
					canSave: !0
				};
				if (!t) return {
					canSave: !1,
					reason: l.NotSelected
				};
				const s = e && t.templateId ? e[t.templateId] : void 0;
				if (!s) return {
					canSave: !1,
					reason: l.InvalidTemplate
				};
				const a = Object(i.g)(t).length;
				return 0 === a ? {
					canSave: !1,
					reason: l.TextIsEmpty
				} : a > r.g ? {
					canSave: !1,
					reason: l.TextIsTooLong
				} : Object(i.n)(t) && !Object(i.q)(s) ? {
					canSave: !1,
					reason: l.TextIsNotAllowed
				} : o()(n, t) ? {
					canSave: !1,
					reason: l.NoChanges
				} : {
					canSave: !0
				}
			}
		},
		"./src/reddit/components/PostFlairPicker/index.m.less": function(e, t, n) {
			e.exports = {
				buttonsRow: "cF9DU_4WDAKS4gs43ct2_",
				clearButton: "_3vB6Y9PiwJ0YV6c9MGbDwT"
			}
		},
		"./src/reddit/components/PostFlairPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return w
			}));
			var s, o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				u = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				m = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				h = n("./src/reddit/components/FlairPreview/index.tsx"),
				b = n("./src/reddit/components/FlairSearch/index.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/models/Flair/index.ts"),
				x = n("./src/reddit/selectors/moderatorPermissions.ts"),
				y = n("./src/reddit/selectors/postFlair.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/selectors/telemetry.ts"),
				E = n("./src/reddit/components/PostFlairPicker/helpers.ts"),
				O = n("./src/reddit/components/PostFlairPicker/index.m.less"),
				j = n.n(O);
			! function(e) {
				e.UNSET = "unset", e.MOD_FLATLIST = "postModFlatlist", e.POST_OVERFLOW = "postOverlay"
			}(s || (s = {}));
			const w = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.UNSET;
					return "PostFlair__Modal-[postId: ".concat(e, "]-isOverlay[").concat(t, "]-position[").concat(n, "]")
				},
				S = Object(c.c)({
					flairData: y.d,
					subreddit: v.S,
					isMod: (e, t) => !!Object(x.j)(e, t)
				});
			class _ extends i.a.Component {
				constructor(e) {
					super(e), this.getTrackingNoun = (e, t) => this.props.isMod ? e : t, this.onApply = () => {
						const {
							previewFlair: e
						} = this.state, t = e && e.templateId;
						this.props.onFlairChanged({
							previewFlair: e,
							selectedTemplateId: t
						}), this.props.closeModal && this.props.closeModal(), this.track(this.getTrackingNoun("flairadd_mod", "flairadd_user"))
					}, this.onClear = () => this.setSelectedFlair(null), this.setSelectedFlair = e => {
						this.setState({
							previewFlair: e
						})
					}, this.track = e => this.props.sendEvent(t => ({
						source: "post_flair_picker",
						action: "click",
						noun: e,
						subreddit: Object(C.subredditById)(t, this.props.subredditId)
					}));
					const t = Object(E.c)(e.flairs);
					this.state = {
						previewFlair: t || null
					}
				}
				canSave() {
					const {
						templates: e
					} = this.props.flairData, {
						previewFlair: t
					} = this.state, n = Object(E.c)(this.props.flairs) || null;
					return Object(E.b)(e, t, n)
				}
				render() {
					const {
						props: e
					} = this, {
						previewFlair: t
					} = this.state, {
						className: n,
						flairData: s,
						subreddit: r
					} = e, a = r.displayText, {
						templates: c,
						templateIds: l
					} = s, {
						canSave: d
					} = this.canSave();
					return i.a.createElement(m.a, {
						className: n
					}, i.a.createElement(p.a, {
						onClosePressed: e.closeModal,
						title: o.fbt._("Select {subredditName} flair", [o.fbt._param("subredditName", a)], {
							hk: "1lDMWS"
						})
					}), i.a.createElement(h.a, {
						flair: t,
						flairTemplateType: g.d.LinkFlair,
						placeholderText: o.fbt._("Post Title", null, {
							hk: "43RsbC"
						})
					}), i.a.createElement(b.a, {
						flair: t,
						flairTemplateType: g.d.LinkFlair,
						subredditId: r.id,
						templates: c,
						templateIds: l,
						onChange: this.setSelectedFlair
					}), i.a.createElement("div", {
						className: j.a.buttonsRow
					}, i.a.createElement(f.f, {
						disabled: !d,
						onClick: this.onApply
					}, o.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), i.a.createElement(f.i, {
						className: j.a.clearButton,
						onClick: this.onClear
					}, o.fbt._("Clear Flair", null, {
						hk: "3jvT0B"
					}))))
				}
			}
			const k = Object(a.b)(S, (e, t) => ({
				closeModal: () => e(Object(u.i)(t.modalId))
			}))(_);
			t.a = Object(d.a)(Object(l.c)(k))
		},
		"./src/reddit/components/PostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				metaContainer: "Ywkt6EDfNWINeTr9lP29H",
				postTopMeta: "iaAYGvTNtknkTxuHArCzL",
				subredditName: "_1L0pdcPf58t25Jy6ljHIKR"
			}
		},
		"./src/reddit/components/PostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/components/AwardBadges/index.tsx"),
				i = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				a = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				c = n("./src/reddit/components/PostBadges/index.tsx"),
				l = n("./src/reddit/components/PostTopMeta/index.tsx"),
				d = n("./src/reddit/components/QuarantinedLabel/index.tsx"),
				u = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				p = n("./src/reddit/components/SubscribeButton/Inline.tsx"),
				m = n("./src/reddit/constants/posts.ts"),
				h = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				b = n("./src/reddit/helpers/trackers/post.ts"),
				f = n("./src/reddit/models/Subreddit/index.ts"),
				g = n("./src/reddit/components/PostMeta/index.m.less"),
				x = n.n(g);
			t.a = e => {
				const {
					flairStyleTemplate: t,
					hideGildCta: n,
					inSubredditOrProfile: s,
					isCurrentUserProfilePost: g,
					isOverlay: y,
					isTopicPage: v,
					post: C,
					shouldShowSubscribeButton: E,
					subredditOrProfile: O,
					tooltipType: j
				} = e, w = !!v;
				return o.a.createElement("div", {
					className: x.a.metaContainer
				}, !s && !C.isSponsored && O && o.a.createElement(i.a, {
					postId: C.id,
					subredditName: O.name
				}, o.a.createElement(u.a, {
					className: x.a.subredditName,
					"data-click-id": "subreddit",
					to: O.url
				}, O.displayText)), O && O.isQuarantined && o.a.createElement(d.a, null), !s && !C.isSponsored && O && E && !g && o.a.createElement(p.a, {
					getEventFactory: e => Object(b.f)(C.id, e ? "unsubscribe" : "subscribe"),
					identifier: {
						name: O.name,
						type: Object(f.g)(O) ? m.a.PROFILE : m.a.SUBREDDIT
					},
					postId: C.id,
					small: !0
				}), !s && !C.isSponsored && o.a.createElement(h.b, null), !s && !C.isSponsored && o.a.createElement(a.h, {
					type: C.belongsTo.type,
					id: C.belongsTo.id
				}), o.a.createElement(l.d, {
					className: x.a.postTopMeta,
					flairStyleTemplate: t,
					post: C,
					tooltipType: j
				}), o.a.createElement(c.a, {
					displayText: O ? O.displayText : null,
					inSubredditOrProfile: !!s,
					post: C,
					tooltipType: j
				}), !w && o.a.createElement(r.a, {
					hideCta: n,
					thing: C,
					tooltipType: y ? l.c.Lightbox : void 0
				}))
			}
		},
		"./src/reddit/components/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				outboundLinkIcon: "qgDkGQIoFEpMMeNtfI0BY",
				pollMeta: "FKej75-i0z1XubMqeVh9Q",
				styledLink: "SQnoC3ObvgnGjWt90zD9Z",
				isVisitedEnabled: "_2INHSNB8V5eaWp4P0rY_mE",
				Title: "_2SdHzo12ISmrC8H86TgSCp",
				title: "_2SdHzo12ISmrC8H86TgSCp",
				titleContainer: "y8HYJ-y_lTUHkQIc1mdCq",
				isNoWrap: "_2_QBmCTk6VD4M3dvKqXD23",
				postTitleVisibility: "_1hLrLjnE1G_RBCNcN9MVQf",
				ExtraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				extraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				Large: "_3wqmjmv3tb_k-PROt7qFZe",
				large: "_3wqmjmv3tb_k-PROt7qFZe",
				Medium: "_1zpZYP8cFNLfLDexPY65Y7",
				medium: "_1zpZYP8cFNLfLDexPY65Y7",
				Small: "uWdXen_41bh0iwLrgzFkc",
				small: "uWdXen_41bh0iwLrgzFkc",
				ExtraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				extraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				Component: "_2FCtq-QzlfuN-SwVMUZMM3",
				component: "_2FCtq-QzlfuN-SwVMUZMM3"
			}
		},
		"./src/reddit/components/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return H
			})), n.d(t, "a", (function() {
				return W
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/polished/dist/polished.es.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/ads/index.ts"),
				d = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				p = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				h = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/controls/OutboundLink/index.tsx"),
				f = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				g = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				x = n("./src/reddit/helpers/flair.ts"),
				y = n("./src/reddit/helpers/path/index.ts"),
				v = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				C = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				E = n("./src/reddit/models/Flair/index.ts"),
				O = n("./src/reddit/models/Media/index.ts"),
				j = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				w = n("./src/lib/getShortenedLink.ts"),
				S = n("./src/reddit/components/FlairWrapper/index.tsx"),
				_ = n("./node_modules/fbt/lib/FbtPublic.js"),
				k = n("./src/lib/prettyPrintNumber/index.ts"),
				T = n("./src/reddit/components/Poll/MetaData/index.tsx"),
				I = n("./src/reddit/components/Governance/PostPollMetaData/index.m.less"),
				P = n.n(I);
			const M = Object(c.c)({
				poll: (e, t) => e.polls.models[t.pollId],
				resultsByVoters: (e, t) => e.polls.results.byVoters[t.pollId]
			});
			var N = Object(i.b)(M)((function(e) {
					const {
						poll: t,
						resultsByVoters: n
					} = e, s = n ? n.totalVotes : "0";
					return r.a.createElement("div", {
						className: Object(d.a)(e.className, P.a.proposalMetaData)
					}, r.a.createElement("span", null, _.fbt._({
						"*": "{count} votes",
						_1: "{count} vote"
					}, [_.fbt._param("count", Object(k.a)(s)), _.fbt._plural(parseInt(s))], {
						hk: "4rP1VK"
					})), t && r.a.createElement(T.a, {
						className: P.a.proposalMetaDataTime,
						poll: t
					}))
				})),
				R = n("./src/reddit/components/SEOTitle/index.tsx"),
				L = n("./src/reddit/selectors/posts.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				F = n("./src/reddit/selectors/user.ts"),
				D = n("./src/reddit/components/PostTitle/index.m.less"),
				B = n.n(D),
				U = n("./src/config.ts");

			function K() {
				return (K = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var H, V = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			! function(e) {
				e[e.ExtraLarge = 0] = "ExtraLarge", e[e.Large = 1] = "Large", e[e.Medium = 2] = "Medium", e[e.Small = 3] = "Small", e[e.ExtraSmall = 4] = "ExtraSmall"
			}(H || (H = {}));
			const W = p.a.wrapped(Object(u.a)(e => {
					var {
						size: t,
						titleColor: n,
						titleType: s,
						nowrap: o,
						children: i,
						className: a,
						redditStyle: c
					} = e, l = V(e, ["size", "titleColor", "titleType", "nowrap", "children", "className", "redditStyle"]);
					let u = "";
					switch (t) {
						case H.ExtraLarge:
							u = B.a.ExtraLarge;
							break;
						case H.Large:
							u = B.a.Large;
							break;
						case H.Medium:
							u = B.a.Medium;
							break;
						case H.Small:
							u = B.a.Small;
							break;
						case H.ExtraSmall:
							u = B.a.ExtraSmall
					}
					return r.a.createElement("div", K({
						className: Object(d.a)(a, u, {
							[B.a.isNoWrap]: o
						}),
						style: {
							"--posttitletextcolor": n || Object(j.a)(Object.assign({
								redditStyle: c
							}, l)).titleText
						}
					}, l), s ? r.a.createElement(R.b, {
						type: s
					}, i) : i)
				}), "Title", B.a),
				z = e => {
					var {
						className: t,
						disableVisited: n,
						titleColor: s
					} = e, o = V(e, ["className", "disableVisited", "titleColor"]);
					return r.a.createElement(a.a, K({}, o, {
						className: Object(d.a)(t, B.a.styledLink, {
							[B.a.isVisitedEnabled]: !n
						})
					}), o.children)
				},
				q = e => {
					var {
						disableVisited: t,
						nowrap: n
					} = e, s = V(e, ["disableVisited", "nowrap"]);
					return r.a.createElement("div", K({}, s, {
						className: Object(d.a)(B.a.titleContainer, s.className, {
							[B.a.isNoWrap]: n,
							[B.a.isVisitedEnabled]: !t
						})
					}))
				},
				G = Object(h.t)({
					isCommentPermalink: h.v,
					pageLayer: e => e
				}),
				J = Object(c.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(h.p)(e, {
							pageLayer: n
						})
					},
					isMeta: (e, t) => {
						let {
							post: n
						} = t;
						return Object(L.r)(e, {
							postId: n.id
						})
					},
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(A.S)(e, {
							subredditId: n.belongsTo.id
						}).name
					},
					shouldOpenPostInNewTab: F.U,
					imageGalleryCurrentItem: (e, t) => {
						let {
							post: n
						} = t;
						return Object(L.i)(e, {
							postId: n.id
						})
					}
				}),
				Q = Object(i.b)(J),
				Z = e => {
					const {
						post: t,
						subredditName: n
					} = e, {
						isSponsored: s
					} = t;
					if (e.isCommentsPage && !e.isCommentPermalink && !e.shouldLinkWrap) return r.a.createElement(q, {
						nowrap: e.nowrap
					}, r.a.createElement(Y, e));
					if (e.isCommentsPageAd && t.source && t.source.url) return r.a.createElement(b.b, {
						href: t.source.url,
						isSponsored: s,
						postId: t.id,
						source: t.source
					}, r.a.createElement(Y, e)); {
						const o = t.media && Object(O.H)(t.media) ? Object(v.b)(t.id, n) : t.permalink,
							i = e.isCommentPermalink ? Object(y.b)(o) : Object(g.a)(o);
						return r.a.createElement(q, {
							disableVisited: e.disableVisited,
							nowrap: e.nowrap
						}, s ? ((e, t) => {
							const {
								source: n
							} = Object(l.s)(e, t.imageGalleryCurrentItem);
							return n ? r.a.createElement(b.b, {
								href: n.url,
								isSponsored: e.isSponsored,
								postId: e.id,
								source: n
							}, r.a.createElement(Y, t)) : r.a.createElement(Y, t)
						})(t, e) : r.a.createElement(z, {
							className: e.titleLinkClassName,
							"data-click-id": "body",
							disableVisited: e.disableVisited,
							target: e.shouldOpenPostInNewTab ? "_blank" : void 0,
							titleColor: e.titleColor,
							to: i
						}, r.a.createElement(Y, e)))
					}
				},
				Y = e => {
					const {
						leftFlair: t,
						post: n
					} = e, s = e.format ? e.format(n) : n.title, o = e.isCommentsPage ? R.a.PostComments : R.a.PostItem;
					return r.a.createElement(W, {
						className: e.titleClassName,
						nowrap: e.nowrap,
						redditStyle: e.redditStyle || e.isCommentsPage,
						size: e.size,
						titleColor: e.titleColor,
						titleType: o
					}, t && r.a.createElement(S.a, {
						titleFlair: t,
						nowrap: !0,
						post: n,
						sendEvent: e.sendEvent,
						showCategoryTag: !1
					}), s)
				},
				X = e => {
					const {
						hideSourceLink: t,
						post: n
					} = e, {
						isSponsored: s
					} = n, o = !t && !e.isCrosspost && e.size !== H.Large && !n.isSponsored && !(n.media && Object(O.H)(n.media)) && (n.source || n.media && (n.media.type === O.o.GIFVIDEO || n.media.type === O.o.IMAGE || n.media.type === O.o.EMBED));
					if (t || !e.isCommentsPage || e.isCommentPermalink || e.shouldLinkWrap) {
						if (o) return r.a.createElement(f.a, {
							className: e.outboundLinkClassName,
							href: Object(O.E)(n),
							isSponsored: s,
							postId: n.id,
							source: n.source
						}, Object(w.a)(n), !n.isSponsored && r.a.createElement(C.a, {
							className: B.a.outboundLinkIcon
						}))
					} else if (n.source && !e.isCrosspost && e.size !== H.Large && e.size !== H.ExtraLarge) return r.a.createElement(f.a, {
						className: e.outboundLinkClassName,
						href: n.source.url,
						isSponsored: s,
						postId: n.id,
						source: n.source
					}, Object(w.a)(n), !n.isSponsored && r.a.createElement(C.a, {
						className: B.a.outboundLinkIcon
					}));
					return null
				};
			class $ extends r.a.Component {
				getDynamicStyleTags() {
					return r.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: "\n        .".concat(this.props.post.id, " .").concat(B.a.Component, " {\n          --postTitle-VisitedLinkColor: ").concat(Object(s.c)(.45, Object(j.a)(this.props).titleText, "#FFFFFF"), ";\n          --postTitleLink-VisitedLinkColor: ").concat(Object(s.c)(.45, this.props.titleColor || Object(j.a)(this.props).titleText, Object(j.a)(this.props).body), ";\n        }\n      ")
						}
					})
				}
				render() {
					const {
						className: e,
						disableFlair: t,
						flairPosition: n,
						isCommentsPage: s,
						isMeta: o,
						isOverlay: i,
						poll: a,
						post: c,
						showNSFWSpoilerFlairsOnly: l
					} = this.props, u = n === E.b.Left, p = Object(S.b)(o, c), m = l ? p.filter(e => e.type === E.f.Nsfw || e.type === E.f.Spoiler) : u ? p.filter(e => Object(x.p)(e.type)) : [], h = l ? [] : u ? p.filter(e => !Object(x.p)(e.type)) : p, b = !i && !s, f = !t && m && m.length > 0 && b, g = !t && h && h.length > 0 && b;
					return r.a.createElement("div", {
						className: Object(d.a)(e, c.id)
					}, !l && f && r.a.createElement(S.a, {
						isFlairFilter: !0,
						titleFlair: m,
						nowrap: !0,
						post: c,
						sendEvent: this.props.sendEvent,
						showCategoryTag: !1
					}), r.a.createElement(Z, K({}, this.props, {
						leftFlair: l ? m : void 0
					})), a && r.a.createElement(N, {
						className: B.a.pollMeta,
						pollId: a.id
					}), r.a.createElement(X, this.props), g && r.a.createElement(S.a, {
						isFlairFilter: !0,
						titleFlair: h,
						nowrap: !0,
						post: c,
						sendEvent: this.props.sendEvent,
						showCategoryTag: !1
					}), r.a.createElement("div", {
						className: B.a.postTitleVisibility,
						dangerouslySetInnerHTML: {
							__html: '\n              <img alt="" src="'.concat(U.a.assetPath, '/img/renderTimingPixel.png" style="width: 1px; height: 1px;" onLoad="(__markFirstPostVisible || function(){})();" />\n            ')
						}
					}), this.getDynamicStyleTags())
				}
			}
			t.c = p.a.wrapped(G(Q(Object(u.a)(Object(m.c)($)))), "Component", B.a)
		},
		"./src/reddit/components/PostTopMeta/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2kj4VmBwjxriyYFAErhLcT",
				badge: "_2v3rPYFjifVGM7CfOh1dOl",
				container: "_3AStxql1mQsrZuUIFP9xSg",
				adminIcon: "s46mo3ittWDxpPuCSXJ_T",
				contractorIcon: "MMQAY3zdk1u4R9hIKTklf",
				premiumIcon: "_6W0v52Yp6BzEfoWlrczS8",
				crosspostIcon: "_3hh-iGjzOv78L_7t_PUHev",
				link: "eQgJJIfdY4JNXam_N622j",
				publicWallet: "SxdIdV2SgMWcIFG6Qsk0Q",
				authorLink: "_2tbHP6ZydRpjI44J3syuqC",
				outboundLink: "_3V0C4FGg6153xIBQjwsycq",
				flairContainer: "NAURX0ARMmhJ5eqxQrlQW",
				externalLink: "_3jOxDPIQ0KaOWpzvSQo-1s",
				sponsored: "_1iAifs5p5MzPoJz5YrErUW",
				text: "_2fCzxBE1dlMh4OFc7B3Dun",
				MetaSeparator: "_3V4xlrklKBP2Hg51ejjjvz",
				metaSeparator: "_3V4xlrklKBP2Hg51ejjjvz",
				powerupBadge: "_22mcWwgVXFmw2-GrK4ZsJd",
				powerupIcon: "_1QXVZCgv3qdc2eb_RSi7qB"
			}
		},
		"./src/reddit/components/PostTopMeta/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return $
			})), n.d(t, "a", (function() {
				return te
			})), n.d(t, "b", (function() {
				return oe
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/lib/humanizeDateTime/index.ts"),
				d = n("./src/lib/lessComponent.tsx"),
				u = n("./src/lib/timeAgo/index.ts"),
				p = n("./src/reddit/constants/modals.ts"),
				m = n("./src/reddit/helpers/trackers/powerups.ts"),
				h = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/helpers/isCrosspost.ts"),
				f = n("./src/reddit/hooks/useInfoTextTooltip.ts"),
				g = n("./src/reddit/hooks/useTracking.ts"),
				x = n("./src/reddit/icons/svgs/Crosspost/index.tsx"),
				y = n("./src/reddit/icons/svgs/Powerup/index.tsx"),
				v = n("./src/reddit/components/AuthorLink/index.tsx"),
				C = n("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx"),
				E = n("./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx"),
				O = n("./src/reddit/components/Flair/index.tsx"),
				j = n("./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx"),
				w = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				S = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				_ = n("./src/reddit/components/InfoTextTooltip/Hooked.tsx"),
				k = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				T = n("./src/reddit/components/QuarantinedLabel/index.tsx"),
				I = n("./src/reddit/components/SponsoredLabel/index.tsx"),
				P = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				M = n("./src/reddit/constants/posts.ts"),
				N = n("./src/reddit/contexts/InsideOverlay.tsx"),
				R = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				L = n("./src/reddit/components/Portal/index.tsx"),
				A = n("./src/reddit/constants/elementIds.ts"),
				F = o.a.memo((function(e) {
					let {
						children: t
					} = e;
					const [n, r] = Object(s.useState)(!1);
					return Object(s.useEffect)(() => (r(!0), () => r(!1)), []), n ? o.a.createElement(L.a, {
						container: document.getElementById(A.d)
					}, o.a.Children.only(t)) : null
				})),
				D = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				B = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				U = n("./src/reddit/icons/fonts/Admin/index.tsx"),
				K = (n("./src/reddit/icons/fonts/Premium/index.tsx"), n("./src/reddit/models/Flair/index.ts")),
				H = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				V = n("./src/reddit/models/Post/index.ts"),
				W = n("./src/reddit/models/Subreddit/index.ts"),
				z = n("./src/reddit/selectors/authorFlair.ts"),
				q = n("./src/reddit/selectors/gold/powerups.ts"),
				G = n("./src/reddit/selectors/userFlair.ts"),
				J = n("./src/reddit/contexts/PageLayer/index.tsx"),
				Q = n("./src/reddit/components/PostTopMeta/index.m.less"),
				Z = n.n(Q);
			const {
				fbt: Y
			} = n("./node_modules/fbt/lib/FbtPublic.js"), X = {
				placement: "top"
			};
			var $;
			! function(e) {
				e.StickyPost = "sticky", e.Lightbox = "lightbox", e.TopAwardedModal = "topAwarded"
			}($ || ($ = {}));
			const ee = e => Object(B.a)(Object(D.a)(e), H.a.metaText, H.b.metaText),
				te = d.a.wrapped(R.b, "MetaSeparator", Z.a),
				ne = d.a.span("text", Z.a),
				se = Object(J.t)(),
				oe = e => {
					const t = !e.isDeleted && e.post.distinguishType === a.C.ADMIN;
					return o.a.createElement(v.a, {
						className: Z.a.authorLink,
						"data-click-id": "user",
						author: e.post.author,
						isAdmin: t,
						isAdminEmeritus: t,
						isAuthorDeleted: e.isDeleted,
						isUnstyled: !0,
						style: e.style
					}, "u/".concat(e.post.author), t && o.a.createElement(U.a, {
						className: Z.a.adminIcon
					}), e.renderContractorBadge && o.a.createElement(U.a, {
						className: Z.a.contractorIcon
					}), !1)
				},
				re = o.a.memo((function(e) {
					const {
						className: t,
						isOverlay: n,
						pageLayer: c,
						post: d,
						showSub: v = !1,
						showTimestamp: N = !0,
						subredditOrProfile: R,
						tooltipType: L
					} = e, A = Object(r.c)(), D = Object(g.a)(), B = d.belongsTo.id, U = Object(s.useCallback)(e => Object(z.a)(e, {
						post: d
					}), [d]), H = Object(r.d)(U), J = Object(s.useCallback)(e => Object(G.a)(e, {
						subredditId: B
					}), [B]), Q = Object(r.d)(J), $ = Object(s.useCallback)(e => Object(q.a)(e, {
						subredditId: B,
						userId: d.authorId
					}), [B, d.authorId]), se = Object(r.d)($), re = Object(s.useCallback)(e => Object(G.d)(e, {
						subredditId: B
					}), [B]), ie = Object(r.d)(re), ae = Object(f.a)(X), ce = Object(f.a)(X), le = c && c.meta && c.meta.name === a.Bb.COMMENTS, de = Object(b.a)(d), ue = ie === K.b.Left, pe = d.authorIsContractor && !!R && R.type === W.e.EmployeesOnly, me = !!R && se, he = !n && !le, be = () => o.a.createElement(te, {
						className: e.metaSeparatorClassName
					}, "•"), fe = o.a.createElement(o.a.Fragment, null, !de && o.a.createElement(ne, {
						style: {
							color: ee(e)
						}
					}, "Posted by"), de && o.a.createElement(s.Fragment, null, o.a.createElement(x.a, {
						className: Z.a.crosspostIcon
					}), o.a.createElement(ne, {
						style: {
							color: ee(e)
						}
					}, "Crossposted by")), H && ue && o.a.createElement("div", {
						className: Z.a.flairContainer
					}, o.a.createElement(O.b, {
						disabled: !Q,
						flair: H,
						forceSmallEmojis: !0,
						usesCommunityStyles: he
					})), Object(V.h)(d.author) ? o.a.createElement(oe, {
						post: d,
						isDeleted: !0,
						renderContractorBadge: pe,
						style: {
							color: ee(e)
						}
					}) : o.a.createElement(s.Fragment, null, !Object(V.h)(d.author) && o.a.createElement(C.b, {
						className: Z.a.badge,
						subredditId: B,
						uniqueIdentifier: "".concat(d.id, "-").concat(n),
						userId: d.authorId
					}), o.a.createElement(w.b, {
						postOrComment: d,
						tooltipType: L
					}, o.a.createElement(E.b, {
						ignore: Object(V.h)(d.author) || !!d.distinguishType && d.distinguishType !== a.C.NONE,
						subredditId: B,
						userId: d.authorId
					}, o.a.createElement(oe, {
						post: d,
						renderContractorBadge: pe,
						style: {
							color: ee(e)
						}
					}))), me && o.a.createElement(o.a.Fragment, null, o.a.createElement("button", {
						className: Z.a.powerupBadge,
						onMouseEnter: ce.show,
						onMouseLeave: ce.hide,
						onClick: () => {
							D(Object(m.c)(L ? "post" : "postlist")), A(Object(h.i)(p.a.ECON_POWERUPS_PURCHASE))
						},
						ref: ce.target.ref
					}, o.a.createElement(y.a, {
						className: Z.a.powerupIcon
					})), o.a.createElement(F, null, o.a.createElement(_.a, {
						arrowProps: ce.arrowProps,
						popperProps: ce.popperProps,
						visible: ce.visible
					}, Y._("Powerups Top Supporter", null, {
						hk: "1GLWsz"
					}))))), H && !ue && o.a.createElement("div", {
						className: Z.a.flairContainer
					}, o.a.createElement(O.b, {
						disabled: !Q,
						flair: H,
						forceSmallEmojis: !0,
						usesCommunityStyles: he
					})), d.belongsTo.type === M.a.SUBREDDIT && !Object(V.h)(d.author) && o.a.createElement(j.a, {
						className: Z.a.publicWallet,
						contentId: d.id,
						metaSeparator: o.a.createElement(be, null),
						subredditId: B,
						userId: d.authorId,
						username: d.author
					}));
					return o.a.createElement("div", {
						className: Object(i.a)(Z.a.container, t)
					}, v && R && o.a.createElement(S.a, {
						postId: d.id,
						subredditName: R.name,
						tooltipType: L
					}, o.a.createElement(P.a, {
						"data-click-id": "subreddit",
						to: R.url
					}, R.displayText)), R && R.isQuarantined && o.a.createElement(T.a, null), v && !de && o.a.createElement(be, null), d.isSponsored && o.a.createElement(s.Fragment, null, o.a.createElement(I.a, null), o.a.createElement(be, null)), fe, o.a.createElement(k.e, {
						post: d
					}), N && o.a.createElement(o.a.Fragment, null, o.a.createElement("a", {
						className: Z.a.externalLink,
						"data-click-id": "timestamp",
						href: d.permalink,
						onMouseEnter: ae.show,
						onMouseLeave: ae.hide,
						ref: ae.target.ref,
						style: {
							color: ee(e)
						},
						target: "_blank",
						rel: "nofollow noopener noreferrer"
					}, Object(u.d)(d.created / 1e3)), o.a.createElement(F, null, o.a.createElement(_.a, {
						arrowProps: ae.arrowProps,
						popperProps: ae.popperProps,
						visible: ae.visible
					}, Object(l.a)(d.created)))))
				}));
			t.d = se(Object(N.b)(Object(c.a)(re)))
		},
		"./src/reddit/components/PostingSidebar/PolicyRow/index.m.less": function(e, t, n) {
			e.exports = {
				PolicyRow: "_2N9ShiilNyzdd0B_i9geBj",
				policyRow: "_2N9ShiilNyzdd0B_i9geBj"
			}
		},
		"./src/reddit/components/PostingSidebar/PolicyRow/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/config.ts");
			const {
				redditUrl: i
			} = r.a, a = "".concat(i, "/help/contentpolicy"), c = "".concat(i, "/wiki/reddiquette");
			var l = n("./src/reddit/components/PostingSidebar/PolicyRow/index.m.less"),
				d = n.n(l);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => o.a.createElement("div", {
				className: d.a.PolicyRow
			}, u._("Please be mindful of reddit's {=content policy} and practice good {=reddiquette}.", [u._param("=content policy", o.a.createElement("a", {
				href: a
			}, u._("content policy", null, {
				hk: "2PeDvo"
			}))), u._param("=reddiquette", o.a.createElement("a", {
				href: c
			}, u._("reddiquette", null, {
				hk: "uPdiw"
			})))], {
				hk: "4yQuKr"
			}))
		},
		"./src/reddit/components/PostingSidebar/PostingReddiquette/index.m.less": function(e, t, n) {
			e.exports = {
				Snoo: "_1XXU14d6sjwsheKLMcy7ro",
				snoo: "_1XXU14d6sjwsheKLMcy7ro",
				Li: "_2aD4E5YdfsXR-e8kLRuTEp",
				li: "_2aD4E5YdfsXR-e8kLRuTEp",
				Ol: "a5fJMl2u0aujwukxWH3if",
				ol: "a5fJMl2u0aujwukxWH3if",
				Title: "_27SYzmGZdspPn9yA9voNCY",
				title: "_27SYzmGZdspPn9yA9voNCY",
				Component: "_1Zj2sAyYL2zB-kzZQcWiW",
				component: "_1Zj2sAyYL2zB-kzZQcWiW"
			}
		},
		"./src/reddit/components/PostingSidebar/PostingReddiquette/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/icons/svgs/SnooPosting/index.tsx"),
				d = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/components/PostingSidebar/PostingReddiquette/index.m.less"),
				p = n.n(u),
				m = n("./src/lib/lessComponent.tsx");
			const h = m.a.wrapped(l.a, "Snoo", p.a),
				b = m.a.li("Li", p.a),
				f = m.a.ol("Ol", p.a),
				g = m.a.div("Title", p.a),
				x = Object(a.c)({
					submissionType: d.fb
				});
			t.a = m.a.wrapped(Object(i.b)(x)(e => {
				const {
					className: t,
					submissionType: n
				} = e, o = n === c.Jb.CROSSPOST;
				return r.a.createElement("div", {
					className: t
				}, r.a.createElement(g, null, r.a.createElement(h, null), o ? s.fbt._("Crossposting to Reddit", null, {
					hk: "2ODPDt"
				}) : s.fbt._("Posting to Reddit", null, {
					hk: "8eEIT"
				})), r.a.createElement(f, null, r.a.createElement(b, null, s.fbt._("Remember the human", null, {
					hk: "1x3u5R"
				})), r.a.createElement(b, null, s.fbt._("Behave like you would in real life", null, {
					hk: "3pxfk1"
				})), r.a.createElement(b, null, s.fbt._("Look for the original source of content", null, {
					hk: "1FfUM4"
				})), r.a.createElement(b, null, s.fbt._("Search for duplicates before posting", null, {
					hk: "3Ij1gf"
				})), r.a.createElement(b, null, s.fbt._("Read the community’s rules", null, {
					hk: "3RNQW2"
				})), o && r.a.createElement(b, null, s.fbt._("You must join a community to crosspost there", null, {
					hk: "1YAEPX"
				}))))
			}), "Component", p.a)
		},
		"./src/reddit/components/PostingSidebar/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "itxZANPrH4AAYOj6VgfL9",
				container: "itxZANPrH4AAYOj6VgfL9"
			}
		},
		"./src/reddit/components/PostingSidebar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				o = n.n(s),
				r = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/components/IdCard/async.tsx"),
				u = n("./src/reddit/components/SidebarFooter/index.tsx"),
				p = n("./src/reddit/components/SidebarSpacer/index.tsx"),
				m = n("./src/reddit/components/Widgets/PostCollection/index.tsx"),
				h = n("./src/reddit/components/Widgets/SubredditRules/index.tsx"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				f = n("./src/reddit/models/Widgets/index.ts"),
				g = n("./src/reddit/selectors/postCreations.ts"),
				x = n("./src/reddit/selectors/profile.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/selectors/widgets.ts"),
				C = n("./src/reddit/components/PostingSidebar/PolicyRow/index.tsx"),
				E = n("./src/reddit/components/PostingSidebar/PostingReddiquette/index.tsx"),
				O = n("./src/reddit/components/PostingSidebar/index.m.less"),
				j = n.n(O),
				w = n("./src/lib/lessComponent.tsx");
			const S = Object(r.a)({
					resolved: {},
					chunkName: () => "reddit-components-ProfileIdCard",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("Settings~reddit-components-ProfileIdCard"), n.e("reddit-components-ProfileIdCard")]).then(n.bind(null, "./src/reddit/components/ProfileIdCard/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ProfileIdCard/index.tsx"
					}
				}),
				_ = w.a.div("Container", j.a),
				k = Object(b.t)(),
				T = new Set(["all", "post"]),
				I = Object(l.a)((e, t) => {
					let {
						pageLayer: n
					} = t;
					const s = Object(b.q)(e, {
						pageLayer: n
					});
					return s && Object(y.R)(e, {
						subredditId: s.id
					})
				}, e => (e || []).filter(e => T.has(e.kind))),
				P = (e, t) => {
					let {
						pageLayer: n
					} = t;
					const s = Object(b.q)(e, {
						pageLayer: n
					});
					return !(!s || !Object(v.d)(e, {
						subredditName: s.name
					}))
				},
				M = Object(l.c)({
					hasIdCardWidgetData: P,
					isCreationPagePending: g.E,
					profile: (e, t) => {
						let {
							pageLayer: n,
							subredditOrProfileId: s
						} = t;
						return s ? Object(x.p)(e, {
							profileId: s
						}) : Object(b.j)(e, {
							pageLayer: n
						})
					},
					subreddit: b.q,
					subredditRules: I,
					currentPostCollection: b.f
				}),
				N = Object(c.b)(M),
				R = e => {
					const {
						className: t,
						currentPostCollection: n,
						hasIdCardWidgetData: s,
						isCreationPagePending: o,
						profile: r,
						subreddit: i,
						subredditRules: c
					} = e, l = s || o;
					return a.a.createElement(_, {
						className: t
					}, n && a.a.createElement(m.a, {
						collection: n
					}), i && l && a.a.createElement(p.a, null, a.a.createElement(d.a, {
						isSubmissionPage: !0,
						listingName: i.name
					})), r && !i && a.a.createElement(p.a, null, a.a.createElement(S, {
						profileName: r.name,
						isOverlay: !1,
						isSubmissionPage: !0
					})), i && c && a.a.createElement(p.a, null, a.a.createElement(h.a, {
						subredditName: i.name,
						display: f.e.COMPACT,
						rules: c,
						redditStyle: !0
					})), a.a.createElement(E.a, null), a.a.createElement(p.a, null), a.a.createElement(C.a, null), a.a.createElement(u.a, {
						redditStyle: !0
					}))
				};
			t.a = k(N(R))
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, n) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ProgressBar/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: n,
					percent: s
				} = e;
				return o.a.createElement("div", {
					className: Object(r.a)(a.a.outerBar, t)
				}, o.a.createElement("div", {
					className: Object(r.a)(a.a.innerBar, n),
					style: {
						width: "".concat(s.toFixed(2), "%")
					}
				}))
			}
		},
		"./src/reddit/components/QuarantinedLabel/index.m.less": function(e, t, n) {
			e.exports = {
				quarantineIcon: "_3fdQM74ud_8KssWgeznOrR",
				Container: "_3Ph6ensT9WFRjOg8dQQKJK",
				container: "_3Ph6ensT9WFRjOg8dQQKJK"
			}
		},
		"./src/reddit/components/QuarantinedLabel/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/higherOrderComponents/asTooltip.tsx"),
				a = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				l = n("./src/reddit/contexts/PageLayer/index.tsx"),
				d = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				u = n("./src/reddit/components/QuarantinedLabel/index.m.less"),
				p = n.n(u);
			const m = ["center", "top"],
				h = ["center", "bottom"],
				b = a.a.div("Container", p.a),
				f = Object(i.a)(c.b),
				g = Object(l.t)({
					isProfileListingPage: l.F
				});
			class x extends r.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						isProfileListingPage: e
					} = this.props;
					if (!e) return null;
					const {
						showTooltip: t
					} = this.state;
					return r.a.createElement(b, {
						innerRef: this.setTooltipTargetRef,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip
					}, r.a.createElement(d.a, {
						className: p.a.quarantineIcon
					}), s.fbt._("quarantined", null, {
						hk: "3hfN4T"
					}), r.a.createElement(f, {
						text: s.fbt._("This post was submitted in a quarantined community", null, {
							hk: "1Rebnc"
						}),
						isOpen: t,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						tooltipPosition: h
					}))
				}
			}
			t.a = g(x)
		},
		"./src/reddit/components/RawHTMLDisplay/Media.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				a = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				c = n("./src/reddit/components/RawHTMLDisplay/index.tsx");

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var d = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			t.a = Object(r.a)(e => {
				var {
					flairStyleTemplate: t
				} = e, n = d(e, ["flairStyleTemplate"]);
				return o.a.createElement(c.a, l({
					style: {
						color: Object(a.a)(Object(i.a)(Object.assign({
							flairStyleTemplate: t
						}, n)))
					}
				}, n))
			})
		},
		"./src/reddit/components/RawHTMLDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				StyledRawHTMLDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH",
				styledRawHtmlDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/polished/dist/polished.es.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/page.ts"),
				d = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				u = n("./src/reddit/components/RawHTMLDisplay/index.m.less"),
				p = n.n(u);
			const m = Object(i.b)(null, e => ({
					onNavigate: t => e(Object(l.G)(t))
				})),
				h = c.a.wrapped(e => r.a.createElement("div", {
					className: e.className,
					dangerouslySetInnerHTML: {
						__html: e.html
					},
					onClick: t => {
						((e, t, n) => {
							if (!e.ctrlKey && !e.metaKey && 1 !== e.button && "A" === e.target.tagName) {
								e.preventDefault(), t(e.target.getAttribute("href"))
							}
							e.target.classList && e.target.classList.contains("md-spoiler-text") && (e.target.dataset.revealed = !0), n && n(e)
						})(t, e.onNavigate, e.onClick)
					},
					style: Object.assign(Object.assign({}, e.style), {
						"--RawHTMLDisplay-tr-even": Object(s.g)(Object(d.a)(e).body, .8),
						"--RawHTMLDisplay-tr-odd": Object(s.g)(Object(d.a)(e).line, .8)
					})
				}), "StyledRawHTMLDisplay", p.a);
			t.a = m(Object(a.a)(h))
		},
		"./src/reddit/components/RequestPendingBanner/index.m.less": function(e, t, n) {
			e.exports = {
				Banner: "_1AD-JX9FUzLgvv8A5yaVqV",
				banner: "_1AD-JX9FUzLgvv8A5yaVqV",
				Subtitle: "_1ljRPHbvpC41amZF9_xBeb",
				subtitle: "_1ljRPHbvpC41amZF9_xBeb"
			}
		},
		"./src/reddit/components/RequestPendingBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				d = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/components/RequestPendingBanner/index.m.less"),
				h = n.n(m);
			const b = c.a.wrapped(l.a, "Banner", h.a),
				f = Object(i.b)(() => Object(a.c)({
					restrictions: p.q,
					subreddit: u.f
				}));
			t.a = f(e => {
				let {
					restrictions: t,
					subreddit: n
				} = e;
				if (!n) return null;
				const o = t === d.e.Comment ? d.a.Create : d.a.Draft;
				return r.a.createElement(b, {
					subtitle: r.a.createElement("span", {
						className: h.a.Subtitle
					}, s.fbt._("Your request to {restrictions} in {displayName} was sent and is pending. In the meantime, you can {action} a post and {=browse the community}", [s.fbt._param("restrictions", d.d[t]()), s.fbt._param("displayName", n.name), s.fbt._param("action", d.c[o]()), s.fbt._param("=browse the community", r.a.createElement("a", {
						href: "".concat(n.url)
					}, s.fbt._("browse the community", null, {
						hk: "3hwgAC"
					})))], {
						hk: "2CX6Q6"
					})),
					title: s.fbt._("Request to {restrictions} is pending...", [s.fbt._param("restrictions", d.d[t]())], {
						hk: "1tQuSr"
					})
				})
			})
		},
		"./src/reddit/components/ResizableAutosizeTextarea/index.m.less": function(e, t, n) {
			e.exports = {
				editorWrapper: "VBa-xDMEbFi3vsO4id4OC",
				textareaAutosize: "_6Ej82J4aTDK36LLOcpFbC",
				mIsFullHeight: "aZb6a46diyLdUQJynW3aD"
			}
		},
		"./src/reddit/components/ResizableAutosizeTextarea/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-autosize-textarea/lib/index.js"),
				i = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/ResizableAutosizeTextarea/index.m.less"),
				l = n.n(c);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const p = e => {
					let {
						className: t,
						children: n,
						editorWrapperRef: s,
						initialHeight: r
					} = e;
					return o.a.createElement("div", {
						className: Object(a.a)(l.a.editorWrapper, t),
						style: r ? {
							height: r
						} : void 0,
						ref: s
					}, n)
				},
				m = e => {
					var {
						isFullHeight: t,
						textAreaRef: n
					} = e, s = u(e, ["isFullHeight", "textAreaRef"]);
					return o.a.createElement(i.a, d({
						className: Object(a.a)(l.a.textareaAutosize, {
							[l.a.mIsFullHeight]: t
						}),
						innerRef: n
					}, s))
				};
			class h extends o.a.Component {
				constructor(e) {
					super(e), this.editorHeight = null, this.editorRef = null, this.editorStyleMutationObserver = null, this.onEditorStyleChanged = () => {
						if (!this.editorRef) return;
						const {
							isResized: e
						} = this.state;
						e || this.setState({
							isResized: !0
						});
						const t = this.editorRef.style.height ? Number.parseInt(this.editorRef.style.height) : null;
						this.editorHeight !== t && (this.editorHeight = t, t && this.props.onEditorResize && this.props.onEditorResize(t))
					}, this.setEditorWrapperRef = e => this.editorRef = e, this.state = {
						initialHeight: e.initialHeight,
						isResized: !!e.initialHeight
					}
				}
				componentDidMount() {
					this.editorRef && (this.editorStyleMutationObserver = new MutationObserver(this.onEditorStyleChanged), this.editorStyleMutationObserver.observe(this.editorRef, {
						attributes: !0,
						attributeFilter: ["style"]
					}))
				}
				componentWillUnmount() {
					this.editorStyleMutationObserver && (this.editorStyleMutationObserver.disconnect(), this.editorStyleMutationObserver = null)
				}
				render() {
					const e = this.props,
						{
							className: t,
							initialHeight: n,
							innerRef: s,
							onEditorResize: r
						} = e,
						i = u(e, ["className", "initialHeight", "innerRef", "onEditorResize"]),
						{
							isResized: a
						} = this.state;
					return o.a.createElement(p, {
						className: t,
						editorWrapperRef: this.setEditorWrapperRef,
						initialHeight: n
					}, o.a.createElement(m, d({}, i, {
						children: !0,
						isFullHeight: !!a,
						textAreaRef: s
					})))
				}
			}
			t.a = h
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.m.less": function(e, t, n) {
			e.exports = {
				removalReasonButton: "_3IEDcFIIs_TeXsZtKZGzUd",
				TextWrapper: "smOzqVIOoNqmSJcyBX2N6",
				textWrapper: "smOzqVIOoNqmSJcyBX2N6",
				Button: "_1rNBkuuOkN2SorEXyRkYjB",
				button: "_1rNBkuuOkN2SorEXyRkYjB",
				ApproveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				approveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				RemoveButton: "_2OvUr_pd3kddsNP_f35S28",
				removeButton: "_2OvUr_pd3kddsNP_f35S28"
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RestrictedFlatlistButton/index.m.less"),
				c = n.n(a);
			const l = i.a.span("TextWrapper", c.a),
				d = i.a.wrapped(e => o.a.createElement("button", {
					className: e.className,
					disabled: e.disabled,
					id: e.id,
					onClick: e.disabled ? void 0 : e.onClick
				}, e.children, e.text && o.a.createElement(l, null, e.text, " ")), "Button", c.a),
				u = i.a.wrapped(d, "ApproveButton", c.a),
				p = i.a.wrapped(d, "RemoveButton", c.a),
				m = e => o.a.createElement("button", {
					className: Object(r.a)(c.a.removalReasonButton, e.className),
					onClick: e.onClick
				}, e.text)
		},
		"./src/reddit/components/RichTextEditor/Blockquote/index.m.less": function(e, t, n) {
			e.exports = {
				BlockQuoteWrapper: "_3bqfSxMWo3yWv7j4N8hQy6",
				blockQuoteWrapper: "_3bqfSxMWo3yWv7j4N8hQy6"
			}
		},
		"./src/reddit/components/RichTextEditor/CodeBlock/index.m.less": function(e, t, n) {
			e.exports = {
				CodeBlockWrapper: "_2YrwxhRxsXvszOhYWDUhMh",
				codeBlockWrapper: "_2YrwxhRxsXvszOhYWDUhMh"
			}
		},
		"./src/reddit/components/RichTextEditor/DragController/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "a", (function() {
				return b
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			var s = n("./node_modules/lodash/includes.js"),
				o = n.n(s);
			var r = n("./src/reddit/helpers/dom/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const a = e => e.className.indexOf("public-DraftEditor-content") >= 0,
				c = e => !!e.parentElement && !!e.parentElement.parentElement && a(e.parentElement.parentElement),
				l = e => !(!e.dataset.block || !e.dataset.offsetKey),
				d = e => {
					const {
						offsetKey: t
					} = e.dataset;
					return t ? (e => e.split("-")[0])(t) : ""
				},
				u = (e, t) => {
					return ((e, t) => {
						const n = function(e, t) {
							let n = 0,
								s = e.length - 1;
							for (; n <= s;) {
								const o = s + n >> 1,
									r = t(e[o]);
								if (r > 0) n = o + 1;
								else {
									if (!(r < 0)) return o;
									s = o - 1
								}
							}
							return n
						}(e, e => {
							const n = e.getBoundingClientRect();
							return t < n.top ? -1 : t > n.bottom ? 1 : 0
						});
						return e[Math.min(n, e.length - 1)]
					})(e.querySelectorAll("[data-block][data-offset-key]"), t)
				},
				p = (e, t) => {
					const n = Object(r.b)(e, l, a);
					return n || u(e, t)
				},
				m = (e, t) => {
					const n = (e => {
						const t = e.target;
						if (!(t instanceof HTMLElement)) return;
						const n = Object(r.b)(t, a);
						if (!n) return;
						const s = p(t, e.clientY);
						if (!s) return;
						const o = Object(r.b)(s, c);
						return o ? {
							editorContentElement: n,
							topLevelElement: o,
							blockElement: s
						} : void 0
					})(t);
					if (!n) return;
					const {
						topLevelElement: s,
						blockElement: o
					} = n, l = d(o), u = e.getCurrentContent(), m = u.getBlockForKey(l);
					if (!m) return;
					const {
						upperElement: h,
						lowerElement: b
					} = ((e, t, n, s) => {
						let o = n,
							r = n;
						if (e.getType() === i.b.UNSTYLED) o = r = t;
						else if (Object(i.o)(e.getType())) {
							o = r = t;
							const a = s.getBlockAfter(e.getKey());
							a && Object(i.u)(a.getType()) && (r = n.nextElementSibling)
						} else Object(i.u)(e.getType()) && (o = n.previousElementSibling, r = t);
						return {
							upperElement: o,
							lowerElement: r
						}
					})(m, o, s, u), {
						clientY: f,
						isBefore: g
					} = ((e, t, n) => {
						const s = e.getBoundingClientRect(),
							o = t.getBoundingClientRect();
						let i, c;
						if (n > (s.top + o.bottom) / 2) {
							i = o.bottom, c = !1;
							const e = Object(r.b)(t, e => !!e.nextElementSibling, a);
							if (e) {
								i = (e.nextElementSibling.getBoundingClientRect().top + o.bottom) / 2
							}
						} else {
							i = s.top, c = !0;
							const t = Object(r.b)(e, e => !!e.previousElementSibling, a);
							if (t) {
								i = (t.previousElementSibling.getBoundingClientRect().bottom + s.top) / 2
							}
						}
						return {
							clientY: i,
							isBefore: c
						}
					})(h, b, t.clientY);
					let x = l;
					if (m.getType() !== i.b.UNSTYLED) {
						const e = p(g ? h : b, f);
						e && (x = d(e))
					}
					return {
						clientY: f,
						isBefore: g,
						blockKey: x
					}
				},
				h = e => e.items ? !!Array.from(e.items).find(e => "file" === e.kind) : !(!e.files || !e.files.length) || o()(e.types, "Files"),
				b = e => e.items ? Array.from(e.items).map(e => "file" === e.kind ? e.getAsFile() : null).filter(Boolean) : e.files ? Array.from(e.files) : []
		},
		"./src/reddit/components/RichTextEditor/DragController/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_13Sj3UMDKkCCJTq88berCB",
				hideCaret: "_2BqK1CuzH2oWi2F9_cuFPQ",
				DropLine: "z5iuD3MVYcfS7tTihbvof",
				dropLine: "z5iuD3MVYcfS7tTihbvof",
				Tooltip: "_1z9S1KmnM79xn-UA0FnbP6",
				tooltip: "_1z9S1KmnM79xn-UA0FnbP6"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				c = n.n(a);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var d = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			t.a = i.a.wrapped(e => {
				const {
					children: t,
					className: n,
					renderBelow: s,
					text: i,
					tooltipContentClass: a
				} = e, u = d(e, ["children", "className", "renderBelow", "text", "tooltipContentClass"]);
				return o.a.createElement("div", l({}, u, {
					className: Object(r.a)(c.a.container, n)
				}), i ? o.a.createElement("div", {
					className: Object(r.a)(c.a.tooltip, a, s ? c.a.below : c.a.above)
				}, i) : null, t)
			}, "HoverTooltip", c.a)
		},
		"./src/reddit/components/RichTextEditor/LinksController/LinkDetailsPopup/index.m.less": function(e, t, n) {
			e.exports = {
				LinkDetailsBox: "_2F28OVOVlGo6WCT2l8lHzO",
				linkDetailsBox: "_2F28OVOVlGo6WCT2l8lHzO",
				Link: "_3vJCj_aXdDc-UXA9fDK-z-",
				link: "_3vJCj_aXdDc-UXA9fDK-z-",
				LinkButton: "_1NtBcR7JgjxkWLJrk3ddD3",
				linkButton: "_1NtBcR7JgjxkWLJrk3ddD3"
			}
		},
		"./src/reddit/components/RichTextEditor/LinksController/LinkEditorPopup/index.m.less": function(e, t, n) {
			e.exports = {
				EditForm: "_1iFkUjPC4J8jzWrDthDpcv",
				editForm: "_1iFkUjPC4J8jzWrDthDpcv",
				LinkEditorBox: "_3HMg7pEvqliZhuStFZ241S",
				linkEditorBox: "_3HMg7pEvqliZhuStFZ241S",
				Input: "_2rXi0UvEKRcI3WdI52LAx1",
				input: "_2rXi0UvEKRcI3WdI52LAx1",
				Label: "_2olni9Ucr8-t8W62nTkY_",
				label: "_2olni9Ucr8-t8W62nTkY_",
				HintAndButtonRow: "_2qiAR3ZyDGPSr9zmqhP_5Z",
				hintAndButtonRow: "_2qiAR3ZyDGPSr9zmqhP_5Z",
				InvalidUrlHint: "pKrgYGkHvjHPFkWO-Gnko",
				invalidUrlHint: "pKrgYGkHvjHPFkWO-Gnko",
				SubmitButton: "_8a_rf-Al8VNnUQ42WlvF",
				submitButton: "_8a_rf-Al8VNnUQ42WlvF"
			}
		},
		"./src/reddit/components/RichTextEditor/OrderedList/index.m.less": function(e, t, n) {
			e.exports = {
				OrderedListWrapper: "_1QXegNe8bOemD558m-vc9t",
				orderedListWrapper: "_1QXegNe8bOemD558m-vc9t"
			}
		},
		"./src/reddit/components/RichTextEditor/Paragraph/index.m.less": function(e, t, n) {
			e.exports = {
				ParagraphWrapper: "_3LuG0YVLLHE2azRNVaKz7O",
				paragraphWrapper: "_3LuG0YVLLHE2azRNVaKz7O"
			}
		},
		"./src/reddit/components/RichTextEditor/TextRendering/index.m.less": function(e, t, n) {
			e.exports = {
				H1: "_15ThA3NFuzpQTnPu0I3QKj",
				h1: "_15ThA3NFuzpQTnPu0I3QKj",
				H2: "_3R5icAd6cRzwpq-yhvQUoW",
				h2: "_3R5icAd6cRzwpq-yhvQUoW",
				H3: "_3UxnA7bFPnKoS0rKMO1UYe",
				h3: "_3UxnA7bFPnKoS0rKMO1UYe",
				H4: "_10CFPbxVR0HQhyRBkeExmO",
				h4: "_10CFPbxVR0HQhyRBkeExmO",
				H5: "_3bidJE2WceaRjyBA8LLfp3",
				h5: "_3bidJE2WceaRjyBA8LLfp3",
				H6: "_27N6aQ0-d-ntRM1JkDwGg7",
				h6: "_27N6aQ0-d-ntRM1JkDwGg7"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.m.less": function(e, t, n) {
			e.exports = {
				FormatterButton: "alPx0QCb4Fws5307SrGWu",
				formatterButton: "alPx0QCb4Fws5307SrGWu",
				enabled: "_1H0LLEwUP5ys6cgxr9KhMa",
				active: "_32EiQr-Px2GJvCfigwwmuK"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				c = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.m.less"),
				l = n.n(c);
			const d = e => {
				e.preventDefault(), e.stopPropagation()
			};
			t.a = i.a.wrapped(e => {
				const {
					active: t,
					className: n,
					disabledTooltip: s,
					enabled: i = !0,
					tooltip: c,
					Icon: u,
					onClick: p,
					tooltipBelow: m,
					children: h
				} = e;
				return o.a.createElement("div", {
					"aria-label": c,
					"aria-selected": t,
					className: Object(r.a)(l.a.button, n, {
						[l.a.active]: !!t,
						[l.a.enabled]: i
					}),
					onMouseDown: d,
					onClick: function(e) {
						d(e), i && p && p(e)
					},
					role: "button",
					tabIndex: -1
				}, o.a.createElement(a.a, {
					text: (i ? c : s) || "",
					tooltipContentClass: e.tooltipContentClass,
					renderBelow: m
				}), u ? o.a.createElement(u, null) : null, h)
			}, "FormatterButton", l.a)
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.m.less": function(e, t, n) {
			e.exports = {
				LoadingIcon: "jOFrSZE7wRk_lVAP2pBvY",
				loadingIcon: "jOFrSZE7wRk_lVAP2pBvY",
				Text: "EVdFfF5K7kZFMaYpSHbLe",
				text: "EVdFfF5K7kZFMaYpSHbLe",
				Button: "_1Mg8ZhclDuQlkzEqVU21qu",
				button: "_1Mg8ZhclDuQlkzEqVU21qu"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/PostCreationForm/DivButton/index.tsx"),
				d = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				u = n("./src/reddit/selectors/editorContent.ts"),
				p = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				m = n("./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.m.less"),
				h = n.n(m);
			const b = c.a.wrapped(d.a, "LoadingIcon", h.a),
				f = c.a.span("Text", h.a),
				g = c.a.wrapped(l.a, "Button", h.a),
				x = Object(a.c)({
					isConverting: (e, t) => Object(u.a)(e, t.draftKey)
				}),
				y = Object(i.b)(x);
			t.a = y(e => r.a.createElement(g, {
				"aria-label": s.fbt._("Switch to markdown", null, {
					hk: "OxsM0"
				}),
				tabIndex: -1,
				className: e.className,
				onClick: e.onClick
			}, e.isConverting && r.a.createElement(b, {
				sizePx: 12
			}), !e.shouldHideTooltip && r.a.createElement(p.a, {
				text: s.fbt._("Switch to markdown", null, {
					hk: "4mWw83"
				})
			}), r.a.createElement(f, null, s.fbt._("Markdown mode", null, {
				hk: "VQcEn"
			}))))
		},
		"./src/reddit/components/RichTextEditor/Toolbar/MediaInputButton/index.m.less": function(e, t, n) {
			e.exports = {
				ImageIcon: "_1jv-IJjyjDSSVuYe6CzeHv",
				imageIcon: "_1jv-IJjyjDSSVuYe6CzeHv",
				VideoIcon: "uo_2BSPFse-IQNQbclyKb",
				videoIcon: "uo_2BSPFse-IQNQbclyKb",
				HiddenInput: "_2keaDnXIlu9Yq2y-cC8zgu",
				hiddenInput: "_2keaDnXIlu9Yq2y-cC8zgu"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.m.less": function(e, t, n) {
			e.exports = {
				Icon: "_3UAl61hrkRAXX5JQ6m_q8R",
				icon: "_3UAl61hrkRAXX5JQ6m_q8R"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return O
			})), n.d(t, "b", (function() {
				return L
			})), n.d(t, "e", (function() {
				return A
			})), n.d(t, "j", (function() {
				return F
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "i", (function() {
				return B
			})), n.d(t, "k", (function() {
				return U
			})), n.d(t, "d", (function() {
				return K
			})), n.d(t, "l", (function() {
				return H
			})), n.d(t, "h", (function() {
				return V
			})), n.d(t, "a", (function() {
				return W
			})), n.d(t, "c", (function() {
				return z
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/icons/svgs/FormattingBlockQuotes/index.tsx"),
				c = n("./src/reddit/icons/svgs/FormattingBold/index.tsx"),
				l = n("./src/reddit/icons/svgs/FormattingCodeBlock/index.tsx"),
				d = n("./src/reddit/icons/svgs/FormattingHeading/index.tsx"),
				u = n("./src/reddit/icons/svgs/FormattingItalics/index.tsx"),
				p = n("./src/reddit/icons/svgs/FormattingMonospace/index.tsx"),
				m = n("./src/reddit/icons/svgs/FormattingOrderedList/index.tsx"),
				h = n("./src/reddit/icons/svgs/FormattingSpoiler/index.tsx"),
				b = n("./src/reddit/icons/svgs/FormattingStrikethrough/index.tsx"),
				f = n("./src/reddit/icons/svgs/FormattingSuperscript/index.tsx"),
				g = n("./src/reddit/icons/svgs/FormattingUnorderedList/index.tsx"),
				x = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				y = n("./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.m.less"),
				v = n.n(y);

			function C() {
				return (C = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const E = e => i.a.wrapped(e, "Icon", v.a),
				O = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					return n => {
						const s = E(e);
						return r.a.createElement(s, C({}, n, {
							style: {
								padding: t
							}
						}))
					}
				},
				j = O(a.a),
				w = O(c.a),
				S = O(l.a),
				_ = O(d.a),
				k = O(u.a),
				T = O(p.a),
				I = O(m.a),
				P = O(h.a, 1),
				M = O(b.a),
				N = O(f.a),
				R = O(g.a),
				L = {
					type: "style",
					name: "bold",
					Icon: w,
					style: x.k.BOLD,
					tooltipTranslation: () => s.fbt._("Bold", null, {
						hk: "16qNLn"
					})
				},
				A = {
					type: "style",
					name: "italics",
					Icon: k,
					style: x.k.ITALIC,
					tooltipTranslation: () => s.fbt._("Italics", null, {
						hk: "3hxpiB"
					})
				},
				F = {
					type: "style",
					name: "strikethrough",
					Icon: M,
					style: x.k.STRIKETHROUGH,
					tooltipTranslation: () => s.fbt._("Strikethrough", null, {
						hk: "U4hXC"
					})
				},
				D = {
					type: "style",
					name: "inline_code",
					Icon: T,
					style: x.k.MONOSPACE,
					tooltipTranslation: () => s.fbt._("Inline Code", null, {
						hk: "1eNxEt"
					})
				},
				B = {
					type: "style",
					name: "spoiler",
					Icon: P,
					style: x.k.SPOILER,
					tooltipTranslation: () => s.fbt._("Spoiler", null, {
						hk: "1tb6Ht"
					})
				},
				U = {
					type: "style",
					name: "superscript",
					Icon: N,
					style: x.k.SUPERSCRIPT,
					tooltipTranslation: () => s.fbt._("Superscript", null, {
						hk: "sqKFn"
					})
				},
				K = {
					type: "block",
					name: "heading",
					Icon: _,
					block: x.b.H1,
					tooltipTranslation: () => s.fbt._("Heading", null, {
						hk: "4jnBPs"
					})
				},
				H = {
					type: "block",
					name: "unordered_list",
					Icon: R,
					block: x.i.UNORDERED,
					tooltipTranslation: () => s.fbt._("Bulleted List", null, {
						hk: "21Yx7R"
					})
				},
				V = {
					type: "block",
					name: "ordered_list",
					Icon: I,
					block: x.i.ORDERED,
					tooltipTranslation: () => s.fbt._("Numbered List", null, {
						hk: "4BmF1X"
					})
				},
				W = {
					type: "block",
					name: "block_quote",
					Icon: j,
					block: x.e,
					tooltipTranslation: () => s.fbt._("Quote Block", null, {
						hk: "1xUsGm"
					})
				},
				z = {
					type: "block",
					name: "code_block",
					Icon: S,
					block: x.f,
					tooltipTranslation: () => s.fbt._("Code Block", null, {
						hk: "2y19DH"
					})
				}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/index.m.less": function(e, t, n) {
			e.exports = {
				toolbarContent: "_2vR2-7URvDAFSwQjhcvJ7m",
				isSticky: "r7zyyy152ZTdiHhea0cIj",
				tooltip: "dMXy0l6Saub8-fPDkQvGC",
				SectionSpacer: "_2voJAi1L0g2QbtAFDHSOCK",
				sectionSpacer: "_2voJAi1L0g2QbtAFDHSOCK",
				Spacer: "uoedn0efWwCxoQUIxsJY3",
				spacer: "uoedn0efWwCxoQUIxsJY3"
			}
		},
		"./src/reddit/components/RichTextEditor/Toolbar/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return A
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "f", (function() {
				return U
			})), n.d(t, "h", (function() {
				return K
			})), n.d(t, "e", (function() {
				return H
			})), n.d(t, "a", (function() {
				return V
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "b", (function() {
				return z
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/icons/svgs/FormattingHyperlink/index.tsx"),
				d = n("./src/reddit/icons/svgs/FormattingTable/index.tsx"),
				u = n("./src/reddit/components/RichTextEditor/editorStateTransforms.ts"),
				p = n("./src/reddit/components/RichTextEditor/helpers/controlsState.ts"),
				m = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				h = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				b = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				f = n("./src/reddit/components/RichTextEditor/table/helpers.ts");
			var g = (e, t, n) => {
					if (Object(m.v)(s.RichUtils.getCurrentBlockType(e))) return e;
					const o = e.getCurrentContent(),
						r = e.getSelection().getEndKey(),
						i = Object(f.l)(t, n),
						a = Object(b.f)(o, r, i, b.a.after, !0),
						c = s.EditorState.push(e, a, h.e);
					return s.EditorState.forceSelection(c, s.SelectionState.createEmpty(i[0].getKey()))
				},
				x = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				y = n("./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.tsx"),
				v = n("./src/reddit/components/RichTextEditor/Toolbar/MarkdownButton/index.tsx"),
				C = n("./src/lib/constants/index.ts"),
				E = n("./src/reddit/icons/svgs/ImagePost/index.tsx"),
				O = n("./src/reddit/icons/svgs/Video/index.tsx"),
				j = n("./src/reddit/components/RichTextEditor/Toolbar/MediaInputButton/index.m.less"),
				w = n.n(j);
			const S = c.a.wrapped(E.a, "ImageIcon", w.a),
				_ = c.a.wrapped(O.a, "VideoIcon", w.a),
				k = c.a.input("HiddenInput", w.a);
			class T extends r.Component {
				constructor() {
					super(...arguments), this.hiddenInputEl = null, this.onFileInputChange = e => {
						e.stopPropagation();
						const t = this.hiddenInputEl;
						t.files && t.files.length && (this.props.onFilesInput(Array.from(t.files)), t.value = "")
					}, this.onButtonClick = () => {
						this.hiddenInputEl && this.hiddenInputEl.click(), this.props.onClick()
					}, this.onHiddenInputClick = e => e.stopPropagation()
				}
				render() {
					const {
						controlsState: e,
						destSubreddit: t,
						type: n
					} = this.props, s = "image" === n, r = e.blocks[m.a];
					let a = !0;
					if (t && t.allowedPostTypes) {
						const {
							images: e,
							videos: n
						} = t.allowedPostTypes;
						a = s ? e : n
					}
					return i.a.createElement(x.a, {
						Icon: s ? S : _,
						active: r.isActive,
						enabled: r.isEnabled && a,
						tooltip: s ? o.fbt._("Add an image", null, {
							hk: "4bqU7J"
						}) : o.fbt._("Add a video", null, {
							hk: "2dn6oZ"
						}),
						onClick: this.onButtonClick
					}, i.a.createElement(k, {
						multiple: !0,
						innerRef: e => this.hiddenInputEl = e,
						onChange: this.onFileInputChange,
						onClick: this.onHiddenInputClick,
						type: "file",
						accept: Array.from(s ? C.a : C.b).join()
					}))
				}
			}
			var I = n("./src/reddit/components/RichTextEditor/Toolbar/index.m.less"),
				P = n.n(I);

			function M() {
				return (M = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const N = Object(y.f)(l.a),
				R = Object(y.f)(d.a),
				L = e => i.a.createElement(x.a, M({}, e, {
					tooltipContentClass: P.a.tooltip
				})),
				A = c.a.div("SectionSpacer", P.a),
				F = c.a.div("Spacer", P.a),
				D = (e, t, n, o, r) => {
					const {
						name: a,
						Icon: c,
						tooltipTranslation: l
					} = e, d = l();
					if ("style" === e.type) {
						const {
							style: s
						} = e;
						return i.a.createElement(L, {
							Icon: c,
							active: t.styles[s].isActive,
							enabled: t.styles[s].isEnabled,
							key: a,
							tooltip: d,
							onClick: () => {
								const e = Object(u.c)(s, n);
								o(e), r(a, ((e, t) => e.getCurrentInlineStyle().contains(t))(e, s))
							}
						})
					} {
						const {
							block: l
						} = e;
						return i.a.createElement(L, {
							Icon: c,
							active: t.blocks[l].isActive,
							enabled: t.blocks[l].isEnabled,
							key: a,
							tooltip: d,
							onClick: () => {
								const e = Object(u.i)(l, n);
								o(e), r(a, ((e, t) => s.RichUtils.getCurrentBlockType(e) === t)(e, l))
							}
						})
					}
				},
				B = (e, t, n, s, o) => e.map(e => D(e, t, n, s, o)),
				U = [y.b, y.e],
				K = [y.j, y.g, y.k, y.i],
				H = [y.d, y.l, y.h, y.a, y.c],
				V = e => i.a.createElement(L, {
					Icon: N,
					active: e.controlsState.link.isActive,
					enabled: e.controlsState.link.isEnabled,
					tooltip: o.fbt._("Link", null, {
						hk: "e4PGW"
					}),
					onClick: () => {
						e.onLinkButtonClick(), e.trackOnClick("link", !0)
					}
				}),
				W = e => i.a.createElement(L, {
					Icon: R,
					active: e.controlsState.blocks[m.l].isActive,
					enabled: e.controlsState.blocks[m.l].isEnabled,
					tooltip: o.fbt._("Table", null, {
						hk: "3cHfLT"
					}),
					onClick: () => {
						e.onChange(g(e.editorState, 3, 2)), e.trackOnClick("table", !0)
					}
				}),
				z = e => {
					const {
						className: t,
						allowMediaUploads: n = !1,
						destSubreddit: s,
						editorState: o,
						isOverlay: r,
						onChange: c,
						onFilesSelect: l,
						readOnly: d,
						trackOnClick: u,
						onLinkButtonClick: m,
						onMarkdownButtonClick: h
					} = e, b = Object(p.a)(o);
					return d && Object(p.b)(b), i.a.createElement("div", {
						className: Object(a.a)(P.a.toolbarContent, t, {
							[P.a.isSticky]: !r
						})
					}, B(U, b, o, c, u), i.a.createElement(V, {
						controlsState: b,
						trackOnClick: u,
						onLinkButtonClick: m
					}), B(K, b, o, c, u), i.a.createElement(A, null), B(H, b, o, c, u), i.a.createElement(A, null), i.a.createElement(W, {
						controlsState: b,
						editorState: o,
						trackOnClick: u,
						onChange: c
					}), n && i.a.createElement(T, {
						destSubreddit: s,
						controlsState: b,
						onClick: () => u("image_upload"),
						onFilesInput: l,
						type: "image"
					}), n && i.a.createElement(T, {
						destSubreddit: s,
						controlsState: b,
						onClick: () => u("video_upload"),
						onFilesInput: l,
						type: "video"
					}), i.a.createElement(F, null), i.a.createElement(v.a, {
						onClick: h
					}))
				}
		},
		"./src/reddit/components/RichTextEditor/Tooltip/getSelectionClientRect.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js");

			function o() {
				const e = window.getSelection();
				if (!e.rangeCount) return null;
				const t = Object(s.getVisibleSelectionRect)(window);
				return t || (!t && e.focusNode && e.focusNode === e.anchorNode ? e.focusNode.getBoundingClientRect() : null)
			}
		},
		"./src/reddit/components/RichTextEditor/Tooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltipBox: "tVQ1dB4n0mAWdcQNxFq-K",
				dropdown: "_1akkpO3lymdoWGIc5tjIpm",
				triangle: "_2O2U-Vhc1mg9O7DOwp50Aa",
				triangleBack: "_3IfYYXUMUzn2OvoiMUNcaQ",
				triangleFront: "_3CtwSTtkmKXvzDo3TmCp9C",
				triangleBelow: "_1churYJpAwcb-tf0k1c46F"
			}
		},
		"./src/reddit/components/RichTextEditor/Tooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/index.tsx"),
				a = n("./src/reddit/helpers/dom/index.ts"),
				c = n("./src/reddit/components/RichTextEditor/Tooltip/index.m.less"),
				l = n.n(c);
			const d = 8,
				u = 16,
				p = 15 + u / 2;
			var m;
			! function(e) {
				e[e.None = 0] = "None", e[e.Above = 1] = "Above", e[e.Below = 2] = "Below"
			}(m || (m = {}));
			const h = e => {
				let {
					isBelow: t = !1,
					style: n
				} = e;
				return o.a.createElement("div", {
					className: Object(r.a)(l.a.triangle, {
						[l.a.triangleBelow]: t
					}),
					style: n
				}, o.a.createElement("div", {
					className: l.a.triangleBack
				}), o.a.createElement("div", {
					className: l.a.triangleFront
				}))
			};
			class b extends s.Component {
				constructor(e) {
					super(e), this.containerRef = null, this.updateContainerRef = e => this.containerRef = e, this.setTargetPosition = e => {
						e ? this.updatePositioning(e) : this.setState({
							positioning: null
						})
					}, this.state = {
						positioning: null
					}
				}
				updatePositioning(e) {
					if (!this.containerRef) return;
					const t = this.containerRef.offsetWidth,
						n = this.containerRef.offsetHeight,
						s = this.state.positioning;
					if (!e) {
						if (!s) return;
						if (s.tooltipWidth === t && s.tooltipHeight === n) return
					}
					const o = e ? e.bottom : s.target.bottom,
						r = e ? e.top : s.target.top,
						i = e ? e.left : s.target.left,
						c = Object(a.e)(this.containerRef);
					let l, d, u;
					if (c) {
						const e = c.getBoundingClientRect();
						l = e.bottom - (o || 0), d = i - e.left + c.scrollLeft, u = r - e.top + c.scrollTop
					} else {
						const e = document.documentElement,
							t = window.pageYOffset || e.scrollTop;
						d = i + (window.pageXOffset || e.scrollLeft), u = r + t
					}
					const p = {
						target: {
							top: r,
							left: i
						},
						tooltipWidth: t,
						tooltipHeight: n,
						tooltip: {
							top: u,
							left: d,
							bottom: l
						}
					};
					this.adjustPositionForTriangle(p, c), this.setState({
						positioning: p
					})
				}
				adjustPositionForTriangle(e, t) {
					const {
						trianglePlacement: n
					} = this.props;
					if (!n) return;
					const s = t ? t.offsetWidth : document.documentElement.offsetWidth,
						o = s ? Math.max(e.tooltip.left + e.tooltipWidth - s, 0) : 0;
					e.tooltip.left -= o + p;
					const r = o + p - u / 2;
					let i;
					n === m.Above ? (e.tooltip.top += d, i = -d) : (e.tooltip.top -= e.tooltipHeight + d, i = e.tooltipHeight), e.triangle = {
						top: i,
						left: r
					}
				}
				componentDidUpdate(e, t) {
					e.targetPosition !== this.props.targetPosition ? this.setTargetPosition(this.props.targetPosition || null) : this.updatePositioning()
				}
				componentDidMount() {
					this.setTargetPosition(this.props.targetPosition || null), this.props.onSetPositionUpdater && this.props.onSetPositionUpdater(this.setTargetPosition)
				}
				componentWillUnmount() {
					this.props.onSetPositionUpdater && this.props.onSetPositionUpdater(null)
				}
				render() {
					const {
						aboveParent: e,
						dropdown: t,
						trianglePlacement: n
					} = this.props, {
						positioning: s
					} = this.state, a = s && void 0 !== s.triangle && o.a.createElement(h, {
						isBelow: n === m.Below,
						style: {
							top: s.triangle.top + "px",
							left: s.triangle.left + "px"
						}
					});
					let c = o.a.createElement("div", {
						className: Object(r.a)(l.a.tooltipBox, this.props.className, {
							[l.a.dropdown]: t
						}),
						style: s ? Object.assign({
							left: s.tooltip.left
						}, e ? {
							bottom: s.tooltip.bottom
						} : {
							top: s.tooltip.top
						}) : {},
						ref: this.updateContainerRef
					}, s && this.props.children && o.a.createElement(o.a.Fragment, null, a, this.props.children));
					return this.props.usePortal && (c = Object(i.d)(c, this.props.portalContainer || document.body)), c
				}
			}
		},
		"./src/reddit/components/RichTextEditor/UnorderedList/index.m.less": function(e, t, n) {
			e.exports = {
				UnorderedListWrapper: "vXDC2CysyRNVq3lFirKDs",
				unorderedListWrapper: "vXDC2CysyRNVq3lFirKDs"
			}
		},
		"./src/reddit/components/RichTextEditor/constants/draftEditorCommands.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "a", (function() {
				return d
			}));
			const s = "bold",
				o = "italic",
				r = "underline",
				i = "undo",
				a = "backspace",
				c = "delete",
				l = "split-block",
				d = "adjust-depth"
		},
		"./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			}));
			const s = "backspace-character",
				o = "insert-fragment",
				r = "insert-characters",
				i = "change-block-data",
				a = "change-block-type",
				c = "remove-range"
		},
		"./src/reddit/components/RichTextEditor/editorStateTransforms.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return u
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return x
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "a", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./node_modules/immutable/dist/immutable.js"),
				r = n("./src/reddit/components/RichTextEditor/constants/draftEditorCommands.ts"),
				i = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				a = n("./src/reddit/components/RichTextEditor/emotes/helpers.ts"),
				c = n("./src/reddit/components/RichTextEditor/helpers/modifiers.ts"),
				l = n("./src/reddit/components/RichTextEditor/helpers/styles.ts"),
				d = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const u = (e, t) => {
					return t.getSelection().isCollapsed() ? Object(l.a)(e, t) : Object(l.b)(e, t)
				},
				p = (e, t) => {
					const n = t.getCurrentContent(),
						o = t.getSelection(),
						r = o.getEndKey(),
						c = s.RichUtils.getCurrentBlockType(t) === e ? d.n : e;
					let u = t,
						p = s.Modifier.setBlockType(n, o, c);
					const m = n.getBlockForKey(r).getLength();
					if (Object(d.r)(c) || Object(d.q)(c)) {
						const e = s.SelectionState.createEmpty(o.getStartKey()).merge({
							focusKey: o.getEndKey(),
							focusOffset: m
						});
						u = Object(l.c)(u), p = ((e, t) => {
							const n = Object.keys(d.k).reduce((e, n) => s.Modifier.removeInlineStyle(e, t, d.k[n]), e);
							return Object(a.h)(n, t)
						})(p, e)
					}
					if (Object(d.q)(c) || Object(d.p)(c)) {
						const e = p.getBlockAfter(r);
						if (!e || e.getType() !== c && e.getType() !== d.n) {
							const e = s.SelectionState.createEmpty(r).merge({
								anchorOffset: m,
								focusOffset: m
							});
							p = s.Modifier.splitBlock(p, e), p = s.Modifier.setBlockType(p, p.getSelectionAfter(), d.n)
						}
					}
					return p = p.merge({
						selectionAfter: o
					}), s.EditorState.push(u, p, i.c)
				},
				m = (e, t) => {
					const n = s.Modifier.setBlockType(e, t, d.n);
					return s.Modifier.replaceText(n, t, "", Object(o.OrderedSet)([]))
				},
				h = (e, t) => s.EditorState.forceSelection(e, s.SelectionState.createEmpty(t)),
				b = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						r = c.d(t, n),
						a = r.getBlockAfter(n.getEndKey()),
						l = s.SelectionState.createEmpty(a.getKey()),
						u = s.Modifier.replaceText(s.Modifier.setBlockType(r, l, d.n), l, "", Object(o.OrderedSet)([])),
						p = s.EditorState.push(e, u, i.d);
					return h(p, a.getKey())
				},
				f = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						o = t.getBlockForKey(n.getEndKey()),
						i = o.set("depth", Math.max(o.getDepth() - 1, 0)),
						a = t.merge({
							blockMap: t.getBlockMap().merge({
								[o.getKey()]: i
							})
						});
					return s.EditorState.push(e, a, r.a)
				},
				g = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						o = t.getBlockForKey(n.getEndKey()).getKey(),
						r = s.EditorState.push(e, m(t, n), i.c);
					return h(r, o)
				},
				x = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						o = t.getBlockForKey(n.getEndKey()),
						r = o.getKey(),
						a = t.getBlockBefore(r).getKey(),
						c = s.SelectionState.createEmpty(r).merge({
							focusOffset: o.getText().length
						}),
						l = s.EditorState.push(e, m(((e, t) => {
							const n = e.getBlockMap().remove(t);
							return e.merge({
								blockMap: n
							})
						})(t, a), c), i.c);
					return h(l, r)
				},
				y = e => {
					const t = c.d(e.getCurrentContent(), e.getSelection());
					return s.EditorState.push(e, t, r.f)
				},
				v = e => {
					const t = c.a(e.getCurrentContent(), e.getSelection(), "\n");
					return s.EditorState.push(e, t, i.d)
				},
				C = e => {
					const t = e.getSelection(),
						n = c.a(e.getCurrentContent(), t, " ");
					return s.EditorState.push(e, n, i.d)
				}
		},
		"./src/reddit/components/RichTextEditor/emotes/decorator.m.less": function(e, t, n) {
			e.exports = {
				emote: "Q7hqnjoPSXm7QyvW8qf57",
				sticker: "_1WD0TSe2_gY29FXmFjPCza"
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "d", (function() {
				return v
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./node_modules/immutable/dist/immutable.js"),
				r = n("./src/lib/memoizeByReference/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				a = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				c = n("./src/reddit/components/RichTextEditor/entity/getAllEntitiesInSelection.ts"),
				l = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				d = n("./src/reddit/components/RichTextEditor/helpers/modifiers.ts"),
				u = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const p = "⬛";

			function m(e, t) {
				return e.createEntity(a.a.EMOTE, "IMMUTABLE", t)
			}

			function h(e, t) {
				let n = t.getCurrentContent();
				const o = (n = m(n, e)).getLastCreatedEntityKey();
				n = Object(d.b)(n, t.getSelection(), p, void 0, o);
				const r = s.EditorState.push(t, n, i.d);
				return s.EditorState.forceSelection(r, r.getSelection())
			}

			function b(e, t) {
				if (t.getStartKey() !== t.getEndKey()) return !1;
				const n = e.getBlockForKey(t.getEndKey()).getType();
				return !(Object(u.q)(n) || Object(u.r)(n) || Object(u.t)(n))
			}

			function f(e, t) {
				const n = Object(c.a)(e, t, t => {
					const n = t.getEntity();
					return !!n && e.getEntity(n).getType() === a.a.EMOTE
				});
				let o;
				for (; o = n.pop();) {
					const t = s.SelectionState.createEmpty(o.blockKey).merge({
						anchorOffset: o.start,
						focusOffset: o.end
					});
					e = s.Modifier.removeRange(e, t, "backward")
				}
				return e
			}

			function g(e) {
				const t = e.getSelection();
				if (!t.isCollapsed()) return null;
				const n = e.getCurrentContent().getBlockForKey(t.getFocusKey()),
					s = n.getText(),
					o = n.getCharacterList();
				let r = t.getFocusOffset() - 1;
				const i = [];
				for (; r >= 0;) {
					const e = s[r],
						t = o.get(r),
						n = t && t.getEntity();
					if (!e.trim().length || n) return null;
					if (":" === e && i.length > 0) break;
					i.unshift(e), r--
				}
				return r >= 0 && i.length ? i.join("").toLowerCase() : null
			}

			function x(e, t, n) {
				e.findEntityRanges(e => {
					const t = e.getEntity();
					return !!t && n.getEntity(t).getType() === a.a.EMOTE
				}, t)
			}
			const y = Object(r.a)(e => {
				if (e.getBlockMap().size > 1) return !1;
				const t = e.getFirstBlock();
				let n = 0;
				return x(t, () => n++, e), n <= 3 && n === t.getLength()
			});

			function v(e, t) {
				if (y(e.getCurrentContent()) === y(t.getCurrentContent())) return e;
				const n = e.getCurrentContent(),
					r = n.getFirstBlock();
				return s.EditorState.set(e, {
					currentContent: s.Modifier.mergeBlockData(n, Object(l.b)(r), Object(o.Map)({
						_emote_modified: new Date
					}))
				})
			}
		},
		"./src/reddit/components/RichTextEditor/entity/applyEntityToContentBlock.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js");

			function o(e, t, n, o) {
				let r = e.getCharacterList();
				return r = r.withMutations(e => {
					for (let r = t; r < n; r++) e.set(r, s.CharacterMetadata.applyEntity(e.get(r), o))
				}), e.set("characterList", r)
			}
		},
		"./src/reddit/components/RichTextEditor/entity/cloneEntitiesInFragment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/components/RichTextEditor/entity/applyEntityToContentBlock.ts");

			function o(e, t, n, o, r) {
				const i = e.createEntity(n.getType(), n.getMutability(), n.getData()),
					a = e.getLastCreatedEntityKey();
				return [i, Object(s.a)(t, o, r, a)]
			}

			function r(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				const s = new Map;
				let r = t,
					i = e;
				return t.forEach((e, t) => {
					e && t && e.findEntityRanges(e => !!e.getEntity(), (n, o) => {
						const r = e.getEntityAt(n),
							i = s.get(r) || [];
						i.push({
							start: n,
							end: o,
							blockKey: t
						}), s.set(r, i)
					})
				}), s.forEach((t, s) => {
					const a = e.getEntity(s);
					(n ? t.slice(1) : t).forEach(e => {
						let {
							start: t,
							end: n,
							blockKey: s
						} = e;
						const c = r.get(s),
							[l, d] = o(i, c, a, t, n);
						i = l, r = r.set(s, d)
					})
				}), [i, r]
			}
		},
		"./src/reddit/components/RichTextEditor/entity/entityTypes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = {
					COMMENT_LINK: "COMMENT_LINK",
					EMOTE: "EMOTE",
					LINK: "LINK",
					POST_LINK: "POST_LINK",
					SUBREDDIT_LINK: "SUBREDDIT_LINK",
					USER_LINK: "USER_LINK",
					USER_MENTION: "USER_MENTION"
				},
				o = new Set([s.COMMENT_LINK, s.LINK, s.POST_LINK, s.SUBREDDIT_LINK, s.USER_LINK, s.USER_MENTION]),
				r = (e, t) => {
					const n = e && t.getEntity(e);
					return !!n && (e => o.has(e))(n.getType())
				}
		},
		"./src/reddit/components/RichTextEditor/entity/getAllEntitiesInSelection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts");

			function o(e, t, n) {
				const o = [];
				return Object(s.a)(e, t, (e, s) => {
					const r = t.getStartKey() === s ? t.getStartOffset() : 0,
						i = t.getEndKey() === s ? t.getEndOffset() : e.getLength();
					e.findEntityRanges(n, (t, n) => {
						r <= n && i >= t && o.push({
							blockKey: s,
							entityKey: e.getEntityAt(t),
							start: t,
							end: n
						})
					})
				}), o
			}
		},
		"./src/reddit/components/RichTextEditor/entity/getSelectionEntityInfo.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js");

			function o(e, t) {
				const n = t.getFocusKey();
				if (n !== t.getAnchorKey()) return;
				const o = e.getBlockForKey(n),
					r = t.getStartOffset(),
					i = t.getEndOffset(),
					a = o.getEntityAt(i) || (i > 0 ? o.getEntityAt(i - 1) : null);
				if (!a) return;
				let c, l;
				if (o.findEntityRanges(e => e.getEntity() === a, (e, t) => {
						e <= r && i <= t && (c = e, l = t)
					}), "number" != typeof c || "number" != typeof l) return;
				const d = o.getText().slice(c, l);
				return {
					entitySelection: s.SelectionState.createEmpty(n).merge({
						anchorOffset: c,
						focusOffset: l
					}),
					entityKey: a,
					entityText: d
				}
			}
		},
		"./src/reddit/components/RichTextEditor/entity/link/decorator.m.less": function(e, t, n) {
			e.exports = {
				RegularLink: "_1FRfMxEAy__7c8vezYv9qP",
				regularLink: "_1FRfMxEAy__7c8vezYv9qP"
			}
		},
		"./src/reddit/components/RichTextEditor/entity/link/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "e", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./src/lib/linkMatchers/index.ts"),
				r = n("./src/lib/linkMatchers/customLinks.ts"),
				i = n("./src/lib/memoizeByReference/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				c = n("./src/reddit/components/RichTextEditor/entity/getAllEntitiesInSelection.ts"),
				l = n("./src/reddit/components/RichTextEditor/entity/getSelectionEntityInfo.ts"),
				d = n("./src/reddit/components/RichTextEditor/spoiler/helpers.ts"),
				u = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const p = [a.a.SUBREDDIT_LINK, a.a.USER_LINK, a.a.USER_MENTION],
				m = [...p, a.a.LINK];

			function h(e, t, n) {
				e.findEntityRanges(e => {
					const t = e.getEntity();
					return !!t && m.includes(n.getEntity(t).getType())
				}, t)
			}
			const b = e => {
					const t = o.a.match(e);
					if (t && t.length && t[0]) {
						const {
							schema: e,
							url: n
						} = t[0];
						return {
							linkPrefix: e,
							url: n
						}
					}
					return {
						linkPrefix: "",
						url: ""
					}
				},
				f = Object(i.a)((function(e) {
					const t = e.getCurrentContent(),
						n = e.getSelection();
					if (!n.isCollapsed()) return;
					if (Object(u.q)(t.getBlockForKey(n.getStartKey()).getType())) return;
					const r = n.getFocusKey(),
						i = t.getBlockForKey(r),
						a = n.getFocusOffset(),
						c = i.getText(),
						l = c.lastIndexOf(" ", a - 1) + 1,
						p = c.slice(l, a);
					if (!p) return;
					const m = o.e.match(p);
					if (!m) return;
					const h = m[m.length - 1],
						b = l + h.index,
						f = l + h.lastIndex;
					let g = -1;
					if (i.findEntityRanges(e => !!e.getEntity(), (e, t) => {
							e < a && (g = t)
						}), g >= b) return;
					return i.getCharacterList().slice(b, f).find(d.b) ? void 0 : {
						selection: s.SelectionState.createEmpty(r).merge({
							anchorOffset: b,
							focusOffset: f
						}),
						url: h.url
					}
				}));

			function g(e, t, n) {
				const o = e.getSelection();
				let r = e.getCurrentContent();
				const i = (r = r.createEntity(a.a.LINK, "MUTABLE", {
					url: n
				})).getLastCreatedEntityKey();
				return r = (r = s.Modifier.applyEntity(r, t, i)).merge({
					selectionAfter: o
				}), s.EditorState.push(e, r, "apply-entity")
			}
			const x = Object(i.a)((function(e) {
				const t = e.getCurrentContent(),
					n = Object(l.a)(t, e.getSelection());
				if (!n) return;
				const s = t.getEntity(n.entityKey);
				if (s.getType() !== a.a.LINK) return;
				const {
					url: o
				} = s.getData();
				return Object.assign({
					url: o
				}, n)
			}));
			const y = Object(i.a)((function(e) {
				const t = e.getCurrentContent(),
					n = e.getSelection(),
					s = Object(l.a)(t, n);
				if (!s) return;
				const o = n.getFocusOffset(),
					r = t.getEntity(s.entityKey),
					{
						linkPrefix: i
					} = b(s.entityText);
				if (!p.includes(r.getType()) || !s.entityText.startsWith(i) || o - s.entitySelection.getStartOffset() < i.length) return;
				const a = s.entityText.slice(i.length);
				return Object.assign({
					internalName: a
				}, s)
			}));

			function v(e, t, n, o) {
				let r = "apply-entity",
					i = e.getCurrentContent(),
					c = e;
				const d = Object(l.a)(i, t);
				if (n)
					if (d) {
						const e = i.getEntity(d.entityKey),
							{
								url: t
							} = e.getData();
						t !== n && (i = i.mergeEntityData(d.entityKey, {
							url: n
						})), void 0 !== o && d.entityText !== o && (i = s.Modifier.replaceText(i, d.entitySelection, o, void 0, d.entityKey), r = "insert-characters")
					} else {
						if (void 0 === o) throw new Error("New link display text must be provided!");
						const e = (i = i.createEntity(a.a.LINK, "MUTABLE", {
							url: n
						})).getLastCreatedEntityKey();
						i = s.Modifier.replaceText(i, t, o, void 0, e), r = "insert-characters"
					}
				else i = (i = s.Modifier.applyEntity(i, t, "")).merge({
					selectionAfter: e.getSelection()
				});
				return i === e.getCurrentContent() ? e : c = s.EditorState.push(c, i, r)
			}

			function C(e, t) {
				const n = y(e);
				if (!n) return e;
				const {
					linkPrefix: o,
					url: i
				} = b(n.entityText), a = o === r.d.mention ? r.d.profile : o, c = "".concat(a).concat(t), l = n.entitySelection.getStartOffset() + c.length;
				let d = v(e, n.entitySelection, i, c);
				return d = s.EditorState.forceSelection(d, n.entitySelection.merge({
					anchorOffset: l,
					focusOffset: l
				}))
			}

			function E(e, t) {
				if (t.getStartKey() !== t.getEndKey()) return !1;
				const n = e.getBlockForKey(t.getEndKey()).getType();
				return !Object(u.q)(n) && !Object(u.t)(n) && !Object(c.a)(e, t, t => {
					const n = t.getEntity();
					return !!n && e.getEntity(n).getType() !== a.a.LINK
				}).length
			}
		},
		"./src/reddit/components/RichTextEditor/helpers/common.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "g", (function() {
				return h
			}));
			var s, o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/immutable/dist/immutable.js"),
				i = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			! function(e) {
				e.before = "before", e.after = "after"
			}(s || (s = {}));
			const a = (e, t) => new o.ContentBlock(Object.assign({
					key: e || Object(o.genKey)()
				}, t ? {
					text: t,
					characterList: Object(r.List)(Object(r.Repeat)(o.CharacterMetadata.create(), t.length))
				} : {})),
				c = e => e.props.children,
				l = e => c(e).props.block,
				d = function(e, t, n) {
					let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : s.after,
						c = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
						l = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
					const d = [];
					let p = -1;
					if (e.getBlockMap().forEach((e, o) => {
							r === s.after && d.push(e), o === t && (d.push(...n), p = d.length - 1), r === s.before && d.push(e)
						}), p >= 0) {
						if (c) {
							const e = d[p + 1];
							e && e.getType() === i.n || d.splice(p + 1, 0, a())
						}
						if (l) {
							const e = p - n.length,
								t = d[e];
							t && t.getType() === i.n || d.splice(e + 1, 0, a())
						}
					}
					return e.merge({
						blockMap: o.BlockMapBuilder.createFromArray(d),
						selectionAfter: u(n[n.length - 1], !1, !0)
					})
				},
				u = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
						s = o.SelectionState.createEmpty(e.getKey()).merge({
							hasFocus: n
						});
					return t && (s = s.merge({
						anchorOffset: e.getLength(),
						focusOffset: e.getLength()
					})), s
				},
				p = (e, t) => {
					let n = e.getBlockBefore(t),
						s = e.getBlockMap();
					return s.get(t) ? (s = s.size > 1 ? s.remove(t) : s.set(t, a(t)), n = n || s.first(), e.merge({
						blockMap: s,
						selectionAfter: u(n, !0)
					})) : e
				},
				m = (e, t) => t.querySelector('[data-block][data-offset-key="'.concat(e, '-0-0"]')),
				h = e => e.getType() === i.n && !e.getText()
		},
		"./src/reddit/components/RichTextEditor/helpers/controlsState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/forEach.js"),
				o = n.n(s),
				r = n("./src/lib/forEachGroup/index.ts"),
				i = n("./src/lib/memoizeByReference/index.ts"),
				a = n("./src/reddit/components/RichTextEditor/emotes/helpers.ts"),
				c = n("./src/reddit/components/RichTextEditor/entity/link/helpers.tsx"),
				l = n("./src/reddit/components/RichTextEditor/media/helpers.ts"),
				d = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				u = n("./src/reddit/components/RichTextEditor/table/helpers.ts"),
				p = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts"),
				m = n("./src/reddit/components/RichTextEditor/helpers/styles.ts");
			const h = e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						s = {};
					o()(d.k, e => s[e] = {
						isActive: !1,
						isEnabled: !1
					});
					const i = new Set(Object.keys(s));
					if (i.delete(d.k.HIGHLIGHT), n.isCollapsed()) {
						const o = t.getBlockForKey(n.getEndKey()),
							r = o.getType();
						Object(d.q)(r) || Object(d.r)(r) || Object(d.t)(r) || i.forEach(e => s[e].isEnabled = !0), e.getCurrentInlineStyle().forEach(e => {
							e && s[e] && (s[e].isActive = !0)
						}), Object(u.i)(o) && (s[d.k.BOLD] = {
							isEnabled: !1,
							isActive: !1
						})
					} else {
						Object(m.e)(t, n).forEach(e => {
							i.delete(e), s[e] && (s[e].isActive = !0, s[e].isEnabled = !0)
						}), Object(p.a)(t, n, (e, o) => {
							if (!i.size) return !1;
							const a = n.getStartKey() === o ? n.getStartOffset() : 0,
								c = n.getEndKey() === o ? n.getEndOffset() : e.getLength(),
								l = e.getType(),
								u = e.getCharacterList();
							Object(d.q)(l) || Object(d.r)(l) || Object(d.t)(l) || Object(r.a)(u, {
								start: a,
								end: c
							}, (n, o, r, a) => {
								const c = n.getStyle(),
									l = n.getEntity(),
									d = l ? t.getEntity(l) : null;
								if (i.forEach(t => {
										const n = !s[t].isActive,
											o = Object(m.f)(c, e, d, t, n);
										o && o !== c && (s[t].isEnabled = !0, i.delete(t))
									}), !i.size) return !1
							})
						})
					}
					return s
				},
				b = e => {
					const t = {};
					return o()(d.b, n => t[n] = {
						isActive: !1,
						isEnabled: e
					}), t
				},
				f = Object(i.a)(e => {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						s = (e => {
							const t = e.getCurrentContent(),
								n = e.getSelection();
							let s = b(!0),
								r = null;
							if (n.isCollapsed()) r = t.getBlockForKey(n.getEndKey()).getType();
							else {
								let e = null;
								Object(p.a)(t, n, (t, n) => {
									const o = t.getType();
									return Object(d.t)(o) ? (s = b(!1), !1) : (null === e && (e = o), e !== o ? (e = null, !1) : void 0)
								}), r = e
							}
							return null !== r && ((Object(d.v)(r) || Object(d.t)(r)) && o()(s, e => {
								e.isEnabled = !1
							}), s[r].isActive = !0), s
						})(e);
					return {
						giphy: {
							isActive: !1,
							isEnabled: s[d.a].isEnabled && !Object(l.j)(t)
						},
						emote: {
							isActive: !1,
							isEnabled: Object(a.b)(t, n)
						},
						link: {
							isActive: !1,
							isEnabled: Object(c.e)(t, n)
						},
						blocks: s,
						styles: h(e)
					}
				}),
				g = e => {
					o()(e.blocks, e => {
						e.isEnabled = !1
					}), o()(e.styles, e => {
						e.isEnabled = !1
					}), e.link.isEnabled = !1
				}
		},
		"./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts": function(e, t, n) {
			"use strict";

			function s(e, t, n) {
				const s = t.getStartKey(),
					o = t.getEndKey();
				if (s === o) return void n(e.getBlockForKey(s), s);
				let r = !1;
				e.getBlockMap().forEach((e, t) => {
					if (t === s && (r = !0), !r || !e || !t) return;
					const i = n(e, t);
					return t !== o && i
				})
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/reddit/components/RichTextEditor/helpers/modifiers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./src/reddit/components/RichTextEditor/entity/cloneEntitiesInFragment.ts");

			function r(e, t) {
				const n = t.getStartKey();
				if (n !== t.getEndKey()) return;
				const s = e.getBlockForKey(n),
					r = t.getStartOffset(),
					i = t.getEndOffset(),
					a = r > 0 ? s.getEntityAt(r - 1) : null,
					c = s.getEntityAt(i);
				if (!a || !c || a !== c) return;
				const l = e.getEntity(c),
					d = s.getCharacterList().toSeq().skip(i).takeWhile(e => !!e && e.getEntity() === c).count(),
					[u, p] = Object(o.a)(e, s, l, i, i + d);
				return u.merge({
					blockMap: u.getBlockMap().set(s.getKey(), p)
				})
			}

			function i(e, t, n) {
				const o = r(e, t) || e;
				return s.Modifier.replaceWithFragment(o, t, n)
			}

			function a(e, t, n, o, i) {
				let a = e;
				return -1 !== n.indexOf("\n") && (a = r(e, t) || a), s.Modifier.replaceText(a, t, n, o, i)
			}

			function c(e, t, n, o, i) {
				let a = e;
				return -1 !== n.indexOf("\n") && (a = r(e, t) || a), s.Modifier.insertText(a, t, n, o, i)
			}

			function l(e, t) {
				const n = r(e, t) || e;
				return s.Modifier.splitBlock(n, t)
			}
		},
		"./src/reddit/components/RichTextEditor/helpers/sliceContiguousBlocks.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/forEach.js"),
				o = n.n(s);
			t.a = (e, t) => {
				const n = e.getBlocksAsArray(),
					s = t.getKey(),
					r = t.getType();
				let i = null,
					a = null,
					c = !1;
				if (o()(n, (e, t) => {
						if (c || e.getKey() !== s || (c = !0), e.getType() === r) null === i && (i = t), a = t;
						else {
							if (c) return !1;
							i = null, a = null
						}
					}), c) return a = a || 0, {
					start: i = i || 0,
					blocks: n.slice(i, a + 1)
				}
			}
		},
		"./src/reddit/components/RichTextEditor/helpers/styles.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./node_modules/immutable/dist/immutable.js"),
				r = n("./src/lib/forEachGroup/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				a = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts"),
				c = n("./src/reddit/components/RichTextEditor/table/helpers.ts"),
				l = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts");
			const d = Object(o.OrderedSet)([]),
				u = function(e, t, n, s) {
					let r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
					const l = t.getType();
					if (Object(a.q)(l) || Object(a.r)(l) || Object(a.t)(l)) return;
					if (s === a.k.BOLD && Object(c.i)(t)) return;
					const u = n ? n.getType() : null,
						p = u === i.a.SUBREDDIT_LINK || u === i.a.USER_LINK;
					return p && s !== a.k.SPOILER && s !== a.k.MONOSPACE || u === i.a.EMOTE ? void 0 : s === a.k.MONOSPACE || s === a.k.SPOILER ? r ? Object(o.OrderedSet)([s]) : d : (e.has(a.k.MONOSPACE) || e.has(a.k.SPOILER)) && r ? Object(o.OrderedSet)([s]) : !r || s !== a.k.SUPERSCRIPT && s !== a.k.SUBSCRIPT ? r ? e.add(s) : e.has(s) ? e.delete(s) : void 0 : e.delete(a.k.SUBSCRIPT).delete(a.k.SUPERSCRIPT).add(s)
				},
				p = (e, t) => {
					let n = null,
						s = !0;
					return Object(l.a)(e, t, (o, l) => {
						const d = o.getType(),
							u = Object(c.i)(o);
						if (u || (s = !1), Object(a.q)(d) || Object(a.r)(d) || Object(a.t)(d)) return !1;
						const p = t.getStartKey() === l ? t.getStartOffset() : 0,
							m = t.getEndKey() === l ? t.getEndOffset() : o.getLength(),
							h = o.getCharacterList();
						Object(r.a)(h, {
							start: p,
							end: m
						}, t => {
							const s = t.getEntity();
							if (s && e.getEntity(s).getType() === i.a.SUBREDDIT_LINK) return;
							let o = t.getStyle();
							return u && (o = o.add(a.k.BOLD)), null === n ? n = o.asMutable() : n.intersect(o), !(n && !n.size) && void 0
						})
					}), null === n ? [] : (s && n.delete(a.k.BOLD), n.toJS())
				},
				m = (e, t) => {
					const n = t.getCurrentContent(),
						o = t.getSelection();
					let i = n.getBlockMap();
					const c = -1 === p(n, o).indexOf(e);
					Object(l.a)(n, o, (t, l) => {
						if (!t || !l) return !1;
						const d = o.getStartKey() === l ? o.getStartOffset() : 0,
							p = o.getEndKey() === l ? o.getEndOffset() : t.getLength(),
							m = t.getCharacterList(),
							h = m.withMutations(o => {
								Object(r.a)(m, {
									start: d,
									end: p
								}, (r, i, l, d) => {
									const p = r.getStyle(),
										m = r.getEntity(),
										h = m ? n.getEntity(m) : null,
										b = u(p, t, h, e, c);
									if (b) {
										const e = ((e, t) => s.CharacterMetadata.create({
											style: t,
											entity: t.has(a.k.SPOILER) ? null : e.getEntity()
										}))(r, b);
										for (let t = l; t < d; t++) o.set(t, e)
									}
								})
							});
						if (h !== m) {
							const e = t.set("characterList", h);
							i = i.set(l, e)
						}
					});
					const d = n.merge({
						blockMap: i,
						selectionAfter: o
					});
					return s.EditorState.push(t, d, "change-inline-style")
				},
				h = (e, t) => {
					const n = t.getCurrentContent(),
						o = t.getSelection(),
						r = n.getBlockForKey(o.getStartKey()),
						i = r.getEntityAt(o.getStartOffset()),
						a = i ? n.getEntity(i) : null,
						c = t.getCurrentInlineStyle(),
						l = u(c, r, a, e, !c.has(e));
					let d = t;
					return l && (d = s.EditorState.setInlineStyleOverride(d, l)), d
				},
				b = e => s.EditorState.setInlineStyleOverride(e, d),
				f = (e, t) => {
					const n = e.getSelection(),
						s = t.getSelection();
					return n.getStartOffset() > 0 || n.getFocusKey() === s.getFocusKey() || e.getCurrentInlineStyle().isEmpty() ? e : b(e)
				}
		},
		"./src/reddit/components/RichTextEditor/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3YZ-jFfccqhepgq1dDuLEv",
				container: "_3YZ-jFfccqhepgq1dDuLEv",
				FocusableContent: "_3wl1bRnSzxHkKJfvqakrNI",
				focusableContent: "_3wl1bRnSzxHkKJfvqakrNI",
				showSubmitButton: "_3Imp2y02BMA96sEJAe9M3M",
				mRedesign: "_2sl29I15jbNPrKiiB9kfVf",
				editorWrapper: "_2baJGEALPiEMZpWB2iWQs7",
				mExpanded: "_1UhKfcyzvaWRtDdXZmzg6D",
				userIcon: "_1wS6Q6S9RvAbzxaselfK2i",
				CurrentUserIcon: "_1RdaOAYbtM4Zwt3M_YE8kp",
				currentUserIcon: "_1RdaOAYbtM4Zwt3M_YE8kp",
				hasInitialHeight: "_35E-zXyMmfsLI7nv_sBvFL",
				hasInitialMinHeight: "_18GfdTZmF2EPjYSkBDE0WI",
				noBorder: "HXDWn-rmYOwqGcGtz9AKm",
				insetSubmitButton: "_3b2mbY1nb1R-z21ihISt7z",
				emptyContent: "_3cP1eCSI5AeGc6__VQ1axu",
				focusedContent: "_2O6bpyGivXLGxZ0LErKCzW"
			}
		},
		"./src/reddit/components/RichTextEditor/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = (n("./node_modules/draft-js/dist/Draft.css"), n("./node_modules/fbt/lib/FbtPublic.js")),
				r = n("./node_modules/lodash/filter.js"),
				i = n.n(r),
				a = n("./node_modules/react/index.js"),
				c = n.n(a),
				l = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./node_modules/shallowequal/index.js"),
				p = n.n(u),
				m = n("./src/lib/classNames/index.ts"),
				h = n("./src/lib/fastdom/index.ts"),
				b = n("./src/lib/lessComponent.tsx"),
				f = n("./src/lib/linkMatchers/customLinks.ts"),
				g = n("./src/lib/logs/console.ts"),
				x = n("./src/telemetry/models/Media.ts"),
				y = n("./src/reddit/actions/economics/subredditPremium/thunkedActions.ts"),
				v = n("./src/reddit/actions/postCreation/mediaUpload.ts"),
				C = n("./src/reddit/featureFlags/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				O = n("./src/reddit/models/Gold/Powerups/index.ts"),
				j = n("./src/reddit/models/PostCreationForm/index.ts"),
				w = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const S = {
				BREAK_HEADER_ENTITY: "BREAK_HEADER_ENTITY",
				CONVERT_TO_LIST_ON_SPACE: "CONVERT_TO_LIST_ON_SPACE",
				EXEC_TABLE_ON_ENTER_HANDLER: "EXEC_TABLE_ON_ENTER_HANDLER",
				INSERT_LINE_BREAK: "INSERT_LINE_BREAK",
				LINKIFY_ON_ENTER: "LINKIFY_ON_ENTER",
				LINKIFY_ON_SPACE: "LINKIFY_ON_SPACE",
				MAKE_PLAIN_BLOCK: "MAKE_PLAIN_BLOCK",
				OPEN_LINK_TOOLTIP: "OPEN_LINK_TOOLTIP",
				REDUCE_LIST_INDENT: "REDUCE_LIST_INDENT",
				REMOVE_EXTRA_LIST_ITEM: "REMOVE_EXTRA_LIST_ITEM",
				RESET_CURRENT_AND_PREVIOUS_BLOCKS: "RESET_CURRENT_AND_PREVIOUS_BLOCKS",
				SUBMIT: "SUBMIT"
			};
			const _ = e => {
					const t = e.getCurrentContent().getBlockMap();
					if (t.size > 2 || (e => !!e.reduce((function() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
								t = arguments.length > 1 ? arguments[1] : void 0;
							return e + t.getLength()
						}), 0))(t) || (e => !!e.find(e => Object(w.o)(e.getType())))(t)) return null; {
						const n = e.getSelection();
						if (n.isCollapsed() && n.getFocusKey() === t.first().getKey()) return n.getFocusKey()
					}
				},
				k = e => {
					const t = e.getCharacterList().map(e => s.CharacterMetadata.create({
						entity: e.getEntity()
					}));
					return e.set("characterList", t)
				};
			var T = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				I = n("./src/reddit/components/RichTextEditor/constants/draftEditorCommands.ts"),
				P = n("./node_modules/lodash/escape.js"),
				M = n.n(P),
				N = n("./src/reddit/components/RichTextEditor/media/helpers.ts"),
				R = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				L = n("./src/reddit/components/RichTextEditor/entity/entityTypes.ts"),
				A = n("./node_modules/immutable/dist/immutable.js"),
				F = n("./src/reddit/helpers/dom/index.ts"),
				D = (n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/lodash/chunk.js")),
				B = n.n(D),
				U = n("./node_modules/lodash/flatten.js"),
				K = n.n(U),
				H = n("./node_modules/lodash/takeWhile.js"),
				V = n.n(H),
				W = n("./src/reddit/components/RichTextEditor/helpers/modifiers.ts"),
				z = n("./src/reddit/components/RichTextEditor/table/helpers.ts"),
				q = n("./node_modules/lodash/last.js"),
				G = n.n(q),
				J = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				Q = n("./src/reddit/components/RichTextEditor/helpers/forEachBlock.ts"),
				Z = n("./node_modules/lodash/find.js"),
				Y = n.n(Z);
			var X = (e, t) => {
				const n = e.getSelection(),
					o = e.getCurrentContent(),
					r = o.getBlockForKey(n.getAnchorKey()),
					i = o.getBlockForKey(n.getFocusKey()),
					[a, c] = Object(z.e)(o, r, i);
				if (!a || a !== c) return e;
				const l = Object(z.g)(r),
					d = Object(z.g)(i),
					{
						blocks: u,
						start: p
					} = a,
					{
						colCount: m
					} = d,
					h = u.length / m,
					{
						minCol: b,
						minRow: f,
						maxCol: g,
						maxRow: x
					} = Object(z.f)(l, d),
					y = u.filter(e => {
						const {
							rowIndex: n,
							colIndex: s
						} = Object(z.g)(e);
						return "rows" === t ? !(f <= n && n <= x) : !(b <= s && s <= g)
					});
				y.sort(z.b);
				const v = "rows" === t ? m : y.length / h,
					C = K()(Object(z.d)(B()(y, v))),
					E = o.getBlocksAsArray(),
					O = [...E.slice(0, p), ...C, ...E.slice(p + u.length)],
					j = o.merge({
						blockMap: s.BlockMapBuilder.createFromArray(O)
					}),
					w = {
						colIndex: b,
						rowIndex: f
					};
				let S = Y()(C, e => Object(z.h)(w, Object(z.g)(e)));
				S || (S = C.length ? C[C.length - 1] : E[p > 0 ? p - 1 : 0]);
				const _ = s.SelectionState.createEmpty(S.getKey()).merge({
					focusOffset: S.getLength(),
					anchorOffset: S.getLength()
				});
				let k = s.EditorState.push(e, j, J.e);
				return k = s.EditorState.forceSelection(k, _)
			};
			var $ = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				const n = e.getSelection();
				if (n.isCollapsed()) return;
				if (n.getStartKey() === n.getEndKey() && !t) return;
				const o = e.getCurrentContent(),
					r = o.getBlockForKey(n.getAnchorKey()),
					i = o.getBlockForKey(n.getFocusKey()),
					[a, c] = Object(z.e)(o, r, i);
				if (!a || a !== c) return;
				const l = {};
				let d = n;
				if (r === i) {
					const e = Object(z.n)(i, 0, n.getStartOffset()),
						t = Object(z.n)(i, n.getEndOffset());
					l[i.getKey()] = Object(z.j)(i, [e, t]), d = n
				} else {
					if (a.blocks[0].getKey() === n.getStartKey() && G()(a.blocks).getKey() === n.getEndKey()) return X(e, "rows");
					Object(Q.a)(o, n, (e, t) => {
						l[t] = Object(z.n)(e, 0, 0)
					}), d = n.merge({
						anchorOffset: 0,
						focusOffset: 0
					})
				}
				const u = o.merge({
					blockMap: o.getBlockMap().merge(l),
					selectionAfter: d
				});
				return s.EditorState.push(e, u, J.f)
			};
			const ee = (e, t, n, s) => {
					const {
						htmlParts: o
					} = t;
					e.forEach((e, r) => {
						o.push("<".concat(n, " ").concat(s[r], " ").concat('style="margin: 0px; padding: 4px 9px; border: 1px solid rgb(229, 227, 218);"', ">")), ge(e, t), o.push("</".concat(n, ">"))
					})
				},
				te = e => {
					const t = e[0],
						n = e[e.length - 1],
						s = [...e].sort(z.b),
						{
							minCol: o,
							maxCol: r
						} = Object(z.f)(Object(z.g)(t), Object(z.g)(n)),
						i = r - o + 1;
					return Object(z.d)(B()(s, i))
				},
				ne = (e, t, n) => {
					n ? ge(e[0], t) : ((e, t) => {
						const {
							editor: n,
							htmlParts: s
						} = t, o = n.getEditorKey(), r = e[0].map(e => {
							const {
								alignment: t
							} = Object(z.g)(e);
							return t ? 'align="'.concat(z.a[t], '"') : ""
						}), [i, ...a] = e;
						s.push('\n    <table data-editor="'.concat(o, '">\n      <thead>\n        <tr>')), ee(i, t, "th", r), s.push("\n        </tr>\n      </thead>\n      <tbody>"), a.forEach(e => {
							s.push("\n        <tr>"), ee(e, t, "td", r), s.push("\n        </tr>")
						}), s.push("\n      </tbody>\n    </table>")
					})(te(e), t)
				},
				se = (e, t, n) => {
					n ? t.textParts.push(ve(e[0], t)) : ((e, t) => {
						const {
							textParts: n
						} = t;
						e.forEach(e => {
							n.push(e.map(e => ve(e, t)).join(" "))
						})
					})(te(e), t)
				},
				oe = e => {
					const {
						processed: t,
						remaining: n
					} = e, s = [];
					for (; n.length;) {
						const e = n[0];
						if (!Object(w.v)(e.getType())) break;
						s.push(n.shift())
					}
					const o = !n.length && !t.length,
						r = 1 === s.length && o;
					ne(s, e, r), se(s, e, r), ((e, t, n, s) => {
						if (n)
							if (s) {
								const n = e[0].merge({
									data: Object(A.Map)(),
									type: w.n
								});
								t.blocksParts = [n]
							} else t.blocksParts = K()(te(e))
					})(s, e, o, r), t.push(...s)
				},
				re = e => $(e, !0),
				ie = (e, t, n) => {
					const o = Object(w.v)(n.first().getType()),
						r = Object(w.v)(n.last().getType()),
						i = e.getBlockForKey(t.getAnchorKey()),
						a = e.getBlockForKey(t.getFocusKey()),
						[c, l] = Object(z.e)(e, i, a);
					return c && c === l ? ((e, t, n, o) => {
						const r = Object(w.v)(o.first().getType()),
							i = e.getBlockForKey(t.getAnchorKey()),
							a = e.getBlockForKey(t.getFocusKey()),
							{
								blocks: c,
								start: l
							} = n;
						c.sort(z.b);
						const d = Object(z.g)(c[0]);
						let {
							colCount: u
						} = d;
						const p = B()(c, u);
						let m = p.length;
						const {
							minRow: h,
							minCol: b
						} = Object(z.f)(Object(z.g)(i), Object(z.g)(a)), f = o.toArray();
						if (r) {
							const n = V()(f, e => Object(w.v)(e.getType()));
							n.sort(z.b);
							const o = Object(z.g)(n[0]).colCount,
								r = B()(n, o),
								i = r.length,
								a = h + i - 1,
								d = b + o - 1;
							if (n.length !== i * o) throw new Error("Invalid table fragment!");
							if (d >= u && p.forEach(e => {
									e.push(...Object(z.l)(d - u + 1, 1))
								}), u = p[0].length, a >= m) {
								const e = B()(Object(z.l)(u, a - m + 1), u);
								p.push(...e)
							}
							m = p.length;
							for (let e = 0; e < i; e++)
								for (let t = 0; t < o; t++) {
									const n = h + e,
										s = b + t,
										o = r[e][t];
									p[n][s] = o.set("key", p[n][s].getKey())
								}
							const g = Object(z.d)(p),
								x = K()(g),
								y = e.getBlocksAsArray(),
								v = [...y.slice(0, l), ...x, ...y.slice(l + c.length)],
								C = Object(z.o)(t, p[h][b], p[a][d]);
							return e.merge({
								blockMap: s.BlockMapBuilder.createFromArray(v),
								selectionAfter: C
							})
						} {
							const n = p[h][b],
								o = Object(z.j)(n, f, " ");
							let r = t;
							return t.getStartKey() !== t.getEndKey() && (r = Object(z.o)(t, n, n)), W.c(e, r, s.BlockMapBuilder.createFromArray([o]))
						}
					})(e, t, c, n) : c || l || !o && !r ? void 0 : ((e, t, n) => {
						const o = Object(w.v)(n.first().getType()),
							r = Object(w.v)(n.last().getType()),
							i = n.toArray();
						o && i.unshift(Object(R.h)()), r && i.push(Object(R.h)());
						const a = s.BlockMapBuilder.createFromArray(i);
						return W.c(e, t, a)
					})(e, t, n)
				};
			var ae = n("./node_modules/draft-js/lib/removeEntitiesAtEdges.js"),
				ce = n.n(ae);
			var le = (e, t) => {
				const n = t.getStartKey(),
					s = t.getStartOffset(),
					o = t.getEndKey(),
					r = t.getEndOffset(),
					i = ce()(e, t).getBlockMap(),
					a = i.keySeq(),
					c = a.indexOf(n),
					l = a.indexOf(o) + 1;
				return i.slice(c, l).map((e, t) => {
					const i = e.getText(),
						a = e.getCharacterList();
					return n === o ? e.merge({
						text: i.slice(s, r),
						characterList: a.slice(s, r)
					}) : t === n ? e.merge({
						text: i.slice(s),
						characterList: a.slice(s)
					}) : t === o ? e.merge({
						text: i.slice(0, r),
						characterList: a.slice(0, r)
					}) : e
				})
			};
			const de = (e, t) => {
					const n = {
							children: [],
							parentItem: t,
							type: e.getType()
						},
						s = {
							block: e,
							parentList: n
						};
					return n.children.push(s), t && (t.childrenLists = t.childrenLists || [], t.childrenLists.push(n)), {
						list: n,
						item: s
					}
				},
				ue = (e, t) => {
					const {
						type: n,
						children: s
					} = e, {
						htmlParts: o
					} = t, r = n === w.b.ORDERED_LIST ? "ol" : "ul";
					o.push("<".concat(r, ">")), s.forEach(e => ((e, t) => {
						const {
							block: n,
							childrenLists: s
						} = e, {
							htmlParts: o
						} = t;
						o.push("<li>"), ge(n, t, !0), s && s.forEach(e => ue(e, t)), o.push("</li>")
					})(e, t)), o.push("</".concat(r, ">"))
				},
				pe = (e, t) => {
					const {
						children: n
					} = e;
					n.forEach((e, n) => me(e, n, t))
				},
				me = (e, t, n) => {
					const {
						block: s,
						childrenLists: o
					} = e, {
						textParts: r
					} = n, i = " ".repeat(s.getDepth()), a = s.getType() === w.b.ORDERED_LIST ? "".concat(t + 1, ".") : "-", c = ve(s, n);
					r.push("".concat(i).concat(a, " ").concat(c)), o && o.forEach(e => pe(e, n))
				},
				he = e => {
					const {
						remaining: t
					} = e, n = t.shift(), s = n.getType(), o = [n];
					for (; t.length;) {
						const e = t[0],
							n = e.getType();
						if (!Object(w.s)(n)) break;
						if (e.getDepth() > 0 || n === w.b.UNORDERED_LIST) o.push(t.shift());
						else {
							if (n !== s) break;
							if (o.some(e => e.getType() !== w.b.ORDERED_LIST)) break;
							o.push(t.shift())
						}
					}
					const r = (e => {
						const t = e[0],
							n = {
								type: t.getType(),
								children: []
							};
						let s, o = n,
							r = t.getDepth();
						return e.forEach(e => {
							const t = e.getType(),
								n = e.getDepth();
							if (n > r) {
								const t = de(e, s);
								o = t.list, s = t.item, r = n
							} else {
								for (; r !== n;) o = o.parentItem ? o.parentItem.parentList : o, r--;
								if (t === o.type) s = {
									block: e,
									parentList: o
								}, o.children.push(s);
								else {
									const t = de(e, o.parentItem);
									o = t.list, s = t.item
								}
							}
						}), n
					})(o);
					ue(r, e), pe(r, e), e.processed.push(...o)
				};
			var be = (e, t) => {
				const n = e.toArray().filter(e => !Object(w.t)(e.getType()));
				if (1 === n.length) {
					n[0].getType() !== w.n && n.push(new s.ContentBlock({
						key: Object(s.genKey)(),
						type: w.n
					}))
				}
				const o = s.ContentState.createFromBlockArray(n),
					r = JSON.stringify(Object(s.convertToRaw)(o));
				return "<div ".concat("data-reddit-rtjson", '="').concat(M()(r), '">').concat(t, "</div>")
			};
			const fe = () => !!window.clipboardData,
				ge = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const {
						htmlParts: s
					} = t, o = xe(e, t);
					o && o.forEach(e => s.push(n ? e.innerHTML : e.outerHTML))
				},
				xe = (e, t) => {
					const {
						selection: n,
						editor: s
					} = t, o = n.getStartKey(), r = n.getEndKey(), i = e.getKey(), a = s.refs.editor, c = Object(R.d)(i, a);
					return c ? i === o || i === r ? Object(F.c)(c) : [c] : null
				};
			var ye = (e, t, n) => {
				const o = e.getCurrentContent(),
					r = e.getSelection(),
					i = Se(e) || le(o, r);
				if (!i || !i.count()) return;
				const a = i.toArray(),
					c = {
						editor: t,
						editorState: e,
						selection: r,
						remaining: a,
						processed: [],
						htmlParts: [],
						textParts: [],
						blocksParts: [...a]
					};
				for (; c.remaining.length;) {
					const e = c.remaining[0].getType();
					switch (!0) {
						case Object(w.t)(e):
							we(c);
							break;
						case Object(w.s)(e):
							he(c);
							break;
						case Object(w.v)(e):
							oe(c);
							break;
						default:
							Ce(c)
					}
				}
				const l = c.textParts.join("\n"),
					d = (e => Object(A.OrderedMap)(e.map(e => {
						const t = Object(s.genKey)();
						return [t, e.set("key", t)]
					})))(c.blocksParts);
				return ((e, t) => {
					let {
						html: n,
						text: s
					} = t;
					fe() ? window.clipboardData.setData("text", s) : (n && e.clipboardData.setData("text/html", n), e.clipboardData.setData("text/plain", s))
				})(n, {
					html: be(d, c.htmlParts.join("")),
					text: l
				}), n.stopPropagation(), n.preventDefault(), t.setClipboard(d), d
			};
			const ve = (e, t) => {
					const n = e.getText(),
						s = t.editorState.getCurrentContent(),
						o = [];
					let r = -1;
					return e.getCharacterList().forEach((e, t) => {
						const i = e && e.getEntity();
						if (i && void 0 !== t) {
							const e = s.getEntity(i);
							e.getType() === L.a.EMOTE && (o.push(n.substring(r + 1, t)), o.push(":".concat(e.getData().id, ":")), r = t)
						}
					}), o.push(n.substring(r + 1, n.length)), o.join("")
				},
				Ce = e => {
					const t = e.remaining.shift();
					((e, t) => ge(e, t))(t, e), ((e, t) => {
						t.textParts.push(ve(e, t))
					})(t, e), e.processed.push(t)
				},
				Ee = (e, t) => {
					const n = e.first(),
						o = e.last();
					let r = e;
					if (Object(w.u)(n.getType()) ? r = r.set(r.keySeq().first(), n.merge({
							type: w.n
						})) : Object(w.o)(n.getType()) && (r = s.BlockMapBuilder.createFromArray([Object(R.h)(), ...r.toArray()])), Object(w.u)(o.getType()) || !Object(N.q)(t)) {
						const e = Object(R.h)();
						r = r.set(e.getKey(), e)
					} else if (Object(w.o)(o.getType())) {
						const e = Object(R.h)().merge({
							type: w.j
						});
						r = r.set(e.getKey(), e)
					}
					return r
				},
				Oe = (e, t, n) => {
					const s = e.getBlockForKey(t.getStartKey());
					if (Object(w.u)(s.getType())) {
						const s = n.first(),
							o = n.set(n.keySeq().first(), Object(R.h)(s.getKey(), s.getText()).merge({
								type: w.j
							}));
						return W.c(e, t, o)
					}
				},
				je = (e, t, n) => {
					const s = ((e, t, n) => {
						const s = t ? t.getText() : "";
						return '<span data-editor="'.concat(n, '">').concat(M()(s), "</span>")
					})(0, t, n.editor.getEditorKey());
					n.htmlParts.push(s)
				},
				we = e => {
					const {
						remaining: t
					} = e, n = t.shift(), s = t[0] && Object(w.u)(t[0].getType()) ? t.shift() : void 0;
					je(0, s, e), ((e, t) => {
						const n = e ? ve(e, t) : "";
						t.textParts.push(n)
					})(s, e), e.processed.push(n), s && e.processed.push(s)
				},
				Se = e => {
					const t = e.getSelection(),
						n = t.getFocusKey();
					if (n !== t.getAnchorKey()) return;
					const o = e.getCurrentContent(),
						r = o.getBlockForKey(n);
					if (Object(w.o)(r.getType())) {
						const e = [r],
							t = o.getBlockAfter(r.getKey());
						return t && Object(w.u)(t.getType()) && e.push(t), s.ContentState.createFromBlockArray(e).getBlockMap()
					}
				},
				_e = e => {
					const t = Se(e);
					if (t) return Object(N.d)(e, t.first().getKey())
				},
				ke = e => {
					const t = e.getSelection();
					let n = e.getCurrentContent();
					const o = n.getBlockForKey(t.getStartKey()),
						r = n.getBlockForKey(t.getEndKey());
					if (Object(w.t)(o.getType()) || Object(w.t)(r.getType())) {
						if (t.isCollapsed())
							if (Object(w.u)(o.getType())) n = W.d(n, t), n = s.Modifier.setBlockType(n, n.getSelectionAfter(), w.n);
							else if (Object(w.o)(o.getType())) {
							let o = n.getBlockAfter(t.getStartKey());
							return o || (o = (e = Object(N.b)(e, t.getStartKey(), R.a.after)).getCurrentContent().getBlockAfter(t.getStartKey())), s.EditorState.forceSelection(e, Object(R.b)(o, !0))
						}
						return s.EditorState.push(e, n, "split-block")
					}
				},
				Te = (e, t) => {
					const n = e.getSelection(),
						o = e.getCurrentContent(),
						r = "up" === t ? n.getStartKey() : n.getEndKey(),
						i = o.getBlockForKey(r);
					if (!Object(w.o)(i.getType())) return;
					const a = "up" === t ? o.getBlockBefore(r) : o.getBlockAfter(r);
					return a ? s.EditorState.forceSelection(e, Object(R.b)(a, !0)) : Object(N.b)(e, r, "up" === t ? R.a.before : R.a.after)
				},
				Ie = (e, t) => {
					if (e.shiftKey) return;
					const n = Te(t, "up");
					return n && e.preventDefault(), n
				},
				Pe = (e, t) => {
					if (e.shiftKey) return;
					const n = Te(t, "down");
					return n && e.preventDefault(), n
				},
				Me = (e, t) => {
					const n = e.getSelection();
					return n.isCollapsed() && 0 === n.getStartOffset() && Object(w.o)(e.getCurrentContent().getBlockForKey(n.getStartKey()).getType())
				};
			var Ne = (e, t) => {
					if (!Object(N.q)(t)) return e;
					const n = e.getSelection(),
						s = e.getCurrentContent(),
						o = s.getBlockForKey(n.getStartKey());
					if (Object(w.o)(o.getType())) {
						const t = s.getBlockAfter(o.getKey());
						if (!t || !Object(w.u)(t.getType())) return Object(N.d)(e, o.getKey(), !1)
					}
					return e
				},
				Re = n("./src/reddit/actions/modal.ts"),
				Le = n("./src/reddit/actions/upload.ts"),
				Ae = n("./src/reddit/components/ThumbnailSelector/index.tsx"),
				Fe = e => null,
				De = n("./src/reddit/helpers/media/index.ts"),
				Be = n("./src/reddit/helpers/richTextEditor/index.ts"),
				Ue = n("./src/reddit/selectors/activeModalId.ts");
			const Ke = "application/x-reddit-rte-block";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var He = n("./src/reddit/models/Upload/index.ts"),
				Ve = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/ImagePreview/index.m.less"),
				We = n.n(Ve);
			const ze = b.a.img("Img", We.a);
			var qe = b.a.wrapped(e => {
					const {
						className: t,
						url: n
					} = e;
					return c.a.createElement("div", {
						className: t
					}, c.a.createElement(ze, {
						draggable: !1,
						src: n
					}))
				}, "Component", We.a),
				Ge = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/Placeholder/index.m.less"),
				Je = n.n(Ge);
			const Qe = b.a.div("Message", Je.a);
			var Ze = b.a.wrapped(e => {
					const {
						className: t,
						isImage: n
					} = e;
					return c.a.createElement("div", {
						className: t
					}, c.a.createElement(Qe, null, n ? o.fbt._("Processing video...", null, {
						hk: "3g3QoU"
					}) : o.fbt._("Processing image...", null, {
						hk: "1xoNB3"
					})))
				}, "Component", Je.a),
				Ye = n("./src/lib/formatApiError/index.ts"),
				Xe = n("./src/reddit/components/ProgressBar/index.tsx"),
				$e = n("./src/reddit/controls/Button/index.tsx"),
				et = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/StatusBar/index.m.less"),
				tt = n.n(et);
			const nt = b.a.div("ControlRow", tt.a),
				st = b.a.wrapped($e.n, "Button", tt.a),
				ot = b.a.wrapped($e.n, "ErrButton", tt.a),
				rt = b.a.div("Status", tt.a),
				it = b.a.wrapped(Xe.a, "ProgressBar", tt.a),
				at = b.a.div("ErrorLine", tt.a),
				ct = e => t => {
					t.stopPropagation(), e(t)
				};
			var lt = b.a.wrapped(e => {
					const {
						upload: t
					} = e, n = ct(e.onCancel), s = ct(e.onRetry), r = ct(e.onRemove), {
						status: i,
						progress: a
					} = t, l = a && a.percent || 0, d = i === He.a.FAILED || i === He.a.CANCELED, u = (e => {
						const {
							status: t,
							progress: n
						} = e;
						return t === He.a.CANCELED ? o.fbt._("Upload was canceled", null, {
							hk: "71azQ"
						}) : t === He.a.FAILED ? o.fbt._("Upload failed: {errorText}", [o.fbt._param("errorText", Object(Ye.a)(e.error))], {
							hk: "3NGGzE"
						}) : 100 === (n && n.percent || 0) ? o.fbt._("Success!", null, {
							hk: "3622uh"
						}) : o.fbt._("Uploading: {fileName}", [o.fbt._param("fileName", e.file.name)], {
							hk: "H7qzO"
						})
					})(t);
					return c.a.createElement("div", {
						className: e.className
					}, d ? c.a.createElement(at, null) : c.a.createElement(it, {
						innerBarClassName: tt.a.ProgressBarInner,
						percent: l
					}), c.a.createElement(nt, null, c.a.createElement(rt, {
						className: d ? tt.a.hasError : void 0,
						title: d ? u : void 0
					}, u), c.a.createElement("div", null, d ? [c.a.createElement(ot, {
						key: "remove",
						onClick: r
					}, o.fbt._("Remove", null, {
						hk: "3LUKPE"
					})), c.a.createElement(ot, {
						key: "retry",
						onClick: s
					}, o.fbt._("Retry", null, {
						hk: "3sO2HB"
					}))] : c.a.createElement(st, {
						disabled: 100 === l,
						onClick: n
					}, o.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})))))
				}, "Component", tt.a),
				dt = n("./node_modules/react-motion/lib/react-motion.js"),
				ut = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				pt = n("./src/reddit/components/PlayButton/index.tsx"),
				mt = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/VideoPreview/index.m.less"),
				ht = n.n(mt);
			const bt = {
					stiffness: 60,
					damping: 20
				},
				ft = [{
					key: "video",
					style: {
						opacity: Object(dt.spring)(1, bt)
					}
				}],
				gt = b.a.wrapped(e => {
					const {
						autoPlay: t = !1,
						className: n,
						showControls: s,
						shouldPause: o,
						style: r,
						dashUrl: i,
						hlsUrl: a,
						otherUrl: l
					} = e;
					return c.a.createElement("div", {
						className: n,
						style: r
					}, c.a.createElement(ut.b, {
						autoPlay: t,
						shouldIgnoreAutoplayPref: !0,
						shouldLoad: !1,
						shouldPause: o,
						isGif: !1,
						hlsSource: a,
						mpegDashSource: i,
						otherSource: l,
						showSettingsIcon: !1,
						showControlBar: s,
						playerClickPlay: !1,
						hideUntilLoaded: !0
					}))
				}, "VideoPlayer", ht.a),
				xt = b.a.img("PosterImg", ht.a),
				yt = b.a.wrapped(e => {
					const {
						className: t,
						onPlayButtonClick: n,
						url: s,
						showPlayButton: o
					} = e;
					return c.a.createElement("div", {
						className: t
					}, c.a.createElement(xt, {
						draggable: !1,
						src: s
					}), o && c.a.createElement(pt.a, {
						className: ht.a.playButton,
						onClick: n
					}))
				}, "Poster", ht.a);
			class vt extends c.a.Component {
				constructor(e) {
					super(e), this.onPlayButtonClick = () => {
						this.setState({
							showVideo: !0
						})
					}, this.willEnter = () => ({
						opacity: 0
					}), this.willLeave = () => ({
						opacity: Object(dt.spring)(0, bt)
					}), this.didLeave = () => {
						this.setState({
							showVideo: !1
						})
					}, this.state = {
						showVideo: !1
					}
				}
				renderVideo() {
					const {
						props: e
					} = this;
					return c.a.createElement("div", {
						className: e.className
					}, c.a.createElement(gt, {
						dashUrl: e.dashUrl,
						hlsUrl: e.hlsUrl,
						showControls: e.isUploaded && e.isSelected,
						shouldPause: !e.isSelected || void 0
					}))
				}
				render() {
					const {
						className: e,
						isSelected: t,
						posterUrl: n,
						dashUrl: s,
						hlsUrl: o,
						otherUrl: r
					} = this.props;
					if (!n) return this.renderVideo();
					const {
						showVideo: i
					} = this.state, a = !!(s || o || r);
					return c.a.createElement(dt.TransitionMotion, {
						defaultStyles: [],
						styles: t && i && a ? ft : [],
						willEnter: this.willEnter,
						willLeave: this.willLeave,
						didLeave: this.didLeave
					}, a => c.a.createElement("div", {
						className: e
					}, a.map(e => c.a.createElement(gt, {
						key: e.key,
						autoPlay: !0,
						style: e.style,
						otherUrl: r,
						dashUrl: s,
						hlsUrl: o,
						showControls: !0,
						shouldPause: !t || void 0
					})), c.a.createElement(yt, {
						url: n,
						showPlayButton: !i || !t,
						onPlayButtonClick: this.onPlayButtonClick
					})))
				}
			}
			var Ct = b.a.wrapped(vt, "Component", ht.a),
				Et = n("./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/index.m.less"),
				Ot = n.n(Et);

			function jt() {
				return (jt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var wt = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			var St = e => {
					const {
						alignCenter: t,
						isSelected: n,
						onCancel: s,
						onRetry: o,
						onRemove: r,
						upload: i,
						mediaAsset: a,
						thumbnail: l
					} = e, d = wt(e, ["alignCenter", "isSelected", "onCancel", "onRetry", "onRemove", "upload", "mediaAsset", "thumbnail"]);
					let u = !1;
					if (i) u = "image" === Object(De.f)(i.metadata.mimetype);
					else {
						if (!a) return null;
						u = a.type === N.a.Image || a.type === N.a.AnimatedImage
					}
					const p = i ? i.metadata.height : a.height,
						h = !i || i.status === He.a.SUCCESS,
						b = u && !!p && p < 104,
						f = !p;
					return c.a.createElement("div", jt({
						className: Object(m.a)(Ot.a.container, {
							[Ot.a.alignCenter]: t,
							[Ot.a.isCompact]: b,
							[Ot.a.isUploaded]: h,
							[Ot.a.isSelected]: n
						})
					}, d), f ? c.a.createElement(Ze, {
						className: Ot.a.placeholder,
						isImage: u
					}) : u ? c.a.createElement(qe, {
						className: Ot.a.imagePreview,
						url: i ? i.metadata.localUrl : a.imageUrl
					}) : c.a.createElement(Ct, {
						className: Ot.a.videoPreview,
						dashUrl: a ? a.dashUrl : void 0,
						hlsUrl: a ? a.hlsUrl : void 0,
						isSelected: n,
						isUploaded: h,
						otherUrl: i ? i.metadata.localUrl : void 0,
						posterUrl: l ? l.url : a.posterUrl
					}), i && c.a.createElement(lt, {
						className: Ot.a.statusBar,
						onCancel: s,
						onRemove: r,
						onRetry: o,
						upload: i
					}))
				},
				_t = n("./src/reddit/components/RichTextEditor/media/MediaBlock/SelectionHook/index.m.less"),
				kt = n.n(_t);

			function Tt() {
				return (Tt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var It = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const Pt = b.a.div("HiddenDiv", kt.a);
			var Mt = e => {
					var {
						elementRef: t
					} = e, n = It(e, ["elementRef"]);
					return c.a.createElement(Pt, Tt({}, n, {
						innerRef: t
					}), c.a.createElement("br", null))
				},
				Nt = n("./src/reddit/components/MakeGifToggle/index.tsx"),
				Rt = n("./src/reddit/icons/svgs/ThumbnailSelect/index.tsx"),
				Lt = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				At = n("./src/reddit/layout/row/Inline/index.tsx"),
				Ft = n("./src/reddit/components/RichTextEditor/Toolbar/index.tsx"),
				Dt = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				Bt = n("./src/reddit/components/RichTextEditor/Toolbar/formatterConfigs.tsx"),
				Ut = n("./src/reddit/components/RichTextEditor/media/MediaBlock/Toolbar/index.m.less"),
				Kt = n.n(Ut);
			const Ht = b.a.wrapped(Dt.a, "FormatterButton", Kt.a),
				Vt = Object(Bt.f)(Lt.b),
				Wt = Object(Bt.f)(Rt.a),
				zt = b.a.wrapped(At.a, "ToolbarContent", Kt.a);
			var qt = e => {
					const {
						alignCenter: t,
						block: n,
						editorState: s,
						onChange: r,
						showVideoControls: i
					} = e, a = n.getKey(), {
						makeGif: l = !1
					} = Object(N.h)(n) || {};
					return c.a.createElement("div", {
						className: Object(m.a)(Kt.a.container, {
							[Kt.a.alignCenter]: t
						})
					}, c.a.createElement(zt, {
						className: Kt.a.content
					}, i && c.a.createElement(Nt.a, {
						isCompact: !0,
						key: "make-gif",
						on: l,
						onClick: () => r(Object(N.r)(s, a, {
							makeGif: !l
						}))
					}), i && e.showThumbnailButton && c.a.createElement(Ht, {
						Icon: Wt,
						onClick: e.onThumbnailButtonClick,
						tooltip: o.fbt._("Choose thumbnail", null, {
							hk: "2gKwDF"
						}),
						tooltipBelow: !0
					}), i && c.a.createElement(Ft.c, null), c.a.createElement(Ht, {
						Icon: Vt,
						onClick: () => r(Object(N.d)(s, a)),
						tooltip: o.fbt._("Remove", null, {
							hk: "2aF1Zw"
						}),
						tooltipBelow: !0
					})))
				},
				Gt = n("./src/reddit/components/RichTextEditor/media/MediaBlock/index.m.less"),
				Jt = n.n(Gt);
			const Qt = e => "RTE_VIDEO_THUMBNAIL_SELECTOR_".concat(e.getKey()),
				Zt = Object(d.a)(e => e.uploads, (e, t) => {
					const n = Object(N.h)(t.block);
					return n && n.uploadInfo && n.uploadInfo.uploadKey
				}, (e, t) => t ? e[t] : void 0),
				Yt = Object(l.b)((e, t) => ({
					upload: Zt(e, t),
					isThumbnailSelectorOpen: Object(Ue.a)(e) === Qt(t.block),
					isRteVideoPosterEnabled: C.d.rteVideoPoster(e)
				}), (e, t) => ({
					onCancelUpload: t => e(Le.i(t, !1)),
					toggleVideoThumbnailsSelector: () => e(Object(Re.i)(Qt(t.block)))
				})),
				Xt = b.a.div("MediaContainer", Jt.a),
				$t = b.a.div("Container", Jt.a);
			class en extends c.a.Component {
				constructor(e) {
					super(e), this.onNativeSelectionChange = () => {
						const e = window.getSelection();
						if (0 === e.rangeCount) return;
						const t = e.getRangeAt(0),
							{
								commonAncestorContainer: n
							} = t;
						this.state.active ? this.rootContainer.contains(n) || this.setState({
							active: !1
						}) : this.rootContainer && this.rootContainer.contains(n) && this.selectBlock(), this.setState({
							isInSelection: Object(F.i)(t, this.rootContainer)
						})
					}, this.selectBlock = () => {
						const e = document.createRange();
						e.selectNodeContents(this.rootContainer);
						const t = window.getSelection();
						t.removeAllRanges(), t.addRange(e), this.setState({
							active: !0
						})
					}, this.isSelected = () => {
						const e = this.props.blockProps.getEditorState().getSelection(),
							t = this.props.block.getKey();
						return this.state.active && Object(N.n)(e, t)
					}, this.onRetryUpload = () => {
						const {
							upload: e
						} = this.props;
						e && this.props.blockProps.onRetryUpload(e.key)
					}, this.onMediaViewClickCapture = e => {
						this.state.active || this.selectBlock()
					}, this.onDragStart = e => {
						e.dataTransfer.effectAllowed = "move", e.dataTransfer.setData(Ke, this.props.block.getKey())
					}, this.onRemove = () => {
						const e = this.props.blockProps.getEditorState();
						this.props.blockProps.onChange(Object(N.d)(e, this.props.block.getKey()))
					}, this.onCancelUpload = async () => {
						this.props.upload && (await this.props.onCancelUpload(this.props.upload.key), this.selectBlock())
					}, this.onToolbarStateChange = e => {
						this.props.blockProps.onChange(e)
					}, this.toggleVideoThumbnailsSelector = () => {
						this.props.toggleVideoThumbnailsSelector()
					}, this.onThumbnailSelect = e => {
						const t = this.props.blockProps.getEditorState(),
							n = this.props.block.getKey();
						let s = Object(N.r)(t, this.props.block.getKey(), {
							thumbnail: e
						});
						s = Object(N.p)(s, n), this.props.blockProps.onChange(s), this.toggleVideoThumbnailsSelector()
					}, this.state = {
						active: !1,
						isInSelection: !1
					}
				}
				shouldComponentUpdate(e, t) {
					return t.active !== this.state.active || t.isInSelection !== this.state.isInSelection || e.block !== this.props.block || e.upload !== this.props.upload || Object(N.n)(e.selection, e.block.getKey())
				}
				componentDidMount() {
					document.addEventListener("selectionchange", this.onNativeSelectionChange);
					const {
						selection: e
					} = this.props;
					e.getHasFocus() && Object(N.n)(e, this.props.block.getKey()) && this.selectBlock(), this.overlayContainer = Fe(!0)
				}
				componentWillUnmount() {
					document.removeEventListener("selectionchange", this.onNativeSelectionChange)
				}
				componentWillReceiveProps(e) {
					const t = e.block.getKey(),
						n = this.props.blockProps.getEditorState(),
						s = n;
					n !== s && this.props.blockProps.onChange(s), !this.state.active && e.selection !== this.props.selection && e.selection.getHasFocus() && Object(N.n)(e.selection, t) && this.selectBlock()
				}
				getToolbarOffset() {
					if (!this.props.blockProps.rteFocusableContentRef || !this.rootContainer) return 0;
					const {
						top: e
					} = this.rootContainer.getBoundingClientRect(), {
						top: t
					} = this.props.blockProps.rteFocusableContentRef.getBoundingClientRect();
					return e - t - 30 - 10
				}
				render() {
					const {
						block: e,
						blockProps: t,
						isRteVideoPosterEnabled: n,
						offsetKey: s,
						upload: o
					} = this.props, r = Object(N.h)(e), i = r ? r.thumbnail : void 0, a = !!o && Object(De.l)(o.metadata.mimetype || ""), {
						active: l,
						isInSelection: d
					} = this.state, u = t.editorType === Be.a.Comment;
					return c.a.createElement($t, {
						innerRef: e => this.rootContainer = e
					}, l && c.a.createElement(qt, {
						block: e,
						editorState: t.getEditorState(),
						onChange: this.onToolbarStateChange,
						onThumbnailButtonClick: this.toggleVideoThumbnailsSelector,
						showThumbnailButton: n,
						showVideoControls: a,
						alignCenter: !u
					}), c.a.createElement(Mt, null), c.a.createElement("div", {
						contentEditable: !1,
						"data-offset-key": s
					}, c.a.createElement(Xt, {
						draggable: !0,
						onDragStart: this.onDragStart,
						innerRef: e => this.mediaContainer = e
					}, c.a.createElement(St, {
						isSelected: d || l,
						thumbnail: i,
						onCancel: this.onCancelUpload,
						onClickCapture: this.onMediaViewClickCapture,
						onRetry: this.onRetryUpload,
						onRemove: this.onRemove,
						upload: o,
						mediaAsset: r.mediaAsset,
						alignCenter: !u
					})), o && a && c.a.createElement(Ae.a, {
						onSelect: this.onThumbnailSelect,
						onToggleModal: this.toggleVideoThumbnailsSelector,
						videoSource: o.metadata.localUrl,
						videoDuration: o.metadata.videoDuration,
						selected: i,
						isOpen: this.props.isThumbnailSelectorOpen
					})), c.a.createElement(Mt, null))
				}
			}
			var tn = Yt(en),
				nn = n("./src/reddit/components/RichTextEditor/media/MediaCaption/index.m.less"),
				sn = n.n(nn);
			class on extends c.a.PureComponent {
				constructor(e) {
					super(e);
					const {
						contentState: t,
						block: n
					} = Object(R.e)(e.children[0]).props;
					this.mediaBlockKey = t.getBlockBefore(n.getKey()).getKey()
				}
				render() {
					const e = this.props.children[0],
						t = Object(R.e)(e),
						{
							block: n,
							contentState: s
						} = t.props,
						r = s.getBlockForKey(this.mediaBlockKey),
						i = Object(N.h)(r);
					if (!i || !(i.mediaAsset || i.uploadInfo && i.uploadInfo.mediaType)) return null;
					const a = !n.getLength();
					return c.a.createElement("div", {
						className: sn.a.wrapper,
						style: {
							"--media-caption-placeholder-text": a ? "'".concat(o.fbt._("Add caption", null, {
								hk: "3zI8El"
							}), "'") : ""
						}
					}, e)
				}
			}
			const rn = Object(A.Map)({
				[w.j]: {
					element: "div",
					wrapper: c.a.createElement(on, null)
				}
			});
			var an = (e, t, n) => {
					const o = e.getSelection(),
						r = e.getCurrentContent(),
						i = r.getBlockForKey(o.getAnchorKey()),
						a = r.getBlockForKey(o.getFocusKey()),
						[c, l] = Object(z.e)(r, i, a);
					if (!c || c !== l) return e;
					const {
						blocks: d,
						start: u
					} = c, p = Object(z.g)(i), m = Object(z.g)(a), {
						colCount: h
					} = m;
					d.sort(z.b);
					const b = B()(d, h),
						{
							minCol: f,
							minRow: g,
							maxCol: x,
							maxRow: y
						} = Object(z.f)(p, m),
						v = {
							rowIndex: 0,
							colIndex: 0
						};
					if ("rows" === t) {
						const e = "before" === n ? g : y + 1,
							t = B()(Object(z.l)(h, y - g + 1), h);
						b.splice(e, 0, ...t), v.rowIndex = e
					} else {
						const e = "before" === n ? f : x + 1;
						b.forEach(t => {
							t.splice(e, 0, ...Object(z.l)(x - f + 1, 1))
						}), v.colIndex = e
					}
					const C = Object(z.d)(b),
						E = r.getBlocksAsArray(),
						O = K()(C),
						j = [...E.slice(0, u), ...O, ...E.slice(u + d.length)],
						w = r.merge({
							blockMap: s.BlockMapBuilder.createFromArray(j)
						}),
						S = Y()(O, e => Object(z.h)(v, Object(z.g)(e))),
						_ = Object(z.o)(o, S, S);
					let k = s.EditorState.push(e, w, J.e);
					return k = s.EditorState.forceSelection(k, _)
				},
				cn = n("./node_modules/lodash/clamp.js"),
				ln = n.n(cn),
				dn = n("./src/reddit/components/RichTextEditor/helpers/sliceContiguousBlocks.ts");
			var un = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "preserve";
				const o = e.getSelection(),
					r = e.getCurrentContent(),
					i = "up" === t || "left" === t ? o.getStartKey() : o.getEndKey(),
					a = r.getBlockForKey(i);
				if (!Object(w.v)(a.getType())) return;
				const c = Object(z.g)(a),
					{
						colCount: l,
						colIndex: d,
						rowIndex: u
					} = c,
					p = r.getBlocksAsArray(),
					m = Object(dn.a)(r, a);
				if (!m) return;
				let h = u,
					b = d;
				switch (t) {
					case "up":
						h--;
						break;
					case "down":
						h++;
						break;
					case "left":
						--b < 0 && (h--, b = l - 1);
						break;
					case "right":
						++b >= l && (h++, b = 0)
				}
				const f = {
					rowIndex: h,
					colIndex: b
				};
				let g = i;
				const x = Y()(m.blocks, e => Object(z.h)(Object(z.g)(e), f));
				if (x) g = x.getKey();
				else {
					const e = Object(z.c)(f, c) < 0 ? m.start - 1 : m.start + m.blocks.length;
					0 <= e && e < p.length && (g = p[e].getKey())
				}
				const y = r.getBlockForKey(g);
				let v = 0;
				"preserve" === n ? v = ln()(o.getFocusOffset(), 0, y.getLength()) : "end" === n && (v = y.getLength());
				const C = o.merge({
					anchorKey: g,
					focusKey: g,
					focusOffset: v,
					anchorOffset: v
				});
				return o !== C ? s.EditorState.forceSelection(e, C) : void 0
			};
			const pn = (e, t) => {
					const n = t.getCurrentContent(),
						s = t.getSelection(),
						o = n.getBlockForKey(s.getFocusKey()),
						[r] = Object(z.e)(n, o, o);
					if (!r) return;
					const i = Object(z.g)(o);
					let a;
					return (a = i.colIndex === i.colCount - 1 && i.rowIndex === r.blocks.length / i.colCount - 1 && !e.shiftKey && s.getFocusKey() === s.getAnchorKey() ? an(t, "rows", "after") : un(t, e.shiftKey ? "left" : "right", "end")) ? (e.preventDefault(), a) : void 0
				},
				mn = (e, t) => {
					if (e.shiftKey) return;
					const n = un(t, "up");
					return n && e.preventDefault(), n
				},
				hn = (e, t) => {
					if (e.shiftKey) return;
					const n = un(t, "down");
					return n && e.preventDefault(), n
				};
			class bn {
				constructor() {
					this.lastRowInsertionState = null
				}
				undoRowInsertion(e) {
					const t = s.EditorState.undo(e);
					return un(t, "down", "end") || t
				}
				isSelectionInLastRow(e) {
					const t = e.getCurrentContent(),
						n = e.getSelection(),
						s = t.getBlockForKey(n.getFocusKey()),
						[o] = Object(z.e)(t, s, s);
					if (!o) return !1;
					const r = Object(z.g)(o.blocks[0]).colCount,
						i = o.blocks.length / r;
					return Object(z.g)(s).rowIndex === i - 1
				}
				insertNewRow(e) {
					const t = e.getSelection();
					let n = an(e, "rows", "after");
					return n = s.EditorState.forceSelection(n, t), n = un(n, "down") || n, this.lastRowInsertionState = n, n
				}
				handle(e) {
					return e.getSelection().isCollapsed() ? e === this.lastRowInsertionState ? this.undoRowInsertion(e) : this.isSelectionInLastRow(e) ? this.insertNewRow(e) : un(e, "down") || e : e
				}
			}
			const fn = (e, t) => {
				const n = e.getSelection();
				if (n.isCollapsed() || n.getStartKey() === n.getEndKey()) return;
				const o = e.getCurrentContent(),
					r = o.getBlockForKey(n.getAnchorKey()),
					i = o.getBlockForKey(n.getFocusKey()),
					[a, c] = Object(z.e)(o, r, i);
				if (a && a === c) {
					const r = Object(z.o)(n, i, i, !1),
						a = W.b(o, r, t);
					return s.EditorState.push(e, a, J.d)
				}
			};
			var gn = n("./node_modules/lodash/forEach.js"),
				xn = n.n(gn);
			const yn = (e, t) => t ? e[0] : e[e.length - 1];
			var vn = (e, t) => {
					return e.getSelection().isCollapsed() ? ((e, t) => {
						const n = e.getSelection(),
							o = t.getSelection();
						if (!n.isCollapsed() || o.isCollapsed() || 0 !== o.getStartOffset() || o.getStartKey() !== n.getStartKey()) return e;
						const r = e.getCurrentContent(),
							i = t.getCurrentContent(),
							a = r.getBlockForKey(n.getAnchorKey());
						if (!Object(w.v)(a.getType())) return e;
						const {
							rowIndex: c,
							colIndex: l
						} = Object(z.g)(a);
						if (0 !== c || 0 !== l) return e;
						const d = r.getBlockMap(),
							u = i.getBlockMap();
						if (d.size >= u.size) return e;
						const p = r.getBlockAfter(n.getAnchorKey()),
							m = i.getBlockAfter(o.getEndKey());
						if (p && p !== m) return e;
						const h = a.merge({
								type: w.n,
								data: Object(A.Map)({})
							}),
							b = r.merge({
								blockMap: d.set(a.getKey(), h)
							});
						return s.EditorState.set(e, {
							currentContent: b
						})
					})(e, t) : ((e, t) => {
						const n = e.getSelection();
						if (n.isCollapsed()) return e;
						if (t.getSelection() === n) return e;
						if (n.getFocusKey() === n.getAnchorKey()) return e;
						const o = e.getCurrentContent(),
							r = o.getBlockForKey(n.getAnchorKey()),
							i = o.getBlockForKey(n.getFocusKey()),
							[a, c] = Object(z.e)(o, r, i);
						if (!a && !c) return e;
						let l = e;
						if (a !== c) {
							const t = n.getIsBackward(),
								o = Object(z.o)(n, a ? yn(a.blocks, !t) : null, c ? yn(c.blocks, t) : null, t);
							n !== o && (l = s.EditorState.forceSelection(e, o))
						} else if (a && c && a === c) {
							const t = Object(z.g)(r),
								a = Object(z.g)(i),
								d = o.getBlocksAsArray(),
								{
									start: u,
									blocks: p
								} = c,
								m = p[0],
								h = Object(z.g)(m);
							if (0 !== h.colIndex || 0 !== h.rowIndex) throw new Error("First table block must always has [0, 0] coordinate!");
							const b = Object(z.b)(i, r) < 0,
								f = Object(z.k)(t, a),
								g = [],
								x = [];
							xn()(p, e => {
								const t = Object(z.g)(e);
								f(t.rowIndex, t.colIndex) ? g.push(e) : e !== m && x.push(e)
							});
							const y = g[0] === m;
							g.sort(z.b);
							const v = [...d.slice(0, u), ...y ? [] : [m], ...g, ...x, ...d.slice(u + p.length)],
								C = yn(g, !b),
								E = yn(g, b),
								O = Object(z.o)(n, C, E, b),
								j = o.merge({
									blockMap: s.BlockMapBuilder.createFromArray(v),
									selectionAfter: O
								});
							l = s.EditorState.set(e, {
								currentContent: j
							}), O !== n && (l = s.EditorState.forceSelection(l, O))
						}
						return l
					})(e, t)
				},
				Cn = (n("./node_modules/core-js/modules/es6.regexp.to-string.js"), n("./src/reddit/components/RichTextEditor/table/Renderer/index.m.less")),
				En = n.n(Cn);
			const On = b.a.div("Cell", En.a),
				jn = b.a.div("Row", En.a),
				wn = b.a.div("Table", En.a),
				Sn = (e, t) => {
					if (!t || !e.contains(t)) return;
					let n = t;
					for (; n && n !== e;) {
						if (n instanceof HTMLElement && n.hasAttribute("data-row")) return n;
						n.parentElement && (n = n.parentElement)
					}
				},
				_n = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
						n = e,
						s = t;
					for (; n && s > 0;) {
						if (n instanceof HTMLElement && n.dataset.table) return n;
						n.parentElement && (n = n.parentElement), s--
					}
				},
				kn = e => {
					const {
						dataset: t
					} = e;
					if ("string" == typeof t.row && "string" == typeof t.col) return {
						rowIndex: +t.row,
						colIndex: +t.col
					}
				},
				Tn = e => {
					const t = window.getSelection(),
						{
							focusNode: n,
							anchorNode: s,
							rangeCount: o
						} = t;
					if (n !== s && o && e) {
						const n = t.getRangeAt(0);
						return Object(F.i)(n, e) && !e.contains(n.commonAncestorContainer)
					}
					return !1
				},
				In = e => {
					const t = c.a.Children.toArray(e),
						n = Object(R.e)(t[0]),
						{
							selection: s,
							contentState: o,
							block: r
						} = n.props,
						{
							colCount: i
						} = Object(z.g)(r);
					t.sort((e, t) => Object(z.b)(Object(R.c)(e), Object(R.c)(t)));
					const a = B()(t, i);
					let l, d, u = !1;
					if (s.getAnchorKey() !== s.getFocusKey()) {
						const e = o.getBlocksAsArray(),
							n = o.getBlockForKey(s.getStartKey()),
							i = o.getBlockForKey(s.getEndKey()),
							a = e.indexOf(n),
							c = e.indexOf(i),
							p = e.indexOf(r),
							m = p + t.length - 1;
						a < p && p < c || a < m && m < c ? u = !0 : p <= a && c <= m && (d = Object(z.g)(s.getIsBackward() ? i : n), l = Object(z.g)(s.getIsBackward() ? n : i))
					}
					return {
						rows: a,
						anchorCell: d,
						focusCell: l,
						isSelectWholeTable: u
					}
				};
			class Pn extends c.a.Component {
				constructor(e) {
					super(e), this.tableElem = null, this.onMouseDown = e => {
						if (!this.tableElem || e.nativeEvent.detail < 2) return;
						const t = window.getSelection(),
							n = t.rangeCount ? t.getRangeAt(0) : null,
							s = Sn(this.tableElem, t.focusNode);
						if (n && s)
							if (2 === e.nativeEvent.detail && t.isCollapsed) {
								const o = n.cloneRange();
								o.setEndAfter(s), o.toString() || (e.preventDefault(), t.selectAllChildren(s))
							} else e.nativeEvent.detail >= 3 && (t.selectAllChildren(s), e.preventDefault())
					}, this.onNativeSelectionChange = () => {
						const e = this.tableElem;
						if (!e) return;
						const t = window.getSelection();
						if (t.anchorNode === t.focusNode) return void this.resetSelection();
						const n = Sn(e, t.anchorNode),
							s = Sn(e, t.focusNode);
						n && n === s ? this.resetSelection() : n && s ? this.setCellsRange(n, s) : n || s ? this.selectWholeTable() : Tn(e) ? this.selectWholeTable() : this.resetSelection()
					}, this.resetSelection = () => {
						(this.state.anchorCell || this.state.focusCell || this.state.isSelectWholeTable) && this.setState({
							isSelectWholeTable: !1,
							focusCell: void 0,
							anchorCell: void 0
						})
					}, this.setCellsRange = (e, t) => {
						const n = kn(t),
							s = kn(e);
						Object(z.h)(n, this.state.focusCell) && Object(z.h)(s, this.state.anchorCell) && !this.state.isSelectWholeTable || this.setState({
							focusCell: n,
							anchorCell: s,
							isSelectWholeTable: !1
						})
					}, this.selectWholeTable = () => {
						!this.state.focusCell && this.state.isSelectWholeTable || this.setState({
							focusCell: void 0,
							isSelectWholeTable: !0
						})
					}, this.state = In(e.children)
				}
				componentDidMount() {
					document.addEventListener("selectionchange", this.onNativeSelectionChange)
				}
				componentWillUnmount() {
					document.removeEventListener("selectionchange", this.onNativeSelectionChange)
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.children !== this.props.children && this.setState(In(e.children))
				}
				render() {
					const {
						rows: e,
						anchorCell: t,
						focusCell: n,
						isSelectWholeTable: s
					} = this.state;
					let o;
					s ? o = (e, t) => !0 : t && n && !Object(z.h)(t, n) && (o = Object(z.k)(t, n));
					const r = e[0].map(e => Object(z.g)(Object(R.e)(e).props.block).alignment),
						i = e.map((e, t) => c.a.createElement(jn, {
							key: t
						}, e.map((e, n) => c.a.createElement(On, {
							"data-row": t,
							"data-col": n,
							"data-selected": !!o && o(t, n),
							key: n,
							style: {
								"--cell-text-alignment": r[n] ? z.a[r[n]] : void 0
							}
						}, e))));
					return c.a.createElement(wn, {
						className: o ? En.a.isFakeSelectionActive : void 0,
						innerRef: e => this.tableElem = e,
						onMouseDown: this.onMouseDown,
						"data-table": !0
					}, i)
				}
			}
			const Mn = Object(A.Map)({
				[w.l]: {
					element: "div",
					wrapper: c.a.createElement(Pn, null)
				}
			});
			var Nn = n("./node_modules/lodash/isEqual.js"),
				Rn = n.n(Nn),
				Ln = n("./src/reddit/components/RichTextEditor/Tooltip/index.tsx"),
				An = n("./src/reddit/icons/svgs/FormattingAlignCenter/index.tsx"),
				Fn = n("./src/reddit/icons/svgs/FormattingAlignLeft/index.tsx"),
				Dn = n("./src/reddit/icons/svgs/FormattingAlignRight/index.tsx"),
				Bn = n("./src/reddit/icons/svgs/FormattingDeleteRow/index.tsx"),
				Un = n("./src/reddit/icons/svgs/FormattingInsertRow/index.tsx"),
				Kn = n("./src/reddit/models/RichTextJson/index.ts");
			var Hn = function(e) {
				arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				const t = e.getSelection(),
					n = e.getCurrentContent(),
					o = n.getBlockForKey(t.getAnchorKey()),
					r = n.getBlockForKey(t.getFocusKey()),
					[i, a] = Object(z.e)(n, o, r);
				if (i && i === a) {
					const {
						blocks: n
					} = i;
					n.sort(z.b);
					const o = Object(z.o)(t, n[0], G()(n));
					return X(s.EditorState.set(e, {
						selection: o
					}), "rows")
				}
			};
			var Vn = (e, t) => {
					const n = e.getSelection(),
						o = e.getCurrentContent(),
						r = o.getBlockForKey(n.getAnchorKey()),
						i = o.getBlockForKey(n.getFocusKey()),
						[a, c] = Object(z.e)(o, r, i);
					if (!a || a !== c) return e;
					const l = Object(z.g)(r),
						d = Object(z.g)(i),
						{
							minCol: u,
							maxCol: p
						} = Object(z.f)(l, d),
						m = a.blocks.map(e => {
							const {
								colIndex: n
							} = Object(z.g)(e);
							return u <= n && n <= p ? Object(z.m)(e, {
								alignment: t
							}) : e
						}),
						h = o.getBlockMap(),
						b = o.merge({
							blockMap: h.merge(s.BlockMapBuilder.createFromArray(m)),
							selectionAfter: n,
							selectionBefore: n
						});
					return s.EditorState.push(e, b, J.b)
				},
				Wn = n("./src/reddit/components/RichTextEditor/table/Toolbar/index.m.less"),
				zn = n.n(Wn);

			function qn() {
				return (qn = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Gn = (e, t) => n => c.a.createElement(e, qn({}, t, n)),
				Jn = Object(Bt.f)(Un.a),
				Qn = Gn(Jn, {
					orientation: "up"
				}),
				Zn = Gn(Jn, {
					orientation: "right"
				}),
				Yn = Gn(Jn, {
					orientation: "left"
				}),
				Xn = Object(Bt.f)(Bn.a),
				$n = Gn(Xn, {
					orientation: "vertical"
				}),
				es = Object(Bt.f)(An.a),
				ts = Object(Bt.f)(Fn.a),
				ns = Object(Bt.f)(Dn.a),
				ss = Object(Bt.f)(Lt.b),
				os = b.a.wrapped(At.a, "ToolbarContent", zn.a),
				rs = e => c.a.createElement(Dt.a, qn({}, e, {
					className: Object(m.a)(zn.a.formatterButton, e.className),
					tooltipContentClass: zn.a.tooltip
				}));
			var is = e => {
					const {
						editorState: t,
						onChange: n
					} = e;
					return c.a.createElement(os, null, c.a.createElement(rs, {
						Icon: ts,
						onClick: () => n(Vn(t, Kn.e)),
						tooltip: o.fbt._("Left align", null, {
							hk: "45eAc"
						})
					}), c.a.createElement(rs, {
						Icon: es,
						onClick: () => n(Vn(t, Kn.d)),
						tooltip: o.fbt._("Center align", null, {
							hk: "4aAfyf"
						})
					}), c.a.createElement(rs, {
						Icon: ns,
						onClick: () => n(Vn(t, Kn.f)),
						tooltip: o.fbt._("Right align", null, {
							hk: "3oHuXw"
						})
					}), c.a.createElement(Ft.c, null), c.a.createElement(rs, {
						Icon: Yn,
						onClick: () => n(an(t, "columns", "before")),
						tooltip: o.fbt._("Insert column before", null, {
							hk: "11EB6Q"
						})
					}), c.a.createElement(rs, {
						Icon: Zn,
						onClick: () => n(an(t, "columns", "after")),
						tooltip: o.fbt._("Insert column after", null, {
							hk: "Ddlpl"
						})
					}), c.a.createElement(rs, {
						Icon: $n,
						onClick: () => n(X(t, "columns")),
						tooltip: o.fbt._("Delete column", null, {
							hk: "3HaQQD"
						})
					}), c.a.createElement(Ft.c, null), c.a.createElement(rs, {
						Icon: Qn,
						onClick: () => n(an(t, "rows", "before")),
						tooltip: o.fbt._("Insert row above", null, {
							hk: "1HIgn"
						})
					}), c.a.createElement(rs, {
						Icon: Jn,
						onClick: () => n(an(t, "rows", "after")),
						tooltip: o.fbt._("Insert row below", null, {
							hk: "3t7ZU"
						})
					}), c.a.createElement(rs, {
						Icon: Xn,
						onClick: () => n(X(t, "rows")),
						tooltip: o.fbt._("Delete row", null, {
							hk: "3yJYqS"
						})
					}), c.a.createElement(Ft.c, null), c.a.createElement(rs, {
						Icon: ss,
						onClick: () => n(Hn(t) || t),
						tooltip: o.fbt._("Delete table", null, {
							hk: "1fK0KA"
						})
					}))
				},
				as = n("./src/reddit/components/RichTextEditor/table/ToolbarController/index.m.less"),
				cs = n.n(as);
			const ls = 20,
				ds = b.a.div("ActionButton", cs.a),
				us = b.a.div("ToolbarWrapper", cs.a),
				ps = e => {
					const t = {};
					if (!e || !document.documentElement) return t;
					const n = e.left - 154.5,
						s = e.left + 154.5 - document.documentElement.clientWidth;
					return n < 0 ? t.left = -n + ls + 2 : s > 0 && (t.left = -s + ls - 2), t
				},
				ms = e => {
					e.preventDefault(), e.stopPropagation()
				};
			class hs extends a.Component {
				constructor(e) {
					super(e), this.containerElem = null, this.setContainerRef = e => this.containerElem = e, this.onResize = e => {
						this.hideToolbar(), this.state.tooltipPosition && this.updateForCurrentSelection()
					}, this.onDocumentClick = e => {
						this.state.isToolbarActive && this.containerElem && (this.containerElem.contains(e.target) || this.hideToolbar())
					}, this.onNativeSelectionChange = () => {
						this.updateForCurrentSelection()
					}, this.updateForCurrentSelection = () => {
						const e = window.getSelection();
						if (!e.rangeCount) return void this.hideActionButton();
						const t = e.getRangeAt(0).commonAncestorContainer,
							{
								rteDomRef: n
							} = this.props;
						if (!n.contains(t)) return void this.hideActionButton();
						const s = _n(t);
						if (!s) return void this.hideActionButton();
						const o = Sn(s, e.anchorNode);
						if (!o) return void this.hideActionButton();
						const r = Sn(s, e.focusNode);
						r ? this.updateActionButtonPosition(o, r) : this.hideActionButton()
					}, this.updateActionButtonPosition = (e, t) => {
						const n = e.getBoundingClientRect(),
							s = t.getBoundingClientRect(),
							o = {
								top: Math.min(n.top, s.top),
								left: Math.max(n.right, s.right) - ls
							};
						Rn()(this.state.tooltipPosition, o) || this.setState({
							tooltipPosition: o
						}), this.hideToolbar()
					}, this.hideActionButton = () => {
						this.hideToolbar(), this.state.tooltipPosition && this.setState({
							tooltipPosition: null
						})
					}, this.hideToolbar = () => {
						this.state.isToolbarActive && this.setState({
							isToolbarActive: !1
						})
					}, this.onActionButtonClick = e => {
						this.setState(e => ({
							isToolbarActive: !e.isToolbarActive
						})), ms(e)
					}, this.state = {
						isToolbarActive: !1,
						tooltipPosition: null
					}, this.api = {
						hideActionButton: this.hideActionButton
					}
				}
				componentDidMount() {
					const {
						onSetApi: e
					} = this.props;
					document.addEventListener("selectionchange", this.onNativeSelectionChange), document.addEventListener("click", this.onDocumentClick), window.addEventListener("resize", this.onResize), e && e(this.api)
				}
				componentWillUnmount() {
					const {
						onSetApi: e
					} = this.props;
					document.removeEventListener("selectionchange", this.onNativeSelectionChange), document.removeEventListener("click", this.onDocumentClick), window.removeEventListener("resize", this.onResize), e && e(null)
				}
				UNSAFE_componentWillReceiveProps(e) {
					const t = e.editorState.getSelection(),
						n = this.props.editorState.getSelection();
					t.getHasFocus() && Object(w.v)(s.RichUtils.getCurrentBlockType(e.editorState)) ? t !== n && this.hideToolbar() : this.hideActionButton()
				}
				render() {
					const e = !this.props.readOnly && this.state.isToolbarActive,
						{
							tooltipPosition: t
						} = this.state;
					return c.a.createElement("div", {
						ref: this.setContainerRef
					}, c.a.createElement(Ln.b, {
						targetPosition: t
					}, c.a.createElement(ds, {
						className: e ? cs.a.isPressed : void 0,
						onClick: this.onActionButtonClick,
						onMouseDown: ms,
						onMouseMove: ms
					}, e ? c.a.createElement(us, {
						style: ps(t)
					}, c.a.createElement(is, {
						onChange: this.props.onChange,
						editorState: this.props.editorState
					})) : null)))
				}
			}
			var bs = n("./src/reddit/components/RichTextEditor/editorStateTransforms.ts");

			function fs() {
				return (fs = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function gs() {
				return new Map
			}
			const xs = c.a.createContext(gs());

			function ys(e) {
				class t extends c.a.Component {
					constructor() {
						super(...arguments), this.elementRef = null, this.updateElementRef = e => {
							const {
								registry: t
							} = this.props;
							this.elementRef = e, e ? t.set(this.props.entityKey, e) : t.delete(this.props.entityKey)
						}
					}
					componentWillReceiveProps(e) {
						const {
							registry: t
						} = this.props;
						this.props.entityKey !== e.entityKey && this.elementRef && (t.get(this.props.entityKey) === this.elementRef && t.delete(this.props.entityKey), t.set(e.entityKey, this.elementRef))
					}
					render() {
						return c.a.createElement("span", {
							ref: this.updateElementRef
						}, c.a.createElement(e, this.props))
					}
				}
				return e => c.a.createElement(xs.Consumer, null, n => c.a.createElement(t, fs({}, e, {
					registry: n
				})))
			}
			var vs = n("./src/reddit/components/RichTextEditor/emotes/helpers.ts"),
				Cs = n("./src/reddit/components/RichTextEditor/emotes/decorator.m.less"),
				Es = n.n(Cs);
			const Os = {
					strategy: vs.e,
					component: ys(e => {
						const {
							contentState: t
						} = e, n = Object(vs.i)(t), s = t.getEntity(e.entityKey), {
							id: o,
							emoji: r,
							sticker: i
						} = s.getData(), a = n ? i : r;
						return c.a.createElement("span", {
							className: Object(m.a)(Es.a.emote, {
								[Es.a.sticker]: n
							}),
							title: ":".concat(o, ":"),
							style: {
								backgroundImage: "url(".concat(a.path, ")"),
								height: a.y,
								width: a.x
							}
						}, e.children)
					})
				},
				js = () => Os;
			var ws = n("./src/higherOrderComponents/makeAsync.tsx"),
				Ss = Object(ws.a)({
					ErrorComponent: () => null,
					LoadingComponent: () => null,
					getComponent: () => n.e("EmotesTooltip").then(n.bind(null, "./src/reddit/components/RichTextEditor/emotes/tooltip.tsx")).then(e => e.default)
				});
			const _s = new Set([L.a.LINK]);
			var ks = n("./src/reddit/components/RichTextEditor/entity/link/helpers.tsx"),
				Ts = n("./src/reddit/components/RichTextEditor/entity/link/decorator.m.less"),
				Is = n.n(Ts);
			const Ps = b.a.a("RegularLink", Is.a),
				Ms = {
					strategy: ks.a,
					component: ys(e => {
						const t = e.contentState.getEntity(e.entityKey),
							{
								url: n
							} = t.getData();
						return c.a.createElement(Ps, {
							href: n
						}, e.children)
					})
				},
				Ns = () => Ms;
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var Rs = n("./src/lib/linkMatchers/index.ts");
			const Ls = (e, t) => {
					if (t.getType() === w.f) return [];
					return (e.match(t.getText()) || []).filter(e => ((e, t) => {
						let {
							index: n,
							lastIndex: s
						} = t;
						for (let o = n; o < s; o++) {
							if (e.getInlineStyleAt(o).contains(w.k.MONOSPACE)) return !1
						}
						return !0
					})(t, e))
				},
				As = (e, t, n, o, r, i) => {
					const a = e.getBlockForKey(t),
						c = s.SelectionState.createEmpty(t),
						l = [],
						d = new Set;
					let u = e;
					const p = n === L.a.USER_MENTION ? L.a.USER_LINK : n,
						m = (e, t, s) => {
							let o = null;
							for (let r = e; r < t; r++) {
								const e = a.getEntityAt(r),
									t = e && u.getEntity(e);
								if (t) {
									if (t.getType() !== n) return;
									o || d.has(e) || (o = e)
								}
							}
							if (o) {
								u.getEntity(o).getData().url !== s && (u = u.mergeEntityData(o, {
									url: s
								}))
							}
							return o || (e => (u = u.createEntity(p, "MUTABLE", {
								url: e
							})).getLastCreatedEntityKey())(s)
						},
						h = (e, t, n) => {
							const o = c.merge({
								anchorOffset: e,
								focusOffset: t
							});
							u = s.Modifier.applyEntity(u, o, n)
						},
						b = (e, t) => h(e, t, null),
						g = u.getBlockForKey(t);
					Ls(o, g).forEach((e, o) => {
						let {
							index: a,
							lastIndex: p,
							url: b
						} = e;
						const g = m(a, p, b);
						g && (n === L.a.USER_MENTION ? (((e, n, o) => {
							const a = u && u.getBlockForKey(t),
								l = a && a.getText().substr(e, n);
							if (l && l.replace(f.d.mention, "") && l.startsWith(f.d.mention) && f.c.test(l.replace(f.d.mention, ""))) {
								const t = c.merge({
										anchorOffset: e,
										focusOffset: e + f.d.mention.length
									}),
									a = c.merge({
										anchorOffset: e,
										focusOffset: n + f.d.mention.length
									}),
									l = c.merge({
										anchorOffset: n + f.d.mention.length,
										focusOffset: n + f.d.mention.length
									});
								u = Object(W.b)(u, t, f.d.profile), u = s.Modifier.applyEntity(u, a, o), r && i && i(s.EditorState.forceSelection(r, l))
							}
						})(a + o, p + o, g), l.push([a + o, p + o + 1])) : (h(a, p, g), l.push([a, p])), d.add(g))
					});
					let x = 0;
					return g.findEntityRanges(e => {
						const t = e.getEntity();
						return !!t && u.getEntity(t).getType() === n
					}, (e, t) => {
						if (x >= l.length) return void b(e, t);
						const [n, s] = l[x];
						t <= n ? b(e, t) : (e < n && b(e, n - 1), t > s && b(s, t), x++)
					}), u
				},
				Fs = (e, t) => {
					const n = e.getCurrentContent(),
						o = t.getCurrentContent();
					if (n === o) return e;
					const r = n.getBlockMap(),
						i = o.getBlockMap();
					let a = n;
					return r.forEach((t, n) => {
						if (n) {
							if (t === i.get(n)) return;
							a = As(a, n, L.a.SUBREDDIT_LINK, Rs.f), a = As(a, n, L.a.USER_LINK, Rs.i), a = As(a, n, L.a.USER_MENTION, Rs.d, e, t => e = t)
						}
					}), e.getCurrentContent() === a ? e : (a = a.merge({
						selectionAfter: e.getCurrentContent().getSelectionAfter(),
						selectionBefore: e.getCurrentContent().getSelectionBefore()
					}), s.EditorState.set(e, {
						currentContent: a
					}))
				};
			var Ds = e => {
				return !!e.getCurrentContent().getBlockMap().filter(e => !!e && e.getType() === w.a).size
			};
			n("./node_modules/core-js/modules/es6.regexp.constructor.js");
			const Bs = " ".repeat(4),
				Us = new RegExp("^ {1,".concat(4, "}|\\t")),
				Ks = new Set([w.b.CODE_BLOCK]),
				Hs = (e, t) => {
					const n = t.getCurrentContent(),
						o = t.getSelection(),
						r = e.shiftKey;
					let i = n,
						a = o.getAnchorOffset(),
						c = o.getFocusOffset();
					if (Object(Q.a)(n, o, (e, t) => {
							const n = e.getType();
							if ("paragraph" === n || !Ks.has(n)) return !1;
							let l = null;
							const d = e.getText(),
								u = s.SelectionState.createEmpty(t);
							if (r) {
								const e = d.match(Us);
								if (e) {
									const t = e[0].length;
									i = W.b(i, u.merge({
										focusOffset: t
									}), ""), l = -t
								}
							} else i = W.a(i, o.isCollapsed() ? o : u, Bs), l = 4;
							null !== l && (t === o.getAnchorKey() && (a += l), t === o.getFocusKey() && (c += l))
						}), i !== n) return i = i.merge({
						selectionAfter: o.merge({
							anchorOffset: a,
							focusOffset: c
						})
					}), e.preventDefault(), s.EditorState.push(t, i, r ? "remove-range" : "insert-characters")
				},
				Vs = (e, t) => (e => {
					const t = e.getSelection(),
						n = e.getCurrentContent();
					if (!t.isCollapsed()) return $(e);
					if (0 === t.getStartOffset()) {
						const s = n.getBlockForKey(t.getEndKey());
						if (Object(w.v)(s.getType())) return e; {
							const t = n.getBlockBefore(s.getKey());
							if (t && Object(w.v)(t.getType())) return e
						}
					}
				})(e) || ((e, t) => {
					const n = e.getSelection(),
						o = e.getCurrentContent();
					if (n.isCollapsed() && 0 === n.getStartOffset()) {
						const r = o.getBlockForKey(n.getEndKey());
						if (Object(w.o)(r.getType())) return Object(N.d)(e, r.getKey());
						if (Object(w.u)(r.getType())) {
							const t = o.getBlockBefore(r.getKey());
							return s.EditorState.forceSelection(e, Object(R.b)(t))
						}
						if (!Object(N.q)(t) && Object(R.g)(r)) {
							const t = o.getBlockBefore(r.getKey());
							if (t && Object(w.o)(t.getType())) return e = s.EditorState.push(e, Object(R.i)(o, r.getKey()), J.f), s.EditorState.forceSelection(e, Object(R.b)(t))
						}
					}
				})(e, t),
				Ws = (e, t) => (e => {
					const t = e.getSelection(),
						n = e.getCurrentContent();
					if (!t.isCollapsed()) return $(e); {
						const s = n.getBlockForKey(t.getEndKey());
						if (t.getEndOffset() === s.getLength()) {
							if (Object(w.v)(s.getType())) return e; {
								const t = n.getBlockAfter(s.getKey());
								if (t && Object(w.v)(t.getType())) return e
							}
						}
					}
				})(e) || ((e, t) => {
					const n = e.getSelection(),
						o = e.getCurrentContent();
					if (!n.isCollapsed()) return;
					const r = o.getBlockForKey(n.getEndKey());
					if (n.getEndOffset() === r.getLength()) {
						if (Object(w.o)(r.getType())) return Object(N.d)(e, r.getKey()); {
							const i = o.getBlockAfter(n.getEndKey());
							if (i && Object(w.o)(i.getType())) {
								if (Object(N.q)(t)) return Object(N.d)(e, i.getKey());
								if (Object(R.g)(r)) return e = s.EditorState.push(e, Object(R.i)(o, r.getKey()), J.f), s.EditorState.forceSelection(e, Object(R.b)(i))
							}
						}
					}
				})(e, t),
				zs = e => {
					const t = e.getSelection();
					if (!t.isCollapsed()) return !1;
					const n = s.RichUtils.getCurrentBlockType(e);
					if (!w.c.includes(n)) return !1;
					if (t.getFocusOffset() > 0) {
						if ("\n" === e.getCurrentContent().getBlockForKey(t.getFocusKey()).getText()[t.getFocusOffset() - 1]) return !1
					}
					return !0
				};
			var qs = n("./src/lib/memoizeByReference/index.ts");
			const Gs = Object(qs.a)(e => {
					const t = e.getSelection();
					if (!t.isCollapsed()) return;
					const n = t.getStartOffset(),
						s = e.getCurrentContent(),
						o = s.getBlockForKey(t.getFocusKey());
					if (o.getType() !== w.n) return;
					const r = o.getText();
					if (r.startsWith("1.") && 2 === n) return w.i.ORDERED;
					if (r.startsWith("*") && 1 === n) {
						const e = s.getBlockBefore(o.getKey());
						if (e && e.getType() === w.n && e.getText().startsWith("* ")) return;
						return w.i.UNORDERED
					}
				}),
				Js = e => {
					const t = Gs(e);
					if (!t) return e;
					const n = Object(bs.a)(e);
					let o = s.Modifier.replaceText(n.getCurrentContent(), n.getSelection().merge({
						anchorOffset: 0
					}), "");
					return o = s.Modifier.setBlockType(o, o.getSelectionAfter(), t), s.EditorState.push(n, o, J.c)
				};
			var Qs = n("./src/reddit/components/RichTextEditor/helpers/styles.ts");
			const Zs = Object(ws.a)({
				ErrorComponent: () => null,
				LoadingComponent: () => null,
				getComponent: () => n.e("GifTooltip").then(n.bind(null, "./src/reddit/components/RichTextEditor/media/GifTooltip/index.tsx")).then(e => e.default)
			});

			function Ys(e) {
				return c.a.createElement(Zs, e)
			}
			var Xs = n("./src/reddit/components/RichTextEditor/spoiler/helpers.ts"),
				$s = n("./src/reddit/components/RichTextEditor/spoiler/decorator.m.less"),
				eo = n.n($s);
			const to = e => c.a.createElement("span", {
					className: eo.a.spoiler
				}, c.a.createElement("span", null), e.children, c.a.createElement("span", null)),
				no = () => ({
					strategy: Xs.a,
					component: to
				});
			var so = n("./src/reddit/components/FocusableContent/index.tsx"),
				oo = n("./src/reddit/components/RichTextEditor/Blockquote/index.m.less"),
				ro = n.n(oo);
			const io = b.a.div("BlockQuoteWrapper", ro.a),
				ao = Object(A.Map)({
					[w.e]: {
						element: "blockquote",
						wrapper: c.a.createElement(io, null)
					}
				});
			var co = n("./src/reddit/components/RichTextEditor/CodeBlock/index.m.less"),
				lo = n.n(co);
			const uo = b.a.div("CodeBlockWrapper", lo.a),
				po = Object(A.Map)({
					[w.f]: {
						element: "code",
						wrapper: c.a.createElement(uo, null)
					}
				});
			var mo = n("./node_modules/bowser/src/bowser.js"),
				ho = n.n(mo),
				bo = n("./node_modules/lodash/includes.js"),
				fo = n.n(bo),
				go = n("./src/reddit/components/RichTextEditor/DragController/helpers.ts"),
				xo = n("./src/reddit/components/RichTextEditor/DragController/index.m.less"),
				yo = n.n(xo);
			const vo = b.a.div("DropLine", yo.a),
				Co = b.a.wrapped(Ln.b, "Tooltip", yo.a);
			class Eo extends a.Component {
				constructor(e) {
					super(e), this.dragCount = 0, this.setContainerRef = e => this.containerRef = e, this.preventDocumentDrop = e => {
						!! function e(t) {
							return t.draggable ? t : t.parentElement ? e(t.parentElement) : null
						}(e.target) || (e.preventDefault(), e.stopPropagation())
					}, this.onDragOver = e => {
						const t = fo()(e.dataTransfer.types, Ke);
						if (!t) {
							if (!Object(go.c)(e.dataTransfer) || !this.props.allowMediaUploads) return
						}
						if (!t && !Object(go.c)(e.dataTransfer)) return;
						e.preventDefault();
						try {
							e.dataTransfer.dropEffect = t ? "move" : "copy"
						} catch (r) {}
						const {
							editorState: n
						} = this.props;
						let s = null;
						const o = Object(go.b)(n, e);
						if (o) {
							const e = this.containerRef.getBoundingClientRect().left;
							s = {
								top: o.clientY,
								left: e
							}
						}
						Rn()(s, this.state.point) || this.setState({
							point: s
						})
					}, this.onDragEnter = e => {
						this.dragCount++
					}, this.onDragLeave = e => {
						this.dragCount--, 0 === this.dragCount && this.state.point && this.setState({
							point: null
						})
					}, this.onDrop = e => {
						const t = () => {
								this.dragCount = 0, this.setState({
									point: null
								})
							},
							n = ho.a.msie ? null : e.dataTransfer.getData(Ke),
							s = Object(go.a)(e.dataTransfer);
						if (!(n || s.length && this.props.allowMediaUploads)) return void t();
						const {
							editorState: o
						} = this.props, r = Object(go.b)(o, e);
						if (!r) return void t();
						e.preventDefault(), e.stopPropagation();
						const i = r.isBefore ? R.a.before : R.a.after;
						n ? this.props.onBlockMove(n, r.blockKey, i) : setTimeout(() => {
							this.props.onFilesDrop(s, r.blockKey, i)
						}), t()
					}, this.state = {
						point: null
					}
				}
				componentDidMount() {
					document.addEventListener("drop", this.preventDocumentDrop), document.addEventListener("dragover", this.preventDocumentDrop)
				}
				componentWillUnmount() {
					document.removeEventListener("drop", this.preventDocumentDrop), document.removeEventListener("dragover", this.preventDocumentDrop)
				}
				render() {
					const {
						children: e
					} = this.props, {
						point: t
					} = this.state, n = c.a.Children.only(e);
					return c.a.createElement("div", {
						className: Object(m.a)(yo.a.container, {
							[yo.a.hideCaret]: !!t
						}),
						onDragEnter: this.onDragEnter,
						onDragLeave: this.onDragLeave,
						onDragOver: this.onDragOver,
						onDrop: this.onDrop,
						ref: this.setContainerRef
					}, c.a.createElement("div", null, n), c.a.createElement(Co, {
						targetPosition: t
					}, c.a.createElement(vo, null)))
				}
			}
			var Oo = n("./node_modules/draft-js/lib/DraftPasteProcessor.js"),
				jo = n.n(Oo),
				wo = n("./node_modules/draft-js/lib/getEntityKeyForSelection.js"),
				So = n.n(wo),
				_o = n("./node_modules/draft-js/lib/splitTextIntoTextBlocks.js"),
				ko = n.n(_o),
				To = n("./src/reddit/components/RichTextEditor/entity/cloneEntitiesInFragment.ts"),
				Io = n("./src/reddit/components/RichTextEditor/entity/applyEntityToContentBlock.ts");

			function Po(e, t, n) {
				const o = Object(s.convertFromHTML)(t, void 0, n);
				if (o) {
					const {
						contentBlocks: t,
						entityMap: n
					} = o;
					if (t) {
						const o = s.BlockMapBuilder.createFromArray(function(e) {
							return e.map(e => Object(w.r)(e.getType()) ? k(e) : e)
						}(t));
						return [e.set("entityMap", n), o]
					}
				}
				return [e, null]
			}

			function Mo(e, t, n) {
				const o = ko()(t),
					r = n && 1 === o.length ? n : s.CharacterMetadata.create(),
					i = jo.a.processText(o, r).map(e => e.merge({
						type: w.n
					}));
				return s.BlockMapBuilder.createFromArray(i)
			}
			const No = e => {
					if (!e) return null;
					const t = (new DOMParser).parseFromString(e, "text/html").querySelector("[".concat("data-reddit-rtjson", "]"));
					return t && t.getAttribute("data-reddit-rtjson")
				},
				Ro = e => {
					if (fe()) return {
						text: window.clipboardData.getData("text"),
						html: null
					}; {
						const t = e.clipboardData.getData("text/html");
						return {
							text: e.clipboardData.getData("text/plain"),
							html: t
						}
					}
				};

			function Lo(e, t, n, o) {
				const {
					text: r,
					html: i
				} = Ro(n), a = function(e, t, n, s) {
					const o = {
							text: t,
							html: n,
							rtjson: s,
							fragment: null
						},
						r = e.getClipboard();
					return r && n && function(e, t, n, s) {
						return -1 !== t.indexOf(s) || 1 === e.size && e.first().getText() === n
					}(r, n, t, e.getEditorKey()) && (o.fragment = r), o
				}(t, r, i, i && No(i));
				t.getClipboard() && !a.fragment && t.setClipboard(null);
				const c = e.getCurrentContent(),
					l = e.getSelection(),
					d = e.getCurrentInlineStyle(),
					u = t.props.blockRenderMap;
				let p = null,
					m = c;
				if (!(p = function(e, t, n) {
						const s = e.getBlockForKey(t.getStartKey()),
							o = e.getBlockForKey(t.getEndKey());
						if (s.getType() === w.f || o.getType() === w.f) return Mo(0, n).map(e => e.merge({
							type: w.f,
							depth: 0
						}))
					}(m, l, a.text)) && a.fragment && (p = a.fragment, [m, p] = Object(To.b)(m, p), p = Ee(p, o)), !p && a.rtjson && (p = function(e) {
						const t = JSON.parse(e);
						return Object(s.convertFromRaw)(t).getBlockMap()
					}(a.rtjson)), !p && a.html && ([m, p] = Po(m, a.html, u)), !p && a.text) {
					const e = function(e, t, n) {
						return s.CharacterMetadata.create({
							style: n,
							entity: So()(e, t)
						})
					}(m, l, d);
					p = Mo(0, a.text, e), [m, p] = function(e, t) {
						let n = e,
							s = t;
						return t.forEach(e => {
							const t = e.getText(),
								o = Rs.e.match(t);
							if (!o) return;
							let r = e;
							o.forEach(e => {
								let {
									index: t,
									lastIndex: o,
									url: i
								} = e;
								const a = (n = n.createEntity(L.a.LINK, "MUTABLE", {
									url: i
								})).getLastCreatedEntityKey();
								r = Object(Io.a)(r, t, o, a), s = s.set(r.getKey(), r)
							})
						}), [n, s]
					}(m, p)
				}
				if (p) return m = function(e, t, n) {
					if (n.isEmpty()) return e;
					let s = ie(e, t, n) || Oe(e, t, n);
					return s || (s = W.c(e, t, n))
				}(m, l, p), s.EditorState.push(e, m, J.e)
			}
			var Ao = n("./src/reddit/components/RichTextEditor/entity/getSelectionEntityInfo.ts"),
				Fo = n("./src/reddit/components/RichTextEditor/Tooltip/getSelectionClientRect.ts"),
				Do = n("./src/reddit/components/RichTextEditor/LinksController/LinkDetailsPopup/index.m.less"),
				Bo = n.n(Do);
			const Uo = b.a.div("LinkDetailsBox", Bo.a),
				Ko = b.a.a("Link", Bo.a),
				Ho = b.a.a("LinkButton", Bo.a);
			var Vo = e => c.a.createElement("div", null, c.a.createElement(Uo, {
					onMouseDown: e => e.preventDefault()
				}, c.a.createElement(Ko, {
					href: e.url,
					target: "_blank"
				}, e.url), c.a.createElement("span", null, " – "), c.a.createElement(Ho, {
					onClick: () => e.onStartEdit(),
					role: "button"
				}, o.fbt._("Change", null, {
					hk: "3aOmcP"
				})), c.a.createElement("span", null, " | "), c.a.createElement(Ho, {
					onClick: () => e.onRemove(),
					role: "button"
				}, o.fbt._("Remove", null, {
					hk: "3nPt5D"
				})))),
				Wo = n("./src/reddit/controls/Input/index.tsx"),
				zo = n("./src/reddit/components/RichTextEditor/LinksController/LinkEditorPopup/index.m.less"),
				qo = n.n(zo);
			const Go = b.a.form("EditForm", qo.a),
				Jo = b.a.wrapped(e => c.a.createElement("div", e, e.children), "LinkEditorBox", qo.a),
				Qo = b.a.wrapped(Wo.a, "Input", qo.a),
				Zo = b.a.label("Label", qo.a),
				Yo = b.a.div("HintAndButtonRow", qo.a),
				Xo = b.a.span("InvalidUrlHint", qo.a),
				$o = b.a.wrapped($e.f, "SubmitButton", qo.a),
				er = e => {
					e && (e.focus(), e.select())
				},
				tr = / /g,
				nr = e => e.replace(tr, "%20");
			class sr extends a.Component {
				constructor(e) {
					super(e), this.focused = !1, this.focusLostTimer = 0, this.textInputElementRef = null, this.urlInputElementRef = null, this.onEdited = () => {
						const e = this.state.url.trim(),
							t = nr(e),
							n = Object(Rs.h)(t);
						if (!n) return this.setState({
							isInvalidUrl: !0
						}), void(this.urlInputElementRef && this.urlInputElementRef.focus());
						const s = n.url;
						this.props.onEdited(s, this.state.displayText.trim() || e)
					}, this.onFocus = () => {
						this.focused = !0
					}, this.onBlur = () => {
						this.focused = !1, this.focusLostTimer = window.setTimeout(() => {
							this.focused || this.props.onFocusLost()
						}, 0)
					}, this.onClick = e => {
						e.stopPropagation()
					}, this.handleUrlChange = e => {
						const t = e.target.value;
						let {
							isInvalidUrl: n
						} = this.state;
						n && Object(Rs.g)(Rs.e, t) && (n = !1), this.setState({
							url: t,
							isInvalidUrl: n
						})
					}, this.handleDisplayTextChange = e => {
						this.setState({
							displayText: e.target.value
						})
					}, this.handleSubmit = e => {
						this.onEdited(), e.preventDefault()
					}, this.state = {
						url: e.url,
						displayText: e.displayText,
						isInvalidUrl: !1
					}
				}
				componentDidMount() {
					Object(Rs.g)(Rs.e, this.state.displayText) ? er(this.textInputElementRef) : er(this.urlInputElementRef)
				}
				componentWillUnmount() {
					this.focusLostTimer && clearTimeout(this.focusLostTimer)
				}
				render() {
					const {
						isInsertMode: e
					} = this.props;
					return c.a.createElement(Jo, {
						tabIndex: 0,
						onClick: this.onClick,
						onBlur: this.onBlur,
						onFocus: this.onFocus
					}, c.a.createElement(Go, {
						onSubmit: this.handleSubmit
					}, c.a.createElement(Zo, null, o.fbt._("Text", null, {
						hk: "1oock0"
					}), ":", c.a.createElement(Qo, {
						innerRef: e => this.textInputElementRef = e,
						type: "text",
						placeholder: o.fbt._("Title of link (optional)", null, {
							hk: "17GvI"
						}),
						value: this.state.displayText,
						onChange: this.handleDisplayTextChange
					})), c.a.createElement(Zo, null, o.fbt._("Link", null, {
						hk: "1Cfzw7"
					}), c.a.createElement(Qo, {
						innerRef: e => this.urlInputElementRef = e,
						type: "text",
						placeholder: o.fbt._("Paste or type a link", null, {
							hk: "3QWoAf"
						}),
						value: this.state.url,
						onChange: this.handleUrlChange
					})), c.a.createElement(Yo, null, c.a.createElement($o, {
						type: "submit",
						disabled: this.state.isInvalidUrl
					}, e ? o.fbt._("Insert", null, {
						hk: "3H7yaS"
					}) : o.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), this.state.isInvalidUrl ? c.a.createElement(Xo, null, o.fbt._("Link doesn't look right", null, {
						hk: "1BHfKz"
					})) : null)))
				}
			}

			function or(e, t, n) {
				const s = e.getCurrentContent(),
					o = {
						text: "",
						url: ""
					};
				if (t.isCollapsed()) return o;
				if (n) o.text = n.entityText, o.url = s.getEntity(n.entityKey).getData().url;
				else {
					o.text = function(e, t) {
						if (e.getStartKey() !== e.getEndKey()) throw new Error("Selection must be in a single block");
						return e.isCollapsed() ? "" : t.getBlockForKey(e.getStartKey()).getText().slice(e.getStartOffset(), e.getEndOffset())
					}(t, e.getCurrentContent());
					const n = Object(Rs.g)(Rs.e, o.text);
					n && (o.url = n.url)
				}
				return o
			}

			function rr(e, t) {
				return s.EditorState.set(e, {
					currentContent: s.Modifier.removeInlineStyle(e.getCurrentContent(), t, w.k.HIGHLIGHT)
				})
			}
			class ir extends a.Component {
				constructor(e) {
					super(e), this.api = null, this.updateTooltipPosition = null, this.lastEditorSelectionClientRect = null, this.editLinkInSelection = e => {
						const {
							editorState: t
						} = this.props;
						let n = e,
							o = t;
						const r = t.getCurrentContent();
						if (!Object(ks.e)(r, e)) return !1;
						const i = Object(Ao.a)(r, e);
						if (i) {
							if (r.getEntity(i.entityKey).getType() !== L.a.LINK) return !1;
							n = i.entitySelection
						} else this.isEditorFocused() && (this.lastEditorSelectionClientRect = Object(Fo.a)());
						return this.state.linkSelection && (o = rr(t, this.state.linkSelection)), o = function(e, t) {
							return s.EditorState.set(e, {
								currentContent: s.Modifier.applyInlineStyle(e.getCurrentContent(), t, w.k.HIGHLIGHT)
							})
						}(t, n), this.props.onChange(o, () => {
							this.setState({
								linkSelection: n,
								linkEntity: i
							})
						}), !0
					}, this.hidePopup = () => {
						this.interruptLinkEditing(), this.hideDetailsPopup()
					}, this.showDetailsPopup = () => {
						this.state.isDetailsPopupActive || this.setState({
							isDetailsPopupActive: !0
						})
					}, this.hideDetailsPopup = () => {
						this.state.isDetailsPopupActive && this.setState({
							isDetailsPopupActive: !1
						})
					}, this.updatePosition = () => {
						if (!this.updateTooltipPosition) return;
						const {
							editorState: e
						} = this.props, t = e.getCurrentContent();
						let n;
						if (this.state.linkSelection) {
							const e = Object(Ao.a)(t, this.state.linkSelection);
							if (e) {
								const t = this.props.entityElementRegistry.get(e.entityKey);
								n = t && t.getBoundingClientRect()
							} else this.lastEditorSelectionClientRect && (n = this.lastEditorSelectionClientRect)
						} else {
							const t = Object(ks.c)(e);
							if (t) {
								const e = this.props.entityElementRegistry.get(t.entityKey);
								n = e && e.getBoundingClientRect()
							}
						}
						n && (this.updateTooltipPosition({
							left: n.left,
							top: n.bottom
						}), this.lastEditorSelectionClientRect = null)
					}, this.handleLink = (e, t) => {
						const {
							linkSelection: n
						} = this.state, {
							editorState: o
						} = this.props;
						let r = o;
						n && (n.isCollapsed() || (r = rr(o, n)), void 0 !== e && (r = Object(ks.h)(r, n, e, t)), this.setState({
							linkSelection: null,
							linkEntity: null
						}), r !== o && (r = s.EditorState.forceSelection(r, r.getSelection()), this.props.onChange(r)))
					}, this.onLinkEdited = (e, t) => {
						this.handleLink(e, t)
					}, this.interruptLinkEditing = () => this.handleLink(), this.isEditorFocused = () => this.props.editorState.getSelection().getHasFocus(), this.onStartEditFocusedLink = () => {
						const {
							editorState: e
						} = this.props, t = Object(ks.c)(e);
						t && this.editLinkInSelection(t.entitySelection)
					}, this.onRemoveFocusedLink = () => {
						const {
							editorState: e
						} = this.props, t = Object(ks.c)(e);
						t && this.props.onChange(Object(ks.h)(e, t.entitySelection, ""))
					}, this.renderEditorPopup = () => {
						const {
							linkSelection: e,
							linkEntity: t
						} = this.state, {
							editorState: n
						} = this.props;
						if (!e) return null;
						const {
							text: s,
							url: o
						} = or(n, e, t);
						return c.a.createElement(sr, {
							url: o,
							displayText: s,
							isInsertMode: !t,
							onEdited: this.onLinkEdited,
							onFocusLost: this.interruptLinkEditing
						})
					}, this.renderDetailsPopup = () => {
						const e = Object(ks.c)(this.props.editorState);
						return e && this.isEditorFocused() && this.state.isDetailsPopupActive ? c.a.createElement(Vo, {
							url: e.url,
							onStartEdit: this.onStartEditFocusedLink,
							onRemove: this.onRemoveFocusedLink
						}) : null
					}, this.state = {
						isDetailsPopupActive: !1,
						linkSelection: null,
						linkEntity: null
					}, this.api = {
						editLinkInSelection: this.editLinkInSelection,
						hidePopup: this.hidePopup
					}
				}
				componentDidMount() {
					const {
						onSetApi: e
					} = this.props;
					this.api && e && e(this.api)
				}
				componentWillUnmount() {
					this.props.onSetApi && this.props.onSetApi(null)
				}
				componentDidUpdate(e, t) {
					t.linkSelection === this.state.linkSelection && e.editorState === this.props.editorState || (this.showDetailsPopup(), this.updatePosition())
				}
				render() {
					return c.a.createElement(Ln.b, {
						onSetPositionUpdater: e => this.updateTooltipPosition = e,
						trianglePlacement: Ln.a.Above
					}, this.renderEditorPopup() || this.renderDetailsPopup())
				}
			}
			var ar = n("./src/reddit/components/RichTextEditor/OrderedList/index.m.less"),
				cr = n.n(ar);
			const lr = b.a.ol("OrderedListWrapper", cr.a),
				dr = Object(A.Map)({
					[w.i.ORDERED]: {
						element: "li",
						aliasedElements: ["li"],
						wrapper: c.a.createElement(lr, null)
					}
				});
			var ur = n("./src/reddit/components/RichTextEditor/Paragraph/index.m.less"),
				pr = n.n(ur);
			const mr = b.a.div("ParagraphWrapper", pr.a),
				hr = Object(A.Map)({
					[w.n]: {
						element: "div",
						aliasedElements: ["p"],
						wrapper: c.a.createElement(mr, null)
					}
				});
			var br = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx");
			const fr = "Noto Sans, ".concat("Arial, sans-serif"),
				gr = "Noto Mono, ".concat("Menlo, Monaco, Consolas, monospace");
			"\n  font-family: ".concat(fr, ";\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 21px;\n");
			var xr = n("./src/reddit/components/RichTextEditor/TextRendering/index.m.less"),
				yr = n.n(xr);
			const vr = Object(qs.a)(() => ({
					[w.k.SUPERSCRIPT]: {
						position: "relative",
						top: "-0.4em",
						fontSize: "0.7em",
						lineHeight: "0.7em"
					},
					[w.k.HIGHLIGHT]: {
						backgroundColor: "#b8e0f9"
					},
					[w.k.UNDERLINE]: {
						textDecoration: "none"
					},
					[w.k.MONOSPACE]: {
						backgroundColor: "var(--newRedditTheme-field)",
						caretColor: "#000",
						color: "var(--newRedditTheme-monospaceColor)",
						fontFamily: gr,
						padding: "0.1em 0.2em",
						fontSize: "0.8em",
						borderRadius: "3px"
					}
				})),
				Cr = b.a.div("H1", yr.a),
				Er = b.a.div("H2", yr.a),
				Or = b.a.div("H3", yr.a),
				jr = b.a.div("H4", yr.a),
				wr = b.a.div("H5", yr.a),
				Sr = b.a.div("H6", yr.a),
				_r = e => ({
					component: t => c.a.createElement(e, null, c.a.createElement(s.EditorBlock, t)),
					editable: !0
				}),
				kr = {
					[w.g.H1]: _r(Cr),
					[w.g.H2]: _r(Er),
					[w.g.H3]: _r(Or),
					[w.g.H4]: _r(jr),
					[w.g.H5]: _r(wr),
					[w.g.H6]: _r(Sr)
				},
				Tr = ["italic normal 1em 'Noto Sans'", "italic bold 1em 'Noto Sans'", "normal bold 1em 'Noto Sans'"],
				Ir = () => {
					const e = document.fonts;
					e && e.load && Tr.forEach(t => e.load(t))
				};
			var Pr = n("./src/reddit/components/RichTextEditor/UnorderedList/index.m.less"),
				Mr = n.n(Pr);
			const Nr = b.a.ul("UnorderedListWrapper", Mr.a),
				Rr = Object(A.Map)({
					[w.i.UNORDERED]: {
						element: "li",
						aliasedElements: ["li"],
						wrapper: c.a.createElement(Nr, null)
					}
				});
			var Lr = n("./src/reddit/contexts/InsideOverlay.tsx"),
				Ar = n("./node_modules/lodash/debounce.js"),
				Fr = n.n(Ar),
				Dr = n("./src/reddit/actions/subredditAutocomplete.ts"),
				Br = n("./src/reddit/controls/SubredditDropdown/index.m.less"),
				Ur = n.n(Br);

			function Kr() {
				return (Kr = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var Hr = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const Vr = e => {
				var {
					isFocused: t
				} = e, n = Hr(e, ["isFocused"]);
				return c.a.createElement("div", Kr({
					className: Object(m.a)(Ur.a.entry, {
						[Ur.a.mIsFocused]: t
					})
				}, n))
			};
			class Wr extends a.Component {
				constructor(e) {
					super(e), this.mouseDown = !1, this.onMouseUp = () => {
						this.mouseDown && (this.props.onEntrySelect(this.props.entry), this.mouseDown = !1)
					}, this.onMouseDown = e => {
						this.mouseDown = !0, e.preventDefault()
					}, this.onMouseOver = () => {
						this.props.onEntryFocus(this.props.entry)
					}, this.mouseDown = !1
				}
				componentDidUpdate() {
					this.mouseDown = !1
				}
				render() {
					return c.a.createElement(Vr, {
						isFocused: this.props.isFocused,
						onMouseDown: this.onMouseDown,
						onMouseUp: this.onMouseUp,
						onMouseOver: this.onMouseOver
					}, this.props.children)
				}
			}
			var zr = n("./src/reddit/helpers/name/index.ts"),
				qr = n("./src/reddit/selectors/subredditAutocomplete.ts");
			const Gr = Object(d.c)({
				subredditSuggestions: (e, t) => {
					const n = Object(qr.d)(e, t);
					return n ? n.subreddits : []
				}
			});
			class Jr extends a.Component {
				constructor(e) {
					super(e), this.api = null, this.onEntrySelect = e => {
						this.props.onSelect(this.props.subredditSuggestions[e].name)
					}, this.onEntryFocus = e => {
						this.setState({
							selectedSuggestionIndex: e
						})
					}, this.moveUp = () => {
						if (this.props.subredditSuggestions.length > 1) {
							let e = this.state.selectedSuggestionIndex - 1;
							return e = e < 0 ? this.props.subredditSuggestions.length - 1 : e, this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.moveDown = () => {
						if (this.props.subredditSuggestions.length > 1) {
							const e = (this.state.selectedSuggestionIndex + 1) % this.props.subredditSuggestions.length;
							return this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.selectCurrent = () => {
						if (this.props.subredditSuggestions.length) {
							const e = this.props.subredditSuggestions[this.state.selectedSuggestionIndex];
							return e && this.props.onSelect(e.name), !0
						}
						return !1
					}, this.state = {
						selectedSuggestionIndex: 0
					}, this.requestSubredditAutocomplete = Fr()(this.requestSubredditAutocomplete.bind(this), 200, {
						maxWait: 200
					}), this.api = {
						moveUp: this.moveUp,
						moveDown: this.moveDown,
						selectCurrent: this.selectCurrent
					}
				}
				componentDidMount() {
					this.requestSubredditAutocomplete(this.props.substring), this.props.onDropdownApi(this.api)
				}
				componentWillUnmount() {
					this.props.onDropdownApi(null)
				}
				componentWillReceiveProps(e) {
					e.substring !== this.props.substring && (this.requestSubredditAutocomplete(e.substring), this.setState({
						selectedSuggestionIndex: 0
					}))
				}
				requestSubredditAutocomplete(e) {
					this.props.onGetSubredditAutocomplete(e)
				}
				render() {
					return this.props.subredditSuggestions.length ? c.a.createElement("div", {
						className: Object(m.a)(Ur.a.list, this.props.className)
					}, this.props.subredditSuggestions.map((e, t) => c.a.createElement(Wr, {
						entry: t,
						isFocused: t === this.state.selectedSuggestionIndex,
						key: e.name,
						onEntrySelect: this.onEntrySelect,
						onEntryFocus: this.onEntryFocus
					}, Object(zr.b)(e.name)))) : null
				}
			}
			var Qr = Object(l.b)(Gr, (e, t) => ({
					onGetSubredditAutocomplete: t => {
						e(Dr.d(t))
					}
				}))(Jr),
				Zr = n("./src/reddit/selectors/comments.ts");
			const Yr = Object(d.c)({
				commentAuthors: Zr.h
			});
			class Xr extends a.Component {
				constructor(e) {
					super(e), this.api = null, this.onEntrySelect = e => {
						this.props.onSelect(this.state.userSuggestions[e])
					}, this.onEntryFocus = e => {
						this.setState({
							selectedSuggestionIndex: e
						})
					}, this.moveUp = () => {
						if (this.state.userSuggestions.length > 1) {
							let e = this.state.selectedSuggestionIndex - 1;
							return e = e < 0 ? this.state.userSuggestions.length - 1 : e, this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.moveDown = () => {
						if (this.state.userSuggestions.length > 1) {
							const e = (this.state.selectedSuggestionIndex + 1) % this.state.userSuggestions.length;
							return this.setState({
								selectedSuggestionIndex: e
							}), !0
						}
						return !1
					}, this.selectCurrent = () => {
						if (this.state.userSuggestions.length) {
							const e = this.state.userSuggestions[this.state.selectedSuggestionIndex];
							return e && this.props.onSelect(e), !0
						}
						return !1
					}, this.state = {
						userSuggestions: [],
						selectedSuggestionIndex: 0
					}, this.api = {
						moveUp: this.moveUp,
						moveDown: this.moveDown,
						selectCurrent: this.selectCurrent
					}
				}
				componentDidMount() {
					this.props.onDropdownApi(this.api), this.setState({
						userSuggestions: this.filterUsers(this.props.substring)
					})
				}
				componentWillUnmount() {
					this.props.onDropdownApi(null)
				}
				componentWillReceiveProps(e) {
					e.substring !== this.props.substring && this.setState({
						selectedSuggestionIndex: 0,
						userSuggestions: this.filterUsers(e.substring)
					})
				}
				filterUsers(e) {
					const {
						commentAuthors: t
					} = this.props;
					return t.filter(t => t.toLowerCase().startsWith(e.toLowerCase()))
				}
				render() {
					return this.state.userSuggestions.length ? c.a.createElement("div", {
						className: Object(m.a)(Ur.a.list, this.props.className)
					}, this.state.userSuggestions.map((e, t) => c.a.createElement(Wr, {
						key: t,
						entry: t,
						onEntryFocus: this.onEntryFocus,
						onEntrySelect: this.onEntrySelect,
						isFocused: t === this.state.selectedSuggestionIndex
					}, Object(zr.c)(e)))) : null
				}
			}
			var $r = Object(l.b)(Yr)(Xr),
				ei = n("./node_modules/lodash/dropRightWhile.js"),
				ti = n.n(ei),
				ni = n("./node_modules/lodash/flatMap.js"),
				si = n.n(ni),
				oi = n("./node_modules/lodash/reduceRight.js"),
				ri = n.n(oi),
				ii = n("./node_modules/lodash/trimEnd.js"),
				ai = n.n(ii),
				ci = n("./node_modules/lodash/trimStart.js"),
				li = n.n(ci),
				di = n("./src/lib/forEachGroup/index.ts");

			function ui(e, t) {
				const n = [],
					s = e.withMutations(e => {
						for (; e.size && t(e.first());) n.push(e.first()), e.shift()
					});
				return {
					popped: n,
					stack: s
				}
			}
			var pi = n("./src/lib/unicodeUtils/index.ts"),
				mi = n("./src/reddit/helpers/richTextJson/index.ts"),
				hi = n("./src/reddit/models/RichTextJson/nodeMakers.ts");
			const bi = {
				BOLD: Kn.j.bold,
				ITALIC: Kn.j.italic,
				MONOSPACE: Kn.j.monospace,
				STRIKETHROUGH: Kn.j.strikethrough,
				SUBSCRIPT: Kn.j.subscript,
				SUPERSCRIPT: Kn.j.superscript,
				UNDERLINE: Kn.j.underline
			};
			var fi = (e, t) => gi(e.getBlockMap(), e, t);
			const gi = (e, t, n) => {
					const s = [];
					let o = e.toStack();
					for (; o.size;) {
						const e = o.first(),
							r = e.getType();
						switch (o = o.shift(), r) {
							case w.g.H1:
							case w.g.H2:
							case w.g.H3:
							case w.g.H4:
							case w.g.H5:
							case w.g.H6:
								s.push(Oi(e, t));
								break;
							case w.e: {
								const {
									popped: n,
									stack: r
								} = ui(o, e => e.getType() === w.e);
								o = r, s.push(ji([e, ...n], t));
								break
							}
							case w.f: {
								const {
									popped: t,
									stack: n
								} = ui(o, e => e.getType() === w.f);
								o = n, s.push(wi([e, ...t]));
								break
							}
							case w.i.ORDERED:
							case w.i.UNORDERED: {
								const {
									popped: n,
									stack: i
								} = ui(o, e => e.getType() === r);
								o = i, s.push(Si([e, ...n], t));
								break
							}
							case w.l: {
								const {
									popped: n,
									stack: r
								} = ui(o, e => Object(w.v)(e.getType()));
								o = r, s.push(_i([e, ...n], t));
								break
							}
							case w.a: {
								let t = o.first();
								t && Object(w.u)(t.getType()) ? o = o.shift() : t = void 0, s.push(ki(e, t, n));
								break
							}
							case w.n:
							default:
								s.push(Ci(e, t))
						}
					}
					return s
				},
				xi = e => e.reduce((e, t) => t === w.k.UNDERLINE || t === w.k.SUBSCRIPT ? e : e | (bi[t] || 0) | 0, 0),
				yi = (e, t) => {
					const n = [],
						s = Object(pi.b)(e);
					return Object(di.a)(t, {
						keyFn: e => e.getStyle()
					}, (t, o, r, i) => {
						if (o.isEmpty()) return;
						const a = e.slice(r, i),
							c = r + (a.length - li()(a).length),
							l = i - (a.length - ai()(a).length),
							d = l - c,
							u = s[c],
							p = s[l] - u;
						d > 0 && n.push([xi(o), u, p])
					}), n.length ? n : null
				},
				vi = (e, t) => {
					const n = e.getText(),
						s = e.getCharacterList(),
						o = [],
						r = w.d.includes(e.getType()),
						i = w.c.includes(e.getType());
					let a = 0;
					return Object(di.a)(s, {
						keyFn: (e, s) => {
							const o = e.getEntity();
							return r && e.getStyle().contains(w.k.SPOILER) ? "spoiler" : Object(L.b)(o, t) ? "link-".concat(e.getEntity()) : "\n" === n[s] ? i ? "linebreak" : "skip" : o && t.getEntity(o).getType() === L.a.EMOTE ? "emote-".concat(a++) : "text"
						}
					}, (e, r, i, a) => {
						const c = n.slice(i, a),
							l = s.slice(i, a).toList();
						if ("text" === r) {
							const e = yi(c, l);
							o.push(Object(hi.s)(c, e))
						} else if ("spoiler" === r) o.push(Object(hi.n)(c));
						else if (r.startsWith("link-")) {
							const n = t.getEntity(e.getEntity());
							o.push(((e, t, n) => {
								const s = e.getType(),
									o = [L.a.USER_LINK, L.a.USER_MENTION],
									{
										url: r
									} = e.getData(),
									i = t.startsWith("/");
								if (s === L.a.SUBREDDIT_LINK) {
									const e = t.replace(f.e, "");
									return Object(hi.o)(e, i)
								}
								if (o.includes(s)) {
									const e = t.replace(f.a, "");
									return Object(hi.t)(e, i)
								}
								const a = yi(t, n);
								return Object(hi.i)(t, r, a)
							})(n, c, l))
						} else if ("linebreak" === r) o.push(Object(hi.h)());
						else if (r.startsWith("emote-")) {
							const n = t.getEntity(e.getEntity()).getData();
							o.push(Object(hi.e)(n.fullId, n.imageType))
						}
					}), o
				},
				Ci = (e, t) => Object(hi.l)(vi(e, t)),
				Ei = e => "text" === e.e ? Object(hi.m)(e.t) : "link" === e.e ? Object(hi.i)(e.t, e.u, null) : e.e === Kn.x ? e.c.map(Ei) : e.e === Kn.n ? Object(hi.m)("") : e,
				Oi = (e, t) => Object(hi.f)(w.m[e.getType()], ((e, t) => ri()(si()(vi(e, t), Ei), (e, t) => {
					let [n, ...s] = e;
					if (!n) return [t];
					const o = s.length ? s : [];
					return n && "raw" === t.e && "raw" === n.e ? [Object(hi.m)(t.t + n.t), ...o] : [t, n, ...o]
				}, []))(e, t)),
				ji = (e, t) => Object(hi.c)(ti()(e.map(e => ((e, t) => e.getText().trim().length ? Ci(e, t) : hi.a)(e, t)), e => e === hi.a)),
				wi = e => Object(hi.d)(e.map(e => Object(hi.m)(e.getText()))),
				Si = (e, t) => {
					if (!e.length) return Object(hi.k)([], !1);
					const n = e[0].getDepth();
					let s = null;
					const o = [];
					let r = [];
					const i = () => null !== s || r.length,
						a = () => {
							const e = [];
							null !== s && (e.push(s), s = null), r.length && (e.push(Si(r, t)), r = []), o.push(Object(hi.j)(e))
						};
					return e.forEach(e => {
						e.getDepth() > n ? r.push(e) : (i() && a(), s = Object(hi.l)(vi(e, t)))
					}), i() && a(), Object(hi.k)(o, e[0].getType() === w.i.ORDERED)
				},
				_i = (e, t) => {
					const n = [...e].sort(z.b),
						s = n[0],
						{
							colCount: o
						} = Object(z.g)(s),
						r = B()(n, o),
						i = r[0].map(e => {
							const {
								alignment: n
							} = Object(z.g)(e);
							return Object(hi.q)(vi(e, t), n)
						}),
						a = r.slice(1).map(e => e.map(e => Object(hi.p)(vi(e, t))));
					return Object(hi.r)(i, a)
				},
				ki = (e, t, n) => {
					const s = Object(N.h)(e);
					if (!s) throw new Error("Invalid atomic block!");
					const {
						uploadInfo: o,
						mediaAsset: r,
						makeGif: i
					} = s, a = t ? t.getText() : "";
					if (o && n) {
						const e = n[o.uploadKey],
							t = e && e.metadata.mimetype || "",
							{
								assetId: r,
								thumbnailAssetId: c
							} = Object(N.f)(s, n);
						return Object(De.j)(t) ? Object(hi.b)(r, a) : Object(De.k)(t) ? Object(hi.g)(r, a) : Object(hi.u)(r, a, c, i)
					} {
						const {
							assetId: e,
							type: t
						} = r;
						let n;
						switch (t) {
							case N.a.AnimatedImage:
								n = Object(hi.b)(e, a);
								break;
							case N.a.Image:
								n = Object(hi.g)(e, a);
								break;
							case N.a.Video:
								n = Object(hi.u)(e, a);
								break;
							default:
								throw new Error("Invalid media type")
						}
						return Object(mi.e)(e) ? Object(hi.l)([n]) : n
					}
				};
			var Ti, Ii = n("./src/reddit/constants/componentSizes.ts"),
				Pi = n("./src/reddit/constants/elementIds.ts");
			! function(e) {
				e.Up = "up", e.Down = "down"
			}(Ti || (Ti = {}));
			var Mi = e => {
					const t = window.getSelection().focusNode;
					if (!t || !t.parentElement) return;
					const n = document.getElementById(Pi.d),
						s = n || document.documentElement;
					if (!s) return;
					const o = window.innerHeight,
						{
							bottom: r,
							top: i
						} = t.parentElement.getBoundingClientRect(),
						a = n ? 0 : Ii.f + Ii.p;
					e === Ti.Up && i < a ? s.scrollBy(0, i - a) : e === Ti.Down && r > o && s.scrollBy(0, r - o)
				},
				Ni = n("./src/reddit/models/Product/index.ts"),
				Ri = (e, t, n) => {
					const s = {
						url: n
					};
					return e.createEntity(t, "MUTABLE", s)
				},
				Li = n("./node_modules/lodash/maxBy.js"),
				Ai = n.n(Li);
			const Fi = (e, t) => {
				if (!t) return (e => {
					const t = e.id;
					switch (e.e) {
						case Kn.m:
							return {
								assetId: t, type: N.a.Image
							};
						case Kn.a:
							return {
								assetId: t, type: N.a.AnimatedImage
							};
						case Kn.D:
							return {
								assetId: t, type: N.a.Video
							}
					}
				})(e);
				const n = t.id;
				switch (t.e) {
					case Kn.s: {
						const {
							s: e
						} = t;
						return {
							assetId: n,
							type: N.a.Image,
							imageUrl: e.u,
							width: e.x,
							height: e.y
						}
					}
					case Kn.r: {
						const {
							s: e
						} = t;
						return {
							assetId: n,
							type: N.a.AnimatedImage,
							imageUrl: e.gif,
							posterUrl: e.p,
							dashUrl: e.mp4,
							width: e.x,
							height: e.y
						}
					}
					case Kn.t: {
						const {
							isGif: e,
							dashUrl: s,
							hlsUrl: o,
							p: r,
							x: i,
							y: a
						} = t;
						let c;
						if (r) {
							c = Ai()(r, e => e.x).u
						}
						return {
							assetId: n,
							type: N.a.Video,
							isGif: e,
							dashUrl: s,
							hlsUrl: o,
							posterUrl: c,
							width: i,
							height: a
						}
					}
				}
			};

			function Di(e, t, n) {
				const o = e.id,
					r = e.c,
					i = Kn.E(t, o),
					a = Fi(e, i),
					c = [new s.ContentBlock({
						key: Object(s.genKey)(),
						type: w.a,
						data: Object(A.Map)({
							mediaAsset: a
						})
					})];
				if (n) {
					const e = Object(R.h)(Object(s.genKey)(), r).merge({
						type: w.j
					});
					c.push(e)
				}
				return c
			}
			const Bi = Object.keys(bi),
				Ui = (e, t, n) => {
					switch (t.e) {
						case Kn.u:
							return qi(e, t.c, w.b.UNSTYLED, n);
						case Kn.k:
							const s = w.h[t.l];
							return qi(e, t.c || [], s, n);
						case Kn.p:
							return Vi(e, t, n);
						case Kn.b:
							return Ki(e, t, n);
						case Kn.c:
							return void t.c.forEach(t => qi(e, [t], w.b.CODE_BLOCK, n));
						case Kn.z:
							return Hi(e, t, n);
						case Kn.m:
						case Kn.a:
						case Kn.D:
							return void e.blocks.push(...Di(t, n.mediaMetadataMap, Object(N.q)(n.editorType)))
					}
				},
				Ki = (e, t, n) => {
					t && t.c && t.c.length && t.c.forEach(t => t.e === Kn.u ? qi(e, t.c, w.b.BLOCK_QUOTE, n) : Ui(e, t, n))
				},
				Hi = (e, t, n) => {
					const {
						h: s,
						c: o
					} = t, r = s.length;
					[s, ...o].forEach((t, o) => t.forEach((t, i) => {
						const {
							c: a = []
						} = t, {
							a: c
						} = s[i], l = {
							alignment: c,
							colCount: r,
							colIndex: i,
							rowIndex: o
						};
						qi(e, a, w.b.TABLE_CELL, n, l)
					}))
				},
				Vi = function e(t, n, s) {
					let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
					const r = n.o ? w.b.ORDERED_LIST : w.b.UNORDERED_LIST;
					n.c.forEach(n => {
						const i = n.c;
						if (!i || !i.length) return;
						const [a, c] = i, l = a.e === Kn.u ? a.c : [];
						qi(t, l, r, s, void 0, o), c && c.e === Kn.p && e(t, c, s, o + 1)
					})
				},
				Wi = {
					[Kn.y]: ["r/", "/r/"],
					[Kn.B]: ["u/", "/user/"],
					[Kn.C]: ["u/", "/user/"],
					[Kn.v]: ["p/", ""],
					[Kn.g]: ["c/", ""]
				},
				zi = {
					[Kn.y]: L.a.SUBREDDIT_LINK,
					[Kn.B]: L.a.USER_LINK,
					[Kn.C]: L.a.USER_MENTION,
					[Kn.v]: L.a.POST_LINK,
					[Kn.g]: L.a.COMMENT_LINK
				},
				qi = function(e, t, n, o) {
					let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
						i = arguments.length > 5 ? arguments[5] : void 0,
						a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
					const c = e.content;
					if (1 === t.length && (t[0].e === Kn.m || t[0].e === Kn.a)) {
						const n = t[0];
						if (Object(mi.e)(n.id)) return void e.blocks.push(...Di(n, o.mediaMetadataMap, Object(N.q)(o.editorType)))
					}
					const {
						charList: l,
						text: d,
						updatedContent: u
					} = Gi(t, c, o), p = new s.ContentBlock({
						key: Object(s.genKey)(),
						characterList: Object(A.List)(l),
						data: Object(A.fromJS)(r),
						depth: i,
						text: d,
						type: n
					});
					e.content = u || c, a ? e.blocks.unshift(p) : e.blocks.push(p)
				},
				Gi = (e, t, n) => {
					let s = t,
						o = "";
					const r = [];
					if (e.forEach(e => {
							const t = Ji(e, s, n);
							s = t.updatedContent || s, o += t.text, r.push(...t.charList)
						}), o.length !== r.length) throw new Error("Characters length mismatch!");
					return {
						charList: r,
						text: o,
						updatedContent: s !== t ? s : void 0
					}
				},
				Ji = (e, t, n) => {
					switch (e.e) {
						case Kn.A: {
							const {
								t,
								f: n
							} = e;
							return {
								charList: Zi(t, n),
								text: t
							}
						}
						case Kn.x: {
							const {
								c: o
							} = e, r = Gi(o, t, n);
							return r.charList = r.charList.map(e => (e => s.CharacterMetadata.create({
								style: e.getStyle().add(w.k.SPOILER),
								entity: e.getEntity()
							}))(e)), r
						}
						case Kn.v:
						case Kn.g:
						case Kn.w: {
							const {
								t
							} = e;
							return {
								charList: Zi(t),
								text: t
							}
						}
						case Kn.y:
						case Kn.B:
						case Kn.C: {
							const [n, s] = Wi[e.e], o = (e.l ? "/" : "") + n + e.t, r = s + e.t, i = Ri(t, zi[e.e], r), a = i.getLastCreatedEntityKey();
							return {
								charList: Zi(o, void 0, a),
								text: o,
								updatedContent: i
							}
						}
						case Kn.o: {
							const {
								t: n,
								u: s,
								f: o
							} = e, r = Ri(t, L.a.LINK, s), i = r.getLastCreatedEntityKey();
							return {
								charList: Zi(n, o, i),
								text: n,
								updatedContent: r
							}
						}
						case Kn.m:
						case Kn.a:
							const {
								id: o
							} = e;
							if (o.startsWith("emote|")) {
								const e = Object(Ni.b)(o),
									s = n.activeEmotes && n.activeEmotes[e];
								if (s) {
									const e = Object(vs.c)(t, s),
										n = e.getLastCreatedEntityKey(),
										o = vs.a;
									return {
										charList: Zi(o, void 0, n),
										text: o,
										updatedContent: e
									}
								}
								const r = ":".concat(e, ":");
								return {
									charList: Zi(r),
									text: r
								}
							}
							return {
								text: "", charList: Zi("")
							};
						default:
							return {
								text: "", charList: Zi("")
							}
					}
				},
				Qi = e => {
					const t = Bi.filter(t => !!(bi[t] & e));
					return Object(A.OrderedSet)(t)
				},
				Zi = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
					const o = s.CharacterMetadata.create({
							entity: n
						}),
						r = Array(e.length).fill(o),
						i = Object(pi.a)(e);
					return t && t.forEach(e => {
						const [t, o, a] = e, c = Qi(t), l = o + a, d = s.CharacterMetadata.create({
							entity: n,
							style: c
						});
						r.fill(d, i[o], i[l])
					}), r
				},
				Yi = (e, t) => {
					e.blocks.length && (e.blocks[0].getType() === w.b.TABLE_CELL && qi(e, [], w.b.UNSTYLED, t, void 0, void 0, !0), e.blocks[e.blocks.length - 1].getType() === w.b.TABLE_CELL && qi(e, [], w.b.UNSTYLED, t))
				};
			var Xi = (e, t, n, o) => {
					const r = "string" == typeof e ? JSON.parse(e) : e;
					if (!r || !r.document || !r.document.length) return null;
					const i = {
							editorType: t,
							mediaMetadataMap: n,
							activeEmotes: o ? o.reduce((e, t) => Object.assign(Object.assign({}, e), t.emotes), {}) : void 0
						},
						a = {
							blocks: [],
							content: s.ContentState.createFromText("")
						};
					r.document.forEach(e => {
						Ui(a, e, i)
					}), 0 === a.blocks.length && qi(a, [], w.b.UNSTYLED, i), Yi(a, i);
					const c = s.BlockMapBuilder.createFromArray(a.blocks),
						l = s.SelectionState.createEmpty(c.first().getKey());
					return a.content.merge({
						blockMap: c,
						selectionBefore: l,
						selectionAfter: l
					})
				},
				$i = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				ea = n("./src/reddit/constants/elementClassNames.ts"),
				ta = n("./src/reddit/constants/keycodes.ts"),
				na = n("./src/reddit/icons/svgs/Send/index.tsx"),
				sa = n("./src/reddit/selectors/economics.ts"),
				oa = n("./src/reddit/selectors/gold/powerups.ts"),
				ra = n("./src/reddit/components/RichTextEditor/index.m.less"),
				ia = n.n(ra);

			function aa() {
				return (aa = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			Object(br.b)({
				draftToRTFJson: fi,
				getMediaCount: N.g,
				getPendingThumbnailUploads: N.i,
				isAllMediaUploaded: N.m
			});
			const ca = "handled",
				la = "not-handled",
				da = /^\s*$/,
				ua = 20,
				pa = b.a.wrapped(so.a, "FocusableContent", ia.a),
				ma = b.a.div("Container", ia.a),
				ha = b.a.wrapped($i.a, "CurrentUserIcon", ia.a),
				ba = e => "".concat(v.b, "-").concat(e),
				fa = Object(l.b)(() => {
					const e = (() => Object(d.a)(e => e.uploads, (e, t) => t.rteState.editorKey, (e, t) => i()(e, e => e.key.startsWith(ba(t)))))();
					return Object(d.c)({
						editorUploads: e,
						emotesPowerupBenefitUnlocked: (e, t) => {
							let {
								destSubreddit: n
							} = t;
							return !!n && !!n.id && Object(oa.h)(e, {
								subredditId: n.id,
								benefit: O.a.CommentsWithEmoji
							})
						},
						emotesSpecialMembershipEnabled: C.d.spEmotes,
						giphyPowerupBenefitEnabledUnlocked: (e, t) => {
							let {
								destSubreddit: n
							} = t;
							return !!n && !!n.id && Object(oa.h)(e, {
								subredditId: n.id,
								benefit: O.a.CommentsWithGifs
							})
						},
						giphySpecialMembershipEnabled: C.d.spGiphy,
						activeEmotes: (e, t) => !!t.destSubreddit && t.destSubreddit.id && Object(sa.b)(e, t.destSubreddit.id) || void 0
					})
				}, e => ({
					onFetchEditorProducts: t => e(Object(y.e)(t)),
					onTrackMediaDrop: t => e((e, n) => E.o(n(), t)),
					retryUpload: t => e(v.c(t)),
					startUploads: (t, n, s) => e(v.e(t, n, ba(s)))
				}));
			class ga extends a.Component {
				constructor(e) {
					super(e), this.blockRenderMap = s.DefaultDraftBlockRenderMap.merge(ao, po, Mn, dr, hr, Rr, rn), this.editorHeight = null, this.editorRef = null, this.editorRootStyleMutationObserver = null, this.linksControllerApi = null, this.suggestionDropdownApi = null, this.tableToolbarControllerApi = null, this.emotesTooltipApi = null, this.gifTooltipApi = null, this.updateSuggestionDropdownPosition = null, this.isJustAutocompleteSelected = !1, this.isJustLinkified = !1, this.isMouseDown = !1, this.isJustConvertedToList = !1, this.needSyncScroll = null, this.transforms = {
						[S.BREAK_HEADER_ENTITY]: bs.b,
						[S.INSERT_LINE_BREAK]: bs.e,
						[S.REDUCE_LIST_INDENT]: bs.f,
						[S.RESET_CURRENT_AND_PREVIOUS_BLOCKS]: bs.g,
						[S.REMOVE_EXTRA_LIST_ITEM]: bs.h,
						[I.d]: e => Ws(e, this.props.editorType),
						[I.b]: e => Vs(e, this.props.editorType),
						[I.f]: bs.d,
						[I.c]: e => Object(bs.c)(w.k.BOLD, e),
						[I.e]: e => Object(bs.c)(w.k.ITALIC, e),
						[I.g]: e => Object(bs.c)(w.k.UNDERLINE, e)
					}, this.setContainerRef = e => {
						const {
							domRef: t
						} = this.props;
						t && t(e), this.setState({
							containerRef: e
						})
					}, this.setFocusableContentRef = e => this.setState({
						focusableContentRef: e
					}), this.rteStateChanged = (e, t) => {
						const n = Object.assign(Object.assign({}, this.props.rteState), {
							isBound: !0,
							editorState: e
						});
						this.props.onChange(n, t)
					}, this.hideTooltips = () => {
						this.emotesTooltipApi && this.emotesTooltipApi.closeTooltip(), this.gifTooltipApi && this.gifTooltipApi.closeTooltip(), this.tableToolbarControllerApi && this.tableToolbarControllerApi.hideActionButton(), this.linksControllerApi && this.linksControllerApi.hidePopup(), this.suppressAutocompleteForFocusedLink()
					}, this.onEditorStyleChanged = () => {
						if (!this.editorRef) return;
						const e = this.editorRef.refs.editor,
							t = e.style.height ? Number.parseInt(e.style.height) : null;
						this.editorHeight !== t && (this.hideTooltips(), this.editorHeight = t, t && this.props.onEditorResize && this.props.onEditorResize(t))
					}, this.insertValidatedMedia = () => {
						const {
							editorUploads: e
						} = this.props, {
							editorState: t,
							mediaToInsert: n
						} = this.state;
						if (!n) return;
						const {
							files: s,
							blockKey: o,
							insertionMode: r
						} = n, i = s.map(t => e.find(e => e.file === t)).filter(Boolean);
						this.setState({
							mediaToInsert: null
						});
						const a = i.filter(e => !!e.metadata.mimetype);
						a.length && this.onChange(Object(N.l)(t, a, o, r))
					}, this.focus = () => this.editorRef && this.editorRef.focus(), this.blur = () => this.editorRef && this.editorRef.blur(), this.isFocused = () => this.state.editorState.getSelection().getHasFocus(), this.isEmpty = () => !this.state.editorState.getCurrentContent().hasText(), this.setEditorRef = e => this.editorRef = e, this.setSuggestionDropdownApi = e => this.suggestionDropdownApi = e, this.setLinksControllerApi = e => this.linksControllerApi = e, this.setTableToolbarControllerApi = e => this.tableToolbarControllerApi = e, this.setEmotesTooltipApi = e => this.emotesTooltipApi = e, this.setGifTooltipApi = e => this.gifTooltipApi = e, this.setSuggestionDropdownPositionUpdater = e => this.updateSuggestionDropdownPosition = e, this.getEditorState = () => this.state.editorState, this.setEditorState = (e, t) => {
						const n = this.state.editorState.getCurrentContent() !== e.getCurrentContent();
						n && this.props.readOnly || (this.setState({
							editorState: e
						}, t), this.rteStateChanged(e, n))
					}, this.toolbarSetState = e => {
						const t = e.getInlineStyleOverride();
						let n = e;
						n.getSelection().getHasFocus() || (n = s.EditorState.forceSelection(n, n.getSelection()), t && (n = s.EditorState.setInlineStyleOverride(n, t))), this.onChange(n)
					}, this.onChange = (e, t) => {
						let n = e;
						n = vn(n, this.state.editorState), n = Ne(n, this.props.editorType), this.emotesTooltipApi && (n = Object(vs.d)(n, this.state.editorState)), n = Fs(n, this.state.editorState), n = Object(Qs.d)(n, this.state.editorState), this.setEditorState(n, t);
						let {
							suppressAutocompleteForLink: s
						} = this.state;
						if (s) {
							const t = Object(ks.b)(e);
							t && t.entityKey === s || (s = null)
						}
						this.setState({
							suppressAutocompleteForLink: s
						}), this.isJustAutocompleteSelected = !1, this.isJustLinkified = !1, this.isMouseDown = !1, this.isJustConvertedToList = !1
					}, this.onFocus = () => {
						const {
							onFocus: e
						} = this.props;
						this.emotesTooltipApi && this.emotesTooltipApi.closeTooltip(), this.gifTooltipApi && this.gifTooltipApi.closeTooltip(), e && e()
					}, this.handleBeforeInput = e => {
						const {
							editorState: t
						} = this.state;
						if (this.isMouseDown) return ca;
						if (Me(t, e)) return ca;
						let n = function(e, t) {
							const n = e.getSelection(),
								o = n.getFocusOffset();
							if (!n.isCollapsed() || 0 === o) return;
							const r = n.getFocusKey(),
								i = e.getCurrentContent(),
								a = i.getBlockForKey(r),
								c = a.getEntityAt(o - 1),
								l = a.getEntityAt(o);
							if (!(c && (!l || l !== c))) return;
							const d = i.getEntity(c),
								u = _s.has(d.getType());
							if ("MUTABLE" === d.getMutability() && u) {
								const o = s.Modifier.insertText(i, n, t, e.getCurrentInlineStyle());
								return s.EditorState.push(e, o, "insert-characters")
							}
						}(t, e) || t;
						return (n = fn(n, e) || n) !== t ? (this.onChange(n), ca) : la
					}, this.keyBindingFN = e => {
						const {
							editorState: t
						} = this.state, {
							submitOnEnter: n
						} = this.props, o = t.getSelection();
						if (e.metaKey && e.keyCode === ta.a.K) return S.OPEN_LINK_TOOLTIP;
						if (e.keyCode === ta.a.Space) {
							if (Gs(t)) return S.CONVERT_TO_LIST_ON_SPACE;
							if (Object(ks.d)(t)) return S.LINKIFY_ON_SPACE
						} else if (e.keyCode === ta.a.Enter) {
							if (e.ctrlKey || e.metaKey || n && !e.shiftKey) return S.SUBMIT;
							if (e.shiftKey && zs(t)) return S.INSERT_LINE_BREAK; {
								const e = this.enterKeyBinding(t);
								if (e) return e
							}
						} else if (e.keyCode === ta.a.Backspace) {
							if (this.isJustLinkified || this.isJustConvertedToList) return I.h;
							if (o.isCollapsed()) {
								const e = t.getCurrentContent(),
									n = o.getEndKey(),
									s = o.getStartOffset(),
									r = e.getBlockForKey(n),
									i = r.getType();
								if ((Object(w.s)(i) || Object(w.q)(i) || Object(w.p)(i)) && 0 === s && r.getLength() > 0) {
									const t = e.getBlockBefore(n);
									if (!t || t.getType() !== i) return S.MAKE_PLAIN_BLOCK
								}
							}
						}
						return Object(s.getDefaultKeyBinding)(e)
					}, this.handleKeyCommand = e => {
						const {
							editorState: t
						} = this.state;
						let n = e,
							o = null;
						const r = e => {
							let t = e;
							if (o) {
								const {
									selection: e,
									url: n
								} = o;
								t = Object(ks.f)(t, e, n)
							}
							return this.onChange(t), this.isJustLinkified = !!o, ca
						};
						if (n === S.SUBMIT) this.props.onSubmit();
						else {
							if (n === S.CONVERT_TO_LIST_ON_SPACE) {
								const e = r(Js(t));
								return this.isJustConvertedToList = !0, e
							}
							if (n === S.LINKIFY_ON_SPACE) return o = Object(ks.d)(t), r(Object(bs.a)(t));
							if (n === S.LINKIFY_ON_ENTER && (o = Object(ks.d)(t), !(n = this.enterKeyBinding(t, !1)))) return r(Object(bs.d)(t))
						}
						if (n === S.OPEN_LINK_TOOLTIP) return this.onToolbarLinkButtonClick(), ca;
						if (n === S.MAKE_PLAIN_BLOCK) {
							return r(Object(bs.i)(w.n, t))
						}
						if (n === S.EXEC_TABLE_ON_ENTER_HANDLER) return r(this.tableOnEnterHandler.handle(t));
						const i = this.transforms[n];
						if (i) {
							const e = i(t);
							if (e) return r(e)
						}
						const a = s.RichUtils.handleKeyCommand(t, n);
						return a ? r(a) : la
					}, this.handleOnTab = e => {
						if (this.emotesTooltipApi && this.emotesTooltipApi.handleTabInEditor() || this.suggestionDropdownApi && this.suggestionDropdownApi.selectCurrent()) return void e.preventDefault();
						const {
							editorState: t
						} = this.state;
						let n = pn(e, t);
						if (n = n || Hs(e, t)) return void this.onChange(n);
						const o = s.RichUtils.onTab(e, t, 2);
						this.onChange(o)
					}, this.handleOnUpArrow = e => {
						if (this.emotesTooltipApi && this.emotesTooltipApi.handleUpArrowInEditor() || this.suggestionDropdownApi && this.suggestionDropdownApi.moveUp()) return void e.preventDefault();
						const t = mn(e, this.state.editorState) || Ie(e, this.state.editorState);
						t && this.onChange(t), this.needSyncScroll = Ti.Up
					}, this.handleOnDownArrow = e => {
						if (this.suggestionDropdownApi && this.suggestionDropdownApi.moveDown()) return void e.preventDefault();
						const t = hn(e, this.state.editorState) || Pe(e, this.state.editorState);
						t && this.onChange(t), this.needSyncScroll = Ti.Down
					}, this.handleReturn = e => {
						const t = ke(this.state.editorState);
						return t ? (this.onChange(t), e.preventDefault(), ca) : this.suggestionDropdownApi && this.suggestionDropdownApi.selectCurrent() ? (e.preventDefault(), ca) : la
					}, this.suppressAutocompleteForFocusedLink = () => {
						const e = Object(ks.b)(this.state.editorState);
						e && this.state.suppressAutocompleteForLink !== e.entityKey && this.setState({
							suppressAutocompleteForLink: e.entityKey
						})
					}, this.handleEscape = e => {
						this.emotesTooltipApi && this.emotesTooltipApi.handleEscapeKeyInEditor(), this.suppressAutocompleteForFocusedLink()
					}, this.handleOnCopy = e => {
						this.editorRef && ye(this.state.editorState, this.editorRef, e)
					}, this.handleOnCut = e => {
						const {
							editorState: t
						} = this.state;
						if (!this.editorRef) return;
						if (!ye(t, this.editorRef, e)) return;
						const n = re(t) || _e(t) || Object(N.e)(t);
						n && this.onChange(n)
					}, this.handleOnPaste = e => {
						const {
							editorState: t
						} = this.state;
						if (!this.editorRef) return;
						if (this.handleFilesPaste(e, t), e.isPropagationStopped()) return;
						const n = Lo(t, this.editorRef, e, this.props.editorType);
						n && this.onChange(n)
					}, this.handleFilesPaste = (e, t) => {
						const n = e.clipboardData.files;
						if (n && n.length) {
							const s = Array.from(n),
								o = t.getSelection().getEndKey();
							this.insertMediaFiles({
								files: s,
								blockKey: o,
								insertionMode: R.a.after,
								filesSource: x.FileSource.Clipboard
							}), e.stopPropagation()
						}
					}, this.handleOnMouseDown = e => {
						this.isMouseDown = !0
					}, this.handleOnMouseUp = e => {
						this.isMouseDown = !1
					}, this.handleDroppedFiles = (e, t) => ca, this.handleDrop = (e, t, n) => ca, this.handleBlur = () => {
						this.props.onBlur && this.props.onBlur()
					}, this.handlePastedText = (e, t) => ca, this.onInternalSuggestionSelected = e => {
						this.onChange(Object(ks.g)(this.state.editorState, e)), this.isJustAutocompleteSelected = !0
					}, this.onToolbarEmoteButtonClick = e => {
						this.gifTooltipApi && this.gifTooltipApi.closeTooltip(), this.emotesTooltipApi && this.emotesTooltipApi.toggleTooltip(e)
					}, this.onToolbarGifButtonClick = e => {
						this.emotesTooltipApi && this.emotesTooltipApi.closeTooltip(), this.gifTooltipApi && this.gifTooltipApi.toggleTooltip(e)
					}, this.onToolbarLinkButtonClick = () => {
						if (!this.linksControllerApi) return;
						const {
							editorState: e
						} = this.state;
						this.linksControllerApi.editLinkInSelection(e.getSelection()) || Object(g.b)(void 0, "Current selection cannot be edited by link editor!")
					}, this.handleSwitchToMarkdownMode = () => {
						const {
							editorState: e
						} = this.state, {
							onSwitchEditorMode: t
						} = this.props, n = br.a.toRichTextJSON(Object.assign(Object.assign({}, this.props.rteState), {
							isBound: !0,
							editorState: Object(N.c)(e)
						}));
						t && t(j.h.MARKDOWN, n), this.state.confirmModalOpen && this.toggleConfirmModal()
					}, this.onToolbarMarkdownSwitchClick = () => {
						const {
							editorState: e
						} = this.state;
						e && Ds(e) ? this.setState({
							confirmModalOpen: !0
						}) : this.handleSwitchToMarkdownMode()
					}, this.toggleConfirmModal = () => {
						this.setState({
							confirmModalOpen: !this.state.confirmModalOpen
						})
					}, this.insertMediaFiles = async e => {
						this.setState({
							mediaToInsert: e
						});
						const {
							files: t,
							filesSource: n
						} = e, s = t.slice(0, ua);
						await this.props.startUploads(s, n, this.props.rteState.editorKey), this.insertValidatedMedia()
					}, this.onRetryUpload = e => {
						this.props.retryUpload(e)
					}, this.onFilesSelect = e => {
						const {
							editorState: t
						} = this.state, n = t.getSelection().getEndKey();
						this.insertMediaFiles({
							files: e,
							blockKey: n,
							insertionMode: R.a.after,
							filesSource: x.FileSource.FileSelector
						})
					}, this.onFilesDrop = (e, t, n) => {
						this.props.onTrackMediaDrop(e), this.insertMediaFiles({
							files: e,
							blockKey: t,
							insertionMode: n,
							filesSource: x.FileSource.DragAndDrop
						})
					}, this.onBlockMove = (e, t, n) => {
						const {
							editorState: s
						} = this.state, o = Object(N.o)(s, e, t, n);
						o && this.onChange(o)
					}, this.getAtomicBlocksRenderConfig = () => ({
						component: tn,
						props: {
							getEditorState: this.getEditorState,
							onChange: this.onChange,
							onRetryUpload: this.onRetryUpload,
							rteFocusableContentRef: this.state.focusableContentRef,
							editorType: this.props.editorType
						}
					}), this.blockRendererFn = e => {
						const t = e.getType();
						return t === w.a ? this.getAtomicBlocksRenderConfig() : t in kr ? kr[t] : void 0
					}, this.renderToolbar = e => c.a.createElement(Ft.b, e), this.entityElementRegistry = gs(), this.tableOnEnterHandler = new bn;
					const {
						activeEmotes: t,
						editorType: n,
						noBorder: o,
						initialHeight: r,
						initialMinHeight: i,
						rteState: a
					} = e;
					let l;
					a.isBound ? l = a.editorState : Object(Kn.G)(a.initialRTJSON) ? l = this.createInitialState(a.editorKey) : (l = s.EditorState.createWithContent(Xi(a.initialRTJSON, n, a.mediaMetadataMap, t), this.editorDecorators()), l = this.moveSelectionToEnd(l)), this.state = {
						noBorder: o,
						containerRef: null,
						confirmModalOpen: !1,
						editorState: l,
						focusableContentRef: null,
						inited: !1,
						initialHeight: r,
						initialMinHeight: i,
						mediaToInsert: null,
						suppressAutocompleteForLink: null
					}
				}
				editorDecorators() {
					return new s.CompositeDecorator([js(), no(), Ns()])
				}
				moveSelectionToEnd(e) {
					const t = e.getCurrentContent().getBlockMap(),
						n = t.last().getKey(),
						o = t.last().getLength(),
						r = new s.SelectionState({
							anchorKey: n,
							anchorOffset: o,
							focusKey: n,
							focusOffset: o
						});
					return s.EditorState.acceptSelection(e, r)
				}
				createInitialState(e) {
					return s.EditorState.createWithContent(s.ContentState.createFromBlockArray([new s.ContentBlock({
						key: "".concat(e, "_initial")
					})]), this.editorDecorators())
				}
				componentDidMount() {
					if (this.props.rteRef && this.props.rteRef(this), h.a.write(Ir), this.rteStateChanged(this.state.editorState, !1), this.editorRef) {
						const e = this.editorRef.refs.editor;
						e.addEventListener("scroll", this.hideTooltips), this.editorRootStyleMutationObserver = new MutationObserver(this.onEditorStyleChanged), this.editorRootStyleMutationObserver.observe(e, {
							attributes: !0,
							attributeFilter: ["style"]
						})
					}
					const {
						destSubreddit: e,
						emotesSpecialMembershipEnabled: t,
						giphySpecialMembershipEnabled: n
					} = this.props;
					e && e.id && (t || n) && this.props.onFetchEditorProducts(e.id)
				}
				componentDidUpdate(e, t) {
					const n = this.getLinkForAutocomplete();
					if (n && this.updateSuggestionDropdownPosition) {
						const e = this.entityElementRegistry.get(n.entityKey);
						if (e) {
							const {
								left: t,
								bottom: n,
								height: s
							} = e.getBoundingClientRect();
							this.updateSuggestionDropdownPosition({
								left: t,
								top: n,
								bottom: n - s
							})
						}
					}
					this.needSyncScroll && (Mi(this.needSyncScroll), this.needSyncScroll = null)
				}
				componentWillUnmount() {
					if (this.props.rteRef && this.props.rteRef(null), this.insertValidatedMedia = () => {}, this.editorRef) {
						this.editorRef.refs.editor.removeEventListener("scroll", this.hideTooltips)
					}
					this.editorRootStyleMutationObserver && (this.editorRootStyleMutationObserver.disconnect(), this.editorRootStyleMutationObserver = null)
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.rteState !== this.props.rteState && e.rteState.isBound && e.rteState.editorState !== this.state.editorState && this.setState({
						editorState: e.rteState.editorState
					})
				}
				shouldComponentUpdate(e, t) {
					if (t !== this.state) return !0;
					if (!(e.rteState.isBound && e.rteState.editorState === this.state.editorState)) return !0;
					return !p()(e, this.props, (e, t, n) => "rteState" === n || void 0)
				}
				enterKeyBinding(e) {
					let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					const n = e.getCurrentContent(),
						s = e.getSelection(),
						o = s.getStartKey(),
						r = s.getEndKey(),
						i = s.getEndOffset(),
						a = n.getBlockForKey(o).getType(),
						c = n.getBlockForKey(r),
						l = c.getType(),
						d = i === c.getText().length;
					if (a === w.l || l === w.l) return S.EXEC_TABLE_ON_ENTER_HANDLER;
					if (s.isCollapsed()) {
						if (t && Object(ks.d)(e)) return S.LINKIFY_ON_ENTER;
						if (Object(w.r)(l) && d) return S.BREAK_HEADER_ENTITY;
						if (Object(w.s)(l)) {
							if (da.test(c.getText())) return c.getDepth() > 0 ? S.REDUCE_LIST_INDENT : S.REMOVE_EXTRA_LIST_ITEM
						} else if (l === w.e) {
							const e = n.getBlockBefore(r);
							if (e && e.getType() === w.e && da.test(e.getText()) && da.test(c.getText())) return S.RESET_CURRENT_AND_PREVIOUS_BLOCKS
						} else if (l === w.f) {
							const e = n.getBlockBefore(r),
								t = n.getBlockAfter(r);
							if (!c.getText() && e && e.getType() === w.f && !e.getText() && (!t || t.getType() !== w.f)) return S.RESET_CURRENT_AND_PREVIOUS_BLOCKS
						}
					}
				}
				getLinkForAutocomplete() {
					const {
						editorState: e,
						suppressAutocompleteForLink: t
					} = this.state;
					if (!this.isJustAutocompleteSelected && e.getSelection().getHasFocus()) {
						const n = Object(ks.b)(e);
						if (n && n.entityKey !== t) return n
					}
				}
				renderInternalLinkSuggestionDropdown() {
					const {
						isChatPost: e
					} = this.props, t = this.getLinkForAutocomplete();
					return t ? c.a.createElement(Ln.b, {
						aboveParent: e,
						dropdown: !0,
						onSetPositionUpdater: this.setSuggestionDropdownPositionUpdater
					}, t.entityText.startsWith(f.f) && c.a.createElement(Qr, {
						onDropdownApi: this.setSuggestionDropdownApi,
						onSelect: this.onInternalSuggestionSelected,
						substring: t.internalName
					}), f.a.test(t.entityText) && c.a.createElement($r, {
						onDropdownApi: this.setSuggestionDropdownApi,
						onSelect: this.onInternalSuggestionSelected,
						substring: t.internalName
					})) : null
				}
				render() {
					const {
						className: e,
						activeEmotes: t,
						userCanUseGifs: n,
						allowMediaUploads: r = !1,
						dataTestId: i,
						destSubreddit: a,
						editorType: l,
						emotesPowerupBenefitUnlocked: d,
						emotesSpecialMembershipEnabled: u,
						focusableContentRTEClassName: p,
						giphyPowerupBenefitEnabledUnlocked: h,
						giphySpecialMembershipEnabled: b,
						hideToolbar: f,
						rteState: g,
						isExpanded: x,
						isOverlay: y,
						isCommentBoxDesignEnabled: v,
						onSubmit: C,
						placeholderText: E,
						showSubmitButton: O = !1,
						submitButtonClassName: j,
						toolbarPosition: w = "top",
						renderToolbar: S = this.renderToolbar
					} = this.props, {
						editorKey: k
					} = g, {
						containerRef: I,
						editorState: P,
						mediaToInsert: M,
						confirmModalOpen: N
					} = this.state, R = this.props.readOnly || !!M, L = _(P), A = this.isEmpty(), F = !(!t || !Object.keys(t).length), D = (u || d) && F, B = b || h, U = S({
						allowMediaUploads: r,
						destSubreddit: a,
						editorKey: k,
						editorState: P,
						isOverlay: !!y,
						onChange: this.toolbarSetState,
						onFilesSelect: this.onFilesSelect,
						trackOnClick: this.props.trackToolbarClick,
						readOnly: R,
						onEmoteButtonClick: D ? this.onToolbarEmoteButtonClick : void 0,
						onGifButtonClick: B ? this.onToolbarGifButtonClick : void 0,
						onLinkButtonClick: this.onToolbarLinkButtonClick,
						onMarkdownButtonClick: this.onToolbarMarkdownSwitchClick,
						userCanUseGifs: !!n
					}), K = !f && (!v || x);
					return c.a.createElement(ma, {
						className: e,
						innerRef: this.setContainerRef
					}, v && c.a.createElement("div", {
						className: ia.a.userIcon
					}, c.a.createElement(ha, null)), c.a.createElement(pa, {
						className: Object(m.a)(p, {
							[ia.a.showSubmitButton]: O,
							[ia.a.mExpanded]: x,
							[ia.a.mRedesign]: v
						}),
						noBorder: this.props.noBorder,
						isFocused: this.isFocused(),
						ref: this.setFocusableContentRef
					}, K && "top" === w && U, I && c.a.createElement(hs, {
						editorState: P,
						readOnly: R,
						onChange: this.onChange,
						onSetApi: this.setTableToolbarControllerApi,
						rteDomRef: I
					}), c.a.createElement("div", {
						className: Object(m.a)(ia.a.editorWrapper, {
							[ia.a.hasInitialHeight]: !!this.props.initialHeight,
							[ia.a.hasInitialMinHeight]: !!this.props.initialMinHeight,
							[ia.a.noBorder]: !!this.props.noBorder
						}),
						style: {
							"--rte-initial-height": this.props.initialHeight ? "".concat(this.props.initialHeight, "px") : void 0,
							"--rte-initial-min-height": this.props.initialMinHeight ? "".concat(this.props.initialMinHeight, "px") : void 0
						},
						"data-test-id": i,
						onCopyCapture: this.handleOnCopy,
						onCutCapture: this.handleOnCut,
						onPasteCapture: this.handleOnPaste,
						onMouseDown: this.handleOnMouseDown,
						onMouseUp: this.handleOnMouseUp
					}, c.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: "\n                .".concat(ea.b, "[").concat(ea.d, '="').concat(L, "-0-0\"]::after {\n                  bottom: 0;\n                  color: var(--newCommunityTheme-actionIcon);\n                  content: '").concat(E, "';\n                  cursor: text;\n                  left: 0;\n                  position: absolute;\n                  top: 0;\n                }\n              ")
						}
					}), c.a.createElement(Eo, {
						allowMediaUploads: r && !R,
						onBlockMove: this.onBlockMove,
						onFilesDrop: this.onFilesDrop,
						editorState: P,
						onChange: this.onChange
					}, c.a.createElement(xs.Provider, {
						value: this.entityElementRegistry
					}, c.a.createElement(s.Editor, {
						readOnly: R,
						ref: this.setEditorRef,
						blockRendererFn: this.blockRendererFn,
						blockRenderMap: this.blockRenderMap,
						editorKey: k,
						editorState: P,
						keyBindingFn: this.keyBindingFN,
						handleBeforeInput: this.handleBeforeInput,
						handleKeyCommand: this.handleKeyCommand,
						handlePastedText: this.handlePastedText,
						handleDroppedFiles: this.handleDroppedFiles,
						handleDrop: this.handleDrop,
						onBlur: this.handleBlur,
						onChange: this.onChange,
						onFocus: this.onFocus,
						onTab: this.handleOnTab,
						onUpArrow: this.handleOnUpArrow,
						onDownArrow: this.handleOnDownArrow,
						onEscape: this.handleEscape,
						spellCheck: !0,
						handleReturn: this.handleReturn,
						customStyleMap: vr()
					})))), K && "bottom" === w && U, c.a.createElement(ir, {
						editorState: P,
						entityElementRegistry: this.entityElementRegistry,
						onSetApi: this.setLinksControllerApi,
						onChange: this.onChange
					}), D && !!a && l === Be.a.Comment && c.a.createElement(Ss, {
						editorState: P,
						onChange: this.onChange,
						onSetApi: this.setEmotesTooltipApi,
						subreddit: a,
						shouldHideAddEmote: !u
					}), B && a && c.a.createElement(Ys, {
						editorState: P,
						onChange: this.onChange,
						onSetApi: this.setGifTooltipApi,
						subreddit: a,
						userCanUseGifs: !!n
					}), this.renderInternalLinkSuggestionDropdown(), O && c.a.createElement($e.a, {
						"aria-label": o.fbt._("submit", null, {
							hk: "12XoZ8"
						}),
						className: Object(m.a)(j, ia.a.insetSubmitButton, {
							[ia.a.emptyContent]: A,
							[ia.a.focusedContent]: this.isFocused()
						}),
						disabled: A,
						onClick: C,
						tabIndex: -1,
						type: "submit"
					}, c.a.createElement(na.a, null))), N && c.a.createElement(T.a, {
						toggleModal: this.toggleConfirmModal,
						onConfirm: this.handleSwitchToMarkdownMode,
						actionText: o.fbt._("Continue", null, {
							hk: "3aoEeD"
						}),
						cancelActionText: o.fbt._("Cancel", null, {
							hk: "2TSLl5"
						}),
						headerText: o.fbt._("Switch to Markdown", null, {
							hk: "3zGkKa"
						}),
						modalText: o.fbt._("Switching to markdown will remove any images, gifs or videos from your post.", null, {
							hk: "3rlwkB"
						}),
						trackClick: () => {}
					}))
				}
			}
			t.a = fa(Object(Lr.b)(e => c.a.createElement(ga, aa({
				key: e.rteState.editorKey
			}, e))))
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/ImagePreview/index.m.less": function(e, t, n) {
			e.exports = {
				Img: "_1gJwMe53cjYITkMu0Ve8j-",
				img: "_1gJwMe53cjYITkMu0Ve8j-",
				Component: "_3VYFd7PKhTJ-0i22YsgFPv",
				component: "_3VYFd7PKhTJ-0i22YsgFPv"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/Placeholder/index.m.less": function(e, t, n) {
			e.exports = {
				Message: "_3cyJHYsdZdz4RWdmrzyYx-",
				message: "_3cyJHYsdZdz4RWdmrzyYx-",
				Component: "_3JSUHg1gLhxUj4PB_Pgw8a",
				component: "_3JSUHg1gLhxUj4PB_Pgw8a"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/StatusBar/index.m.less": function(e, t, n) {
			e.exports = {
				buttonBaseStyles: "_3R1ajPuzbs2MdbXedj3YXU",
				ControlRow: "_1rrSEjTxZcLOZTDNZlj5N4",
				controlRow: "_1rrSEjTxZcLOZTDNZlj5N4",
				Button: "_2rIEdliEXr7qNb-COL-zuO",
				button: "_2rIEdliEXr7qNb-COL-zuO",
				ErrButton: "_3CUr1530H3uD-ts9tKd9RA",
				errButton: "_3CUr1530H3uD-ts9tKd9RA",
				Status: "jXuqxr-x0kyU3BSfugjwM",
				status: "jXuqxr-x0kyU3BSfugjwM",
				hasError: "_4XwI6tILia1pR9HTda4wv",
				ProgressBar: "_1NvtB5J5UfhiHd0ix7TZgb",
				progressBar: "_1NvtB5J5UfhiHd0ix7TZgb",
				ProgressBarInner: "_29o2WRRYmrLU47NaFzQzxq",
				progressBarInner: "_29o2WRRYmrLU47NaFzQzxq",
				ErrorLine: "_3M-thbkBHHvsWjDt8edbhz",
				errorLine: "_3M-thbkBHHvsWjDt8edbhz",
				Component: "_1CqupI5I-zzAInIdLwphQg",
				component: "_1CqupI5I-zzAInIdLwphQg"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/VideoPreview/index.m.less": function(e, t, n) {
			e.exports = {
				VideoPlayer: "_3gstD1_YUjNWZqjtwdgU9t",
				videoPlayer: "_3gstD1_YUjNWZqjtwdgU9t",
				PosterImg: "_2C2yx7Rf_BKPOyll-aq_hI",
				posterImg: "_2C2yx7Rf_BKPOyll-aq_hI",
				Poster: "_1UCJLqzcYXck8Ahv0PlvVw",
				poster: "_1UCJLqzcYXck8Ahv0PlvVw",
				Component: "wSihDBKVJH6iP2jdDjRQ6",
				component: "wSihDBKVJH6iP2jdDjRQ6",
				playButton: "il4HPAfKcVtq-WQY-if85"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/MediaView/index.m.less": function(e, t, n) {
			e.exports = {
				statusBar: "_33CSkXq7gXeXCM2zSal9BN",
				container: "_1FMEfWD94pPZ_HdEN_e7Xy",
				isCompact: "_3-T8BPflZuKw_F2VRPDbcX",
				isUploaded: "_3Lj2c902Oeb7yL_jYu9v5L",
				isSelected: "Eaps2a9y_jwhKHth8v14G",
				imagePreview: "_2nlrFrYbO0bIKFeZ3HMbn_",
				placeholder: "_1-LSy7nvfNGWVhRWwwQu6A",
				videoPreview: "_2MumquPHY8gruoy6114twC",
				alignCenter: "_3U9f0TNBM1K2bggm3KMHTk"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/SelectionHook/index.m.less": function(e, t, n) {
			e.exports = {
				HiddenDiv: "_13RYjdyxMuKrkV_EtlOjhg",
				hiddenDiv: "_13RYjdyxMuKrkV_EtlOjhg"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/Toolbar/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3hDtN0e5U4EpahGe25ye-b",
				alignCenter: "Vh7FGvkGyl5SeyJP4J1GG",
				content: "_3wXzBVn-uBvRcixZwQWkNX",
				FormatterButton: "_6DRydZXlG3Ko7_4xxYUhW",
				formatterButton: "_6DRydZXlG3Ko7_4xxYUhW",
				ToolbarContent: "_3qUkCQkbZvTB6uBQEQQfSZ",
				toolbarContent: "_3qUkCQkbZvTB6uBQEQQfSZ"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaBlock/index.m.less": function(e, t, n) {
			e.exports = {
				MediaContainer: "_12ZUhulrgf1BAChnRZHmZt",
				mediaContainer: "_12ZUhulrgf1BAChnRZHmZt",
				Container: "DK9d46mm9FgC8mFWPGlG_",
				container: "DK9d46mm9FgC8mFWPGlG_"
			}
		},
		"./src/reddit/components/RichTextEditor/media/MediaCaption/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2eZK2IABgFqGZLMYPxwoNY"
			}
		},
		"./src/reddit/components/RichTextEditor/media/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "r", (function() {
				return y
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return S
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "m", (function() {
				return T
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "j", (function() {
				return P
			})), n.d(t, "i", (function() {
				return M
			})), n.d(t, "o", (function() {
				return N
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "f", (function() {
				return A
			}));
			var s, o = n("./node_modules/draft-js/lib/Draft.js"),
				r = n("./node_modules/immutable/dist/immutable.js"),
				i = n("./node_modules/lodash/flatten.js"),
				a = n.n(i),
				c = n("./node_modules/lodash/last.js"),
				l = n.n(c),
				d = n("./src/reddit/helpers/media/index.ts"),
				u = n("./src/reddit/helpers/richTextEditor/index.ts"),
				p = n("./src/reddit/helpers/richTextJson/index.ts"),
				m = n("./src/reddit/models/Upload/index.ts"),
				h = n("./src/reddit/components/RichTextEditor/constants/editorChangeTypes.ts"),
				b = n("./src/reddit/components/RichTextEditor/helpers/common.ts"),
				f = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			! function(e) {
				e[e.Image = 0] = "Image", e[e.AnimatedImage = 1] = "AnimatedImage", e[e.Video = 2] = "Video"
			}(s || (s = {}));
			const g = e => e !== u.a.Comment,
				x = e => {
					if (!Object(f.o)(e.getType())) return;
					const t = e.getData(),
						n = t.get("mediaAsset"),
						s = t.get("uploadInfo");
					if (!n && !s) return;
					const o = t.get("thumbnail");
					return {
						makeGif: t.get("makeGif"),
						thumbnail: o,
						uploadInfo: s,
						mediaAsset: n
					}
				},
				y = (e, t, n) => {
					let s = e.getCurrentContent();
					const i = s.getBlockForKey(t),
						a = x(i),
						c = a && a.uploadInfo;
					if (!c) throw new Error("Block must contain `uploadInfo` data");
					if (n.makeGif === a.makeGif && n.thumbnail === a.thumbnail) return e;
					const l = Object(r.Map)(n),
						d = s.getBlockMap().toKeyedSeq().filter(e => {
							const t = x(e);
							return !!t && !!t.uploadInfo && t.uploadInfo.uploadKey === c.uploadKey
						}).map(e => e.mergeIn(["data"], l));
					return s = (s = s.mergeIn(["blockMap"], d)).merge({
						selectionAfter: e.getSelection()
					}), o.EditorState.push(e, s, h.b)
				},
				v = (e, t, n, s) => {
					let i = e.getCurrentContent();
					const c = a()(t.map(e => {
						const t = Object(d.f)(e.metadata.mimetype),
							n = (e => {
								if (e && e.metadata.videoFirstFrameUrl) {
									return {
										url: e.metadata.videoFirstFrameUrl,
										time: 0
									}
								}
							})(e);
						return [new o.ContentBlock({
							key: Object(o.genKey)(),
							type: f.a,
							data: Object(r.Map)({
								uploadInfo: {
									mediaType: t,
									uploadKey: e.key
								},
								thumbnail: n
							})
						}), new o.ContentBlock({
							key: Object(o.genKey)(),
							type: f.j
						})]
					}));
					i = Object(b.f)(i, n, c, s);
					const u = o.EditorState.push(e, i, h.e),
						p = l()(c);
					return o.EditorState.forceSelection(u, Object(b.b)(p, !0))
				},
				C = (e, t, n, i, a, c, l, d) => {
					const u = new o.ContentBlock({
							key: Object(o.genKey)(),
							type: f.a,
							data: Object(r.Map)({
								mediaAsset: {
									type: s.AnimatedImage,
									assetId: Object(p.b)(t, i),
									imageUrl: n,
									width: a,
									height: c
								}
							})
						}),
						m = Object(b.f)(e.getCurrentContent(), l, [u], d);
					let g = o.EditorState.push(e, m, h.e);
					g = o.EditorState.forceSelection(g, Object(b.b)(u, !0));
					const x = u.getKey();
					return g.getCurrentContent().getBlockAfter(x) || (g = R(g, x)), g
				};

			function E(e, t) {
				return e.isCollapsed() && e.getStartKey() === t && 0 === e.getStartOffset() && 0 === e.getEndOffset()
			}

			function O(e, t) {
				const n = e.getCurrentContent().getBlockAfter(t);
				return o.EditorState.forceSelection(e, Object(b.b)(n, !0))
			}
			const j = (e, t) => {
					const n = e.getBlockAfter(t);
					return e = Object(b.i)(e, t), n && Object(f.u)(n.getType()) && (e = Object(b.i)(e, n.getKey())), e
				},
				w = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
						s = e.getCurrentContent();
					s = j(s, t);
					let r = n ? o.EditorState.push(e, s, h.f) : o.EditorState.set(e, {
						currentContent: s
					});
					return r = o.EditorState.forceSelection(r, s.getSelectionAfter())
				},
				S = e => {
					let t = e.getCurrentContent();
					k(t).forEach(e => {
						t = j(t, e.getKey())
					});
					const n = o.EditorState.push(e, t, h.f);
					return o.EditorState.forceSelection(n, t.getSelectionAfter())
				},
				_ = e => {
					let t = e.getCurrentContent();
					const n = e.getSelection();
					t = o.Modifier.removeRange(t, n, "forward");
					let s = o.EditorState.push(e, t, h.f);
					return s = o.EditorState.forceSelection(s, t.getSelectionAfter())
				},
				k = e => e.getBlockMap().toSeq().filter(e => !!e && !!x(e)),
				T = (e, t) => e.getBlockMap().toSeq().filter(e => {
					const n = x(e),
						s = n && n.uploadInfo && n.uploadInfo.uploadKey;
					return !(!s || t[s] && t[s].url)
				}).isEmpty(),
				I = e => {
					const t = k(e),
						n = {
							gifvideo: 0,
							image: 0,
							video: 0,
							total: 0
						};
					return t.forEach(e => {
						const t = x(e);
						let o;
						o = t.makeGif ? "gifvideo" : t.uploadInfo && "video" === t.uploadInfo.mediaType || t.mediaAsset && t.mediaAsset.type === s.Video ? "video" : "image", n[o]++, n.total++
					}), n
				},
				P = e => !k(e).isEmpty(),
				M = (e, t) => {
					const n = k(e).map(e => {
						const n = x(e),
							{
								uploadInfo: s,
								thumbnail: o
							} = n;
						if (!s || !o) return;
						const r = L(n),
							i = t[r];
						return i && i.url ? void 0 : Object.assign(Object.assign({}, o), {
							uploadKey: r
						})
					}).filter(Boolean).toArray();
					return n.length ? n : void 0
				},
				N = (e, t, n, s) => {
					let r = e.getCurrentContent();
					const i = r.getBlockForKey(t),
						a = r.getBlockAfter(t),
						c = [i];
					if (a && Object(f.u)(a.getType()) && c.push(a), c.find(e => e.getKey() === n)) return;
					const d = c.reduce((e, t) => e.remove(t.getKey()), r.getBlockMap());
					r = r.set("blockMap", d), r = Object(b.f)(r, n, c, s);
					const u = o.EditorState.push(e, r, h.e);
					return o.EditorState.forceSelection(u, Object(b.b)(l()(c), !0))
				},
				R = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : b.a.after;
					const s = Object(b.h)(),
						r = Object(b.f)(e.getCurrentContent(), t, [s], n),
						i = o.EditorState.push(e, r, h.e);
					return o.EditorState.forceSelection(i, o.SelectionState.createEmpty(s.getKey()))
				},
				L = e => e.thumbnail && e.uploadInfo ? "".concat(e.uploadInfo.uploadKey, "-thumbnail-").concat(e.thumbnail.time) : "",
				A = (e, t) => {
					let n = "",
						s = "";
					if (e.uploadInfo) {
						const {
							uploadKey: o
						} = e.uploadInfo, r = t[o];
						r && r.url && (n = Object(m.b)(r.url));
						const i = t[L(e)];
						i && i.url && (s = Object(m.b)(i.url))
					}
					return {
						assetId: n,
						thumbnailAssetId: s
					}
				}
		},
		"./src/reddit/components/RichTextEditor/spoiler/decorator.m.less": function(e, t, n) {
			e.exports = {
				spoiler: "_1AlhnBqYYVTQbTr33YViyK"
			}
		},
		"./src/reddit/components/RichTextEditor/spoiler/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/forEachGroup/index.ts"),
				o = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const r = e => e.getStyle().has(o.k.SPOILER);

			function i(e, t, n) {
				const o = e.getCharacterList();
				Object(s.a)(o, {
					keyFn: r
				}, (e, n, s, o) => {
					n && t(s, o)
				})
			}
		},
		"./src/reddit/components/RichTextEditor/table/Renderer/index.m.less": function(e, t, n) {
			e.exports = {
				Cell: "_1J5sneEp0XXo0pFsMN7Kjs",
				cell: "_1J5sneEp0XXo0pFsMN7Kjs",
				Row: "_2Hd-Rc7z9gTKIz6JUGhbcl",
				row: "_2Hd-Rc7z9gTKIz6JUGhbcl",
				Table: "_9QFGu47IyMX1ID1xQid-8",
				table: "_9QFGu47IyMX1ID1xQid-8",
				isFakeSelectionActive: "_1QXaG0_iXh-LFDkah9HqP3"
			}
		},
		"./src/reddit/components/RichTextEditor/table/Toolbar/index.m.less": function(e, t, n) {
			e.exports = {
				formatterButton: "_1dNavKEU0lSO4mo9fYWTPm",
				ToolbarContent: "_1yPmb5QUbyAQX1wIs4FYQI",
				toolbarContent: "_1yPmb5QUbyAQX1wIs4FYQI",
				tooltip: "_3fnB5glctifL-mkYhH6aA1"
			}
		},
		"./src/reddit/components/RichTextEditor/table/ToolbarController/index.m.less": function(e, t, n) {
			e.exports = {
				ActionButton: "_2g2bsszGVtKe_XRKcRrpQi",
				actionButton: "_2g2bsszGVtKe_XRKcRrpQi",
				isPressed: "_2WwwYG59S_TJRq7FSdTVKK",
				ToolbarWrapper: "_3rXrpMuvoGNBbLE7TQQCB9",
				toolbarWrapper: "_3rXrpMuvoGNBbLE7TQQCB9"
			}
		},
		"./src/reddit/components/RichTextEditor/table/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "o", (function() {
				return E
			})), n.d(t, "d", (function() {
				return O
			}));
			var s = n("./node_modules/draft-js/lib/Draft.js"),
				o = n("./node_modules/immutable/dist/immutable.js"),
				r = n("./src/reddit/models/RichTextJson/index.ts"),
				i = n("./src/reddit/components/RichTextEditor/helpers/sliceContiguousBlocks.ts"),
				a = n("./src/reddit/components/RichTextEditor/styleAndBlockTypes.ts");
			const c = {
					[r.e]: "left",
					[r.f]: "right",
					[r.d]: "center"
				},
				l = e => {
					const t = e.getData();
					return {
						colIndex: t.get("colIndex"),
						rowIndex: t.get("rowIndex"),
						colCount: t.get("colCount"),
						alignment: t.get("alignment")
					}
				},
				d = ["data"],
				u = (e, t) => e.mergeIn(d, t),
				p = (e, t, n) => e.merge({
					text: e.getText().slice(t, n),
					characterList: e.getCharacterList().slice(t, n)
				}),
				m = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
						o = arguments.length > 3 ? arguments[3] : void 0;
					const r = t.map(e => e.getText()).join(n),
						i = n ? o || s.CharacterMetadata.create() : null,
						a = [];
					return t.forEach(e => {
						a.push(...e.getCharacterList().toArray()), i && t.length > 1 && a.push(i)
					}), e.merge({
						text: r,
						characterList: a
					})
				},
				h = (e, t) => {
					const n = [];
					for (let r = 0; r < t; r++)
						for (let t = 0; t < e; t++) n.push(new s.ContentBlock({
							key: Object(s.genKey)(),
							type: a.l,
							data: Object(o.Map)({
								colCount: e,
								colIndex: t,
								rowIndex: r
							})
						}));
					return n
				},
				b = (e, t) => ({
					minCol: Math.min(e.colIndex, t.colIndex),
					minRow: Math.min(e.rowIndex, t.rowIndex),
					maxCol: Math.max(e.colIndex, t.colIndex),
					maxRow: Math.max(e.rowIndex, t.rowIndex)
				}),
				f = (e, t) => {
					const {
						minCol: n,
						minRow: s,
						maxCol: o,
						maxRow: r
					} = b(e, t);
					return (e, t) => s <= e && e <= r && n <= t && t <= o
				},
				g = (e, t) => e.rowIndex < t.rowIndex ? -1 : e.rowIndex > t.rowIndex ? 1 : e.colIndex - t.colIndex,
				x = (e, t) => e === t || !(!e || !t) && 0 === g(e, t),
				y = (e, t) => g(l(e), l(t)),
				v = e => {
					if (Object(a.v)(e.getType())) {
						return 0 === l(e).rowIndex
					}
					return !1
				},
				C = (e, t, n) => {
					const s = (t, n) => {
						if (t) {
							const s = Object(i.a)(e, t);
							return s && n && -1 !== s.blocks.indexOf(n) ? [s, s] : [s, n ? Object(i.a)(e, n) : null]
						}
						return n ? s(n, null).reverse() : [null, null]
					};
					return s(Object(a.v)(t.getType()) ? t : null, Object(a.v)(n.getType()) ? n : null)
				},
				E = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					const o = {
						isBackward: s
					};
					return t && (o.anchorKey = t.getKey(), o.anchorOffset = s ? t.getLength() : 0), n && (o.focusKey = n.getKey(), o.focusOffset = s ? 0 : n.getLength()), e.merge(o)
				},
				O = e => {
					if (!e.length) return [];
					const t = e[0].length;
					return e.map((e, n) => e.map((e, s) => u(e, {
						rowIndex: n,
						colIndex: s,
						colCount: t
					})))
				}
		},
		"./src/reddit/components/SEOTitle/index.m.less": function(e, t, n) {
			e.exports = {
				Title: "_eYtD2XCVieq6emjKBH3m",
				title: "_eYtD2XCVieq6emjKBH3m"
			}
		},
		"./src/reddit/components/SEOTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, o, r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js");
			! function(e) {
				e[e.Collection = 0] = "Collection", e[e.HeaderSelector = 1] = "HeaderSelector", e[e.PostComments = 2] = "PostComments", e[e.PostItem = 3] = "PostItem", e[e.TopicHeader = 4] = "TopicHeader", e[e.Widget = 5] = "Widget"
			}(s || (s = {})),
			function(e) {
				e[e.H1 = 1] = "H1", e[e.H2 = 2] = "H2", e[e.H3 = 3] = "H3", e[e.H4 = 4] = "H4", e[e.H5 = 5] = "H5", e[e.H6 = 6] = "H6"
			}(o || (o = {}));
			var l = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/helpers/postCollection.ts");
			const u = [l.Bb.COMMENTS, l.Bb.COLLECTION_COMMENTS],
				p = (e, t) => {
					if (!e) return [];
					const n = u.includes(e),
						o = e === l.Bb.COLLECTION_COMMENTS || t && Object(d.a)(t),
						r = l.N.has(e),
						i = l.sb.has(e),
						a = e === l.Bb.SUBREDDIT,
						c = e === l.Bb.TOPIC;
					let p, m, h;
					return r && !a || i ? p = s.HeaderSelector : o ? p = s.Collection : n ? p = s.PostComments : c && (p = s.TopicHeader), (r || i || o || n) && (m = s.Widget), (r || n) && (h = s.PostItem), [p, m, h]
				};
			var m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/selectors/platform.ts"),
				b = n("./src/reddit/components/SEOTitle/index.m.less"),
				f = n.n(b);
			const g = e => {
					let {
						level: t,
						children: n
					} = e;
					const s = "h".concat(t);
					return i.a.createElement(s, {
						className: f.a.Title
					}, n)
				},
				x = Object(m.t)(),
				y = Object(a.b)(() => Object(c.a)((e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && Object(h.n)(e, {
						page: n
					})
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && n.meta && n.meta.name
				}, (e, t) => {
					let {
						type: n
					} = t;
					return n
				}, (e, t, n) => ({
					level: p(t, e).indexOf(n) + 1 || void 0
				})));
			class v extends i.a.Component {
				render() {
					const {
						children: e,
						level: t
					} = this.props;
					return t ? i.a.createElement(g, {
						level: t
					}, e) : i.a.createElement(i.a.Fragment, null, e)
				}
			}
			t.b = x(y(v))
		},
		"./src/reddit/components/ScheduledPost/PostSchedulePickerModal/loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-ScheduledPost-PostSchedulePickerModal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ScheduledPost-PostSchedulePickerModal").then(n.bind(null, "./src/reddit/components/ScheduledPost/PostSchedulePickerModal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ScheduledPost/PostSchedulePickerModal/index.tsx"
				}
			})
		},
		"./src/reddit/components/SidebarFooter/index.m.less": function(e, t, n) {
			e.exports = {
				Widget: "_2wqyhtudP4weVGsZdVXJgt",
				widget: "_2wqyhtudP4weVGsZdVXJgt",
				LinkContainer: "_1KrMye71CT332tKKKUWAj6",
				linkContainer: "_1KrMye71CT332tKKKUWAj6",
				Column: "_3f2nSSsPBqVDV6Sz82qgrR",
				column: "_3f2nSSsPBqVDV6Sz82qgrR",
				Link: "_3Eyh3vRo5o4IfzVZXhaWAG",
				link: "_3Eyh3vRo5o4IfzVZXhaWAG",
				Copyright: "_34dh2eyzMvJfjCBLeoWiDD",
				copyright: "_34dh2eyzMvJfjCBLeoWiDD"
			}
		},
		"./src/reddit/components/SidebarFooter/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/Widgets/ThemedWidget/index.tsx"),
				a = n("./src/reddit/contexts/PageLayer/index.tsx"),
				c = n("./src/reddit/components/SidebarFooter/index.m.less"),
				l = n.n(c);
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js"), u = r.a.a("Link", l.a), p = Object(a.t)({
				isFrontpage: a.y
			});
			t.a = p(e => o.a.createElement(i.a, {
				className: l.a.Widget,
				redditStyle: e.redditStyle,
				contentOnly: !0
			}, o.a.createElement("div", {
				className: l.a.LinkContainer
			}, o.a.createElement("div", {
				className: l.a.Column
			}, o.a.createElement(u, {
				href: "https://www.reddithelp.com"
			}, d._("help", null, {
				hk: "4lyYaD"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/mobile/download"
			}, d._("Reddit App", null, {
				hk: "1ehrjP"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/coins"
			}, d._("Reddit coins", null, {
				hk: "32iMaN"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/premium"
			}, d._("Reddit premium", null, {
				hk: "RuO3A"
			})), o.a.createElement(u, {
				href: "https://redditgifts.com/"
			}, d._("Reddit gifts", null, {
				hk: "2XziRN"
			})), e.isFrontpage && o.a.createElement(o.a.Fragment, null, o.a.createElement(u, {
				href: "https://www.reddit.com/subreddits/a-1/"
			}, d._("Communities", null, {
				hk: "3CJu37"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/posts/a-1/"
			}, d._("Top Posts", null, {
				hk: "2NOEW2"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/topics/a-1/"
			}, d._("Topics", null, {
				hk: "349RFt"
			})))), o.a.createElement("div", {
				className: l.a.Column
			}, o.a.createElement(u, {
				href: "https://about.reddit.com"
			}, d._("about", null, {
				hk: "1sqJKs"
			})), o.a.createElement(u, {
				href: "https://about.reddit.com/careers/"
			}, d._("careers", null, {
				hk: "26ABvc"
			})), o.a.createElement(u, {
				href: "https://about.reddit.com/press/"
			}, d._("press", null, {
				hk: "2Qmgdz"
			})), o.a.createElement(u, {
				href: "https://www.redditinc.com/advertising"
			}, d._("advertise", null, {
				hk: "Mt40U"
			})), o.a.createElement(u, {
				href: "http://www.redditblog.com/"
			}, d._("blog", null, {
				hk: "46IQJw"
			})), o.a.createElement(u, {
				href: "https://www.redditinc.com/policies/user-agreement"
			}, d._("Terms", null, {
				hk: "4qRzfE"
			})), o.a.createElement(u, {
				href: "https://www.redditinc.com/policies/content-policy"
			}, d._("Content policy", null, {
				hk: "1DyxZS"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/help/privacypolicy"
			}, d._("Privacy policy", null, {
				hk: "10K04G"
			})), o.a.createElement(u, {
				href: "https://www.reddit.com/help/healthycommunities/"
			}, d._("Mod policy", null, {
				hk: "2gYc2T"
			})))), o.a.createElement("div", {
				className: l.a.Copyright
			}, d._("Reddit Inc © {year}. All rights reserved", [d._param("year", (new Date).getFullYear().toString())], {
				hk: "4BrCkA"
			}))))
		},
		"./src/reddit/components/SidebarSpacer/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2vEf-C2keJaBMY9qk_BxVn",
				component: "_2vEf-C2keJaBMY9qk_BxVn"
			}
		},
		"./src/reddit/components/SidebarSpacer/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/SidebarSpacer/index.m.less"),
				o = n.n(s),
				r = n("./src/lib/lessComponent.tsx");
			t.a = r.a.div("Component", o.a)
		},
		"./src/reddit/components/SourceLink/index.m.less": function(e, t, n) {
			e.exports = {
				OutboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				outboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				SourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				sourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				"m-comment": "_1-PD0_zreH-KVwpFoCLvQF",
				mComment: "_1-PD0_zreH-KVwpFoCLvQF"
			}
		},
		"./src/reddit/components/SourceLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/getShortenedLink.ts"),
				a = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				c = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				l = n("./src/reddit/components/SourceLink/index.m.less"),
				d = n.n(l),
				u = n("./src/lib/lessComponent.tsx");
			const p = u.a.wrapped(c.a, "OutboundLinkIcon", d.a),
				m = u.a.div("SourceLinkWrapper", d.a);

			function h(e) {
				const {
					className: t,
					post: n,
					isCommentsPage: s
				} = e, {
					source: c,
					isSponsored: l
				} = n;
				return c ? o.a.createElement(m, {
					className: Object(r.a)({
						[d.a["m-comment"]]: s
					}, t)
				}, o.a.createElement(a.a, {
					href: c.url,
					isSponsored: l,
					postId: n.id,
					source: c
				}, Object(i.a)(n), o.a.createElement(p, null))) : null
			}
		},
		"./src/reddit/components/SponsoredLabel/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_2oEYZXchPfHwcf9mTMGMg8",
				wrapper: "_2oEYZXchPfHwcf9mTMGMg8"
			}
		},
		"./src/reddit/components/SponsoredLabel/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/reddit/components/SponsoredLabel/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.span("Wrapper", a.a);
			t.a = e => {
				let {
					className: t
				} = e;
				return r.a.createElement(c, {
					className: t
				}, s.fbt._("promoted", null, {
					hk: "1R81m"
				}))
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, n) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const d = e => {
					var {
						disabled: t
					} = e, n = l(e, ["disabled"]);
					return o.a.createElement("div", c({}, n, {
						className: Object(r.a)(a.a.FormNavElement, {
							[a.a.disabled]: t
						})
					}), n.children)
				},
				u = e => {
					var {
						canDrop: t,
						className: n,
						isDragging: s,
						isOver: i,
						disabled: d
					} = e, u = l(e, ["canDrop", "className", "isDragging", "isOver", "disabled"]);
					return o.a.createElement("div", c({}, u, {
						className: Object(r.a)(a.a.DragCard, {
							[a.a.disabled]: d,
							[a.a.isDraffing]: s,
							[a.a.isOverAndCanDrop]: i && t
						}, n)
					}))
				}
		},
		"./src/reddit/components/SubredditIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Image: "_34CfAAowTqdbNDYXz5tBTW",
				image: "_34CfAAowTqdbNDYXz5tBTW",
				UserIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				userIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				PlanetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				planetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				BackupImage: "RK004G8fbNOkGdNLEzm67",
				backupImage: "RK004G8fbNOkGdNLEzm67",
				iconContainer: "_7nyhK_sDI_8i22XNdcMzb",
				editableIcon: "_1AxWRIyg1lV9-r_CmqYj0o",
				flexContainer: "-Mpi2pdgifDBOdpUYX2vh",
				clickableUploadText: "_3H6u2CWhsluIPVF14GpEaA",
				inTopBar: "_1UpdjN7u66BU606z97t4HS",
				emptyUploadButton: "ndkYE2hc8Y-V3NHpSYvxA",
				transition: "_1iA7YdCRjbU9Rd_2VNGvsw",
				emptyEditableIcon: "_1h9JeZaSDxkh67Ns3QVUP2",
				emptyPlusButton: "Dh1qxsy_tIctL9f4LEzv9",
				imageUploader: "JBITiVY1zX1mMDq-sHkru",
				loadingIcon: "_3Dk8QRKhQImYqds2lSF6G4",
				loadingIconInTopBar: "_1U3KLnHX2TdXL5lNrrv4EW",
				emptyEditableIconInTopBar: "_3-i_fdY8zqHIo3CjuVzTYE"
			}
		},
		"./src/reddit/components/SubredditIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/reddit/components/UserIcon/index.tsx"),
				a = n("./src/reddit/constants/colors.ts"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				l = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				d = n("./src/reddit/icons/svgs/CircledPlanet/index.tsx"),
				u = n("./src/reddit/models/Subreddit/index.ts"),
				p = n("./src/reddit/components/SubredditIcon/index.m.less"),
				m = n.n(p),
				h = n("./src/lib/lessComponent.tsx");

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var f = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const g = h.a.wrapped(i.a, "UserIcon", m.a),
				x = h.a.img("Image", m.a),
				y = e => {
					var {
						iconColor: t
					} = e, n = f(e, ["iconColor"]);
					return r.a.createElement(x, b({
						style: {
							backgroundColor: t || ""
						}
					}, n))
				},
				v = h.a.wrapped(e => {
					var {
						className: t,
						color: n
					} = e, s = f(e, ["className", "color"]);
					return r.a.createElement(d.a, b({
						className: t,
						style: {
							background: n || ""
						}
					}, s))
				}, "PlanetIcon", m.a),
				C = h.a.div("BackupImage", m.a),
				E = Object(c.t)();
			t.b = E(e => {
				let t, n, o;
				if (e.subredditOrProfile) {
					const {
						url: s,
						color: i
					} = Object(l.a)({
						shouldHideNsfwIcon: !!e.shouldHideNsfwIcon,
						subredditOrProfile: e.subredditOrProfile
					});
					Object(u.g)(e.subredditOrProfile) ? o = r.a.createElement(g, {
						className: e.className,
						iconUrl: s,
						isNSFW: e.subredditOrProfile.isNSFW,
						userName: e.subredditOrProfile.name
					}) : (t = s, n = i)
				} else t = e.iconUrl, n = e.primaryColor || a.a.alienblue;
				return t ? o = r.a.createElement(y, {
					alt: s.fbt._("Subreddit Icon", null, {
						hk: "134aM1"
					}),
					className: e.className,
					iconColor: n,
					role: "presentation",
					src: t
				}) : o || (o = r.a.createElement(v, {
					className: e.className,
					color: e.redditStyle ? a.a.alienblue : n,
					role: "presentation"
				})), e.linkTo ? r.a.createElement("a", {
					href: e.linkTo
				}, o) : r.a.createElement(r.a.Fragment, null, o)
			})
		},
		"./src/reddit/components/SubredditNameLink/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditName: "_3ryJoIoycVkA88fy40qNJc",
				subredditName: "_3ryJoIoycVkA88fy40qNJc"
			}
		},
		"./src/reddit/components/SubredditNameLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				o = n("./src/reddit/components/SubredditNameLink/index.m.less"),
				r = n.n(o);
			const i = n("./src/lib/lessComponent.tsx").a.wrapped(s.a, "SubredditName", r.a);
			t.a = i
		},
		"./src/reddit/components/SubscribeButton/Inline.m.less": function(e, t, n) {
			e.exports = {
				SubscribeInternalButton: "QvUHhznbRVbKaK8dZGZVV",
				subscribeInternalButton: "QvUHhznbRVbKaK8dZGZVV",
				UnsubscribeButton: "_3gteUGkVlyl5VuSsNQJaz1",
				unsubscribeButton: "_3gteUGkVlyl5VuSsNQJaz1",
				isLarge: "_2jGEuWB6HWtIbTjMG68OXY",
				ButtonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				buttonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				Checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				Plus: "_2zcGm9WDxG67GYyNNvHzlA",
				plus: "_2zcGm9WDxG67GYyNNvHzlA",
				unsubscribeButtonHoverStyles: "_1tZ_edPYFuF6jhuTr_iPEE",
				joinCleanupContent: "_3GS035a5A47X7LR9VSQYy6"
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/components/TrackingHelper/index.tsx"),
				i = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				l = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				d = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				u = n("./src/reddit/components/SubscribeButton/Inline.m.less"),
				p = n.n(u),
				m = n("./src/lib/classNames/index.ts"),
				h = n("./src/lib/lessComponent.tsx");

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var f = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const g = h.a.wrapped(e => {
					var {
						small: t,
						shouldReverseColor: n
					} = e, s = f(e, ["small", "shouldReverseColor"]);
					const r = n ? a.i : a.f;
					return o.a.createElement(r, b({}, s, {
						className: Object(m.a)(s.className, {
							[p.a.isLarge]: !t
						})
					}))
				}, "SubscribeInternalButton", p.a),
				x = h.a.wrapped(e => {
					var {
						small: t,
						belongsToType: n,
						shouldReverseColor: s
					} = e, r = f(e, ["small", "belongsToType", "shouldReverseColor"]);
					const i = s ? a.f : a.i;
					return o.a.createElement(i, b({}, r, {
						className: Object(m.a)(r.className, {
							[p.a.isLarge]: !t
						})
					}))
				}, "UnsubscribeButton", p.a),
				y = h.a.wrapped(c.a, "Checkmark", p.a),
				v = h.a.wrapped(l.a, "Plus", p.a),
				C = h.a.div("ButtonSpacer", p.a);
			class E extends o.a.Component {
				constructor(e) {
					super(e), this.onMouseEnter = () => {
						this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						this.setState({
							isHovered: !1
						})
					}, this.onClick = e => {
						const {
							props: t
						} = this;
						if (t.userIsSubscriber ? t.onUnsubscribe() : (this.setState({
								hasJustSubscribed: !0
							}), t.onSubscribe()), t.onClick && t.onClick(e), t.getEventFactory) {
							const e = t.getEventFactory(t.userIsSubscriber);
							e && t.sendEvent(e)
						}
					}, this.state = {
						hasJustSubscribed: !1,
						isHovered: !1
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const e = this.props,
						{
							className: t,
							identifier: n,
							onSubscribe: s,
							onUnsubscribe: r,
							postId: i,
							sendEvent: a,
							small: c = !1,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: u,
							getEventFactory: h,
							onSubscriptionsRequested: E
						} = e,
						O = f(e, ["className", "identifier", "onSubscribe", "onUnsubscribe", "postId", "sendEvent", "small", "userIsSubscriber", "doNotHideOtherSubscribeButtons", "getEventFactory", "onSubscriptionsRequested"]),
						j = this.state.isHovered;
					let w = l ? "subscribed" : "subscribe";
					l && j && (w = "unsubscribe");
					const S = Object(d.a)({
						type: n.type,
						key: w
					});
					return l ? this.state.hasJustSubscribed || u ? o.a.createElement(x, b({
						className: Object(m.a)(t, {
							[p.a.isLarge]: !c,
							[p.a.unsubscribeButtonHoverStyles]: !c
						}),
						onClick: this.onClick,
						small: c,
						belongsToType: n.type,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, O), c && o.a.createElement(y, null), !c && !j && o.a.createElement(y, null), !c && S) : c ? null : o.a.createElement(C, null) : o.a.createElement(o.a.Fragment, null, o.a.createElement(g, b({
						className: Object(m.a)(t, {
							[p.a.isLarge]: !c
						}),
						onClick: this.onClick,
						small: c
					}, O, {
						id: "subscribe-button-".concat(i),
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}), o.a.createElement(v, null), !c && S))
				}
			}
			t.a = Object(i.a)(Object(r.c)(E))
		},
		"./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const o = e => {
					let {
						type: t
					} = e;
					return "subreddit" === t ? "subredditActions" : "profileActions"
				},
				r = {
					subredditActions: {
						subscribe: () => s.fbt._("Join", null, {
							hk: "3Nhj3V"
						}),
						subscribed: () => s.fbt._("Joined", null, {
							hk: "1YGago"
						}),
						unsubscribe: () => s.fbt._("Leave", null, {
							hk: "299znK"
						})
					},
					profileActions: {
						subscribe: () => s.fbt._("Follow", null, {
							hk: "18PRa5"
						}),
						subscribed: () => s.fbt._("Following", null, {
							hk: "sjS3y"
						}),
						unsubscribe: () => s.fbt._("Unfollow", null, {
							hk: "3c0uwF"
						})
					}
				},
				i = e => {
					let {
						type: t,
						key: n
					} = e;
					return r[o({
						type: t
					})][n]()
				}
		},
		"./src/reddit/components/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				blurredThumbnail: "GnWcY6GPzeZ5rzsiQ98fo",
				container: "_2MkcR85HDnYngvlVW2gMMa",
				contentType: "_2hIvPRO2xz4rn9LXAJXYDa",
				hasType: "_10qSZsDWnOBwx4bc7GJ1QF",
				hiddenImage: "_25ZOvQhQdAqwdxPd5z-KFB",
				imageThumbnail: "_33Pa96SGhFVpZeI6a7Y_Pl",
				verticallyCenterThumbnail: "Fq7oYOARH1VVCaLAuAh37",
				linkIcon: "m0n699kowSp8Wfa40lqpF",
				outboundLinkIcon: "_2rOixIHGmpfZB93ihJsw3V",
				placeholderThumbnail: "_2YO2O4rMRYYMeH_t2y8M5w",
				thumbnail: "_2c1ElNxHftd8W_nZtcG9zf",
				usePreview: "_78ohNtfA1urjgUhnN1jLi",
				LinkText: "_3HXDOeeCKnmgu_pIdoLofi",
				linkText: "_3HXDOeeCKnmgu_pIdoLofi"
			}
		},
		"./src/reddit/components/Thumbnail/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return z
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				d = n("./src/reddit/components/ImageWithFallback/index.tsx"),
				u = n("./src/reddit/icons/fonts/Gif/index.tsx"),
				p = n("./src/reddit/icons/fonts/Link/index.tsx"),
				m = n("./src/reddit/icons/fonts/Photos/index.tsx"),
				h = n("./src/reddit/icons/fonts/Text/index.tsx"),
				b = n("./src/reddit/icons/fonts/helpers.tsx"),
				f = n("./src/reddit/icons/fonts/Video/index.m.less"),
				g = n.n(f);
			var x = c.a.wrapped(e => r.a.createElement("i", {
					className: "".concat(Object(b.b)("video"), " ").concat(e.className)
				}), "VideoIcon", g.a),
				y = n("./src/reddit/icons/svgs/Gallery/index.tsx"),
				v = n("./src/reddit/icons/svgs/Poll/index.tsx"),
				C = n("./src/reddit/constants/elementClassNames.ts"),
				E = n("./src/reddit/controls/ContentType/index.m.less"),
				O = n.n(E);
			const j = e => Object(i.a)(O.a.contentTypeIcon, e.className),
				w = e => r.a.createElement(p.a, {
					className: Object(i.a)(C.a, j(e))
				});

			function S(e) {
				const t = j(e);
				switch (e.type) {
					case "gifvideo":
						return r.a.createElement(u.a, {
							className: t
						});
					case "image":
						return r.a.createElement(m.a, {
							className: t
						});
					case "meta":
						return r.a.createElement(v.a, {
							className: t
						});
					case "rtjson":
					case "text":
						return r.a.createElement(h.a, {
							className: t
						});
					case "video":
						return r.a.createElement(x, {
							className: t
						});
					case "gallery":
						return r.a.createElement(y.a, {
							className: t
						});
					default:
						return r.a.createElement(w, e)
				}
			}
			var _ = n("./src/reddit/controls/OutboundLink/index.tsx"),
				k = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				T = n("./src/reddit/models/Media/index.ts"),
				I = n("./src/reddit/models/Theme/index.ts"),
				P = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				M = n("./src/reddit/components/Thumbnail/index.m.less"),
				N = n.n(M);

			function R() {
				return (R = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const L = e => e.placeholderImage || Object(P.a)(e).placeholderImage,
				A = e => e.placeholderImage ? "cover" : Object(P.a)(e).placeholderImagePosition,
				F = c.a.span("LinkText", N.a),
				D = e => {
					let {
						className: t,
						onClick: n,
						children: s
					} = e;
					return r.a.createElement("div", {
						onClick: n,
						className: Object(i.a)(N.a.linkIcon, t)
					}, s)
				},
				B = e => r.a.createElement("img", {
					alt: e.alt,
					className: Object(i.a)(N.a.hiddenImage, e.className)
				}),
				U = e => {
					const t = r.a.createRef(),
						{
							src: n,
							errorSrc: s
						} = e;
					return n && s && Object(d.a)(n).catch(() => {
						t.current && (t.current.style.backgroundImage = "url(".concat(s, ")"))
					}), r.a.createElement("div", {
						"aria-label": e.alt,
						className: Object(i.a)(N.a.thumbnail, N.a.imageThumbnail, e.className),
						"data-click-id": "image",
						ref: t,
						role: "img",
						style: {
							backgroundImage: "url(".concat(e.src, ")"),
							borderColor: e.isOutbound ? Object(P.a)(e).button : Object(P.a)(e).line
						}
					}, e.isOutbound && r.a.createElement(D, {
						className: e.linkIconClassName
					}, r.a.createElement(k.a, {
						className: Object(i.a)(N.a.outboundLinkIcon, e.outboundLinkIconClassName)
					}), e.text && r.a.createElement(F, {
						className: e.linkTextClassName
					}, e.text)), r.a.createElement(B, {
						alt: e.alt,
						className: "hiddenImg"
					}))
				},
				K = e => e.isOutbound ? Object(P.a)(e).button : e.placeholderImage ? "transparent" : Object(P.a)(e).line,
				H = e => {
					const t = L(e),
						n = t && {
							background: Object(I.g)(Object(P.a)(e).placeholder, t, A(e))
						};
					return r.a.createElement("div", {
						className: Object(i.a)(N.a.thumbnail, N.a.placeholderThumbnail, e.className),
						"data-click-id": "image",
						style: Object.assign(Object.assign({}, n), {
							borderColor: K(e)
						})
					}, (!e.placeholderImage || e.showContentType) && r.a.createElement(S, {
						className: Object(i.a)(e.contentTypeClassName, N.a.contentType, {
							[N.a.hasType]: e.type && !e.isOutbound
						}),
						type: e.isMeta || e.isPoll ? "meta" : e.type
					}), e.isOutbound && r.a.createElement(D, {
						className: e.linkIconClassName
					}, r.a.createElement(k.a, {
						className: Object(i.a)(N.a.outboundLinkIcon, e.outboundLinkIconClassName)
					}), e.text && r.a.createElement(F, {
						className: e.linkTextClassName
					}, e.text)))
				},
				V = e => r.a.createElement(U, R({}, e, {
					className: Object(i.a)(N.a.blurredThumbnail, e.className)
				})),
				W = Object(a.a)(e => {
					const {
						className: t,
						containerClassName: n,
						contentTypeClassName: o,
						crosspost: a,
						forceShowNSFW: c,
						isMeta: l,
						linkIconClassName: d,
						linkTextClassName: u,
						outboundLinkIconClassName: p,
						post: m,
						redditStyle: h,
						removeLink: b,
						showContentType: f,
						templatePlaceholderImage: g,
						text: x,
						theme: y,
						usePreview: v
					} = e, C = !y.subredditContext.shouldShowNSFWContent && (m.isNSFW || !(!a || !a.isNSFW)) && !c, E = L({
						placeholderImage: g,
						redditStyle: h,
						theme: y
					}), O = z(e), j = G(m, t, E, C, x, y, O, l, f, b, h, d, u, p, o), w = Object(T.E)(m);
					return Object(s.a)(w) && !b && w.indexOf("redditmedia") < 0 ? r.a.createElement("div", {
						className: Object(i.a)(N.a.container, v ? N.a.usePreview : "", n)
					}, r.a.createElement(_.b, {
						href: Object(T.E)(m),
						isSponsored: m.isSponsored,
						postId: m.id,
						source: m.source
					}, j)) : r.a.createElement("div", {
						className: Object(i.a)(N.a.container, v ? N.a.usePreview : "", n)
					}, j)
				}),
				z = e => {
					let {
						crosspost: t,
						post: n,
						url: s,
						usePreview: o
					} = e;
					if (s) return s;
					const {
						preview: r,
						media: i,
						thumbnail: a
					} = t || n;
					return o && r ? r.url : q(i) ? i.scrubberThumbSource : a.url
				},
				q = e => !!e && e.type === T.o.LIVEVIDEO,
				G = (e, t, n, o, a, c, d, u, p, m, h, b, f, g, x) => {
					const y = e.source && !e.isSponsored || !1;
					if (Object(s.a)(d)) {
						const n = q(e.media),
							s = n ? {
								errorSrc: l.U
							} : {},
							u = Object(i.a)(t, {
								[N.a.verticallyCenterThumbnail]: n
							});
						return o ? r.a.createElement(V, R({
							"data-click-id": "image",
							src: d
						}, s, {
							className: u,
							isOutbound: y && !m,
							linkIconClassName: b,
							linkTextClassName: f,
							outboundLinkIconClassName: g,
							redditStyle: h,
							text: a,
							theme: c
						})) : r.a.createElement(U, R({
							alt: e.title,
							className: u,
							src: d
						}, s, {
							isOutbound: y && !m,
							linkIconClassName: b,
							linkTextClassName: f,
							outboundLinkIconClassName: g,
							redditStyle: h,
							text: a,
							theme: c
						}))
					}
					return r.a.createElement(H, {
						className: t,
						contentTypeClassName: x,
						placeholderImage: n,
						isMeta: u,
						isOutbound: y && !m,
						linkIconClassName: b,
						linkTextClassName: f,
						outboundLinkIconClassName: g,
						redditStyle: h,
						showContentType: p,
						text: a,
						theme: c,
						type: e.media ? e.media.type : null,
						isPoll: !!e.pollData
					})
				};
			t.a = W
		},
		"./src/reddit/components/ThumbnailSelector/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "uqOt5KqJAqw5pe-WNxa0a",
				component: "uqOt5KqJAqw5pe-WNxa0a",
				TitleRow: "HEiFtUR3s93dQ2jUWWnxr",
				titleRow: "HEiFtUR3s93dQ2jUWWnxr",
				Close: "_3RlS_q06rJ_8dy_UNp3Ev7",
				close: "_3RlS_q06rJ_8dy_UNp3Ev7",
				CloseWrapper: "_3lFQIq1yN1kLxjZb5AvHjL",
				closeWrapper: "_3lFQIq1yN1kLxjZb5AvHjL",
				ThumbnailsContainer: "_2sw7c1Sfzp0uz-RIcglCo",
				thumbnailsContainer: "_2sw7c1Sfzp0uz-RIcglCo",
				Image: "_2H32szY9NZ1aKr6j4Ced7u",
				image: "_2H32szY9NZ1aKr6j4Ced7u",
				thumbnail: "_2Ks8P6YD1-8_Ju3IrYpPJf",
				isSelected: "_3oA67AGI49fKcqDP970t4U",
				ButtonRow: "_2Bo7ys2El8ABMVNqYUdrA5",
				buttonRow: "_2Bo7ys2El8ABMVNqYUdrA5",
				CancelButton: "mBq3crGX9-xOOg-b-1V85",
				cancelButton: "mBq3crGX9-xOOg-b-1V85"
			}
		},
		"./src/reddit/components/ThumbnailSelector/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/debounce.js"),
				r = n.n(o),
				i = n("./node_modules/lodash/range.js"),
				a = n.n(i),
				c = n("./node_modules/react/index.js"),
				l = n.n(c),
				d = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/lessComponent.tsx"),
				p = n("./src/higherOrderComponents/asModal/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				f = n("./src/reddit/icons/svgs/Close/index.tsx"),
				g = n("./src/reddit/layout/row/Inline/index.tsx"),
				x = n("./src/reddit/components/ThumbnailSelector/index.m.less"),
				y = n.n(x);
			const v = 10,
				C = Object(p.a)(u.a.div("Component", y.a)),
				E = u.a.wrapped(g.a, "TitleRow", y.a),
				O = u.a.wrapped(f.a, "Close", y.a),
				j = u.a.div("CloseWrapper", y.a),
				w = u.a.div("ThumbnailsContainer", y.a),
				S = u.a.img("Image", y.a),
				_ = e => l.a.createElement("div", {
					className: Object(d.a)(y.a.thumbnail, Object(b.a)({
						isLoading: e.isLoading
					}), {
						[y.a.isSelected]: e.isSelected
					}),
					onClick: e.onClick,
					ref: e.elementRef
				}, e.thumbnail.url && l.a.createElement(S, {
					src: e.thumbnail.url
				})),
				k = u.a.wrapped(g.a, "ButtonRow", y.a),
				T = m.f,
				I = u.a.wrapped(m.i, "CancelButton", y.a),
				P = (e, t) => {
					if (1 === e) return [0];
					const n = a()(0, t, t / (e - 1));
					return n.push(t), n.map(e => +e.toFixed(2))
				};
			class M extends l.a.Component {
				constructor(e) {
					super(e), this.isThumbnailsAreGenerating = !1, this.setSelectedElementRef = e => this.selectedElement = e, this.setThumbnails = r()(e => this.setState({
						thumbnails: e
					}), 100), this.scrollIntoView = () => {
						this.selectedElement && this.selectedElement.scrollIntoView({})
					}, this.setSelected = e => {
						this.setState({
							selectedIndex: e
						})
					}, this.onSelectButton = () => {
						const {
							selectedIndex: e
						} = this.state, t = this.state.thumbnails[e];
						this.props.onSelect({
							time: t.time,
							url: t.url
						})
					};
					const {
						thumbnailsCount: t = v,
						selected: n,
						videoDuration: s
					} = this.props, o = P(t, s).map(e => ({
						time: e,
						url: n && n.time === e ? n.url : void 0
					})), i = n ? o.findIndex(e => n.time === e.time) : -1;
					this.state = {
						thumbnails: o,
						selectedIndex: i
					}
				}
				componentDidMount() {
					this.scrollIntoView(), this.props.isOpen && this.generateVideoThumbnails()
				}
				componentDidUpdate(e) {
					this.props.isOpen && !e.isOpen && (this.scrollIntoView(), this.generateVideoThumbnails())
				}
				async generateVideoThumbnails() {
					const {
						thumbnails: e
					} = this.state;
					if (this.isThumbnailsAreGenerating || !e.find(e => !e.url)) return;
					this.isThumbnailsAreGenerating = !0;
					const t = document.createElement("video"),
						n = document.createElement("canvas");
					await Object(h.m)(t, this.props.videoSource);
					let s = 0;
					t.currentTime = e[s].time, await Object(h.d)(t, n, t => (e[s].url = t.dataUrl, s++, this.setThumbnails(e), s < e.length ? e[s].time : null)), this.setState({
						thumbnails: e
					}), this.isThumbnailsAreGenerating = !1
				}
				render() {
					if (!this.props.isOpen) return null;
					const {
						selectedIndex: e,
						thumbnails: t
					} = this.state;
					return l.a.createElement(C, {
						withOverlay: !0
					}, l.a.createElement(E, null, s.fbt._("Choose thumbnail", null, {
						hk: "XlI0H"
					}), l.a.createElement(j, {
						onClick: this.props.onToggleModal
					}, l.a.createElement(O, null))), l.a.createElement(w, null, t.map((t, n) => l.a.createElement(_, {
						key: n,
						elementRef: n === e ? this.setSelectedElementRef : void 0,
						isLoading: !t.url,
						onClick: () => this.setSelected(n),
						isSelected: n === e,
						thumbnail: t
					}))), l.a.createElement(k, null, l.a.createElement(I, {
						onClick: this.props.onToggleModal
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), l.a.createElement(T, {
						onClick: this.onSelectButton
					}, s.fbt._("Select", null, {
						hk: "3s53WD"
					}))))
				}
			}
			t.a = M
		},
		"./src/reddit/components/UserIcon/CurrentUserIcon.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/selectors/user.ts"),
				c = n("./src/reddit/components/UserIcon/UserIcon.tsx");

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var d = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const u = Object(i.c)({
					currentUser: a.i,
					isNightMode: a.S,
					shouldHideNSFW: a.z
				}),
				p = Object(r.b)(u);
			t.a = p(e => {
				const {
					currentUser: t
				} = e, n = d(e, ["currentUser"]);
				return o.a.createElement(c.a, l({}, n, {
					iconUrl: t ? t.accountIcon : void 0,
					isCurrentUser: !0,
					isNSFW: !!t && t.isNSFW
				}))
			})
		},
		"./src/reddit/components/UserIcon/UserIcon.m.less": function(e, t, n) {
			e.exports = {
				DefaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				defaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				UserIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				userIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				mNightmode: "_2aVSEFJsIE0M-4uRE-U24H"
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			}));
			var s = n("./src/config.ts"),
				o = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/icons/svgs/SnooSilhouette/index.tsx"),
				l = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				d = n.n(l);
			const u = "".concat(s.a.assetPath, "/img/avatar_over18_square.png"),
				p = e => !e || e.includes("avatar_default_");
			t.a = e => {
				const {
					className: t,
					iconUrl: n,
					isCurrentUser: s,
					isNightMode: r,
					isNSFW: l,
					nsfwIconUrl: m,
					shouldHideNSFW: h
				} = e;
				if (s && p(n) || !s && !n) return i.a.createElement(c.a, {
					className: Object(a.a)(d.a.DefaultUserIcon, t, {
						[d.a.mNightmode]: r
					})
				});
				const b = !s && l && h ? m || u : n;
				return i.a.createElement("img", {
					alt: o.fbt._("User avatar", null, {
						hk: "X43nA"
					}),
					className: Object(a.a)(d.a.UserIcon, t),
					src: b
				})
			}
		},
		"./src/reddit/components/UserIcon/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/models/User/index.ts"),
				c = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				l = n("./src/reddit/selectors/user.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const p = Object(i.c)({
					currentUser: l.i,
					isNightMode: l.S,
					shouldHideNSFW: l.z,
					user: l.eb
				}),
				m = Object(r.b)(p);
			t.a = m(e => {
				const {
					currentUser: t,
					iconUrl: n,
					isNSFW: s,
					user: r,
					userName: i
				} = e, l = u(e, ["currentUser", "iconUrl", "isNSFW", "user", "userName"]), p = !!t && Object(a.e)(t) === i, m = p && t.accountIcon || r && r.accountIcon || n, h = r ? r.isNSFW : s;
				return o.a.createElement(c.a, d({}, l, {
					iconUrl: m,
					isCurrentUser: p,
					isNSFW: h
				}))
			})
		},
		"./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				DropdownRow: "JoWBeMWu_l8J_Hn6Udz_j",
				dropdownRow: "JoWBeMWu_l8J_Hn6Udz_j"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/react-router-redux/es/index.js"),
				l = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/post.ts"),
				p = n("./src/reddit/actions/postCollection/index.ts"),
				m = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = n("./src/reddit/components/OverflowMenu/index.tsx"),
				b = n("./src/reddit/components/TrackingHelper/index.tsx"),
				f = n("./src/reddit/controls/Dropdown/Row.tsx"),
				g = n("./src/reddit/selectors/activeModalId.ts"),
				x = n("./src/reddit/selectors/postCollection.ts"),
				y = n("./node_modules/reselect/es/index.js"),
				v = n("./src/reddit/helpers/trackers/postCollection.ts"),
				C = n("./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.m.less"),
				E = n.n(C),
				O = n("./node_modules/fbt/lib/FbtPublic.js");
			const j = l.a.wrapped(f.b, "DropdownRow", E.a);
			let w;
			const S = Object(g.b)("DELETE_COLLECTION_CONFM_MODAL_ID"),
				_ = Object(g.b)("EDIT_POST_COLLECTION_MODAL_ID"),
				k = Object(y.c)({
					createPostUrl: x.d,
					isDeleteConfirmModalOpen: S,
					isEditCollectionModalOpen: _,
					shouldShowCollectionEditOptions: x.t
				}),
				T = Object(a.b)(k, (e, t) => ({
					copyLink: () => e(Object(u.v)(t.permalink)),
					onCreatePost: n => {
						t.shouldShowCreatePost && e(Object(c.b)(n))
					},
					onRemoveCollection: () => e(Object(p.c)(t.collectionId, t.isSubmitPage)),
					onToggleDeleteConfirmModal: () => e(d.i("DELETE_COLLECTION_CONFM_MODAL_ID")),
					onToggleEditModal: async () => {
						w || (w = await Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("editCollectionModal")]).then(n.bind(null, "./src/reddit/components/EditCollectionModal/index.tsx")).then(e => e.EditCollectionModal)), e(d.i("EDIT_POST_COLLECTION_MODAL_ID"))
					}
				}));
			t.a = T(Object(b.c)(e => {
				const {
					className: t,
					collectionId: n,
					copyLink: s,
					createPostUrl: r,
					isDeleteConfirmModalOpen: a,
					isEditCollectionModalOpen: c,
					onCreatePost: l,
					onRemoveCollection: d,
					onToggleDeleteConfirmModal: u,
					onToggleEditModal: p,
					shouldShowCollectionEditOptions: b,
					shouldShowCreatePost: f,
					targetPosition: g,
					tooltipPosition: x,
					sendEvent: y
				} = e;
				return i.a.createElement(i.a.Fragment, null, i.a.createElement(h.b, {
					className: t,
					dropdownId: "collection-menu-".concat(n, "-").concat(f ? 1 : 2),
					onClick: o.a,
					targetPosition: g,
					tooltipPosition: x
				}, i.a.createElement(j, {
					onClick: s,
					displayText: O.fbt._("Copy collection link", null, {
						hk: "3Rfodz"
					})
				}), b && i.a.createElement(i.a.Fragment, null, i.a.createElement(j, {
					onClick: () => {
						y(Object(v.l)(n)), p()
					},
					displayText: O.fbt._("Edit", null, {
						hk: "1nftDt"
					})
				}), i.a.createElement(j, {
					onClick: () => {
						y(Object(v.k)(n)), u()
					},
					displayText: O.fbt._("Delete collection", null, {
						hk: "2FyIJB"
					})
				}), f && i.a.createElement(j, {
					onClick: () => {
						l(r)
					},
					displayText: O.fbt._("Create post", null, {
						hk: "1v2jHl"
					})
				}))), c && w && i.a.createElement(w, {
					collectionId: n,
					onClose: p,
					onEditSuccess: p
				}), a && i.a.createElement(m.a, {
					actionText: O.fbt._("Yes, Delete", null, {
						hk: "15Espn"
					}),
					headerText: O.fbt._("Delete Collection", null, {
						hk: "1QJ3as"
					}),
					modalText: O.fbt._("Are you sure you want to delete this collection? The posts within the collection won't be deleted.", null, {
						hk: "36jKp5"
					}),
					onConfirm: d,
					toggleModal: u,
					trackClick: o.a
				}))
			}))
		},
		"./src/reddit/components/Widgets/PostCollection/PendingItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_135f7-HhEMvekPzYxVBaFE",
				activeItemIndicator: "_31zbCRopTPo2NGtlgVsrBX",
				metaLine: "_1OrlyQwYIehGSk4bhP_l2R",
				title: "_2jvQA1RLlcCLU44q6eB3g0"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				DropdownRow: "_3V8ByF4idIiROiWQ9i468R",
				dropdownRow: "_3V8ByF4idIiROiWQ9i468R"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/noop.js"),
				r = n.n(o),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/opener/index.ts"),
				d = n("./src/reddit/components/LinkOrOverlayLink/index.tsx"),
				u = n("./src/reddit/components/OverflowMenu/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/Row.tsx"),
				m = n("./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.m.less"),
				h = n.n(m);
			const b = c.a.wrapped(p.b, "DropdownRow", h.a);
			t.a = e => {
				const {
					isFutureEvent: t,
					onAddEventStartTime: n,
					onEditStartTime: o,
					onStartEventNow: i,
					postPermalink: c,
					shouldShowAddEventStartTime: p,
					targetPosition: m,
					tooltipPosition: h
				} = e;
				return a.a.createElement(u.b, {
					className: e.className,
					dropdownId: e.dropdownId,
					onClick: r.a,
					targetPosition: m,
					tooltipPosition: h
				}, p && n && a.a.createElement(b, {
					onClick: n,
					displayText: s.fbt._("Add event start time", null, {
						hk: "4xWttR"
					})
				}), t && i && a.a.createElement(b, {
					onClick: i,
					displayText: s.fbt._("Start event now", null, {
						hk: "2TTNfJ"
					})
				}), t && o && a.a.createElement(b, {
					onClick: o,
					displayText: s.fbt._("Edit start time", null, {
						hk: "44XUxC"
					})
				}), a.a.createElement(b, {
					onClick: e.onRemoveClick,
					displayText: s.fbt._("Remove from collection", null, {
						hk: "qsiiu"
					})
				}), c && a.a.createElement(d.a, {
					target: l.c.BLANK,
					rel: l.b,
					isOverlay: !1,
					to: c
				}, a.a.createElement(b, {
					displayText: s.fbt._("View post", null, {
						hk: "1PtvnG"
					})
				})))
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/Placeholder.m.less": function(e, t, n) {
			e.exports = {
				Container: "I9mI9NePKM1BEsmfZR-6H",
				container: "I9mI9NePKM1BEsmfZR-6H",
				Content: "_6d8yyfLZcJ1OXLzEXoApB",
				content: "_6d8yyfLZcJ1OXLzEXoApB",
				Title: "_1efKScSk4JSYvERdEecZnZ",
				title: "_1efKScSk4JSYvERdEecZnZ",
				Secondary: "_3fCsv_r4CtfCTdAzBRaR9N",
				secondary: "_3fCsv_r4CtfCTdAzBRaR9N"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/PostItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "ceAYEjQdznT14GrQQ52QV",
				content: "_36S4oraLw5gf--rC9-aWZs",
				overflowMenu: "MiZ0gbh9xe5Yiwt3RQf2o",
				metaLine: "_2JVAK9jCDOKkFXe1XS6gwH",
				title: "_2U-RjfXG1sY-NtByFOS-uC"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3_XzG2WCa3EYhqzE_vUcMN",
				topRow: "r_Dz4suUXbQkBdwR-eQ77",
				collectionDescription: "_3K3iJQYRdF3d2n1WlPxkpr",
				listContainer: "_2K8wDNk-kaP5gX-QEAXuMc",
				listWrapper: "VYYQfc9_vtbBaR47zbXdB",
				menuButton: "_1BX9a5jz4LWzuQohy4Cvz4"
			}
		},
		"./src/reddit/components/Widgets/PostCollection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Widgets/PostCollection/CollectionOverflowMenu/index.tsx"),
				a = n("./node_modules/react-redux/es/index.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				d = n("./src/reddit/components/Widgets/PostCollection/PendingItem/index.m.less"),
				u = n.n(d);
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), m = Object(c.c)({
				title: l.kb
			});
			var h = Object(a.b)(m)(e => {
					const {
						title: t
					} = e;
					return o.a.createElement("div", {
						className: u.a.container
					}, o.a.createElement("div", {
						className: u.a.activeItemIndicator
					}), t && o.a.createElement("h2", {
						className: u.a.title
					}, t), o.a.createElement("div", {
						className: u.a.metaLine
					}, p._("Editing", null, {
						hk: "2w5fAf"
					})))
				}),
				b = n("./node_modules/fbt/lib/FbtPublic.js"),
				f = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				g = n("./src/lib/timeAgo/index.ts"),
				x = n("./src/reddit/actions/postCollection/index.ts"),
				y = n("./src/reddit/selectors/posts.ts"),
				v = n("./src/reddit/components/Widgets/PostCollection/PostItem/index.m.less"),
				C = n.n(v),
				E = n("./src/reddit/components/Widgets/PostCollection/PostItem/OverflowMenu/index.tsx"),
				O = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				j = n("./src/reddit/components/Widgets/PostCollection/PostItem/Placeholder.m.less"),
				w = n.n(j);

			function S(e) {
				let {
					className: t,
					isLoading: n
				} = e;
				const s = Object(O.a)({
					isLoading: n
				});
				return o.a.createElement("div", {
					className: Object(r.a)(w.a.Container, t)
				}, o.a.createElement("div", {
					className: w.a.Content
				}, o.a.createElement("div", {
					className: Object(r.a)(w.a.Title, s)
				}), o.a.createElement("div", {
					className: Object(r.a)(w.a.Secondary, s)
				})))
			}
			const _ = ["right", "bottom"],
				k = ["right", "top"];
			var T = Object(a.b)(() => Object(c.c)({
					post: y.N
				}), (e, t) => ({
					onRemovePostFromCollection: () => e(Object(x.g)(t.collectionId, t.postId))
				}))(e => {
					const {
						post: t,
						onRemovePostFromCollection: n
					} = e;
					return t ? o.a.createElement("div", {
						className: C.a.container
					}, o.a.createElement("div", {
						className: C.a.content
					}, o.a.createElement(f.a, {
						className: C.a.title,
						target: "_blank",
						to: t.permalink
					}, t.title), o.a.createElement("div", {
						className: C.a.metaLine
					}, b.fbt._("Posted · {timeAgo}", [b.fbt._param("timeAgo", Object(g.d)(t.created / 1e3))], {
						hk: "ZVJpV"
					}))), o.a.createElement(E.a, {
						onRemoveClick: n,
						className: C.a.overflowMenu,
						dropdownId: "collection-widget-item" + t.id,
						postPermalink: t.permalink,
						targetPosition: _,
						tooltipPosition: k
					})) : o.a.createElement(S, {
						className: C.a.container,
						isLoading: !0
					})
				}),
				I = n("./src/reddit/components/Widgets/PostCollection/index.m.less"),
				P = n.n(I);
			const {
				fbt: M
			} = n("./node_modules/fbt/lib/FbtPublic.js"), N = ["right", "bottom"], R = ["right", "top"];
			class L extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.renderItem = (e, t) => o.a.createElement(T, {
						collectionId: this.props.collection.id,
						key: e,
						postId: e
					})
				}
				render() {
					const {
						className: e,
						collection: t
					} = this.props, n = t.postIds.map(this.renderItem).reverse();
					return o.a.createElement("div", {
						className: Object(r.a)(e, P.a.container)
					}, o.a.createElement("div", {
						className: P.a.topRow
					}, M._("Collection", null, {
						hk: "1pY1s2"
					}), o.a.createElement(i.a, {
						className: P.a.menuButton,
						collectionId: t.id,
						isSubmitPage: !0,
						permalink: t.permalink,
						targetPosition: N,
						tooltipPosition: R
					})), o.a.createElement("h4", {
						className: P.a.collectionDescription
					}, t.title), o.a.createElement("div", {
						className: P.a.listWrapper
					}, o.a.createElement("div", {
						className: P.a.listContainer
					}, n)), o.a.createElement(h, null))
				}
			}
			t.a = L
		},
		"./src/reddit/components/Widgets/SubredditRules/Rule/index.m.less": function(e, t, n) {
			e.exports = {
				RawHTMLDisplay: "_2vztYwRKSDZV2ISjSixByA",
				rawHtmlDisplay: "_2vztYwRKSDZV2ISjSixByA",
				Chevron: "_2U-LBUvfr1W6MEMTGXgzmh",
				chevron: "_2U-LBUvfr1W6MEMTGXgzmh",
				RuleShortName: "_8ZLJI1-ZiP7pHJ_yO1L4Z",
				ruleShortName: "_8ZLJI1-ZiP7pHJ_yO1L4Z",
				pointerCursor: "_3osxlOKfiylmgqNqsW7erB",
				RuleIndex: "_36D5hmBSZbFxkFMkiWg6cY",
				ruleIndex: "_36D5hmBSZbFxkFMkiWg6cY",
				RuleTitle: "tbIApBd2DM_drfZQJjIum",
				ruleTitle: "tbIApBd2DM_drfZQJjIum",
				RuleDescription: "_2QhEclR_DjIrTv_oNU5MMN",
				ruleDescription: "_2QhEclR_DjIrTv_oNU5MMN"
			}
		},
		"./src/reddit/components/Widgets/SubredditRules/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/reddit/components/Widgets/ThemedWidget/index.tsx"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				d = n("./src/reddit/components/RichTextJson/index.tsx"),
				u = n("./src/reddit/helpers/dom/index.ts"),
				p = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				m = n("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				h = n("./src/reddit/layout/threeCol/ExpandCenter/index.tsx"),
				b = n("./src/reddit/models/Widgets/index.ts"),
				f = n("./src/reddit/components/Widgets/SubredditRules/Rule/index.m.less"),
				g = n.n(f);
			const x = c.a.div("RuleShortName", g.a),
				y = c.a.div("RuleIndex", g.a),
				v = c.a.div("RuleTitle", g.a),
				C = c.a.div("RuleDescription", g.a),
				E = c.a.wrapped(l.a, "RawHTMLDisplay", g.a),
				O = {};
			class j extends r.a.Component {
				constructor(e) {
					super(e), this.onClick = () => {
						Object(u.f)() || this.setState({
							isVisible: !this.state.isVisible
						})
					}, this.state = {
						isVisible: this.shouldShowFullDisplay(e)
					}
				}
				shouldShowFullDisplay(e) {
					return e.display === b.e.FULL
				}
				render() {
					const {
						props: e,
						state: t,
						onClick: n,
						shouldShowFullDisplay: s
					} = this, o = !!(e.rule.descriptionRichText || e.rule.descriptionHtml || e.rule.description), i = !s(e) && !!o;
					return r.a.createElement(x, {
						className: Object(a.a)({
							[g.a.pointerCursor]: i
						}),
						onClick: s(e) || !o ? void 0 : n
					}, r.a.createElement(h.a, null, r.a.createElement(y, null, "".concat(e.humanIndex, ".")), r.a.createElement(v, null, "".concat(e.rule.shortName)), r.a.createElement("div", null, !s(e) && o && (t.isVisible ? r.a.createElement(m.a, {
						className: g.a.Chevron
					}) : r.a.createElement(p.a, {
						className: g.a.Chevron
					})))), t.isVisible && r.a.createElement(C, null, e.rule.descriptionRichText ? r.a.createElement(d.a, {
						content: JSON.parse(e.rule.descriptionRichText),
						useExplicitTextColor: !0,
						rtJsonElementProps: O
					}) : e.rule.descriptionHtml ? r.a.createElement(E, {
						html: e.rule.descriptionHtml
					}) : e.rule.description))
				}
			}
			const w = e => e.rules.length > 0 ? r.a.createElement(i.a, {
				className: e.className,
				styles: e.styles,
				title: s.fbt._("{subredditName} Rules", [s.fbt._param("subredditName", "r/".concat(e.subredditName))], {
					hk: "2AwRLk"
				}),
				redditStyle: e.redditStyle
			}, e.rules.map((function(t, n) {
				return r.a.createElement(j, {
					key: "rule".concat(t.shortName).concat(t.createdUtc),
					rule: t,
					display: e.display,
					humanIndex: n + 1
				})
			}))) : null;
			t.b = e => r.a.createElement(w, {
				rules: e.widget.data || [],
				subredditName: e.subredditName,
				display: e.widget.display,
				redditStyle: e.redditStyle,
				styles: e.widget.styles
			})
		},
		"./src/reddit/components/Widgets/ThemedWidget/index.m.less": function(e, t, n) {
			e.exports = {
				widgetBackground: "_1G4yU68P50vRZ4USXfaceV",
				clickable: "_2mtWlchu4uQf339v56bSha",
				redditStyle: "_2QeqBqfT5UbHBoViZUt-wX",
				truncatedGradient: "_1lvCNVth3dt5y8lu3vT95L",
				widgetHeader: "_ZhON3a3vplThB8NFwuJn",
				widgetTitle: "_2sggAEfRQLyoAl4J__5twU",
				widgetContent: "TmgZY6tDcdErbE5d7E0HJ",
				widgetContentOnly: "_3RPJ8hHnfFohktLZca18J6",
				truncated: "r5dzQq7dgZyAmve8abbbt",
				seeMore: "_3dbp6Cm9uKkkIBr9EsU-qS"
			}
		},
		"./src/reddit/components/Widgets/ThemedWidget/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/reddit/components/SEOTitle/index.tsx"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/selectors/telemetry.ts");
			const h = (e, t) => n => Object.assign({
				source: "community_widgets",
				action: "click",
				noun: "see_more",
				widget: Object(m.widget)(n, {
					subredditId: e,
					widgetKind: t
				})
			}, m.defaults);
			var b = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				f = n("./src/reddit/selectors/experiments/topPosts.ts"),
				g = n("./src/reddit/selectors/structuredStyles.ts"),
				x = n("./src/reddit/selectors/user.ts"),
				y = n("./src/reddit/models/Theme/index.ts"),
				v = n("./src/reddit/models/Theme/NewColorSystem/index.ts");
			const C = e => e.styles && e.styles.backgroundColor ? e.styles.backgroundColor : Object(v.a)(e).widgetColors.sidebarWidgetBackgroundColor,
				E = e => e.styles && e.styles.headerColor ? e.styles.headerColor : Object(v.a)(e).widgetColors.sidebarWidgetHeaderColor,
				O = e => {
					const t = C(e);
					return Object(y.f)(t)
				},
				j = e => {
					const t = E(e);
					return Object(y.f)(t)
				};
			var w = n("./src/reddit/components/Widgets/ThemedWidget/index.m.less"),
				S = n.n(w);
			const {
				fbt: _
			} = n("./node_modules/fbt/lib/FbtPublic.js"), k = Object(u.t)(), T = Object(r.b)(() => Object(i.c)({
				forceRedditStyle: (e, t) => {
					const n = Object(u.m)(e, t) || void 0,
						s = t.redditStyle || Object(g.m)(e, {
							subredditId: n
						}),
						o = Object(x.S)(e);
					return s || o
				},
				nigtmode: x.S,
				subredditId: u.m,
				topPostVariant: f.d
			}));
			class I extends o.a.Component {
				constructor() {
					super(...arguments), this.contentRef = o.a.createRef(), this.state = {
						isTruncated: !1
					}, this.handleSeeMoreClick = () => {
						const {
							subredditId: e,
							widgetKind: t
						} = this.props;
						e && t && this.props.sendEvent(h(e, t)), this.setState({
							isTruncated: !1
						})
					}
				}
				componentDidMount() {
					const e = this.contentRef.current,
						t = e && e.offsetHeight;
					this.props.truncateThreshold && t && t > this.props.truncateThreshold && this.setState({
						isTruncated: !0
					})
				}
				getWidgetBackgroundStyles() {
					const e = {};
					return e.backgroundColor = C(this.props), e.borderColor = Object(b.d)(e.backgroundColor, this.props.nigtmode), e.color = e.fill = O(this.props), e
				}
				getWidgetHeaderStyles() {
					const e = {};
					return e.backgroundColor = E(this.props), e.color = e.fill = j(this.props), e
				}
				render() {
					const {
						children: e,
						className: t,
						contentOnly: n,
						forceRedditStyle: s,
						headerButton: r,
						onClick: i,
						title: c,
						titleClassName: d,
						truncateThreshold: u
					} = this.props, m = n ? S.a.widgetContentOnly : S.a.widgetContent, h = !s && this.props.styles, b = h ? this.getWidgetBackgroundStyles() : {}, f = h ? this.getWidgetHeaderStyles() : {};
					return o.a.createElement("div", {
						className: Object(a.a)(t, S.a.widgetBackground, {
							[S.a.redditStyle]: s,
							[S.a.clickable]: !!i,
							[S.a.truncatedGradient]: this.state.isTruncated && !this.props.noGradient
						}),
						"data-redditstyle": s,
						onClick: i,
						style: b
					}, c && o.a.createElement("div", {
						className: S.a.widgetHeader,
						style: f
					}, o.a.createElement("div", {
						className: Object(a.a)(S.a.widgetTitle, d)
					}, o.a.createElement(l.b, {
						type: l.a.Widget
					}, c)), r), o.a.createElement("div", {
						className: Object(a.a)(m, {
							[S.a.truncated]: this.state.isTruncated
						}),
						ref: this.contentRef,
						style: {
							maxHeight: this.state.isTruncated ? u : "none"
						}
					}, e), this.state.isTruncated && o.a.createElement(p.n, {
						className: S.a.seeMore,
						onClick: this.handleSeeMoreClick
					}, _._("See More", null, {
						hk: "4w47Qu"
					})))
				}
			}
			t.a = k(T(Object(c.a)(Object(d.c)(I))))
		},
		"./src/reddit/connectors/PostViewable/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/reddit/actions/post.ts");
			t.a = (e, t) => Object(s.b)(e, function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return Object.assign(Object.assign({}, e), {
					onPostViewable: o.H
				})
			}(t))
		},
		"./src/reddit/connectors/SubscribeButton/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				o = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/actions/subscription/index.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			t.a = Object(s.b)(() => Object(o.c)({
				userIsSubscriber: i.eb
			}), (e, t) => {
				let {
					identifier: n
				} = t;
				return {
					onSubscribe: () => e(r.d([n], !0)),
					onSubscriptionsRequested: () => e(r.e()),
					onUnsubscribe: () => e(r.d([n], !1))
				}
			})
		},
		"./src/reddit/connectors/connectClickToToggleEditor.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				o = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/actions/structuredStyles/index.ts"),
				i = n("./src/reddit/selectors/activeModalId.ts"),
				a = n("./src/reddit/selectors/structuredStyles.ts"),
				c = n("./src/reddit/constants/modals.ts");
			const l = Object(o.c)({
				bladeHasUnsavedChanges: a.a,
				isEditing: a.j,
				isBladeEditorDirty: a.i,
				isModalOpen: Object(i.b)(c.a.BLADE_UNSAVED_CHANGES)
			});
			t.a = Object(s.b)(l, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					requestCloseBlade: () => n && e(Object(r.h)(n))
				}
			})
		},
		"./src/reddit/constants/componentSizes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "m", (function() {
				return m
			})), n.d(t, "q", (function() {
				return h
			})), n.d(t, "r", (function() {
				return b
			})), n.d(t, "s", (function() {
				return f
			})), n.d(t, "u", (function() {
				return g
			})), n.d(t, "t", (function() {
				return x
			})), n.d(t, "v", (function() {
				return y
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "l", (function() {
				return C
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "p", (function() {
				return w
			}));
			const s = 284,
				o = 450,
				r = 800,
				i = 284,
				a = 48,
				c = 640,
				l = 1600,
				d = 1280,
				u = 40,
				p = 48,
				m = 24,
				h = 24,
				b = 312,
				f = 40,
				g = 270,
				x = 106,
				y = 5,
				v = 16,
				C = 1250,
				E = 82,
				O = 48,
				j = 36,
				w = 37
		},
		"./src/reddit/constants/componentTestIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			}));
			const s = "comment",
				o = "comment-submission-form-markdown",
				r = "comment-submission-form-richtext",
				i = "comments-page-link-num-comments",
				a = "post-content"
		},
		"./src/reddit/constants/disclaimers.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.ORIGINAL_CONTENT_DISCLAIMER = "original_content_disclaimer"
				}(s || (s = {}));
			const o = "https://www.redditinc.com/policies/beta-terms-of-service"
		},
		"./src/reddit/constants/elementClassNames.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "o", (function() {
				return d
			})), n.d(t, "n", (function() {
				return u
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			}));
			const s = "DraftEditor-contentwrapper",
				o = "public-DraftStyleDefault-block",
				r = "data-offset-key",
				i = "hovered",
				a = "scrollerItem",
				c = "threadline",
				l = "header-user-dropdown",
				d = "voteButton",
				u = "unsubscribe-icon-button",
				p = "RichTextJSON-root",
				m = "ImageBox-image",
				h = "content-type-link",
				b = "styled-outbound-link",
				f = "ListingLayout-backgroundContainer",
				g = "ListingLayout-outerContainer"
		},
		"./src/reddit/constants/elementIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			}));
			const s = "bladeContainer",
				o = "header",
				r = "overlayScrollContainer",
				i = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/jsapiEvents.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			}));
			const s = "reddit",
				o = "reddit.ready",
				r = "reddit.urlChanged"
		},
		"./src/reddit/constants/keycodes.ts": function(e, t, n) {
			"use strict";
			var s, o;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return o
				})),
				function(e) {
					e[e.ArrowDown = 40] = "ArrowDown", e[e.ArrowLeft = 37] = "ArrowLeft", e[e.ArrowRight = 39] = "ArrowRight", e[e.ArrowUp = 38] = "ArrowUp", e[e.Backspace = 8] = "Backspace", e[e.Delete = 46] = "Delete", e[e.Enter = 13] = "Enter", e[e.Escape = 27] = "Escape", e[e.F = 70] = "F", e[e.K = 75] = "K", e[e.Space = 32] = "Space", e[e.Tab = 9] = "Tab", e[e.Comma = 188] = "Comma"
				}(s || (s = {})),
				function(e) {
					e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.ArrowUp = "ArrowUp", e.Enter = "Enter", e.Escape = "Escape", e.F = "f", e.Tab = "Tab", e.Space = " ", e.Comma = ","
				}(o || (o = {}))
		},
		"./src/reddit/constants/postCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			}));
			const s = "PostCreation-AddEventButton",
				o = 500,
				r = "PostCreation-CollectionEducationTooltip",
				i = "PostCreation-EventEducationTooltip",
				a = 300,
				c = a,
				l = "PostCreation-AddToCollectionButton"
		},
		"./src/reddit/constants/screenWidths.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = 480,
				o = 960,
				r = 1200
		},
		"./src/reddit/constants/zIndex.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "b", (function() {
				return d
			}));
			const s = 4,
				o = 51,
				r = 60,
				i = 70,
				a = 90,
				c = 99,
				l = 100,
				d = 100
		},
		"./src/reddit/contexts/InsideOverlay.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const i = o.a.createContext(!1);

			function a(e) {
				return class extends o.a.Component {
					render() {
						return o.a.createElement(i.Consumer, null, t => o.a.createElement(e, r({}, this.props, {
							isOverlay: t
						})))
					}
				}
			}
		},
		"./src/reddit/controls/Button/index.m.less": function(e, t, n) {
			e.exports = {
				DangerButton: "_1K_eZyG6kthwPn55PD-EMM",
				dangerButton: "_1K_eZyG6kthwPn55PD-EMM",
				DangerButtonStyles: "_2TFttKq5FzfEJ75z_ZdIum",
				dangerButtonStyles: "_2TFttKq5FzfEJ75z_ZdIum",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				GoldButton: "_2GYoN_LmWsKeeYnfg8wF7N",
				goldButton: "_2GYoN_LmWsKeeYnfg8wF7N",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				PremiumButton: "_14IRbTHWqATJbFJ9PgPswU",
				premiumButton: "_14IRbTHWqATJbFJ9PgPswU",
				PrimaryButton: "_2JBsHFobuapzGwpHQjrDlD",
				primaryButton: "_2JBsHFobuapzGwpHQjrDlD",
				PrimaryLinkButton: "wLV79_wV-ziNiWmf3Y7OV",
				primaryLinkButton: "wLV79_wV-ziNiWmf3Y7OV",
				PrimaryRouterLink: "_3UhcBirLMXHSbN5vYYBGSF",
				primaryRouterLink: "_3UhcBirLMXHSbN5vYYBGSF",
				SecondaryButton: "PiO8QDmoJoOL2sDjJAk4C",
				secondaryButton: "PiO8QDmoJoOL2sDjJAk4C",
				SecondaryLinkButton: "_1HunhFR-0b-AYs0WG9mU_P",
				secondaryLinkButton: "_1HunhFR-0b-AYs0WG9mU_P",
				SecondaryRouterLink: "_2yhUdcPyG1k3qsmDb4y6u_",
				secondaryRouterLink: "_2yhUdcPyG1k3qsmDb4y6u_",
				TertiaryButton: "_1McO-Omm_mC2bkTnVgD6NV",
				tertiaryButton: "_1McO-Omm_mC2bkTnVgD6NV",
				TertiaryLinkButton: "_9Yn-qhIEvQgFU6jnrKkSC",
				tertiaryLinkButton: "_9Yn-qhIEvQgFU6jnrKkSC",
				TertiaryRouterLink: "SuTcOCtRzb-pPZYaAZTjh",
				tertiaryRouterLink: "SuTcOCtRzb-pPZYaAZTjh",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return m
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "j", (function() {
				return v
			})), n.d(t, "k", (function() {
				return C
			})), n.d(t, "i", (function() {
				return E
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "c", (function() {
				return w
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "d", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/controls/Button/index.m.less"),
				l = n.n(c);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const p = (e, t, n) => Object(r.a)(e, {
				[l.a.redditStyle]: !(!t && !n)
			});
			a.a.wrapped(e => {
				const {
					className: t,
					redditStyle: n,
					"data-redditstyle": s
				} = e, r = u(e, ["className", "redditStyle", "data-redditstyle"]);
				return o.a.createElement("button", d({
					className: p(t, n, s)
				}, r))
			}, "Button", l.a);
			const m = e => {
					var {
						className: t,
						redditStyle: n,
						"data-redditstyle": s
					} = e, r = u(e, ["className", "redditStyle", "data-redditstyle"]);
					return o.a.createElement(i.a, d({
						className: p(t, n, s)
					}, r))
				},
				h = e => {
					var {
						className: t,
						redditStyle: n,
						"data-redditstyle": s
					} = e, r = u(e, ["className", "redditStyle", "data-redditstyle"]);
					return o.a.createElement("a", d({
						className: p(t, n, s)
					}, r))
				},
				b = e => {
					var {
						className: t,
						redditStyle: n,
						"data-redditstyle": s
					} = e, r = u(e, ["className", "redditStyle", "data-redditstyle"]);
					return o.a.createElement("button", d({
						className: p(t, n, s)
					}, r))
				},
				f = a.a.wrapped(h, "PrimaryLinkButton", l.a),
				g = a.a.wrapped(m, "PrimaryRouterLink", l.a),
				x = a.a.wrapped(b, "PrimaryButton", l.a),
				y = a.a.wrapped(b, "DangerButton", l.a),
				v = a.a.wrapped(h, "SecondaryLinkButton", l.a),
				C = a.a.wrapped(m, "SecondaryRouterLink", l.a),
				E = a.a.wrapped(b, "SecondaryButton", l.a),
				O = a.a.wrapped(b, "TertiaryButton", l.a),
				j = (a.a.wrapped(h, "TertiaryLinkButton", l.a), a.a.wrapped(m, "TertiaryRouterLink", l.a)),
				w = a.a.wrapped(b, "GoldButton", l.a),
				S = a.a.wrapped(b, "PremiumButton", l.a),
				_ = a.a.wrapped(b, "ChatButton", l.a),
				k = a.a.wrapped(b, "InlineTextButton", l.a)
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.regexp.to-string.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				a = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				c = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/CheckboxInput/index.m.less"),
				d = n.n(l);
			t.a = e => o.a.createElement(c.a, {
				"aria-checked": !!e.value,
				"aria-disabled": e.disabled,
				"aria-labelledby": e.name,
				className: Object(r.a)(e.className, d.a.checkboxInput, e.disabled ? d.a.disabled : null),
				onClick: e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0,
				role: "checkbox"
			}, o.a.createElement("input", {
				value: e.value ? e.value.toString() : "",
				type: "hidden"
			}), e.value ? o.a.createElement(a.a, {
				className: d.a.checkboxSelected
			}) : o.a.createElement(i.a, null), e.children)
		},
		"./src/reddit/controls/ContentType/index.m.less": function(e, t, n) {
			e.exports = {
				contentTypeIcon: "_3CquMWJ6RMh8E9D-_84AtZ"
			}
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/lodash/throttle.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				l = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				d = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				u = n("./src/reddit/layout/row/InlineButton/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/index.m.less"),
				m = n.n(p),
				h = n("./src/reddit/controls/Dropdown/row.m.less"),
				b = n.n(h);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var g = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			class x extends i.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = o()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, n = Object(a.a)(b.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? i.a.createElement(c.a, f({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href
					}), e.children && i.a.createElement("span", {
						className: n
					}, e.children), i.a.createElement("span", {
						className: Object(a.a)(b.a.text, e.textClassName)
					}, e.displayText)) : i.a.createElement(u.a, f({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: o()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? i.a.createElement("div", null, e.children) : i.a.createElement("span", {
						className: n
					}, e.children)), e.displayText && i.a.createElement("span", {
						className: Object(a.a)(b.a.text, e.textClassName)
					}, e.displayText), e.showSelectedCheckmark && e.isSelected && i.a.createElement(d.a, {
						className: b.a.checkmark
					}), e.showDropdownTriangle && i.a.createElement(l.a, {
						className: m.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				var {
					className: t
				} = e, n = g(e, ["className"]);
				const s = Object(a.a)(b.a.row, t, {
					[b.a.mIsInteractive]: !n.noHover,
					[b.a.mIsSelected]: n.isSelected,
					[b.a.topics]: n.isTopicsStyle
				});
				return i.a.createElement(x, f({
					className: s
				}, n))
			}
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				iconStyles: "Ls9uHSAO9p2g7EMya2KXp",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/domUtils/index.ts"),
				a = n("./src/reddit/constants/zIndex.ts"),
				c = n("./src/reddit/controls/Dropdown/index.m.less"),
				l = n.n(c);
			class d extends o.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(i.a)(this.props.tooltipId)
				}
				render() {
					const e = this.props,
						t = {};
					return (e.isFixed || e.isOverlay) && (e.isFixed && (t.position = "fixed"), e.isOverlay && (t.zIndex = e.isFixed ? a.d + 1 : a.c)), o.a.createElement("div", {
						className: Object(r.a)(l.a.dropdown, e.className),
						id: this.props.id,
						ref: e => this.ref = e,
						role: "menu",
						style: Object.assign(Object.assign({}, t), e.style),
						tabIndex: -1,
						onScroll: e.onScroll
					}, e.children)
				}
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				iconStyles: "_2XOVBjNLHjJIznEsn35vs2",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				topics: "kR_ljR-F8vtc-ORj1uipB",
				checkmark: "_3Iua3qlR9JiTwjjk6NKye1",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2AfJEqW9tv4b_kolKEuS9K",
				titleRow: "p4QfstubN5cRxd-gy8gFH",
				detailsContainer: "_2V3KEAhexNh-mP3TbrVClC",
				buttonRow: "_1fcbQFwN65ik28DNmWnpX4",
				confirmButton: "zcMEJWBL7q-mYGOPSpjN-"
			}
		},
		"./src/reddit/controls/ErrorText/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2hGJP-9xfXBXd0wqhBLHhY",
				description: "_3h_9YwxjuOr77VhScPrjCI",
				moreText: "_1Y0BrhDgcSTeSYvmSPYepI"
			}
		},
		"./src/reddit/controls/ErrorText/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return S
			})), n.d(t, "c", (function() {
				return _
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/uniqueId.js"),
				r = n.n(o),
				i = n("./node_modules/raf/index.js"),
				a = n.n(i),
				c = n("./node_modules/react/index.js"),
				l = n.n(c),
				d = n("./node_modules/react-redux/es/index.js"),
				u = n("./node_modules/reselect/es/index.js"),
				p = n("./src/lib/classNames/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				h = n("./src/reddit/selectors/activeModalId.ts"),
				b = n("./src/higherOrderComponents/asModal/index.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/layout/row/Inline/index.tsx"),
				x = n("./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less"),
				y = n.n(x);
			var v = Object(b.a)(e => {
					const {
						children: t,
						title: n
					} = e;
					return l.a.createElement("div", {
						className: y.a.wrapper
					}, l.a.createElement(g.a, {
						className: y.a.titleRow
					}, n), l.a.createElement("div", {
						className: y.a.detailsContainer
					}, t), l.a.createElement(g.a, {
						className: y.a.buttonRow
					}, l.a.createElement(f.f, {
						className: y.a.confirmButton,
						onClick: e.onConfirmed
					}, s.fbt._("Ok", null, {
						hk: "2Giu9U"
					}))))
				}),
				C = n("./src/reddit/controls/ErrorText/index.m.less"),
				E = n.n(C);
			const O = Object(u.c)({
				activeModalId: h.a
			});
			class j extends l.a.Component {
				constructor(e) {
					super(e), this.spanRef = l.a.createRef(), this.toggleModal = () => {
						this.props.toggleErrorTextModal(this.state.modalId)
					}, this.state = {
						textHasOverflowed: !1,
						modalId: "ErrorTextModal--".concat(r()())
					}
				}
				componentDidMount() {
					this.calcTextDidOverflow()
				}
				componentDidUpdate() {
					this.calcTextDidOverflow()
				}
				calcTextDidOverflow() {
					a()(() => {
						const e = this.spanRef.current;
						if (!e) return;
						const t = e.scrollWidth > e.clientWidth;
						this.setState(e => e.textHasOverflowed !== t ? {
							textHasOverflowed: t
						} : null)
					})
				}
				render() {
					const {
						children: e,
						activeModalId: t,
						className: n,
						errorModalBody: o,
						errorModalTitle: r = s.fbt._("Error", null, {
							hk: "2nPF4G"
						}),
						moreText: i = s.fbt._("More", null, {
							hk: "1bCAQ0"
						})
					} = this.props, {
						modalId: a,
						textHasOverflowed: c
					} = this.state;
					return l.a.createElement("div", {
						className: Object(p.a)(E.a.wrapper, n)
					}, l.a.createElement("span", {
						className: E.a.description,
						ref: this.spanRef
					}, e), c && l.a.createElement("span", {
						className: E.a.moreText,
						onClick: this.toggleModal
					}, i), t === a && l.a.createElement(v, {
						onConfirmed: this.toggleModal,
						title: r
					}, o || e))
				}
			}
			const w = Object(d.b)(O, e => ({
					toggleErrorTextModal: t => e(Object(m.i)(t))
				}))(j),
				S = e => {
					const {
						className: t,
						errorClassName: n,
						errorModalTitle: s,
						fallbackMessage: o,
						messages: r = []
					} = e, i = r.length ? r : o ? [o] : [];
					return i.length ? l.a.createElement("div", {
						className: t
					}, i.map((e, t) => l.a.createElement(w, {
						className: n,
						errorModalTitle: s,
						key: t
					}, e))) : null
				},
				_ = e => l.a.createElement(S, {
					fallbackMessage: s.fbt._("Something went wrong", null, {
						hk: "Cw1BT"
					}),
					messages: e
				});
			t.b = w
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/flow.js"),
				o = n.n(s),
				r = n("./node_modules/react/index.js"),
				i = n.n(r),
				a = n("./node_modules/react-dnd/lib/index.js"),
				c = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				l = n("./src/reddit/helpers/dragDropContext/index.ts");
			const d = c.NativeTypes.FILE,
				u = o()(Object(a.DropTarget)(d, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const n = t.getItem();
						n.files && e.onDrop(n.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), l.a);
			class p extends i.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(i.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = u(p)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/ErrorText/index.tsx"),
				c = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				l = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				d = n("./src/reddit/controls/FormFields/index.m.less"),
				u = n.n(d);

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var m = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const h = i.a.input("input", u.a),
				b = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				f = e => {
					const {
						label: t,
						children: n,
						inputRef: s,
						className: i
					} = e, a = m(e, ["label", "children", "inputRef", "className"]), c = void 0 !== e.value && "" !== e.value;
					return o.a.createElement("div", {
						className: Object(r.a)(u.a.inputWrapper, i, {
							[u.a.mIsInvalid]: e.isInvalid
						}),
						onClick: b
					}, o.a.createElement(h, p({
						"aria-invalid": e.isInvalid,
						innerRef: s
					}, a)), e.label && o.a.createElement("label", {
						className: Object(r.a)(u.a.label, {
							[u.a.mHasValue]: c
						})
					}, e.label), e.children)
				},
				g = e => {
					const {
						label: t,
						children: n,
						inputRef: s,
						isInvalid: i,
						className: a,
						redditStyle: c
					} = e, l = m(e, ["label", "children", "inputRef", "isInvalid", "className", "redditStyle"]), d = void 0 !== e.value && "" !== e.value;
					return o.a.createElement("div", {
						className: Object(r.a)(u.a.inputMovingLabelWrapper, a, {
							[u.a.mIsInvalid]: i,
							[u.a.mIsRedditStyle]: c
						}),
						onClick: b
					}, o.a.createElement(h, p({
						innerRef: s
					}, l)), e.label && o.a.createElement("label", {
						className: Object(r.a)(u.a.label, {
							[u.a.mHasValue]: d
						})
					}, e.label), e.children)
				},
				x = e => o.a.createElement("div", {
					className: Object(r.a)(u.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", o.a.createElement(c.a, {
					className: u.a.plus
				}));
			var y;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(y || (y = {}));
			class v extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: y.ADD
						})
					}, this.updateValue = (e, t) => {
						const n = this.props.values.slice();
						n[t] = e.target.value, this.props.onChange(n)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							n = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: y.REMOVE,
							value: n,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: n,
						placeholder: s,
						errors: r = []
					} = this.props;
					return e.map((e, i) => o.a.createElement(f, {
						inputRef: e => this.setInputRef(e, i),
						isInvalid: !!r[i],
						disabled: t,
						type: "text",
						label: n,
						onChange: e => this.updateValue(e, i),
						placeholder: s,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, o.a.createElement("div", {
						className: u.a.trashContainer,
						onClick: () => this.removeValue(i)
					}, o.a.createElement(l.b, {
						className: u.a.trash
					})), !!r[i] && o.a.createElement(a.b, {
						className: u.a.errorText
					}, r[i])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: n,
						maxLength: s,
						addValueText: i,
						disabled: a
					} = this.props;
					this.focusedInput = null;
					const c = !(!!s && n.length >= s) && !a;
					return o.a.createElement("div", {
						className: Object(r.a)(u.a.multiInputWrapper, e)
					}, t && c && o.a.createElement(x, {
						onClick: this.addValue,
						text: i
					}), this.renderFields(), !t && c && o.a.createElement(x, {
						onClick: this.addValue,
						text: i
					}))
				}
			}
		},
		"./src/reddit/controls/GrowingOutlinedInput/index.m.less": function(e, t, n) {
			e.exports = {
				growingOutlinedInput: "PqYQ3WC15KaceZuKcFI02"
			}
		},
		"./src/reddit/controls/Input/ModalInput.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/constants/keycodes.ts"),
				l = n("./src/reddit/controls/Input/index.m.less"),
				d = n.n(l);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var p = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			class m extends o.a.Component {
				constructor() {
					super(...arguments), this.handleKeyDown = e => {
						let {
							keyCode: t
						} = e;
						t === c.a.Escape && this.props.closeModal()
					}
				}
				render() {
					const e = this.props,
						{
							className: t,
							closeModal: n
						} = e,
						s = p(e, ["className", "closeModal"]);
					return o.a.createElement("input", u({
						className: Object(i.a)(d.a.input, t),
						onKeyDown: this.handleKeyDown
					}, s))
				}
			}
			t.a = Object(r.b)(null, {
				closeModal: a.f
			})(m)
		},
		"./src/reddit/controls/Input/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3eoXtlBWKbkFYoOHUIcIgK"
			}
		},
		"./src/reddit/controls/Input/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/controls/Input/index.m.less"),
				r = n.n(o);
			t.a = s.a.input("input", r.a)
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/helpers/path/index.ts"),
				c = n("./src/reddit/controls/InternalLink/index.m.less"),
				l = n.n(c);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var u = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};

			function p(e) {
				var {
					children: t,
					className: n,
					disabled: s,
					replace: c,
					to: p
				} = e, m = u(e, ["children", "className", "disabled", "replace", "to"]);
				return s ? o.a.createElement("span", {
					className: Object(i.a)(l.a.disabledLink, n)
				}, t) : ("string" == typeof p && (p = Object(a.b)(p)), o.a.createElement(r.a, d({
					className: n,
					to: p
				}, m), t))
			}
		},
		"./src/reddit/controls/LoadingIcon/index.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_3LwT7hgGcSjmJ7ng7drAuq",
				spin: "ibDwUVR1CAykturOgqOS5",
				mCentered: "_2qr28EeyPvBWAsPKl-KuWN"
			}
		},
		"./src/reddit/controls/LoadingIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/LoadingIcon/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					center: t,
					className: n,
					sizePx: s
				} = e;
				return o.a.createElement("div", {
					className: Object(r.a)(a.a.loadingIcon, n, {
						[a.a.mCentered]: t
					}),
					style: {
						"--sizePx": "".concat(s, "px")
					}
				})
			}
		},
		"./src/reddit/controls/MetaSeparator/index.m.less": function(e, t, n) {
			e.exports = {
				unstyledMetaSeparator: "_3LS4zudUBagjFS7HjWJYxo",
				metaSeparator: "_37gsGHa8DMRAxBmQS-Ppg8"
			}
		},
		"./src/reddit/controls/MetaSeparator/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/MetaSeparator/index.m.less"),
				a = n.n(i);
			const c = e => o.a.createElement("span", {
				className: Object(r.a)(a.a.unstyledMetaSeparator, e.className),
				role: "presentation"
			}, e.isSmall ? "·" : "•");
			t.b = e => {
				let {
					className: t,
					isSmall: n
				} = e;
				return o.a.createElement(c, {
					className: Object(r.a)(a.a.metaSeparator, t),
					isSmall: n
				})
			}
		},
		"./src/reddit/controls/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return j
			})), n.d(t, "c", (function() {
				return w
			}));
			var s = n("./node_modules/lodash/omit.js"),
				o = n.n(s),
				r = n("./node_modules/query-string/index.js"),
				i = n.n(r),
				a = n("./node_modules/react/index.js"),
				c = n.n(a),
				l = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts");
			var p = (e, t) => t ? Object(u.a)(e, {
					user_id: t
				}) : e,
				m = n("./src/lib/opener/index.ts"),
				h = n("./src/lib/redditId/index.ts"),
				b = n("./src/reddit/actions/post.ts"),
				f = n("./src/reddit/constants/adEvents.ts"),
				g = n("./src/reddit/helpers/getVendorMetadata.ts"),
				x = n("./src/reddit/selectors/posts.ts"),
				y = n("./src/reddit/selectors/user.ts");

			function v() {
				return (v = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const C = Object(d.a)(y.a, y.i, (e, t) => {
					let {
						isSponsored: n,
						postId: s
					} = t;
					return n && s ? Object(x.b)(e, s) : null
				}, x.N, (e, t, n, s) => ({
					allowClickTracking: e,
					basePixelMetadata: n,
					userId: t ? Object(h.a)(t.id) : null,
					post: s
				})),
				E = Object(l.b)(C, e => ({
					fireAdPixelsOfType: (t, n) => e(Object(b.t)(t, n))
				})),
				O = (e, t, n, s) => {
					const o = t.outboundUrlExpiration && t.outboundUrlExpiration > Date.now();
					s && t.outboundUrl && o && (e.href = p(t.outboundUrl, n))
				},
				j = (e, t, n) => {
					if (e && t && /^(http|https):\/\/([a-z]+\.)?reddit.com/.test(n)) {
						const s = Object(g.a)(e, t),
							{
								url: o,
								query: r
							} = i.a.parseUrl(n);
						return i.a.stringifyUrl({
							url: o,
							query: Object.assign(Object.assign({}, r), s)
						})
					}
					return n
				},
				w = (e, t, n) => e.href = j(t, n, e.href),
				S = E(e => {
					const {
						allowClickTracking: t,
						basePixelMetadata: n,
						href: s,
						isSponsored: r,
						post: i,
						postId: a,
						source: l,
						userId: d
					} = e;
					let u = o()(e, ["allowClickTracking", "basePixelMetadata", "isSponsored", "postId", "source", "userId"]);
					const p = l && l.outboundUrl && r ? l.outboundUrl : s;
					return u = Object.assign(Object.assign({}, u), {
						href: p,
						rel: m.a,
						target: m.c.BLANK
					}), !l || (e => {
						const {
							outboundUrlCreated: t,
							outboundUrlReceived: n
						} = e;
						return !(!t || !n) && (t > n + 3e5 || t < n - 36e5)
					})(l) ? c.a.createElement("a", u) : c.a.createElement("a", v({}, u, {
						onMouseDown: e => {
							if (!(l && l.outboundUrl && r)) return !(1 !== e.button && 2 !== e.button && !e.ctrlKey) || void O(e.currentTarget, l, d, t);
							w(e.currentTarget, a, n)
						},
						onClick: () => {
							i && Object(b.t)(i, f.a.Click)
						},
						onMouseLeave: e => {
							r || ((e, t) => {
								e.href = t
							})(e.currentTarget, p)
						},
						onTouchStart: e => O(e.currentTarget, l, d, t)
					}))
				});
			t.b = S
		},
		"./src/reddit/controls/OutboundLink/styled.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/constants/elementClassNames.ts"),
				r = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/controls/OutboundLink/styles.m.less"),
				a = n.n(i);
			t.a = s.a.wrapped(r.b, "styledOutboundLink", {
				styledOutboundLink: "".concat(a.a.styledOutboundLink, " ").concat(o.l)
			})
		},
		"./src/reddit/controls/OutboundLink/styles.m.less": function(e, t, n) {
			e.exports = {
				styledOutboundLink: "_13svhQIUZqD9PVzFcLwOKT"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.m.less": function(e, t, n) {
			e.exports = {
				radioOption: "_2e6fJknJ4noSygWYov8-F1",
				radioOff: "_1lzSnSABNXX12WerTnwqI3",
				radioOn: "_3PYsg_uRJ6AGptv-hi7kqu"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				c = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				d = n("./src/reddit/controls/RadioInput/RadioOption/index.m.less"),
				u = n.n(d);
			class p extends o.a.Component {
				constructor() {
					super(...arguments), this.ref = null, this.onKeyPress = e => {
						const {
							props: t
						} = this;
						t.disabled || e.key !== i.b.Enter && e.key !== i.b.Space || (t.onClick && t.onClick(t.value), e.preventDefault())
					}
				}
				componentDidUpdate(e) {
					this.props.selected && !e.selected && this.ref && this.ref.focus()
				}
				render() {
					const {
						props: e
					} = this;
					return e.hidden ? null : o.a.createElement(l.a, {
						"aria-checked": e.selected,
						className: Object(r.a)(e.className, u.a.radioOption),
						innerRef: e => this.ref = e,
						onClick: e.disabled ? void 0 : e.onClick,
						onKeyPress: this.onKeyPress,
						role: "radio",
						tabIndex: e.tabIndex
					}, e.showButton && (e.selected ? o.a.createElement(c.a, {
						className: u.a.radioOn,
						role: "presentation"
					}) : o.a.createElement(a.a, {
						className: u.a.radioOff,
						role: "presentation"
					})), e.children)
				}
			}
			t.a = p
		},
		"./src/reddit/controls/RadioInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/constants/keycodes.ts");
			class i extends o.a.Component {
				constructor(e) {
					super(e), this.handleClick = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props;
						t || this.state.value !== e && (n(e), this.setState({
							value: e
						}))
					}, this.getValues = () => {
						const e = [];
						return o.a.Children.forEach(this.props.children, t => {
							t.props.hidden || t.props.disabled || e.push(t.props.value)
						}), e
					}, this.onKeyDown = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props, {
							value: s
						} = this.state;
						if (t) return;
						const o = e.key === r.b.ArrowUp,
							i = e.key === r.b.ArrowDown;
						if (o || i) {
							const t = this.getValues();
							if (!t.length) return;
							const r = s ? t.indexOf(s) : 0,
								i = t[((o ? r - 1 : r + 1) + t.length) % t.length];
							n(i), this.setState({
								value: i
							}), e.preventDefault()
						}
					}, this.state = {
						value: e.value || null
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.value !== this.props.value && this.setState({
						value: e.value || null
					})
				}
				render() {
					const {
						props: e
					} = this, {
						value: t
					} = this.state;
					return o.a.createElement("div", {
						"aria-label": e.name,
						className: e.className,
						role: "radiogroup",
						onKeyDown: this.onKeyDown
					}, o.a.createElement("input", {
						disabled: e.disabled,
						type: "hidden",
						value: t || ""
					}), o.a.Children.map(e.children, (n, s) => {
						const r = 0 === s,
							i = n.props.value === t,
							a = null !== t ? i ? 0 : -1 : r ? 0 : -1;
						return o.a.cloneElement(n, {
							disabled: e.disabled,
							onClick: e => this.handleClick(n.props.value),
							selected: i,
							tabIndex: a
						})
					}))
				}
			}
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/helpers/dragDropContext/index.ts"),
				i = n("./node_modules/lodash/flow.js"),
				a = n.n(i),
				c = n("./node_modules/react-dnd/lib/index.js");
			class l extends o.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? a()(e.connectDropTarget, e.connectDragSource)(o.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var d = a()(Object(c.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const n = t.getDropResult();
						e.onDrop(e.id, n.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(c.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const n = t.getItem();
					return e.id !== n.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(l);
			class u extends o.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(n => {
							const s = n.values.slice(),
								o = s.indexOf(e),
								r = s.splice(o, 1)[0];
							let i = s.indexOf(t);
							return o <= i && (i += 1), s.splice(i, 0, r), this.props.onDrop(e, t, s), {
								values: s
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: n,
						render: s
					} = this.props;
					return o.a.createElement("div", {
						className: e
					}, this.state.values.map((e, r) => o.a.createElement(d, {
						id: e,
						key: t && t(e),
						index: r,
						render: s,
						onDrop: this.onDrop,
						onClick: n
					})))
				}
			}
			t.a = Object(r.a)(u)
		},
		"./src/reddit/controls/SubredditDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				entry: "BR2J4z5ndMj6r3-QW2hHI",
				mIsFocused: "_2KXTnIrbZ1Fr5F4nZyXeKS",
				list: "_17g61LC45mhwjs-g79qbZK"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_1MHSX9NVr4C2QxH2dMcg4M",
				inputWrapper: "anPJr_ybRailY8NbAunl2",
				searchBar: "_3cWzf-usAKfGV1Ay7h2zM_",
				commonIconStyles: "_3UX5zf2Jh7UCwxr3e1Rrt2",
				dropdownIcon: "_15FJlGHQ_lg8wmnMsXlnes",
				iconEmpty: "_3adQsrepNO01e3sMjt2z0P",
				subredditRoundIcon: "jpIFeDw811_DQwlQEqBjm",
				userIcon: "_1Xb3_WGBJKTWZNy0MHWTsR",
				searchIcon: "_2MCEtCukiOUDUHF1PDgWwH",
				mDisabled: "I8Mbkr_v6UNBq2UjXD24r"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownEntry/index.m.less": function(e, t, n) {
			e.exports = {
				entry: "_2_6Q3rlmltjQM8nEBoNJr-",
				disabled: "_1eGUunOsIyMkgTF3IiieVl"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownSection/index.m.less": function(e, t, n) {
			e.exports = {
				title: "-T-WBPEANCCRwTdAGSdj_",
				dropdownSection: "_2MAa_9ffQVHzsZ-RD1dD5F"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/PostTypes/index.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "_2jjSvas2tvdAFgIvSzSBax",
				mDisabled: "_2PoEIlhFzgV0sUWfM40K-N",
				rowStyle: "_3DfMNtnkrzHeGN0WyUTTuX"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.m.less": function(e, t, n) {
			e.exports = {
				subredditIcon: "vxu9qtznQ1Kvakd5mtfxV",
				main: "_11CAFoZ5ryUXHrO5iX6Ktk",
				title: "_1bEDlh2fhWPx9-h3IqUvFa",
				secondary: "_2q4aqq7yddFWa3SfRCihRH",
				container: "_3oyS3dPRsa51zDEONlIdts",
				mHighLight: "F6s6qTIrbT1UvKhtNmPq4"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/ProfileEntryContent/index.m.less": function(e, t, n) {
			e.exports = {
				profileIcon: "_3JCR5jV3N1dbyHaUswxl4K"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				noMatches: "kaGogHhtbK_vPZj9943oa",
				container: "_3DQXGvoE1SM3Kmz20of7Iz",
				mIsValid: "_28z84WGIIVp4uDMcA3-Kgw",
				mIsVisible: "_3009h778F7QI2qu6YmsxVV"
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return G
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/debounce.js"),
				r = n.n(o),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				c = n("./src/lib/classNames/index.ts");
			const l = {
				leading: !0,
				trailing: !1
			};
			var d = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : l;
					const o = Object.assign(Object.assign({}, l), s),
						r = t > e ? 1 : -1;
					let i = e;
					if (e !== t) {
						for (o.leading || (i += r); i !== t;) n(i), i += r;
						o.trailing && n(i)
					} else(o.leading || o.trailing) && n(e)
				},
				u = n("./src/lib/forEachGroup/index.ts"),
				p = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				m = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownEntry/index.m.less"),
				h = n.n(m);
			class b extends i.Component {
				constructor(e) {
					super(e), this.mouseDown = !1, this.element = null, this.setRef = e => this.element = e, this.onMouseUp = () => {
						this.mouseDown && (this.props.disabled || this.props.onSelect(this.props.entryIndex), this.mouseDown = !1)
					}, this.onMouseDown = e => {
						this.mouseDown = !0, e.preventDefault()
					}, this.onMouseOver = () => {
						this.props.onOver(this.props.entryIndex)
					}, this.mouseDown = !1
				}
				componentDidUpdate() {
					this.mouseDown = !1, this.element && this.props.onUpdate(this.props.entryIndex, this.element)
				}
				render() {
					return a.a.createElement("div", {
						className: Object(c.a)(h.a.entry, this.props.disabled && h.a.disabled),
						onMouseDown: this.onMouseDown,
						onMouseOver: this.onMouseOver,
						onMouseUp: this.onMouseUp,
						ref: this.setRef
					}, this.props.children)
				}
			}
			n("./node_modules/core-js/modules/es6.symbol.js");
			var f = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/DropdownSection/index.m.less"),
				g = n.n(f);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var y = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			var v = e => {
					var {
						className: t,
						children: n,
						title: s
					} = e, o = y(e, ["className", "children", "title"]);
					return a.a.createElement("div", x({
						className: Object(c.a)(g.a.dropdownSection, t)
					}, o), s && a.a.createElement("div", {
						className: g.a.title
					}, s), n)
				},
				C = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				E = n("./src/reddit/helpers/name/index.ts"),
				O = n("./src/lib/lessComponent.tsx"),
				j = n("./src/reddit/components/SubredditIcon/index.tsx"),
				w = n("./src/reddit/icons/svgs/ImagePost/index.tsx"),
				S = n("./src/reddit/icons/svgs/Link/index.tsx"),
				_ = n("./src/reddit/icons/svgs/TextPost/index.tsx"),
				k = n("./src/reddit/icons/svgs/Video/index.tsx"),
				T = n("./src/reddit/layout/row/Inline/index.tsx"),
				I = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/PostTypes/index.m.less"),
				P = n.n(I);
			const M = [{
				type: "text",
				Icon: _.a
			}, {
				type: "images",
				Icon: w.a
			}, {
				type: "videos",
				Icon: k.a
			}, {
				type: "links",
				Icon: S.a
			}];

			function N(e) {
				const {
					allowedPostTypes: t,
					className: n
				} = e;
				return a.a.createElement(T.a, {
					className: Object(c.a)(P.a.rowStyle, n)
				}, M.map(e => {
					let {
						type: n,
						Icon: s
					} = e;
					return a.a.createElement("div", {
						className: Object(c.a)(P.a.iconWrapper, {
							[P.a.mDisabled]: !t[n]
						})
					}, a.a.createElement(s, null))
				}))
			}
			var R = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/EntryContent/index.m.less"),
				L = n.n(R);
			const A = O.a.wrapped(j.b, "subredditIcon", L.a);

			function F(e) {
				const {
					highlight: t,
					icon: n,
					title: s,
					secondaryText: o,
					item: r
				} = e, {
					allowedPostTypes: i
				} = r;
				return a.a.createElement("div", {
					className: Object(c.a)(L.a.container, {
						[L.a.mHighlight]: t
					})
				}, n, a.a.createElement("div", {
					className: L.a.main
				}, a.a.createElement("span", {
					className: L.a.title
				}, s), o && a.a.createElement("span", {
					className: L.a.secondary
				}, o)), t && i && a.a.createElement(N, {
					allowedPostTypes: i
				}))
			}
			var D = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/ProfileEntryContent/index.m.less"),
				B = n.n(D);

			function U() {
				return (U = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function K(e) {
				const {
					item: {
						name: t,
						subscribers: n
					}
				} = e, o = Object(E.c)(t), r = void 0 !== n ? s.fbt._({
					"*": "{number} members",
					_1: "1 member"
				}, [s.fbt._plural(n, "number")], {
					hk: "2SvJUX"
				}) : void 0, i = a.a.createElement(C.a, {
					className: Object(c.a)(B.a.profileIcon, L.a.subredditIcon)
				});
				return a.a.createElement(F, U({
					icon: i,
					title: o,
					secondaryText: r
				}, e))
			}

			function H() {
				return (H = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function V(e) {
				const {
					item: {
						primaryColor: t,
						iconUrl: n,
						name: o,
						subscribers: r
					}
				} = e, i = Object(E.b)(o), c = void 0 !== r ? s.fbt._({
					"*": "{number} members",
					_1: "1 member"
				}, [s.fbt._plural(r, "number")], {
					hk: "2SvJUX"
				}) : void 0, l = a.a.createElement(A, {
					iconUrl: n,
					primaryColor: t,
					redditStyle: !0
				});
				return a.a.createElement(F, H({
					icon: l,
					title: i,
					secondaryText: c
				}, e))
			}
			var W = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.m.less"),
				z = n.n(W);
			const q = {
				[p.a.OWN_PROFILE]: () => s.fbt._("Your profile", null, {
					hk: "1Qoy4P"
				}),
				[p.a.SUBSCRIBED_TO_SUBREDDIT]: () => s.fbt._("My communities", null, {
					hk: "2NVUpl"
				}),
				[p.a.OTHER_SUBREDDIT]: () => s.fbt._("Others", null, {
					hk: "3WQHlu"
				}),
				[p.a.MODERATED_SUBREDDIT]: () => s.fbt._("Moderated subreddits", null, {
					hk: "uZtld"
				})
			};
			class G extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.selectedEntryElement = null, this.containerElement = null, this.ignoreEntryOverEvents = !1, this.activateEntryOverEvents = r()(() => this.ignoreEntryOverEvents = !1, 100), this.setContainerRef = e => this.containerElement = e, this.onEntryUpdate = (e, t) => {
						e === this.props.focusedIndex && (this.selectedEntryElement = t)
					}, this.onScroll = () => {
						this.ignoreEntryOverEvents && this.activateEntryOverEvents()
					}, this.onEntryOver = e => {
						this.ignoreEntryOverEvents || this.props.items[e].disabled || this.props.onEntryFocus(e), this.ignoreEntryOverEvents = !1
					}
				}
				componentDidUpdate() {
					if (this.props.focusedIndex >= 0 && this.selectedEntryElement && this.containerElement) {
						const e = this.selectedEntryElement.getBoundingClientRect(),
							t = this.containerElement.getBoundingClientRect();
						(e.top < t.top || e.bottom > t.bottom) && (this.ignoreEntryOverEvents = !0, 0 === this.props.focusedIndex ? this.containerElement.scrollTop = 0 : this.selectedEntryElement.scrollIntoView(e.top < t.top)), this.props.onEntryFocus(this.props.focusedIndex)
					}
				}
				getEntryContentComponent(e, t) {
					switch (e) {
						case p.a.OWN_PROFILE:
							return K;
						default:
							return V
					}
				}
				render() {
					const {
						focusedIndex: e,
						items: t
					} = this.props, n = [];
					return this.props.showNoMatchesCaption && n.push(a.a.createElement(v, {
						key: "no-matches"
					}, a.a.createElement("div", {
						className: z.a.noMatches
					}, s.fbt._("No communities found", null, {
						hk: "4wDUHv"
					})))), Object(u.a)(t, {
						keyFn: e => e.type
					}, (s, o, r, i) => {
						const c = [];
						d(r, i, n => {
							const s = t[n],
								o = n === e,
								r = this.getEntryContentComponent(s.type, s.name);
							r && c.push(a.a.createElement(b, {
								entryIndex: n,
								disabled: s.disabled,
								key: s.id || s.name,
								onSelect: this.props.onEntrySelect,
								onOver: this.onEntryOver,
								onUpdate: this.onEntryUpdate
							}, a.a.createElement(r, {
								highlight: o,
								item: s
							})))
						});
						const l = q[o];
						n.push(a.a.createElement(v, {
							key: o,
							title: l && l()
						}, c))
					}), a.a.createElement("div", {
						className: Object(c.a)(z.a.container, this.props.className, {
							[z.a.mIsValid]: this.props.isValid,
							[z.a.mIsVisible]: n.length > 0
						}),
						ref: this.setContainerRef,
						onMouseDown: this.props.onContainerMouseDown,
						onScroll: this.onScroll
					}, n)
				}
			}
		},
		"./src/reddit/controls/SubredditPicker/Picker/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2sfaZWDVT8JLAt2J9p4IzV",
				mIsActive: "_1d_qHIhircwk0cy-gLlRQq",
				mIsInvalid: "_3sp2CpDC4eODg63Hhf8_lz"
			}
		},
		"./src/reddit/controls/SubredditPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "c", (function() {
				return h
			}));
			n("./node_modules/core-js/modules/es6.regexp.constructor.js");
			var s = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				r = n("./src/reddit/helpers/name/index.ts"),
				i = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				a = n("./src/reddit/models/User/index.ts");
			const c = (e, t, n) => {
					if (Object(r.a)(e, t.name)) {
						const {
							id: e,
							name: i
						} = t, {
							url: a,
							color: c
						} = Object(o.a)({
							shouldHideNsfwIcon: n,
							subredditOrProfile: t
						});
						return {
							rawString: Object(r.b)(i),
							record: {
								id: e,
								name: i,
								iconUrl: a,
								primaryColor: c,
								type: s.a.SUBREDDIT
							}
						}
					}
					return {
						rawString: e,
						record: null
					}
				},
				l = (e, t, n) => {
					const o = Object(a.e)(t);
					if (Object(r.a)(e, o)) {
						const {
							id: e,
							accountIcon: n
						} = t;
						return {
							rawString: Object(r.c)(o),
							record: {
								id: e,
								name: o,
								iconUrl: n,
								type: s.a.PROFILE
							}
						}
					}
					return {
						rawString: e,
						record: null
					}
				},
				d = (e, t, n, s) => {
					if (t && (!n || Object(r.d)(e))) return c(e, t, s);
					if (n && (!t || Object(r.e)(e))) return l(e, n);
					if (t && n) {
						const o = c(e, t, s);
						return o.record ? o : l(e, n)
					}
					return {
						rawString: e,
						record: null
					}
				},
				u = e => {
					let t;
					return t = e.type === s.a.PROFILE ? i.a.OWN_PROFILE : i.a.OTHER_SUBREDDIT, Object.assign(Object.assign({}, e), {
						type: t
					})
				},
				p = new RegExp("^(r/)?[A-Za-z0-9][A-Za-z0-9_]{1,20}$", "i"),
				m = new RegExp("^u/[A-Za-z0-9_-]{2,20}$", "i"),
				h = e => p.test(e) || m.test(e) || "" === e
		},
		"./src/reddit/controls/SubredditPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return Z
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/lodash/isEqual.js"),
				i = n.n(r),
				a = n("./src/reddit/helpers/name/index.ts");
			class c extends o.a.Component {
				constructor(e) {
					super(e), this.isFocused = !1, this.onFocus = () => {
						this.isFocused = !0, this.props.onFocus && this.props.onFocus()
					}, this.onChange = (e, t) => {
						this.setState({
							value: e
						}, () => {
							t && (this.props.onSelect(e), this.isFocused = !1)
						})
					}, this.state = {
						value: e.value
					}
				}
				componentWillReceiveProps(e) {
					const {
						value: t
					} = this.state, {
						value: n
					} = e;
					if (!i()(t, n) && !this.isFocused) {
						t.record && !n.record && Object(a.a)(t.record.name, n.rawString) ? this.setState({
							value: {
								rawString: n.rawString,
								record: t.record
							}
						}) : this.setState({
							value: n
						})
					}
				}
				render() {
					return o.a.createElement(o.a.Fragment, null, this.props.renderPicker({
						onChange: this.onChange,
						onFocus: this.onFocus,
						value: this.state.value
					}))
				}
			}
			var l = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/objectSelector/index.ts"),
				p = n("./src/reddit/actions/subredditAutocomplete.ts"),
				m = n("./src/reddit/actions/subredditCrosspostable.ts"),
				h = n("./src/reddit/actions/subscription/index.ts"),
				b = n("./src/reddit/controls/SubredditPicker/helpers.ts"),
				f = n("./node_modules/lodash/debounce.js"),
				g = n.n(f),
				x = n("./src/lib/classNames/index.ts"),
				y = n("./src/reddit/constants/keycodes.ts"),
				v = n("./src/reddit/constants/posts.ts"),
				C = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				E = (n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/fbt/lib/FbtPublic.js")),
				O = n("./src/lib/lessComponent.tsx"),
				j = n("./src/reddit/components/SubredditIcon/index.tsx"),
				w = n("./src/reddit/components/UserIcon/CurrentUserIcon.tsx"),
				S = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				_ = n("./src/reddit/icons/svgs/Search/index.tsx"),
				k = n("./src/reddit/controls/SubredditPicker/Picker/SearchBar/index.m.less"),
				T = n.n(k);
			const I = O.a.wrapped(j.b, "subredditRoundIcon", T.a),
				P = O.a.wrapped(_.a, "searchIcon", T.a),
				M = O.a.wrapped(w.a, "userIcon", T.a),
				N = O.a.span("iconEmpty", T.a),
				R = e => {
					let {
						className: t,
						disabled: n
					} = e;
					return o.a.createElement(S.b, {
						className: Object(x.a)(T.a.dropdownIcon, t, {
							[T.a.mDisabled]: n
						})
					})
				};

			function L() {
				return (L = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var A = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const F = e => {
				e.preventDefault(), e.stopPropagation()
			};

			function D(e) {
				const {
					className: t,
					disabled: n,
					isActive: s,
					onDropdownClick: r,
					inputRef: i,
					record: a,
					value: c
				} = e, l = A(e, ["className", "disabled", "isActive", "onDropdownClick", "inputRef", "record", "value"]);
				let d = o.a.createElement(N, null);
				return s ? d = o.a.createElement(P, null) : a && (d = a.type === v.a.SUBREDDIT ? o.a.createElement(I, a) : o.a.createElement(M, null)), o.a.createElement("div", {
					className: Object(x.a)(T.a.searchBar, t)
				}, d, o.a.createElement("div", {
					className: T.a.inputWrapper
				}, o.a.createElement("input", L({
					className: T.a.input,
					ref: i,
					disabled: n,
					placeholder: s ? E.fbt._("Search communities", null, {
						hk: "1mtF5A"
					}) : E.fbt._("Choose a community", null, {
						hk: "44gKTd"
					}),
					spellCheck: !1,
					value: c
				}, l))), o.a.createElement("div", {
					onClick: r,
					onMouseDown: F
				}, o.a.createElement(R, {
					disabled: n
				})))
			}
			var B = n("./src/reddit/controls/SubredditPicker/Picker/SubredditDropdown/index.tsx"),
				U = n("./src/reddit/controls/SubredditPicker/Picker/index.m.less"),
				K = n.n(U);
			class H extends o.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.inputRef = null, this.setInputRef = e => {
						this.inputRef = e, this.props.inputRef && this.props.inputRef(e)
					}, this.commitSelection = () => {
						const e = this.getPickerValue(!0);
						Object(b.c)(e.rawString) ? this.props.onChange(e, !0) : this.props.onChange({
							rawString: "",
							record: null
						}, !0), this.state.isOpen && this.setState({
							isOpen: !1
						})
					}, this.callOnChange = () => this.props.onChange(this.getPickerValue()), this.requestAutocomplete = g()(e => this.props.onGetSubredditAutocomplete(e), 200, {
						maxWait: 200
					}), this.selectItem = e => {
						const t = this.props.items[e];
						if (!t) throw new Error("Invalid item index");
						let n;
						n = t.type === C.a.OWN_PROFILE ? Object(a.c)(t.name) : Object(a.b)(t.name), this.setState({
							inputValue: n,
							focusedIndex: e
						}, this.commitSelection)
					}, this.getPickerValue = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						const n = t.state.inputValue,
							s = t.state.focusedIndex,
							{
								items: o,
								value: r
							} = t.props;
						if (r && r.record && Object(a.a)(n, r.record.name)) return Object.assign(Object.assign({}, r), {
							rawString: n
						});
						const i = o[s] || e && o.find(e => Object(a.a)(e.name, n));
						if (!i) return {
							rawString: n,
							record: null
						};
						const {
							type: c,
							id: l,
							name: d,
							iconUrl: u,
							primaryColor: p,
							allowedPostTypes: m
						} = i;
						return {
							rawString: n,
							record: Object(a.a)(n, d) ? {
								id: l,
								name: d,
								iconUrl: u,
								primaryColor: p,
								allowedPostTypes: m,
								type: c === C.a.OWN_PROFILE ? v.a.PROFILE : v.a.SUBREDDIT
							} : null
						}
					}, this.findNextEnabledItemIndex = e => {
						const t = e ? -1 : 1;
						let n = this.state.focusedIndex + t,
							s = this.props.items[n];
						for (; s;) {
							if (!s.disabled) return n;
							n += t, s = this.props.items[n]
						}
						return n
					}, this.moveSelection = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						const {
							value: n,
							items: s
						} = t.props;
						let o = t.findNextEnabledItemIndex(e);
						o < -1 ? o = s.length - 1 : o >= s.length && (o = -1);
						const r = -1 === o ? n.rawString : s[o].name;
						r && t.setState({
							focusedIndex: o,
							inputValue: r
						})
					}, this.placeCursorAtTheEnd = () => {
						const e = this.state.inputValue.length;
						this.inputRef && this.inputRef.setSelectionRange(e, e)
					}, this.onDropdownClick = e => {
						const {
							inputRef: t
						} = this;
						this.state.isOpen ? this.setState({
							isOpen: !1
						}) : (t && t.focus(), this.setState({
							isOpen: !0
						}), this.placeCursorAtTheEnd()), e.preventDefault(), e.stopPropagation()
					}, this.onFocus = () => {
						this.props.onFocus && this.props.onFocus(), this.setState({
							isActive: !0,
							isOpen: !0
						}), this.inputRef && this.inputRef.select()
					}, this.onBlur = () => {
						this.props.selectOnBlur && this.state.isOpen ? (this.commitSelection(), this.setState({
							isActive: !1
						})) : this.setState({
							isActive: !1,
							isOpen: !1
						})
					}, this.onDropdownContainerMouseDown = e => {
						e.preventDefault()
					}, this.onEntryFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.onEntrySelect = e => {
						this.selectItem(e)
					}, this.onInputChange = e => {
						this.state.isOpen || this.setState({
							isOpen: !0
						});
						const t = e.target.value;
						this.requestAutocomplete(t), this.setState({
							inputValue: t
						}, this.callOnChange)
					}, this.onKeyDown = e => {
						e.which === y.a.ArrowUp ? (this.moveSelection(!0), e.preventDefault()) : e.which === y.a.ArrowDown ? (this.moveSelection(), e.preventDefault()) : e.which === y.a.Enter || e.which === y.a.Tab ? (-1 !== this.state.focusedIndex ? this.selectItem(this.state.focusedIndex) : this.commitSelection(), e.which !== y.a.Tab && e.preventDefault()) : e.which === y.a.Escape && (this.inputRef && this.inputRef.blur(), e.preventDefault())
					}, this.state = {
						isActive: !1,
						isOpen: !1,
						focusedIndex: 0,
						inputValue: e.value.rawString
					}
				}
				componentDidMount() {
					const {
						value: {
							rawString: e
						}
					} = this.props;
					e && this.requestAutocomplete(e)
				}
				UNSAFE_componentWillReceiveProps(e) {
					this.setState({
						focusedIndex: -1,
						inputValue: e.value.rawString
					})
				}
				render() {
					const {
						className: e,
						disabled: t,
						isValid: n = !0,
						items: s,
						value: r
					} = this.props, {
						isActive: i,
						isOpen: a
					} = this.state, c = r.record;
					return o.a.createElement("div", {
						className: Object(x.a)(K.a.container, e, {
							[K.a.mIsActive]: i,
							[K.a.mIsInvalid]: !n
						})
					}, o.a.createElement(D, {
						disabled: t,
						isActive: this.state.isActive,
						value: this.state.inputValue,
						inputRef: this.setInputRef,
						onDropdownClick: this.onDropdownClick,
						onChange: this.onInputChange,
						onFocus: this.onFocus,
						onBlur: this.onBlur,
						onKeyDown: this.onKeyDown,
						record: c
					}), a && o.a.createElement(B.a, {
						items: s,
						isValid: n,
						focusedIndex: this.state.focusedIndex,
						showNoMatchesCaption: !this.props.haveSuggestions && this.props.isAllDataRetrieved,
						onContainerMouseDown: this.onDropdownContainerMouseDown,
						onEntryFocus: this.onEntryFocus,
						onEntrySelect: this.onEntrySelect
					}))
				}
			}
			var V = H,
				W = n("./src/reddit/selectors/subredditAutocomplete.ts");

			function z() {
				return (z = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const q = Object(u.a)(Object(d.a)((e, t) => t.value, (e, t) => {
					let {
						allowCrosspostableOnly: n,
						includeUserProfile: s,
						value: o
					} = t;
					return Object(W.a)(e, {
						allowCrosspostableOnly: n,
						includeUserProfile: s,
						substring: o.rawString
					})
				}, (e, t) => {
					const {
						suggestedItems: n,
						fallbackItems: s,
						isAllDataRetrieved: o
					} = t, r = n.length ? n : e.record ? [Object(b.a)(e.record)] : [];
					return {
						items: 0 === r.length && o ? s : r,
						haveSuggestions: r.length > 0,
						isAllDataRetrieved: t.isAllDataRetrieved,
						isAutocompletePending: t.isPending
					}
				})),
				G = {
					onGetInitialData: e => t => t(e ? m.d() : h.e()),
					onGetSubredditAutocomplete: p.d
				};
			class J extends o.a.Component {
				constructor() {
					super(...arguments), this.onGetSubredditAutocomplete = e => {
						this.props.onGetSubredditAutocomplete(e)
					}
				}
				componentDidMount() {
					this.props.onGetInitialData(!!this.props.allowCrosspostableOnly)
				}
				render() {
					return o.a.createElement(V, z({}, this.props, {
						onGetSubredditAutocomplete: this.onGetSubredditAutocomplete
					}))
				}
			}
			var Q = Object(l.b)(q, G)(J);
			class Z extends o.a.Component {
				constructor() {
					super(...arguments), this.renderPicker = e => o.a.createElement(Q, {
						allowCrosspostableOnly: this.props.allowCrosspostableOnly,
						className: this.props.className,
						disabled: this.props.disabled || !1,
						includeUserProfile: this.props.includeUserProfile,
						inputRef: this.props.inputRef,
						isValid: this.props.isValid,
						onChange: e.onChange,
						onFocus: e.onFocus,
						value: e.value,
						selectOnBlur: this.props.selectOnBlur || !1
					})
				}
				render() {
					return o.a.createElement(c, {
						onFocus: this.props.onFocus,
						onSelect: this.props.onSelect,
						renderPicker: this.renderPicker,
						value: this.props.value
					})
				}
			}
		},
		"./src/reddit/controls/TextButton/index.m.less": function(e, t, n) {
			e.exports = {
				textButton: "qYzY57HWQ8W424hj3s10-"
			}
		},
		"./src/reddit/controls/TextButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/TextButton/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("button", {
				children: e.children,
				className: Object(r.a)(a.a.textButton, e.className),
				disabled: e.disabled,
				onClick: e.onClick
			})
		},
		"./src/reddit/controls/ToggleSwitch/index.m.less": function(e, t, n) {
			e.exports = {
				toggleDisplay: "_2FKpII1jz0h6xCAw1kQAvS",
				toggleSwitch: "_2e2g485kpErHhJQUiyvvC2",
				mActive: "_1L5kUnhRYhUJ4TkMbOTKkI",
				mDisabled: "_3clF3xRMqSWmoBQpXv8U5z"
			}
		},
		"./src/reddit/controls/ToggleSwitch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/ToggleSwitch/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("button", {
				"aria-checked": e.on,
				className: Object(r.a)(a.a.toggleSwitch, e.className, {
					[a.a.mActive]: e.on && !e.disabled || e.forceOn && e.on,
					[a.a.mDisabled]: e.disabled
				}),
				style: e.on && !e.disabled && e.activeColorOverride ? {
					backgroundColor: e.activeColorOverride
				} : void 0,
				id: e.id,
				role: "switch",
				tabIndex: e.tabIndex,
				type: "button",
				onClick: () => !e.disabled && e.onToggle && e.onToggle()
			}, o.a.createElement("div", {
				className: a.a.toggleDisplay
			}))
		},
		"./src/reddit/controls/Typography/index.m.less": function(e, t, n) {
			e.exports = {
				heading1: "_37JeV292IJA7_x1qej_-2H",
				heading2: "p13k-tsMcatGBlVpJBZmw",
				heading3: "_1nHvvYpmn7q9eWDAGzKcce",
				heading4: "_1-rwUWsB5F8WmYI8F66dai",
				heading5: "_22RKdGqihAj6MFumW6DuRV",
				heading6: "_4xqrI_N1UdqsK9E1RSisG",
				body1: "_2HJOIn4SJm4z1NeCv_hNFu",
				body2: "_3ImIPX9rfoPmUrZ1R8KGqS",
				actionFont: "_3uShGanwyVFBaTiPMFzfAC",
				metadata: "_2nyJGeaFJbXTqTh9OGwxfu",
				metadata3: "_3BIqvjJkJKZfH4vtC11dGF"
			}
		},
		"./src/reddit/controls/Typography/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/controls/Typography/index.m.less"),
				r = n.n(o);
			s.a.h1("heading1", r.a), s.a.h2("heading2", r.a), s.a.h3("heading3", r.a), s.a.h4("heading4", r.a);
			const i = s.a.h5("heading5", r.a),
				a = (s.a.h6("heading6", r.a), s.a.p("body1", r.a), s.a.p("body2", r.a)),
				c = (s.a.p("actionFont", r.a), s.a.p("metadata", r.a));
			s.a.p("metadata3", r.a)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/controls/InternalLink/index.tsx"),
				r = n("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				i = n.n(r);
			t.a = s.a.wrapped(o.a, "unstyledInternalLink", i.a)
		},
		"./src/reddit/endpoints/economics/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/config.ts"),
				o = n("./src/reddit/endpoints/governance/requester.ts");
			const r = (e, t) => Object(o.a)(e, {
					method: "post",
					endpoint: "".concat(s.a.metaUrl, "/orders"),
					data: {
						price: "0",
						currency: "usd",
						products: [{
							productId: t.productId,
							quantity: "1"
						}],
						subredditId: t.subredditId
					}
				}),
				i = (e, t) => Object(o.a)(e, {
					method: "get",
					endpoint: "".concat(s.a.metaUrl, "/product-collections/").concat(t, "?types=emotes_pack")
				})
		},
		"./src/reddit/endpoints/economics/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./src/config.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				r = n("./src/reddit/constants/headers.ts"),
				i = n("./src/reddit/endpoints/governance/requester.ts"),
				a = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				c = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts");

			function l(e, t) {
				return Object(i.a)(e, {
					endpoint: "".concat(s.a.metaUrl, "/communities/").concat(t.subredditId, "/me"),
					method: "patch",
					data: {
						specialMemberships: {
							settings: {
								renew: !1
							}
						}
					}
				})
			}

			function d(e, t) {
				return Object(i.a)(e, {
					endpoint: "".concat(s.a.metaUrl, "/ps/me/braintree-client-tokens"),
					method: "post",
					data: {
						username: t && t.username
					}
				})
			}

			function u(e, t) {
				return Object(i.a)(e, {
					endpoint: "".concat(s.a.metaUrl, "/orders"),
					method: "post",
					data: {
						currency: "usd",
						orderTarget: "special_membership",
						price: t.trial ? "0" : t.price,
						products: [{
							productId: t.productId,
							quantity: "1"
						}],
						providerArgs: {
							paymentNonce: t.nonce,
							savePaymentMethod: !0
						},
						providerName: "braintree",
						subredditId: t.subredditId,
						targetArgs: {
							renew: !0,
							receiverName: t.username
						}
					}
				})
			}

			function p(e, t) {
				return Object(i.a)(Object(o.a)(e, [r.a]), {
					endpoint: "".concat(e.apiUrl, "/api/info?id=").concat(t.join(",")),
					method: "get"
				}).then(e => {
					if (e.ok) {
						const t = e.body.data.children.map(e => {
							let {
								data: t
							} = e;
							return Object(c.a)(t)
						}).reduce((e, t) => (e[t.id] = t, e), {});
						return Object.assign(Object.assign({}, e), {
							body: t
						})
					}
					return e
				})
			}
			async function m(e, t) {
				const n = await Object(i.a)(e, {
					endpoint: "".concat(s.a.metaUrl, "/orders"),
					method: "post",
					data: Object.assign(Object.assign({}, t), {
						currency: "points",
						orderTarget: "special_membership",
						products: [{
							productId: "provisional_membership",
							quantity: "1"
						}],
						targetArgs: {
							renew: !1
						}
					})
				});
				if (!n.ok) throw new Error("Error fetching provisional membership: ".concat(Object(a.b)(n.error)));
				return n.body
			}
		},
		"./src/reddit/endpoints/economics/subredditPremium.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/merge.js"),
				o = n.n(s),
				r = n("./src/config.ts"),
				i = n("./src/reddit/endpoints/governance/badges.ts"),
				a = n("./src/reddit/endpoints/governance/community.ts"),
				c = n("./src/reddit/endpoints/governance/products/badges.ts"),
				l = n("./src/reddit/endpoints/governance/requester.ts");
			async function d(e, t, n) {
				const s = {
						subredditId: t,
						badges: {},
						errors: {},
						collections: {},
						products: {},
						subscription: void 0,
						userOwnedBadges: []
					},
					d = function(e, t) {
						return Object(l.a)(e, {
							method: "get",
							endpoint: "".concat(r.a.metaUrl, "/product-collections/").concat(t, "?types=badge")
						})
					}(e, t),
					u = Object(a.a)(e, {
						subredditId: t
					}),
					p = Object(c.b)(e, t),
					m = Object(i.c)(e, t, n),
					[h, b, f, g] = await Promise.all([d, u, p, m]);
				if (h.ok ? s.collections = h.body : s.errors.collections = h.error, b.ok) {
					const e = b.body;
					s.subscription = e.specialMemberships, s.communityRaw = e
				}
				return f.ok ? s.products = f.body : s.errors.products = f.error, g.ok ? (o()(s.badges, g.body.badges), s.userOwnedBadges = g.body.userOwnedBadges) : s.errors.userBadges = g.error, s
			}
			const u = (e, t) => Object(l.a)(e, {
				endpoint: "".concat(r.a.metaUrl, "/products/").concat(t, "?types=badge,membership"),
				method: "delete"
			})
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "k", (function() {
				return b
			}));
			var s, o = n("./src/config.ts"),
				r = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "Ethereum Main Network";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}

			function a(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "https://meta-api.reddit.com/ethereum/ethereum";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "https://meta-api.reddit.com/ethereum/rinkeby"
				}
				throw new Error("No JSON RPC url for provider: ".concat(e))
			}

			function c(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "homestead";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "rinkeby"
				}
				throw new Error("No ethereum network for provider: ".concat(e))
			}
			async function l(e, t, n) {
				return Object(r.a)(e, {
					method: "post",
					endpoint: "".concat(o.a.metaUrl, "/crypto/").concat(t, "/challenges"),
					data: {
						challengeType: "registration-challenge-EIP712",
						address: n
					}
				})
			}
			async function d(e, t, n) {
				return await Object(r.a)(e, {
					method: "post",
					endpoint: "".concat(o.a.metaUrl, "/crypto/").concat(t, "/registrations"),
					data: n
				})
			}
			async function u(e, t, n) {
				return await Object(r.a)(e, {
					method: "delete",
					endpoint: "".concat(o.a.metaUrl, "/crypto/").concat(t, "/registrations/").concat(n)
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.EthTraderEthereum = "ethereum:1:ethtrader", e.EthTraderRinkeby = "ethereum:4:ethtrader", e.Stellar = "stellar"
			}(s || (s = {}));
			const p = e => ({
					type: "claim",
					subredditId: e
				}),
				m = e => ({
					type: "subscribe",
					subredditId: e
				}),
				h = (e, t, n, s) => ({
					type: "transfer",
					subredditId: e,
					recipient: t,
					recipientAddress: n,
					amount: s
				});
			async function b(e, t) {
				return await Object(r.a)(e, {
					method: "put",
					endpoint: "".concat(o.a.metaUrl, "/crypto/ethereum/transaction-intent"),
					data: t
				})
			}
		},
		"./src/reddit/endpoints/governance/poll.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/lodash/get.js"),
				o = n.n(s),
				r = n("./src/config.ts"),
				i = n("./src/graphql/operations/PollVote.json"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				d = (n("./src/reddit/models/Poll/index.ts"), n("./src/reddit/endpoints/governance/requester.ts"));

			function u(e, t, n, s) {
				return Object(d.a)(e, {
					method: "put",
					endpoint: "".concat(r.a.metaUrl, "/polls/").concat(t, "/").concat(n, "/votes/me/").concat(s)
				})
			}
			const p = (e, t, n) => Object(a.a)(e, Object.assign(Object.assign({}, i), {
				variables: {
					input: {
						postId: t,
						optionId: n
					}
				}
			}));

			function m(e, t) {
				return Object(d.a)(Object(c.a)(e, [l.a]), {
					method: "get",
					endpoint: "".concat(e.apiUrl, "/by_id/").concat(t, ".json")
				}).then(e => e.ok ? Object.assign(Object.assign({}, e), {
					body: {
						title: o()(e.body, ["data", "children", 0, "data", "title"], ""),
						url: o()(e.body, ["data", "children", 0, "data", "permalink"], "")
					}
				}) : e)
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				o = (n("./src/lib/bigNumberUtils/percent.ts"), n("./src/lib/constants/index.ts")),
				r = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(r.a)(e, {
					endpoint: "".concat(s.a.metaUrl, "/wallets/").concat(t.subredditId, "/me"),
					method: o.db.GET
				}).then(e => {
					if (e.ok) {
						const n = e.body,
							s = {
								[t.subredditId]: n
							};
						return Object.assign(Object.assign({}, e), {
							body: s
						})
					}
					return e
				})
			}

			function a(e, t) {
				return Object(r.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: "".concat(s.a.metaUrl, "/wallets/").concat(t.subredditId),
					method: o.db.POST,
					data: t.userIds
				}).then(e => e.ok ? Object.assign(Object.assign({}, e), {
					body: {
						wallets: e.body
					}
				}) : e)
			}
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/graphql/operations/CreateScheduledPost.json"),
				o = n("./src/graphql/operations/SubredditScheduledPosts.json"),
				r = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/helpers/richTextJson/index.ts"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/ScheduledPost/index.ts");
			const u = (e, t) => Object(r.a)(e, Object.assign(Object.assign({}, o), {
					variables: Object.assign(Object.assign({}, t), {
						includeRecurring: !(!t.includeRecurring || !t.includeRecurring.recurringFirst),
						includeStandalone: !(!t.includeStandalone || !t.includeStandalone.standaloneFirst),
						recurringAfter: t.includeRecurring ? t.includeRecurring.recurringAfter : void 0,
						recurringFirst: t.includeRecurring ? t.includeRecurring.recurringFirst : void 0,
						standaloneAfter: t.includeStandalone ? t.includeStandalone.standaloneAfter : void 0,
						standaloneFirst: t.includeStandalone ? t.includeStandalone.standaloneFirst : void 0
					})
				})),
				p = (e, t) => {
					if (!e.ok || !e.body) return !1;
					const n = e.body;
					return !!(n.data && n.data.subredditInfoById && n.data.subredditInfoById.scheduledPosts && n.data.subredditInfoById.scheduledPosts[t] && n.data.subredditInfoById.scheduledPosts[t].edges)
				},
				m = (e, t) => !(!e.ok || !e.body) && (!(t.includeStandalone && !(e => p(e, d.f.standalonePosts))(e)) && !(t.includeRecurring && !(e => p(e, d.f.recurringPosts))(e))),
				h = e => {
					let {
						poll: t,
						schedule: n,
						submission: s,
						subredditId: o
					} = e;
					return Object.assign(Object.assign(Object.assign({
						collectionId: s.collectionId || "",
						discussionType: s.isChatPost ? c.b.Chat : c.b.Comment,
						isContestMode: s.isContestMode,
						isSpoiler: s.isSpoiler,
						isNsfw: s.isNSFW,
						poll: t && C(t),
						title: s.title,
						isOriginalContent: s.isOC,
						flair: s.flair ? {
							id: s.flair.templateId,
							text: Object(i.g)(s.flair)
						} : {},
						sticky: s.sticky,
						subredditId: o,
						suggestedCommentSort: s.suggestedSort,
						isSendReplies: s.sendReplies
					}, b(n)), y(s)), {
						assetIds: v(s)
					})
				},
				b = e => ({
					scheduling: {
						publishAt: e.submitDate,
						clientTimezone: e.timezoneName,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					}
				}),
				f = e => ({
					scheduling: Object.keys(e).length > 0 ? {
						clientTimezone: e.timezoneName || void 0,
						publishAt: e.submitDate || void 0,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					} : void 0
				}),
				g = e => {
					let {
						poll: t,
						schedule: n,
						scheduledPostId: s,
						submission: o,
						subredditId: r
					} = e;
					const i = h({
						poll: t,
						schedule: n,
						submission: o,
						subredditId: r
					});
					return Object.assign(Object.assign({
						id: s
					}, i), {
						flair: Object.keys(i.flair || {}).length ? Object.assign({}, i.flair) : {
							id: "",
							text: ""
						}
					})
				},
				x = e => /^https?:\/\//i.test(e) ? e : "http://".concat(e),
				y = e => {
					switch (e.kind) {
						case l.o.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case l.o.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case l.o.LINK:
							return {
								content: {}, link: {
									url: x(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				v = e => {
					let t = [];
					if (e.document) {
						const n = e.document || [];
						t = Object(a.c)(n)
					}
					return t
				},
				C = e => {
					if (e && e.options && e.duration && (e.options = e.options.map(e => ({
							text: e.text.trim()
						})).filter(e => !!e.text), e.options.length)) return e.duration = Math.floor(e.duration / 864e5), e
				},
				E = (e, t) => Object(r.a)(e, Object.assign(Object.assign({}, s), {
					variables: {
						input: t
					}
				}))
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/graphql/operations/UpdateScheduledPost.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			const r = (e, t) => Object(o.a)(e, Object.assign(Object.assign({}, s), {
				variables: {
					input: t
				}
			}))
		},
		"./src/reddit/featureFlags/component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/featureFlags/index.ts"),
				c = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
					}
					return n
				};

			function l(e, t, n) {
				const s = Object(i.c)({
					featureEnabled: t => a.d[e](t)
				});
				return Object(r.b)(s)(e => {
					const {
						featureEnabled: s
					} = e, r = c(e, ["featureEnabled"]);
					return s ? o.a.createElement(t, r) : void 0 !== n ? o.a.createElement(n, r) : null
				})
			}
		},
		"./src/reddit/helpers/canPreviewSelfText/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/postHasSelfText/index.ts");
			t.a = e => (Object(s.a)(e) || !!e.pollData) && !e.isSpoiler && !e.isNSFW
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-dnd/lib/index.js"),
				o = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				r = n.n(o);
			t.a = Object(s.DragDropContext)(r.a)
		},
		"./src/reddit/helpers/externalAccount/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = () => new BroadcastChannel("external_account"),
				o = e => {
					const t = s();
					t.postMessage({
						type: "connected",
						provider: e
					}), t.close()
				}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return b
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js");
			const s = e => e.subredditInfoById.scheduledPosts.recurringPosts ? {
					recurringPosts: {
						models: m(e.subredditInfoById.scheduledPosts.recurringPosts.edges),
						pageInfo: Object.assign({}, e.subredditInfoById.scheduledPosts.recurringPosts.pageInfo)
					},
					recurringPostsIds: e.subredditInfoById.scheduledPosts.recurringPosts.edges.map(e => e.node.id)
				} : {},
				o = e => e.subredditInfoById.scheduledPosts.standalonePosts ? {
					standalonePosts: {
						models: u(e.subredditInfoById.scheduledPosts.standalonePosts.edges),
						pageInfo: Object.assign({}, e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo)
					},
					standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
				} : {},
				r = e => Object.assign(Object.assign({}, e), {
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: Object.assign(Object.assign({}, s(e)), o(e))
					}
				}),
				i = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.recurringPosts && !!e.subredditInfoById.scheduledPosts.recurringPostsIds,
				a = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.standalonePosts && !!e.subredditInfoById.scheduledPosts.standalonePostsIds,
				c = e => i(e) && a(e),
				l = e => !i(e) && a(e),
				d = e => i(e) && !a(e),
				u = e => e.map(e => p(e.node)),
				p = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					collectionId: e.collections.edges.length ? e.collections.edges[0].node.id : void 0,
					discussionType: e.discussionType,
					isContestMode: e.isContestMode,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					isSticky: !!e.sticky && "NONE" !== e.sticky,
					mediaAssets: e.mediaAssets,
					subreddit: Object.assign({}, e.subreddit),
					suggestedCommentSort: e.suggestedCommentSort,
					owner: Object.assign({}, e.owner),
					poll: e.poll,
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt.split(".")[0],
					state: e.state,
					flair: e.flair ? Object.assign({}, e.flair) : void 0,
					sticky: e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				}),
				m = e => e.map(e => h(e.node)),
				h = e => Object.assign(Object.assign({}, p(e)), {
					frequency: e.frequency,
					byMonthDays: e.byMonthDays || [],
					byWeekDays: e.byWeekDays || [],
					interval: e.interval || 1
				}),
				b = e => (e => !!e.frequency && !!e.interval)(e) ? h(e) : p(e)
		},
		"./src/reddit/helpers/isCrosspost.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return !!e && !!e.crosspostRootId
			}
		},
		"./src/reddit/helpers/isRemoved.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e.bannedBy && !e.isSpam
		},
		"./src/reddit/helpers/mediaGallery/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/core-js/modules/es6.array.sort.js");
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				o = n.n(s),
				r = n("./src/reddit/models/Media/index.ts");

			function i(e, t) {
				const n = t.sort((e, t) => e.y - t.y),
					s = n.find(t => t.y > e);
				if (s) return s;
				const o = n.pop();
				return o || null
			}

			function a(e) {
				const t = u(e),
					n = t.every(e => e.y > e.x),
					s = t.every(e => e.x > e.y);
				return !n && !s
			}

			function c(e, t, n) {
				const s = u(e);
				if (h(s, t)) return !0;
				const o = p(s).y;
				return !o || o < n
			}
			const l = e => e ? r.j : r.e;

			function d(e, t, n, s) {
				const o = u(e);
				if (h(o, t)) return t;
				const r = p(o);
				let i = r.y;
				return !i || i < n ? n : (s > 0 && (i = s * i / r.x), i > t ? t : i)
			}
			const u = e => Object.entries(e).reduce((e, t) => {
					let [n, s] = t;
					return s && s.s && e.push(s.s), e
				}, []),
				p = e => e.reduce((e, t) => m(e, t), e && e[0] || []),
				m = (e, t) => {
					const n = e.x / e.y + .005,
						s = e.x / e.y - .005;
					return t.x / t.y > n ? t : t.x / t.y > s ? e.y > t.y ? e : t : e
				},
				h = (e, t) => e.some(e => e.y > t && Object(r.J)(e.y, e.x));

			function b(e, t) {
				return e && e.items && !t && e.items.some(e => void 0 !== e.caption || void 0 !== e.outboundUrl) ? r.i : 0
			}
			const f = e => {
				const t = o.a.parse(e),
					n = t.path || "",
					s = n.length > 7 ? n.substring(0, 7) + "..." : n;
				return (t.hostname ? t.hostname.replace("www.", "") : "") + s.substring(s.lastIndexOf("/") + 1)
			}
		},
		"./src/reddit/helpers/modTooltipTemplates/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/humanizeUTCDate/index.tsx");
			const r = e => e.approvedBy && "string" == typeof e.approvedBy && e.approvedAtUTC ? s.fbt._("Approved by {username} at {time}", [s.fbt._param("username", e.approvedBy), s.fbt._param("time", Object(o.a)(e.approvedAtUTC))], {
					hk: "3G807D"
				}) : s.fbt._("Approved", null, {
					hk: "3CbKag"
				}),
				i = s.fbt._("Action taken by Automoderator", null, {
					hk: "1zud7K"
				}),
				a = e => {
					let t = e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? s.fbt._("Removed by {username} at {time}", [s.fbt._param("username", e.bannedBy), s.fbt._param("time", Object(o.a)(e.bannedAtUTC))], {
						hk: "2Ey569"
					}) : s.fbt._("Removed", null, {
						hk: "238xK9"
					});
					return e.modReasonBy && e.modRemovalReason && (t = t + "\n" + s.fbt._("Reason by {username}:", [s.fbt._param("username", "u/".concat(e.bannedBy))], {
						hk: "3qLdNZ"
					}) + e.modRemovalReason), e.modNote && (t = t + "\n" + s.fbt._("Note:", null, {
						hk: "2LD4vO"
					}) + e.modNote), t
				},
				c = e => s.fbt._({
					"*": "{number} Reports",
					_1: "1 Report"
				}, [s.fbt._plural(e, "number")], {
					hk: "3S0yx6"
				}),
				l = e => e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? s.fbt._("Removed as spam by {username} at {time}", [s.fbt._param("username", e.bannedBy), s.fbt._param("time", Object(o.a)(e.bannedAtUTC))], {
					hk: "2uutjk"
				}) : s.fbt._("Removed as spam", null, {
					hk: "1hD9G0"
				})
		},
		"./src/reddit/helpers/postHasSelfText/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/Media/index.ts"),
				o = n("./src/reddit/models/RichTextJson/index.ts");
			t.a = e => {
				const t = e && e.media;
				return !!t && (t.type === s.o.TEXT && !!t.content || t.type === s.o.RTJSON && !Object(o.G)(t.richtextContent))
			}
		},
		"./src/reddit/helpers/richTextEditor/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e[e.Post = 0] = "Post", e[e.Comment = 1] = "Comment"
				}(s || (s = {}))
		},
		"./src/reddit/helpers/richTextJson/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/es6.regexp.split.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/models/RichTextJson/index.ts");
			const o = "giphy|",
				r = "|downsized";

			function i(e, t) {
				return o + e + (t ? r : "")
			}

			function a(e) {
				return e && 0 === e.indexOf(o)
			}

			function c(e) {
				const t = e && e.media && e.media.mediaMetadata;
				return !!t && Object.keys(t).some(a)
			}

			function l(e) {
				let t = e.substring(o.length);
				return t.indexOf("|") && (t = t.split("|")[0]), "https://giphy.com/gifs/".concat(t)
			}

			function d(e) {
				return "object" == typeof e && null !== e && !!e.e
			}

			function u(e) {
				const t = e => {
					let n = [];
					const o = e.c && Array.isArray(e.c) ? e.c : [];
					for (const s of o) d(s) && (n = [...n, ...t(s)]);
					return s.F(e) && n.push(e.id), n
				};
				return e.reduce((e, n) => [...e, ...t(n)], [])
			}
		},
		"./src/reddit/helpers/showReportIndicator/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !e.ignoreReports && (e.numReports || 0) > 0
		},
		"./src/reddit/helpers/stripMetaLinks/fromRTJ.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/redditId/index.ts");

			function o(e, t) {
				const n = function e(t, n) {
					let s = !1;
					let o = [];
					try {
						for (const r of t)
							if ("link" === r.e && r.u && r.u.includes("https://www.reddit.com/poll/".concat(n))) s = !0;
							else if (r.c && "string" != typeof r.c) {
							const t = e(r.c, n);
							t.found ? (s = !0, ("par" !== r.e || t.updated.length) && o.push(Object.assign(Object.assign({}, r), {
								c: t.updated
							}))) : o.push(r)
						} else o.push(r)
					} catch (r) {
						s = !1, o = []
					}
					return {
						found: s,
						updated: s ? o : t
					}
				}(e.document, Object(s.c)(t));
				return n.found ? {
					document: n.updated
				} : e
			}
		},
		"./src/reddit/helpers/stripMetaLinks/fromRawHtml.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/es6.regexp.replace.js");
			var s = n("./src/lib/redditId/index.ts");

			function o(e, t, n) {
				return e.replace('href="https://www.reddit.com/poll/'.concat(Object(s.c)(t)), 'class="'.concat(n, '" href="https://www.reddit.com/poll/').concat(Object(s.c)(t)))
			}
		},
		"./src/reddit/helpers/styles/mixins/loading.m.less": function(e, t, n) {
			e.exports = {
				loadingBackground: "fzTkuBRFT8iIn1XnJX_Yn",
				"m-loading": "_34yMY7-6MNnz3utfjExvIq",
				mLoading: "_34yMY7-6MNnz3utfjExvIq",
				gradientAnimation: "vnt666wwqSK5qL63sBn9P",
				loadingBar: "_3giTODNeZ-Po90u8Ghs4aI",
				loadingContainer: "VRC9QT7CgUxvhK0ceQSrn"
			}
		},
		"./src/reddit/helpers/styles/mixins/loading.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/classNames/index.ts"),
				o = n("./src/reddit/helpers/styles/mixins/loading.m.less"),
				r = n.n(o);
			const i = e => {
					let {
						isLoading: t
					} = e;
					return Object(s.a)(r.a.loadingBackground, {
						[r.a["m-loading"]]: t
					})
				},
				a = e => Object(s.a)(r.a.loadingBar, i(e))
		},
		"./src/reddit/helpers/styles/postBackgroundColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			n("./node_modules/polished/dist/polished.es.js");
			var s = n("./src/reddit/models/Theme/NewColorSystem/index.ts");

			function o(e) {
				return e.flairStyleTemplate && e.flairStyleTemplate.postBackgroundColor ? e.flairStyleTemplate.postBackgroundColor : Object(s.a)(e).post
			}
		},
		"./src/reddit/helpers/styles/smartTextColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				o = n("./src/reddit/models/NewStructuredStyles/index.ts");
			const r = e => Object(s.b)(e) < .6;

			function i(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.a.bodyText,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o.b.bodyText;
				return r(e) ? n : t
			}
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			let o;
			const r = () => {
					const e = document.body.dataset.previousOverflow;
					if (!e) return;
					document.body.removeAttribute("data-previous-overflow");
					const t = document.getElementById(s.c);
					document.body.style.overflow = e, document.body.style.marginRight = "", t && (t.style.marginRight = "")
				},
				i = () => {
					if (document.body.dataset.previousOverflow) return;
					const e = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = e, o || (o = a(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = "".concat(o, "px");
					const t = document.getElementById(s.c);
					t && (t.style.marginRight = "".concat(o, "px"))
				},
				a = e => {
					const t = e.getBoundingClientRect();
					return window.innerWidth - (t.left + t.right)
				},
				c = e => {
					if (!e || !document.body) return 0;
					const t = a(document.body),
						n = e.offsetWidth - e.scrollWidth;
					return t || n
				}
		},
		"./src/reddit/helpers/trackers/gallery.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/helpers/parseUrl.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const i = (e, t, n) => Object.assign({
					gallery: r.gallery(e, t, n),
					post: r.post(e, t)
				}, r.defaults(e)),
				a = (e, t) => n => Object.assign(Object.assign({}, i(n, e, t)), {
					action: s.c.VIEW,
					noun: "media",
					source: "gallery",
					media: r.media(n, e)
				}),
				c = (e, t, n) => a => {
					const c = Object(o.a)(t);
					return Object.assign(Object.assign({}, i(a, e, n)), {
						action: s.c.CLICK,
						noun: "outbound_url",
						source: "gallery",
						media: Object.assign(Object.assign({}, r.media(a, e)), {
							outboundUrl: t,
							outboundDomain: c ? c.hostname : void 0
						})
					})
				},
				l = (e, t) => u(e, !0, t),
				d = (e, t) => u(e, !1, t),
				u = (e, t, n) => o => Object.assign(Object.assign({}, i(o, e, n)), {
					action: s.c.CLICK,
					noun: t ? "forward" : "backward",
					source: "gallery"
				})
		},
		"./src/reddit/helpers/trackers/goldPayment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "a", (function() {
				return C
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return j
			}));
			var s = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/models/Gold/ProductOffer.ts"),
				r = n("./src/reddit/selectors/gold/giveAwards.ts"),
				i = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				a = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				d = n("./src/telemetry/models/GoldPurchase.ts"),
				u = n("./src/telemetry/models/Payment.ts"),
				p = n("./src/reddit/helpers/trackers/gild.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				h = n("./src/reddit/helpers/isComment.ts");
			const b = (e, t) => {
					const {
						thingId: n,
						packageId: c
					} = t, u = !!n, b = r.b(e), f = b ? Object(p.getAwardTypeFromAward)(b) : null, g = u ? f : a.m(e) ? d.Premium : d.Coins, x = n ? Object(h.a)(n) ? "comment" : "post" : void 0, y = c || a.q(e), v = [...Object(i.b)(e), ...Object(i.d)(e)].filter(e => e.mobileId === y)[0], C = Object(o.b)(v, u), E = v ? Math.round(1e4 * (v.baselinePennies - v.pennies) / v.baselinePennies) / 100 : 0, O = v ? Math.round(1e4 * (v.coins - v.baselineCoins) / v.coins) / 100 : 0, j = v ? v.baselinePennies !== v.pennies ? "".concat(E, "_percent_price") : v.baselineCoins !== v.coins ? "".concat(O, "_percent_bonus") : void 0 : void 0, w = g === d.Premium ? s.ob : v ? v.pennies : void 0;
					return Object.assign(Object.assign({}, l.defaults(e)), {
						comment: n ? l.comment(e, n) : null,
						correlationId: a.o(e) || Object(m.d)(m.a.GoldPayment, !1),
						post: n ? l.post(e, n) : null,
						screen: l.screen(e),
						subreddit: n ? l.subreddit(e) : null,
						goldPurchase: Object.assign(Object.assign({}, b ? {
							awardId: b.id,
							awardName: b.name,
							numberCoinsToRecipient: b.coinReward
						} : null), {
							type: g,
							gildedContent: u,
							contentType: x,
							numberCoins: v ? v.coins : void 0,
							offerContext: C,
							offerType: j
						}),
						payment: {
							currency: "USD",
							amountInSmallestDenom: w
						},
						purchase: {
							priceMicros: w
						}
					})
				},
				f = (e, t) => n => Object.assign(Object.assign({}, b(n, {
					packageId: t,
					thingId: e
				})), {
					source: "gold_payment",
					action: "click",
					noun: "close"
				}),
				g = e => t => Object.assign(Object.assign({}, b(t, {
					thingId: e
				})), {
					source: "gold_payment",
					action: "click",
					noun: "paypal"
				}),
				x = e => t => Object.assign(Object.assign({}, b(t, {
					thingId: e
				})), {
					source: "gold_payment",
					action: "click",
					noun: "continue_paypal"
				}),
				y = e => t => Object.assign(Object.assign({}, b(t, {
					thingId: e
				})), {
					source: "gold_payment",
					action: "click",
					noun: "credit_card"
				}),
				v = e => t => Object.assign(Object.assign({}, b(t, {
					thingId: e
				})), {
					source: "gold_payment",
					action: "click",
					noun: "complete_credit_card"
				}),
				C = e => t => Object.assign(Object.assign({}, b(t, {
					packageId: e
				})), {
					source: "gold_payment",
					action: "click",
					noun: "confirm"
				}),
				E = e => t => Object.assign(Object.assign({}, b(t, {
					thingId: e
				})), {
					source: "gold_payment",
					action: "display",
					noun: "error"
				}),
				O = (e, t) => n => {
					const s = b(n, {
						packageId: t,
						thingId: e
					});
					return Object.assign(Object.assign({}, s), {
						source: "gold_payment",
						action: "view",
						noun: "page",
						payment: Object.assign(Object.assign({}, s.payment), {
							defaultOption: u.PaymentMethod.Paypal
						}),
						goldPurchase: Object.assign(Object.assign({}, s.goldPurchase), {
							source: e ? d.GiveGold : a.m(n) ? d.PremiumMarketing : d.CoinsMarketing
						})
					})
				},
				j = e => t => {
					const n = b(t, {
						thingId: e
					});
					return Object.assign(Object.assign({}, n), {
						source: "gold_payment",
						action: "view",
						noun: "success",
						payment: Object.assign(Object.assign({}, n.payment), {
							method: Object(c.b)(t).queryParams.thanks ? u.PaymentMethod.Paypal : u.PaymentMethod.CreditCard
						})
					})
				}
		},
		"./src/reddit/helpers/trackers/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "p", (function() {
				return y
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "d", (function() {
				return S
			}));
			var s, o, r = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/helpers/trackers/postEvent.ts"),
				a = n("./src/reddit/selectors/platform.ts"),
				c = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.collection = "collection", e.collectionComposer = "collection_composer", e.postComposer = "post_composer", e.postOverflowMenu = "post_overflow_menu"
			}(s || (s = {})),
			function(e) {
				e.post = "post", e.follow = "follow", e.unfollow = "unfollow", e.screen = "screen", e.eventEducation = "event_education", e.eventEducationGotIt = "event_education_got_it", e.collectionEducation = "collection_education", e.collectionEducationGotIt = "collection_education_got_it", e.collectionCancel = "cancel", e.collectionCreate = "collection_create", e.collectionSelect = "collection_select", e.collectionDelete = "collection_delete", e.collectionEdit = "collection_edit", e.collectionAddPost = "collection_add_post", e.collectionRemovePost = "remove_post_from_collection", e.startEvent = "start_event"
			}(o || (o = {}));
			const l = e => t => Object.assign({
					source: s.collection,
					noun: o.post
				}, p(t, e)),
				d = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => Object.assign({
						source: s.collection,
						noun: n ? o.unfollow : o.follow
					}, p(e, t))
				},
				u = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => Object.assign({
						source: i.a.postEvent,
						noun: n ? o.unfollow : o.follow
					}, p(e, t))
				},
				p = (e, t) => {
					const n = Object.assign(Object.assign({}, c.defaults(e)), {
						action: r.c.CLICK,
						subreddit: c.subreddit(e)
					});
					return void 0 === t ? n : Object.assign(Object.assign({}, n), {
						post: c.post(e, t),
						postCollection: c.postCollectionI13nSelector(e, {
							postId: t
						}),
						postEvent: c.postEventI13nSelector(e, {
							postId: t
						})
					})
				},
				m = e => Object.assign(Object.assign({}, g(e)), {
					action: r.c.VIEW,
					noun: o.collectionEducation
				}),
				h = e => Object.assign(Object.assign({}, g(e)), {
					action: r.c.CLICK,
					noun: o.collectionEducationGotIt
				}),
				b = e => Object.assign(Object.assign({}, g(e)), {
					action: r.c.VIEW,
					noun: o.eventEducation
				}),
				f = e => Object.assign(Object.assign({}, g(e)), {
					action: r.c.CLICK,
					noun: o.eventEducationGotIt
				}),
				g = e => Object.assign(Object.assign({}, c.defaults(e)), {
					subreddit: c.subreddit(e),
					source: s.postComposer
				}),
				x = (e, t) => n => Object.assign(Object.assign({}, p(n, e)), {
					source: t || s.postOverflowMenu,
					noun: o.collectionAddPost
				}),
				y = e => t => Object.assign(Object.assign({}, p(t, e)), {
					source: s.collectionComposer,
					noun: o.collectionRemovePost
				}),
				v = () => e => Object.assign(Object.assign({}, p(e)), {
					source: s.collectionComposer,
					noun: o.collectionCancel
				}),
				C = () => e => {
					const t = Object(a.o)(e) || void 0;
					return Object.assign(Object.assign({}, p(e, t)), {
						source: s.collectionComposer,
						noun: o.collectionCreate
					})
				},
				E = () => e => Object.assign(Object.assign({}, p(e)), {
					source: s.collectionComposer,
					noun: o.collectionSelect
				}),
				O = e => t => Object.assign(Object.assign({}, c.defaults(t)), {
					subreddit: c.subreddit(t),
					source: s.collectionComposer,
					action: r.c.CLICK,
					noun: o.collectionDelete,
					postCollection: c.postCollectionI13nByCollectionIdSelector(t, {
						collectionId: e
					})
				}),
				j = e => t => Object.assign(Object.assign({}, p(t)), {
					source: s.collectionComposer,
					noun: o.collectionEdit,
					postCollection: c.postCollectionI13nByCollectionIdSelector(t, {
						collectionId: e
					})
				}),
				w = e => t => Object.assign(Object.assign({}, p(t, e)), {
					source: s.collectionComposer,
					noun: o.startEvent
				}),
				S = () => e => {
					const t = Object(a.o)(e) || void 0;
					return Object.assign(Object.assign({}, p(e, t)), {
						source: s.collectionComposer,
						action: r.c.VIEW,
						noun: o.screen
					})
				}
		},
		"./src/reddit/helpers/trackers/postEvent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return y
			}));
			var s, o = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/eventTools/index.ts"),
				i = n("./src/lib/timezone/index.ts"),
				a = n("./src/reddit/constants/tracking.ts"),
				c = n("./src/reddit/models/PostCreationForm/index.ts"),
				l = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				p = n("./src/telemetry/index.ts");
			! function(e) {
				e.postEvent = "post_event", e.postComposer = "post_composer", e.eventComposer = "event_composer"
			}(s || (s = {}));
			const m = e => u.actionInfo(e, {
					pageType: "event_submit"
				}),
				h = e => {
					Object(p.a)(Object.assign(Object.assign({}, u.defaults(e)), {
						source: s.postComposer,
						action: a.c.CLICK,
						noun: "event_create",
						subreddit: u.subreddit(e)
					}))
				},
				b = e => {
					Object(p.a)(Object.assign(Object.assign({}, u.defaults(e)), {
						source: s.postComposer,
						action: a.c.CLICK,
						noun: "event_edit",
						subreddit: u.subreddit(e),
						postEvent: v(e),
						postComposer: C(e)
					}))
				},
				f = () => e => ({
					source: s.eventComposer,
					action: a.c.VIEW,
					noun: a.b.SCREEN,
					actionInfo: m(e),
					postEvent: v(e)
				}),
				g = e => t => Object.assign(Object.assign({}, j(t, Object(l.o)(t))), {
					source: s.postComposer,
					noun: "apply",
					postComposer: E(e)
				}),
				x = () => e => Object.assign(Object.assign({}, j(e, Object(l.o)(e))), {
					noun: "cancel",
					actionInfo: m(e)
				}),
				y = e => t => Object.assign(Object.assign({}, j(t, Object(l.o)(t))), {
					noun: "delete",
					actionInfo: m(t),
					postComposer: C(t),
					postEvent: O(e)
				}),
				v = e => {
					const t = Object(d.o)(e);
					return t && O(t)
				},
				C = e => E(Object(d.o)(e)),
				E = e => {
					return {
						postScheduled: !!e,
						submitScheduledTime: e && e.submitTime === c.i.AtEventTime ? Object(i.f)(e.startDate).getTime() / o.Fb : void 0
					}
				},
				O = e => {
					const t = Object(i.f)(e.startDate).getTime() / o.Fb,
						n = Object(i.f)(e.endDate).getTime() / o.Fb;
					return {
						eventStartTimestamp: t,
						eventEndTimestamp: n,
						eventState: Object(r.e)(t, n)
					}
				},
				j = (e, t) => {
					const n = {
						source: s.eventComposer,
						action: a.c.CLICK,
						subreddit: u.subreddit(e)
					};
					return t ? Object.assign(Object.assign({}, n), {
						post: u.post(e, t),
						postEvent: u.postEventI13nSelector(e, {
							postId: t
						}),
						postCollection: u.postCollectionI13nSelector(e, {
							postId: t
						})
					}) : n
				}
		},
		"./src/reddit/helpers/trackers/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "e", (function() {
				return u
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/reddit/helpers/flair.ts");
			const i = (e, t) => n => Object.assign(Object.assign({
					source: "post",
					action: "click",
					noun: "post_flair"
				}, o.defaults(n)), {
					actionInfo: o.actionInfo(n),
					correlationId: Object(s.c)(s.a.SearchResults),
					post: o.post(n, e),
					search: Object.assign(Object.assign({}, o.postFlairClickToSearch(n, t)), {
						query: "flair_name:'".concat(t.postFlairName, "'"),
						queryId: Object(s.c)(s.a.SearchResults)
					}),
					subreddit: o.subreddit(n)
				}),
				a = e => t => Object.assign(Object.assign({
					source: "post_flair_widget",
					action: "click",
					noun: "post_flair_search"
				}, o.defaults(t)), {
					actionInfo: o.actionInfo(t),
					correlationId: Object(s.c)(s.a.SearchResults),
					search: o.postFlairClickToSearch(t, e),
					subreddit: o.subreddit(t)
				}),
				c = e => t => {
					const n = Object(r.g)(e);
					return Object.assign(Object.assign({}, o.defaults(t)), {
						action: "click",
						noun: "post_flair",
						source: "post_flair_widget",
						subreddit: o.subreddit(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					})
				},
				l = () => e => Object.assign(Object.assign({}, o.defaults(e)), {
					action: "click",
					noun: "overflow",
					source: "post_flair_widget",
					subreddit: o.subreddit(e)
				}),
				d = e => t => {
					const n = Object(r.g)(e);
					return Object.assign(Object.assign({}, o.defaults(t)), {
						action: "click",
						noun: "clear",
						source: "post_flair_widget",
						subreddit: o.subreddit(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					})
				},
				u = (e, t) => n => {
					const i = Object(r.g)(e),
						a = o.post(n, t);
					return Object.assign(Object.assign({}, o.defaults(n)), {
						action: "click",
						noun: "post_flair",
						source: "post",
						subreddit: o.subreddit(n),
						postFlair: {
							id: e.templateId,
							title: i
						},
						post: a,
						search: {
							query: "flair_name:'".concat(i, "'"),
							subredditId: a ? a.subredditId : void 0,
							subredditName: a ? a.subredditName : void 0,
							postFlairName: i,
							originElement: "post_flair",
							queryId: Object(s.c)(s.a.SearchResults),
							originPageType: n.platform.currentPage ? o.getPageTypeFromCurrentPage(n.platform.currentPage) : void 0
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/powerups.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const r = (e, t, n) => Object.assign(Object.assign({}, o.defaults(e)), {
					correlationId: Object(s.d)(s.a.PowerupsFlow, !1),
					profile: o.profile(e),
					subreddit: o.subreddit(e),
					powerups: Object.assign(Object.assign({}, o.subredditPowerups(e)), {
						freeCount: t,
						paidCount: n
					})
				}),
				i = e => t => Object.assign(Object.assign({
					source: e,
					action: "click",
					noun: "powerups_user_badge"
				}, r(t)), {
					correlationId: Object(s.d)(s.a.PowerupsFlow, !0)
				}),
				a = () => e => Object.assign(Object.assign({
					source: "postlist",
					action: "click",
					noun: "powerups_supporters_cta"
				}, r(e)), {
					correlationId: Object(s.d)(s.a.PowerupsFlow, !0)
				}),
				c = (e, t) => n => Object.assign({
					source: "powerups_modal",
					action: "view",
					noun: "purchase_step"
				}, r(n, e, t))
		},
		"./src/reddit/helpers/trackers/restrictedCommunity.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => Object.assign(Object.assign({}, s.defaults(t)), {
					source: e,
					action: "click",
					noun: "request_restricted_approval_button",
					subreddit: s.subreddit(t)
				}),
				r = e => t => Object.assign(Object.assign({}, s.defaults(t)), {
					source: "request_restricted_approval_form",
					action: "click",
					noun: e,
					subreddit: s.subreddit(t)
				})
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return a
			})), n.d(t, "E", (function() {
				return c
			})), n.d(t, "q", (function() {
				return l
			})), n.d(t, "t", (function() {
				return d
			})), n.d(t, "u", (function() {
				return u
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "s", (function() {
				return h
			})), n.d(t, "v", (function() {
				return b
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "F", (function() {
				return x
			})), n.d(t, "C", (function() {
				return y
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "r", (function() {
				return C
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "w", (function() {
				return S
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "p", (function() {
				return T
			})), n.d(t, "y", (function() {
				return I
			})), n.d(t, "n", (function() {
				return P
			})), n.d(t, "g", (function() {
				return M
			})), n.d(t, "D", (function() {
				return N
			})), n.d(t, "z", (function() {
				return R
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "x", (function() {
				return A
			})), n.d(t, "A", (function() {
				return F
			})), n.d(t, "B", (function() {
				return D
			}));
			var s = n("./src/reddit/models/ScheduledPost/index.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const r = e => Object.assign(Object.assign({}, o.defaults(e)), {
					screen: o.screen(e),
					subreddit: o.subreddit(e),
					userSubreddit: o.userSubreddit(e)
				}),
				i = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone,
					isRecurring: Object(s.o)(e)
				}),
				a = () => e => Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post"
				}, r(e)),
				c = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer"
				}, r(e)),
				l = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date"
				}, r(e)),
				d = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time"
				}, r(e)),
				u = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone"
				}, r(e)),
				p = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply"
				}, r(e)),
				m = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel"
				}, r(e)),
				h = e => t => Object.assign(Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit"
				}, r(t)), {
					scheduledPost: i(e)
				}),
				b = e => t => Object.assign(Object.assign({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit"
				}, r(t)), {
					scheduledPost: i(e)
				}),
				f = () => e => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts"
				}, r(e)),
				g = () => e => Object.assign({
					source: "mod_hub_nav",
					action: "click",
					noun: "event_posts"
				}, r(e)),
				x = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, r(e)),
				y = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, r(e)),
				v = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "edit_post"
				}, r(e)),
				C = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "submit_post_now"
				}, r(e)),
				E = e => t => Object.assign(Object.assign({
					source: "post",
					action: "click",
					noun: "overflow_menu"
				}, r(t)), {
					actionInfo: o.actionInfo(t, {
						pageType: e ? "recurring_posts" : "scheduled_posts"
					})
				}),
				O = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "one_time_frequency"
				}, r(e)),
				j = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "hourly_frequency"
				}, r(e)),
				w = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "daily_frequency"
				}, r(e)),
				S = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "weekly_frequency"
				}, r(e)),
				_ = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "monthly_frequency"
				}, r(e)),
				k = () => e => Object.assign({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: "custom_frequency"
				}, r(e)),
				T = () => e => Object.assign({
					source: "post",
					action: "click",
					noun: "start_event_now"
				}, r(e)),
				I = (e, t, n) => i => Object.assign(Object.assign({
					source: "post",
					action: "click",
					noun: Object(s.l)(e)
				}, r(i)), {
					actionInfo: o.actionInfo(i, {
						settingValue: t ? "true" : "false",
						pageType: n ? "recurring_posts" : "scheduled_posts"
					})
				}),
				P = () => e => Object.assign({
					source: "recurring_post_module",
					action: "click",
					noun: "schedule_post_cta"
				}, r(e)),
				M = () => e => Object.assign({
					source: "recurring_post_module",
					action: "click",
					noun: "edit_recurring_post"
				}, r(e)),
				N = () => e => Object.assign({
					source: "recurring_post_composer",
					action: "view",
					noun: "recurring_post_composer"
				}, r(e)),
				R = () => (e, t) => Object.assign(Object.assign({
					source: "recurring_post_composer",
					action: "click",
					noun: "update"
				}, r(e)), {
					scheduledPost: i(t)
				}),
				L = () => e => Object.assign({
					source: "recurring_post_composer",
					action: "click",
					noun: "cancel"
				}, r(e)),
				A = () => (e, t) => Object.assign(Object.assign({
					source: "recurring_post_composer",
					action: "click",
					noun: "delete"
				}, r(e)), {
					scheduledPost: i(t)
				}),
				F = () => e => Object.assign({
					source: "scheduled_post_composer",
					action: "view",
					noun: "custom_schedule_post_composer"
				}, r(e)),
				D = () => (e, t) => {
					const n = r(e);
					return Object.assign(Object.assign({
						source: "post",
						action: "view",
						noun: "error"
					}, n), {
						actionInfo: Object.assign(Object.assign({}, n.actionInfo), {
							reason: "failed_post"
						}),
						scheduledPost: i(t)
					})
				}
		},
		"./src/reddit/helpers/trackers/screenview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return x
			})), n.d(t, "e", (function() {
				return y
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "f", (function() {
				return S
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "j", (function() {
				return I
			})), n.d(t, "o", (function() {
				return N
			})), n.d(t, "q", (function() {
				return R
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "p", (function() {
				return D
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/es6.regexp.match.js");
			var s = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makePostDraftPageKey/index.ts"),
				r = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				i = n("./src/reddit/helpers/routeKey/index.ts"),
				a = n("./src/reddit/helpers/trackers/postComposer.ts"),
				c = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				l = n("./src/reddit/models/Comment/index.ts"),
				d = n("./src/reddit/models/Post/index.ts"),
				u = n("./src/reddit/selectors/profile.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				h = n("./src/reddit/helpers/trackers/searchResults.ts"),
				b = n("./src/reddit/selectors/postDraft.ts"),
				f = n("./src/reddit/selectors/telemetry.ts"),
				g = n("./src/telemetry/index.ts");
			const x = (e, t, n, a) => {
					const {
						route: u
					} = e, {
						name: p
					} = u.meta;
					if (p) switch (p) {
						case s.Bb.COMMENTS: {
							const {
								partialCommentId: s,
								partialPostId: o
							} = e.match.params, c = Object(d.m)(o), u = Object(i.a)(e, t, t.posts.models[c]);
							if (!u) return;
							const p = s && Object(l.e)(s),
								{
									sortToUse: m
								} = Object(r.a)(t, c);
							Object(g.a)(j(u, c, p, n, a, m)(t));
							break
						}
						case s.Bb.INDEX:
						case s.Bb.LISTING:
						case s.Bb.MULTIREDDIT:
						case s.Bb.SUBREDDIT: {
							const o = Object(i.c)(e, t);
							if (!o.listingKey) return;
							const {
								params: r,
								queryParams: c
							} = e.match, {
								sort: l = (o.sort ? o.sort : s.O.HOT)
							} = r, d = c.t;
							Object(g.a)(y(o.listingKey, l, n, a, d)(t));
							break
						}
						case s.Bb.TOPIC: {
							const o = Object(i.c)(e, t);
							if (!o.listingKey) return;
							const {
								params: r
							} = e.match, c = o.sort ? o.sort : s.P, {
								sort: l = c
							} = r;
							Object(g.a)(y(o.listingKey, l, n, a)(t));
							break
						}
						case s.Bb.PROFILE_OVERVIEW: {
							const o = Object(i.d)(e, t);
							if (!o) return;
							const {
								params: r,
								queryParams: c
							} = e.match, {
								sort: l = s.ub
							} = r, d = c.t;
							Object(g.a)(v(o, l, n, a, d)(t));
							break
						}
						case s.Bb.PROFILE_POSTS: {
							const o = Object(i.d)(e, t);
							if (!o) return;
							const {
								queryParams: r
							} = e.match, {
								sort: c = s.ub,
								t: l = s.Tb
							} = r;
							Object(g.a)(C(o, c, n, a, l)(t));
							break
						}
						case s.Bb.PROFILE_COMMENTS: {
							const o = Object(i.d)(e, t);
							if (!o) return;
							const {
								queryParams: r
							} = e.match, {
								sort: c = s.ub,
								t: l = s.Tb
							} = r;
							Object(g.a)(E(o, c, n, a, l)(t));
							break
						}
						case s.Bb.SETTINGS:
							e.match.params.page === s.Ob.Profile ? Object(c.j)(t) : Object(g.a)(M(n, a)(t));
							break;
						case s.Bb.POST_CREATION:
							break;
						case s.Bb.POST_DRAFT: {
							const {
								draftId: s
							} = e.match.params, r = Object(o.a)(e.match.params);
							if (!r) return;
							k(t, r, s, n, a);
							break
						}
						case s.Bb.SUBREDDIT_WIKI:
							Object(g.a)(A(n, a)(t));
							break;
						case s.Bb.COINS:
							Object(g.a)(T(n, a)(t));
							break;
						case s.Bb.PREMIUM:
							Object(g.a)(I(n, a)(t));
							break;
						case s.Bb.APPEAL:
							Object(g.a)(P(n, a)(t))
					}
				},
				y = (e, t, n, s, o, r) => i => {
					const {
						api: a
					} = i.listings.postOrder, c = !a.error[e] && !a.pending[e];
					return Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(i)), {
						actionInfo: f.actionInfo(i, {
							success: c
						}),
						customFeed: f.customFeed(i),
						listing: f.listing(i, e, {
							sort: t,
							sortTime: o
						}),
						subreddit: f.subreddit(i),
						timer: f.timer(n, s),
						userSubreddit: f.userSubreddit(i),
						adblock: f.adblock(i),
						postFlair: {
							title: r
						}
					})
				},
				v = (e, t, n, s, o) => r => {
					const i = f.listing(r, e);
					i && (i.sort = t, o && (i.sortTime = o));
					const {
						api: a
					} = r.listings.postOrder, c = !a.error[e] && !a.pending[e];
					return Object.assign(Object.assign({
						listing: i,
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(r)), {
						actionInfo: f.actionInfo(r, {
							success: c
						}),
						profile: f.profile(r),
						subreddit: f.subreddit(r),
						timer: f.timer(n, s),
						userSubreddit: f.userSubreddit(r),
						adblock: f.adblock(r)
					})
				},
				C = (e, t, n, s, o) => r => {
					const i = f.listing(r, e);
					i && (i.sort = t, o && (i.sortTime = o));
					const {
						api: a
					} = r.listings.postOrder, c = !a.error[e] && !a.pending[e];
					return Object.assign(Object.assign({
						listing: i,
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(r)), {
						actionInfo: f.actionInfo(r, {
							success: c
						}),
						profile: f.profile(r),
						subreddit: f.subreddit(r),
						timer: f.timer(n, s),
						userSubreddit: f.userSubreddit(r),
						adblock: f.adblock(r)
					})
				},
				E = (e, t, n, s, o) => r => {
					const i = f.profileComments(r, e);
					i && (i.sort = t, o && (i.sortTime = o));
					const {
						api: a
					} = r.profileCommentsPage, c = !a.error[e] && !a.pending[e];
					return Object.assign(Object.assign({
						listing: i,
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(r)), {
						actionInfo: f.actionInfo(r, {
							success: c
						}),
						profile: f.profile(r),
						subreddit: f.subreddit(r),
						timer: f.timer(n, s),
						userSubreddit: f.userSubreddit(r),
						adblock: f.adblock(r)
					})
				},
				O = e => (t, n) => s => {
					const o = !s.profilePrivatePage.api.error[e] && !s.profilePrivatePage.api.pending[e];
					return Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(s)), {
						actionInfo: f.actionInfo(s, {
							success: o
						}),
						profile: f.profile(s),
						subreddit: f.subreddit(s),
						timer: f.timer(n, t),
						userSubreddit: f.userSubreddit(s),
						adblock: f.adblock(s)
					})
				},
				j = (e, t, n, s, o, r) => i => {
					const {
						api: a
					} = i.commentsPage, c = !a.error[e] && !a.pending[e], l = Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(i)), {
						actionInfo: f.actionInfo(i, {
							success: c
						}),
						post: f.post(i, t),
						profile: f.profile(i),
						subreddit: f.subreddit(i),
						timer: f.timer(s, o),
						userSubreddit: f.userSubreddit(i),
						adblock: f.adblock(i),
						postEvent: f.postEventI13nSelector(i, {
							postId: t
						}),
						postCollection: f.postCollectionI13nSelector(i, {
							postId: t
						}),
						listing: f.listing(i, void 0, {
							sort: r
						})
					});
					return n && (l.comment = f.comment(i, n)), l
				},
				w = (e, t, n) => s => {
					const o = s.creations.api.page.fetched[e],
						r = s.platform.currentPage ? s.platform.currentPage.queryParams.source_id : void 0;
					return Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(s)), {
						actionInfo: f.actionInfo(s, {
							success: o
						}),
						post: r ? f.post(s, r) : void 0,
						subreddit: f.subreddit(s),
						timer: f.timer(t, n),
						userSubreddit: f.userSubreddit(s),
						adblock: f.adblock(s)
					})
				},
				S = (e, t, n) => {
					Object(g.a)(Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(e)), {
						actionInfo: f.actionInfo(e, {
							success: t
						}),
						subreddit: f.subredditById(e, Object(p.G)(e, n)),
						userSubreddit: f.userSubreddit(e),
						adblock: f.adblock(e)
					}))
				},
				_ = (e, t, n, s) => {
					Object(g.a)(Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(e)), {
						profile: f.profileById(e, Object(u.m)(e, s)),
						subreddit: f.subredditById(e, Object(p.G)(e, n)),
						userSubreddit: f.userSubreddit(e),
						adblock: f.adblock(e)
					}))
				},
				k = (e, t, n, s, o) => {
					const r = e.creations.api.page.pending[t],
						i = !e.creations.api.page.error[t] && !r && !!n,
						c = Object(b.h)(e, n);
					Object(g.a)(Object.assign(Object.assign(Object.assign({
						source: "global",
						action: "view",
						noun: "screen"
					}, f.defaults(e)), {
						actionInfo: f.actionInfo(e, {
							success: i
						}),
						subreddit: f.subreddit(e),
						timer: f.timer(s, o),
						userSubreddit: f.userSubreddit(e),
						adblock: f.adblock(e)
					}), c ? Object(a.m)(e, c) : {}))
				},
				T = (e, t) => n => Object.assign(Object.assign({
					source: "coins_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(m.c)(m.a.GoldPayment)
				}, f.defaults(n)), {
					timer: f.timer(e, t),
					adblock: f.adblock(n)
				}),
				I = (e, t) => n => Object.assign(Object.assign({
					source: "premium_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(m.c)(m.a.GoldPayment)
				}, f.defaults(n)), {
					timer: f.timer(e, t),
					adblock: f.adblock(n)
				}),
				P = (e, t) => n => Object.assign(Object.assign({
					source: "appeal",
					action: "view",
					noun: "page"
				}, f.defaults(n)), {
					timer: f.timer(e, t)
				}),
				M = (e, t) => n => Object.assign(Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, f.defaults(n)), {
					timer: f.timer(e, t)
				}),
				N = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen",
					subreddit: f.subreddit(e)
				}, f.defaults(e)),
				R = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, f.defaults(e)),
				L = () => e => Object.assign({
					action: "view",
					source: "global",
					noun: "screen"
				}, f.defaults(e)),
				A = (e, t) => n => Object.assign(Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, f.defaults(n)), {
					customFeed: f.customFeed(n),
					subreddit: f.subreddit(n),
					timer: f.timer(e, t),
					userSubreddit: f.userSubreddit(n),
					adblock: f.adblock(n)
				}),
				F = () => e => Object.assign({
					source: "global",
					action: "view",
					noun: "screen"
				}, f.defaults(e)),
				D = (e, t, n, o, r, i) => a => {
					let c = !0;
					if (t.type.indexOf(s.Nb.Posts) > -1) {
						const {
							api: t
						} = a.listings.listingOrder;
						c = c && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(s.Nb.Subreddits) > -1 || t.type.indexOf(s.Nb.Users) > -1) {
						const {
							api: t
						} = a.listings.postOrder;
						c = c && !t.error[e] && !t.pending[e]
					}
					const l = f.paneName(a, r),
						d = f.structureType(a, r),
						u = a.platform.currentPage && a.platform.currentPage.urlParams && a.platform.currentPage.urlParams.subredditName ? f.subredditByName(a, a.platform.currentPage.urlParams.subredditName) : void 0;
					return Object.assign(Object.assign(Object.assign(Object.assign({}, h.c(a, t)), {
						source: "global",
						action: "view",
						noun: "screen",
						actionInfo: f.actionInfo(a, {
							success: c,
							paneName: l
						}),
						timer: f.timer(n, o),
						search: Object.assign(Object.assign(Object.assign({}, f.search(a, t, !0, r || void 0)), !!i && {
							originElement: i
						}), {
							queryId: Object(m.c)(m.a.SearchResults),
							structureType: d,
							subredditId: t.restrict_sr && u && u.id ? u.id : void 0,
							subredditName: t.restrict_sr && u && u.name ? u.name : void 0
						})
					}), !!i && {
						correlationId: Object(m.c)(m.a.SearchResults)
					}), {
						userPreferences: {
							hideNsfw: !a.user.prefs.over18
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/topAwarded.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/helpers/trackers/goldPayment.ts"),
				r = n("./src/reddit/selectors/gold/topAwarded.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return Object.assign(Object.assign({}, Object(o.h)(e, t)), {
						correlationId: Object(s.d)(s.a.GildingFlow, !1),
						profile: i.profile(e),
						subreddit: i.subreddit(e)
					})
				},
				c = e => t => Object.assign({
					source: "post",
					action: "click",
					noun: "award_spotlight_banner"
				}, a(t, {
					thingId: e
				})),
				l = e => t => Object.assign({
					source: "post_awards_leaderboard",
					action: "view",
					noun: "page"
				}, a(t, {
					thingId: e
				})),
				d = () => e => Object.assign({
					source: "post_awards_leaderboard",
					action: "click",
					noun: "give_gold"
				}, a(e, {
					thingId: Object(r.a)(e) || void 0
				}))
		},
		"./src/reddit/hooks/useInfoTextTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				o = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-popper/lib/esm/usePopper.js");
			const i = Object(s.freeze)({
				modifiers: []
			});

			function a(e) {
				let t = "object" == typeof e ? e : i;
				return Array.isArray(t.modifiers) || (t = Object(s.assoc)(t, "modifiers", i.modifiers)), t
			}
			const c = Object(s.freeze)({
				name: "offset",
				options: {
					offset: [0, 6]
				}
			});

			function l(e) {
				return function(e) {
					const [t, n] = Object(o.useState)(null), [i, c] = Object(o.useState)(null), [l, d] = Object(o.useState)(null), [u, p] = Object(o.useState)(!1), m = Object(o.useCallback)(async () => p(!0), []), h = Object(o.useCallback)(() => p(!1), []), b = Object(o.useMemo)(() => {
						const t = a(e);
						return l ? Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, {
							name: "arrow",
							options: {
								element: l
							}
						})) : t
					}, [l, e]), {
						attributes: f,
						styles: g
					} = Object(r.a)(t, i, b);
					return Object(o.useMemo)(() => ({
						arrowProps: Object.assign({
							ref: d,
							style: g.arrow
						}, f.arrow),
						hide: h,
						popperProps: Object.assign({
							ref: c,
							style: g.popper
						}, f.popper),
						show: m,
						target: {
							element: t,
							ref: n
						},
						visible: u
					}), [d, f, c, h, m, g, t, n, u])
				}(Object(o.useMemo)(() => {
					const t = a(e);
					return Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, c))
				}, [e]))
			}
		},
		"./src/reddit/hooks/useTracking.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = s.b
		},
		"./src/reddit/icons/fonts/Admin/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("admin"), c.a.adminIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Approve/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("approve"), c.a.approveIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Archived/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("archived"), c.a.archivedIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Calendar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("calendar"), c.a.calendarIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.m.less": function(e, t, n) {
			e.exports = {
				DropdownTriangle: "_28O0gzb6GMS8lbDeySdpwp",
				dropdownTriangle: "_28O0gzb6GMS8lbDeySdpwp"
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/DropdownTriangle/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("dropdownTriangle"), " ").concat(e.className)
			}), "DropdownTriangle", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Expandos/Media/Video/index.m.less": function(e, t, n) {
			e.exports = {
				TextMediaIcon: "_1YuQjV5ZXNDhhSOkCnE9he",
				textMediaIcon: "_1YuQjV5ZXNDhhSOkCnE9he"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Media/Video/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Expandos/Media/Video/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("expandoMediaVideo"), " ").concat(e.className)
			}), "TextMediaIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Gif/index.m.less": function(e, t, n) {
			e.exports = {
				GifIcon: "_2FVMHfvH9Kj7f59LnZjdUX",
				gifIcon: "_2FVMHfvH9Kj7f59LnZjdUX"
			}
		},
		"./src/reddit/icons/fonts/Gif/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Gif/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("gif"), " ").concat(e.className)
			}), "GifIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Gift/index.m.less": function(e, t, n) {
			e.exports = {
				GiftIcon: "_12P1l1cITUMF05krI6QUSj",
				giftIcon: "_12P1l1cITUMF05krI6QUSj"
			}
		},
		"./src/reddit/icons/fonts/Gift/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Gift/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("gift"), " ").concat(e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(r.a, null, e.desc)), "GiftIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Info/index.m.less": function(e, t, n) {
			e.exports = {
				InfoIcon: "_3nKAYOml-oSgh4pKL20-sC",
				infoIcon: "_3nKAYOml-oSgh4pKL20-sC"
			}
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Info/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("info"), " ").concat(e.className)
			}), "InfoIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Link/index.m.less": function(e, t, n) {
			e.exports = {
				LinkIcon: "_1UzGujIvFbQUgWI4gO6QeD",
				linkIcon: "_1UzGujIvFbQUgWI4gO6QeD"
			}
		},
		"./src/reddit/icons/fonts/Link/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Link/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("link"), " ").concat(e.className)
			}), "LinkIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Live/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("live"), c.a.liveIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("lock"), c.a.lockIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Menu/index.m.less": function(e, t, n) {
			e.exports = {
				MenuIcon: "_2L8b_l8zFzAkWuMyZJ1_vg",
				menuIcon: "_2L8b_l8zFzAkWuMyZJ1_vg"
			}
		},
		"./src/reddit/icons/fonts/Menu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Menu/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("menu"), " ").concat(e.className)
			}), "MenuIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("outboundLink"), " ").concat(e.className)
			})
		},
		"./src/reddit/icons/fonts/Photos/index.m.less": function(e, t, n) {
			e.exports = {
				PhotoIcon: "_1LWQVKh7NQLbKMIz2io1Di",
				photoIcon: "_1LWQVKh7NQLbKMIz2io1Di"
			}
		},
		"./src/reddit/icons/fonts/Photos/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Photos/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("photos"), " ").concat(e.className)
			}), "PhotoIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Plus/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("plus"), e.className)
			})
		},
		"./src/reddit/icons/fonts/Premium/index.m.less": function(e, t, n) {
			e.exports = {
				PremiumIcon: "dLp3R7pmxclGjLS87yr5S",
				premiumIcon: "dLp3R7pmxclGjLS87yr5S"
			}
		},
		"./src/reddit/icons/fonts/Premium/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Premium/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				title: e.title,
				className: "".concat(Object(r.b)("premium"), " ").concat(e.className)
			}), "PremiumIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("remove"), c.a.removeIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Report/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("report"), c.a.reportIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Spam/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("spam"), c.a.spamIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Sticky/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				c = n.n(a);
			t.a = e => o.a.createElement("i", {
				className: Object(r.a)(Object(i.b)("sticky"), c.a.stickyIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, o.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Text/index.m.less": function(e, t, n) {
			e.exports = {
				TextIcon: "_5UHlAh7zBZ6migrBJeld3",
				textIcon: "_5UHlAh7zBZ6migrBJeld3"
			}
		},
		"./src/reddit/icons/fonts/Text/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Text/index.m.less"),
				a = n.n(i);
			const c = n("./src/lib/lessComponent.tsx").a.wrapped(e => o.a.createElement("i", {
				className: "".concat(Object(r.b)("text"), " ").concat(e.className)
			}), "TextIcon", a.a);
			t.a = c
		},
		"./src/reddit/icons/fonts/Video/index.m.less": function(e, t, n) {
			e.exports = {
				VideoIcon: "_1q4uVersxe3LOuom7R34bx",
				videoIcon: "_1q4uVersxe3LOuom7R34bx"
			}
		},
		"./src/reddit/icons/fonts/commonStyles.m.less": function(e, t, n) {
			e.exports = {
				iconFont: "WxKparxaBCy4-EWML7xc3",
				approveIcon: "MAe2tslj1FAD6GliiZ3it",
				calendarIcon: "_2YXLfgRGcJoCJROcTAGqir",
				commentIcon: "_3ch9jJ0painNf41PmU4F9i",
				lockIcon: "XHMWG1CPWX8RXeNg-o5-R",
				modActions: "_3phKxmomoio9ulzAoL4XhZ",
				moderateIcon: "_2Xt7ltq8LezAkf8ZF8x9dv",
				removeIcon: "_2IVG3b9-lczna8tonL9FWB",
				reportIcon: "_1MDjRAzxk1RSTB12748O1v",
				shareIcon: "xwmljjCrovDE5C9MasZja",
				spamIcon: "_1Gn6JH0U8GJtJXSIc54IMU",
				stickyIcon: "hMF1wBi2Z6Lh9zHskfhX1",
				adminIcon: "_3ACtZ0jvC5KDN8RNxR0lXX",
				archivedIcon: "_2trXhUAJMhIhxp8a2zvOVP",
				liveIcon: "_3cdJ6BHH65ws78AzuO0KLw"
			}
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(e, t, n) {
			e.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/icons/fonts/helpers.m.less"),
				i = n.n(r),
				a = n("./src/lib/lessComponent.tsx");
			const c = e => "icon icon-".concat(e),
				l = a.a.wrapped(e => o.a.createElement("span", {
					className: e.className
				}, e.children), "TooltipDesc", i.a)
		},
		"./src/reddit/icons/svgs/AddCollection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 24 24"
			}, o.a.createElement("defs", null, o.a.createElement("path", {
				id: "svg-add-collection",
				d: "M19.2 2.4a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V4.8a2.4 2.4 0 0 1 2.4-2.4h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V8.4A2.4 2.4 0 0 1 4.8 6h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v7.2a2.4 2.4 0 0 1-2.4 2.4H4.8a2.4 2.4 0 0 1-2.4-2.4V12a2.4 2.4 0 0 1 2.4-2.4h14.4zm-3.806 5.1H12.9v-2.494a.9.9 0 1 0-1.8 0V14.7H8.607a.9.9 0 1 0 0 1.8H11.1v2.494a.9.9 0 1 0 1.8 0V16.5h2.494a.9.9 0 0 0 0-1.8z"
			})), o.a.createElement("use", {
				fill: "inherit",
				xlinkHref: "#".concat("svg-add-collection"),
				fillRule: "evenodd"
			}))
		},
		"./src/reddit/icons/svgs/AddSquare/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r(e) {
				return o.a.createElement("svg", {
					className: e.className,
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, o.a.createElement("rect", {
					fill: "transparent",
					height: "18",
					rx: "4.5",
					strokeDasharray: "2 2",
					strokeLinejoin: "round",
					strokeWidth: "1",
					width: "18",
					x: "1",
					y: "1"
				}), o.a.createElement("path", {
					clipRule: "evenodd",
					d: "M13 9H11V7C11 6.7235 10.7765 6.5 10.5 6.5H9.5C9.2235 6.5 9 6.7235 9 7V9H7C6.724 9 6.5 9.2235 6.5 9.5V10.5C6.5 10.7765 6.724 11 7 11H9V13C9 13.2765 9.2235 13.5 9.5 13.5H10.5C10.7765 13.5 11 13.2765 11 13V11H13C13.2765 11 13.5 10.7765 13.5 10.5V9.5C13.5 9.2235 13.2765 9 13 9Z",
					fillRule: "evenodd"
				}))
			}
		},
		"./src/reddit/icons/svgs/Automoderator/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("path", {
				d: "M16,2H4A2,2,0,0,0,2,4V16a2,2,0,0,0,2,2H16a2,2,0,0,0,2-2V4A2,2,0,0,0,16,2ZM5.5,15.5h-1v-3h1Zm2,0h-1v-3h1ZM6,9A2,2,0,1,1,8,7,2,2,0,0,1,6,9Zm3.5,6.5h-1v-3h1Zm2,0h-1v-3h1Zm2,0h-1v-3h1Zm2,0h-1v-3h1ZM14,9a2,2,0,1,1,2-2A2,2,0,0,1,14,9Z"
			}))
		},
		"./src/reddit/icons/svgs/Chat/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: e.viewBox || "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M10,0A10,10,0,0,0,1.64,15.51L.57,18.73c-.16.52.19.86.7.7l3.22-1.08A10,10,0,1,0,10,0ZM5.54,11.41A1.39,1.39,0,1,1,6.93,10,1.39,1.39,0,0,1,5.54,11.41Zm4.46,0A1.39,1.39,0,1,1,11.39,10,1.39,1.39,0,0,1,10,11.41Zm4.44,0A1.39,1.39,0,1,1,15.83,10,1.39,1.39,0,0,1,14.44,11.41Z"
			}))
		},
		"./src/reddit/icons/svgs/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_1vmueUAOJJg7fhS7wxztWa"
			}
		},
		"./src/reddit/icons/svgs/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			t.a = e => {
				var {
					className: t
				} = e, n = l(e, ["className"]);
				return o.a.createElement("svg", c({
					xmlns: "http://www.w3.org/2000/svg",
					width: "20",
					height: "20",
					viewBox: "0 0 20 20",
					className: Object(r.a)(a.a.checkbox, t)
				}, n), o.a.createElement("path", {
					fill: "inherit",
					d: "M1.66666667,3.34755033 L1.66666667,16.6524497 C1.66666667,17.5781756 2.42112363,18.3333333 3.34755033,18.3333333 L16.6524497,18.3333333 C17.5781756,18.3333333 18.3333333,17.5788764 18.3333333,16.6524497 L18.3333333,3.34755033 C18.3333333,2.42182438 17.5788764,1.66666667 16.6524497,1.66666667 L3.34755033,1.66666667 C2.42182438,1.66666667 1.66666667,2.42112363 1.66666667,3.34755033 Z M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z"
				}))
			}
		},
		"./src/reddit/icons/svgs/CheckboxSelected/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", r({
				xmlns: "http://www.w3.org/2000/svg",
				width: "20",
				height: "20",
				viewBox: "0 0 20 20"
			}, e), o.a.createElement("path", {
				fill: "inherit",
				d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M8.50575,15.1995 L15.797625,7.907625 C16.25325,7.452625 16.25325,6.71325 15.797625,6.25825 C15.342,5.802625 14.602625,5.802625 14.147625,6.25825 L7.7295,12.676375 L5.635125,10.327625 C5.20575,9.846375 4.46825,9.805125 3.987625,10.23325 C3.506375,10.662625 3.4645,11.400125 3.89325,11.88075 L6.810125,15.151375 C7.023875,15.39075 7.327,15.531375 7.647625,15.54075 C7.658875,15.54075 7.6695,15.541375 7.68075,15.541375 C7.990125,15.541375 8.287,15.41825 8.50575,15.1995 Z"
			}))
		},
		"./src/reddit/icons/svgs/Checkmark/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 22",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Chevron/index.m.less": function(e, t, n) {
			e.exports = {
				chevron: "_1c_YBKkiW4FhhLJPkq9c1v"
			}
		},
		"./src/reddit/icons/svgs/Chevron/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Chevron/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.chevron, e.className),
				viewBox: "0 0 9 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				transform: "translate(-6.000000, -3.000000)"
			}, o.a.createElement("polygon", {
				fill: "none",
				points: "0 20 20 20 20 0 0 0"
			}), o.a.createElement("polygon", {
				fill: "inherit",
				points: "7.47566213 3 14.4756621 10 7.47566213 17 6 15.5239203 11.5239203 10 6 4.47566213"
			})))
		},
		"./src/reddit/icons/svgs/ChevronDown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, o.a.createElement("g", null, o.a.createElement("polygon", {
				fill: "inherit",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/ChevronUp/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("polygon", {
				fill: "inherit",
				transform: "translate(6.029200, 6.044700) scale(1, -1) translate(-6.029200, -6.044700)",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/CircledPlanet/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", r({
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, e), o.a.createElement("path", {
				d: "M15.8286,15.8998 C15.3466,16.3788 12.6326,15.5598 8.5516,11.4798 C4.4706,7.3968 3.6486,4.6858 4.1316,4.2038 C4.3566,3.9788 4.9286,3.9208 5.9126,4.3518 C5.6166,4.5678 5.3306,4.8008 5.0666,5.0658 C5.0536,5.0798 5.0416,5.0948 5.0266,5.1098 C5.5756,6.4268 6.8946,8.4088 9.2596,10.7728 C11.6206,13.1338 13.6046,14.4538 14.9246,15.0028 C14.9376,14.9898 14.9526,14.9778 14.9666,14.9638 C15.2316,14.6988 15.4646,14.4128 15.6786,14.1178 C16.1096,15.1028 16.0526,15.6748 15.8286,15.8998 M16.7526,11.8998 C17.4066,9.5458 16.8136,6.9138 14.9666,5.0658 C13.6436,3.7438 11.8866,3.0148 10.0166,3.0148 C9.3686,3.0148 8.7356,3.1078 8.1286,3.2768 C5.7306,1.7598 3.9176,1.5898 2.7176,2.7898 C1.4036,4.1028 2.0736,6.1918 3.2866,8.1688 C2.6446,10.5128 3.2276,13.1258 5.0666,14.9638 C6.3886,16.2868 8.1456,17.0148 10.0166,17.0148 C10.6536,17.0148 11.2746,16.9178 11.8736,16.7518 C13.0856,17.4938 14.3406,18.0318 15.4316,18.0318 C16.1156,18.0318 16.7366,17.8198 17.2426,17.3138 C18.4416,16.1138 18.2706,14.2988 16.7526,11.8998"
			}))
		},
		"./src/reddit/icons/svgs/Clear/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				onClick: e.onClick,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, o.a.createElement("path", {
				d: "M20 2.5C10.3 2.5 2.5 10.3 2.5 20c0 9.7 7.8 17.5 17.5 17.5S37.5 29.7 37.5 20C37.5 10.3 29.7 2.5 20 2.5zM24.2 27.7L20 23.5l-4.2 4.2c-1.1 1.1-2.5 1.1-3.5 0-1.1-1.1-1.1-2.4 0-3.5l4.2-4.2-4.2-4.2c-1.1-1.1-1.1-2.5 0-3.5 1.1-1.1 2.4-1.1 3.5 0l4.2 4.2 4.2-4.2c1.1-1.1 2.5-1.1 3.5 0 1.1 1.1 1.1 2.4 0 3.5L23.5 20l4.2 4.2c1.1 1.1 1.1 2.5 0 3.5C26.7 28.8 25.3 28.8 24.2 27.7z"
			}))
		},
		"./src/reddit/icons/svgs/Clock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 11 11"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M5 3.75C5 3.47388 5.22363 3.25 5.5 3.25C5.77637 3.25 6 3.47388 6 3.75V5.53735L7.81689 6.58643C8.05615 6.72449 8.13818 7.03027 8 7.26941C7.86182 7.50861 7.55615 7.59052 7.31689 7.45245L5.25049 6.25934C5.07861 6.16028 4.98779 5.97504 5.00146 5.78992L5 5.75V3.75Z",
				fill: "inherit"
			}), o.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M11 5.5C11 8.53754 8.5376 11 5.5 11C2.4624 11 0 8.53754 0 5.5C0 2.46246 2.4624 0 5.5 0C8.5376 0 11 2.46246 11 5.5ZM10 5.5C10 7.98529 7.98535 10 5.5 10C3.01465 10 1 7.98529 1 5.5C1 3.01471 3.01465 1 5.5 1C7.98535 1 10 3.01471 10 5.5Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", r({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), o.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/icons/svgs/Crosspost/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", r({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), o.a.createElement("path", {
				d: "M9.06,8.64c1.12-1.26,2.2-2.45,4.44-2.6V7.5a1,1,0,0,0,.6.92,1,1,0,0,0,.41.09,1,1,0,0,0,.67-.26l3.16-2.9a.5.5,0,0,0,0-.74L15.18,1.7a1,1,0,0,0-1.68.74V4c-3.14.17-4.69,1.88-5.93,3.28C6.58,8.42,6,9,5,9H2a1,1,0,0,0,0,2H5C6.93,11,8,9.82,9.06,8.64Z"
			}), o.a.createElement("path", {
				d: "M15.18,11.76a1,1,0,0,0-1.68.74V14c-2.23-.16-3.29-1.32-4.39-2.56-.21-.24-.43-.48-.66-.72a5.63,5.63,0,0,1-1.77,1.06,13.34,13.34,0,0,1,.94,1A7.85,7.85,0,0,0,13.5,16v1.59a1,1,0,0,0,.6.92,1,1,0,0,0,.41.09,1,1,0,0,0,.67-.26l3.16-2.9a.5.5,0,0,0,0-.74Z"
			}))
		},
		"./src/reddit/icons/svgs/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "XHbKeEqnW58ib9mTN6jnS",
				mRedditStyle: "u_kypUXmB-k1A5TcC8MI9"
			}
		},
		"./src/reddit/icons/svgs/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Dropdown/index.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var l = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const d = e => {
				var {
					className: t,
					isSubreddit: n
				} = e, s = l(e, ["className", "isSubreddit"]);
				return o.a.createElement("svg", c({
					className: Object(r.a)(a.a.dropdown, {
						[a.a.mRedditStyle]: !n
					}, t),
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, s), o.a.createElement("path", {
					d: "M14.17,9.35,10,13.53,5.83,9.35a.5.5,0,0,1,.35-.85h7.64a.5.5,0,0,1,.35.85"
				}))
			};
			t.b = d
		},
		"./src/reddit/icons/svgs/FormattingAlignCenter/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1ZVHRoTDdo57082D2GcC80"
			}
		},
		"./src/reddit/icons/svgs/FormattingAlignCenter/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingAlignCenter/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero"
			}, o.a.createElement("path", {
				d: "M3.5 11h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1zM7.42 16h5.08c.55 0 1-.45 1-1s-.45-1-1-1H7.42c-.56 0-1 .45-1 1s.44 1 1 1zM3.5 6h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingAlignLeft/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_33vXt91MK_ualpifvvw_3v"
			}
		},
		"./src/reddit/icons/svgs/FormattingAlignLeft/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingAlignLeft/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero"
			}, o.a.createElement("path", {
				d: "M3.5 11h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1zM3.5 16h5.4c.54 0 1-.45 1-1s-.46-1-1-1H3.5c-.55 0-1 .45-1 1s.45 1 1 1zM3.5 6h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingAlignRight/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_34rYEsgbWk8eOQx_bs7fTV"
			}
		},
		"./src/reddit/icons/svgs/FormattingAlignRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingAlignRight/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero"
			}, o.a.createElement("path", {
				d: "M3.5 11h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1zM11.5 16h5c.55 0 1-.45 1-1s-.45-1-1-1h-5c-.55 0-1 .45-1 1s.45 1 1 1zM3.5 6h13c.55 0 1-.45 1-1s-.45-1-1-1h-13c-.55 0-1 .45-1 1s.45 1 1 1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingBlockQuotes/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_32TQMV98QwoweVXtMHpwr2"
			}
		},
		"./src/reddit/icons/svgs/FormattingBlockQuotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingBlockQuotes/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("polygon", {
				points: "8.63 4 5.36 4 2 9.8 2 16 9.2 16 9.2 9.24 6.75 9.24 8.63 4"
			}), o.a.createElement("polygon", {
				points: "15.56 9.24 17.39 4 14.16 4 10.8 9.8 10.8 16 18 16 18 9.24 15.56 9.24"
			}))
		},
		"./src/reddit/icons/svgs/FormattingBold/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1329vPT9OSGZyEvo6Fqss"
			}
		},
		"./src/reddit/icons/svgs/FormattingBold/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingBold/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M12.44,9.72v0a3.07,3.07,0,0,0,2.67-3.22c0-2.84-2.42-3.46-5-3.46H4.51V17H10.4c2.61,0,5.09-1,5.09-3.86C15.49,10.91,14.14,10,12.44,9.72ZM7.54,5.38H9.85c1.65,0,2.31.61,2.31,1.7s-.74,1.68-2.35,1.68H7.54ZM10,14.65H7.54V10.95H9.89c1.7,0,2.59.61,2.59,1.83S11.72,14.65,10,14.65Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingCodeBlock/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "F0bObcodUF6At5SPF9bIr"
			}
		},
		"./src/reddit/icons/svgs/FormattingCodeBlock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingCodeBlock/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M15,2H13a1,1,0,0,0,0,2h2a1,1,0,0,1,1,1V15a1,1,0,0,1-1,1H5a1,1,0,0,1-1-1V13a1,1,0,0,0-2,0v2a3,3,0,0,0,3,3H15a3,3,0,0,0,3-3V5A3,3,0,0,0,15,2Z"
			}), o.a.createElement("path", {
				d: "M2.79,5a.71.71,0,0,0,.53-.2.74.74,0,0,0,.19-.54V4.08l0-.48H5.07V8.4H4.9a1,1,0,0,0-.69.18A.79.79,0,0,0,4,9.2a.79.79,0,0,0,.21.61A1,1,0,0,0,4.9,10H7.1a1,1,0,0,0,.69-.19A.79.79,0,0,0,8,9.2a.78.78,0,0,0-.21-.61A1,1,0,0,0,7.1,8.4H6.93V3.6H8.44l0,.48a1.19,1.19,0,0,0,.18.72.7.7,0,0,0,.56.2.75.75,0,0,0,.59-.2A1,1,0,0,0,10,4.14V4.08L9.93,2.9q0-.64-.18-.77A1.06,1.06,0,0,0,9.11,2H2.89a1.06,1.06,0,0,0-.63.13q-.16.13-.18.77L2,4.08v.06a.94.94,0,0,0,.19.65A.78.78,0,0,0,2.79,5Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingDeleteRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_8Y1-XP7A1OOfoU_mUqKcg"
			}
		},
		"./src/reddit/icons/svgs/FormattingDeleteRow/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingDeleteRow/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero",
				transform: "vertical" === e.orientation ? "rotate(90, 10, 10)" : ""
			}, o.a.createElement("path", {
				d: "M3 3c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V3zM2 3v14c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2z"
			}), o.a.createElement("path", {
				d: "M2 15h16v1H2M2 4h16v1H2M7.17 11.4l4.24-4.23c.4-.4 1.04-.4 1.43 0 .4.4.4 1.03 0 1.42L8.6 12.82c-.4.4-1.04.4-1.43 0-.4-.4-.4-1.03 0-1.42z"
			}), o.a.createElement("path", {
				d: "M8.6 7.17l4.23 4.24c.4.4.4 1.04 0 1.43-.4.4-1.03.4-1.42 0L7.18 8.6c-.4-.4-.4-1.04 0-1.43.4-.4 1.03-.4 1.42 0z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingHeading/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2C-VR7luDjfFqzNiJQEpk0"
			}
		},
		"./src/reddit/icons/svgs/FormattingHeading/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingHeading/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("polygon", {
				points: "6.57 3 6.57 5.57 10.73 5.57 10.73 17 13.82 17 13.82 5.57 18 5.57 18 3 6.57 3"
			}), o.a.createElement("polygon", {
				points: "2 9.65 4.68 9.65 4.68 17 6.66 17 6.66 9.65 9.35 9.65 9.35 8 2 8 2 9.65"
			}))
		},
		"./src/reddit/icons/svgs/FormattingHyperlink/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2-0pxD6-cM6bWeb73TNNhJ"
			}
		},
		"./src/reddit/icons/svgs/FormattingHyperlink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingHyperlink/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M17.15,2.86a6.33,6.33,0,1,0-9,9A1,1,0,0,0,9.6,10.4a4.39,4.39,0,1,1,4.92.83,7.41,7.41,0,0,1,.14,1.44c0,.23,0,.46,0,.68a6.33,6.33,0,0,0,2.51-10.5Z"
			}), o.a.createElement("path", {
				d: "M10.4,8.19a1,1,0,0,0,0,1.41,4.39,4.39,0,1,1-4.92-.83,7.41,7.41,0,0,1-.14-1.44c0-.23,0-.46,0-.68a6.33,6.33,0,1,0,6.44,1.54A1,1,0,0,0,10.4,8.19Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingInsertRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1PNKgIKbpvIWTVU3LO0PJQ"
			}
		},
		"./src/reddit/icons/svgs/FormattingInsertRow/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingInsertRow/index.m.less"),
				a = n.n(i);
			const c = {
				up: "rotate(180 10 10)",
				down: "",
				left: "rotate(90 10 10)",
				right: "rotate(-90 10 10)"
			};
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit",
				fillRule: "nonzero",
				transform: c[e.orientation || "down"]
			}, o.a.createElement("path", {
				d: "M17 17c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v14zm1 0V3c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2z"
			}), o.a.createElement("path", {
				d: "M18 6H2V5h16M13 13H7c-.55 0-1-.45-1-1s.45-1 1-1h6c.55 0 1 .45 1 1s-.45 1-1 1z"
			}), o.a.createElement("path", {
				d: "M9 15V9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1z"
			})))
		},
		"./src/reddit/icons/svgs/FormattingItalics/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_32WqBD1jOzjyQPJdFZ8Rrt"
			}
		},
		"./src/reddit/icons/svgs/FormattingItalics/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingItalics/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("polygon", {
				points: "7.24 17 10.3 17 12.1 6.85 9.05 6.85 7.24 17"
			}), o.a.createElement("polygon", {
				points: "9.7 3 9.28 5.46 12.34 5.46 12.76 3 9.7 3"
			}))
		},
		"./src/reddit/icons/svgs/FormattingMonospace/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1cI-FoGkiT7RNcT2BsWaRU"
			}
		},
		"./src/reddit/icons/svgs/FormattingMonospace/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingMonospace/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M18.8,9.4l-3-4a1,1,0,1,0-1.6,1.2L16.75,10,14.2,13.4a1,1,0,1,0,1.6,1.2l3-4A1,1,0,0,0,18.8,9.4Z"
			}), o.a.createElement("path", {
				d: "M5.6,5.2a1,1,0,0,0-1.4.2l-3,4a1,1,0,0,0,0,1.2l3,4a1,1,0,0,0,1.6-1.2L3.25,10,5.8,6.6A1,1,0,0,0,5.6,5.2Z"
			}), o.a.createElement("path", {
				d: "M12.24,1A1,1,0,0,0,11,1.76l-4,16A1,1,0,1,0,9,18.24l4-16A1,1,0,0,0,12.24,1Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingOrderedList/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1fQOXfyxB1SmgMOi7sihQV"
			}
		},
		"./src/reddit/icons/svgs/FormattingOrderedList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingOrderedList/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M4.78,5.15H4.15V2H3.09a1,1,0,0,1-.73.25V3a1.84,1.84,0,0,0,.7-.17V5.15H2.35V6H4.78Z"
			}), o.a.createElement("path", {
				d: "M3.62,8.88c.25,0,.39.12.39.35s-.17.41-.77.78c-1,.63-1.15,1.21-1.15,1.78V12H5v-.85H3.31c.06-.16.22-.35.72-.64.81-.43,1-.87,1-1.32C5,8.47,4.58,8,3.65,8A1.76,1.76,0,0,0,2.08,9l.72.52A1.07,1.07,0,0,1,3.62,8.88Z"
			}), o.a.createElement("path", {
				d: "M4.43,15.87A.82.82,0,0,0,5,15.05C5,14.4,4.53,14,3.65,14a2.15,2.15,0,0,0-1.51.61l.55.64a1.24,1.24,0,0,1,.88-.39c.27,0,.41.12.41.32s-.15.38-.67.38H3v.72h.31c.53,0,.76.13.76.46s-.15.42-.57.42a1.05,1.05,0,0,1-.85-.5L2,17.21A1.83,1.83,0,0,0,3.57,18c.94,0,1.55-.43,1.55-1.24A.87.87,0,0,0,4.43,15.87Z"
			}), o.a.createElement("path", {
				d: "M17,9H8a1,1,0,0,0,0,2h9a1,1,0,0,0,0-2Z"
			}), o.a.createElement("path", {
				d: "M17,15H8a1,1,0,0,0,0,2h9a1,1,0,0,0,0-2Z"
			}), o.a.createElement("path", {
				d: "M8,5h9a1,1,0,0,0,0-2H8A1,1,0,0,0,8,5Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingSpoiler/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1KIFUYxvtUxuRVhS-FGTns"
			}
		},
		"./src/reddit/icons/svgs/FormattingSpoiler/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingSpoiler/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M10,1.5A8.5,8.5,0,1,0,18.5,10,8.51,8.51,0,0,0,10,1.5Zm.71,13-.15.12-.18.1-.18.05a.73.73,0,0,1-.2,0,1,1,0,0,1-.71-.29,1,1,0,0,1-.21-.32A1,1,0,0,1,9,13.83a1,1,0,0,1,.08-.38,1,1,0,0,1,.21-.32,1,1,0,0,1,.91-.28l.18.06.18.09.15.13a1,1,0,0,1,.29.7A1,1,0,0,1,10.71,14.54Zm-.22-3.6a.5.5,0,0,1-1,0l-1-4.67A.5.5,0,0,1,9,5.67h2a.5.5,0,0,1,.49.6Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingStrikethrough/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_3C1w798INaJPgFxfklr4an"
			}
		},
		"./src/reddit/icons/svgs/FormattingStrikethrough/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingStrikethrough/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M11.86,12a1.36,1.36,0,0,1,.7,1.19c0,1.07-1,1.59-2.42,1.59a4.12,4.12,0,0,1-3.75-2.36L4.08,13.79A6.21,6.21,0,0,0,10,17.2c3.86,0,5.55-2,5.55-4.22a4,4,0,0,0-.12-1Z"
			}), o.a.createElement("path", {
				d: "M17,9H11.61l-1.09-.31c-1.82-.51-2.85-.9-2.85-2,0-.82.71-1.39,2-1.39a4.13,4.13,0,0,1,3.41,2L15.2,5.65A6.23,6.23,0,0,0,9.69,2.8c-3,0-5,1.56-5,4.14A3.31,3.31,0,0,0,5.31,9H3a1,1,0,0,0,0,2H17a1,1,0,0,0,0-2Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingSuperscript/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1DvEfZosXHE4A0gHsGOjEU"
			}
		},
		"./src/reddit/icons/svgs/FormattingSuperscript/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingSuperscript/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M6.94,3,2,17H4.83L5.9,13.89h4.75l1,3.11h3.11L9.86,3Zm-.28,8.67L8.29,6.92h0l1.6,4.75Z"
			}), o.a.createElement("path", {
				d: "M16.06,3H14.92L13,8.49h1.11l.42-1.22h1.86l.41,1.22H18ZM14.81,6.4l.64-1.86h0l.63,1.86Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingTable/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_12fGjUaA4qUfdUrX7rnmTK"
			}
		},
		"./src/reddit/icons/svgs/FormattingTable/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingTable/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M17,2H3A1,1,0,0,0,2,3V17a1,1,0,0,0,1,1H17a1,1,0,0,0,1-1V3A1,1,0,0,0,17,2ZM4,6H9V9.8H4Zm7,0h5V9.8H11ZM4,11.8H9V16H4ZM11,16V11.8h5V16Z"
			}))
		},
		"./src/reddit/icons/svgs/FormattingUnorderedList/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "LfxAZX1Sm9aiJZiizUSZO"
			}
		},
		"./src/reddit/icons/svgs/FormattingUnorderedList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/FormattingUnorderedList/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M17,9H8a1,1,0,0,0,0,2h9a1,1,0,0,0,0-2Z"
			}), o.a.createElement("path", {
				d: "M17,15H8a1,1,0,0,0,0,2h9a1,1,0,0,0,0-2Z"
			}), o.a.createElement("path", {
				d: "M8,5h9a1,1,0,0,0,0-2H8A1,1,0,0,0,8,5Z"
			}), o.a.createElement("path", {
				d: "M4.88,9.43a1.29,1.29,0,0,0-.13-.26,2.17,2.17,0,0,0-.19-.23,1.55,1.55,0,0,0-2.12,0,2.16,2.16,0,0,0-.19.23,2.2,2.2,0,0,0-.14.26A2.3,2.3,0,0,0,2,9.71,1.32,1.32,0,0,0,2,10a1.5,1.5,0,0,0,1.5,1.5,1.55,1.55,0,0,0,.57-.11A1.52,1.52,0,0,0,5,10a1.32,1.32,0,0,0,0-.29A1.27,1.27,0,0,0,4.88,9.43Z"
			}), o.a.createElement("path", {
				d: "M4.33,14.75l-.26-.14-.28-.08a1.42,1.42,0,0,0-.58,0l-.28.08-.26.14a2.16,2.16,0,0,0-.23.19A1.52,1.52,0,0,0,2,16a1.47,1.47,0,0,0,.44,1.06,1.52,1.52,0,0,0,.49.33,1.53,1.53,0,0,0,1.14,0,1.61,1.61,0,0,0,.49-.33A1.52,1.52,0,0,0,5,16a1.5,1.5,0,0,0-.44-1.06A2.06,2.06,0,0,0,4.33,14.75Z"
			}), o.a.createElement("path", {
				d: "M2.44,2.94A1.52,1.52,0,0,0,2,4a1.47,1.47,0,0,0,.44,1.06,1.59,1.59,0,0,0,.48.33,1.65,1.65,0,0,0,.58.11,1.55,1.55,0,0,0,.57-.11,1.5,1.5,0,0,0,.49-.33,1.5,1.5,0,0,0,0-2.12A1.55,1.55,0,0,0,2.44,2.94Z"
			}))
		},
		"./src/reddit/icons/svgs/Gallery/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 16 16"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "M1 0H6C6.55298 0 7 0.446991 7 1V6C7 6.55301 6.55298 7 6 7H1C0.447021 7 0 6.55301 0 6V1C0 0.446991 0.447021 0 1 0ZM10 0H15C15.553 0 16 0.446991 16 1V6C16 6.55301 15.553 7 15 7H10C9.44702 7 9 6.55301 9 6V1C9 0.446991 9.44702 0 10 0ZM15 9H10C9.44702 9 9 9.44699 9 10V15C9 15.553 9.44702 16 10 16H15C15.553 16 16 15.553 16 15V10C16 9.44699 15.553 9 15 9ZM1 9H6C6.55298 9 7 9.44699 7 10V15C7 15.553 6.55298 16 6 16H1C0.447021 16 0 15.553 0 15V10C0 9.44699 0.447021 9 1 9Z"
			})))
		},
		"./src/reddit/icons/svgs/GovSmall/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M8.5,0.2l6.2,3c0.5,0.3,0.6,0.9,0.3,1.4C14.9,4.8,14.6,5,14.2,5H1.8c-0.6,0-1-0.4-1-1 c0-0.4,0.2-0.7,0.5-0.9l6.2-3C7.9,0,8.1,0,8.5,0.2z"
			}), o.a.createElement("path", {
				d: "M2,12h12c0.6,0,1,0.4,1,1l0,0c0,0.6-0.4,1-1,1H2c-0.6,0-1-0.4-1-1l0,0C1,12.4,1.4,12,2,12z"
			}), o.a.createElement("path", {
				d: "M3.8,6h0.5C4.7,6,5,6.3,5,6.8v3.5C5,10.7,4.7,11,4.2,11H3.8C3.3,11,3,10.7,3,10.3V6.8C3,6.3,3.3,6,3.8,6z"
			}), o.a.createElement("path", {
				d: "M7.8,6h0.5C8.7,6,9,6.3,9,6.8v3.5C9,10.7,8.7,11,8.2,11H7.8C7.3,11,7,10.7,7,10.3V6.8 C7,6.3,7.3,6,7.8,6z"
			}), o.a.createElement("path", {
				d: "M11.8,6h0.5C12.7,6,13,6.3,13,6.8v3.5c0,0.4-0.3,0.8-0.8,0.8h-0.5c-0.4,0-0.8-0.3-0.8-0.8V6.8 C11,6.3,11.3,6,11.8,6z"
			})))
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, n) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Grapple/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(e.className, a.a.grapple, {
					[a.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("title", {
				id: "".concat(e.title, "-title")
			}, e.title), o.a.createElement("g", null, o.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/Hamster1/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 53 67"
			}, o.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, o.a.createElement("path", {
				fill: "#000",
				d: "M36.17 15.7877c-2.1457-.6233-4.6272.5142-5.0853 2.419-.174.7268-.5168 1.0273-1.2283 1.124-1.5643.2126-2.9247.8707-4.0924 1.901-.807.7112-1.2403 1.523-1.2154 2.6702.0477 2.1067 1.0792 3.8318 2.0054 5.608.2256.432 2.0283-.631 1.111-.082-.616-1.9145-1.1994-3.6348-1.7152-5.3744-.2127-.72.0527-1.406.7364-1.754 1.2204-.6195 2.4954-1.1375 3.7456-1.702.5923-.2676.93-.057 1.27.465.821 1.2544 1.9995 2.04 3.5757 1.8642 1.6357-.1817 2.555-1.264 3.054-2.7215.6707-1.956-.2665-3.8677-2.1616-4.4176"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M32.575 18.997c-.1866-1.1486.5913-2.0766 1.949-2.3235 1.4877-.2722 2.729.4466 2.9796 1.7235.2642 1.345-.7003 2.9457-1.9175 3.1832-1.341.2627-2.7447-.9416-3.011-2.5832"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M17.0857 23.965c-2.5846-.806-4.1367.6-4.4678 3.2556-.3653 2.9378.675 6.234 3.5116 7.1787 2.9598.9843 5.8344-1.5318 6.3822-4.5023.4535-2.4616-3.5227-5.3826-5.426-5.932-3.1034-.9685 1.507.4345 0 0M39.321 24.512c-2.184-2.2814-6.028.2842-7.4777 2.256-.521.7074-.9206 1.5057-1.1896 2.3475-.35 1.0897.269.94.3743 1.8643.1922 1.6742 2.1314 3.3578 3.7206 3.5912 4.7354.694 7.7125-6.7713 4.3803-10.2603.1294.1364.259.2717.3894.408-.0658-.0692-.1315-.1384-.1973-.2066-1.9745-2.0624.696.7283 0 0M18.9308 59.6326c-.1867-.0458-.3346.0093-.443.1056-.001 0-.001-.001-.002-.001-1.5598.099-3.8566.7662-4.6848 2.1695-.8887 1.507.7358 2.5096 2.148 2.674 1.553.1813 3.8715-.3148 4.4405-1.8975.439-1.2193-.0328-2.7012-1.4587-3.0506M34.37 60.348c-.242-.0358-.5174.043-.6267.2957-1.5118 3.4664 6.185 5.586 7.6074 2.4245 1.3572-3.016-4.6648-4.4187-6.9808-2.7203"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M39.9895 37.3797c-3.8707-9.353-16.7772-11.6802-23.5762-4.7352-3.177 3.245-4.373 8.2466-4.83 9.7576-1.4357 4.748-1.561 10.198.7932 14.6874 3.987 7.605 16.61 9.4605 23.792 5.505 9.1842-5.058 6.6638-18.3606 3.437-26.1424.2377.5734.4746 1.1468.7124 1.7202-.1096-.2645-.219-.528-.3285-.7925-2.1562-5.211 1.182 2.856 0 0"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M26.4406 29.6162c3.5285 0 8.4696 2.1882 10.6613 4.9576 2.5828 3.2633 3.7284 8.3103 4.3175 12.3626.4945 3.4113-.4807 8.203-2.2755 11.186-2.1327 3.5455-6.732 4.5153-10.5422 4.4935-4.6918-.026-10.162-.5288-13.2412-4.577-2.77-3.643-3.234-8.4117-2.506-12.8188.401-2.4216 1.0284-5.207 1.9967-7.4706 2.105-4.9197 5.7597-8.1334 11.5893-8.1334"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M41.5915 49.6162c.03-.6952.008-1.3605-.044-2l.044 2zM37.4186 60.1975c-1.3365-.7743-2.342-2.1664-2.536-3.716-.0665-.533-.0396-1.074-.0128-1.61.0477-.9814.1004-1.9818.458-2.8933.4095-1.0428 1.1846-1.8868 1.9427-2.7034.46-.4967.9212-.9934 1.3823-1.49.7273-.7844 1.6783-1.6223 2.688-1.475-.4125-2.465-1.0336-5.1514-2.0422-7.567-1.0493 2.024-3.0208 3.9137-5.4086 2.871-.5147-.2242-.8774-.3756-1.3395-.7027-.8615-.7398-1.9138-.9498-3.157-.6288-.2702.3008-.5265.6128-.769.9368-.5157.521-1.1567.9812-1.9347.7632-1.7777-.5007-2.97-2.9346-5.1046-1.4002-.8675.624-1.9396 1.5637-3.0953 1.5082-2.0044-.096-3.3925-1.0983-4.2153-2.752-.776 2.0393-1.2024 4.4066-1.5432 6.479-.0407.2524-.0636.5098-.0974.7652.6232-.0353 1.2462-.013 1.8206.219.6776.2727 1.2182.8037 1.74 1.3225.8435.8388 1.708 1.706 2.187 2.8033.4382 1.0014.5227 2.123.5366 3.2183.015 1.0882-.0338 2.1754-.145 3.2566-.1313 1.284-.475 2.7296-1.571 3.3606 3.1707 2.359 7.553 2.7054 11.4153 2.7266 3.2216.0182 6.9976-.6774 9.4033-3.0224-.2027-.0868-.4104-.1585-.6022-.2695"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M19.3634 62.297c-.4735.8925-1.877 1.0785-2.832 1.1074-.5274.0154-1.058-.045-1.5395-.25-.894-.3822-.2403-1.1526.2322-1.5266.884-.7018 2.083-1.0513 3.2383-1.1217.114-.0072.2012-.0478.2752-.0993.846.2655.982 1.2193.6257 1.8904M39.1353 63.7074c-.7183.2857-1.607.0788-2.318-.0972-1.225-.3028-2.4647-1.2617-2.3147-2.656.0894-.0388.1756-.0948.2438-.1942 1.16-1.6788 4.4677-.7897 5.5096.6697.7194 1.008-.38 1.984-1.1207 2.2777"
			}), o.a.createElement("path", {
				fill: "#C18D42",
				d: "M17.2218 28.842c-.2698-1.599-.862-3.239-2.209-4.0722-1.519-.9397-1.5314 2.7022-1.4284 3.646.1773 1.6212.7036 4.1546 2.031 4.9962 1.0735.6814 1.7476-.4387 1.9068-1.9332.105-.9777-.1392-1.678-.3004-2.6368-.3327-1.9776.2232 1.3268 0 0"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M15.5475 24.681c1.747.664 2.8352 2.0178 3.3196 3.9672.3962 1.5937.7234 3.6126-.1366 4.959 1.6953.081 3.8534-.3464 3.6123-2.602 1.339-1.9475-4.229-7.018-6.7952-6.3243M33.6698 32.7516c-.407-.451.364.404 0 0"
			}), o.a.createElement("path", {
				fill: "#C18D42",
				d: "M35.796 29.1142c-.1635.7146-.323 1.4594-.211 2.192.178 1.1545.9577 1.6425 1.872 1.0695 1.2238-.7655 1.577-2.3845 1.9186-3.693.1864-.7164.529-3.6248-.9526-2.9716-1.4423.6354-2.308 2.0174-2.627 3.4032-.238 1.0394.3698-1.6104 0 0"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M35.3533 32.5596c-1.0047-1.2304-.5965-3.2887-.0174-4.64.6404-1.496 1.6748-2.6295 3.2115-3.037-.0695-.041-.136-.083-.2138-.114-1.9296-.775-4.9295 1.584-5.8667 3.0262-.6885 1.0606-2.0135 2.6206.8063 4.2594.7018.4085 1.3024.687 2.08.5054"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M32.8514 39.097c-.577.676-1.6076.6748-2.4273.0963-1.264-.8917-1.1062-3.3024.122-4.234.7017-.532 1.6705-.4205 2.1302.1645 1.53 1.946.6833 3.3772.1752 3.973"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M30.755 38.0938c-.2703-.432-.2692-1.2056-.039-1.8203.3575-.9478 1.322-.8296 1.6942.092.213.5263.1684 1.252-.0664 1.597-.7778 1.1484-1.3505.512-1.5888.1313"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M24.71 39.009c-.6662.8048-2.161.7863-3.1096.0826-1.5367-1.1425-1.2565-2.9377-.0257-3.8424.9816-.721 1.9472-.897 2.8605-.1542 1.636 1.3315 1.2372 2.751.2748 3.914"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M21.79 38.1136c-.322-.4-.3135-1.296-.0326-1.8656.4566-.922 1.1752-.7538 1.537-.016.2884.589.359 1.1686.0612 1.7166-.5324.982-1.0995.7425-1.5656.165"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M24.5598 40.2202c.8506 1.8878 3.3605 1.9104 3.9825-.235.0587-.206-.3954-.314-.471-.3215-1.1-.0954-2.188-.0502-3.278.1646-.637.1256.158.5627.459.5024.9212-.182 1.8433-.2474 2.7733-.167-.157-.1068-.314-.2136-.471-.3216-.14.4862-.3785.834-.7293 1.098-.5525.4157-1.0443-.1445-1.3017-.716-.147-.3266-1.094-.2915-.9638-.0038"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M22.5907 41.495c1.505 1.488 4.0743 1.4078 5.0584-.571-.3263-.06-.6527-.121-.98-.182-.2436 2.3982 3.9335 2.359 4.8708.653.1018-.186-.8275-.4596-.9802-.1822-.556 1.1467-1.526 1.0504-2.9105-.2888.029-.284-.8573-.428-.98-.182-.497 1.0008-1.7188 2.179-3.194.7215-.1837-.182-1.14-.221-.8843.0315M19.5653 46.516c-.473 6.7128 8.6924 4.2055 5.1774-.548-.6672-.903-.7844.151-.5202.7218.5274 1.1447.4853 2.1653-.5644 2.844-1.2192.7874-2.6945.0107-2.9834-1.216-.112-.5384-.144-1.082-.0936-1.6312.0237-.3453-.993-.4877-1.0157-.1705M29.6923 44.8475c-1.689 1.2247-1.5924 4.6386.8496 4.7633 1.13.0575 2.2874-.3435 3.0557-1.1673.3415-.3653 1.5518-2.4732.5793-2.709-1.2043-.293-1.2043 3.92-3.9756 3.001-.9725-.3227-.5812-1.1573-.5253-1.9048.0163-.218 1.4523-3.0258.0163-1.9832"
			})))
		},
		"./src/reddit/icons/svgs/Hamster2/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 53 67"
			}, o.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, o.a.createElement("path", {
				fill: "#FFF",
				d: "M9.5927 33.2517c.829 1.0475-1.9245 5.7044-2.2983 5.6247-7.91-1.6942-2.065-11.142 2.2983-5.6247z"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M7.2853 38.8738c-7.8952-1.69-2.0557-11.1393 2.297-5.625.8272 1.047-.4264.8297-.9997.3446-1.1508-.97-2.3416-1.2604-3.462-.3077-1.3005 1.107-.879 3.0184.443 3.748.585.3038 1.202.5194 1.8517.6446.4058.0876.243 1.275-.13 1.1955"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M50.0333 34.034c-.1167 1.5037-.772 2.978-1.8564 3.877-.4812.3997-3.1335 1.7-3.25.3792-.1457-1.6356-1.7525-4.3107-.3047-6.062 1.7012-2.06 5.6625-1.444 5.411 1.8057z"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M38.8415 2.2205c-2.7586-.8015-5.949.661-6.538 3.11-.2237.9345-.6645 1.321-1.5794 1.4452-2.011.2734-3.7602 1.1195-5.2615 2.444-1.0375.9146-1.5946 1.9584-1.5627 3.4333.0614 2.7088 1.3876 4.9268 2.5785 7.2106.29.5554 2.6078-.8114 1.4285-.1056-.7922-2.4615-1.5422-4.6733-2.2054-6.91-.2734-.9256.0677-1.8078.9468-2.2552 1.569-.7964 3.2084-1.4625 4.8157-2.188.7615-.3443 1.196-.0734 1.633.5976 1.0553 1.6128 2.5707 2.623 4.597 2.397 2.1033-.2337 3.2852-1.6254 3.9266-3.4992.8624-2.515-.3425-4.9727-2.779-5.6797"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M33.9315 6.857c-.224-1.3784.7095-2.492 2.3388-2.7883 1.7852-.3266 3.275.536 3.5755 2.0682.317 1.614-.8404 3.5347-2.301 3.8197-1.6092.3153-3.2938-1.13-3.6133-3.0997"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M14.7982 12.4437c-3.36-1.0258-5.3778.7637-5.8082 4.1436-.4748 3.739.8778 7.9344 4.5652 9.1366 3.8478 1.2526 7.5847-1.9496 8.297-5.7303.5894-3.133-4.5797-6.8506-7.054-7.55-4.0343-1.2325 1.959.5532 0 0M43.3042 13.0588c-2.8393-2.6964-7.8367.3357-9.7212 2.666-.6773.836-1.1967 1.7795-1.5465 2.7743-.455 1.288.3498 1.111.4866 2.2034.25 1.9786 2.771 3.9682 4.837 4.244 6.156.8204 10.0262-8.0023 5.6943-12.1256.1683.161.3367.321.5063.482-.0855-.0817-.171-.1634-.2564-.244-2.567-2.4376.9047.8605 0 0M16.2644 58.021c-.2208-.059-.3958.012-.5237.136-.0012 0-.0012-.0012-.0024-.0012-1.8447.1275-4.5607.9865-5.54 2.7936-1.051 1.9405.87 3.2314 2.5398 3.4432 1.8366.2334 4.5785-.4055 5.2513-2.4435.519-1.57-.0387-3.478-1.725-3.928M35.8236 58.9218c-.272-.045-.582.0543-.705.3726-1.7005 4.3674 6.9575 7.0378 8.5576 3.0546 1.5267-3.7998-5.2473-5.567-7.8526-3.4272"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M43.621 29.1977c-4.9592-11.951-21.4957-14.9246-30.207-6.0505-4.0707 4.1463-5.603 10.5374-6.1882 12.468-1.8397 6.067-2.0003 13.0306 1.016 18.767 5.1085 9.718 21.2816 12.0886 30.4837 7.0343 11.767-6.463 8.538-23.4607 4.4034-33.4042.3046.7327.608 1.4654.9127 2.198-.1402-.338-.2804-.6746-.4207-1.0126-2.7626-6.6584 1.5146 3.6495 0 0"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M25.8506 19.7317c4.5594 0 10.944 2.8204 13.7762 6.3902 3.3375 4.2063 4.8178 10.7118 5.579 15.935.639 4.3973-.6212 10.5736-2.9403 14.4188-2.7558 4.57-8.6988 5.8202-13.6222 5.792-6.0627-.0332-13.131-.6814-17.1098-5.8996-3.5793-4.6956-4.179-10.8425-3.2382-16.523.518-3.1216 1.329-6.7118 2.58-9.6297 2.7202-6.3415 7.4425-10.4838 14.9753-10.4838"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M45.9425 45c.03-.6952.008-1.3605-.044-2l.044 2zM39.8434 58.144c-1.7227-.9698-3.0188-2.7136-3.2686-4.6547-.0858-.6677-.0512-1.3455-.0166-2.017.0615-1.2292.1293-2.4824.5904-3.6243.5277-1.3063 1.5267-2.3634 2.504-3.3865.593-.622 1.1872-1.2443 1.7815-1.8665.9376-.9825 2.1633-2.032 3.4645-1.8475-.5315-3.088-1.332-6.453-2.632-9.4792-1.3524 2.5355-3.8935 4.9027-6.971 3.5964-.6636-.2807-1.131-.4704-1.7266-.88-1.1105-.927-2.467-1.19-4.069-.788-.3485.377-.679.7677-.9914 1.1736-.6647.6525-1.4908 1.2292-2.4937.956-2.2913-.6272-3.8283-3.676-6.5793-1.754-1.1182.7816-2.5 1.959-3.9896 1.8893-2.5832-.12-4.3725-1.3758-5.433-3.4472-1.0002 2.5544-1.5497 5.5198-1.989 8.116-.0525.316-.082.6386-.1255.9585.803-.0443 1.606-.0165 2.3464.2743.8734.3415 1.57 1.0066 2.2425 1.6566 1.0874 1.0508 2.2016 2.137 2.819 3.5116.5648 1.2545.6737 2.6594.6916 4.0315.0193 1.3633-.0435 2.7252-.187 4.0796-.169 1.6085-.612 3.4193-2.0248 4.2097 4.087 2.9553 9.735 3.389 14.7134 3.4156 4.1523.0226 9.0192-.8486 12.12-3.7862-.2614-.1088-.529-.1986-.7762-.3377"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M16.6775 61.5205c-.5682 1.19-2.2523 1.438-3.3982 1.4765-.633.0205-1.2697-.0602-1.8475-.3336-1.0727-.5094-.2883-1.5367.2787-2.0352 1.0607-.9357 2.4997-1.4018 3.886-1.4957.137-.0097.2414-.064.3303-.1325 1.015.354 1.1784 1.6258.7507 2.5205M41.3178 62.8585c-.838.2857-1.875.079-2.7043-.097-1.429-.303-2.8756-1.2618-2.7005-2.656.1043-.039.2048-.095.2843-.1944 1.3534-1.6787 5.2124-.7896 6.428.6698.8393 1.008-.4433 1.984-1.3075 2.2777"
			}), o.a.createElement("path", {
				fill: "#C18D42",
				d: "M14.4914 18.1648c-.3373-1.9542-1.0774-3.9587-2.7615-4.977-1.8987-1.1487-1.9142 3.3025-1.7855 4.4562.2217 1.9814.8796 5.0777 2.5387 6.1064 1.342.8328 2.1846-.5362 2.3836-2.363.131-1.1948-.174-2.0508-.3754-3.2226-.416-2.417.279 1.6217 0 0"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M11.8985 13.079c1.9966.812 3.2402 2.4664 3.7938 4.849.4527 1.9478.8267 4.4154-.1562 6.061 1.9376.099 4.404-.4234 4.1285-3.1804 1.5303-2.38-4.8333-8.5774-7.766-7.7295M35.0207 23.1353c-.407-.451.364.404 0 0"
			}), o.a.createElement("path", {
				fill: "#C18D42",
				d: "M38.2093 19.4974c-.2045.9188-.4038 1.8764-.264 2.8182.2225 1.4844 1.197 2.112 2.34 1.3752 1.5298-.9843 1.9712-3.066 2.3983-4.748.233-.9213.6613-4.6607-1.1908-3.8208-1.803.8168-2.885 2.5937-3.2835 4.3754-.2977 1.3363.462-2.0706 0 0"
			}), o.a.createElement("path", {
				fill: "#FF8717",
				d: "M37.7916 23.9292c-1.2917-1.538-.767-4.111-.0223-5.8.8235-1.87 2.1534-3.287 4.1292-3.7963-.0894-.0513-.175-.1037-.275-.1424-2.481-.9687-6.3378 1.98-7.5428 3.7826-.8853 1.3257-2.5888 3.2757 1.0366 5.3243.9024.5106 1.6746.859 2.6743.6317"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M34.0283 31.3767c-.721.8113-2.0094.81-3.034.1158-1.58-1.07-1.383-3.963.1523-5.081.877-.6384 2.088-.5045 2.6627.1976 1.9127 2.3352.854 4.0527.219 4.7677"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M31.106 29.4776c-.2703-.432-.2692-1.2056-.039-1.8204.3574-.9477 1.322-.8296 1.6942.092.213.5264.1684 1.252-.0664 1.597-.7778 1.1484-1.3506.5122-1.5888.1314"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M23.8934 30.2714c-.7994.9656-2.5933.9435-3.7315.099-1.844-1.371-1.508-3.5252-.031-4.6108 1.178-.8653 2.3368-1.0765 3.4327-.185 1.9633 1.5977 1.4846 3.301.3297 4.6968"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M20.141 29.4974c-.322-.4-.3135-1.2962-.0326-1.8657.4566-.922 1.1752-.7537 1.537-.0158.2884.5886.359 1.1683.061 1.7164-.5322.982-1.0993.7424-1.5654.165"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M23.9138 33.604c1.0632 1.8878 4.2007 1.9104 4.9782-.235.0733-.206-.4943-.314-.5887-.3215-1.375-.0955-2.735-.0502-4.0976.1646-.796.1257.1975.5628.574.5025 1.1512-.1822 2.304-.2475 3.4664-.167-.196-.1068-.3923-.2136-.5886-.3216-.175.486-.4732.834-.9117 1.0977-.6905.4157-1.3054-.1445-1.627-.716-.184-.3266-1.3676-.2914-1.205-.0038"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M20.9512 35.318c1.8397 2.232 4.9797 2.112 6.1826-.8564-.399-.09-.798-.1816-1.198-.273-.2976 3.5973 4.8077 3.5387 5.9532.9794.1245-.279-1.0113-.6892-1.198-.273-.6794 1.72-1.8652 1.5755-3.5572-.4334.0354-.426-1.048-.642-1.198-.273-.6075 1.5012-2.1007 3.2685-3.9037 1.0823-.2244-.2732-1.393-.3318-1.0808.047M44.4978 32.213c1.7332-2.056 5.7836-1.429 5.5353 1.821-.115 1.5038-.7808 2.977-1.8867 3.8733-.4907.3984-3.198 1.692-3.3206.3704-.1534-1.6365 4.8643-1.0204 4.2203-4.8223-.2264-1.3343-1.284-.9385-2.1835-.974-.262-.0102-3.8398 1.4795-2.3647-.2684"
			})))
		},
		"./src/reddit/icons/svgs/Help/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 16 16",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				fill: "inherit",
				d: "M8.622 10.616c.078.08.14.175.183.28.044.105.07.218.07.332 0 .237-.087.456-.253.62-.167.168-.385.255-.622.255-.236 0-.455-.087-.62-.254-.167-.166-.255-.385-.255-.622 0-.114.027-.227.07-.332.044-.105.105-.2.184-.28.087-.088.174-.15.288-.193.324-.13.71-.052.954.193zm-.205-6.242c1.595 0 2.466.807 2.466 1.92 0 .976-.556 1.448-1.238 1.816-.615.317-.83.518-.904.898 0 .004-.034.207-.036.21-.034.126-.087.244-.18.336-.14.14-.323.21-.524.21-.097 0-.192-.017-.29-.052-.087-.035-.165-.088-.235-.158-.14-.14-.22-.333-.22-.533 0-.11.02-.188.074-.348.16-.472.55-.896 1.056-1.17.577-.327.84-.558.84-1.07 0-.42-.357-.715-.987-.715-.496 0-.996.218-1.39.52-.26.2-.62.202-.858-.02l-.05-.05c-.313-.29-.27-.787.075-1.04.603-.444 1.394-.753 2.4-.753zM8 13.25c-2.895 0-5.25-2.355-5.25-5.25S5.105 2.75 8 2.75 13.25 5.105 13.25 8 10.895 13.25 8 13.25M8 1C4.14 1 1 4.14 1 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7"
			}))
		},
		"./src/reddit/icons/svgs/ImagePost/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1pAYDrDlDFEJk994qhxbYj"
			}
		},
		"./src/reddit/icons/svgs/ImagePost/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/ImagePost/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M16,2H4A2,2,0,0,0,2,4V16a2,2,0,0,0,2,2H16a2,2,0,0,0,2-2V4A2,2,0,0,0,16,2Zm0,14H10.14a.49.49,0,0,1,.05-.48l3.15-4.26a.5.5,0,0,1,.38-.2.53.53,0,0,1,.4.17L16,13.35ZM4,13.51,7.26,8.82a.54.54,0,0,1,.42-.21.5.5,0,0,1,.41.23l2.85,4.34L8.84,16H4Zm10.4-7.1a1.7,1.7,0,1,1-1.7-1.7A1.7,1.7,0,0,1,14.4,6.41Z"
			}))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Link/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "M18.4773727,1.51993937 C19.4600354,2.50135191 20.0013751,3.80656808 20.0013751,5.19554812 C20.0013751,6.58577837 19.4600354,7.89099453 18.4773727,8.87240707 C17.9885417,9.35998782 17.1984109,9.35998782 16.7095799,8.87240707 C16.2207489,8.38357611 16.2207489,7.59094484 16.7095799,7.10461429 C17.2196644,6.59452982 17.500961,5.91691759 17.500961,5.19554812 C17.500961,4.47542886 17.2196644,3.79781663 16.7095799,3.28773215 C15.6569056,2.23755822 13.9453721,2.23755822 12.8926978,3.28773215 L8.62324066,7.55843946 C7.57181653,8.6111138 7.57181653,10.3226473 8.62324066,11.3753216 C9.11207162,11.8629024 9.11207162,12.6555336 8.62324066,13.1431144 C8.37945029,13.3869048 8.05939728,13.509425 7.73934427,13.509425 C7.41929127,13.509425 7.09923826,13.3869048 6.85544788,13.1431144 C4.82886225,11.1152785 4.82886225,7.81723232 6.85544788,5.79064668 L11.124905,1.51993937 C13.1502404,-0.505396058 16.4495368,-0.507896472 18.4773727,1.51993937 Z M11.3753215,6.8540728 C11.8641524,6.36524184 12.6542833,6.36524184 13.1431142,6.8540728 C15.1696999,8.88065844 15.1696999,12.1799549 13.1431142,14.2065405 L8.87240693,18.4772478 C7.89099439,19.4586603 6.58452801,20 5.19679818,20 C3.80781814,20 2.50135177,19.4586603 1.51993923,18.4772478 C-0.50664641,16.4506622 -0.50664641,13.1513657 1.51993923,11.1247801 C2.00877019,10.6359491 2.80015125,10.6359491 3.28773201,11.1247801 C3.77656297,11.6136111 3.77656297,12.4037419 3.28773201,12.8925729 C2.23505767,13.9452472 2.23505767,15.6567807 3.28773201,16.709455 C4.34040635,17.7621294 6.05193981,17.7621294 7.10461415,16.709455 L11.3753215,12.4387477 C12.4279958,11.3860734 12.4279958,9.67453992 11.3753215,8.62186558 C10.8864905,8.13303462 10.8864905,7.34290376 11.3753215,6.8540728 Z"
			})))
		},
		"./src/reddit/icons/svgs/MarkdownMode/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 208 128"
			}, o.a.createElement("rect", {
				width: "198",
				height: "118",
				x: "5",
				y: "5",
				ry: "10",
				stroke: "currentColor",
				strokeWidth: "10",
				fill: "none"
			}), o.a.createElement("path", {
				d: "M30 98v-68h20l20 25 20-25h20v68h-20v-39l-20 25-20-25v39zM155 98l-30-33h20v-35h20v35h20z"
			}))
		},
		"./src/reddit/icons/svgs/Media/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				fill: "inherit",
				fillRule: "evenodd",
				d: "m8.986223,16.927949l2.240493,-3.024991l-3.521864,-5.376734c-0.102125,-0.156 -0.274999,-0.251499 -0.461249,-0.253749c-0.158375,-0.01 -0.362749,0.0875 -0.468249,0.241249l-5.239359,7.532977c-0.12,0.170624 -0.1335,0.394124 -0.037,0.579248c0.0975,0.185249 0.287499,0.301999 0.497498,0.301999l6.989729,0zm8.513724,3.071991l-14.999954,0c-1.378746,0 -2.499992,-1.121247 -2.499992,-2.499992l0,-14.999954c0,-1.378746 1.121247,-2.499992 2.499992,-2.499992l14.999954,0c1.378746,0 2.499992,1.121247 2.499992,2.499992l0,14.999954c0,1.378746 -1.121247,2.499992 -2.499992,2.499992zm0.803498,-3.071991c0.221249,0 0.420999,-0.129125 0.511873,-0.331249c0.091,-0.201999 0.05375,-0.437749 -0.092,-0.602748l-4.238862,-4.778985c-0.11125,-0.12575 -0.257124,-0.186249 -0.444499,-0.188749c-0.169624,0.008 -0.325624,0.091 -0.425499,0.226874l-3.540739,4.778985c-0.126875,0.170749 -0.145,0.398749 -0.0495,0.587123c0.094375,0.189749 0.288749,0.308749 0.500748,0.308749l7.778726,0l-0.00025,0zm-2.982116,-11.404215c0,-1.173746 -0.952497,-2.124994 -2.124994,-2.124994c-1.174996,0 -2.124994,0.951247 -2.124994,2.124994c0,1.172496 0.949997,2.123744 2.124994,2.123744c1.172496,0 2.124994,-0.951247 2.124994,-2.123744z"
			}))
		},
		"./src/reddit/icons/svgs/Moderate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/constants/colors.ts");
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && o.a.createElement("desc", null, e.desc), o.a.createElement("path", {
				d: "M1.88,3.32V9a11.53,11.53,0,0,0,8,11L10,20l.08,0a11.53,11.53,0,0,0,8-11V3.32A11.57,11.57,0,0,1,10,0,11.57,11.57,0,0,1,1.88,3.32"
			}), o.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "5",
				fill: e.isUnread ? "white" : "none"
			}), o.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "4",
				fill: e.isUnread ? r.a.orangered : "none"
			}))
		},
		"./src/reddit/icons/svgs/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("path", {
				d: "M16 10.77a1 1 0 0 0-1 1V14a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h2.23a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3v-2.23a1 1 0 0 0-1-1z"
			}), o.a.createElement("path", {
				d: "M17.91 2.62A1 1 0 0 0 17 2h-4a1 1 0 0 0 0 2h1.59L9.38 9.19a1 1 0 1 0 1.41 1.41L16 5.41V7a1 1 0 0 0 2 0V3a1 1 0 0 0-.09-.38z"
			}))
		},
		"./src/reddit/icons/svgs/Pencil/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("title", {
				id: "".concat(e.title, "-title")
			}, e.title), o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "M15.75,7.834625 L12,4.084625 L12.808,3.276625 C13.8435,2.241125 15.5225,2.241125 16.558,3.276625 C17.5935,4.312125 17.5935,5.991125 16.558,7.026625 L15.75,7.834625 Z M11.366,5 L15.116,8.75 L7.25,16.616 L3.5,12.866 L11.366,5 Z M2.5035,13.5 L6.1125,17.109 L1,18.6125 L2.5035,13.5 Z"
			})))
		},
		"./src/reddit/icons/svgs/Plus/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1"
			}, o.a.createElement("g", {
				stroke: "none"
			}, o.a.createElement("g", {
				transform: "translate(-34.000000, -136.000000)",
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "M45.2,147.2 L48.8,147.2 C49.46272,147.2 50,146.66272 50,146 C50,145.33728 49.46272,144.8 48.8,144.8 L45.2,144.8 L45.2,141.2 C45.2,140.53728 44.66272,140 44,140 C43.33728,140 42.8,140.53728 42.8,141.2 L42.8,144.8 L39.2,144.8 C38.53728,144.8 38,145.33728 38,146 C38,146.66272 38.53728,147.2 39.2,147.2 L42.8,147.2 L42.8,150.8 C42.8,151.46272 43.33728,152 44,152 C44.66272,152 45.2,151.46272 45.2,150.8 L45.2,147.2 Z"
			}))))
		},
		"./src/reddit/icons/svgs/Poll/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				d: "M2.1952,13.9279 C2.9452,13.9279 3.5382,14.3119 3.8382,14.8939 L2.8962,15.3249 C2.7702,15.0489 2.4882,14.8519 2.1232,14.8519 C1.6192,14.8519 1.2232,15.3189 1.2232,15.9489 C1.2232,16.5849 1.6252,17.0409 2.1172,17.0409 C2.4882,17.0409 2.7772,16.8369 2.9262,16.5369 L3.9162,16.8909 C3.6102,17.5559 2.9802,17.9639 2.1952,17.9639 C1.0492,17.9639 0.1202,17.0759 0.1202,15.9489 C0.1202,14.8279 1.0492,13.9279 2.1952,13.9279 Z M11.5004,14.5 C12.3294,14.5 13.0004,15.171 13.0004,16 C13.0004,16.829 12.3294,17.5 11.5004,17.5 L6.5004,17.5 C5.6714,17.5 5.0004,16.829 5.0004,16 C5.0004,15.171 5.6714,14.5 6.5004,14.5 L11.5004,14.5 Z M1.8953,8.0003 C2.8063,8.0003 3.5503,8.2643 3.5503,9.0313 C3.5503,9.3433 3.3523,9.5893 3.0763,9.7813 C3.4483,9.9553 3.7243,10.2253 3.7243,10.6623 C3.7243,11.5179667 2.93757778,11.8598556 2.22929983,11.8952023 L2.1053,11.8983 L0.3723,11.8983 L0.3723,8.0003 L1.8953,8.0003 Z M18.5004,8.5 C19.3294,8.5 20.0004,9.171 20.0004,10 C20.0004,10.829 19.3294,11.5 18.5004,11.5 L6.5004,11.5 C5.6714,11.5 5.0004,10.829 5.0004,10 C5.0004,9.171 5.6714,8.5 6.5004,8.5 L18.5004,8.5 Z M1.8623,8.8693 L1.4753,8.8693 L1.4753,11.0283 L1.9843,11.0283 C2.3013,11.0283 2.5853,10.7603 2.5853,10.4623 C2.5853,10.0713909 2.27786198,9.92097769 2.01460128,9.89686048 L1.9373,9.8933 L1.9373,9.7853 C2.0923,9.7853 2.4353,9.6783 2.4353,9.3333 C2.4353,8.9793 2.1923,8.8693 1.8623,8.8693 Z M2.783,1.9997 L4.096,5.8977 L2.963,5.8977 C2.963,5.8977 2.147,3.3737 2.063,3.0137 L2.063,3.0137 L2.039,3.0137 C1.955,3.3737 1.127,5.8977 1.127,5.8977 L1.127,5.8977 L-2.25597319e-13,5.8977 L1.319,1.9997 L2.783,1.9997 Z M15.5004,2.5 C16.3294,2.5 17.0004,3.171 17.0004,4 C17.0004,4.829 16.3294,5.5 15.5004,5.5 L6.5004,5.5 C5.6714,5.5 5.0004,4.829 5.0004,4 C5.0004,3.171 5.6714,2.5 6.5004,2.5 L15.5004,2.5 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Powerup/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 32 32",
				fill: "none",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				id: e.id
			}, e.title && o.a.createElement("title", null, e.title), o.a.createElement("path", {
				d: "M12.249 32c-.4 0-.8-.1-1.2-.25l-.05-.05-5.05-2.6c-1.25-.7-1.75-2.2-1.25-3.5l.05-.1 2.45-5.45-3.15-1.5a2.985 2.985 0 01-1.4-3.55l3.5-12.05C6.649 1.2 8.299 0 10.099 0h7.8c.45 0 .9.1 1.3.3l.15.1 4.85 2.45c1.5.8 2.05 2.55 1.35 4.05l-2.2 4.3 4.45 2.25c.8.45 1.35 1.25 1.45 2.2.1.9-.2 1.8-.9 2.45l-14.15 13.15c-.55.5-1.25.75-1.95.75z",
				fill: "#000"
			}), o.a.createElement("path", {
				d: "M10.648 17l-.85 2.1-4.65-2.2c.1.05.25.1.4.1h5.1zM23.749 13.6l3.1 1.6c.5.3.65 1 .15 1.45L12.849 29.8c-.3.25-.65.3-.95.15l-4.85-2.5c.3.1.65.1.9-.15l14.15-13.15c.5-.45.35-1.15-.15-1.45l1.8.9z",
				fill: "#FF4500"
			}), o.a.createElement("path", {
				d: "M23.75 13.6l3.1 1.6c.5.3.65 1 .15 1.45l-4.9-2.5c.5-.45.35-1.15-.15-1.45l1.8.9z",
				fill: "#FF8717"
			}), o.a.createElement("path", {
				d: "M18.898 3.5c.25-.55.05-1.1-.45-1.4l4.9 2.5c.5.25.7.85.45 1.4l-3.35 6.55h-6.05l4.5-9.05z",
				fill: "#FF4500"
			}), o.a.createElement("path", {
				d: "M18.9 3.5c.25-.55.05-1.1-.45-1.4l4.9 2.5c.5.25.7.85.45 1.4l-4.9-2.5z",
				fill: "#FF8717"
			}), o.a.createElement("path", {
				d: "M21.95 12.65c.5.3.65 1 .15 1.45L7.95 27.3c-.3.25-.65.3-.9.15l-.1-.05a.86.86 0 01-.4-1.05l4.1-9.35h-5.1c-.15 0-.3-.05-.45-.1l-.1-.05c-.4-.25-.65-.75-.5-1.25L8.05 3.55A2.19 2.19 0 0110.15 2h7.8c.15 0 .3.05.45.1l.05.05c.45.25.7.85.45 1.4l-4.5 9.05h7.1c.15 0 .3.05.4.1l.05-.05z",
				fill: "#FFD635"
			}), o.a.createElement("path", {
				d: "M15.599 3.45c.55-.15 1.15-.25 1.7-.45-.6-.1-1.15-.15-1.75-.2-.6-.05-1.15-.05-1.75-.1-1.15-.05-2.25 0-3.4.05-.55 0-1.05.3-1.35.8-.15.3-.15.35-.2.5l-.15.4-.5 1.55c-.35 1.05-.7 2.1-1 3.15-.3 1.05-.65 2.1-.9 3.2-.3 1.05-.6 2.15-.8 3.25.55-1 1-2 1.5-3 .45-1 .9-2 1.35-3.05.4-1 .85-2.05 1.2-3.1l.6-1.55.25-.65h.05c1.15-.1 2.3-.25 3.4-.45.6-.1 1.15-.2 1.75-.35zM20.25 13.35c-1.1-.05-2.2-.05-3.3 0-.55 0-1.1.05-1.65.1-.55.05-1.1.1-1.65.2.55.15 1.1.25 1.6.35.55.1 1.1.2 1.65.25.6.1 1.25.15 1.85.2-.45.45-.9.85-1.3 1.3-.75.75-1.5 1.5-2.25 2.3-.75.8-1.5 1.55-2.2 2.35-.7.8-1.45 1.6-2.1 2.45.9-.65 1.7-1.3 2.55-2 .85-.7 1.65-1.4 2.45-2.1.8-.7 1.6-1.45 2.4-2.15l2.35-2.2c.1-.1.15-.25.2-.4 0-.4-.3-.65-.6-.65z",
				fill: "#fff"
			}))
		},
		"./src/reddit/icons/svgs/QuarantineWarning/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => {
				let {
					className: t
				} = e;
				return o.a.createElement("svg", {
					className: t,
					viewBox: "0 0 12 12",
					xmlns: "http://www.w3.org/2000/svg"
				}, o.a.createElement("g", {
					fillRule: "evenodd"
				}, o.a.createElement("path", {
					d: "M0 12h12V0H0z",
					fill: "none"
				}), o.a.createElement("path", {
					d: "M6.367 6.704a.376.376 0 0 1-.734 0l-.75-3.5a.376.376 0 0 1 .367-.454h1.5a.376.376 0 0 1 .367.454l-.75 3.5zm.166 2.701A.756.756 0 0 1 6 9.622a.74.74 0 0 1-.75-.75c0-.097.023-.195.06-.285a.74.74 0 0 1 .158-.24.778.778 0 0 1 1.065 0 .74.74 0 0 1 .157.24.76.76 0 0 1 .06.285c0 .203-.083.39-.217.533zm5.284-.373l-4.5-8.25a1.5 1.5 0 0 0-2.634 0l-4.5 8.25A1.501 1.501 0 0 0 1.5 11.25h9a1.5 1.5 0 0 0 1.317-2.218z",
					fill: "inherit"
				})))
			}
		},
		"./src/reddit/icons/svgs/RadioOff/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_11Rht_b1e-kmk12gkz7Lug"
			}
		},
		"./src/reddit/icons/svgs/RadioOff/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/RadioOff/index.m.less"),
				a = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", c({}, e, {
				className: Object(r.a)(a.a.icon, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "M10,1.66666667 C5.39762708,1.66666667 1.66666667,5.39762708 1.66666667,10 C1.66666667,14.6023729 5.39762708,18.3333333 10,18.3333333 C14.6023729,18.3333333 18.3333333,14.6023729 18.3333333,10 C18.3333333,5.39762708 14.6023729,1.66666667 10,1.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/RadioOn/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", r({}, e, {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "M10,6.66666667 C8.15905083,6.66666667 6.66666667,8.15905083 6.66666667,10 C6.66666667,11.8409492 8.15905083,13.3333333 10,13.3333333 C11.8409492,13.3333333 13.3333333,11.8409492 13.3333333,10 C13.3333333,8.15905083 11.8409492,6.66666667 10,6.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);

			function r() {
				return (r = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => o.a.createElement("svg", r({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), o.a.createElement("g", null, o.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Search/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M15.59,13.91l2.78,2.69a1.25,1.25,0,1,1-1.74,1.8l-2.82-2.73a8,8,0,1,1,1.78-1.76ZM14.64,9.2A5.45,5.45,0,1,0,9.2,14.64,5.45,5.45,0,0,0,14.64,9.2Z"
			}))
		},
		"./src/reddit/icons/svgs/Send/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				id: e.id,
				viewBox: "0 0 18 18",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "M17.98 8.87c-.012-.093-.03-.182-.062-.27-.017-.043-.034-.085-.055-.126-.013-.026-.02-.057-.034-.082l-.07-.1c-.018-.02-.04-.03-.055-.046-.073-.083-.158-.145-.252-.204-.032-.02-.053-.055-.088-.072L3.88 1.12c-.35-.176-.764-.158-1.096.05-.332.208-.534.576-.534.973V5c0 .507.33.954.81 1.097L9 7.857H3.375c-.175 0-.347.04-.503.12L.622 9.12c-.48.243-.724.8-.582 1.325.135.5.582.84 1.085.84.027 0 .054 0 .08-.003l1.045-.075v4.65c0 .396.202.764.534.972.18.112.386.17.59.17.173 0 .346-.04.505-.12l13.483-6.85c.08-.044.134-.075.184-.113.05-.038.092-.085.136-.13.012-.013.026-.022.037-.036.092-.107.147-.21.19-.32.013-.03.02-.06.03-.09.013-.045.033-.086.042-.132.008-.046.013-.09.017-.138 0-.023-.008-.043-.008-.063 0-.017.008-.03.008-.048 0-.032-.017-.058-.02-.09z"
			})))
		},
		"./src/reddit/icons/svgs/SnooPosting/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 45 43"
			}, o.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, o.a.createElement("g", {
				fill: "#0DD3BB",
				transform: "translate(0 4)"
			}, o.a.createElement("ellipse", {
				cx: "25.492",
				cy: "22.2631",
				transform: "rotate(5 25.492 22.263)",
				rx: "17.6396",
				ry: "13.9883"
			}), o.a.createElement("ellipse", {
				cx: "19.3519",
				cy: "17.9699",
				transform: "rotate(5 19.352 17.97)",
				rx: "14.7297",
				ry: "16.0688"
			}), o.a.createElement("ellipse", {
				cx: "14.0251",
				cy: "27.7862",
				transform: "rotate(5 14.025 27.786)",
				rx: "8.4751",
				ry: "8.9243"
			}), o.a.createElement("ellipse", {
				cx: "11.808",
				cy: "17.4531",
				transform: "rotate(5 11.808 17.453)",
				rx: "10.7695",
				ry: "10.8575"
			}), o.a.createElement("ellipse", {
				cx: "12.1168",
				cy: "22.4429",
				transform: "rotate(5 12.117 22.443)",
				rx: "8.4751",
				ry: "8.9243"
			})), o.a.createElement("path", {
				fill: "#FFF",
				d: "M35.6875 31.5625c-1.3275 1.8696-6.7017 5.0483-8.7188 6.0313-2.0174.983-13.478 2.1465-15.625-.6876-1.5625-2.0624-.9687-4.625 1-6.1562C9.6563 29.2812 8.125 27.8437 7 24.9062c-.0872-.2277-1.1015-1.763-.875-1.7812l.9375-4.0313c.8158-2.9308 4.2118-5.1638 6.7992-6.5715 2.3198-1.2615 4.9067-1.934 7.5113-2.1714 2.1052-.192 4.259-.101 6.277.554 2.0182.6552 4.2956 1.063 5.5063 2.8765 0 0 1.5532 3.6305 1.6736 5.5487.1204 1.9177-2.0402 6.1206-2.0402 6.1206"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M31.5665 34.5708c.6293 1.944.9 4.0143.794 6.0635 0 0-.473 1.3654-6.7204 1.3654-6.2478 0-7.6077-.7104-7.6077-.7104.047-1.224.0518-2.4493.014-3.6732-.0028-.097.0414-.2356.13-.2062l-.1555-7.319 12.5354-2.0634c.4433.252.8525.5696 1.211.9412l-.2007 5.6022z"
			}), o.a.createElement("path", {
				fill: "#FF0",
				d: "M34.0514 21.4676c-.3642.8707-.5738 1.8017-.8143 2.7188-.601 2.29-1.4044 4.5218-2.3967 6.658.1578.0357.3286.0014.4624-.0927.072.7567 1.0046 1.1686 1.678.8836.6734-.2846 1.071-1.0334 1.2235-1.777.0223-.1084.0407-.2198.0277-.33-.0202-.1737-.114-.3265-.1996-.477-.6817-1.2056-.9025-2.6877-.6033-4.0528.099-.4518.2715-.9186.6318-1.1878.2046-.1536.452-.2293.6975-.2872.6156-.146 1.2512-.198 1.8812-.154l.33-1.1467c.054-.1864.108-.3773.0993-.572-.0212-.4554-.393-.8263-.8058-.9727-.412-.1463-.8604-.115-1.2947-.0823"
			}), o.a.createElement("path", {
				fill: "#F15A24",
				d: "M12.322 21.7194c.061.3407.127.693.3168.977.3034.4517.85.6324 1.3573.785.3797.1136.7785.2284 1.165.141.2643-.0598.5012-.2104.725-.3697.61-.433 1.1792-.9615 1.5326-1.6395.3962-.7593.4926-1.684.2625-2.5148-.0912-.3294-.2458-.6615-.524-.843-.2292-.1494-.5564-.2205-.6293-.4927-.1057-.3946-1.938-.4537-2.25-.4202-.474.051-.939.1728-1.2797.5403-.9068.9784-.8953 2.613-.676 3.8366M24.194 19.0418c.0644.3482.1334.708.3344.998.3193.462.8963.6468 1.431.8023.4005.1164.8212.234 1.2286.1447.2793-.0614.529-.2154.7647-.3776.644-.443 1.244-.983 1.617-1.6756.4174-.776.5195-1.7205.2768-2.5694-.0964-.3366-.2596-.6762-.5526-.8614-.242-.1528-.587-.2255-.664-.5037-.1117-.4033-2.0443-.464-2.3736-.4297-.4998.052-.9902.1766-1.3498.5523-.9564 1-.9442 2.67-.7126 3.9202"
			}), o.a.createElement("path", {
				fill: "#CCC",
				d: "M35.9408 20.9708c.222.0064.4462.0053.6533.066.4068.1196.9188.5786.945-.1845.007-.1902.012-.3904-.0708-.56-.122-.251-.5983-.9602-.824-1.087-.1087-.061-.236-.0694-.359-.073-.3063-.0092-.613.0014-.9182.0315-.9906.0986-.7374 1.4513.01 1.725.177.0647.3693.0764.5638.082"
			}), o.a.createElement("path", {
				fill: "#FF7BAC",
				d: "M37.8215 19.8532c-.0306.0467-.0694.0968-.123.099-.0946.0034-.1258-.128-.1816-.2085-.0644-.0938-.1824-.1258-.29-.1506-.4784-.112-1.163-.1415-1.5974-.3738-.4688-.251-.4095-.3117-.2434-.8975.178-.6268.4606-1.3722 1.071-1.6617 2.0532-.9728 2.1506 1.9814 1.3643 3.1932"
			}), o.a.createElement("path", {
				fill: "#FF0",
				d: "M30.808 32.959c.0077.0694.0343.1556.1004.1593-.0834-.0335-.1158.1122-.095.203.429.0508.8583.1012 1.2877.152.263.0313.5674.0482.752-.151.1304-.141.16-.3512.1825-.5462.032-.274.064-.548.0964-.822.0082-.0724.0135-.1552-.0336-.2086-.034-.0388-.087-.051-.137-.0588-.219-.0327-.446-.0064-.6532.075-.6713.2642-.6634-.6747-1.1966-.4688-.4516.1747-.346 1.279-.3035 1.6663"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M31.9858 34.3613c.3538.146.738.196 1.1182.2014 2.1213.03 4.1668-1.396 5.0646-3.4086.8978-2.0117.661-4.4994-.4998-6.3584-.514-.8238-1.3235-1.5857-2.2608-1.5168-.594.0433-1.1344.429-1.4745.9404-.3405.5112-.499 1.1347-.552 1.7558-.1233 1.4442.3143 2.9324 1.1923 4.053"
			}), o.a.createElement("path", {
				fill: "#F7E1CB",
				d: "M11.2195 30.4984l9.4083-2.7606 1.318 7.9058-7.4904 2.7607"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M12.7516 37.7683c.2136.2304.5864.1393.8525-.0207 1.096-.6588 1.5454-2.1516 1.337-3.4564-.108-.6758-.3805-1.3463-.877-1.792-.4966-.446-1.243-.6212-1.827-.3125-.402.212-.682.6167-.8776 1.041-.4437.9637-.5192 2.107-.206 3.1258.1683.548.462 1.0782.9255 1.388.4637.3095 1.1184.3464 1.543-.0195"
			}), o.a.createElement("g", null, o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M27.37 11.0563c-2.068-.6386-4.2747-.727-6.4318-.54-2.669.2313-5.8933.8336-7.6967 2.1168-.6986.4972-3.0193 1.2145-3.5257 3.1977"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M10.0543 14.9054c-1.561-.3985-3.317.0782-4.4594 1.2103-1.1422 1.132-1.726 2.906-1.237 4.4356.5752 1.8004 1.926 3.0712 2.306 3.275"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M10.0543 14.9054c-1.561-.3985-3.317.0782-4.4594 1.2103-1.1422 1.132-1.7258 2.906-1.237 4.4356.5756 1.8004 1.926 3.0712 2.306 3.275"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M11.823 29.9606c-2.7657-.9024-4.92-3.4455-5.3476-6.3126-.034-.2298.0103-.55.2428-.5677M33.1486 15.4973c.192.314.384.6286.576.9427.114.1872.2283.374.33.5677.5276 1.003.7084 2.182.5062 3.2958M35.8308 16.6844c-1.6376 4.9262-3.3644 9.8235-5.1785 14.688"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M35.671 17.0804c.2263-.288.586-.4587.9517-.4895.366-.0313.736.0692 1.0563.2483.2708.1508.515.364.6543.6404.1393.276.161.6202.0118.8913M38.3983 17.8874c-.6142 1.9982-1.3304 3.9652-2.145 5.891"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M37.245 21.08c.2485-.5347.1342-1.2158-.2747-1.641-.4093-.425-1.0872-.5678-1.6347-.3436-.1367.0562-.278.1512-.301.297"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M37.2275 21.501c.0044-.5535-.3094-1.0984-.791-1.374-.482-.2753-1.113-.2705-1.5904.012"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M34.2996 20.788c.7136-.389 1.6686-.2757 2.2706.269.2052.1856.376.4304.3964.706.006.0785-.0008.1578-.0196.2345M31.8127 33.921c.3626.1424.7564.1912 1.1458.1963 2.1737.0294 4.2697-1.3607 5.1896-3.3225.92-1.961.6773-4.386-.512-6.1982-.5268-.803-1.3562-1.5457-2.3166-1.4785-.6087.0423-1.1624.4184-1.511.9168-.3488.4983-.5113 1.106-.5655 1.7115-.1264 1.4077.322 2.8584 1.2216 3.9508M33.9912 29.3915l-1.467 4.0393M32.6352 33.0774c-.951.6286-1.8904 1.2738-2.8177 1.935"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M30.6496 31.0486l-.6455 4.1743c-.0058.0366-.0053.083.0385.099.044.0162.0833-.0547.0346-.0517"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M30.1422 33.367c.1982-.3278.4635-.6147.7748-.8386.078.1534.1257.3226.139.4943.287-.1218.5986-.183.9103-.1802-.3703.3692-.701.778-.9844 1.2173"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M31.195 33.0817c-.389.5013-.7464 1.0268-1.0695 1.5725.0302-.0257.0604-.0514.0902-.0775M30.7412 32.969c.0104.3634-.12.7275-.3766 1.0607M32.6658 33.0168c.1094-.676.1787-1.3585.2074-2.0422-.326.1956-.6525.3912-.979.5872-.1045.0627-.2386.1262-.3414.06-.063-.04-.091-.1166-.1135-.1874-.133-.4158-.2417-.8396-.3253-1.2682-.291.3247-.547.6807-.7626 1.0594"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M33.4372 28.176c-.177.4906-.354.9812-.5313 1.472-.285.7874-.5726 1.5822-1.0206 2.291M36.2456 21.1264c.048-.0176.0608-.0917.0218-.1244-.3043.6815-.5497 1.3883-.732 2.1112M30.4806 30.95c-.0843.2098-.1095.43-.074.6453M32.6366 25.235c-1.3602 1.8225-3.2855 3.1704-5.3524 4.1286-2.0672.958-4.284 1.55-6.5023 2.0763M30.348 27.747c.454.2455.8732.5552 1.24.9174M31.3832 34.1252c.6447 1.895.9225 3.913.8134 5.9105"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M20.2203 27.5033c.529 2.5225.9453 5.069 1.2474 7.6282.0048.042.0063.0925-.0276.1178-.0345.0253-.095-.029-.0603-.0536"
			}), o.a.createElement("path", {
				stroke: "#000",
				d: "M21.462 35.1753c-2.4317 1.1842-4.9882 2.113-7.614 2.7662-.0714.0177-.1587.031-.208-.023-.0494-.0544.038-.1667.0828-.1083",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), o.a.createElement("path", {
				stroke: "#000",
				d: "M13.3965 36.9094l.6482 1.51c-.01-.0428-.0207-.086-.0312-.129",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), o.a.createElement("path", {
				stroke: "#000",
				d: "M12.104 37.242c.219.2246.601.1358.8735-.0202 1.123-.6422 1.5835-2.0972 1.3698-3.369-.111-.659-.3898-1.3124-.8986-1.747-.5087-.4348-1.2736-.6054-1.872-.3045-.4118.2066-.6988.601-.8992 1.0147-.4546.9394-.532 2.054-.211 3.047.1723.5342.4733 1.051.9482 1.353.4753.3016 1.1462.3376 1.5813-.019M10.6766 30.3595c-.0715-.0158-.065.1064-.022.1655l.7927 1.0914c.011.0154.0276.0326.0457.0264.018-.006.0015-.0418-.01-.0268M10.6893 30.2222c3.1114-1.025 6.255-1.953 9.425-2.782.0814.1758.1628.352.2443.5274",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), o.a.createElement("path", {
				stroke: "#000",
				d: "M17.6433 28.0588c-.2222-.2202-.246-.6037-.5073-.7755-.2244-.148-.522-.0737-.7792.0048-1.0368.3175-2.073.6346-3.11.952-.2287.07-.4843.163-.579.382-.1275.2944.111.6096.332.843M13.849 27.877c-.025-.1897.085-.3783.2402-.4906.1554-.1123.349-.1592.5393-.1816.302-.0364.678.0275.7848.3115M17.774 36.8926c-.1595-.0286-.2392.1064-.234.201.068 1.193.0596 2.3876-.0247 3.5806M27.3276 14.627c-1.155-.254-2.4348.1776-3.1982 1.0778-.763.9005-.975 2.23-.5294 3.3214.203.498.537.9487.9825 1.252.757.5157 1.7714.556 2.64.263.9157-.3095 1.7137-.983 2.115-1.8592.401-.8763.3797-1.9464-.108-2.7783-.4875-.8312-1.447-1.3828-2.412-1.3303",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeWidth: ".5",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M15.604 17.5287c-.993-.5754-2.3376-.3743-3.2093.371-.872.745-1.2777 1.9505-1.1753 3.0903.038.4224.1422.845.359 1.2103.4368.7372 1.309 1.1618 2.168 1.1684.8592.007 1.6937-.3673 2.346-.924.2724-.2316.518-.497.7086-.799.465-.738.5666-1.6924.2675-2.511-.2992-.8188-.993-1.485-1.8255-1.7524"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M25.8734 23.061c.019.8443.036 1.706-.2144 2.513-.3128 1.0058-1.0497 1.8733-1.9936 2.347-.9442.4738-2.0827.547-3.0803.1982"
			}), o.a.createElement("path", {
				fill: "#000",
				d: "M24.826 27.045c-.909 1.0263-2.4282 1.5463-3.7262 1.098-.325-.1124-.682-.385-.5983-.7172-.305-.1123-.6554.132-.9616.024-.1132-.0405-.2045-.124-.2882-.21-.507-.519-.8602-1.1846-1.0054-1.894 1.3742.2257 2.797.237 4.147-.1035.6403-.1614 1.2614-.404 1.8365-.7284.2493-.1406 1.482-1.2717 1.6324-1.2287.3404.0972-.014 1.6884-.081 1.9398-.1798.6673-.4952 1.3003-.9554 1.82"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M24.826 27.045c-.909 1.0263-2.4282 1.5463-3.7262 1.098-.325-.1124-.682-.385-.5983-.7172-.305-.1123-.6554.132-.9616.024-.1132-.0405-.2045-.124-.2882-.21-.507-.519-.8602-1.1846-1.0054-1.894 1.3742.2257 2.797.237 4.147-.1035.6403-.1614 1.2614-.404 1.8365-.7284.2493-.1406 1.482-1.2717 1.6324-1.2287.3404.0972-.014 1.6884-.081 1.9398-.1798.6673-.4952 1.3003-.9554 1.82z"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M27.1593 11.0486c.356-.539.901-.9515 1.5182-1.148.3725-.1184.7656-.1595 1.157-.1632 1.2186-.011 2.452.3553 3.4137 1.1013.9616.7464 1.63 1.8822 1.7275 3.0925l.0405 1.2437c.0792.8083-.1735 1.644-.687 2.274-.0244.03-.0506.0716-.0296.1038.021.0323.0833-.0212.0465-.033"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M27.1593 11.0486c.356-.539.901-.9515 1.5182-1.148.3725-.1184.7656-.1595 1.157-.1632 1.2186-.011 2.452.3553 3.4137 1.1013.9616.7464 1.63 1.8822 1.7275 3.0925l.0405 1.2437c.0792.8083-.1735 1.644-.687 2.274-.0244.03-.0506.0716-.0296.1038.021.0323.0833-.0212.0465-.033M19.0092 10.923c-.1602-.079-.1772-.2954-.172-.4733.078-2.7703.1672-5.5993 1.1384-8.1964 1.835.0793 3.6632.3303 5.4515.7494"
			}), o.a.createElement("path", {
				fill: "#FFF",
				d: "M24.8624 3.1944c-.9362 1.032-.8485 2.7633.0626 3.8172.9108 1.0536 2.4758 1.4224 3.826 1.0687.64-.1677 1.2505-.4896 1.6915-.981 1.0054-1.121.9137-2.9152.1555-4.215-.237-.407-.534-.784-.9052-1.075-.72-.5643-1.7132-.7643-2.597-.5235-.883.241-1.6355.917-1.9667 1.768"
			}), o.a.createElement("path", {
				stroke: "#000",
				strokeLinecap: "round",
				strokeLinejoin: "round",
				d: "M24.8624 3.1944c-.9362 1.032-.8485 2.7633.0626 3.8172.9108 1.0536 2.4758 1.4224 3.826 1.0687.64-.1677 1.2505-.4896 1.6915-.981 1.0054-1.121.9137-2.9152.1555-4.215-.237-.407-.534-.784-.9052-1.075-.72-.5643-1.7132-.7643-2.597-.5235-.883.241-1.6355.917-1.9667 1.768"
			}))))
		},
		"./src/reddit/icons/svgs/SnooSilhouette/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 320 320",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "m124.91 237.79c-53.47 32.9-28.3 109.77-9.81 76.9"
			}), o.a.createElement("path", {
				d: "m115.13 314.7a9.86 9.86 0 0 1 -1.44 3l-.85 1.22c-.34.4-.68.85-1.09 1.28a11.46 11.46 0 0 1 -3 2.34 7.26 7.26 0 0 1 -4.16.82 8.13 8.13 0 0 1 -3.86-1.63 14 14 0 0 1 -2.64-2.62 26.58 26.58 0 0 1 -1.7-2.45c-3.11-5.09-4.59-11.37-5.16-17.65a66.18 66.18 0 0 1 6.12-33.55 69 69 0 0 1 3.7-6.66 68.22 68.22 0 0 1 4.3-5.93 62.51 62.51 0 0 1 9.65-9.4 61.54 61.54 0 0 1 9.62-6.13c-2.15 2.3-5.35 5.36-8.11 8.41s-5.19 6-6.61 7.42a56.91 56.91 0 0 0 -7.33 9.28 58.25 58.25 0 0 0 -5 10 60.67 60.67 0 0 0 -4 20 53 53 0 0 0 2.33 17.65 28.76 28.76 0 0 0 3.32 7.14c1.39 2 3.15 3.76 5.17 4.28a5.79 5.79 0 0 0 3.36-.19 11.09 11.09 0 0 0 3.45-2.14 29.87 29.87 0 0 0 3.93-4.49z"
			}), o.a.createElement("path", {
				d: "m194.69 240.89c45.74 25.85 23.37 107.54 4.1 73.8"
			}), o.a.createElement("path", {
				d: "m198.81 314.67a17 17 0 0 1 2 2.41 16.1 16.1 0 0 0 4.54 4.16 6.1 6.1 0 0 0 3.23.79 5.88 5.88 0 0 0 3-1.15 12.67 12.67 0 0 0 3.58-4.37c2.39-4.65 3.64-10.3 4.24-16a71.58 71.58 0 0 0 -.3-17 66.16 66.16 0 0 0 -9-25.89 54.68 54.68 0 0 0 -15.7-16.28 30.16 30.16 0 0 1 10.19 5 29.29 29.29 0 0 1 7.11 7.13 68.35 68.35 0 0 1 8.62 21.25 81.56 81.56 0 0 1 2 19.91 58.88 58.88 0 0 1 -2.83 17.4 27.36 27.36 0 0 1 -3.67 7.28 13.8 13.8 0 0 1 -2.85 2.86 7.81 7.81 0 0 1 -3.8 1.51 6.82 6.82 0 0 1 -4.21-1 11.92 11.92 0 0 1 -3.25-3 24.69 24.69 0 0 1 -2.9-5.01z"
			}), o.a.createElement("path", {
				d: "m125.46 236.86c32.07-45.32 77.78-13.73 79.92 56.7-.5 46.56-23 35.27-51.14 35.27s-42.05 9.17-44.66-24.83c-1.5-19.46-.66-20.87 3.28-33"
			}), o.a.createElement("path", {
				d: "m112.89 271a23.38 23.38 0 0 1 -.68 2.76c-.41 1.47-1 3.44-1.61 5.81a38.08 38.08 0 0 0 -1.14 8.22c-.12 3.08.07 6.43.29 9.9.51 6.92 1 14.41 3.16 20.71a16.43 16.43 0 0 0 4.9 7.54 13.56 13.56 0 0 0 6.7 2.65 56.37 56.37 0 0 0 11.6-.1c4-.32 8-.71 12.18-.92a124.9 124.9 0 0 1 12.55-.09c4.2.16 8.4.49 12.56.7 2.08.1 4.15.18 6.2.15a40.17 40.17 0 0 0 6.05-.44 22.51 22.51 0 0 0 5.6-1.55 14.89 14.89 0 0 0 4.6-3.17 17.38 17.38 0 0 0 3.27-4.6l.33-.64.29-.67.56-1.34c.3-.93.65-1.84.9-2.79a62.06 62.06 0 0 0 1.9-11.66 108.3 108.3 0 0 0 -.63-20.6 130.55 130.55 0 0 0 -3.86-20 94.18 94.18 0 0 0 -7.15-18.4 59.18 59.18 0 0 0 -11-15.23c-4.38-4.24-9.48-7.58-15-9a27.57 27.57 0 0 0 -16.33.49 39.21 39.21 0 0 0 -13.41 7.9 74.8 74.8 0 0 0 -9.76 10.58 61.55 61.55 0 0 1 8.78-11.74 39.25 39.25 0 0 1 14.45-9.6 31.64 31.64 0 0 1 8.59-1.83h2.12a13 13 0 0 1 2.08.09 28.29 28.29 0 0 1 3.93.63 31.93 31.93 0 0 1 11.28 5.06 50.46 50.46 0 0 1 12 12.46 74.93 74.93 0 0 1 7.89 14.59 117.86 117.86 0 0 1 7.81 30.35c.15 1.25.31 2.5.46 3.75s.22 2.49.32 3.73c.26 2.48.3 5 .43 7.41a34.56 34.56 0 0 1 0 3.67c0 1.22-.07 2.44-.16 3.64s-.14 2.41-.28 3.6-.23 2.38-.43 3.56-.34 2.36-.6 3.52-.51 2.32-.82 3.46a16.49 16.49 0 0 1 -.52 1.69c-.19.56-.36 1.12-.57 1.68a32.08 32.08 0 0 1 -1.48 3.21 19.92 19.92 0 0 1 -4.28 5.58 18.29 18.29 0 0 1 -6 3.5 37.52 37.52 0 0 1 -13.18 1.66c-4.33-.07-8.53-.42-12.65-.67s-8.17-.43-12.14-.36-7.88.29-11.73.58-7.66.61-11.47.63a34.51 34.51 0 0 1 -5.73-.4 17.16 17.16 0 0 1 -5.52-1.82 13.8 13.8 0 0 1 -4.34-3.84 19.11 19.11 0 0 1 -2.64-4.9 44.16 44.16 0 0 1 -2.39-10.24c-.44-3.22-.63-7-.81-11a93.65 93.65 0 0 1 .09-12 37.54 37.54 0 0 1 .92-5.5c.42-1.71.94-3.25 1.4-4.62.96-2.66 1.74-4.74 2.12-5.74z"
			}), o.a.createElement("path", {
				d: "m229 74.81c-1 .47-5.78-2.28-11.24-5.44s-11.7-6.6-15.42-7.94c-3.26-1.22-6.62-2.41-10-3.36a43 43 0 0 0 -4.93-1.07 13.89 13.89 0 0 0 -4.19-.08 3.6 3.6 0 0 0 -1.2.4c-.13.08-.17.17-.27.22s-.12.11-.14.24l-1 1.75c-.42.78-.91 1.53-1.29 2.34-.8 1.58-1.62 3.14-2.3 4.75s-1.34 3.2-2 4.78c-4.19 11.17-6.17 23.06-7.52 34.18s-2.05 21.46-3.05 29.85a36 36 0 0 1 -3.83-6.41 58 58 0 0 1 -2.89-7.72c-1.5-5.24-2.06-10.33-1.53-13a266.73 266.73 0 0 1 7.37-29.3 114.2 114.2 0 0 1 10.81-24.11l.39-.67.2-.33.09-.17.16-.2a8.58 8.58 0 0 1 1.33-1.56l.78-.69.86-.53a9.4 9.4 0 0 1 1.8-.83 15.64 15.64 0 0 1 6.86-.52 44.74 44.74 0 0 1 11.26 3.14 87 87 0 0 1 17.63 9.78c4.93 3.27 11.92 10.94 13.26 12.5z"
			}), o.a.createElement("path", {
				d: "m105.63 128c-43.28-20.15-74.18 36.54-30.75 61.74"
			}), o.a.createElement("path", {
				d: "m74.86 189.75c-.5 0-4.4-2-8.31-5.22-.94-.85-2-1.65-2.88-2.59s-1.82-1.86-2.61-2.82-1.51-1.9-2.15-2.77-1.13-1.7-1.57-2.38a32.77 32.77 0 0 1 -5-17.32 36.58 36.58 0 0 1 1.3-9.37c.22-.76.5-1.49.74-2.24l.39-1.1.47-1.07c.33-.7.62-1.42 1-2.11s.76-1.33 1.13-2a34 34 0 0 1 24.86-16.35 36.14 36.14 0 0 1 13.32.9 42.71 42.71 0 0 1 10.39 4.17c-3.08-.41-7.27-1.42-11.25-1.59a81.76 81.76 0 0 0 -9.48-.06 29.42 29.42 0 0 0 -11 2.08 30.48 30.48 0 0 0 -9.21 5.75 31.36 31.36 0 0 0 -8.27 34 38.69 38.69 0 0 0 7.82 12.76 66.35 66.35 0 0 0 5.7 5.64 36 36 0 0 0 2.84 2.34z"
			}), o.a.createElement("path", {
				d: "m254.61 176.52c30.45-26.89-2.76-71.55-39.71-54.67"
			}), o.a.createElement("path", {
				d: "m214.89 121.83a9.6 9.6 0 0 1 2.48-1.41 20.3 20.3 0 0 1 2.51-1l1.47-.51c.5-.18 1.05-.27 1.59-.42a28.32 28.32 0 0 1 3.37-.69 28.71 28.71 0 0 1 3.38-.39 46.61 46.61 0 0 1 5.63 0 34.21 34.21 0 0 1 15.32 4.6l1.79 1.09c.59.37 1.13.81 1.7 1.22a35.6 35.6 0 0 1 8.53 8.92 32.62 32.62 0 0 1 5.34 12.84 30.43 30.43 0 0 1 -.56 13.24 31.13 31.13 0 0 1 -5.33 10.68 36.88 36.88 0 0 1 -7.12 7c1.37-2.44 3.58-5.54 5.05-8.73.43-.76.7-1.59 1-2.31.16-.38.35-.73.49-1.09l.38-1c.24-.68.53-1.28.72-1.84a13.79 13.79 0 0 1 .52-1.42 26.43 26.43 0 0 0 .49-19 31.61 31.61 0 0 0 -4.13-8 35.33 35.33 0 0 0 -5.79-6.19c-.52-.45-1.08-.83-1.62-1.24a15 15 0 0 0 -1.64-1.14l-1.68-1-1.72-.88-.85-.44c-.28-.13-.58-.24-.87-.36l-1.73-.71c-.58-.21-1.17-.37-1.74-.56a17.9 17.9 0 0 0 -1.73-.5 40.08 40.08 0 0 0 -13.23-.93c-.49.06-1 .1-1.6.14l-1.76.27c-.6.09-1.23.15-1.84.26l-1.81.39c-.59.13-1.17.22-1.7.37l-1.46.41z"
			}), o.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z"
			}), o.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z",
				fill: "none"
			}), o.a.createElement("path", {
				d: "m159.25 111.2a100.82 100.82 0 0 1 14.86.32 130.39 130.39 0 0 1 30.18 6.06 97.07 97.07 0 0 1 16.43 7.17 78.93 78.93 0 0 1 14.49 10.25 63.78 63.78 0 0 1 16.79 23.82 67.61 67.61 0 0 1 4.45 19.57c.13 1.7.15 3.4.22 5.11v3.89l-.11 1.3-.22 2.61-.42 2.6a23.2 23.2 0 0 1 -.54 2.58c-.22.85-.37 1.72-.67 2.56a49.79 49.79 0 0 1 -4.15 9.79 56.7 56.7 0 0 1 -6.2 8.74 68 68 0 0 1 -7.75 7.43 78.42 78.42 0 0 1 -8.81 6.14c-12.32 7.38-26.19 11.74-40.07 14.24a168.29 168.29 0 0 1 -41.54 2.05 148 148 0 0 1 -34.89-6.69c-11.22-3.67-22-9-31-16.58a56.52 56.52 0 0 1 -11.6-13.16 48.93 48.93 0 0 1 -6.51-16.08 50.29 50.29 0 0 1 -.46-17 66.24 66.24 0 0 1 4.18-16 70.76 70.76 0 0 1 18.09-25.69 90.75 90.75 0 0 1 24.8-15.93 101.47 101.47 0 0 1 13.06-4.78 112.2 112.2 0 0 1 12.93-3c2.12-.41 4.24-.65 6.32-1s4.15-.47 6.2-.57c4.08-.33 8.06-.33 11.91-.29a142.44 142.44 0 0 0 -24.22 3.34 117.79 117.79 0 0 0 -26.52 9.42 92.75 92.75 0 0 0 -21.58 14.9 77.13 77.13 0 0 0 -12.25 14.6 62.07 62.07 0 0 0 -9.53 25.39 45.71 45.71 0 0 0 3.46 25.86 53.67 53.67 0 0 0 16.28 19.83 87.52 87.52 0 0 0 22.14 12.14 129.68 129.68 0 0 0 23.75 6.56 160.17 160.17 0 0 0 23.78 2.47 157.94 157.94 0 0 0 45.17-5.1 113.68 113.68 0 0 0 20.3-7.54 86.22 86.22 0 0 0 9.16-5.19 73.68 73.68 0 0 0 8.22-6.24 52.36 52.36 0 0 0 12.26-15.71l.56-1.09.48-1.13c.3-.76.64-1.5.92-2.26a44.84 44.84 0 0 0 1.41-4.63 46.94 46.94 0 0 0 1.37-9.46c0-1.59.08-3.16 0-4.75s-.07-3.17-.26-4.72l-.21-2.34c-.09-.77-.23-1.54-.34-2.3s-.22-1.54-.37-2.3l-.49-2.25a58.73 58.73 0 0 0 -6.56-16.8 63.59 63.59 0 0 0 -10.77-13.72 74.79 74.79 0 0 0 -13.46-10.24 100.84 100.84 0 0 0 -16.3-7.81 122.86 122.86 0 0 0 -19-5.41 160 160 0 0 0 -27.37-2.98z"
			}), o.a.createElement("circle", {
				cx: "238.47",
				cy: "80.13",
				r: "22.93"
			}), o.a.createElement("path", {
				d: "m261.37 80.13a5.12 5.12 0 0 1 -.27-1.29c-.06-.34-.08-.75-.17-1.2s-.19-1-.3-1.5a23.88 23.88 0 0 0 -3.12-7.61 22.56 22.56 0 0 0 -6.59-6.71 20 20 0 0 0 -7.06-2.93 22.12 22.12 0 0 0 -19.67 5.49 21.36 21.36 0 0 0 -5.7 9 20.88 20.88 0 0 0 -.7 10.29 21.16 21.16 0 0 0 9.47 14.18 21.55 21.55 0 0 0 16.06 2.92 21.77 21.77 0 0 0 12.8-8.08 23.8 23.8 0 0 0 3.39-6.16 26 26 0 0 0 1.32-6.35 19.06 19.06 0 0 1 .12 6.81 21.83 21.83 0 0 1 -8.21 13.51 18.67 18.67 0 0 1 -5.13 2.82 24.34 24.34 0 0 1 -8.2 1.31 24.84 24.84 0 0 1 -7.83-1.26 25.86 25.86 0 0 1 -6.77-3.5 25 25 0 0 1 -5.2-5.16 23.4 23.4 0 0 1 -3.35-6.21 25 25 0 0 1 -1-3.32c-.13-.56-.18-1.12-.28-1.68l-.12-.84c0-.28 0-.56-.05-.84 0-.56 0-1.12-.07-1.68s.05-1.11.08-1.66a11.26 11.26 0 0 1 .17-1.64c.09-.54.15-1.09.26-1.62a25.58 25.58 0 0 1 2.15-6 24.56 24.56 0 0 1 5.71-7.24c.37-.34.79-.62 1.18-.93a11.19 11.19 0 0 1 1.21-.87 23.57 23.57 0 0 1 21.4-2.45 23 23 0 0 1 8.39 5.48 22 22 0 0 1 6.08 14.14c.11 1.26 0 2.29 0 2.78z"
			})))
		},
		"./src/reddit/icons/svgs/Tag/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				style: e.style,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("g", null, o.a.createElement("path", {
				fill: "inherit",
				d: "M5.14293863,3.38188919 C5.75317178,3.99212234 5.75317178,4.98136473 5.14293863,5.59159788 C4.53270548,6.20183104 3.54346309,6.20183104 2.93322994,5.59159788 C2.32299679,4.98136473 2.32299679,3.99212234 2.93322994,3.38188919 C3.54346309,2.77165604 4.53270548,2.77165604 5.14293863,3.38188919 Z M1.01449569,2.94595786 L1,9.03662212 C1.00035355,9.55457784 1.19162594,10.0654625 1.55790725,10.4317438 L9.89929239,18.7731289 C10.6622606,19.5360972 11.8989904,19.5360972 12.661605,18.7734825 L18.7381272,12.6969604 C19.5007418,11.9343457 19.5007418,10.697616 18.7377736,9.93464773 L10.3963885,1.59326259 C10.0301071,1.22698128 9.54786032,1.00707107 9.02955105,1.00707107 L2.96045355,1 C1.8814086,1 1.01414214,1.86726647 1.01449569,2.94595786 Z"
			})))
		},
		"./src/reddit/icons/svgs/Text/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("g", {
				fill: "inherit"
			}, o.a.createElement("path", {
				d: "M15.6498441,5.62718315 L4.38195636,5.62718315 C4.0364078,5.62718315 3.75596259,5.34673795 3.75596259,5.00118939 C3.75596259,4.65564083 4.0364078,4.37519562 4.38195636,4.37519562 L15.6498441,4.37519562 C15.9953927,4.37519562 16.2758379,4.65564083 16.2758379,5.00118939 C16.2758379,5.34673795 15.9953927,5.62718315 15.6498441,5.62718315 M15.6498441,9.38314574 L4.38195636,9.38314574 C4.0364078,9.38314574 3.75596259,9.10270054 3.75596259,8.75715198 C3.75596259,8.41160342 4.0364078,8.13115821 4.38195636,8.13115821 L15.6498441,8.13115821 C15.9953927,8.13115821 16.2758379,8.41160342 16.2758379,8.75715198 C16.2758379,9.10270054 15.9953927,9.38314574 15.6498441,9.38314574 M13.1458691,13.1391083 L4.38195636,13.1391083 C4.0364078,13.1391083 3.75596259,12.8586631 3.75596259,12.5131146 C3.75596259,12.167566 4.0364078,11.8871208 4.38195636,11.8871208 L13.1458691,11.8871208 C13.4914176,11.8871208 13.7718628,12.167566 13.7718628,12.5131146 C13.7718628,12.8586631 13.4914176,13.1391083 13.1458691,13.1391083 M17.6104566,0.000751192518 L2.42134388,0.000751192518 C1.08547319,0.000751192518 0,1.08622438 0,2.42084309 L0,17.5811601 C0,18.4174878 0.423171785,19.1837041 1.13054474,19.6306637 C1.52116485,19.8748012 1.96061247,20 2.410076,20 C2.77440437,20 3.14624466,19.9173688 3.49805316,19.7470985 L7.81490616,17.5210647 L17.5278254,17.5210647 C18.8611921,17.5210647 20.0318005,16.3504563 20.0318005,15.0170896 L20.0318005,2.42084309 C20.0318005,1.08622438 18.9463273,0.000751192518 17.6104566,0.000751192518"
			})))
		},
		"./src/reddit/icons/svgs/TextPost/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_13NhOjx-Siom7MKe3Dex5y"
			}
		},
		"./src/reddit/icons/svgs/TextPost/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/TextPost/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				fill: "inherit",
				fillRule: "evenodd",
				d: "M16.8656 7.205H13.139c-.3428 0-.621-.2782-.621-.621 0-.343.2782-.621.621-.621h3.7266c.343 0 .621.278.621.621 0 .3428-.278.621-.621.621zm0 3.416H13.139c-.3428 0-.621-.2782-.621-.621s.2782-.621.621-.621h3.7266c.343 0 .621.2782.621.621s-.278.621-.621.621zm0 3.416H3.2016c-.343 0-.621-.278-.621-.621 0-.3428.278-.621.621-.621h13.664c.343 0 .621.2782.621.621 0 .343-.278.621-.621.621zm-13.664 3.416c-.343 0-.621-.278-.621-.621 0-.3428.278-.621.621-.621h13.664c.343 0 .621.2782.621.621 0 .343-.278.621-.621.621H3.2016zm-.621-14.285c0-.343.278-.621.621-.621h6.5997c.343 0 .621.278.621.621V10c0 .3428-.278.621-.621.621H3.2016c-.343 0-.621-.2782-.621-.621V3.168zM1.3382.0625C.6513.0625.096.6178.096 1.3047v17.3906c0 .687.5554 1.2422 1.2423 1.2422H18.729c.6868 0 1.242-.5553 1.242-1.2422V1.3047c0-.687-.5552-1.2422-1.242-1.2422H1.3382z"
			}))
		},
		"./src/reddit/icons/svgs/ThumbnailSelect/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_3QNLLzw_kUPhkWkxg22tT9"
			}
		},
		"./src/reddit/icons/svgs/ThumbnailSelect/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/ThumbnailSelect/index.m.less"),
				a = n.n(i);
			t.a = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, o.a.createElement("path", {
				d: "M0 0h20v20H0z"
			}), o.a.createElement("path", {
				fill: "#A5A4A4",
				d: "M6 3h8c1.1046 0 2 .8954 2 2v10c0 1.1046-.8954 2-2 2H6c-1.1046 0-2-.8954-2-2V5c0-1.1046.8954-2 2-2zm11 1c1.1046 0 2 .8954 2 2v8c0 1.1046-.8954 2-2 2V4zM3 4v12h-.6667C1.597 16 1 15.1734 1 14.1538V5.8462C1 4.8266 1.597 4 2.3333 4H3z"
			})))
		},
		"./src/reddit/icons/svgs/Tile/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("g", null, o.a.createElement("rect", {
				stroke: "inherit",
				fill: "none",
				x: "1.5",
				y: "1.5",
				width: "17",
				height: "17",
				rx: "4"
			}), o.a.createElement("rect", {
				fill: "inherit",
				stroke: "none",
				x: "4",
				y: "4",
				width: "5.5",
				height: "5.5"
			}), o.a.createElement("rect", {
				fill: "inherit",
				stroke: "none",
				x: "10.5",
				y: "4",
				width: "5.5",
				height: "5.5"
			}), o.a.createElement("rect", {
				fill: "inherit",
				stroke: "none",
				x: "4",
				y: "10",
				width: "5.5",
				height: "5.5"
			}), o.a.createElement("rect", {
				fill: "inherit",
				stroke: "none",
				x: "10.5",
				y: "10",
				width: "5.5",
				height: "5.5"
			})))
		},
		"./src/reddit/icons/svgs/TopAwarded/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 24 24",
				fill: "none",
				xmlns: "http://www.w3.org/2000/svg"
			}, o.a.createElement("path", {
				d: "M22.5 22.866h-21a1.5 1.5 0 01-1.5-1.5v-7.329c0-.59.34-1.1.835-1.345v-7.23a1.5 1.5 0 011.5-1.5h4.943v-1.65a1.5 1.5 0 011.5-1.5h6.444a1.5 1.5 0 011.5 1.5v4.363h4.943a1.5 1.5 0 011.5 1.5v4.517c.495.245.835.755.835 1.345v7.329a1.5 1.5 0 01-1.5 1.5z",
				fill: "#000"
			}), o.a.createElement("path", {
				d: "M22.5 18.971h-21v2.395h21V18.97z",
				fill: "#FFD635"
			}), o.a.createElement("path", {
				d: "M22.5 14.037h-21v5.119h21v-5.119z",
				fill: "#FF8717"
			}), o.a.createElement("path", {
				d: "M21.665 14.66v3.178h-6.443V12.85h6.443v1.812zM8.779 10.136v7.702H2.335v-7.702H8.78z",
				fill: "#FFD635"
			}), o.a.createElement("path", {
				d: "M15.222 17.838v.348H8.779V6.987h6.443v10.852z",
				fill: "#FFD635"
			}), o.a.createElement("path", {
				d: "M16.244 12.85h-1.022v4.988h1.022V12.85zM8.779 10.136H7.756v7.702H8.78v-7.702z",
				fill: "#FEB331"
			}), o.a.createElement("path", {
				d: "M15.734 12.85h-.512v4.988h.512V12.85zM8.78 10.136h-.512v7.702h.512v-7.702z",
				fill: "#F76B0B"
			}), o.a.createElement("path", {
				d: "M21.665 8.175h-6.443v4.674h6.443V8.175zM8.779 5.462H2.335v4.674H8.78V5.462z",
				fill: "#FF8717"
			}), o.a.createElement("path", {
				d: "M15.222 2.313H8.779v4.674h6.443V2.312z",
				fill: "#FF8717"
			}), o.a.createElement("path", {
				d: "M16.244 8.175h-1.022v4.674h1.022V8.175zM8.779 5.462H7.756v4.674H8.78V5.462z",
				fill: "#DB5003"
			}), o.a.createElement("path", {
				d: "M11.752 11.577h-.063l-1.143.772v-1.038l1.206-.822h1.206v4.742h-1.206v-3.654zM5.326 12.403c.916 0 1.462.496 1.462 1.174 0 .469-.208.779-.84 1.349l-.778.705v.052h1.665v.784H3.826v-.672l1.415-1.28c.489-.447.57-.617.57-.85 0-.275-.191-.502-.537-.502-.367 0-.584.25-.584.592H3.77c0-.804.633-1.352 1.557-1.352zM18.267 15.477h.412c.272 0 .448-.159.448-.39 0-.218-.167-.379-.443-.379-.29 0-.466.154-.479.415h-.744c.011-.617.5-1.025 1.263-1.025.753 0 1.165.394 1.162.873 0 .388-.25.644-.6.726v.042c.462.065.73.352.73.775 0 .575-.548.971-1.321.971-.764 0-1.283-.412-1.312-1.044h.78c.01.247.211.4.52.4.3 0 .502-.162.502-.405 0-.253-.192-.407-.506-.407h-.412v-.552z",
				fill: "#FFF1B6"
			}), o.a.createElement("path", {
				d: "M11.752 11.13h-.063l-1.143.771v-1.038l1.206-.822h1.206v4.742h-1.206V11.13zM5.326 11.955c.916 0 1.462.496 1.462 1.174 0 .469-.208.779-.84 1.349l-.778.705v.052h1.665v.784H3.826v-.672l1.415-1.28c.489-.447.57-.617.57-.85 0-.275-.191-.503-.537-.503-.367 0-.584.25-.584.593H3.77c0-.804.633-1.352 1.557-1.352zM18.267 15.029h.412c.272 0 .448-.159.448-.39 0-.218-.167-.379-.443-.379-.29 0-.466.154-.479.415h-.744c.011-.617.5-1.025 1.263-1.025.753 0 1.165.394 1.162.873 0 .388-.25.644-.6.726v.042c.462.065.73.352.73.775 0 .575-.548.971-1.321.971-.764 0-1.283-.412-1.312-1.044h.78c.01.247.211.4.52.4.3 0 .502-.162.502-.405 0-.253-.192-.407-.506-.407h-.412v-.552z",
				fill: "#000"
			}), o.a.createElement("path", {
				d: "M15.222 6.08H8.779v.907h6.443V6.08zM22.5 19.156h-21v.907h21v-.907zM21.665 12.866h-5.931l.51-.907h5.421v.907zM8.268 10.136H2.336v-.907h5.42l.512.907z",
				fill: "#FFFCD9"
			}))
		},
		"./src/reddit/icons/svgs/Trash2/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1Fa4RPHlhrfUZuNaXK2-eP"
			}
		},
		"./src/reddit/icons/svgs/Trash2/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Trash2/index.m.less"),
				a = n.n(i);
			const c = e => o.a.createElement("svg", {
				className: Object(r.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, o.a.createElement("path", {
				d: "M16.5,2H12.71l-.85-.85A.5.5,0,0,0,11.5,1h-3a.5.5,0,0,0-.35.15L7.29,2H3.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5h13a.5.5,0,0,0,.5-.5v-1A.5.5,0,0,0,16.5,2Z"
			}), o.a.createElement("path", {
				d: "M16.5,5H3.5a.5.5,0,0,0-.5.5v12A1.5,1.5,0,0,0,4.5,19h11A1.5,1.5,0,0,0,17,17.5V5.5A.5.5,0,0,0,16.5,5ZM6.75,15.5a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Z"
			}));
			t.b = c
		},
		"./src/reddit/icons/svgs/Video/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s);
			t.a = e => o.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, o.a.createElement("g", {
				transform: "translate(3, 4)"
			}, o.a.createElement("path", {
				d: "M15.4927,2.1514 C15.1797,1.9734 14.7947,1.9784 14.4857,2.1644 L11.9997,3.6554 L11.9997,2.0004 C11.9997,0.8974 11.1027,0.0004 9.9997,0.0004 L1.9997,0.0004 C0.8967,0.0004 -0.0003,0.8974 -0.0003,2.0004 L-0.0003,10.0004 C-0.0003,11.1034 0.8967,12.0004 1.9997,12.0004 L9.9997,12.0004 C11.1027,12.0004 11.9997,11.1034 11.9997,10.0004 L11.9997,8.3664 L14.4907,9.8394 C14.6477,9.9324 14.8237,9.9784 14.9997,9.9784 C15.1707,9.9784 15.3417,9.9344 15.4957,9.8474 C15.8077,9.6694 15.9997,9.3384 15.9997,8.9784 L15.9997,3.0214 C15.9997,2.6614 15.8057,2.3284 15.4927,2.1514"
			})))
		},
		"./src/reddit/layout/page/Listing/Content.m.less": function(e, t, n) {
			e.exports = {
				styledContent: "_1OVBBWLtHoSPfGCRaPzpTf",
				mCanFlexFullWidth: "PaJBYLqPf_Gie2aZntVQ7",
				mLargePostLayout: "_3nSp9cdBpqL13CqjdMr2L_",
				mDisableFullScreen: "_2udhMC-jldHp_EpAuBeSR1",
				mClassicWidth: "_1Tc65kRFm7a8piCXHVL4L4",
				mIsEditing: "_25-JsrYQ-pXWBM8eqpxeN7"
			}
		},
		"./src/reddit/layout/page/Listing/Content.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/constants/postLayout.ts"),
				l = n("./src/reddit/contexts/PageLayer/index.tsx"),
				d = n("./src/reddit/selectors/structuredStyles.ts"),
				u = n("./src/reddit/layout/page/Listing/Content.m.less"),
				p = n.n(u);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var h = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const b = Object(l.t)(),
				f = Object(i.c)({
					isEditing: d.j,
					layout: (e, t) => t.forcedLayout || Object(l.N)(e, t)
				}),
				g = Object(r.b)(f),
				x = e => {
					var {
						disableFullscreen: t,
						dispatch: n,
						fitPageToContent: s,
						forcedLayout: r,
						isCollectionLayout: i,
						isEditing: a,
						layout: c,
						pageLayer: l
					} = e, d = h(e, ["disableFullscreen", "dispatch", "fitPageToContent", "forcedLayout", "isCollectionLayout", "isEditing", "layout", "pageLayer"]);
					return o.a.createElement("div", d)
				};
			t.a = b(g(e => {
				var {
					className: t
				} = e, n = h(e, ["className"]);
				return o.a.createElement(x, m({
					className: Object(a.a)(t, p.a.styledContent, {
						[p.a.mLargePostLayout]: n.layout === c.g.Large,
						[p.a.mDisableFullScreen]: n.disableFullscreen && !n.isCollectionLayout,
						[p.a.mClassicWidth]: n.isCollectionLayout,
						[p.a.mIsEditing]: !!n.isEditing,
						[p.a.mCanFlexFullWidth]: !n.fitPageToContent
					})
				}, n))
			}))
		},
		"./src/reddit/layout/page/Listing/index.m.less": function(e, t, n) {
			e.exports = {
				Body: "_1vyLCp-v-tE5QvZovwrASa",
				body: "_1vyLCp-v-tE5QvZovwrASa",
				Sidebar: "_1BFbVxT49QnrAN3fqGZ1z8",
				sidebar: "_1BFbVxT49QnrAN3fqGZ1z8",
				defaultLayout: "_1tvThPWQpORoc2taKebHxs",
				"m-collectionLayout": "K1OCXipJxqOt01sOdQXEx",
				mCollectionLayout: "K1OCXipJxqOt01sOdQXEx",
				outerContainer: "qYj03fU5CXf5t2Fc5iSvg",
				innerContainer: "_3ozFtOe6WpJEMUtxDOIvtU",
				bannerNavContainer: "q4a8asWOWdfdniAbgNhMh",
				backgroundContainer: "_33erTQ46yfKeF2B6B-ooMJ"
			}
		},
		"./src/reddit/layout/page/Listing/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/es6.symbol.js");
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/reddit/layout/page/Listing/Content.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/constants/componentSizes.ts"),
				d = n("./src/reddit/constants/elementClassNames.ts"),
				u = n("./src/reddit/constants/screenWidths.ts"),
				p = n("./src/reddit/models/Theme/index.ts"),
				m = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				h = n("./src/reddit/connectors/connectClickToToggleEditor.ts");
			class b extends o.a.Component {
				constructor() {
					super(...arguments), this.onClickCapture = e => {
						this.props.isEditing && this.props.subredditId && !this.props.isModalOpen && (e.stopPropagation(), e.preventDefault(), this.props.requestCloseBlade())
					}
				}
				render() {
					return o.a.createElement("div", {
						className: this.props.className,
						onClickCapture: this.onClickCapture,
						children: this.props.children
					})
				}
			}
			var f = Object(h.a)(b);
			var g = e => o.a.createElement(f, e),
				x = n("./src/reddit/layout/page/Listing/index.m.less"),
				y = n.n(x);

			function v() {
				return (v = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var C = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			const E = Object(a.a)(e => {
					const {
						backgroundColor: t,
						className: n,
						redditStyle: s,
						theme: r
					} = e, a = C(e, ["backgroundColor", "className", "redditStyle", "theme"]), c = Object(m.a)(e), l = {
						"--pseudo-before-background": t || Object(p.g)(c.canvas, c.canvasImgUrl, c.canvasImgPosition)
					};
					return o.a.createElement("div", v({
						className: Object(i.a)(y.a.backgroundContainer, n),
						style: l
					}, a))
				}),
				O = c.a.div("Body", y.a),
				j = c.a.div("Sidebar", y.a),
				w = e => e.hero ? o.a.createElement(o.a.Fragment, null, e.hero) : null;

			function S(e) {
				const t = e.trendingUnit ? "28px" : "0",
					n = e.isPageSwapped ? {
						marginRight: "".concat(l.q, "px"),
						marginTop: t
					} : {
						marginLeft: "".concat(l.q, "px"),
						marginTop: t
					},
					s = e.sidebar && o.a.createElement(j, {
						className: e.isCollectionLayout ? y.a["m-collectionLayout"] : y.a.defaultLayout,
						style: n
					}, e.sidebar),
					a = o.a.createElement(r.a, {
						className: e.contentClassName,
						disableFullscreen: e.disableFullscreen,
						fitPageToContent: e.fitPageToContent,
						forcedLayout: e.forcedLayout,
						isCollectionLayout: e.isCollectionLayout
					}, e.contentBanner, e.content);
				let c;
				c = e.sidebars ? o.a.createElement(o.a.Fragment, null, e.sidebars[0], a, e.sidebars[1]) : e.isPageSwapped ? o.a.createElement(o.a.Fragment, null, s, a) : o.a.createElement(o.a.Fragment, null, a, s);
				const p = e.disableFullscreen ? "".concat(e.maxWidth || u.a + 2 * l.m, "px") : "100%";
				return o.a.createElement(g, {
					subredditId: e.subredditId
				}, o.a.createElement("div", {
					className: Object(i.a)(y.a.outerContainer, d.i, e.className),
					ref: e.containerRef
				}, o.a.createElement(E, {
					className: d.h,
					redditStyle: e.redditStyle,
					backgroundColor: e.backgroundColor
				}), o.a.createElement("div", {
					className: y.a.innerContainer
				}, o.a.createElement("div", {
					className: y.a.bannerNavContainer
				}, e.navBar), e.contentNavBar, w(e), o.a.createElement("div", {
					style: {
						maxWidth: p
					}
				}, e.trendingUnit), o.a.createElement(O, {
					style: {
						maxWidth: p
					}
				}, c))))
			}
		},
		"./src/reddit/layout/row/Inline/index.m.less": function(e, t, n) {
			e.exports = {
				inlineRow: "XZK-LTFT5CgGo9MvPQQsy"
			}
		},
		"./src/reddit/layout/row/Inline/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/layout/row/Inline/index.m.less"),
				r = n.n(o);
			t.a = s.a.div("inlineRow", r.a)
		},
		"./src/reddit/layout/row/InlineButton/index.m.less": function(e, t, n) {
			e.exports = {
				inlineButton: "_10K5i7NW6qcm-UoCtpB3aK"
			}
		},
		"./src/reddit/layout/row/InlineButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/layout/row/InlineButton/index.m.less"),
				r = n.n(o);
			t.a = s.a.button("inlineButton", r.a)
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, n) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				o = n("./src/reddit/layout/row/RightAlign/index.m.less"),
				r = n.n(o);
			t.a = s.a.div("rightAligned", r.a)
		},
		"./src/reddit/layout/threeCol/ExpandCenter/index.m.less": function(e, t, n) {
			e.exports = {
				leftAndRight: "_3P6gMBKOhtWWrytWm-8hc",
				center: "CEs01bewsmQQV7LRLaHib",
				expandedCenterContainer: "_2FZY7HXlkf-PdemHbQoAEt"
			}
		},
		"./src/reddit/layout/threeCol/ExpandCenter/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/threeCol/ExpandCenter/index.m.less"),
				c = n.n(a);
			t.a = Object(r.a)(e => o.a.createElement("div", {
				className: Object(i.a)(c.a.expandedCenterContainer, e.className)
			}, o.a.createElement("div", {
				className: c.a.leftAndRight,
				style: {
					flexBasis: e.widthLeft
				}
			}, Array.isArray(e.children) && e.children[0]), o.a.createElement("div", {
				className: c.a.center
			}, Array.isArray(e.children) && e.children[1]), o.a.createElement("div", {
				className: c.a.leftAndRight,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[2])), 3)
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_5gAwSCo7K8G413IoE78Ml",
				right: "_2ghjBMFIsORwdO3oh2Kq6g",
				exapndLeftContainer: "_1zTJo0Ndih4fp__5DjbClN"
			}
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/twoCol/ExpandLeft/index.m.less"),
				c = n.n(a);
			t.a = Object(r.a)(e => o.a.createElement("div", {
				className: Object(i.a)(c.a.exapndLeftContainer, e.className)
			}, o.a.createElement("div", {
				className: c.a.left
			}, Array.isArray(e.children) && e.children[0]), o.a.createElement("div", {
				className: c.a.right,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[1])), 2)
		},
		"./src/reddit/models/Gold/TopAwarded/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Active = "ACTIVE", e.Inactive = "INACTIVE"
				}(s || (s = {}))
		},
		"./src/reddit/models/Payments/index.ts": function(e, t, n) {
			"use strict";
			var s, o, r;
			n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.PayPal = "paypal", e.Stripe = "stripe"
				}(s || (s = {})),
				function(e) {
					e.NewPayPal = "new-paypal", e.NewStripe = "new-stripe", e.SavedPayPal = "saved-paypal", e.SavedStripe = "saved-stripe"
				}(o || (o = {})),
				function(e) {
					e.Comment = "comment", e.Post = "post", e.Profile = "profile", e.Subreddit = "subreddit"
				}(r || (r = {}))
		},
		"./src/reddit/models/Product/index.ts": function(e, t, n) {
			"use strict";
			var s;

			function o(e) {
				return e.substring(e.lastIndexOf("|") + 1)
			}
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return o
				})),
				function(e) {
					e.Badge = "badge", e.EmotesPack = "emotes_pack", e.Giphy = "giphy", e.Membership = "membership"
				}(s || (s = {}))
		},
		"./src/reddit/pages/ErrorPages/index.m.less": function(e, t, n) {
			e.exports = {
				primaryRouterLink: "WPSTJCepGLEWZl2fETrUM",
				container: "_3pfk0xbr5atzL7KT8pXEZG",
				title: "_3uo9iClHghoc_hoxzdgipi"
			}
		},
		"./src/reddit/pages/ErrorPages/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				r = n.n(o),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/pages/ErrorPages/index.m.less"),
				c = n.n(a);
			const l = e => {
					let {
						message: t
					} = e;
					return r.a.createElement("div", {
						className: c.a.container
					}, r.a.createElement("h3", {
						className: c.a.title
					}, t || s.fbt._("Sorry, there doesn't seem to be anything here.", null, {
						hk: "3VvHek"
					})), r.a.createElement(i.h, {
						className: c.a.primaryRouterLink,
						to: "/"
					}, s.fbt._("Go Home", null, {
						hk: "3E9E1g"
					})))
				},
				d = e => {
					let {
						message: t
					} = e;
					return r.a.createElement("div", {
						className: c.a.container
					}, r.a.createElement("h3", {
						className: c.a.title
					}, t || s.fbt._("Sorry, You do not have permission to view this page.", null, {
						hk: "4lRbHD"
					})), r.a.createElement(i.h, {
						className: c.a.primaryRouterLink,
						to: "/"
					}, s.fbt._("Go Home", null, {
						hk: "3E9E1g"
					})))
				}
		},
		"./src/reddit/pages/PostCreation/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/react/index.js"),
				o = n.n(s),
				r = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/postCreation/general.ts"),
				c = n("./src/reddit/components/JumpToContent/index.tsx"),
				l = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./node_modules/lodash/once.js"),
				u = n.n(d),
				p = n("./node_modules/react-router-redux/es/index.js"),
				m = n("./src/lib/constants/index.ts"),
				h = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/models/PostCreationForm/index.ts"),
				g = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				x = n("./src/reddit/pages/ErrorPages/index.tsx"),
				y = n("./src/reddit/components/CrosspostBox/index.tsx"),
				v = n("./src/reddit/components/RequestPendingBanner/index.tsx"),
				C = n("./src/reddit/components/RichTextEditor/media/helpers.ts"),
				E = n("./src/reddit/contexts/PageLayer/index.tsx"),
				O = n("./src/reddit/helpers/trackers/postComposer.ts"),
				j = n("./src/reddit/selectors/platform.ts"),
				w = n("./src/reddit/selectors/postCreations.ts"),
				S = n("./src/reddit/selectors/postDraft.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/selectors/user.ts"),
				T = n("./src/reddit/actions/changeUsername.ts"),
				I = n("./src/reddit/actions/externalAccount.ts"),
				P = n("./src/reddit/actions/postCreation/mediaUpload.ts"),
				M = (n("./node_modules/core-js/modules/es6.regexp.replace.js"), n("./src/lib/makeActionCreator/index.ts")),
				N = n("./src/telemetry/index.ts"),
				R = n("./src/reddit/actions/governance/index.ts"),
				L = n("./src/reddit/actions/page.ts"),
				A = n("./src/reddit/actions/pages/subreddit.ts"),
				F = n("./src/reddit/actions/postDraft.ts"),
				D = n("./src/reddit/actions/scheduledPosts/index.ts"),
				B = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				U = n("./src/config.ts"),
				K = n("./src/lib/convertToCamelCase/index.ts"),
				H = n("./src/lib/makeApiRequest/index.ts"),
				V = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				W = n("./src/lib/omitHeaders/index.ts"),
				z = n("./src/reddit/constants/headers.ts"),
				q = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				G = n("./src/reddit/helpers/flair.ts"),
				J = n("./src/reddit/helpers/name/index.ts"),
				Q = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				Z = n("./src/reddit/models/Post/index.ts"),
				Y = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const X = e => {
					switch (e.kind) {
						case f.o.CROSSPOST:
							return f.o.CROSSPOST;
						case f.o.LINK:
							return f.o.LINK;
						case f.o.POLL:
							return f.o.POLL;
						case f.o.MEDIA:
							return e.makeGif ? f.o.VIDEO_GIF : e.mediaType;
						default:
							return "self"
					}
				},
				$ = e => {
					const t = Object(J.f)(e.destSubreddit.name);
					return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
						sr: t,
						api_type: "json",
						show_error_list: !0,
						draft_id: e.draftId || void 0,
						title: e.title,
						discussion_type: e.isChatPost ? Z.b.Chat : void 0,
						spoiler: e.isSpoiler,
						nsfw: e.isNSFW
					}, e.kind !== f.o.POLL ? Object.assign({
						kind: X(e),
						original_content: e.isOC
					}, e.destSubreddit.isProfile ? {
						sr: "u_".concat(t),
						submit_type: "profile"
					} : {
						sr: t,
						submit_type: "subreddit"
					}) : {}), {
						post_to_twitter: e.postToTwitter,
						sendreplies: e.sendReplies
					}), e.gRecaptchaResponse ? {
						"g-recaptcha-response": e.gRecaptchaResponse
					} : {}), {
						resubmit: e.resubmit
					}), (e => {
						switch (e.kind) {
							case f.o.RICH_TEXT:
								return {
									richtext_json: JSON.stringify({
										document: e.document
									})
								};
							case f.o.MARKDOWN:
								return {
									text: e.markdown
								};
							case f.o.LINK:
							case f.o.MEDIA:
								return {
									url: e.url
								};
							case f.o.CROSSPOST:
								return {
									crosspost_fullname: e.sourcePostId
								};
							case f.o.POLL:
								return {
									duration: Math.floor(e.poll.duration / 864e5), options: e.poll.options.map(e => e.text), text: e.markdown, raw_rtjson: "markdown" in e ? null : JSON.stringify({
										document: e.document
									})
								}
						}
					})(e)), e.kind === f.o.MEDIA && "video" === e.mediaType ? {
						video_poster_url: e.videoThumbnailUrl
					} : {}), e.kind === f.o.MEDIA && e.makeGif ? {
						make_gif: "on"
					} : {}), e.flair ? {
						flair_id: e.flair.templateId,
						flair_text: Object(G.g)(e.flair)
					} : {}), e.validate_on_submit ? {
						validate_on_submit: e.validate_on_submit
					} : {}), e.eventSchedule && {
						event_start: e.eventSchedule.startDate,
						event_end: e.eventSchedule.endDate,
						event_tz: e.eventSchedule.timezoneName,
						unlist: e.eventSchedule.submitTime === f.i.AtEventTime
					}), e.collectionId && {
						collection_id: e.collectionId
					})
				},
				ee = async (e, t) => {
					if (!e.ok) return Object(Q.b)(e);
					const n = e.body.json.data;
					let s = n.url;
					s || t.kind !== f.o.MEDIA || (s = await ((e, t) => new Promise(n => {
						const s = new WebSocket(e),
							o = e => {
								s.close(), clearTimeout(r), n(e)
							},
							r = setTimeout(() => {
								o("")
							}, t);
						s.onmessage = e => {
							const t = JSON.parse(e.data),
								n = "success" === t.type ? t.payload.redirect : "";
							o(n)
						}, s.onerror = e => {
							o("")
						}
					}))(n.websocket_url, 3e4));
					const o = n.id || (e => {
							const t = /comments\/(\w+)\/.*$/.exec(e),
								n = t && t[1];
							return n ? "".concat(m.yb.Post, "_").concat(n) : ""
						})(s),
						r = Object(V.parse)(s).path,
						i = n.drafts_count;
					return Object.assign(Object.assign({}, e), {
						body: {
							id: o,
							path: r,
							draftsCount: i
						}
					})
				};
			var te = (e, t) => Object(H.a)(Object(W.a)(e, [z.a]), {
				endpoint: Object(Y.a)(Object(q.a)("".concat(e.apiUrl, "/api/submit?resubmit=true"))),
				method: m.db.POST,
				data: $(t)
			}).then(async e => await ee(e, t));
			var ne = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				se = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				oe = n("./src/reddit/featureFlags/index.ts"),
				re = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				ie = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				ae = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				ce = n("./src/reddit/models/Poll/index.ts"),
				le = n("./src/reddit/models/User/index.ts"),
				de = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				ue = n("./src/reddit/models/ScheduledPost/index.ts"),
				pe = n("./src/reddit/actions/postCreation/constants.ts");
			const me = Object(M.a)(pe.A),
				he = Object(M.a)(pe.P),
				be = Object(M.a)(pe.r),
				fe = Object(M.a)(pe.C),
				ge = Object(M.a)(pe.bb),
				xe = Object(M.a)(pe.J),
				ye = Object(M.a)(pe.a),
				ve = Object(M.a)(pe.F),
				Ce = e => "/r/".concat(e, "/about/").concat(ue.q),
				Ee = (e, t) => {
					const n = e || {
							duration: m.x,
							options: []
						},
						{
							govType: s,
							newSubreddit: o,
							newTopMod: r
						} = Object(w.s)(t),
						i = Object.assign({}, n);
					return s && (i.type = s), i.type === ce.a.ReplaceTopMod ? (i.params = {
						userName: r
					}, i.options = ce.f[ce.a.ReplaceTopMod]()) : i.type === ce.a.Spinoff ? (i.params = {
						subreddit: o
					}, i.options = ce.f[ce.a.Spinoff](o)) : i.options = i.options.map(e => ({
						text: e.text.trim()
					})).filter(e => !!e.text), i
				},
				Oe = e => {
					const t = e.uploads,
						n = Object(w.O)(e),
						s = Object(w.a)(e),
						o = Object(w.Z)(e);
					if (s === m.Jb.POST) return B.a.getPendingThumbnailUploads(o, t);
					if (s === m.Jb.MEDIA && n && n.items.length) {
						const {
							video: e
						} = n.items[0];
						if (e && e.thumbnail && !t[f.m]) return [Object.assign(Object.assign({}, e.thumbnail), {
							uploadKey: f.m
						})]
					}
				},
				je = e => async (t, n, s) => {
					let {
						gqlContext: o
					} = s;
					const r = n(),
						i = Object(w.W)(r),
						a = Object(w.X)(r, e),
						c = Object(w.g)(r),
						l = Object(de.r)(r);
					if (!(a && c.id && i && Object(ie.f)(l))) return;
					const d = c.id,
						u = Object(de.a)(r, {
							subredditId: d,
							scheduledPostId: l
						});
					if (u && Object(N.a)(Object(ae.v)(u)(r)), t(me(a)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(w.u)(n()))) return;
					const {
						isPoll: p,
						polls: m
					} = Object(w.s)(r), h = Ee(m, r), b = Object.assign({}, Object(ne.e)({
						poll: p ? h : void 0,
						submission: a,
						schedule: i,
						subredditId: c.id,
						scheduledPostId: l
					})), f = await Object(se.a)(o(), b);
					if (f.ok) return t(Object(D.e)({
						subredditId: c.id
					})), void t(Object(L.G)(Ce(c.name), !1));
					const g = f.error;
					t(be(g))
				}, we = e => async (t, n, s) => {
					let {
						gqlContext: o
					} = s;
					const r = n(),
						i = Object(w.W)(r),
						a = Object(w.X)(r, e),
						c = Object(w.g)(r),
						l = Object(de.b)(r);
					if (!a || !c.id || !i) return;
					if (t(me(a)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(w.u)(n()))) return;
					const {
						isPoll: d,
						polls: u
					} = Object(w.s)(r), p = Ee(u, r), m = Object.assign(Object.assign({}, Object(ne.d)({
						poll: d ? p : void 0,
						submission: a,
						schedule: i,
						subredditId: c.id
					})), {
						creationToken: l
					}), h = await Object(ne.a)(o(), m);
					if (h.ok) {
						t(Object(D.e)({
							subredditId: c.id
						}));
						const e = h.body.data.createScheduledPost.scheduledPost;
						return e && Object(N.a)(Object(ae.s)(Object(re.d)(e))(r)), void t(Object(L.G)(Ce(c.name), !1))
					}
					const b = h.error;
					t(be(b))
				}, Se = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const r = n(),
						i = Object(w.X)(r, e),
						{
							isPoll: c,
							polls: l
						} = Object(w.s)(r),
						d = Ee(l, r);
					if (!i) return;
					if (t(me(i)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(w.u)(n()))) return;
					let u;
					const p = c && oe.d.spPolls(r);
					if ((u = p ? await
							function(e, t, n) {
								const s = t.destSubreddit.id;
								return Object(H.a)(e, {
									method: m.db.POST,
									endpoint: "".concat(U.a.metaUrl, "/polls/").concat(s),
									type: "json",
									data: Object.assign({
										poll: n,
										subredditId: s
									}, Object(K.a)($(t)))
								}).then(async e => {
									const n = e.ok ? Object.assign(Object.assign({}, e), {
											body: {
												json: {
													data: e.body
												}
											}
										}) : e,
										s = await ee(n, t);
									if (s.ok) {
										const t = s.body;
										return {
											body: Object.assign(Object.assign({}, t), {
												poll: e.body.poll
											}),
											ok: !0,
											status: e.status
										}
									}
									return {
										error: s.body,
										ok: !1,
										status: e.status
									}
								})
							}(o(), i, d) : c ? await ((e, t) => Object(H.a)(Object(W.a)(e, [z.a]), {
								endpoint: Object(Y.a)(Object(q.a)("".concat(e.apiUrl, "/api/submit_poll_post.json?resubmit=true"))),
								method: m.db.POST,
								data: $(t),
								type: "json"
							}).then(e => ee(e, t)))(o(), Object.assign(Object.assign({}, i), {
								kind: f.o.POLL,
								poll: d
							})) : i.kind === f.o.GALLERY ? await ((e, t) => Object(H.a)(Object(W.a)(e, [z.a]), {
								endpoint: Object(Y.a)(Object(q.a)("".concat(e.apiUrl, "/api/submit_gallery_post.json?resubmit=true"))),
								method: m.db.POST,
								data: Object.assign(Object.assign({}, $(t)), {
									items: t.galleryItems.map(e => ({
										caption: e.caption,
										outbound_url: e.url,
										media_id: e.assetId
									}))
								}),
								type: "json"
							}).then(e => ee(e, t)))(o(), i) : await te(o(), i)).ok) {
						const e = Object(k.i)(r),
							n = u.body;
						t(he({
							draftId: i.draftId,
							response: n
						})), p && t(Object(R.c)({
							poll: n.poll
						}));
						const s = (n.path || "/user/".concat(Object(le.e)(e), "/posts")).replace(/^\/r\/u_/, "/user/");
						t(Object(A.j)(i.destSubreddit.name)), t(Object(L.G)(s, !1))
					} else {
						if (c) {
							const e = u.error;
							t(fe(e))
						}
						const e = u.error;
						e.type === m.E.BAD_CAPTCHA_ERROR ? t(ye()) : e.type === m.E.VALIDATION_ERROR ? t(ge(e)) : e.type === m.E.SUBMIT_VALIDATION_ERROR ? t(xe(e)) : t(be(e))
					}
					const h = Object(a.n)(i.kind),
						b = u.ok && u.body && u.body.id && Object(Z.m)(u.body.id),
						g = n();
					O.r(g, h, b)
				};
			var _e = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				ke = n("./src/reddit/actions/upload.ts"),
				Te = n("./src/reddit/helpers/externalAccount/index.tsx"),
				Ie = n("./node_modules/history/esm/history.js"),
				Pe = n("./node_modules/react-router/esm/react-router.js"),
				Me = n("./src/lib/matchRoute/index.ts"),
				Ne = n("./src/reddit/components/PostCreationForm/Prompt/PromptModal.tsx");
			const Re = "DISCARD_POST_ON_NAVIGATION_MODAL_ID",
				Le = Object(i.c)({
					isEditingScheduledPost: e => !!Object(de.r)(e),
					isScheduledPost: w.K
				});
			var Ae = Object(r.b)(Le)(e => {
					const {
						isEditingScheduledPost: t,
						isScheduledPost: n,
						onAbort: s,
						onDiscardConfirmed: r,
						onSaveDraft: i,
						submissionType: a
					} = e;
					return m.D.has(a) && !n ? o.a.createElement(Ne.a, {
						bodyText: l.fbt._("Do you want to save a draft of your post?", null, {
							hk: "3EV54t"
						}),
						onClose: s,
						onPrimaryAction: i,
						onSecondaryAction: r,
						primaryButtonText: l.fbt._("Save draft", null, {
							hk: "292J1G"
						}),
						secondaryButtonText: l.fbt._("Discard post", null, {
							hk: "1RpuOL"
						}),
						titleText: l.fbt._("Save draft", null, {
							hk: "44JnYT"
						})
					}) : o.a.createElement(Ne.a, {
						bodyText: t ? l.fbt._("Returning to the previous page will discard your changes", null, {
							hk: "2LlXOp"
						}) : l.fbt._("Returning to the previous page will discard your post", null, {
							hk: "3fT0mW"
						}),
						onClose: s,
						onPrimaryAction: s,
						onSecondaryAction: r,
						primaryButtonText: l.fbt._("Edit post", null, {
							hk: "1e3xR0"
						}),
						secondaryButtonText: t ? l.fbt._("Discard Changes", null, {
							hk: "7JOA"
						}) : l.fbt._("Discard Post", null, {
							hk: "1CBjtn"
						}),
						titleText: t ? l.fbt._("Discard Changes", null, {
							hk: "2vyCBa"
						}) : l.fbt._("Discard Post", null, {
							hk: "2BlkSe"
						})
					})
				}),
				Fe = n("./src/reddit/routes/postCreation/index.ts");
			const De = e => (e.returnValue = "", ""),
				Be = Object(i.c)({
					destSubreddit: w.g,
					hasError: w.t,
					havePostContent: w.y,
					isChanged: w.B,
					modalId: w.Q,
					submitPostPending: w.hb
				}),
				Ue = Object(r.b)(Be, e => ({
					onToggleDiscardModal: () => e(a.x(Re))
				}), (e, t, n) => Object.assign(Object.assign(Object.assign({}, e), t), n));
			class Ke extends o.a.Component {
				constructor() {
					super(...arguments), this.unblockNavigation = null, this.ensureBlocked = e => {
						e.isChanged && (e.havePostContent || e.destSubreddit.name) ? this.block(e) : this.unblock()
					}, this.block = e => {
						this.unblockNavigation || (window.addEventListener("beforeunload", De), this.unblockNavigation = e.history.block((e, t) => {
							if (!Object(Me.a)(Object(Ie.e)(e), [Fe.a])) return this.props.modalId !== Re && this.props.onToggleDiscardModal(), "Are you sure you want to leave?"
						}))
					}, this.unblock = () => {
						this.unblockNavigation && (this.unblockNavigation(), this.unblockNavigation = null), window.removeEventListener("beforeunload", De)
					}
				}
				componentDidMount() {
					this.ensureBlocked(this.props)
				}
				componentWillReceiveProps(e) {
					!this.props.submitPostPending || e.submitPostPending || e.hasError ? this.ensureBlocked(e) : this.unblock()
				}
				componentWillUnmount() {
					this.unblock()
				}
				render() {
					return null
				}
			}
			var He = Object(E.t)({
					draftId: E.u,
					pageLayer: e => e
				})(Ue(Object(Pe.i)(Ke))),
				Ve = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx"),
				We = n("./src/lib/classNames/index.ts"),
				ze = n("./src/lib/prettyPrintNumber/index.ts"),
				qe = n("./src/reddit/components/ContributorRequestFlow/ContributorRequestButton.tsx"),
				Ge = n("./src/reddit/components/Governance/Token/index.tsx"),
				Je = n("./src/reddit/components/ScheduledPost/PostSchedulePickerModal/loader.tsx"),
				Qe = n("./src/reddit/controls/ErrorText/index.tsx"),
				Ze = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				Ye = n("./src/reddit/icons/svgs/Clock/index.tsx"),
				Xe = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				$e = n("./src/reddit/layout/row/Inline/index.tsx"),
				et = n("./src/reddit/models/Media/index.ts"),
				tt = n("./src/reddit/models/Upload/index.ts"),
				nt = n("./src/reddit/selectors/activeModalId.ts"),
				st = n("./src/reddit/selectors/gov.ts"),
				ot = n("./src/reddit/selectors/moderatorPermissions.ts"),
				rt = n("./src/reddit/models/Duplicates/index.ts"),
				it = n("./src/reddit/selectors/posts.ts");
			var at = n("./src/reddit/controls/Button/index.tsx"),
				ct = n("./src/reddit/components/PostCreationForm/Button/index.m.less"),
				lt = n.n(ct),
				dt = n("./src/lib/lessComponent.tsx");
			const ut = dt.a.wrapped(at.f, "PrimaryButton", lt.a),
				pt = dt.a.wrapped(at.i, "SecondaryButton", lt.a);
			var mt = n("./src/lib/timezone/index.ts"),
				ht = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				bt = n("./src/reddit/components/PostCreationForm/PostCreationFooter/ScheduledTimeInfo/index.m.less"),
				ft = n.n(bt);
			const {
				fbt: gt
			} = n("./node_modules/fbt/lib/FbtPublic.js"), xt = dt.a.div("Container", ft.a), yt = Object(i.c)({
				eventSchedule: w.o,
				postSchedule: w.W
			});
			var vt = Object(r.b)(yt)(e => {
					const {
						eventSchedule: t,
						postSchedule: n
					} = e;
					let s;
					if (t && t.submitTime !== f.i.Now) s = (e => {
						const t = Object(mt.f)(e.startDate),
							n = t.toLocaleDateString(void 0, {
								month: "numeric",
								day: "numeric",
								year: "2-digit"
							}),
							s = t.toLocaleTimeString([], {
								hour: "numeric",
								minute: "numeric"
							}).replace(" ", "");
						let r = "".concat(n, " ").concat(s);
						const i = Object(mt.d)(e.timezoneName, +t);
						return i && (r += " ".concat(i.abbreviation)), o.a.createElement("span", null, gt._("Will automatically post at", null, {
							hk: "1ixr16"
						}), " ", o.a.createElement("time", {
							dateTime: e.startDate
						}, r))
					})(t);
					else {
						if (!n) return null;
						s = (e => {
							const t = Object(mt.f)(e.submitDate),
								n = t.toLocaleDateString(void 0, {
									month: "numeric",
									day: "numeric"
								}),
								s = t.toLocaleTimeString([], {
									hour: "numeric",
									minute: "numeric"
								}).replace(" ", "");
							let r = "".concat(n, " ").concat(s);
							const i = Object(mt.d)(e.timezoneName, +t);
							i && (r += " ".concat(i.abbreviation));
							const a = e.recurrenceInfo ? o.a.createElement("span", null, o.a.createElement(ht.a, {
								className: ft.a.replayIcon
							}), gt._("Recurring post template scheduled for", null, {
								hk: "2tTwIB"
							})) : gt._("Post scheduled for", null, {
								hk: "47yVoo"
							});
							return o.a.createElement("span", null, a, " ", o.a.createElement("time", {
								dateTime: e.submitDate
							}, r))
						})(n)
					}
					return o.a.createElement(xt, null, s)
				}),
				Ct = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				Et = n("./src/lib/linkMatchers/index.ts"),
				Ot = n("./src/reddit/contexts/PageLayer/selectors.ts");
			const jt = Object(M.a)(pe.K),
				wt = Object(M.a)(pe.L),
				St = (e, t) => async (n, s, o) => {
					let {
						apiContext: r
					} = o;
					const i = s(),
						a = Object(Ot.r)(i, {
							pageLayer: t
						});
					if (!a) return;
					const c = Object(w.q)(i, {
						field: e
					});
					if (!c) return;
					const d = Object(w.e)(i),
						u = await ((e, t, n, s, o) => Object(H.a)(Object(W.a)(e, [z.a]), {
							endpoint: "".concat(e.apiUrl, "/api/validate_submission_field"),
							method: m.db.POST,
							data: {
								sr: t,
								field: n,
								kind: s,
								title: o.title || "",
								url: o.url || null,
								text: o.selftext,
								richtext_json: o.rtjson && JSON.stringify({
									document: o.rtjson
								}),
								flair_id: o.flairId || null,
								show_error_list: !0
							}
						}).then(Q.b))(r(), a.name, e, d, c),
						p = u.error || function(e, t) {
							if (e === m.nb.LINK && !Object(Et.g)(Et.e, t.url || "")) return {
								fields: [{
									field: m.nb.LINK,
									msg: l.fbt._("Link doesn't look right", null, {
										hk: "11qrsa"
									})
								}],
								type: m.E.SUBMIT_VALIDATION_ERROR
							}
						}(e, c);
					p && p.fields && p.fields.length ? n(jt(p)) : n(wt(e)), u.error && n(xe(u.error))
				};
			var _t = n("./src/reddit/components/Flair/index.tsx"),
				kt = n("./src/reddit/controls/TextButton/index.tsx"),
				Tt = n("./src/reddit/controls/Typography/index.tsx"),
				It = n("./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/OCDisclaimer/index.m.less"),
				Pt = n.n(It);
			const {
				fbt: Mt
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Nt = dt.a.wrapped(kt.a, "DontShowButton", Pt.a);
			var Rt, Lt = dt.a.wrapped(e => {
					const {
						className: t,
						onDoNotShowClick: n
					} = e;
					return o.a.createElement("div", {
						className: t
					}, o.a.createElement(Tt.a, null, Mt._("Use the OC tag if you want to take credit for your post as Original Content.", null, {
						hk: "2D3GYX"
					})), o.a.createElement(Tt.a, null, o.a.createElement(Nt, {
						onClick: n
					}, Mt._("Cool, whatever, don't show me this again.", null, {
						hk: "4nvsEF"
					}))))
				}, "Component", Pt.a),
				At = n("./src/reddit/components/PostCreationForm/DivButton/index.tsx"),
				Ft = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				Dt = n("./src/reddit/constants/colors.ts");
			! function(e) {
				e.CHAT = "chat", e.FLAIR = "flair", e.GOVERNANCE = "gov", e.SPOILER = "spoiler", e.NSFW = "nsfw", e.ORIGINAL_CONTENT = "originalContent", e.SCHEDULE = "schedule"
			}(Rt || (Rt = {}));
			var Bt = n("./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/PostModifierButton/index.m.less"),
				Ut = n.n(Bt);
			const Kt = dt.a.div("TintOverlay", Ut.a),
				Ht = (e, t) => {
					switch (t) {
						case Rt.ORIGINAL_CONTENT:
							return {
								backgroundColor: Dt.a.orangered, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case Rt.CHAT:
							return {
								backgroundColor: Dt.a.chat, textColor: e.newCommunityTheme.lightText, iconColor: e.newCommunityTheme.lightText
							};
						case Rt.SPOILER:
							return {
								backgroundColor: Dt.a.spoiler, textColor: e.newCommunityTheme.lightText, iconColor: e.newCommunityTheme.lightText
							};
						case Rt.NSFW:
							return {
								backgroundColor: Dt.a.nsfw, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case Rt.FLAIR:
							return {
								backgroundColor: e.newCommunityTheme.flair, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case Rt.SCHEDULE:
							return {
								backgroundColor: e.newCommunityTheme.active, textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							};
						case Rt.GOVERNANCE:
							return {
								backgroundColor: e.newCommunityTheme.line, textColor: e.newCommunityTheme.bodyText, iconColor: e.newCommunityTheme.bodyText
							};
						default:
							return {
								backgroundColor: "none", textColor: e.newCommunityTheme.body, iconColor: e.newCommunityTheme.body
							}
					}
				},
				Vt = e => Object(Ct.a)(t => {
					const {
						addModifierTooltip: n,
						children: s,
						className: r,
						disabled: i,
						disabledTooltip: a,
						id: c,
						onClick: l,
						removeModifierTooltip: d,
						toggled: u,
						theme: p
					} = t, m = i && a ? a : u ? d : n, h = {
						color: t.textColor || p && Ht(p, e).textColor,
						fill: t.textColor || p && Ht(p, e).iconColor,
						backgroundColor: t.backgroundColor || p && Ht(p, e).backgroundColor
					};
					return o.a.createElement(At.a, {
						style: u ? h : {},
						"aria-label": m,
						className: Object(We.a)(r, Ut.a.PostModifierButton),
						disabled: i,
						id: c,
						onClick: l
					}, o.a.createElement(Ft.a, {
						text: m,
						className: Ut.a.HoverTooltip,
						tooltipContentClass: t.shiftTooltipToRight ? Ut.a.mShiftTooltipToTheRight : void 0
					}), o.a.createElement(Kt, {
						className: Object(We.a)(Ut.a.TintOverlay, {
							[Ut.a.isDisabled]: i
						})
					}, s))
				});
			var Wt = n("./src/reddit/constants/postCreation.ts"),
				zt = n("./src/reddit/icons/fonts/Calendar/index.tsx"),
				qt = n("./src/reddit/icons/fonts/helpers.tsx");
			var Gt = e => o.a.createElement("i", {
					className: Object(We.a)(Object(qt.b)("create"), e.className)
				}),
				Jt = n("./src/reddit/icons/fonts/Live/index.tsx"),
				Qt = n("./src/higherOrderComponents/asTooltip.tsx"),
				Zt = n("./src/reddit/components/PostCreationForm/EduTooltips/BaseEduTooltip/index.m.less"),
				Yt = n.n(Zt);
			const {
				fbt: Xt
			} = n("./node_modules/fbt/lib/FbtPublic.js"), $t = dt.a.div("Container", Yt.a), en = dt.a.div("OuterContainer", Yt.a);
			class tn extends o.a.Component {
				constructor() {
					super(...arguments), this.tooltipRef = null, this.onGotItClick = e => {
						this.close(!0), e.stopPropagation()
					}, this.onKeyDown = e => {
						e.keyCode === h.a.Escape && this.close(!1)
					}, this.onMouseClick = e => {
						this.tooltipRef && !this.tooltipRef.contains(e.target) && this.close(!1)
					}, this.onWindowResize = () => {
						this.close(!1)
					}, this.setTooltipRef = e => {
						this.tooltipRef = e
					}
				}
				componentDidMount() {
					document.addEventListener("keydown", this.onKeyDown), document.addEventListener("click", this.onMouseClick), window.addEventListener("resize", this.onWindowResize), this.tooltipRef && this.tooltipRef.scrollIntoView({
						behavior: "smooth",
						block: "end"
					})
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.onKeyDown), document.removeEventListener("click", this.onMouseClick), window.removeEventListener("resize", this.onWindowResize)
				}
				close(e) {
					this.props.onClose(e)
				}
				render() {
					const e = this.props;
					return o.a.createElement(en, {
						className: e.className,
						innerRef: this.setTooltipRef,
						style: e.style
					}, o.a.createElement($t, {
						className: Yt.a.container
					}, o.a.createElement("img", {
						src: e.heroImagePath,
						className: Yt.a.hero
					}), o.a.createElement("div", {
						className: Yt.a.contentContainer
					}, o.a.createElement("div", {
						className: Yt.a.title
					}, e.title), o.a.createElement("div", {
						className: Yt.a.description
					}, e.description), o.a.createElement("div", {
						className: Yt.a.iconsExplanations
					}, e.iconsExplanations.map((e, t) => {
						const n = e.iconComponent;
						return o.a.createElement("div", {
							className: Yt.a.iconExplanation,
							key: t
						}, o.a.createElement(n, {
							className: Yt.a.icon
						}), e.text)
					})), o.a.createElement(at.f, {
						className: Yt.a.gotIt,
						onClick: this.onGotItClick
					}, Xt._("Got it", null, {
						hk: "2RPumB"
					})))))
				}
			}
			var nn = Object(Qt.a)(tn),
				sn = (n("./node_modules/core-js/modules/es6.symbol.js"), n("./node_modules/lodash/debounce.js")),
				on = n.n(sn),
				rn = n("./src/reddit/actions/modal.ts"),
				an = n("./src/reddit/helpers/localStorage/index.ts"),
				cn = n("./src/reddit/helpers/trackers/postCollection.ts"),
				ln = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
					}
					return n
				};
			const dn = [{
					id: Wt.d,
					getShowTimesLeft: an.v,
					setShowTimesLeft: an.bb,
					tooltipShown: cn.n,
					tooltipDismissed: cn.m
				}, {
					id: Wt.c,
					getShowTimesLeft: an.u,
					setShowTimesLeft: an.ab,
					tooltipShown: cn.f,
					tooltipDismissed: cn.e
				}],
				un = {};
			let pn;
			const mn = () => (void 0 === pn && (pn = dn.filter(e => e.getShowTimesLeft() > 0).map(e => e.id)), pn),
				hn = e => {
					const t = mn().indexOf(e);
					t > -1 && mn().splice(t, 1)
				},
				bn = e => async (t, n) => {
					const s = dn.find(t => t.id === e);
					s && (fn(s, !0), Object(N.a)(s.tooltipDismissed(n())))
				}, fn = (e, t) => {
					e.setShowTimesLeft(t ? 0 : e.getShowTimesLeft() - 1)
				}, gn = () => async (e, t) => {
					const {
						activeModalId: n
					} = t(), s = mn().find(e => !!un[e]);
					if (!s || s === n) return;
					const o = dn.find(e => e.id === s);
					o && (Object(N.a)(o.tooltipShown(t())), fn(o)), e(rn.i(s))
				}, xn = on()(e => e(), 100);

			function yn(e, t) {
				const n = Object(i.c)({
					isOpen: e => Object(nt.a)(e) === t
				});
				class s extends o.a.Component {
					componentDidMount() {
						un[t] = !0, xn(this.props.onShowNextTooltip)
					}
					componentWillUnmount() {
						un[t] = !1, xn(this.props.onShowNextTooltip)
					}
					render() {
						const t = this.props,
							{
								isOpen: n
							} = t,
							s = ln(t, ["isOpen"]);
						return n ? o.a.createElement(e, s) : null
					}
				}
				return Object(r.b)(n, e => ({
					onCloseTooltip: n => {
						hn(t), n && e(bn(t)), e(rn.i(t)), e(gn())
					},
					onShowNextTooltip: () => e(gn())
				}))(s)
			}
			var vn = n("./src/reddit/components/PostCreationForm/EduTooltips/EventButtonTooltip/index.m.less"),
				Cn = n.n(vn);
			var En = yn(e => {
					const {
						onCloseTooltip: t
					} = e;
					return o.a.createElement(nn, {
						className: Cn.a.container,
						description: l.fbt._("Let your community know about discussion threads, AMA’s or even a game thread.", null, {
							hk: "4aMUL6"
						}),
						heroImagePath: "".concat(U.a.assetPath, "/img/events-tooltip-hero@2x.png"),
						iconsExplanations: [{
							iconComponent: Gt,
							text: l.fbt._("Compose a post like normal.", null, {
								hk: "so4h7"
							})
						}, {
							iconComponent: zt.a,
							text: l.fbt._("Schedule when the event is happening.", null, {
								hk: "2EoghL"
							})
						}, {
							iconComponent: Jt.a,
							text: l.fbt._("Remind your community when its live.", null, {
								hk: "2W4fY"
							})
						}],
						isOpen: !0,
						isOverlayOff: !0,
						onClose: t,
						title: l.fbt._("Make an Event", null, {
							hk: "4Bz0L3"
						}),
						tooltipId: Wt.a
					})
				}, Wt.d),
				On = n("./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx"),
				jn = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				wn = n("./src/reddit/constants/disclaimers.ts"),
				Sn = n("./src/reddit/helpers/trackers/postEvent.ts"),
				_n = n("./src/reddit/icons/svgs/Chat/index.tsx"),
				kn = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				Tn = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				In = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				Pn = n("./src/reddit/icons/svgs/Tag/index.tsx"),
				Mn = n("./src/reddit/models/Subreddit/index.ts"),
				Nn = n("./src/reddit/selectors/experiments/chatPost.ts");
			const Rn = e => e.creations.formState.fieldValidation;
			var Ln = n("./src/telemetry/models/PostComposer.ts"),
				An = n("./src/reddit/components/PostCreationForm/ControlRow/PostModifiers/index.m.less"),
				Fn = n.n(An);
			const Dn = "PostFlair--Modal--CreationForm",
				Bn = e => {
					let t = Object(mt.f)(e.startDate).toLocaleDateString(void 0, {
						month: "numeric",
						day: "numeric",
						hour: "numeric",
						minute: "numeric"
					});
					return t = t.replace(" ", "").replace(",", " ")
				},
				Un = dt.a.wrapped(Tn.b, "StyledCaretIcon", Fn.a),
				Kn = dt.a.wrapped(zt.a, "CalendarIcon", Fn.a),
				Hn = dt.a.wrapped(Xe.a, "PencilIcon", Fn.a),
				Vn = dt.a.wrapped(_n.a, "ChatIcon", Fn.a),
				Wn = dt.a.wrapped(kn.a, "CheckmarkIcon", Fn.a),
				zn = dt.a.wrapped(In.a, "PlusIcon", Fn.a),
				qn = dt.a.wrapped(_t.b, "FlairComponent", Fn.a),
				Gn = dt.a.wrapped(Pn.a, "FlairIcon", Fn.a),
				Jn = dt.a.div("FlairTextWrapper", Fn.a),
				Qn = dt.a.wrapped($e.a, "ModifierRow", Fn.a),
				Zn = Vt(Rt.ORIGINAL_CONTENT),
				Yn = Vt(Rt.CHAT),
				Xn = Vt(Rt.SPOILER),
				$n = Vt(Rt.NSFW),
				es = Vt(Rt.FLAIR),
				ts = Vt(Rt.SCHEDULE),
				ns = Object(E.t)({
					draftId: E.u,
					pageLayer: e => e
				}),
				ss = Object(i.c)({
					activeModalId: nt.a,
					canAddPostFlair: w.c,
					canPostAsModerator: w.d,
					currentSubredditId: E.m,
					destSubreddit: w.g,
					destSubredditAboutInfo: w.f,
					eventSchedule: w.o,
					extendedScheduledPostsEnabled: w.p,
					isChatPostAvailable: Nn.a,
					isChatPostSelected: w.C,
					isNsfw: w.H,
					isSpoiler: w.L,
					isOriginalContent: w.I,
					flair: w.r,
					postCreationFieldErrors: Rn,
					postSchedule: w.W,
					submissionType: w.a
				}),
				os = Object(r.b)(ss, (e, t) => {
					let {
						onPostFieldValidation: n,
						pageLayer: s
					} = t;
					return {
						doNotShowOriginalContentDisclaimerClicked: () => e((e, t) => O.d(t())),
						onEventScheduleChange: t => {
							e(a.a(t))
						},
						postFlairAdded: t => {
							e(a.b(t)), n(e(St(m.nb.FLAIR, s)))
						},
						toggleSchedulePicker: (t, n) => {
							e(a.x(f.f)), t && e((e, t) => {
								(n ? Sn.g : Sn.f)(t())
							})
						},
						toggleChatPostTag: t => {
							e(a.s(!t)), e((e, n) => O.y(n(), !t, Ln.ToggleNoun.CHAT))
						},
						toggleFlairPicker: () => e(a.x(Dn)),
						toggleNsfwTag: t => {
							e(a.t(!t)), e((e, n) => O.y(n(), !t, Ln.ToggleNoun.NSFW))
						},
						toggleOriginalContentTag: t => {
							e(a.u(!t)), e((e, n) => O.y(n(), !t, Ln.ToggleNoun.ORIGINAL_CONTENT))
						},
						toggleSpoilerTag: t => {
							e(a.w(!t)), e((e, n) => O.y(n(), !t, Ln.ToggleNoun.SPOILER))
						},
						sendChatPostExposureEvent: (t, n) => {
							e((e, s) => {
								const o = s(),
									r = Object(ot.g)(o, {
										subredditId: n
									});
								Object(Nn.g)(o, t, r)
							})
						}
					}
				});
			class rs extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						showOCDisclaimer: !1,
						fireHoldoutEvent: !1
					}, this.handlePostFlairSelected = e => {
						let {
							previewFlair: t
						} = e;
						this.props.flair !== t && this.props.postFlairAdded(t)
					}, this.handleOCDisclaimerDoNotShowClick = () => {
						const {
							doNotShowOriginalContentDisclaimerClicked: e
						} = this.props;
						e(), Object(an.O)(wn.b.ORIGINAL_CONTENT_DISCLAIMER, !0), this.setState({
							showOCDisclaimer: !1
						})
					}, this.handleOriginalContentClick = () => {
						this.props.toggleOriginalContentTag(this.props.isOriginalContent)
					}, this.handleChatPostClick = () => {
						this.props.toggleChatPostTag(this.props.isChatPostSelected)
					}, this.handleSpoilerClick = () => {
						this.props.toggleSpoilerTag(this.props.isSpoiler)
					}, this.handleNsfwClick = () => {
						this.props.toggleNsfwTag(this.props.isNsfw)
					}, this.handleToggleSchedulePicker = () => {
						const e = this.props.activeModalId !== f.f,
							t = !!this.props.eventSchedule;
						this.props.toggleSchedulePicker(e, t)
					}
				}
				componentDidMount() {
					this.setState({
						showOCDisclaimer: !Object(an.h)(wn.b.ORIGINAL_CONTENT_DISCLAIMER)
					}), this.sendChatPostExposureEvent()
				}
				componentDidUpdate(e) {
					let {
						currentSubredditId: t
					} = e;
					this.sendChatPostExposureEvent(t === this.props.currentSubredditId)
				}
				sendChatPostExposureEvent() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					const {
						fireHoldoutEvent: t
					} = this.state, {
						currentSubredditId: n,
						isChatPostAvailable: s,
						sendChatPostExposureEvent: o
					} = this.props;
					t || e || !n ? t && this.setState({
						fireHoldoutEvent: !1
					}) : (o(s, n), this.setState({
						fireHoldoutEvent: !0
					}))
				}
				render() {
					const {
						activeModalId: e,
						canAddPostFlair: t,
						canPostAsModerator: n,
						className: s,
						currentSubredditId: r,
						destSubreddit: i,
						destSubredditAboutInfo: a,
						eventSchedule: c,
						extendedScheduledPostsEnabled: d,
						disabled: u,
						flair: p,
						isChatPostAvailable: h,
						isChatPostSelected: b,
						isNsfw: g,
						isSpoiler: x,
						isOriginalContent: y,
						postCreationFieldErrors: v,
						postSchedule: C,
						submissionType: E,
						theme: O,
						toggleFlairPicker: j
					} = this.props, {
						showOCDisclaimer: w
					} = this.state, S = !!p, {
						backgroundColor: _ = null,
						textColor: k = null
					} = p || {}, {
						allOriginalContent: T = !1,
						eventPostsEnabled: I = !1
					} = a || {}, P = i.isProfile || Object(Mn.f)(a), M = u || !P || T || E === m.Jb.CROSSPOST, N = u || !!C && !d, R = u || !!C;
					return o.a.createElement("div", {
						className: s
					}, o.a.createElement(Qn, null, h && o.a.createElement(Yn, {
						disabled: N,
						onClick: this.handleChatPostClick,
						toggled: b,
						addModifierTooltip: l.fbt._("Use live chat instead of comments", null, {
							hk: "27t9lW"
						}),
						removeModifierTooltip: l.fbt._("Use comments instead of live chat", null, {
							hk: "3seokS"
						})
					}, b ? o.a.createElement(Wn, null) : o.a.createElement(Vn, {
						viewBox: "0 -5 20 30"
					}), l.fbt._("Live chat", null, {
						hk: "1WNjQ8"
					})), n && I && o.a.createElement(ts, {
						disabled: R,
						id: Wt.a,
						onClick: this.handleToggleSchedulePicker,
						shiftTooltipToRight: !0,
						toggled: !!c,
						addModifierTooltip: l.fbt._("Add time and date info", null, {
							hk: "L2KN8"
						}),
						removeModifierTooltip: l.fbt._("Edit event data", null, {
							hk: "1FSblM"
						})
					}, o.a.createElement(En, null), o.a.createElement(Kn, null), c ? Bn(c) : l.fbt._("Event", null, {
						hk: "40pq7b"
					}), c && o.a.createElement(Hn, null)), e === f.f && o.a.createElement(On.default, {
						schedule: this.props.eventSchedule,
						onClose: this.handleToggleSchedulePicker,
						onChange: this.props.onEventScheduleChange,
						shouldShowSubmitTime: !0,
						shouldShowDeleteButton: !0
					}), o.a.createElement(Zn, {
						disabled: M,
						onClick: this.handleOriginalContentClick,
						shiftTooltipToRight: !0,
						toggled: P && (y || T),
						addModifierTooltip: l.fbt._("Mark this post as Original Content [OC]", null, {
							hk: "3V5aHC"
						}),
						removeModifierTooltip: l.fbt._("Unmark this post as Original Content [OC]", null, {
							hk: "2oj9GI"
						}),
						disabledTooltip: P ? "" : l.fbt._("This community does not allow original content tag", null, {
							hk: "gBN3o"
						})
					}, y ? o.a.createElement(Wn, null) : o.a.createElement(zn, null), l.fbt._("OC", null, {
						hk: "2GRpRs"
					})), o.a.createElement(Xn, {
						disabled: u,
						onClick: this.handleSpoilerClick,
						toggled: x,
						addModifierTooltip: l.fbt._("Mark as a spoiler", null, {
							hk: "3ICynB"
						}),
						removeModifierTooltip: l.fbt._("Unmark as a spoiler", null, {
							hk: "34pmqg"
						})
					}, x ? o.a.createElement(Wn, null) : o.a.createElement(zn, null), l.fbt._("Spoiler", null, {
						hk: "1K7ROJ"
					})), o.a.createElement($n, {
						disabled: u,
						onClick: this.handleNsfwClick,
						toggled: g,
						addModifierTooltip: l.fbt._("Mark as Not Safe For Work", null, {
							hk: "1LNeZB"
						}),
						removeModifierTooltip: l.fbt._("Unmark Not Safe For Work", null, {
							hk: "1EcrjD"
						})
					}, g ? o.a.createElement(Wn, null) : o.a.createElement(zn, null), l.fbt._("NSFW", null, {
						hk: "3Tg62D"
					})), o.a.createElement(es, {
						className: Object(We.a)(Fn.a.AddFlair, {
							[Fn.a.isToggled]: S,
							[Fn.a.mHasError]: v[m.nb.FLAIR].length > 0
						}),
						disabled: !t || u,
						disabledTooltip: i.id ? l.fbt._("Not available for this community", null, {
							hk: "2gkbLI"
						}) : l.fbt._("Select a subreddit to enable flair", null, {
							hk: "1LNvTq"
						}),
						onClick: j,
						toggled: S,
						addModifierTooltip: l.fbt._("Add flair", null, {
							hk: "1RHLMM"
						}),
						removeModifierTooltip: l.fbt._("Change or remove flair", null, {
							hk: "34t9cQ"
						}),
						backgroundColor: _,
						textColor: k
					}, o.a.createElement(Gn, {
						className: Fn.a.FlairIcon,
						style: {
							"--flairColor": S ? Object(_t.c)(Object.assign(Object.assign({}, this.props), {
								backgroundColor: _,
								textColor: k
							})) : O.newCommunityTheme.actionIcon
						}
					}), p ? o.a.createElement(qn, {
						flair: p,
						forceSmallEmojis: !0
					}) : o.a.createElement(Jn, null, l.fbt._("Flair", null, {
						hk: "4Dtvp0"
					})), o.a.createElement(Un, {
						className: Fn.a.CaretIcon,
						style: {
							"--flairColor": S ? Object(_t.c)(Object.assign(Object.assign({}, this.props), {
								backgroundColor: _,
								textColor: k
							})) : O.newCommunityTheme.actionIcon
						}
					})), e === Dn && o.a.createElement(jn.a, {
						flairs: p ? [p] : [],
						modalId: Dn,
						onFlairChanged: this.handlePostFlairSelected,
						subredditId: r || ""
					})), o.a.createElement(Qe.a, {
						className: Fn.a.errorMessages,
						messages: v[m.nb.FLAIR]
					}), P && y && w && o.a.createElement(Lt, {
						onDoNotShowClick: this.handleOCDisclaimerDoNotShowClick
					}))
				}
			}
			var is = ns(Object(Ct.a)(os(rs)));
			var as = e => o.a.createElement("i", {
					className: Object(We.a)(Object(qt.b)("addCollection"), e.className)
				}),
				cs = n("./src/reddit/icons/fonts/Plus/index.tsx"),
				ls = n("./src/reddit/components/PostCreationForm/EduTooltips/CollectionButtonTooltip/index.m.less"),
				ds = n.n(ls);
			var us = yn(e => o.a.createElement(nn, {
					className: ds.a.container,
					description: l.fbt._("Create a series of scheduled events or just group random things. Make something awesome.", null, {
						hk: "40PwoH"
					}),
					heroImagePath: "".concat(U.a.assetPath, "/img/collection-tooltip-hero@2x.png"),
					iconsExplanations: [{
						iconComponent: Gt,
						text: l.fbt._("Compose a post like normal.", null, {
							hk: "466GER"
						})
					}, {
						iconComponent: as,
						text: l.fbt._("Create & name your collection.", null, {
							hk: "3BuZKz"
						})
					}, {
						iconComponent: cs.a,
						text: l.fbt._("Add more posts to your collection.", null, {
							hk: "2wzlHs"
						})
					}],
					isOpen: !0,
					isOverlayOff: !0,
					onClose: e.onCloseTooltip,
					title: l.fbt._("Create Collections!", null, {
						hk: "3tSmbj"
					}),
					tooltipId: Wt.g
				}), Wt.c),
				ps = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				ms = n("./src/reddit/components/PostCreationForm/ControlRow/ToggleDestCollectionButton/index.m.less"),
				hs = n.n(ms);
			const bs = dt.a.wrapped(At.a, "DivButton", hs.a);
			class fs extends o.a.Component {
				render() {
					const {
						disabled: e,
						isToggled: t
					} = this.props, n = t ? ps.b : as;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(bs, {
						className: Object(We.a)(hs.a.button, e ? hs.a.disabled : null),
						disabled: e,
						id: Wt.g,
						onClick: this.props.onClick
					}, o.a.createElement(n, {
						className: hs.a.icon
					}), o.a.createElement(Ft.a, {
						text: t ? l.fbt._("Cancel adding to collection", null, {
							hk: "359w09"
						}) : l.fbt._("Add to collection", null, {
							hk: "48nVCZ"
						})
					})), !t && o.a.createElement(us, null))
				}
			}
			var gs = fs,
				xs = n("./src/reddit/components/TrackingHelper/index.tsx"),
				ys = n("./src/reddit/components/PostCreationForm/ControlRow/index.m.less"),
				vs = n.n(ys);
			const Cs = () => l.fbt._("Post", null, {
					hk: "47QFCY"
				}),
				Es = () => l.fbt._("Cancel", null, {
					hk: "2TSLl5"
				}),
				Os = () => l.fbt._("Saved!", null, {
					hk: "34qXtS"
				}),
				js = () => l.fbt._("Save draft", null, {
					hk: "1xneFj"
				}),
				ws = () => l.fbt._("Updated!", null, {
					hk: "45fGGU"
				}),
				Ss = () => l.fbt._("Update draft", null, {
					hk: "1c8tCb"
				}),
				_s = () => l.fbt._("Please fix the above requirements", null, {
					hk: "17Yk98"
				}),
				ks = () => l.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4x2ypi"
				}),
				Ts = 10,
				Is = dt.a.wrapped($e.a, "Container", vs.a),
				Ps = (e, t) => {
					return (t ? [m.Jb.LINK_ONLY, m.Jb.POLL, m.Jb.POST] : [m.Jb.LINK_ONLY, m.Jb.POST]).includes(e)
				},
				Ms = dt.a.div("ButtonsAndErrors", vs.a),
				Ns = dt.a.wrapped($e.a, "ButtonRow", vs.a),
				Rs = dt.a.div("ButtonLayout", vs.a),
				Ls = dt.a.div("SaveDraftButtonLayout", vs.a),
				As = dt.a.wrapped(Ze.a, "PostLoadingIcon", vs.a),
				Fs = dt.a.wrapped(As, "DraftLoadingIcon", vs.a),
				Ds = dt.a.wrapped(Ge.a, "Token", vs.a),
				Bs = Object(i.a)(w.Z, B.a.getMediaCount),
				Us = (e, t) => {
					const n = Object(E.m)(e, t),
						s = !!Object(E.j)(e, t);
					return n ? e.creations.formData.isPoll && Object(st.i)(e, {
						subredditId: n
					}) : !s
				},
				Ks = [],
				Hs = e => {
					const t = Object(w.Z)(e),
						n = Object(w.fb)(e);
					if (!t.isBound || n !== m.Jb.POST || !Object(w.bb)(e)) return Ks;
					const s = (e => {
						const {
							allowedPostTypes: t,
							name: n
						} = Object(w.g)(e), s = Bs(e);
						if (!s || !t) return null;
						let o = "";
						return !s.total || t.images || t.videos ? s.video && !t.videos ? o = l.fbt._("Videos are not allowed in r/{subreddit name}", [l.fbt._param("subreddit name", n)], {
							hk: "1EUr31"
						}) : !s.image && !s.gifvideo || t.images || (o = l.fbt._("Images are not allowed in r/{subreddit name}", [l.fbt._param("subreddit name", n)], {
							hk: "2pxaRa"
						})) : o = l.fbt._("Videos and images are not allowed in r/{subreddit name}", [l.fbt._param("subreddit name", n)], {
							hk: "3AMcQ8"
						}), o || null
					})(e);
					return s ? [s] : (e => {
						const t = Bs(e);
						if (!t) return Ks;
						const n = [];
						return t.image > m.S && n.push(l.fbt._("Post may not contain more that 20 images", null, {
							hk: "1Szc36"
						})), t.video + t.gifvideo > m.W && n.push(l.fbt._("Post may not contain more that 5 videos", null, {
							hk: "2WhZ8k"
						})), n
					})(e)
				},
				Vs = (e, t) => {
					let {
						sourcePostId: n
					} = t;
					const s = Object(w.db)(e, {
							sourcePostId: n
						}),
						{
							allowedPostTypes: o,
							id: r,
							isProfile: i,
							name: a
						} = Object(w.g)(e);
					if (!n) return l.fbt._("A source post is required to crosspost", null, {
						hk: "2TeLDw"
					});
					if (!r) return l.fbt._("A destination community is required to crosspost", null, {
						hk: "3haidF"
					});
					const c = i ? Object(k.W)(e, {
						userId: r
					}) : r;
					if (c) {
						if (((e, t, n) => {
								const s = Object(rt.a)(n, {
										sort: "new",
										crossposts_only: !0
									}),
									o = e.subreddits.duplicates.models[t];
								return !(o && o[s])
							})(e, c, n)) return l.fbt._("Checking community...", null, {
							hk: "1ycXCe"
						});
						if (((e, t, n) => {
								const s = ((e, t, n) => {
									const s = e.subreddits.duplicates.models[t];
									return s ? s[n] : []
								})(e, t, Object(rt.a)(n, {
									sort: "new",
									crossposts_only: !0
								}));
								return 0 !== s.length && Object(it.G)(e, s[0])
							})(e, c, n)) return l.fbt._("This community has the same crosspost within last 24 hours", null, {
							hk: "177pgf"
						})
					}
					if (!o || !s) return null;
					if (s.source) return !o.links && l.fbt._("This community does not allow for crossposting of link posts", null, {
						hk: "2cZPxJ"
					});
					const {
						isCrosspostableSubreddit: d
					} = Object(_.y)(e, {
						subredditName: a
					});
					if (!d) return l.fbt._("This community does not allow for crossposting of any posts", null, {
						hk: "2KrrAO"
					});
					switch (s.media && s.media.type) {
						case et.o.TEXT:
						case et.o.RTJSON:
							return !o.text && l.fbt._("This community does not allow for crossposting of text posts", null, {
								hk: "1a4voI"
							});
						case et.o.IMAGE:
							return !o.images && l.fbt._("This community does not allow for crossposting of image posts", null, {
								hk: "tGzk7"
							});
						case et.o.VIDEO:
						case et.o.GIFVIDEO:
						case et.o.EMBED:
							return !o.videos && l.fbt._("This community does not allow for crossposting of video posts", null, {
								hk: "w6HED"
							})
					}
					return null
				},
				Ws = (e, t) => {
					let {
						sourcePostId: n
					} = t;
					const s = Object(w.O)(e),
						o = Object(w.Z)(e),
						r = Object(w.fb)(e);
					if (r === m.Jb.IMAGE_ONLY) return !1;
					if (!Object(w.g)(e).name || !Object(w.A)(e)) return !1;
					if (r === m.Jb.POST || r === m.Jb.POLL) {
						const t = Hs(e),
							n = !B.a.isAllMediaUploaded(o, e.uploads);
						return !t.length && !n
					}
					if (r === m.Jb.MEDIA) {
						const {
							items: t
						} = s, n = t.every(t => {
							const n = e.uploads[t.uploadKey];
							return !(!n || !n.url || n.status !== tt.a.SUCCESS)
						});
						return t.length > 0 && n
					}
					return r === m.Jb.LINK_ONLY ? Object(w.v)(e) : r === m.Jb.CROSSPOST && !Vs(e, {
						sourcePostId: n
					})
				},
				zs = Object(i.c)({
					isPoll: Us,
					activeModalId: nt.a,
					currentSubredditOrProfile: E.o,
					canPostAsModerator: w.d,
					currentCollection: E.f,
					errorMsgs: (e, t) => {
						let {
							sourcePostId: n
						} = t;
						if (Object(w.t)(e)) return Object(w.n)(e);
						if (n) {
							const t = Vs(e, {
								sourcePostId: n
							});
							if (t) return [t]
						}
						return Hs(e)
					},
					eventSchedule: w.o,
					extendedScheduledPostsEnabled: w.p,
					hasDraftError: S.f,
					hasError: w.t,
					hasSubmitValidationError: w.u,
					destSubreddit: w.g,
					destSubredditAboutInfo: w.f,
					isChatPostSelected: w.C,
					isContestMode: w.D,
					isDraftsFeatureEnabled: (e, t) => !Us(e, t),
					isDraftPending: S.g,
					isMediaUploadPending: w.P,
					isModeratorSomewhere: ot.h,
					isPostPending: w.hb,
					isPostSubmitEnabled: Ws,
					isSaveDraftEnabled: e => {
						const t = Object(w.fb)(e);
						if (!m.D.has(t) || !Object(w.B)(e)) return !1;
						const n = Object(w.g)(e),
							s = Object(w.m)(e),
							o = t === m.Jb.LINK_ONLY && Object(w.v)(e),
							r = t === m.Jb.POST && s === f.h.RICH_TEXT && Object(w.z)(e),
							i = t === m.Jb.POST && s === f.h.MARKDOWN && Object(w.w)(e),
							a = o || r || i;
						return !!n.name || Object(w.A)(e) || a
					},
					isScheduledPost: w.K,
					postSchedule: w.W,
					postToTwitter: w.Y,
					isEditingScheduledPost: e => !!Object(de.r)(e),
					showContributorRequestFlow: e => Object(_.s)(e, g.e.Post),
					showScheduledPosts: w.cb,
					stickyPosition: w.eb,
					submissionType: w.a,
					submitMode: w.gb,
					subredditGovMeta: e => {
						const t = Object(w.g)(e);
						if (t && t.id) return e.subreddits.gov.meta[t.id]
					},
					suggestedSort: w.jb
				}),
				qs = Object(E.t)(),
				Gs = Object(r.b)(zs, e => ({
					onResetDestCollection: () => e(_e.c()),
					onScheduledPostSettingsChange: t => e(a.A(t)),
					onTrackCancelButtonClick: () => {
						e((e, t) => O.a(t()))
					},
					openCollectionsListOrCreationModal: t => e(a.m(t)),
					togglePostSchedulePicker: () => e(a.x(f.n)),
					clickPostSchedule: () => {
						e((e, t) => Object(N.a)(Object(ae.m)()(t())))
					}
				})),
				Js = 2e3,
				Qs = e => e ? l.fbt._("Update", null, {
					hk: "3MoYFL"
				}) : l.fbt._("Schedule", null, {
					hk: "4bXWUG"
				});
			class Zs extends o.a.Component {
				constructor() {
					super(...arguments), this.isSavedTimer = null, this.state = {
						draftId: null,
						isSaved: !1
					}, this.onCancel = () => {
						this.props.onTrackCancelButtonClick(), this.props.onCancel()
					}, this.handleDestCollectionClick = () => {
						const {
							currentCollection: e,
							onResetDestCollection: t,
							currentSubredditOrProfile: n,
							openCollectionsListOrCreationModal: s,
							sendEvent: o
						} = this.props;
						if (e) return t();
						n && (s(n.id), o(Object(cn.b)(void 0, cn.a.collectionComposer)))
					}, this.shouldDisablePostButton = () => {
						const {
							contributorRequestPending: e,
							hasSubmitValidationError: t,
							isDraftPending: n,
							isMediaUploadPending: s,
							isPostPending: o,
							isPostSubmitEnabled: r
						} = this.props;
						return !r || n || o || s || this.state.isSaved || t || e
					}, this.shouldDisablePostScheduleButton = () => {
						const {
							currentCollection: e,
							eventSchedule: t,
							extendedScheduledPostsEnabled: n,
							isChatPostSelected: s,
							postToTwitter: o,
							submissionType: r
						} = this.props;
						return n ? !!t || o || !Ps(r, !0) : !!t || o || !Ps(r, !1) || s || !!e
					}, this.openPostSchedulePickerModal = () => {
						this.props.togglePostSchedulePicker(), this.props.clickPostSchedule()
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					!this.props.isDraftPending || e.isDraftPending || e.hasDraftError || this.setState({
						isSaved: !0,
						draftId: this.props.draftId
					}, () => {
						this.isSavedTimer = window.setTimeout(() => {
							this.isSavedTimer = null, this.setState({
								isSaved: !1,
								draftId: null
							})
						}, Js)
					})
				}
				componentWillUnmount() {
					this.isSavedTimer && (clearTimeout(this.isSavedTimer), this.isSavedTimer = null)
				}
				getSaveDraftButtonText() {
					const {
						draftId: e
					} = this.props, {
						isSaved: t,
						draftId: n
					} = this.state;
					return t ? n ? ws() : Os() : e ? Ss() : js()
				}
				render() {
					const {
						activeModalId: e,
						canPostAsModerator: t,
						currentCollection: n,
						className: r,
						destSubreddit: i,
						destSubredditAboutInfo: a,
						extendedScheduledPostsEnabled: c,
						hasError: d,
						hasSubmitValidationError: u,
						isEditingScheduledPost: p,
						errorMsgs: h,
						isContestMode: b,
						isDraftsFeatureEnabled: x,
						isDraftPending: y,
						isPoll: v,
						isMediaUploadPending: C,
						isPostPending: E,
						isSaveDraftEnabled: O,
						isScheduledPost: j,
						onPostFieldValidation: w,
						onScheduledPostSettingsChange: S,
						onSaveDraft: _,
						onSubmit: k,
						postSchedule: T,
						sendEvent: I,
						showContributorRequestFlow: P,
						showScheduledPosts: M,
						stickyPosition: N,
						submissionType: R,
						submitMode: L,
						subredditGovMeta: A,
						suggestedSort: F,
						togglePostSchedulePicker: D
					} = this.props, {
						isSaved: B
					} = this.state, U = y || E || C, K = L === f.q.Post && C, H = L === f.q.Draft && C, {
						collectionsEnabled: V = !1
					} = a || {}, W = U || j && !c, z = Object(We.a)(vs.a.ButtonLayout, {
						[vs.a.autoWidth]: v || P || M
					});
					return o.a.createElement(Is, {
						className: r
					}, o.a.createElement(is, {
						className: vs.a.postModifiers,
						disabled: U,
						onPostFieldValidation: w
					}), o.a.createElement(Ms, null, o.a.createElement(Ns, null, o.a.createElement("div", {
						className: z
					}, P ? o.a.createElement(qe.a, {
						eventSource: g.b.PostSubmission,
						smallButton: !0
					}) : o.a.createElement(ut, {
						disabled: this.shouldDisablePostButton(),
						onClick: k,
						className: M && vs.a.removeRightBorderRadius
					}, E || K ? o.a.createElement(As, {
						sizePx: Ts
					}) : o.a.createElement(s.Fragment, null, v && A && A.polls && A.polls.price && i.id ? o.a.createElement(s.Fragment, null, Cs(), o.a.createElement(Ds, {
						subredditId: i.id
					}), Object(ze.a)(A.polls.price)) : j ? Qs(p) : Cs())), M && o.a.createElement(ut, {
						title: l.fbt._("Make a scheduled post", null, {
							hk: "3TBSMs"
						}),
						disabled: this.shouldDisablePostScheduleButton(),
						onClick: this.openPostSchedulePickerModal,
						className: vs.a.postScheduleButton
					}, T ? o.a.createElement(Xe.a, {
						className: vs.a.postScheduleIcon
					}) : o.a.createElement(Ye.a, {
						className: vs.a.postScheduleIcon
					}))), e === f.n && o.a.createElement(Je.a, {
						extendedScheduledPostsEnabled: c,
						isContestMode: b,
						sendEvent: I,
						schedule: T,
						stickyPosition: N,
						suggestedSort: F,
						onChange: S,
						onClose: D
					}), x && R !== m.Jb.MEDIA && R !== m.Jb.POLL && !j ? o.a.createElement(Ls, null, o.a.createElement(pt, {
						disabled: !O || U || B,
						onClick: _
					}, y || H ? o.a.createElement(Fs, {
						sizePx: Ts
					}) : this.getSaveDraftButtonText())) : o.a.createElement(Rs, null, o.a.createElement(pt, {
						disabled: U || B,
						onClick: this.onCancel
					}, Es())), V && t && o.a.createElement(gs, {
						disabled: W,
						isToggled: !!n,
						onClick: this.handleDestCollectionClick
					})), o.a.createElement(vt, null), !!(d || h.length || u) && o.a.createElement(Qe.a, {
						className: vs.a.errorMessages,
						messages: h,
						fallbackMessage: u ? _s() : ks()
					})))
				}
			}
			var Ys = qs(Gs(Object(xs.c)(Zs))),
				Xs = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx"),
				$s = n("./src/reddit/constants/posts.ts"),
				eo = n("./src/reddit/controls/SubredditPicker/index.tsx"),
				to = n("./src/reddit/controls/SubredditPicker/helpers.ts"),
				no = n("./src/reddit/components/PostCreationForm/CreationControls/index.m.less"),
				so = n.n(no);
			const oo = dt.a.wrapped(eo.a, "SubredditPicker", so.a),
				ro = dt.a.wrapped($e.a, "ControlRow", so.a),
				io = Object(i.a)(w.g, nt.a, w.S, k.i, E.q, k.z, (e, t, n, s, o, r) => {
					const i = n && !t ? n : e;
					if (!i || !i.name) return Object(to.b)("", null, null, r);
					const {
						name: a,
						isProfile: c
					} = i;
					return c ? Object(to.b)(Object(J.c)(a), null, s, r) : Object(to.b)(Object(J.b)(a), o, null, r)
				}),
				ao = Object(i.c)({
					pending: w.U,
					pickerValue: io
				}),
				co = Object(r.b)(ao, (e, t) => {
					let {
						draftId: n,
						pageLayer: s
					} = t;
					return {
						onSubredditChangeRequested: t => e(_e.b(t, s)),
						onTrackSubredditPickerClick: () => e((e, t) => O.w(t()))
					}
				});
			class lo extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.inputRef = null, this.onSelectSubreddit = e => {
						const {
							rawString: t,
							record: n
						} = e, s = {
							name: n && n.name || Object(J.f)(t),
							isProfile: n && n.type === $s.a.PROFILE || Object(J.e)(t),
							allowedPostTypes: n && n.allowedPostTypes
						};
						this.props.onSubredditChangeRequested(s)
					}, this.setInputRef = e => this.inputRef = e
				}
				render() {
					return o.a.createElement(ro, null, o.a.createElement(oo, {
						allowCrosspostableOnly: this.props.allowCrosspostableOnly,
						disabled: this.props.pending,
						includeUserProfile: this.props.includeUserProfile,
						inputRef: this.setInputRef,
						onSelect: this.onSelectSubreddit,
						onFocus: this.props.onTrackSubredditPickerClick,
						selectOnBlur: !0,
						value: this.props.pickerValue
					}))
				}
			}
			var uo = Object(E.t)({
					draftId: E.u,
					pageLayer: e => e
				})(co(lo)),
				po = n("./node_modules/lodash/range.js"),
				mo = n.n(po),
				ho = n("./src/higherOrderComponents/asModal/index.tsx"),
				bo = n("./src/reddit/icons/svgs/Close/index.tsx"),
				fo = n("./src/lib/timeAgo/index.ts"),
				go = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				xo = n("./src/reddit/icons/fonts/Expandos/Media/Video/index.tsx"),
				yo = n("./src/reddit/icons/fonts/Link/index.tsx"),
				vo = n("./src/reddit/icons/fonts/Photos/index.tsx"),
				Co = n("./src/reddit/icons/fonts/Text/index.tsx"),
				Eo = n("./src/reddit/models/PostDraft/index.ts"),
				Oo = n("./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Icon.m.less"),
				jo = n.n(Oo),
				wo = function(e, t) {
					var n = {};
					for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
					if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
						var o = 0;
						for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
					}
					return n
				};
			const So = {
				[Eo.b.Image]: vo.a,
				[Eo.b.Link]: yo.a,
				[Eo.b.Markdown]: Co.a,
				[Eo.b.RichText]: Co.a,
				[Eo.b.Video]: xo.a
			};
			var _o = dt.a.wrapped(e => {
					const {
						draftKind: t
					} = e, n = wo(e, ["draftKind"]), s = So[t] || yo.a;
					return o.a.createElement(s, n)
				}, "Component", jo.a),
				ko = n("./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/index.m.less"),
				To = n.n(ko);
			const Io = dt.a.div("Container", To.a),
				Po = dt.a.div("LeftBlock", To.a),
				Mo = dt.a.div("Content", To.a),
				No = dt.a.div("RightBlock", To.a),
				Ro = dt.a.h2("PostTitle", To.a),
				Lo = dt.a.wrapped(Ro, "EditingPostTitle", To.a),
				Ao = dt.a.div("MetaLine", To.a),
				Fo = dt.a.span("SubredditName", To.a),
				Do = dt.a.time("DraftSavedTime", To.a),
				Bo = dt.a.wrapped(ps.b, "TrashIcon", To.a),
				Uo = dt.a.div("InteractiveDiv", To.a),
				Ko = dt.a.button("ConfirmDelete", To.a),
				Ho = Object(i.c)({
					isDraftDeletionPending: (e, t) => {
						let {
							draft: {
								id: n
							}
						} = t;
						return Object(S.a)(e, n)
					},
					subreddit: (e, t) => {
						let {
							draft: {
								subredditId: n
							}
						} = t;
						return n ? Object(_.S)(e, {
							subredditId: n
						}) : void 0
					},
					user: k.i
				}),
				Vo = Object(r.b)(Ho, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return {
						deleteDraft: t => e(F.o(t, n))
					}
				}),
				Wo = Object(E.t)({
					currentDraftId: E.u,
					pageLayer: e => e
				}),
				zo = 1e3;
			class qo extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						showConfirmText: !1
					}, this.onClick = () => {
						this.props.onClick(this.props.draft.id)
					}, this.onConfirmClick = e => {
						e.stopPropagation(), this.props.deleteDraft(this.props.draft.id)
					}, this.onTrashCanClick = e => {
						e.stopPropagation(), this.setState({
							showConfirmText: !0
						})
					}
				}
				render() {
					const {
						draft: e,
						currentDraftId: t,
						isDraftDeletionPending: n,
						subreddit: s,
						user: r
					} = this.props, i = s && Object(Mn.g)(s) && r ? {
						displayText: Object(J.c)(Object(le.e)(r)),
						url: "/user/".concat(Object(le.e)(r), "/")
					} : s;
					if (n) return null;
					const a = e.title || l.fbt._("Untitled", null, {
						hk: "2gEXjp"
					});
					return o.a.createElement(Io, {
						onClick: this.onClick
					}, o.a.createElement(Po, null, o.a.createElement(_o, {
						draftKind: e.kind
					})), o.a.createElement(Mo, null, t === e.id ? o.a.createElement(Lo, {
						"data-redditstyle": !0
					}, l.fbt._("EDITING: {postTitle}", [l.fbt._param("postTitle", a)], {
						hk: "3M5MUj"
					})) : o.a.createElement(Ro, {
						"data-redditstyle": !0
					}, a), o.a.createElement(Ao, {
						"data-redditstyle": !0
					}, i && o.a.createElement(Fo, {
						"data-redditstyle": !0
					}, i.displayText), i && o.a.createElement(go.b, null), o.a.createElement(Do, null, l.fbt._("Draft saved {draftSavedAtTime}", [l.fbt._param("draftSavedAtTime", Object(fo.d)((e.modified || e.created) / zo))], {
						hk: "2HjAWY"
					})))), o.a.createElement(No, null, this.state.showConfirmText ? o.a.createElement(Ko, {
						onClick: this.onConfirmClick,
						"data-redditstyle": !0
					}, t === e.id ? l.fbt._("Delete working draft?", null, {
						hk: "2iGoUj"
					}) : l.fbt._("Confirm", null, {
						hk: "2bjb66"
					})) : o.a.createElement(Uo, {
						onClick: this.onTrashCanClick
					}, o.a.createElement(Bo, {
						"data-redditstyle": !0
					}))))
				}
			}
			var Go = Wo(Vo(qo)),
				Jo = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				Qo = n("./src/reddit/components/PostCreationForm/DraftListModal/DraftListItem/Placeholder.m.less"),
				Zo = n.n(Qo);
			const Yo = dt.a.div("Container", Zo.a),
				Xo = dt.a.div("LeftBlock", Zo.a),
				$o = dt.a.div("Content", Zo.a),
				er = dt.a.div("MediaIcon", Zo.a),
				tr = dt.a.div("Title", Zo.a),
				nr = dt.a.div("Secondary", Zo.a);
			var sr = e => {
					let {
						className: t,
						isLoading: n
					} = e;
					return o.a.createElement(Yo, {
						className: t,
						"data-redditstyle": !0
					}, o.a.createElement(Xo, null, o.a.createElement(er, {
						className: Object(Jo.a)({
							isLoading: n
						}),
						"data-redditstyle": !0
					})), o.a.createElement($o, null, o.a.createElement(tr, {
						className: Object(Jo.b)({
							isLoading: n
						}),
						"data-redditstyle": !0
					}), o.a.createElement(nr, {
						className: Object(Jo.b)({
							isLoading: n
						}),
						"data-redditstyle": !0
					})))
				},
				or = n("./src/reddit/components/PostCreationForm/DraftListModal/index.m.less"),
				rr = n.n(or);

			function ir() {
				return (ir = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: ar
			} = n("./node_modules/fbt/lib/FbtPublic.js"), cr = "".concat(U.a.assetPath, "/img/snoo-drafts.png"), lr = 3, dr = dt.a.div("Wrapper", rr.a), ur = dt.a.div("TitleRow", rr.a), pr = dt.a.span("DraftsNumber", rr.a), mr = dt.a.div("DetailsContainer", rr.a), hr = dt.a.wrapped($e.a, "ButtonRow", rr.a), br = dt.a.wrapped(at.i, "CancelButton", rr.a), fr = dt.a.div("CloseWrapper", rr.a), gr = dt.a.wrapped(bo.a, "Close", rr.a), xr = dt.a.div("Empty", rr.a), yr = dt.a.img("EmptyImage", rr.a), vr = dt.a.p("EmptyText", rr.a), Cr = Object(i.c)({
				drafts: S.c,
				isPending: S.b,
				maxDrafts: k.R
			}), Er = Object(r.b)(Cr);
			class Or extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.handleEscapeKey = e => {
						e.keyCode === h.a.Escape && this.props.onClose()
					}, this.renderItem = e => o.a.createElement(Go, {
						key: e.id,
						draft: e,
						onClick: () => this.props.onLoadDraft(e)
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey)
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderPlaceholder(e) {
					return o.a.createElement(sr, {
						isLoading: !0,
						key: e
					})
				}
				renderEmpty() {
					return o.a.createElement(xr, null, o.a.createElement(yr, {
						src: cr
					}), o.a.createElement(vr, null, ar._("Your drafts will live here", null, {
						hk: "NIEIr"
					})))
				}
				render() {
					const {
						drafts: e,
						isPending: t,
						maxDrafts: n
					} = this.props;
					let s;
					return s = t ? mo()(lr).map(this.renderPlaceholder) : 0 === e.length ? this.renderEmpty() : e.map(this.renderItem), o.a.createElement(dr, {
						"data-redditstyle": !0
					}, o.a.createElement(ur, {
						"data-redditstyle": !0
					}, ar._("Drafts", null, {
						hk: "1fvOmI"
					}), o.a.createElement(pr, {
						"data-redditstyle": !0
					}, e.length, "/", n), o.a.createElement(fr, {
						onClick: this.props.onClose
					}, o.a.createElement(gr, {
						"data-redditstyle": !0
					}))), o.a.createElement(mr, null, s), o.a.createElement(hr, {
						"data-redditstyle": !0
					}, o.a.createElement(br, {
						onClick: this.props.onClose,
						"data-redditstyle": !0
					}, ar._("Close", null, {
						hk: "4gbyAA"
					}))))
				}
			}
			const jr = dt.a.wrapped(Object(ho.a)(Er(Or)), "DraftListModal", rr.a);
			var wr = e => o.a.createElement(jr, ir({
					withOverlay: !0,
					onOverlayClick: e.onClose
				}, e)),
				Sr = (n("./node_modules/core-js/modules/es6.regexp.constructor.js"), n("./src/lib/forceHttps/index.ts")),
				_r = n("./src/reddit/components/PostCreationForm/SafeHarborText/index.m.less"),
				kr = n.n(_r);
			const {
				fbt: Tr
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Ir = new RegExp("\\b(".concat([...et.x].join("|"), ")\\.com$"), "i"), Pr = new RegExp("\\.(".concat(et.w.join("|"), ")$")), Mr = dt.a.div("TextContainer", kr.a);
			class Nr extends o.a.Component {
				constructor() {
					super(...arguments), this.isUrlScraped = e => {
						const t = Object(V.parse)(Object(Sr.a)(e));
						return !(!t.hostname || !Ir.test(t.hostname)) || !(!t.pathname || !Pr.test(t.pathname))
					}
				}
				render() {
					return this.props.value && this.isUrlScraped(this.props.value) ? o.a.createElement(Mr, null, Tr._("Posting this link saves the image or gif to Reddit", null, {
						hk: "1zFV82"
					})) : null
				}
			}
			var Rr = n("./node_modules/react-autosize-textarea/lib/index.js"),
				Lr = n.n(Rr),
				Ar = n("./src/reddit/controls/GrowingOutlinedInput/index.m.less"),
				Fr = n.n(Ar);

			function Dr() {
				return (Dr = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var Br = function(e, t) {
				var n = {};
				for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
				if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
					var o = 0;
					for (s = Object.getOwnPropertySymbols(e); o < s.length; o++) t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[o]) && (n[s[o]] = e[s[o]])
				}
				return n
			};
			class Ur extends o.a.Component {
				constructor(e) {
					super(e), this.innerRef = null, this.focused = !1, this.setInnerRef = e => {
						this.innerRef = e, this.props.textareaRef && this.props.textareaRef(e)
					}, this.handleOnValueChange = () => {
						this.props.onValueChange && this.props.onValueChange(this.state.value)
					}, this.onFocus = e => {
						this.focused = !0, this.props.onFocus && this.props.onFocus(e)
					}, this.onBlur = e => {
						this.focused = !1, this.props.onBlur && this.props.onBlur(e)
					}, this.onChange = e => {
						if (this.innerRef) {
							const e = this.innerRef.value.replace(/\n/g, " ");
							this.setState(() => ({
								value: e
							}), this.handleOnValueChange)
						}
						this.props.onChange && this.props.onChange(e)
					}, this.onKeyPress = e => {
						13 === e.which && e.preventDefault(), this.props.onKeyPress && this.props.onKeyPress(e)
					}, this.state = {
						value: e.value || ""
					}
				}
				componentWillReceiveProps(e) {
					this.focused || this.state.value === e.value || this.setState({
						value: e.value
					})
				}
				render() {
					const {
						value: e
					} = this.state, t = this.props, {
						className: n,
						onValueChange: s,
						textareaRef: r,
						minHeight: i
					} = t, a = Br(t, ["className", "onValueChange", "textareaRef", "minHeight"]);
					return o.a.createElement(Lr.a, Dr({}, a, {
						className: Object(We.a)(Fr.a.growingOutlinedInput, n),
						style: {
							minHeight: i
						},
						innerRef: this.setInnerRef,
						onFocus: this.onFocus,
						onBlur: this.onBlur,
						onChange: this.onChange,
						onKeyPress: this.onKeyPress,
						value: e
					}))
				}
			}
			var Kr = n("./src/reddit/components/PostCreationForm/LinkEditor/index.m.less"),
				Hr = n.n(Kr);
			const Vr = Object(i.c)({
					pending: w.U,
					postCreationFieldErrors: Rn,
					subreddit: E.q,
					value: w.M
				}),
				Wr = Object(r.b)(Vr, (e, t) => {
					let {
						onChange: n,
						onPostFieldValidation: s,
						pageLayer: o
					} = t;
					return {
						onBlur: () => {
							s(e(St(m.nb.LINK, o)))
						},
						onChange: t => {
							e(a.q(t)), n(t)
						},
						onFocus: () => e((e, t) => O.n(t(), f.k.CLICK, f.l.URL))
					}
				});
			var zr, qr = Object(E.t)()(Wr(e => {
					const {
						pending: t,
						postCreationFieldErrors: n,
						subreddit: s,
						value: r
					} = e, i = n[m.nb.LINK].length > 0;
					return o.a.createElement("div", null, o.a.createElement(Ur, {
						className: Object(We.a)(Hr.a.URLInput, {
							[Hr.a.mHasError]: i
						}),
						placeholder: l.fbt._("Url", null, {
							hk: "4dfMY"
						}),
						value: r,
						onBlur: e.onBlur,
						onFocus: e.onFocus,
						onKeyDown: e.onKeyDown,
						onValueChange: e.onChange,
						readOnly: t
					}), o.a.createElement(Qe.a, {
						errorModalTitle: s ? Object(J.b)(s.name) : void 0,
						messages: n[m.nb.LINK]
					}), o.a.createElement(Nr, {
						value: r
					}))
				})),
				Gr = n("./node_modules/lodash/clamp.js"),
				Jr = n.n(Gr),
				Qr = n("./node_modules/lodash/pickBy.js"),
				Zr = n.n(Qr),
				Yr = n("./src/lib/formatApiError/index.ts"),
				Xr = n("./src/lib/objectSelector/index.ts"),
				$r = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/lodash/isEqual.js")),
				ei = n.n($r),
				ti = n("./src/reddit/controls/Sortable/index.tsx"),
				ni = n("./src/reddit/hooks/useTracking.ts");
			! function(e) {
				e.RemoveGalleryItem = "REMOVE_GALLERY_ITEM", e.SelectGalleryItem = "SELECT_GALLERY_ITEM", e.SetGalleryItems = "SET_GALLERY_ITEMS", e.SetCaptionInput = "SET_CAPTION_INPUT", e.SetURLInput = "SET_URL_INPUT", e.SelectPrevMedia = "SELECT_PREV_MEDIA", e.SelectNextMedia = "SELECT_NEXT_MEDIA"
			}(zr || (zr = {}));
			var si = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				oi = n("./node_modules/lodash/upperFirst.js"),
				ri = n.n(oi),
				ii = n("./src/reddit/icons/svgs/Hamster1/index.tsx"),
				ai = n("./src/reddit/icons/svgs/Hamster2/index.tsx"),
				ci = n("./src/reddit/components/PostCreationForm/MediaInput/DropArea/index.m.less"),
				li = n.n(ci);
			const {
				fbt: di
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ui = [...Array.from(m.a), ...Array.from(m.b)].join(), pi = dt.a.input("HiddenInput", li.a), mi = dt.a.wrapped(at.i, "UploadButton", li.a), hi = dt.a.wrapped(ii.a, "HamsterSmall", li.a), bi = dt.a.wrapped(ai.a, "HamsterLarge", li.a), fi = dt.a.div("Container", li.a), gi = dt.a.div("DropArea", li.a), xi = dt.a.wrapped(gi, "DropAreaActive", li.a), yi = dt.a.wrapped(xi, "DropAreaOver", li.a), vi = dt.a.p("Paragraph", li.a), Ci = dt.a.p("ErrorMsg", li.a), Ei = dt.a.div("Box", li.a);
			class Oi extends o.a.Component {
				constructor() {
					super(...arguments), this.hiddenInputEl = null, this.onFileInput = e => {
						this.props.onFileInput(e.currentTarget.files)
					}, this.clickUploadButton = () => this.hiddenInputEl && this.hiddenInputEl.click()
				}
				render() {
					const {
						isOver: e,
						canDrop: t,
						lastErrorMsg: n,
						allowMultiple: s
					} = this.props;
					return o.a.createElement(fi, null, o.a.createElement(pi, {
						innerRef: e => this.hiddenInputEl = e,
						onChange: this.onFileInput,
						type: "file",
						accept: ui,
						multiple: s
					}), e ? o.a.createElement(yi, null, o.a.createElement(Ei, null, o.a.createElement(bi, null), o.a.createElement(vi, null, di._("Drop Here to Upload", null, {
						hk: "3e1xuE"
					})))) : t ? o.a.createElement(xi, null, o.a.createElement(Ei, null, o.a.createElement(hi, null), di._("Drop Here to Upload", null, {
						hk: "3e1xuE"
					}))) : o.a.createElement(gi, null, o.a.createElement(vi, null, di._("Drag and drop {images} or {upload}", [di._param("images", s ? "images" : ""), di._param("upload", o.a.createElement(mi, {
						onClick: this.clickUploadButton
					}, di._("Upload", null, {
						hk: "4dwHCO"
					})))], {
						hk: "2gpX4v"
					})), n && o.a.createElement(Ci, null, ri()(n))))
				}
			}
			var ji = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/AddImageItem.m.less"),
				wi = n.n(ji);

			function Si(e) {
				const {
					onClickEvent: t,
					onFileInput: n
				} = e, r = Object(s.useRef)(null), i = Object(s.useCallback)(() => {
					r && r.current && r.current.click(), t()
				}, [t, r]), a = Object(s.useCallback)(e => {
					n(e.currentTarget.files)
				}, [n]);
				return o.a.createElement("span", {
					className: wi.a.AddImageWrapper
				}, o.a.createElement("input", {
					accept: ui,
					className: wi.a.hiddenInput,
					multiple: !0,
					onChange: a,
					ref: r,
					type: "file"
				}), o.a.createElement("button", {
					className: wi.a.AddImageItem,
					onClick: i
				}, o.a.createElement(In.a, {
					className: wi.a.plusIcon
				})))
			}
			var _i = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				ki = n("./src/reddit/icons/svgs/Clear/index.tsx"),
				Ti = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItem.m.less"),
				Ii = n.n(Ti);
			var Pi = e => {
					const {
						canDrop: t,
						mediaUpload: n,
						isDragging: r,
						isOver: i,
						isSelected: a,
						mediaItem: c,
						removeGalleryItem: l,
						dispatch: d
					} = e, u = Object(s.useRef)(null), p = n.key, m = n.status === tt.a.FAILED, h = Object(s.useCallback)(() => d((e => ({
						type: zr.SelectGalleryItem,
						payload: {
							key: e
						}
					}))(p)), [d, p]), b = Object(s.useCallback)(e => {
						e.stopPropagation(), l(c)
					}, [l, c]), f = n.metadata.localUrl;
					return f ? o.a.createElement("span", {
						ref: u
					}, o.a.createElement(_i.a, {
						canDrop: t,
						className: Object(We.a)(Ii.a.GalleryMediaUpload, {
							[Ii.a.isDragging]: r,
							[Ii.a.isSelected]: a,
							[Ii.a.isError]: m
						}),
						isDragging: r,
						isOver: i
					}, o.a.createElement("span", {
						className: Object(We.a)(Ii.a.galleryImage, {
							[Ii.a.isDragging]: r,
							[Ii.a.isSelected]: a,
							[Ii.a.isError]: m
						}),
						onClick: h,
						style: {
							backgroundImage: 'url("'.concat(f, '")')
						}
					}, o.a.createElement("button", {
						className: Object(We.a)(Ii.a.deleteButton, {
							[Ii.a.isDragging]: r,
							[Ii.a.showDeleteNormal]: !a,
							[Ii.a.isError]: m
						}),
						onClick: b
					}, o.a.createElement(ki.a, {
						className: Object(We.a)(Ii.a.deleteIcon, {
							[Ii.a.isDragging]: r
						})
					}))))) : null
				},
				Mi = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/ImageItemsWrapper.m.less"),
				Ni = n.n(Mi);
			var Ri = e => {
					const {
						onRemoveUpload: t,
						dispatch: n,
						mediaState: r,
						uploads: i
					} = e, a = Object(ni.a)(), c = Object(s.useCallback)(() => a(O.j()), [a]), l = Object(s.useCallback)(e => {
						t(e.uploadKey), a(O.l())
					}, [a, t]);
					return o.a.createElement("div", {
						className: Ni.a.itemsWrapper
					}, o.a.createElement(ti.a, {
						className: Ni.a.sortableImages,
						values: r.items,
						getReactKey: e => e.uploadKey,
						render: (e, t, s, a, c) => {
							const d = i[e.uploadKey];
							if (!d) return null;
							if (Object(tt.c)(d)) return o.a.createElement("span", {
								className: Object(We.a)(Ni.a.pendingItem, Object(Jo.b)({
									isLoading: !0
								}))
							});
							const u = e.uploadKey === r.selectedKey;
							return o.a.createElement("span", {
								className: Ni.a.imageStyles
							}, a && o.a.createElement("span", {
								className: Ni.a.hoverMarker
							}), o.a.createElement(Pi, {
								canDrop: c,
								dispatch: n,
								isDragging: s,
								isOver: a,
								isSelected: u,
								mediaItem: e,
								key: e.uploadKey,
								mediaUpload: d,
								removeGalleryItem: l
							}))
						},
						onDrop: (e, t, s) => {
							n((e => ({
								type: zr.SetGalleryItems,
								payload: {
									items: e
								}
							}))(s))
						}
					}), r.items.length < si.b && o.a.createElement(Si, {
						onClickEvent: c,
						onFileInput: e.onFileInput
					}))
				},
				Li = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/InputWrapper.m.less"),
				Ai = n.n(Li);
			var Fi = e => {
					const {
						uploads: t,
						galleryItem: n,
						isSelected: r,
						dispatch: i
					} = e, a = t[n.uploadKey], c = n.caption, d = n.url, u = Object(ni.a)(), p = Object(s.useCallback)(e => i((e => ({
						type: zr.SetCaptionInput,
						payload: {
							input: e
						}
					}))(e)), [i]), m = Object(s.useCallback)(e => i((e => ({
						type: zr.SetURLInput,
						payload: {
							input: e
						}
					}))(e)), [i]), h = Object(s.useCallback)(e => u(O.k(e)), [u]), b = Object(s.useCallback)(() => h(f.l.CAPTION), [h]), g = Object(s.useCallback)(() => h(f.l.OUTBOUND_URL), [h]), x = !r || !a || !a.url || Object(tt.c)(a);
					return o.a.createElement("div", null, o.a.createElement("div", {
						className: Ai.a.inputWrapper
					}, o.a.createElement(Ur, {
						className: Ai.a.inputStyles,
						disabled: x,
						maxLength: si.a,
						onFocus: b,
						onValueChange: p,
						placeholder: l.fbt._("Add a caption...", null, {
							hk: "1fOmKi"
						}),
						value: c
					}), o.a.createElement("div", {
						className: Ai.a.charsCounter
					}, c.length, "/", si.a)), o.a.createElement("div", {
						className: Ai.a.inputWrapper
					}, o.a.createElement(Ur, {
						className: Object(We.a)(Ai.a.inputStyles, Ai.a.urlInputStyles),
						disabled: x,
						onFocus: g,
						onValueChange: m,
						placeholder: l.fbt._("Add a link...", null, {
							hk: "Z6l9K"
						}),
						value: d
					})))
				},
				Di = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/Layout.m.less"),
				Bi = n.n(Di);
			var Ui = e => {
					const {
						heroSlot: t,
						mainContent: n,
						sideMetaContent: s,
						bottomContent: r
					} = e;
					return o.a.createElement("div", {
						className: Bi.a.Layout
					}, o.a.createElement("div", {
						className: Bi.a.hero
					}, t), n && o.a.createElement("div", {
						className: Bi.a.mainContent
					}, n), s && o.a.createElement("div", {
						className: Bi.a.sideMetaContent
					}, s), o.a.createElement("div", {
						className: Bi.a.bottomContent
					}, r))
				},
				Ki = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/components/SelectedImage.m.less"),
				Hi = n.n(Ki);
			var Vi = e => {
					const {
						upload: t
					} = e, n = t.metadata.localUrl;
					return Object(tt.c)(t) ? o.a.createElement("span", {
						className: Object(We.a)(Hi.a.pendingImage, Object(Jo.b)({
							isLoading: !0
						}))
					}) : o.a.createElement("img", {
						className: Hi.a.selectedImage,
						src: n
					})
				},
				Wi = n("./src/reddit/components/ProgressBar/index.tsx"),
				zi = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/MultipleUploadStatusBar/index.m.less"),
				qi = n.n(zi);
			const {
				fbt: Gi
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Ji = dt.a.div("ControlRow", qi.a), Qi = dt.a.div("Status", qi.a);
			var Zi = dt.a.wrapped(e => {
					const {
						progress: t
					} = e, n = t && t.percent || 0;
					return o.a.createElement("div", {
						className: e.className
					}, o.a.createElement(Wi.a, {
						percent: n,
						className: qi.a.OuterDivProgressBar,
						innerBarClassName: qi.a.ProgressBar
					}), o.a.createElement(Ji, null, o.a.createElement(Qi, {
						className: qi.a.StatusText
					}, n < 100 ? Gi._("Image uploading in progress...", null, {
						hk: "n2dCj"
					}) : Gi._("Image uploading completed", null, {
						hk: "4ko42w"
					}))))
				}, "Component", qi.a),
				Yi = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/index.m.less"),
				Xi = n.n(Yi);

			function $i(e) {
				const {
					canDrop: t,
					dispatch: n,
					isOver: r,
					mediaState: i,
					onFileInput: a,
					onRemoveUpload: c,
					uploads: d
				} = e, [u, p] = Object(s.useState)([]), m = i.selectedKey, h = i.items.length > 1, b = i.items.find(e => e.uploadKey === m), f = m && d[m], g = i.items.filter(e => {
					const t = d[e.uploadKey];
					return !!t && t.status === tt.a.FAILED
				}).length, x = Object.values(d).filter(tt.c);
				if (!ei()(u, x))
					if (0 === x.length) p([]);
					else {
						const e = x.filter(e => !u.some(t => t.key === e.key));
						e.length > 0 && p([...u, ...e])
					} const y = u.length > 0,
					v = {
						percent: (() => {
							if (!y) return 0;
							let e = 0;
							return u.forEach(t => {
								const n = d[t.key];
								if (null == n || n && (n.status === tt.a.CANCELED || n.status === tt.a.FAILED || n.status === tt.a.SUCCESS)) e += 100;
								else {
									const n = d[t.key].progress;
									e += n && n.percent || 0
								}
							}), e / u.length
						})(),
						uploaded: 0
					};
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: Object(We.a)(Xi.a.dropArea, {
						[Xi.a.isDropAreaActive]: t,
						[Xi.a.isDropAreaOver]: r
					})
				}, o.a.createElement(Ui, {
					heroSlot: o.a.createElement(Ri, {
						mediaState: i,
						onFileInput: a,
						onRemoveUpload: c,
						uploads: d,
						dispatch: n
					}),
					mainContent: f && h && o.a.createElement(Vi, {
						upload: f
					}),
					sideMetaContent: b && h && o.a.createElement(Fi, {
						dispatch: n,
						galleryItem: b,
						uploads: d,
						isSelected: !!m
					}),
					bottomContent: null
				})), y ? o.a.createElement(Zi, {
					progress: v
				}) : null, !!g && o.a.createElement(Qe.a, {
					className: Xi.a.errorMessage,
					messages: [l.fbt._("Some files failed to upload, please remove or retry them", null, {
						hk: "3BP9AQ"
					})]
				}))
			}
			var ea = n("./src/reddit/components/RichTextEditor/DragController/helpers.ts"),
				ta = n("./src/reddit/components/ThumbnailSelector/index.tsx"),
				na = n("./src/reddit/controls/FileDrop/index.tsx"),
				sa = n("./src/reddit/helpers/media/index.ts"),
				oa = n("./src/telemetry/models/Media.ts"),
				ra = n("./src/reddit/components/MakeGifToggle/index.tsx"),
				ia = n("./src/reddit/icons/svgs/ThumbnailSelect/index.tsx"),
				aa = n("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				ca = n("./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/Preview/index.m.less"),
				la = n.n(ca);
			const da = dt.a.img("Img", la.a),
				ua = dt.a.img("BlurImg", la.a),
				pa = dt.a.wrapped(e => {
					const {
						className: t,
						url: n
					} = e;
					return o.a.createElement("div", {
						className: t
					}, o.a.createElement(ua, {
						src: n
					}), o.a.createElement(da, {
						src: n
					}))
				}, "ImagePreview", la.a),
				ma = dt.a.wrapped(e => {
					const {
						className: t,
						url: n,
						showControls: s,
						videoBlurImgSrc: r
					} = e;
					return o.a.createElement("div", {
						className: t
					}, o.a.createElement(aa.b, {
						shouldLoad: !1,
						shouldPause: !1,
						isGif: !1,
						otherSource: n,
						showControlBar: s,
						showSettingsIcon: !1,
						blurImageSrc: r
					}))
				}, "VideoPreview", la.a);
			var ha = dt.a.wrapped(e => {
					const {
						className: t,
						type: n,
						url: s,
						showControls: r,
						videoBlurImgSrc: i
					} = e;
					return o.a.createElement("div", {
						className: t
					}, "image" === n ? o.a.createElement(pa, {
						url: s
					}) : o.a.createElement(ma, {
						url: s,
						videoBlurImgSrc: i,
						showControls: r
					}))
				}, "Component", la.a),
				ba = n("./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/UploadStatusBar/index.m.less"),
				fa = n.n(ba);
			const {
				fbt: ga
			} = n("./node_modules/fbt/lib/FbtPublic.js"), xa = dt.a.div("ControlRow", fa.a), ya = dt.a.wrapped(at.n, "Button", fa.a), va = dt.a.div("Status", fa.a);
			var Ca = dt.a.wrapped(e => {
					const {
						name: t,
						progress: n,
						onCancel: s
					} = e, r = n && n.percent || 0;
					return o.a.createElement("div", {
						className: e.className
					}, o.a.createElement(Wi.a, {
						percent: r
					}), o.a.createElement(xa, null, o.a.createElement(va, null, r < 100 ? ga._("Uploading {fileName}", [ga._param("fileName", t)], {
						hk: "1F1ZHh"
					}) : ga._("Success!", null, {
						hk: "2SQAeu"
					})), r < 100 && o.a.createElement(ya, {
						onClick: s
					}, ga._("Cancel", null, {
						hk: "2TSLl5"
					}))))
				}, "Component", fa.a),
				Ea = n("./src/reddit/components/RichTextEditor/Toolbar/FormatterButton/index.tsx"),
				Oa = n("./src/reddit/components/PostCreationForm/MediaInput/MediaUpload/index.m.less"),
				ja = n.n(Oa);
			const wa = dt.a.div("Wrapper", ja.a),
				Sa = dt.a.div("Controls", ja.a),
				_a = dt.a.wrapped(ps.b, "Trash", ja.a),
				ka = dt.a.wrapped(ia.a, "ThumbnailSelect", ja.a);

			function Ta(e) {
				const {
					isPostSubmitPending: t,
					mediaType: n,
					onCancelUpload: s,
					onRemove: r,
					upload: i
				} = e, a = i.metadata, {
					localUrl: c,
					videoFirstFrameUrl: d
				} = a, u = i.status, p = u === tt.a.PENDING || u === tt.a.UPLOADING, m = u === tt.a.SUCCESS, h = !t;
				return o.a.createElement(wa, null, p ? o.a.createElement(Ca, {
					className: ja.a.UploadStatusBar,
					name: i.file.name,
					progress: i.progress,
					onCancel: s
				}) : null, c ? o.a.createElement(ha, {
					type: n,
					url: c,
					showControls: m,
					videoBlurImgSrc: d
				}) : null, m && o.a.createElement(Sa, null, "video" === n && o.a.createElement(ra.a, {
					disabled: !!e.makeGifDisableReason || !h,
					tooltip: e.makeGifDisableReason,
					on: e.isMakeGifToggleOn,
					onClick: e.onMakeGifToggle
				}), "video" === n && o.a.createElement(Ea.a, {
					enabled: h,
					Icon: ka,
					tooltip: l.fbt._("Choose thumbnail", null, {
						hk: "2XlKfd"
					}),
					onClick: e.onShowThumbnailSelector
				}), o.a.createElement(Ea.a, {
					enabled: h,
					Icon: _a,
					tooltip: l.fbt._("Remove", null, {
						hk: "H42IB"
					}),
					onClick: r
				})))
			}
			var Ia = n("./src/reddit/components/PostCreationForm/MediaInput/RemovePrompt/index.m.less"),
				Pa = n.n(Ia);
			const Ma = "POST_CREATION_MEDIA_REMOVE_PROMPT_ID",
				Na = dt.a.div("Wrapper", Pa.a),
				Ra = dt.a.wrapped($e.a, "TitleRow", Pa.a),
				La = dt.a.div("DetailsContainer", Pa.a),
				Aa = dt.a.wrapped($e.a, "ButtonRow", Pa.a),
				Fa = dt.a.wrapped(at.i, "CancelButton", Pa.a),
				Da = dt.a.wrapped(at.f, "ConfirmButton", Pa.a);
			var Ba = Object(ho.a)(e => {
					const {
						isVideo: t
					} = e;
					return o.a.createElement(Na, null, o.a.createElement(Ra, null, t ? l.fbt._("Remove video?", null, {
						hk: "34eepe"
					}) : l.fbt._("Remove image?", null, {
						hk: "41e1Uy"
					})), o.a.createElement(La, null, t ? l.fbt._("Are you sure you want to remove your video?", null, {
						hk: "smTuF"
					}) : l.fbt._("Are you sure you want to remove your image?", null, {
						hk: "Ci5LM"
					})), o.a.createElement(Aa, null, o.a.createElement(Fa, {
						onClick: e.onCanceled
					}, l.fbt._("Keep", null, {
						hk: "4gFSdj"
					})), o.a.createElement(Da, {
						onClick: e.onConfirmed
					}, l.fbt._("Remove", null, {
						hk: "1Jdd3U"
					}))))
				}),
				Ua = n("./src/reddit/components/PostCreationForm/MediaInput/index.m.less"),
				Ka = n.n(Ua);
			const Ha = "MEDIA_POST_VIDEO_THUMBNAIL_SELECTOR_MODAL_ID",
				Va = Object(i.c)({
					activeModalId: nt.a,
					isPostPending: w.U,
					uploads: Object(Xr.a)(e => Zr()(e.uploads, e => e.key.startsWith(P.a))),
					value: w.O,
					isImageGalleryCreationEnabled: w.G
				}),
				Wa = Object(r.b)(Va, e => ({
					onChange: t => e(a.d(t)),
					startMediaGalleryUploads: (t, n) => e(P.d(t, n)),
					removeUpload: t => e(ke.i(t, !0)),
					toggleThumbnailModal: () => e(a.x(Ha)),
					toggleRemovePrompt: () => e(a.x(Ma))
				})),
				za = dt.a.div("Container", Ka.a),
				qa = (e, t, n) => {
					if (!e.length) return null;
					let s = e.findIndex(e => e.uploadKey === n);
					if (-1 === s) {
						const o = t.findIndex(e => e.uploadKey === n);
						s = Jr()(o - 1, 0, e.length - 1)
					}
					return e[s].uploadKey
				};
			class Ga extends o.a.Component {
				constructor() {
					super(...arguments), this.onFileDrop = e => this.uploadMediaFiles(e, oa.FileSource.DragAndDrop), this.onFileInput = e => this.uploadMediaFiles(e, oa.FileSource.FileSelector), this.onRemoveUpload = e => {
						const {
							value: t
						} = this.props, {
							items: n,
							selectedKey: s
						} = t, o = n.filter(t => t.uploadKey !== e);
						this.props.onChange(Object.assign(Object.assign({}, t), {
							items: o,
							selectedKey: qa(o, n, s)
						})), this.props.removeUpload(e)
					}, this.onCancelSingleMediaUpload = () => {
						this.onRemoveUpload(this.getSingleUpload().key)
					}, this.handlePaste = e => {
						if (e.clipboardData) {
							const t = Object(ea.a)(e.clipboardData);
							t.length && (e.preventDefault(), e.stopPropagation(), this.uploadMediaFiles(t, oa.FileSource.Clipboard))
						}
					}, this.onRemoveConfirmed = () => {
						this.props.toggleRemovePrompt(), this.onRemoveUpload(this.getSingleUpload().key)
					}, this.onThumbnailSelect = e => {
						this.toggleThumbnailSelector();
						const {
							value: t
						} = this.props;
						if (!Object(f.v)(t)) return;
						const n = t.items[0],
							s = n.video;
						this.props.onChange(Object.assign(Object.assign({}, t), {
							items: [Object.assign(Object.assign({}, n), {
								video: Object.assign(Object.assign({}, s), {
									thumbnail: e
								})
							})]
						}))
					}, this.toggleThumbnailSelector = () => {
						this.props.toggleThumbnailModal()
					}, this.onMakeGifToggle = () => {
						const {
							value: e
						} = this.props;
						if (!Object(f.v)(e)) return;
						const t = e.items[0],
							n = t.video;
						this.props.onChange(Object.assign(Object.assign({}, e), {
							items: [Object.assign(Object.assign({}, t), {
								video: Object.assign(Object.assign({}, n), {
									isMakeGif: !n.isMakeGif
								})
							})]
						}))
					}, this.dispatchAction = e => {
						const {
							value: t
						} = this.props, n = function(e, t) {
							switch (t.type) {
								case zr.SelectGalleryItem: {
									const {
										key: n
									} = t.payload;
									return Object.assign(Object.assign({}, e), {
										selectedKey: n
									})
								}
								case zr.SetGalleryItems: {
									const {
										items: n
									} = t.payload;
									return Object.assign(Object.assign({}, e), {
										items: n
									})
								}
								case zr.SetCaptionInput: {
									const {
										input: n
									} = t.payload, {
										selectedKey: s,
										items: o
									} = e;
									return s ? Object.assign(Object.assign({}, e), {
										items: o.map(e => e.uploadKey === s ? Object.assign(Object.assign({}, e), {
											caption: n
										}) : e)
									}) : e
								}
								case zr.SetURLInput: {
									const {
										input: n
									} = t.payload, {
										selectedKey: s,
										items: o
									} = e;
									return s ? Object.assign(Object.assign({}, e), {
										items: o.map(e => e.uploadKey === s ? Object.assign(Object.assign({}, e), {
											url: n
										}) : e)
									}) : e
								}
								case zr.SelectPrevMedia: {
									const {
										selectedKey: t,
										items: n
									} = e, s = n.findIndex(e => e.uploadKey === t);
									let o = -1 === s ? 0 : s - 1;
									return o < 0 && (o = n.length - 1), Object.assign(Object.assign({}, e), {
										selectedKey: n[o].uploadKey
									})
								}
								case zr.SelectNextMedia: {
									const {
										selectedKey: t,
										items: n
									} = e, s = n.findIndex(e => e.uploadKey === t), o = -1 === s ? 0 : (s + 1) % n.length;
									return Object.assign(Object.assign({}, e), {
										selectedKey: n[o].uploadKey
									})
								}
								default:
									return e
							}
						}(t, e);
						this.props.onChange(n)
					}, this.renderDropArea = (e, t) => {
						const {
							isPostPending: n,
							value: s,
							isImageGalleryCreationEnabled: r,
							uploads: i
						} = this.props;
						if (r && s.items.length >= 1) return o.a.createElement($i, {
							isOver: e,
							canDrop: t,
							dispatch: this.dispatchAction,
							mediaState: s,
							onFileInput: this.onFileInput,
							onRemoveUpload: this.onRemoveUpload,
							uploads: i
						}); {
							const i = this.getSingleUpload(),
								a = this.props.value.items[0],
								{
									isMakeGif: c = !1,
									makeGifDisableReason: l = null
								} = a && a.video || {},
								d = i && i.status === tt.a.FAILED,
								u = i && d ? Object(Yr.a)(i.error) : "",
								p = i && Object(sa.f)(i.metadata.mimetype);
							return s && p && i && !d ? o.a.createElement(Ta, {
								isPostSubmitPending: n,
								upload: i,
								mediaType: p,
								onRemove: this.props.toggleRemovePrompt,
								onCancelUpload: this.onCancelSingleMediaUpload,
								onShowThumbnailSelector: this.toggleThumbnailSelector,
								onMakeGifToggle: this.onMakeGifToggle,
								isMakeGifToggleOn: c,
								makeGifDisableReason: l
							}) : o.a.createElement(Oi, {
								lastErrorMsg: u,
								isOver: e,
								canDrop: t,
								onFileInput: this.onFileInput,
								allowMultiple: r
							})
						}
					}
				}
				componentDidMount() {
					document.addEventListener("paste", this.handlePaste)
				}
				componentWillUnmount() {
					document.removeEventListener("paste", this.handlePaste)
				}
				getSingleUpload() {
					const {
						items: e
					} = this.props.value, t = 1 === e.length && e[0];
					return t && this.props.uploads[t.uploadKey] || void 0
				}
				uploadMediaFiles(e, t) {
					this.props.startMediaGalleryUploads([...e], t)
				}
				render() {
					const {
						value: e
					} = this.props, {
						items: t
					} = e, n = this.getSingleUpload(), s = t[0], r = Object(f.v)(e), i = r && s.video.thumbnail || void 0;
					return o.a.createElement(za, null, o.a.createElement(na.a, {
						render: (e, t) => this.renderDropArea(e, t),
						onDrop: this.onFileDrop
					}), n && n.metadata.videoDuration && o.a.createElement(ta.a, {
						onSelect: this.onThumbnailSelect,
						onToggleModal: this.toggleThumbnailSelector,
						videoSource: n.metadata.localUrl,
						videoDuration: n.metadata.videoDuration,
						selected: i,
						isOpen: this.props.activeModalId === Ha
					}), this.props.activeModalId === Ma && o.a.createElement(Ba, {
						isVideo: r,
						onCanceled: this.props.toggleRemovePrompt,
						onConfirmed: this.onRemoveConfirmed
					}))
				}
			}
			var Ja = Wa(Ga),
				Qa = n("./src/reddit/actions/post.ts"),
				Za = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				Ya = n("./src/reddit/controls/OutboundLink/index.tsx"),
				Xa = n("./src/reddit/selectors/externalAccount.ts"),
				$a = n("./src/reddit/icons/fonts/Info/index.tsx"),
				ec = n("./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/Hint/index.m.less"),
				tc = n.n(ec);
			const nc = dt.a.wrapped($a.a, "Info", tc.a),
				sc = dt.a.div("TooltipContent", tc.a);
			var oc = e => o.a.createElement("div", {
					className: tc.a.Hint
				}, o.a.createElement(Ft.a, {
					className: tc.a.HoverTooltip,
					tooltipContentClass: tc.a.tooltipContentClass,
					text: o.a.createElement(sc, null, e.text)
				}), o.a.createElement(nc, null)),
				rc = n("./src/reddit/components/PostCreationForm/PostCreationFooter/PostSettings/index.m.less"),
				ic = n.n(rc);
			const ac = dt.a.wrapped(Za.a, "CheckboxInput", ic.a),
				cc = dt.a.wrapped(Ya.b, "ConnectAccountLink", ic.a),
				lc = dt.a.div("Container", ic.a),
				dc = dt.a.div("ContainerLeft", ic.a),
				uc = dt.a.div("ContainerRight", ic.a),
				pc = dt.a.div("CheckboxText", ic.a),
				mc = dt.a.div("Option", ic.a),
				hc = dt.a.wrapped(kt.a, "TextButton", ic.a),
				bc = dt.a.input("TextBox", ic.a),
				fc = dt.a.div("Wrapper", ic.a),
				gc = Object(i.c)({
					connectedTwitterAccount: Xa.a,
					currentSubredditOrProfile: E.o,
					currentUser: k.i,
					isDraftPending: S.g,
					isMediaUploadPending: w.P,
					isPostPending: w.hb,
					isPublicLink: w.J,
					postToTwitter: w.Y,
					sendReplies: w.ab,
					sharingLink: S.i,
					submissionType: w.a
				}),
				xc = Object(r.b)(gc, (e, t) => ({
					togglePostToTwitter: t => {
						e(a.y(t)), e((e, n) => O.v(n(), t))
					},
					toggleSendReplies: t => {
						e(a.z(t))
					},
					toggleDraftIsPublic: n => {
						e(F.s(n)), e(Object(F.r)(t.draftId)), e((e, s) => {
							const o = Object(S.h)(s(), t.draftId);
							o && O.g(s(), o, n)
						})
					},
					copyLink: t => e(Object(Qa.v)(t)),
					trackConnectAccountsClick: () => e((e, t) => O.b(t()))
				}), (e, t, n) => Object.assign(Object.assign(Object.assign(Object.assign({}, e), t), n), {
					onTogglePostToTwitter: () => t.togglePostToTwitter(!e.postToTwitter),
					onToggleSendReplies: () => t.toggleSendReplies(!e.sendReplies),
					onToggleDraftIsPublic: () => {
						t.toggleDraftIsPublic(!e.isPublicLink), e.isPublicLink || t.copyLink(e.sharingLink)
					},
					onCopyLink: () => t.copyLink(e.sharingLink)
				}));
			var yc = Object(E.t)()(xc(e => {
					const {
						connectedTwitterAccount: t,
						currentSubredditOrProfile: n,
						currentUser: s,
						draftId: r,
						submissionType: i
					} = e, a = !!n && !!n.isQuarantined, c = e.isDraftPending || e.isPostPending || e.isMediaUploadPending, d = i !== m.Jb.MEDIA && r, u = e.isPublicLink, p = s && s.hasUserProfile;
					return o.a.createElement(lc, null, o.a.createElement(dc, {
						className: e.className
					}, o.a.createElement($e.a, null, o.a.createElement(mc, null, o.a.createElement(ac, {
						disabled: c,
						name: "send-replies",
						onChange: e.onToggleSendReplies,
						value: e.sendReplies
					}, o.a.createElement(pc, null, l.fbt._("Send me post reply notifications", null, {
						hk: "3kNmey"
					}))))), p && t && o.a.createElement($e.a, null, o.a.createElement(mc, null, o.a.createElement(ac, {
						disabled: c || a,
						name: "post-to-twitter",
						onChange: e.onTogglePostToTwitter,
						value: e.postToTwitter
					}, o.a.createElement(pc, null, l.fbt._("Share this post on Twitter", null, {
						hk: "3SPI4V"
					}))))), p && !t && !a && o.a.createElement($e.a, null, o.a.createElement(cc, {
						href: "/settings#connected-accounts",
						isSponsored: !1,
						onClick: e.trackConnectAccountsClick,
						source: null
					}, l.fbt._("Connect accounts to share your post", null, {
						hk: "1nIuWp"
					})), o.a.createElement(oc, {
						text: l.fbt._("Connect a Twitter account in your User Settings. With a connected account you can choose to share new posts you make directly to Twitter.", null, {
							hk: "JRoQz"
						})
					}))), o.a.createElement(uc, {
						className: e.className
					}, d && o.a.createElement(fc, null, o.a.createElement(mc, null, o.a.createElement(ac, {
						name: "enable-public-link",
						onChange: e.onToggleDraftIsPublic,
						value: e.isPublicLink
					}, o.a.createElement(pc, null, l.fbt._("Enable public draft link", null, {
						hk: "1SpDgT"
					})), o.a.createElement(oc, {
						text: l.fbt._("This option will create a link to a preview of this draft. Anyone with this link will be able to see this draft. You can disable this link at any time.", null, {
							hk: "1r77YF"
						})
					})))), d && u && o.a.createElement($e.a, null, o.a.createElement(bc, {
						disabled: !0,
						value: e.sharingLink
					}), o.a.createElement(hc, {
						onClick: e.onCopyLink
					}, l.fbt._("Copy link", null, {
						hk: "22rywZ"
					})))))
				})),
				vc = n("./src/reddit/components/PostCreationForm/PostCreationFooter/index.m.less"),
				Cc = n.n(vc);
			const Ec = dt.a.div("Container", Cc.a);
			var Oc = e => o.a.createElement(Ec, null, o.a.createElement(yc, {
					draftId: e.draftId
				})),
				jc = n("./src/reddit/featureFlags/profileCollections.ts"),
				wc = n("./src/reddit/selectors/postCollection.ts"),
				Sc = n("./src/reddit/selectors/profile.ts"),
				_c = n("./src/reddit/components/PostCreationForm/PostCreationHeader/index.m.less"),
				kc = n.n(_c);
			const Tc = dt.a.div("CreateLabel", kc.a),
				Ic = dt.a.span("CountIndicator", kc.a),
				Pc = dt.a.wrapped(at.i, "LinkButton", kc.a),
				Mc = Pc,
				Nc = dt.a.div("CreatePostHeader", kc.a),
				Rc = Object(i.c)({
					canPostAsModerator: w.d,
					collectionsCount: e => {
						const t = Object(w.g)(e);
						let n = t.id;
						if (t.isProfile && Object(jc.a)(e)) {
							const s = Object(Sc.j)(e, {
								profileName: t.name
							});
							n = s && s.id
						}
						return n ? Object(wc.v)(e, {
							subredditId: n
						}) : 0
					},
					destSubredditAboutInfo: w.f,
					draftsCount: k.j,
					isPending: w.U
				});
			var Lc = Object(r.b)(Rc, e => ({
					showDraftsList: () => {
						e(F.p()), e(a.x(f.d))
					},
					showCollectionsList: () => {
						e(a.x(f.a))
					}
				}))(e => {
					const {
						canPostAsModerator: t,
						collectionsCount: n,
						destSubredditAboutInfo: s,
						draftsCount: r,
						isPending: i,
						showCollectionsList: a,
						showDraftsList: c,
						submissionType: d,
						submitMode: u
					} = e, p = d === m.Jb.CROSSPOST, h = p ? l.fbt._("Create a crosspost", null, {
						hk: "1oNF7H"
					}) : l.fbt._("Create a post", null, {
						hk: "4u8qEy"
					}), b = t && s && s.collectionsEnabled;
					return o.a.createElement(Nc, null, o.a.createElement(Tc, null, u === f.q.Draft ? l.fbt._("Edit draft", null, {
						hk: "oMgcW"
					}) : h), !p && o.a.createElement(o.a.Fragment, null, b && o.a.createElement(Mc, {
						onClick: a
					}, l.fbt._("Collections", null, {
						hk: "2FVot0"
					}), o.a.createElement(Ic, null, n)), o.a.createElement(Pc, {
						disabled: i,
						onClick: c
					}, l.fbt._("Drafts", null, {
						hk: "25z4rQ"
					}), o.a.createElement(Ic, null, r))))
				}),
				Ac = n("./src/reddit/actions/polls.ts"),
				Fc = n("./src/reddit/actions/postCreation/editorContent.ts"),
				Dc = n("./src/reddit/components/Governance/PollHelpText/index.m.less"),
				Bc = n.n(Dc);
			const Uc = Object(i.c)({
				subredditGovInfo: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(st.n)(e, {
						subredditId: n.id
					})
				},
				tokenName: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(st.q)(e, {
						subredditId: n.id
					})
				}
			});
			var Kc = Object(r.b)(Uc)((function(e) {
					const {
						subreddit: t,
						subredditGovInfo: n,
						tokenName: r
					} = e, i = n && n.polls ? n.polls.decisionThreshold : void 0;
					return o.a.createElement(s.Fragment, null, i && o.a.createElement(s.Fragment, null, o.a.createElement("div", {
						className: Bc.a.decisionThreholdAmount
					}, o.a.createElement(Ge.a, {
						className: Bc.a.token,
						subredditId: t.id
					}), Object(ze.b)(parseInt(i))), o.a.createElement("div", {
						className: Bc.a.decisionThresholdTitle
					}, l.fbt._("Decision Threshold", null, {
						hk: "39nut8"
					}))), o.a.createElement("div", {
						className: Bc.a.decisionThresholdExplanation
					}, l.fbt._("Governance Polls are auto-enacted when one option reaches the Decision Threshold. The Decision Threshold is based on the number {tokenName} that voted previously.", [l.fbt._param("tokenName", r)], {
						hk: "3U9qGh"
					})))
				})),
				Hc = n("./src/reddit/actions/tooltip.ts"),
				Vc = n("./src/reddit/controls/Dropdown/index.tsx"),
				Wc = n("./src/reddit/controls/Dropdown/Row.tsx"),
				zc = n("./src/reddit/selectors/experiments/pollsGA.ts"),
				qc = n("./src/reddit/icons/svgs/Grapple/index.tsx"),
				Gc = n("./src/reddit/components/PollCreator/Option/index.m.less"),
				Jc = n.n(Gc);

			function Qc(e) {
				return o.a.createElement("div", {
					className: Object(We.a)(e.className, Jc.a.container),
					style: {
						left: e.isDropTarget ? 16 : 0,
						opacity: Zc(e),
						pointerEvents: e.isDisabled ? "none" : void 0
					}
				}, o.a.createElement(qc.a, {
					className: Jc.a.grapple
				}), o.a.createElement("input", {
					className: Jc.a.input,
					maxLength: 120,
					placeholder: "".concat(l.fbt._("option", null, {
						hk: "3IGnB"
					}), " ").concat(e.index + 1),
					value: e.text,
					onBlur: e.onBlur,
					onChange: t => e.onTextChange(t.currentTarget.value),
					onFocus: e.onFocus
				}), e.removable && o.a.createElement(ps.a, {
					className: Jc.a.trash,
					onClick: e.onRemove
				}))
			}

			function Zc(e) {
				return e.isDisabled ? .5 : e.isBeingDragged ? .25 : 1
			}
			var Yc = n("./src/reddit/components/PollCreator/index.m.less"),
				Xc = n.n(Yc);
			const $c = 2,
				el = 6,
				tl = 7,
				nl = 7,
				sl = "poll-creation-voting-length";
			var ol;
			! function(e) {
				e.Options = "options", e.VotingLength = "votingLength"
			}(ol || (ol = {}));
			const rl = Object(Qt.a)(Vc.a),
				il = Object(i.c)({
					isInPollsGA: zc.a,
					votingLengthDropdownIsOpen: e => e.tooltipId === sl
				});
			class al extends o.a.Component {
				constructor(e) {
					super(e), this.handleAddOption = e => () => {
						const {
							sendEvent: t
						} = this.props;
						e.options.length < 7 && (t(Object(O.p)()), this.props.onUpdatePoll(Object.assign(Object.assign({}, e), {
							options: e.options.concat(this.makeOption())
						})))
					}, this.handleBlur = () => this.inputFocused = !1, this.handleVotingLengthDropdownClick = () => {
						const {
							sendEvent: e,
							votingLengthDropdownIsOpen: t
						} = this.props;
						t || e(Object(O.q)()), this.props.onToggleVotingLengthDropdown()
					}, this.handleChangeVotingLength = e => t => {
						this.props.onUpdatePoll(Object.assign(Object.assign({}, e), {
							duration: t
						})), this.props.onToggleVotingLengthDropdown()
					}, this.handleFocus = () => this.inputFocused = !0, this.handleOptionTextChange = (e, t) => n => {
						const s = e.options.indexOf(t);
						this.props.onUpdatePoll(Object.assign(Object.assign({}, e), {
							options: e.options.slice(0, s).concat({
								text: n
							}).concat(e.options.slice(s + 1))
						}))
					}, this.handleRemoveOption = (e, t) => () => {
						this.props.onUpdatePoll(Object.assign(Object.assign({}, e), {
							options: e.options.filter(e => e !== t)
						}))
					}, this.makeOption = () => ({
						text: ""
					}), this.makeDefaultPoll = () => {
						const {
							isInPollsGA: e
						} = this.props;
						return {
							duration: e ? 3 * m.x : m.x,
							options: Array.from({
								length: $c
							}).map(this.makeOption)
						}
					}, this.preventDrag = e => {
						this.inputFocused && (e.preventDefault(), e.stopPropagation())
					}, this.inputFocused = !1
				}
				componentDidMount() {
					document.addEventListener("dragstart", this.preventDrag), document.addEventListener("drop", this.preventDrag), document.addEventListener("dragover", this.preventDrag)
				}
				componentWillUnmount() {
					document.removeEventListener("dragstart", this.preventDrag), document.removeEventListener("drop", this.preventDrag), document.removeEventListener("dragover", this.preventDrag)
				}
				sectionIsDisabled(e) {
					return this.props.disabledSections && this.props.disabledSections.includes(e)
				}
				render() {
					const {
						className: e,
						poll: t = this.makeDefaultPoll()
					} = this.props;
					return o.a.createElement("div", {
						className: Object(We.a)(e, Xc.a.container)
					}, o.a.createElement("div", {
						className: Xc.a.options
					}, this.renderPollCreator(t), this.renderControls(t)), o.a.createElement("div", {
						className: Xc.a.help
					}, this.props.hintTextComponent))
				}
				renderPollCreator(e) {
					const t = this.sectionIsDisabled(ol.Options);
					return o.a.createElement(ti.a, {
						render: (n, s, r, i, a) => o.a.createElement(Qc, {
							className: Xc.a.option,
							index: s,
							isBeingDragged: r,
							isDisabled: t,
							isDropTarget: i && a,
							option: n,
							removable: s > 1,
							text: n.text,
							onBlur: this.handleBlur,
							onFocus: this.handleFocus,
							onTextChange: this.handleOptionTextChange(e, n),
							onRemove: this.handleRemoveOption(e, n)
						}),
						values: e.options,
						onDrop: (t, n, s) => this.props.onUpdatePoll(Object.assign(Object.assign({}, e), {
							options: s
						}))
					})
				}
				renderControls(e) {
					const {
						isInPollsGA: t
					} = this.props, n = e.options.length >= (t ? el : tl) || this.sectionIsDisabled(ol.Options), s = this.sectionIsDisabled(ol.VotingLength), r = Math.floor(e.duration / m.x);
					return o.a.createElement("div", {
						className: Xc.a.controls
					}, o.a.createElement(at.n, {
						className: Xc.a.addButton,
						disabled: n,
						onClick: this.handleAddOption(e)
					}, l.fbt._("add option", null, {
						hk: "3ki0bB"
					})), o.a.createElement("div", {
						className: Object(We.a)(Xc.a.votingLengthSelector, {
							[Xc.a.votingLengthSelector__disabled]: !!s
						})
					}, o.a.createElement("div", {
						className: Xc.a.votingLengthTitleText
					}, l.fbt._("Voting length:", null, {
						hk: "4pPVUg"
					})), o.a.createElement("div", {
						className: Xc.a.votingLengthDropdownContainer,
						id: sl
					}, o.a.createElement("div", {
						className: Xc.a.votingLengthDisplay,
						onClick: this.handleVotingLengthDropdownClick
					}, o.a.createElement("div", null, l.fbt._({
						"*": "{numDays} days",
						_1: "{numDays} day"
					}, [l.fbt._param("numDays", String(r)), l.fbt._plural(r)], {
						hk: "2HsFBA"
					})), o.a.createElement(Tn.a, {
						className: Xc.a.votingLengthCaret
					})), this.renderVotingLengthDropdown(e))))
				}
				renderVotingLengthDropdown(e) {
					const {
						votingLengthDropdownIsOpen: t
					} = this.props, n = this.handleChangeVotingLength(e);
					return o.a.createElement(rl, {
						className: Xc.a.votingLengthDropdown,
						tooltipId: sl,
						isOpen: t
					}, Array.from({
						length: nl
					}).map((t, s) => {
						const r = s + 1;
						return o.a.createElement(Wc.b, {
							"data-redditstyle": !0,
							key: s,
							index: s,
							displayText: l.fbt._({
								"*": "{number} days",
								_1: "1 day"
							}, [l.fbt._plural(r, "number")], {
								hk: "bXXYo"
							}),
							isSelected: Math.floor(e.duration / m.x) === r,
							onClick: () => n(r * m.x)
						})
					}))
				}
			}
			var cl = Object(r.b)(il, e => ({
					onToggleVotingLengthDropdown: () => e(Object(Hc.h)({
						tooltipId: sl
					}))
				}))(Object(xs.c)(al)),
				ll = n("./src/reddit/components/Governance/ProposalTemplates/Generic/index.m.less"),
				dl = n.n(ll);
			const ul = [{
				text: "Yes"
			}, {
				text: "No"
			}];

			function pl(e) {
				const t = {
					duration: e.poll ? e.poll.duration : m.x,
					options: e.options || ul
				};
				return o.a.createElement("div", {
					className: Object(We.a)(dl.a.container, e.className)
				}, o.a.createElement("div", {
					className: dl.a.topline
				}, e.children.map(e => "string" == typeof e ? o.a.createElement("div", {
					className: dl.a.text
				}, e) : e)), o.a.createElement(cl, {
					disabledSections: [ol.Options],
					hintTextComponent: o.a.createElement("div", {
						className: dl.a.hintText
					}, o.a.createElement(Kc, {
						subreddit: e.subreddit
					})),
					poll: t,
					onUpdatePoll: e.onUpdatePoll
				}))
			}
			var ml = n("./src/reddit/controls/FormFields/index.tsx"),
				hl = n("./src/reddit/components/Governance/ProposalTemplates/Spinoff/index.m.less"),
				bl = n.n(hl);
			const fl = 3,
				gl = 20,
				xl = /[^(\w|_)]/g;
			const yl = Object(i.c)({
				newSubredditName: e => e.creations.formData.newSubreddit
			});
			var vl = Object(r.b)(yl, e => ({
					onSubredditNameChange: t => e(Object(R.a)({
						subredditName: t
					}))
				}))((function(e) {
					return o.a.createElement(pl, {
						className: e.className,
						options: ce.f[ce.a.Spinoff](e.newSubredditName),
						poll: e.poll,
						subreddit: e.subreddit,
						onUpdatePoll: e.onUpdatePoll
					}, l.fbt._("Should we spin-off to", null, {
						hk: "3oKiyE"
					}), o.a.createElement(ml.c, {
						redditStyle: !0,
						className: bl.a.input,
						label: l.fbt._("subreddit name", null, {
							hk: "1qzJqB"
						}),
						max: gl,
						min: fl,
						type: "text",
						value: e.newSubredditName,
						onChange: t => {
							const n = t.currentTarget.value.replace(xl, "");
							e.onSubredditNameChange(n)
						}
					}), l.fbt._("?", null, {
						hk: "1b1vhH"
					}))
				})),
				Cl = n("./src/reddit/components/Governance/ProposalTemplates/TopModReplacement/index.m.less"),
				El = n.n(Cl);
			const Ol = 20;
			const jl = Object(i.c)({
				topMod: e => e.creations.formData.newTopMod
			});
			var wl = Object(r.b)(jl, e => ({
					onUsernameChange: t => e(Object(R.b)({
						username: t
					}))
				}))((function(e) {
					return o.a.createElement(pl, {
						className: e.className,
						options: ce.f[ce.a.ReplaceTopMod](),
						poll: e.poll,
						subreddit: e.subreddit,
						onUpdatePoll: e.onUpdatePoll
					}, l.fbt._("Should", null, {
						hk: "22RF0A"
					}), o.a.createElement(ml.c, {
						redditStyle: !0,
						className: El.a.input,
						label: l.fbt._("username", null, {
							hk: "1Fk03V"
						}),
						max: Ol,
						type: "text",
						value: e.topMod,
						onChange: t => e.onUsernameChange(t.currentTarget.value)
					}), l.fbt._("become the top moderator?", null, {
						hk: "4COtce"
					}))
				})),
				Sl = n("./src/reddit/icons/svgs/Info/index.tsx"),
				_l = n("./src/reddit/components/PollCreator/DefaultHintText/index.m.less"),
				kl = n.n(_l);
			const Tl = [() => l.fbt._("Suggest short clear options", null, {
				hk: "4bpIfe"
			}), () => l.fbt._("The more options, the better", null, {
				hk: "37GJUq"
			}), () => l.fbt._("Choose the poll duration", null, {
				hk: "2opBOc"
			}), () => l.fbt._("Options can't be edited after post creation", null, {
				hk: "3iRICg"
			})];

			function Il(e) {
				return o.a.createElement(s.Fragment, null, o.a.createElement("div", {
					className: kl.a.helpTitle
				}, o.a.createElement(Sl.a, {
					className: kl.a.infoIcon
				}), o.a.createElement("div", {
					className: kl.a.helpTitleText
				}, l.fbt._("Tips on Better Polls", null, {
					hk: "2QMuX9"
				}))), o.a.createElement("ol", {
					className: kl.a.helpTextList
				}, Tl.map(e => o.a.createElement("li", {
					className: kl.a.helpTextItem,
					key: e()
				}, e()))))
			}
			var Pl = n("./src/reddit/components/PostCreationForm/MarkdownEditor/index.tsx"),
				Ml = n("./src/reddit/components/RichTextEditor/index.tsx"),
				Nl = n("./src/reddit/featureFlags/component.tsx"),
				Rl = n("./src/reddit/helpers/richTextEditor/index.ts"),
				Ll = n("./src/reddit/models/PostRequirements/index.ts"),
				Al = n("./src/reddit/icons/svgs/GovSmall/index.tsx"),
				Fl = n("./src/reddit/icons/svgs/Poll/index.tsx"),
				Dl = n("./src/reddit/components/PostCreationForm/PostEditor/GovTypeSelector/index.m.less"),
				Bl = n.n(Dl);
			const Ul = Object(Qt.a)(Vc.a),
				Kl = [{
					Icon: Fl.a,
					showNewTag: !0,
					text: () => l.fbt._("general", null, {
						hk: "2zk1er"
					}),
					type: null
				}, {
					Icon: Al.a,
					showNewTag: !1,
					text: () => l.fbt._("governance", null, {
						hk: "1wlLfQ"
					}),
					type: ce.a.GovGeneric
				}, {
					Icon: Al.a,
					showNewTag: !1,
					text: () => l.fbt._("spin-off a new community", null, {
						hk: "jNK0c"
					}),
					type: ce.a.Spinoff
				}],
				Hl = "gov-type-selector-dropdown";
			const Vl = Object(i.c)({
				dropdownIsOpen: e => e.tooltipId === Hl,
				govType: e => e.creations.formData.govType,
				spinoffEnabled: oe.d.spSpinoffs
			});
			var Wl = Object(r.b)(Vl, e => ({
					onChangeGovType: (t, n) => {
						e(Object(a.j)({
							oldType: n,
							type: t
						})), e(Object(Hc.i)())
					},
					onToggleDropdown: () => e(Object(Hc.h)({
						tooltipId: Hl
					}))
				}))((function(e) {
					const t = function(e, t) {
							return Kl.filter(e => {
								let {
									type: n
								} = e;
								return !(!t.spinoffEnabled && n === ce.a.Spinoff)
							})
						}(0, e),
						n = t.find(t => t.type === e.govType) || t[0];
					return o.a.createElement("div", {
						className: Object(We.a)(Bl.a.container, e.className)
					}, o.a.createElement("div", {
						className: Bl.a.currentSelection,
						id: Hl,
						onClick: e.onToggleDropdown
					}, o.a.createElement(n.Icon, {
						className: Bl.a.pollTypeIcon
					}), o.a.createElement("div", {
						className: Bl.a.text
					}, n.text()), o.a.createElement(Tn.a, {
						className: Bl.a.dropdownIcon
					}), n.showNewTag && o.a.createElement("div", {
						className: Bl.a.newLabel
					}, l.fbt._("new", null, {
						hk: "4iv34v"
					}))), o.a.createElement(Ul, {
						className: Bl.a.dropdown,
						tooltipId: Hl,
						isOpen: e.dropdownIsOpen
					}, t.map((t, s) => o.a.createElement(Wc.b, {
						"data-redditstyle": !0,
						displayText: t.text(),
						isSelected: t.type === n.type,
						key: s,
						onClick: () => e.onChangeGovType(t.type, e.govType)
					}))))
				})),
				zl = n("./src/reddit/components/PostCreationForm/PostEditor/index.m.less"),
				ql = n.n(zl);
			const Gl = Object(Nl.a)("spGovPolls", Wl),
				Jl = (e, t) => !e && t && t.bodyRestrictionPolicy === Ll.a.Required,
				Ql = Object(i.c)({
					canPostAsModerator: w.d,
					destSubreddit: w.g,
					draft: S.d,
					editorMode: w.m,
					govType: e => e.creations.formData.govType,
					markdownBody: w.N,
					pending: w.U,
					poll: e => e.creations.formData.polls || void 0,
					postCreationFieldErrors: Rn,
					postRequirements: w.ib,
					rteState: w.Z,
					shouldAllowBodyText: w.bb,
					subreddit: E.q
				}),
				Zl = Object(r.b)(Ql, (e, t) => {
					let {
						onChange: n,
						onPostFieldValidation: s,
						pageLayer: o
					} = t;
					return {
						onBlur: () => {
							s(e(St(m.nb.BODY, o)))
						},
						onFocus: () => e((e, t) => O.n(t(), f.k.CLICK, f.l.BODY)),
						onRTEStateChange: (t, s) => {
							e(a.e({
								rteState: t,
								isContentChanged: s
							})), n()
						},
						onToggleEditorMode: (t, n) => e(Fc.d(f.g.POST_CREATION, t, n)),
						onTrackToolbarClick: (t, n) => e((e, s) => O.z(s(), t, n)),
						onUpdatePoll: t => e(Object(Ac.b)(t))
					}
				});
			class Yl extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {}, this.onEditorResize = e => {
						this.setState({
							editorHeight: e
						})
					}, this.onToggleEditorMode = async (e, t) => {
						await this.props.onToggleEditorMode(e, t), e === f.h.RICH_TEXT ? this.rteRef && this.rteRef.focus() : this.markdownEditorRef && this.markdownEditorRef.focus()
					}, this.setRteRef = e => this.rteRef = e, this.setMarkdownEditorRef = e => this.markdownEditorRef = e
				}
				renderEditor() {
					const {
						canPostAsModerator: e,
						destSubreddit: t,
						displayPollCreation: n,
						editorMode: s,
						markdownBody: r,
						pending: i,
						postCreationFieldErrors: a,
						postRequirements: c,
						rteState: d,
						subreddit: u
					} = this.props, p = a[m.nb.BODY].length > 0, h = !!u && u.isNSFW, b = Jl(e, c) ? l.fbt._("Text (required)", null, {
						hk: "E1dIP"
					}) : l.fbt._("Text (optional)", null, {
						hk: "4jfNex"
					}), g = h;
					return s === f.h.RICH_TEXT ? o.a.createElement(Ml.a, {
						allowMediaUploads: !g,
						focusableContentRTEClassName: Object(We.a)(ql.a.focusableContent, {
							[ql.a.mHasError]: p,
							[ql.a.mPollBorder]: !!n
						}),
						destSubreddit: t,
						editorType: Rl.a.Post,
						initialHeight: this.state.editorHeight,
						rteState: d,
						onBlur: this.props.onBlur,
						onChange: this.props.onRTEStateChange,
						onEditorResize: this.onEditorResize,
						onFocus: this.props.onFocus,
						onSubmit: this.props.onSubmit,
						onSwitchEditorMode: this.onToggleEditorMode,
						placeholderText: b,
						readOnly: i,
						rteRef: this.setRteRef,
						trackToolbarClick: this.props.onTrackToolbarClick
					}) : o.a.createElement(Pl.a, {
						focusableContentMarkdownClassName: Object(We.a)(ql.a.focusableContent, {
							[ql.a.mHasError]: p,
							[ql.a.mPollBorder]: !!n
						}),
						initialHeight: this.state.editorHeight,
						instanceRef: this.setMarkdownEditorRef,
						onBlur: this.props.onBlur,
						onChange: this.props.onChange,
						onEditorResize: this.onEditorResize,
						onFocus: this.props.onFocus,
						value: r,
						onSubmit: this.props.onSubmit,
						onSwitchEditorMode: this.onToggleEditorMode,
						placeholderText: b
					})
				}
				render() {
					const {
						displayPollCreation: e,
						postCreationFieldErrors: t,
						shouldAllowBodyText: n,
						subreddit: s
					} = this.props;
					return o.a.createElement("div", null, n && this.renderEditor(), n && e && o.a.createElement("div", {
						className: ql.a.pollCreator
					}, o.a.createElement(Gl, {
						className: ql.a.govToggle
					}), this.govType()), o.a.createElement(Qe.a, {
						errorModalTitle: s ? Object(J.b)(s.name) : void 0,
						messages: t[m.nb.BODY]
					}))
				}
				govType() {
					const {
						govType: e,
						poll: t,
						subreddit: n
					} = this.props;
					switch (e) {
						case ce.a.ReplaceTopMod:
							return n ? o.a.createElement(wl, {
								poll: t,
								subreddit: n,
								onUpdatePoll: this.props.onUpdatePoll
							}) : o.a.createElement(cl, {
								hintTextComponent: o.a.createElement(Il, null),
								poll: t,
								onUpdatePoll: this.props.onUpdatePoll
							});
						case ce.a.GovGeneric:
							return o.a.createElement(cl, {
								hintTextComponent: n ? o.a.createElement(Kc, {
									subreddit: n
								}) : o.a.createElement(Il, null),
								poll: t,
								onUpdatePoll: this.props.onUpdatePoll
							});
						case ce.a.Spinoff:
							return n ? o.a.createElement(vl, {
								poll: t,
								subreddit: n,
								onUpdatePoll: this.props.onUpdatePoll
							}) : o.a.createElement(cl, {
								hintTextComponent: o.a.createElement(Il, null),
								poll: t,
								onUpdatePoll: this.props.onUpdatePoll
							});
						case ce.a.GA:
						case null:
							return o.a.createElement(cl, {
								hintTextComponent: o.a.createElement(Il, null),
								poll: t,
								onUpdatePoll: this.props.onUpdatePoll
							})
					}
				}
			}
			var Xl = Object(E.t)({
					draftId: E.u,
					pageLayer: e => e
				})(Zl(Yl)),
				$l = n("./src/reddit/components/PostCreationForm/PostTitle/index.m.less"),
				ed = n.n($l);
			const td = Object(i.c)({
					canPostAsModerator: w.d,
					disableTitleEdits: e => e.creations.formData.govType === ce.a.ReplaceTopMod || e.creations.formData.govType === ce.a.Spinoff,
					pending: w.U,
					postCreationFieldErrors: Rn,
					postRequirements: w.ib,
					shouldAllowBodyText: w.bb,
					submissionType: w.a,
					subreddit: E.q,
					title: w.kb
				}),
				nd = Object(r.b)(td, (e, t) => {
					let {
						onChange: n,
						onPostFieldValidation: s,
						pageLayer: o
					} = t;
					return {
						onBlur: () => {
							s(e(St(m.nb.TITLE, o)))
						},
						onChange: t => {
							e(a.h(t)), n(t)
						},
						onInputFocus: () => e((e, t) => O.n(t(), f.k.CLICK, f.l.TITLE))
					}
				});
			var sd = Object(E.t)()(nd(e => {
					const {
						canPostAsModerator: t,
						postRequirements: n,
						postCreationFieldErrors: s,
						subreddit: r
					} = e, i = e.submissionType === m.Jb.POST && !e.shouldAllowBodyText, a = s[m.nb.TITLE].length > 0, c = t ? Wt.f : n && n.titleTextMaxLength || Wt.f;
					return o.a.createElement("div", {
						className: ed.a.container
					}, o.a.createElement("div", {
						className: ed.a.inputWrapper
					}, o.a.createElement(Ur, {
						className: Object(We.a)(ed.a.PostTitleInput, {
							[ed.a.mHasError]: a
						}),
						disabled: e.disableTitleEdits,
						maxLength: c,
						minHeight: i ? 92 : void 0,
						onBlur: e.onBlur,
						onFocus: e.onInputFocus,
						onKeyDown: e.onKeyDown,
						onValueChange: e.onChange,
						placeholder: l.fbt._("Title", null, {
							hk: "j3s6r"
						}),
						readOnly: e.pending,
						value: e.title
					}), o.a.createElement("div", {
						className: ed.a.charsCounter
					}, e.title.length, "/", c)), o.a.createElement(Qe.a, {
						errorModalTitle: r ? Object(J.b)(r.name) : void 0,
						messages: s[m.nb.TITLE]
					}))
				})),
				od = n("./src/reddit/components/PostCreationForm/Prompt/index.tsx");
			const rd = "g-recaptcha",
				id = "image",
				ad = {
					COMPACT: "compact",
					NORMAL: "normal"
				},
				cd = () => new Promise(e => {
					if (window.grecaptcha) return e(window.grecaptcha);
					window.grecaptchaOnLoad = () => e(window.grecaptcha);
					const t = document.createElement("script");
					t.src = "https://www.google.com/recaptcha/api.js?onload=grecaptchaOnLoad&render=explicit", document.body.appendChild(t)
				});
			class ld extends o.a.Component {
				shouldComponentUpdate() {
					return !1
				}
				componentDidMount() {
					const {
						callback: e,
						size: t,
						type: n
					} = this.props;
					cd().then(s => {
						s.render(rd, {
							callback: e,
							type: n,
							sitekey: U.a.recaptchaSitekey,
							size: t || ad.COMPACT
						})
					})
				}
				componentWillReceiveProps(e) {
					this.props.submissionPending && !e.submissionPending && cd().then(e => {
						e.reset()
					})
				}
				render() {
					return o.a.createElement("div", {
						className: "Recaptcha",
						id: rd
					})
				}
			}
			var dd = n("./src/reddit/components/PostCreationForm/RecaptchaOverlay/index.m.less"),
				ud = n.n(dd);
			const {
				fbt: pd
			} = n("./node_modules/fbt/lib/FbtPublic.js"), md = dt.a.div("OverlayWrapper", ud.a), hd = dt.a.div("OverlayContent", ud.a), bd = dt.a.div("ExplanationText", ud.a);
			var fd = Object(r.b)(void 0, (e, t) => ({
				onChange: n => {
					e(a.f(n)), t.callback(n)
				}
			}))(e => o.a.createElement(md, null, o.a.createElement(hd, null, o.a.createElement(bd, null, pd._("Ok, one more thing ... you're human, right?", null, {
				hk: "2xDwBB"
			})), o.a.createElement(ld, {
				submissionPending: !0,
				callback: e.onChange,
				size: ad.NORMAL,
				type: id
			}))));
			const gd = "POST_CREATION__CONFIRM_SAVE_DRAFT_WITH_LIMITATIONS";

			function xd(e) {
				const {
					hasEventSchedule: t,
					hasRichPostMedia: n
				} = e;
				let s = l.fbt._("Saving this draft will not save media and the applied event schedule, all other information will be saved", null, {
					hk: "3NIEQF"
				});
				return n && !t ? s = l.fbt._("Saving this draft will not save media, all other information will be saved", null, {
					hk: "2tpNPY"
				}) : !n && t && (s = l.fbt._("Saving this draft will not save the applied event schedule, all other information will be saved", null, {
					hk: "3wm3T3"
				})), o.a.createElement(Ne.a, {
					bodyText: s,
					onClose: e.onCancel,
					onPrimaryAction: e.onConfirm,
					onSecondaryAction: e.onCancel,
					primaryButtonText: l.fbt._("Save", null, {
						hk: "1YTiSI"
					}),
					secondaryButtonText: l.fbt._("Cancel", null, {
						hk: "2TSLl5"
					}),
					titleText: l.fbt._("Save draft", null, {
						hk: "1RxZQJ"
					})
				})
			}
			var yd = n("./src/reddit/components/PostCreationForm/SubredditChangePrompt/index.m.less"),
				vd = n.n(yd);
			const Cd = {
					[f.p.ImageWillBeRemoved]: {
						removePromptTitle: () => l.fbt._("Remove image?", null, {
							hk: "3Pk53F"
						}),
						removeConfirm: () => l.fbt._("Change and remove image", null, {
							hk: "Ik8BT"
						}),
						removeCancel: () => l.fbt._("Keep image", null, {
							hk: "1e7FY0"
						}),
						details: e => l.fbt._("Aw crap, {sureddit name} doesn't allow images. If you change to {suredditName} your image will be removed.", [l.fbt._param("sureddit name", "r/".concat(e)), l.fbt._param("suredditName", "r/".concat(e))], {
							hk: "1zQOEn"
						})
					},
					[f.p.VideoWillBeRemovedMediaNotAllowed]: {
						removePromptTitle: () => l.fbt._("Remove video?", null, {
							hk: "12xLOq"
						}),
						removeConfirm: () => l.fbt._("Change and remove video", null, {
							hk: "3izwIJ"
						}),
						removeCancel: () => l.fbt._("Keep video", null, {
							hk: "32ZDlX"
						}),
						details: e => l.fbt._("Aw crap, {sureddit name} doesn't allow videos. If you change to {suredditName} your video will be removed.", [l.fbt._param("sureddit name", "r/".concat(e)), l.fbt._param("suredditName", "r/".concat(e))], {
							hk: "1sxEJG"
						})
					},
					[f.p.VideoWillBeRemovedTooLongForGif]: {
						removePromptTitle: () => l.fbt._("Remove video?", null, {
							hk: "12xLOq"
						}),
						removeConfirm: () => l.fbt._("Change and remove video", null, {
							hk: "3izwIJ"
						}),
						removeCancel: () => l.fbt._("Keep video", null, {
							hk: "32ZDlX"
						}),
						details: e => l.fbt._("Aw crap, {sureddit name} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF. If you change to {suredditName} your video will be removed.", [l.fbt._param("sureddit name", "r/".concat(e)), l.fbt._param("suredditName", "r/".concat(e))], {
							hk: "34j8hI"
						})
					},
					[f.p.GalleryWillBeRemovedGalleryNotAllowed]: {
						removePromptTitle: () => l.fbt._("Remove gallery?", null, {
							hk: "4mddlm"
						}),
						removeConfirm: () => l.fbt._("Change and remove gallery", null, {
							hk: "2JB1HN"
						}),
						removeCancel: () => l.fbt._("Keep gallery", null, {
							hk: "26kW19"
						}),
						details: e => l.fbt._("Aw crap, {sureddit name} doesn't allow galleries. If you change to {suredditName} your gallery will be removed.", [l.fbt._param("sureddit name", "r/".concat(e)), l.fbt._param("suredditName", "r/".concat(e))], {
							hk: "11irkw"
						})
					}
				},
				Ed = dt.a.div("Wrapper", vd.a),
				Od = dt.a.wrapped($e.a, "TitleRow", vd.a),
				jd = dt.a.div("DetailsContainer", vd.a),
				wd = dt.a.wrapped($e.a, "ButtonRow", vd.a),
				Sd = dt.a.wrapped(at.f, "CancelButton", vd.a),
				_d = dt.a.wrapped(at.i, "ConfirmButton", vd.a);
			var kd = Object(ho.a)(e => {
					const {
						promptType: t,
						nextSubreddit: n
					} = e, s = Cd[t];
					return o.a.createElement(Ed, null, o.a.createElement(Od, null, s.removePromptTitle()), o.a.createElement(jd, null, s.details(n.name)), o.a.createElement(wd, null, o.a.createElement(_d, {
						onClick: e.onConfirmed
					}, s.removeConfirm()), o.a.createElement(Sd, {
						onClick: e.onCanceled
					}, s.removeCancel())))
				}),
				Td = n("./src/lib/filterQueryParams/index.ts"),
				Id = n("./src/reddit/selectors/gold/powerups.ts"),
				Pd = n("./src/reddit/icons/svgs/FormattingHyperlink/index.tsx"),
				Md = n("./src/reddit/icons/svgs/Media/index.tsx"),
				Nd = n("./src/reddit/icons/svgs/Text/index.tsx"),
				Rd = n("./src/reddit/components/PostCreationForm/Tabs/index.m.less"),
				Ld = n.n(Rd);
			const Ad = e => dt.a.wrapped(e, "Component", Ld.a),
				Fd = Ad(Pd.a),
				Dd = Ad(Md.a),
				Bd = dt.a.wrapped(Fl.a, "PollIcon", Ld.a),
				Ud = Ad(Nd.a),
				Kd = dt.a.div("Container", Ld.a),
				Hd = e => o.a.createElement("button", {
					className: Object(We.a)(Ld.a.Tab, e.className, {
						[Ld.a.isActive]: e.active
					}),
					disabled: e.disabled,
					onClick: e.onClick
				}, e.children),
				Vd = Object(i.a)(w.d, w.g, w.p, w.K, w.U, E.q, (e, t) => {
					const n = Object(E.m)(e, t);
					return !!n && Object(Id.i)(e, {
						subredditId: n
					})
				}, (e, t, n, s, o, r, i) => {
					const {
						images: a = !0,
						links: c = !0,
						text: l = !0,
						videos: d = !0,
						polls: u = !0
					} = t.allowedPostTypes || {}, p = !!r && r.isNSFW;
					return {
						link: o || !c || s && !Object(ue.g)("links", n),
						media: !d && !a && !e || o || p && !i || s && !Object(ue.g)("images", n),
						post: !l && !e || o || s && !Object(ue.g)("text", n),
						poll: !u && !e || s && !Object(ue.g)("polls", n)
					}
				}),
				Wd = Object(i.c)({
					canCreatePoll: (e, t) => {
						const n = Object(E.m)(e, t),
							s = !!Object(E.j)(e, t);
						return n ? Object(st.i)(e, {
							subredditId: n
						}) : !s
					},
					canPostAsModerator: w.d,
					destSubreddit: w.g,
					govType: e => e.creations.formData.govType,
					isTabsDisabled: Vd,
					pending: w.U,
					submissionType: w.a,
					subreddit: E.q,
					isImageGalleryCreationEnabled: w.G
				}),
				zd = Object(r.b)(Wd, (e, t) => ({
					onChange: (n, s) => {
						e(a.g({
							submissionType: n,
							extra: s
						})), e((e, t) => O.s(t(), n)), e(a.v(n === m.Jb.POLL)), ((e, t, n) => {
							if (!t) return;
							const s = Object(Td.a)(t.url, n);
							t.url !== s && e(Object(p.c)(s))
						})(e, t.pageLayer, ["url", "media", "onlyTitle", "text", "selftext"])
					}
				}));
			class qd extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.onPostTabClick = () => {
						this.props.isTabsDisabled.post || this.props.onChange(m.Jb.POST, {
							govType: this.props.govType
						})
					}, this.onMediaTabClick = () => {
						this.props.isTabsDisabled.media || this.props.onChange(m.Jb.MEDIA, {
							govType: this.props.govType
						})
					}, this.onLinkTabClick = () => {
						this.props.isTabsDisabled.link || this.props.onChange(m.Jb.LINK_ONLY, {
							govType: this.props.govType
						})
					}, this.onPollTabClick = () => {
						this.props.isTabsDisabled.poll || this.props.onChange(m.Jb.POLL, {
							govType: this.props.govType
						})
					}
				}
				render() {
					const {
						canCreatePoll: e,
						destSubreddit: t,
						isTabsDisabled: n,
						submissionType: s,
						isImageGalleryCreationEnabled: r
					} = this.props, {
						name: i = "",
						allowedPostTypes: a
					} = t, {
						images: c = !0,
						videos: d = !0
					} = a || {};
					let u = l.fbt._("{imageOrImages} & Video", [l.fbt._param("imageOrImages", r ? "Images" : "Image")], {
						hk: "yYdjl"
					});
					return c && !d ? u = r ? l.fbt._("Images", null, {
						hk: "3fSX8N"
					}) : l.fbt._("Image", null, {
						hk: "uFHQ1"
					}) : d && !c && (u = l.fbt._("Video", null, {
						hk: "3w6DFr"
					})), o.a.createElement(Kd, null, o.a.createElement($e.a, null, o.a.createElement(Hd, {
						active: s === m.Jb.POST,
						disabled: n.post,
						onClick: this.onPostTabClick
					}, o.a.createElement(Ud, null), l.fbt._("Post", null, {
						hk: "ozUj2"
					})), o.a.createElement(Hd, {
						active: s === m.Jb.MEDIA,
						disabled: n.media,
						onClick: this.onMediaTabClick
					}, n.media && o.a.createElement(Ft.a, {
						text: l.fbt._("Images and videos are not allowed in {subreddit name}", [l.fbt._param("subreddit name", "r/".concat(i))], {
							hk: "2uC6BP"
						})
					}), o.a.createElement(Dd, null), u), o.a.createElement(Hd, {
						active: s === m.Jb.LINK_ONLY,
						disabled: n.link,
						onClick: this.onLinkTabClick
					}, o.a.createElement(Fd, null), l.fbt._("Link", null, {
						hk: "1pbEKv"
					})), e && o.a.createElement(Hd, {
						active: s === m.Jb.POLL,
						disabled: n.poll,
						onClick: this.onPollTabClick
					}, o.a.createElement(Bd, null), l.fbt._("Poll", null, {
						hk: "SQdo4"
					}))))
				}
			}
			var Gd = Object(E.t)()(zd(qd)),
				Jd = n("./src/reddit/components/PostCreationForm/index.m.less"),
				Qd = n.n(Jd);
			const Zd = dt.a.div("FormContent", Qd.a),
				Yd = dt.a.wrapped(y.a, "CrosspostBox", Qd.a),
				Xd = dt.a.div("FormContainer", Qd.a),
				$d = dt.a.div("TabContent", Qd.a),
				eu = dt.a.div("PostingGuidelines", Qd.a),
				tu = Object(E.t)({
					draftId: E.u,
					isPostCreationPage: E.D,
					pageLayer: e => e,
					sourcePostId: e => Object(E.T)(e).source_id
				}),
				nu = Object(i.c)({
					submissionType: w.a,
					allowNavigationCallback: j.a,
					contributorRequestPending: e => Object(_.h)(e, g.e.Post),
					discardGoesBack: (e, t) => {
						let {
							pageLayer: n
						} = t;
						const s = Object(E.Q)(e, {
							pageLayer: n
						});
						return !!s && "/" === s[0]
					},
					draft: S.d,
					draftsCount: k.j,
					editorMode: w.m,
					eventSchedule: w.o,
					includeUserProfile: k.f,
					isChanged: w.B,
					isNameEditable: k.J,
					isPostSubmitEnabled: Ws,
					isScheduledPost: w.K,
					flair: w.r,
					hasError: w.t,
					havePostContent: w.y,
					linkBody: w.M,
					markdownBody: w.N,
					rteBody: w.Z,
					maxDrafts: k.R,
					modalId: w.Q,
					needsCaptcha: w.R,
					nextSubreddit: w.S,
					pending: w.U,
					postRequirements: w.ib,
					sourcePostRoot: w.db,
					submitMode: w.gb,
					subredditOrProfile: E.o,
					title: w.kb,
					uploads: e => e.uploads
				});
			class su extends o.a.Component {
				constructor(e) {
					super(e), this.postFieldValidationPending = null, this.sendStartTypingInputBodyEvent = u()(() => this.props.onStartTypingInput(f.l.BODY)), this.sendStartTypingInputTitleEvent = u()(() => this.props.onStartTypingInput(f.l.TITLE)), this.sendStartTypingInputUrlEvent = u()(() => this.props.onStartTypingInput(f.l.URL)), this.onExternalAccountConnected = () => {
						this.props.onExternalAccountsDataRequested()
					}, this.onRecaptchaSucceeded = () => {
						this.props.onSubmit(this.props.submitMode, this.postFieldValidationPending)
					}, this.onDiscardPromptOnNavigationConfirm = () => {
						this.props.onTrackDiscardButtonClick(), this.props.discardGoesBack || this.props.onDiscardPromptOnNavigationConfirmed(), this.props.allowNavigationCallback && this.props.allowNavigationCallback(!0)
					}, this.onDiscardPromptOnNewPostConfirm = () => {
						this.props.onTrackDiscardButtonClick(), this.props.onToggleModal(f.c), this.props.onDiscardPromptOnCreatePostConfirmed()
					}, this.onDiscardPromptAbort = () => {
						this.props.onToggleModal(this.props.modalId), this.props.allowNavigationCallback && this.props.allowNavigationCallback(!1)
					}, this.onDiscardPromptSaveDraft = () => {
						this.props.onToggleModal(this.props.modalId), this.onSaveDraft()
					}, this.handleKeyDown = e => {
						const {
							ctrlKey: t,
							metaKey: n,
							keyCode: s
						} = e;
						(t || n) && s === h.a.Enter && this.onSubmit()
					}, this.onSubredditChangePromptConfirmed = () => {
						this.props.nextSubreddit && (this.props.onCancelAndRemoveMediaUpload(), this.props.onRedirectToSubreddit(this.props.nextSubreddit))
					}, this.onSubmit = () => {
						const {
							isPostSubmitEnabled: e,
							isScheduledPost: t,
							onSubmit: n
						} = this.props;
						e && n(t ? f.q.ScheduledPost : f.q.Post, this.postFieldValidationPending)
					}, this.onSaveDraft = async () => {
						const {
							draftId: e,
							draftsCount: t,
							eventSchedule: n,
							maxDrafts: s,
							onToggleModal: o
						} = this.props;
						!e && t >= s ? o(od.a.MAX_DRAFTS_MODAL_ID) : n || this.hasRichPostMedia() ? o(gd) : this.props.onSubmit(f.q.Draft, this.postFieldValidationPending)
					}, this.tryLoadDraft = e => {
						this.props.isChanged ? (this.setState({
							draftToLoad: e
						}), this.props.onToggleModal(od.a.LOAD_DRAFT_MODAL_ID)) : (this.props.onToggleModal(f.d), this.onLoadDraft(e))
					}, this.onLoadDraft = e => {
						e && this.props.onLoadDraft(e)
					}, this.onSelectCollection = e => {
						this.props.onSetDestCollection(e.id)
					}, this.onPromptCancel = e => {
						this.props.onToggleModal(e)
					}, this.onToggleCurrentModal = () => {
						this.props.modalId && this.props.onToggleModal(this.props.modalId)
					}, this.onPromptConfirm = e => {
						switch (e) {
							case od.a.LOAD_DRAFT_MODAL_ID:
								this.props.onToggleModal(e), this.onLoadDraft(this.state.draftToLoad);
								break;
							case od.a.MAX_DRAFTS_MODAL_ID:
								this.props.onRequestDraftList(), this.props.onToggleModal(f.d);
								break;
							default:
								this.props.onToggleModal(e)
						}
					}, this.onConfirmSavingDraftWithLimitations = () => {
						this.onToggleCurrentModal(), this.props.onSubmit(f.q.Draft, this.postFieldValidationPending)
					}, this.onToggleCollectionListModal = () => {
						this.props.onToggleModal(f.a)
					}, this.onCollectionCreated = e => {
						this.onToggleCurrentModal(), this.onSelectCollection(e)
					}, this.onDraftListClose = () => {
						this.props.onToggleModal(f.d)
					}, this.onPostFieldValidation = e => {
						this.postFieldValidationPending = e
					}, this.state = {
						draftToLoad: null
					}
				}
				componentDidMount() {
					Object(b.d)(b.a.PostComposer), this.externalAccountEventsChannel = Object(Te.a)(), this.externalAccountEventsChannel.addEventListener("message", this.onExternalAccountConnected), this.props.isNameEditable && this.props.startChangeUsernameFlow()
				}
				componentWillUnmount() {
					Object(b.b)(b.a.PostComposer), this.externalAccountEventsChannel && this.externalAccountEventsChannel.close(), this.props.onUnmount()
				}
				hasRichPostMedia() {
					const {
						rteBody: e,
						submissionType: t
					} = this.props;
					return t === m.Jb.POST && e.isBound && Object(C.j)(e.editorState.getCurrentContent())
				}
				renderActiveForm() {
					switch (this.props.submissionType) {
						case m.Jb.POST:
						case m.Jb.POLL:
							return o.a.createElement(Xl, {
								displayPollCreation: this.props.submissionType === m.Jb.POLL,
								onChange: this.sendStartTypingInputBodyEvent,
								onPostFieldValidation: this.onPostFieldValidation,
								onSubmit: this.onSubmit
							});
						case m.Jb.MEDIA:
							return o.a.createElement(Ja, null);
						case m.Jb.LINK_ONLY:
							return o.a.createElement(qr, {
								onChange: this.sendStartTypingInputUrlEvent,
								onKeyDown: this.handleKeyDown,
								onPostFieldValidation: this.onPostFieldValidation
							});
						case m.Jb.CROSSPOST: {
							const {
								sourcePostRoot: e
							} = this.props;
							return e && o.a.createElement(Yd, {
								postId: e.id,
								mediaProps: {
									isExpando: !1,
									isListing: !1,
									isNotCardView: !0,
									post: e,
									primaryContent: !1,
									showCentered: !0,
									showFull: !0,
									shouldLoad: !0,
									shouldPause: !1
								}
							})
						}
						default:
							return "Invalid submissionType"
					}
				}
				render() {
					const {
						contributorRequestPending: e,
						draftId: t,
						includeUserProfile: n,
						modalId: s,
						needsCaptcha: r,
						nextSubreddit: i,
						postRequirements: a,
						sourcePostId: c,
						sourcePostRoot: d,
						submissionType: u,
						submitMode: p,
						subredditOrProfile: h
					} = this.props;
					if (u === m.Jb.CROSSPOST) {
						if (!d) return o.a.createElement(x.b, {
							message: l.fbt._("The original post cannot be found", null, {
								hk: "3ieS5B"
							})
						});
						if (!d.isCrosspostable || d.isSponsored) return o.a.createElement(x.a, {
							message: l.fbt._("The original post cannot be crossposted", null, {
								hk: "4hn9ht"
							})
						})
					}
					const b = a && a.guidelinesText && a.guidelinesText.trim() || "";
					return o.a.createElement(Xd, null, o.a.createElement(Lc, {
						submissionType: u,
						submitMode: p
					}), o.a.createElement(uo, {
						includeUserProfile: n,
						allowCrosspostableOnly: !!c
					}), !!b && o.a.createElement(eu, null, b), o.a.createElement(Zd, null, u !== m.Jb.CROSSPOST && o.a.createElement(Gd, null), o.a.createElement($d, null, o.a.createElement(sd, {
						onChange: this.sendStartTypingInputTitleEvent,
						onKeyDown: this.handleKeyDown,
						onPostFieldValidation: this.onPostFieldValidation
					}), this.renderActiveForm()), e && o.a.createElement(v.a, null), o.a.createElement(Ys, {
						contributorRequestPending: e,
						draftId: t,
						onCancel: this.props.onDiscardPromptOnNavigationConfirmed,
						onPostFieldValidation: this.onPostFieldValidation,
						onSaveDraft: this.onSaveDraft,
						onSubmit: this.onSubmit,
						sourcePostId: c
					}), o.a.createElement(Oc, {
						draftId: t
					})), r && o.a.createElement(fd, {
						callback: this.onRecaptchaSucceeded
					}), s === Re && o.a.createElement(Ae, {
						onAbort: this.onDiscardPromptAbort,
						onDiscardConfirmed: this.onDiscardPromptOnNavigationConfirm,
						onSaveDraft: this.onDiscardPromptSaveDraft,
						submissionType: u
					}), s === f.c && o.a.createElement(Ae, {
						onAbort: this.onDiscardPromptAbort,
						onDiscardConfirmed: this.onDiscardPromptOnNewPostConfirm,
						onSaveDraft: this.onDiscardPromptSaveDraft,
						submissionType: u
					}), s === f.d && o.a.createElement(wr, {
						onClose: this.onDraftListClose,
						onLoadDraft: this.tryLoadDraft
					}), s === f.a && h && o.a.createElement(Ve.a, {
						onClose: this.onToggleCollectionListModal,
						onSelectCollection: this.onSelectCollection,
						subredditId: h.id
					}), s === f.b && h && o.a.createElement(Xs.a, {
						onCancel: this.onToggleCollectionListModal,
						onCollectionCreated: this.onCollectionCreated,
						subredditId: h.id
					}), s === od.a.LOAD_DRAFT_MODAL_ID && o.a.createElement(od.b, {
						modalId: od.a.LOAD_DRAFT_MODAL_ID,
						onCancel: this.onPromptCancel,
						onConfirm: this.onPromptConfirm
					}), s === od.a.MAX_DRAFTS_MODAL_ID && o.a.createElement(od.b, {
						modalId: od.a.MAX_DRAFTS_MODAL_ID,
						onCancel: this.onPromptCancel,
						onConfirm: this.onPromptConfirm
					}), s === gd && o.a.createElement(xd, {
						onCancel: this.onToggleCurrentModal,
						onConfirm: this.onConfirmSavingDraftWithLimitations,
						hasEventSchedule: !!this.props.eventSchedule,
						hasRichPostMedia: this.hasRichPostMedia()
					}), i && (s === f.p.ImageWillBeRemoved || s === f.p.VideoWillBeRemovedTooLongForGif || s === f.p.VideoWillBeRemovedMediaNotAllowed || s === f.p.GalleryWillBeRemovedGalleryNotAllowed) && o.a.createElement(kd, {
						withOverlay: !0,
						promptType: s,
						nextSubreddit: i,
						onConfirmed: this.onSubredditChangePromptConfirmed,
						onCanceled: this.props.onCancelSubredditChange
					}), o.a.createElement(He, null))
				}
			}
			var ou = tu(Object(r.b)(nu, (e, t) => {
					let {
						draftId: n,
						sourcePostId: s,
						pageLayer: o
					} = t;
					return {
						onLoadDraft: t => e(F.q(t)),
						onSubmit: (t, r) => e(((e, t) => async (n, s, o) => {
							let {
								apiContext: r
							} = o, i = s();
							const {
								pending: a
							} = i.creations.api.post.submit, c = Object(S.g)(i);
							if (a || c) return;
							n(ve(e)), i = s();
							const l = Object(w.a)(i),
								d = oe.d.rteVideoPoster(i),
								u = Oe(i),
								p = l === m.Jb.MEDIA;
							u && (d || p) && (await n(P.f(u)), Oe(s())) || (e === f.q.Draft ? await n(Object(F.r)(t.draftId)) : e === f.q.ScheduledPost && Object(de.r)(i) ? await n(je(t)) : e === f.q.ScheduledPost ? await n(we(t)) : await n(Se(t)))
						})(t, {
							draftId: n || void 0,
							pageLayer: o,
							postFieldValidationPending: r,
							sourcePostId: s
						})),
						onDiscardPromptOnCreatePostConfirmed: () => {
							e(a.p(!1, o))
						},
						onDiscardPromptOnNavigationConfirmed: (t, n) => {
							e(t ? Object(p.a)() : n ? Object(p.b)(n.url) : Object(p.b)("/"))
						},
						onExternalAccountsDataRequested: () => e(I.o()),
						onRedirectToSubreddit: t => e(_e.a(t, n)),
						onCancelSubredditChange: () => {
							e(a.x("")), e(_e.e())
						},
						onCancelAndRemoveMediaUpload: () => {
							e(Object(a.d)({
								items: [],
								selectedKey: null
							})), e(ke.j(P.a, !0))
						},
						onClearErrors: (t, n) => t && e(a.i(n)),
						onRequestDraftList: () => e(F.p()),
						onSetDestCollection: t => e(_e.d(t)),
						onStartTypingInput: t => e((e, n) => O.n(n(), f.k.TYPE, t)),
						onToggleIsChanged: t => e(a.r(t)),
						onToggleModal: t => e(a.x(t)),
						onTrackDiscardButtonClick: () => e((e, t) => O.c(t())),
						onUnmount: () => e((e, t) => {
							e(ke.j(P.a, !0)), e(ke.i(f.m, !0))
						}),
						onUploadPendingThumbnails: t => e(P.f(t)),
						startChangeUsernameFlow: () => e(Object(T.f)())
					}
				}, (e, t, n) => Object.assign(Object.assign(Object.assign(Object.assign({}, e), t), n), {
					onClearErrors: n => t.onClearErrors(e.hasError || e.hasSubmitValidationError, n),
					onDiscardPromptOnNavigationConfirmed: () => t.onDiscardPromptOnNavigationConfirmed(e.discardGoesBack, e.subreddit)
				}))(su)),
				ru = n("./src/reddit/components/PostingSidebar/index.tsx"),
				iu = n("./src/reddit/layout/page/Listing/index.tsx"),
				au = n("./src/lib/makePostCreationPageKey/index.ts"),
				cu = n("./src/reddit/helpers/trackers/screenview.ts"),
				lu = n("./src/telemetry/models/Timer.ts");
			const du = Object(i.c)({
					destSubreddit: w.g,
					user: k.i
				}),
				uu = Object(r.b)(du, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return {
						onResetForm: () => e(a.p(!1, n))
					}
				}),
				pu = Object(E.t)({
					draftId: E.u,
					pageLayer: e => e
				});
			class mu extends s.Component {
				componentDidMount() {
					document.documentElement.scrollTop = document.body.scrollTop = 0;
					const e = this.props.pageLayer;
					if (e) {
						const t = Object(au.a)(e.urlParams);
						N.c.has(t) && this.props.sendEvent(Object(cu.i)(t, lu.TimerType.InApp, N.c.end(t)))
					}
				}
				componentWillReceiveProps(e) {
					this.props.draftId && !e.draftId && e.onResetForm()
				}
				render() {
					const {
						destSubreddit: e,
						user: t
					} = this.props;
					if (e.isProfile) {
						if (!t) return o.a.createElement(x.b, null);
						if (Object(le.e)(t).toLowerCase() !== e.name.toLowerCase()) return o.a.createElement(x.a, null)
					}
					return o.a.createElement(iu.a, {
						redditStyle: !0,
						disableFullscreen: !0,
						navBar: o.a.createElement("div", null),
						content: o.a.createElement(o.a.Fragment, null, o.a.createElement(c.a, null), o.a.createElement(ou, null)),
						sidebar: o.a.createElement(ru.a, null)
					})
				}
			}
			t.default = pu(uu(Object(xs.c)(mu)))
		},
		"./src/reddit/selectors/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			}));
			const s = (e, t) => {
					let {
						post: n
					} = t;
					const s = n.belongsTo.id;
					if (!s) return null;
					const o = e.authorFlair.models[s];
					if (!o) return null;
					const r = n.author;
					return r && o[r] || null
				},
				o = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.authorFlair && e.authorFlair.inContext && e.authorFlair.inContext.username;
					if (!s) return null;
					if (!n) return null;
					const o = e.authorFlair.models[n];
					return o ? o[s] : null
				},
				r = e => e.authorFlair.inContext
		},
		"./src/reddit/selectors/economics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "x", (function() {
				return x
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "z", (function() {
				return E
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "q", (function() {
				return k
			})), n.d(t, "k", (function() {
				return P
			})), n.d(t, "s", (function() {
				return N
			})), n.d(t, "y", (function() {
				return R
			})), n.d(t, "u", (function() {
				return L
			})), n.d(t, "v", (function() {
				return A
			})), n.d(t, "b", (function() {
				return F
			})), n.d(t, "w", (function() {
				return D
			})), n.d(t, "t", (function() {
				return B
			})), n.d(t, "g", (function() {
				return U
			})), n.d(t, "l", (function() {
				return K
			})), n.d(t, "j", (function() {
				return H
			})), n.d(t, "n", (function() {
				return V
			}));
			n("./node_modules/core-js/modules/es6.array.sort.js"), n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/featureFlags/index.ts"),
				o = n("./src/reddit/helpers/economics/sortBadges.ts"),
				r = n("./src/reddit/helpers/richTextJson/index.ts"),
				i = n("./src/reddit/models/Badge/index.ts"),
				a = n("./src/reddit/models/Badge/managementPage.ts"),
				c = n("./src/reddit/models/Gold/Powerups/index.ts"),
				l = n("./src/reddit/models/Payments/index.ts"),
				d = n("./src/reddit/models/Product/index.ts"),
				u = n("./src/reddit/reducers/economics/paymentSystems/index.ts"),
				p = n("./src/reddit/reducers/economics/subredditPremium/index.ts"),
				m = n("./src/reddit/selectors/comments.ts"),
				h = n("./src/reddit/selectors/gold/powerups.ts");
			const b = (e, t) => {
					const n = e.economics.subredditPremium[t];
					if (n && n.status === p.a.Fetched) {
						const e = n.data.subscription,
							t = e && e.active;
						if (t) {
							let e = Object.keys(t);
							return e.length > 1 && (e = e.filter(e => "provisional_membership" !== e)), t[e[0]] || null
						}
					}
					return null
				},
				f = (e, t) => {
					const n = b(e, t);
					return n && n.endsAt || null
				};
			var g;
			! function(e) {
				e[e.DontKnow = 0] = "DontKnow", e[e.NotSubscribed = 1] = "NotSubscribed", e[e.Subscribed = 2] = "Subscribed"
			}(g || (g = {}));
			const x = (e, t) => {
					const n = e.economics.subredditPremium[t];
					if (n && n.status === p.a.Fetched) {
						const n = f(e, t),
							s = Date.now();
						return n && s < n ? g.Subscribed : g.NotSubscribed
					}
					return g.DontKnow
				},
				y = (e, t) => {
					const n = e.user.account,
						s = e.economics.subredditPremium[t];
					if (n && s && s.status === p.a.Fetched) {
						const s = ((e.users.appliedBadges[n.id] || {})[t] || []).map(t => e.badges.models[t]).filter(Boolean);
						if (s) return {
							[a.a.Loyalty]: s.find(e => e.placement === i.a.First),
							[a.a.Achievement]: s.find(e => e.placement === i.a.Second),
							[a.a.Cosmetic]: s.find(e => !e.placement)
						}
					}
					return {
						[a.a.Loyalty]: void 0,
						[a.a.Achievement]: void 0,
						[a.a.Cosmetic]: void 0
					}
				},
				v = (e, t, n) => {
					if (!s.d.spBadges(e)) return [];
					const r = (e.users.appliedBadges[n] || {})[t] || [];
					return Object(o.a)(r.map(t => e.badges.models[t]).filter(Boolean))
				},
				C = (e, t) => {
					const n = e.economics.subredditPremium[t.subredditId];
					if (n && n.status === p.a.Fetched) {
						const e = n.raw.collections[t.collectionId];
						if (e) return {
							highlight: e.extra && e.extra.style && e.extra.style.color,
							title: e.title
						}
					}
				};

			function E(e, t) {
				const n = (e.economics.me.data.specialMemberships || {})[t];
				return !!(n && n.settings && n.settings.optOut)
			}

			function O(e, t) {
				const {
					badge: n,
					subredditId: s
				} = t, o = e.user.account ? e.user.account.id : void 0;
				if (Object(i.c)(n) && n.userId === o) return n;
				const r = e.badges.models,
					a = e.user.ownedBadges[s] || {},
					c = Object(i.c)(n) ? n.type : n.id;
				return Object.keys(a).map(e => r[e]).find(e => e && e.type === c)
			}

			function j(e, t, n, s) {
				const o = e.economics.subredditPremium[t];
				if (o && o.status === p.a.Fetched) {
					if (n === a.a.Loyalty || n === a.a.Achievement) return o.data.collections[n];
					if (n === a.a.Cosmetic && s) return o.data.collections[n][s]
				}
				return []
			}

			function w(e, t) {
				const n = j(e, t, a.a.Loyalty).find(e => "membership" === e.id);
				return n ? [].concat(n.locked, n.unlocked).filter(e => e.position).sort((e, t) => e.position - t.position) : []
			}

			function S(e, t) {
				const n = e.economics.subredditPremium[t];
				if (n && n.status === p.a.Fetched) {
					const e = n.data.collections[a.a.Cosmetic];
					return Object.values(e).reduce((e, t) => e.concat(t), []).reduce((e, t) => e.concat(t.locked, t.unlocked), []).filter(i.d)
				}
				return []
			}

			function _(e, t) {
				return j(e, t, a.a.Cosmetic, a.c.Gallery).some(e => e.locked.some(e => Object(i.d)(e) || !!e.price))
			}
			const k = e => {
				const t = [],
					n = e.economics.paymentSystems;
				if (n.status === u.a.Fetched && n.data.stripe && n.data.stripe.sources) {
					const e = n.data.stripe.sources;
					for (const n in e) {
						const s = e[n];
						t.push({
							display: "".concat(s.brand, " •••• ").concat(s.last4),
							id: n,
							type: l.a.SavedStripe
						})
					}
				}
				if (n.status === u.a.Fetched && n.data.braintree && n.data.braintree.sources) {
					const e = n.data.braintree.sources;
					for (const n in e) {
						const s = e[n];
						"PayPal" === s.brand && t.push({
							display: "PayPal",
							id: s.id,
							type: l.a.SavedPayPal
						})
					}
				}
				return t
			};
			var T;
			! function(e) {
				e[e.Fetched = 0] = "Fetched", e[e.Fetching = 1] = "Fetching", e[e.NotFetched = 2] = "NotFetched"
			}(T || (T = {}));
			const I = {
					prices: {},
					member: "Supporter",
					memberPlural: "Supporters",
					memberAlt: "Subreddit Supporter",
					memberAltPlural: "Subreddit Supporters",
					membership: "Membership",
					membershipAlt: "Supporter Membership"
				},
				P = (e, t) => Object.values(e.products.models).filter(e => e.type === d.a.Membership && t && e.subredditId === t),
				M = (e, t) => {
					if (!t) return {};
					const n = I.prices;
					P(e, t).forEach(e => {
						e.price && e.currency && (n[e.currency] = e.price)
					});
					const s = b(e, t);
					return s && s.price && s.currency && (n[s.currency] = s.price), n
				},
				N = (e, t) => {
					const n = e.subreddits.gov.meta[t || ""],
						s = n && n.extra && n.extra.nomenclature || I;
					return {
						prices: M(e, t),
						member: s.member || I.member,
						memberPlural: s.memberPlural || I.memberPlural,
						memberAlt: s.memberAlt || I.memberAlt,
						memberAltPlural: s.memberAltPlural || I.memberAltPlural,
						membership: s.membership || I.membership,
						membershipAlt: s.membershipAlt || I.membershipAlt
					}
				},
				R = e => {
					const t = e.economics.paymentSystems;
					return !!(t.status === u.a.Fetched && t.data && t.data.tips && t.data.tips.usdr && t.data.tips.usdr.allowed)
				},
				L = (e, t) => {
					const n = e.user.ownedBadges[t] || {};
					return !!Object.keys(n).length
				},
				A = e => {
					const t = e.economics.paymentSystems;
					return t.status === u.a.Fetched && !!t.data && !!t.data.stripe && !!t.data.stripe.stripeAccountId
				},
				F = (e, t) => {
					if (!t) return;
					return e.economics.emotes[t]
				},
				D = (e, t) => {
					const n = t && e.economics.gifs[t];
					return !!n && n.hasGifProduct
				},
				B = (e, t, n) => {
					if (t && Object(h.h)(e, {
							subredditId: t,
							benefit: c.a.CommentsWithGifs
						})) return !0;
					const o = s.d.spGiphy(e),
						i = D(e, t),
						a = "replyToPost" !== n && Object(m.n)(e, {
							commentId: n
						}),
						l = !!a && Object(r.a)(a);
					return o && (i || l)
				},
				U = (e, t, n) => {
					if (t) {
						const s = e.economics.banners.dismissedBanners[t];
						if (s && s.data) return !!s.data[n]
					}
				},
				K = (e, t) => {
					if (!t || !t.subredditId) return null;
					const n = (e.economics.me.data.claimPoints || {})[t.subredditId];
					if (!n || !n.length) return null;
					const s = (e.user.wallets[t.subredditId] || {}).latest,
						o = s && s.publicAddress && s.publicAddress.toLowerCase(),
						r = n.filter(e => !e.address || e.address.toLowerCase() === o);
					return r.reduce((e, t) => parseInt(t.round) < parseInt(e.round) ? t : e, r[0]) || null
				},
				H = (e, t) => {
					const n = e.economics.claims[t.subredditId];
					return !!n && n.isClaiming
				},
				V = e => e.economics.pointsCopy.data
		},
		"./src/reddit/selectors/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/actions/postCreation/constants.ts");
			const o = (e, t) => e.creations.api.editor.converting.pending[t || s.n]
		},
		"./src/reddit/selectors/experiments/pollsGA.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => !0
		},
		"./src/reddit/selectors/gold/topAwarded.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			const s = e => e.users.topAwarders.currentPostId,
				o = e => e.users.topAwarders.api.pending,
				r = e => e.users.topAwarders.api.error,
				i = (e, t) => e.users.topAwarders.list[t],
				a = (e, t) => e.users.topAwarders.currentRank[t]
		},
		"./src/reddit/selectors/gov.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "t", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "i", (function() {
				return x
			})), n.d(t, "j", (function() {
				return y
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "r", (function() {
				return E
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "n", (function() {
				return w
			})), n.d(t, "u", (function() {
				return S
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "f", (function() {
				return k
			})), n.d(t, "s", (function() {
				return T
			})), n.d(t, "o", (function() {
				return I
			})), n.d(t, "l", (function() {
				return P
			}));
			var s = n("./src/reddit/contexts/PageLayer/index.tsx"),
				o = n("./src/reddit/endpoints/governance/crypto.ts"),
				r = n("./src/reddit/featureFlags/index.ts"),
				i = n("./src/reddit/selectors/experiments/pollsGA.ts"),
				a = n("./src/reddit/selectors/postCreations.ts");
			const c = [],
				l = {},
				d = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = S(e, {
						subredditId: n
					});
					return s && s.extra && s.extra.contracts && s.extra.contracts.harberger ? s.extra.contracts.harberger : {
						address: void 0,
						decimals: void 0,
						image: void 0,
						taxRate: .01,
						token: void 0
					}
				},
				p = (e, t) => {
					const n = j(e, t);
					if (n) return n.mainHeader
				},
				m = (e, t) => {
					const n = j(e, t);
					return n && n.mainHeader ? n.mainHeader.price : "0"
				},
				h = (e, t) => {
					const n = j(e, t);
					return n && n.mainHeader ? {
						owner: n.mainHeader.owner,
						ownerId: n.mainHeader.ownerId
					} : l
				},
				b = (e, t) => t && t.subredditId ? (e.user.wallets[t.subredditId] || {}).latest : void 0,
				f = (e, t) => {
					const n = b(e, t),
						s = n && n.publicAddress;
					if (!s) throw new Error("No wallet address found");
					return s
				},
				g = (e, t) => {
					const n = b(e, t);
					return n && n.amount || "0"
				},
				x = (e, t) => {
					if (Object(i.a)(e)) {
						const t = Object(a.g)(e);
						if (t.allowedPostTypes && t.allowedPostTypes.polls) return !0
					}
					const n = r.d.spPolls(e),
						s = t && t.subredditId ? e.subreddits.gov.meta[t.subredditId] : void 0;
					if (s) {
						const e = !!s.polls && !1 === s.polls.canCreate;
						return n && !e
					}
					return n
				},
				y = (e, t) => {
					return (e.users.publicWallets[t.userId] || {})[t.subredditId]
				},
				v = (e, t) => {
					const n = Object(s.m)(e, t);
					return n && e.subreddits.gov.releaseNotes[n] || c
				},
				C = (e, t) => t && t.subredditId && (e.subreddits.gov.meta[t.subredditId] || {}).name || "Subreddit Points",
				E = (e, t) => t && t.subredditId && (e.subreddits.gov.meta[t.subredditId] || {}).images || d,
				O = (e, t) => {
					const n = T(e, t);
					return n && n.decimals ? "1" + "0".repeat(n.decimals) : "1"
				},
				j = (e, t) => t.subredditId ? e.subreddits.gov.assets[t.subredditId] : void 0,
				w = (e, t) => t && t.subredditId ? e.subreddits.gov.meta[t.subredditId] : void 0,
				S = (e, t) => {
					const n = w(e, t);
					return n && n.walletProvider
				},
				_ = (e, t) => {
					const n = S(e, t),
						s = w(e, t);
					return n && n.provider || s && s.provider
				},
				k = (e, t) => {
					const n = _(e, t);
					return n === o.a.Ethereum || n === o.a.Rinkeby || n === o.a.EthTraderEthereum || n === o.a.EthTraderRinkeby
				},
				T = (e, t) => {
					const n = S(e, t),
						s = _(e, t);
					if (n && !n.inTransition && s === o.a.Stellar) return {
						address: n.extra && n.extra.issuerAddress || "",
						decimals: n.extra && n.extra.decimals || 7,
						symbol: n.extra && n.extra.token || "PHOTON"
					};
					const r = n && n.extra && n.extra.contracts,
						i = r && r.unlocked;
					return i && {
						address: i.address,
						symbol: i.token || "",
						decimals: i.decimals || 18,
						image: i.image
					}
				},
				I = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = S(e, {
						subredditId: n
					});
					return s && s.extra && s.extra.contracts && s.extra.contracts.subscriptions ? s.extra.contracts.subscriptions : {
						address: void 0
					}
				},
				P = (e, t) => {
					const n = w(e, t);
					return !!n && !!n.walletProvider && !n.walletProvider.inTransition
				}
		},
		"./src/reddit/selectors/products.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/models/Product/index.ts");
			const o = (e, t) => {
					const n = e.products.models[t];
					if (n && n.type === s.a.Badge) return n
				},
				r = (e, t) => {
					let {
						productId: n
					} = t;
					const s = e.products.models[n];
					if (s) {
						const t = s.subredditId,
							o = Object.keys(e.user.ownedBadges[t] || {}),
							r = e.badges.models,
							i = Date.now();
						let a = !1;
						return o.forEach(e => {
							const t = r[e];
							t && t.type === n && t.endsAt > i && (a = !0)
						}), a
					}
					return !1
				}
		},
		"./src/reddit/selectors/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = e => e.tooltipId,
				o = e => t => t.tooltipId === e
		},
		"./src/reddit/singleton/EventSystem.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				o = n("./src/lib/fastdom/index.ts"),
				r = n("./src/reddit/actions/jsApi.ts");
			const i = "JSAPI customEvent.detail.name is deprecated. Please upgrade to <meta>",
				a = "jsapi.consumer",
				c = "/r/redesign/wiki/jsapi";
			var l = n("./src/reddit/constants/jsapiEvents.ts");
			const d = 100;
			const u = new class {
				constructor() {
					if (this.queue = [], this.active = !1, "undefined" == typeof document) return;
					let e;
					this.store = new Promise(t => e = t), this.attachStore = t => e(t);
					const t = document.querySelectorAll('meta[name="'.concat(a, '"]'));
					t.length && (t.forEach(e => {
						const t = e.content;
						this.store.then(e => e.dispatch(r.b(t)))
					}), this.store.then(() => this.fireEventsQueue())), document.addEventListener(l.b, e => this.onReadyEvent(e), !0)
				}
				onReadyEvent(e) {
					let t;
					if (this.active = !0, e.target && e.target instanceof HTMLMetaElement && e.target.name === a && (t = e.target.content), !t) try {
						e.detail && (t = e.detail.name, console.warn(i, "".concat(s.a.redditUrl).concat(c), e))
					} catch (n) {
						return void console.error(i, "".concat(s.a.redditUrl).concat(c), n)
					}
					this.store.then(e => {
						e.dispatch(r.b(t || "")), this.fireEventsQueue()
					})
				}
				publish(e, t, n) {
					const s = {
						name: e,
						props: t,
						element: n
					};
					this.queue.push(s), this.queue.length > d && this.queue.shift(), this.active && this.fireEvent(s)
				}
				fireEvent(e) {
					e.element.dispatchEvent(new CustomEvent(e.name, {
						detail: e.props
					}))
				}
				fireEventsQueue() {
					o.a.read(() => {
						for (let e = 0; e < this.queue.length; e++) {
							const t = this.queue[e];
							this.fireEvent(t)
						}
					})
				}
			};
			t.a = u
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/PostCreation.b0aaffaf1611712fa134.js.map