// https://www.redditstatic.com/desktop2x/CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~MembershipPaywa~c24a8af4.b4161b6dcdee7d8dabb0.js
// Retrieved at 11/4/2021, 7:50:05 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~MembershipPaywa~c24a8af4"], {
		"./src/lib/colors/constants.ts": function(e, t, s) {
			"use strict";
			s.d(t, "b", (function() {
				return i
			})), s.d(t, "f", (function() {
				return o
			})), s.d(t, "c", (function() {
				return a
			})), s.d(t, "a", (function() {
				return n
			})), s.d(t, "e", (function() {
				return r
			})), s.d(t, "d", (function() {
				return l
			})), s.d(t, "g", (function() {
				return d
			})), s.d(t, "h", (function() {
				return c
			}));
			const i = "#000",
				o = "#FFF",
				a = "#FF4500",
				n = "#0079D3",
				r = "#24A0ED",
				l = "#46D160",
				d = {
					black: i,
					white: o,
					orangered: a,
					alienblue: n,
					tone1: "#1A1A1B",
					tone2: "#6A6D6F",
					tone3: "#878A8C",
					tone4: "#D3D6DA",
					tone5: "#EDEFF1",
					tone6: "#F6F7F8",
					tone7: "#FFFFFF",
					primary: r,
					secondary: "#006CBF",
					upvote: a,
					downvote: "#7193FF",
					positive: l,
					negative: "#EA0027",
					caution: "#FFB000",
					admin: a,
					moderator: "#46D160",
					self: "#0DD3BB",
					coins: "#DDBD37",
					live: a,
					nsfw: "#FF585B",
					spoiler: "#1A1A1B"
				},
				c = {
					...d,
					tone1: "#D7DADC",
					tone2: "#818384",
					tone3: "#565758",
					tone4: "#3A3A3C",
					tone5: "#272729",
					tone6: "#1A1A1B",
					tone7: "#121213",
					primary: "#006CBF",
					secondary: "#24A0ED",
					coins: "#FFE600",
					spoiler: "#D7DADC"
				}
		},
		"./src/reddit/components/HTML5StreamPlayer/BlurImage/index.m.less": function(e, t, s) {
			e.exports = {
				Component: "_1chxf6wi6yizUXVYKuz67P",
				component: "_1chxf6wi6yizUXVYKuz67P"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/ControlBar/index.m.less": function(e, t, s) {
			e.exports = {
				baseControlStyles: "_2rtFq5-gNnsnqTzEcTSmVx",
				NormalControl: "_3MU1RfVON0x2Jtnz9Zq3FA",
				normalControl: "_3MU1RfVON0x2Jtnz9Zq3FA",
				TooltipControl: "_1mDDkogVo82R5-IFxvyPRX",
				tooltipControl: "_1mDDkogVo82R5-IFxvyPRX",
				AnimatedSettingIconParent: "_3KjMjt45Pg4_LoShJNFMEf",
				animatedSettingIconParent: "_3KjMjt45Pg4_LoShJNFMEf",
				baseIconStyles: "_2c7UOdkceyJz77qZPoGPAL",
				ControlCollapse: "_3uhleNVV7YkJm0tszcz4z9",
				controlCollapse: "_3uhleNVV7YkJm0tszcz4z9",
				ControlExpand: "_3ly5pJnuzH6jga1JGXpOXD",
				controlExpand: "_3ly5pJnuzH6jga1JGXpOXD",
				ControlPlay: "fqsG3oqeIwcEC-HTRf23d",
				controlPlay: "fqsG3oqeIwcEC-HTRf23d",
				ControlSnoo: "_2Zt53GmI1y_S0N7pA0jMc0",
				controlSnoo: "_2Zt53GmI1y_S0N7pA0jMc0",
				ControlVolume: "_2W9KLflUho3xU7KURAaHwH",
				controlVolume: "_2W9KLflUho3xU7KURAaHwH",
				Time: "_1z-qg2gzYKkI37gkYYJCi0",
				time: "_1z-qg2gzYKkI37gkYYJCi0",
				LiveLabel: "_1s8L9kNAgwvsmhnrpHl4Ef",
				liveLabel: "_1s8L9kNAgwvsmhnrpHl4Ef",
				ControlScrubber: "_3YQsKErciDXsBNWhb0bzul",
				controlScrubber: "_3YQsKErciDXsBNWhb0bzul",
				VolumeControl: "_3nTkqMMtsoqxVmhplDRef3",
				volumeControl: "_3nTkqMMtsoqxVmhplDRef3",
				SettingIcon: "X3KvZpgZg_2f0etJY2Ba7",
				settingIcon: "X3KvZpgZg_2f0etJY2Ba7",
				VideoSettingContainer: "_1s7GuSZPqjgn0QP60a6asr",
				videoSettingContainer: "_1s7GuSZPqjgn0QP60a6asr",
				ControlBarContainer: "gUpEQXQu8G8UvISmBIPsj",
				controlBarContainer: "gUpEQXQu8G8UvISmBIPsj",
				AudioOnlyControlBar: "_35yCa6dYJNzUGsRDLtEoWU",
				audioOnlyControlBar: "_35yCa6dYJNzUGsRDLtEoWU",
				mIsFullScreen: "IlN7iDYa9yzeFlgOo0JQe",
				mHasZeroOpacity: "_1RZSSlyqzokrcxh0ESwE2e",
				button: "_15cvJJTKClcHJuPN2mcpY4"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/ControlBar/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return le
			}));
			var i = s("./node_modules/fbt/lib/FbtPublic.js"),
				o = s("./node_modules/react/index.js"),
				a = s.n(o),
				n = s("./src/lib/classNames/index.ts"),
				r = s("./src/lib/lessComponent.tsx"),
				l = s("./src/reddit/components/HTML5StreamPlayer/index.tsx"),
				d = s("./src/reddit/icons/svgs/VideoCollapse/index.tsx"),
				c = s("./src/reddit/icons/svgs/VideoExpand/index.tsx"),
				h = s("./src/reddit/icons/svgs/VideoMute/index.tsx"),
				u = s("./src/reddit/icons/svgs/VideoPause/index.tsx"),
				p = s("./src/reddit/icons/svgs/VideoPlay/index.tsx"),
				m = s("./src/reddit/icons/svgs/VideoVolume/index.tsx"),
				g = s("./src/reddit/components/HTML5StreamPlayer/ControlGradient/index.m.less"),
				v = s.n(g),
				y = r.a.div("Component", v.a),
				f = s("./node_modules/lodash/clamp.js"),
				S = s.n(f),
				P = s("./node_modules/react-dom/index.js"),
				b = s.n(P),
				C = s("./src/lib/fastdom/index.ts");
			const T = e => {
					const t = Math.floor(e / 60).toString();
					let s = Math.trunc(e % 60).toString();
					return `${t}:${s=`0${s}`.slice(-2)}`
				},
				x = (e, t) => {
					let s = Math.floor(e / 60).toString(),
						i = Math.trunc(e % 60).toString();
					const o = Math.floor(t / 60).toString();
					return s.length < o.length && (s = `0${s}`.slice(-2)), `${s}:${i=`0${i}`.slice(-2)}`
				};
			var E = s("./src/reddit/constants/keycodes.ts"),
				V = s("./src/reddit/components/HTML5StreamPlayer/SeekBar/index.m.less"),
				M = s.n(V);
			const L = r.a.div("Thumb", M.a),
				_ = r.a.div("ProgressBar", M.a),
				B = r.a.div("Floating", M.a),
				w = r.a.video("PreviewVideo", M.a),
				R = r.a.div("PreviewTime", M.a),
				k = r.a.div("VideoSeekbar", M.a);
			class F extends a.a.PureComponent {
				constructor(e) {
					super(e), this.setParentRect = e => this.parentRect = e, this.setPreviewThumbnailContainer = e => this.previewThumbnailContainer = e, this.setPreviewThumbnailVideo = e => this.previewThumbnailVideo = e, this.setPreviewThumbnailTime = e => this.previewThumbnailTime = e, this.setProgressBar = e => this.progressBar = e, this.handleMouseDown = e => {
						if (0 === e.button && this.parentRect) {
							const t = this.parentRect.getBoundingClientRect();
							let s = (e.clientX - t.left) / t.width * 100;
							s = Math.min(Math.max(s, 0), 100), this.setProgress(s, !0)
						}
					}, this.handleMouseMove = e => {
						if (e.stopPropagation(), this.parentRect) {
							const t = this.parentRect.getBoundingClientRect();
							let s = (e.clientX - t.left) / t.width * 100;
							s = Math.min(Math.max(s, 0), 100), this.setLookahead(s), this.props.active && this.setProgress(s, !0)
						}
					}, this.handleMouseUp = e => {
						if (this.props.active) {
							const e = this.state.progressPercent * this.props.totalTime / 100;
							this.props.updatePosition(e), this.progressBar && this.progressThumb && (this.progressBar.style.width = "", this.progressThumb.style.marginLeft = "")
						}
					}, this.handleMouseLeave = e => {
						this.setLookahead(0)
					}, this.handleKeyDown = e => {
						switch (e.key) {
							case E.b.ArrowRight:
								return void this.jumpPlayback(5);
							case E.b.ArrowLeft:
								return void this.jumpPlayback(-5);
							case E.b.Space:
								return this.props.playPauseVideo(), void e.preventDefault()
						}
					}, this.setProgressThumbRef = e => {
						this.progressThumb = e, e && C.a.read(() => {
							const t = e.getBoundingClientRect().width / 2;
							C.a.write(() => {
								this.setState({
									thumbOffset: t
								})
							})
						})
					}, this.state = {
						thumbMargin: "",
						thumbOffset: null,
						isMouseDown: !1,
						progressPercent: 0,
						percent: 0
					}
				}
				jumpPlayback(e) {
					const {
						currentTime: t,
						totalTime: s
					} = this.props, i = S()(t + e, 0, s);
					i !== t && this.props.updatePosition(i)
				}
				getCurrentPercent() {
					const {
						currentTime: e,
						totalTime: t
					} = this.props;
					return e && t ? 100 * e / t : 0
				}
				setProgress(e, t = !1) {
					this.progressBar && this.progressThumb && (!this.props.active || t) && (this.progressBar.style.width = "calc(" + e + "% + " + this.state.thumbOffset + "px)", this.progressThumb.style.marginLeft = "calc(" + e + "% - " + this.state.thumbOffset + "px)", this.setState({
						progressPercent: e
					}), this.props.updateContinuousStartTime && this.props.updateContinuousStartTime(1e3 * this.props.currentTime))
				}
				getThumbMargin(e) {
					return this.props.active && this.progressThumb ? this.progressThumb.style.marginLeft || "0" : `calc(${e}% - ${this.state.thumbOffset||0}px)`
				}
				getProgressWidth(e) {
					return this.props.active && this.progressBar ? this.progressBar.style.width : `${e}%`
				}
				setLookahead(e) {
					if (this.lookaheadBar && this.previewThumbnailContainer && this.previewThumbnailTime && this.parentRect) {
						this.lookaheadBar.style.width = e + "%";
						const {
							totalTime: t
						} = this.props, s = t * (e / 100);
						isNaN(s) || (this.previewThumbnailVideo && (this.previewThumbnailVideo.currentTime = s), this.previewThumbnailTime.innerHTML = x(s, t));
						const i = b.a.findDOMNode(this);
						if (!i || !i.parentNode) return;
						const o = i.parentNode;
						if (!(o instanceof Element)) return;
						const a = o.getBoundingClientRect(),
							n = this.parentRect.getBoundingClientRect(),
							r = this.previewThumbnailContainer.getBoundingClientRect(),
							l = a.left - n.left,
							d = a.right - n.left - r.width,
							c = e / 100 * n.width - r.width / 2;
						this.previewThumbnailContainer.style.left = Math.max(l, Math.min(c, d)) + "px"
					}
				}
				getBufferedStyle() {
					const {
						bufferedRanges: e
					} = this.props, {
						progressPercent: t
					} = this.state, s = this.getCurrentPercent();
					let i = t;
					for (let o = 0; o < e.length; o++) e[o].start <= s && (i = e[o].end);
					return {
						width: `${i=S()(i,0,100)}%`
					}
				}
				render() {
					const {
						active: e
					} = this.props, {
						progressPercent: t
					} = this.state, s = this.getCurrentPercent();
					let o = e ? t : s;
					o = S()(o, 0, 100);
					const r = {
							width: this.getProgressWidth(o) || "0"
						},
						l = {
							marginLeft: this.getThumbMargin(o),
							opacity: e ? 1 : 0
						};
					return a.a.createElement(k, {
						innerRef: this.setParentRect,
						onKeyDown: this.handleKeyDown,
						onMouseLeave: this.handleMouseLeave,
						onMouseMove: this.handleMouseMove
					}, a.a.createElement("div", {
						"aria-label": i.fbt._("Seek Slider", null, {
							hk: "1fNTBw"
						}),
						"aria-valuemax": Math.round(this.props.totalTime),
						"aria-valuemin": 0,
						"aria-valuenow": this.props.currentTime,
						className: M.a.Mainbar,
						role: "slider",
						tabIndex: 0
					}, a.a.createElement("div", {
						className: Object(n.a)(M.a.Bar, M.a.Background)
					}), a.a.createElement("div", {
						className: Object(n.a)(M.a.Bar, M.a.Lookahead),
						ref: e => this.lookaheadBar = e
					}), a.a.createElement("div", {
						className: Object(n.a)(M.a.Bar, M.a.Buffered),
						style: this.getBufferedStyle()
					}), a.a.createElement(_, {
						className: Object(n.a)(this.props.isLive && M.a.Live),
						innerRef: this.setProgressBar,
						style: r
					})), a.a.createElement(L, {
						className: Object(n.a)(this.props.isLive && M.a.Live),
						innerRef: this.setProgressThumbRef,
						style: l
					}), !this.props.controlBarIsHidden && a.a.createElement(B, {
						innerRef: this.setPreviewThumbnailContainer
					}, this.props.thumbSource && a.a.createElement(w, {
						innerRef: this.setPreviewThumbnailVideo,
						src: this.props.thumbSource
					}), a.a.createElement(R, {
						innerRef: this.setPreviewThumbnailTime
					})))
				}
			}
			var I = s("./node_modules/react-router-dom/esm/react-router-dom.js"),
				A = s("./src/reddit/icons/svgs/VideoSnoo/index.tsx"),
				D = s("./src/reddit/components/HTML5StreamPlayer/SnooButton/index.m.less"),
				H = s.n(D);
			const O = () => a.a.createElement("div", {
				className: H.a.icon
			}, a.a.createElement(A.a, null));
			var N = e => "string" == typeof e.postUrl ? a.a.createElement("a", {
					href: e.postUrl,
					className: H.a.button
				}, a.a.createElement(O, null)) : a.a.createElement(I.a, {
					to: e.postUrl,
					className: H.a.button
				}, a.a.createElement(O, null)),
				U = s("./src/reddit/components/HTML5StreamPlayer/Tooltip/index.tsx"),
				j = s("./src/reddit/components/HTML5StreamPlayer/VolumeControl/index.m.less"),
				W = s.n(j);
			class G extends o.Component {
				constructor(e) {
					super(e), this.step = .1, this.max = 1, this.min = 0, this.handleMouseDown = e => {
						if (0 === e.button && this.track) {
							e.preventDefault(), this.setState({
								isMouseDown: !0
							});
							const t = this.track.getBoundingClientRect(),
								s = 100 - (e.clientY - t.top) / t.height * 100,
								i = (this.max - this.min) * (s / 100);
							this.setState({
								value: this.adjustValue(i)
							})
						}
					}, this.handleMouseMove = e => {
						if (this.state.isMouseDown && this.track) {
							const t = this.track.getBoundingClientRect(),
								s = 100 - (e.clientY - t.top) / t.height * 100,
								i = (this.max - this.min) * (s / 100);
							this.setState({
								value: this.adjustValue(i)
							})
						}
					}, this.handleMouseUp = e => {
						this.state.isMouseDown && this.setState({
							isMouseDown: !1
						}), this.props.setVolume(this.state.value, !0)
					}, this.state = {
						isMouseDown: !1,
						value: 0
					}
				}
				convertVolumeToPercent(e) {
					if ("number" != typeof e) return 100;
					const t = S()(e, this.min, this.max);
					let s = 0;
					if (t) {
						s = 20 * Math.log10(t) / 40 + 1
					}
					return this.calculatePercent(s)
				}
				calculatePercent(e) {
					return (e - this.min) / (this.max - this.min) * 100
				}
				adjustValue(e) {
					const t = S()(e, this.min, this.max);
					let s;
					if (1 === t || 0 === t) s = t;
					else {
						const e = 40 * (t - 1);
						s = Math.pow(10, e / 20)
					}
					return this.props.setVolume(s, !1), s
				}
				render() {
					const {
						active: e,
						className: t,
						isLive: s,
						isMuted: i,
						volume: o
					} = this.props, {
						value: r
					} = this.state, l = i ? 0 : e ? r : o, d = this.convertVolumeToPercent(l);
					return a.a.createElement("div", {
						className: Object(n.a)(W.a.VolumeControl, t),
						ref: e => this.container = e
					}, a.a.createElement("div", {
						className: Object(n.a)(W.a.SliderTrack, W.a.SliderBar),
						ref: e => this.track = e
					}, a.a.createElement("div", {
						className: Object(n.a)(W.a.SliderProgress, W.a.SliderBar, {
							[W.a.Live]: s
						}),
						ref: e => this.progress = e,
						style: {
							height: `${d}%`
						}
					}, a.a.createElement("div", {
						className: W.a.SliderThumb
					}))))
				}
			}
			var Y = s("./src/reddit/components/HTML5StreamPlayer/ControlBar/index.m.less"),
				z = s.n(Y);

			function K() {
				return (K = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (e[i] = s[i])
					}
					return e
				}).apply(this, arguments)
			}
			const J = r.a.wrapped(U.a, "TooltipControl", z.a),
				Q = r.a.div("NormalControl", z.a),
				Z = r.a.wrapped(J, "ControlSnoo", z.a),
				q = r.a.wrapped(J, "ControlPlay", z.a),
				X = r.a.wrapped(Q, "Time", z.a),
				$ = r.a.wrapped(X, "LeftTime", z.a),
				ee = r.a.wrapped(X, "RightTime", z.a),
				te = r.a.div("LiveLabel", z.a),
				se = r.a.wrapped(Q, "ControlScrubber", z.a),
				ie = r.a.wrapped(Q, "ControlVolume", z.a),
				oe = r.a.wrapped(J, "ControlExpand", z.a),
				ae = r.a.wrapped(J, "ControlCollapse", z.a),
				ne = ({
					className: e,
					isFullScreen: t,
					zeroOpacity: s,
					innerRef: i,
					...o
				}) => a.a.createElement("div", K({
					className: Object(n.a)(z.a.ControlBarContainer, e, {
						[z.a.mIsFullScreen]: t,
						[z.a.mHasZeroOpacity]: s
					}),
					ref: i
				}, o));
			class re extends a.a.Component {
				constructor(e) {
					super(e), this.state = {
						currentTime: e.currentTime,
						totalTime: e.totalTime,
						bufferedRanges: []
					}
				}
				setCurrentTime(e) {
					this.setState({
						currentTime: e
					})
				}
				setTotalTime(e) {
					this.setState({
						totalTime: e
					})
				}
				setBufferedRanges(e) {
					this.setState({
						bufferedRanges: e
					})
				}
				renderContent() {
					const {
						hideFullScreenButton: e,
						hideGradient: t,
						postUrl: s,
						isListing: o,
						isLive: n,
						settingsButton: r,
						settingChange: h,
						hideLiveLabel: m,
						showSettingsIcon: g
					} = this.props, v = i.fbt._("View Comments", null, {
						hk: "2Vf8xl"
					}), f = i.fbt._("Play", null, {
						hk: "2cQV3h"
					}), S = i.fbt._("Pause", null, {
						hk: "2YnRgT"
					}), P = i.fbt._("Exit Fullscreen", null, {
						hk: "LnrWa"
					}), b = i.fbt._("Fullscreen", null, {
						hk: "3JvSdn"
					}), {
						currentTime: C
					} = this.state, {
						totalTime: E
					} = n ? this.state : this.props, V = this.props.isPaused ? f : S;
					return a.a.createElement(a.a.Fragment, null, !t && a.a.createElement(y, null), s && o && a.a.createElement(Z, {
						tooltip: v
					}, a.a.createElement("div", {
						onClick: this.props.clickSnoo
					}, a.a.createElement(N, {
						postUrl: s
					}))), a.a.createElement(q, {
						tooltip: V
					}, a.a.createElement("button", {
						"aria-label": V,
						className: z.a.button,
						onClick: this.props.playPauseVideo
					}, this.props.isPaused ? a.a.createElement(p.a, null) : a.a.createElement(u.a, null))), a.a.createElement($, null, x(C, E)), a.a.createElement(se, null, a.a.createElement(F, {
						active: h === l.a.SeekBar,
						bufferedRanges: this.state.bufferedRanges,
						controlBarIsHidden: this.props.hideControlBar,
						currentTime: C,
						isLive: n,
						ref: this.props.seekBarRef,
						thumbSource: this.props.scrubberThumbSource,
						totalTime: E,
						playPauseVideo: this.props.playPauseVideo,
						updatePosition: this.props.setVideoPosition,
						updateContinuousStartTime: this.props.updateContinuousStartTime
					})), n ? m ? null : a.a.createElement(te, {
						"aria-label": i.fbt._("live", null, {
							hk: "1rkHRc"
						}),
						onClick: () => this.props.setVideoPosition(E)
					}, i.fbt._("Live", null, {
						hk: "3bCYlO"
					})) : a.a.createElement(ee, null, T(E)), g && r, !e && (this.props.isFullScreen ? a.a.createElement(ae, {
						tooltip: P
					}, a.a.createElement("button", {
						"aria-label": P,
						className: z.a.button,
						onClick: this.props.exitFullScreen
					}, a.a.createElement(d.a, null))) : a.a.createElement(oe, {
						tooltip: b
					}, a.a.createElement("button", {
						"aria-label": b,
						className: z.a.button,
						onClick: this.props.enterFullScreen
					}, a.a.createElement(c.a, null)))))
				}
				render() {
					const {
						controlBarRef: e,
						isLive: t
					} = this.props;
					return a.a.createElement(ne, {
						className: this.props.className,
						innerRef: t => e && e(t),
						isFullScreen: this.props.isFullScreen,
						zeroOpacity: this.props.hideControlBar
					}, this.renderContent(), this.props.hasAudio && a.a.createElement(ie, {
						className: this.props.showVolumeIcon ? "disableHide" : ""
					}, a.a.createElement(G, {
						className: z.a.VolumeControl,
						ref: e => this.props.volumeRef(e),
						active: this.props.settingChange === l.a.Volume,
						isMuted: this.props.isMuted,
						isLive: t,
						setVolume: this.props.setVolume,
						volume: this.props.volume
					}), a.a.createElement("button", {
						className: z.a.button,
						onClick: this.props.toggleMute
					}, this.props.isMuted ? a.a.createElement(h.a, null) : a.a.createElement(m.a, null))))
				}
			}
			t.b = re;
			const le = e => a.a.createElement(ne, {
				className: z.a.AudioOnlyControlBar,
				isFullScreen: e.isFullScreen,
				zeroOpacity: e.hideControlBar
			}, a.a.createElement(ie, null, a.a.createElement(G, {
				className: z.a.VolumeControl,
				ref: t => e.volumeRef(t),
				active: e.settingChange === l.a.Volume,
				isMuted: e.isMuted,
				isLive: e.isLive,
				setVolume: e.setVolume,
				volume: e.volume
			}), a.a.createElement("button", {
				className: z.a.button,
				onClick: e.toggleMute
			}, e.isMuted ? a.a.createElement(h.a, null) : a.a.createElement(m.a, null))))
		},
		"./src/reddit/components/HTML5StreamPlayer/ControlGradient/index.m.less": function(e, t, s) {
			e.exports = {
				Component: "_3YDPJHFl8YQG4TIAGQwHwK",
				component: "_3YDPJHFl8YQG4TIAGQwHwK"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/ReplayVideo/index.m.less": function(e, t, s) {
			e.exports = {
				Centered: "_241TIL5Gnyx3yLobU95FlI",
				centered: "_241TIL5Gnyx3yLobU95FlI",
				EndedOverlay: "_3G7xHJZQMrQlpjhNDQI2fe",
				endedOverlay: "_3G7xHJZQMrQlpjhNDQI2fe",
				ReplayText: "qDCxOHuaGNjcgDp5-rvJr",
				replayText: "qDCxOHuaGNjcgDp5-rvJr",
				ReplayButton: "_2KpvSaYm8FNb5KzZzf4-TO",
				replayButton: "_2KpvSaYm8FNb5KzZzf4-TO"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/SeekBar/index.m.less": function(e, t, s) {
			e.exports = {
				Thumb: "_2MDmJfq0z5K-d2xH--GnRU",
				thumb: "_2MDmJfq0z5K-d2xH--GnRU",
				ProgressBar: "_3fnsfWuIyofBJBBCbeOZzM",
				progressBar: "_3fnsfWuIyofBJBBCbeOZzM",
				Floating: "AZ2rAoFxu6aiCBbBq02Sr",
				floating: "AZ2rAoFxu6aiCBbBq02Sr",
				PreviewVideo: "V26VfIGfGxnmQGCoWYGY7",
				previewVideo: "V26VfIGfGxnmQGCoWYGY7",
				PreviewTime: "_2PInUKITfsesytaTfWfG42",
				previewTime: "_2PInUKITfsesytaTfWfG42",
				VideoSeekbar: "_3-Dc7BBLD7JWsyF3pV-rsH",
				videoSeekbar: "_3-Dc7BBLD7JWsyF3pV-rsH",
				Mainbar: "_2uVDwsKlmWPhYjwe_hYwKZ",
				mainbar: "_2uVDwsKlmWPhYjwe_hYwKZ",
				Bar: "_4UI_04IgDx06P4biEkiF3",
				bar: "_4UI_04IgDx06P4biEkiF3",
				Background: "_2uPlpBWBrO4n82P3YvBGF_",
				background: "_2uPlpBWBrO4n82P3YvBGF_",
				Lookahead: "l8jnP9bxmZRCAmhfPBTa1",
				lookahead: "l8jnP9bxmZRCAmhfPBTa1",
				Buffered: "_169ZVSyFxp9z4y1H0OYA7w",
				buffered: "_169ZVSyFxp9z4y1H0OYA7w",
				Progress: "_3LxsYVQvMOr6phpuWaScdt",
				progress: "_3LxsYVQvMOr6phpuWaScdt",
				Live: "YTPNvBfuKbdKUEJL6hPJT",
				live: "YTPNvBfuKbdKUEJL6hPJT"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/SettingControl/index.m.less": function(e, t, s) {
			e.exports = {
				SettingControlContainer: "_2XC4hSYLNzvTJ9n8Qx5t2E",
				settingControlContainer: "_2XC4hSYLNzvTJ9n8Qx5t2E",
				mIsActive: "KE4seaOPBFBF1jhkJyWzD",
				VideoSettingContainer: "C_R5GVVZDJEPfB_2ZVw_j",
				videoSettingContainer: "C_R5GVVZDJEPfB_2ZVw_j",
				AutoplayContainer: "_2BOpKj2--T_MqNo_ZMRxNG",
				autoplayContainer: "_2BOpKj2--T_MqNo_ZMRxNG",
				SetAutoplayButton: "_3FgC5gbpQJUntY23YtQ89Z",
				setAutoplayButton: "_3FgC5gbpQJUntY23YtQ89Z",
				VideoResolutionButton: "bAXkjkzl_SYFOHtU-04DK",
				videoResolutionButton: "bAXkjkzl_SYFOHtU-04DK",
				VideoResolutionContainer: "_3IZDbV1r5OQ2PtnsjF02A",
				videoResolutionContainer: "_3IZDbV1r5OQ2PtnsjF02A",
				AutoplayDescription: "_2NY4rl5z4S5VUOfEs8PdJ_",
				autoplayDescription: "_2NY4rl5z4S5VUOfEs8PdJ_",
				VideoResolutionDescription: "_1n_g7VROCpBaLnT_3bzFIL",
				videoResolutionDescription: "_1n_g7VROCpBaLnT_3bzFIL",
				VideoHd: "UyJedjQe5dUxEFYt6pF_G",
				videoHd: "UyJedjQe5dUxEFYt6pF_G"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/SnooButton/index.m.less": function(e, t, s) {
			e.exports = {
				button: "sm5fCodJsfJ3dJgv8LoJU",
				icon: "_1JylLL_Ux6Orq3W6Gpj0I5"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/Tooltip/index.m.less": function(e, t, s) {
			e.exports = {
				TooltipPopup: "_1BLNYd_poiSXsApjISxu_9",
				tooltipPopup: "_1BLNYd_poiSXsApjISxu_9",
				TooltipControl: "_7xWC34a6DkOCXgS96vOSO",
				tooltipControl: "_7xWC34a6DkOCXgS96vOSO",
				mNotDisable: "_2BgDJndeb40Gp_YvmIR_81"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/Tooltip/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return m
			}));
			var i = s("./node_modules/react/index.js"),
				o = s.n(i),
				a = s("./src/lib/classNames/index.ts"),
				n = s("./src/lib/fastdom/index.ts"),
				r = s("./src/reddit/components/HTML5StreamPlayer/Tooltip/index.m.less"),
				l = s.n(r),
				d = s("./src/lib/lessComponent.tsx");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (e[i] = s[i])
					}
					return e
				}).apply(this, arguments)
			}
			const h = 8,
				u = d.a.span("TooltipPopup", l.a),
				p = ({
					className: e,
					setRef: t,
					disable: s,
					...i
				}) => o.a.createElement("div", c({
					className: Object(a.a)(l.a.TooltipControl, e, {
						[l.a.mNotDisable]: !s
					}),
					ref: t
				}, i));
			class m extends i.Component {
				constructor() {
					super(...arguments), this.onMouseEnter = () => {
						n.a.read(this.setPosition)
					}, this.setPosition = () => {
						const {
							container: e,
							tooltipContainer: t
						} = this;
						if (e && t && this.props.tooltip) {
							const s = t.getBoundingClientRect(),
								i = e.getBoundingClientRect(),
								o = e.parentNode.getBoundingClientRect(),
								a = o.left - i.left + h,
								r = o.right - i.left - s.width - h,
								l = i.width / 2 - s.width / 2;
							n.a.write(() => {
								t.style.left = Math.max(a, Math.min(l, r)) + "px"
							})
						}
					}
				}
				componentDidMount() {
					this.container && this.container.addEventListener("focusin", this.setPosition)
				}
				componentWillUnmount() {
					this.container && this.container.removeEventListener("focusin", this.setPosition)
				}
				render() {
					const {
						className: e,
						children: t,
						disable: s,
						tooltip: i
					} = this.props;
					return o.a.createElement(p, {
						onMouseEnter: this.onMouseEnter,
						setRef: e => this.container = e,
						className: e,
						disable: s
					}, o.a.createElement(u, {
						className: l.a.TooltipPopup,
						innerRef: e => this.tooltipContainer = e
					}, i), t)
				}
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/VideoContainer/index.m.less": function(e, t, s) {
			e.exports = {
				Component: "_2UrTEvz_DRsDezLCxNpGnZ",
				component: "_2UrTEvz_DRsDezLCxNpGnZ",
				mIsNotVisible: "ziid7jHsA37M8sq6Set2x"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/VideoOverlay/index.m.less": function(e, t, s) {
			e.exports = {
				Component: "_3UEq__yL-82zX4EyuluREz",
				component: "_3UEq__yL-82zX4EyuluREz"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/VolumeControl/index.m.less": function(e, t, s) {
			e.exports = {
				VolumeControl: "_3IYkqm44eWg992tFnELzuW",
				volumeControl: "_3IYkqm44eWg992tFnELzuW",
				SliderBar: "_1iy-RNoDbjuTYxfwaLdPRO",
				sliderBar: "_1iy-RNoDbjuTYxfwaLdPRO",
				SliderTrack: "gzyVgIvE9b8wMmHefFf6i",
				sliderTrack: "gzyVgIvE9b8wMmHefFf6i",
				SliderProgress: "_2mdWr-OXgnLh-fdDgEEb6E",
				sliderProgress: "_2mdWr-OXgnLh-fdDgEEb6E",
				Live: "_2GyJbEWZL04QA2bbVtv_Qu",
				live: "_2GyJbEWZL04QA2bbVtv_Qu",
				SliderThumb: "_320cReGqgLhY1pPA-fM8Z7",
				sliderThumb: "_320cReGqgLhY1pPA-fM8Z7"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/index.m.less": function(e, t, s) {
			e.exports = {
				RedditVideoPlayerRoot: "_3QOPLw8PZipW3i8kDxod81",
				redditVideoPlayerRoot: "_3QOPLw8PZipW3i8kDxod81",
				RedditVideoPlayerRoot__Fullscreen: "_1znUHTb50VqdFqfWmai1ts",
				redditVideoPlayerRootFullscreen: "_1znUHTb50VqdFqfWmai1ts",
				HTML5StreamPlayer__VideoFullscreen: "_6p8buRs-LijHSXx1H4MGe",
				html5StreamPlayerVideoFullscreen: "_6p8buRs-LijHSXx1H4MGe",
				HTML5StreamPlayer: "zRGpGBNtA_hojI_RK9ouQ",
				html5StreamPlayer: "zRGpGBNtA_hojI_RK9ouQ",
				HTML5StreamPlayer__VideoRegular: "_1EQJpXY7ExS04odI1YBBlj",
				html5StreamPlayerVideoRegular: "_1EQJpXY7ExS04odI1YBBlj",
				VideoBackgroundStyles: "_14LIEiRn-naKqUT7DJ8vwV",
				videoBackgroundStyles: "_14LIEiRn-naKqUT7DJ8vwV"
			}
		},
		"./src/reddit/components/HTML5StreamPlayer/index.tsx": function(e, t, s) {
			"use strict";
			s.d(t, "a", (function() {
				return ke
			}));
			var i = s("./node_modules/bowser/src/bowser.js"),
				o = s.n(i),
				a = s("./node_modules/lodash/debounce.js"),
				n = s.n(a),
				r = s("./node_modules/react/index.js"),
				l = s.n(r),
				d = s("./node_modules/react-redux/es/index.js"),
				c = s("./node_modules/reselect/es/index.js"),
				h = s("./src/lib/classNames/index.ts"),
				u = s("./src/lib/colors/constants.ts"),
				p = s("./src/lib/combineRefs/index.tsx"),
				m = s("./src/lib/domUtils/index.ts");
			const g = () => {
					const e = navigator.userAgent || navigator.vendor || window.opera;
					return /android/i.test(e) ? "Android" : /iPad|iPhone|iPod/.test(e) && !window.MSStream ? "iOS" : "unknown"
				},
				v = () => "Android" === g() || "iOS" === g();
			var y = s("./src/lib/loadWithRetries/index.ts"),
				f = s("./src/lib/sentry/index.ts"),
				S = s("./src/reddit/actions/media.ts"),
				P = s("./src/reddit/actions/preferences.ts"),
				b = s("./src/reddit/actions/video.ts"),
				C = s("./src/reddit/components/Media/LoadingIcon/index.tsx"),
				T = s("./src/reddit/components/PlayButton/index.tsx"),
				x = s("./src/reddit/components/TrackingHelper/index.tsx"),
				E = s("./src/reddit/constants/video.ts"),
				V = s("./src/reddit/contexts/InsideOverlay.tsx"),
				M = s("./src/reddit/helpers/overlay/index.ts"),
				L = s("./src/reddit/helpers/trackers/media.ts"),
				_ = s("./src/reddit/selectors/media.ts"),
				B = s("./src/reddit/selectors/platform.ts"),
				w = s("./src/reddit/selectors/posts.ts"),
				R = s("./src/reddit/selectors/user.ts"),
				k = s("./src/reddit/selectors/video.ts"),
				F = s("./src/reddit/components/HTML5StreamPlayer/BlurImage/index.m.less"),
				I = s.n(F),
				A = s("./src/lib/lessComponent.tsx"),
				D = A.a.img("Component", I.a),
				H = s("./src/reddit/components/HTML5StreamPlayer/ControlBar/index.tsx"),
				O = s("./node_modules/fbt/lib/FbtPublic.js"),
				N = s("./src/reddit/icons/svgs/VideoCheckmark/index.tsx"),
				U = s("./src/reddit/components/HTML5StreamPlayer/SettingControl/index.m.less"),
				j = s.n(U);

			function W() {
				return (W = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (e[i] = s[i])
					}
					return e
				}).apply(this, arguments)
			}
			const G = 0,
				Y = [1080, 720],
				z = [...Y, 480, 360, 240, G],
				K = e => l.a.createElement("button", {
					"aria-checked": e.isChecked,
					className: j.a.SetAutoplayButton,
					onClick: e.onClick,
					role: "checkbox",
					tabIndex: 0
				}, l.a.createElement(N.a, null), l.a.createElement("div", {
					className: j.a.AutoplayDescription
				}, O.fbt._("Autoplay", null, {
					hk: "1x30w1"
				}))),
				J = e => {
					const {
						resolution: t,
						onClick: s,
						isChecked: i
					} = e;
					return l.a.createElement("button", {
						"aria-checked": i,
						className: j.a.VideoResolutionButton,
						onClick: s,
						role: "radio",
						tabIndex: 0
					}, l.a.createElement(N.a, null), l.a.createElement("div", {
						className: j.a.VideoResolutionDescription
					}, t === G ? O.fbt._("Auto", null, {
						hk: "6zgZT"
					}) : l.a.createElement(l.a.Fragment, null, l.a.createElement("span", null, t, "p"), Y.includes(t) && l.a.createElement("span", {
						className: j.a.VideoHd
					}, " ", O.fbt._("HD", null, {
						hk: "2KjxjH"
					})))))
				},
				Q = ({
					isActive: e,
					className: t,
					innerRef: s,
					...i
				}) => l.a.createElement("div", W({
					className: Object(h.a)(j.a.SettingControlContainer, t, {
						[j.a.mIsActive]: e
					}),
					ref: s
				}, i));
			class Z extends r.Component {
				constructor() {
					super(...arguments), this.container = null, this.state = {
						autoplayPref: this.props.autoplayPref
					}, this.setContainerRef = e => this.container = e, this.setResolution = e => {
						this.props.setResolution(e)
					}, this.setAutoplay = e => {
						const t = !this.state.autoplayPref;
						this.setState({
							autoplayPref: t
						}), this.props.setAutoplay(t)
					}
				}
				componentDidMount() {
					if (this.container) {
						const e = this.container.querySelector("[tabindex]");
						e && e.focus()
					}
				}
				render() {
					const {
						active: e,
						bitrateInfo: t,
						className: s,
						isLoggedIn: i,
						resolution: o
					} = this.props, a = [...t.map(e => e.height), G];
					return l.a.createElement(Q, {
						innerRef: this.setContainerRef,
						className: Object(h.a)(j.a.VideoSettingContainer, s),
						isActive: e
					}, i && l.a.createElement("div", {
						className: j.a.AutoplayContainer
					}, l.a.createElement(K, {
						isChecked: this.state.autoplayPref,
						onClick: this.setAutoplay
					})), l.a.createElement("div", {
						className: j.a.VideoResolutionContainer,
						role: "radiogroup"
					}, z.map((e, t) => a.includes(e) ? l.a.createElement(J, {
						key: t,
						resolution: e,
						onClick: () => this.setResolution(e),
						isChecked: o === e
					}) : null)))
				}
			}
			var q = s("./src/reddit/components/HTML5StreamPlayer/Tooltip/index.tsx"),
				X = s("./src/reddit/icons/svgs/VideoSetting/index.tsx"),
				$ = s("./src/reddit/components/HTML5StreamPlayer/ControlBar/index.m.less"),
				ee = s.n($);
			const te = A.a.wrapped(q.a, "TooltipControl", ee.a),
				se = A.a.wrapped(te, "ControlSetting", ee.a);
			class ie extends r.Component {
				render() {
					const {
						autoplayPref: e,
						bitrateInfo: t,
						isLoggedIn: s,
						resolution: i,
						setAutoplay: o,
						setResolution: a,
						settingChange: n,
						settingRef: r,
						toggleSetting: d
					} = this.props;
					return l.a.createElement(se, {
						key: "setting",
						className: ee.a.AnimatedSettingIconParent,
						tooltip: O.fbt._("Settings", null, {
							hk: "1AhVBJ"
						}),
						disable: n === ke.Settings
					}, n === ke.Settings && l.a.createElement(Z, {
						className: ee.a.VideoSettingContainer,
						isLoggedIn: s,
						autoplayPref: e,
						active: n === ke.Settings,
						ref: e => r(e),
						resolution: i,
						setResolution: a,
						setAutoplay: o,
						bitrateInfo: t
					}), l.a.createElement("button", {
						"aria-expanded": n === ke.Settings,
						"aria-haspopup": !0,
						"aria-label": O.fbt._("Settings", null, {
							hk: "4jfIa6"
						}),
						className: ee.a.button,
						onClick: d
					}, l.a.createElement(X.a, {
						className: ee.a.SettingIcon
					})))
				}
			}
			var oe = s("./src/reddit/controls/OutboundLink/styled.tsx"),
				ae = s("./src/reddit/selectors/telemetry.ts"),
				ne = s("./src/reddit/icons/svgs/VideoApplyNow/index.tsx"),
				re = s("./src/reddit/icons/svgs/VideoContactUs/index.tsx"),
				le = s("./src/reddit/icons/svgs/VideoGetAQuote/index.tsx"),
				de = s("./src/reddit/icons/svgs/VideoGetShowtimes/index.tsx"),
				ce = s("./src/reddit/icons/svgs/VideoInstall/index.tsx"),
				he = s("./src/reddit/icons/svgs/VideoLearnMore/index.tsx"),
				ue = s("./src/reddit/icons/svgs/VideoPlayNow/index.tsx"),
				pe = s("./src/reddit/icons/svgs/VideoSeeMenu/index.tsx"),
				me = s("./src/reddit/icons/svgs/VideoShopNow/index.tsx"),
				ge = s("./src/reddit/icons/svgs/VideoSignUp/index.tsx"),
				ve = s("./src/reddit/icons/svgs/VideoViewMore/index.tsx"),
				ye = s("./src/reddit/icons/svgs/VideoWatchNow/index.tsx"),
				fe = s("./src/reddit/components/VideoCTA/index.m.less"),
				Se = s.n(fe);
			const Pe = {
				"Apply Now": l.a.createElement(ne.a, null),
				"Contact Us": l.a.createElement(re.a, null),
				"Learn More": l.a.createElement(he.a, null),
				"Get a Quote": l.a.createElement(le.a, null),
				"Get Showtimes": l.a.createElement(de.a, null),
				Install: l.a.createElement(ce.a, null),
				Download: l.a.createElement(ce.a, null),
				"Learn More": l.a.createElement(he.a, null),
				"Play Now": l.a.createElement(ue.a, null),
				"See Menu": l.a.createElement(pe.a, null),
				"Shop Now": l.a.createElement(me.a, null),
				"Sign Up": l.a.createElement(ge.a, null),
				"View More": l.a.createElement(ve.a, null),
				"Watch Now": l.a.createElement(ye.a, null)
			};
			var be = Object(x.c)(e => {
					const {
						callToAction: t,
						postId: s,
						sendEvent: i,
						source: o
					} = e;
					return l.a.createElement(oe.a, {
						className: Se.a.ctaLink,
						onClick: e => i(e => ({
							...Object(ae.defaults)(e),
							source: "videoplayer",
							action: "click",
							noun: "callToAction"
						})),
						href: o.url,
						isSponsored: !0,
						postId: s,
						source: o
					}, l.a.createElement("div", {
						className: Se.a.ctaWrapper
					}, (e => Pe[e = e || "Learn More"])(t), l.a.createElement("span", {
						className: Se.a.ctaText
					}, t || "Learn More")))
				}),
				Ce = s("./src/reddit/icons/svgs/VideoReplay/index.tsx"),
				Te = s("./src/reddit/components/HTML5StreamPlayer/ReplayVideo/index.m.less"),
				xe = s.n(Te);
			const Ee = A.a.div("Centered", xe.a),
				Ve = A.a.div("EndedOverlay", xe.a),
				Me = A.a.span("ReplayText", xe.a),
				Le = A.a.button("ReplayButton", xe.a);
			var _e = e => {
					const {
						onClick: t,
						source: s,
						callToAction: i,
						postId: o
					} = e;
					return l.a.createElement(Ve, {
						onClick: t
					}, l.a.createElement(Ee, null, l.a.createElement(Le, null, l.a.createElement(Ce.a, null), l.a.createElement(Me, {
						className: "replay-video"
					}, O.fbt._("Replay Video", null, {
						hk: "1iD2Wj"
					}))), s && i && l.a.createElement(be, {
						callToAction: i,
						postId: o,
						source: s
					})))
				},
				Be = s("./src/reddit/components/HTML5StreamPlayer/VideoContainer/index.m.less"),
				we = s.n(Be);

			function Re() {
				return (Re = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var s = arguments[t];
						for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (e[i] = s[i])
					}
					return e
				}).apply(this, arguments)
			}
			var ke, Fe = ({
					className: e,
					isVisible: t,
					setRef: s,
					...i
				}) => l.a.createElement("div", Re({
					className: Object(h.a)(we.a.Component, e, {
						[we.a.mIsNotVisible]: !t
					}),
					ref: s
				}, i)),
				Ie = s("./src/reddit/components/HTML5StreamPlayer/VideoOverlay/index.m.less"),
				Ae = s.n(Ie),
				De = A.a.div("Component", Ae.a),
				He = s("./src/reddit/components/HTML5StreamPlayer/index.m.less"),
				Oe = s.n(He);
			! function(e) {
				e[e.SeekBar = 0] = "SeekBar", e[e.Settings = 1] = "Settings", e[e.Volume = 2] = "Volume"
			}(ke || (ke = {}));
			const Ne = 3e3,
				Ue = 6e3,
				je = 100,
				We = Object(d.b)(() => Object(c.c)({
					isLoggedIn: R.K,
					autoplayPref: R.b,
					currentTime: k.c,
					currentUser: R.k,
					isOverlayOpen: B.i,
					loadTimes: k.f,
					metadata: k.h,
					mutedInFeed: k.i,
					postUrl: w.J,
					started: k.k,
					volume: _.d
				}), (e, {
					postId: t
				}) => ({
					exitVideoFullscreen: () => e(b.t()),
					onLoadStarted: s => {
						t && e(b.q(t, s))
					},
					onMetadataReceived: t => e(b.D({
						metadata: t,
						postId: t.id
					})),
					onPlayable: s => {
						t && e(b.A(t, s))
					},
					onUpdateVideoTime: n()(s => {
						t && e(b.I({
							postId: t,
							time: s
						}))
					}, E.l, {
						maxWait: E.m
					}),
					openLightbox: s => {
						s ? e(Object(M.a)(s)) : f.c.withScope(e => {
							e.setExtra("info", {
								postId: t,
								postUrl: s
							}), f.c.captureMessage("Post lightbox cannot be opened with a falsy postUrl")
						})
					},
					setPlaying: s => {
						t && e(b.H({
							postId: t,
							isPlaying: s
						}))
					},
					setAutoplayPref: t => e(P.t(t)),
					setVideoFullscreen: () => {
						t && e(b.F(t))
					},
					setVideoMuted: (s, i) => e(S.g(s, i, t)),
					setVideoVolume: t => e(S.h(t)),
					onWatchedPercent: s => {
						t && e(b.N(s, t))
					},
					onWatchedSeconds: s => {
						t && e(b.O(s, t))
					},
					onUpdateContinuousViewStartTime: s => {
						t && e(b.K(t, s))
					},
					onVideoStarted: () => {
						t && e(b.M(t))
					},
					onVideoReset: () => {
						t && e(b.L(t))
					},
					setMutedInFeed: t => e(b.G(t))
				}));
			class Ge extends r.Component {
				constructor(e) {
					super(e), this.isSeekingWithRetry = !1, this.percentagePixelsFired = {
						[E.b]: !1,
						[E.c]: !1,
						[E.d]: !1,
						[E.e]: !1,
						[E.a]: !1
					}, this.timePixelsFired = {
						[E.g]: !1,
						[E.h]: !1,
						[E.f]: !1
					}, this.sendEvent = (e, t, s = !1) => {
						if (this.HTML5StreamPlayerVideo && null != this.props.postId) {
							const i = s ? L.b(this.props.postId, e, t) : L.a(this.props.postId, e, t);
							this.props.sendEvent(i)
						}
					}, this.resetMediaPlayer = () => {
						const e = this.HTML5StreamPlayerVideo,
							t = this.props.mpegDashSource;
						if (!e || !t) return;
						const {
							currentTime: s
						} = e;
						this.setState({
							isRecovering: !0
						}), e.addEventListener("loadedmetadata", async () => {
							e.currentTime = s, await e.play(), this.setState({
								isRecovering: !1
							})
						}, {
							once: !0
						}), this.dashPlayer.attachSource(t)
					}, this.getVideoQualityList = () => {
						if (this.dashPlayer) {
							const e = this.dashPlayer.getBitrateInfoListFor("video");
							this.setState({
								bitrateInfo: e
							})
						}
					}, this.getAudioInfo = () => {
						if (this.props.isGif) this.setState({
							hasAudio: !1
						});
						else if (this.dashPlayer) {
							const e = this.dashPlayer.getActiveStream(),
								t = !!e && e.getHasAudioTrack();
							this.setState({
								hasAudio: t
							})
						}
					}, this.handleKeyDown = e => {
						this.updateUsingKeyStatus(e)
					}, this.handleKeyUp = e => {
						this.updateUsingKeyStatus(e)
					}, this.handleMouseEnter = e => {
						const t = this.HTML5StreamPlayerVideo;
						t && this.controlBarApi && this.controlBarApi.setCurrentTime(t.currentTime), this.resetControlBarFadeTimer()
					}, this.handleMouseDown = e => {
						e.stopPropagation();
						const {
							seekBar: t,
							volumeControl: s
						} = this;
						s && s.container && s.container.contains(e.target) ? (this.setState({
							settingChange: ke.Volume
						}), s.handleMouseDown(e)) : t && t.parentRect && t.parentRect.contains(e.target) && (this.setState({
							settingChange: ke.SeekBar
						}), t.handleMouseDown(e)), this.state.usingKeys && this.setState({
							usingKeys: !1
						})
					}, this.handleMouseMove = e => {
						const {
							controlBar: t,
							seekBar: s,
							volumeControl: i
						} = this;
						switch (this.setState({
							hasHovered: !0
						}), t && t.contains(e.target) ? this.clearControlBarFadeTimer() : this.resetControlBarFadeTimer(), this.state.settingChange) {
							case ke.SeekBar:
								s && s.handleMouseMove(e);
								break;
							case ke.Volume:
								i && i.handleMouseMove(e);
								break;
							case ke.Settings:
						}
					}, this.handleMouseUp = e => {
						e.stopPropagation();
						const {
							controlBar: t,
							seekBar: s,
							volumeControl: i
						} = this;
						switch (this.state.settingChange) {
							case ke.SeekBar:
								if (s) {
									this.setState({
										ignoreUnderrunsUntil: Date.now() + je
									}), s.handleMouseUp(e), this.sendEvent("click", "seek");
									const t = this.HTML5StreamPlayerVideo;
									this.state.videoEnded && t && t.currentTime !== t.duration && this.playVideo()
								}
								break;
							case ke.Volume:
								i && (i.handleMouseUp(e), this.sendEvent("click", "volume"));
								break;
							case ke.Settings:
								if (t && t.contains(e.target)) return;
								break;
							default:
								if (t && !t.contains(e.target)) {
									const {
										playerClickPlay: t = !0
									} = this.props;
									if (this.props.trackPostClick && this.props.trackPostClick("media")(), this.resetControlBarFadeTimer(), this.state.videoEnded) return;
									if (this.props.isGif && this.props.isListing && !this.state.videoPaused) {
										if (this.props.isSponsored && this.props.onAdPostClick) return void this.props.onAdPostClick(e);
										this.props.openLightbox(this.props.postUrl)
									} else !t && this.state.videoPaused || this.playPauseVideo(e)
								}
						}
						this.setState({
							settingChange: void 0
						})
					}, this.handleMouseLeave = e => {
						switch (this.clearControlBarFadeTimer(), this.setState({
							hideControlBar: !0
						}), this.state.settingChange) {
							case ke.SeekBar:
							case ke.Volume:
							case ke.Settings:
							default:
								this.setState({
									settingChange: void 0
								})
						}
					}, this.handleClick = e => {
						e.stopPropagation()
					}, this.setContainerRef = e => this.HTML5StreamPlayerContainer = e, this.setControlBarRef = e => this.controlBar = e, this.setControlBarApi = e => this.controlBarApi = e, this.setVolumeRef = e => this.volumeControl = e, this.setSeekBarRef = e => this.seekBar = e, this.setSettingRef = e => this.settingControl = e, this.onCanPlay = () => {
						if (this.HTML5StreamPlayerVideo && !this.state.videoLoaded) {
							if (this.setState({
									videoLoaded: !0,
									videoWaiting: !1
								}), this.props.playFromStart) return this.setVideoPos(0), void(this.isUnobscured() && this.playVideo());
							this.autoplay() && this.playVideo()
						}
					}, this.clearControlBarFadeTimer = () => {
						const {
							controlBarFadeTimer: e
						} = this;
						e && clearTimeout(e)
					}, this.resetControlBarFadeTimer = (e = Ne) => {
						this.clearControlBarFadeTimer(), this.setState({
							hideControlBar: !1
						}), this.controlBarFadeTimer = window.setTimeout(() => {
							this.setState({
								hideControlBar: !0
							})
						}, e)
					}, this.exitHandler = () => {
						this.state.videoFullScreen && !Object(m.b)() && this.exitFullScreen()
					}, this.playPauseVideo = e => {
						const t = this.HTML5StreamPlayerVideo;
						t && (t.paused && this.state.videoPaused ? (this.playVideo(), this.sendEvent("click", "play"), this.setState({
							videoManualPaused: !1
						})) : (this.pauseVideo(), this.sendEvent("click", "pause"), this.setState({
							videoManualPaused: !0
						})))
					}, this.playVideo = async () => {
						const e = this.HTML5StreamPlayerVideo;
						if (e) try {
							this.setVideoMute(this.state.isMuted, !1), await e.play(), e.currentTime < 1 && this.props.onVideoStarted(), this.setState({
								videoEnded: !1
							})
						} catch (t) {}
					}, this.pauseVideo = () => {
						const e = this.HTML5StreamPlayerVideo;
						e && e.pause()
					}, this.resetVideo = e => {
						this.isUnobscured && this.state.videoEnded && (this.resetVideoWithRetry(), this.sendEvent("click", "replay"), this.setState({
							ignoreUnderrunsUntil: Date.now() + je,
							videoEnded: !1,
							videoManualPaused: !1
						}), this.props.onVideoReset())
					}, this.exitFullScreen = () => {
						document.exitFullScreen ? document.exitFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen(), this.setState({
							videoFullScreen: !1
						}), null != this.props.postId && (this.sendEvent("change", "pagetype", !0), this.props.exitVideoFullscreen())
					}, this.enterFullScreen = () => {
						const e = this.HTML5StreamPlayerContainer;
						e && (e.requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.mozRequestFullScreen && e.mozRequestFullScreen()), this.setState({
							videoFullScreen: !0
						}), this.sendEvent("click", "fullscreen"), null != this.props.postId && (this.sendEvent("change", "pagetype", !0), this.props.setVideoFullscreen())
					}, this.setVolume = (e, t) => {
						const s = this.HTML5StreamPlayerVideo;
						s && (s.volume = e);
						const i = !e,
							o = this.state.isMuted !== i,
							a = this.state.volume !== e;
						t ? (e && (a && this.setState({
							volume: e
						}), this.props.setVideoVolume(e)), this.props.setMutedInFeed(i)) : o && this.setState({
							isMuted: i
						})
					}, this.toggleMuteVideo = e => {
						e.stopPropagation();
						const t = !this.state.isMuted;
						this.setVideoMute(t, !0);
						const s = t ? "mute" : "unmute";
						this.sendEvent("click", s)
					}, this.setVideoMute = (e, t) => {
						const s = this.HTML5StreamPlayerVideo;
						s && (e || (s.volume = this.state.volume), s.muted = e), this.setState({
							isMuted: e
						}), this.props.setVideoMuted(e, t), this.props.setMutedInFeed(e)
					}, this.clickSnoo = e => {
						this.state.videoFullScreen && this.exitFullScreen(), this.sendEvent("click", "snoo")
					}, this.setAutoplay = e => {
						this.props.setAutoplayPref(e), e ? this.sendEvent("click", "video_autoplay_on") : this.sendEvent("click", "video_autoplay_off")
					}, this.setResolution = e => {
						const {
							bitrateInfo: t
						} = this.state;
						if (t && this.dashPlayer) {
							if (e === G) this.dashPlayer.updateSettings({
								streaming: {
									abr: {
										autoSwitchBitrate: {
											video: !0
										}
									}
								}
							});
							else {
								const s = t.findIndex(t => t.height === e);
								this.dashPlayer.updateSettings({
									streaming: {
										abr: {
											autoSwitchBitrate: {
												video: !1
											}
										}
									}
								}), this.dashPlayer.setQualityFor("video", s)
							}
							this.setState({
								resolution: e
							})
						}
					}, this.toggleSetting = e => {
						this.state.settingChange === ke.Settings ? this.setState({
							settingChange: void 0
						}) : this.setState({
							settingChange: ke.Settings
						})
					}, this.setVideoPos = e => {
						const t = this.HTML5StreamPlayerVideo;
						t && (this.controlBarApi && !this.state.hideControlBar && this.controlBarApi.setCurrentTime(e), t.currentTime = e)
					}, this.updateTime = () => {
						const e = performance.now(),
							t = this.HTML5StreamPlayerVideo;
						if (t) {
							let s = this.state.maxTimeServed;
							if (this.state.lastUpdate && !this.state.videoPaused && (s += e - this.state.lastUpdate), t.currentTime && t.duration) {
								let i = !1;
								this.triggerAdWatchedPixels(t.currentTime, t.duration, s / 1e3), t.currentTime >= t.duration && (this.props.isGif || (i = !0, this.pauseVideo())), this.controlBarApi && !this.state.hideControlBar && this.controlBarApi.setCurrentTime(t.currentTime), this.setState({
									videoEnded: i,
									maxTimeServed: s,
									lastUpdate: e
								})
							}
							if (this.props.postId) {
								const e = {
									currentTime: 1e3 * t.currentTime,
									maxTimeServed: s
								};
								this.props.onUpdateVideoTime(e)
							}
						}
					}, this.triggerAdWatchedPixels = (e, t, s) => {
						const i = this.getWatchedPercentRange(e, t);
						this.triggerPercentagePixels(i);
						s / t >= .95 && this.triggerTimeWatchedPixels(E.f), this.triggerTimeWatchedPixels(s)
					}, this.updateContinuousStartTime = e => {
						this.props.onUpdateContinuousViewStartTime(e)
					}, this.onVideoPlayable = e => {
						this.props.metadata || this.sendTransformedMetadata(e)
					}, this.onPlay = e => {
						const t = performance.now();
						this.setState({
							videoPaused: !1,
							lastUpdate: t
						}), this.props.setPlaying(!0)
					}, this.onPause = e => {
						this.setState({
							videoPaused: !0
						}), this.props.setPlaying(!1)
					}, this.onPlaying = e => {
						this.props.metadata || this.sendTransformedMetadata(e), this.setState({
							videoWaiting: !1
						})
					}, this.sendTransformedMetadata = e => {
						null != this.props.postId && this.props.onMetadataReceived({
							id: this.props.postId,
							length: 1e3 * e.target.duration,
							originalHeight: e.target.videoHeight,
							originalWidth: e.target.videoWidth
						}), this.setState({
							totalTime: e.target.duration
						})
					}, this.videoRef = e => {
						this.HTML5StreamPlayerVideo = e, this.HTML5StreamPlayerVideo && (this.HTML5StreamPlayerVideo.volume = this.state.volume)
					}, Ge.dashjs || (Ge.dashjs = Object(y.a)(() => s.e("vendors~dashjs").then(s.t.bind(null, "./node_modules/dashjs/build/es5/index.js", 7))));
					const t = !!e.isListing && e.mutedInFeed;
					this.state = {
						bitrateInfo: [],
						hasAudio: !1,
						hasHovered: !1,
						hideControlBar: !0,
						isMuted: t,
						isRecovering: !1,
						lastUpdate: null,
						ignoreUnderrunsUntil: 0,
						maxTimeServed: 0,
						resolution: G,
						scrubPosition: 0,
						settingChange: void 0,
						settingSeekBar: !1,
						settingVolume: !1,
						thumbPosition: 0,
						totalTime: 0,
						videoEnded: !1,
						videoFullScreen: !1,
						videoInView: !1,
						videoLoaded: !1,
						videoManualPaused: !1,
						videoPaused: !e.autoPlay,
						videoScrollPaused: !0,
						videoWaiting: !0,
						volume: e.volume,
						usingKeys: !1
					}, this.combinedVideoRefs = this.combineExternalVideoRef(e.videoRef)
				}
				autoplayPref(e = this.props) {
					return e.autoplayPref || e.isOverlay || e.isExpando || !!e.shouldIgnoreAutoplayPref
				}
				shouldAutoplay(e = this.props) {
					return !!e.autoPlay && this.autoplayPref(e)
				}
				isUnobscured(e = this.props) {
					return !e.isListing || e.isOverlay || !e.isOverlayOpen
				}
				isInViewport(e = this.props, t = this.state) {
					return !e.isListing || e.isOverlay || !!e.isExpando || !t.videoScrollPaused
				}
				autoplay(e = this.props, t = this.state) {
					return this.shouldAutoplay(e) && this.isUnobscured(e) && this.isInViewport(e, t)
				}
				componentDidMount() {
					Ge.dashjs.then(e => {
						var t, s;
						const i = this.HTML5StreamPlayerVideo,
							o = this.props.mpegDashSource;
						if (i && o) {
							this.dashPlayer = e.MediaPlayer().create();
							try {
								this.dashPlayer.initialize(i, o, i.autoplay || !i.paused), this.setBufferTime(E.i), this.dashPlayer.updateSettings({
									streaming: {
										fastSwitchEnabled: !0,
										abr: {
											initialBitrate: {
												video: 999999999
											},
											autoSwitchBitrate: {
												video: !0
											}
										}
									}
								})
							} catch (a) {
								return
							}
							null != this.props.postId && this.props.onLoadStarted(performance.now()), this.dashPlayer.on(e.MediaPlayer.events.STREAM_INITIALIZED, () => {
								this.getVideoQualityList(), this.getAudioInfo(), null != this.props.postId && this.props.onPlayable(performance.now()), this.controlBarApi && !this.state.hideControlBar && this.controlBarApi.setCurrentTime(0)
							}), this.dashPlayer.on(e.MediaPlayer.events.BUFFER_EMPTY, e => {
								if (null != this.props.postId && Date.now() > this.state.ignoreUnderrunsUntil) {
									const e = L.c(this.props.postId);
									this.props.sendEvent(e), this.setState({
										ignoreUnderrunsUntil: Date.now() + je
									})
								}
							}), i.addEventListener("error", this.resetMediaPlayer), null === (s = (t = this.props).onDashCreate) || void 0 === s || s.call(t, this.dashPlayer)
						}
					});
					const e = this.HTML5StreamPlayerVideo;
					document.addEventListener("webkitfullscreenchange", this.exitHandler, !1), document.addEventListener("fullscreenchange", this.exitHandler, !1), document.addEventListener("mozfullscreenchange", this.exitHandler, !1), document.addEventListener("MSFullscreenChange", this.exitHandler, !1), e && (v() ? e.play() : o.a.safari && !this.props.mpegDashSource && setTimeout(async () => {
						try {
							await e.play()
						} catch (t) {} finally {
							e.pause()
						}
					}), e.oncanplay = () => this.onCanPlay(), e.onprogress = () => this.setBuffered(), e.onseeked = () => this.setState({
						videoWaiting: !1
					}), e.onwaiting = () => this.setState({
						videoWaiting: !0
					}), e.onplaying = e => this.onPlaying(e), e.onplay = e => this.onPlay(e), e.onpause = e => this.onPause(e), e.onloadeddata = e => this.onVideoPlayable(e), e.onloadedmetadata = e => this.sendTransformedMetadata(e), this.props.currentTime && (e.currentTime = this.props.currentTime))
				}
				componentDidUpdate(e) {
					const {
						isListing: t,
						mutedInFeed: s,
						videoRef: i,
						volume: o
					} = this.props;
					i !== e.videoRef && (this.combinedVideoRefs = this.combineExternalVideoRef(i)), t && this.state.videoPaused && (s !== e.mutedInFeed && s !== this.state.isMuted && this.setState({
						isMuted: s
					}), o !== e.volume && (this.HTML5StreamPlayerVideo && (this.HTML5StreamPlayerVideo.volume = o), o !== this.state.volume && this.setState({
						volume: o
					}))), t || s === this.state.isMuted || this.setState({
						isMuted: s
					})
				}
				async destroyMediaPlayer() {
					var e, t;
					this.dashPlayer && (await (null === (t = (e = this.props).onDashDestroy) || void 0 === t ? void 0 : t.call(e, this.dashPlayer)), this.dashPlayer.destroy(), this.dashPlayer = null)
				}
				componentWillUnmount() {
					document.removeEventListener("webkitfullscreenchange", this.exitHandler, !1), document.removeEventListener("fullscreenchange", this.exitHandler, !1), document.removeEventListener("mozfullscreenchange", this.exitHandler, !1), document.removeEventListener("MSFullscreenChange", this.exitHandler, !1), this.destroyMediaPlayer(), this.clearControlBarFadeTimer(), null == this.props.postId || this.state.videoScrollPaused || this.sendEvent("served", "video", !0)
				}
				shouldComponentUpdate(e, t) {
					const s = !!this.props.isListing && !this.props.isOverlayOpen && e.isOverlayOpen,
						i = !!this.props.isListing && this.props.isOverlayOpen && !e.isOverlayOpen,
						o = this.props.isOverlayOpen !== e.isOverlayOpen,
						a = !!this.props.isListing && e.mutedInFeed !== this.props.mutedInFeed,
						n = e.volume !== this.props.volume;
					return t.videoFullScreen !== this.state.videoFullScreen || t.videoPaused !== this.state.videoPaused || t.isMuted !== this.state.isMuted || t.hideControlBar !== this.state.hideControlBar || t.settingChange !== this.state.settingChange || t.videoScrollPaused !== this.state.videoScrollPaused || t.videoWaiting !== this.state.videoWaiting || t.isRecovering !== this.state.isRecovering || e.shouldPause !== this.props.shouldPause || e.shouldStop !== this.props.shouldStop || t.videoLoaded !== this.state.videoLoaded || t.usingKeys !== this.state.usingKeys || t.resolution !== this.state.resolution || s || i || o || a || n
				}
				UNSAFE_componentWillReceiveProps(e, t) {
					const s = this.HTML5StreamPlayerVideo,
						i = s && !s.paused,
						o = !e.shouldStop && this.props.shouldStop,
						a = e.shouldStop && !this.props.shouldStop,
						n = !e.shouldPause && this.props.shouldPause,
						r = e.shouldPause && !this.props.shouldPause,
						l = !this.props.shouldPause && !this.props.shouldStop,
						d = !e.isOverlay && !this.props.isOverlay,
						c = e.isOverlayOpen && !this.props.isOverlayOpen,
						h = !e.isOverlayOpen && this.props.isOverlayOpen,
						u = (l || i) && d && c,
						p = l && d && h;
					if (o && (this.setState({
							videoScrollPaused: !1
						}), this.sendEvent("view", "autoplay")), (n || p) && (!this.state.videoManualPaused && s && s.currentTime < s.duration && (e.currentTime && (s.currentTime = e.currentTime), this.autoplay(e, t) && this.playVideo()), p && this.sendEvent("change", "pagetype", !0)), (r || u) && (this.pauseVideo(), u && this.sendEvent("change", "pagetype", !0)), a && (this.pauseVideo(), this.setState({
							videoScrollPaused: !0
						}), this.sendEvent("served", "video", !0), this.state.videoEnded || (this.sendEvent("scroll", "pause"), this.props.isListing || this.setVideoMute(!0, !1))), e.mpegDashSource && this.props.mpegDashSource !== e.mpegDashSource) {
						const {
							dashPlayer: s
						} = this;
						try {
							s.setAutoPlay(this.autoplay(e, t)), s.attachSource(this.props.mpegDashSource)
						} catch (m) {}
					}
				}
				updateUsingKeyStatus(e) {
					if (0 !== e.location) return;
					this.state.usingKeys || this.setState({
						usingKeys: !0
					});
					let t = Ue;
					this.state.settingChange === ke.Settings && (t = 5 * Ue), this.resetControlBarFadeTimer(t)
				}
				setBuffered() {
					const e = this.HTML5StreamPlayerVideo;
					if (e && this.controlBarApi) {
						const t = [];
						for (let s = 0; s < e.buffered.length; s++) {
							const i = {
								start: e.buffered.start(s) / e.duration * 100,
								end: e.buffered.end(s) / e.duration * 100
							};
							t.push(i)
						}
						this.controlBarApi.setBufferedRanges(t)
					}
				}
				resetVideoWithRetry() {
					const e = this.HTML5StreamPlayerVideo;
					if (this.isSeekingWithRetry || !e) return;
					this.isSeekingWithRetry = !0;
					let t = 0,
						s = 0;
					const i = () => {
							this.isSeekingWithRetry = !1, window.clearInterval(o), e.removeEventListener("seeked", i)
						},
						o = window.setInterval(() => {
							!e || e.paused || s !== e.currentTime || t > 5 ? i() : (s = .016 * Math.pow(2, t), e.currentTime = s, t++)
						}, 100);
					e.addEventListener("seeked", i, {
						once: !0
					}), this.setVideoPos(s), this.playVideo()
				}
				setBufferTime(e) {
					this.dashPlayer && this.dashPlayer.updateSettings({
						streaming: {
							bufferTimeAtTopQuality: e,
							bufferTimeAtTopQualityLongForm: e,
							stableBufferTime: e
						}
					})
				}
				getWatchedPercentRange(e, t) {
					const s = e / t;
					return s >= 1 ? E.a : s >= .95 ? E.e : s >= .75 ? E.d : s >= .5 ? E.c : s >= .25 ? E.b : 0
				}
				triggerPercentagePixels(e) {
					E.j.forEach(t => {
						t <= e && !this.percentagePixelsFired[t] && (this.props.onWatchedPercent(t), this.percentagePixelsFired[t] = !0)
					})
				}
				triggerTimeWatchedPixels(e) {
					E.k.forEach(t => {
						t <= e && !this.timePixelsFired[t] && (this.props.onWatchedSeconds(t), this.timePixelsFired[t] = !0)
					})
				}
				combineExternalVideoRef(e) {
					return e ? Object(p.a)(this.videoRef, e) : this.videoRef
				}
				render() {
					const {
						className: e,
						hideUntilLoaded: t,
						playerClickPlay: s = !0,
						showControlBar: i = !0,
						showSettingsIcon: o = !0
					} = this.props, {
						hasAudio: a,
						hasHovered: n,
						hideControlBar: r,
						isMuted: d,
						isRecovering: c,
						settingChange: p,
						videoEnded: m,
						videoLoaded: g
					} = this.state, v = this.HTML5StreamPlayerVideo, y = p === ke.SeekBar, f = g || !t, S = f && v && 0 !== v.currentTime, P = !n && d, b = m && !y, x = {
						...this.props,
						bitrateInfo: this.state.bitrateInfo,
						resolution: this.state.resolution,
						setAutoplay: this.setAutoplay,
						setResolution: this.setResolution,
						settingChange: p,
						settingRef: this.setSettingRef,
						toggleSetting: this.toggleSetting
					};
					return l.a.createElement(Fe, {
						setRef: this.setContainerRef,
						className: Object(h.a)(e, this.state.videoFullScreen ? Oe.a.RedditVideoPlayerRoot__Fullscreen : Oe.a.RedditVideoPlayerRoot, this.state.usingKeys ? "using-keys" : null),
						isVisible: f,
						onClick: this.handleClick,
						onKeyDown: this.handleKeyDown,
						onKeyUp: this.handleKeyUp,
						onMouseDown: this.handleMouseDown,
						onMouseEnter: this.handleMouseEnter,
						onMouseLeave: this.handleMouseLeave,
						onMouseMove: this.handleMouseMove,
						onMouseUp: this.handleMouseUp
					}, this.props.blurImageSrc && l.a.createElement(D, {
						src: this.props.blurImageSrc
					}), l.a.createElement("video", {
						style: {
							backgroundImage: c || v && 0 !== v.currentTime ? "" : `url(${this.props.posterUrl})`,
							backgroundColor: u.b
						},
						poster: this.props.posterUrl,
						loop: this.props.isGif,
						muted: d,
						onTimeUpdate: this.updateTime,
						preload: "metadata",
						ref: this.combinedVideoRefs,
						className: this.state.videoFullScreen ? Oe.a.HTML5StreamPlayer__VideoFullscreen : Oe.a.HTML5StreamPlayer__VideoRegular
					}, this.props.hlsSource && l.a.createElement("source", {
						src: this.props.hlsSource,
						type: "application/vnd.apple.mpegURL"
					}), this.props.otherSource && l.a.createElement("source", {
						src: this.props.otherSource
					})), b ? l.a.createElement(_e, {
						onClick: this.resetVideo,
						postId: this.props.postId,
						source: this.props.callToActionSource,
						callToAction: this.props.callToActionText
					}) : l.a.createElement(De, null), c ? l.a.createElement(C.a, null) : this.state.videoWaiting ? S && l.a.createElement(C.a, null) : this.state.videoPaused && !b && l.a.createElement(T.a, {
						onClick: s ? void 0 : this.playPauseVideo
					}), i && l.a.createElement(H.b, {
						clickSnoo: this.clickSnoo,
						controlBarRef: this.setControlBarRef,
						currentTime: v ? v.currentTime : 0,
						hasAudio: a,
						updateContinuousStartTime: this.updateContinuousStartTime,
						enterFullScreen: this.enterFullScreen,
						exitFullScreen: this.exitFullScreen,
						hideControlBar: r,
						isFullScreen: this.state.videoFullScreen,
						isListing: this.props.isListing,
						isMuted: this.state.isMuted,
						isPaused: this.state.videoPaused,
						playPauseVideo: this.playPauseVideo,
						postUrl: this.props.postUrl,
						ref: this.setControlBarApi,
						settingsButton: l.a.createElement(ie, x),
						scrubberThumbSource: this.props.scrubberThumbSource,
						seekBarRef: this.setSeekBarRef,
						settingChange: p,
						setVideoPosition: this.setVideoPos,
						setVolume: this.setVolume,
						showSettingsIcon: o,
						showVolumeIcon: P,
						toggleMute: this.toggleMuteVideo,
						totalTime: this.state.totalTime,
						volume: this.state.volume,
						volumeRef: this.setVolumeRef
					}))
				}
			}
			t.b = We(Object(x.c)(Object(V.b)(Ge)))
		},
		"./src/reddit/components/Media/LoadingIcon/index.m.less": function(e, t, s) {
			e.exports = {
				image: "_1Wd26c2ichqUxeZVJStEJT"
			}
		},
		"./src/reddit/components/Media/LoadingIcon/index.tsx": function(e, t, s) {
			"use strict";
			var i = s("./node_modules/react/index.js"),
				o = s.n(i),
				a = s("./src/config.ts"),
				n = s("./src/reddit/components/Media/LoadingIcon/index.m.less"),
				r = s.n(n);
			t.a = () => o.a.createElement("img", {
				className: r.a.image,
				src: `${a.a.assetPath}/img/loading.gif`
			})
		},
		"./src/reddit/components/PlayButton/index.m.less": function(e, t, s) {
			e.exports = {
				PlayIcon: "_2XQ3ZY6qCbEm9_WtvLLFru",
				playIcon: "_2XQ3ZY6qCbEm9_WtvLLFru",
				PlayContainer: "vLH0XV-l8Y4mNGUvw4HHy",
				playContainer: "vLH0XV-l8Y4mNGUvw4HHy"
			}
		},
		"./src/reddit/components/PlayButton/index.tsx": function(e, t, s) {
			"use strict";
			var i = s("./node_modules/react/index.js"),
				o = s.n(i),
				a = s("./src/lib/lessComponent.tsx"),
				n = s("./src/reddit/icons/svgs/VideoNewPlayButton/index.tsx"),
				r = s("./src/reddit/components/PlayButton/index.m.less"),
				l = s.n(r);
			const d = a.a.wrapped(n.a, "PlayIcon", l.a),
				c = a.a.div("PlayContainer", l.a);
			t.a = e => o.a.createElement(c, {
				className: e.className,
				onClick: e.onClick
			}, o.a.createElement(d, {
				className: e.playIconClassName
			}))
		},
		"./src/reddit/components/VideoCTA/index.m.less": function(e, t, s) {
			e.exports = {
				ctaLink: "_2FH_xFiDZCFtYKBJAmSpeD",
				ctaText: "_3uyGw8SwblJ37jvDUd-0Z_",
				ctaWrapper: "_267SSeon8aryjeoh4UclX8"
			}
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/CollectionCommentsPage~CommentsPage~FramedGild~GildModal~GovernanceReleaseNotesModal~MembershipPaywa~c24a8af4.b4161b6dcdee7d8dabb0.js.map